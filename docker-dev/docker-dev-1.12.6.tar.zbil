ta will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is compressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<bzip2> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the compressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
compressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
compressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
compressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the compressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<bzip2> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple files/buffers and
C<$output_filename_or_reference> is a single
file/buffer the input files/buffers will be stored
in C<$output_filename_or_reference> as a concatenated series of compressed data streams.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<bzip2>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<bzip2> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<bzip2> has
completed.

This parameter defaults to 0.

=item C<< BinModeIn => 0|1 >>

When reading from a file or filehandle, set C<binmode> before reading.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all compressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
compressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any compressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any compressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all compressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any compressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all compressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any compressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any compressed data is output.

Defaults to 0.

=back

=head2 Examples

To read the contents of the file C<file1.txt> and write the compressed
data to the file C<file1.txt.bz2>.

    use strict ;
    use warnings ;
    use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error) ;

    my $input = "file1.txt";
    bzip2 $input => "$input.bz2"
        or die "bzip2 failed: $Bzip2Error\n";

To read from an existing Perl filehandle, C<$input>, and write the
compressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt"
        or die "Cannot open 'file1.txt': $!\n" ;
    my $buffer ;
    bzip2 $input => \$buffer 
        or die "bzip2 failed: $Bzip2Error\n";

To compress all files in the directory "/my/home" that match "*.txt"
and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error) ;

    bzip2 '</my/home/*.txt>' => '<*.bz2>'
        or die "bzip2 failed: $Bzip2Error\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error) ;

    for my $input ( glob "/my/home/*.txt" )
    {
        my $output = "$input.bz2" ;
        bzip2 $input => $output 
            or die "Error compressing '$input': $Bzip2Error\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for C<IO::Compress::Bzip2> is shown below

    my $z = new IO::Compress::Bzip2 $output [,OPTS]
        or die "IO::Compress::Bzip2 failed: $Bzip2Error\n";

It returns an C<IO::Compress::Bzip2> object on success and undef on failure. 
The variable C<$Bzip2Error> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from 
IO::Compress::Bzip2 can be used exactly like an L<IO::File|IO::File> filehandle. 
This means that all normal output file operations can be carried out 
with C<$z>. 
For example, to write to a compressed file/buffer you can use either of 
these forms

    $z->print("hello world\n");
    print $z "hello world\n";

The mandatory parameter C<$output> is used to control the destination
of the compressed data. This parameter can take one of these forms.

=over 5

=item A filename

If the C<$output> parameter is a simple scalar, it is assumed to be a
filename. This file will be opened for writing and the compressed data
will be written to it.

=item A filehandle

If the C<$output> parameter is a filehandle, the compressed data will be
written to it.
The string '-' can be used as an alias for standard output.

=item A scalar reference 

If C<$output> is a scalar reference, the compressed data will be stored
in C<$$output>.

=back

If the C<$output> parameter is any other type, C<IO::Compress::Bzip2>::new will
return undef.

=head2 Constructor Options

C<OPTS> is any combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$output> parameter is a filehandle. If
specified, and the value is true, it will result in the C<$output> being
closed once either the C<close> method is called or the C<IO::Compress::Bzip2>
object is destroyed.

This parameter defaults to 0.

=item C<< Append => 0|1 >>

Opens C<$output> in append mode. 

The behaviour of this option is dependent on the type of C<$output>.

=over 5

=item * A Buffer

If C<$output> is a buffer and C<Append> is enabled, all compressed data
will be append to the end of C<$output>. Otherwise C<$output> will be
cleared before any data is written to it.

=item * A Filename

If C<$output> is a filename and C<Append> is enabled, the file will be
opened in append mode. Otherwise the contents of the file, if any, will be
truncated before any compressed data is written to it.

=item * A Filehandle

If C<$output> is a filehandle, the file pointer will be positioned to the
end of the file via a call to C<seek> before any compressed data is written
to it.  Otherwise the file pointer will not be moved.

=back

This parameter defaults to 0.

=item C<< BlockSize100K => number >>

Specify the number of 100K blocks bzip2 uses during compression. 

Valid values are from 1 to 9, where 9 is best compression.

The default is 1.

=item C<< WorkFactor => number >>

Specifies how much effort bzip2 should take before resorting to a slower
fallback compression algorithm.

Valid values range from 0 to 250, where 0 means use the default value 30.

The default is 0.

=item C<< Strict => 0|1 >>

This is a placeholder option.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 print

Usage is

    $z->print($data)
    print $z $data

Compresses and outputs the contents of the C<$data> parameter. This
has the same behaviour as the C<print> built-in.

Returns true if successful.

=head2 printf

Usage is

    $z->printf($format, $data)
    printf $z $format, $data

Compresses and outputs the contents of the C<$data> parameter.

Returns true if successful.

=head2 syswrite

Usage is

    $z->syswrite $data
    $z->syswrite $data, $length
    $z->syswrite $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 write

Usage is

    $z->write $data
    $z->write $data, $length
    $z->write $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 flush

Usage is

    $z->flush;

Flushes any pending compressed data to the output file/buffer.

TODO

Returns true on success.

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the C<close> method has been called.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the output file/buffer.
It is a fatal error to attempt to seek backward.

Empty parts of the file/buffer will have NULL (0x00) bytes written to them.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

This method always returns C<undef> when compressing. 

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Flushes any pending compressed data and then closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Compress::Bzip2 object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Compress::Bzip2
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 newStream([OPTS])

Usage is

    $z->newStream( [OPTS] )

Closes the current compressed data stream and starts a new one.

OPTS consists of any of the options that are available when creating
the C<$z> object.

See the L</"Constructor Options"> section for more details.

=head1 Importing 

No symbolic constants are required by this IO::Compress::Bzip2 at present. 

=over 5

=item :all

Imports C<bzip2> and C<$Bzip2Error>.
Same as doing this

    use IO::Compress::Bzip2 qw(bzip2 $Bzip2Error) ;

    

=back

=head1 EXAMPLES

=head2 Apache::GZip Revisited

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Apache::GZip Revisited">

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

The primary site for the bzip2 program is F<http://www.bzip.org>.

See the module L<Compress::Bzip2|Compress::Bzip2>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/IO/Compress/Deflate.pm                                                        0100644 0000000 0000000 00000056130 12744441327 016667  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Deflate ;

require 5.006 ;

use strict ;
use warnings;
use bytes;

require Exporter ;

use IO::Compress::RawDeflate 2.064 ();
use IO::Compress::Adapter::Deflate 2.064 ;

use IO::Compress::Zlib::Constants 2.064 ;
use IO::Compress::Base::Common  2.064 qw();


our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $DeflateError);

$VERSION = '2.064';
$DeflateError = '';

@ISA    = qw(Exporter IO::Compress::RawDeflate);
@EXPORT_OK = qw( $DeflateError deflate ) ;
%EXPORT_TAGS = %IO::Compress::RawDeflate::DEFLATE_CONSTANTS ;

push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');


sub new
{
    my $class = shift ;

    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$DeflateError);
    return $obj->_create(undef, @_);
}

sub deflate
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$DeflateError);
    return $obj->_def(@_);
}


sub bitmask($$$$)
{
    my $into  = shift ;
    my $value  = shift ;
    my $offset = shift ;
    my $mask   = shift ;

    return $into | (($value & $mask) << $offset ) ;
}

sub mkDeflateHdr($$$;$)
{
    my $method = shift ;
    my $cinfo  = shift;
    my $level  = shift;
    my $fdict_adler = shift  ;

    my $cmf = 0;
    my $flg = 0;
    my $fdict = 0;
    $fdict = 1 if defined $fdict_adler;

    $cmf = bitmask($cmf, $method, ZLIB_CMF_CM_OFFSET,    ZLIB_CMF_CM_BITS);
    $cmf = bitmask($cmf, $cinfo,  ZLIB_CMF_CINFO_OFFSET, ZLIB_CMF_CINFO_BITS);

    $flg = bitmask($flg, $fdict,  ZLIB_FLG_FDICT_OFFSET, ZLIB_FLG_FDICT_BITS);
    $flg = bitmask($flg, $level,  ZLIB_FLG_LEVEL_OFFSET, ZLIB_FLG_LEVEL_BITS);

    my $fcheck = 31 - ($cmf * 256 + $flg) % 31 ;
    $flg = bitmask($flg, $fcheck, ZLIB_FLG_FCHECK_OFFSET, ZLIB_FLG_FCHECK_BITS);

    my $hdr =  pack("CC", $cmf, $flg) ;
    $hdr .= pack("N", $fdict_adler) if $fdict ;

    return $hdr;
}

sub mkHeader 
{
    my $self = shift ;
    my $param = shift ;

    my $level = $param->getValue('level');
    my $strategy = $param->getValue('strategy');

    my $lflag ;
    $level = 6 
        if $level == Z_DEFAULT_COMPRESSION ;

    if (ZLIB_VERNUM >= 0x1210)
    {
        if ($strategy >= Z_HUFFMAN_ONLY || $level < 2)
         {  $lflag = ZLIB_FLG_LEVEL_FASTEST }
        elsif ($level < 6)
         {  $lflag = ZLIB_FLG_LEVEL_FAST }
        elsif ($level == 6)
         {  $lflag = ZLIB_FLG_LEVEL_DEFAULT }
        else
         {  $lflag = ZLIB_FLG_LEVEL_SLOWEST }
    }
    else
    {
        $lflag = ($level - 1) >> 1 ;
        $lflag = 3 if $lflag > 3 ;
    }

     #my $wbits = (MAX_WBITS - 8) << 4 ;
    my $wbits = 7;
    mkDeflateHdr(ZLIB_CMF_CM_DEFLATED, $wbits, $lflag);
}

sub ckParams
{
    my $self = shift ;
    my $got = shift;
    
    $got->setValue('adler32' => 1);
    return 1 ;
}


sub mkTrailer
{
    my $self = shift ;
    return pack("N", *$self->{Compress}->adler32()) ;
}

sub mkFinalTrailer
{
    return '';
}

#sub newHeader
#{
#    my $self = shift ;
#    return *$self->{Header};
#}

sub getExtraParams
{
    my $self = shift ;
    return $self->getZlibParams(),
}

sub getInverseClass
{
    return ('IO::Uncompress::Inflate',
                \$IO::Uncompress::Inflate::InflateError);
}

sub getFileInfo
{
    my $self = shift ;
    my $params = shift;
    my $file = shift ;
    
}



1;

__END__

=head1 NAME

IO::Compress::Deflate - Write RFC 1950 files/buffers
 
 

=head1 SYNOPSIS

    use IO::Compress::Deflate qw(deflate $DeflateError) ;

    my $status = deflate $input => $output [,OPTS] 
        or die "deflate failed: $DeflateError\n";

    my $z = new IO::Compress::Deflate $output [,OPTS]
        or die "deflate failed: $DeflateError\n";

    $z->print($string);
    $z->printf($format, $string);
    $z->write($string);
    $z->syswrite($string [, $length, $offset]);
    $z->flush();
    $z->tell();
    $z->eof();
    $z->seek($position, $whence);
    $z->binmode();
    $z->fileno();
    $z->opened();
    $z->autoflush();
    $z->input_line_number();
    $z->newStream( [OPTS] );
    
    $z->deflateParams();
    
    $z->close() ;

    $DeflateError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
    

=head1 DESCRIPTION

This module provides a Perl interface that allows writing compressed
data to files or buffer as defined in RFC 1950.

For reading RFC 1950 files/buffers, see the companion module 
L<IO::Uncompress::Inflate|IO::Uncompress::Inflate>.

=head1 Functional Interface

A top-level function, C<deflate>, is provided to carry out
"one-shot" compression between buffers and/or files. For finer
control over the compression process, see the L</"OO Interface">
section.

    use IO::Compress::Deflate qw(deflate $DeflateError) ;

    deflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "deflate failed: $DeflateError\n";

The functional interface needs Perl5.005 or better.

=head2 deflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<deflate> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the uncompressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is compressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<deflate> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the compressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
compressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
compressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
compressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the compressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<deflate> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple files/buffers and
C<$output_filename_or_reference> is a single
file/buffer the input files/buffers will be stored
in C<$output_filename_or_reference> as a concatenated series of compressed data streams.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<deflate>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<deflate> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<deflate> has
completed.

This parameter defaults to 0.

=item C<< BinModeIn => 0|1 >>

When reading from a file or filehandle, set C<binmode> before reading.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all compressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
compressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any compressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any compressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all compressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any compressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all compressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any compressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any compressed data is output.

Defaults to 0.

=back

=head2 Examples

To read the contents of the file C<file1.txt> and write the compressed
data to the file C<file1.txt.1950>.

    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;

    my $input = "file1.txt";
    deflate $input => "$input.1950"
        or die "deflate failed: $DeflateError\n";

To read from an existing Perl filehandle, C<$input>, and write the
compressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt"
        or die "Cannot open 'file1.txt': $!\n" ;
    my $buffer ;
    deflate $input => \$buffer 
        or die "deflate failed: $DeflateError\n";

To compress all files in the directory "/my/home" that match "*.txt"
and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;

    deflate '</my/home/*.txt>' => '<*.1950>'
        or die "deflate failed: $DeflateError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Compress::Deflate qw(deflate $DeflateError) ;

    for my $input ( glob "/my/home/*.txt" )
    {
        my $output = "$input.1950" ;
        deflate $input => $output 
            or die "Error compressing '$input': $DeflateError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for C<IO::Compress::Deflate> is shown below

    my $z = new IO::Compress::Deflate $output [,OPTS]
        or die "IO::Compress::Deflate failed: $DeflateError\n";

It returns an C<IO::Compress::Deflate> object on success and undef on failure. 
The variable C<$DeflateError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from 
IO::Compress::Deflate can be used exactly like an L<IO::File|IO::File> filehandle. 
This means that all normal output file operations can be carried out 
with C<$z>. 
For example, to write to a compressed file/buffer you can use either of 
these forms

    $z->print("hello world\n");
    print $z "hello world\n";

The mandatory parameter C<$output> is used to control the destination
of the compressed data. This parameter can take one of these forms.

=over 5

=item A filename

If the C<$output> parameter is a simple scalar, it is assumed to be a
filename. This file will be opened for writing and the compressed data
will be written to it.

=item A filehandle

If the C<$output> parameter is a filehandle, the compressed data will be
written to it.
The string '-' can be used as an alias for standard output.

=item A scalar reference 

If C<$output> is a scalar reference, the compressed data will be stored
in C<$$output>.

=back

If the C<$output> parameter is any other type, C<IO::Compress::Deflate>::new will
return undef.

=head2 Constructor Options

C<OPTS> is any combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$output> parameter is a filehandle. If
specified, and the value is true, it will result in the C<$output> being
closed once either the C<close> method is called or the C<IO::Compress::Deflate>
object is destroyed.

This parameter defaults to 0.

=item C<< Append => 0|1 >>

Opens C<$output> in append mode. 

The behaviour of this option is dependent on the type of C<$output>.

=over 5

=item * A Buffer

If C<$output> is a buffer and C<Append> is enabled, all compressed data
will be append to the end of C<$output>. Otherwise C<$output> will be
cleared before any data is written to it.

=item * A Filename

If C<$output> is a filename and C<Append> is enabled, the file will be
opened in append mode. Otherwise the contents of the file, if any, will be
truncated before any compressed data is written to it.

=item * A Filehandle

If C<$output> is a filehandle, the file pointer will be positioned to the
end of the file via a call to C<seek> before any compressed data is written
to it.  Otherwise the file pointer will not be moved.

=back

This parameter defaults to 0.

=item C<< Merge => 0|1 >>

This option is used to compress input data and append it to an existing
compressed data stream in C<$output>. The end result is a single compressed
data stream stored in C<$output>. 

It is a fatal error to attempt to use this option when C<$output> is not an
RFC 1950 data stream.

There are a number of other limitations with the C<Merge> option:

=over 5 

=item 1

This module needs to have been built with zlib 1.2.1 or better to work. A
fatal error will be thrown if C<Merge> is used with an older version of
zlib.  

=item 2

If C<$output> is a file or a filehandle, it must be seekable.

=back

This parameter defaults to 0.

=item -Level 

Defines the compression level used by zlib. The value should either be
a number between 0 and 9 (0 means no compression and 9 is maximum
compression), or one of the symbolic constants defined below.

   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION

The default is Z_DEFAULT_COMPRESSION.

Note, these constants are not imported by C<IO::Compress::Deflate> by default.

    use IO::Compress::Deflate qw(:strategy);
    use IO::Compress::Deflate qw(:constants);
    use IO::Compress::Deflate qw(:all);

=item -Strategy 

Defines the strategy used to tune the compression. Use one of the symbolic
constants defined below.

   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY

The default is Z_DEFAULT_STRATEGY.

=item C<< Strict => 0|1 >>

This is a placeholder option.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 print

Usage is

    $z->print($data)
    print $z $data

Compresses and outputs the contents of the C<$data> parameter. This
has the same behaviour as the C<print> built-in.

Returns true if successful.

=head2 printf

Usage is

    $z->printf($format, $data)
    printf $z $format, $data

Compresses and outputs the contents of the C<$data> parameter.

Returns true if successful.

=head2 syswrite

Usage is

    $z->syswrite $data
    $z->syswrite $data, $length
    $z->syswrite $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 write

Usage is

    $z->write $data
    $z->write $data, $length
    $z->write $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 flush

Usage is

    $z->flush;
    $z->flush($flush_type);

Flushes any pending compressed data to the output file/buffer.

This method takes an optional parameter, C<$flush_type>, that controls
how the flushing will be carried out. By default the C<$flush_type>
used is C<Z_FINISH>. Other valid values for C<$flush_type> are
C<Z_NO_FLUSH>, C<Z_SYNC_FLUSH>, C<Z_FULL_FLUSH> and C<Z_BLOCK>. It is
strongly recommended that you only set the C<flush_type> parameter if
you fully understand the implications of what it does - overuse of C<flush>
can seriously degrade the level of compression achieved. See the C<zlib>
documentation for details.

Returns true on success.

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the C<close> method has been called.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the output file/buffer.
It is a fatal error to attempt to seek backward.

Empty parts of the file/buffer will have NULL (0x00) bytes written to them.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

This method always returns C<undef> when compressing. 

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Flushes any pending compressed data and then closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Compress::Deflate object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Compress::Deflate
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 newStream([OPTS])

Usage is

    $z->newStream( [OPTS] )

Closes the current compressed data stream and starts a new one.

OPTS consists of any of the options that are available when creating
the C<$z> object.

See the L</"Constructor Options"> section for more details.

=head2 deflateParams

Usage is

    $z->deflateParams

TODO

=head1 Importing 

A number of symbolic constants are required by some methods in 
C<IO::Compress::Deflate>. None are imported by default.

=over 5

=item :all

Imports C<deflate>, C<$DeflateError> and all symbolic
constants that can be used by C<IO::Compress::Deflate>. Same as doing this

    use IO::Compress::Deflate qw(deflate $DeflateError :constants) ;

=item :constants

Import all symbolic constants. Same as doing this

    use IO::Compress::Deflate qw(:flush :level :strategy) ;

=item :flush

These symbolic constants are used by the C<flush> method.

    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK

=item :level

These symbolic constants are used by the C<Level> option in the constructor.

    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION

=item :strategy

These symbolic constants are used by the C<Strategy> option in the constructor.

    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY

    
    

=back

=head1 EXAMPLES

=head2 Apache::GZip Revisited

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Apache::GZip Revisited">

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                                                                        usr/share/perl/5.20.2/IO/Compress/FAQ.pod                                                           0100644 0000000 0000000 00000047562 12744441327 016111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
=head1 NAME

IO::Compress::FAQ -- Frequently Asked Questions about IO::Compress

=head1 DESCRIPTION

Common questions answered.

=head1 GENERAL 

=head2 Compatibility with Unix compress/uncompress.

Although C<Compress::Zlib> has a pair of functions called C<compress> and
C<uncompress>, they are I<not> related to the Unix programs of the same
name. The C<Compress::Zlib> module is not compatible with Unix
C<compress>.

If you have the C<uncompress> program available, you can use this to read
compressed files

    open F, "uncompress -c $filename |";
    while (<F>)
    {
        ...

Alternatively, if you have the C<gunzip> program available, you can use
this to read compressed files

    open F, "gunzip -c $filename |";
    while (<F>)
    {
        ...

and this to write compress files, if you have the C<compress> program
available

    open F, "| compress -c $filename ";
    print F "data";
    ...
    close F ;

=head2 Accessing .tar.Z files

The C<Archive::Tar> module can optionally use C<Compress::Zlib> (via the
C<IO::Zlib> module) to access tar files that have been compressed with
C<gzip>. Unfortunately tar files compressed with the Unix C<compress>
utility cannot be read by C<Compress::Zlib> and so cannot be directly
accessed by C<Archive::Tar>.

If the C<uncompress> or C<gunzip> programs are available, you can use one
of these workarounds to read C<.tar.Z> files from C<Archive::Tar>

Firstly with C<uncompress>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "uncompress -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

and this with C<gunzip>

    use strict;
    use warnings;
    use Archive::Tar;

    open F, "gunzip -c $filename |";
    my $tar = Archive::Tar->new(*F);
    ...

Similarly, if the C<compress> program is available, you can use this to
write a C<.tar.Z> file

    use strict;
    use warnings;
    use Archive::Tar;
    use IO::File;

    my $fh = new IO::File "| compress -c >$filename";
    my $tar = Archive::Tar->new();
    ...
    $tar->write($fh);
    $fh->close ;

=head2 How do I recompress using a different compression?

This is easier that you might expect if you realise that all the
C<IO::Compress::*> objects are derived from C<IO::File> and that all the
C<IO::Uncompress::*> modules can read from an C<IO::File> filehandle.

So, for example, say you have a file compressed with gzip that you want to
recompress with bzip2. Here is all that is needed to carry out the
recompression.

    use IO::Uncompress::Gunzip ':all';
    use IO::Compress::Bzip2 ':all';

    my $gzipFile = "somefile.gz";
    my $bzipFile = "somefile.bz2";

    my $gunzip = new IO::Uncompress::Gunzip $gzipFile
        or die "Cannot gunzip $gzipFile: $GunzipError\n" ;

    bzip2 $gunzip => $bzipFile 
        or die "Cannot bzip2 to $bzipFile: $Bzip2Error\n" ;

Note, there is a limitation of this technique. Some compression file
formats store extra information along with the compressed data payload. For
example, gzip can optionally store the original filename and Zip stores a
lot of information about the original file. If the original compressed file
contains any of this extra information, it will not be transferred to the
new compressed file using the technique above.

=head1 ZIP

=head2 What Compression Types do IO::Compress::Zip & IO::Uncompress::Unzip support?

The following compression formats are supported by C<IO::Compress::Zip> and
C<IO::Uncompress::Unzip>

=over 5

=item * Store (method 0)

No compression at all.

=item * Deflate (method 8)

This is the default compression used when creating a zip file with
C<IO::Compress::Zip>.

=item * Bzip2 (method 12)

Only supported if the C<IO-Compress-Bzip2> module is installed.

=item * Lzma (method 14)

Only supported if the C<IO-Compress-Lzma> module is installed.

=back

=head2 Can I Read/Write Zip files larger the 4 Gig?

Yes, both the C<IO-Compress-Zip> and C<IO-Uncompress-Unzip>  modules
support the zip feature called I<Zip64>. That allows them to read/write
files/buffers larger than 4Gig. 

If you are creating a Zip file using the one-shot interface, and any of the
input files is greater than 4Gig, a zip64 complaint zip file will be
created. 

    zip "really-large-file" => "my.zip";

Similarly with the one-shot interface, if the input is a buffer larger than
4 Gig, a zip64 complaint zip file will be created. 

    zip \$really_large_buffer => "my.zip";

The one-shot interface allows you to force the creation of a zip64 zip file
by including the C<Zip64> option.

    zip $filehandle => "my.zip", Zip64 => 1;

If you want to create a zip64 zip file with the OO interface you must
specify the C<Zip64> option.

    my $zip = new IO::Compress::Zip "whatever", Zip64 => 1;
	
When uncompressing with C<IO-Uncompress-Unzip>, it will automatically
detect if the zip file is zip64.

If you intend to manipulate the Zip64 zip files created with
C<IO-Compress-Zip> using an external zip/unzip, make sure that it supports
Zip64.  

In particular, if you are using Info-Zip you need to have zip version 3.x
or better to update a Zip64 archive and unzip version 6.x to read a zip64
archive. 

=head2 Can I write more that 64K entries is a Zip files?

Yes. Zip64 allows this. See previous question.

=head2 Zip Resources

The primary reference for zip files is the "appnote" document available at
L<http://www.pkware.com/documents/casestudies/APPNOTE.TXT>

An alternatively is the Info-Zip appnote. This is available from
L<ftp://ftp.info-zip.org/pub/infozip/doc/>

=head1 GZIP

=head2 Gzip Resources

The primary reference for gzip files is RFC 1952
L<http://www.faqs.org/rfcs/rfc1952.html>

The primary site for gzip is F<http://www.gzip.org>.

=head2 Dealing with Concatenated gzip files

If the gunzip program encounters a file containing multiple gzip files
concatenated together it will automatically uncompress them all.
The example below illustrates this behaviour

    $ echo abc | gzip -c >x.gz
    $ echo def | gzip -c >>x.gz
    $ gunzip -c x.gz 
    abc
    def

By default C<IO::Uncompress::Gunzip> will I<not> behave like the gunzip
program. It will only uncompress the first gzip data stream in the file, as
shown below

    $ perl -MIO::Uncompress::Gunzip=:all -e 'gunzip "x.gz" => \*STDOUT'
    abc

To force C<IO::Uncompress::Gunzip> to uncompress all the gzip data streams,
include the C<MultiStream> option, as shown below

    $ perl -MIO::Uncompress::Gunzip=:all -e 'gunzip "x.gz" => \*STDOUT, MultiStream => 1'
    abc
    def

=head1 ZLIB

=head2 Zlib Resources

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

=head1 Bzip2

=head2 Bzip2 Resources

The primary site for bzip2 is F<http://www.bzip.org>.

=head2 Dealing with Concatenated bzip2 files

If the bunzip2 program encounters a file containing multiple bzip2 files
concatenated together it will automatically uncompress them all.
The example below illustrates this behaviour

    $ echo abc | bzip2 -c >x.bz2
    $ echo def | bzip2 -c >>x.bz2
    $ bunzip2 -c x.bz2
    abc
    def

By default C<IO::Uncompress::Bunzip2> will I<not> behave like the bunzip2
program. It will only uncompress the first bunzip2 data stream in the file, as
shown below

    $ perl -MIO::Uncompress::Bunzip2=:all -e 'bunzip2 "x.bz2" => \*STDOUT'
    abc

To force C<IO::Uncompress::Bunzip2> to uncompress all the bzip2 data streams,
include the C<MultiStream> option, as shown below

    $ perl -MIO::Uncompress::Bunzip2=:all -e 'bunzip2 "x.bz2" => \*STDOUT, MultiStream => 1'
    abc
    def

=head2 Interoperating with Pbzip2

Pbzip2 (L<http://compression.ca/pbzip2/>) is a parallel implementation of
bzip2. The output from pbzip2 consists of a series of concatenated bzip2
data streams.

By default C<IO::Uncompress::Bzip2> will only uncompress the first bzip2
data stream in a pbzip2 file. To uncompress the complete pbzip2 file you
must include the C<MultiStream> option, like this.

    bunzip2 $input => \$output, MultiStream => 1 
        or die "bunzip2 failed: $Bunzip2Error\n";

=head1 HTTP & NETWORK

=head2 Apache::GZip Revisited

Below is a mod_perl Apache compression module, called C<Apache::GZip>,
taken from
F<http://perl.apache.org/docs/tutorials/tips/mod_perl_tricks/mod_perl_tricks.html#On_the_Fly_Compression>

  package Apache::GZip;
  #File: Apache::GZip.pm
  
  use strict vars;
  use Apache::Constants ':common';
  use Compress::Zlib;
  use IO::File;
  use constant GZIP_MAGIC => 0x1f8b;
  use constant OS_MAGIC => 0x03;
  
  sub handler {
      my $r = shift;
      my ($fh,$gz);
      my $file = $r->filename;
      return DECLINED unless $fh=IO::File->new($file);
      $r->header_out('Content-Encoding'=>'gzip');
      $r->send_http_header;
      return OK if $r->header_only;
  
      tie *STDOUT,'Apache::GZip',$r;
      print($_) while <$fh>;
      untie *STDOUT;
      return OK;
  }
  
  sub TIEHANDLE {
      my($class,$r) = @_;
      # initialize a deflation stream
      my $d = deflateInit(-WindowBits=>-MAX_WBITS()) || return undef;
  
      # gzip header -- don't ask how I found out
      $r->print(pack("nccVcc",GZIP_MAGIC,Z_DEFLATED,0,time(),0,OS_MAGIC));
  
      return bless { r   => $r,
                     crc =>  crc32(undef),
                     d   => $d,
                     l   =>  0 
                   },$class;
  }
  
  sub PRINT {
      my $self = shift;
      foreach (@_) {
        # deflate the data
        my $data = $self->{d}->deflate($_);
        $self->{r}->print($data);
        # keep track of its length and crc
        $self->{l} += length($_);
        $self->{crc} = crc32($_,$self->{crc});
      }
  }
  
  sub DESTROY {
     my $self = shift;
     
     # flush the output buffers
     my $data = $self->{d}->flush;
     $self->{r}->print($data);
     
     # print the CRC and the total length (uncompressed)
     $self->{r}->print(pack("LL",@{$self}{qw/crc l/}));
  }
   
  1;

Here's the Apache configuration entry you'll need to make use of it.  Once
set it will result in everything in the /compressed directory will be
compressed automagically.

  <Location /compressed>
     SetHandler  perl-script
     PerlHandler Apache::GZip
  </Location>

Although at first sight there seems to be quite a lot going on in
C<Apache::GZip>, you could sum up what the code was doing as follows --
read the contents of the file in C<< $r->filename >>, compress it and write
the compressed data to standard output. That's all.

This code has to jump through a few hoops to achieve this because

=over

=item 1.

The gzip support in C<Compress::Zlib> version 1.x can only work with a real
filesystem filehandle. The filehandles used by Apache modules are not
associated with the filesystem.

=item 2.

That means all the gzip support has to be done by hand - in this case by
creating a tied filehandle to deal with creating the gzip header and
trailer.

=back

C<IO::Compress::Gzip> doesn't have that filehandle limitation (this was one
of the reasons for writing it in the first place). So if
C<IO::Compress::Gzip> is used instead of C<Compress::Zlib> the whole tied
filehandle code can be removed. Here is the rewritten code.

  package Apache::GZip;
  
  use strict vars;
  use Apache::Constants ':common';
  use IO::Compress::Gzip;
  use IO::File;
  
  sub handler {
      my $r = shift;
      my ($fh,$gz);
      my $file = $r->filename;
      return DECLINED unless $fh=IO::File->new($file);
      $r->header_out('Content-Encoding'=>'gzip');
      $r->send_http_header;
      return OK if $r->header_only;

      my $gz = new IO::Compress::Gzip '-', Minimal => 1
          or return DECLINED ;

      print $gz $_ while <$fh>;
  
      return OK;
  }
  
or even more succinctly, like this, using a one-shot gzip

  package Apache::GZip;
  
  use strict vars;
  use Apache::Constants ':common';
  use IO::Compress::Gzip qw(gzip);
  
  sub handler {
      my $r = shift;
      $r->header_out('Content-Encoding'=>'gzip');
      $r->send_http_header;
      return OK if $r->header_only;

      gzip $r->filename => '-', Minimal => 1
        or return DECLINED ;

      return OK;
  }
   
  1;

The use of one-shot C<gzip> above just reads from C<< $r->filename >> and
writes the compressed data to standard output.

Note the use of the C<Minimal> option in the code above. When using gzip
for Content-Encoding you should I<always> use this option. In the example
above it will prevent the filename being included in the gzip header and
make the size of the gzip data stream a slight bit smaller.

=head2 Compressed files and Net::FTP

The C<Net::FTP> module provides two low-level methods called C<stor> and
C<retr> that both return filehandles. These filehandles can used with the
C<IO::Compress/Uncompress> modules to compress or uncompress files read
from or written to an FTP Server on the fly, without having to create a
temporary file.

Firstly, here is code that uses C<retr> to uncompressed a file as it is
read from the FTP Server.

    use Net::FTP;
    use IO::Uncompress::Gunzip qw(:all);

    my $ftp = new Net::FTP ...

    my $retr_fh = $ftp->retr($compressed_filename);
    gunzip $retr_fh => $outFilename, AutoClose => 1
        or die "Cannot uncompress '$compressed_file': $GunzipError\n";

and this to compress a file as it is written to the FTP Server 

    use Net::FTP;
    use IO::Compress::Gzip qw(:all);

    my $stor_fh = $ftp->stor($filename);
    gzip "filename" => $stor_fh, AutoClose => 1
        or die "Cannot compress '$filename': $GzipError\n";

=head1 MISC

=head2 Using C<InputLength> to uncompress data embedded in a larger file/buffer.

A fairly common use-case is where compressed data is embedded in a larger
file/buffer and you want to read both.

As an example consider the structure of a zip file. This is a well-defined
file format that mixes both compressed and uncompressed sections of data in
a single file. 

For the purposes of this discussion you can think of a zip file as sequence
of compressed data streams, each of which is prefixed by an uncompressed
local header. The local header contains information about the compressed
data stream, including the name of the compressed file and, in particular,
the length of the compressed data stream. 

To illustrate how to use C<InputLength> here is a script that walks a zip
file and prints out how many lines are in each compressed file (if you
intend write code to walking through a zip file for real see
L<IO::Uncompress::Unzip/"Walking through a zip file"> ). Also, although
this example uses the zlib-based compression, the technique can be used by
the other C<IO::Uncompress::*> modules.

    use strict;
    use warnings;

    use IO::File;
    use IO::Uncompress::RawInflate qw(:all);

    use constant ZIP_LOCAL_HDR_SIG  => 0x04034b50;
    use constant ZIP_LOCAL_HDR_LENGTH => 30;

    my $file = $ARGV[0] ;

    my $fh = new IO::File "<$file"
                or die "Cannot open '$file': $!\n";

    while (1)
    {
        my $sig;
        my $buffer;

        my $x ;
        ($x = $fh->read($buffer, ZIP_LOCAL_HDR_LENGTH)) == ZIP_LOCAL_HDR_LENGTH 
            or die "Truncated file: $!\n";

        my $signature = unpack ("V", substr($buffer, 0, 4));

        last unless $signature == ZIP_LOCAL_HDR_SIG;

        # Read Local Header
        my $gpFlag             = unpack ("v", substr($buffer, 6, 2));
        my $compressedMethod   = unpack ("v", substr($buffer, 8, 2));
        my $compressedLength   = unpack ("V", substr($buffer, 18, 4));
        my $uncompressedLength = unpack ("V", substr($buffer, 22, 4));
        my $filename_length    = unpack ("v", substr($buffer, 26, 2)); 
        my $extra_length       = unpack ("v", substr($buffer, 28, 2));

        my $filename ;
        $fh->read($filename, $filename_length) == $filename_length 
            or die "Truncated file\n";

        $fh->read($buffer, $extra_length) == $extra_length
            or die "Truncated file\n";

        if ($compressedMethod != 8 && $compressedMethod != 0)
        {
            warn "Skipping file '$filename' - not deflated $compressedMethod\n";
            $fh->read($buffer, $compressedLength) == $compressedLength
                or die "Truncated file\n";
            next;
        }

        if ($compressedMethod == 0 && $gpFlag & 8 == 8)
        {
            die "Streamed Stored not supported for '$filename'\n";
        }

        next if $compressedLength == 0;

        # Done reading the Local Header

        my $inf = new IO::Uncompress::RawInflate $fh,
                            Transparent => 1,
                            InputLength => $compressedLength
          or die "Cannot uncompress $file [$filename]: $RawInflateError\n"  ;

        my $line_count = 0;

        while (<$inf>)
        {
            ++ $line_count;
        }

        print "$filename: $line_count\n";
    }

The majority of the code above is concerned with reading the zip local
header data. The code that I want to focus on is at the bottom. 

    while (1) {
    
        # read local zip header data
        # get $filename
        # get $compressedLength

        my $inf = new IO::Uncompress::RawInflate $fh,
                            Transparent => 1,
                            InputLength => $compressedLength
          or die "Cannot uncompress $file [$filename]: $RawInflateError\n"  ;

        my $line_count = 0;

        while (<$inf>)
        {
            ++ $line_count;
        }

        print "$filename: $line_count\n";
    }

The call to C<IO::Uncompress::RawInflate> creates a new filehandle C<$inf>
that can be used to read from the parent filehandle C<$fh>, uncompressing
it as it goes. The use of the C<InputLength> option will guarantee that
I<at most> C<$compressedLength> bytes of compressed data will be read from
the C<$fh> filehandle (The only exception is for an error case like a
truncated file or a corrupt data stream).

This means that once RawInflate is finished C<$fh> will be left at the
byte directly after the compressed data stream. 

Now consider what the code looks like without C<InputLength> 

    while (1) {
    
        # read local zip header data
        # get $filename
        # get $compressedLength

        # read all the compressed data into $data
        read($fh, $data, $compressedLength);

        my $inf = new IO::Uncompress::RawInflate \$data,
                            Transparent => 1,
          or die "Cannot uncompress $file [$filename]: $RawInflateError\n"  ;

        my $line_count = 0;

        while (<$inf>)
        {
            ++ $line_count;
        }

        print "$filename: $line_count\n";
    }

The difference here is the addition of the temporary variable C<$data>.
This is used to store a copy of the compressed data while it is being
uncompressed.

If you know that C<$compressedLength> isn't that big then using temporary
storage won't be a problem. But if C<$compressedLength> is very large or
you are writing an application that other people will use, and so have no
idea how big C<$compressedLength> will be, it could be an issue.

Using C<InputLength> avoids the use of temporary storage and means the
application can cope with large compressed data streams.

One final point -- obviously C<InputLength> can only be used whenever you
know the length of the compressed data beforehand, like here with a zip
file. 

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                              usr/share/perl/5.20.2/IO/Compress/Gzip/                                                             0040755 0000000 0000000 00000000000 13077704254 015675  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IO/Compress/Gzip/Constants.pm                                                 0100644 0000000 0000000 00000007477 12744441327 020222  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Gzip::Constants;

use strict ;
use warnings;
use bytes;

require Exporter;

our ($VERSION, @ISA, @EXPORT, %GZIP_OS_Names);
our ($GZIP_FNAME_INVALID_CHAR_RE, $GZIP_FCOMMENT_INVALID_CHAR_RE);

$VERSION = '2.064';

@ISA = qw(Exporter);

@EXPORT= qw(

    GZIP_ID_SIZE
    GZIP_ID1
    GZIP_ID2

    GZIP_FLG_DEFAULT
    GZIP_FLG_FTEXT
    GZIP_FLG_FHCRC
    GZIP_FLG_FEXTRA
    GZIP_FLG_FNAME
    GZIP_FLG_FCOMMENT
    GZIP_FLG_RESERVED

    GZIP_CM_DEFLATED

    GZIP_MIN_HEADER_SIZE
    GZIP_TRAILER_SIZE

    GZIP_MTIME_DEFAULT
    GZIP_XFL_DEFAULT
    GZIP_FEXTRA_HEADER_SIZE
    GZIP_FEXTRA_MAX_SIZE
    GZIP_FEXTRA_SUBFIELD_HEADER_SIZE
    GZIP_FEXTRA_SUBFIELD_ID_SIZE
    GZIP_FEXTRA_SUBFIELD_LEN_SIZE
    GZIP_FEXTRA_SUBFIELD_MAX_SIZE

    $GZIP_FNAME_INVALID_CHAR_RE
    $GZIP_FCOMMENT_INVALID_CHAR_RE

    GZIP_FHCRC_SIZE

    GZIP_ISIZE_MAX
    GZIP_ISIZE_MOD_VALUE


    GZIP_NULL_BYTE

    GZIP_OS_DEFAULT

    %GZIP_OS_Names

    GZIP_MINIMUM_HEADER

    );

# Constant names derived from RFC 1952

use constant GZIP_ID_SIZE                     => 2 ;
use constant GZIP_ID1                         => 0x1F;
use constant GZIP_ID2                         => 0x8B;

use constant GZIP_MIN_HEADER_SIZE             => 10 ;# minimum gzip header size
use constant GZIP_TRAILER_SIZE                => 8 ;


use constant GZIP_FLG_DEFAULT                 => 0x00 ;
use constant GZIP_FLG_FTEXT                   => 0x01 ;
use constant GZIP_FLG_FHCRC                   => 0x02 ; # called CONTINUATION in gzip
use constant GZIP_FLG_FEXTRA                  => 0x04 ;
use constant GZIP_FLG_FNAME                   => 0x08 ;
use constant GZIP_FLG_FCOMMENT                => 0x10 ;
#use constant GZIP_FLG_ENCRYPTED              => 0x20 ; # documented in gzip sources
use constant GZIP_FLG_RESERVED                => (0x20 | 0x40 | 0x80) ;

use constant GZIP_XFL_DEFAULT                 => 0x00 ;

use constant GZIP_MTIME_DEFAULT               => 0x00 ;

use constant GZIP_FEXTRA_HEADER_SIZE          => 2 ;
use constant GZIP_FEXTRA_MAX_SIZE             => 0xFFFF ;
use constant GZIP_FEXTRA_SUBFIELD_ID_SIZE     => 2 ;
use constant GZIP_FEXTRA_SUBFIELD_LEN_SIZE    => 2 ;
use constant GZIP_FEXTRA_SUBFIELD_HEADER_SIZE => GZIP_FEXTRA_SUBFIELD_ID_SIZE +
                                                 GZIP_FEXTRA_SUBFIELD_LEN_SIZE;
use constant GZIP_FEXTRA_SUBFIELD_MAX_SIZE    => GZIP_FEXTRA_MAX_SIZE - 
                                                 GZIP_FEXTRA_SUBFIELD_HEADER_SIZE ;


if (ord('A') == 193)
{
    # EBCDIC 
    $GZIP_FNAME_INVALID_CHAR_RE = '[\x00-\x3f\xff]';
    $GZIP_FCOMMENT_INVALID_CHAR_RE = '[\x00-\x0a\x11-\x14\x16-\x3f\xff]';
    
}
else
{
    $GZIP_FNAME_INVALID_CHAR_RE       =  '[\x00-\x1F\x7F-\x9F]';
    $GZIP_FCOMMENT_INVALID_CHAR_RE    =  '[\x00-\x09\x11-\x1F\x7F-\x9F]';
}            

use constant GZIP_FHCRC_SIZE        => 2 ; # aka CONTINUATION in gzip

use constant GZIP_CM_DEFLATED       => 8 ;

use constant GZIP_NULL_BYTE         => "\x00";
use constant GZIP_ISIZE_MAX         => 0xFFFFFFFF ;
use constant GZIP_ISIZE_MOD_VALUE   => GZIP_ISIZE_MAX + 1 ;

# OS Names sourced from http://www.gzip.org/format.txt

use constant GZIP_OS_DEFAULT=> 0xFF ;
%GZIP_OS_Names = (
    0   => 'MS-DOS',
    1   => 'Amiga',
    2   => 'VMS',
    3   => 'Unix',
    4   => 'VM/CMS',
    5   => 'Atari TOS',
    6   => 'HPFS (OS/2, NT)',
    7   => 'Macintosh',
    8   => 'Z-System',
    9   => 'CP/M',
    10  => 'TOPS-20',
    11  => 'NTFS (NT)',
    12  => 'SMS QDOS',
    13  => 'Acorn RISCOS',
    14  => 'VFAT file system (Win95, NT)',
    15  => 'MVS',
    16  => 'BeOS',
    17  => 'Tandem/NSK',
    18  => 'THEOS',
    GZIP_OS_DEFAULT()   => 'Unknown',
    ) ;

use constant GZIP_MINIMUM_HEADER =>   pack("C4 V C C",  
        GZIP_ID1, GZIP_ID2, GZIP_CM_DEFLATED, GZIP_FLG_DEFAULT,
        GZIP_MTIME_DEFAULT, GZIP_XFL_DEFAULT, GZIP_OS_DEFAULT) ;


1;
                                                                                                                                                                                                 usr/share/perl/5.20.2/IO/Compress/Gzip.pm                                                           0100644 0000000 0000000 00000102541 12744441327 016232  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Gzip ;

require 5.006 ;

use strict ;
use warnings;
use bytes;

require Exporter ;

use IO::Compress::RawDeflate 2.064 () ; 
use IO::Compress::Adapter::Deflate 2.064 ;

use IO::Compress::Base::Common  2.064 qw(:Status );
use IO::Compress::Gzip::Constants 2.064 ;
use IO::Compress::Zlib::Extra 2.064 ;

BEGIN
{
    if (defined &utf8::downgrade ) 
      { *noUTF8 = \&utf8::downgrade }
    else
      { *noUTF8 = sub {} }  
}

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $GzipError);

$VERSION = '2.064';
$GzipError = '' ;

@ISA    = qw(Exporter IO::Compress::RawDeflate);
@EXPORT_OK = qw( $GzipError gzip ) ;
%EXPORT_TAGS = %IO::Compress::RawDeflate::DEFLATE_CONSTANTS ;

push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

sub new
{
    my $class = shift ;

    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$GzipError);

    $obj->_create(undef, @_);
}


sub gzip
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$GzipError);
    return $obj->_def(@_);
}

#sub newHeader
#{
#    my $self = shift ;
#    #return GZIP_MINIMUM_HEADER ;
#    return $self->mkHeader(*$self->{Got});
#}

sub getExtraParams
{
    my $self = shift ;

    return (
            # zlib behaviour
            $self->getZlibParams(),
           
            # Gzip header fields
            'minimal'   => [IO::Compress::Base::Common::Parse_boolean,   0],
            'comment'   => [IO::Compress::Base::Common::Parse_any,       undef],
            'name'      => [IO::Compress::Base::Common::Parse_any,       undef],
            'time'      => [IO::Compress::Base::Common::Parse_any,       undef],
            'textflag'  => [IO::Compress::Base::Common::Parse_boolean,   0],
            'headercrc' => [IO::Compress::Base::Common::Parse_boolean,   0],
            'os_code'   => [IO::Compress::Base::Common::Parse_unsigned,  $Compress::Raw::Zlib::gzip_os_code],
            'extrafield'=> [IO::Compress::Base::Common::Parse_any,       undef],
            'extraflags'=> [IO::Compress::Base::Common::Parse_any,       undef],

        );
}


sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # gzip always needs crc32
    $got->setValue('crc32' => 1);

    return 1
        if $got->getValue('merge') ;

    my $strict = $got->getValue('strict') ;


    {
        if (! $got->parsed('time') ) {
            # Modification time defaults to now.
            $got->setValue(time => time) ;
        }

        # Check that the Name & Comment don't have embedded NULLs
        # Also check that they only contain ISO 8859-1 chars.
        if ($got->parsed('name') && defined $got->getValue('name')) {
            my $name = $got->getValue('name');
                
            return $self->saveErrorString(undef, "Null Character found in Name",
                                                Z_DATA_ERROR)
                if $strict && $name =~ /\x00/ ;

            return $self->saveErrorString(undef, "Non ISO 8859-1 Character found in Name",
                                                Z_DATA_ERROR)
                if $strict && $name =~ /$GZIP_FNAME_INVALID_CHAR_RE/o ;
        }

        if ($got->parsed('comment') && defined $got->getValue('comment')) {
            my $comment = $got->getValue('comment');

            return $self->saveErrorString(undef, "Null Character found in Comment",
                                                Z_DATA_ERROR)
                if $strict && $comment =~ /\x00/ ;

            return $self->saveErrorString(undef, "Non ISO 8859-1 Character found in Comment",
                                                Z_DATA_ERROR)
                if $strict && $comment =~ /$GZIP_FCOMMENT_INVALID_CHAR_RE/o;
        }

        if ($got->parsed('os_code') ) {
            my $value = $got->getValue('os_code');

            return $self->saveErrorString(undef, "OS_Code must be between 0 and 255, got '$value'")
                if $value < 0 || $value > 255 ;
            
        }

        # gzip only supports Deflate at present
        $got->setValue('method' => Z_DEFLATED) ;

        if ( ! $got->parsed('extraflags')) {
            $got->setValue('extraflags' => 2) 
                if $got->getValue('level') == Z_BEST_COMPRESSION ;
            $got->setValue('extraflags' => 4) 
                if $got->getValue('level') == Z_BEST_SPEED ;
        }

        my $data = $got->getValue('extrafield') ;
        if (defined $data) {
            my $bad = IO::Compress::Zlib::Extra::parseExtraField($data, $strict, 1) ;
            return $self->saveErrorString(undef, "Error with ExtraField Parameter: $bad", Z_DATA_ERROR)
                if $bad ;

            $got->setValue('extrafield' => $data) ;
        }
    }

    return 1;
}

sub mkTrailer
{
    my $self = shift ;
    return pack("V V", *$self->{Compress}->crc32(), 
                       *$self->{UnCompSize}->get32bit());
}

sub getInverseClass
{
    return ('IO::Uncompress::Gunzip',
                \$IO::Uncompress::Gunzip::GunzipError);
}

sub getFileInfo
{
    my $self = shift ;
    my $params = shift;
    my $filename = shift ;

    return if IO::Compress::Base::Common::isaScalar($filename);

    my $defaultTime = (stat($filename))[9] ;

    $params->setValue('name' => $filename)
        if ! $params->parsed('name') ;

    $params->setValue('time' => $defaultTime) 
        if ! $params->parsed('time') ;
}


sub mkHeader
{
    my $self = shift ;
    my $param = shift ;

    # short-circuit if a minimal header is requested.
    return GZIP_MINIMUM_HEADER if $param->getValue('minimal') ;

    # METHOD
    my $method = $param->valueOrDefault('method', GZIP_CM_DEFLATED) ;

    # FLAGS
    my $flags       = GZIP_FLG_DEFAULT ;
    $flags |= GZIP_FLG_FTEXT    if $param->getValue('textflag') ;
    $flags |= GZIP_FLG_FHCRC    if $param->getValue('headercrc') ;
    $flags |= GZIP_FLG_FEXTRA   if $param->wantValue('extrafield') ;
    $flags |= GZIP_FLG_FNAME    if $param->wantValue('name') ;
    $flags |= GZIP_FLG_FCOMMENT if $param->wantValue('comment') ;
    
    # MTIME
    my $time = $param->valueOrDefault('time', GZIP_MTIME_DEFAULT) ;

    # EXTRA FLAGS
    my $extra_flags = $param->valueOrDefault('extraflags', GZIP_XFL_DEFAULT);

    # OS CODE
    my $os_code = $param->valueOrDefault('os_code', GZIP_OS_DEFAULT) ;


    my $out = pack("C4 V C C", 
            GZIP_ID1,   # ID1
            GZIP_ID2,   # ID2
            $method,    # Compression Method
            $flags,     # Flags
            $time,      # Modification Time
            $extra_flags, # Extra Flags
            $os_code,   # Operating System Code
            ) ;

    # EXTRA
    if ($flags & GZIP_FLG_FEXTRA) {
        my $extra = $param->getValue('extrafield') ;
        $out .= pack("v", length $extra) . $extra ;
    }

    # NAME
    if ($flags & GZIP_FLG_FNAME) {
        my $name .= $param->getValue('name') ;
        $name =~ s/\x00.*$//;
        $out .= $name ;
        # Terminate the filename with NULL unless it already is
        $out .= GZIP_NULL_BYTE 
            if !length $name or
               substr($name, 1, -1) ne GZIP_NULL_BYTE ;
    }

    # COMMENT
    if ($flags & GZIP_FLG_FCOMMENT) {
        my $comment .= $param->getValue('comment') ;
        $comment =~ s/\x00.*$//;
        $out .= $comment ;
        # Terminate the comment with NULL unless it already is
        $out .= GZIP_NULL_BYTE
            if ! length $comment or
               substr($comment, 1, -1) ne GZIP_NULL_BYTE;
    }

    # HEADER CRC
    $out .= pack("v", Compress::Raw::Zlib::crc32($out) & 0x00FF ) 
        if $param->getValue('headercrc') ;

    noUTF8($out);

    return $out ;
}

sub mkFinalTrailer
{
    return '';
}

1; 

__END__

=head1 NAME

IO::Compress::Gzip - Write RFC 1952 files/buffers
 
 

=head1 SYNOPSIS

    use IO::Compress::Gzip qw(gzip $GzipError) ;

    my $status = gzip $input => $output [,OPTS] 
        or die "gzip failed: $GzipError\n";

    my $z = new IO::Compress::Gzip $output [,OPTS]
        or die "gzip failed: $GzipError\n";

    $z->print($string);
    $z->printf($format, $string);
    $z->write($string);
    $z->syswrite($string [, $length, $offset]);
    $z->flush();
    $z->tell();
    $z->eof();
    $z->seek($position, $whence);
    $z->binmode();
    $z->fileno();
    $z->opened();
    $z->autoflush();
    $z->input_line_number();
    $z->newStream( [OPTS] );
    
    $z->deflateParams();
    
    $z->close() ;

    $GzipError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
    

=head1 DESCRIPTION

This module provides a Perl interface that allows writing compressed
data to files or buffer as defined in RFC 1952.

All the gzip headers defined in RFC 1952 can be created using
this module.

For reading RFC 1952 files/buffers, see the companion module 
L<IO::Uncompress::Gunzip|IO::Uncompress::Gunzip>.

=head1 Functional Interface

A top-level function, C<gzip>, is provided to carry out
"one-shot" compression between buffers and/or files. For finer
control over the compression process, see the L</"OO Interface">
section.

    use IO::Compress::Gzip qw(gzip $GzipError) ;

    gzip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "gzip failed: $GzipError\n";

The functional interface needs Perl5.005 or better.

=head2 gzip $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<gzip> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the uncompressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is compressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<gzip> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

In addition, if C<$input_filename_or_reference> is a simple filename, 
the default values for
the C<Name> and C<Time> options will be sourced from that file.

If you do not want to use these defaults they can be overridden by
explicitly setting the C<Name> and C<Time> options or by setting the
C<Minimal> parameter.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the compressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
compressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
compressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
compressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the compressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<gzip> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple files/buffers and
C<$output_filename_or_reference> is a single
file/buffer the input files/buffers will be stored
in C<$output_filename_or_reference> as a concatenated series of compressed data streams.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<gzip>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<gzip> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<gzip> has
completed.

This parameter defaults to 0.

=item C<< BinModeIn => 0|1 >>

When reading from a file or filehandle, set C<binmode> before reading.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all compressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
compressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any compressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any compressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all compressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any compressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all compressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any compressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any compressed data is output.

Defaults to 0.

=back

=head2 Examples

To read the contents of the file C<file1.txt> and write the compressed
data to the file C<file1.txt.gz>.

    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    my $input = "file1.txt";
    gzip $input => "$input.gz"
        or die "gzip failed: $GzipError\n";

To read from an existing Perl filehandle, C<$input>, and write the
compressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt"
        or die "Cannot open 'file1.txt': $!\n" ;
    my $buffer ;
    gzip $input => \$buffer 
        or die "gzip failed: $GzipError\n";

To compress all files in the directory "/my/home" that match "*.txt"
and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    gzip '</my/home/*.txt>' => '<*.gz>'
        or die "gzip failed: $GzipError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Compress::Gzip qw(gzip $GzipError) ;

    for my $input ( glob "/my/home/*.txt" )
    {
        my $output = "$input.gz" ;
        gzip $input => $output 
            or die "Error compressing '$input': $GzipError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for C<IO::Compress::Gzip> is shown below

    my $z = new IO::Compress::Gzip $output [,OPTS]
        or die "IO::Compress::Gzip failed: $GzipError\n";

It returns an C<IO::Compress::Gzip> object on success and undef on failure. 
The variable C<$GzipError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from 
IO::Compress::Gzip can be used exactly like an L<IO::File|IO::File> filehandle. 
This means that all normal output file operations can be carried out 
with C<$z>. 
For example, to write to a compressed file/buffer you can use either of 
these forms

    $z->print("hello world\n");
    print $z "hello world\n";

The mandatory parameter C<$output> is used to control the destination
of the compressed data. This parameter can take one of these forms.

=over 5

=item A filename

If the C<$output> parameter is a simple scalar, it is assumed to be a
filename. This file will be opened for writing and the compressed data
will be written to it.

=item A filehandle

If the C<$output> parameter is a filehandle, the compressed data will be
written to it.
The string '-' can be used as an alias for standard output.

=item A scalar reference 

If C<$output> is a scalar reference, the compressed data will be stored
in C<$$output>.

=back

If the C<$output> parameter is any other type, C<IO::Compress::Gzip>::new will
return undef.

=head2 Constructor Options

C<OPTS> is any combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$output> parameter is a filehandle. If
specified, and the value is true, it will result in the C<$output> being
closed once either the C<close> method is called or the C<IO::Compress::Gzip>
object is destroyed.

This parameter defaults to 0.

=item C<< Append => 0|1 >>

Opens C<$output> in append mode. 

The behaviour of this option is dependent on the type of C<$output>.

=over 5

=item * A Buffer

If C<$output> is a buffer and C<Append> is enabled, all compressed data
will be append to the end of C<$output>. Otherwise C<$output> will be
cleared before any data is written to it.

=item * A Filename

If C<$output> is a filename and C<Append> is enabled, the file will be
opened in append mode. Otherwise the contents of the file, if any, will be
truncated before any compressed data is written to it.

=item * A Filehandle

If C<$output> is a filehandle, the file pointer will be positioned to the
end of the file via a call to C<seek> before any compressed data is written
to it.  Otherwise the file pointer will not be moved.

=back

This parameter defaults to 0.

=item C<< Merge => 0|1 >>

This option is used to compress input data and append it to an existing
compressed data stream in C<$output>. The end result is a single compressed
data stream stored in C<$output>. 

It is a fatal error to attempt to use this option when C<$output> is not an
RFC 1952 data stream.

There are a number of other limitations with the C<Merge> option:

=over 5 

=item 1

This module needs to have been built with zlib 1.2.1 or better to work. A
fatal error will be thrown if C<Merge> is used with an older version of
zlib.  

=item 2

If C<$output> is a file or a filehandle, it must be seekable.

=back

This parameter defaults to 0.

=item -Level 

Defines the compression level used by zlib. The value should either be
a number between 0 and 9 (0 means no compression and 9 is maximum
compression), or one of the symbolic constants defined below.

   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION

The default is Z_DEFAULT_COMPRESSION.

Note, these constants are not imported by C<IO::Compress::Gzip> by default.

    use IO::Compress::Gzip qw(:strategy);
    use IO::Compress::Gzip qw(:constants);
    use IO::Compress::Gzip qw(:all);

=item -Strategy 

Defines the strategy used to tune the compression. Use one of the symbolic
constants defined below.

   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY

The default is Z_DEFAULT_STRATEGY.

=item C<< Minimal => 0|1 >>

If specified, this option will force the creation of the smallest possible
compliant gzip header (which is exactly 10 bytes long) as defined in
RFC 1952.

See the section titled "Compliance" in RFC 1952 for a definition 
of the values used for the fields in the gzip header.

All other parameters that control the content of the gzip header will
be ignored if this parameter is set to 1.

This parameter defaults to 0.

=item C<< Comment => $comment >>

Stores the contents of C<$comment> in the COMMENT field in
the gzip header.
By default, no comment field is written to the gzip file.

If the C<-Strict> option is enabled, the comment can only consist of ISO
8859-1 characters plus line feed.

If the C<-Strict> option is disabled, the comment field can contain any
character except NULL. If any null characters are present, the field
will be truncated at the first NULL.

=item C<< Name => $string >>

Stores the contents of C<$string> in the gzip NAME header field. If
C<Name> is not specified, no gzip NAME field will be created.

If the C<-Strict> option is enabled, C<$string> can only consist of ISO
8859-1 characters.

If C<-Strict> is disabled, then C<$string> can contain any character
except NULL. If any null characters are present, the field will be
truncated at the first NULL.

=item C<< Time => $number >>

Sets the MTIME field in the gzip header to $number.

This field defaults to the time the C<IO::Compress::Gzip> object was created
if this option is not specified.

=item C<< TextFlag => 0|1 >>

This parameter controls the setting of the FLG.FTEXT bit in the gzip
header. It is used to signal that the data stored in the gzip file/buffer
is probably text.

The default is 0. 

=item C<< HeaderCRC => 0|1 >>

When true this parameter will set the FLG.FHCRC bit to 1 in the gzip header
and set the CRC16 header field to the CRC of the complete gzip header
except the CRC16 field itself.

B<Note> that gzip files created with the C<HeaderCRC> flag set to 1 cannot
be read by most, if not all, of the standard gunzip utilities, most
notably gzip version 1.2.4. You should therefore avoid using this option if
you want to maximize the portability of your gzip files.

This parameter defaults to 0.

=item C<< OS_Code => $value >>

Stores C<$value> in the gzip OS header field. A number between 0 and 255 is
valid.

If not specified, this parameter defaults to the OS code of the Operating
System this module was built on. The value 3 is used as a catch-all for all
Unix variants and unknown Operating Systems.

=item C<< ExtraField => $data >>

This parameter allows additional metadata to be stored in the ExtraField in
the gzip header. An RFC 1952 compliant ExtraField consists of zero or more
subfields. Each subfield consists of a two byte header followed by the
subfield data.

The list of subfields can be supplied in any of the following formats

    -ExtraField => [$id1, $data1,
                    $id2, $data2,
                     ...
                   ]
    -ExtraField => [ [$id1 => $data1],
                     [$id2 => $data2],
                     ...
                   ]
    -ExtraField => { $id1 => $data1,
                     $id2 => $data2,
                     ...
                   }

Where C<$id1>, C<$id2> are two byte subfield ID's. The second byte of
the ID cannot be 0, unless the C<Strict> option has been disabled.

If you use the hash syntax, you have no control over the order in which
the ExtraSubFields are stored, plus you cannot have SubFields with
duplicate ID.

Alternatively the list of subfields can by supplied as a scalar, thus

    -ExtraField => $rawdata

If you use the raw format, and the C<Strict> option is enabled,
C<IO::Compress::Gzip> will check that C<$rawdata> consists of zero or more
conformant sub-fields. When C<Strict> is disabled, C<$rawdata> can
consist of any arbitrary byte stream.

The maximum size of the Extra Field 65535 bytes.

=item C<< ExtraFlags => $value >>

Sets the XFL byte in the gzip header to C<$value>.

If this option is not present, the value stored in XFL field will be
determined by the setting of the C<Level> option.

If C<< Level => Z_BEST_SPEED >> has been specified then XFL is set to 2.
If C<< Level => Z_BEST_COMPRESSION >> has been specified then XFL is set to 4.
Otherwise XFL is set to 0.

=item C<< Strict => 0|1 >>

C<Strict> will optionally police the values supplied with other options
to ensure they are compliant with RFC1952.

This option is enabled by default.

If C<Strict> is enabled the following behaviour will be policed:

=over 5

=item * 

The value supplied with the C<Name> option can only contain ISO 8859-1
characters.

=item * 

The value supplied with the C<Comment> option can only contain ISO 8859-1
characters plus line-feed.

=item *

The values supplied with the C<-Name> and C<-Comment> options cannot
contain multiple embedded nulls.

=item * 

If an C<ExtraField> option is specified and it is a simple scalar,
it must conform to the sub-field structure as defined in RFC 1952.

=item * 

If an C<ExtraField> option is specified the second byte of the ID will be
checked in each subfield to ensure that it does not contain the reserved
value 0x00.

=back

When C<Strict> is disabled the following behaviour will be policed:

=over 5

=item * 

The value supplied with C<-Name> option can contain
any character except NULL.

=item * 

The value supplied with C<-Comment> option can contain any character
except NULL.

=item *

The values supplied with the C<-Name> and C<-Comment> options can contain
multiple embedded nulls. The string written to the gzip header will
consist of the characters up to, but not including, the first embedded
NULL.

=item * 

If an C<ExtraField> option is specified and it is a simple scalar, the
structure will not be checked. The only error is if the length is too big.

=item * 

The ID header in an C<ExtraField> sub-field can consist of any two bytes.

=back

=back

=head2 Examples

TODO

=head1 Methods 

=head2 print

Usage is

    $z->print($data)
    print $z $data

Compresses and outputs the contents of the C<$data> parameter. This
has the same behaviour as the C<print> built-in.

Returns true if successful.

=head2 printf

Usage is

    $z->printf($format, $data)
    printf $z $format, $data

Compresses and outputs the contents of the C<$data> parameter.

Returns true if successful.

=head2 syswrite

Usage is

    $z->syswrite $data
    $z->syswrite $data, $length
    $z->syswrite $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 write

Usage is

    $z->write $data
    $z->write $data, $length
    $z->write $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 flush

Usage is

    $z->flush;
    $z->flush($flush_type);

Flushes any pending compressed data to the output file/buffer.

This method takes an optional parameter, C<$flush_type>, that controls
how the flushing will be carried out. By default the C<$flush_type>
used is C<Z_FINISH>. Other valid values for C<$flush_type> are
C<Z_NO_FLUSH>, C<Z_SYNC_FLUSH>, C<Z_FULL_FLUSH> and C<Z_BLOCK>. It is
strongly recommended that you only set the C<flush_type> parameter if
you fully understand the implications of what it does - overuse of C<flush>
can seriously degrade the level of compression achieved. See the C<zlib>
documentation for details.

Returns true on success.

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the C<close> method has been called.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the output file/buffer.
It is a fatal error to attempt to seek backward.

Empty parts of the file/buffer will have NULL (0x00) bytes written to them.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

This method always returns C<undef> when compressing. 

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Flushes any pending compressed data and then closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Compress::Gzip object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Compress::Gzip
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 newStream([OPTS])

Usage is

    $z->newStream( [OPTS] )

Closes the current compressed data stream and starts a new one.

OPTS consists of any of the options that are available when creating
the C<$z> object.

See the L</"Constructor Options"> section for more details.

=head2 deflateParams

Usage is

    $z->deflateParams

TODO

=head1 Importing 

A number of symbolic constants are required by some methods in 
C<IO::Compress::Gzip>. None are imported by default.

=over 5

=item :all

Imports C<gzip>, C<$GzipError> and all symbolic
constants that can be used by C<IO::Compress::Gzip>. Same as doing this

    use IO::Compress::Gzip qw(gzip $GzipError :constants) ;

=item :constants

Import all symbolic constants. Same as doing this

    use IO::Compress::Gzip qw(:flush :level :strategy) ;

=item :flush

These symbolic constants are used by the C<flush> method.

    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK

=item :level

These symbolic constants are used by the C<Level> option in the constructor.

    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION

=item :strategy

These symbolic constants are used by the C<Strategy> option in the constructor.

    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY

    
    

=back

=head1 EXAMPLES

=head2 Apache::GZip Revisited

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Apache::GZip Revisited">

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                               usr/share/perl/5.20.2/IO/Compress/RawDeflate.pm                                                     0100644 0000000 0000000 00000062423 12744441327 017343  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::RawDeflate ;

# create RFC1951
#
use strict ;
use warnings;
use bytes;

use IO::Compress::Base 2.064 ;
use IO::Compress::Base::Common  2.064 qw(:Status );
use IO::Compress::Adapter::Deflate 2.064 ;

require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %DEFLATE_CONSTANTS, %EXPORT_TAGS, $RawDeflateError);

$VERSION = '2.064';
$RawDeflateError = '';

@ISA = qw(Exporter IO::Compress::Base);
@EXPORT_OK = qw( $RawDeflateError rawdeflate ) ;
push @EXPORT_OK, @IO::Compress::Adapter::Deflate::EXPORT_OK ;

%EXPORT_TAGS = %IO::Compress::Adapter::Deflate::DEFLATE_CONSTANTS;


{
    my %seen;
    foreach (keys %EXPORT_TAGS )
    {
        push @{$EXPORT_TAGS{constants}}, 
                 grep { !$seen{$_}++ } 
                 @{ $EXPORT_TAGS{$_} }
    }
    $EXPORT_TAGS{all} = $EXPORT_TAGS{constants} ;
}


%DEFLATE_CONSTANTS = %EXPORT_TAGS;

#push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;

Exporter::export_ok_tags('all');
              


sub new
{
    my $class = shift ;

    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$RawDeflateError);

    return $obj->_create(undef, @_);
}

sub rawdeflate
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$RawDeflateError);
    return $obj->_def(@_);
}

sub ckParams
{
    my $self = shift ;
    my $got = shift;

    return 1 ;
}

sub mkComp
{
    my $self = shift ;
    my $got = shift ;

    my ($obj, $errstr, $errno) = IO::Compress::Adapter::Deflate::mkCompObject(
                                                 $got->getValue('crc32'),
                                                 $got->getValue('adler32'),
                                                 $got->getValue('level'),
                                                 $got->getValue('strategy')
                                                 );

   return $self->saveErrorString(undef, $errstr, $errno)
       if ! defined $obj;

   return $obj;    
}


sub mkHeader
{
    my $self = shift ;
    return '';
}

sub mkTrailer
{
    my $self = shift ;
    return '';
}

sub mkFinalTrailer
{
    return '';
}


#sub newHeader
#{
#    my $self = shift ;
#    return '';
#}

sub getExtraParams
{
    my $self = shift ;
    return getZlibParams();
}

use IO::Compress::Base::Common  2.064 qw(:Parse);
use Compress::Raw::Zlib  2.064 qw(Z_DEFLATED Z_DEFAULT_COMPRESSION Z_DEFAULT_STRATEGY);
our %PARAMS = (
            #'method'   => [IO::Compress::Base::Common::Parse_unsigned,  Z_DEFLATED],
            'level'     => [IO::Compress::Base::Common::Parse_signed,    Z_DEFAULT_COMPRESSION],
            'strategy'  => [IO::Compress::Base::Common::Parse_signed,    Z_DEFAULT_STRATEGY],

            'crc32'     => [IO::Compress::Base::Common::Parse_boolean,   0],
            'adler32'   => [IO::Compress::Base::Common::Parse_boolean,   0],
            'merge'     => [IO::Compress::Base::Common::Parse_boolean,   0], 
        );
        
sub getZlibParams
{
    return %PARAMS;    
}

sub getInverseClass
{
    return ('IO::Uncompress::RawInflate', 
                \$IO::Uncompress::RawInflate::RawInflateError);
}

sub getFileInfo
{
    my $self = shift ;
    my $params = shift;
    my $file = shift ;
    
}

use IO::Seekable qw(SEEK_SET);

sub createMerge
{
    my $self = shift ;
    my $outValue = shift ;
    my $outType = shift ;

    my ($invClass, $error_ref) = $self->getInverseClass();
    eval "require $invClass" 
        or die "aaaahhhh" ;

    my $inf = $invClass->new( $outValue, 
                             Transparent => 0, 
                             #Strict     => 1,
                             AutoClose   => 0,
                             Scan        => 1)
       or return $self->saveErrorString(undef, "Cannot create InflateScan object: $$error_ref" ) ;

    my $end_offset = 0;
    $inf->scan() 
        or return $self->saveErrorString(undef, "Error Scanning: $$error_ref", $inf->errorNo) ;
    $inf->zap($end_offset) 
        or return $self->saveErrorString(undef, "Error Zapping: $$error_ref", $inf->errorNo) ;

    my $def = *$self->{Compress} = $inf->createDeflate();

    *$self->{Header} = *$inf->{Info}{Header};
    *$self->{UnCompSize} = *$inf->{UnCompSize}->clone();
    *$self->{CompSize} = *$inf->{CompSize}->clone();
    # TODO -- fix this
    #*$self->{CompSize} = new U64(0, *$self->{UnCompSize_32bit});


    if ( $outType eq 'buffer') 
      { substr( ${ *$self->{Buffer} }, $end_offset) = '' }
    elsif ($outType eq 'handle' || $outType eq 'filename') {
        *$self->{FH} = *$inf->{FH} ;
        delete *$inf->{FH};
        *$self->{FH}->flush() ;
        *$self->{Handle} = 1 if $outType eq 'handle';

        #seek(*$self->{FH}, $end_offset, SEEK_SET) 
        *$self->{FH}->seek($end_offset, SEEK_SET) 
            or return $self->saveErrorString(undef, $!, $!) ;
    }

    return $def ;
}

#### zlib specific methods

sub deflateParams 
{
    my $self = shift ;

    my $level = shift ;
    my $strategy = shift ;

    my $status = *$self->{Compress}->deflateParams(Level => $level, Strategy => $strategy) ;
    return $self->saveErrorString(0, *$self->{Compress}{Error}, *$self->{Compress}{ErrorNo})
        if $status == STATUS_ERROR;

    return 1;    
}




1;

__END__

=head1 NAME

IO::Compress::RawDeflate - Write RFC 1951 files/buffers
 
 

=head1 SYNOPSIS

    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    my $status = rawdeflate $input => $output [,OPTS] 
        or die "rawdeflate failed: $RawDeflateError\n";

    my $z = new IO::Compress::RawDeflate $output [,OPTS]
        or die "rawdeflate failed: $RawDeflateError\n";

    $z->print($string);
    $z->printf($format, $string);
    $z->write($string);
    $z->syswrite($string [, $length, $offset]);
    $z->flush();
    $z->tell();
    $z->eof();
    $z->seek($position, $whence);
    $z->binmode();
    $z->fileno();
    $z->opened();
    $z->autoflush();
    $z->input_line_number();
    $z->newStream( [OPTS] );
    
    $z->deflateParams();
    
    $z->close() ;

    $RawDeflateError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
    

=head1 DESCRIPTION

This module provides a Perl interface that allows writing compressed
data to files or buffer as defined in RFC 1951.

Note that RFC 1951 data is not a good choice of compression format
to use in isolation, especially if you want to auto-detect it.

For reading RFC 1951 files/buffers, see the companion module 
L<IO::Uncompress::RawInflate|IO::Uncompress::RawInflate>.

=head1 Functional Interface

A top-level function, C<rawdeflate>, is provided to carry out
"one-shot" compression between buffers and/or files. For finer
control over the compression process, see the L</"OO Interface">
section.

    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    rawdeflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "rawdeflate failed: $RawDeflateError\n";

The functional interface needs Perl5.005 or better.

=head2 rawdeflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<rawdeflate> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the uncompressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is compressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<rawdeflate> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the compressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
compressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
compressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
compressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the compressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<rawdeflate> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple files/buffers and
C<$output_filename_or_reference> is a single
file/buffer the input files/buffers will be stored
in C<$output_filename_or_reference> as a concatenated series of compressed data streams.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<rawdeflate>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<rawdeflate> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<rawdeflate> has
completed.

This parameter defaults to 0.

=item C<< BinModeIn => 0|1 >>

When reading from a file or filehandle, set C<binmode> before reading.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all compressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
compressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any compressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any compressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all compressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any compressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all compressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any compressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any compressed data is output.

Defaults to 0.

=back

=head2 Examples

To read the contents of the file C<file1.txt> and write the compressed
data to the file C<file1.txt.1951>.

    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    my $input = "file1.txt";
    rawdeflate $input => "$input.1951"
        or die "rawdeflate failed: $RawDeflateError\n";

To read from an existing Perl filehandle, C<$input>, and write the
compressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt"
        or die "Cannot open 'file1.txt': $!\n" ;
    my $buffer ;
    rawdeflate $input => \$buffer 
        or die "rawdeflate failed: $RawDeflateError\n";

To compress all files in the directory "/my/home" that match "*.txt"
and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    rawdeflate '</my/home/*.txt>' => '<*.1951>'
        or die "rawdeflate failed: $RawDeflateError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError) ;

    for my $input ( glob "/my/home/*.txt" )
    {
        my $output = "$input.1951" ;
        rawdeflate $input => $output 
            or die "Error compressing '$input': $RawDeflateError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for C<IO::Compress::RawDeflate> is shown below

    my $z = new IO::Compress::RawDeflate $output [,OPTS]
        or die "IO::Compress::RawDeflate failed: $RawDeflateError\n";

It returns an C<IO::Compress::RawDeflate> object on success and undef on failure. 
The variable C<$RawDeflateError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from 
IO::Compress::RawDeflate can be used exactly like an L<IO::File|IO::File> filehandle. 
This means that all normal output file operations can be carried out 
with C<$z>. 
For example, to write to a compressed file/buffer you can use either of 
these forms

    $z->print("hello world\n");
    print $z "hello world\n";

The mandatory parameter C<$output> is used to control the destination
of the compressed data. This parameter can take one of these forms.

=over 5

=item A filename

If the C<$output> parameter is a simple scalar, it is assumed to be a
filename. This file will be opened for writing and the compressed data
will be written to it.

=item A filehandle

If the C<$output> parameter is a filehandle, the compressed data will be
written to it.
The string '-' can be used as an alias for standard output.

=item A scalar reference 

If C<$output> is a scalar reference, the compressed data will be stored
in C<$$output>.

=back

If the C<$output> parameter is any other type, C<IO::Compress::RawDeflate>::new will
return undef.

=head2 Constructor Options

C<OPTS> is any combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$output> parameter is a filehandle. If
specified, and the value is true, it will result in the C<$output> being
closed once either the C<close> method is called or the C<IO::Compress::RawDeflate>
object is destroyed.

This parameter defaults to 0.

=item C<< Append => 0|1 >>

Opens C<$output> in append mode. 

The behaviour of this option is dependent on the type of C<$output>.

=over 5

=item * A Buffer

If C<$output> is a buffer and C<Append> is enabled, all compressed data
will be append to the end of C<$output>. Otherwise C<$output> will be
cleared before any data is written to it.

=item * A Filename

If C<$output> is a filename and C<Append> is enabled, the file will be
opened in append mode. Otherwise the contents of the file, if any, will be
truncated before any compressed data is written to it.

=item * A Filehandle

If C<$output> is a filehandle, the file pointer will be positioned to the
end of the file via a call to C<seek> before any compressed data is written
to it.  Otherwise the file pointer will not be moved.

=back

This parameter defaults to 0.

=item C<< Merge => 0|1 >>

This option is used to compress input data and append it to an existing
compressed data stream in C<$output>. The end result is a single compressed
data stream stored in C<$output>. 

It is a fatal error to attempt to use this option when C<$output> is not an
RFC 1951 data stream.

There are a number of other limitations with the C<Merge> option:

=over 5 

=item 1

This module needs to have been built with zlib 1.2.1 or better to work. A
fatal error will be thrown if C<Merge> is used with an older version of
zlib.  

=item 2

If C<$output> is a file or a filehandle, it must be seekable.

=back

This parameter defaults to 0.

=item -Level 

Defines the compression level used by zlib. The value should either be
a number between 0 and 9 (0 means no compression and 9 is maximum
compression), or one of the symbolic constants defined below.

   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION

The default is Z_DEFAULT_COMPRESSION.

Note, these constants are not imported by C<IO::Compress::RawDeflate> by default.

    use IO::Compress::RawDeflate qw(:strategy);
    use IO::Compress::RawDeflate qw(:constants);
    use IO::Compress::RawDeflate qw(:all);

=item -Strategy 

Defines the strategy used to tune the compression. Use one of the symbolic
constants defined below.

   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY

The default is Z_DEFAULT_STRATEGY.

=item C<< Strict => 0|1 >>

This is a placeholder option.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 print

Usage is

    $z->print($data)
    print $z $data

Compresses and outputs the contents of the C<$data> parameter. This
has the same behaviour as the C<print> built-in.

Returns true if successful.

=head2 printf

Usage is

    $z->printf($format, $data)
    printf $z $format, $data

Compresses and outputs the contents of the C<$data> parameter.

Returns true if successful.

=head2 syswrite

Usage is

    $z->syswrite $data
    $z->syswrite $data, $length
    $z->syswrite $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 write

Usage is

    $z->write $data
    $z->write $data, $length
    $z->write $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 flush

Usage is

    $z->flush;
    $z->flush($flush_type);

Flushes any pending compressed data to the output file/buffer.

This method takes an optional parameter, C<$flush_type>, that controls
how the flushing will be carried out. By default the C<$flush_type>
used is C<Z_FINISH>. Other valid values for C<$flush_type> are
C<Z_NO_FLUSH>, C<Z_SYNC_FLUSH>, C<Z_FULL_FLUSH> and C<Z_BLOCK>. It is
strongly recommended that you only set the C<flush_type> parameter if
you fully understand the implications of what it does - overuse of C<flush>
can seriously degrade the level of compression achieved. See the C<zlib>
documentation for details.

Returns true on success.

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the C<close> method has been called.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the output file/buffer.
It is a fatal error to attempt to seek backward.

Empty parts of the file/buffer will have NULL (0x00) bytes written to them.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

This method always returns C<undef> when compressing. 

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Flushes any pending compressed data and then closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Compress::RawDeflate object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Compress::RawDeflate
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 newStream([OPTS])

Usage is

    $z->newStream( [OPTS] )

Closes the current compressed data stream and starts a new one.

OPTS consists of any of the options that are available when creating
the C<$z> object.

See the L</"Constructor Options"> section for more details.

=head2 deflateParams

Usage is

    $z->deflateParams

TODO

=head1 Importing 

A number of symbolic constants are required by some methods in 
C<IO::Compress::RawDeflate>. None are imported by default.

=over 5

=item :all

Imports C<rawdeflate>, C<$RawDeflateError> and all symbolic
constants that can be used by C<IO::Compress::RawDeflate>. Same as doing this

    use IO::Compress::RawDeflate qw(rawdeflate $RawDeflateError :constants) ;

=item :constants

Import all symbolic constants. Same as doing this

    use IO::Compress::RawDeflate qw(:flush :level :strategy) ;

=item :flush

These symbolic constants are used by the C<flush> method.

    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK

=item :level

These symbolic constants are used by the C<Level> option in the constructor.

    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION

=item :strategy

These symbolic constants are used by the C<Strategy> option in the constructor.

    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY

    
    

=back

=head1 EXAMPLES

=head2 Apache::GZip Revisited

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Apache::GZip Revisited">

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                             usr/share/perl/5.20.2/IO/Compress/Zip/                                                              0040755 0000000 0000000 00000000000 13077704254 015526  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IO/Compress/Zip/Constants.pm                                                  0100644 0000000 0000000 00000007410 12744441327 020036  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Zip::Constants;

use strict ;
use warnings;

require Exporter;

our ($VERSION, @ISA, @EXPORT, %ZIP_CM_MIN_VERSIONS);

$VERSION = '2.064';

@ISA = qw(Exporter);

@EXPORT= qw(

    ZIP_CM_STORE
    ZIP_CM_DEFLATE
    ZIP_CM_BZIP2
    ZIP_CM_LZMA
    ZIP_CM_PPMD
    
    ZIP_LOCAL_HDR_SIG
    ZIP_DATA_HDR_SIG
    ZIP_CENTRAL_HDR_SIG
    ZIP_END_CENTRAL_HDR_SIG
    ZIP64_END_CENTRAL_REC_HDR_SIG
    ZIP64_END_CENTRAL_LOC_HDR_SIG
    ZIP64_ARCHIVE_EXTRA_SIG
    ZIP64_DIGITAL_SIGNATURE_SIG

    ZIP_GP_FLAG_ENCRYPTED_MASK
    ZIP_GP_FLAG_STREAMING_MASK
    ZIP_GP_FLAG_PATCHED_MASK
    ZIP_GP_FLAG_STRONG_ENCRYPTED_MASK
    ZIP_GP_FLAG_LZMA_EOS_PRESENT
    ZIP_GP_FLAG_LANGUAGE_ENCODING

    ZIP_EXTRA_ID_ZIP64
    ZIP_EXTRA_ID_EXT_TIMESTAMP
    ZIP_EXTRA_ID_INFO_ZIP_UNIX2
    ZIP_EXTRA_ID_INFO_ZIP_UNIXN
    ZIP_EXTRA_ID_INFO_ZIP_Upath
    ZIP_EXTRA_ID_INFO_ZIP_Ucom        
    ZIP_EXTRA_ID_JAVA_EXE

    ZIP_OS_CODE_UNIX
    ZIP_OS_CODE_DEFAULT

    ZIP_IFA_TEXT_MASK

    %ZIP_CM_MIN_VERSIONS
    ZIP64_MIN_VERSION

    ZIP_A_RONLY
    ZIP_A_HIDDEN
    ZIP_A_SYSTEM
    ZIP_A_LABEL
    ZIP_A_DIR 
    ZIP_A_ARCHIVE
    );

# Compression types supported
use constant ZIP_CM_STORE                      => 0 ;
use constant ZIP_CM_DEFLATE                    => 8 ;
use constant ZIP_CM_BZIP2                      => 12 ;
use constant ZIP_CM_LZMA                       => 14 ; # Not Supported yet
use constant ZIP_CM_PPMD                       => 98 ; # Not Supported yet

# General Purpose Flag
use constant ZIP_GP_FLAG_ENCRYPTED_MASK        => (1 << 0) ;
use constant ZIP_GP_FLAG_STREAMING_MASK        => (1 << 3) ;
use constant ZIP_GP_FLAG_PATCHED_MASK          => (1 << 5) ;
use constant ZIP_GP_FLAG_STRONG_ENCRYPTED_MASK => (1 << 6) ;
use constant ZIP_GP_FLAG_LZMA_EOS_PRESENT      => (1 << 1) ;
use constant ZIP_GP_FLAG_LANGUAGE_ENCODING     => (1 << 11) ;

# Internal File Attributes
use constant ZIP_IFA_TEXT_MASK                 => 1;

# Signatures for each of the headers
use constant ZIP_LOCAL_HDR_SIG                 => 0x04034b50;
use constant ZIP_DATA_HDR_SIG                  => 0x08074b50;
use constant packed_ZIP_DATA_HDR_SIG           => pack "V", ZIP_DATA_HDR_SIG;
use constant ZIP_CENTRAL_HDR_SIG               => 0x02014b50;
use constant ZIP_END_CENTRAL_HDR_SIG           => 0x06054b50;
use constant ZIP64_END_CENTRAL_REC_HDR_SIG     => 0x06064b50;
use constant ZIP64_END_CENTRAL_LOC_HDR_SIG     => 0x07064b50;
use constant ZIP64_ARCHIVE_EXTRA_SIG           => 0x08064b50;
use constant ZIP64_DIGITAL_SIGNATURE_SIG       => 0x05054b50;

use constant ZIP_OS_CODE_UNIX                  => 3;
use constant ZIP_OS_CODE_DEFAULT               => 3;

# Extra Field ID's
use constant ZIP_EXTRA_ID_ZIP64                => pack "v", 1;
use constant ZIP_EXTRA_ID_EXT_TIMESTAMP        => "UT";
use constant ZIP_EXTRA_ID_INFO_ZIP_UNIX2       => "Ux";
use constant ZIP_EXTRA_ID_INFO_ZIP_UNIXN       => "ux";
use constant ZIP_EXTRA_ID_INFO_ZIP_Upath       => "up";
use constant ZIP_EXTRA_ID_INFO_ZIP_Ucom        => "uc";
use constant ZIP_EXTRA_ID_JAVA_EXE             => pack "v", 0xCAFE;

# DOS Attributes
use constant ZIP_A_RONLY                       => 0x01;
use constant ZIP_A_HIDDEN                      => 0x02;
use constant ZIP_A_SYSTEM                      => 0x04;
use constant ZIP_A_LABEL                       => 0x08;
use constant ZIP_A_DIR                         => 0x10;
use constant ZIP_A_ARCHIVE                     => 0x20;

use constant ZIP64_MIN_VERSION                 => 45;

%ZIP_CM_MIN_VERSIONS = (
            ZIP_CM_STORE()                     => 20,
            ZIP_CM_DEFLATE()                   => 20,
            ZIP_CM_BZIP2()                     => 46,
            ZIP_CM_LZMA()                      => 63,
            ZIP_CM_PPMD()                      => 63,
            );


1;

__END__

                                                                                                                                                                                                                                                        usr/share/perl/5.20.2/IO/Compress/Zip.pm                                                            0100644 0000000 0000000 00000161364 12744441327 016073  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Zip ;

use strict ;
use warnings;
use bytes;

use IO::Compress::Base::Common  2.064 qw(:Status );
use IO::Compress::RawDeflate 2.064 ();
use IO::Compress::Adapter::Deflate 2.064 ;
use IO::Compress::Adapter::Identity 2.064 ;
use IO::Compress::Zlib::Extra 2.064 ;
use IO::Compress::Zip::Constants 2.064 ;

use File::Spec();
use Config;

use Compress::Raw::Zlib  2.064 (); 

BEGIN
{
    eval { require IO::Compress::Adapter::Bzip2 ; 
           import  IO::Compress::Adapter::Bzip2 2.064 ; 
           require IO::Compress::Bzip2 ; 
           import  IO::Compress::Bzip2 2.064 ; 
         } ;
         
    eval { require IO::Compress::Adapter::Lzma ; 
           import  IO::Compress::Adapter::Lzma 2.064 ; 
           require IO::Compress::Lzma ; 
           import  IO::Compress::Lzma 2.064 ; 
         } ;
}


require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $ZipError);

$VERSION = '2.064';
$ZipError = '';

@ISA = qw(Exporter IO::Compress::RawDeflate);
@EXPORT_OK = qw( $ZipError zip ) ;
%EXPORT_TAGS = %IO::Compress::RawDeflate::DEFLATE_CONSTANTS ;

push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;

$EXPORT_TAGS{zip_method} = [qw( ZIP_CM_STORE ZIP_CM_DEFLATE ZIP_CM_BZIP2 ZIP_CM_LZMA)];
push @{ $EXPORT_TAGS{all} }, @{ $EXPORT_TAGS{zip_method} };

Exporter::export_ok_tags('all');

sub new
{
    my $class = shift ;

    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$ZipError);    
    $obj->_create(undef, @_);

}

sub zip
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$ZipError);    
    return $obj->_def(@_);
}

sub isMethodAvailable
{
    my $method = shift;
    
    # Store & Deflate are always available
    return 1
        if $method == ZIP_CM_STORE || $method == ZIP_CM_DEFLATE ;
        
    return 1 
        if $method == ZIP_CM_BZIP2 and 
           defined $IO::Compress::Adapter::Bzip2::VERSION;
           
    return 1
        if $method == ZIP_CM_LZMA and
           defined $IO::Compress::Adapter::Lzma::VERSION;
           
    return 0;       
}

sub beforePayload
{
    my $self = shift ;

    if (*$self->{ZipData}{Sparse} ) {
        my $inc = 1024 * 100 ;
        my $NULLS = ("\x00" x $inc) ;
        my $sparse = *$self->{ZipData}{Sparse} ;
        *$self->{CompSize}->add( $sparse );
        *$self->{UnCompSize}->add( $sparse );
        
        *$self->{FH}->seek($sparse, IO::Handle::SEEK_CUR);
        
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32($NULLS, *$self->{ZipData}{CRC32})
            for 1 .. int $sparse / $inc;
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(substr($NULLS, 0,  $sparse % $inc), 
                                         *$self->{ZipData}{CRC32})
            if $sparse % $inc;
    }
}

sub mkComp
{
    my $self = shift ;
    my $got = shift ;

    my ($obj, $errstr, $errno) ;

    if (*$self->{ZipData}{Method} == ZIP_CM_STORE) {
        ($obj, $errstr, $errno) = IO::Compress::Adapter::Identity::mkCompObject(
                                                 $got->getValue('level'),
                                                 $got->getValue('strategy')
                                                 );
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(undef);
    }
    elsif (*$self->{ZipData}{Method} == ZIP_CM_DEFLATE) {
        ($obj, $errstr, $errno) = IO::Compress::Adapter::Deflate::mkCompObject(
                                                 $got->getValue('crc32'),
                                                 $got->getValue('adler32'),
                                                 $got->getValue('level'),
                                                 $got->getValue('strategy')
                                                 );
    }
    elsif (*$self->{ZipData}{Method} == ZIP_CM_BZIP2) {
        ($obj, $errstr, $errno) = IO::Compress::Adapter::Bzip2::mkCompObject(
                                                $got->getValue('blocksize100k'),
                                                $got->getValue('workfactor'),
                                                $got->getValue('verbosity')
                                               );
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(undef);
    }
    elsif (*$self->{ZipData}{Method} == ZIP_CM_LZMA) {
        ($obj, $errstr, $errno) = IO::Compress::Adapter::Lzma::mkRawZipCompObject($got->getValue('preset'),
                                                                                 $got->getValue('extreme'),
                                                                                 );
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(undef);
    }

    return $self->saveErrorString(undef, $errstr, $errno)
       if ! defined $obj;

    if (! defined *$self->{ZipData}{SizesOffset}) {
        *$self->{ZipData}{SizesOffset} = 0;
        *$self->{ZipData}{Offset} = new U64 ;
    }

    *$self->{ZipData}{AnyZip64} = 0
        if ! defined  *$self->{ZipData}{AnyZip64} ;

    return $obj;    
}

sub reset
{
    my $self = shift ;

    *$self->{Compress}->reset();
    *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32('');

    return STATUS_OK;    
}

sub filterUncompressed
{
    my $self = shift ;

    if (*$self->{ZipData}{Method} == ZIP_CM_DEFLATE) {
        *$self->{ZipData}{CRC32} = *$self->{Compress}->crc32();
    }
    else {
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(${$_[0]}, *$self->{ZipData}{CRC32});

    }
}

sub canonicalName
{
    # This sub is derived from Archive::Zip::_asZipDirName

    # Return the normalized name as used in a zip file (path
    # separators become slashes, etc.).
    # Will translate internal slashes in path components (i.e. on Macs) to
    # underscores.  Discards volume names.
    # When $forceDir is set, returns paths with trailing slashes 
    #
    # input         output
    # .             '.'
    # ./a           a
    # ./a/b         a/b
    # ./a/b/        a/b
    # a/b/          a/b
    # /a/b/         a/b
    # c:\a\b\c.doc  a/b/c.doc      # on Windows
    # "i/o maps:whatever"   i_o maps/whatever   # on Macs

    my $name      = shift;
    my $forceDir  = shift ;

    my ( $volume, $directories, $file ) =
      File::Spec->splitpath( File::Spec->canonpath($name), $forceDir );
      
    my @dirs = map { $_ =~ s{/}{_}g; $_ } 
               File::Spec->splitdir($directories);

    if ( @dirs > 0 ) { pop (@dirs) if $dirs[-1] eq '' }   # remove empty component
    push @dirs, defined($file) ? $file : '' ;

    my $normalised_path = join '/', @dirs;

    # Leading directory separators should not be stored in zip archives.
    # Example:
    #   C:\a\b\c\      a/b/c
    #   C:\a\b\c.txt   a/b/c.txt
    #   /a/b/c/        a/b/c
    #   /a/b/c.txt     a/b/c.txt
    $normalised_path =~ s{^/}{};  # remove leading separator

    return $normalised_path;
}


sub mkHeader
{
    my $self  = shift;
    my $param = shift ;
    
    *$self->{ZipData}{LocalHdrOffset} = U64::clone(*$self->{ZipData}{Offset});
        
    my $comment = '';
    $comment = $param->valueOrDefault('comment') ;

    my $filename = '';
    $filename = $param->valueOrDefault('name') ;

    $filename = canonicalName($filename)
        if length $filename && $param->getValue('canonicalname') ;

    if (defined *$self->{ZipData}{FilterName} ) {
        local *_ = \$filename ;
        &{ *$self->{ZipData}{FilterName} }() ;
    }

#    if ( $param->getValue('utf8') ) {
#        require Encode ;
#        $filename = Encode::encode_utf8($filename)
#            if length $filename ;
#        $comment = Encode::encode_utf8($comment)
#            if length $comment ;
#    }

    my $hdr = '';

    my $time = _unixToDosTime($param->getValue('time'));

    my $extra = '';
    my $ctlExtra = '';
    my $empty = 0;
    my $osCode = $param->getValue('os_code') ;
    my $extFileAttr = 0 ;
    
    # This code assumes Unix.
    # TODO - revisit this
    $extFileAttr = 0100644 << 16 
        if $osCode == ZIP_OS_CODE_UNIX ;

    if (*$self->{ZipData}{Zip64}) {
        $empty = IO::Compress::Base::Common::MAX32;

        my $x = '';
        $x .= pack "V V", 0, 0 ; # uncompressedLength   
        $x .= pack "V V", 0, 0 ; # compressedLength   
        $extra .= IO::Compress::Zlib::Extra::mkSubField(ZIP_EXTRA_ID_ZIP64, $x);
    }

    if (! $param->getValue('minimal')) {
        if ($param->parsed('mtime'))
        {
            $extra .= mkExtendedTime($param->getValue('mtime'), 
                                    $param->getValue('atime'), 
                                    $param->getValue('ctime'));

            $ctlExtra .= mkExtendedTime($param->getValue('mtime'));
        }

        if ( $osCode == ZIP_OS_CODE_UNIX )
        {
            if ( $param->getValue('want_exunixn') )
            {
                    my $ux3 = mkUnixNExtra( @{ $param->getValue('want_exunixn') }); 
                    $extra    .= $ux3;
                    $ctlExtra .= $ux3;
            }

            if ( $param->getValue('exunix2') )
            {
                    $extra    .= mkUnix2Extra( @{ $param->getValue('exunix2') }); 
                    $ctlExtra .= mkUnix2Extra();
            }
        }

        $extFileAttr = $param->getValue('extattr') 
            if defined $param->getValue('extattr') ;

        $extra .= $param->getValue('extrafieldlocal') 
            if defined $param->getValue('extrafieldlocal');

        $ctlExtra .= $param->getValue('extrafieldcentral') 
            if defined $param->getValue('extrafieldcentral');
    }

    my $method = *$self->{ZipData}{Method} ;
    my $gpFlag = 0 ;    
    $gpFlag |= ZIP_GP_FLAG_STREAMING_MASK
        if *$self->{ZipData}{Stream} ;

    $gpFlag |= ZIP_GP_FLAG_LZMA_EOS_PRESENT
        if $method == ZIP_CM_LZMA ;

#    $gpFlag |= ZIP_GP_FLAG_LANGUAGE_ENCODING
#        if  $param->getValue('utf8') && (length($filename) || length($comment));

    my $version = $ZIP_CM_MIN_VERSIONS{$method};
    $version = ZIP64_MIN_VERSION
        if ZIP64_MIN_VERSION > $version && *$self->{ZipData}{Zip64};

    my $madeBy = ($param->getValue('os_code') << 8) + $version;
    my $extract = $version;

    *$self->{ZipData}{Version} = $version;
    *$self->{ZipData}{MadeBy} = $madeBy;

    my $ifa = 0;
    $ifa |= ZIP_IFA_TEXT_MASK
        if $param->getValue('textflag');

    $hdr .= pack "V", ZIP_LOCAL_HDR_SIG ; # signature
    $hdr .= pack 'v', $extract   ; # extract Version & OS
    $hdr .= pack 'v', $gpFlag    ; # general purpose flag (set streaming mode)
    $hdr .= pack 'v', $method    ; # compression method (deflate)
    $hdr .= pack 'V', $time      ; # last mod date/time
    $hdr .= pack 'V', 0          ; # crc32               - 0 when streaming
    $hdr .= pack 'V', $empty     ; # compressed length   - 0 when streaming
    $hdr .= pack 'V', $empty     ; # uncompressed length - 0 when streaming
    $hdr .= pack 'v', length $filename ; # filename length
    $hdr .= pack 'v', length $extra ; # extra length
    
    $hdr .= $filename ;

    # Remember the offset for the compressed & uncompressed lengths in the
    # local header.
    if (*$self->{ZipData}{Zip64}) {
        *$self->{ZipData}{SizesOffset} = *$self->{ZipData}{Offset}->get64bit()
            + length($hdr) + 4 ;
    }
    else {
        *$self->{ZipData}{SizesOffset} = *$self->{ZipData}{Offset}->get64bit()
                                            + 18;
    }

    $hdr .= $extra ;


    my $ctl = '';

    $ctl .= pack "V", ZIP_CENTRAL_HDR_SIG ; # signature
    $ctl .= pack 'v', $madeBy    ; # version made by
    $ctl .= pack 'v', $extract   ; # extract Version
    $ctl .= pack 'v', $gpFlag    ; # general purpose flag (streaming mode)
    $ctl .= pack 'v', $method    ; # compression method (deflate)
    $ctl .= pack 'V', $time      ; # last mod date/time
    $ctl .= pack 'V', 0          ; # crc32
    $ctl .= pack 'V', $empty     ; # compressed length
    $ctl .= pack 'V', $empty     ; # uncompressed length
    $ctl .= pack 'v', length $filename ; # filename length

    *$self->{ZipData}{ExtraOffset} = length $ctl;
    *$self->{ZipData}{ExtraSize} = length $ctlExtra ;

    $ctl .= pack 'v', length $ctlExtra ; # extra length
    $ctl .= pack 'v', length $comment ;  # file comment length
    $ctl .= pack 'v', 0          ; # disk number start 
    $ctl .= pack 'v', $ifa       ; # internal file attributes
    $ctl .= pack 'V', $extFileAttr   ; # external file attributes

    # offset to local hdr
    if (*$self->{ZipData}{LocalHdrOffset}->is64bit() ) { 
        $ctl .= pack 'V', IO::Compress::Base::Common::MAX32 ;
    }
    else {
        $ctl .= *$self->{ZipData}{LocalHdrOffset}->getPacked_V32() ; 
    }
    
    $ctl .= $filename ;
    $ctl .= $ctlExtra ;
    $ctl .= $comment ;

    *$self->{ZipData}{Offset}->add32(length $hdr) ;

    *$self->{ZipData}{CentralHeader} = $ctl;


    return $hdr;
}

sub mkTrailer
{
    my $self = shift ;

    my $crc32 ;
    if (*$self->{ZipData}{Method} == ZIP_CM_DEFLATE) {
        $crc32 = pack "V", *$self->{Compress}->crc32();
    }
    else {
        $crc32 = pack "V", *$self->{ZipData}{CRC32};
    }

    my $ctl = *$self->{ZipData}{CentralHeader} ;

    my $sizes ;
    if (! *$self->{ZipData}{Zip64}) {
        $sizes .= *$self->{CompSize}->getPacked_V32() ;   # Compressed size
        $sizes .= *$self->{UnCompSize}->getPacked_V32() ; # Uncompressed size
    }
    else {
        $sizes .= *$self->{CompSize}->getPacked_V64() ;   # Compressed size
        $sizes .= *$self->{UnCompSize}->getPacked_V64() ; # Uncompressed size
    }

    my $data = $crc32 . $sizes ;


    my $xtrasize  = *$self->{UnCompSize}->getPacked_V64() ; # Uncompressed size
       $xtrasize .= *$self->{CompSize}->getPacked_V64() ;   # Compressed size

    my $hdr = '';

    if (*$self->{ZipData}{Stream}) {
        $hdr  = pack "V", ZIP_DATA_HDR_SIG ;                       # signature
        $hdr .= $data ;
    }
    else {
        $self->writeAt(*$self->{ZipData}{LocalHdrOffset}->get64bit() + 14,  $crc32)
            or return undef;
        $self->writeAt(*$self->{ZipData}{SizesOffset}, 
                *$self->{ZipData}{Zip64} ? $xtrasize : $sizes)
            or return undef;
    }

    # Central Header Record/Zip64 extended field

    substr($ctl, 16, length $crc32) = $crc32 ;

    my $x = '';

    # uncompressed length
    if (*$self->{UnCompSize}->isAlmost64bit() || *$self->{ZipData}{Zip64} > 1) {
        $x .= *$self->{UnCompSize}->getPacked_V64() ; 
    } else {
        substr($ctl, 24, 4) = *$self->{UnCompSize}->getPacked_V32() ;
    }

    # compressed length
    if (*$self->{CompSize}->isAlmost64bit() || *$self->{ZipData}{Zip64} > 1) {
        $x .= *$self->{CompSize}->getPacked_V64() ; 
    } else {
        substr($ctl, 20, 4) = *$self->{CompSize}->getPacked_V32() ;
    }

    # Local Header offset
    $x .= *$self->{ZipData}{LocalHdrOffset}->getPacked_V64()
        if *$self->{ZipData}{LocalHdrOffset}->is64bit() ; 

    # disk no - always zero, so don't need it
    #$x .= pack "V", 0    ; 

    if (length $x) {
        my $xtra = IO::Compress::Zlib::Extra::mkSubField(ZIP_EXTRA_ID_ZIP64, $x);
        $ctl .= $xtra ;
        substr($ctl, *$self->{ZipData}{ExtraOffset}, 2) = 
             pack 'v', *$self->{ZipData}{ExtraSize} + length $xtra;

        *$self->{ZipData}{AnyZip64} = 1;
    }

    *$self->{ZipData}{Offset}->add32(length($hdr));
    *$self->{ZipData}{Offset}->add( *$self->{CompSize} );
    push @{ *$self->{ZipData}{CentralDir} }, $ctl ;

    return $hdr;
}

sub mkFinalTrailer
{
    my $self = shift ;
        
    my $comment = '';
    $comment = *$self->{ZipData}{ZipComment} ;

    my $cd_offset = *$self->{ZipData}{Offset}->get32bit() ; # offset to start central dir

    my $entries = @{ *$self->{ZipData}{CentralDir} };
    
    *$self->{ZipData}{AnyZip64} = 1 
        if *$self->{ZipData}{Offset}->is64bit || $entries >= 0xFFFF ;      
           
    my $cd = join '', @{ *$self->{ZipData}{CentralDir} };
    my $cd_len = length $cd ;

    my $z64e = '';

    if ( *$self->{ZipData}{AnyZip64} ) {

        my $v  = *$self->{ZipData}{Version} ;
        my $mb = *$self->{ZipData}{MadeBy} ;
        $z64e .= pack 'v', $mb            ; # Version made by
        $z64e .= pack 'v', $v             ; # Version to extract
        $z64e .= pack 'V', 0              ; # number of disk
        $z64e .= pack 'V', 0              ; # number of disk with central dir
        $z64e .= U64::pack_V64 $entries   ; # entries in central dir on this disk
        $z64e .= U64::pack_V64 $entries   ; # entries in central dir
        $z64e .= U64::pack_V64 $cd_len    ; # size of central dir
        $z64e .= *$self->{ZipData}{Offset}->getPacked_V64() ; # offset to start central dir

        $z64e  = pack("V", ZIP64_END_CENTRAL_REC_HDR_SIG) # signature
              .  U64::pack_V64(length $z64e)
              .  $z64e ;

        *$self->{ZipData}{Offset}->add32(length $cd) ; 

        $z64e .= pack "V", ZIP64_END_CENTRAL_LOC_HDR_SIG; # signature
        $z64e .= pack 'V', 0              ; # number of disk with central dir
        $z64e .= *$self->{ZipData}{Offset}->getPacked_V64() ; # offset to end zip64 central dir
        $z64e .= pack 'V', 1              ; # Total number of disks 

        $cd_offset = IO::Compress::Base::Common::MAX32 ;
        $cd_len = IO::Compress::Base::Common::MAX32 if IO::Compress::Base::Common::isGeMax32 $cd_len ;
        $entries = 0xFFFF if $entries >= 0xFFFF ;
    }

    my $ecd = '';
    $ecd .= pack "V", ZIP_END_CENTRAL_HDR_SIG ; # signature
    $ecd .= pack 'v', 0          ; # number of disk
    $ecd .= pack 'v', 0          ; # number of disk with central dir
    $ecd .= pack 'v', $entries   ; # entries in central dir on this disk
    $ecd .= pack 'v', $entries   ; # entries in central dir
    $ecd .= pack 'V', $cd_len    ; # size of central dir
    $ecd .= pack 'V', $cd_offset ; # offset to start central dir
    $ecd .= pack 'v', length $comment ; # zipfile comment length
    $ecd .= $comment;

    return $cd . $z64e . $ecd ;
}

sub ckParams
{
    my $self = shift ;
    my $got = shift;
    
    $got->setValue('crc32' => 1);

    if (! $got->parsed('time') ) {
        # Modification time defaults to now.
        $got->setValue('time' => time) ;
    }

    if ($got->parsed('extime') ) {
        my $timeRef = $got->getValue('extime');
        if ( defined $timeRef) {
            return $self->saveErrorString(undef, "exTime not a 3-element array ref")   
                if ref $timeRef ne 'ARRAY' || @$timeRef != 3;
        }

        $got->setValue("mtime", $timeRef->[1]);
        $got->setValue("atime", $timeRef->[0]);
        $got->setValue("ctime", $timeRef->[2]);
    }
    
    # Unix2/3 Extended Attribute
    for my $name (qw(exunix2 exunixn))
    {
        if ($got->parsed($name) ) {
            my $idRef = $got->getValue($name);
            if ( defined $idRef) {
                return $self->saveErrorString(undef, "$name not a 2-element array ref")   
                    if ref $idRef ne 'ARRAY' || @$idRef != 2;
            }

            $got->setValue("uid", $idRef->[0]);
            $got->setValue("gid", $idRef->[1]);
            $got->setValue("want_$name", $idRef);
        }
    }

    *$self->{ZipData}{AnyZip64} = 1
        if $got->getValue('zip64');
    *$self->{ZipData}{Zip64} = $got->getValue('zip64');
    *$self->{ZipData}{Stream} = $got->getValue('stream');

    my $method = $got->getValue('method');
    return $self->saveErrorString(undef, "Unknown Method '$method'")   
        if ! defined $ZIP_CM_MIN_VERSIONS{$method};

    return $self->saveErrorString(undef, "Bzip2 not available")
        if $method == ZIP_CM_BZIP2 and 
           ! defined $IO::Compress::Adapter::Bzip2::VERSION;

    return $self->saveErrorString(undef, "Lzma not available")
        if $method == ZIP_CM_LZMA 
        and ! defined $IO::Compress::Adapter::Lzma::VERSION;

    *$self->{ZipData}{Method} = $method;

    *$self->{ZipData}{ZipComment} = $got->getValue('zipcomment') ;

    for my $name (qw( extrafieldlocal extrafieldcentral ))
    {
        my $data = $got->getValue($name) ;
        if (defined $data) {
            my $bad = IO::Compress::Zlib::Extra::parseExtraField($data, 1, 0) ;
            return $self->saveErrorString(undef, "Error with $name Parameter: $bad")
                if $bad ;

            $got->setValue($name, $data) ;
        }
    }

    return undef
        if defined $IO::Compress::Bzip2::VERSION
            and ! IO::Compress::Bzip2::ckParams($self, $got);

    if ($got->parsed('sparse') ) {
        *$self->{ZipData}{Sparse} = $got->getValue('sparse') ;
        *$self->{ZipData}{Method} = ZIP_CM_STORE;
    }

    if ($got->parsed('filtername')) {
        my $v = $got->getValue('filtername') ;
        *$self->{ZipData}{FilterName} = $v
            if ref $v eq 'CODE' ;
    }

    return 1 ;
}

sub outputPayload
{
    my $self = shift ;
    return 1 if *$self->{ZipData}{Sparse} ;
    return $self->output(@_);
}


#sub newHeader
#{
#    my $self = shift ;
#
#    return $self->mkHeader(*$self->{Got});
#}


our %PARAMS = (            
            'stream'    => [IO::Compress::Base::Common::Parse_boolean,   1],
           #'store'     => [IO::Compress::Base::Common::Parse_boolean,   0],
            'method'    => [IO::Compress::Base::Common::Parse_unsigned,  ZIP_CM_DEFLATE],
            
#            # Zip header fields
            'minimal'   => [IO::Compress::Base::Common::Parse_boolean,   0],
            'zip64'     => [IO::Compress::Base::Common::Parse_boolean,   0],
            'comment'   => [IO::Compress::Base::Common::Parse_any,       ''],
            'zipcomment'=> [IO::Compress::Base::Common::Parse_any,       ''],
            'name'      => [IO::Compress::Base::Common::Parse_any,       ''],
            'filtername'=> [IO::Compress::Base::Common::Parse_code,      undef],
            'canonicalname'=> [IO::Compress::Base::Common::Parse_boolean,   0],
#            'utf8'      => [IO::Compress::Base::Common::Parse_boolean,   0],
            'time'      => [IO::Compress::Base::Common::Parse_any,       undef],
            'extime'    => [IO::Compress::Base::Common::Parse_any,       undef],
            'exunix2'   => [IO::Compress::Base::Common::Parse_any,       undef], 
            'exunixn'   => [IO::Compress::Base::Common::Parse_any,       undef], 
            'extattr'   => [IO::Compress::Base::Common::Parse_any, 
                    $Compress::Raw::Zlib::gzip_os_code == 3 
                        ? 0100644 << 16 
                        : 0],
            'os_code'   => [IO::Compress::Base::Common::Parse_unsigned,  $Compress::Raw::Zlib::gzip_os_code],
            
            'textflag'  => [IO::Compress::Base::Common::Parse_boolean,   0],
            'extrafieldlocal'  => [IO::Compress::Base::Common::Parse_any,    undef],
            'extrafieldcentral'=> [IO::Compress::Base::Common::Parse_any,    undef],

            # Lzma
            'preset'   => [IO::Compress::Base::Common::Parse_unsigned, 6],
            'extreme'  => [IO::Compress::Base::Common::Parse_boolean,  0],

            # For internal use only         
            'sparse'    => [IO::Compress::Base::Common::Parse_unsigned,  0],

            IO::Compress::RawDeflate::getZlibParams(),
            defined $IO::Compress::Bzip2::VERSION
                ? IO::Compress::Bzip2::getExtraParams()
                : ()
                
  
                );

sub getExtraParams
{
    return %PARAMS ;
}

sub getInverseClass
{
    return ('IO::Uncompress::Unzip',
                \$IO::Uncompress::Unzip::UnzipError);
}

sub getFileInfo
{
    my $self = shift ;
    my $params = shift;
    my $filename = shift ;

    if (IO::Compress::Base::Common::isaScalar($filename))
    {
        $params->setValue(zip64 => 1)
            if IO::Compress::Base::Common::isGeMax32 length (${ $filename }) ;

        return ;
    }

    my ($mode, $uid, $gid, $size, $atime, $mtime, $ctime) ;
    if ( $params->parsed('storelinks') )
    {
        ($mode, $uid, $gid, $size, $atime, $mtime, $ctime) 
                = (lstat($filename))[2, 4,5,7, 8,9,10] ;
    }
    else
    {
        ($mode, $uid, $gid, $size, $atime, $mtime, $ctime) 
                = (stat($filename))[2, 4,5,7, 8,9,10] ;
    }

    $params->setValue(textflag => -T $filename )
        if ! $params->parsed('textflag');

    $params->setValue(zip64 => 1)
        if IO::Compress::Base::Common::isGeMax32 $size ;

    $params->setValue('name' => $filename)
        if ! $params->parsed('name') ;

    $params->setValue('time' => $mtime) 
        if ! $params->parsed('time') ;
    
    if ( ! $params->parsed('extime'))
    {
        $params->setValue('mtime' => $mtime) ;
        $params->setValue('atime' => $atime) ;
        $params->setValue('ctime' => undef) ; # No Creation time
        # TODO - see if can fillout creation time on non-Unix
    }

    # NOTE - Unix specific code alert
    if (! $params->parsed('extattr'))
    {
        use Fcntl qw(:mode) ;
        my $attr = $mode << 16;
        $attr |= ZIP_A_RONLY if ($mode & S_IWRITE) == 0 ;
        $attr |= ZIP_A_DIR   if ($mode & S_IFMT  ) == S_IFDIR ;
        
        $params->setValue('extattr' => $attr);
    }

    $params->setValue('want_exunixn', [$uid, $gid]);
    $params->setValue('uid' => $uid) ;
    $params->setValue('gid' => $gid) ;
    
}

sub mkExtendedTime
{
    # order expected is m, a, c

    my $times = '';
    my $bit = 1 ;
    my $flags = 0;

    for my $time (@_)
    {
        if (defined $time)
        {
            $flags |= $bit;
            $times .= pack("V", $time);
        }

        $bit <<= 1 ;
    }

    return IO::Compress::Zlib::Extra::mkSubField(ZIP_EXTRA_ID_EXT_TIMESTAMP,
                                                 pack("C", $flags) .  $times);
}

sub mkUnix2Extra
{
    my $ids = '';
    for my $id (@_)
    {
        $ids .= pack("v", $id);
    }

    return IO::Compress::Zlib::Extra::mkSubField(ZIP_EXTRA_ID_INFO_ZIP_UNIX2, 
                                                 $ids);
}

sub mkUnixNExtra
{
    my $uid = shift;
    my $gid = shift;

    # Assumes UID/GID are 32-bit
    my $ids ;
    $ids .= pack "C", 1; # version
    $ids .= pack "C", $Config{uidsize};
    $ids .= pack "V", $uid;
    $ids .= pack "C", $Config{gidsize};
    $ids .= pack "V", $gid;

    return IO::Compress::Zlib::Extra::mkSubField(ZIP_EXTRA_ID_INFO_ZIP_UNIXN, 
                                                 $ids);
}


# from Archive::Zip
sub _unixToDosTime    # Archive::Zip::Member
{
	my $time_t = shift;
    
    # TODO - add something to cope with unix time < 1980 
	my ( $sec, $min, $hour, $mday, $mon, $year ) = localtime($time_t);
	my $dt = 0;
	$dt += ( $sec >> 1 );
	$dt += ( $min << 5 );
	$dt += ( $hour << 11 );
	$dt += ( $mday << 16 );
	$dt += ( ( $mon + 1 ) << 21 );
	$dt += ( ( $year - 80 ) << 25 );
	return $dt;
}

1;

__END__

=head1 NAME

IO::Compress::Zip - Write zip files/buffers
 
 

=head1 SYNOPSIS

    use IO::Compress::Zip qw(zip $ZipError) ;

    my $status = zip $input => $output [,OPTS] 
        or die "zip failed: $ZipError\n";

    my $z = new IO::Compress::Zip $output [,OPTS]
        or die "zip failed: $ZipError\n";

    $z->print($string);
    $z->printf($format, $string);
    $z->write($string);
    $z->syswrite($string [, $length, $offset]);
    $z->flush();
    $z->tell();
    $z->eof();
    $z->seek($position, $whence);
    $z->binmode();
    $z->fileno();
    $z->opened();
    $z->autoflush();
    $z->input_line_number();
    $z->newStream( [OPTS] );
    
    $z->deflateParams();
    
    $z->close() ;

    $ZipError ;

    # IO::File mode

    print $z $string;
    printf $z $format, $string;
    tell $z
    eof $z
    seek $z, $position, $whence
    binmode $z
    fileno $z
    close $z ;
    

=head1 DESCRIPTION

This module provides a Perl interface that allows writing zip 
compressed data to files or buffer.

The primary purpose of this module is to provide streaming write access to
zip files and buffers. It is not a general-purpose file archiver. If that
is what you want, check out C<Archive::Zip>.

At present three compression methods are supported by IO::Compress::Zip,
namely Store (no compression at all), Deflate, Bzip2 and LZMA.

Note that to create Bzip2 content, the module C<IO::Compress::Bzip2> must
be installed.

Note that to create LZMA content, the module C<IO::Compress::Lzma> must
be installed.

For reading zip files/buffers, see the companion module 
L<IO::Uncompress::Unzip|IO::Uncompress::Unzip>.

=head1 Functional Interface

A top-level function, C<zip>, is provided to carry out
"one-shot" compression between buffers and/or files. For finer
control over the compression process, see the L</"OO Interface">
section.

    use IO::Compress::Zip qw(zip $ZipError) ;

    zip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "zip failed: $ZipError\n";

The functional interface needs Perl5.005 or better.

=head2 zip $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<zip> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the uncompressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is compressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<zip> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

In addition, if C<$input_filename_or_reference> is a simple filename, 
the default values for
the C<Name>, C<Time>, C<TextFlag>, C<ExtAttr>, C<exUnixN> and C<exTime> options will be sourced from that file.

If you do not want to use these defaults they can be overridden by
explicitly setting the C<Name>, C<Time>, C<TextFlag>, C<ExtAttr>, C<exUnixN> and C<exTime> options or by setting the
C<Minimal> parameter.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the compressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
compressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
compressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
compressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the compressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<zip> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple files/buffers and
C<$output_filename_or_reference> is a single
file/buffer the input files/buffers will each be stored
in C<$output_filename_or_reference> as a distinct entry.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<zip>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<zip> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<zip> has
completed.

This parameter defaults to 0.

=item C<< BinModeIn => 0|1 >>

When reading from a file or filehandle, set C<binmode> before reading.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all compressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
compressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any compressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any compressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all compressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any compressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all compressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any compressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any compressed data is output.

Defaults to 0.

=back

=head2 Examples

To read the contents of the file C<file1.txt> and write the compressed
data to the file C<file1.txt.zip>.

    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    my $input = "file1.txt";
    zip $input => "$input.zip"
        or die "zip failed: $ZipError\n";

To read from an existing Perl filehandle, C<$input>, and write the
compressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt"
        or die "Cannot open 'file1.txt': $!\n" ;
    my $buffer ;
    zip $input => \$buffer 
        or die "zip failed: $ZipError\n";

To create a zip file, C<output.zip>, that contains the compressed contents
of the files C<alpha.txt> and C<beta.txt>

    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    zip [ 'alpha.txt', 'beta.txt' ] => 'output.zip'
        or die "zip failed: $ZipError\n";

Alternatively, rather than having to explicitly name each of the files that
you want to compress, you could use a fileglob to select all the C<txt>
files in the current directory, as follows

    use strict ;
    use warnings ;
    use IO::Compress::Zip qw(zip $ZipError) ;

    my @files = <*.txt>;
    zip \@files => 'output.zip'
        or die "zip failed: $ZipError\n";

or more succinctly

    zip [ <*.txt> ] => 'output.zip'
        or die "zip failed: $ZipError\n";

=head1 OO Interface

=head2 Constructor

The format of the constructor for C<IO::Compress::Zip> is shown below

    my $z = new IO::Compress::Zip $output [,OPTS]
        or die "IO::Compress::Zip failed: $ZipError\n";

It returns an C<IO::Compress::Zip> object on success and undef on failure. 
The variable C<$ZipError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from 
IO::Compress::Zip can be used exactly like an L<IO::File|IO::File> filehandle. 
This means that all normal output file operations can be carried out 
with C<$z>. 
For example, to write to a compressed file/buffer you can use either of 
these forms

    $z->print("hello world\n");
    print $z "hello world\n";

The mandatory parameter C<$output> is used to control the destination
of the compressed data. This parameter can take one of these forms.

=over 5

=item A filename

If the C<$output> parameter is a simple scalar, it is assumed to be a
filename. This file will be opened for writing and the compressed data
will be written to it.

=item A filehandle

If the C<$output> parameter is a filehandle, the compressed data will be
written to it.
The string '-' can be used as an alias for standard output.

=item A scalar reference 

If C<$output> is a scalar reference, the compressed data will be stored
in C<$$output>.

=back

If the C<$output> parameter is any other type, C<IO::Compress::Zip>::new will
return undef.

=head2 Constructor Options

C<OPTS> is any combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$output> parameter is a filehandle. If
specified, and the value is true, it will result in the C<$output> being
closed once either the C<close> method is called or the C<IO::Compress::Zip>
object is destroyed.

This parameter defaults to 0.

=item C<< Append => 0|1 >>

Opens C<$output> in append mode. 

The behaviour of this option is dependent on the type of C<$output>.

=over 5

=item * A Buffer

If C<$output> is a buffer and C<Append> is enabled, all compressed data
will be append to the end of C<$output>. Otherwise C<$output> will be
cleared before any data is written to it.

=item * A Filename

If C<$output> is a filename and C<Append> is enabled, the file will be
opened in append mode. Otherwise the contents of the file, if any, will be
truncated before any compressed data is written to it.

=item * A Filehandle

If C<$output> is a filehandle, the file pointer will be positioned to the
end of the file via a call to C<seek> before any compressed data is written
to it.  Otherwise the file pointer will not be moved.

=back

This parameter defaults to 0.

=item C<< Name => $string >>

Stores the contents of C<$string> in the zip filename header field. 

If C<Name> is not specified and the C<$input> parameter is a filename, the
value of C<$input> will be used for the zip filename header field.

If C<Name> is not specified and the C<$input> parameter is not a filename,
no zip filename field will be created.

Note that both the C<CanonicalName> and C<FilterName> options
can modify the value used for the zip filename header field.

=item C<< CanonicalName => 0|1 >>

This option controls whether the filename field in the zip header is
I<normalized> into Unix format before being written to the zip file.

It is recommended that you enable this option unless you really need
to create a non-standard Zip file.

This is what APPNOTE.TXT has to say on what should be stored in the zip
filename header field.

    The name of the file, with optional relative path.          
    The path stored should not contain a drive or
    device letter, or a leading slash.  All slashes
    should be forward slashes '/' as opposed to
    backwards slashes '\' for compatibility with Amiga
    and UNIX file systems etc.

This option defaults to B<false>.

=item C<< FilterName => sub { ... }  >>

This option allow the filename field in the zip header to be modified
before it is written to the zip file.

This option takes a parameter that must be a reference to a sub.  On entry
to the sub the C<$_> variable will contain the name to be filtered. If no
filename is available C<$_> will contain an empty string.

The value of C<$_> when the sub returns will be  stored in the filename
header field.

Note that if C<CanonicalName> is enabled, a
normalized filename will be passed to the sub.

If you use C<FilterName> to modify the filename, it is your responsibility
to keep the filename in Unix format.

Although this option can be used with the OO interface, it is of most use
with the one-shot interface. For example, the code below shows how
C<FilterName> can be used to remove the path component from a series of
filenames before they are stored in C<$zipfile>.

    sub compressTxtFiles
    {
        my $zipfile = shift ;
        my $dir     = shift ;

        zip [ <$dir/*.txt> ] => $zipfile,
            FilterName => sub { s[^$dir/][] } ;  
    }    

=item C<< Time => $number >>

Sets the last modified time field in the zip header to $number.

This field defaults to the time the C<IO::Compress::Zip> object was created
if this option is not specified and the C<$input> parameter is not a
filename.

=item C<< ExtAttr => $attr >>

This option controls the "external file attributes" field in the central
header of the zip file. This is a 4 byte field.

If you are running a Unix derivative this value defaults to 

    0100644 << 16

This should allow read/write access to any files that are extracted from
the zip file/buffer`.

For all other systems it defaults to 0.

=item C<< exTime => [$atime, $mtime, $ctime] >>

This option expects an array reference with exactly three elements:
C<$atime>, C<mtime> and C<$ctime>. These correspond to the last access
time, last modification time and creation time respectively.

It uses these values to set the extended timestamp field (ID is "UT") in
the local zip header using the three values, $atime, $mtime, $ctime. In
addition it sets the extended timestamp field in the central zip header
using C<$mtime>.

If any of the three values is C<undef> that time value will not be used.
So, for example, to set only the C<$mtime> you would use this

    exTime => [undef, $mtime, undef]

If the C<Minimal> option is set to true, this option will be ignored.

By default no extended time field is created.

=item C<< exUnix2 => [$uid, $gid] >>

This option expects an array reference with exactly two elements: C<$uid>
and C<$gid>. These values correspond to the numeric User ID (UID) and Group ID
(GID) of the owner of the files respectively.

When the C<exUnix2> option is present it will trigger the creation of a
Unix2 extra field (ID is "Ux") in the local zip header. This will be populated
with C<$uid> and C<$gid>. An empty Unix2 extra field will also
be created in the central zip header. 

Note - The UID & GID are stored as 16-bit
integers in the "Ux" field. Use C<< exUnixN >> if your UID or GID are
32-bit.

If the C<Minimal> option is set to true, this option will be ignored.

By default no Unix2 extra field is created.

=item C<< exUnixN => [$uid, $gid] >>

This option expects an array reference with exactly two elements: C<$uid>
and C<$gid>. These values correspond to the numeric User ID (UID) and Group ID
(GID) of the owner of the files respectively.

When the C<exUnixN> option is present it will trigger the creation of a
UnixN extra field (ID is "ux") in both the local and central zip headers. 
This will be populated with C<$uid> and C<$gid>. 
The UID & GID are stored as 32-bit integers.

If the C<Minimal> option is set to true, this option will be ignored.

By default no UnixN extra field is created.

=item C<< Comment => $comment >>

Stores the contents of C<$comment> in the Central File Header of
the zip file.

By default, no comment field is written to the zip file.

=item C<< ZipComment => $comment >>

Stores the contents of C<$comment> in the End of Central Directory record
of the zip file.

By default, no comment field is written to the zip file.

=item C<< Method => $method >>

Controls which compression method is used. At present four compression
methods are supported, namely Store (no compression at all), Deflate, 
Bzip2 and Lzma.

The symbols, ZIP_CM_STORE, ZIP_CM_DEFLATE, ZIP_CM_BZIP2 and ZIP_CM_LZMA 
are used to select the compression method.

These constants are not imported by C<IO::Compress::Zip> by default.

    use IO::Compress::Zip qw(:zip_method);
    use IO::Compress::Zip qw(:constants);
    use IO::Compress::Zip qw(:all);

Note that to create Bzip2 content, the module C<IO::Compress::Bzip2> must
be installed. A fatal error will be thrown if you attempt to create Bzip2
content when C<IO::Compress::Bzip2> is not available.

Note that to create Lzma content, the module C<IO::Compress::Lzma> must
be installed. A fatal error will be thrown if you attempt to create Lzma
content when C<IO::Compress::Lzma> is not available.

The default method is ZIP_CM_DEFLATE.

=item C<< Stream => 0|1 >>

This option controls whether the zip file/buffer output is created in
streaming mode.

Note that when outputting to a file with streaming mode disabled (C<Stream>
is 0), the output file must be seekable.

The default is 1.

=item C<< Zip64 => 0|1 >>

Create a Zip64 zip file/buffer. This option is used if you want
to store files larger than 4 Gig or store more than 64K files in a single
zip archive.. 

C<Zip64> will be automatically set, as needed, if working with the one-shot 
interface when the input is either a filename or a scalar reference.

If you intend to manipulate the Zip64 zip files created with this module
using an external zip/unzip, make sure that it supports Zip64.  

In particular, if you are using Info-Zip you need to have zip version 3.x
or better to update a Zip64 archive and unzip version 6.x to read a zip64
archive. 

The default is 0.

=item C<< TextFlag => 0|1 >>

This parameter controls the setting of a bit in the zip central header. It
is used to signal that the data stored in the zip file/buffer is probably
text.

In one-shot mode this flag will be set to true if the Perl C<-T> operator thinks
the file contains text.

The default is 0. 

=item C<< ExtraFieldLocal => $data >>

=item C<< ExtraFieldCentral => $data >>

The C<ExtraFieldLocal> option is used to store additional metadata in the
local header for the zip file/buffer. The C<ExtraFieldCentral> does the
same for the matching central header.

An extra field consists of zero or more subfields. Each subfield consists
of a two byte header followed by the subfield data.

The list of subfields can be supplied in any of the following formats

    ExtraFieldLocal => [$id1, $data1,
                        $id2, $data2,
                         ...
                       ]

    ExtraFieldLocal => [ [$id1 => $data1],
                         [$id2 => $data2],
                         ...
                       ]

    ExtraFieldLocal => { $id1 => $data1,
                         $id2 => $data2,
                         ...
                       }

Where C<$id1>, C<$id2> are two byte subfield ID's. 

If you use the hash syntax, you have no control over the order in which
the ExtraSubFields are stored, plus you cannot have SubFields with
duplicate ID.

Alternatively the list of subfields can by supplied as a scalar, thus

    ExtraField => $rawdata

In this case C<IO::Compress::Zip> will check that C<$rawdata> consists of 
zero or more conformant sub-fields. 

The Extended Time field (ID "UT"), set using the C<exTime> option, and the
Unix2 extra field (ID "Ux), set using the C<exUnix2> option, are examples
of extra fields.

If the C<Minimal> option is set to true, this option will be ignored.

The maximum size of an extra field 65535 bytes.

=item C<< Minimal => 1|0 >>

If specified, this option will disable the creation of all extra fields
in the zip local and central headers. So the C<exTime>, C<exUnix2>,
C<exUnixN>, C<ExtraFieldLocal> and C<ExtraFieldCentral> options will 
be ignored.

This parameter defaults to 0.

=item C<< BlockSize100K => number >>

Specify the number of 100K blocks bzip2 uses during compression. 

Valid values are from 1 to 9, where 9 is best compression.

This option is only valid if the C<Method> is ZIP_CM_BZIP2. It is ignored
otherwise.

The default is 1.

=item C<< WorkFactor => number >>

Specifies how much effort bzip2 should take before resorting to a slower
fallback compression algorithm.

Valid values range from 0 to 250, where 0 means use the default value 30.

This option is only valid if the C<Method> is ZIP_CM_BZIP2. It is ignored
otherwise.

The default is 0.

=item C<< Preset => number >>

Used to choose the LZMA compression preset.

Valid values are 0-9 and C<LZMA_PRESET_DEFAULT>.

0 is the fastest compression with the lowest memory usage and the lowest
compression.

9 is the slowest compression with the highest memory usage but with the best
compression.

This option is only valid if the C<Method> is ZIP_CM_LZMA. It is ignored
otherwise.

Defaults to C<LZMA_PRESET_DEFAULT> (6).

=item C<< Extreme => 0|1 >>

Makes LZMA compression a lot slower, but a small compression gain.

This option is only valid if the C<Method> is ZIP_CM_LZMA. It is ignored
otherwise.

Defaults to 0.

=item -Level 

Defines the compression level used by zlib. The value should either be
a number between 0 and 9 (0 means no compression and 9 is maximum
compression), or one of the symbolic constants defined below.

   Z_NO_COMPRESSION
   Z_BEST_SPEED
   Z_BEST_COMPRESSION
   Z_DEFAULT_COMPRESSION

The default is Z_DEFAULT_COMPRESSION.

Note, these constants are not imported by C<IO::Compress::Zip> by default.

    use IO::Compress::Zip qw(:strategy);
    use IO::Compress::Zip qw(:constants);
    use IO::Compress::Zip qw(:all);

=item -Strategy 

Defines the strategy used to tune the compression. Use one of the symbolic
constants defined below.

   Z_FILTERED
   Z_HUFFMAN_ONLY
   Z_RLE
   Z_FIXED
   Z_DEFAULT_STRATEGY

The default is Z_DEFAULT_STRATEGY.

=item C<< Strict => 0|1 >>

This is a placeholder option.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 print

Usage is

    $z->print($data)
    print $z $data

Compresses and outputs the contents of the C<$data> parameter. This
has the same behaviour as the C<print> built-in.

Returns true if successful.

=head2 printf

Usage is

    $z->printf($format, $data)
    printf $z $format, $data

Compresses and outputs the contents of the C<$data> parameter.

Returns true if successful.

=head2 syswrite

Usage is

    $z->syswrite $data
    $z->syswrite $data, $length
    $z->syswrite $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 write

Usage is

    $z->write $data
    $z->write $data, $length
    $z->write $data, $length, $offset

Compresses and outputs the contents of the C<$data> parameter.

Returns the number of uncompressed bytes written, or C<undef> if
unsuccessful.

=head2 flush

Usage is

    $z->flush;
    $z->flush($flush_type);

Flushes any pending compressed data to the output file/buffer.

This method takes an optional parameter, C<$flush_type>, that controls
how the flushing will be carried out. By default the C<$flush_type>
used is C<Z_FINISH>. Other valid values for C<$flush_type> are
C<Z_NO_FLUSH>, C<Z_SYNC_FLUSH>, C<Z_FULL_FLUSH> and C<Z_BLOCK>. It is
strongly recommended that you only set the C<flush_type> parameter if
you fully understand the implications of what it does - overuse of C<flush>
can seriously degrade the level of compression achieved. See the C<zlib>
documentation for details.

Returns true on success.

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the C<close> method has been called.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the output file/buffer.
It is a fatal error to attempt to seek backward.

Empty parts of the file/buffer will have NULL (0x00) bytes written to them.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

This method always returns C<undef> when compressing. 

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Flushes any pending compressed data and then closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Compress::Zip object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Compress::Zip
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 newStream([OPTS])

Usage is

    $z->newStream( [OPTS] )

Closes the current compressed data stream and starts a new one.

OPTS consists of any of the options that are available when creating
the C<$z> object.

See the L</"Constructor Options"> section for more details.

=head2 deflateParams

Usage is

    $z->deflateParams

TODO

=head1 Importing 

A number of symbolic constants are required by some methods in 
C<IO::Compress::Zip>. None are imported by default.

=over 5

=item :all

Imports C<zip>, C<$ZipError> and all symbolic
constants that can be used by C<IO::Compress::Zip>. Same as doing this

    use IO::Compress::Zip qw(zip $ZipError :constants) ;

=item :constants

Import all symbolic constants. Same as doing this

    use IO::Compress::Zip qw(:flush :level :strategy :zip_method) ;

=item :flush

These symbolic constants are used by the C<flush> method.

    Z_NO_FLUSH
    Z_PARTIAL_FLUSH
    Z_SYNC_FLUSH
    Z_FULL_FLUSH
    Z_FINISH
    Z_BLOCK

=item :level

These symbolic constants are used by the C<Level> option in the constructor.

    Z_NO_COMPRESSION
    Z_BEST_SPEED
    Z_BEST_COMPRESSION
    Z_DEFAULT_COMPRESSION

=item :strategy

These symbolic constants are used by the C<Strategy> option in the constructor.

    Z_FILTERED
    Z_HUFFMAN_ONLY
    Z_RLE
    Z_FIXED
    Z_DEFAULT_STRATEGY

=item :zip_method

These symbolic constants are used by the C<Method> option in the
constructor.

    ZIP_CM_STORE
    ZIP_CM_DEFLATE
    ZIP_CM_BZIP2

    
    

=back

=head1 EXAMPLES

=head2 Apache::GZip Revisited

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Apache::GZip Revisited">

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/IO/Compress/Zlib/                                                             0040755 0000000 0000000 00000000000 13077704254 015664  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IO/Compress/Zlib/Constants.pm                                                 0100644 0000000 0000000 00000003172 12744441327 020175  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package IO::Compress::Zlib::Constants ;

use strict ;
use warnings;
use bytes;

require Exporter;

our ($VERSION, @ISA, @EXPORT);

$VERSION = '2.064';

@ISA = qw(Exporter);

@EXPORT= qw(

        ZLIB_HEADER_SIZE
        ZLIB_TRAILER_SIZE

        ZLIB_CMF_CM_OFFSET
        ZLIB_CMF_CM_BITS
        ZLIB_CMF_CM_DEFLATED

        ZLIB_CMF_CINFO_OFFSET
        ZLIB_CMF_CINFO_BITS 
        ZLIB_CMF_CINFO_MAX

        ZLIB_FLG_FCHECK_OFFSET
        ZLIB_FLG_FCHECK_BITS

        ZLIB_FLG_FDICT_OFFSET
        ZLIB_FLG_FDICT_BITS

        ZLIB_FLG_LEVEL_OFFSET
        ZLIB_FLG_LEVEL_BITS

        ZLIB_FLG_LEVEL_FASTEST
        ZLIB_FLG_LEVEL_FAST
        ZLIB_FLG_LEVEL_DEFAULT
        ZLIB_FLG_LEVEL_SLOWEST

        ZLIB_FDICT_SIZE

        );

# Constant names derived from RFC1950

use constant ZLIB_HEADER_SIZE       => 2;
use constant ZLIB_TRAILER_SIZE      => 4;

use constant ZLIB_CMF_CM_OFFSET     => 0;
use constant ZLIB_CMF_CM_BITS       => 0xF ; # 0b1111
use constant ZLIB_CMF_CM_DEFLATED   => 8;

use constant ZLIB_CMF_CINFO_OFFSET  => 4;
use constant ZLIB_CMF_CINFO_BITS    => 0xF ; # 0b1111;
use constant ZLIB_CMF_CINFO_MAX     => 7;

use constant ZLIB_FLG_FCHECK_OFFSET => 0;
use constant ZLIB_FLG_FCHECK_BITS   => 0x1F ; # 0b11111;

use constant ZLIB_FLG_FDICT_OFFSET  => 5;
use constant ZLIB_FLG_FDICT_BITS    => 0x1 ; # 0b1;

use constant ZLIB_FLG_LEVEL_OFFSET  => 6;
use constant ZLIB_FLG_LEVEL_BITS    => 0x3 ; # 0b11;

use constant ZLIB_FLG_LEVEL_FASTEST => 0;
use constant ZLIB_FLG_LEVEL_FAST    => 1;
use constant ZLIB_FLG_LEVEL_DEFAULT => 2;
use constant ZLIB_FLG_LEVEL_SLOWEST => 3;

use constant ZLIB_FDICT_SIZE        => 4;


1;
                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/IO/Compress/Zlib/Extra.pm                                                     0100644 0000000 0000000 00000013117 12744441327 017304  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Compress::Zlib::Extra;

require 5.006 ;

use strict ;
use warnings;
use bytes;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS);

$VERSION = '2.064';

use IO::Compress::Gzip::Constants 2.064 ;

sub ExtraFieldError
{
    return $_[0];
    return "Error with ExtraField Parameter: $_[0]" ;
}

sub validateExtraFieldPair
{
    my $pair = shift ;
    my $strict = shift;
    my $gzipMode = shift ;

    return ExtraFieldError("Not an array ref")
        unless ref $pair &&  ref $pair eq 'ARRAY';

    return ExtraFieldError("SubField must have two parts")
        unless @$pair == 2 ;

    return ExtraFieldError("SubField ID is a reference")
        if ref $pair->[0] ;

    return ExtraFieldError("SubField Data is a reference")
        if ref $pair->[1] ;

    # ID is exactly two chars   
    return ExtraFieldError("SubField ID not two chars long")
        unless length $pair->[0] == GZIP_FEXTRA_SUBFIELD_ID_SIZE ;

    # Check that the 2nd byte of the ID isn't 0    
    return ExtraFieldError("SubField ID 2nd byte is 0x00")
        if $strict && $gzipMode && substr($pair->[0], 1, 1) eq "\x00" ;

    return ExtraFieldError("SubField Data too long")
        if length $pair->[1] > GZIP_FEXTRA_SUBFIELD_MAX_SIZE ;


    return undef ;
}

sub parseRawExtra
{
    my $data     = shift ;
    my $extraRef = shift;
    my $strict   = shift;
    my $gzipMode = shift ;

    #my $lax = shift ;

    #return undef
    #    if $lax ;

    my $XLEN = length $data ;

    return ExtraFieldError("Too Large")
        if $XLEN > GZIP_FEXTRA_MAX_SIZE;

    my $offset = 0 ;
    while ($offset < $XLEN) {

        return ExtraFieldError("Truncated in FEXTRA Body Section")
            if $offset + GZIP_FEXTRA_SUBFIELD_HEADER_SIZE  > $XLEN ;

        my $id = substr($data, $offset, GZIP_FEXTRA_SUBFIELD_ID_SIZE);    
        $offset += GZIP_FEXTRA_SUBFIELD_ID_SIZE;

        my $subLen =  unpack("v", substr($data, $offset,
                                            GZIP_FEXTRA_SUBFIELD_LEN_SIZE));
        $offset += GZIP_FEXTRA_SUBFIELD_LEN_SIZE ;

        return ExtraFieldError("Truncated in FEXTRA Body Section")
            if $offset + $subLen > $XLEN ;

        my $bad = validateExtraFieldPair( [$id, 
                                           substr($data, $offset, $subLen)], 
                                           $strict, $gzipMode );
        return $bad if $bad ;
        push @$extraRef, [$id => substr($data, $offset, $subLen)]
            if defined $extraRef;;

        $offset += $subLen ;
    }

        
    return undef ;
}

sub findID
{
    my $id_want = shift ;
    my $data    = shift;

    my $XLEN = length $data ;

    my $offset = 0 ;
    while ($offset < $XLEN) {

        return undef
            if $offset + GZIP_FEXTRA_SUBFIELD_HEADER_SIZE  > $XLEN ;

        my $id = substr($data, $offset, GZIP_FEXTRA_SUBFIELD_ID_SIZE);    
        $offset += GZIP_FEXTRA_SUBFIELD_ID_SIZE;

        my $subLen =  unpack("v", substr($data, $offset,
                                            GZIP_FEXTRA_SUBFIELD_LEN_SIZE));
        $offset += GZIP_FEXTRA_SUBFIELD_LEN_SIZE ;

        return undef
            if $offset + $subLen > $XLEN ;

        return substr($data, $offset, $subLen)
            if $id eq $id_want ;

        $offset += $subLen ;
    }
        
    return undef ;
}


sub mkSubField
{
    my $id = shift ;
    my $data = shift ;

    return $id . pack("v", length $data) . $data ;
}

sub parseExtraField
{
    my $dataRef  = $_[0];
    my $strict   = $_[1];
    my $gzipMode = $_[2];
    #my $lax     = @_ == 2 ? $_[1] : 1;


    # ExtraField can be any of
    #
    #    -ExtraField => $data
    #
    #    -ExtraField => [$id1, $data1,
    #                    $id2, $data2]
    #                     ...
    #                   ]
    #
    #    -ExtraField => [ [$id1 => $data1],
    #                     [$id2 => $data2],
    #                     ...
    #                   ]
    #
    #    -ExtraField => { $id1 => $data1,
    #                     $id2 => $data2,
    #                     ...
    #                   }
    
    if ( ! ref $dataRef ) {

        return undef
            if ! $strict;

        return parseRawExtra($dataRef, undef, 1, $gzipMode);
    }

    my $data = $dataRef;
    my $out = '' ;

    if (ref $data eq 'ARRAY') {    
        if (ref $data->[0]) {

            foreach my $pair (@$data) {
                return ExtraFieldError("Not list of lists")
                    unless ref $pair eq 'ARRAY' ;

                my $bad = validateExtraFieldPair($pair, $strict, $gzipMode) ;
                return $bad if $bad ;

                $out .= mkSubField(@$pair);
            }   
        }   
        else {
            return ExtraFieldError("Not even number of elements")
                unless @$data % 2  == 0;

            for (my $ix = 0; $ix <= @$data -1 ; $ix += 2) {
                my $bad = validateExtraFieldPair([$data->[$ix],
                                                  $data->[$ix+1]], 
                                                 $strict, $gzipMode) ;
                return $bad if $bad ;

                $out .= mkSubField($data->[$ix], $data->[$ix+1]);
            }   
        }
    }   
    elsif (ref $data eq 'HASH') {    
        while (my ($id, $info) = each %$data) {
            my $bad = validateExtraFieldPair([$id, $info], $strict, $gzipMode);
            return $bad if $bad ;

            $out .= mkSubField($id, $info);
        }   
    }   
    else {
        return ExtraFieldError("Not a scalar, array ref or hash ref") ;
    }

    return ExtraFieldError("Too Large")
        if length $out > GZIP_FEXTRA_MAX_SIZE;

    $_[0] = $out ;

    return undef;
}

1;

__END__
                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/IO/Uncompress/                                                                0040755 0000000 0000000 00000000000 13077704254 015327  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IO/Uncompress/Adapter/                                                        0040755 0000000 0000000 00000000000 13077704254 016707  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IO/Uncompress/Adapter/Bunzip2.pm                                              0100644 0000000 0000000 00000003772 12744441327 020603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Adapter::Bunzip2;

use strict;
use warnings;
use bytes;

use IO::Compress::Base::Common 2.064 qw(:Status);

use Compress::Raw::Bzip2 2.064 ;

our ($VERSION, @ISA);
$VERSION = '2.064';

sub mkUncompObject
{
    my $small     = shift || 0;
    my $verbosity = shift || 0;

    my ($inflate, $status) = new Compress::Raw::Bunzip2(1, 1, $small, $verbosity, 1);

    return (undef, "Could not create Inflation object: $status", $status)
        if $status != BZ_OK ;

    return bless {'Inf'           => $inflate,
                  'CompSize'      => 0,
                  'UnCompSize'    => 0,
                  'Error'         => '',
                  'ConsumesInput' => 1,
                 }  ;     
    
}

sub uncompr
{
    my $self = shift ;
    my $from = shift ;
    my $to   = shift ;
    my $eof  = shift ;

    my $inf   = $self->{Inf};

    my $status = $inf->bzinflate($from, $to);
    $self->{ErrorNo} = $status;

    if ($status != BZ_OK && $status != BZ_STREAM_END )
    {
        $self->{Error} = "Inflation Error: $status";
        return STATUS_ERROR;
    }

    
    return STATUS_OK        if $status == BZ_OK ;
    return STATUS_ENDSTREAM if $status == BZ_STREAM_END ;
    return STATUS_ERROR ;
}


sub reset
{
    my $self = shift ;

    my ($inf, $status) = new Compress::Raw::Bunzip2();
    $self->{ErrorNo} = ($status == BZ_OK) ? 0 : $status ;

    if ($status != BZ_OK)
    {
        $self->{Error} = "Cannot create Inflate object: $status"; 
        return STATUS_ERROR;
    }

    $self->{Inf} = $inf;

    return STATUS_OK ;
}

sub compressedBytes
{
    my $self = shift ;
    $self->{Inf}->compressedBytes();
}

sub uncompressedBytes
{
    my $self = shift ;
    $self->{Inf}->uncompressedBytes();
}

sub crc32
{
    my $self = shift ;
    #$self->{Inf}->crc32();
}

sub adler32
{
    my $self = shift ;
    #$self->{Inf}->adler32();
}

sub sync
{
    my $self = shift ;
    #( $self->{Inf}->inflateSync(@_) == BZ_OK) 
    #        ? STATUS_OK 
    #        : STATUS_ERROR ;
}


1;

__END__

      usr/share/perl/5.20.2/IO/Uncompress/Adapter/Identity.pm                                             0100644 0000000 0000000 00000010747 12744441327 021043  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Adapter::Identity;

use warnings;
use strict;
use bytes;

use IO::Compress::Base::Common  2.064 qw(:Status);
use IO::Compress::Zip::Constants ;

our ($VERSION);

$VERSION = '2.064';

use Compress::Raw::Zlib  2.064 ();

sub mkUncompObject
{
    my $streaming = shift;
    my $zip64 = shift;

    my $crc32 = 1; #shift ;
    my $adler32 = shift;

    bless { 'CompSize'   => new U64 , # 0,
            'UnCompSize' => 0,
            'wantCRC32'  => $crc32,
            'CRC32'      => Compress::Raw::Zlib::crc32(''),
            'wantADLER32'=> $adler32,
            'ADLER32'    => Compress::Raw::Zlib::adler32(''),
            'ConsumesInput' => 1,
            'Streaming'  => $streaming,
            'Zip64'      => $zip64,
            'DataHdrSize'  => $zip64 ? 24 :  16,
            'Pending'   => '',

          } ;
}


sub uncompr
{
    my $self = shift;
    my $in = $_[0];
    my $eof = $_[2];

    my $len = length $$in;
    my $remainder = '';

    if (defined $$in && $len) {

        if ($self->{Streaming}) {

            if (length $self->{Pending}) {
                $$in = $self->{Pending} . $$in ;
                $len = length $$in;
                $self->{Pending} = '';
            }

            my $ind = index($$in, "\x50\x4b\x07\x08");

            if ($ind < 0) {
                $len = length $$in;
                if ($len >= 3 && substr($$in, -3) eq "\x50\x4b\x07") {
                    $ind = $len - 3 ;
                }
                elsif ($len >= 2 && substr($$in, -2) eq "\x50\x4b") {
                    $ind = $len - 2 ;
                }
                elsif ($len >= 1 && substr($$in, -1) eq "\x50") {
                    $ind = $len - 1 ;
                }
            }
           
            if ($ind >= 0) {
                $remainder = substr($$in, $ind) ;
                substr($$in, $ind) = '' ;
            }
        }

        if (length $remainder && length $remainder < $self->{DataHdrSize}) {
            $self->{Pending} = $remainder ;
            $remainder = '';
        }
        elsif (length $remainder >= $self->{DataHdrSize}) {
            my $crc = unpack "V", substr($remainder, 4);
            if ($crc == Compress::Raw::Zlib::crc32($$in,  $self->{CRC32})) {
                my ($l1, $l2) ;

                if ($self->{Zip64}) {
                    $l1 = U64::newUnpack_V64(substr($remainder, 8));
                    $l2 = U64::newUnpack_V64(substr($remainder, 16));
                }
                else {
                    $l1 = U64::newUnpack_V32(substr($remainder, 8));
                    $l2 = U64::newUnpack_V32(substr($remainder, 12));
                }
                    
                my $newLen = $self->{CompSize}->clone();
                $newLen->add(length $$in);
                if ($l1->equal($l2) && $l1->equal($newLen) ) {
                    $eof = 1;
                }
                else {
                    $$in .= substr($remainder, 0, 4) ;
                    $remainder       = substr($remainder, 4);
                    #$self->{Pending} = substr($remainder, 4);
                    #$remainder = '';
                    $eof = 0;
                }
            }
            else {
                $$in .= substr($remainder, 0, 4) ;
                $remainder       = substr($remainder, 4);
                #$self->{Pending} = substr($remainder, 4);
                #$remainder = '';
                $eof = 0;
            }
        }

        if (length $$in) {
            $self->{CompSize}->add(length $$in) ;

            $self->{CRC32} = Compress::Raw::Zlib::crc32($$in,  $self->{CRC32})
                if $self->{wantCRC32};

            $self->{ADLER32} = Compress::Zlib::adler32($$in,  $self->{ADLER32})
                if $self->{wantADLER32};
        }

        ${ $_[1] } .= $$in;
        $$in  = $remainder;
    }

    return STATUS_ENDSTREAM if $eof;
    return STATUS_OK ;
}

sub reset
{
    my $self = shift;

    $self->{CompSize}   = 0;
    $self->{UnCompSize} = 0;
    $self->{CRC32}      = Compress::Raw::Zlib::crc32('');
    $self->{ADLER32}    = Compress::Raw::Zlib::adler32('');      

    return STATUS_OK ;
}

#sub count
#{
#    my $self = shift ;
#    return $self->{UnCompSize} ;
#}

sub compressedBytes
{
    my $self = shift ;
    return $self->{CompSize} ;
}

sub uncompressedBytes
{
    my $self = shift ;
    return $self->{CompSize} ;
}

sub sync
{
    return STATUS_OK ;
}

sub crc32
{
    my $self = shift ;
    return $self->{CRC32};
}

sub adler32
{
    my $self = shift ;
    return $self->{ADLER32};
}


1;

__END__
                         usr/share/perl/5.20.2/IO/Uncompress/Adapter/Inflate.pm                                              0100644 0000000 0000000 00000006320 12744441327 020624  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Adapter::Inflate;

use strict;
use warnings;
#use bytes;

use IO::Compress::Base::Common  2.064 qw(:Status);
use Compress::Raw::Zlib  2.064 qw(Z_OK Z_BUF_ERROR Z_STREAM_END Z_FINISH MAX_WBITS);

our ($VERSION);
$VERSION = '2.064';



sub mkUncompObject
{
    my $crc32   = shift || 1;
    my $adler32 = shift || 1;
    my $scan    = shift || 0;

    my $inflate ;
    my $status ;

    if ($scan)
    {
        ($inflate, $status) = new Compress::Raw::Zlib::InflateScan
                                    #LimitOutput  => 1,
                                    CRC32        => $crc32,
                                    ADLER32      => $adler32,
                                    WindowBits   => - MAX_WBITS ;
    }
    else
    {
        ($inflate, $status) = new Compress::Raw::Zlib::Inflate
                                    AppendOutput => 1,
                                    LimitOutput  => 1,
                                    CRC32        => $crc32,
                                    ADLER32      => $adler32,
                                    WindowBits   => - MAX_WBITS ;
    }

    return (undef, "Could not create Inflation object: $status", $status) 
        if $status != Z_OK ;

    return bless {'Inf'        => $inflate,
                  'CompSize'   => 0,
                  'UnCompSize' => 0,
                  'Error'      => '',
                  'ConsumesInput' => 1,
                 } ;     
    
}

sub uncompr
{
    my $self = shift ;
    my $from = shift ;
    my $to   = shift ;
    my $eof  = shift ;

    my $inf   = $self->{Inf};

    my $status = $inf->inflate($from, $to, $eof);
    $self->{ErrorNo} = $status;

    if ($status != Z_OK && $status != Z_STREAM_END && $status != Z_BUF_ERROR)
    {
        $self->{Error} = "Inflation Error: $status";
        return STATUS_ERROR;
    }
            
    return STATUS_OK        if $status == Z_BUF_ERROR ; # ???
    return STATUS_OK        if $status == Z_OK ;
    return STATUS_ENDSTREAM if $status == Z_STREAM_END ;
    return STATUS_ERROR ;
}

sub reset
{
    my $self = shift ;
    $self->{Inf}->inflateReset();

    return STATUS_OK ;
}

#sub count
#{
#    my $self = shift ;
#    $self->{Inf}->inflateCount();
#}

sub crc32
{
    my $self = shift ;
    $self->{Inf}->crc32();
}

sub compressedBytes
{
    my $self = shift ;
    $self->{Inf}->compressedBytes();
}

sub uncompressedBytes
{
    my $self = shift ;
    $self->{Inf}->uncompressedBytes();
}

sub adler32
{
    my $self = shift ;
    $self->{Inf}->adler32();
}

sub sync
{
    my $self = shift ;
    ( $self->{Inf}->inflateSync(@_) == Z_OK) 
            ? STATUS_OK 
            : STATUS_ERROR ;
}


sub getLastBlockOffset
{
    my $self = shift ;
    $self->{Inf}->getLastBlockOffset();
}

sub getEndOffset
{
    my $self = shift ;
    $self->{Inf}->getEndOffset();
}

sub resetLastBlockByte
{
    my $self = shift ;
    $self->{Inf}->resetLastBlockByte(@_);
}

sub createDeflateStream
{
    my $self = shift ;
    my $deflate = $self->{Inf}->createDeflateStream(@_);
    return bless {'Def'        => $deflate,
                  'CompSize'   => 0,
                  'UnCompSize' => 0,
                  'Error'      => '',
                 }, 'IO::Compress::Adapter::Deflate';
}

1;


__END__

                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/IO/Uncompress/AnyInflate.pm                                                   0100644 0000000 0000000 00000066430 12744441327 017724  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::AnyInflate ;

# for RFC1950, RFC1951 or RFC1952

use strict;
use warnings;
use bytes;

use IO::Compress::Base::Common  2.064 ();

use IO::Uncompress::Adapter::Inflate  2.064 ();


use IO::Uncompress::Base  2.064 ;
use IO::Uncompress::Gunzip  2.064 ;
use IO::Uncompress::Inflate  2.064 ;
use IO::Uncompress::RawInflate  2.064 ;
use IO::Uncompress::Unzip  2.064 ;

require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $AnyInflateError);

$VERSION = '2.064';
$AnyInflateError = '';

@ISA = qw( Exporter IO::Uncompress::Base );
@EXPORT_OK = qw( $AnyInflateError anyinflate ) ;
%EXPORT_TAGS = %IO::Uncompress::Base::DEFLATE_CONSTANTS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

# TODO - allow the user to pick a set of the three formats to allow
#        or just assume want to auto-detect any of the three formats.

sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$AnyInflateError);
    $obj->_create(undef, 0, @_);
}

sub anyinflate
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$AnyInflateError);
    return $obj->_inf(@_) ;
}

sub getExtraParams
{
    use IO::Compress::Base::Common  2.064 qw(:Parse);
    return ( 'rawinflate' => [Parse_boolean,  0] ) ;
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # any always needs both crc32 and adler32
    $got->setValue('crc32' => 1);
    $got->setValue('adler32' => 1);

    return 1;
}

sub mkUncomp
{
    my $self = shift ;
    my $got = shift ;

    my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Inflate::mkUncompObject();

    return $self->saveErrorString(undef, $errstr, $errno)
        if ! defined $obj;

    *$self->{Uncomp} = $obj;
    
     my @possible = qw( Inflate Gunzip Unzip );
     unshift @possible, 'RawInflate' 
        if 1 || $got->getValue('rawinflate');

     my $magic = $self->ckMagic( @possible );

     if ($magic) {
        *$self->{Info} = $self->readHeader($magic)
            or return undef ;

        return 1;
     }

     return 0 ;
}



sub ckMagic
{
    my $self = shift;
    my @names = @_ ;

    my $keep = ref $self ;
    for my $class ( map { "IO::Uncompress::$_" } @names)
    {
        bless $self => $class;
        my $magic = $self->ckMagic();

        if ($magic)
        {
            #bless $self => $class;
            return $magic ;
        }

        $self->pushBack(*$self->{HeaderPending})  ;
        *$self->{HeaderPending} = ''  ;
    }    

    bless $self => $keep;
    return undef;
}

1 ;

__END__


=head1 NAME

IO::Uncompress::AnyInflate - Uncompress zlib-based (zip, gzip) file/buffer

=head1 SYNOPSIS

    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

    my $status = anyinflate $input => $output [,OPTS]
        or die "anyinflate failed: $AnyInflateError\n";

    my $z = new IO::Uncompress::AnyInflate $input [OPTS] 
        or die "anyinflate failed: $AnyInflateError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $status = $z->inflateSync()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $AnyInflateError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
files/buffers that have been compressed in a number of formats that use the
zlib compression library.

The formats supported are

=over 5

=item RFC 1950

=item RFC 1951 (optionally)

=item gzip (RFC 1952)

=item zip

=back

The module will auto-detect which, if any, of the supported
compression formats is being used.

=head1 Functional Interface

A top-level function, C<anyinflate>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

    anyinflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "anyinflate failed: $AnyInflateError\n";

The functional interface needs Perl5.005 or better.

=head2 anyinflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<anyinflate> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<anyinflate> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<anyinflate> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<anyinflate>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<anyinflate> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<anyinflate> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.Compressed> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

    my $input = "file1.txt.Compressed";
    my $output = "file1.txt";
    anyinflate $input => $output
        or die "anyinflate failed: $AnyInflateError\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.Compressed"
        or die "Cannot open 'file1.txt.Compressed': $!\n" ;
    my $buffer ;
    anyinflate $input => \$buffer 
        or die "anyinflate failed: $AnyInflateError\n";

To uncompress all files in the directory "/my/home" that match "*.txt.Compressed" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

    anyinflate '</my/home/*.txt.Compressed>' => '</my/home/#1.txt>'
        or die "anyinflate failed: $AnyInflateError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

    for my $input ( glob "/my/home/*.txt.Compressed" )
    {
        my $output = $input;
        $output =~ s/.Compressed// ;
        anyinflate $input => $output 
            or die "Error compressing '$input': $AnyInflateError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::AnyInflate is shown below

    my $z = new IO::Uncompress::AnyInflate $input [OPTS]
        or die "IO::Uncompress::AnyInflate failed: $AnyInflateError\n";

Returns an C<IO::Uncompress::AnyInflate> object on success and undef on failure.
The variable C<$AnyInflateError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::AnyInflate can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::AnyInflate object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::AnyInflate will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option controls whether the extra checks defined below are used when
carrying out the decompression. When Strict is on, the extra tests are
carried out, when Strict is off they are not.

The default for this option is off.

If the input is an RFC 1950 data stream, the following will be checked:

=over 5

=item 1

The ADLER32 checksum field must be present.

=item 2

The value of the ADLER32 field read must match the adler32 value of the
uncompressed data actually contained in the file.

=back

If the input is a gzip (RFC 1952) data stream, the following will be checked:

=over 5

=item 1 

If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the
header must match the crc16 value of the gzip header actually read.

=item 2

If the gzip header contains a name field (FNAME) it consists solely of ISO
8859-1 characters.

=item 3

If the gzip header contains a comment field (FCOMMENT) it consists solely
of ISO 8859-1 characters plus line-feed.

=item 4

If the gzip FEXTRA header field is present it must conform to the sub-field
structure as defined in RFC 1952.

=item 5

The CRC32 and ISIZE trailer fields must be present.

=item 6

The value of the CRC32 field read must match the crc32 value of the
uncompressed data actually contained in the gzip file.

=item 7

The value of the ISIZE fields read must match the length of the
uncompressed data actually read from the file.

=back

=item C<< RawInflate => 0|1 >>

When auto-detecting the compressed format, try to test for raw-deflate (RFC
1951) content using the C<IO::Uncompress::RawInflate> module. 

The reason this is not default behaviour is because RFC 1951 content can
only be detected by attempting to uncompress it. This process is error
prone and can result is false positives.

Defaults to 0.

=item C<< ParseExtra => 0|1 >>
If the gzip FEXTRA header field is present and this option is set, it will
force the module to check that it conforms to the sub-field structure as
defined in RFC 1952.

If the C<Strict> is on it will automatically enable this option.

Defaults to 0.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 inflateSync

Usage is

    $status = $z->inflateSync()

TODO

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::AnyInflate object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::AnyInflate
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::AnyInflate at present. 

=over 5

=item :all

Imports C<anyinflate> and C<$AnyInflateError>.
Same as doing this

    use IO::Uncompress::AnyInflate qw(anyinflate $AnyInflateError) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                        usr/share/perl/5.20.2/IO/Uncompress/AnyUncompress.pm                                                0100644 0000000 0000000 00000071453 12744441327 020501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::AnyUncompress ;

use strict;
use warnings;
use bytes;

use IO::Compress::Base::Common 2.064 ();

use IO::Uncompress::Base 2.064 ;


require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $AnyUncompressError);

$VERSION = '2.064';
$AnyUncompressError = '';

@ISA = qw( Exporter IO::Uncompress::Base );
@EXPORT_OK = qw( $AnyUncompressError anyuncompress ) ;
%EXPORT_TAGS = %IO::Uncompress::Base::DEFLATE_CONSTANTS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

# TODO - allow the user to pick a set of the three formats to allow
#        or just assume want to auto-detect any of the three formats.

BEGIN
{
   local @INC = @INC;
   pop @INC if $INC[-1] eq '.';
   eval ' use IO::Uncompress::Adapter::Inflate 2.064 ;';
   eval ' use IO::Uncompress::Adapter::Bunzip2 2.064 ;';
   eval ' use IO::Uncompress::Adapter::LZO 2.064 ;';
   eval ' use IO::Uncompress::Adapter::Lzf 2.064 ;';
   eval ' use IO::Uncompress::Adapter::UnLzma 2.064 ;';
   eval ' use IO::Uncompress::Adapter::UnXz 2.064 ;';

   eval ' use IO::Uncompress::Bunzip2 2.064 ;';
   eval ' use IO::Uncompress::UnLzop 2.064 ;';
   eval ' use IO::Uncompress::Gunzip 2.064 ;';
   eval ' use IO::Uncompress::Inflate 2.064 ;';
   eval ' use IO::Uncompress::RawInflate 2.064 ;';
   eval ' use IO::Uncompress::Unzip 2.064 ;';
   eval ' use IO::Uncompress::UnLzf 2.064 ;';
   eval ' use IO::Uncompress::UnLzma 2.064 ;';
   eval ' use IO::Uncompress::UnXz 2.064 ;';
}

sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$AnyUncompressError);
    $obj->_create(undef, 0, @_);
}

sub anyuncompress
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$AnyUncompressError);
    return $obj->_inf(@_) ;
}

sub getExtraParams
{ 
    return ( 'rawinflate' => [IO::Compress::Base::Common::Parse_boolean,  0] ,
             'unlzma'     => [IO::Compress::Base::Common::Parse_boolean,  0] ) ;
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # any always needs both crc32 and adler32
    $got->setValue('crc32' => 1);
    $got->setValue('adler32' => 1);

    return 1;
}

sub mkUncomp
{
    my $self = shift ;
    my $got = shift ;

    my $magic ;

    # try zlib first
    if (defined $IO::Uncompress::RawInflate::VERSION )
    {
        my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Inflate::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;
        
        my @possible = qw( Inflate Gunzip Unzip );
        unshift @possible, 'RawInflate' 
            if $got->getValue('rawinflate');

        $magic = $self->ckMagic( @possible );
        
        if ($magic) {
            *$self->{Info} = $self->readHeader($magic)
                or return undef ;

            return 1;
        }
     }

    if (defined $IO::Uncompress::UnLzma::VERSION && $got->getValue('unlzma'))
    {
        my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::UnLzma::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;
        
        my @possible = qw( UnLzma );
        #unshift @possible, 'RawInflate' 
        #    if $got->getValue('rawinflate');

        if ( *$self->{Info} = $self->ckMagic( @possible ))
        {
            return 1;
        }
     }

     if (defined $IO::Uncompress::UnXz::VERSION and
         $magic = $self->ckMagic('UnXz')) {
        *$self->{Info} = $self->readHeader($magic)
            or return undef ;

        my ($obj, $errstr, $errno) =
            IO::Uncompress::Adapter::UnXz::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;

         return 1;
     }

     if (defined $IO::Uncompress::Bunzip2::VERSION and
         $magic = $self->ckMagic('Bunzip2')) {
        *$self->{Info} = $self->readHeader($magic)
            or return undef ;

        my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Bunzip2::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;

         return 1;
     }

     if (defined $IO::Uncompress::UnLzop::VERSION and
            $magic = $self->ckMagic('UnLzop')) {

        *$self->{Info} = $self->readHeader($magic)
            or return undef ;

        my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::LZO::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;

         return 1;
     }

     if (defined $IO::Uncompress::UnLzf::VERSION and
            $magic = $self->ckMagic('UnLzf')) {

        *$self->{Info} = $self->readHeader($magic)
            or return undef ;

        my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Lzf::mkUncompObject();

        return $self->saveErrorString(undef, $errstr, $errno)
            if ! defined $obj;

        *$self->{Uncomp} = $obj;

         return 1;
     }

     return 0 ;
}



sub ckMagic
{
    my $self = shift;
    my @names = @_ ;

    my $keep = ref $self ;
    for my $class ( map { "IO::Uncompress::$_" } @names)
    {
        bless $self => $class;
        my $magic = $self->ckMagic();

        if ($magic)
        {
            #bless $self => $class;
            return $magic ;
        }

        $self->pushBack(*$self->{HeaderPending})  ;
        *$self->{HeaderPending} = ''  ;
    }    

    bless $self => $keep;
    return undef;
}

1 ;

__END__


=head1 NAME

IO::Uncompress::AnyUncompress - Uncompress gzip, zip, bzip2 or lzop file/buffer

=head1 SYNOPSIS

    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

    my $status = anyuncompress $input => $output [,OPTS]
        or die "anyuncompress failed: $AnyUncompressError\n";

    my $z = new IO::Uncompress::AnyUncompress $input [OPTS] 
        or die "anyuncompress failed: $AnyUncompressError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $AnyUncompressError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
files/buffers that have been compressed with a variety of compression
libraries.

The formats supported are:

=over 5

=item RFC 1950

=item RFC 1951 (optionally)

=item gzip (RFC 1952)

=item zip

=item bzip2

=item lzop

=item lzf

=item lzma

=item xz

=back

The module will auto-detect which, if any, of the supported
compression formats is being used.

=head1 Functional Interface

A top-level function, C<anyuncompress>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

    anyuncompress $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "anyuncompress failed: $AnyUncompressError\n";

The functional interface needs Perl5.005 or better.

=head2 anyuncompress $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<anyuncompress> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<anyuncompress> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<anyuncompress> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<anyuncompress>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<anyuncompress> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<anyuncompress> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.Compressed> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

    my $input = "file1.txt.Compressed";
    my $output = "file1.txt";
    anyuncompress $input => $output
        or die "anyuncompress failed: $AnyUncompressError\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.Compressed"
        or die "Cannot open 'file1.txt.Compressed': $!\n" ;
    my $buffer ;
    anyuncompress $input => \$buffer 
        or die "anyuncompress failed: $AnyUncompressError\n";

To uncompress all files in the directory "/my/home" that match "*.txt.Compressed" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

    anyuncompress '</my/home/*.txt.Compressed>' => '</my/home/#1.txt>'
        or die "anyuncompress failed: $AnyUncompressError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

    for my $input ( glob "/my/home/*.txt.Compressed" )
    {
        my $output = $input;
        $output =~ s/.Compressed// ;
        anyuncompress $input => $output 
            or die "Error compressing '$input': $AnyUncompressError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::AnyUncompress is shown below

    my $z = new IO::Uncompress::AnyUncompress $input [OPTS]
        or die "IO::Uncompress::AnyUncompress failed: $AnyUncompressError\n";

Returns an C<IO::Uncompress::AnyUncompress> object on success and undef on failure.
The variable C<$AnyUncompressError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::AnyUncompress can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::AnyUncompress object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::AnyUncompress will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option controls whether the extra checks defined below are used when
carrying out the decompression. When Strict is on, the extra tests are
carried out, when Strict is off they are not.

The default for this option is off.

=item C<< RawInflate => 0|1 >>

When auto-detecting the compressed format, try to test for raw-deflate (RFC
1951) content using the C<IO::Uncompress::RawInflate> module. 

The reason this is not default behaviour is because RFC 1951 content can
only be detected by attempting to uncompress it. This process is error
prone and can result is false positives.

Defaults to 0.

=item C<< UnLzma => 0|1 >>

When auto-detecting the compressed format, try to test for lzma_alone
content using the C<IO::Uncompress::UnLzma> module. 

The reason this is not default behaviour is because lzma_alone content can
only be detected by attempting to uncompress it. This process is error
prone and can result is false positives.

Defaults to 0.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::AnyUncompress object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::AnyUncompress
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::AnyUncompress at present. 

=over 5

=item :all

Imports C<anyuncompress> and C<$AnyUncompressError>.
Same as doing this

    use IO::Uncompress::AnyUncompress qw(anyuncompress $AnyUncompressError) ;

=back

=head1 EXAMPLES

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                     usr/share/perl/5.20.2/IO/Uncompress/Base.pm                                                         0100644 0000000 0000000 00000112314 12744441327 016535  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package IO::Uncompress::Base ;

use strict ;
use warnings;
#use bytes;

our (@ISA, $VERSION, @EXPORT_OK, %EXPORT_TAGS);
@ISA    = qw(Exporter IO::File);


$VERSION = '2.064';

use constant G_EOF => 0 ;
use constant G_ERR => -1 ;

use IO::Compress::Base::Common 2.064 ;

use IO::File ;
use Symbol;
use Scalar::Util ();
use List::Util ();
use Carp ;

%EXPORT_TAGS = ( );
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;

sub smartRead
{
    my $self = $_[0];
    my $out = $_[1];
    my $size = $_[2];
    $$out = "" ;

    my $offset = 0 ;
    my $status = 1;


    if (defined *$self->{InputLength}) {
        return 0
            if *$self->{InputLengthRemaining} <= 0 ;
        $size = List::Util::min($size, *$self->{InputLengthRemaining});
    }

    if ( length *$self->{Prime} ) {
        $$out = substr(*$self->{Prime}, 0, $size) ;
        substr(*$self->{Prime}, 0, $size) =  '' ;
        if (length $$out == $size) {
            *$self->{InputLengthRemaining} -= length $$out
                if defined *$self->{InputLength};

            return length $$out ;
        }
        $offset = length $$out ;
    }

    my $get_size = $size - $offset ;

    if (defined *$self->{FH}) {
        if ($offset) {
            # Not using this 
            #
            #  *$self->{FH}->read($$out, $get_size, $offset);
            #
            # because the filehandle may not support the offset parameter
            # An example is Net::FTP
            my $tmp = '';
            $status = *$self->{FH}->read($tmp, $get_size) ;
            substr($$out, $offset) = $tmp
                if defined $status && $status > 0 ;
        }
        else
          { $status = *$self->{FH}->read($$out, $get_size) }
    }
    elsif (defined *$self->{InputEvent}) {
        my $got = 1 ;
        while (length $$out < $size) {
            last 
                if ($got = *$self->{InputEvent}->($$out, $get_size)) <= 0;
        }

        if (length $$out > $size ) {
            *$self->{Prime} = substr($$out, $size, length($$out));
            substr($$out, $size, length($$out)) =  '';
        }

       *$self->{EventEof} = 1 if $got <= 0 ;
    }
    else {
       no warnings 'uninitialized';
       my $buf = *$self->{Buffer} ;
       $$buf = '' unless defined $$buf ;
       substr($$out, $offset) = substr($$buf, *$self->{BufferOffset}, $get_size);
       if (*$self->{ConsumeInput})
         { substr($$buf, 0, $get_size) = '' }
       else  
         { *$self->{BufferOffset} += length($$out) - $offset }
    }

    *$self->{InputLengthRemaining} -= length($$out) #- $offset 
        if defined *$self->{InputLength};
        
    if (! defined $status) {
        $self->saveStatus($!) ;
        return STATUS_ERROR;
    }

    $self->saveStatus(length $$out < 0 ? STATUS_ERROR : STATUS_OK) ;

    return length $$out;
}

sub pushBack
{
    my $self = shift ;

    return if ! defined $_[0] || length $_[0] == 0 ;

    if (defined *$self->{FH} || defined *$self->{InputEvent} ) {
        *$self->{Prime} = $_[0] . *$self->{Prime} ;
        *$self->{InputLengthRemaining} += length($_[0]);
    }
    else {
        my $len = length $_[0];

        if($len > *$self->{BufferOffset}) {
            *$self->{Prime} = substr($_[0], 0, $len - *$self->{BufferOffset}) . *$self->{Prime} ;
            *$self->{InputLengthRemaining} = *$self->{InputLength};
            *$self->{BufferOffset} = 0
        }
        else {
            *$self->{InputLengthRemaining} += length($_[0]);
            *$self->{BufferOffset} -= length($_[0]) ;
        }
    }
}

sub smartSeek
{
    my $self   = shift ;
    my $offset = shift ;
    my $truncate = shift;
    my $position = shift || SEEK_SET;

    # TODO -- need to take prime into account
    if (defined *$self->{FH})
      { *$self->{FH}->seek($offset, $position) }
    else {
        if ($position == SEEK_END) {
            *$self->{BufferOffset} = length ${ *$self->{Buffer} } + $offset ;
        }
        elsif ($position == SEEK_CUR) {
            *$self->{BufferOffset} += $offset ;
        }
        else {
            *$self->{BufferOffset} = $offset ;
        }

        substr(${ *$self->{Buffer} }, *$self->{BufferOffset}) = ''
            if $truncate;
        return 1;
    }
}

sub smartTell
{
    my $self   = shift ;

    if (defined *$self->{FH})
      { return *$self->{FH}->tell() }
    else 
      { return *$self->{BufferOffset} }
}

sub smartWrite
{
    my $self   = shift ;
    my $out_data = shift ;

    if (defined *$self->{FH}) {
        # flush needed for 5.8.0 
        defined *$self->{FH}->write($out_data, length $out_data) &&
        defined *$self->{FH}->flush() ;
    }
    else {
       my $buf = *$self->{Buffer} ;
       substr($$buf, *$self->{BufferOffset}, length $out_data) = $out_data ;
       *$self->{BufferOffset} += length($out_data) ;
       return 1;
    }
}

sub smartReadExact
{
    return $_[0]->smartRead($_[1], $_[2]) == $_[2];
}

sub smartEof
{
    my ($self) = $_[0];
    local $.; 

    return 0 if length *$self->{Prime} || *$self->{PushMode};

    if (defined *$self->{FH})
    {
        # Could use
        #
        #  *$self->{FH}->eof() 
        #
        # here, but this can cause trouble if
        # the filehandle is itself a tied handle, but it uses sysread.
        # Then we get into mixing buffered & non-buffered IO, 
        # which will cause trouble

        my $info = $self->getErrInfo();
        
        my $buffer = '';
        my $status = $self->smartRead(\$buffer, 1);
        $self->pushBack($buffer) if length $buffer;
        $self->setErrInfo($info);

        return $status == 0 ;
    }
    elsif (defined *$self->{InputEvent})
     { *$self->{EventEof} }
    else 
     { *$self->{BufferOffset} >= length(${ *$self->{Buffer} }) }
}

sub clearError
{
    my $self   = shift ;

    *$self->{ErrorNo}  =  0 ;
    ${ *$self->{Error} } = '' ;
}

sub getErrInfo
{
    my $self   = shift ;

    return [ *$self->{ErrorNo}, ${ *$self->{Error} } ] ;
}

sub setErrInfo
{
    my $self   = shift ;
    my $ref    = shift;

    *$self->{ErrorNo}  =  $ref->[0] ;
    ${ *$self->{Error} } = $ref->[1] ;
}

sub saveStatus
{
    my $self   = shift ;
    my $errno = shift() + 0 ;

    *$self->{ErrorNo}  = $errno;
    ${ *$self->{Error} } = '' ;

    return *$self->{ErrorNo} ;
}


sub saveErrorString
{
    my $self   = shift ;
    my $retval = shift ;

    ${ *$self->{Error} } = shift ;
    *$self->{ErrorNo} = @_ ? shift() + 0 : STATUS_ERROR ;

    return $retval;
}

sub croakError
{
    my $self   = shift ;
    $self->saveErrorString(0, $_[0]);
    croak $_[0];
}


sub closeError
{
    my $self = shift ;
    my $retval = shift ;

    my $errno = *$self->{ErrorNo};
    my $error = ${ *$self->{Error} };

    $self->close();

    *$self->{ErrorNo} = $errno ;
    ${ *$self->{Error} } = $error ;

    return $retval;
}

sub error
{
    my $self   = shift ;
    return ${ *$self->{Error} } ;
}

sub errorNo
{
    my $self   = shift ;
    return *$self->{ErrorNo};
}

sub HeaderError
{
    my ($self) = shift;
    return $self->saveErrorString(undef, "Header Error: $_[0]", STATUS_ERROR);
}

sub TrailerError
{
    my ($self) = shift;
    return $self->saveErrorString(G_ERR, "Trailer Error: $_[0]", STATUS_ERROR);
}

sub TruncatedHeader
{
    my ($self) = shift;
    return $self->HeaderError("Truncated in $_[0] Section");
}

sub TruncatedTrailer
{
    my ($self) = shift;
    return $self->TrailerError("Truncated in $_[0] Section");
}

sub postCheckParams
{
    return 1;
}

sub checkParams
{
    my $self = shift ;
    my $class = shift ;

    my $got = shift || IO::Compress::Base::Parameters::new();
    
    my $Valid = {
                    'blocksize'     => [IO::Compress::Base::Common::Parse_unsigned, 16 * 1024],
                    'autoclose'     => [IO::Compress::Base::Common::Parse_boolean,  0],
                    'strict'        => [IO::Compress::Base::Common::Parse_boolean,  0],
                    'append'        => [IO::Compress::Base::Common::Parse_boolean,  0],
                    'prime'         => [IO::Compress::Base::Common::Parse_any,      undef],
                    'multistream'   => [IO::Compress::Base::Common::Parse_boolean,  0],
                    'transparent'   => [IO::Compress::Base::Common::Parse_any,      1],
                    'scan'          => [IO::Compress::Base::Common::Parse_boolean,  0],
                    'inputlength'   => [IO::Compress::Base::Common::Parse_unsigned, undef],
                    'binmodeout'    => [IO::Compress::Base::Common::Parse_boolean,  0],
                   #'decode'        => [IO::Compress::Base::Common::Parse_any,      undef],

                   #'consumeinput'  => [IO::Compress::Base::Common::Parse_boolean,  0],
                   
                    $self->getExtraParams(),

                    #'Todo - Revert to ordinary file on end Z_STREAM_END'=> 0,
                    # ContinueAfterEof
                } ;

    $Valid->{trailingdata} = [IO::Compress::Base::Common::Parse_writable_scalar, undef]
        if  *$self->{OneShot} ;
        
    $got->parse($Valid, @_ ) 
        or $self->croakError("${class}: " . $got->getError()) ;

    $self->postCheckParams($got) 
        or $self->croakError("${class}: " . $self->error()) ;

    return $got;
}

sub _create
{
    my $obj = shift;
    my $got = shift;
    my $append_mode = shift ;

    my $class = ref $obj;
    $obj->croakError("$class: Missing Input parameter")
        if ! @_ && ! $got ;

    my $inValue = shift ;

    *$obj->{OneShot} = 0 ;

    if (! $got)
    {
        $got = $obj->checkParams($class, undef, @_)
            or return undef ;
    }

    my $inType  = whatIsInput($inValue, 1);

    $obj->ckInputParam($class, $inValue, 1) 
        or return undef ;

    *$obj->{InNew} = 1;

    $obj->ckParams($got)
        or $obj->croakError("${class}: " . *$obj->{Error});

    if ($inType eq 'buffer' || $inType eq 'code') {
        *$obj->{Buffer} = $inValue ;        
        *$obj->{InputEvent} = $inValue 
           if $inType eq 'code' ;
    }
    else {
        if ($inType eq 'handle') {
            *$obj->{FH} = $inValue ;
            *$obj->{Handle} = 1 ;

            # Need to rewind for Scan
            *$obj->{FH}->seek(0, SEEK_SET) 
                if $got->getValue('scan');
        }  
        else {    
            no warnings ;
            my $mode = '<';
            $mode = '+<' if $got->getValue('scan');
            *$obj->{StdIO} = ($inValue eq '-');
            *$obj->{FH} = new IO::File "$mode $inValue"
                or return $obj->saveErrorString(undef, "cannot open file '$inValue': $!", $!) ;
        }
        
        *$obj->{LineNo} = $. = 0;
        setBinModeInput(*$obj->{FH}) ;

        my $buff = "" ;
        *$obj->{Buffer} = \$buff ;
    }

#    if ($got->getValue('decode')) { 
#        my $want_encoding = $got->getValue('decode');
#        *$obj->{Encoding} = IO::Compress::Base::Common::getEncoding($obj, $class, $want_encoding);
#    }
#    else {
#        *$obj->{Encoding} = undef;
#    }

    *$obj->{InputLength}       = $got->parsed('inputlength') 
                                    ? $got->getValue('inputlength')
                                    : undef ;
    *$obj->{InputLengthRemaining} = $got->getValue('inputlength');
    *$obj->{BufferOffset}      = 0 ;
    *$obj->{AutoClose}         = $got->getValue('autoclose');
    *$obj->{Strict}            = $got->getValue('strict');
    *$obj->{BlockSize}         = $got->getValue('blocksize');
    *$obj->{Append}            = $got->getValue('append');
    *$obj->{AppendOutput}      = $append_mode || $got->getValue('append');
    *$obj->{ConsumeInput}      = $got->getValue('consumeinput');
    *$obj->{Transparent}       = $got->getValue('transparent');
    *$obj->{MultiStream}       = $got->getValue('multistream');

    # TODO - move these two into RawDeflate
    *$obj->{Scan}              = $got->getValue('scan');
    *$obj->{ParseExtra}        = $got->getValue('parseextra') 
                                  || $got->getValue('strict')  ;
    *$obj->{Type}              = '';
    *$obj->{Prime}             = $got->getValue('prime') || '' ;
    *$obj->{Pending}           = '';
    *$obj->{Plain}             = 0;
    *$obj->{PlainBytesRead}    = 0;
    *$obj->{InflatedBytesRead} = 0;
    *$obj->{UnCompSize}        = new U64;
    *$obj->{CompSize}          = new U64;
    *$obj->{TotalInflatedBytesRead} = 0;
    *$obj->{NewStream}         = 0 ;
    *$obj->{EventEof}          = 0 ;
    *$obj->{ClassName}         = $class ;
    *$obj->{Params}            = $got ;

    if (*$obj->{ConsumeInput}) {
        *$obj->{InNew} = 0;
        *$obj->{Closed} = 0;
        return $obj
    }

    my $status = $obj->mkUncomp($got);

    return undef
        unless defined $status;

    *$obj->{InNew} = 0;
    *$obj->{Closed} = 0;

    if ($status) {
        # Need to try uncompressing to catch the case
        # where the compressed file uncompresses to an
        # empty string - so eof is set immediately.
        
        my $out_buffer = '';

        $status = $obj->read(\$out_buffer);
    
        if ($status < 0) {
            *$obj->{ReadStatus} = [ $status, $obj->error(), $obj->errorNo() ];
        }

        $obj->ungetc($out_buffer)
            if length $out_buffer;
    }
    else {
        return undef 
            unless *$obj->{Transparent};

        $obj->clearError();
        *$obj->{Type} = 'plain';
        *$obj->{Plain} = 1;
        $obj->pushBack(*$obj->{HeaderPending})  ;
    }

    push @{ *$obj->{InfoList} }, *$obj->{Info} ;

    $obj->saveStatus(STATUS_OK) ;
    *$obj->{InNew} = 0;
    *$obj->{Closed} = 0;

    return $obj;
}

sub ckInputParam
{
    my $self = shift ;
    my $from = shift ;
    my $inType = whatIsInput($_[0], $_[1]);

    $self->croakError("$from: input parameter not a filename, filehandle, array ref or scalar ref")
        if ! $inType ;

#    if ($inType  eq 'filename' )
#    {
#        return $self->saveErrorString(1, "$from: input filename is undef or null string", STATUS_ERROR)
#            if ! defined $_[0] || $_[0] eq ''  ;
#
#        if ($_[0] ne '-' && ! -e $_[0] )
#        {
#            return $self->saveErrorString(1, 
#                            "input file '$_[0]' does not exist", STATUS_ERROR);
#        }
#    }

    return 1;
}


sub _inf
{
    my $obj = shift ;

    my $class = (caller)[0] ;
    my $name = (caller(1))[3] ;

    $obj->croakError("$name: expected at least 1 parameters\n")
        unless @_ >= 1 ;

    my $input = shift ;
    my $haveOut = @_ ;
    my $output = shift ;


    my $x = new IO::Compress::Base::Validator($class, *$obj->{Error}, $name, $input, $output)
        or return undef ;
    
    push @_, $output if $haveOut && $x->{Hash};

    *$obj->{OneShot} = 1 ;
    
    my $got = $obj->checkParams($name, undef, @_)
        or return undef ;

    if ($got->parsed('trailingdata'))
    {
#        my $value = $got->valueRef('TrailingData');
#        warn "TD $value ";
#        #$value = $$value;
##                warn "TD $value $$value ";
#       
#        return retErr($obj, "Parameter 'TrailingData' not writable")
#            if readonly $$value ;          
#
#        if (ref $$value) 
#        {
#            return retErr($obj,"Parameter 'TrailingData' not a scalar reference")
#                if ref $$value ne 'SCALAR' ;
#              
#            *$obj->{TrailingData} = $$value ;
#        }
#        else  
#        {
#            return retErr($obj,"Parameter 'TrailingData' not a scalar")
#                if ref $value ne 'SCALAR' ;               
#
#            *$obj->{TrailingData} = $value ;
#        }
        
        *$obj->{TrailingData} = $got->getValue('trailingdata');
    }

    *$obj->{MultiStream} = $got->getValue('multistream');
    $got->setValue('multistream', 0);

    $x->{Got} = $got ;

#    if ($x->{Hash})
#    {
#        while (my($k, $v) = each %$input)
#        {
#            $v = \$input->{$k} 
#                unless defined $v ;
#
#            $obj->_singleTarget($x, $k, $v, @_)
#                or return undef ;
#        }
#
#        return keys %$input ;
#    }
    
    if ($x->{GlobMap})
    {
        $x->{oneInput} = 1 ;
        foreach my $pair (@{ $x->{Pairs} })
        {
            my ($from, $to) = @$pair ;
            $obj->_singleTarget($x, $from, $to, @_)
                or return undef ;
        }

        return scalar @{ $x->{Pairs} } ;
    }

    if (! $x->{oneOutput} )
    {
        my $inFile = ($x->{inType} eq 'filenames' 
                        || $x->{inType} eq 'filename');

        $x->{inType} = $inFile ? 'filename' : 'buffer';
        
        foreach my $in ($x->{oneInput} ? $input : @$input)
        {
            my $out ;
            $x->{oneInput} = 1 ;

            $obj->_singleTarget($x, $in, $output, @_)
                or return undef ;
        }

        return 1 ;
    }

    # finally the 1 to 1 and n to 1
    return $obj->_singleTarget($x, $input, $output, @_);

    croak "should not be here" ;
}

sub retErr
{
    my $x = shift ;
    my $string = shift ;

    ${ $x->{Error} } = $string ;

    return undef ;
}

sub _singleTarget
{
    my $self      = shift ;
    my $x         = shift ;
    my $input     = shift;
    my $output    = shift;
    
    my $buff = '';
    $x->{buff} = \$buff ;

    my $fh ;
    if ($x->{outType} eq 'filename') {
        my $mode = '>' ;
        $mode = '>>'
            if $x->{Got}->getValue('append') ;
        $x->{fh} = new IO::File "$mode $output" 
            or return retErr($x, "cannot open file '$output': $!") ;
        binmode $x->{fh} if $x->{Got}->valueOrDefault('binmodeout');

    }

    elsif ($x->{outType} eq 'handle') {
        $x->{fh} = $output;
        binmode $x->{fh} if $x->{Got}->valueOrDefault('binmodeout');
        if ($x->{Got}->getValue('append')) {
                seek($x->{fh}, 0, SEEK_END)
                    or return retErr($x, "Cannot seek to end of output filehandle: $!") ;
            }
    }

    
    elsif ($x->{outType} eq 'buffer' )
    {
        $$output = '' 
            unless $x->{Got}->getValue('append');
        $x->{buff} = $output ;
    }

    if ($x->{oneInput})
    {
        defined $self->_rd2($x, $input, $output)
            or return undef; 
    }
    else
    {
        for my $element ( ($x->{inType} eq 'hash') ? keys %$input : @$input)
        {
            defined $self->_rd2($x, $element, $output) 
                or return undef ;
        }
    }


    if ( ($x->{outType} eq 'filename' && $output ne '-') || 
         ($x->{outType} eq 'handle' && $x->{Got}->getValue('autoclose'))) {
        $x->{fh}->close() 
            or return retErr($x, $!); 
        delete $x->{fh};
    }

    return 1 ;
}

sub _rd2
{
    my $self      = shift ;
    my $x         = shift ;
    my $input     = shift;
    my $output    = shift;
        
    my $z = IO::Compress::Base::Common::createSelfTiedObject($x->{Class}, *$self->{Error});
    
    $z->_create($x->{Got}, 1, $input, @_)
        or return undef ;

    my $status ;
    my $fh = $x->{fh};
    
    while (1) {

        while (($status = $z->read($x->{buff})) > 0) {
            if ($fh) {
                local $\;
                print $fh ${ $x->{buff} }
                    or return $z->saveErrorString(undef, "Error writing to output file: $!", $!);
                ${ $x->{buff} } = '' ;
            }
        }

        if (! $x->{oneOutput} ) {
            my $ot = $x->{outType} ;

            if ($ot eq 'array') 
              { push @$output, $x->{buff} }
            elsif ($ot eq 'hash') 
              { $output->{$input} = $x->{buff} }

            my $buff = '';
            $x->{buff} = \$buff;
        }

        last if $status < 0 || $z->smartEof();

        last 
            unless *$self->{MultiStream};

        $status = $z->nextStream();

        last 
            unless $status == 1 ;
    }

    return $z->closeError(undef)
        if $status < 0 ;

    ${ *$self->{TrailingData} } = $z->trailingData()
        if defined *$self->{TrailingData} ;

    $z->close() 
        or return undef ;

    return 1 ;
}

sub TIEHANDLE
{
    return $_[0] if ref($_[0]);
    die "OOPS\n" ;

}
  
sub UNTIE
{
    my $self = shift ;
}


sub getHeaderInfo
{
    my $self = shift ;
    wantarray ? @{ *$self->{InfoList} } : *$self->{Info};
}

sub readBlock
{
    my $self = shift ;
    my $buff = shift ;
    my $size = shift ;

    if (defined *$self->{CompressedInputLength}) {
        if (*$self->{CompressedInputLengthRemaining} == 0) {
            delete *$self->{CompressedInputLength};
            *$self->{CompressedInputLengthDone} = 1;
            return STATUS_OK ;
        }
        $size = List::Util::min($size, *$self->{CompressedInputLengthRemaining} );
        *$self->{CompressedInputLengthRemaining} -= $size ;
    }
    
    my $status = $self->smartRead($buff, $size) ;
    return $self->saveErrorString(STATUS_ERROR, "Error Reading Data: $!", $!)
        if $status == STATUS_ERROR  ;

    if ($status == 0 ) {
        *$self->{Closed} = 1 ;
        *$self->{EndStream} = 1 ;
        return $self->saveErrorString(STATUS_ERROR, "unexpected end of file", STATUS_ERROR);
    }

    return STATUS_OK;
}

sub postBlockChk
{
    return STATUS_OK;
}

sub _raw_read
{
    # return codes
    # >0 - ok, number of bytes read
    # =0 - ok, eof
    # <0 - not ok
    
    my $self = shift ;

    return G_EOF if *$self->{Closed} ;
    return G_EOF if *$self->{EndStream} ;

    my $buffer = shift ;
    my $scan_mode = shift ;

    if (*$self->{Plain}) {
        my $tmp_buff ;
        my $len = $self->smartRead(\$tmp_buff, *$self->{BlockSize}) ;
        
        return $self->saveErrorString(G_ERR, "Error reading data: $!", $!) 
                if $len == STATUS_ERROR ;

        if ($len == 0 ) {
            *$self->{EndStream} = 1 ;
        }
        else {
            *$self->{PlainBytesRead} += $len ;
            $$buffer .= $tmp_buff;
        }

        return $len ;
    }

    if (*$self->{NewStream}) {

        $self->gotoNextStream() > 0
            or return G_ERR;

        # For the headers that actually uncompressed data, put the
        # uncompressed data into the output buffer.
        $$buffer .=  *$self->{Pending} ;
        my $len = length  *$self->{Pending} ;
        *$self->{Pending} = '';
        return $len; 
    }

    my $temp_buf = '';
    my $outSize = 0;
    my $status = $self->readBlock(\$temp_buf, *$self->{BlockSize}, $outSize) ;
    
    return G_ERR
        if $status == STATUS_ERROR  ;

    my $buf_len = 0;
    if ($status == STATUS_OK) {
        my $beforeC_len = length $temp_buf;
        my $before_len = defined $$buffer ? length $$buffer : 0 ;
        $status = *$self->{Uncomp}->uncompr(\$temp_buf, $buffer,
                                    defined *$self->{CompressedInputLengthDone} ||
                                                $self->smartEof(), $outSize);
                                                
        # Remember the input buffer if it wasn't consumed completely
        $self->pushBack($temp_buf) if *$self->{Uncomp}{ConsumesInput};

        return $self->saveErrorString(G_ERR, *$self->{Uncomp}{Error}, *$self->{Uncomp}{ErrorNo})
            if $self->saveStatus($status) == STATUS_ERROR;    

        $self->postBlockChk($buffer, $before_len) == STATUS_OK
            or return G_ERR;

        $buf_len = defined $$buffer ? length($$buffer) - $before_len : 0;
    
        *$self->{CompSize}->add($beforeC_len - length $temp_buf) ;

        *$self->{InflatedBytesRead} += $buf_len ;
        *$self->{TotalInflatedBytesRead} += $buf_len ;
        *$self->{UnCompSize}->add($buf_len) ;

        $self->filterUncompressed($buffer, $before_len);

#        if (*$self->{Encoding}) {
#            use Encode ;
#            *$self->{PendingDecode} .= substr($$buffer, $before_len) ;
#            my $got = *$self->{Encoding}->decode(*$self->{PendingDecode}, Encode::FB_QUIET) ;
#            substr($$buffer, $before_len) = $got;
#        }
    }

    if ($status == STATUS_ENDSTREAM) {

        *$self->{EndStream} = 1 ;

        my $trailer;
        my $trailer_size = *$self->{Info}{TrailerLength} ;
        my $got = 0;
        if (*$self->{Info}{TrailerLength})
        {
            $got = $self->smartRead(\$trailer, $trailer_size) ;
        }

        if ($got == $trailer_size) {
            $self->chkTrailer($trailer) == STATUS_OK
                or return G_ERR;
        }
        else {
            return $self->TrailerError("trailer truncated. Expected " . 
                                      "$trailer_size bytes, got $got")
                if *$self->{Strict};
            $self->pushBack($trailer)  ;
        }

        # TODO - if want file pointer, do it here

        if (! $self->smartEof()) {
            *$self->{NewStream} = 1 ;

            if (*$self->{MultiStream}) {
                *$self->{EndStream} = 0 ;
                return $buf_len ;
            }
        }

    }
    

    # return the number of uncompressed bytes read
    return $buf_len ;
}

sub reset
{
    my $self = shift ;

    return *$self->{Uncomp}->reset();
}

sub filterUncompressed
{
}

#sub isEndStream
#{
#    my $self = shift ;
#    return *$self->{NewStream} ||
#           *$self->{EndStream} ;
#}

sub nextStream
{
    my $self = shift ;

    my $status = $self->gotoNextStream();
    $status == 1
        or return $status ;

    *$self->{TotalInflatedBytesRead} = 0 ;
    *$self->{LineNo} = $. = 0;

    return 1;
}

sub gotoNextStream
{
    my $self = shift ;

    if (! *$self->{NewStream}) {
        my $status = 1;
        my $buffer ;

        # TODO - make this more efficient if know the offset for the end of
        # the stream and seekable
        $status = $self->read($buffer) 
            while $status > 0 ;

        return $status
            if $status < 0;
    }

    *$self->{NewStream} = 0 ;
    *$self->{EndStream} = 0 ;
    *$self->{CompressedInputLengthDone} = undef ;
    *$self->{CompressedInputLength} = undef ;
    $self->reset();
    *$self->{UnCompSize}->reset();
    *$self->{CompSize}->reset();

    my $magic = $self->ckMagic();

    if ( ! defined $magic) {
        if (! *$self->{Transparent} || $self->eof())
        {
            *$self->{EndStream} = 1 ;
            return 0;
        }

        $self->clearError();
        *$self->{Type} = 'plain';
        *$self->{Plain} = 1;
        $self->pushBack(*$self->{HeaderPending})  ;
    }
    else
    {
        *$self->{Info} = $self->readHeader($magic);

        if ( ! defined *$self->{Info} ) {
            *$self->{EndStream} = 1 ;
            return -1;
        }
    }

    push @{ *$self->{InfoList} }, *$self->{Info} ;

    return 1; 
}

sub streamCount
{
    my $self = shift ;
    return 1 if ! defined *$self->{InfoList};
    return scalar @{ *$self->{InfoList} }  ;
}

#sub read
#{
#    my $status = myRead(@_);
#    return undef if $status < 0;
#    return $status;
#}

sub read
{
    # return codes
    # >0 - ok, number of bytes read
    # =0 - ok, eof
    # <0 - not ok
    
    my $self = shift ;

    if (defined *$self->{ReadStatus} ) {
        my $status = *$self->{ReadStatus}[0];
        $self->saveErrorString( @{ *$self->{ReadStatus} } );
        delete  *$self->{ReadStatus} ;
        return $status ;
    }

    return G_EOF if *$self->{Closed} ;

    my $buffer ;

    if (ref $_[0] ) {
        $self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
            if Scalar::Util::readonly(${ $_[0] });

        $self->croakError(*$self->{ClassName} . "::read: not a scalar reference $_[0]" )
            unless ref $_[0] eq 'SCALAR' ;
        $buffer = $_[0] ;
    }
    else {
        $self->croakError(*$self->{ClassName} . "::read: buffer parameter is read-only")
            if Scalar::Util::readonly($_[0]);

        $buffer = \$_[0] ;
    }

    my $length = $_[1] ;
    my $offset = $_[2] || 0;

    if (! *$self->{AppendOutput}) {
        if (! $offset) {    
            $$buffer = '' ;
        }
        else {
            if ($offset > length($$buffer)) {
                $$buffer .= "\x00" x ($offset - length($$buffer));
            }
            else {
                substr($$buffer, $offset) = '';
            }
        }
    }
    elsif (! defined $$buffer) {
        $$buffer = '' ;
    }

    return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;

    # the core read will return 0 if asked for 0 bytes
    return 0 if defined $length && $length == 0 ;

    $length = $length || 0;

    $self->croakError(*$self->{ClassName} . "::read: length parameter is negative")
        if $length < 0 ;

    # Short-circuit if this is a simple read, with no length
    # or offset specified.
    unless ( $length || $offset) {
        if (length *$self->{Pending}) {
            $$buffer .= *$self->{Pending} ;
            my $len = length *$self->{Pending};
            *$self->{Pending} = '' ;
            return $len ;
        }
        else {
            my $len = 0;
            $len = $self->_raw_read($buffer) 
                while ! *$self->{EndStream} && $len == 0 ;
            return $len ;
        }
    }

    # Need to jump through more hoops - either length or offset 
    # or both are specified.
    my $out_buffer = *$self->{Pending} ;
    *$self->{Pending} = '';


    while (! *$self->{EndStream} && length($out_buffer) < $length)
    {
        my $buf_len = $self->_raw_read(\$out_buffer);
        return $buf_len 
            if $buf_len < 0 ;
    }

    $length = length $out_buffer 
        if length($out_buffer) < $length ;

    return 0 
        if $length == 0 ;

    $$buffer = '' 
        if ! defined $$buffer;

    $offset = length $$buffer
        if *$self->{AppendOutput} ;

    *$self->{Pending} = $out_buffer;
    $out_buffer = \*$self->{Pending} ;

    substr($$buffer, $offset) = substr($$out_buffer, 0, $length) ;
    substr($$out_buffer, 0, $length) =  '' ;

    return $length ;
}

sub _getline
{
    my $self = shift ;
    my $status = 0 ;

    # Slurp Mode
    if ( ! defined $/ ) {
        my $data ;
        1 while ($status = $self->read($data)) > 0 ;
        return ($status, \$data);
    }

    # Record Mode
    if ( ref $/ eq 'SCALAR' && ${$/} =~ /^\d+$/ && ${$/} > 0) {
        my $reclen = ${$/} ;
        my $data ;
        $status = $self->read($data, $reclen) ;
        return ($status, \$data);
    }

    # Paragraph Mode
    if ( ! length $/ ) {
        my $paragraph ;    
        while (($status = $self->read($paragraph)) > 0 ) {
            if ($paragraph =~ s/^(.*?\n\n+)//s) {
                *$self->{Pending}  = $paragraph ;
                my $par = $1 ;
                return (1, \$par);
            }
        }
        return ($status, \$paragraph);
    }

    # $/ isn't empty, or a reference, so it's Line Mode.
    {
        my $line ;    
        my $p = \*$self->{Pending}  ;
        while (($status = $self->read($line)) > 0 ) {
            my $offset = index($line, $/);
            if ($offset >= 0) {
                my $l = substr($line, 0, $offset + length $/ );
                substr($line, 0, $offset + length $/) = '';    
                $$p = $line;
                return (1, \$l);
            }
        }

        return ($status, \$line);
    }
}

sub getline
{
    my $self = shift;

    if (defined *$self->{ReadStatus} ) {
        $self->saveErrorString( @{ *$self->{ReadStatus} } );
        delete  *$self->{ReadStatus} ;
        return undef;
    }

    return undef 
        if *$self->{Closed} || (!length *$self->{Pending} && *$self->{EndStream}) ;

    my $current_append = *$self->{AppendOutput} ;
    *$self->{AppendOutput} = 1;

    my ($status, $lineref) = $self->_getline();
    *$self->{AppendOutput} = $current_append;

    return undef 
        if $status < 0 || length $$lineref == 0 ;

    $. = ++ *$self->{LineNo} ;

    return $$lineref ;
}

sub getlines
{
    my $self = shift;
    $self->croakError(*$self->{ClassName} . 
            "::getlines: called in scalar context\n") unless wantarray;
    my($line, @lines);
    push(@lines, $line) 
        while defined($line = $self->getline);
    return @lines;
}

sub READLINE
{
    goto &getlines if wantarray;
    goto &getline;
}

sub getc
{
    my $self = shift;
    my $buf;
    return $buf if $self->read($buf, 1);
    return undef;
}

sub ungetc
{
    my $self = shift;
    *$self->{Pending} = ""  unless defined *$self->{Pending} ;    
    *$self->{Pending} = $_[0] . *$self->{Pending} ;    
}


sub trailingData
{
    my $self = shift ;

    if (defined *$self->{FH} || defined *$self->{InputEvent} ) {
        return *$self->{Prime} ;
    }
    else {
        my $buf = *$self->{Buffer} ;
        my $offset = *$self->{BufferOffset} ;
        return substr($$buf, $offset) ;
    }
}


sub eof
{
    my $self = shift ;

    return (*$self->{Closed} ||
              (!length *$self->{Pending} 
                && ( $self->smartEof() || *$self->{EndStream}))) ;
}

sub tell
{
    my $self = shift ;

    my $in ;
    if (*$self->{Plain}) {
        $in = *$self->{PlainBytesRead} ;
    }
    else {
        $in = *$self->{TotalInflatedBytesRead} ;
    }

    my $pending = length *$self->{Pending} ;

    return 0 if $pending > $in ;
    return $in - $pending ;
}

sub close
{
    # todo - what to do if close is called before the end of the gzip file
    #        do we remember any trailing data?
    my $self = shift ;

    return 1 if *$self->{Closed} ;

    untie *$self 
        if $] >= 5.008 ;

    my $status = 1 ;

    if (defined *$self->{FH}) {
        if ((! *$self->{Handle} || *$self->{AutoClose}) && ! *$self->{StdIO}) {
            local $.; 
            $! = 0 ;
            $status = *$self->{FH}->close();
            return $self->saveErrorString(0, $!, $!)
                if !*$self->{InNew} && $self->saveStatus($!) != 0 ;
        }
        delete *$self->{FH} ;
        $! = 0 ;
    }
    *$self->{Closed} = 1 ;

    return 1;
}

sub DESTROY
{
    my $self = shift ;
    local ($., $@, $!, $^E, $?);

    $self->close() ;
}

sub seek
{
    my $self     = shift ;
    my $position = shift;
    my $whence   = shift ;

    my $here = $self->tell() ;
    my $target = 0 ;


    if ($whence == SEEK_SET) {
        $target = $position ;
    }
    elsif ($whence == SEEK_CUR) {
        $target = $here + $position ;
    }
    elsif ($whence == SEEK_END) {
        $target = $position ;
        $self->croakError(*$self->{ClassName} . "::seek: SEEK_END not allowed") ;
    }
    else {
        $self->croakError(*$self->{ClassName} ."::seek: unknown value, $whence, for whence parameter");
    }

    # short circuit if seeking to current offset
    if ($target == $here) {
        # On ordinary filehandles, seeking to the current
        # position also clears the EOF condition, so we
        # emulate this behavior locally while simultaneously
        # cascading it to the underlying filehandle
        if (*$self->{Plain}) {
            *$self->{EndStream} = 0;
            seek(*$self->{FH},0,1) if *$self->{FH};
        }
        return 1;
    }

    # Outlaw any attempt to seek backwards
    $self->croakError( *$self->{ClassName} ."::seek: cannot seek backwards")
        if $target < $here ;

    # Walk the file to the new offset
    my $offset = $target - $here ;

    my $got;
    while (($got = $self->read(my $buffer, List::Util::min($offset, *$self->{BlockSize})) ) > 0)
    {
        $offset -= $got;
        last if $offset == 0 ;
    }

    $here = $self->tell() ;
    return $offset == 0 ? 1 : 0 ;
}

sub fileno
{
    my $self = shift ;
    return defined *$self->{FH} 
           ? fileno *$self->{FH} 
           : undef ;
}

sub binmode
{
    1;
#    my $self     = shift ;
#    return defined *$self->{FH} 
#            ? binmode *$self->{FH} 
#            : 1 ;
}

sub opened
{
    my $self     = shift ;
    return ! *$self->{Closed} ;
}

sub autoflush
{
    my $self     = shift ;
    return defined *$self->{FH} 
            ? *$self->{FH}->autoflush(@_) 
            : undef ;
}

sub input_line_number
{
    my $self = shift ;
    my $last = *$self->{LineNo};
    $. = *$self->{LineNo} = $_[1] if @_ ;
    return $last;
}


*BINMODE  = \&binmode;
*SEEK     = \&seek; 
*READ     = \&read;
*sysread  = \&read;
*TELL     = \&tell;
*EOF      = \&eof;

*FILENO   = \&fileno;
*CLOSE    = \&close;

sub _notAvailable
{
    my $name = shift ;
    return sub { croak "$name Not Available: File opened only for intput" ; } ;
}


*print    = _notAvailable('print');
*PRINT    = _notAvailable('print');
*printf   = _notAvailable('printf');
*PRINTF   = _notAvailable('printf');
*write    = _notAvailable('write');
*WRITE    = _notAvailable('write');

#*sysread  = \&read;
#*syswrite = \&_notAvailable;



package IO::Uncompress::Base ;


1 ;
__END__

=head1 NAME

IO::Uncompress::Base - Base Class for IO::Uncompress modules 

=head1 SYNOPSIS

    use IO::Uncompress::Base ;

=head1 DESCRIPTION

This module is not intended for direct use in application code. Its sole
purpose is to be sub-classed by IO::Uncompress modules.

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/IO/Uncompress/Bunzip2.pm                                                      0100644 0000000 0000000 00000061213 12744441327 017215  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Bunzip2 ;

use strict ;
use warnings;
use bytes;

use IO::Compress::Base::Common 2.064 qw(:Status );

use IO::Uncompress::Base 2.064 ;
use IO::Uncompress::Adapter::Bunzip2 2.064 ;

require Exporter ;
our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $Bunzip2Error);

$VERSION = '2.064';
$Bunzip2Error = '';

@ISA    = qw( Exporter IO::Uncompress::Base );
@EXPORT_OK = qw( $Bunzip2Error bunzip2 ) ;
#%EXPORT_TAGS = %IO::Uncompress::Base::EXPORT_TAGS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
#Exporter::export_ok_tags('all');


sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$Bunzip2Error);

    $obj->_create(undef, 0, @_);
}

sub bunzip2
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$Bunzip2Error);
    return $obj->_inf(@_);
}

sub getExtraParams
{
    return (
            'verbosity'     => [IO::Compress::Base::Common::Parse_boolean,   0],
            'small'         => [IO::Compress::Base::Common::Parse_boolean,   0],
        );
}


sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    return 1;
}

sub mkUncomp
{
    my $self = shift ;
    my $got = shift ;

     my $magic = $self->ckMagic()
        or return 0;

    *$self->{Info} = $self->readHeader($magic)
        or return undef ;

    my $Small     = $got->getValue('small');
    my $Verbosity = $got->getValue('verbosity');

    my ($obj, $errstr, $errno) =  IO::Uncompress::Adapter::Bunzip2::mkUncompObject(
                                                    $Small, $Verbosity);

    return $self->saveErrorString(undef, $errstr, $errno)
        if ! defined $obj;
    
    *$self->{Uncomp} = $obj;

    return 1;

}


sub ckMagic
{
    my $self = shift;

    my $magic ;
    $self->smartReadExact(\$magic, 4);

    *$self->{HeaderPending} = $magic ;
    
    return $self->HeaderError("Header size is " . 
                                        4 . " bytes") 
        if length $magic != 4;

    return $self->HeaderError("Bad Magic.")
        if ! isBzip2Magic($magic) ;
                      
        
    *$self->{Type} = 'bzip2';
    return $magic;
}

sub readHeader
{
    my $self = shift;
    my $magic = shift ;

    $self->pushBack($magic);
    *$self->{HeaderPending} = '';


    return {
        'Type'              => 'bzip2',
        'FingerprintLength' => 4,
        'HeaderLength'      => 4,
        'TrailerLength'     => 0,
        'Header'            => '$magic'
        };
    
}

sub chkTrailer
{
    return STATUS_OK;
}



sub isBzip2Magic
{
    my $buffer = shift ;
    return $buffer =~ /^BZh\d$/;
}

1 ;

__END__


=head1 NAME

IO::Uncompress::Bunzip2 - Read bzip2 files/buffers

=head1 SYNOPSIS

    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

    my $status = bunzip2 $input => $output [,OPTS]
        or die "bunzip2 failed: $Bunzip2Error\n";

    my $z = new IO::Uncompress::Bunzip2 $input [OPTS] 
        or die "bunzip2 failed: $Bunzip2Error\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $Bunzip2Error ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
bzip2 files/buffers.

For writing bzip2 files/buffers, see the companion module IO::Compress::Bzip2.

=head1 Functional Interface

A top-level function, C<bunzip2>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

    bunzip2 $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "bunzip2 failed: $Bunzip2Error\n";

The functional interface needs Perl5.005 or better.

=head2 bunzip2 $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<bunzip2> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<bunzip2> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<bunzip2> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<bunzip2>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<bunzip2> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<bunzip2> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.bz2> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

    my $input = "file1.txt.bz2";
    my $output = "file1.txt";
    bunzip2 $input => $output
        or die "bunzip2 failed: $Bunzip2Error\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.bz2"
        or die "Cannot open 'file1.txt.bz2': $!\n" ;
    my $buffer ;
    bunzip2 $input => \$buffer 
        or die "bunzip2 failed: $Bunzip2Error\n";

To uncompress all files in the directory "/my/home" that match "*.txt.bz2" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

    bunzip2 '</my/home/*.txt.bz2>' => '</my/home/#1.txt>'
        or die "bunzip2 failed: $Bunzip2Error\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

    for my $input ( glob "/my/home/*.txt.bz2" )
    {
        my $output = $input;
        $output =~ s/.bz2// ;
        bunzip2 $input => $output 
            or die "Error compressing '$input': $Bunzip2Error\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::Bunzip2 is shown below

    my $z = new IO::Uncompress::Bunzip2 $input [OPTS]
        or die "IO::Uncompress::Bunzip2 failed: $Bunzip2Error\n";

Returns an C<IO::Uncompress::Bunzip2> object on success and undef on failure.
The variable C<$Bunzip2Error> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::Bunzip2 can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::Bunzip2 object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::Bunzip2 will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option is a no-op.

=item C<< Small => 0|1 >>

When non-zero this options will make bzip2 use a decompression algorithm
that uses less memory at the expense of increasing the amount of time
taken for decompression. 

Default is 0.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::Bunzip2 object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::Bunzip2
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::Bunzip2 at present. 

=over 5

=item :all

Imports C<bunzip2> and C<$Bunzip2Error>.
Same as doing this

    use IO::Uncompress::Bunzip2 qw(bunzip2 $Bunzip2Error) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

The primary site for the bzip2 program is F<http://www.bzip.org>.

See the module L<Compress::Bzip2|Compress::Bzip2>

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/IO/Uncompress/Gunzip.pm                                                       0100644 0000000 0000000 00000076236 12744441327 017153  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
package IO::Uncompress::Gunzip ;

require 5.006 ;

# for RFC1952

use strict ;
use warnings;
use bytes;

use IO::Uncompress::RawInflate 2.064 ;

use Compress::Raw::Zlib 2.064 () ;
use IO::Compress::Base::Common 2.064 qw(:Status );
use IO::Compress::Gzip::Constants 2.064 ;
use IO::Compress::Zlib::Extra 2.064 ;

require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $GunzipError);

@ISA = qw( Exporter IO::Uncompress::RawInflate );
@EXPORT_OK = qw( $GunzipError gunzip );
%EXPORT_TAGS = %IO::Uncompress::RawInflate::DEFLATE_CONSTANTS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

$GunzipError = '';

$VERSION = '2.064';

sub new
{
    my $class = shift ;
    $GunzipError = '';
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$GunzipError);

    $obj->_create(undef, 0, @_);
}

sub gunzip
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$GunzipError);
    return $obj->_inf(@_) ;
}

sub getExtraParams
{
    return ( 'parseextra' => [IO::Compress::Base::Common::Parse_boolean,  0] ) ;
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # gunzip always needs crc32
    $got->setValue('crc32' => 1);

    return 1;
}

sub ckMagic
{
    my $self = shift;

    my $magic ;
    $self->smartReadExact(\$magic, GZIP_ID_SIZE);

    *$self->{HeaderPending} = $magic ;

    return $self->HeaderError("Minimum header size is " . 
                              GZIP_MIN_HEADER_SIZE . " bytes") 
        if length $magic != GZIP_ID_SIZE ;                                    

    return $self->HeaderError("Bad Magic")
        if ! isGzipMagic($magic) ;

    *$self->{Type} = 'rfc1952';

    return $magic ;
}

sub readHeader
{
    my $self = shift;
    my $magic = shift;

    return $self->_readGzipHeader($magic);
}

sub chkTrailer
{
    my $self = shift;
    my $trailer = shift;

    # Check CRC & ISIZE 
    my ($CRC32, $ISIZE) = unpack("V V", $trailer) ;
    *$self->{Info}{CRC32} = $CRC32;    
    *$self->{Info}{ISIZE} = $ISIZE;    

    if (*$self->{Strict}) {
        return $self->TrailerError("CRC mismatch")
            if $CRC32 != *$self->{Uncomp}->crc32() ;

        my $exp_isize = *$self->{UnCompSize}->get32bit();
        return $self->TrailerError("ISIZE mismatch. Got $ISIZE"
                                  . ", expected $exp_isize")
            if $ISIZE != $exp_isize ;
    }

    return STATUS_OK;
}

sub isGzipMagic
{
    my $buffer = shift ;
    return 0 if length $buffer < GZIP_ID_SIZE ;
    my ($id1, $id2) = unpack("C C", $buffer) ;
    return $id1 == GZIP_ID1 && $id2 == GZIP_ID2 ;
}

sub _readFullGzipHeader($)
{
    my ($self) = @_ ;
    my $magic = '' ;

    $self->smartReadExact(\$magic, GZIP_ID_SIZE);

    *$self->{HeaderPending} = $magic ;

    return $self->HeaderError("Minimum header size is " . 
                              GZIP_MIN_HEADER_SIZE . " bytes") 
        if length $magic != GZIP_ID_SIZE ;                                    


    return $self->HeaderError("Bad Magic")
        if ! isGzipMagic($magic) ;

    my $status = $self->_readGzipHeader($magic);
    delete *$self->{Transparent} if ! defined $status ;
    return $status ;
}

sub _readGzipHeader($)
{
    my ($self, $magic) = @_ ;
    my ($HeaderCRC) ;
    my ($buffer) = '' ;

    $self->smartReadExact(\$buffer, GZIP_MIN_HEADER_SIZE - GZIP_ID_SIZE)
        or return $self->HeaderError("Minimum header size is " . 
                                     GZIP_MIN_HEADER_SIZE . " bytes") ;

    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;

    # now split out the various parts
    my ($cm, $flag, $mtime, $xfl, $os) = unpack("C C V C C", $buffer) ;

    $cm == GZIP_CM_DEFLATED 
        or return $self->HeaderError("Not Deflate (CM is $cm)") ;

    # check for use of reserved bits
    return $self->HeaderError("Use of Reserved Bits in FLG field.")
        if $flag & GZIP_FLG_RESERVED ; 

    my $EXTRA ;
    my @EXTRA = () ;
    if ($flag & GZIP_FLG_FEXTRA) {
        $EXTRA = "" ;
        $self->smartReadExact(\$buffer, GZIP_FEXTRA_HEADER_SIZE) 
            or return $self->TruncatedHeader("FEXTRA Length") ;

        my ($XLEN) = unpack("v", $buffer) ;
        $self->smartReadExact(\$EXTRA, $XLEN) 
            or return $self->TruncatedHeader("FEXTRA Body");
        $keep .= $buffer . $EXTRA ;

        if ($XLEN && *$self->{'ParseExtra'}) {
            my $bad = IO::Compress::Zlib::Extra::parseRawExtra($EXTRA,
                                                \@EXTRA, 1, 1);
            return $self->HeaderError($bad)
                if defined $bad;
        }
    }

    my $origname ;
    if ($flag & GZIP_FLG_FNAME) {
        $origname = "" ;
        while (1) {
            $self->smartReadExact(\$buffer, 1) 
                or return $self->TruncatedHeader("FNAME");
            last if $buffer eq GZIP_NULL_BYTE ;
            $origname .= $buffer 
        }
        $keep .= $origname . GZIP_NULL_BYTE ;

        return $self->HeaderError("Non ISO 8859-1 Character found in Name")
            if *$self->{Strict} && $origname =~ /$GZIP_FNAME_INVALID_CHAR_RE/o ;
    }

    my $comment ;
    if ($flag & GZIP_FLG_FCOMMENT) {
        $comment = "";
        while (1) {
            $self->smartReadExact(\$buffer, 1) 
                or return $self->TruncatedHeader("FCOMMENT");
            last if $buffer eq GZIP_NULL_BYTE ;
            $comment .= $buffer 
        }
        $keep .= $comment . GZIP_NULL_BYTE ;

        return $self->HeaderError("Non ISO 8859-1 Character found in Comment")
            if *$self->{Strict} && $comment =~ /$GZIP_FCOMMENT_INVALID_CHAR_RE/o ;
    }

    if ($flag & GZIP_FLG_FHCRC) {
        $self->smartReadExact(\$buffer, GZIP_FHCRC_SIZE) 
            or return $self->TruncatedHeader("FHCRC");

        $HeaderCRC = unpack("v", $buffer) ;
        my $crc16 = Compress::Raw::Zlib::crc32($keep) & 0xFF ;

        return $self->HeaderError("CRC16 mismatch.")
            if *$self->{Strict} && $crc16 != $HeaderCRC;

        $keep .= $buffer ;
    }

    # Assume compression method is deflated for xfl tests
    #if ($xfl) {
    #}

    *$self->{Type} = 'rfc1952';

    return {
        'Type'          => 'rfc1952',
        'FingerprintLength'  => 2,
        'HeaderLength'  => length $keep,
        'TrailerLength' => GZIP_TRAILER_SIZE,
        'Header'        => $keep,
        'isMinimalHeader' => $keep eq GZIP_MINIMUM_HEADER ? 1 : 0,

        'MethodID'      => $cm,
        'MethodName'    => $cm == GZIP_CM_DEFLATED ? "Deflated" : "Unknown" ,
        'TextFlag'      => $flag & GZIP_FLG_FTEXT ? 1 : 0,
        'HeaderCRCFlag' => $flag & GZIP_FLG_FHCRC ? 1 : 0,
        'NameFlag'      => $flag & GZIP_FLG_FNAME ? 1 : 0,
        'CommentFlag'   => $flag & GZIP_FLG_FCOMMENT ? 1 : 0,
        'ExtraFlag'     => $flag & GZIP_FLG_FEXTRA ? 1 : 0,
        'Name'          => $origname,
        'Comment'       => $comment,
        'Time'          => $mtime,
        'OsID'          => $os,
        'OsName'        => defined $GZIP_OS_Names{$os} 
                                 ? $GZIP_OS_Names{$os} : "Unknown",
        'HeaderCRC'     => $HeaderCRC,
        'Flags'         => $flag,
        'ExtraFlags'    => $xfl,
        'ExtraFieldRaw' => $EXTRA,
        'ExtraField'    => [ @EXTRA ],


        #'CompSize'=> $compsize,
        #'CRC32'=> $CRC32,
        #'OrigSize'=> $ISIZE,
      }
}


1;

__END__


=head1 NAME

IO::Uncompress::Gunzip - Read RFC 1952 files/buffers

=head1 SYNOPSIS

    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

    my $status = gunzip $input => $output [,OPTS]
        or die "gunzip failed: $GunzipError\n";

    my $z = new IO::Uncompress::Gunzip $input [OPTS] 
        or die "gunzip failed: $GunzipError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $status = $z->inflateSync()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $GunzipError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
files/buffers that conform to RFC 1952.

For writing RFC 1952 files/buffers, see the companion module IO::Compress::Gzip.

=head1 Functional Interface

A top-level function, C<gunzip>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

    gunzip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "gunzip failed: $GunzipError\n";

The functional interface needs Perl5.005 or better.

=head2 gunzip $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<gunzip> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<gunzip> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<gunzip> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<gunzip>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<gunzip> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<gunzip> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.gz> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

    my $input = "file1.txt.gz";
    my $output = "file1.txt";
    gunzip $input => $output
        or die "gunzip failed: $GunzipError\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.gz"
        or die "Cannot open 'file1.txt.gz': $!\n" ;
    my $buffer ;
    gunzip $input => \$buffer 
        or die "gunzip failed: $GunzipError\n";

To uncompress all files in the directory "/my/home" that match "*.txt.gz" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

    gunzip '</my/home/*.txt.gz>' => '</my/home/#1.txt>'
        or die "gunzip failed: $GunzipError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

    for my $input ( glob "/my/home/*.txt.gz" )
    {
        my $output = $input;
        $output =~ s/.gz// ;
        gunzip $input => $output 
            or die "Error compressing '$input': $GunzipError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::Gunzip is shown below

    my $z = new IO::Uncompress::Gunzip $input [OPTS]
        or die "IO::Uncompress::Gunzip failed: $GunzipError\n";

Returns an C<IO::Uncompress::Gunzip> object on success and undef on failure.
The variable C<$GunzipError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::Gunzip can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::Gunzip object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::Gunzip will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option controls whether the extra checks defined below are used when
carrying out the decompression. When Strict is on, the extra tests are
carried out, when Strict is off they are not.

The default for this option is off.

=over 5

=item 1 

If the FHCRC bit is set in the gzip FLG header byte, the CRC16 bytes in the
header must match the crc16 value of the gzip header actually read.

=item 2

If the gzip header contains a name field (FNAME) it consists solely of ISO
8859-1 characters.

=item 3

If the gzip header contains a comment field (FCOMMENT) it consists solely
of ISO 8859-1 characters plus line-feed.

=item 4

If the gzip FEXTRA header field is present it must conform to the sub-field
structure as defined in RFC 1952.

=item 5

The CRC32 and ISIZE trailer fields must be present.

=item 6

The value of the CRC32 field read must match the crc32 value of the
uncompressed data actually contained in the gzip file.

=item 7

The value of the ISIZE fields read must match the length of the
uncompressed data actually read from the file.

=back

=item C<< ParseExtra => 0|1 >>
If the gzip FEXTRA header field is present and this option is set, it will
force the module to check that it conforms to the sub-field structure as
defined in RFC 1952.

If the C<Strict> is on it will automatically enable this option.

Defaults to 0.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 inflateSync

Usage is

    $status = $z->inflateSync()

TODO

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=over 5

=item Name

The contents of the Name header field, if present. If no name is
present, the value will be undef. Note this is different from a zero length
name, which will return an empty string.

=item Comment

The contents of the Comment header field, if present. If no comment is
present, the value will be undef. Note this is different from a zero length
comment, which will return an empty string.

=back

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::Gunzip object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::Gunzip
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::Gunzip at present. 

=over 5

=item :all

Imports C<gunzip> and C<$GunzipError>.
Same as doing this

    use IO::Uncompress::Gunzip qw(gunzip $GunzipError) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                                  usr/share/perl/5.20.2/IO/Uncompress/Inflate.pm                                                      0100644 0000000 0000000 00000066634 12744441327 017262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Inflate ;
# for RFC1950

use strict ;
use warnings;
use bytes;

use IO::Compress::Base::Common  2.064 qw(:Status );
use IO::Compress::Zlib::Constants 2.064 ;

use IO::Uncompress::RawInflate  2.064 ;

require Exporter ;
our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $InflateError);

$VERSION = '2.064';
$InflateError = '';

@ISA    = qw( Exporter IO::Uncompress::RawInflate );
@EXPORT_OK = qw( $InflateError inflate ) ;
%EXPORT_TAGS = %IO::Uncompress::RawInflate::DEFLATE_CONSTANTS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');


sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$InflateError);

    $obj->_create(undef, 0, @_);
}

sub inflate
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$InflateError);
    return $obj->_inf(@_);
}

sub getExtraParams
{
    return ();
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # gunzip always needs adler32
    $got->setValue('adler32' => 1);

    return 1;
}

sub ckMagic
{
    my $self = shift;

    my $magic ;
    $self->smartReadExact(\$magic, ZLIB_HEADER_SIZE);

    *$self->{HeaderPending} = $magic ;

    return $self->HeaderError("Header size is " . 
                                        ZLIB_HEADER_SIZE . " bytes") 
        if length $magic != ZLIB_HEADER_SIZE;

    #return $self->HeaderError("CRC mismatch.")
    return undef
        if ! $self->isZlibMagic($magic) ;
                      
    *$self->{Type} = 'rfc1950';
    return $magic;
}

sub readHeader
{
    my $self = shift;
    my $magic = shift ;

    return $self->_readDeflateHeader($magic) ;
}

sub chkTrailer
{
    my $self = shift;
    my $trailer = shift;

    my $ADLER32 = unpack("N", $trailer) ;
    *$self->{Info}{ADLER32} = $ADLER32;    
    return $self->TrailerError("CRC mismatch")
        if *$self->{Strict} && $ADLER32 != *$self->{Uncomp}->adler32() ;

    return STATUS_OK;
}



sub isZlibMagic
{
    my $self = shift;
    my $buffer = shift ;

    return 0 
        if length $buffer < ZLIB_HEADER_SIZE ;

    my $hdr = unpack("n", $buffer) ;
    #return 0 if $hdr % 31 != 0 ;
    return $self->HeaderError("CRC mismatch.")
        if $hdr % 31 != 0 ;

    my ($CMF, $FLG) = unpack "C C", $buffer;
    my $cm =    bits($CMF, ZLIB_CMF_CM_OFFSET,    ZLIB_CMF_CM_BITS) ;

    # Only Deflate supported
    return $self->HeaderError("Not Deflate (CM is $cm)") 
        if $cm != ZLIB_CMF_CM_DEFLATED ;

    # Max window value is 7 for Deflate.
    my $cinfo = bits($CMF, ZLIB_CMF_CINFO_OFFSET, ZLIB_CMF_CINFO_BITS) ;
    return $self->HeaderError("CINFO > " . ZLIB_CMF_CINFO_MAX . 
                              " (CINFO is $cinfo)") 
        if $cinfo > ZLIB_CMF_CINFO_MAX ;

    return 1;    
}

sub bits
{
    my $data   = shift ;
    my $offset = shift ;
    my $mask  = shift ;

    ($data >> $offset ) & $mask & 0xFF ;
}


sub _readDeflateHeader
{
    my ($self, $buffer) = @_ ;

#    if (! $buffer) {
#        $self->smartReadExact(\$buffer, ZLIB_HEADER_SIZE);
#
#        *$self->{HeaderPending} = $buffer ;
#
#        return $self->HeaderError("Header size is " . 
#                                            ZLIB_HEADER_SIZE . " bytes") 
#            if length $buffer != ZLIB_HEADER_SIZE;
#
#        return $self->HeaderError("CRC mismatch.")
#            if ! isZlibMagic($buffer) ;
#    }
                                        
    my ($CMF, $FLG) = unpack "C C", $buffer;
    my $FDICT = bits($FLG, ZLIB_FLG_FDICT_OFFSET,  ZLIB_FLG_FDICT_BITS ),

    my $cm = bits($CMF, ZLIB_CMF_CM_OFFSET, ZLIB_CMF_CM_BITS) ;
    $cm == ZLIB_CMF_CM_DEFLATED 
        or return $self->HeaderError("Not Deflate (CM is $cm)") ;

    my $DICTID;
    if ($FDICT) {
        $self->smartReadExact(\$buffer, ZLIB_FDICT_SIZE)
            or return $self->TruncatedHeader("FDICT");

        $DICTID = unpack("N", $buffer) ;
    }

    *$self->{Type} = 'rfc1950';

    return {
        'Type'          => 'rfc1950',
        'FingerprintLength'  => ZLIB_HEADER_SIZE,
        'HeaderLength'  => ZLIB_HEADER_SIZE,
        'TrailerLength' => ZLIB_TRAILER_SIZE,
        'Header'        => $buffer,

        CMF     =>      $CMF                                               ,
        CM      => bits($CMF, ZLIB_CMF_CM_OFFSET,     ZLIB_CMF_CM_BITS    ),
        CINFO   => bits($CMF, ZLIB_CMF_CINFO_OFFSET,  ZLIB_CMF_CINFO_BITS ),
        FLG     =>      $FLG                                               ,
        FCHECK  => bits($FLG, ZLIB_FLG_FCHECK_OFFSET, ZLIB_FLG_FCHECK_BITS),
        FDICT   => bits($FLG, ZLIB_FLG_FDICT_OFFSET,  ZLIB_FLG_FDICT_BITS ),
        FLEVEL  => bits($FLG, ZLIB_FLG_LEVEL_OFFSET,  ZLIB_FLG_LEVEL_BITS ),
        DICTID  =>      $DICTID                                            ,

    };
}




1 ;

__END__


=head1 NAME

IO::Uncompress::Inflate - Read RFC 1950 files/buffers

=head1 SYNOPSIS

    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

    my $status = inflate $input => $output [,OPTS]
        or die "inflate failed: $InflateError\n";

    my $z = new IO::Uncompress::Inflate $input [OPTS] 
        or die "inflate failed: $InflateError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $status = $z->inflateSync()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $InflateError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
files/buffers that conform to RFC 1950.

For writing RFC 1950 files/buffers, see the companion module IO::Compress::Deflate.

=head1 Functional Interface

A top-level function, C<inflate>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

    inflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "inflate failed: $InflateError\n";

The functional interface needs Perl5.005 or better.

=head2 inflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<inflate> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<inflate> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<inflate> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<inflate>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<inflate> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<inflate> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.1950> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

    my $input = "file1.txt.1950";
    my $output = "file1.txt";
    inflate $input => $output
        or die "inflate failed: $InflateError\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Inflate qw(inflate $InflateError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.1950"
        or die "Cannot open 'file1.txt.1950': $!\n" ;
    my $buffer ;
    inflate $input => \$buffer 
        or die "inflate failed: $InflateError\n";

To uncompress all files in the directory "/my/home" that match "*.txt.1950" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

    inflate '</my/home/*.txt.1950>' => '</my/home/#1.txt>'
        or die "inflate failed: $InflateError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

    for my $input ( glob "/my/home/*.txt.1950" )
    {
        my $output = $input;
        $output =~ s/.1950// ;
        inflate $input => $output 
            or die "Error compressing '$input': $InflateError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::Inflate is shown below

    my $z = new IO::Uncompress::Inflate $input [OPTS]
        or die "IO::Uncompress::Inflate failed: $InflateError\n";

Returns an C<IO::Uncompress::Inflate> object on success and undef on failure.
The variable C<$InflateError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::Inflate can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::Inflate object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::Inflate will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option controls whether the extra checks defined below are used when
carrying out the decompression. When Strict is on, the extra tests are
carried out, when Strict is off they are not.

The default for this option is off.

=over 5

=item 1

The ADLER32 checksum field must be present.

=item 2

The value of the ADLER32 field read must match the adler32 value of the
uncompressed data actually contained in the file.

=back

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 inflateSync

Usage is

    $status = $z->inflateSync()

TODO

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::Inflate object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::Inflate
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::Inflate at present. 

=over 5

=item :all

Imports C<inflate> and C<$InflateError>.
Same as doing this

    use IO::Uncompress::Inflate qw(inflate $InflateError) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                    usr/share/perl/5.20.2/IO/Uncompress/RawInflate.pm                                                   0100644 0000000 0000000 00000075564 12744441327 017736  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::RawInflate ;
# for RFC1951

use strict ;
use warnings;
#use bytes;

use Compress::Raw::Zlib  2.064 ;
use IO::Compress::Base::Common  2.064 qw(:Status );

use IO::Uncompress::Base  2.064 ;
use IO::Uncompress::Adapter::Inflate  2.064 ;

require Exporter ;
our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, %DEFLATE_CONSTANTS, $RawInflateError);

$VERSION = '2.064';
$RawInflateError = '';

@ISA    = qw( Exporter IO::Uncompress::Base );
@EXPORT_OK = qw( $RawInflateError rawinflate ) ;
%DEFLATE_CONSTANTS = ();
%EXPORT_TAGS = %IO::Uncompress::Base::EXPORT_TAGS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

#{
#    # Execute at runtime  
#    my %bad;
#    for my $module (qw(Compress::Raw::Zlib IO::Compress::Base::Common IO::Uncompress::Base IO::Uncompress::Adapter::Inflate))
#    {
#        my $ver = ${ $module . "::VERSION"} ;
#        
#        $bad{$module} = $ver
#            if $ver ne $VERSION;
#    }
#    
#    if (keys %bad)
#    {
#        my $string = join "\n", map { "$_ $bad{$_}" } keys %bad;
#        die caller(0)[0] . "needs version $VERSION mismatch\n$string\n";
#    }
#}

sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$RawInflateError);
    $obj->_create(undef, 0, @_);
}

sub rawinflate
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$RawInflateError);
    return $obj->_inf(@_);
}

sub getExtraParams
{
    return ();
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    return 1;
}

sub mkUncomp
{
    my $self = shift ;
    my $got = shift ;

    my ($obj, $errstr, $errno) = IO::Uncompress::Adapter::Inflate::mkUncompObject(
                                                                $got->getValue('crc32'),
                                                                $got->getValue('adler32'),
                                                                $got->getValue('scan'),
                                                            );

    return $self->saveErrorString(undef, $errstr, $errno)
        if ! defined $obj;

    *$self->{Uncomp} = $obj;

     my $magic = $self->ckMagic()
        or return 0;

    *$self->{Info} = $self->readHeader($magic)
        or return undef ;

    return 1;

}


sub ckMagic
{
    my $self = shift;

    return $self->_isRaw() ;
}

sub readHeader
{
    my $self = shift;
    my $magic = shift ;

    return {
        'Type'          => 'rfc1951',
        'FingerprintLength'  => 0,
        'HeaderLength'  => 0,
        'TrailerLength' => 0,
        'Header'        => ''
        };
}

sub chkTrailer
{
    return STATUS_OK ;
}

sub _isRaw
{
    my $self   = shift ;

    my $got = $self->_isRawx(@_);

    if ($got) {
        *$self->{Pending} = *$self->{HeaderPending} ;
    }
    else {
        $self->pushBack(*$self->{HeaderPending});
        *$self->{Uncomp}->reset();
    }
    *$self->{HeaderPending} = '';

    return $got ;
}

sub _isRawx
{
    my $self   = shift ;
    my $magic = shift ;

    $magic = '' unless defined $magic ;

    my $buffer = '';

    $self->smartRead(\$buffer, *$self->{BlockSize}) >= 0  
        or return $self->saveErrorString(undef, "No data to read");

    my $temp_buf = $magic . $buffer ;
    *$self->{HeaderPending} = $temp_buf ;    
    $buffer = '';
    my $status = *$self->{Uncomp}->uncompr(\$temp_buf, \$buffer, $self->smartEof()) ;
    
    return $self->saveErrorString(undef, *$self->{Uncomp}{Error}, STATUS_ERROR)
        if $status == STATUS_ERROR;

    $self->pushBack($temp_buf)  ;

    return $self->saveErrorString(undef, "unexpected end of file", STATUS_ERROR)
        if $self->smartEof() && $status != STATUS_ENDSTREAM;
            
    #my $buf_len = *$self->{Uncomp}->uncompressedBytes();
    my $buf_len = length $buffer;

    if ($status == STATUS_ENDSTREAM) {
        if (*$self->{MultiStream} 
                    && (length $temp_buf || ! $self->smartEof())){
            *$self->{NewStream} = 1 ;
            *$self->{EndStream} = 0 ;
        }
        else {
            *$self->{EndStream} = 1 ;
        }
    }
    *$self->{HeaderPending} = $buffer ;    
    *$self->{InflatedBytesRead} = $buf_len ;    
    *$self->{TotalInflatedBytesRead} += $buf_len ;    
    *$self->{Type} = 'rfc1951';

    $self->saveStatus(STATUS_OK);

    return {
        'Type'          => 'rfc1951',
        'HeaderLength'  => 0,
        'TrailerLength' => 0,
        'Header'        => ''
        };
}


sub inflateSync
{
    my $self = shift ;

    # inflateSync is a no-op in Plain mode
    return 1
        if *$self->{Plain} ;

    return 0 if *$self->{Closed} ;
    #return G_EOF if !length *$self->{Pending} && *$self->{EndStream} ;
    return 0 if ! length *$self->{Pending} && *$self->{EndStream} ;

    # Disable CRC check
    *$self->{Strict} = 0 ;

    my $status ;
    while (1)
    {
        my $temp_buf ;

        if (length *$self->{Pending} )
        {
            $temp_buf = *$self->{Pending} ;
            *$self->{Pending} = '';
        }
        else
        {
            $status = $self->smartRead(\$temp_buf, *$self->{BlockSize}) ;
            return $self->saveErrorString(0, "Error Reading Data")
                if $status < 0  ;

            if ($status == 0 ) {
                *$self->{EndStream} = 1 ;
                return $self->saveErrorString(0, "unexpected end of file", STATUS_ERROR);
            }
        }
        
        $status = *$self->{Uncomp}->sync($temp_buf) ;

        if ($status == STATUS_OK)
        {
            *$self->{Pending} .= $temp_buf ;
            return 1 ;
        }

        last unless $status == STATUS_ERROR ;
    }

    return 0;
}

#sub performScan
#{
#    my $self = shift ;
#
#    my $status ;
#    my $end_offset = 0;
#
#    $status = $self->scan() 
#    #or return $self->saveErrorString(undef, "Error Scanning: $$error_ref", $self->errorNo) ;
#        or return $self->saveErrorString(G_ERR, "Error Scanning: $status")
#
#    $status = $self->zap($end_offset) 
#        or return $self->saveErrorString(G_ERR, "Error Zapping: $status");
#    #or return $self->saveErrorString(undef, "Error Zapping: $$error_ref", $self->errorNo) ;
#
#    #(*$obj->{Deflate}, $status) = $inf->createDeflate();
#
##    *$obj->{Header} = *$inf->{Info}{Header};
##    *$obj->{UnCompSize_32bit} = 
##        *$obj->{BytesWritten} = *$inf->{UnCompSize_32bit} ;
##    *$obj->{CompSize_32bit} = *$inf->{CompSize_32bit} ;
#
#
##    if ( $outType eq 'buffer') 
##      { substr( ${ *$self->{Buffer} }, $end_offset) = '' }
##    elsif ($outType eq 'handle' || $outType eq 'filename') {
##        *$self->{FH} = *$inf->{FH} ;
##        delete *$inf->{FH};
##        *$obj->{FH}->flush() ;
##        *$obj->{Handle} = 1 if $outType eq 'handle';
##
##        #seek(*$obj->{FH}, $end_offset, SEEK_SET) 
##        *$obj->{FH}->seek($end_offset, SEEK_SET) 
##            or return $obj->saveErrorString(undef, $!, $!) ;
##    }
#    
#}

sub scan
{
    my $self = shift ;

    return 1 if *$self->{Closed} ;
    return 1 if !length *$self->{Pending} && *$self->{EndStream} ;

    my $buffer = '' ;
    my $len = 0;

    $len = $self->_raw_read(\$buffer, 1) 
        while ! *$self->{EndStream} && $len >= 0 ;

    #return $len if $len < 0 ? $len : 0 ;
    return $len < 0 ? 0 : 1 ;
}

sub zap
{
    my $self  = shift ;

    my $headerLength = *$self->{Info}{HeaderLength};
    my $block_offset =  $headerLength + *$self->{Uncomp}->getLastBlockOffset();
    $_[0] = $headerLength + *$self->{Uncomp}->getEndOffset();
    #printf "# End $_[0], headerlen $headerLength \n";;
    #printf "# block_offset $block_offset %x\n", $block_offset;
    my $byte ;
    ( $self->smartSeek($block_offset) &&
      $self->smartRead(\$byte, 1) ) 
        or return $self->saveErrorString(0, $!, $!); 

    #printf "#byte is %x\n", unpack('C*',$byte);
    *$self->{Uncomp}->resetLastBlockByte($byte);
    #printf "#to byte is %x\n", unpack('C*',$byte);

    ( $self->smartSeek($block_offset) && 
      $self->smartWrite($byte) )
        or return $self->saveErrorString(0, $!, $!); 

    #$self->smartSeek($end_offset, 1);

    return 1 ;
}

sub createDeflate
{
    my $self  = shift ;
    my ($def, $status) = *$self->{Uncomp}->createDeflateStream(
                                    -AppendOutput   => 1,
                                    -WindowBits => - MAX_WBITS,
                                    -CRC32      => *$self->{Params}->getValue('crc32'),
                                    -ADLER32    => *$self->{Params}->getValue('adler32'),
                                );
    
    return wantarray ? ($status, $def) : $def ;                                
}


1; 

__END__


=head1 NAME

IO::Uncompress::RawInflate - Read RFC 1951 files/buffers

=head1 SYNOPSIS

    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

    my $status = rawinflate $input => $output [,OPTS]
        or die "rawinflate failed: $RawInflateError\n";

    my $z = new IO::Uncompress::RawInflate $input [OPTS] 
        or die "rawinflate failed: $RawInflateError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $status = $z->inflateSync()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $RawInflateError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
files/buffers that conform to RFC 1951.

For writing RFC 1951 files/buffers, see the companion module IO::Compress::RawDeflate.

=head1 Functional Interface

A top-level function, C<rawinflate>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

    rawinflate $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "rawinflate failed: $RawInflateError\n";

The functional interface needs Perl5.005 or better.

=head2 rawinflate $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<rawinflate> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<rawinflate> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<rawinflate> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<rawinflate>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<rawinflate> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<rawinflate> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

This option is a no-op.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

To read the contents of the file C<file1.txt.1951> and write the
uncompressed data to the file C<file1.txt>.

    use strict ;
    use warnings ;
    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

    my $input = "file1.txt.1951";
    my $output = "file1.txt";
    rawinflate $input => $output
        or die "rawinflate failed: $RawInflateError\n";

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;
    use IO::File ;

    my $input = new IO::File "<file1.txt.1951"
        or die "Cannot open 'file1.txt.1951': $!\n" ;
    my $buffer ;
    rawinflate $input => \$buffer 
        or die "rawinflate failed: $RawInflateError\n";

To uncompress all files in the directory "/my/home" that match "*.txt.1951" and store the compressed data in the same directory

    use strict ;
    use warnings ;
    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

    rawinflate '</my/home/*.txt.1951>' => '</my/home/#1.txt>'
        or die "rawinflate failed: $RawInflateError\n";

and if you want to compress each file one at a time, this will do the trick

    use strict ;
    use warnings ;
    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

    for my $input ( glob "/my/home/*.txt.1951" )
    {
        my $output = $input;
        $output =~ s/.1951// ;
        rawinflate $input => $output 
            or die "Error compressing '$input': $RawInflateError\n";
    }

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::RawInflate is shown below

    my $z = new IO::Uncompress::RawInflate $input [OPTS]
        or die "IO::Uncompress::RawInflate failed: $RawInflateError\n";

Returns an C<IO::Uncompress::RawInflate> object on success and undef on failure.
The variable C<$RawInflateError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::RawInflate can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::RawInflate object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Allows multiple concatenated compressed streams to be treated as a single
compressed stream. Decompression will stop once either the end of the
file/buffer is reached, an error is encountered (premature eof, corrupt
compressed data) or the end of a stream is not immediately followed by the
start of another stream.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::RawInflate will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option is a no-op.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 inflateSync

Usage is

    $status = $z->inflateSync()

TODO

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::RawInflate object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::RawInflate
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::RawInflate at present. 

=over 5

=item :all

Imports C<rawinflate> and C<$RawInflateError>.
Same as doing this

    use IO::Uncompress::RawInflate qw(rawinflate $RawInflateError) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                            usr/share/perl/5.20.2/IO/Uncompress/Unzip.pm                                                        0100644 0000000 0000000 00000150254 12744441327 016775  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IO::Uncompress::Unzip;

require 5.006 ;

# for RFC1952

use strict ;
use warnings;
#use bytes;

use IO::File;
use IO::Uncompress::RawInflate  2.064 ;
use IO::Compress::Base::Common  2.064 qw(:Status );
use IO::Uncompress::Adapter::Inflate  2.064 ;
use IO::Uncompress::Adapter::Identity 2.064 ;
use IO::Compress::Zlib::Extra 2.064 ;
use IO::Compress::Zip::Constants 2.064 ;

use Compress::Raw::Zlib  2.064 () ;

BEGIN
{
    eval{ require IO::Uncompress::Adapter::Bunzip2 ;
           import  IO::Uncompress::Adapter::Bunzip2 } ;
    eval{ require IO::Uncompress::Adapter::UnLzma ;
          import  IO::Uncompress::Adapter::UnLzma } ;
}


require Exporter ;

our ($VERSION, @ISA, @EXPORT_OK, %EXPORT_TAGS, $UnzipError, %headerLookup);

$VERSION = '2.064';
$UnzipError = '';

@ISA    = qw(Exporter IO::Uncompress::RawInflate);
@EXPORT_OK = qw( $UnzipError unzip );
%EXPORT_TAGS = %IO::Uncompress::RawInflate::EXPORT_TAGS ;
push @{ $EXPORT_TAGS{all} }, @EXPORT_OK ;
Exporter::export_ok_tags('all');

%headerLookup = (
        ZIP_CENTRAL_HDR_SIG,            \&skipCentralDirectory,
        ZIP_END_CENTRAL_HDR_SIG,        \&skipEndCentralDirectory,
        ZIP64_END_CENTRAL_REC_HDR_SIG,  \&skipCentralDirectory64Rec,
        ZIP64_END_CENTRAL_LOC_HDR_SIG,  \&skipCentralDirectory64Loc,
        ZIP64_ARCHIVE_EXTRA_SIG,        \&skipArchiveExtra,
        ZIP64_DIGITAL_SIGNATURE_SIG,    \&skipDigitalSignature,
        );

sub new
{
    my $class = shift ;
    my $obj = IO::Compress::Base::Common::createSelfTiedObject($class, \$UnzipError);
    $obj->_create(undef, 0, @_);
}

sub unzip
{
    my $obj = IO::Compress::Base::Common::createSelfTiedObject(undef, \$UnzipError);
    return $obj->_inf(@_) ;
}

sub getExtraParams
{
   
    return (
#            # Zip header fields
            'name'    => [IO::Compress::Base::Common::Parse_any,       undef],

            'stream'  => [IO::Compress::Base::Common::Parse_boolean,   0],
            
            # TODO - This means reading the central directory to get
            # 1. the local header offsets
            # 2. The compressed data length
        );    
}

sub ckParams
{
    my $self = shift ;
    my $got = shift ;

    # unzip always needs crc32
    $got->setValue('crc32' => 1);

    *$self->{UnzipData}{Name} = $got->getValue('name');

    return 1;
}

sub mkUncomp
{
    my $self = shift ;
    my $got = shift ;

     my $magic = $self->ckMagic()
        or return 0;

    *$self->{Info} = $self->readHeader($magic)
        or return undef ;

    return 1;

}

sub ckMagic
{
    my $self = shift;

    my $magic ;
    $self->smartReadExact(\$magic, 4);

    *$self->{HeaderPending} = $magic ;

    return $self->HeaderError("Minimum header size is " . 
                              4 . " bytes") 
        if length $magic != 4 ;                                    

    return $self->HeaderError("Bad Magic")
        if ! _isZipMagic($magic) ;

    *$self->{Type} = 'zip';

    return $magic ;
}


sub fastForward
{
    my $self = shift;
    my $offset = shift;

    # TODO - if Stream isn't enabled & reading from file, use seek

    my $buffer = '';
    my $c = 1024 * 16;

    while ($offset > 0)
    {
        $c = length $offset
            if length $offset < $c ;

        $offset -= $c;

        $self->smartReadExact(\$buffer, $c)
            or return 0;
    }

    return 1;
}


sub readHeader
{
    my $self = shift;
    my $magic = shift ;

    my $name =  *$self->{UnzipData}{Name} ;
    my $hdr = $self->_readZipHeader($magic) ;

    while (defined $hdr)
    {
        if (! defined $name || $hdr->{Name} eq $name)
        {
            return $hdr ;
        }

        # skip the data
        # TODO - when Stream is off, use seek
        my $buffer;
        if (*$self->{ZipData}{Streaming}) {

            while (1) {

                my $b;
                my $status = $self->smartRead(\$b, 1024 * 16);
                return undef
                    if $status <= 0 ;

                my $temp_buf;
                my $out;
                $status = *$self->{Uncomp}->uncompr(\$b, \$temp_buf, 0, $out);

                return $self->saveErrorString(undef, *$self->{Uncomp}{Error}, 
                                                     *$self->{Uncomp}{ErrorNo})
                    if $self->saveStatus($status) == STATUS_ERROR;                

                if ($status == STATUS_ENDSTREAM) {
                    *$self->{Uncomp}->reset();
                    $self->pushBack($b)  ;
                    last;
                }
            }

            # skip the trailer
            $self->smartReadExact(\$buffer, $hdr->{TrailerLength})
                or return $self->saveErrorString(undef, "Truncated file");
        }
        else {
            my $c = $hdr->{CompressedLength}->get64bit();
            $self->fastForward($c)
                or return $self->saveErrorString(undef, "Truncated file");
            $buffer = '';
        }

        $self->chkTrailer($buffer) == STATUS_OK
            or return $self->saveErrorString(undef, "Truncated file");

        $hdr = $self->_readFullZipHeader();

        return $self->saveErrorString(undef, "Cannot find '$name'")
            if $self->smartEof();
    }

    return undef;
}

sub chkTrailer
{
    my $self = shift;
    my $trailer = shift;

    my ($sig, $CRC32, $cSize, $uSize) ;
    my ($cSizeHi, $uSizeHi) = (0, 0);
    if (*$self->{ZipData}{Streaming}) {
        $sig   = unpack ("V", substr($trailer, 0, 4));
        $CRC32 = unpack ("V", substr($trailer, 4, 4));

        if (*$self->{ZipData}{Zip64} ) {
            $cSize = U64::newUnpack_V64 substr($trailer,  8, 8);
            $uSize = U64::newUnpack_V64 substr($trailer, 16, 8);
        }
        else {
            $cSize = U64::newUnpack_V32 substr($trailer,  8, 4);
            $uSize = U64::newUnpack_V32 substr($trailer, 12, 4);
        }

        return $self->TrailerError("Data Descriptor signature, got $sig")
            if $sig != ZIP_DATA_HDR_SIG;
    }
    else {
        ($CRC32, $cSize, $uSize) = 
            (*$self->{ZipData}{Crc32},
             *$self->{ZipData}{CompressedLen},
             *$self->{ZipData}{UnCompressedLen});
    }

    *$self->{Info}{CRC32} = *$self->{ZipData}{CRC32} ;
    *$self->{Info}{CompressedLength} = $cSize->get64bit();
    *$self->{Info}{UncompressedLength} = $uSize->get64bit();

    if (*$self->{Strict}) {
        return $self->TrailerError("CRC mismatch")
            if $CRC32  != *$self->{ZipData}{CRC32} ;

        return $self->TrailerError("CSIZE mismatch.")
            if ! $cSize->equal(*$self->{CompSize});

        return $self->TrailerError("USIZE mismatch.")
            if ! $uSize->equal(*$self->{UnCompSize});
    }

    my $reachedEnd = STATUS_ERROR ;
    # check for central directory or end of central directory
    while (1)
    {
        my $magic ;
        my $got = $self->smartRead(\$magic, 4);

        return $self->saveErrorString(STATUS_ERROR, "Truncated file")
            if $got != 4 && *$self->{Strict};

        if ($got == 0) {
            return STATUS_EOF ;
        }
        elsif ($got < 0) {
            return STATUS_ERROR ;
        }
        elsif ($got < 4) {
            $self->pushBack($magic)  ;
            return STATUS_OK ;
        }

        my $sig = unpack("V", $magic) ;

        my $hdr;
        if ($hdr = $headerLookup{$sig})
        {
            if (&$hdr($self, $magic) != STATUS_OK ) {
                if (*$self->{Strict}) {
                    return STATUS_ERROR ;
                }
                else {
                    $self->clearError();
                    return STATUS_OK ;
                }
            }

            if ($sig == ZIP_END_CENTRAL_HDR_SIG)
            {
                return STATUS_OK ;
                last;
            }
        }
        elsif ($sig == ZIP_LOCAL_HDR_SIG)
        {
            $self->pushBack($magic)  ;
            return STATUS_OK ;
        }
        else
        {
            # put the data back
            $self->pushBack($magic)  ;
            last;
        }
    }

    return $reachedEnd ;
}

sub skipCentralDirectory
{
    my $self = shift;
    my $magic = shift ;

    my $buffer;
    $self->smartReadExact(\$buffer, 46 - 4)
        or return $self->TrailerError("Minimum header size is " . 
                                     46 . " bytes") ;

    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;

   #my $versionMadeBy      = unpack ("v", substr($buffer, 4-4,  2));
   #my $extractVersion     = unpack ("v", substr($buffer, 6-4,  2));
   #my $gpFlag             = unpack ("v", substr($buffer, 8-4,  2));
   #my $compressedMethod   = unpack ("v", substr($buffer, 10-4, 2));
   #my $lastModTime        = unpack ("V", substr($buffer, 12-4, 4));
   #my $crc32              = unpack ("V", substr($buffer, 16-4, 4));
    my $compressedLength   = unpack ("V", substr($buffer, 20-4, 4));
    my $uncompressedLength = unpack ("V", substr($buffer, 24-4, 4));
    my $filename_length    = unpack ("v", substr($buffer, 28-4, 2)); 
    my $extra_length       = unpack ("v", substr($buffer, 30-4, 2));
    my $comment_length     = unpack ("v", substr($buffer, 32-4, 2));
   #my $disk_start         = unpack ("v", substr($buffer, 34-4, 2));
   #my $int_file_attrib    = unpack ("v", substr($buffer, 36-4, 2));
   #my $ext_file_attrib    = unpack ("V", substr($buffer, 38-4, 2));
   #my $lcl_hdr_offset     = unpack ("V", substr($buffer, 42-4, 2));

    
    my $filename;
    my $extraField;
    my $comment ;
    if ($filename_length)
    {
        $self->smartReadExact(\$filename, $filename_length)
            or return $self->TruncatedTrailer("filename");
        $keep .= $filename ;
    }

    if ($extra_length)
    {
        $self->smartReadExact(\$extraField, $extra_length)
            or return $self->TruncatedTrailer("extra");
        $keep .= $extraField ;
    }

    if ($comment_length)
    {
        $self->smartReadExact(\$comment, $comment_length)
            or return $self->TruncatedTrailer("comment");
        $keep .= $comment ;
    }

    return STATUS_OK ;
}

sub skipArchiveExtra
{
    my $self = shift;
    my $magic = shift ;

    my $buffer;
    $self->smartReadExact(\$buffer, 4)
        or return $self->TrailerError("Minimum header size is " . 
                                     4 . " bytes") ;

    my $keep = $magic . $buffer ;

    my $size = unpack ("V", $buffer);

    $self->smartReadExact(\$buffer, $size)
        or return $self->TrailerError("Minimum header size is " . 
                                     $size . " bytes") ;

    $keep .= $buffer ;
    *$self->{HeaderPending} = $keep ;

    return STATUS_OK ;
}


sub skipCentralDirectory64Rec
{
    my $self = shift;
    my $magic = shift ;

    my $buffer;
    $self->smartReadExact(\$buffer, 8)
        or return $self->TrailerError("Minimum header size is " . 
                                     8 . " bytes") ;

    my $keep = $magic . $buffer ;

    my ($sizeLo, $sizeHi)  = unpack ("V V", $buffer);
    my $size = $sizeHi * U64::MAX32 + $sizeLo;

    $self->fastForward($size)
        or return $self->TrailerError("Minimum header size is " . 
                                     $size . " bytes") ;

   #$keep .= $buffer ;
   #*$self->{HeaderPending} = $keep ;

   #my $versionMadeBy      = unpack ("v",   substr($buffer,  0, 2));
   #my $extractVersion     = unpack ("v",   substr($buffer,  2, 2));
   #my $diskNumber         = unpack ("V",   substr($buffer,  4, 4));
   #my $cntrlDirDiskNo     = unpack ("V",   substr($buffer,  8, 4));
   #my $entriesInThisCD    = unpack ("V V", substr($buffer, 12, 8));
   #my $entriesInCD        = unpack ("V V", substr($buffer, 20, 8));
   #my $sizeOfCD           = unpack ("V V", substr($buffer, 28, 8));
   #my $offsetToCD         = unpack ("V V", substr($buffer, 36, 8));

    return STATUS_OK ;
}

sub skipCentralDirectory64Loc
{
    my $self = shift;
    my $magic = shift ;

    my $buffer;
    $self->smartReadExact(\$buffer, 20 - 4)
        or return $self->TrailerError("Minimum header size is " . 
                                     20 . " bytes") ;

    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;

   #my $startCdDisk        = unpack ("V",   substr($buffer,  4-4, 4));
   #my $offsetToCD         = unpack ("V V", substr($buffer,  8-4, 8));
   #my $diskCount          = unpack ("V",   substr($buffer, 16-4, 4));

    return STATUS_OK ;
}

sub skipEndCentralDirectory
{
    my $self = shift;
    my $magic = shift ;

    my $buffer;
    $self->smartReadExact(\$buffer, 22 - 4)
        or return $self->TrailerError("Minimum header size is " . 
                                     22 . " bytes") ;

    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;

   #my $diskNumber         = unpack ("v", substr($buffer, 4-4,  2));
   #my $cntrlDirDiskNo     = unpack ("v", substr($buffer, 6-4,  2));
   #my $entriesInThisCD    = unpack ("v", substr($buffer, 8-4,  2));
   #my $entriesInCD        = unpack ("v", substr($buffer, 10-4, 2));
   #my $sizeOfCD           = unpack ("V", substr($buffer, 12-4, 4));
   #my $offsetToCD         = unpack ("V", substr($buffer, 16-4, 4));
    my $comment_length     = unpack ("v", substr($buffer, 20-4, 2));

    
    my $comment ;
    if ($comment_length)
    {
        $self->smartReadExact(\$comment, $comment_length)
            or return $self->TruncatedTrailer("comment");
        $keep .= $comment ;
    }

    return STATUS_OK ;
}


sub _isZipMagic
{
    my $buffer = shift ;
    return 0 if length $buffer < 4 ;
    my $sig = unpack("V", $buffer) ;
    return $sig == ZIP_LOCAL_HDR_SIG ;
}


sub _readFullZipHeader($)
{
    my ($self) = @_ ;
    my $magic = '' ;

    $self->smartReadExact(\$magic, 4);

    *$self->{HeaderPending} = $magic ;

    return $self->HeaderError("Minimum header size is " . 
                              30 . " bytes") 
        if length $magic != 4 ;                                    


    return $self->HeaderError("Bad Magic")
        if ! _isZipMagic($magic) ;

    my $status = $self->_readZipHeader($magic);
    delete *$self->{Transparent} if ! defined $status ;
    return $status ;
}

sub _readZipHeader($)
{
    my ($self, $magic) = @_ ;
    my ($HeaderCRC) ;
    my ($buffer) = '' ;

    $self->smartReadExact(\$buffer, 30 - 4)
        or return $self->HeaderError("Minimum header size is " . 
                                     30 . " bytes") ;

    my $keep = $magic . $buffer ;
    *$self->{HeaderPending} = $keep ;

    my $extractVersion     = unpack ("v", substr($buffer, 4-4,  2));
    my $gpFlag             = unpack ("v", substr($buffer, 6-4,  2));
    my $compressedMethod   = unpack ("v", substr($buffer, 8-4,  2));
    my $lastModTime        = unpack ("V", substr($buffer, 10-4, 4));
    my $crc32              = unpack ("V", substr($buffer, 14-4, 4));
    my $compressedLength   = U64::newUnpack_V32 substr($buffer, 18-4, 4);
    my $uncompressedLength = U64::newUnpack_V32 substr($buffer, 22-4, 4);
    my $filename_length    = unpack ("v", substr($buffer, 26-4, 2)); 
    my $extra_length       = unpack ("v", substr($buffer, 28-4, 2));

    my $filename;
    my $extraField;
    my @EXTRA = ();
    my $streamingMode = ($gpFlag & ZIP_GP_FLAG_STREAMING_MASK) ? 1 : 0 ;

    return $self->HeaderError("Encrypted content not supported")
        if $gpFlag & (ZIP_GP_FLAG_ENCRYPTED_MASK|ZIP_GP_FLAG_STRONG_ENCRYPTED_MASK);

    return $self->HeaderError("Patch content not supported")
        if $gpFlag & ZIP_GP_FLAG_PATCHED_MASK;

    *$self->{ZipData}{Streaming} = $streamingMode;


    if ($filename_length)
    {
        $self->smartReadExact(\$filename, $filename_length)
            or return $self->TruncatedHeader("Filename");
        $keep .= $filename ;
    }

    my $zip64 = 0 ;

    if ($extra_length)
    {
        $self->smartReadExact(\$extraField, $extra_length)
            or return $self->TruncatedHeader("Extra Field");

        my $bad = IO::Compress::Zlib::Extra::parseRawExtra($extraField,
                                                \@EXTRA, 1, 0);
        return $self->HeaderError($bad)
            if defined $bad;

        $keep .= $extraField ;

        my %Extra ;
        for (@EXTRA)
        {
            $Extra{$_->[0]} = \$_->[1];
        }
        
        if (defined $Extra{ZIP_EXTRA_ID_ZIP64()})
        {
            $zip64 = 1 ;

            my $buff = ${ $Extra{ZIP_EXTRA_ID_ZIP64()} };

            # This code assumes that all the fields in the Zip64
            # extra field aren't necessarily present. The spec says that
            # they only exist if the equivalent local headers are -1.

            if (! $streamingMode) {
                my $offset = 0 ;

                if (U64::full32 $uncompressedLength->get32bit() ) {
                    $uncompressedLength 
                            = U64::newUnpack_V64 substr($buff, 0, 8);

                    $offset += 8 ;
                }

                if (U64::full32 $compressedLength->get32bit() ) {

                    $compressedLength 
                        = U64::newUnpack_V64 substr($buff, $offset, 8);

                    $offset += 8 ;
                }
           }
        }
    }

    *$self->{ZipData}{Zip64} = $zip64;

    if (! $streamingMode) {
        *$self->{ZipData}{Streaming} = 0;
        *$self->{ZipData}{Crc32} = $crc32;
        *$self->{ZipData}{CompressedLen} = $compressedLength;
        *$self->{ZipData}{UnCompressedLen} = $uncompressedLength;
        *$self->{CompressedInputLengthRemaining} =
            *$self->{CompressedInputLength} = $compressedLength->get64bit();
    }

    *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(undef);
    *$self->{ZipData}{Method} = $compressedMethod;
    if ($compressedMethod == ZIP_CM_DEFLATE)
    {
        *$self->{Type} = 'zip-deflate';
        my $obj = IO::Uncompress::Adapter::Inflate::mkUncompObject(1,0,0);

        *$self->{Uncomp} = $obj;
    }
    elsif ($compressedMethod == ZIP_CM_BZIP2)
    {
        return $self->HeaderError("Unsupported Compression format $compressedMethod")
            if ! defined $IO::Uncompress::Adapter::Bunzip2::VERSION ;
        
        *$self->{Type} = 'zip-bzip2';
        
        my $obj = IO::Uncompress::Adapter::Bunzip2::mkUncompObject();

        *$self->{Uncomp} = $obj;
    }
    elsif ($compressedMethod == ZIP_CM_LZMA)
    {
        return $self->HeaderError("Unsupported Compression format $compressedMethod")
            if ! defined $IO::Uncompress::Adapter::UnLzma::VERSION ;
        
        *$self->{Type} = 'zip-lzma';
        my $LzmaHeader;
        $self->smartReadExact(\$LzmaHeader, 4)
                or return $self->saveErrorString(undef, "Truncated file");
        my ($verHi, $verLo)   = unpack ("CC", substr($LzmaHeader, 0, 2));
        my $LzmaPropertiesSize   = unpack ("v", substr($LzmaHeader, 2, 2));


        my $LzmaPropertyData;
        $self->smartReadExact(\$LzmaPropertyData, $LzmaPropertiesSize)
                or return $self->saveErrorString(undef, "Truncated file");

        if (! $streamingMode) {
            *$self->{ZipData}{CompressedLen}->subtract(4 + $LzmaPropertiesSize) ;
            *$self->{CompressedInputLengthRemaining} =
                *$self->{CompressedInputLength} = *$self->{ZipData}{CompressedLen}->get64bit();
        }

        my $obj =
            IO::Uncompress::Adapter::UnLzma::mkUncompZipObject($LzmaPropertyData);

        *$self->{Uncomp} = $obj;
    }
    elsif ($compressedMethod == ZIP_CM_STORE)
    {
        *$self->{Type} = 'zip-stored';
        
        my $obj =
        IO::Uncompress::Adapter::Identity::mkUncompObject($streamingMode,
                                                          $zip64);

        *$self->{Uncomp} = $obj;
    }
    else
    {
        return $self->HeaderError("Unsupported Compression format $compressedMethod");
    }

    return {
        'Type'               => 'zip',
        'FingerprintLength'  => 4,
        #'HeaderLength'       => $compressedMethod == 8 ? length $keep : 0,
        'HeaderLength'       => length $keep,
        'Zip64'              => $zip64,
        'TrailerLength'      => ! $streamingMode ? 0 : $zip64 ? 24 : 16,
        'Header'             => $keep,
        'CompressedLength'   => $compressedLength ,
        'UncompressedLength' => $uncompressedLength ,
        'CRC32'              => $crc32 ,
        'Name'               => $filename,
        'Time'               => _dosToUnixTime($lastModTime),
        'Stream'             => $streamingMode,

        'MethodID'           => $compressedMethod,
        'MethodName'         => $compressedMethod == ZIP_CM_DEFLATE 
                                 ? "Deflated" 
                                 : $compressedMethod == ZIP_CM_BZIP2
                                     ? "Bzip2"
                                     : $compressedMethod == ZIP_CM_LZMA
                                         ? "Lzma"
                                         : $compressedMethod == ZIP_CM_STORE
                                             ? "Stored"
                                             : "Unknown" ,

#        'TextFlag'      => $flag & GZIP_FLG_FTEXT ? 1 : 0,
#        'HeaderCRCFlag' => $flag & GZIP_FLG_FHCRC ? 1 : 0,
#        'NameFlag'      => $flag & GZIP_FLG_FNAME ? 1 : 0,
#        'CommentFlag'   => $flag & GZIP_FLG_FCOMMENT ? 1 : 0,
#        'ExtraFlag'     => $flag & GZIP_FLG_FEXTRA ? 1 : 0,
#        'Comment'       => $comment,
#        'OsID'          => $os,
#        'OsName'        => defined $GZIP_OS_Names{$os} 
#                                 ? $GZIP_OS_Names{$os} : "Unknown",
#        'HeaderCRC'     => $HeaderCRC,
#        'Flags'         => $flag,
#        'ExtraFlags'    => $xfl,
        'ExtraFieldRaw' => $extraField,
        'ExtraField'    => [ @EXTRA ],


      }
}

sub filterUncompressed
{
    my $self = shift ;

    if (*$self->{ZipData}{Method} == ZIP_CM_DEFLATE) {
        *$self->{ZipData}{CRC32} = *$self->{Uncomp}->crc32() ;
    }
    else {
        *$self->{ZipData}{CRC32} = Compress::Raw::Zlib::crc32(${$_[0]}, *$self->{ZipData}{CRC32}, $_[1]);
    }
}    


# from Archive::Zip & info-zip
sub _dosToUnixTime
{
	my $dt = shift;

	my $year = ( ( $dt >> 25 ) & 0x7f ) + 80;
	my $mon  = ( ( $dt >> 21 ) & 0x0f ) - 1;
	my $mday = ( ( $dt >> 16 ) & 0x1f );

	my $hour = ( ( $dt >> 11 ) & 0x1f );
	my $min  = ( ( $dt >> 5 ) & 0x3f );
	my $sec  = ( ( $dt << 1 ) & 0x3e );


    use POSIX 'mktime';

    my $time_t = mktime( $sec, $min, $hour, $mday, $mon, $year, 0, 0, -1 );
    return 0 if ! defined $time_t;
	return $time_t;
}

#sub scanCentralDirectory
#{
#    # Use cases
#    # 1 32-bit CD
#    # 2 64-bit CD
#
#    my $self = shift ;
#
#    my @CD = ();
#    my $offset = $self->findCentralDirectoryOffset();
#
#    return 0
#        if ! defined $offset;
#
#    $self->smarkSeek($offset, 0, SEEK_SET) ;
#
#    # Now walk the Central Directory Records
#    my $buffer ;
#    while ($self->smartReadExact(\$buffer, 46) && 
#           unpack("V", $buffer) == ZIP_CENTRAL_HDR_SIG) {
#
#        my $compressedLength   = unpack ("V", substr($buffer, 20, 4));
#        my $filename_length    = unpack ("v", substr($buffer, 28, 2));
#        my $extra_length       = unpack ("v", substr($buffer, 30, 2));
#        my $comment_length     = unpack ("v", substr($buffer, 32, 2));
#
#        $self->smarkSeek($filename_length + $extra_length + $comment_length, 0, SEEK_CUR) 
#            if $extra_length || $comment_length || $filename_length;
#        push @CD, $compressedLength ;
#    }
#
#}
#
#sub findCentralDirectoryOffset
#{
#    my $self = shift ;
#
#    # Most common use-case is where there is no comment, so
#    # know exactly where the end of central directory record
#    # should be.
#
#    $self->smarkSeek(-22, 0, SEEK_END) ;
#
#    my $buffer;
#    $self->smartReadExact(\$buffer, 22) ;
#
#    my $zip64 = 0;                             
#    my $centralDirOffset ;
#    if ( unpack("V", $buffer) == ZIP_END_CENTRAL_HDR_SIG ) {
#        $centralDirOffset = unpack ("V", substr($buffer, 16, 2));
#    }
#    else {
#        die "xxxx";
#    }
#
#    return $centralDirOffset ;
#}
#
#sub is84BitCD
#{
#    # TODO
#    my $self = shift ;
#}


sub skip
{
    my $self = shift;
    my $size = shift;

    use Fcntl qw(SEEK_CUR);
    if (ref $size eq 'U64') {
        $self->smartSeek($size->get64bit(), SEEK_CUR);
    }
    else {
        $self->smartSeek($size, SEEK_CUR);
    }
    
}


sub scanCentralDirectory
{
    my $self = shift;

    my $here = $self->tell();

    # Use cases
    # 1 32-bit CD
    # 2 64-bit CD

    my @CD = ();
    my $offset = $self->findCentralDirectoryOffset();

    return ()
        if ! defined $offset;

    $self->smarkSeek($offset, 0, SEEK_SET) ;

    # Now walk the Central Directory Records
    my $buffer ;
    while ($self->smartReadExact(\$buffer, 46) && 
           unpack("V", $buffer) == ZIP_CENTRAL_HDR_SIG) {

        my $compressedLength   = unpack("V", substr($buffer, 20, 4));
        my $uncompressedLength = unpack("V", substr($buffer, 24, 4));
        my $filename_length    = unpack("v", substr($buffer, 28, 2));
        my $extra_length       = unpack("v", substr($buffer, 30, 2));
        my $comment_length     = unpack("v", substr($buffer, 32, 2));

        $self->skip($filename_length ) ;

        my $v64 = new U64 $compressedLength ;

        if (U64::full32 $compressedLength ) {
            $self->smartReadExact(\$buffer, $extra_length) ;
            die "xxx $offset $comment_length $filename_length $extra_length" . length($buffer) 
                if length($buffer) != $extra_length;
            my $got = $self->get64Extra($buffer, U64::full32 $uncompressedLength);

            # If not Zip64 extra field, assume size is 0xFFFFFFFF
            $v64 = $got if defined $got;
        }
        else {
            $self->skip($extra_length) ;
        }

        $self->skip($comment_length ) ;
            
        push @CD, $v64 ;
    }

    $self->smartSeek($here, 0, SEEK_SET) ;

    return @CD;
}

sub get64Extra
{
    my $self = shift ;

    my $buffer = shift;
    my $is_uncomp = shift ;

    my $extra = IO::Compress::Zlib::Extra::findID(0x0001, $buffer);
                                            
    if (! defined $extra)
    {
        return undef;
    }
    else
    {
        my $u64 = U64::newUnpack_V64(substr($extra,  $is_uncomp ? 8 : 0)) ;
        return $u64;
    }    
}

sub offsetFromZip64
{
    my $self = shift ;
    my $here = shift;

    $self->smartSeek($here - 20, 0, SEEK_SET) 
        or die "xx $!" ;

    my $buffer;
    my $got = 0;
    $self->smartReadExact(\$buffer, 20)  
        or die "xxx $here $got $!" ;

    if ( unpack("V", $buffer) == ZIP64_END_CENTRAL_LOC_HDR_SIG ) {
        my $cd64 = U64::Value_VV64 substr($buffer,  8, 8);
       
        $self->smartSeek($cd64, 0, SEEK_SET) ;

        $self->smartReadExact(\$buffer, 4) 
            or die "xxx" ;

        if ( unpack("V", $buffer) == ZIP64_END_CENTRAL_REC_HDR_SIG ) {

            $self->smartReadExact(\$buffer, 8)
                or die "xxx" ;
            my $size  = U64::Value_VV64($buffer);
            $self->smartReadExact(\$buffer, $size)
                or die "xxx" ;

            my $cd64 =  U64::Value_VV64 substr($buffer,  36, 8);

            return $cd64 ;
        }
        
        die "zzz";
    }

    die "zzz";
}

use constant Pack_ZIP_END_CENTRAL_HDR_SIG => pack("V", ZIP_END_CENTRAL_HDR_SIG);

sub findCentralDirectoryOffset
{
    my $self = shift ;

    # Most common use-case is where there is no comment, so
    # know exactly where the end of central directory record
    # should be.

    $self->smartSeek(-22, 0, SEEK_END) ;
    my $here = $self->tell();

    my $buffer;
    $self->smartReadExact(\$buffer, 22) 
        or die "xxx" ;

    my $zip64 = 0;                             
    my $centralDirOffset ;
    if ( unpack("V", $buffer) == ZIP_END_CENTRAL_HDR_SIG ) {
        $centralDirOffset = unpack("V", substr($buffer, 16,  4));
    }
    else {
        $self->smartSeek(0, 0, SEEK_END) ;

        my $fileLen = $self->tell();
        my $want = 0 ;

        while(1) {
            $want += 1024;
            my $seekTo = $fileLen - $want;
            if ($seekTo < 0 ) {
                $seekTo = 0;
                $want = $fileLen ;
            }
            $self->smartSeek( $seekTo, 0, SEEK_SET) 
                or die "xxx $!" ;
            my $got;
            $self->smartReadExact($buffer, $want)
                or die "xxx " ;
            my $pos = rindex( $buffer, Pack_ZIP_END_CENTRAL_HDR_SIG);

            if ($pos >= 0) {
                #$here = $self->tell();
                $here = $seekTo + $pos ;
                $centralDirOffset = unpack("V", substr($buffer, $pos + 16,  4));
                last ;
            }

            return undef
                if $want == $fileLen;
        }
    }

    $centralDirOffset = $self->offsetFromZip64($here)
        if U64::full32 $centralDirOffset ;

    return $centralDirOffset ;
}

1;

__END__


=head1 NAME

IO::Uncompress::Unzip - Read zip files/buffers

=head1 SYNOPSIS

    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

    my $status = unzip $input => $output [,OPTS]
        or die "unzip failed: $UnzipError\n";

    my $z = new IO::Uncompress::Unzip $input [OPTS] 
        or die "unzip failed: $UnzipError\n";

    $status = $z->read($buffer)
    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)
    $line = $z->getline()
    $char = $z->getc()
    $char = $z->ungetc()
    $char = $z->opened()

    $status = $z->inflateSync()

    $data = $z->trailingData()
    $status = $z->nextStream()
    $data = $z->getHeaderInfo()
    $z->tell()
    $z->seek($position, $whence)
    $z->binmode()
    $z->fileno()
    $z->eof()
    $z->close()

    $UnzipError ;

    # IO::File mode

    <$z>
    read($z, $buffer);
    read($z, $buffer, $length);
    read($z, $buffer, $length, $offset);
    tell($z)
    seek($z, $position, $whence)
    binmode($z)
    fileno($z)
    eof($z)
    close($z)

=head1 DESCRIPTION

This module provides a Perl interface that allows the reading of
zlib files/buffers.

For writing zip files/buffers, see the companion module IO::Compress::Zip.

=head1 Functional Interface

A top-level function, C<unzip>, is provided to carry out
"one-shot" uncompression between buffers and/or files. For finer
control over the uncompression process, see the L</"OO Interface">
section.

    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

    unzip $input_filename_or_reference => $output_filename_or_reference [,OPTS] 
        or die "unzip failed: $UnzipError\n";

The functional interface needs Perl5.005 or better.

=head2 unzip $input_filename_or_reference => $output_filename_or_reference [, OPTS]

C<unzip> expects at least two parameters,
C<$input_filename_or_reference> and C<$output_filename_or_reference>.

=head3 The C<$input_filename_or_reference> parameter

The parameter, C<$input_filename_or_reference>, is used to define the
source of the compressed data. 

It can take one of the following forms:

=over 5

=item A filename

If the <$input_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename. This file will be opened for reading and the
input data will be read from it.

=item A filehandle

If the C<$input_filename_or_reference> parameter is a filehandle, the input
data will be read from it.  The string '-' can be used as an alias for
standard input.

=item A scalar reference 

If C<$input_filename_or_reference> is a scalar reference, the input data
will be read from C<$$input_filename_or_reference>.

=item An array reference 

If C<$input_filename_or_reference> is an array reference, each element in
the array must be a filename.

The input data will be read from each file in turn. 

The complete array will be walked to ensure that it only
contains valid filenames before any data is uncompressed.

=item An Input FileGlob string

If C<$input_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<unzip> will assume that it is an 
I<input fileglob string>. The input is the list of files that match the 
fileglob.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$input_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head3 The C<$output_filename_or_reference> parameter

The parameter C<$output_filename_or_reference> is used to control the
destination of the uncompressed data. This parameter can take one of
these forms.

=over 5

=item A filename

If the C<$output_filename_or_reference> parameter is a simple scalar, it is
assumed to be a filename.  This file will be opened for writing and the 
uncompressed data will be written to it.

=item A filehandle

If the C<$output_filename_or_reference> parameter is a filehandle, the
uncompressed data will be written to it.  The string '-' can be used as
an alias for standard output.

=item A scalar reference 

If C<$output_filename_or_reference> is a scalar reference, the
uncompressed data will be stored in C<$$output_filename_or_reference>.

=item An Array Reference

If C<$output_filename_or_reference> is an array reference, 
the uncompressed data will be pushed onto the array.

=item An Output FileGlob

If C<$output_filename_or_reference> is a string that is delimited by the
characters "<" and ">" C<unzip> will assume that it is an
I<output fileglob string>. The output is the list of files that match the
fileglob.

When C<$output_filename_or_reference> is an fileglob string,
C<$input_filename_or_reference> must also be a fileglob string. Anything
else is an error.

See L<File::GlobMapper|File::GlobMapper> for more details.

=back

If the C<$output_filename_or_reference> parameter is any other type,
C<undef> will be returned.

=head2 Notes

When C<$input_filename_or_reference> maps to multiple compressed
files/buffers and C<$output_filename_or_reference> is
a single file/buffer, after uncompression C<$output_filename_or_reference> will contain a
concatenation of all the uncompressed data from each of the input
files/buffers.

=head2 Optional Parameters

Unless specified below, the optional parameters for C<unzip>,
C<OPTS>, are the same as those used with the OO interface defined in the
L</"Constructor Options"> section below.

=over 5

=item C<< AutoClose => 0|1 >>

This option applies to any input or output data streams to 
C<unzip> that are filehandles.

If C<AutoClose> is specified, and the value is true, it will result in all
input and/or output filehandles being closed once C<unzip> has
completed.

This parameter defaults to 0.

=item C<< BinModeOut => 0|1 >>

When writing to a file or filehandle, set C<binmode> before writing to the
file.

Defaults to 0.

=item C<< Append => 0|1 >>

The behaviour of this option is dependent on the type of output data
stream.

=over 5

=item * A Buffer

If C<Append> is enabled, all uncompressed data will be append to the end of
the output buffer. Otherwise the output buffer will be cleared before any
uncompressed data is written to it.

=item * A Filename

If C<Append> is enabled, the file will be opened in append mode. Otherwise
the contents of the file, if any, will be truncated before any uncompressed
data is written to it.

=item * A Filehandle

If C<Append> is enabled, the filehandle will be positioned to the end of
the file via a call to C<seek> before any uncompressed data is
written to it.  Otherwise the file pointer will not be moved.

=back

When C<Append> is specified, and set to true, it will I<append> all uncompressed 
data to the output data stream.

So when the output is a filehandle it will carry out a seek to the eof
before writing any uncompressed data. If the output is a filename, it will be opened for
appending. If the output is a buffer, all uncompressed data will be
appended to the existing buffer.

Conversely when C<Append> is not specified, or it is present and is set to
false, it will operate as follows.

When the output is a filename, it will truncate the contents of the file
before writing any uncompressed data. If the output is a filehandle
its position will not be changed. If the output is a buffer, it will be
wiped before any uncompressed data is output.

Defaults to 0.

=item C<< MultiStream => 0|1 >>

If the input file/buffer contains multiple compressed data streams, this
option will uncompress the whole lot as a single data stream.

Defaults to 0.

=item C<< TrailingData => $scalar >>

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. 

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option.

=back

=head2 Examples

Say you have a zip file, C<file1.zip>, that only contains a
single member, you can read it and write the uncompressed data to the
file C<file1.txt> like this.

    use strict ;
    use warnings ;
    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

    my $input = "file1.zip";
    my $output = "file1.txt";
    unzip $input => $output
        or die "unzip failed: $UnzipError\n";

If you have a zip file that contains multiple members and want to read a
specific member from the file, say C<"data1">, use the C<Name> option 

    use strict ;
    use warnings ;
    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

    my $input = "file1.zip";
    my $output = "file1.txt";
    unzip $input => $output, Name => "data1"
        or die "unzip failed: $UnzipError\n";

Alternatively, if you want to read the  C<"data1"> member into memory, use
a scalar reference for the C<output> parameter.

    use strict ;
    use warnings ;
    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

    my $input = "file1.zip";
    my $output ;
    unzip $input => \$output, Name => "data1"
        or die "unzip failed: $UnzipError\n";
    # $output now contains the uncompressed data

To read from an existing Perl filehandle, C<$input>, and write the
uncompressed data to a buffer, C<$buffer>.

    use strict ;
    use warnings ;
    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;
    use IO::File ;

    my $input = new IO::File "<file1.zip"
        or die "Cannot open 'file1.zip': $!\n" ;
    my $buffer ;
    unzip $input => \$buffer 
        or die "unzip failed: $UnzipError\n";

=head1 OO Interface

=head2 Constructor

The format of the constructor for IO::Uncompress::Unzip is shown below

    my $z = new IO::Uncompress::Unzip $input [OPTS]
        or die "IO::Uncompress::Unzip failed: $UnzipError\n";

Returns an C<IO::Uncompress::Unzip> object on success and undef on failure.
The variable C<$UnzipError> will contain an error message on failure.

If you are running Perl 5.005 or better the object, C<$z>, returned from
IO::Uncompress::Unzip can be used exactly like an L<IO::File|IO::File> filehandle.
This means that all normal input file operations can be carried out with
C<$z>.  For example, to read a line from a compressed file/buffer you can
use either of these forms

    $line = $z->getline();
    $line = <$z>;

The mandatory parameter C<$input> is used to determine the source of the
compressed data. This parameter can take one of three forms.

=over 5

=item A filename

If the C<$input> parameter is a scalar, it is assumed to be a filename. This
file will be opened for reading and the compressed data will be read from it.

=item A filehandle

If the C<$input> parameter is a filehandle, the compressed data will be
read from it.
The string '-' can be used as an alias for standard input.

=item A scalar reference 

If C<$input> is a scalar reference, the compressed data will be read from
C<$$input>.

=back

=head2 Constructor Options

The option names defined below are case insensitive and can be optionally
prefixed by a '-'.  So all of the following are valid

    -AutoClose
    -autoclose
    AUTOCLOSE
    autoclose

OPTS is a combination of the following options:

=over 5

=item C<< Name => "membername" >>

Open "membername" from the zip file for reading. 

=item C<< AutoClose => 0|1 >>

This option is only valid when the C<$input> parameter is a filehandle. If
specified, and the value is true, it will result in the file being closed once
either the C<close> method is called or the IO::Uncompress::Unzip object is
destroyed.

This parameter defaults to 0.

=item C<< MultiStream => 0|1 >>

Treats the complete zip file/buffer as a single compressed data
stream. When reading in multi-stream mode each member of the zip
file/buffer will be uncompressed in turn until the end of the file/buffer
is encountered.

This parameter defaults to 0.

=item C<< Prime => $string >>

This option will uncompress the contents of C<$string> before processing the
input file/buffer.

This option can be useful when the compressed data is embedded in another
file/data structure and it is not possible to work out where the compressed
data begins without having to read the first few bytes. If this is the
case, the uncompression can be I<primed> with these bytes using this
option.

=item C<< Transparent => 0|1 >>

If this option is set and the input file/buffer is not compressed data,
the module will allow reading of it anyway.

In addition, if the input file/buffer does contain compressed data and
there is non-compressed data immediately following it, setting this option
will make this module treat the whole file/buffer as a single data stream.

This option defaults to 1.

=item C<< BlockSize => $num >>

When reading the compressed input data, IO::Uncompress::Unzip will read it in
blocks of C<$num> bytes.

This option defaults to 4096.

=item C<< InputLength => $size >>

When present this option will limit the number of compressed bytes read
from the input file/buffer to C<$size>. This option can be used in the
situation where there is useful data directly after the compressed data
stream and you know beforehand the exact length of the compressed data
stream. 

This option is mostly used when reading from a filehandle, in which case
the file pointer will be left pointing to the first byte directly after the
compressed data stream.

This option defaults to off.

=item C<< Append => 0|1 >>

This option controls what the C<read> method does with uncompressed data.

If set to 1, all uncompressed data will be appended to the output parameter
of the C<read> method.

If set to 0, the contents of the output parameter of the C<read> method
will be overwritten by the uncompressed data.

Defaults to 0.

=item C<< Strict => 0|1 >>

This option controls whether the extra checks defined below are used when
carrying out the decompression. When Strict is on, the extra tests are
carried out, when Strict is off they are not.

The default for this option is off.

=back

=head2 Examples

TODO

=head1 Methods 

=head2 read

Usage is

    $status = $z->read($buffer)

Reads a block of compressed data (the size of the compressed block is
determined by the C<Buffer> option in the constructor), uncompresses it and
writes any uncompressed data into C<$buffer>. If the C<Append> parameter is
set in the constructor, the uncompressed data will be appended to the
C<$buffer> parameter. Otherwise C<$buffer> will be overwritten.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 read

Usage is

    $status = $z->read($buffer, $length)
    $status = $z->read($buffer, $length, $offset)

    $status = read($z, $buffer, $length)
    $status = read($z, $buffer, $length, $offset)

Attempt to read C<$length> bytes of uncompressed data into C<$buffer>.

The main difference between this form of the C<read> method and the
previous one, is that this one will attempt to return I<exactly> C<$length>
bytes. The only circumstances that this function will not is if end-of-file
or an IO error is encountered.

Returns the number of uncompressed bytes written to C<$buffer>, zero if eof
or a negative number on error.

=head2 getline

Usage is

    $line = $z->getline()
    $line = <$z>

Reads a single line. 

This method fully supports the use of the variable C<$/> (or
C<$INPUT_RECORD_SEPARATOR> or C<$RS> when C<English> is in use) to
determine what constitutes an end of line. Paragraph mode, record mode and
file slurp mode are all supported. 

=head2 getc

Usage is 

    $char = $z->getc()

Read a single character.

=head2 ungetc

Usage is

    $char = $z->ungetc($string)

=head2 inflateSync

Usage is

    $status = $z->inflateSync()

TODO

=head2 getHeaderInfo

Usage is

    $hdr  = $z->getHeaderInfo();
    @hdrs = $z->getHeaderInfo();

This method returns either a hash reference (in scalar context) or a list
or hash references (in array context) that contains information about each
of the header fields in the compressed data stream(s).

=head2 tell

Usage is

    $z->tell()
    tell $z

Returns the uncompressed file offset.

=head2 eof

Usage is

    $z->eof();
    eof($z);

Returns true if the end of the compressed input stream has been reached.

=head2 seek

    $z->seek($position, $whence);
    seek($z, $position, $whence);

Provides a sub-set of the C<seek> functionality, with the restriction
that it is only legal to seek forward in the input file/buffer.
It is a fatal error to attempt to seek backward.

Note that the implementation of C<seek> in this module does not provide
true random access to a compressed file/buffer. It  works by uncompressing
data from the current offset in the file/buffer until it reaches the
uncompressed offset specified in the parameters to C<seek>. For very small
files this may be acceptable behaviour. For large files it may cause an
unacceptable delay.

The C<$whence> parameter takes one the usual values, namely SEEK_SET,
SEEK_CUR or SEEK_END.

Returns 1 on success, 0 on failure.

=head2 binmode

Usage is

    $z->binmode
    binmode $z ;

This is a noop provided for completeness.

=head2 opened

    $z->opened()

Returns true if the object currently refers to a opened file/buffer. 

=head2 autoflush

    my $prev = $z->autoflush()
    my $prev = $z->autoflush(EXPR)

If the C<$z> object is associated with a file or a filehandle, this method
returns the current autoflush setting for the underlying filehandle. If
C<EXPR> is present, and is non-zero, it will enable flushing after every
write/print operation.

If C<$z> is associated with a buffer, this method has no effect and always
returns C<undef>.

B<Note> that the special variable C<$|> B<cannot> be used to set or
retrieve the autoflush setting.

=head2 input_line_number

    $z->input_line_number()
    $z->input_line_number(EXPR)

Returns the current uncompressed line number. If C<EXPR> is present it has
the effect of setting the line number. Note that setting the line number
does not change the current position within the file/buffer being read.

The contents of C<$/> are used to determine what constitutes a line
terminator.

=head2 fileno

    $z->fileno()
    fileno($z)

If the C<$z> object is associated with a file or a filehandle, C<fileno>
will return the underlying file descriptor. Once the C<close> method is
called C<fileno> will return C<undef>.

If the C<$z> object is associated with a buffer, this method will return
C<undef>.

=head2 close

    $z->close() ;
    close $z ;

Closes the output file/buffer. 

For most versions of Perl this method will be automatically invoked if
the IO::Uncompress::Unzip object is destroyed (either explicitly or by the
variable with the reference to the object going out of scope). The
exceptions are Perl versions 5.005 through 5.00504 and 5.8.0. In
these cases, the C<close> method will be called automatically, but
not until global destruction of all live objects when the program is
terminating.

Therefore, if you want your scripts to be able to run on all versions
of Perl, you should call C<close> explicitly and not rely on automatic
closing.

Returns true on success, otherwise 0.

If the C<AutoClose> option has been enabled when the IO::Uncompress::Unzip
object was created, and the object is associated with a file, the
underlying file will also be closed.

=head2 nextStream

Usage is

    my $status = $z->nextStream();

Skips to the next compressed data stream in the input file/buffer. If a new
compressed data stream is found, the eof marker will be cleared and C<$.>
will be reset to 0.

Returns 1 if a new stream was found, 0 if none was found, and -1 if an
error was encountered.

=head2 trailingData

Usage is

    my $data = $z->trailingData();

Returns the data, if any, that is present immediately after the compressed
data stream once uncompression is complete. It only makes sense to call
this method once the end of the compressed data stream has been
encountered.

This option can be used when there is useful information immediately
following the compressed data stream, and you don't know the length of the
compressed data stream.

If the input is a buffer, C<trailingData> will return everything from the
end of the compressed data stream to the end of the buffer.

If the input is a filehandle, C<trailingData> will return the data that is
left in the filehandle input buffer once the end of the compressed data
stream has been reached. You can then use the filehandle to read the rest
of the input file. 

Don't bother using C<trailingData> if the input is a filename.

If you know the length of the compressed data stream before you start
uncompressing, you can avoid having to use C<trailingData> by setting the
C<InputLength> option in the constructor.

=head1 Importing 

No symbolic constants are required by this IO::Uncompress::Unzip at present. 

=over 5

=item :all

Imports C<unzip> and C<$UnzipError>.
Same as doing this

    use IO::Uncompress::Unzip qw(unzip $UnzipError) ;

=back

=head1 EXAMPLES

=head2 Working with Net::FTP

See L<IO::Compress::FAQ|IO::Compress::FAQ/"Compressed files and Net::FTP">

=head2 Walking through a zip file

The code below can be used to traverse a zip file, one compressed data
stream at a time.

    use IO::Uncompress::Unzip qw($UnzipError);

    my $zipfile = "somefile.zip";
    my $u = new IO::Uncompress::Unzip $zipfile
        or die "Cannot open $zipfile: $UnzipError";

    my $status;
    for ($status = 1; $status > 0; $status = $u->nextStream())
    {
 
        my $name = $u->getHeaderInfo()->{Name};
        warn "Processing member $name\n" ;

        my $buff;
        while (($status = $u->read($buff)) > 0) {
            # Do something here
        }

        last if $status < 0;
    }

    die "Error processing $zipfile: $!\n"
        if $status < 0 ;

Each individual compressed data stream is read until the logical
end-of-file is reached. Then C<nextStream> is called. This will skip to the
start of the next compressed data stream and clear the end-of-file flag.

It is also worth noting that C<nextStream> can be called at any time -- you
don't have to wait until you have exhausted a compressed data stream before
skipping to the next one.

=head2 Unzipping a complete zip file to disk

Daniel S. Sterling has written a script that uses C<IO::Uncompress::UnZip>
to read a zip file and unzip its contents to disk.

The script is available from L<https://gist.github.com/eqhmcow/5389877>

=head1 SEE ALSO

L<Compress::Zlib>, L<IO::Compress::Gzip>, L<IO::Uncompress::Gunzip>, L<IO::Compress::Deflate>, L<IO::Uncompress::Inflate>, L<IO::Compress::RawDeflate>, L<IO::Uncompress::RawInflate>, L<IO::Compress::Bzip2>, L<IO::Uncompress::Bunzip2>, L<IO::Compress::Lzma>, L<IO::Uncompress::UnLzma>, L<IO::Compress::Xz>, L<IO::Uncompress::UnXz>, L<IO::Compress::Lzop>, L<IO::Uncompress::UnLzop>, L<IO::Compress::Lzf>, L<IO::Uncompress::UnLzf>, L<IO::Uncompress::AnyInflate>, L<IO::Uncompress::AnyUncompress>

L<IO::Compress::FAQ|IO::Compress::FAQ>

L<File::GlobMapper|File::GlobMapper>, L<Archive::Zip|Archive::Zip>,
L<Archive::Tar|Archive::Tar>,
L<IO::Zlib|IO::Zlib>

For RFC 1950, 1951 and 1952 see 
F<http://www.faqs.org/rfcs/rfc1950.html>,
F<http://www.faqs.org/rfcs/rfc1951.html> and
F<http://www.faqs.org/rfcs/rfc1952.html>

The I<zlib> compression library was written by Jean-loup Gailly
F<gzip@prep.ai.mit.edu> and Mark Adler F<madler@alumni.caltech.edu>.

The primary site for the I<zlib> compression library is
F<http://www.zlib.org>.

The primary site for gzip is F<http://www.gzip.org>.

=head1 AUTHOR

This module was written by Paul Marquess, F<pmqs@cpan.org>. 

=head1 MODIFICATION HISTORY

See the Changes file.

=head1 COPYRIGHT AND LICENSE

Copyright (c) 2005-2014 Paul Marquess. All rights reserved.

This program is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

                                                                                                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/IO/Zlib.pm                                                                    0100644 0000000 0000000 00000035247 12744441327 014436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # IO::Zlib.pm
#
# Copyright (c) 1998-2004 Tom Hughes <tom@compton.nu>.
# All rights reserved. This program is free software; you can redistribute
# it and/or modify it under the same terms as Perl itself.

package IO::Zlib;

$VERSION = "1.10";

=head1 NAME

IO::Zlib - IO:: style interface to L<Compress::Zlib>

=head1 SYNOPSIS

With any version of Perl 5 you can use the basic OO interface:

    use IO::Zlib;

    $fh = new IO::Zlib;
    if ($fh->open("file.gz", "rb")) {
        print <$fh>;
        $fh->close;
    }

    $fh = IO::Zlib->new("file.gz", "wb9");
    if (defined $fh) {
        print $fh "bar\n";
        $fh->close;
    }

    $fh = IO::Zlib->new("file.gz", "rb");
    if (defined $fh) {
        print <$fh>;
        undef $fh;       # automatically closes the file
    }

With Perl 5.004 you can also use the TIEHANDLE interface to access
compressed files just like ordinary files:

    use IO::Zlib;

    tie *FILE, 'IO::Zlib', "file.gz", "wb";
    print FILE "line 1\nline2\n";

    tie *FILE, 'IO::Zlib', "file.gz", "rb";
    while (<FILE>) { print "LINE: ", $_ };

=head1 DESCRIPTION

C<IO::Zlib> provides an IO:: style interface to L<Compress::Zlib> and
hence to gzip/zlib compressed files. It provides many of the same methods
as the L<IO::Handle> interface.

Starting from IO::Zlib version 1.02, IO::Zlib can also use an
external F<gzip> command.  The default behaviour is to try to use
an external F<gzip> if no C<Compress::Zlib> can be loaded, unless
explicitly disabled by

    use IO::Zlib qw(:gzip_external 0);

If explicitly enabled by

    use IO::Zlib qw(:gzip_external 1);

then the external F<gzip> is used B<instead> of C<Compress::Zlib>.

=head1 CONSTRUCTOR

=over 4

=item new ( [ARGS] )

Creates an C<IO::Zlib> object. If it receives any parameters, they are
passed to the method C<open>; if the open fails, the object is destroyed.
Otherwise, it is returned to the caller.

=back

=head1 OBJECT METHODS

=over 4

=item open ( FILENAME, MODE )

C<open> takes two arguments. The first is the name of the file to open
and the second is the open mode. The mode can be anything acceptable to
L<Compress::Zlib> and by extension anything acceptable to I<zlib> (that
basically means POSIX fopen() style mode strings plus an optional number
to indicate the compression level).

=item opened

Returns true if the object currently refers to a opened file.

=item close

Close the file associated with the object and disassociate
the file from the handle.
Done automatically on destroy.

=item getc

Return the next character from the file, or undef if none remain.

=item getline

Return the next line from the file, or undef on end of string.
Can safely be called in an array context.
Currently ignores $/ ($INPUT_RECORD_SEPARATOR or $RS when L<English>
is in use) and treats lines as delimited by "\n".

=item getlines

Get all remaining lines from the file.
It will croak() if accidentally called in a scalar context.

=item print ( ARGS... )

Print ARGS to the  file.

=item read ( BUF, NBYTES, [OFFSET] )

Read some bytes from the file.
Returns the number of bytes actually read, 0 on end-of-file, undef on error.

=item eof

Returns true if the handle is currently positioned at end of file?

=item seek ( OFFSET, WHENCE )

Seek to a given position in the stream.
Not yet supported.

=item tell

Return the current position in the stream, as a numeric offset.
Not yet supported.

=item setpos ( POS )

Set the current position, using the opaque value returned by C<getpos()>.
Not yet supported.

=item getpos ( POS )

Return the current position in the string, as an opaque object.
Not yet supported.

=back

=head1 USING THE EXTERNAL GZIP

If the external F<gzip> is used, the following C<open>s are used:

    open(FH, "gzip -dc $filename |")  # for read opens
    open(FH, " | gzip > $filename")   # for write opens

You can modify the 'commands' for example to hardwire
an absolute path by e.g.

    use IO::Zlib ':gzip_read_open'  => '/some/where/gunzip -c %s |';
    use IO::Zlib ':gzip_write_open' => '| /some/where/gzip.exe > %s';

The C<%s> is expanded to be the filename (C<sprintf> is used, so be
careful to escape any other C<%> signs).  The 'commands' are checked
for sanity - they must contain the C<%s>, and the read open must end
with the pipe sign, and the write open must begin with the pipe sign.

=head1 CLASS METHODS

=over 4

=item has_Compress_Zlib

Returns true if C<Compress::Zlib> is available.  Note that this does
not mean that C<Compress::Zlib> is being used: see L</gzip_external>
and L<gzip_used>.

=item gzip_external

Undef if an external F<gzip> B<can> be used if C<Compress::Zlib> is
not available (see L</has_Compress_Zlib>), true if an external F<gzip>
is explicitly used, false if an external F<gzip> must not be used.
See L</gzip_used>.

=item gzip_used

True if an external F<gzip> is being used, false if not.

=item gzip_read_open

Return the 'command' being used for opening a file for reading using an
external F<gzip>.

=item gzip_write_open

Return the 'command' being used for opening a file for writing using an
external F<gzip>.

=back

=head1 DIAGNOSTICS

=over 4

=item IO::Zlib::getlines: must be called in list context

If you want read lines, you must read in list context.

=item IO::Zlib::gzopen_external: mode '...' is illegal

Use only modes 'rb' or 'wb' or /wb[1-9]/.

=item IO::Zlib::import: '...' is illegal

The known import symbols are the C<:gzip_external>, C<:gzip_read_open>,
and C<:gzip_write_open>.  Anything else is not recognized.

=item IO::Zlib::import: ':gzip_external' requires an argument

The C<:gzip_external> requires one boolean argument.

=item IO::Zlib::import: 'gzip_read_open' requires an argument

The C<:gzip_external> requires one string argument.

=item IO::Zlib::import: 'gzip_read' '...' is illegal

The C<:gzip_read_open> argument must end with the pipe sign (|)
and have the C<%s> for the filename.  See L</"USING THE EXTERNAL GZIP">.

=item IO::Zlib::import: 'gzip_write_open' requires an argument

The C<:gzip_external> requires one string argument.

=item IO::Zlib::import: 'gzip_write_open' '...' is illegal

The C<:gzip_write_open> argument must begin with the pipe sign (|)
and have the C<%s> for the filename.  An output redirect (>) is also
often a good idea, depending on your operating system shell syntax.
See L</"USING THE EXTERNAL GZIP">.

=item IO::Zlib::import: no Compress::Zlib and no external gzip

Given that we failed to load C<Compress::Zlib> and that the use of
 an external F<gzip> was disabled, IO::Zlib has not much chance of working.

=item IO::Zlib::open: needs a filename

No filename, no open.

=item IO::Zlib::READ: NBYTES must be specified

We must know how much to read.

=item IO::Zlib::WRITE: too long LENGTH

The LENGTH must be less than or equal to the buffer size.

=back

=head1 SEE ALSO

L<perlfunc>,
L<perlop/"I/O Operators">,
L<IO::Handle>,
L<Compress::Zlib>

=head1 HISTORY

Created by Tom Hughes E<lt>F<tom@compton.nu>E<gt>.

Support for external gzip added by Jarkko Hietaniemi E<lt>F<jhi@iki.fi>E<gt>.

=head1 COPYRIGHT

Copyright (c) 1998-2004 Tom Hughes E<lt>F<tom@compton.nu>E<gt>.
All rights reserved. This program is free software; you can redistribute
it and/or modify it under the same terms as Perl itself.

=cut

require 5.006;

use strict;
use vars qw($VERSION $AUTOLOAD @ISA);

use Carp;
use Fcntl qw(SEEK_SET);

my $has_Compress_Zlib;
my $aliased;

sub has_Compress_Zlib {
    $has_Compress_Zlib;
}

BEGIN {
    eval { require Compress::Zlib };
    $has_Compress_Zlib = $@ || $Compress::Zlib::VERSION < 2.000 ? 0 : 1;
}

use Symbol;
use Tie::Handle;

# These might use some $^O logic.
my $gzip_read_open   = "gzip -dc %s |";
my $gzip_write_open  = "| gzip > %s";

my $gzip_external;
my $gzip_used;

sub gzip_read_open {
    $gzip_read_open;
}

sub gzip_write_open {
    $gzip_write_open;
}

sub gzip_external {
    $gzip_external;
}

sub gzip_used {
    $gzip_used;
}

sub can_gunzip {
    $has_Compress_Zlib || $gzip_external;
}

sub _import {
    my $import = shift;
    while (@_) {
	if ($_[0] eq ':gzip_external') {
	    shift;
	    if (@_) {
		$gzip_external = shift;
	    } else {
		croak "$import: ':gzip_external' requires an argument";
	    }
	}
	elsif ($_[0] eq ':gzip_read_open') {
	    shift;
	    if (@_) {
		$gzip_read_open = shift;
		croak "$import: ':gzip_read_open' '$gzip_read_open' is illegal"
		    unless $gzip_read_open =~ /^.+%s.+\|\s*$/;
	    } else {
		croak "$import: ':gzip_read_open' requires an argument";
	    }
	}
	elsif ($_[0] eq ':gzip_write_open') {
	    shift;
	    if (@_) {
		$gzip_write_open = shift;
		croak "$import: ':gzip_write_open' '$gzip_read_open' is illegal"
		    unless $gzip_write_open =~ /^\s*\|.+%s.*$/;
	    } else {
		croak "$import: ':gzip_write_open' requires an argument";
	    }
	}
	else {
	    last;
	}
    }
    return @_;
}

sub _alias {
    my $import = shift;
    if ((!$has_Compress_Zlib && !defined $gzip_external) || $gzip_external) {
	# The undef *gzopen is really needed only during
	# testing where we eval several 'use IO::Zlib's.
	undef *gzopen;
        *gzopen                 = \&gzopen_external;
        *IO::Handle::gzread     = \&gzread_external;
        *IO::Handle::gzwrite    = \&gzwrite_external;
        *IO::Handle::gzreadline = \&gzreadline_external;
        *IO::Handle::gzeof      = \&gzeof_external;
        *IO::Handle::gzclose    = \&gzclose_external;
	$gzip_used = 1;
    } else {
	croak "$import: no Compress::Zlib and no external gzip"
	    unless $has_Compress_Zlib;
        *gzopen     = \&Compress::Zlib::gzopen;
        *gzread     = \&Compress::Zlib::gzread;
        *gzwrite    = \&Compress::Zlib::gzwrite;
        *gzreadline = \&Compress::Zlib::gzreadline;
        *gzeof      = \&Compress::Zlib::gzeof;
    }
    $aliased = 1;
}

sub import {
    shift;
    my $import = "IO::Zlib::import";
    if (@_) {
	if (_import($import, @_)) {
	    croak "$import: '@_' is illegal";
	}
    }
    _alias($import);
}

@ISA = qw(Tie::Handle);

sub TIEHANDLE
{
    my $class = shift;
    my @args = @_;

    my $self = bless {}, $class;

    return @args ? $self->OPEN(@args) : $self;
}

sub DESTROY
{
}

sub OPEN
{
    my $self = shift;
    my $filename = shift;
    my $mode = shift;

    croak "IO::Zlib::open: needs a filename" unless defined($filename);

    $self->{'file'} = gzopen($filename,$mode);

    return defined($self->{'file'}) ? $self : undef;
}

sub CLOSE
{
    my $self = shift;

    return undef unless defined($self->{'file'});

    my $status = $self->{'file'}->gzclose();

    delete $self->{'file'};

    return ($status == 0) ? 1 : undef;
}

sub READ
{
    my $self = shift;
    my $bufref = \$_[0];
    my $nbytes = $_[1];
    my $offset = $_[2] || 0;

    croak "IO::Zlib::READ: NBYTES must be specified" unless defined($nbytes);

    $$bufref = "" unless defined($$bufref);

    my $bytesread = $self->{'file'}->gzread(substr($$bufref,$offset),$nbytes);

    return undef if $bytesread < 0;

    return $bytesread;
}

sub READLINE
{
    my $self = shift;

    my $line;

    return () if $self->{'file'}->gzreadline($line) <= 0;

    return $line unless wantarray;

    my @lines = $line;

    while ($self->{'file'}->gzreadline($line) > 0)
    {
        push @lines, $line;
    }

    return @lines;
}

sub WRITE
{
    my $self = shift;
    my $buf = shift;
    my $length = shift;
    my $offset = shift;

    croak "IO::Zlib::WRITE: too long LENGTH" unless $offset + $length <= length($buf);

    return $self->{'file'}->gzwrite(substr($buf,$offset,$length));
}

sub EOF
{
    my $self = shift;

    return $self->{'file'}->gzeof();
}

sub FILENO
{
    return undef;
}

sub new
{
    my $class = shift;
    my @args = @_;

    _alias("new", @_) unless $aliased; # Some call new IO::Zlib directly...

    my $self = gensym();

    tie *{$self}, $class, @args;

    return tied(${$self}) ? bless $self, $class : undef;
}

sub getline
{
    my $self = shift;

    return scalar tied(*{$self})->READLINE();
}

sub getlines
{
    my $self = shift;

    croak "IO::Zlib::getlines: must be called in list context"
	unless wantarray;

    return tied(*{$self})->READLINE();
}

sub opened
{
    my $self = shift;

    return defined tied(*{$self})->{'file'};
}

sub AUTOLOAD
{
    my $self = shift;

    $AUTOLOAD =~ s/.*:://;
    $AUTOLOAD =~ tr/a-z/A-Z/;

    return tied(*{$self})->$AUTOLOAD(@_);
}

sub gzopen_external {
    my ($filename, $mode) = @_;
    require IO::Handle;
    my $fh = IO::Handle->new();
    if ($mode =~ /r/) {
	# Because someone will try to read ungzipped files
	# with this we peek and verify the signature.  Yes,
	# this means that we open the file twice (if it is
	# gzipped).
	# Plenty of race conditions exist in this code, but
	# the alternative would be to capture the stderr of
	# gzip and parse it, which would be a portability nightmare.
	if (-e $filename && open($fh, $filename)) {
	    binmode $fh;
	    my $sig;
	    my $rdb = read($fh, $sig, 2);
	    if ($rdb == 2 && $sig eq "\x1F\x8B") {
		my $ropen = sprintf $gzip_read_open, $filename;
		if (open($fh, $ropen)) {
		    binmode $fh;
		    return $fh;
		} else {
		    return undef;
		}
	    }
	    seek($fh, 0, SEEK_SET) or
		die "IO::Zlib: open('$filename', 'r'): seek: $!";
	    return $fh;
	} else {
	    return undef;
	}
    } elsif ($mode =~ /w/) {
	my $level = '';
	$level = "-$1" if $mode =~ /([1-9])/;
	# To maximize portability we would need to open
	# two filehandles here, one for "| gzip $level"
	# and another for "> $filename", and then when
	# writing copy bytes from the first to the second.
	# We are using IO::Handle objects for now, however,
	# and they can only contain one stream at a time.
	my $wopen = sprintf $gzip_write_open, $filename;
	if (open($fh, $wopen)) {
	    $fh->autoflush(1);
	    binmode $fh;
	    return $fh;
	} else {
	    return undef;
	}
    } else {
	croak "IO::Zlib::gzopen_external: mode '$mode' is illegal";
    }
    return undef;
}

sub gzread_external {
    # Use read() instead of syswrite() because people may
    # mix reads and readlines, and we don't want to mess
    # the stdio buffering.  See also gzreadline_external()
    # and gzwrite_external().
    my $nread = read($_[0], $_[1], @_ == 3 ? $_[2] : 4096);
    defined $nread ? $nread : -1;
}

sub gzwrite_external {
    # Using syswrite() is okay (cf. gzread_external())
    # since the bytes leave this process and buffering
    # is therefore not an issue.
    my $nwrote = syswrite($_[0], $_[1]);
    defined $nwrote ? $nwrote : -1;
}

sub gzreadline_external {
    # See the comment in gzread_external().
    $_[1] = readline($_[0]);
    return defined $_[1] ? length($_[1]) : -1;
}

sub gzeof_external {
    return eof($_[0]);
}

sub gzclose_external {
    close($_[0]);
    # I am not entirely certain why this is needed but it seems
    # the above close() always fails (as if the stream would have
    # been already closed - something to do with using external
    # processes via pipes?)
    return 0;
}

1;
                                                                                                                                                                                                                                                                                                                                                         usr/share/perl/5.20.2/IPC/                                                                          0040755 0000000 0000000 00000000000 13077704254 013275  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/IPC/Cmd.pm                                                                    0100644 0000000 0000000 00000200627 12744441327 014341  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package IPC::Cmd;

use strict;

BEGIN {

    use constant IS_VMS         => $^O eq 'VMS'                       ? 1 : 0;
    use constant IS_WIN32       => $^O eq 'MSWin32'                   ? 1 : 0;
    use constant IS_WIN98       => (IS_WIN32 and !Win32::IsWinNT())   ? 1 : 0;
    use constant ALARM_CLASS    => __PACKAGE__ . '::TimeOut';
    use constant SPECIAL_CHARS  => qw[< > | &];
    use constant QUOTE          => do { IS_WIN32 ? q["] : q['] };

    use Exporter    ();
    use vars        qw[ @ISA $VERSION @EXPORT_OK $VERBOSE $DEBUG
                        $USE_IPC_RUN $USE_IPC_OPEN3 $CAN_USE_RUN_FORKED $WARN
                        $INSTANCES $ALLOW_NULL_ARGS
                        $HAVE_MONOTONIC
                    ];

    $VERSION        = '0.92';
    $VERBOSE        = 0;
    $DEBUG          = 0;
    $WARN           = 1;
    $USE_IPC_RUN    = IS_WIN32 && !IS_WIN98;
    $USE_IPC_OPEN3  = not IS_VMS;
    $ALLOW_NULL_ARGS = 0;

    $CAN_USE_RUN_FORKED = 0;
    eval {
        require POSIX; POSIX->import();
        require IPC::Open3; IPC::Open3->import();
        require IO::Select; IO::Select->import();
        require IO::Handle; IO::Handle->import();
        require FileHandle; FileHandle->import();
        require Socket;
        require Time::HiRes; Time::HiRes->import();
        require Win32 if IS_WIN32;
    };
    $CAN_USE_RUN_FORKED = $@ || !IS_VMS && !IS_WIN32;

    eval {
        my $wait_start_time = Time::HiRes::clock_gettime(&Time::HiRes::CLOCK_MONOTONIC);
    };
    if ($@) {
        $HAVE_MONOTONIC = 0;
    }
    else {
        $HAVE_MONOTONIC = 1;
    }

    @ISA            = qw[Exporter];
    @EXPORT_OK      = qw[can_run run run_forked QUOTE];
}

require Carp;
use File::Spec;
use Params::Check               qw[check];
use Text::ParseWords            ();             # import ONLY if needed!
use Module::Load::Conditional   qw[can_load];
use Locale::Maketext::Simple    Style => 'gettext';

=pod

=head1 NAME

IPC::Cmd - finding and running system commands made easy

=head1 SYNOPSIS

    use IPC::Cmd qw[can_run run run_forked];

    my $full_path = can_run('wget') or warn 'wget is not installed!';

    ### commands can be arrayrefs or strings ###
    my $cmd = "$full_path -b theregister.co.uk";
    my $cmd = [$full_path, '-b', 'theregister.co.uk'];

    ### in scalar context ###
    my $buffer;
    if( scalar run( command => $cmd,
                    verbose => 0,
                    buffer  => \$buffer,
                    timeout => 20 )
    ) {
        print "fetched webpage successfully: $buffer\n";
    }


    ### in list context ###
    my( $success, $error_message, $full_buf, $stdout_buf, $stderr_buf ) =
            run( command => $cmd, verbose => 0 );

    if( $success ) {
        print "this is what the command printed:\n";
        print join "", @$full_buf;
    }

    ### run_forked example ###
    my $result = run_forked("$full_path -q -O - theregister.co.uk", {'timeout' => 20});
    if ($result->{'exit_code'} eq 0 && !$result->{'timeout'}) {
        print "this is what wget returned:\n";
        print $result->{'stdout'};
    }

    ### check for features
    print "IPC::Open3 available: "  . IPC::Cmd->can_use_ipc_open3;
    print "IPC::Run available: "    . IPC::Cmd->can_use_ipc_run;
    print "Can capture buffer: "    . IPC::Cmd->can_capture_buffer;

    ### don't have IPC::Cmd be verbose, ie don't print to stdout or
    ### stderr when running commands -- default is '0'
    $IPC::Cmd::VERBOSE = 0;


=head1 DESCRIPTION

IPC::Cmd allows you to run commands platform independently,
interactively if desired, but have them still work.

The C<can_run> function can tell you if a certain binary is installed
and if so where, whereas the C<run> function can actually execute any
of the commands you give it and give you a clear return value, as well
as adhere to your verbosity settings.

=head1 CLASS METHODS

=head2 $ipc_run_version = IPC::Cmd->can_use_ipc_run( [VERBOSE] )

Utility function that tells you if C<IPC::Run> is available.
If the C<verbose> flag is passed, it will print diagnostic messages
if L<IPC::Run> can not be found or loaded.

=cut


sub can_use_ipc_run     {
    my $self    = shift;
    my $verbose = shift || 0;

    ### IPC::Run doesn't run on win98
    return if IS_WIN98;

    ### if we don't have ipc::run, we obviously can't use it.
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    return unless can_load(
                        modules => { 'IPC::Run' => '0.55' },
                        verbose => ($WARN && $verbose),
                    );

    ### otherwise, we're good to go
    return $IPC::Run::VERSION;
}

=head2 $ipc_open3_version = IPC::Cmd->can_use_ipc_open3( [VERBOSE] )

Utility function that tells you if C<IPC::Open3> is available.
If the verbose flag is passed, it will print diagnostic messages
if C<IPC::Open3> can not be found or loaded.

=cut


sub can_use_ipc_open3   {
    my $self    = shift;
    my $verbose = shift || 0;

    ### IPC::Open3 is not working on VMS because of a lack of fork.
    return if IS_VMS;

    ### IPC::Open3 works on every non-VMS platform, but it can't
    ### capture buffers on win32 :(
    local @INC = @INC;
    pop @INC if $INC[-1] eq '.';
    return unless can_load(
        modules => { map {$_ => '0.0'} qw|IPC::Open3 IO::Select Symbol| },
        verbose => ($WARN && $verbose),
    );

    return $IPC::Open3::VERSION;
}

=head2 $bool = IPC::Cmd->can_capture_buffer

Utility function that tells you if C<IPC::Cmd> is capable of
capturing buffers in it's current configuration.

=cut

sub can_capture_buffer {
    my $self    = shift;

    return 1 if $USE_IPC_RUN    && $self->can_use_ipc_run;
    return 1 if $USE_IPC_OPEN3  && $self->can_use_ipc_open3;
    return;
}

=head2 $bool = IPC::Cmd->can_use_run_forked

Utility function that tells you if C<IPC::Cmd> is capable of
providing C<run_forked> on the current platform.

=head1 FUNCTIONS

=head2 $path = can_run( PROGRAM );

C<can_run> takes only one argument: the name of a binary you wish
to locate. C<can_run> works much like the unix binary C<which> or the bash
command C<type>, which scans through your path, looking for the requested
binary.

Unlike C<which> and C<type>, this function is platform independent and
will also work on, for example, Win32.

If called in a scalar context it will return the full path to the binary
you asked for if it was found, or C<undef> if it was not.

If called in a list context and the global variable C<$INSTANCES> is a true
value, it will return a list of the full paths to instances
of the binary where found in C<PATH>, or an empty list if it was not found.

=cut

sub can_run {
    my $command = shift;

    # a lot of VMS executables have a symbol defined
    # check those first
    if ( $^O eq 'VMS' ) {
        require VMS::DCLsym;
        my $syms = VMS::DCLsym->new;
        return $command if scalar $syms->getsym( uc $command );
    }

    require File::Spec;
    require ExtUtils::MakeMaker;

    my @possibles;

    if( File::Spec->file_name_is_absolute($command) ) {
        return MM->maybe_command($command);

    } else {
        for my $dir (
            File::Spec->path,
            File::Spec->curdir
        ) {
            next if ! $dir || ! -d $dir;
            my $abs = File::Spec->catfile( IS_WIN32 ? Win32::GetShortPathName( $dir ) : $dir, $command);
            push @possibles, $abs if $abs = MM->maybe_command($abs);
        }
    }
    return @possibles if wantarray and $INSTANCES;
    return shift @possibles;
}

=head2 $ok | ($ok, $err, $full_buf, $stdout_buff, $stderr_buff) = run( command => COMMAND, [verbose => BOOL, buffer => \$SCALAR, timeout => DIGIT] );

C<run> takes 4 arguments:

=over 4

=item command

This is the command to execute. It may be either a string or an array
reference.
This is a required argument.

See L<"Caveats"> for remarks on how commands are parsed and their
limitations.

=item verbose

This controls whether all output of a command should also be printed
to STDOUT/STDERR or should only be trapped in buffers (NOTE: buffers
require L<IPC::Run> to be installed, or your system able to work with
L<IPC::Open3>).

It will default to the global setting of C<$IPC::Cmd::VERBOSE>,
which by default is 0.

=item buffer

This will hold all the output of a command. It needs to be a reference
to a scalar.
Note that this will hold both the STDOUT and STDERR messages, and you
have no way of telling which is which.
If you require this distinction, run the C<run> command in list context
and inspect the individual buffers.

Of course, this requires that the underlying call supports buffers. See
the note on buffers above.

=item timeout

Sets the maximum time the command is allowed to run before aborting,
using the built-in C<alarm()> call. If the timeout is triggered, the
C<errorcode> in the return value will be set to an object of the
C<IPC::Cmd::TimeOut> class. See the L<"error message"> section below for
details.

Defaults to C<0>, meaning no timeout is set.

=back

C<run> will return a simple C<true> or C<false> when called in scalar
context.
In list context, you will be returned a list of the following items:

=over 4

=item success

A simple boolean indicating if the command executed without errors or
not.

=item error message

If the first element of the return value (C<success>) was 0, then some
error occurred. This second element is the error message the command
you requested exited with, if available. This is generally a pretty
printed value of C<$?> or C<$@>. See C<perldoc perlvar> for details on
what they can contain.
If the error was a timeout, the C<error message> will be prefixed with
the string C<IPC::Cmd::TimeOut>, the timeout class.

=item full_buffer

This is an array reference containing all the output the command
generated.
Note that buffers are only available if you have L<IPC::Run> installed,
or if your system is able to work with L<IPC::Open3> -- see below).
Otherwise, this element will be C<undef>.

=item out_buffer

This is an array reference containing all the output sent to STDOUT the
command generated. The notes from L<"full_buffer"> apply.

=item error_buffer

This is an arrayreference containing all the output sent to STDERR the
command generated. The notes from L<"full_buffer"> apply.


=back

See the L<"HOW IT WORKS"> section below to see how C<IPC::Cmd> decides
what modules or function calls to use when issuing a command.

=cut

{   my @acc = qw[ok error _fds];

    ### autogenerate accessors ###
    for my $key ( @acc ) {
        no strict 'refs';
        *{__PACKAGE__."::$key"} = sub {
            $_[0]->{$key} = $_[1] if @_ > 1;
            return $_[0]->{$key};
        }
    }
}

sub can_use_run_forked {
    return $CAN_USE_RUN_FORKED eq "1";
}

sub get_monotonic_time {
    if ($HAVE_MONOTONIC) {
        return Time::HiRes::clock_gettime(&Time::HiRes::CLOCK_MONOTONIC);
    }
    else {
        return time();
    }
}

sub adjust_monotonic_start_time {
    my ($ref_vars, $now, $previous) = @_;

    # workaround only for those systems which don't have
    # Time::HiRes::CLOCK_MONOTONIC (Mac OSX in particular)
    return if $HAVE_MONOTONIC;

    # don't have previous monotonic value (only happens once
    # in the beginning of the program execution)
    return unless $previous;

    my $time_diff = $now - $previous;

    # adjust previously saved time with the skew value which is
    # either negative when clock moved back or more than 5 seconds --
    # assuming that event loop does happen more often than once
    # per five seconds, which might not be always true (!) but
    # hopefully that's ok, because it's just a workaround
    if ($time_diff > 5 || $time_diff < 0) {
        foreach my $ref_var (@{$ref_vars}) {
            if (defined($$ref_var)) {
                $$ref_var = $$ref_var + $time_diff;
            }
        }
    }
}

# incompatible with POSIX::SigAction
#
sub install_layered_signal {
  my ($s, $handler_code) = @_;

  my %available_signals = map {$_ => 1} keys %SIG;

  Carp::confess("install_layered_signal got nonexistent signal name [$s]")
    unless defined($available_signals{$s});
  Carp::confess("install_layered_signal expects coderef")
    if !ref($handler_code) || ref($handler_code) ne 'CODE';

  my $previous_handler = $SIG{$s};

  my $sig_handler = sub {
    my ($called_sig_name, @sig_param) = @_;

    # $s is a closure referring to real signal name
    # for which this handler is being installed.
    # it is used to distinguish between
    # real signal handlers and aliased signal handlers
    my $signal_name = $s;

    # $called_sig_name is a signal name which
    # was passed to this signal handler;
    # it doesn't equal $signal_name in case
    # some signal handlers in %SIG point
    # to other signal handler (CHLD and CLD,
    # ABRT and IOT)
    #
    # initial signal handler for aliased signal
    # calls some other signal handler which
    # should not execute the same handler_code again
    if ($called_sig_name eq $signal_name) {
      $handler_code->($signal_name);
    }

    # run original signal handler if any (including aliased)
    #
    if (ref($previous_handler)) {
      $previous_handler->($called_sig_name, @sig_param);
    }
  };

  $SIG{$s} = $sig_handler;
}

# give process a chance sending TERM,
# waiting for a while (2 seconds)
# and killing it with KILL
sub kill_gently {
  my ($pid, $opts) = @_;

  require POSIX;

  $opts = {} unless $opts;
  $opts->{'wait_time'} = 2 unless defined($opts->{'wait_time'});
  $opts->{'first_kill_type'} = 'just_process' unless $opts->{'first_kill_type'};
  $opts->{'final_kill_type'} = 'just_process' unless $opts->{'final_kill_type'};

  if ($opts->{'first_kill_type'} eq 'just_process') {
    kill(15, $pid);
  }
  elsif ($opts->{'first_kill_type'} eq 'process_group') {
    kill(-15, $pid);
  }

  my $do_wait = 1;
  my $child_finished = 0;

  my $wait_start_time = get_monotonic_time();
  my $now;
  my $previous_monotonic_value;

  while ($do_wait) {
    $previous_monotonic_value = $now;
    $now = get_monotonic_time();
    
    adjust_monotonic_start_time([\$wait_start_time], $now, $previous_monotonic_value);

    if ($now > $wait_start_time + $opts->{'wait_time'}) {
        $do_wait = 0;
        next;
    }

    my $waitpid = waitpid($pid, POSIX::WNOHANG);

    if ($waitpid eq -1) {
        $child_finished = 1;
        $do_wait = 0;
        next;
    }
    
    Time::HiRes::usleep(250000); # quarter of a second
  }

  if (!$child_finished) {
    if ($opts->{'final_kill_type'} eq 'just_process') {
      kill(9, $pid);
    }
    elsif ($opts->{'final_kill_type'} eq 'process_group') {
      kill(-9, $pid);
    }
  }
}

sub open3_run {
    my ($cmd, $opts) = @_;

    $opts = {} unless $opts;

    my $child_in = FileHandle->new;
    my $child_out = FileHandle->new;
    my $child_err = FileHandle->new;
    $child_out->autoflush(1);
    $child_err->autoflush(1);

    my $pid = open3($child_in, $child_out, $child_err, $cmd);

    # push my child's pid to our parent
    # so in case i am killed parent
    # could stop my child (search for
    # child_child_pid in parent code)
    if ($opts->{'parent_info'}) {
      my $ps = $opts->{'parent_info'};
      print $ps "spawned $pid\n";
    }

    if ($child_in && $child_out->opened && $opts->{'child_stdin'}) {
        # If the child process dies for any reason,
        # the next write to CHLD_IN is likely to generate
        # a SIGPIPE in the parent, which is fatal by default.
        # So you may wish to handle this signal.
        #
        # from http://perldoc.perl.org/IPC/Open3.html,
        # absolutely needed to catch piped commands errors.
        #
        local $SIG{'PIPE'} = sub { 1; };

        print $child_in $opts->{'child_stdin'};
    }
    close($child_in);

    my $child_output = {
        'out' => $child_out->fileno,
        'err' => $child_err->fileno,
        $child_out->fileno => {
            'parent_socket' => $opts->{'parent_stdout'},
            'scalar_buffer' => "",
            'child_handle' => $child_out,
            'block_size' => ($child_out->stat)[11] || 1024,
          },
        $child_err->fileno => {
            'parent_socket' => $opts->{'parent_stderr'},
            'scalar_buffer' => "",
            'child_handle' => $child_err,
            'block_size' => ($child_err->stat)[11] || 1024,
          },
        };

    my $select = IO::Select->new();
    $select->add($child_out, $child_err);

    # pass any signal to the child
    # effectively creating process
    # strongly attached to the child:
    # it will terminate only after child
    # has terminated (except for SIGKILL,
    # which is specially handled)
    foreach my $s (keys %SIG) {
        my $sig_handler;
        $sig_handler = sub {
            kill("$s", $pid);
            $SIG{$s} = $sig_handler;
        };
        $SIG{$s} = $sig_handler;
    }

    my $child_finished = 0;

    my $real_exit;
    my $exit_value;

    while(!$child_finished) {

        # parent was killed otherwise we would have got
        # the same signal as parent and process it same way
        if (getppid() eq "1") {

          # end my process group with all the children
          # (i am the process group leader, so my pid
          # equals to the process group id)
          #
          # same thing which is done
          # with $opts->{'clean_up_children'}
          # in run_forked
          #
          kill(-9, $$);

          POSIX::_exit 1;
        }

        my $waitpid = waitpid($pid, POSIX::WNOHANG);

        # child finished, catch it's exit status
        if ($waitpid ne 0 && $waitpid ne -1) {
          $real_exit = $?;
          $exit_value = $? >> 8;
        }

        if ($waitpid eq -1) {
          $child_finished = 1;
        }


        my $ready_fds = [];
        push @{$ready_fds}, $select->can_read(1/100);

        READY_FDS: while (scalar(@{$ready_fds})) {
            my $fd = shift @{$ready_fds};
            $ready_fds = [grep {$_ ne $fd} @{$ready_fds}];

            my $str = $child_output->{$fd->fileno};
            Carp::confess("child stream not found: $fd") unless $str;

            my $data;
            my $count = $fd->sysread($data, $str->{'block_size'});

            if ($count) {
                if ($str->{'parent_socket'}) {
                    my $ph = $str->{'parent_socket'};
                    print $ph $data;
                }
                else {
                    $str->{'scalar_buffer'} .= $data;
                }
            }
            elsif ($count eq 0) {
                $select->remove($fd);
                $fd->close();
            }
            else {
                Carp::confess("error during sysread: " . $!);
            }

            push @{$ready_fds}, $select->can_read(1/100) if $child_finished;
        }

        Time::HiRes::usleep(1);
    }

    # since we've successfully reaped the child,
    # let our parent know about this.
    #
    if ($opts->{'parent_info'}) {
        my $ps = $opts->{'parent_info'};

        # child was killed, inform parent
        if ($real_exit & 127) {
          print $ps "$pid killed with " . ($real_exit & 127) . "\n";
        }

        print $ps "reaped $pid\n";
    }

    if ($opts->{'parent_stdout'} || $opts->{'parent_stderr'}) {
        return $exit_value;
    }
    else {
        return {
            'stdout' => $child_output->{$child_output->{'out'}}->{'scalar_buffer'},
            'stderr' => $child_output->{$child_output->{'err'}}->{'scalar_buffer'},
            'exit_code' => $exit_value,
            };
    }
}

=head2 $hashref = run_forked( COMMAND, { child_stdin => SCALAR, timeout => DIGIT, stdout_handler => CODEREF, stderr_handler => CODEREF} );

C<run_forked> is used to execute some program or a coderef,
optionally feed it with some input, get its return code
and output (both stdout and stderr into separate buffers).
In addition, it allows to terminate the program
if it takes too long to finish.

The important and distinguishing feature of run_forked
is execution timeout which at first seems to be
quite a simple task but if you think
that the program which you're spawning
might spawn some children itself (which
in their turn could do the same and so on)
it turns out to be not a simple issue.

C<run_forked> is designed to survive and
successfully terminate almost any long running task,
even a fork bomb in case your system has the resources
to survive during given timeout.

This is achieved by creating separate watchdog process
which spawns the specified program in a separate
process session and supervises it: optionally
feeds it with input, stores its exit code,
stdout and stderr, terminates it in case
it runs longer than specified.

Invocation requires the command to be executed or a coderef and optionally a hashref of options:

=over

=item C<timeout>

Specify in seconds how long to run the command before it is killed with SIG_KILL (9),
which effectively terminates it and all of its children (direct or indirect).

=item C<child_stdin>

Specify some text that will be passed into the C<STDIN> of the executed program.

=item C<stdout_handler>

Coderef of a subroutine to call when a portion of data is received on
STDOUT from the executing program.

=item C<stderr_handler>

Coderef of a subroutine to call when a portion of data is received on
STDERR from the executing program.


=item C<discard_output>

Discards the buffering of the standard output and standard errors for return by run_forked().
With this option you have to use the std*_handlers to read what the command outputs.
Useful for commands that send a lot of output.

=item C<terminate_on_parent_sudden_death>

Enable this option if you wish all spawned processes to be killed if the initially spawned
process (the parent) is killed or dies without waiting for child processes.

=back

C<run_forked> will return a HASHREF with the following keys:

=over

=item C<exit_code>

The exit code of the executed program.

=item C<timeout>

The number of seconds the program ran for before being terminated, or 0 if no timeout occurred.

=item C<stdout>

Holds the standard output of the executed command (or empty string if
there was no STDOUT output or if C<discard_output> was used; it's always defined!)

=item C<stderr>

Holds the standard error of the executed command (or empty string if
there was no STDERR output or if C<discard_output> was used; it's always defined!)

=item C<merged>

Holds the standard output and error of the executed command merged into one stream
(or empty string if there was no output at all or if C<discard_output> was used; it's always defined!)

=item C<err_msg>

Holds some explanation in the case of an error.

=back

=cut

sub run_forked {
    ### container to store things in
    my $self = bless {}, __PACKAGE__;

    if (!can_use_run_forked()) {
        Carp::carp("run_forked is not available: $CAN_USE_RUN_FORKED");
        return;
    }

    require POSIX;

    my ($cmd, $opts) = @_;
    if (ref($cmd) eq 'ARRAY') {
        $cmd = join(" ", @{$cmd});
    }

    if (!$cmd) {
        Carp::carp("run_forked expects command to run");
        return;
    }

    $opts = {} unless $opts;
    $opts->{'timeout'} = 0 unless $opts->{'timeout'};
    $opts->{'terminate_wait_time'} = 2 unless defined($opts->{'terminate_wait_time'});

    # turned on by default
    $opts->{'clean_up_children'} = 1 unless defined($opts->{'clean_up_children'});

    # sockets to pass child stdout to parent
    my $child_stdout_socket;
    my $parent_stdout_socket;

    # sockets to pass child stderr to parent
    my $child_stderr_socket;
    my $parent_stderr_socket;

    # sockets for child -> parent internal communication
    my $child_info_socket;
    my $parent_info_socket;

    socketpair($child_stdout_socket, $parent_stdout_socket, &Socket::AF_UNIX, &Socket::SOCK_STREAM, &Socket::PF_UNSPEC) ||
      Carp::confess ("socketpair: $!");
    socketpair($child_stderr_socket, $parent_stderr_socket, &Socket::AF_UNIX, &Socket::SOCK_STREAM, &Socket::PF_UNSPEC) ||
      Carp::confess ("socketpair: $!");
    socketpair($child_info_socket, $parent_info_socket, &Socket::AF_UNIX, &Socket::SOCK_STREAM, &Socket::PF_UNSPEC) ||
      Carp::confess ("socketpair: $!");

    $child_stdout_socket->autoflush(1);
    $parent_stdout_socket->autoflush(1);
    $child_stderr_socket->autoflush(1);
    $parent_stderr_socket->autoflush(1);
    $child_info_socket->autoflush(1);
    $parent_info_socket->autoflush(1);

    my $start_time = get_monotonic_time();

    my $pid;
    if ($pid = fork) {

      # we are a parent
      close($parent_stdout_socket);
      close($parent_stderr_socket);
      close($parent_info_socket);

      my $flags;

      # prepare sockets to read from child

      $flags = 0;
      fcntl($child_stdout_socket, POSIX::F_GETFL, $flags) || Carp::confess "can't fnctl F_GETFL: $!";
      $flags |= POSIX::O_NONBLOCK;
      fcntl($child_stdout_socket, POSIX::F_SETFL, $flags) || Carp::confess "can't fnctl F_SETFL: $!";

      $flags = 0;
      fcntl($child_stderr_socket, POSIX::F_GETFL, $flags) || Carp::confess "can't fnctl F_GETFL: $!";
      $flags |= POSIX::O_NONBLOCK;
      fcntl($child_stderr_socket, POSIX::F_SETFL, $flags) || Carp::confess "can't fnctl F_SETFL: $!";

      $flags = 0;
      fcntl($child_info_socket, POSIX::F_GETFL, $flags) || Carp::confess "can't fnctl F_GETFL: $!";
      $flags |= POSIX::O_NONBLOCK;
      fcntl($child_info_socket, POSIX::F_SETFL, $flags) || Carp::confess "can't fnctl F_SETFL: $!";

  #    print "child $pid started\n";

      my $child_output = {
        $child_stdout_socket->fileno => {
          'scalar_buffer' => "",
          'child_handle' => $child_stdout_socket,
          'block_size' => ($child_stdout_socket->stat)[11] || 1024,
          'protocol' => 'stdout',
          },
        $child_stderr_socket->fileno => {
          'scalar_buffer' => "",
          'child_handle' => $child_stderr_socket,
          'block_size' => ($child_stderr_socket->stat)[11] || 1024,
          'protocol' => 'stderr',
          },
        $child_info_socket->fileno => {
          'scalar_buffer' => "",
          'child_handle' => $child_info_socket,
          'block_size' => ($child_info_socket->stat)[11] || 1024,
          'protocol' => 'info',
          },
        };

      my $select = IO::Select->new();
      $select->add($child_stdout_socket, $child_stderr_socket, $child_info_socket);

      my $child_timedout = 0;
      my $child_finished = 0;
      my $child_stdout = '';
      my $child_stderr = '';
      my $child_merged = '';
      my $child_exit_code = 0;
      my $child_killed_by_signal = 0;
      my $parent_died = 0;

      my $last_parent_check = 0;
      my $got_sig_child = 0;
      my $got_sig_quit = 0;
      my $orig_sig_child = $SIG{'CHLD'};

      $SIG{'CHLD'} = sub { $got_sig_child = get_monotonic_time(); };

      if ($opts->{'terminate_on_signal'}) {
        install_layered_signal($opts->{'terminate_on_signal'}, sub { $got_sig_quit = time(); });
      }

      my $child_child_pid;
      my $now;
      my $previous_monotonic_value;

      while (!$child_finished) {
        $previous_monotonic_value = $now;
        $now = get_monotonic_time();

        adjust_monotonic_start_time([\$start_time, \$last_parent_check, \$got_sig_child], $now, $previous_monotonic_value);

        if ($opts->{'terminate_on_parent_sudden_death'}) {
          # check for parent once each five seconds
          if ($now > $last_parent_check + 5) {
            if (getppid() eq "1") {
              kill_gently ($pid, {
                'first_kill_type' => 'process_group',
                'final_kill_type' => 'process_group',
                'wait_time' => $opts->{'terminate_wait_time'}
                });
              $parent_died = 1;
            }

            $last_parent_check = $now;
          }
        }

        # user specified timeout
        if ($opts->{'timeout'}) {
          if ($now > $start_time + $opts->{'timeout'}) {
            kill_gently ($pid, {
              'first_kill_type' => 'process_group',
              'final_kill_type' => 'process_group',
              'wait_time' => $opts->{'terminate_wait_time'}
              });
            $child_timedout = 1;
          }
        }

        # give OS 10 seconds for correct return of waitpid,
        # kill process after that and finish wait loop;
        # shouldn't ever happen -- remove this code?
        if ($got_sig_child) {
          if ($now > $got_sig_child + 10) {
            print STDERR "waitpid did not return -1 for 10 seconds after SIG_CHLD, killing [$pid]\n";
            kill (-9, $pid);
            $child_finished = 1;
          }
        }

        if ($got_sig_quit) {
          kill_gently ($pid, {
            'first_kill_type' => 'process_group',
            'final_kill_type' => 'process_group',
            'wait_time' => $opts->{'terminate_wait_time'}
            });
          $child_finished = 1;
        }

        my $waitpid = waitpid($pid, POSIX::WNOHANG);

        # child finished, catch it's exit status
        if ($waitpid ne 0 && $waitpid ne -1) {
          $child_exit_code = $? >> 8;
        }

        if ($waitpid eq -1) {
          $child_finished = 1;
        }

        my $ready_fds = [];
        push @{$ready_fds}, $select->can_read(1/100);

        READY_FDS: while (scalar(@{$ready_fds})) {
          my $fd = shift @{$ready_fds};
          $ready_fds = [grep {$_ ne $fd} @{$ready_fds}];

          my $str = $child_output->{$fd->fileno};
          Carp::confess("child stream not found: $fd") unless $str;

          my $data = "";
          my $count = $fd->sysread($data, $str->{'block_size'});

          if ($count) {
              # extract all the available lines and store the rest in temporary buffer
              if ($data =~ /(.+\n)([^\n]*)/so) {
                  $data = $str->{'scalar_buffer'} . $1;
                  $str->{'scalar_buffer'} = $2 || "";
              }
              else {
                  $str->{'scalar_buffer'} .= $data;
                  $data = "";
              }
          }
          elsif ($count eq 0) {
            $select->remove($fd);
            $fd->close();
            if ($str->{'scalar_buffer'}) {
                $data = $str->{'scalar_buffer'} . "\n";
            }
          }
          else {
            Carp::confess("error during sysread on [$fd]: " . $!);
          }

          # $data contains only full lines (or last line if it was unfinished read
          # or now new-line in the output of the child); dat is processed
          # according to the "protocol" of socket
          if ($str->{'protocol'} eq 'info') {
            if ($data =~ /^spawned ([0-9]+?)\n(.*?)/so) {
              $child_child_pid = $1;
              $data = $2;
            }
            if ($data =~ /^reaped ([0-9]+?)\n(.*?)/so) {
              $child_child_pid = undef;
              $data = $2;
            }
            if ($data =~ /^[\d]+ killed with ([0-9]+?)\n(.*?)/so) {
              $child_killed_by_signal = $1;
              $data = $2;
            }

            # we don't expect any other data in info socket, so it's
            # some strange violation of protocol, better know about this
            if ($data) {
              Carp::confess("info protocol violation: [$data]");
            }
          }
          if ($str->{'protocol'} eq 'stdout') {
            if (!$opts->{'discard_output'}) {
              $child_stdout .= $data;
              $child_merged .= $data;
            }

            if ($opts->{'stdout_handler'} && ref($opts->{'stdout_handler'}) eq 'CODE') {
              $opts->{'stdout_handler'}->($data);
            }
          }
          if ($str->{'protocol'} eq 'stderr') {
            if (!$opts->{'discard_output'}) {
              $child_stderr .= $data;
              $child_merged .= $data;
            }

            if ($opts->{'stderr_handler'} && ref($opts->{'stderr_handler'}) eq 'CODE') {
              $opts->{'stderr_handler'}->($data);
            }
          }
 
          # process may finish (waitpid returns -1) before
          # we've read all of its output because of buffering;
          # so try to read all the way it is possible to read
          # in such case - this shouldn't be too much (unless
          # the buffer size is HUGE -- should introduce
          # another counter in such case, maybe later)
          #
          push @{$ready_fds}, $select->can_read(1/100) if $child_finished;
        }

        Time::HiRes::usleep(1);
      }

      # $child_pid_pid is not defined in two cases:
      #  * when our child was killed before
      #    it had chance to tell us the pid
      #    of the child it spawned. we can do
      #    nothing in this case :(
      #  * our child successfully reaped its child,
      #    we have nothing left to do in this case
      #
      # defined $child_pid_pid means child's child
      # has not died but nobody is waiting for it,
      # killing it brutally.
      #
      if ($child_child_pid) {
        kill_gently($child_child_pid);
      }

      # in case there are forks in child which
      # do not forward or process signals (TERM) correctly
      # kill whole child process group, effectively trying
      # not to return with some children or their parts still running
      #
      # to be more accurate -- we need to be sure
      # that this is process group created by our child
      # (and not some other process group with the same pgid,
      # created just after death of our child) -- fortunately
      # this might happen only when process group ids
      # are reused quickly (there are lots of processes
      # spawning new process groups for example)
      #
      if ($opts->{'clean_up_children'}) {
        kill(-9, $pid);
      }

  #    print "child $pid finished\n";

      close($child_stdout_socket);
      close($child_stderr_socket);
      close($child_info_socket);

      my $o = {
        'stdout' => $child_stdout,
        'stderr' => $child_stderr,
        'merged' => $child_merged,
        'timeout' => $child_timedout ? $opts->{'timeout'} : 0,
        'exit_code' => $child_exit_code,
        'parent_died' => $parent_died,
        'killed_by_signal' => $child_killed_by_signal,
        'child_pgid' => $pid,
        'cmd' => $cmd,
        };

      my $err_msg = '';
      if ($o->{'exit_code'}) {
        $err_msg .= "exited with code [$o->{'exit_code'}]\n";
      }
      if ($o->{'timeout'}) {
        $err_msg .= "ran more than [$o->{'timeout'}] seconds\n";
      }
      if ($o->{'parent_died'}) {
        $err_msg .= "parent died\n";
      }
      if ($o->{'stdout'} && !$opts->{'non_empty_stdout_ok'}) {
        $err_msg .= "stdout:\n" . $o->{'stdout'} . "\n";
      }
      if ($o->{'stderr'}) {
        $err_msg .= "stderr:\n" . $o->{'stderr'} . "\n";
      }
      if ($o->{'killed_by_signal'}) {
        $err_msg .= "killed by signal [" . $o->{'killed_by_signal'} . "]\n";
      }
      $o->{'err_msg'} = $err_msg;

      if ($orig_sig_child) {
        $SIG{'CHLD'} = $orig_sig_child;
      }
      else {
        delete($SIG{'CHLD'});
      }

      return $o;
    }
    else {
      Carp::confess("cannot fork: $!") unless defined($pid);

      # create new process session for open3 call,
      # so we hopefully can kill all the subprocesses
      # which might be spawned in it (except for those
      # which do setsid theirselves -- can't do anything
      # with those)

      POSIX::setsid() || Carp::confess("Error running setsid: " . $!);

      if ($opts->{'child_BEGIN'} && ref($opts->{'child_BEGIN'}) eq 'CODE') {
        $opts->{'child_BEGIN'}->();
      }

      close($child_stdout_socket);
      close($child_stderr_socket);
      close($child_info_socket);

      my $child_exit_code;

      # allow both external programs
      # and internal perl calls
      if (!ref($cmd)) {
        $child_exit_code = open3_run($cmd, {
          'parent_info' => $parent_info_socket,
          'parent_stdout' => $parent_stdout_socket,
          'parent_stderr' => $parent_stderr_socket,
          'child_stdin' => $opts->{'child_stdin'},
          });
      }
      elsif (ref($cmd) eq 'CODE') {
        # reopen STDOUT and STDERR for child code:
        # https://rt.cpan.org/Ticket/Display.html?id=85912
        open STDOUT, '>&', $parent_stdout_socket || Carp::confess("Unable to reopen STDOUT: $!\n");
        open STDERR, '>&', $parent_stderr_socket || Carp::confess("Unable to reopen STDERR: $!\n");

        $child_exit_code = $cmd->({
          'opts' => $opts,
          'parent_info' => $parent_info_socket,
          'parent_stdout' => $parent_stdout_socket,
          'parent_stderr' => $parent_stderr_socket,
          'child_stdin' => $opts->{'child_stdin'},
          });
      }
      else {
        print $parent_stderr_socket "Invalid command reference: " . ref($cmd) . "\n";
        $child_exit_code = 1;
      }

      close($parent_stdout_socket);
      close($parent_stderr_socket);
      close($parent_info_socket);

      if ($opts->{'child_END'} && ref($opts->{'child_END'}) eq 'CODE') {
        $opts->{'child_END'}->();
      }

      $| = 1;
      POSIX::_exit $child_exit_code;
    }
}

sub run {
    ### container to store things in
    my $self = bless {}, __PACKAGE__;

    my %hash = @_;

    ### if the user didn't provide a buffer, we'll store it here.
    my $def_buf = '';

    my($verbose,$cmd,$buffer,$timeout);
    my $tmpl = {
        verbose => { default  => $VERBOSE,  store => \$verbose },
        buffer  => { default  => \$def_buf, store => \$buffer },
        command => { required => 1,         store => \$cmd,
                     allow    => sub { !ref($_[0]) or ref($_[0]) eq 'ARRAY' },
        },
        timeout => { default  => 0,         store => \$timeout },
    };

    unless( check( $tmpl, \%hash, $VERBOSE ) ) {
        Carp::carp( loc( "Could not validate input: %1",
                         Params::Check->last_error ) );
        return;
    };

    $cmd = _quote_args_vms( $cmd ) if IS_VMS;

    ### strip any empty elements from $cmd if present
    if ( $ALLOW_NULL_ARGS ) {
      $cmd = [ grep { defined } @$cmd ] if ref $cmd;
    }
    else {
      $cmd = [ grep { defined && length } @$cmd ] if ref $cmd;
    }

    my $pp_cmd = (ref $cmd ? "@$cmd" : $cmd);
    print loc("Running [%1]...\n", $pp_cmd ) if $verbose;

    ### did the user pass us a buffer to fill or not? if so, set this
    ### flag so we know what is expected of us
    ### XXX this is now being ignored. in the future, we could add diagnostic
    ### messages based on this logic
    #my $user_provided_buffer = $buffer == \$def_buf ? 0 : 1;

    ### buffers that are to be captured
    my( @buffer, @buff_err, @buff_out );

    ### capture STDOUT
    my $_out_handler = sub {
        my $buf = shift;
        return unless defined $buf;

        print STDOUT $buf if $verbose;
        push @buffer,   $buf;
        push @buff_out, $buf;
    };

    ### capture STDERR
    my $_err_handler = sub {
        my $buf = shift;
        return unless defined $buf;

        print STDERR $buf if $verbose;
        push @buffer,   $buf;
        push @buff_err, $buf;
    };


    ### flag to indicate we have a buffer captured
    my $have_buffer = $self->can_capture_buffer ? 1 : 0;

    ### flag indicating if the subcall went ok
    my $ok;

    ### don't look at previous errors:
    local $?;
    local $@;
    local $!;

    ### we might be having a timeout set
    eval {
        local $SIG{ALRM} = sub { die bless sub {
            ALARM_CLASS .
            qq[: Command '$pp_cmd' aborted by alarm after $timeout seconds]
        }, ALARM_CLASS } if $timeout;
        alarm $timeout || 0;

        ### IPC::Run is first choice if $USE_IPC_RUN is set.
        if( !IS_WIN32 and $USE_IPC_RUN and $self->can_use_ipc_run( 1 ) ) {
            ### ipc::run handlers needs the command as a string or an array ref

            $self->_debug( "# Using IPC::Run. Have buffer: $have_buffer" )
                if $DEBUG;

            $ok = $self->_ipc_run( $cmd, $_out_handler, $_err_handler );

        ### since IPC::Open3 works on all platforms, and just fails on
        ### win32 for capturing buffers, do that ideally
        } elsif ( $USE_IPC_OPEN3 and $self->can_use_ipc_open3( 1 ) ) {

            $self->_debug("# Using IPC::Open3. Have buffer: $have_buffer")
                if $DEBUG;

            ### in case there are pipes in there;
            ### IPC::Open3 will call exec and exec will do the right thing

            my $method = IS_WIN32 ? '_open3_run_win32' : '_open3_run';

            $ok = $self->$method(
                                    $cmd, $_out_handler, $_err_handler, $verbose
                                );

        ### if we are allowed to run verbose, just dispatch the system command
        } else {
            $self->_debug( "# Using system(). Have buffer: $have_buffer" )
                if $DEBUG;
            $ok = $self->_system_run( $cmd, $verbose );
        }

        alarm 0;
    };

    ### restore STDIN after duping, or STDIN will be closed for
    ### this current perl process!
    $self->__reopen_fds( @{ $self->_fds} ) if $self->_fds;

    my $err;
    unless( $ok ) {
        ### alarm happened
        if ( $@ and ref $@ and $@->isa( ALARM_CLASS ) ) {
            $err = $@->();  # the error code is an expired alarm

        ### another error happened, set by the dispatchub
        } else {
            $err = $self->error;
        }
    }

    ### fill the buffer;
    $$buffer = join '', @buffer if @buffer;

    ### return a list of flags and buffers (if available) in list
    ### context, or just a simple 'ok' in scalar
    return wantarray
                ? $have_buffer
                    ? ($ok, $err, \@buffer, \@buff_out, \@buff_err)
                    : ($ok, $err )
                : $ok


}

sub _open3_run_win32 {
  my $self    = shift;
  my $cmd     = shift;
  my $outhand = shift;
  my $errhand = shift;

  require Socket;

  my $pipe = sub {
    socketpair($_[0], $_[1], &Socket::AF_UNIX, &Socket::SOCK_STREAM, &Socket::PF_UNSPEC)
        or return undef;
    shutdown($_[0], 1);  # No more writing for reader
    shutdown($_[1], 0);  # No more reading for writer
    return 1;
  };

  my $open3 = sub {
    local (*TO_CHLD_R,     *TO_CHLD_W);
    local (*FR_CHLD_R,     *FR_CHLD_W);
    local (*FR_CHLD_ERR_R, *FR_CHLD_ERR_W);

    $pipe->(*TO_CHLD_R,     *TO_CHLD_W    ) or die $^E;
    $pipe->(*FR_CHLD_R,     *FR_CHLD_W    ) or die $^E;
    $pipe->(*FR_CHLD_ERR_R, *FR_CHLD_ERR_W) or die $^E;

    my $pid = IPC::Open3::open3('>&TO_CHLD_R', '<&FR_CHLD_W', '<&FR_CHLD_ERR_W', @_);

    return ( $pid, *TO_CHLD_W, *FR_CHLD_R, *FR_CHLD_ERR_R );
  };

  $cmd = [ grep { defined && length } @$cmd ] if ref $cmd;
  $cmd = $self->__fix_cmd_whitespace_and_special_chars( $cmd );

  my ($pid, $to_chld, $fr_chld, $fr_chld_err) =
    $open3->( ( ref $cmd ? @$cmd : $cmd ) );

  my $in_sel  = IO::Select->new();
  my $out_sel = IO::Select->new();

  my %objs;

  $objs{ fileno( $fr_chld ) } = $outhand;
  $objs{ fileno( $fr_chld_err ) } = $errhand;
  $in_sel->add( $fr_chld );
  $in_sel->add( $fr_chld_err );

  close($to_chld);

  while ($in_sel->count() + $out_sel->count()) {
    my ($ins, $outs) = IO::Select::select($in_sel, $out_sel, undef);

    for my $fh (@$ins) {
        my $obj = $objs{ fileno($fh) };
        my $buf;
        my $bytes_read = sysread($fh, $buf, 64*1024 ); #, length($buf));
        if (!$bytes_read) {
            $in_sel->remove($fh);
        }
        else {
            $obj->( "$buf" );
        }
      }

      for my $fh (@$outs) {
      }
  }

  waitpid($pid, 0);

  ### some error occurred
  if( $? ) {
        $self->error( $self->_pp_child_error( $cmd, $? ) );
        $self->ok( 0 );
        return;
  } else {
        return $self->ok( 1 );
  }
}

sub _open3_run {
    my $self            = shift;
    my $cmd             = shift;
    my $_out_handler    = shift;
    my $_err_handler    = shift;
    my $verbose         = shift || 0;

    ### Following code are adapted from Friar 'abstracts' in the
    ### Perl Monastery (http://www.perlmonks.org/index.pl?node_id=151886).
    ### XXX that code didn't work.
    ### we now use the following code, thanks to theorbtwo

    ### define them beforehand, so we always have defined FH's
    ### to read from.
    use Symbol;
    my $kidout      = Symbol::gensym();
    my $kiderror    = Symbol::gensym();

    ### Dup the filehandle so we can pass 'our' STDIN to the
    ### child process. This stops us from having to pump input
    ### from ourselves to the childprocess. However, we will need
    ### to revive the FH afterwards, as IPC::Open3 closes it.
    ### We'll do the same for STDOUT and STDERR. It works without
    ### duping them on non-unix derivatives, but not on win32.
    my @fds_to_dup = ( IS_WIN32 && !$verbose
                            ? qw[STDIN STDOUT STDERR]
                            : qw[STDIN]
                        );
    $self->_fds( \@fds_to_dup );
    $self->__dup_fds( @fds_to_dup );

    ### pipes have to come in a quoted string, and that clashes with
    ### whitespace. This sub fixes up such commands so they run properly
    $cmd = $self->__fix_cmd_whitespace_and_special_chars( $cmd );

    ### don't stringify @$cmd, so spaces in filenames/paths are
    ### treated properly
    my $pid = eval {
        IPC::Open3::open3(
                    '<&STDIN',
                    (IS_WIN32 ? '>&STDOUT' : $kidout),
                    (IS_WIN32 ? '>&STDERR' : $kiderror),
                    ( ref $cmd ? @$cmd : $cmd ),
                );
    };

    ### open3 error occurred
    if( $@ and $@ =~ /^open3:/ ) {
        $self->ok( 0 );
        $self->error( $@ );
        return;
    };

    ### use OUR stdin, not $kidin. Somehow,
    ### we never get the input.. so jump through
    ### some hoops to do it :(
    my $selector = IO::Select->new(
                        (IS_WIN32 ? \*STDERR : $kiderror),
                        \*STDIN,
                        (IS_WIN32 ? \*STDOUT : $kidout)
                    );

    STDOUT->autoflush(1);   STDERR->autoflush(1);   STDIN->autoflush(1);
    $kidout->autoflush(1)   if UNIVERSAL::can($kidout,   'autoflush');
    $kiderror->autoflush(1) if UNIVERSAL::can($kiderror, 'autoflush');

    ### add an explicit break statement
    ### code courtesy of theorbtwo from #london.pm
    my $stdout_done = 0;
    my $stderr_done = 0;
    OUTER: while ( my @ready = $selector->can_read ) {

        for my $h ( @ready ) {
            my $buf;

            ### $len is the amount of bytes read
            my $len = sysread( $h, $buf, 4096 );    # try to read 4096 bytes

            ### see perldoc -f sysread: it returns undef on error,
            ### so bail out.
            if( not defined $len ) {
                warn(loc("Error reading from process: %1", $!));
                last OUTER;
            }

            ### check for $len. it may be 0, at which point we're
            ### done reading, so don't try to process it.
            ### if we would print anyway, we'd provide bogus information
            $_out_handler->( "$buf" ) if $len && $h == $kidout;
            $_err_handler->( "$buf" ) if $len && $h == $kiderror;

            ### Wait till child process is done printing to both
            ### stdout and stderr.
            $stdout_done = 1 if $h == $kidout   and $len == 0;
            $stderr_done = 1 if $h == $kiderror and $len == 0;
            last OUTER if ($stdout_done && $stderr_done);
        }
    }

    waitpid $pid, 0; # wait for it to die

    ### restore STDIN after duping, or STDIN will be closed for
    ### this current perl process!
    ### done in the parent call now
    # $self->__reopen_fds( @fds_to_dup );

    ### some error occurred
    if( $? ) {
        $self->error( $self->_pp_child_error( $cmd, $? ) );
        $self->ok( 0 );
        return;
    } else {
        return $self->ok( 1 );
    }
}

### Text::ParseWords::shellwords() uses unix semantics. that will break
### on win32
{   my $parse_sub = IS_WIN32
                        ? __PACKAGE__->can('_split_like_shell_win32')
                        : Text::ParseWords->can('shellwords');

    sub _ipc_run {
        my $self            = shift;
        my $cmd             = shift;
        my $_out_handler    = shift;
        my $_err_handler    = shift;

        STDOUT->autoflush(1); STDERR->autoflush(1);

        ### a command like:
        # [
        #     '/usr/bin/gzip',
        #     '-cdf',
        #     '/Users/kane/sources/p4/other/archive-extract/t/src/x.tgz',
        #     '|',
        #     '/usr/bin/tar',
        #     '-tf -'
        # ]
        ### needs to become:
        # [
        #     ['/usr/bin/gzip', '-cdf',
        #       '/Users/kane/sources/p4/other/archive-extract/t/src/x.tgz']
        #     '|',
        #     ['/usr/bin/tar', '-tf -']
        # ]


        my @command;
        my $special_chars;

        my $re = do { my $x = join '', SPECIAL_CHARS; qr/([$x])/ };
        if( ref $cmd ) {
            my $aref = [];
            for my $item (@$cmd) {
                if( $item =~ $re ) {
                    push @command, $aref, $item;
                    $aref = [];
                    $special_chars .= $1;
                } else {
                    push @$aref, $item;
                }
            }
            push @command, $aref;
        } else {
            @command = map { if( $_ =~ $re ) {
                                $special_chars .= $1; $_;
                             } else {
#                                [ split /\s+/ ]
                                 [ map { m/[ ]/ ? qq{'$_'} : $_ } $parse_sub->($_) ]
                             }
                        } split( /\s*$re\s*/, $cmd );
        }

        ### if there's a pipe in the command, *STDIN needs to
        ### be inserted *BEFORE* the pipe, to work on win32
        ### this also works on *nix, so we should do it when possible
        ### this should *also* work on multiple pipes in the command
        ### if there's no pipe in the command, append STDIN to the back
        ### of the command instead.
        ### XXX seems IPC::Run works it out for itself if you just
        ### don't pass STDIN at all.
        #     if( $special_chars and $special_chars =~ /\|/ ) {
        #         ### only add STDIN the first time..
        #         my $i;
        #         @command = map { ($_ eq '|' && not $i++)
        #                             ? ( \*STDIN, $_ )
        #                             : $_
        #                         } @command;
        #     } else {
        #         push @command, \*STDIN;
        #     }

        # \*STDIN is already included in the @command, see a few lines up
        my $ok = eval { IPC::Run::run(   @command,
                                fileno(STDOUT).'>',
                                $_out_handler,
                                fileno(STDERR).'>',
                                $_err_handler
                            )
                        };

        ### all is well
        if( $ok ) {
            return $self->ok( $ok );

        ### some error occurred
        } else {
            $self->ok( 0 );

            ### if the eval fails due to an exception, deal with it
            ### unless it's an alarm
            if( $@ and not UNIVERSAL::isa( $@, ALARM_CLASS ) ) {
                $self->error( $@ );

            ### if it *is* an alarm, propagate
            } elsif( $@ ) {
                die $@;

            ### some error in the sub command
            } else {
                $self->error( $self->_pp_child_error( $cmd, $? ) );
            }

            return;
        }
    }
}

sub _system_run {
    my $self    = shift;
    my $cmd     = shift;
    my $verbose = shift || 0;

    ### pipes have to come in a quoted string, and that clashes with
    ### whitespace. This sub fixes up such commands so they run properly
    $cmd = $self->__fix_cmd_whitespace_and_special_chars( $cmd );

    my @fds_to_dup = $verbose ? () : qw[STDOUT STDERR];
    $self->_fds( \@fds_to_dup );
    $self->__dup_fds( @fds_to_dup );

    ### system returns 'true' on failure -- the exit code of the cmd
    $self->ok( 1 );
    system( ref $cmd ? @$cmd : $cmd ) == 0 or do {
        $self->error( $self->_pp_child_error( $cmd, $? ) );
        $self->ok( 0 );
    };

    ### done in the parent call now
    #$self->__reopen_fds( @fds_to_dup );

    return unless $self->ok;
    return $self->ok;
}

{   my %sc_lookup = map { $_ => $_ } SPECIAL_CHARS;


    sub __fix_cmd_whitespace_and_special_chars {
        my $self = shift;
        my $cmd  = shift;

        ### command has a special char in it
        if( ref $cmd and grep { $sc_lookup{$_} } @$cmd ) {

            ### since we have special chars, we have to quote white space
            ### this *may* conflict with the parsing :(
            my $fixed;
            my @cmd = map { / / ? do { $fixed++; QUOTE.$_.QUOTE } : $_ } @$cmd;

            $self->_debug( "# Quoted $fixed arguments containing whitespace" )
                    if $DEBUG && $fixed;

            ### stringify it, so the special char isn't escaped as argument
            ### to the program
            $cmd = join ' ', @cmd;
        }

        return $cmd;
    }
}

### Command-line arguments (but not the command itself) must be quoted
### to ensure case preservation. Borrowed from Module::Build with adaptations.
### Patch for this supplied by Craig Berry, see RT #46288: [PATCH] Add argument
### quoting for run() on VMS
sub _quote_args_vms {
  ### Returns a command string with proper quoting so that the subprocess
  ### sees this same list of args, or if we get a single arg that is an
  ### array reference, quote the elements of it (except for the first)
  ### and return the reference.
  my @args = @_;
  my $got_arrayref = (scalar(@args) == 1
                      && UNIVERSAL::isa($args[0], 'ARRAY'))
                   ? 1
                   : 0;

  @args = split(/\s+/, $args[0]) unless $got_arrayref || scalar(@args) > 1;

  my $cmd = $got_arrayref ? shift @{$args[0]} : shift @args;

  ### Do not quote qualifiers that begin with '/' or previously quoted args.
  map { if (/^[^\/\"]/) {
          $_ =~ s/\"/""/g;     # escape C<"> by doubling
          $_ = q(").$_.q(");
        }
  }
    ($got_arrayref ? @{$args[0]}
                   : @args
    );

  $got_arrayref ? unshift(@{$args[0]}, $cmd) : unshift(@args, $cmd);

  return $got_arrayref ? $args[0]
                       : join(' ', @args);
}


### XXX this is cribbed STRAIGHT from M::B 0.30 here:
### http://search.cpan.org/src/KWILLIAMS/Module-Build-0.30/lib/Module/Build/Platform/Windows.pm:split_like_shell
### XXX this *should* be integrated into text::parsewords
sub _split_like_shell_win32 {
  # As it turns out, Windows command-parsing is very different from
  # Unix command-parsing.  Double-quotes mean different things,
  # backslashes don't necessarily mean escapes, and so on.  So we
  # can't use Text::ParseWords::shellwords() to break a command string
  # into words.  The algorithm below was bashed out by Randy and Ken
  # (mostly Randy), and there are a lot of regression tests, so we
  # should feel free to adjust if desired.

  local $_ = shift;

  my @argv;
  return @argv unless defined() && length();

  my $arg = '';
  my( $i, $quote_mode ) = ( 0, 0 );

  while ( $i < length() ) {

    my $ch      = substr( $_, $i  , 1 );
    my $next_ch = substr( $_, $i+1, 1 );

    if ( $ch eq '\\' && $next_ch eq '"' ) {
      $arg .= '"';
      $i++;
    } elsif ( $ch eq '\\' && $next_ch eq '\\' ) {
      $arg .= '\\';
      $i++;
    } elsif ( $ch eq '"' && $next_ch eq '"' && $quote_mode ) {
      $quote_mode = !$quote_mode;
      $arg .= '"';
      $i++;
    } elsif ( $ch eq '"' && $next_ch eq '"' && !$quote_mode &&
          ( $i + 2 == length()  ||
        substr( $_, $i + 2, 1 ) eq ' ' )
        ) { # for cases like: a"" => [ 'a' ]
      push( @argv, $arg );
      $arg = '';
      $i += 2;
    } elsif ( $ch eq '"' ) {
      $quote_mode = !$quote_mode;
    } elsif ( $ch eq ' ' && !$quote_mode ) {
      push( @argv, $arg ) if defined( $arg ) && length( $arg );
      $arg = '';
      ++$i while substr( $_, $i + 1, 1 ) eq ' ';
    } else {
      $arg .= $ch;
    }

    $i++;
  }

  push( @argv, $arg ) if defined( $arg ) && length( $arg );
  return @argv;
}



{   use File::Spec;
    use Symbol;

    my %Map = (
        STDOUT => [qw|>&|, \*STDOUT, Symbol::gensym() ],
        STDERR => [qw|>&|, \*STDERR, Symbol::gensym() ],
        STDIN  => [qw|<&|, \*STDIN,  Symbol::gensym() ],
    );

    ### dups FDs and stores them in a cache
    sub __dup_fds {
        my $self    = shift;
        my @fds     = @_;

        __PACKAGE__->_debug( "# Closing the following fds: @fds" ) if $DEBUG;

        for my $name ( @fds ) {
            my($redir, $fh, $glob) = @{$Map{$name}} or (
                Carp::carp(loc("No such FD: '%1'", $name)), next );

            ### MUST use the 2-arg version of open for dup'ing for
            ### 5.6.x compatibility. 5.8.x can use 3-arg open
            ### see perldoc5.6.2 -f open for details
            open $glob, $redir . fileno($fh) or (
                        Carp::carp(loc("Could not dup '$name': %1", $!)),
                        return
                    );

            ### we should re-open this filehandle right now, not
            ### just dup it
            ### Use 2-arg version of open, as 5.5.x doesn't support
            ### 3-arg version =/
            if( $redir eq '>&' ) {
                open( $fh, '>' . File::Spec->devnull ) or (
                    Carp::carp(loc("Could not reopen '$name': %1", $!)),
                    return
                );
            }
        }

        return 1;
    }

    ### reopens FDs from the cache
    sub __reopen_fds {
        my $self    = shift;
        my @fds     = @_;

        __PACKAGE__->_debug( "# Reopening the following fds: @fds" ) if $DEBUG;

        for my $name ( @fds ) {
            my($redir, $fh, $glob) = @{$Map{$name}} or (
                Carp::carp(loc("No such FD: '%1'", $name)), next );

            ### MUST use the 2-arg version of open for dup'ing for
            ### 5.6.x compatibility. 5.8.x can use 3-arg open
            ### see perldoc5.6.2 -f open for details
            open( $fh, $redir . fileno($glob) ) or (
                    Carp::carp(loc("Could not restore '$name': %1", $!)),
                    return
                );

            ### close this FD, we're not using it anymore
            close $glob;
        }
        return 1;

    }
}

sub _debug {
    my $self    = shift;
    my $msg     = shift or return;
    my $level   = shift || 0;

    local $Carp::CarpLevel += $level;
    Carp::carp($msg);

    return 1;
}

sub _pp_child_error {
    my $self    = shift;
    my $cmd     = shift or return;
    my $ce      = shift or return;
    my $pp_cmd  = ref $cmd ? "@$cmd" : $cmd;


    my $str;
    if( $ce == -1 ) {
        ### Include $! in the error message, so that the user can
        ### see 'No such file or directory' versus 'Permission denied'
        ### versus 'Cannot fork' or whatever the cause was.
        $str = "Failed to execute '$pp_cmd': $!";

    } elsif ( $ce & 127 ) {
        ### some signal
        $str = loc( "'%1' died with signal %2, %3 coredump",
               $pp_cmd, ($ce & 127), ($ce & 128) ? 'with' : 'without');

    } else {
        ### Otherwise, the command run but gave error status.
        $str = "'$pp_cmd' exited with value " . ($ce >> 8);
    }

    $self->_debug( "# Child error '$ce' translated to: $str" ) if $DEBUG;

    return $str;
}

1;

=head2 $q = QUOTE

Returns the character used for quoting strings on this platform. This is
usually a C<'> (single quote) on most systems, but some systems use different
quotes. For example, C<Win32> uses C<"> (double quote).

You can use it as follows:

  use IPC::Cmd qw[run QUOTE];
  my $cmd = q[echo ] . QUOTE . q[foo bar] . QUOTE;

This makes sure that C<foo bar> is treated as a string, rather than two
separate arguments to the C<echo> function.

__END__

=head1 HOW IT WORKS

C<run> will try to execute your command using the following logic:

=over 4

=item *

If you have C<IPC::Run> installed, and the variable C<$IPC::Cmd::USE_IPC_RUN>
is set to true (See the L<"Global Variables"> section) use that to execute
the command. You will have the full output available in buffers, interactive commands
are sure to work  and you are guaranteed to have your verbosity
settings honored cleanly.

=item *

Otherwise, if the variable C<$IPC::Cmd::USE_IPC_OPEN3> is set to true
(See the L<"Global Variables"> section), try to execute the command using
L<IPC::Open3>. Buffers will be available on all platforms,
interactive commands will still execute cleanly, and also your verbosity
settings will be adhered to nicely;

=item *

Otherwise, if you have the C<verbose> argument set to true, we fall back
to a simple C<system()> call. We cannot capture any buffers, but
interactive commands will still work.

=item *

Otherwise we will try and temporarily redirect STDERR and STDOUT, do a
C<system()> call with your command and then re-open STDERR and STDOUT.
This is the method of last resort and will still allow you to execute
your commands cleanly. However, no buffers will be available.

=back

=head1 Global Variables

The behaviour of IPC::Cmd can be altered by changing the following
global variables:

=head2 $IPC::Cmd::VERBOSE

This controls whether IPC::Cmd will print any output from the
commands to the screen or not. The default is 0.

=head2 $IPC::Cmd::USE_IPC_RUN

This variable controls whether IPC::Cmd will try to use L<IPC::Run>
when available and suitable.

=head2 $IPC::Cmd::USE_IPC_OPEN3

This variable controls whether IPC::Cmd will try to use L<IPC::Open3>
when available and suitable. Defaults to true.

=head2 $IPC::Cmd::WARN

This variable controls whether run-time warnings should be issued, like
the failure to load an C<IPC::*> module you explicitly requested.

Defaults to true. Turn this off at your own risk.

=head2 $IPC::Cmd::INSTANCES

This variable controls whether C<can_run> will return all instances of
the binary it finds in the C<PATH> when called in a list context.

Defaults to false, set to true to enable the described behaviour.

=head2 $IPC::Cmd::ALLOW_NULL_ARGS

This variable controls whether C<run> will remove any empty/null arguments
it finds in command arguments.

Defaults to false, so it will remove null arguments. Set to true to allow
them.

=head1 Caveats

=over 4

=item Whitespace and IPC::Open3 / system()

When using C<IPC::Open3> or C<system>, if you provide a string as the
C<command> argument, it is assumed to be appropriately escaped. You can
use the C<QUOTE> constant to use as a portable quote character (see above).
However, if you provide an array reference, special rules apply:

If your command contains B<special characters> (< > | &), it will
be internally stringified before executing the command, to avoid that these
special characters are escaped and passed as arguments instead of retaining
their special meaning.

However, if the command contained arguments that contained whitespace,
stringifying the command would lose the significance of the whitespace.
Therefore, C<IPC::Cmd> will quote any arguments containing whitespace in your
command if the command is passed as an arrayref and contains special characters.

=item Whitespace and IPC::Run

When using C<IPC::Run>, if you provide a string as the C<command> argument,
the string will be split on whitespace to determine the individual elements
of your command. Although this will usually just Do What You Mean, it may
break if you have files or commands with whitespace in them.

If you do not wish this to happen, you should provide an array
reference, where all parts of your command are already separated out.
Note however, if there are extra or spurious whitespaces in these parts,
the parser or underlying code may not interpret it correctly, and
cause an error.

Example:
The following code

    gzip -cdf foo.tar.gz | tar -xf -

should either be passed as

    "gzip -cdf foo.tar.gz | tar -xf -"

or as

    ['gzip', '-cdf', 'foo.tar.gz', '|', 'tar', '-xf', '-']

But take care not to pass it as, for example

    ['gzip -cdf foo.tar.gz', '|', 'tar -xf -']

Since this will lead to issues as described above.


=item IO Redirect

Currently it is too complicated to parse your command for IO
redirections. For capturing STDOUT or STDERR there is a work around
however, since you can just inspect your buffers for the contents.

=item Interleaving STDOUT/STDERR

Neither IPC::Run nor IPC::Open3 can interleave STDOUT and STDERR. For short
bursts of output from a program, e.g. this sample,

    for ( 1..4 ) {
        $_ % 2 ? print STDOUT $_ : print STDERR $_;
    }

IPC::[Run|Open3] will first read all of STDOUT, then all of STDERR, meaning
the output looks like '13' on STDOUT and '24' on STDERR, instead of

    1
    2
    3
    4

This has been recorded in L<rt.cpan.org> as bug #37532: Unable to interleave
STDOUT and STDERR.

=back

=head1 See Also

L<IPC::Run>, L<IPC::Open3>

=head1 ACKNOWLEDGEMENTS

Thanks to James Mastros and Martijn van der Streek for their
help in getting L<IPC::Open3> to behave nicely.

Thanks to Petya Kohts for the C<run_forked> code.

=head1 BUG REPORTS

Please report bugs or other issues to E<lt>bug-ipc-cmd@rt.cpan.orgE<gt>.

=head1 AUTHOR

Original author: Jos Boumans E<lt>kane@cpan.orgE<gt>.
Current maintainer: Chris Williams E<lt>bingos@cpan.orgE<gt>.

=head1 COPYRIGHT

This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.

=cut
                                                                                                         usr/share/perl/5.20.2/JSON/                                                                         0040755 0000000 0000000 00000000000 13077704254 013433  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/JSON/PP/                                                                      0040755 0000000 0000000 00000000000 13077704254 013752  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/JSON/PP/Boolean.pm                                                            0100644 0000000 0000000 00000000651 12744441327 015665  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =head1 NAME

JSON::PP::Boolean - dummy module providing JSON::PP::Boolean

=head1 SYNOPSIS

 # do not "use" yourself

=head1 DESCRIPTION

This module exists only to provide overload resolution for Storable and similar modules. See
L<JSON::PP> for more info about this class.

=cut

use JSON::PP ();
use strict;

1;

=head1 AUTHOR

This idea is from L<JSON::XS::Boolean> written by Marc Lehmann <schmorp[at]schmorp.de>

=cut

                                                                                       usr/share/perl/5.20.2/JSON/PP.pm                                                                    0100644 0000000 0000000 00000240115 12744441327 014307  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package JSON::PP;

# JSON-2.0

use 5.005;
use strict;
use base qw(Exporter);
use overload ();

use Carp ();
use B ();
#use Devel::Peek;

$JSON::PP::VERSION = '2.27203';

@JSON::PP::EXPORT = qw(encode_json decode_json from_json to_json);

# instead of hash-access, i tried index-access for speed.
# but this method is not faster than what i expected. so it will be changed.

use constant P_ASCII                => 0;
use constant P_LATIN1               => 1;
use constant P_UTF8                 => 2;
use constant P_INDENT               => 3;
use constant P_CANONICAL            => 4;
use constant P_SPACE_BEFORE         => 5;
use constant P_SPACE_AFTER          => 6;
use constant P_ALLOW_NONREF         => 7;
use constant P_SHRINK               => 8;
use constant P_ALLOW_BLESSED        => 9;
use constant P_CONVERT_BLESSED      => 10;
use constant P_RELAXED              => 11;

use constant P_LOOSE                => 12;
use constant P_ALLOW_BIGNUM         => 13;
use constant P_ALLOW_BAREKEY        => 14;
use constant P_ALLOW_SINGLEQUOTE    => 15;
use constant P_ESCAPE_SLASH         => 16;
use constant P_AS_NONBLESSED        => 17;

use constant P_ALLOW_UNKNOWN        => 18;

use constant OLD_PERL => $] < 5.008 ? 1 : 0;

BEGIN {
    my @xs_compati_bit_properties = qw(
            latin1 ascii utf8 indent canonical space_before space_after allow_nonref shrink
            allow_blessed convert_blessed relaxed allow_unknown
    );
    my @pp_bit_properties = qw(
            allow_singlequote allow_bignum loose
            allow_barekey escape_slash as_nonblessed
    );

    # Perl version check, Unicode handling is enable?
    # Helper module sets @JSON::PP::_properties.
    if ($] < 5.008 ) {
        my $helper = $] >= 5.006 ? 'JSON::PP::Compat5006' : 'JSON::PP::Compat5005';
        eval qq| require $helper |;
        if ($@) { Carp::croak $@; }
    }

    for my $name (@xs_compati_bit_properties, @pp_bit_properties) {
        my $flag_name = 'P_' . uc($name);

        eval qq/
            sub $name {
                my \$enable = defined \$_[1] ? \$_[1] : 1;

                if (\$enable) {
                    \$_[0]->{PROPS}->[$flag_name] = 1;
                }
                else {
                    \$_[0]->{PROPS}->[$flag_name] = 0;
                }

                \$_[0];
            }

            sub get_$name {
                \$_[0]->{PROPS}->[$flag_name] ? 1 : '';
            }
        /;
    }

}



# Functions

my %encode_allow_method
     = map {($_ => 1)} qw/utf8 pretty allow_nonref latin1 self_encode escape_slash
                          allow_blessed convert_blessed indent indent_length allow_bignum
                          as_nonblessed
                        /;
my %decode_allow_method
     = map {($_ => 1)} qw/utf8 allow_nonref loose allow_singlequote allow_bignum
                          allow_barekey max_size relaxed/;


my $JSON; # cache

sub encode_json ($) { # encode
    ($JSON ||= __PACKAGE__->new->utf8)->encode(@_);
}


sub decode_json { # decode
    ($JSON ||= __PACKAGE__->new->utf8)->decode(@_);
}

# Obsoleted

sub to_json($) {
   Carp::croak ("JSON::PP::to_json has been renamed to encode_json.");
}


sub from_json($) {
   Carp::croak ("JSON::PP::from_json has been renamed to decode_json.");
}


# Methods

sub new {
    my $class = shift;
    my $self  = {
        max_depth   => 512,
        max_size    => 0,
        indent      => 0,
        FLAGS       => 0,
        fallback      => sub { encode_error('Invalid value. JSON can only reference.') },
        indent_length => 3,
    };

    bless $self, $class;
}


sub encode {
    return $_[0]->PP_encode_json($_[1]);
}


sub decode {
    return $_[0]->PP_decode_json($_[1], 0x00000000);
}


sub decode_prefix {
    return $_[0]->PP_decode_json($_[1], 0x00000001);
}


# accessor


# pretty printing

sub pretty {
    my ($self, $v) = @_;
    my $enable = defined $v ? $v : 1;

    if ($enable) { # indent_length(3) for JSON::XS compatibility
        $self->indent(1)->indent_length(3)->space_before(1)->space_after(1);
    }
    else {
        $self->indent(0)->space_before(0)->space_after(0);
    }

    $self;
}

# etc

sub max_depth {
    my $max  = defined $_[1] ? $_[1] : 0x80000000;
    $_[0]->{max_depth} = $max;
    $_[0];
}


sub get_max_depth { $_[0]->{max_depth}; }


sub max_size {
    my $max  = defined $_[1] ? $_[1] : 0;
    $_[0]->{max_size} = $max;
    $_[0];
}


sub get_max_size { $_[0]->{max_size}; }


sub filter_json_object {
    $_[0]->{cb_object} = defined $_[1] ? $_[1] : 0;
    $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
    $_[0];
}

sub filter_json_single_key_object {
    if (@_ > 1) {
        $_[0]->{cb_sk_object}->{$_[1]} = $_[2];
    }
    $_[0]->{F_HOOK} = ($_[0]->{cb_object} or $_[0]->{cb_sk_object}) ? 1 : 0;
    $_[0];
}

sub indent_length {
    if (!defined $_[1] or $_[1] > 15 or $_[1] < 0) {
        Carp::carp "The acceptable range of indent_length() is 0 to 15.";
    }
    else {
        $_[0]->{indent_length} = $_[1];
    }
    $_[0];
}

sub get_indent_length {
    $_[0]->{indent_length};
}

sub sort_by {
    $_[0]->{sort_by} = defined $_[1] ? $_[1] : 1;
    $_[0];
}

sub allow_bigint {
    Carp::carp("allow_bigint() is obsoleted. use allow_bignum() insted.");
}

###############################

###
### Perl => JSON
###


{ # Convert

    my $max_depth;
    my $indent;
    my $ascii;
    my $latin1;
    my $utf8;
    my $space_before;
    my $space_after;
    my $canonical;
    my $allow_blessed;
    my $convert_blessed;

    my $indent_length;
    my $escape_slash;
    my $bignum;
    my $as_nonblessed;

    my $depth;
    my $indent_count;
    my $keysort;


    sub PP_encode_json {
        my $self = shift;
        my $obj  = shift;

        $indent_count = 0;
        $depth        = 0;

        my $idx = $self->{PROPS};

        ($ascii, $latin1, $utf8, $indent, $canonical, $space_before, $space_after, $allow_blessed,
            $convert_blessed, $escape_slash, $bignum, $as_nonblessed)
         = @{$idx}[P_ASCII .. P_SPACE_AFTER, P_ALLOW_BLESSED, P_CONVERT_BLESSED,
                    P_ESCAPE_SLASH, P_ALLOW_BIGNUM, P_AS_NONBLESSED];

        ($max_depth, $indent_length) = @{$self}{qw/max_depth indent_length/};

        $keysort = $canonical ? sub { $a cmp $b } : undef;

        if ($self->{sort_by}) {
            $keysort = ref($self->{sort_by}) eq 'CODE' ? $self->{sort_by}
                     : $self->{sort_by} =~ /\D+/       ? $self->{sort_by}
                     : sub { $a cmp $b };
        }

        encode_error("hash- or arrayref expected (not a simple scalar, use allow_nonref to allow this)")
             if(!ref $obj and !$idx->[ P_ALLOW_NONREF ]);

        my $str  = $self->object_to_json($obj);

        $str .= "\n" if ( $indent ); # JSON::XS 2.26 compatible

        unless ($ascii or $latin1 or $utf8) {
            utf8::upgrade($str);
        }

        if ($idx->[ P_SHRINK ]) {
            utf8::downgrade($str, 1);
        }

        return $str;
    }


    sub object_to_json {
        my ($self, $obj) = @_;
        my $type = ref($obj);

        if($type eq 'HASH'){
            return $self->hash_to_json($obj);
        }
        elsif($type eq 'ARRAY'){
            return $self->array_to_json($obj);
        }
        elsif ($type) { # blessed object?
            if (blessed($obj)) {

                return $self->value_to_json($obj) if ( $obj->isa('JSON::PP::Boolean') );

                if ( $convert_blessed and $obj->can('TO_JSON') ) {
                    my $result = $obj->TO_JSON();
                    if ( defined $result and ref( $result ) ) {
                        if ( refaddr( $obj ) eq refaddr( $result ) ) {
                            encode_error( sprintf(
                                "%s::TO_JSON method returned same object as was passed instead of a new one",
                                ref $obj
                            ) );
                        }
                    }

                    return $self->object_to_json( $result );
                }

                return "$obj" if ( $bignum and _is_bignum($obj) );
                return $self->blessed_to_json($obj) if ($allow_blessed and $as_nonblessed); # will be removed.

                encode_error( sprintf("encountered object '%s', but neither allow_blessed "
                    . "nor convert_blessed settings are enabled", $obj)
                ) unless ($allow_blessed);

                return 'null';
            }
            else {
                return $self->value_to_json($obj);
            }
        }
        else{
            return $self->value_to_json($obj);
        }
    }


    sub hash_to_json {
        my ($self, $obj) = @_;
        my @res;

        encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                         if (++$depth > $max_depth);

        my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');
        my $del = ($space_before ? ' ' : '') . ':' . ($space_after ? ' ' : '');

        for my $k ( _sort( $obj ) ) {
            if ( OLD_PERL ) { utf8::decode($k) } # key for Perl 5.6 / be optimized
            push @res, string_to_json( $self, $k )
                          .  $del
                          . ( $self->object_to_json( $obj->{$k} ) || $self->value_to_json( $obj->{$k} ) );
        }

        --$depth;
        $self->_down_indent() if ($indent);

        return   '{' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' )  . '}';
    }


    sub array_to_json {
        my ($self, $obj) = @_;
        my @res;

        encode_error("json text or perl structure exceeds maximum nesting level (max_depth set too low?)")
                                         if (++$depth > $max_depth);

        my ($pre, $post) = $indent ? $self->_up_indent() : ('', '');

        for my $v (@$obj){
            push @res, $self->object_to_json($v) || $self->value_to_json($v);
        }

        --$depth;
        $self->_down_indent() if ($indent);

        return '[' . ( @res ? $pre : '' ) . ( @res ? join( ",$pre", @res ) . $post : '' ) . ']';
    }


    sub value_to_json {
        my ($self, $value) = @_;

        return 'null' if(!defined $value);

        my $b_obj = B::svref_2object(\$value);  # for round trip problem
        my $flags = $b_obj->FLAGS;

        return $value # as is 
            if $flags & ( B::SVp_IOK | B::SVp_NOK ) and !( $flags & B::SVp_POK ); # SvTYPE is IV or NV?

        my $type = ref($value);

        if(!$type){
            return string_to_json($self, $value);
        }
        elsif( blessed($value) and  $value->isa('JSON::PP::Boolean') ){
            return $$value == 1 ? 'true' : 'false';
        }
        elsif ($type) {
            if ((overload::StrVal($value) =~ /=(\w+)/)[0]) {
                return $self->value_to_json("$value");
            }

            if ($type eq 'SCALAR' and defined $$value) {
                return   $$value eq '1' ? 'true'
                       : $$value eq '0' ? 'false'
                       : $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ? 'null'
                       : encode_error("cannot encode reference to scalar");
            }

             if ( $self->{PROPS}->[ P_ALLOW_UNKNOWN ] ) {
                 return 'null';
             }
             else {
                 if ( $type eq 'SCALAR' or $type eq 'REF' ) {
                    encode_error("cannot encode reference to scalar");
                 }
                 else {
                    encode_error("encountered $value, but JSON can only represent references to arrays or hashes");
                 }
             }

        }
        else {
            return $self->{fallback}->($value)
                 if ($self->{fallback} and ref($self->{fallback}) eq 'CODE');
            return 'null';
        }

    }


    my %esc = (
        "\n" => '\n',
        "\r" => '\r',
        "\t" => '\t',
        "\f" => '\f',
        "\b" => '\b',
        "\"" => '\"',
        "\\" => '\\\\',
        "\'" => '\\\'',
    );


    sub string_to_json {
        my ($self, $arg) = @_;

        $arg =~ s/([\x22\x5c\n\r\t\f\b])/$esc{$1}/g;
        $arg =~ s/\//\\\//g if ($escape_slash);
        $arg =~ s/([\x00-\x08\x0b\x0e-\x1f])/'\\u00' . unpack('H2', $1)/eg;

        if ($ascii) {
            $arg = JSON_PP_encode_ascii($arg);
        }

        if ($latin1) {
            $arg = JSON_PP_encode_latin1($arg);
        }

        if ($utf8) {
            utf8::encode($arg);
        }

        return '"' . $arg . '"';
    }


    sub blessed_to_json {
        my $reftype = reftype($_[1]) || '';
        if ($reftype eq 'HASH') {
            return $_[0]->hash_to_json($_[1]);
        }
        elsif ($reftype eq 'ARRAY') {
            return $_[0]->array_to_json($_[1]);
        }
        else {
            return 'null';
        }
    }


    sub encode_error {
        my $error  = shift;
        Carp::croak "$error";
    }


    sub _sort {
        defined $keysort ? (sort $keysort (keys %{$_[0]})) : keys %{$_[0]};
    }


    sub _up_indent {
        my $self  = shift;
        my $space = ' ' x $indent_length;

        my ($pre,$post) = ('','');

        $post = "\n" . $space x $indent_count;

        $indent_count++;

        $pre = "\n" . $space x $indent_count;

        return ($pre,$post);
    }


    sub _down_indent { $indent_count--; }


    sub PP_encode_box {
        {
            depth        => $depth,
            indent_count => $indent_count,
        };
    }

} # Convert


sub _encode_ascii {
    join('',
        map {
            $_ <= 127 ?
                chr($_) :
            $_ <= 65535 ?
                sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
        } unpack('U*', $_[0])
    );
}


sub _encode_latin1 {
    join('',
        map {
            $_ <= 255 ?
                chr($_) :
            $_ <= 65535 ?
                sprintf('\u%04x', $_) : sprintf('\u%x\u%x', _encode_surrogates($_));
        } unpack('U*', $_[0])
    );
}


sub _encode_surrogates { # from perlunicode
    my $uni = $_[0] - 0x10000;
    return ($uni / 0x400 + 0xD800, $uni % 0x400 + 0xDC00);
}


sub _is_bignum {
    $_[0]->isa('Math::BigInt') or $_[0]->isa('Math::BigFloat');
}



#
# JSON => Perl
#

my $max_intsize;

BEGIN {
    my $checkint = 1111;
    for my $d (5..64) {
        $checkint .= 1;
        my $int   = eval qq| $checkint |;
        if ($int =~ /[eE]/) {
            $max_intsize = $d - 1;
            last;
        }
    }
}

{ # PARSE 

    my %escapes = ( #  by Jeremy Muhlich <jmuhlich [at] bitflood.org>
        b    => "\x8",
        t    => "\x9",
        n    => "\xA",
        f    => "\xC",
        r    => "\xD",
        '\\' => '\\',
        '"'  => '"',
        '/'  => '/',
    );

    my $text; # json data
    my $at;   # offset
    my $ch;   # 1chracter
    my $len;  # text length (changed according to UTF8 or NON UTF8)
    # INTERNAL
    my $depth;          # nest counter
    my $encoding;       # json text encoding
    my $is_valid_utf8;  # temp variable
    my $utf8_len;       # utf8 byte length
    # FLAGS
    my $utf8;           # must be utf8
    my $max_depth;      # max nest nubmer of objects and arrays
    my $max_size;
    my $relaxed;
    my $cb_object;
    my $cb_sk_object;

    my $F_HOOK;

    my $allow_bigint;   # using Math::BigInt
    my $singlequote;    # loosely quoting
    my $loose;          # 
    my $allow_barekey;  # bareKey

    # $opt flag
    # 0x00000001 .... decode_prefix
    # 0x10000000 .... incr_parse

    sub PP_decode_json {
        my ($self, $opt); # $opt is an effective flag during this decode_json.

        ($self, $text, $opt) = @_;

        ($at, $ch, $depth) = (0, '', 0);

        if ( !defined $text or ref $text ) {
            decode_error("malformed JSON string, neither array, object, number, string or atom");
        }

        my $idx = $self->{PROPS};

        ($utf8, $relaxed, $loose, $allow_bigint, $allow_barekey, $singlequote)
            = @{$idx}[P_UTF8, P_RELAXED, P_LOOSE .. P_ALLOW_SINGLEQUOTE];

        if ( $utf8 ) {
            utf8::downgrade( $text, 1 ) or Carp::croak("Wide character in subroutine entry");
        }
        else {
            utf8::upgrade( $text );
        }

        $len = length $text;

        ($max_depth, $max_size, $cb_object, $cb_sk_object, $F_HOOK)
             = @{$self}{qw/max_depth  max_size cb_object cb_sk_object F_HOOK/};

        if ($max_size > 1) {
            use bytes;
            my $bytes = length $text;
            decode_error(
                sprintf("attempted decode of JSON text of %s bytes size, but max_size is set to %s"
                    , $bytes, $max_size), 1
            ) if ($bytes > $max_size);
        }

        # Currently no effect
        # should use regexp
        my @octets = unpack('C4', $text);
        $encoding =   ( $octets[0] and  $octets[1]) ? 'UTF-8'
                    : (!$octets[0] and  $octets[1]) ? 'UTF-16BE'
                    : (!$octets[0] and !$octets[1]) ? 'UTF-32BE'
                    : ( $octets[2]                ) ? 'UTF-16LE'
                    : (!$octets[2]                ) ? 'UTF-32LE'
                    : 'unknown';

        white(); # remove head white space

        my $valid_start = defined $ch; # Is there a first character for JSON structure?

        my $result = value();

        return undef if ( !$result && ( $opt & 0x10000000 ) ); # for incr_parse

        decode_error("malformed JSON string, neither array, object, number, string or atom") unless $valid_start;

        if ( !$idx->[ P_ALLOW_NONREF ] and !ref $result ) {
                decode_error(
                'JSON text must be an object or array (but found number, string, true, false or null,'
                       . ' use allow_nonref to allow this)', 1);
        }

        Carp::croak('something wrong.') if $len < $at; # we won't arrive here.

        my $consumed = defined $ch ? $at - 1 : $at; # consumed JSON text length

        white(); # remove tail white space

        if ( $ch ) {
            return ( $result, $consumed ) if ($opt & 0x00000001); # all right if decode_prefix
            decode_error("garbage after JSON object");
        }

        ( $opt & 0x00000001 ) ? ( $result, $consumed ) : $result;
    }


    sub next_chr {
        return $ch = undef if($at >= $len);
        $ch = substr($text, $at++, 1);
    }


    sub value {
        white();
        return          if(!defined $ch);
        return object() if($ch eq '{');
        return array()  if($ch eq '[');
        return string() if($ch eq '"' or ($singlequote and $ch eq "'"));
        return number() if($ch =~ /[0-9]/ or $ch eq '-');
        return word();
    }

    sub string {
        my ($i, $s, $t, $u);
        my $utf16;
        my $is_utf8;

        ($is_valid_utf8, $utf8_len) = ('', 0);

        $s = ''; # basically UTF8 flag on

        if($ch eq '"' or ($singlequote and $ch eq "'")){
            my $boundChar = $ch;

            OUTER: while( defined(next_chr()) ){

                if($ch eq $boundChar){
                    next_chr();

                    if ($utf16) {
                        decode_error("missing low surrogate character in surrogate pair");
                    }

                    utf8::decode($s) if($is_utf8);

                    return $s;
                }
                elsif($ch eq '\\'){
                    next_chr();
                    if(exists $escapes{$ch}){
                        $s .= $escapes{$ch};
                    }
                    elsif($ch eq 'u'){ # UNICODE handling
                        my $u = '';

                        for(1..4){
                            $ch = next_chr();
                            last OUTER if($ch !~ /[0-9a-fA-F]/);
                            $u .= $ch;
                        }

                        # U+D800 - U+DBFF
                        if ($u =~ /^[dD][89abAB][0-9a-fA-F]{2}/) { # UTF-16 high surrogate?
                            $utf16 = $u;
                        }
                        # U+DC00 - U+DFFF
                        elsif ($u =~ /^[dD][c-fC-F][0-9a-fA-F]{2}/) { # UTF-16 low surrogate?
                            unless (defined $utf16) {
                                decode_error("missing high surrogate character in surrogate pair");
                            }
                            $is_utf8 = 1;
                            $s .= JSON_PP_decode_surrogates($utf16, $u) || next;
                            $utf16 = undef;
                        }
                        else {
                            if (defined $utf16) {
                                decode_error("surrogate pair expected");
                            }

                            if ( ( my $hex = hex( $u ) ) > 127 ) {
                                $is_utf8 = 1;
                                $s .= JSON_PP_decode_unicode($u) || next;
                            }
                            else {
                                $s .= chr $hex;
                            }
                        }

                    }
                    else{
                        unless ($loose) {
                            $at -= 2;
                            decode_error('illegal backslash escape sequence in string');
                        }
                        $s .= $ch;
                    }
                }
                else{

                    if ( ord $ch  > 127 ) {
                        if ( $utf8 ) {
                            unless( $ch = is_valid_utf8($ch) ) {
                                $at -= 1;
                                decode_error("malformed UTF-8 character in JSON string");
                            }
                            else {
                                $at += $utf8_len - 1;
                            }
                        }
                        else {
                            utf8::encode( $ch );
                        }

                        $is_utf8 = 1;
                    }

                    if (!$loose) {
                        if ($ch =~ /[\x00-\x1f\x22\x5c]/)  { # '/' ok
                            $at--;
                            decode_error('invalid character encountered while parsing JSON string');
                        }
                    }

                    $s .= $ch;
                }
            }
        }

        decode_error("unexpected end of string while parsing JSON string");
    }


    sub white {
        while( defined $ch  ){
            if($ch le ' '){
                next_chr();
            }
            elsif($ch eq '/'){
                next_chr();
                if(defined $ch and $ch eq '/'){
                    1 while(defined(next_chr()) and $ch ne "\n" and $ch ne "\r");
                }
                elsif(defined $ch and $ch eq '*'){
                    next_chr();
                    while(1){
                        if(defined $ch){
                            if($ch eq '*'){
                                if(defined(next_chr()) and $ch eq '/'){
                                    next_chr();
                                    last;
                                }
                            }
                            else{
                                next_chr();
                            }
                        }
                        else{
                            decode_error("Unterminated comment");
                        }
                    }
                    next;
                }
                else{
                    $at--;
                    decode_error("malformed JSON string, neither array, object, number, string or atom");
                }
            }
            else{
                if ($relaxed and $ch eq '#') { # correctly?
                    pos($text) = $at;
                    $text =~ /\G([^\n]*(?:\r\n|\r|\n|$))/g;
                    $at = pos($text);
                    next_chr;
                    next;
                }

                last;
            }
        }
    }


    sub array {
        my $a  = $_[0] || []; # you can use this code to use another array ref object.

        decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                    if (++$depth > $max_depth);

        next_chr();
        white();

        if(defined $ch and $ch eq ']'){
            --$depth;
            next_chr();
            return $a;
        }
        else {
            while(defined($ch)){
                push @$a, value();

                white();

                if (!defined $ch) {
                    last;
                }

                if($ch eq ']'){
                    --$depth;
                    next_chr();
                    return $a;
                }

                if($ch ne ','){
                    last;
                }

                next_chr();
                white();

                if ($relaxed and $ch eq ']') {
                    --$depth;
                    next_chr();
                    return $a;
                }

            }
        }

        decode_error(", or ] expected while parsing array");
    }


    sub object {
        my $o = $_[0] || {}; # you can use this code to use another hash ref object.
        my $k;

        decode_error('json text or perl structure exceeds maximum nesting level (max_depth set too low?)')
                                                if (++$depth > $max_depth);
        next_chr();
        white();

        if(defined $ch and $ch eq '}'){
            --$depth;
            next_chr();
            if ($F_HOOK) {
                return _json_object_hook($o);
            }
            return $o;
        }
        else {
            while (defined $ch) {
                $k = ($allow_barekey and $ch ne '"' and $ch ne "'") ? bareKey() : string();
                white();

                if(!defined $ch or $ch ne ':'){
                    $at--;
                    decode_error("':' expected");
                }

                next_chr();
                $o->{$k} = value();
                white();

                last if (!defined $ch);

                if($ch eq '}'){
                    --$depth;
                    next_chr();
                    if ($F_HOOK) {
                        return _json_object_hook($o);
                    }
                    return $o;
                }

                if($ch ne ','){
                    last;
                }

                next_chr();
                white();

                if ($relaxed and $ch eq '}') {
                    --$depth;
                    next_chr();
                    if ($F_HOOK) {
                        return _json_object_hook($o);
                    }
                    return $o;
                }

            }

        }

        $at--;
        decode_error(", or } expected while parsing object/hash");
    }


    sub bareKey { # doesn't strictly follow Standard ECMA-262 3rd Edition
        my $key;
        while($ch =~ /[^\x00-\x23\x25-\x2F\x3A-\x40\x5B-\x5E\x60\x7B-\x7F]/){
            $key .= $ch;
            next_chr();
        }
        return $key;
    }


    sub word {
        my $word =  substr($text,$at-1,4);

        if($word eq 'true'){
            $at += 3;
            next_chr;
            return $JSON::PP::true;
        }
        elsif($word eq 'null'){
            $at += 3;
            next_chr;
            return undef;
        }
        elsif($word eq 'fals'){
            $at += 3;
            if(substr($text,$at,1) eq 'e'){
                $at++;
                next_chr;
                return $JSON::PP::false;
            }
        }

        $at--; # for decode_error report

        decode_error("'null' expected")  if ($word =~ /^n/);
        decode_error("'true' expected")  if ($word =~ /^t/);
        decode_error("'false' expected") if ($word =~ /^f/);
        decode_error("malformed JSON string, neither array, object, number, string or atom");
    }


    sub number {
        my $n    = '';
        my $v;

        # According to RFC4627, hex or oct digts are invalid.
        if($ch eq '0'){
            my $peek = substr($text,$at,1);
            my $hex  = $peek =~ /[xX]/; # 0 or 1

            if($hex){
                decode_error("malformed number (leading zero must not be followed by another digit)");
                ($n) = ( substr($text, $at+1) =~ /^([0-9a-fA-F]+)/);
            }
            else{ # oct
                ($n) = ( substr($text, $at) =~ /^([0-7]+)/);
                if (defined $n and length $n > 1) {
                    decode_error("malformed number (leading zero must not be followed by another digit)");
                }
            }

            if(defined $n and length($n)){
                if (!$hex and length($n) == 1) {
                   decode_error("malformed number (leading zero must not be followed by another digit)");
                }
                $at += length($n) + $hex;
                next_chr;
                return $hex ? hex($n) : oct($n);
            }
        }

        if($ch eq '-'){
            $n = '-';
            next_chr;
            if (!defined $ch or $ch !~ /\d/) {
                decode_error("malformed number (no digits after initial minus)");
            }
        }

        while(defined $ch and $ch =~ /\d/){
            $n .= $ch;
            next_chr;
        }

        if(defined $ch and $ch eq '.'){
            $n .= '.';

            next_chr;
            if (!defined $ch or $ch !~ /\d/) {
                decode_error("malformed number (no digits after decimal point)");
            }
            else {
                $n .= $ch;
            }

            while(defined(next_chr) and $ch =~ /\d/){
                $n .= $ch;
            }
        }

        if(defined $ch and ($ch eq 'e' or $ch eq 'E')){
            $n .= $ch;
            next_chr;

            if(defined($ch) and ($ch eq '+' or $ch eq '-')){
                $n .= $ch;
                next_chr;
                if (!defined $ch or $ch =~ /\D/) {
                    decode_error("malformed number (no digits after exp sign)");
                }
                $n .= $ch;
            }
            elsif(defined($ch) and $ch =~ /\d/){
                $n .= $ch;
            }
            else {
                decode_error("malformed number (no digits after exp sign)");
            }

            while(defined(next_chr) and $ch =~ /\d/){
                $n .= $ch;
            }

        }

        $v .= $n;

        if ($v !~ /[.eE]/ and length $v > $max_intsize) {
            if ($allow_bigint) { # from Adam Sussman
                require Math::BigInt;
                return Math::BigInt->new($v);
            }
            else {
                return "$v";
            }
        }
        elsif ($allow_bigint) {
            require Math::BigFloat;
            return Math::BigFloat->new($v);
        }

        return 0+$v;
    }


    sub is_valid_utf8 {

        $utf8_len = $_[0] =~ /[\x00-\x7F]/  ? 1
                  : $_[0] =~ /[\xC2-\xDF]/  ? 2
                  : $_[0] =~ /[\xE0-\xEF]/  ? 3
                  : $_[0] =~ /[\xF0-\xF4]/  ? 4
                  : 0
                  ;

        return unless $utf8_len;

        my $is_valid_utf8 = substr($text, $at - 1, $utf8_len);

        return ( $is_valid_utf8 =~ /^(?:
             [\x00-\x7F]
            |[\xC2-\xDF][\x80-\xBF]
            |[\xE0][\xA0-\xBF][\x80-\xBF]
            |[\xE1-\xEC][\x80-\xBF][\x80-\xBF]
            |[\xED][\x80-\x9F][\x80-\xBF]
            |[\xEE-\xEF][\x80-\xBF][\x80-\xBF]
            |[\xF0][\x90-\xBF][\x80-\xBF][\x80-\xBF]
            |[\xF1-\xF3][\x80-\xBF][\x80-\xBF][\x80-\xBF]
            |[\xF4][\x80-\x8F][\x80-\xBF][\x80-\xBF]
        )$/x )  ? $is_valid_utf8 : '';
    }


    sub decode_error {
        my $error  = shift;
        my $no_rep = shift;
        my $str    = defined $text ? substr($text, $at) : '';
        my $mess   = '';
        my $type   = $] >= 5.008           ? 'U*'
                   : $] <  5.006           ? 'C*'
                   : utf8::is_utf8( $str ) ? 'U*' # 5.6
                   : 'C*'
                   ;

        for my $c ( unpack( $type, $str ) ) { # emulate pv_uni_display() ?
            $mess .=  $c == 0x07 ? '\a'
                    : $c == 0x09 ? '\t'
                    : $c == 0x0a ? '\n'
                    : $c == 0x0d ? '\r'
                    : $c == 0x0c ? '\f'
                    : $c <  0x20 ? sprintf('\x{%x}', $c)
                    : $c == 0x5c ? '\\\\'
                    : $c <  0x80 ? chr($c)
                    : sprintf('\x{%x}', $c)
                    ;
            if ( length $mess >= 20 ) {
                $mess .= '...';
                last;
            }
        }

        unless ( length $mess ) {
            $mess = '(end of string)';
        }

        Carp::croak (
            $no_rep ? "$error" : "$error, at character offset $at (before \"$mess\")"
        );

    }


    sub _json_object_hook {
        my $o    = $_[0];
        my @ks = keys %{$o};

        if ( $cb_sk_object and @ks == 1 and exists $cb_sk_object->{ $ks[0] } and ref $cb_sk_object->{ $ks[0] } ) {
            my @val = $cb_sk_object->{ $ks[0] }->( $o->{$ks[0]} );
            if (@val == 1) {
                return $val[0];
            }
        }

        my @val = $cb_object->($o) if ($cb_object);
        if (@val == 0 or @val > 1) {
            return $o;
        }
        else {
            return $val[0];
        }
    }


    sub PP_decode_box {
        {
            text    => $text,
            at      => $at,
            ch      => $ch,
            len     => $len,
            depth   => $depth,
            encoding      => $encoding,
            is_valid_utf8 => $is_valid_utf8,
        };
    }

} # PARSE


sub _decode_surrogates { # from perlunicode
    my $uni = 0x10000 + (hex($_[0]) - 0xD800) * 0x400 + (hex($_[1]) - 0xDC00);
    my $un  = pack('U*', $uni);
    utf8::encode( $un );
    return $un;
}


sub _decode_unicode {
    my $un = pack('U', hex shift);
    utf8::encode( $un );
    return $un;
}

#
# Setup for various Perl versions (the code from JSON::PP58)
#

BEGIN {

    unless ( defined &utf8::is_utf8 ) {
       require Encode;
       *utf8::is_utf8 = *Encode::is_utf8;
    }

    if ( $] >= 5.008 ) {
        *JSON::PP::JSON_PP_encode_ascii      = \&_encode_ascii;
        *JSON::PP::JSON_PP_encode_latin1     = \&_encode_latin1;
        *JSON::PP::JSON_PP_decode_surrogates = \&_decode_surrogates;
        *JSON::PP::JSON_PP_decode_unicode    = \&_decode_unicode;
    }

    if ($] >= 5.008 and $] < 5.008003) { # join() in 5.8.0 - 5.8.2 is broken.
        package JSON::PP;
        require subs;
        subs->import('join');
        eval q|
            sub join {
                return '' if (@_ < 2);
                my $j   = shift;
                my $str = shift;
                for (@_) { $str .= $j . $_; }
                return $str;
            }
        |;
    }


    sub JSON::PP::incr_parse {
        local $Carp::CarpLevel = 1;
        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_parse( @_ );
    }


    sub JSON::PP::incr_skip {
        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_skip;
    }


    sub JSON::PP::incr_reset {
        ( $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new )->incr_reset;
    }

    eval q{
        sub JSON::PP::incr_text : lvalue {
            $_[0]->{_incr_parser} ||= JSON::PP::IncrParser->new;

            if ( $_[0]->{_incr_parser}->{incr_parsing} ) {
                Carp::croak("incr_text can not be called when the incremental parser already started parsing");
            }
            $_[0]->{_incr_parser}->{incr_text};
        }
    } if ( $] >= 5.006 );

} # Setup for various Perl versions (the code from JSON::PP58)


###############################
# Utilities
#

BEGIN {
    eval 'require Scalar::Util';
    unless($@){
        *JSON::PP::blessed = \&Scalar::Util::blessed;
        *JSON::PP::reftype = \&Scalar::Util::reftype;
        *JSON::PP::refaddr = \&Scalar::Util::refaddr;
    }
    else{ # This code is from Sclar::Util.
        # warn $@;
        eval 'sub UNIVERSAL::a_sub_not_likely_to_be_here { ref($_[0]) }';
        *JSON::PP::blessed = sub {
            local($@, $SIG{__DIE__}, $SIG{__WARN__});
            ref($_[0]) ? eval { $_[0]->a_sub_not_likely_to_be_here } : undef;
        };
        my %tmap = qw(
            B::NULL   SCALAR
            B::HV     HASH
            B::AV     ARRAY
            B::CV     CODE
            B::IO     IO
            B::GV     GLOB
            B::REGEXP REGEXP
        );
        *JSON::PP::reftype = sub {
            my $r = shift;

            return undef unless length(ref($r));

            my $t = ref(B::svref_2object($r));

            return
                exists $tmap{$t} ? $tmap{$t}
              : length(ref($$r)) ? 'REF'
              :                    'SCALAR';
        };
        *JSON::PP::refaddr = sub {
          return undef unless length(ref($_[0]));

          my $addr;
          if(defined(my $pkg = blessed($_[0]))) {
            $addr .= bless $_[0], 'Scalar::Util::Fake';
            bless $_[0], $pkg;
          }
          else {
            $addr .= $_[0]
          }

          $addr =~ /0x(\w+)/;
          local $^W;
          #no warnings 'portable';
          hex($1);
        }
    }
}


# shamely copied and modified from JSON::XS code.

$JSON::PP::true  = do { bless \(my $dummy = 1), "JSON::PP::Boolean" };
$JSON::PP::false = do { bless \(my $dummy = 0), "JSON::PP::Boolean" };

sub is_bool { defined $_[0] and UNIVERSAL::isa($_[0], "JSON::PP::Boolean"); }

sub true  { $JSON::PP::true  }
sub false { $JSON::PP::false }
sub null  { undef; }

###############################

package JSON::PP::Boolean;

use overload (
   "0+"     => sub { ${$_[0]} },
   "++"     => sub { $_[0] = ${$_[0]} + 1 },
   "--"     => sub { $_[0] = ${$_[0]} - 1 },
   fallback => 1,
);


###############################

package JSON::PP::IncrParser;

use strict;

use constant INCR_M_WS   => 0; # initial whitespace skipping
use constant INCR_M_STR  => 1; # inside string
use constant INCR_M_BS   => 2; # inside backslash
use constant INCR_M_JSON => 3; # outside anything, count nesting
use constant INCR_M_C0   => 4;
use constant INCR_M_C1   => 5;

$JSON::PP::IncrParser::VERSION = '1.01';

my $unpack_format = $] < 5.006 ? 'C*' : 'U*';

sub new {
    my ( $class ) = @_;

    bless {
        incr_nest    => 0,
        incr_text    => undef,
        incr_parsing => 0,
        incr_p       => 0,
    }, $class;
}


sub incr_parse {
    my ( $self, $coder, $text ) = @_;

    $self->{incr_text} = '' unless ( defined $self->{incr_text} );

    if ( defined $text ) {
        if ( utf8::is_utf8( $text ) and !utf8::is_utf8( $self->{incr_text} ) ) {
            utf8::upgrade( $self->{incr_text} ) ;
            utf8::decode( $self->{incr_text} ) ;
        }
        $self->{incr_text} .= $text;
    }


    my $max_size = $coder->get_max_size;

    if ( defined wantarray ) {

        $self->{incr_mode} = INCR_M_WS unless defined $self->{incr_mode};

        if ( wantarray ) {
            my @ret;

            $self->{incr_parsing} = 1;

            do {
                push @ret, $self->_incr_parse( $coder, $self->{incr_text} );

                unless ( !$self->{incr_nest} and $self->{incr_mode} == INCR_M_JSON ) {
                    $self->{incr_mode} = INCR_M_WS if $self->{incr_mode} != INCR_M_STR;
                }

            } until ( length $self->{incr_text} >= $self->{incr_p} );

            $self->{incr_parsing} = 0;

            return @ret;
        }
        else { # in scalar context
            $self->{incr_parsing} = 1;
            my $obj = $self->_incr_parse( $coder, $self->{incr_text} );
            $self->{incr_parsing} = 0 if defined $obj; # pointed by Martin J. Evans
            return $obj ? $obj : undef; # $obj is an empty string, parsing was completed.
        }

    }

}


sub _incr_parse {
    my ( $self, $coder, $text, $skip ) = @_;
    my $p = $self->{incr_p};
    my $restore = $p;

    my @obj;
    my $len = length $text;

    if ( $self->{incr_mode} == INCR_M_WS ) {
        while ( $len > $p ) {
            my $s = substr( $text, $p, 1 );
            $p++ and next if ( 0x20 >= unpack($unpack_format, $s) );
            $self->{incr_mode} = INCR_M_JSON;
            last;
       }
    }

    while ( $len > $p ) {
        my $s = substr( $text, $p++, 1 );

        if ( $s eq '"' ) {
            if (substr( $text, $p - 2, 1 ) eq '\\' ) {
                next;
            }

            if ( $self->{incr_mode} != INCR_M_STR  ) {
                $self->{incr_mode} = INCR_M_STR;
            }
            else {
                $self->{incr_mode} = INCR_M_JSON;
                unless ( $self->{incr_nest} ) {
                    last;
                }
            }
        }

        if ( $self->{incr_mode} == INCR_M_JSON ) {

            if ( $s eq '[' or $s eq '{' ) {
                if ( ++$self->{incr_nest} > $coder->get_max_depth ) {
                    Carp::croak('json text or perl structure exceeds maximum nesting level (max_depth set too low?)');
                }
            }
            elsif ( $s eq ']' or $s eq '}' ) {
                last if ( --$self->{incr_nest} <= 0 );
            }
            elsif ( $s eq '#' ) {
                while ( $len > $p ) {
                    last if substr( $text, $p++, 1 ) eq "\n";
                }
            }

        }

    }

    $self->{incr_p} = $p;

    return if ( $self->{incr_mode} == INCR_M_STR and not $self->{incr_nest} );
    return if ( $self->{incr_mode} == INCR_M_JSON and $self->{incr_nest} > 0 );

    return '' unless ( length substr( $self->{incr_text}, 0, $p ) );

    local $Carp::CarpLevel = 2;

    $self->{incr_p} = $restore;
    $self->{incr_c} = $p;

    my ( $obj, $tail ) = $coder->PP_decode_json( substr( $self->{incr_text}, 0, $p ), 0x10000001 );

    $self->{incr_text} = substr( $self->{incr_text}, $p );
    $self->{incr_p} = 0;

    return $obj || '';
}


sub incr_text {
    if ( $_[0]->{incr_parsing} ) {
        Carp::croak("incr_text can not be called when the incremental parser already started parsing");
    }
    $_[0]->{incr_text};
}


sub incr_skip {
    my $self  = shift;
    $self->{incr_text} = substr( $self->{incr_text}, $self->{incr_c} );
    $self->{incr_p} = 0;
}


sub incr_reset {
    my $self = shift;
    $self->{incr_text}    = undef;
    $self->{incr_p}       = 0;
    $self->{incr_mode}    = 0;
    $self->{incr_nest}    = 0;
    $self->{incr_parsing} = 0;
}

###############################


1;
__END__
=pod

=head1 NAME

JSON::PP - JSON::XS compatible pure-Perl module.

=head1 SYNOPSIS

 use JSON::PP;

 # exported functions, they croak on error
 # and expect/generate UTF-8

 $utf8_encoded_json_text = encode_json $perl_hash_or_arrayref;
 $perl_hash_or_arrayref  = decode_json $utf8_encoded_json_text;

 # OO-interface

 $coder = JSON::PP->new->ascii->pretty->allow_nonref;
 
 $json_text   = $json->encode( $perl_scalar );
 $perl_scalar = $json->decode( $json_text );
 
 $pretty_printed = $json->pretty->encode( $perl_scalar ); # pretty-printing
 
 # Note that JSON version 2.0 and above will automatically use
 # JSON::XS or JSON::PP, so you should be able to just:
 
 use JSON;


=head1 VERSION

    2.27202

L<JSON::XS> 2.27 (~2.30) compatible.

=head1 NOTE

JSON::PP had been inculded in JSON distribution (CPAN module).
It was a perl core module in Perl 5.14.

=head1 DESCRIPTION

This module is L<JSON::XS> compatible pure Perl module.
(Perl 5.8 or later is recommended)

JSON::XS is the fastest and most proper JSON module on CPAN.
It is written by Marc Lehmann in C, so must be compiled and
installed in the used environment.

JSON::PP is a pure-Perl module and has compatibility to JSON::XS.


=head2 FEATURES

=over

=item * correct unicode handling

This module knows how to handle Unicode (depending on Perl version).

See to L<JSON::XS/A FEW NOTES ON UNICODE AND PERL> and L<UNICODE HANDLING ON PERLS>.


=item * round-trip integrity

When you serialise a perl data structure using only data types supported
by JSON and Perl, the deserialised data structure is identical on the Perl
level. (e.g. the string "2.0" doesn't suddenly become "2" just because
it looks like a number). There I<are> minor exceptions to this, read the
MAPPING section below to learn about those.


=item * strict checking of JSON correctness

There is no guessing, no generating of illegal JSON texts by default,
and only JSON is accepted as input by default (the latter is a security feature).
But when some options are set, loose chcking features are available.

=back

=head1 FUNCTIONAL INTERFACE

Some documents are copied and modified from L<JSON::XS/FUNCTIONAL INTERFACE>.

=head2 encode_json

    $json_text = encode_json $perl_scalar

Converts the given Perl data structure to a UTF-8 encoded, binary string.

This function call is functionally identical to:

    $json_text = JSON::PP->new->utf8->encode($perl_scalar)

=head2 decode_json

    $perl_scalar = decode_json $json_text

The opposite of C<encode_json>: expects an UTF-8 (binary) string and tries
to parse that as an UTF-8 encoded JSON text, returning the resulting
reference.

This function call is functionally identical to:

    $perl_scalar = JSON::PP->new->utf8->decode($json_text)

=head2 JSON::PP::is_bool

    $is_boolean = JSON::PP::is_bool($scalar)

Returns true if the passed scalar represents either JSON::PP::true or
JSON::PP::false, two constants that act like C<1> and C<0> respectively
and are also used to represent JSON C<true> and C<false> in Perl strings.

=head2 JSON::PP::true

Returns JSON true value which is blessed object.
It C<isa> JSON::PP::Boolean object.

=head2 JSON::PP::false

Returns JSON false value which is blessed object.
It C<isa> JSON::PP::Boolean object.

=head2 JSON::PP::null

Returns C<undef>.

See L<MAPPING>, below, for more information on how JSON values are mapped to
Perl.


=head1 HOW DO I DECODE A DATA FROM OUTER AND ENCODE TO OUTER

This section supposes that your perl vresion is 5.8 or later.

If you know a JSON text from an outer world - a network, a file content, and so on,
is encoded in UTF-8, you should use C<decode_json> or C<JSON> module object
with C<utf8> enable. And the decoded result will contain UNICODE characters.

  # from network
  my $json        = JSON::PP->new->utf8;
  my $json_text   = CGI->new->param( 'json_data' );
  my $perl_scalar = $json->decode( $json_text );
  
  # from file content
  local $/;
  open( my $fh, '<', 'json.data' );
  $json_text   = <$fh>;
  $perl_scalar = decode_json( $json_text );

If an outer data is not encoded in UTF-8, firstly you should C<decode> it.

  use Encode;
  local $/;
  open( my $fh, '<', 'json.data' );
  my $encoding = 'cp932';
  my $unicode_json_text = decode( $encoding, <$fh> ); # UNICODE
  
  # or you can write the below code.
  #
  # open( my $fh, "<:encoding($encoding)", 'json.data' );
  # $unicode_json_text = <$fh>;

In this case, C<$unicode_json_text> is of course UNICODE string.
So you B<cannot> use C<decode_json> nor C<JSON> module object with C<utf8> enable.
Instead of them, you use C<JSON> module object with C<utf8> disable.

  $perl_scalar = $json->utf8(0)->decode( $unicode_json_text );

Or C<encode 'utf8'> and C<decode_json>:

  $perl_scalar = decode_json( encode( 'utf8', $unicode_json_text ) );
  # this way is not efficient.

And now, you want to convert your C<$perl_scalar> into JSON data and
send it to an outer world - a network or a file content, and so on.

Your data usually contains UNICODE strings and you want the converted data to be encoded
in UTF-8, you should use C<encode_json> or C<JSON> module object with C<utf8> enable.

  print encode_json( $perl_scalar ); # to a network? file? or display?
  # or
  print $json->utf8->encode( $perl_scalar );

If C<$perl_scalar> does not contain UNICODE but C<$encoding>-encoded strings
for some reason, then its characters are regarded as B<latin1> for perl
(because it does not concern with your $encoding).
You B<cannot> use C<encode_json> nor C<JSON> module object with C<utf8> enable.
Instead of them, you use C<JSON> module object with C<utf8> disable.
Note that the resulted text is a UNICODE string but no problem to print it.

  # $perl_scalar contains $encoding encoded string values
  $unicode_json_text = $json->utf8(0)->encode( $perl_scalar );
  # $unicode_json_text consists of characters less than 0x100
  print $unicode_json_text;

Or C<decode $encoding> all string values and C<encode_json>:

  $perl_scalar->{ foo } = decode( $encoding, $perl_scalar->{ foo } );
  # ... do it to each string values, then encode_json
  $json_text = encode_json( $perl_scalar );

This method is a proper way but probably not efficient.

See to L<Encode>, L<perluniintro>.


=head1 METHODS

Basically, check to L<JSON> or L<JSON::XS>.

=head2 new

    $json = JSON::PP->new

Rturns a new JSON::PP object that can be used to de/encode JSON
strings.

All boolean flags described below are by default I<disabled>.

The mutators for flags all return the JSON object again and thus calls can
be chained:

   my $json = JSON::PP->new->utf8->space_after->encode({a => [1,2]})
   => {"a": [1, 2]}

=head2 ascii

    $json = $json->ascii([$enable])
    
    $enabled = $json->get_ascii

If $enable is true (or missing), then the encode method will not generate characters outside
the code range 0..127. Any Unicode characters outside that range will be escaped using either
a single \uXXXX or a double \uHHHH\uLLLLL escape sequence, as per RFC4627.
(See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>).

In Perl 5.005, there is no character having high value (more than 255).
See to L<UNICODE HANDLING ON PERLS>.

If $enable is false, then the encode method will not escape Unicode characters unless
required by the JSON syntax or other flags. This results in a faster and more compact format.

  JSON::PP->new->ascii(1)->encode([chr 0x10401])
  => ["\ud801\udc01"]

=head2 latin1

    $json = $json->latin1([$enable])
    
    $enabled = $json->get_latin1

If $enable is true (or missing), then the encode method will encode the resulting JSON
text as latin1 (or iso-8859-1), escaping any characters outside the code range 0..255.

If $enable is false, then the encode method will not escape Unicode characters
unless required by the JSON syntax or other flags.

  JSON::XS->new->latin1->encode (["\x{89}\x{abc}"]
  => ["\x{89}\\u0abc"]    # (perl syntax, U+abc escaped, U+89 not)

See to L<UNICODE HANDLING ON PERLS>.

=head2 utf8

    $json = $json->utf8([$enable])
    
    $enabled = $json->get_utf8

If $enable is true (or missing), then the encode method will encode the JSON result
into UTF-8, as required by many protocols, while the decode method expects to be handled
an UTF-8-encoded string. Please note that UTF-8-encoded strings do not contain any
characters outside the range 0..255, they are thus useful for bytewise/binary I/O.

(In Perl 5.005, any character outside the range 0..255 does not exist.
See to L<UNICODE HANDLING ON PERLS>.)

In future versions, enabling this option might enable autodetection of the UTF-16 and UTF-32
encoding families, as described in RFC4627.

If $enable is false, then the encode method will return the JSON string as a (non-encoded)
Unicode string, while decode expects thus a Unicode string. Any decoding or encoding
(e.g. to UTF-8 or UTF-16) needs to be done yourself, e.g. using the Encode module.

Example, output UTF-16BE-encoded JSON:

  use Encode;
  $jsontext = encode "UTF-16BE", JSON::PP->new->encode ($object);

Example, decode UTF-32LE-encoded JSON:

  use Encode;
  $object = JSON::PP->new->decode (decode "UTF-32LE", $jsontext);


=head2 pretty

    $json = $json->pretty([$enable])

This enables (or disables) all of the C<indent>, C<space_before> and
C<space_after> flags in one call to generate the most readable
(or most compact) form possible.

Equivalent to:

   $json->indent->space_before->space_after

=head2 indent

    $json = $json->indent([$enable])
    
    $enabled = $json->get_indent

The default indent space length is three.
You can use C<indent_length> to change the length.

=head2 space_before

    $json = $json->space_before([$enable])
    
    $enabled = $json->get_space_before

If C<$enable> is true (or missing), then the C<encode> method will add an extra
optional space before the C<:> separating keys from values in JSON objects.

If C<$enable> is false, then the C<encode> method will not add any extra
space at those places.

This setting has no effect when decoding JSON texts.

Example, space_before enabled, space_after and indent disabled:

   {"key" :"value"}

=head2 space_after

    $json = $json->space_after([$enable])
    
    $enabled = $json->get_space_after

If C<$enable> is true (or missing), then the C<encode> method will add an extra
optional space after the C<:> separating keys from values in JSON objects
and extra whitespace after the C<,> separating key-value pairs and array
members.

If C<$enable> is false, then the C<encode> method will not add any extra
space at those places.

This setting has no effect when decoding JSON texts.

Example, space_before and indent disabled, space_after enabled:

   {"key": "value"}

=head2 relaxed

    $json = $json->relaxed([$enable])
    
    $enabled = $json->get_relaxed

If C<$enable> is true (or missing), then C<decode> will accept some
extensions to normal JSON syntax (see below). C<encode> will not be
affected in anyway. I<Be aware that this option makes you accept invalid
JSON texts as if they were valid!>. I suggest only to use this option to
parse application-specific files written by humans (configuration files,
resource files etc.)

If C<$enable> is false (the default), then C<decode> will only accept
valid JSON texts.

Currently accepted extensions are:

=over 4

=item * list items can have an end-comma

JSON I<separates> array elements and key-value pairs with commas. This
can be annoying if you write JSON texts manually and want to be able to
quickly append elements, so this extension accepts comma at the end of
such items not just between them:

   [
      1,
      2, <- this comma not normally allowed
   ]
   {
      "k1": "v1",
      "k2": "v2", <- this comma not normally allowed
   }

=item * shell-style '#'-comments

Whenever JSON allows whitespace, shell-style comments are additionally
allowed. They are terminated by the first carriage-return or line-feed
character, after which more white-space and comments are allowed.

  [
     1, # this comment not allowed in JSON
        # neither this one...
  ]

=back

=head2 canonical

    $json = $json->canonical([$enable])
    
    $enabled = $json->get_canonical

If C<$enable> is true (or missing), then the C<encode> method will output JSON objects
by sorting their keys. This is adding a comparatively high overhead.

If C<$enable> is false, then the C<encode> method will output key-value
pairs in the order Perl stores them (which will likely change between runs
of the same script).

This option is useful if you want the same data structure to be encoded as
the same JSON text (given the same overall settings). If it is disabled,
the same hash might be encoded differently even if contains the same data,
as key-value pairs have no inherent ordering in Perl.

This setting has no effect when decoding JSON texts.

If you want your own sorting routine, you can give a code referece
or a subroutine name to C<sort_by>. See to C<JSON::PP OWN METHODS>.

=head2 allow_nonref

    $json = $json->allow_nonref([$enable])
    
    $enabled = $json->get_allow_nonref

If C<$enable> is true (or missing), then the C<encode> method can convert a
non-reference into its corresponding string, number or null JSON value,
which is an extension to RFC4627. Likewise, C<decode> will accept those JSON
values instead of croaking.

If C<$enable> is false, then the C<encode> method will croak if it isn't
passed an arrayref or hashref, as JSON texts must either be an object
or array. Likewise, C<decode> will croak if given something that is not a
JSON object or array.

   JSON::PP->new->allow_nonref->encode ("Hello, World!")
   => "Hello, World!"

=head2 allow_unknown

    $json = $json->allow_unknown ([$enable])
    
    $enabled = $json->get_allow_unknown

If $enable is true (or missing), then "encode" will *not* throw an
exception when it encounters values it cannot represent in JSON (for
example, filehandles) but instead will encode a JSON "null" value.
Note that blessed objects are not included here and are handled
separately by c<allow_nonref>.

If $enable is false (the default), then "encode" will throw an
exception when it encounters anything it cannot encode as JSON.

This option does not affect "decode" in any way, and it is
recommended to leave it off unless you know your communications
partner.

=head2 allow_blessed

    $json = $json->allow_blessed([$enable])
    
    $enabled = $json->get_allow_blessed

If C<$enable> is true (or missing), then the C<encode> method will not
barf when it encounters a blessed reference. Instead, the value of the
B<convert_blessed> option will decide whether C<null> (C<convert_blessed>
disabled or no C<TO_JSON> method found) or a representation of the
object (C<convert_blessed> enabled and C<TO_JSON> method found) is being
encoded. Has no effect on C<decode>.

If C<$enable> is false (the default), then C<encode> will throw an
exception when it encounters a blessed object.

=head2 convert_blessed

    $json = $json->convert_blessed([$enable])
    
    $enabled = $json->get_convert_blessed

If C<$enable> is true (or missing), then C<encode>, upon encountering a
blessed object, will check for the availability of the C<TO_JSON> method
on the object's class. If found, it will be called in scalar context
and the resulting scalar will be encoded instead of the object. If no
C<TO_JSON> method is found, the value of C<allow_blessed> will decide what
to do.

The C<TO_JSON> method may safely call die if it wants. If C<TO_JSON>
returns other blessed objects, those will be handled in the same
way. C<TO_JSON> must take care of not causing an endless recursion cycle
(== crash) in this case. The name of C<TO_JSON> was chosen because other
methods called by the Perl core (== not by the user of the object) are
usually in upper case letters and to avoid collisions with the C<to_json>
function or method.

This setting does not yet influence C<decode> in any way.

If C<$enable> is false, then the C<allow_blessed> setting will decide what
to do when a blessed object is found.

=head2 filter_json_object

    $json = $json->filter_json_object([$coderef])

When C<$coderef> is specified, it will be called from C<decode> each
time it decodes a JSON object. The only argument passed to the coderef
is a reference to the newly-created hash. If the code references returns
a single scalar (which need not be a reference), this value
(i.e. a copy of that scalar to avoid aliasing) is inserted into the
deserialised data structure. If it returns an empty list
(NOTE: I<not> C<undef>, which is a valid scalar), the original deserialised
hash will be inserted. This setting can slow down decoding considerably.

When C<$coderef> is omitted or undefined, any existing callback will
be removed and C<decode> will not change the deserialised hash in any
way.

Example, convert all JSON objects into the integer 5:

   my $js = JSON::PP->new->filter_json_object (sub { 5 });
   # returns [5]
   $js->decode ('[{}]'); # the given subroutine takes a hash reference.
   # throw an exception because allow_nonref is not enabled
   # so a lone 5 is not allowed.
   $js->decode ('{"a":1, "b":2}');

=head2 filter_json_single_key_object

    $json = $json->filter_json_single_key_object($key [=> $coderef])

Works remotely similar to C<filter_json_object>, but is only called for
JSON objects having a single key named C<$key>.

This C<$coderef> is called before the one specified via
C<filter_json_object>, if any. It gets passed the single value in the JSON
object. If it returns a single value, it will be inserted into the data
structure. If it returns nothing (not even C<undef> but the empty list),
the callback from C<filter_json_object> will be called next, as if no
single-key callback were specified.

If C<$coderef> is omitted or undefined, the corresponding callback will be
disabled. There can only ever be one callback for a given key.

As this callback gets called less often then the C<filter_json_object>
one, decoding speed will not usually suffer as much. Therefore, single-key
objects make excellent targets to serialise Perl objects into, especially
as single-key JSON objects are as close to the type-tagged value concept
as JSON gets (it's basically an ID/VALUE tuple). Of course, JSON does not
support this in any way, so you need to make sure your data never looks
like a serialised Perl hash.

Typical names for the single object key are C<__class_whatever__>, or
C<$__dollars_are_rarely_used__$> or C<}ugly_brace_placement>, or even
things like C<__class_md5sum(classname)__>, to reduce the risk of clashing
with real hashes.

Example, decode JSON objects of the form C<< { "__widget__" => <id> } >>
into the corresponding C<< $WIDGET{<id>} >> object:

   # return whatever is in $WIDGET{5}:
   JSON::PP
      ->new
      ->filter_json_single_key_object (__widget__ => sub {
            $WIDGET{ $_[0] }
         })
      ->decode ('{"__widget__": 5')

   # this can be used with a TO_JSON method in some "widget" class
   # for serialisation to json:
   sub WidgetBase::TO_JSON {
      my ($self) = @_;

      unless ($self->{id}) {
         $self->{id} = ..get..some..id..;
         $WIDGET{$self->{id}} = $self;
      }

      { __widget__ => $self->{id} }
   }

=head2 shrink

    $json = $json->shrink([$enable])
    
    $enabled = $json->get_shrink

In JSON::XS, this flag resizes strings generated by either
C<encode> or C<decode> to their minimum size possible.
It will also try to downgrade any strings to octet-form if possible.

In JSON::PP, it is noop about resizing strings but tries
C<utf8::downgrade> to the returned string by C<encode>.
See to L<utf8>.

See to L<JSON::XS/OBJECT-ORIENTED INTERFACE>

=head2 max_depth

    $json = $json->max_depth([$maximum_nesting_depth])
    
    $max_depth = $json->get_max_depth

Sets the maximum nesting level (default C<512>) accepted while encoding
or decoding. If a higher nesting level is detected in JSON text or a Perl
data structure, then the encoder and decoder will stop and croak at that
point.

Nesting level is defined by number of hash- or arrayrefs that the encoder
needs to traverse to reach a given point or the number of C<{> or C<[>
characters without their matching closing parenthesis crossed to reach a
given character in a string.

If no argument is given, the highest possible setting will be used, which
is rarely useful.

See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.

When a large value (100 or more) was set and it de/encodes a deep nested object/text,
it may raise a warning 'Deep recursion on subroutin' at the perl runtime phase.

=head2 max_size

    $json = $json->max_size([$maximum_string_size])
    
    $max_size = $json->get_max_size

Set the maximum length a JSON text may have (in bytes) where decoding is
being attempted. The default is C<0>, meaning no limit. When C<decode>
is called on a string that is longer then this many bytes, it will not
attempt to decode the string but throw an exception. This setting has no
effect on C<encode> (yet).

If no argument is given, the limit check will be deactivated (same as when
C<0> is specified).

See L<JSON::XS/SSECURITY CONSIDERATIONS> for more info on why this is useful.

=head2 encode

    $json_text = $json->encode($perl_scalar)

Converts the given Perl data structure (a simple scalar or a reference
to a hash or array) to its JSON representation. Simple scalars will be
converted into JSON string or number sequences, while references to arrays
become JSON arrays and references to hashes become JSON objects. Undefined
Perl values (e.g. C<undef>) become JSON C<null> values.
References to the integers C<0> and C<1> are converted into C<true> and C<false>.

=head2 decode

    $perl_scalar = $json->decode($json_text)

The opposite of C<encode>: expects a JSON text and tries to parse it,
returning the resulting simple scalar or reference. Croaks on error.

JSON numbers and strings become simple Perl scalars. JSON arrays become
Perl arrayrefs and JSON objects become Perl hashrefs. C<true> becomes
C<1> (C<JSON::true>), C<false> becomes C<0> (C<JSON::false>) and
C<null> becomes C<undef>.

=head2 decode_prefix

    ($perl_scalar, $characters) = $json->decode_prefix($json_text)

This works like the C<decode> method, but instead of raising an exception
when there is trailing garbage after the first JSON object, it will
silently stop parsing there and return the number of characters consumed
so far.

   JSON->new->decode_prefix ("[1] the tail")
   => ([], 3)

=head1 INCREMENTAL PARSING

Most of this section are copied and modified from L<JSON::XS/INCREMENTAL PARSING>.

In some cases, there is the need for incremental parsing of JSON texts.
This module does allow you to parse a JSON stream incrementally.
It does so by accumulating text until it has a full JSON object, which
it then can decode. This process is similar to using C<decode_prefix>
to see if a full JSON object is available, but is much more efficient
(and can be implemented with a minimum of method calls).

This module will only attempt to parse the JSON text once it is sure it
has enough text to get a decisive result, using a very simple but
truly incremental parser. This means that it sometimes won't stop as
early as the full parser, for example, it doesn't detect parenthese
mismatches. The only thing it guarantees is that it starts decoding as
soon as a syntactically valid JSON text has been seen. This means you need
to set resource limits (e.g. C<max_size>) to ensure the parser will stop
parsing in the presence if syntax errors.

The following methods implement this incremental parser.

=head2 incr_parse

    $json->incr_parse( [$string] ) # void context
    
    $obj_or_undef = $json->incr_parse( [$string] ) # scalar context
    
    @obj_or_empty = $json->incr_parse( [$string] ) # list context

This is the central parsing function. It can both append new text and
extract objects from the stream accumulated so far (both of these
functions are optional).

If C<$string> is given, then this string is appended to the already
existing JSON fragment stored in the C<$json> object.

After that, if the function is called in void context, it will simply
return without doing anything further. This can be used to add more text
in as many chunks as you want.

If the method is called in scalar context, then it will try to extract
exactly I<one> JSON object. If that is successful, it will return this
object, otherwise it will return C<undef>. If there is a parse error,
this method will croak just as C<decode> would do (one can then use
C<incr_skip> to skip the errornous part). This is the most common way of
using the method.

And finally, in list context, it will try to extract as many objects
from the stream as it can find and return them, or the empty list
otherwise. For this to work, there must be no separators between the JSON
objects or arrays, instead they must be concatenated back-to-back. If
an error occurs, an exception will be raised as in the scalar context
case. Note that in this case, any previously-parsed JSON texts will be
lost.

Example: Parse some JSON arrays/objects in a given string and return them.

    my @objs = JSON->new->incr_parse ("[5][7][1,2]");

=head2 incr_text

    $lvalue_string = $json->incr_text

This method returns the currently stored JSON fragment as an lvalue, that
is, you can manipulate it. This I<only> works when a preceding call to
C<incr_parse> in I<scalar context> successfully returned an object. Under
all other circumstances you must not call this function (I mean it.
although in simple tests it might actually work, it I<will> fail under
real world conditions). As a special exception, you can also call this
method before having parsed anything.

This function is useful in two cases: a) finding the trailing text after a
JSON object or b) parsing multiple JSON objects separated by non-JSON text
(such as commas).

    $json->incr_text =~ s/\s*,\s*//;

In Perl 5.005, C<lvalue> attribute is not available.
You must write codes like the below:

    $string = $json->incr_text;
    $string =~ s/\s*,\s*//;
    $json->incr_text( $string );

=head2 incr_skip

    $json->incr_skip

This will reset the state of the incremental parser and will remove the
parsed text from the input buffer. This is useful after C<incr_parse>
died, in which case the input buffer and incremental parser state is left
unchanged, to skip the text parsed so far and to reset the parse state.

=head2 incr_reset

    $json->incr_reset

This completely resets the incremental parser, that is, after this call,
it will be as if the parser had never parsed anything.

This is useful if you want ot repeatedly parse JSON objects and want to
ignore any trailing data, which means you have to reset the parser after
each successful decode.

See to L<JSON::XS/INCREMENTAL PARSING> for examples.


=head1 JSON::PP OWN METHODS

=head2 allow_singlequote

    $json = $json->allow_singlequote([$enable])

If C<$enable> is true (or missing), then C<decode> will accept
JSON strings quoted by single quotations that are invalid JSON
format.

    $json->allow_singlequote->decode({"foo":'bar'});
    $json->allow_singlequote->decode({'foo':"bar"});
    $json->allow_singlequote->decode({'foo':'bar'});

As same as the C<relaxed> option, this option may be used to parse
application-specific files written by humans.


=head2 allow_barekey

    $json = $json->allow_barekey([$enable])

If C<$enable> is true (or missing), then C<decode> will accept
bare keys of JSON object that are invalid JSON format.

As same as the C<relaxed> option, this option may be used to parse
application-specific files written by humans.

    $json->allow_barekey->decode('{foo:"bar"}');

=head2 allow_bignum

    $json = $json->allow_bignum([$enable])

If C<$enable> is true (or missing), then C<decode> will convert
the big integer Perl cannot handle as integer into a L<Math::BigInt>
object and convert a floating number (any) into a L<Math::BigFloat>.

On the contary, C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
objects into JSON numbers with C<allow_blessed> enable.

   $json->allow_nonref->allow_blessed->allow_bignum;
   $bigfloat = $json->decode('2.000000000000000000000000001');
   print $json->encode($bigfloat);
   # => 2.000000000000000000000000001

See to L<JSON::XS/MAPPING> aboout the normal conversion of JSON number.

=head2 loose

    $json = $json->loose([$enable])

The unescaped [\x00-\x1f\x22\x2f\x5c] strings are invalid in JSON strings
and the module doesn't allow to C<decode> to these (except for \x2f).
If C<$enable> is true (or missing), then C<decode>  will accept these
unescaped strings.

    $json->loose->decode(qq|["abc
                                   def"]|);

See L<JSON::XS/SSECURITY CONSIDERATIONS>.

=head2 escape_slash

    $json = $json->escape_slash([$enable])

According to JSON Grammar, I<slash> (U+002F) is escaped. But default
JSON::PP (as same as JSON::XS) encodes strings without escaping slash.

If C<$enable> is true (or missing), then C<encode> will escape slashes.

=head2 indent_length

    $json = $json->indent_length($length)

JSON::XS indent space length is 3 and cannot be changed.
JSON::PP set the indent space length with the given $length.
The default is 3. The acceptable range is 0 to 15.

=head2 sort_by

    $json = $json->sort_by($function_name)
    $json = $json->sort_by($subroutine_ref)

If $function_name or $subroutine_ref are set, its sort routine are used
in encoding JSON objects.

   $js = $pc->sort_by(sub { $JSON::PP::a cmp $JSON::PP::b })->encode($obj);
   # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);

   $js = $pc->sort_by('own_sort')->encode($obj);
   # is($js, q|{"a":1,"b":2,"c":3,"d":4,"e":5,"f":6,"g":7,"h":8,"i":9}|);

   sub JSON::PP::own_sort { $JSON::PP::a cmp $JSON::PP::b }

As the sorting routine runs in the JSON::PP scope, the given
subroutine name and the special variables C<$a>, C<$b> will begin
'JSON::PP::'.

If $integer is set, then the effect is same as C<canonical> on.

=head1 INTERNAL

For developers.

=over

=item PP_encode_box

Returns

        {
            depth        => $depth,
            indent_count => $indent_count,
        }


=item PP_decode_box

Returns

        {
            text    => $text,
            at      => $at,
            ch      => $ch,
            len     => $len,
            depth   => $depth,
            encoding      => $encoding,
            is_valid_utf8 => $is_valid_utf8,
        };

=back

=head1 MAPPING

This section is copied from JSON::XS and modified to C<JSON::PP>.
JSON::XS and JSON::PP mapping mechanisms are almost equivalent.

See to L<JSON::XS/MAPPING>.

=head2 JSON -> PERL

=over 4

=item object

A JSON object becomes a reference to a hash in Perl. No ordering of object
keys is preserved (JSON does not preserver object key ordering itself).

=item array

A JSON array becomes a reference to an array in Perl.

=item string

A JSON string becomes a string scalar in Perl - Unicode codepoints in JSON
are represented by the same codepoints in the Perl string, so no manual
decoding is necessary.

=item number

A JSON number becomes either an integer, numeric (floating point) or
string scalar in perl, depending on its range and any fractional parts. On
the Perl level, there is no difference between those as Perl handles all
the conversion details, but an integer may take slightly less memory and
might represent more values exactly than floating point numbers.

If the number consists of digits only, C<JSON> will try to represent
it as an integer value. If that fails, it will try to represent it as
a numeric (floating point) value if that is possible without loss of
precision. Otherwise it will preserve the number as a string value (in
which case you lose roundtripping ability, as the JSON number will be
re-encoded toa JSON string).

Numbers containing a fractional or exponential part will always be
represented as numeric (floating point) values, possibly at a loss of
precision (in which case you might lose perfect roundtripping ability, but
the JSON number will still be re-encoded as a JSON number).

Note that precision is not accuracy - binary floating point values cannot
represent most decimal fractions exactly, and when converting from and to
floating point, C<JSON> only guarantees precision up to but not including
the leats significant bit.

When C<allow_bignum> is enable, the big integers 
and the numeric can be optionally converted into L<Math::BigInt> and
L<Math::BigFloat> objects.

=item true, false

These JSON atoms become C<JSON::PP::true> and C<JSON::PP::false>,
respectively. They are overloaded to act almost exactly like the numbers
C<1> and C<0>. You can check wether a scalar is a JSON boolean by using
the C<JSON::is_bool> function.

   print JSON::PP::true . "\n";
    => true
   print JSON::PP::true + 1;
    => 1

   ok(JSON::true eq  '1');
   ok(JSON::true == 1);

C<JSON> will install these missing overloading features to the backend modules.


=item null

A JSON null atom becomes C<undef> in Perl.

C<JSON::PP::null> returns C<unddef>.

=back


=head2 PERL -> JSON

The mapping from Perl to JSON is slightly more difficult, as Perl is a
truly typeless language, so we can only guess which JSON type is meant by
a Perl value.

=over 4

=item hash references

Perl hash references become JSON objects. As there is no inherent ordering
in hash keys (or JSON objects), they will usually be encoded in a
pseudo-random order that can change between runs of the same program but
stays generally the same within a single run of a program. C<JSON>
optionally sort the hash keys (determined by the I<canonical> flag), so
the same datastructure will serialise to the same JSON text (given same
settings and version of JSON::XS), but this incurs a runtime overhead
and is only rarely useful, e.g. when you want to compare some JSON text
against another for equality.


=item array references

Perl array references become JSON arrays.

=item other references

Other unblessed references are generally not allowed and will cause an
exception to be thrown, except for references to the integers C<0> and
C<1>, which get turned into C<false> and C<true> atoms in JSON. You can
also use C<JSON::false> and C<JSON::true> to improve readability.

   to_json [\0,JSON::PP::true]      # yields [false,true]

=item JSON::PP::true, JSON::PP::false, JSON::PP::null

These special values become JSON true and JSON false values,
respectively. You can also use C<\1> and C<\0> directly if you want.

JSON::PP::null returns C<undef>.

=item blessed objects

Blessed objects are not directly representable in JSON. See the
C<allow_blessed> and C<convert_blessed> methods on various options on
how to deal with this: basically, you can choose between throwing an
exception, encoding the reference as if it weren't blessed, or provide
your own serialiser method.

See to L<convert_blessed>.

=item simple scalars

Simple Perl scalars (any scalar that is not a reference) are the most
difficult objects to encode: JSON::XS and JSON::PP will encode undefined scalars as
JSON C<null> values, scalars that have last been used in a string context
before encoding as JSON strings, and anything else as number value:

   # dump as number
   encode_json [2]                      # yields [2]
   encode_json [-3.0e17]                # yields [-3e+17]
   my $value = 5; encode_json [$value]  # yields [5]

   # used as string, so dump as string
   print $value;
   encode_json [$value]                 # yields ["5"]

   # undef becomes null
   encode_json [undef]                  # yields [null]

You can force the type to be a string by stringifying it:

   my $x = 3.1; # some variable containing a number
   "$x";        # stringified
   $x .= "";    # another, more awkward way to stringify
   print $x;    # perl does it for you, too, quite often

You can force the type to be a number by numifying it:

   my $x = "3"; # some variable containing a string
   $x += 0;     # numify it, ensuring it will be dumped as a number
   $x *= 1;     # same thing, the choise is yours.

You can not currently force the type in other, less obscure, ways.

Note that numerical precision has the same meaning as under Perl (so
binary to decimal conversion follows the same rules as in Perl, which
can differ to other languages). Also, your perl interpreter might expose
extensions to the floating point numbers of your platform, such as
infinities or NaN's - these cannot be represented in JSON, and it is an
error to pass those in.

=item Big Number

When C<allow_bignum> is enable, 
C<encode> converts C<Math::BigInt> objects and C<Math::BigFloat>
objects into JSON numbers.


=back

=head1 UNICODE HANDLING ON PERLS

If you do not know about Unicode on Perl well,
please check L<JSON::XS/A FEW NOTES ON UNICODE AND PERL>.

=head2 Perl 5.8 and later

Perl can handle Unicode and the JSON::PP de/encode methods also work properly.

    $json->allow_nonref->encode(chr hex 3042);
    $json->allow_nonref->encode(chr hex 12345);

Reuturns C<"\u3042"> and C<"\ud808\udf45"> respectively.

    $json->allow_nonref->decode('"\u3042"');
    $json->allow_nonref->decode('"\ud808\udf45"');

Returns UTF-8 encoded strings with UTF8 flag, regarded as C<U+3042> and C<U+12345>.

Note that the versions from Perl 5.8.0 to 5.8.2, Perl built-in C<join> was broken,
so JSON::PP wraps the C<join> with a subroutine. Thus JSON::PP works slow in the versions.


=head2 Perl 5.6

Perl can handle Unicode and the JSON::PP de/encode methods also work.

=head2 Perl 5.005

Perl 5.005 is a byte sementics world -- all strings are sequences of bytes.
That means the unicode handling is not available.

In encoding,

    $json->allow_nonref->encode(chr hex 3042);  # hex 3042 is 12354.
    $json->allow_nonref->encode(chr hex 12345); # hex 12345 is 74565.

Returns C<B> and C<E>, as C<chr> takes a value more than 255, it treats
as C<$value % 256>, so the above codes are equivalent to :

    $json->allow_nonref->encode(chr 66);
    $json->allow_nonref->encode(chr 69);

In decoding,

    $json->decode('"\u00e3\u0081\u0082"');

The returned is a byte sequence C<0xE3 0x81 0x82> for UTF-8 encoded
japanese character (C<HIRAGANA LETTER A>).
And if it is represented in Unicode code point, C<U+3042>.

Next, 

    $json->decode('"\u3042"');

We ordinary expect the returned value is a Unicode character C<U+3042>.
But here is 5.005 world. This is C<0xE3 0x81 0x82>.

    $json->decode('"\ud808\udf45"');

This is not a character C<U+12345> but bytes - C<0xf0 0x92 0x8d 0x85>.


=head1 TODO

=over

=item speed

=item memory saving

=back


=head1 SEE ALSO

Most of the document are copied and modified from JSON::XS doc.

L<JSON::XS>

RFC4627 (L<http://www.ietf.org/rfc/rfc4627.txt>)

=head1 AUTHOR

Makamaka Hannyaharamitu, E<lt>makamaka[at]cpan.orgE<gt>


=head1 COPYRIGHT AND LICENSE

Copyright 2007-2013 by Makamaka Hannyaharamitu

This library is free software; you can redistribute it and/or modify
it under the same terms as Perl itself. 

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/share/perl/5.20.2/Locale/                                                                       0040755 0000000 0000000 00000000000 13077704254 014061  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Locale/Codes/                                                                 0040755 0000000 0000000 00000000000 13077704254 015116  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/perl/5.20.2/Locale/Codes/API.pod                                                          0100644 0000000 0000000 00000025377 12744441327 016245  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::API - a description of the callable function in each module

=head1 DESCRIPTION

Although there are several modules in the Locale-Codes distribution, all of them
(as of version 3.10) use exactly the same API.  As a matter of fact, each of the
main callable modules are just wrappers around a central module which does all
the real work.

=head1 ROUTINES

In order to maintain the documentation for the modules consistently,
the functions are all documented here, rather than in the documentation
for the separate modules.

The name of the function depends on the module. For example, every module
contains a function "code2XXX" where XXX refers to the type of data.
The values of XXX are described in the following table:

   XXX       MODULE

   country   Locale::Codes::Country
   language  Locale::Codes::Language
   currency  Locale::Codes::Currency
   script    Locale::Codes::Script
   langext   Locale::Codes::LangExt
   langvar   Locale::Codes::LangVar
   langfam   Locale::Codes::LangFAM

So, the Locale::Country module contains the function code2country, the
Locale::Language module contains the function code2language, etc.

In all of the functions below, CODE refers to a code for one element in
the code set. For example, in the two-letter country codes from ISO 3166-1,
the code 'fi' is used to refer to the country Finland. CODE is always
case insensitive (though when a code is returned, it will always be in
the case as used in the standard), so 'fi', 'FI', and 'Fi' would all
be equivalent.

CODESET refers to a constant specified in the documentation for each
module to label the various code sets. For example, in the
Locale::Language module, CODESET could be LOCALE_CODE_ALPHA_2 or
LOCALE_CODE_ALPHA_3 (among others). Most functions have a default one,
so they do not need to be specified. So the following calls are valid:

   code2country("fi");
   code2country("fi",LOCALE_CODE_ALPHA_2);
   code2country("fin",LOCALE_CODE_ALPHA_3);

Since LOCALE_CODE_ALPHA_2 is the default code set, the first two are
identical.

=over 4

=item B<code2XXX ( CODE [,CODESET] [,'retired'] )>

These functions take a code and returns a string which contains
the name of the element identified.  If the code is not a valid
code in the CODESET specified then C<undef> will be returned.

The name of the element is the name as specified in the standard,
and as a result, different variations of an element name may
be returned for different values of CODESET.

For example, the B<alpha-2> country code set defines the two-letter
code "bo" to be "Bolivia, Plurinational State of", whereas the
B<alpha-3> code set defines the code 'bol' to be the country "Bolivia
(Plurinational State of)". So:

   code2country('bo',LOCALE_CODE_ALPHA_2);
      => 'Bolivia, Plurinational State of'

   code2country('bol',LOCALE_CODE_ALPHA_3);
      => 'Bolivia (Plurinational State of)'

By default, only active codes will be used, but if the string
'retired' is passed in as an argument, both active and retired
codes will be examined.

=item B<XXX2code ( NAME [,CODESET] [,'retired'] )>

These functions takes the name of an element (or any of it's aliases)
and returns the code that corresponds to it, if it exists. If NAME
could not be identified as the name of one of the elements, then
C<undef> will be returned.

The name is not case sensitive. Also, any known variation of a name
may be passed in.

For example, even though the country name returned using
LOCALE_CODE_ALPHA_2 and LOCALE_CODE_ALPHA_3 country codes for Bolivia is different,
either country name may be passed in since for each code set, in addition to
the alias 'Bolivia'. So:

   country2code('Bolivia, Plurinational State of',
                LOCALE_CODE_ALPHA_2);
      => bo

   country2code('Bolivia (Plurinational State of)',
                LOCALE_CODE_ALPHA_2);
      => bo

   country2code('Bolivia',LOCALE_CODE_ALPHA_2);
      => bo

By default, only active names will be used, but if the string
'retired' is passed in as an argument, both active and retired
names will be examined.

=item B<XXX_code2code ( CODE ,CODESET ,CODESET2 )>

These functions takes a code from one code set, and returns the
corresponding code from another code set. CODE must exists in the code
set specified by CODESET and must have a corresponding code in the
code set specified by CODESET2 or C<undef> will be returned.

Both CODESETs must be explicitly entered.

   country_code2code('fin', LOCALE_CODE_ALPHA_3,
                     LOCALE_CODE_ALPHA_2);
      => 'fi'

Note that this function does NOT support retired codes.

=item B<all_XXX_codes ( [CODESET] [,'retired'] )>

These returns a list of all code in the code set. The codes will be
sorted.

By default, only active codes will be returned, but if the string
'retired' is passed in as an argument, both active and retired
codes will be returned.

=item B<all_XXX_names ( [CODESET] [,'retired'] )>

These return a list of all elements names for which there is a
corresponding code in the specified code set.

The names returned are exactly as they are specified in the standard,
and are sorted.

Since not all elements are listed in all code sets, the list of
elements may differ depending on the code set specified.

By default, only active names will be returned, but if the string
'retired' is passed in as an argument, both active and retired
names will be returned.

=back

=head1 SEMI-PRIVATE ROUTINES

Additional semi-private routines which may be used to modify the
internal data are also available.  Given their status, they aren't
exported, and so need to be called by prefixing the function name with
the package name.

These routines do not currently work with retired codes.

=over 4

=item B<MODULE::rename_XXX  ( CODE ,NEW_NAME [,CODESET] )>

These routines are used to change the official name of an element. At
that point, the name returned by the code2XXX routine would be
NEW_NAME instead of the name specified in the standard.

The original name will remain as an alias.

For example, the official country name for code 'gb' is 'United
Kingdom'.  If you want to change that, you might call:

   Locale::Codes::Country::rename_country('gb', 'Great Britain');

This means that calling code2country('gb') will now return 'Great
Britain' instead of 'United Kingdom'.

If any error occurs, a warning is issued and 0 is returned. An error
occurs if CODE doesn't exist in the specified code set, or if
NEW_NAME is already in use but for a different element.

If the routine succeeds, 1 is returned.

=item B<MODULE::add_XXX  ( CODE ,NAME [,CODESET] )>

These routines are used to add a new code and name to the data.

Both CODE and NAME must be unused in the data set or an error
occurs (though NAME may be used in a different data set).

For example, to create the fictitious country named "Duchy of
Grand Fenwick" with codes "gf" and "fen", use the following:

   Locale::Codes::Country::add_country("fe","Duchy of Grand Fenwick",
                                LOCALE_CODE_ALPHA_2);

   Locale::Codes::Country::add_country("fen","Duchy of Grand Fenwick",
                                LOCALE_CODE_ALPHA_3);

The return value is 1 on success, 0 on an error.

=item B<MODULE::delete_XXX  ( CODE [,CODESET] )>

These routines are used to delete a code from the data.

CODE must refer to an existing code in the code set.

The return value is 1 on success, 0 on an error.

=item B<MODULE::add_XXX_alias  ( NAME ,NEW_NAME )>

These routines are used to add a new alias to the data. They do
not alter the return value of the code2XXX function.

NAME must be an existing element name, and NEW_NAME must
be unused or an error occurs.

The return value is 1 on success, 0 on an error.

=item B<MODULE::delete_XXX_alias  ( NAME )>

These routines are used to delete an alias from the data. Once
removed, the element may not be referred to by NAME.

NAME must be one of a list of at least two names that may be used to
specify an element. If the element may only be referred to by a single
name, you'll need to use the add_XXX_alias function to add a new alias
first, or the remove_XXX function to remove the element entirely.

If the alias is used as the name in any code set, one of the other
names will be used instead. Predicting exactly which one will
be used requires you to know the order in which the standards
were read, which is not reliable, so you may want to use the
rename_XXX function to force one of the alternate names to be
used.

The return value is 1 on success, 0 on an error.

=item B<MODULE::rename_XXX_code  ( CODE ,NEW_CODE [,CODESET] )>

These routines are used to change the official code for an element. At
that point, the code returned by the XXX2code routine would be
NEW_CODE instead of the code specified in the standard.

NEW_CODE may either be a code that is not in use, or it may be an
alias for CODE (in which case, CODE becomes and alias and NEW_CODE
becomes the "real" code).

The original code is kept as an alias, so that the code2XXX routines
will work with either the code from the standard or the new code.

However, the all_XXX_codes routine will only return the codes which
are considered "real" (which means that the list of codes will now
contain NEW_CODE, but will not contain CODE).

=item B<MODULE::add_XXX_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

These routines add an alias for the code. At that point, NEW_CODE and CODE
will both work in the code2XXX routines. However, the XXX2code routines will
still return the original code.

=item B<MODULE::delete_XXX_code_alias  ( CODE [,CODESET] )>

These routines delete an alias for the code.

These will only work if CODE is actually an alias. If it is the "real"
code, it will not be deleted. You will need to use the rename_XXX_code
function to switch the real code with one of the aliases, and then
delete the alias.

=back

=head1 KNOWN BUGS AND LIMITATIONS

=over 4

=item B<Relationship between code sets>

Because each code set uses a slightly different list of elements, and
they are not necessarily one-to-one, there may be some confusion
about the relationship between codes from different code sets.

For example, ISO 3166 assigns one code to the country "United States
Minor Outlying Islands", but the IANA codes give different codes
to different islands (Baker Island, Howland Island, etc.).

This may cause some confusion... I've done the best that I could do
to minimize it.

=item B<Non-ASCII characters not supported>

Currently all names must be all ASCII. I plan on relaxing that
limitation in the future.

=back

=head1 SEE ALSO

Locale::Codes

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Locale/Codes/Changes.pod                                                      0100644 0000000 0000000 00000045637 12744441327 017205  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::Changes - details changes to Locale::Codes

=head1 SYNOPSIS

This describes the changes made to modules in the Locale-Codes
distribution.  Major changes are marked with asterisks (*).  For the
most part, all modules have remained backward compatible at every
release, but occasionally a change is made which is backward
incompatible. These are marked with an exclamation mark (!).

As of 3.00, the codes are autogenerated from the standards. With each
release, codes will be re-generated and tested to see if any code
changed. Any time there are any changes to the codes, it will be
flagged below with a change: NEW CODE(s).

I intend to check for new codes four times a year (March, June,
September, December). I will also check on request, so if a code
changes that you use, feel free to contact me.  Any time there are new
codes, I will add them to the module and release a new version.

=head1 VERSION 3.33  (planned 2014-12-01; sbeck)

=head1 VERSION 3.32  (planned 2014-09-01; sbeck)

=head1 VERSION 3.31  (planned 2014-06-01; sbeck)

=head1 VERSION 3.30  (2014-03-04; sbeck)

NEW CODE(s)

=over 4

=item B<alias_code remove date set>

The alias_code function exists for backward compatibility.  It has been
deprecated since version 3.20 when it was replaced by rename_country_code.
The alias_code function will be removed in the December 2014 release.

=item B<Bug fixes>

Fixed a problem that was preventing rename_* functions to not work.
RT 92680.

=back

=head1 VERSION 3.29  (2014-01-27; sbeck)

NEW CODE(s)

=over 4

=item B<ISO 3166 country codes improved>

ISO 3166 is now browsable online (previously, only the alpha-2 codes were)
and it contains more accurate information than the previous sources, so
I've switched to using the full standard.  In response to RT 92303 which
reported some codes being 'retired' that should not have been.

=item B<Bug fixes>

Fixed the pod test files so that pod tests won't get run at install
time.  In response to RT 91167.

=back

=head1 VERSION 3.28  (2013-12-02; sbeck)

NEW CODE(s)

=head1 VERSION 3.27  (2013-09-03; sbeck)

NEW CODE(s)

=over 4

=item B<* FIPS-10 country codes removed>

As of June, the FIPS codes are not being published in their
entirety.  Only changes to the codes are published.  This adds
a huge layer of complexity to maintaining the set, which is not
worth doing considering that the set is deprecated.  As such, the
code set is no longer supported.

=back

=head1 VERSION 3.26  (2013-06-03; sbeck)

=over 4

=item B<Documentation fixes>

Some of the examples were not correct.  RT 84589

Some typos corrected.  RT 85692

=back

=head1 VERSION 3.25  (2013-03-01; sbeck)

NEW CODE(s)

=head1 VERSION 3.24  (2012-12-03; sbeck)

NEW CODE(s)

=over 4

=item B<Syria alias>

Syria added as an alias.  RT 82747

=item B<FIPS-10 country codes deprecated>

The FIPS-10 document is being withdrawn.  It was deprecated in 2008,
and is being updated now only until all the agencies that use it have
switched to something else.  The current version no longer lists the
long names for countries.  These long names (such as 'Republic of
Albania' for Albania) only appeared in the old FIPS-10 document which
is no longer available, so they are no longer available in this module.

I will continue to support the FIPS-10 codeset as long as it is available,
but at that point, it will be withdrawn immediately.  If an official
end-of-life date is announced, I will include a notice here.  Otherwise, support
for the codeset will be discontinued when the document is withdrawn.

You are encouraged to no longer use the FIPS-10 codeset.

=item B<Domain country codes now come from ISO 3166>

The IANA domain codes have changed slightly.  The IANA no longer
publishes a list of countries associated with their codes.  Instead,
they use the ISO 3166 codes and country names.  However, they support
a few non-standard codes, so I will continue to maintain this codeset.
The domain codes are now lowercase to correspond to the ISO 3166 codes.

=back

=head1 VERSION 3.23  (2012-09-01; sbeck)

NEW CODE(s)

=head1 VERSION 3.22  (2012-06-01; sbeck)

NEW CODE(s)

=over 4

=item B<Updated perl version required>

Changed 'require 5.002' (which dated back to the version 2.xx Locale-Codes)
to 'require 5.006'.  Some features used in Locale-Codes are not supported that
far back.  Nicholas Clark

=item B<Sorted deprecated codes>

The codes in the generated deprecated codes modules were not sorted making version
diffs bigger than they should be.  Nicholas Clark

=back

=head1 VERSION 3.21  (2012-03-01; sbeck)

NEW CODE(s)

=head1 VERSION 3.20  (2011-12-01; sbeck)

NEW CODE(s)

=over 4

=item B<Added limited support for deprecated codes>

The code2XXX, XXX2code, all_XXX_codes, and all_XXX_names functions
now support retired codes.  RT 71124

=item B<Fixed capitalization>

The 'South Sudan' country was all caps.  RT 71024

=item B<Pod tests off by default>

The pod tests will not run at install time.  RT 71122

=item B<Codesets may be specified by name>

All codesets may be specified by a constant or by their name now.  Previously,
they were specified only by a constant.

=item B<alias_code deprecated>

The alias_code function exists for backward compatibility.  It has been replaced
by rename_country_code .  The alias_code function will be removed sometime
after September, 2013 .

=item B<Code cleanup>

All work is now done in the central module (Locale::Codes).  Previously, some
was still done in the wrapper modules (Locale::Codes::*) but that is gone now.

=item B<Added LangFam module>

Added Language Family codes (langfam) as defined in ISO 639-5.

=back

=head1 VERSION 3.18  (2011-08-31; sbeck)

NEW CODE(s)

=over 4

=item B<No longer use CIA data>

The CIA world added non-standard values, so I no longer use it as
a source of data.  Based on a report by Michiel Beijen.

=back

=head1 VERSION 3.17  (2011-06-28; sbeck)

NEW CODE(s)

=over 4

=item B<Added new types of codes>

Added Language Extension codes (langext) and Language Variation codes
(langvar) as defined in the IANA language registry.

=item B<Added new codeset(s)>

Added language codes from ISO 639-5

Added language/script codes from the IANA language subtag
registry

=item B<Bug fixes>

Fixed an uninitialized value warning.  RT 67438

Fixed the return value for the all_XXX_codes and all_XXX_names functions.  RT 69100

=item B<Reorganized code>

Reorganized modules to move Locale::MODULE to Locale::Codes::MODULE to
allow for cleaner future additions.  The original four modules (Locale::Language,
Locale::Currency, Locale::Country, Locale::Script) will continue to work, but
all new sets of codes will be added in the Locale::Codes namespace.

=back

=head1 VERSION 3.16  (2011-03-01; sbeck)

NEW CODE(s)

=head1 VERSION 3.15  (2010-12-02; sbeck)

NEW CODE(s)

=over 4

=item B<Minor fixes>

Added version number to Makefile.PL/Build.PL requirement
for POD testing modules.  RT 62247

Changed 'use vars' to 'our'

=back

=head1 VERSION 3.14  (2010-09-28; sbeck)

NEW CODE(s)

=over 4

=item B<Bug fixes>

Stripped out some HTML that got included with some codes.

=back

=head1 VERSION 3.13  (2010-06-04; sbeck)

NEW CODE(s)

=head1 VERSION 3.12  (2010-04-06; sbeck)

NEW CODE(s)

=over 4

=item B<Reorganized code>

Renamed test.pl to testfunc.pl to avoid causing an error
when built as part of perl.

=back

=head1 VERSION 3.11  (2010-03-01; sbeck)

NEW CODE(s)

=over 4

=item B<Added new codeset(s)>

Added the IANA domain names to Country

=item B<Bug fixes>

Fixed a problem that produced warnings with perl 5.11.5.
Jerry D. Hedden

=back

=head1 VERSION 3.10  (2010-02-18; sbeck)

NEW CODE(s)

=over 4

=item B<Reorganized code>

Moved support files into the Locale::Codes namespace.

The work done in each of the Locale::XXX modules was virtually
identical to each other. It has all been moved to a central module and
the Locale::XXX modules are now just wrappers.

=item B<(!) Changed XXX_code2code behavior slightly>

In previous versions, passing in the same code set for both code set
arguments would automatically return undef. For example:

   country_code2code('bo',LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
      => undef

This doesn't seem like reasonable behavior, so it has been changed
to allow the same code set:

   country_code2code('bo',LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
      => 'bo'

Note that if an invalid code is passed in, undef will still be
returned:

   country_code2code('bol',LOCALE_CODE_ALPHA_2,LOCALE_CODE_ALPHA_2);
      => undef

=item B<Added many semi-private routines>

Previous versions had only two semi-private routines: rename_country
and alias_code which had the ability to modify the internal data in
a couple very limited ways. It was requested (in an anonymous posting
by someone named Steve and also by Steve Hay) that better support
for modifying internal data, so a full set of routines were added.

The full set of routines includes:

   rename_country
   rename_language
   rename_currency
   rename_script

   add_country
   add_language
   add_currency
   add_script

   delete_country
   delete_language
   delete_currency
   delete_script

   add_country_alias
   add_language_alias
   add_currency_alias
   add_script_alias

   delete_country_alias
   delete_language_alias
   delete_currency_alias
   delete_script_alias

   rename_country_code
   rename_language_code
   rename_currency_code
   rename_script_code

   add_country_code_alias
   add_language_code_alias
   add_currency_code_alias
   add_script_code_alias

   delete_country_code_alias
   delete_language_code_alias
   delete_currency_code_alias
   delete_script_code_alias

=item B<New aliases>

Added "UK" alias. Steve Hay

=back

=head1 VERSION 3.01  (2010-02-15; sbeck)

=over 4

=item B<Fixed Makefile.PL and Build.PL>

They now install as core modules as they are supposed to.  Reported in
RT 54526

=back

=head1 VERSION 3.00  (2010-02-10; sbeck)

NEW CODE(s)

=over 4

=item B<(*) New maintainer>

From 1997 to 2004, Locale::Codes was maintained by Neil
Bowers. Unfortunately, no updates were made from June 2004 to January
2010. During that time, a number of changes have been made to the
standards since then, so the data included was out-of-date.

I contacted Neil to get his permission to assume maintenance of
the module, and he kindly agreed.

=item B<(*) (!) All codes are generated from standards>

All of the values returned by the various functions are now values
directly from the standards. This means that the values returned in
the 2.xx series are not necessarily the same as the values returned
here.

As an example, the ISO 3166 standard which lists country codes refers
to the country associated with the code "bo" as "Bolivia,
Plurinational State of", so that is what is returned. In the 2.xx
series, "Bolivia" was returned.  Also, the country names vary from one
standard to another. So the code "bol" which is maintained by the
United Nations returns the name of the country as "Bolivia
(Plurinational State of)". Some common aliases have been added, so you
can still request a code associated with a county name "Bolivia".

Since the data comes from the standards, some "incorrect" values are
no longer supported. For example, 2.07 treated "Zaire" as an alias for
"Congo", but the country changed it's name, and "Zaire" is not in the
standard, so it has been dropped in 3.00.

=item B<Added new codeset(s)>

FIPS 10 country codes (requested in RT 1755)

Alpha-3 and Term language codes (requested in RT 11730)

Numeric currency codes (requested in RT 18797)

=item B<(*) (!) Locale::Script changed>

In 2.xx, Locale::Script assigned scripts to country codes, which is NOT
how it is done currently in the standards. It appears that an older version
of ISO 15924 did this, but I haven't found an old version to confirm
that, and in any case, that is not the case in the current standards.

As a result, the Locale::Script module is completely incompatible with
the 2.xx version with respect to the types of codes it supports. None of
the old codes will work.

=item B<Added missing functions>

I've added in some functions which were "missing" previously (since there was
only one set of codes supported, the code2code functions didn't apply):

   language_code2code
   currency_code2code

so the interfaces for each type of codes are consistent.

=item B<(!) Dropped support for _alias_code>

In Locale::Country, _alias_code was an allowed, but deprecated function
which was documented to be supported in the 2.xx series. I've removed it.

=item B<(!) All functions return the standard value>

code2country (and other equivalent functions) now returns the name of
the country specified in the standard (if the different standards
refer to the country by different variations in the name, the results
will differ based on the CODESET)

=item B<(!) rename_country function altered>

The rename_country function from 2.07 would guess the CODESET (unlike
all other functions which used a default of LOCALE_CODE_ALPHA_2). The
guess can cause problems since (with the addition of FIPS) codes may
appear in different codesets for different countries. The behavior has
been changed to be the same as other functions (default to
LOCALE_CODE_ALPHA_2).

=back

=head1 VERSION 2.07  (2004-06-10; neilb)

Made $_ local in the initialization code for each module
change back-propagated from Perl distribution

Removed two non ISO-8859-1 characters from language names
change back-propagated from Perl distribution

Added the following aliases, with a test case for each
   - Burma added to Myanmar
   - French Southern and Antarctic Lands to
     French Southern Territories
patch from TJ Mather

"Canadian Dollar" was misspelled as "Candian Dollar"
   - noted by Nick Cabatoff, patch from Michael Hennecke

Changes to Locale::Country reflecting changes in ISO 3166
   - added Aland Islands (ax, ala, 248)
   - YUGOSLAVIA is now SERBIA AND MONTENEGRO
      YU => CS
      YUG => SCG
      891 => 891 (unchanged)
      (YUGOSLAVIA retained as an alias)
   - EAST TIMOR changed to TIMOR-LESTE
      (old name retained as an alias)
   - three letter code for Romania changed from ROM to ROU

ZAIRE is now CONGO, THE DEMOCRATIC REPUBLIC OF THE
    ZR  => CD
    ZAR => COD
    180 => 180 (unchanged)
    (ZAIRE retained as alias)

=head1 VERSION 2.06  (2002-07-15; neilb)

The four modules which have data after __DATA__ weren't closing the
DATA filehandle after reading from it, which they should. Bug and
patch from Steve Hay.

=head1 VERSION 2.05  (2002-07-08; neilb)

Added three letter codes for the countries that were missing
them. Patch from TJ Mather.

Documentation bug: one of the examples used => where the
lvalue was a constant, which isn't allowed, unless you
put the () with the constant to force the right interpretation.
Pointed out by TJ Mather and MYT.

Updated the URL for the appendix in the CIA world factbook.
Patch from TJ Mather.

=head1 VERSION 2.04  (2002-05-23; neilb)

Updated according to changes in ISO 3166-1 described
in ISO 3166-1 newsletters V-4 and V-5, dated 2002-05-20:
   - Kazakstan is now "Kazakhstan"
   - Macau is now "Macao"
The old names are retained as aliases.

The alpha-2 and alpha-3 codes for East Timor have changed:
   tp -> tl
   tmp -> tls
the numeric code stays 626. If you want to support the old
codes, you can use the semi-private function alias_code().

=head1 VERSION 2.03  (2002-03-24; neilb)

Fixed a typo in the alias for the Vatican, reported (with patch)
by Philip Newton.

Added "Moldova" as an alias for "Moldova, Republic of"

Updated Makefile.PL to include AUTHOR and ABSTRACT

=head1 VERSION 2.02  (2002-03-09; neilb)

Added semi-private routine rename_country() to Locale::Country,
based on a patch from Iain Chalmers.

Added test rename.t for the above function.

Renamed _alias_code to be alias_code. Have retained the old
name for backwards compatibility. Will remove it when the
major version number next changes.

=head1 VERSION 2.01  (2002-02-18; neilb)

Split the documentation for all modules into separate pod files.

Made sure all =over were =over 4; some were other values.

The code2code() methods had one more shift than was needed.

=head1 VERSION 2.00  (2002-02-17; neilb)

Created Locale::Script which provides an interface to the ISO codes
for identification of scripts (writing scripts, rather than perl style
scripts). The codes are defined by ISO 15924, which is currently in
final draft.  Thanks to Jarkko for pointing out this new standard.
All three code sets are supported, and a test-suite added.

Added support for country name variants to Locale::Country,
so that
   country2code('USA')
   country2code('United States')
   country2code('United States of America')
will all return 'us'.  This had been in the LIMITATIONS section since
the first version.  Patch from TJ Mather with additional variants from
me. Added test-cases for these.

Added VERSION to Locale::Constants. Thanks to Jarkko for
pointing that it was missing.

Should really have bumped major version with previous release,
since there was a change to the API.

=head1 VERSION 1.06  (2001-03-04; neilb)

Added Locale::Constants, which defines three symbols for identifying
which codeset is being used:

   LOCALE_CODE_ALPHA_2
   LOCALE_CODE_ALPHA_3
   LOCALE_CODE_NUMERIC

Updated Locale::Country to support all three code sets defined by ISO
3166. This was requested by Keith Wall.  I haven't added multiple
codeset support to the other modules yet - I'll wait until someone
asks for them.

=head1 VERSION 1.05  (2001-02-13; neilb)

Added Locale::Currency, contribution from Michael Hennecke.

Added test suite for it (t/currency.t) and added test cases
to t/all.t for the all_* functions.

=head1 VERSION 1.04  (2000-12-21; neilb)

Fixed very minor typos from 1.03!

=head1 VERSION 1.03  (2000-12-??; neilb)

Updated Locale::Country:
   - fixed spelling of a few countries
   - added link to a relevant page from CIA world factbook

Updated Locale::Language:
   - fixed typo in the documentation (ISO 939 should be 639)

=head1 VERSION 1.02  (2000-05-04; neilb)

Updated Locale::Country and Locale::Language to reflect changes in the
relevant ISO standards. These mainly reflect languages which are new
to the relevant standard, and changes in the spelling of some country
names.

Added official URLs for the standards to the SEE ALSO sections of the
doc for each module.

Thanks to Jarkko Hietaniemi for pointing me at the pages with latest
versions of ISO 3166 and 639.

=head1 VERSION 1.00  (1998-03-09; neilb)

Added Locale::Country::_alias_code() so that 'uk' can be added as the
code for "United Kingdom", if you want it.  This was prompted by Ed
Jordan.

Added a new test suite for handling this case, and extended the
existing test-suite to include testing of the case where 'uk' hasn't
been defined as a valid code.

=head1 VERSION 0.003  (1997-05-09; neilb)

First public release to CPAN

=head1 SEE ALSO

Locale::Codes

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                 usr/share/perl/5.20.2/Locale/Codes/Constants.pm                                                     0100644 0000000 0000000 00000010204 12744441327 017421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::Constants;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
use warnings;

require Exporter;

#-----------------------------------------------------------------------
#	Public Global Variables
#-----------------------------------------------------------------------

our($VERSION,@ISA,@EXPORT);
our(%ALL_CODESETS);

$VERSION='3.30';
@ISA     = qw(Exporter);
@EXPORT  = qw(LOCALE_CODE_ALPHA_2
              LOCALE_CODE_ALPHA_3
              LOCALE_CODE_NUMERIC
              LOCALE_CODE_DOM

              LOCALE_LANG_ALPHA_2
              LOCALE_LANG_ALPHA_3
              LOCALE_LANG_TERM

              LOCALE_CURR_ALPHA
              LOCALE_CURR_NUMERIC

              LOCALE_SCRIPT_ALPHA
              LOCALE_SCRIPT_NUMERIC

              LOCALE_LANGEXT_ALPHA

              LOCALE_LANGVAR_ALPHA

              LOCALE_LANGFAM_ALPHA

              %ALL_CODESETS
            );

#-----------------------------------------------------------------------
#	Constants
#-----------------------------------------------------------------------

use constant LOCALE_CODE_ALPHA_2    => 'alpha-2';
use constant LOCALE_CODE_ALPHA_3    => 'alpha-3';
use constant LOCALE_CODE_NUMERIC    => 'numeric';
use constant LOCALE_CODE_DOM        => 'dom';

$ALL_CODESETS{'country'} = {
                            'default'  => 'alpha-2',
                            'codesets' => { 'alpha-2'  => ['lc'],
                                            'alpha-3'  => ['lc'],
                                            'numeric'  => ['numeric',3],
                                            'dom'      => ['lc'],
                                          }
                           };

use constant LOCALE_LANG_ALPHA_2    => 'alpha-2';
use constant LOCALE_LANG_ALPHA_3    => 'alpha-3';
use constant LOCALE_LANG_TERM       => 'term';

$ALL_CODESETS{'language'} = {
                             'default'  => 'alpha-2',
                             'codesets' => { 'alpha-2'  => ['lc'],
                                             'alpha-3'  => ['lc'],
                                             'term'     => ['lc'],
                                           }
                            };

use constant LOCALE_CURR_ALPHA      => 'alpha';
use constant LOCALE_CURR_NUMERIC    => 'num';

$ALL_CODESETS{'currency'} = {
                             'default'  => 'alpha',
                             'codesets' => { 'alpha'  => ['uc'],
                                             'num'    => ['numeric',3],
                                           }
                            };

use constant LOCALE_SCRIPT_ALPHA    => 'alpha';
use constant LOCALE_SCRIPT_NUMERIC  => 'num';

$ALL_CODESETS{'script'} = {
                           'default'  => 'alpha',
                           'codesets' => { 'alpha'  => ['ucfirst'],
                                           'num'    => ['numeric',3],
                                         }
                          };

use constant LOCALE_LANGEXT_ALPHA   => 'alpha';

$ALL_CODESETS{'langext'} = {
                           'default'  => 'alpha',
                           'codesets' => { 'alpha'  => ['lc'],
                                         }
                          };

use constant LOCALE_LANGVAR_ALPHA   => 'alpha';

$ALL_CODESETS{'langvar'} = {
                           'default'  => 'alpha',
                           'codesets' => { 'alpha'  => ['lc'],
                                         }
                          };

use constant LOCALE_LANGFAM_ALPHA   => 'alpha';

$ALL_CODESETS{'langfam'} = {
                           'default'  => 'alpha',
                           'codesets' => { 'alpha'  => ['lc'],
                                         }
                          };

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                            usr/share/perl/5.20.2/Locale/Codes/Constants.pod                                                    0100644 0000000 0000000 00000001561 12744441327 017575  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::Constants - constants for Locale codes

=head1 DESCRIPTION

B<Locale::Codes::Constants> defines symbols which are used in the other
modules from the Locale-Codes distribution.

You shouldn't have to C<use> this module directly yourself - it is
used by the other Locale modules, which in turn export the symbols.

The constants are documented in each of the Locale modules.

=head1 KNOWN BUGS AND LIMITATIONS

None known.

=head1 SEE ALSO

Locale::Codes

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

                                                                                                                                               usr/share/perl/5.20.2/Locale/Codes/Country.pm                                                       0100644 0000000 0000000 00000005171 12744441327 017117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::Country;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::Country_Codes;
use Locale::Codes::Country_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2country
                country2code
                all_country_codes
                all_country_names
                country_code2code
                LOCALE_CODE_ALPHA_2
                LOCALE_CODE_ALPHA_3
                LOCALE_CODE_NUMERIC
                LOCALE_CODE_DOM
               );

sub code2country {
   return Locale::Codes::_code2name('country',@_);
}

sub country2code {
   return Locale::Codes::_name2code('country',@_);
}

sub country_code2code {
   return Locale::Codes::_code2code('country',@_);
}

sub all_country_codes {
   return Locale::Codes::_all_codes('country',@_);
}

sub all_country_names {
   return Locale::Codes::_all_names('country',@_);
}

sub rename_country {
   return Locale::Codes::_rename('country',@_);
}

sub add_country {
   return Locale::Codes::_add_code('country',@_);
}

sub delete_country {
   return Locale::Codes::_delete_code('country',@_);
}

sub add_country_alias {
   return Locale::Codes::_add_alias('country',@_);
}

sub delete_country_alias {
   return Locale::Codes::_delete_alias('country',@_);
}

sub rename_country_code {
   return Locale::Codes::_rename_code('country',@_);
}

sub add_country_code_alias {
   return Locale::Codes::_add_code_alias('country',@_);
}

sub delete_country_code_alias {
   return Locale::Codes::_delete_code_alias('country',@_);
}

#=======================================================================
#
# Old function for backward compatibility
#
#=======================================================================

sub alias_code {
   my($alias,$code,@args) = @_;
   my $success = rename_country_code($code,$alias,@args);
   return 0  if (! $success);
   return $alias;
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/perl/5.20.2/Locale/Codes/Country.pod                                                      0100644 0000000 0000000 00000013607 12744441327 017270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::Country - standard codes for country identification

=head1 SYNOPSIS

   use Locale::Codes::Country;

   $country = code2country('jp' [,CODESET]);        # $country gets 'Japan'
   $code    = country2code('Norway' [,CODESET]);    # $code gets 'no'

   @codes   = all_country_codes( [CODESET]);
   @names   = all_country_names();

   # semi-private routines
   Locale::Codes::Country::alias_code('uk' => 'gb');
   Locale::Codes::Country::rename_country('gb' => 'Great Britain');

=head1 DESCRIPTION

The C<Locale::Codes::Country> module provides access to several code sets
that can be used for identifying countries, such as those defined in
ISO 3166-1.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
3166-1 two-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
countries. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $country = code2country('jp','alpha-2');
   $country = code2country('jp',LOCALE_CODE_ALPHA_2);

The codesets currently supported are:

=over 4

=item B<alpha-2, LOCALE_CODE_ALPHA_2>

This is the set of two-letter (lowercase) codes from ISO 3166-1, such
as 'tv' for Tuvalu.

This is the default code set.

=item B<alpha-3, LOCALE_CODE_ALPHA_3>

This is the set of three-letter (lowercase) codes from ISO 3166-1,
such as 'brb' for Barbados. These codes are actually defined and
maintained by the U.N. Statistics division.

=item B<numeric, LOCALE_CODE_NUMERIC>

This is the set of three-digit numeric codes from ISO 3166-1, such as
064 for Bhutan. These codes are actually defined and maintained by the
U.N. Statistics division.

If a 2-digit code is entered, it is converted to 3 digits by prepending
a 0.

=item B<dom, LOCALE_CODE_DOM>

The IANA is responsible for delegating management of the top level country
domains.  The country domains are the two-letter (lowercase) codes from ISO 3166
with a few other additions.

=back

NOTE: As of version 3.27, the FIPS code set is no longer supported.  See the
Locale::Codes::Changes document for details.

=head1 ROUTINES

=over 4

=item B<code2country ( CODE [,CODESET] )>

=item B<country2code ( NAME [,CODESET] )>

=item B<country_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_country_codes ( [CODESET] )>

=item B<all_country_names ( [CODESET] )>

=item B<Locale::Codes::Country::rename_country  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::Country::add_country  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::Country::delete_country  ( CODE [,CODESET] )>

=item B<Locale::Codes::Country::add_country_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::Country::delete_country_alias  ( NAME )>

=item B<Locale::Codes::Country::rename_country_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Country::add_country_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Country::delete_country_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=item B<alias_code ( ALIAS, CODE [,CODESET] )>

Version 2.07 included 2 functions for modifying the internal data:
rename_country and alias_code. Both of these could be used only to
modify the internal data for country codes.

As of 3.10, the internal data for all types of codes can be modified.

The alias_code function is preserved for backwards compatibility, but
the following two are identical:

   alias_code(ALIAS,CODE [,CODESET]);
   rename_country_code(CODE,ALIAS [,CODESET]);

and the latter should be used for consistency.

The alias_code function is deprecated and will be removed in the December
2014 release.

B<Note:> this function was previously called _alias_code, but the
leading underscore has been dropped. The old name was supported for
all 2.X releases, but has been dropped as of 3.00.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<Locale::SubCountry>

ISO codes for country sub-divisions (states, counties, provinces,
etc), as defined in ISO 3166-2.  This module is not part of the
Locale-Codes distribution, but is available from CPAN in
CPAN/modules/by-module/Locale/

=item B<http://www.iso.org/iso/home/standards/country_codes.htm>

Official home page for the ISO 3166 maintenance agency.

=item B<http://www.iso.org/iso/home/standards/country_codes/iso-3166-1_decoding_table.htm>

The source of ISO 3166-1 two-letter codes used by this
module.

=item B<http://www.iana.org/domains/root/db/>

Official source of the top-level domain names.

=item B<http://unstats.un.org/unsd/methods/m49/m49alpha.htm>

The source of the official ISO 3166-1 three-letter codes and
three-digit codes.

For some reason, this table is incomplete! Several countries are
missing from it, and I cannot find them anywhere on the UN site.  I
no longer use this as a source of data.

=item B<https://www.cia.gov/library/publications/the-world-factbook/appendix/print_appendix-d.html>

The World Factbook maintained by the CIA is a potential source of
the data.  Unfortunately, it adds/preserves non-standard codes, so it is no
longer used as a source of data.

=item B<http://www.statoids.com/wab.html>

Another unofficial source of data. Currently, it is not used to get
data, but the notes and explanatory material were very useful for
understanding discrepancies between the sources.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                         usr/share/perl/5.20.2/Locale/Codes/Country_Codes.pm                                                 0100644 0000000 0000000 00000412505 12744441327 020237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Country_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:43:45 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'country'}{'id'} = '0252';

$Locale::Codes::Data{'country'}{'id2names'} = {
   q(0001) => [
      q(Afghanistan),
      ],
   q(0002) => [
      q(Aland Islands),
      ],
   q(0003) => [
      q(Albania),
      ],
   q(0004) => [
      q(Algeria),
      ],
   q(0005) => [
      q(American Samoa),
      ],
   q(0006) => [
      q(Andorra),
      ],
   q(0007) => [
      q(Angola),
      ],
   q(0008) => [
      q(Anguilla),
      ],
   q(0009) => [
      q(Antarctica),
      ],
   q(0010) => [
      q(Antigua and Barbuda),
      ],
   q(0011) => [
      q(Argentina),
      ],
   q(0012) => [
      q(Armenia),
      ],
   q(0013) => [
      q(Aruba),
      ],
   q(0014) => [
      q(Australia),
      ],
   q(0015) => [
      q(Austria),
      ],
   q(0016) => [
      q(Azerbaijan),
      ],
   q(0017) => [
      q(Bahamas),
      q(The Bahamas),
      q(Bahamas, The),
      q(Bahamas (The)),
      ],
   q(0018) => [
      q(Bahrain),
      ],
   q(0019) => [
      q(Bangladesh),
      ],
   q(0020) => [
      q(Barbados),
      ],
   q(0021) => [
      q(Belarus),
      ],
   q(0022) => [
      q(Belgium),
      ],
   q(0023) => [
      q(Belize),
      ],
   q(0024) => [
      q(Benin),
      ],
   q(0025) => [
      q(Bermuda),
      ],
   q(0026) => [
      q(Bhutan),
      ],
   q(0027) => [
      q(Bolivia, Plurinational State of),
      q(Bolivia (Plurinational State of)),
      q(Plurinational State of Bolivia),
      q(Bolivia),
      ],
   q(0028) => [
      q(Bonaire, Sint Eustatius and Saba),
      ],
   q(0029) => [
      q(Bosnia and Herzegovina),
      ],
   q(0030) => [
      q(Botswana),
      ],
   q(0031) => [
      q(Bouvet Island),
      ],
   q(0032) => [
      q(Brazil),
      ],
   q(0033) => [
      q(British Indian Ocean Territory),
      q(The British Indian Ocean Territory),
      q(British Indian Ocean Territory, The),
      q(British Indian Ocean Territory (The)),
      ],
   q(0034) => [
      q(Brunei Darussalam),
      q(Brunei),
      ],
   q(0035) => [
      q(Bulgaria),
      ],
   q(0036) => [
      q(Burkina Faso),
      ],
   q(0037) => [
      q(Burundi),
      ],
   q(0038) => [
      q(Cambodia),
      ],
   q(0039) => [
      q(Cameroon),
      ],
   q(0040) => [
      q(Canada),
      ],
   q(0041) => [
      q(Cape Verde),
      ],
   q(0042) => [
      q(Cayman Islands),
      q(The Cayman Islands),
      q(Cayman Islands, The),
      q(Cayman Islands (The)),
      ],
   q(0043) => [
      q(Central African Republic),
      q(The Central African Republic),
      q(Central African Republic, The),
      q(Central African Republic (The)),
      ],
   q(0044) => [
      q(Chad),
      ],
   q(0045) => [
      q(Chile),
      ],
   q(0046) => [
      q(China),
      ],
   q(0047) => [
      q(Christmas Island),
      ],
   q(0048) => [
      q(Cocos (Keeling) Islands),
      q(The Cocos (Keeling) Islands),
      q(Cocos (Keeling) Islands, The),
      q(Cocos (Keeling) Islands (The)),
      q(Cocos Islands),
      q(The Cocos Islands),
      q(Keeling Islands),
      q(The Keeling Islands),
      ],
   q(0049) => [
      q(Colombia),
      ],
   q(0050) => [
      q(Comoros),
      ],
   q(0051) => [
      q(Congo),
      q(The Republic of the Congo),
      q(Republic of the Congo),
      q(Congo, The Republic of the),
      q(Congo, Republic of the),
      q(Congo-Brazzaville),
      q(Congo (Brazzaville)),
      ],
   q(0052) => [
      q(Congo (The Democratic Republic of the)),
      q(Congo, The Democratic Republic of the),
      q(Congo, Democratic Republic of the),
      q(The Democratic Republic of the Congo),
      q(Democratic Republic of the Congo),
      q(Congo-Kinshasa),
      q(Congo (Kinshasa)),
      ],
   q(0053) => [
      q(Cook Islands),
      q(The Cook Islands),
      q(Cook Islands, The),
      q(Cook Islands (The)),
      ],
   q(0054) => [
      q(Costa Rica),
      ],
   q(0055) => [
      q(Cote d'Ivoire),
      ],
   q(0056) => [
      q(Croatia),
      ],
   q(0057) => [
      q(Cuba),
      ],
   q(0058) => [
      q(Curacao),
      ],
   q(0059) => [
      q(Cyprus),
      ],
   q(0060) => [
      q(Czech Republic),
      q(The Czech Republic),
      q(Czech Republic, The),
      q(Czech Republic (The)),
      ],
   q(0061) => [
      q(Denmark),
      ],
   q(0062) => [
      q(Djibouti),
      ],
   q(0063) => [
      q(Dominica),
      ],
   q(0064) => [
      q(Dominican Republic),
      q(The Dominican Republic),
      q(Dominican Republic, The),
      q(Dominican Republic (The)),
      ],
   q(0065) => [
      q(Ecuador),
      ],
   q(0066) => [
      q(Egypt),
      ],
   q(0067) => [
      q(El Salvador),
      ],
   q(0068) => [
      q(Equatorial Guinea),
      ],
   q(0069) => [
      q(Eritrea),
      ],
   q(0070) => [
      q(Estonia),
      ],
   q(0071) => [
      q(Ethiopia),
      ],
   q(0072) => [
      q(Falkland Islands (The) [Malvinas]),
      q(Falkland Islands (Malvinas)),
      q(Falkland Islands (Islas Malvinas)),
      ],
   q(0073) => [
      q(Faroe Islands),
      q(The Faroe Islands),
      q(Faroe Islands, The),
      q(Faroe Islands (The)),
      q(Faeroe Islands),
      q(The Faeroe Islands),
      ],
   q(0074) => [
      q(Fiji),
      ],
   q(0075) => [
      q(Finland),
      ],
   q(0076) => [
      q(France),
      ],
   q(0077) => [
      q(French Guiana),
      ],
   q(0078) => [
      q(French Polynesia),
      ],
   q(0079) => [
      q(French Southern Territories),
      q(The French Southern Territories),
      q(French Southern Territories, The),
      q(French Southern Territories (The)),
      q(French Southern and Antarctic Lands),
      ],
   q(0080) => [
      q(Gabon),
      ],
   q(0081) => [
      q(Gambia),
      q(The Gambia),
      q(Gambia, The),
      q(Gambia (The)),
      ],
   q(0082) => [
      q(Georgia),
      ],
   q(0083) => [
      q(Germany),
      ],
   q(0084) => [
      q(Ghana),
      ],
   q(0085) => [
      q(Gibraltar),
      ],
   q(0086) => [
      q(Greece),
      ],
   q(0087) => [
      q(Greenland),
      ],
   q(0088) => [
      q(Grenada),
      ],
   q(0089) => [
      q(Guadeloupe),
      ],
   q(0090) => [
      q(Guam),
      ],
   q(0091) => [
      q(Guatemala),
      ],
   q(0092) => [
      q(Guernsey),
      ],
   q(0093) => [
      q(Guinea),
      ],
   q(0094) => [
      q(Guinea-Bissau),
      ],
   q(0095) => [
      q(Guyana),
      ],
   q(0096) => [
      q(Haiti),
      ],
   q(0097) => [
      q(Heard Island and McDonald Islands),
      ],
   q(0098) => [
      q(Holy See (The) [Vatican City State]),
      q(Holy See (Vatican City State)),
      q(Holy See (Vatican City)),
      q(The Holy See),
      q(Holy See),
      q(Holy See (The)),
      q(Holy See, The),
      q(Vatican City),
      ],
   q(0099) => [
      q(Honduras),
      ],
   q(0100) => [
      q(Hong Kong),
      q(China, Hong Kong Special Administrative Region),
      q(Hong Kong S.A.R.),
      q(Hong Kong Special Administrative Region of China),
      ],
   q(0101) => [
      q(Hungary),
      ],
   q(0102) => [
      q(Iceland),
      ],
   q(0103) => [
      q(India),
      ],
   q(0104) => [
      q(Indonesia),
      ],
   q(0105) => [
      q(Iran, The Islamic Republic of),
      q(Iran (The Islamic Republic of)),
      q(Iran, Islamic Republic of),
      q(Iran (Islamic Republic of)),
      q(The Islamic Republic of Iran),
      q(Islamic Republic of Iran),
      q(Iran),
      ],
   q(0106) => [
      q(Iraq),
      ],
   q(0107) => [
      q(Ireland),
      ],
   q(0108) => [
      q(Isle of Man),
      ],
   q(0109) => [
      q(Israel),
      ],
   q(0110) => [
      q(Italy),
      ],
   q(0111) => [
      q(Jamaica),
      ],
   q(0112) => [
      q(Japan),
      ],
   q(0113) => [
      q(Jersey),
      ],
   q(0114) => [
      q(Jordan),
      ],
   q(0115) => [
      q(Kazakhstan),
      q(Kazakstan),
      ],
   q(0116) => [
      q(Kenya),
      ],
   q(0117) => [
      q(Kiribati),
      ],
   q(0118) => [
      q(Korea, The Democratic People's Republic of),
      q(Korea (The Democratic People's Republic of)),
      q(Korea, Democratic People's Republic of),
      q(Korea (Democratic People's Republic of)),
      q(The Democratic People's Republic of Korea),
      q(Democratic People's Republic of Korea),
      q(North Korea),
      ],
   q(0119) => [
      q(Korea, The Republic of),
      q(Korea (The Republic of)),
      q(Korea, Republic of),
      q(Korea (Republic of)),
      q(The Republic of Korea),
      q(Republic of Korea),
      q(South Korea),
      ],
   q(0120) => [
      q(Kuwait),
      ],
   q(0121) => [
      q(Kyrgyzstan),
      ],
   q(0122) => [
      q(Lao People's Democratic Republic),
      q(The Lao People's Democratic Republic),
      q(Lao People's Democratic Republic, The),
      q(Lao People's Democratic Republic (The)),
      ],
   q(0123) => [
      q(Latvia),
      ],
   q(0124) => [
      q(Lebanon),
      ],
   q(0125) => [
      q(Lesotho),
      ],
   q(0126) => [
      q(Liberia),
      ],
   q(0127) => [
      q(Libya),
      ],
   q(0128) => [
      q(Liechtenstein),
      ],
   q(0129) => [
      q(Lithuania),
      ],
   q(0130) => [
      q(Luxembourg),
      ],
   q(0131) => [
      q(Macao),
      q(China, Macao Special Administrative Region),
      q(Macao Special Administrative Region of China),
      q(Macau S.A.R),
      q(Macau S.A.R.),
      q(Macau),
      ],
   q(0132) => [
      q(Macedonia, The former Yugoslav Republic of),
      q(Macedonia (The former Yugoslav Republic of)),
      q(Macedonia, former Yugoslav Republic of),
      q(Macedonia (former Yugoslav Republic of)),
      q(The former Yugoslav Republic of Macedonia),
      q(former Yugoslav Republic of Macedonia),
      q(Macedonia),
      ],
   q(0133) => [
      q(Madagascar),
      ],
   q(0134) => [
      q(Malawi),
      ],
   q(0135) => [
      q(Malaysia),
      ],
   q(0136) => [
      q(Maldives),
      ],
   q(0137) => [
      q(Mali),
      ],
   q(0138) => [
      q(Malta),
      ],
   q(0139) => [
      q(Marshall Islands),
      q(The Marshall Islands),
      q(Marshall Islands, The),
      q(Marshall Islands (The)),
      ],
   q(0140) => [
      q(Martinique),
      ],
   q(0141) => [
      q(Mauritania),
      ],
   q(0142) => [
      q(Mauritius),
      ],
   q(0143) => [
      q(Mayotte),
      ],
   q(0144) => [
      q(Mexico),
      ],
   q(0145) => [
      q(Micronesia, The Federated States of),
      q(Micronesia (The Federated States of)),
      q(Micronesia, Federated States of),
      q(Micronesia (Federated States of)),
      q(The Federated States of Micronesia),
      q(Federated States of Micronesia),
      ],
   q(0146) => [
      q(Moldova, The Republic of),
      q(Moldova (The Republic of)),
      q(Moldova, Republic of),
      q(Moldova (Republic of)),
      q(The Republic of Moldova),
      q(Republic of Moldova),
      ],
   q(0147) => [
      q(Monaco),
      ],
   q(0148) => [
      q(Mongolia),
      ],
   q(0149) => [
      q(Montenegro),
      ],
   q(0150) => [
      q(Montserrat),
      ],
   q(0151) => [
      q(Morocco),
      ],
   q(0152) => [
      q(Mozambique),
      ],
   q(0153) => [
      q(Myanmar),
      q(The Republic of the Union of Myanmar),
      q(Republic of the Union of Myanmar),
      q(Burma),
      ],
   q(0154) => [
      q(Namibia),
      ],
   q(0155) => [
      q(Nauru),
      ],
   q(0156) => [
      q(Nepal),
      ],
   q(0157) => [
      q(Netherlands),
      q(The Netherlands),
      q(Netherlands, The),
      q(Netherlands (The)),
      ],
   q(0158) => [
      q(New Caledonia),
      ],
   q(0159) => [
      q(New Zealand),
      ],
   q(0160) => [
      q(Nicaragua),
      ],
   q(0161) => [
      q(Niger),
      q(The Niger),
      q(Niger, The),
      q(Niger (The)),
      ],
   q(0162) => [
      q(Nigeria),
      ],
   q(0163) => [
      q(Niue),
      ],
   q(0164) => [
      q(Norfolk Island),
      ],
   q(0165) => [
      q(Northern Mariana Islands),
      q(The Northern Mariana Islands),
      q(Northern Mariana Islands, The),
      q(Northern Mariana Islands (The)),
      ],
   q(0166) => [
      q(Norway),
      ],
   q(0167) => [
      q(Oman),
      ],
   q(0168) => [
      q(Pakistan),
      ],
   q(0169) => [
      q(Palau),
      ],
   q(0170) => [
      q(Palestine, State of),
      q(Palestine (State of)),
      q(State of Palestine),
      ],
   q(0171) => [
      q(Panama),
      ],
   q(0172) => [
      q(Papua New Guinea),
      ],
   q(0173) => [
      q(Paraguay),
      ],
   q(0174) => [
      q(Peru),
      ],
   q(0175) => [
      q(Philippines),
      q(The Philippines),
      q(Philippines, The),
      q(Philippines (The)),
      ],
   q(0176) => [
      q(Pitcairn),
      q(Pitcairn Island),
      q(Pitcairn Islands),
      ],
   q(0177) => [
      q(Poland),
      ],
   q(0178) => [
      q(Portugal),
      ],
   q(0179) => [
      q(Puerto Rico),
      ],
   q(0180) => [
      q(Qatar),
      ],
   q(0181) => [
      q(Reunion),
      ],
   q(0182) => [
      q(Romania),
      ],
   q(0183) => [
      q(Russian Federation),
      q(The Russian Federation),
      q(Russian Federation, The),
      q(Russian Federation (The)),
      ],
   q(0184) => [
      q(Rwanda),
      ],
   q(0185) => [
      q(Saint Barthelemy),
      q(Saint-Barthelemy),
      ],
   q(0186) => [
      q(Saint Helena, Ascension and Tristan da Cunha),
      q(Saint Helena),
      ],
   q(0187) => [
      q(Saint Kitts and Nevis),
      ],
   q(0188) => [
      q(Saint Lucia),
      ],
   q(0189) => [
      q(Saint Martin (French part)),
      q(Saint Martin),
      q(Saint-Martin (French part)),
      q(Saint-Martin),
      ],
   q(0190) => [
      q(Saint Pierre and Miquelon),
      ],
   q(0191) => [
      q(Saint Vincent and the Grenadines),
      ],
   q(0192) => [
      q(Samoa),
      ],
   q(0193) => [
      q(San Marino),
      ],
   q(0194) => [
      q(Sao Tome and Principe),
      ],
   q(0195) => [
      q(Saudi Arabia),
      ],
   q(0196) => [
      q(Senegal),
      ],
   q(0197) => [
      q(Serbia),
      ],
   q(0198) => [
      q(Seychelles),
      ],
   q(0199) => [
      q(Sierra Leone),
      ],
   q(0200) => [
      q(Singapore),
      ],
   q(0201) => [
      q(Sint Maarten (Dutch part)),
      ],
   q(0202) => [
      q(Slovakia),
      ],
   q(0203) => [
      q(Slovenia),
      ],
   q(0204) => [
      q(Solomon Islands),
      q(The Solomon Islands),
      q(Solomon Islands, The),
      q(Solomon Islands (The)),
      ],
   q(0205) => [
      q(Somalia),
      ],
   q(0206) => [
      q(South Africa),
      ],
   q(0207) => [
      q(South Georgia and the South Sandwich Islands),
      q(South Georgia and the Islands),
      ],
   q(0208) => [
      q(South Sudan),
      ],
   q(0209) => [
      q(Spain),
      ],
   q(0210) => [
      q(Sri Lanka),
      ],
   q(0211) => [
      q(Sudan),
      q(The Sudan),
      q(Sudan, The),
      q(Sudan (The)),
      ],
   q(0212) => [
      q(Suriname),
      ],
   q(0213) => [
      q(Svalbard and Jan Mayen),
      q(Svalbard and Jan Mayen Islands),
      ],
   q(0214) => [
      q(Swaziland),
      ],
   q(0215) => [
      q(Sweden),
      ],
   q(0216) => [
      q(Switzerland),
      ],
   q(0217) => [
      q(Syrian Arab Republic),
      q(The Syrian Arab Republic),
      q(Syrian Arab Republic, The),
      q(Syrian Arab Republic (The)),
      q(Syria),
      ],
   q(0218) => [
      q(Taiwan (Province of China)),
      q(Taiwan),
      q(Taiwan, Province of China),
      ],
   q(0219) => [
      q(Tajikistan),
      ],
   q(0220) => [
      q(Tanzania, United Republic of),
      q(Tanzania (United Republic of)),
      q(United Republic of Tanzania),
      ],
   q(0221) => [
      q(Thailand),
      ],
   q(0222) => [
      q(Timor-Leste),
      q(East Timor),
      q(The Democratic Republic of Timor-Leste),
      q(Democratic Republic of Timor-Leste),
      q(Timor-Leste, The Democratic Republic of),
      q(Timor-Leste, Democratic Republic of),
      q(Timor-Leste (The Democratic Republic of)),
      q(Timor-Leste (Democratic Republic of)),
      ],
   q(0223) => [
      q(Togo),
      ],
   q(0224) => [
      q(Tokelau),
      ],
   q(0225) => [
      q(Tonga),
      ],
   q(0226) => [
      q(Trinidad and Tobago),
      ],
   q(0227) => [
      q(Tunisia),
      ],
   q(0228) => [
      q(Turkey),
      ],
   q(0229) => [
      q(Turkmenistan),
      ],
   q(0230) => [
      q(Turks and Caicos Islands),
      q(The Turks and Caicos Islands),
      q(Turks and Caicos Islands, The),
      q(Turks and Caicos Islands (The)),
      ],
   q(0231) => [
      q(Tuvalu),
      ],
   q(0232) => [
      q(Uganda),
      ],
   q(0233) => [
      q(Ukraine),
      ],
   q(0234) => [
      q(United Arab Emirates),
      q(The United Arab Emirates),
      q(United Arab Emirates, The),
      q(United Arab Emirates (The)),
      ],
   q(0235) => [
      q(United Kingdom),
      q(The United Kingdom),
      q(United Kingdom, The),
      q(United Kingdom (The)),
      q(Great Britain),
      q(United Kingdom of Great Britain and Northern Ireland),
      q(UK),
      ],
   q(0236) => [
      q(United States),
      q(The United States),
      q(United States, The),
      q(United States (The)),
      q(US),
      q(USA),
      q(United States of America),
      q(The United States of America),
      ],
   q(0237) => [
      q(United States Minor Outlying Islands),
      q(The United States Minor Outlying Islands),
      q(United States Minor Outlying Islands, The),
      q(United States Minor Outlying Islands (The)),
      ],
   q(0238) => [
      q(Uruguay),
      ],
   q(0239) => [
      q(Uzbekistan),
      ],
   q(0240) => [
      q(Vanuatu),
      ],
   q(0241) => [
      q(Venezuela, Bolivarian Republic of ),
      ],
   q(0242) => [
      q(Viet Nam),
      q(Vietnam),
      ],
   q(0243) => [
      q(Virgin Islands (British)),
      q(British Virgin Islands),
      q(Virgin Islands, British),
      q(Virgin Islands (UK)),
      ],
   q(0244) => [
      q(Virgin Islands (U.S.)),
      q(United States Virgin Islands),
      q(Virgin Islands (US)),
      q(Virgin Islands, U.S.),
      q(Virgin Islands),
      ],
   q(0245) => [
      q(Wallis and Futuna),
      q(Wallis and Futuna Islands),
      q(The Territory of the Wallis and Futuna Islands),
      q(Territory of the Wallis and Futuna Islands),
      ],
   q(0246) => [
      q(Western Sahara),
      ],
   q(0247) => [
      q(Yemen),
      q(The Yemeni Republic),
      q(Yemeni Republic),
      q(Yemeni Republic, The),
      q(Yemeni Republic (The)),
      ],
   q(0248) => [
      q(Zambia),
      q(The Republic of Zambia),
      q(Republic of Zambia),
      q(Republic of Zambia, The),
      q(Republic of Zambia (The)),
      ],
   q(0249) => [
      q(Zimbabwe),
      q(The Republic of Zimbabwe),
      q(Republic of Zimbabwe),
      q(Republic of Zimbabwe, The),
      q(Republic of Zimbabwe (The)),
      ],
   q(0250) => [
      q(Netherlands Antilles),
      ],
   q(0251) => [
      q(USSR),
      ],
};

$Locale::Codes::Data{'country'}{'alias2id'} = {
   q(afghanistan) => [
      q(0001),
      q(0),
      ],
   q(aland islands) => [
      q(0002),
      q(0),
      ],
   q(albania) => [
      q(0003),
      q(0),
      ],
   q(algeria) => [
      q(0004),
      q(0),
      ],
   q(american samoa) => [
      q(0005),
      q(0),
      ],
   q(andorra) => [
      q(0006),
      q(0),
      ],
   q(angola) => [
      q(0007),
      q(0),
      ],
   q(anguilla) => [
      q(0008),
      q(0),
      ],
   q(antarctica) => [
      q(0009),
      q(0),
      ],
   q(antigua and barbuda) => [
      q(0010),
      q(0),
      ],
   q(argentina) => [
      q(0011),
      q(0),
      ],
   q(armenia) => [
      q(0012),
      q(0),
      ],
   q(aruba) => [
      q(0013),
      q(0),
      ],
   q(australia) => [
      q(0014),
      q(0),
      ],
   q(austria) => [
      q(0015),
      q(0),
      ],
   q(azerbaijan) => [
      q(0016),
      q(0),
      ],
   q(bahamas) => [
      q(0017),
      q(0),
      ],
   q(bahamas (the)) => [
      q(0017),
      q(3),
      ],
   q(bahamas, the) => [
      q(0017),
      q(2),
      ],
   q(bahrain) => [
      q(0018),
      q(0),
      ],
   q(bangladesh) => [
      q(0019),
      q(0),
      ],
   q(barbados) => [
      q(0020),
      q(0),
      ],
   q(belarus) => [
      q(0021),
      q(0),
      ],
   q(belgium) => [
      q(0022),
      q(0),
      ],
   q(belize) => [
      q(0023),
      q(0),
      ],
   q(benin) => [
      q(0024),
      q(0),
      ],
   q(bermuda) => [
      q(0025),
      q(0),
      ],
   q(bhutan) => [
      q(0026),
      q(0),
      ],
   q(bolivia) => [
      q(0027),
      q(3),
      ],
   q(bolivia (plurinational state of)) => [
      q(0027),
      q(1),
      ],
   q(bolivia, plurinational state of) => [
      q(0027),
      q(0),
      ],
   q(bonaire, sint eustatius and saba) => [
      q(0028),
      q(0),
      ],
   q(bosnia and herzegovina) => [
      q(0029),
      q(0),
      ],
   q(botswana) => [
      q(0030),
      q(0),
      ],
   q(bouvet island) => [
      q(0031),
      q(0),
      ],
   q(brazil) => [
      q(0032),
      q(0),
      ],
   q(british indian ocean territory) => [
      q(0033),
      q(0),
      ],
   q(british indian ocean territory (the)) => [
      q(0033),
      q(3),
      ],
   q(british indian ocean territory, the) => [
      q(0033),
      q(2),
      ],
   q(british virgin islands) => [
      q(0243),
      q(1),
      ],
   q(brunei) => [
      q(0034),
      q(1),
      ],
   q(brunei darussalam) => [
      q(0034),
      q(0),
      ],
   q(bulgaria) => [
      q(0035),
      q(0),
      ],
   q(burkina faso) => [
      q(0036),
      q(0),
      ],
   q(burma) => [
      q(0153),
      q(3),
      ],
   q(burundi) => [
      q(0037),
      q(0),
      ],
   q(cambodia) => [
      q(0038),
      q(0),
      ],
   q(cameroon) => [
      q(0039),
      q(0),
      ],
   q(canada) => [
      q(0040),
      q(0),
      ],
   q(cape verde) => [
      q(0041),
      q(0),
      ],
   q(cayman islands) => [
      q(0042),
      q(0),
      ],
   q(cayman islands (the)) => [
      q(0042),
      q(3),
      ],
   q(cayman islands, the) => [
      q(0042),
      q(2),
      ],
   q(central african republic) => [
      q(0043),
      q(0),
      ],
   q(central african republic (the)) => [
      q(0043),
      q(3),
      ],
   q(central african republic, the) => [
      q(0043),
      q(2),
      ],
   q(chad) => [
      q(0044),
      q(0),
      ],
   q(chile) => [
      q(0045),
      q(0),
      ],
   q(china) => [
      q(0046),
      q(0),
      ],
   q(china, hong kong special administrative region) => [
      q(0100),
      q(1),
      ],
   q(china, macao special administrative region) => [
      q(0131),
      q(1),
      ],
   q(christmas island) => [
      q(0047),
      q(0),
      ],
   q(cocos (keeling) islands) => [
      q(0048),
      q(0),
      ],
   q(cocos (keeling) islands (the)) => [
      q(0048),
      q(3),
      ],
   q(cocos (keeling) islands, the) => [
      q(0048),
      q(2),
      ],
   q(cocos islands) => [
      q(0048),
      q(4),
      ],
   q(colombia) => [
      q(0049),
      q(0),
      ],
   q(comoros) => [
      q(0050),
      q(0),
      ],
   q(congo) => [
      q(0051),
      q(0),
      ],
   q(congo (brazzaville)) => [
      q(0051),
      q(6),
      ],
   q(congo (kinshasa)) => [
      q(0052),
      q(6),
      ],
   q(congo (the democratic republic of the)) => [
      q(0052),
      q(0),
      ],
   q(congo, democratic republic of the) => [
      q(0052),
      q(2),
      ],
   q(congo, republic of the) => [
      q(0051),
      q(4),
      ],
   q(congo, the democratic republic of the) => [
      q(0052),
      q(1),
      ],
   q(congo, the republic of the) => [
      q(0051),
      q(3),
      ],
   q(congo-brazzaville) => [
      q(0051),
      q(5),
      ],
   q(congo-kinshasa) => [
      q(0052),
      q(5),
      ],
   q(cook islands) => [
      q(0053),
      q(0),
      ],
   q(cook islands (the)) => [
      q(0053),
      q(3),
      ],
   q(cook islands, the) => [
      q(0053),
      q(2),
      ],
   q(costa rica) => [
      q(0054),
      q(0),
      ],
   q(cote d'ivoire) => [
      q(0055),
      q(0),
      ],
   q(croatia) => [
      q(0056),
      q(0),
      ],
   q(cuba) => [
      q(0057),
      q(0),
      ],
   q(curacao) => [
      q(0058),
      q(0),
      ],
   q(cyprus) => [
      q(0059),
      q(0),
      ],
   q(czech republic) => [
      q(0060),
      q(0),
      ],
   q(czech republic (the)) => [
      q(0060),
      q(3),
      ],
   q(czech republic, the) => [
      q(0060),
      q(2),
      ],
   q(democratic people's republic of korea) => [
      q(0118),
      q(5),
      ],
   q(democratic republic of the congo) => [
      q(0052),
      q(4),
      ],
   q(democratic republic of timor-leste) => [
      q(0222),
      q(3),
      ],
   q(denmark) => [
      q(0061),
      q(0),
      ],
   q(djibouti) => [
      q(0062),
      q(0),
      ],
   q(dominica) => [
      q(0063),
      q(0),
      ],
   q(dominican republic) => [
      q(0064),
      q(0),
      ],
   q(dominican republic (the)) => [
      q(0064),
      q(3),
      ],
   q(dominican republic, the) => [
      q(0064),
      q(2),
      ],
   q(east timor) => [
      q(0222),
      q(1),
      ],
   q(ecuador) => [
      q(0065),
      q(0),
      ],
   q(egypt) => [
      q(0066),
      q(0),
      ],
   q(el salvador) => [
      q(0067),
      q(0),
      ],
   q(equatorial guinea) => [
      q(0068),
      q(0),
      ],
   q(eritrea) => [
      q(0069),
      q(0),
      ],
   q(estonia) => [
      q(0070),
      q(0),
      ],
   q(ethiopia) => [
      q(0071),
      q(0),
      ],
   q(faeroe islands) => [
      q(0073),
      q(4),
      ],
   q(falkland islands (islas malvinas)) => [
      q(0072),
      q(2),
      ],
   q(falkland islands (malvinas)) => [
      q(0072),
      q(1),
      ],
   q(falkland islands (the) [malvinas]) => [
      q(0072),
      q(0),
      ],
   q(faroe islands) => [
      q(0073),
      q(0),
      ],
   q(faroe islands (the)) => [
      q(0073),
      q(3),
      ],
   q(faroe islands, the) => [
      q(0073),
      q(2),
      ],
   q(federated states of micronesia) => [
      q(0145),
      q(5),
      ],
   q(fiji) => [
      q(0074),
      q(0),
      ],
   q(finland) => [
      q(0075),
      q(0),
      ],
   q(former yugoslav republic of macedonia) => [
      q(0132),
      q(5),
      ],
   q(france) => [
      q(0076),
      q(0),
      ],
   q(french guiana) => [
      q(0077),
      q(0),
      ],
   q(french polynesia) => [
      q(0078),
      q(0),
      ],
   q(french southern and antarctic lands) => [
      q(0079),
      q(4),
      ],
   q(french southern territories) => [
      q(0079),
      q(0),
      ],
   q(french southern territories (the)) => [
      q(0079),
      q(3),
      ],
   q(french southern territories, the) => [
      q(0079),
      q(2),
      ],
   q(gabon) => [
      q(0080),
      q(0),
      ],
   q(gambia) => [
      q(0081),
      q(0),
      ],
   q(gambia (the)) => [
      q(0081),
      q(3),
      ],
   q(gambia, the) => [
      q(0081),
      q(2),
      ],
   q(georgia) => [
      q(0082),
      q(0),
      ],
   q(germany) => [
      q(0083),
      q(0),
      ],
   q(ghana) => [
      q(0084),
      q(0),
      ],
   q(gibraltar) => [
      q(0085),
      q(0),
      ],
   q(great britain) => [
      q(0235),
      q(4),
      ],
   q(greece) => [
      q(0086),
      q(0),
      ],
   q(greenland) => [
      q(0087),
      q(0),
      ],
   q(grenada) => [
      q(0088),
      q(0),
      ],
   q(guadeloupe) => [
      q(0089),
      q(0),
      ],
   q(guam) => [
      q(0090),
      q(0),
      ],
   q(guatemala) => [
      q(0091),
      q(0),
      ],
   q(guernsey) => [
      q(0092),
      q(0),
      ],
   q(guinea) => [
      q(0093),
      q(0),
      ],
   q(guinea-bissau) => [
      q(0094),
      q(0),
      ],
   q(guyana) => [
      q(0095),
      q(0),
      ],
   q(haiti) => [
      q(0096),
      q(0),
      ],
   q(heard island and mcdonald islands) => [
      q(0097),
      q(0),
      ],
   q(holy see) => [
      q(0098),
      q(4),
      ],
   q(holy see (the)) => [
      q(0098),
      q(5),
      ],
   q(holy see (the) [vatican city state]) => [
      q(0098),
      q(0),
      ],
   q(holy see (vatican city state)) => [
      q(0098),
      q(1),
      ],
   q(holy see (vatican city)) => [
      q(0098),
      q(2),
      ],
   q(holy see, the) => [
      q(0098),
      q(6),
      ],
   q(honduras) => [
      q(0099),
      q(0),
      ],
   q(hong kong) => [
      q(0100),
      q(0),
      ],
   q(hong kong s.a.r.) => [
      q(0100),
      q(2),
      ],
   q(hong kong special administrative region of china) => [
      q(0100),
      q(3),
      ],
   q(hungary) => [
      q(0101),
      q(0),
      ],
   q(iceland) => [
      q(0102),
      q(0),
      ],
   q(india) => [
      q(0103),
      q(0),
      ],
   q(indonesia) => [
      q(0104),
      q(0),
      ],
   q(iran) => [
      q(0105),
      q(6),
      ],
   q(iran (islamic republic of)) => [
      q(0105),
      q(3),
      ],
   q(iran (the islamic republic of)) => [
      q(0105),
      q(1),
      ],
   q(iran, islamic republic of) => [
      q(0105),
      q(2),
      ],
   q(iran, the islamic republic of) => [
      q(0105),
      q(0),
      ],
   q(iraq) => [
      q(0106),
      q(0),
      ],
   q(ireland) => [
      q(0107),
      q(0),
      ],
   q(islamic republic of iran) => [
      q(0105),
      q(5),
      ],
   q(isle of man) => [
      q(0108),
      q(0),
      ],
   q(israel) => [
      q(0109),
      q(0),
      ],
   q(italy) => [
      q(0110),
      q(0),
      ],
   q(jamaica) => [
      q(0111),
      q(0),
      ],
   q(japan) => [
      q(0112),
      q(0),
      ],
   q(jersey) => [
      q(0113),
      q(0),
      ],
   q(jordan) => [
      q(0114),
      q(0),
      ],
   q(kazakhstan) => [
      q(0115),
      q(0),
      ],
   q(kazakstan) => [
      q(0115),
      q(1),
      ],
   q(keeling islands) => [
      q(0048),
      q(6),
      ],
   q(kenya) => [
      q(0116),
      q(0),
      ],
   q(kiribati) => [
      q(0117),
      q(0),
      ],
   q(korea (democratic people's republic of)) => [
      q(0118),
      q(3),
      ],
   q(korea (republic of)) => [
      q(0119),
      q(3),
      ],
   q(korea (the democratic people's republic of)) => [
      q(0118),
      q(1),
      ],
   q(korea (the republic of)) => [
      q(0119),
      q(1),
      ],
   q(korea, democratic people's republic of) => [
      q(0118),
      q(2),
      ],
   q(korea, republic of) => [
      q(0119),
      q(2),
      ],
   q(korea, the democratic people's republic of) => [
      q(0118),
      q(0),
      ],
   q(korea, the republic of) => [
      q(0119),
      q(0),
      ],
   q(kuwait) => [
      q(0120),
      q(0),
      ],
   q(kyrgyzstan) => [
      q(0121),
      q(0),
      ],
   q(lao people's democratic republic) => [
      q(0122),
      q(0),
      ],
   q(lao people's democratic republic (the)) => [
      q(0122),
      q(3),
      ],
   q(lao people's democratic republic, the) => [
      q(0122),
      q(2),
      ],
   q(latvia) => [
      q(0123),
      q(0),
      ],
   q(lebanon) => [
      q(0124),
      q(0),
      ],
   q(lesotho) => [
      q(0125),
      q(0),
      ],
   q(liberia) => [
      q(0126),
      q(0),
      ],
   q(libya) => [
      q(0127),
      q(0),
      ],
   q(liechtenstein) => [
      q(0128),
      q(0),
      ],
   q(lithuania) => [
      q(0129),
      q(0),
      ],
   q(luxembourg) => [
      q(0130),
      q(0),
      ],
   q(macao) => [
      q(0131),
      q(0),
      ],
   q(macao special administrative region of china) => [
      q(0131),
      q(2),
      ],
   q(macau) => [
      q(0131),
      q(5),
      ],
   q(macau s.a.r) => [
      q(0131),
      q(3),
      ],
   q(macau s.a.r.) => [
      q(0131),
      q(4),
      ],
   q(macedonia) => [
      q(0132),
      q(6),
      ],
   q(macedonia (former yugoslav republic of)) => [
      q(0132),
      q(3),
      ],
   q(macedonia (the former yugoslav republic of)) => [
      q(0132),
      q(1),
      ],
   q(macedonia, former yugoslav republic of) => [
      q(0132),
      q(2),
      ],
   q(macedonia, the former yugoslav republic of) => [
      q(0132),
      q(0),
      ],
   q(madagascar) => [
      q(0133),
      q(0),
      ],
   q(malawi) => [
      q(0134),
      q(0),
      ],
   q(malaysia) => [
      q(0135),
      q(0),
      ],
   q(maldives) => [
      q(0136),
      q(0),
      ],
   q(mali) => [
      q(0137),
      q(0),
      ],
   q(malta) => [
      q(0138),
      q(0),
      ],
   q(marshall islands) => [
      q(0139),
      q(0),
      ],
   q(marshall islands (the)) => [
      q(0139),
      q(3),
      ],
   q(marshall islands, the) => [
      q(0139),
      q(2),
      ],
   q(martinique) => [
      q(0140),
      q(0),
      ],
   q(mauritania) => [
      q(0141),
      q(0),
      ],
   q(mauritius) => [
      q(0142),
      q(0),
      ],
   q(mayotte) => [
      q(0143),
      q(0),
      ],
   q(mexico) => [
      q(0144),
      q(0),
      ],
   q(micronesia (federated states of)) => [
      q(0145),
      q(3),
      ],
   q(micronesia (the federated states of)) => [
      q(0145),
      q(1),
      ],
   q(micronesia, federated states of) => [
      q(0145),
      q(2),
      ],
   q(micronesia, the federated states of) => [
      q(0145),
      q(0),
      ],
   q(moldova (republic of)) => [
      q(0146),
      q(3),
      ],
   q(moldova (the republic of)) => [
      q(0146),
      q(1),
      ],
   q(moldova, republic of) => [
      q(0146),
      q(2),
      ],
   q(moldova, the republic of) => [
      q(0146),
      q(0),
      ],
   q(monaco) => [
      q(0147),
      q(0),
      ],
   q(mongolia) => [
      q(0148),
      q(0),
      ],
   q(montenegro) => [
      q(0149),
      q(0),
      ],
   q(montserrat) => [
      q(0150),
      q(0),
      ],
   q(morocco) => [
      q(0151),
      q(0),
      ],
   q(mozambique) => [
      q(0152),
      q(0),
      ],
   q(myanmar) => [
      q(0153),
      q(0),
      ],
   q(namibia) => [
      q(0154),
      q(0),
      ],
   q(nauru) => [
      q(0155),
      q(0),
      ],
   q(nepal) => [
      q(0156),
      q(0),
      ],
   q(netherlands) => [
      q(0157),
      q(0),
      ],
   q(netherlands (the)) => [
      q(0157),
      q(3),
      ],
   q(netherlands antilles) => [
      q(0250),
      q(0),
      ],
   q(netherlands, the) => [
      q(0157),
      q(2),
      ],
   q(new caledonia) => [
      q(0158),
      q(0),
      ],
   q(new zealand) => [
      q(0159),
      q(0),
      ],
   q(nicaragua) => [
      q(0160),
      q(0),
      ],
   q(niger) => [
      q(0161),
      q(0),
      ],
   q(niger (the)) => [
      q(0161),
      q(3),
      ],
   q(niger, the) => [
      q(0161),
      q(2),
      ],
   q(nigeria) => [
      q(0162),
      q(0),
      ],
   q(niue) => [
      q(0163),
      q(0),
      ],
   q(norfolk island) => [
      q(0164),
      q(0),
      ],
   q(north korea) => [
      q(0118),
      q(6),
      ],
   q(northern mariana islands) => [
      q(0165),
      q(0),
      ],
   q(northern mariana islands (the)) => [
      q(0165),
      q(3),
      ],
   q(northern mariana islands, the) => [
      q(0165),
      q(2),
      ],
   q(norway) => [
      q(0166),
      q(0),
      ],
   q(oman) => [
      q(0167),
      q(0),
      ],
   q(pakistan) => [
      q(0168),
      q(0),
      ],
   q(palau) => [
      q(0169),
      q(0),
      ],
   q(palestine (state of)) => [
      q(0170),
      q(1),
      ],
   q(palestine, state of) => [
      q(0170),
      q(0),
      ],
   q(panama) => [
      q(0171),
      q(0),
      ],
   q(papua new guinea) => [
      q(0172),
      q(0),
      ],
   q(paraguay) => [
      q(0173),
      q(0),
      ],
   q(peru) => [
      q(0174),
      q(0),
      ],
   q(philippines) => [
      q(0175),
      q(0),
      ],
   q(philippines (the)) => [
      q(0175),
      q(3),
      ],
   q(philippines, the) => [
      q(0175),
      q(2),
      ],
   q(pitcairn) => [
      q(0176),
      q(0),
      ],
   q(pitcairn island) => [
      q(0176),
      q(1),
      ],
   q(pitcairn islands) => [
      q(0176),
      q(2),
      ],
   q(plurinational state of bolivia) => [
      q(0027),
      q(2),
      ],
   q(poland) => [
      q(0177),
      q(0),
      ],
   q(portugal) => [
      q(0178),
      q(0),
      ],
   q(puerto rico) => [
      q(0179),
      q(0),
      ],
   q(qatar) => [
      q(0180),
      q(0),
      ],
   q(republic of korea) => [
      q(0119),
      q(5),
      ],
   q(republic of moldova) => [
      q(0146),
      q(5),
      ],
   q(republic of the congo) => [
      q(0051),
      q(2),
      ],
   q(republic of the union of myanmar) => [
      q(0153),
      q(2),
      ],
   q(republic of zambia) => [
      q(0248),
      q(2),
      ],
   q(republic of zambia (the)) => [
      q(0248),
      q(4),
      ],
   q(republic of zambia, the) => [
      q(0248),
      q(3),
      ],
   q(republic of zimbabwe) => [
      q(0249),
      q(2),
      ],
   q(republic of zimbabwe (the)) => [
      q(0249),
      q(4),
      ],
   q(republic of zimbabwe, the) => [
      q(0249),
      q(3),
      ],
   q(reunion) => [
      q(0181),
      q(0),
      ],
   q(romania) => [
      q(0182),
      q(0),
      ],
   q(russian federation) => [
      q(0183),
      q(0),
      ],
   q(russian federation (the)) => [
      q(0183),
      q(3),
      ],
   q(russian federation, the) => [
      q(0183),
      q(2),
      ],
   q(rwanda) => [
      q(0184),
      q(0),
      ],
   q(saint barthelemy) => [
      q(0185),
      q(0),
      ],
   q(saint helena) => [
      q(0186),
      q(1),
      ],
   q(saint helena, ascension and tristan da cunha) => [
      q(0186),
      q(0),
      ],
   q(saint kitts and nevis) => [
      q(0187),
      q(0),
      ],
   q(saint lucia) => [
      q(0188),
      q(0),
      ],
   q(saint martin) => [
      q(0189),
      q(1),
      ],
   q(saint martin (french part)) => [
      q(0189),
      q(0),
      ],
   q(saint pierre and miquelon) => [
      q(0190),
      q(0),
      ],
   q(saint vincent and the grenadines) => [
      q(0191),
      q(0),
      ],
   q(saint-barthelemy) => [
      q(0185),
      q(1),
      ],
   q(saint-martin) => [
      q(0189),
      q(3),
      ],
   q(saint-martin (french part)) => [
      q(0189),
      q(2),
      ],
   q(samoa) => [
      q(0192),
      q(0),
      ],
   q(san marino) => [
      q(0193),
      q(0),
      ],
   q(sao tome and principe) => [
      q(0194),
      q(0),
      ],
   q(saudi arabia) => [
      q(0195),
      q(0),
      ],
   q(senegal) => [
      q(0196),
      q(0),
      ],
   q(serbia) => [
      q(0197),
      q(0),
      ],
   q(seychelles) => [
      q(0198),
      q(0),
      ],
   q(sierra leone) => [
      q(0199),
      q(0),
      ],
   q(singapore) => [
      q(0200),
      q(0),
      ],
   q(sint maarten (dutch part)) => [
      q(0201),
      q(0),
      ],
   q(slovakia) => [
      q(0202),
      q(0),
      ],
   q(slovenia) => [
      q(0203),
      q(0),
      ],
   q(solomon islands) => [
      q(0204),
      q(0),
      ],
   q(solomon islands (the)) => [
      q(0204),
      q(3),
      ],
   q(solomon islands, the) => [
      q(0204),
      q(2),
      ],
   q(somalia) => [
      q(0205),
      q(0),
      ],
   q(south africa) => [
      q(0206),
      q(0),
      ],
   q(south georgia and the islands) => [
      q(0207),
      q(1),
      ],
   q(south georgia and the south sandwich islands) => [
      q(0207),
      q(0),
      ],
   q(south korea) => [
      q(0119),
      q(6),
      ],
   q(south sudan) => [
      q(0208),
      q(0),
      ],
   q(spain) => [
      q(0209),
      q(0),
      ],
   q(sri lanka) => [
      q(0210),
      q(0),
      ],
   q(state of palestine) => [
      q(0170),
      q(2),
      ],
   q(sudan) => [
      q(0211),
      q(0),
      ],
   q(sudan (the)) => [
      q(0211),
      q(3),
      ],
   q(sudan, the) => [
      q(0211),
      q(2),
      ],
   q(suriname) => [
      q(0212),
      q(0),
      ],
   q(svalbard and jan mayen) => [
      q(0213),
      q(0),
      ],
   q(svalbard and jan mayen islands) => [
      q(0213),
      q(1),
      ],
   q(swaziland) => [
      q(0214),
      q(0),
      ],
   q(sweden) => [
      q(0215),
      q(0),
      ],
   q(switzerland) => [
      q(0216),
      q(0),
      ],
   q(syria) => [
      q(0217),
      q(4),
      ],
   q(syrian arab republic) => [
      q(0217),
      q(0),
      ],
   q(syrian arab republic (the)) => [
      q(0217),
      q(3),
      ],
   q(syrian arab republic, the) => [
      q(0217),
      q(2),
      ],
   q(taiwan) => [
      q(0218),
      q(1),
      ],
   q(taiwan (province of china)) => [
      q(0218),
      q(0),
      ],
   q(taiwan, province of china) => [
      q(0218),
      q(2),
      ],
   q(tajikistan) => [
      q(0219),
      q(0),
      ],
   q(tanzania (united republic of)) => [
      q(0220),
      q(1),
      ],
   q(tanzania, united republic of) => [
      q(0220),
      q(0),
      ],
   q(territory of the wallis and futuna islands) => [
      q(0245),
      q(3),
      ],
   q(thailand) => [
      q(0221),
      q(0),
      ],
   q(the bahamas) => [
      q(0017),
      q(1),
      ],
   q(the british indian ocean territory) => [
      q(0033),
      q(1),
      ],
   q(the cayman islands) => [
      q(0042),
      q(1),
      ],
   q(the central african republic) => [
      q(0043),
      q(1),
      ],
   q(the cocos (keeling) islands) => [
      q(0048),
      q(1),
      ],
   q(the cocos islands) => [
      q(0048),
      q(5),
      ],
   q(the cook islands) => [
      q(0053),
      q(1),
      ],
   q(the czech republic) => [
      q(0060),
      q(1),
      ],
   q(the democratic people's republic of korea) => [
      q(0118),
      q(4),
      ],
   q(the democratic republic of the congo) => [
      q(0052),
      q(3),
      ],
   q(the democratic republic of timor-leste) => [
      q(0222),
      q(2),
      ],
   q(the dominican republic) => [
      q(0064),
      q(1),
      ],
   q(the faeroe islands) => [
      q(0073),
      q(5),
      ],
   q(the faroe islands) => [
      q(0073),
      q(1),
      ],
   q(the federated states of micronesia) => [
      q(0145),
      q(4),
      ],
   q(the former yugoslav republic of macedonia) => [
      q(0132),
      q(4),
      ],
   q(the french southern territories) => [
      q(0079),
      q(1),
      ],
   q(the gambia) => [
      q(0081),
      q(1),
      ],
   q(the holy see) => [
      q(0098),
      q(3),
      ],
   q(the islamic republic of iran) => [
      q(0105),
      q(4),
      ],
   q(the keeling islands) => [
      q(0048),
      q(7),
      ],
   q(the lao people's democratic republic) => [
      q(0122),
      q(1),
      ],
   q(the marshall islands) => [
      q(0139),
      q(1),
      ],
   q(the netherlands) => [
      q(0157),
      q(1),
      ],
   q(the niger) => [
      q(0161),
      q(1),
      ],
   q(the northern mariana islands) => [
      q(0165),
      q(1),
      ],
   q(the philippines) => [
      q(0175),
      q(1),
      ],
   q(the republic of korea) => [
      q(0119),
      q(4),
      ],
   q(the republic of moldova) => [
      q(0146),
      q(4),
      ],
   q(the republic of the congo) => [
      q(0051),
      q(1),
      ],
   q(the republic of the union of myanmar) => [
      q(0153),
      q(1),
      ],
   q(the republic of zambia) => [
      q(0248),
      q(1),
      ],
   q(the republic of zimbabwe) => [
      q(0249),
      q(1),
      ],
   q(the russian federation) => [
      q(0183),
      q(1),
      ],
   q(the solomon islands) => [
      q(0204),
      q(1),
      ],
   q(the sudan) => [
      q(0211),
      q(1),
      ],
   q(the syrian arab republic) => [
      q(0217),
      q(1),
      ],
   q(the territory of the wallis and futuna islands) => [
      q(0245),
      q(2),
      ],
   q(the turks and caicos islands) => [
      q(0230),
      q(1),
      ],
   q(the united arab emirates) => [
      q(0234),
      q(1),
      ],
   q(the united kingdom) => [
      q(0235),
      q(1),
      ],
   q(the united states) => [
      q(0236),
      q(1),
      ],
   q(the united states minor outlying islands) => [
      q(0237),
      q(1),
      ],
   q(the united states of america) => [
      q(0236),
      q(7),
      ],
   q(the yemeni republic) => [
      q(0247),
      q(1),
      ],
   q(timor-leste) => [
      q(0222),
      q(0),
      ],
   q(timor-leste (democratic republic of)) => [
      q(0222),
      q(7),
      ],
   q(timor-leste (the democratic republic of)) => [
      q(0222),
      q(6),
      ],
   q(timor-leste, democratic republic of) => [
      q(0222),
      q(5),
      ],
   q(timor-leste, the democratic republic of) => [
      q(0222),
      q(4),
      ],
   q(togo) => [
      q(0223),
      q(0),
      ],
   q(tokelau) => [
      q(0224),
      q(0),
      ],
   q(tonga) => [
      q(0225),
      q(0),
      ],
   q(trinidad and tobago) => [
      q(0226),
      q(0),
      ],
   q(tunisia) => [
      q(0227),
      q(0),
      ],
   q(turkey) => [
      q(0228),
      q(0),
      ],
   q(turkmenistan) => [
      q(0229),
      q(0),
      ],
   q(turks and caicos islands) => [
      q(0230),
      q(0),
      ],
   q(turks and caicos islands (the)) => [
      q(0230),
      q(3),
      ],
   q(turks and caicos islands, the) => [
      q(0230),
      q(2),
      ],
   q(tuvalu) => [
      q(0231),
      q(0),
      ],
   q(uganda) => [
      q(0232),
      q(0),
      ],
   q(uk) => [
      q(0235),
      q(6),
      ],
   q(ukraine) => [
      q(0233),
      q(0),
      ],
   q(united arab emirates) => [
      q(0234),
      q(0),
      ],
   q(united arab emirates (the)) => [
      q(0234),
      q(3),
      ],
   q(united arab emirates, the) => [
      q(0234),
      q(2),
      ],
   q(united kingdom) => [
      q(0235),
      q(0),
      ],
   q(united kingdom (the)) => [
      q(0235),
      q(3),
      ],
   q(united kingdom of great britain and northern ireland) => [
      q(0235),
      q(5),
      ],
   q(united kingdom, the) => [
      q(0235),
      q(2),
      ],
   q(united republic of tanzania) => [
      q(0220),
      q(2),
      ],
   q(united states) => [
      q(0236),
      q(0),
      ],
   q(united states (the)) => [
      q(0236),
      q(3),
      ],
   q(united states minor outlying islands) => [
      q(0237),
      q(0),
      ],
   q(united states minor outlying islands (the)) => [
      q(0237),
      q(3),
      ],
   q(united states minor outlying islands, the) => [
      q(0237),
      q(2),
      ],
   q(united states of america) => [
      q(0236),
      q(6),
      ],
   q(united states virgin islands) => [
      q(0244),
      q(1),
      ],
   q(united states, the) => [
      q(0236),
      q(2),
      ],
   q(uruguay) => [
      q(0238),
      q(0),
      ],
   q(us) => [
      q(0236),
      q(4),
      ],
   q(usa) => [
      q(0236),
      q(5),
      ],
   q(ussr) => [
      q(0251),
      q(0),
      ],
   q(uzbekistan) => [
      q(0239),
      q(0),
      ],
   q(vanuatu) => [
      q(0240),
      q(0),
      ],
   q(vatican city) => [
      q(0098),
      q(7),
      ],
   q(venezuela, bolivarian republic of ) => [
      q(0241),
      q(0),
      ],
   q(viet nam) => [
      q(0242),
      q(0),
      ],
   q(vietnam) => [
      q(0242),
      q(1),
      ],
   q(virgin islands) => [
      q(0244),
      q(4),
      ],
   q(virgin islands (british)) => [
      q(0243),
      q(0),
      ],
   q(virgin islands (u.s.)) => [
      q(0244),
      q(0),
      ],
   q(virgin islands (uk)) => [
      q(0243),
      q(3),
      ],
   q(virgin islands (us)) => [
      q(0244),
      q(2),
      ],
   q(virgin islands, british) => [
      q(0243),
      q(2),
      ],
   q(virgin islands, u.s.) => [
      q(0244),
      q(3),
      ],
   q(wallis and futuna) => [
      q(0245),
      q(0),
      ],
   q(wallis and futuna islands) => [
      q(0245),
      q(1),
      ],
   q(western sahara) => [
      q(0246),
      q(0),
      ],
   q(yemen) => [
      q(0247),
      q(0),
      ],
   q(yemeni republic) => [
      q(0247),
      q(2),
      ],
   q(yemeni republic (the)) => [
      q(0247),
      q(4),
      ],
   q(yemeni republic, the) => [
      q(0247),
      q(3),
      ],
   q(zambia) => [
      q(0248),
      q(0),
      ],
   q(zimbabwe) => [
      q(0249),
      q(0),
      ],
};

$Locale::Codes::Data{'country'}{'code2id'} = {
   q(alpha-2) => {
      q(ad) => [
         q(0006),
         q(0),
         ],
      q(ae) => [
         q(0234),
         q(0),
         ],
      q(af) => [
         q(0001),
         q(0),
         ],
      q(ag) => [
         q(0010),
         q(0),
         ],
      q(ai) => [
         q(0008),
         q(0),
         ],
      q(al) => [
         q(0003),
         q(0),
         ],
      q(am) => [
         q(0012),
         q(0),
         ],
      q(ao) => [
         q(0007),
         q(0),
         ],
      q(aq) => [
         q(0009),
         q(0),
         ],
      q(ar) => [
         q(0011),
         q(0),
         ],
      q(as) => [
         q(0005),
         q(0),
         ],
      q(at) => [
         q(0015),
         q(0),
         ],
      q(au) => [
         q(0014),
         q(0),
         ],
      q(aw) => [
         q(0013),
         q(0),
         ],
      q(ax) => [
         q(0002),
         q(0),
         ],
      q(az) => [
         q(0016),
         q(0),
         ],
      q(ba) => [
         q(0029),
         q(0),
         ],
      q(bb) => [
         q(0020),
         q(0),
         ],
      q(bd) => [
         q(0019),
         q(0),
         ],
      q(be) => [
         q(0022),
         q(0),
         ],
      q(bf) => [
         q(0036),
         q(0),
         ],
      q(bg) => [
         q(0035),
         q(0),
         ],
      q(bh) => [
         q(0018),
         q(0),
         ],
      q(bi) => [
         q(0037),
         q(0),
         ],
      q(bj) => [
         q(0024),
         q(0),
         ],
      q(bl) => [
         q(0185),
         q(0),
         ],
      q(bm) => [
         q(0025),
         q(0),
         ],
      q(bn) => [
         q(0034),
         q(0),
         ],
      q(bo) => [
         q(0027),
         q(0),
         ],
      q(bq) => [
         q(0028),
         q(0),
         ],
      q(br) => [
         q(0032),
         q(0),
         ],
      q(bs) => [
         q(0017),
         q(0),
         ],
      q(bt) => [
         q(0026),
         q(0),
         ],
      q(bv) => [
         q(0031),
         q(0),
         ],
      q(bw) => [
         q(0030),
         q(0),
         ],
      q(by) => [
         q(0021),
         q(0),
         ],
      q(bz) => [
         q(0023),
         q(0),
         ],
      q(ca) => [
         q(0040),
         q(0),
         ],
      q(cc) => [
         q(0048),
         q(0),
         ],
      q(cd) => [
         q(0052),
         q(0),
         ],
      q(cf) => [
         q(0043),
         q(0),
         ],
      q(cg) => [
         q(0051),
         q(0),
         ],
      q(ch) => [
         q(0216),
         q(0),
         ],
      q(ci) => [
         q(0055),
         q(0),
         ],
      q(ck) => [
         q(0053),
         q(0),
         ],
      q(cl) => [
         q(0045),
         q(0),
         ],
      q(cm) => [
         q(0039),
         q(0),
         ],
      q(cn) => [
         q(0046),
         q(0),
         ],
      q(co) => [
         q(0049),
         q(0),
         ],
      q(cr) => [
         q(0054),
         q(0),
         ],
      q(cu) => [
         q(0057),
         q(0),
         ],
      q(cv) => [
         q(0041),
         q(0),
         ],
      q(cw) => [
         q(0058),
         q(0),
         ],
      q(cx) => [
         q(0047),
         q(0),
         ],
      q(cy) => [
         q(0059),
         q(0),
         ],
      q(cz) => [
         q(0060),
         q(0),
         ],
      q(de) => [
         q(0083),
         q(0),
         ],
      q(dj) => [
         q(0062),
         q(0),
         ],
      q(dk) => [
         q(0061),
         q(0),
         ],
      q(dm) => [
         q(0063),
         q(0),
         ],
      q(do) => [
         q(0064),
         q(0),
         ],
      q(dz) => [
         q(0004),
         q(0),
         ],
      q(ec) => [
         q(0065),
         q(0),
         ],
      q(ee) => [
         q(0070),
         q(0),
         ],
      q(eg) => [
         q(0066),
         q(0),
         ],
      q(eh) => [
         q(0246),
         q(0),
         ],
      q(er) => [
         q(0069),
         q(0),
         ],
      q(es) => [
         q(0209),
         q(0),
         ],
      q(et) => [
         q(0071),
         q(0),
         ],
      q(fi) => [
         q(0075),
         q(0),
         ],
      q(fj) => [
         q(0074),
         q(0),
         ],
      q(fk) => [
         q(0072),
         q(0),
         ],
      q(fm) => [
         q(0145),
         q(0),
         ],
      q(fo) => [
         q(0073),
         q(0),
         ],
      q(fr) => [
         q(0076),
         q(0),
         ],
      q(ga) => [
         q(0080),
         q(0),
         ],
      q(gb) => [
         q(0235),
         q(0),
         ],
      q(gd) => [
         q(0088),
         q(0),
         ],
      q(ge) => [
         q(0082),
         q(0),
         ],
      q(gf) => [
         q(0077),
         q(0),
         ],
      q(gg) => [
         q(0092),
         q(0),
         ],
      q(gh) => [
         q(0084),
         q(0),
         ],
      q(gi) => [
         q(0085),
         q(0),
         ],
      q(gl) => [
         q(0087),
         q(0),
         ],
      q(gm) => [
         q(0081),
         q(0),
         ],
      q(gn) => [
         q(0093),
         q(0),
         ],
      q(gp) => [
         q(0089),
         q(0),
         ],
      q(gq) => [
         q(0068),
         q(0),
         ],
      q(gr) => [
         q(0086),
         q(0),
         ],
      q(gs) => [
         q(0207),
         q(0),
         ],
      q(gt) => [
         q(0091),
         q(0),
         ],
      q(gu) => [
         q(0090),
         q(0),
         ],
      q(gw) => [
         q(0094),
         q(0),
         ],
      q(gy) => [
         q(0095),
         q(0),
         ],
      q(hk) => [
         q(0100),
         q(0),
         ],
      q(hm) => [
         q(0097),
         q(0),
         ],
      q(hn) => [
         q(0099),
         q(0),
         ],
      q(hr) => [
         q(0056),
         q(0),
         ],
      q(ht) => [
         q(0096),
         q(0),
         ],
      q(hu) => [
         q(0101),
         q(0),
         ],
      q(id) => [
         q(0104),
         q(0),
         ],
      q(ie) => [
         q(0107),
         q(0),
         ],
      q(il) => [
         q(0109),
         q(0),
         ],
      q(im) => [
         q(0108),
         q(0),
         ],
      q(in) => [
         q(0103),
         q(0),
         ],
      q(io) => [
         q(0033),
         q(0),
         ],
      q(iq) => [
         q(0106),
         q(0),
         ],
      q(ir) => [
         q(0105),
         q(0),
         ],
      q(is) => [
         q(0102),
         q(0),
         ],
      q(it) => [
         q(0110),
         q(0),
         ],
      q(je) => [
         q(0113),
         q(0),
         ],
      q(jm) => [
         q(0111),
         q(0),
         ],
      q(jo) => [
         q(0114),
         q(0),
         ],
      q(jp) => [
         q(0112),
         q(0),
         ],
      q(ke) => [
         q(0116),
         q(0),
         ],
      q(kg) => [
         q(0121),
         q(0),
         ],
      q(kh) => [
         q(0038),
         q(0),
         ],
      q(ki) => [
         q(0117),
         q(0),
         ],
      q(km) => [
         q(0050),
         q(0),
         ],
      q(kn) => [
         q(0187),
         q(0),
         ],
      q(kp) => [
         q(0118),
         q(0),
         ],
      q(kr) => [
         q(0119),
         q(0),
         ],
      q(kw) => [
         q(0120),
         q(0),
         ],
      q(ky) => [
         q(0042),
         q(0),
         ],
      q(kz) => [
         q(0115),
         q(0),
         ],
      q(la) => [
         q(0122),
         q(0),
         ],
      q(lb) => [
         q(0124),
         q(0),
         ],
      q(lc) => [
         q(0188),
         q(0),
         ],
      q(li) => [
         q(0128),
         q(0),
         ],
      q(lk) => [
         q(0210),
         q(0),
         ],
      q(lr) => [
         q(0126),
         q(0),
         ],
      q(ls) => [
         q(0125),
         q(0),
         ],
      q(lt) => [
         q(0129),
         q(0),
         ],
      q(lu) => [
         q(0130),
         q(0),
         ],
      q(lv) => [
         q(0123),
         q(0),
         ],
      q(ly) => [
         q(0127),
         q(0),
         ],
      q(ma) => [
         q(0151),
         q(0),
         ],
      q(mc) => [
         q(0147),
         q(0),
         ],
      q(md) => [
         q(0146),
         q(0),
         ],
      q(me) => [
         q(0149),
         q(0),
         ],
      q(mf) => [
         q(0189),
         q(0),
         ],
      q(mg) => [
         q(0133),
         q(0),
         ],
      q(mh) => [
         q(0139),
         q(0),
         ],
      q(mk) => [
         q(0132),
         q(0),
         ],
      q(ml) => [
         q(0137),
         q(0),
         ],
      q(mm) => [
         q(0153),
         q(0),
         ],
      q(mn) => [
         q(0148),
         q(0),
         ],
      q(mo) => [
         q(0131),
         q(0),
         ],
      q(mp) => [
         q(0165),
         q(0),
         ],
      q(mq) => [
         q(0140),
         q(0),
         ],
      q(mr) => [
         q(0141),
         q(0),
         ],
      q(ms) => [
         q(0150),
         q(0),
         ],
      q(mt) => [
         q(0138),
         q(0),
         ],
      q(mu) => [
         q(0142),
         q(0),
         ],
      q(mv) => [
         q(0136),
         q(0),
         ],
      q(mw) => [
         q(0134),
         q(0),
         ],
      q(mx) => [
         q(0144),
         q(0),
         ],
      q(my) => [
         q(0135),
         q(0),
         ],
      q(mz) => [
         q(0152),
         q(0),
         ],
      q(na) => [
         q(0154),
         q(0),
         ],
      q(nc) => [
         q(0158),
         q(0),
         ],
      q(ne) => [
         q(0161),
         q(0),
         ],
      q(nf) => [
         q(0164),
         q(0),
         ],
      q(ng) => [
         q(0162),
         q(0),
         ],
      q(ni) => [
         q(0160),
         q(0),
         ],
      q(nl) => [
         q(0157),
         q(0),
         ],
      q(no) => [
         q(0166),
         q(0),
         ],
      q(np) => [
         q(0156),
         q(0),
         ],
      q(nr) => [
         q(0155),
         q(0),
         ],
      q(nu) => [
         q(0163),
         q(0),
         ],
      q(nz) => [
         q(0159),
         q(0),
         ],
      q(om) => [
         q(0167),
         q(0),
         ],
      q(pa) => [
         q(0171),
         q(0),
         ],
      q(pe) => [
         q(0174),
         q(0),
         ],
      q(pf) => [
         q(0078),
         q(0),
         ],
      q(pg) => [
         q(0172),
         q(0),
         ],
      q(ph) => [
         q(0175),
         q(0),
         ],
      q(pk) => [
         q(0168),
         q(0),
         ],
      q(pl) => [
         q(0177),
         q(0),
         ],
      q(pm) => [
         q(0190),
         q(0),
         ],
      q(pn) => [
         q(0176),
         q(0),
         ],
      q(pr) => [
         q(0179),
         q(0),
         ],
      q(ps) => [
         q(0170),
         q(0),
         ],
      q(pt) => [
         q(0178),
         q(0),
         ],
      q(pw) => [
         q(0169),
         q(0),
         ],
      q(py) => [
         q(0173),
         q(0),
         ],
      q(qa) => [
         q(0180),
         q(0),
         ],
      q(re) => [
         q(0181),
         q(0),
         ],
      q(ro) => [
         q(0182),
         q(0),
         ],
      q(rs) => [
         q(0197),
         q(0),
         ],
      q(ru) => [
         q(0183),
         q(0),
         ],
      q(rw) => [
         q(0184),
         q(0),
         ],
      q(sa) => [
         q(0195),
         q(0),
         ],
      q(sb) => [
         q(0204),
         q(0),
         ],
      q(sc) => [
         q(0198),
         q(0),
         ],
      q(sd) => [
         q(0211),
         q(0),
         ],
      q(se) => [
         q(0215),
         q(0),
         ],
      q(sg) => [
         q(0200),
         q(0),
         ],
      q(sh) => [
         q(0186),
         q(0),
         ],
      q(si) => [
         q(0203),
         q(0),
         ],
      q(sj) => [
         q(0213),
         q(0),
         ],
      q(sk) => [
         q(0202),
         q(0),
         ],
      q(sl) => [
         q(0199),
         q(0),
         ],
      q(sm) => [
         q(0193),
         q(0),
         ],
      q(sn) => [
         q(0196),
         q(0),
         ],
      q(so) => [
         q(0205),
         q(0),
         ],
      q(sr) => [
         q(0212),
         q(0),
         ],
      q(ss) => [
         q(0208),
         q(0),
         ],
      q(st) => [
         q(0194),
         q(0),
         ],
      q(sv) => [
         q(0067),
         q(0),
         ],
      q(sx) => [
         q(0201),
         q(0),
         ],
      q(sy) => [
         q(0217),
         q(0),
         ],
      q(sz) => [
         q(0214),
         q(0),
         ],
      q(tc) => [
         q(0230),
         q(0),
         ],
      q(td) => [
         q(0044),
         q(0),
         ],
      q(tf) => [
         q(0079),
         q(0),
         ],
      q(tg) => [
         q(0223),
         q(0),
         ],
      q(th) => [
         q(0221),
         q(0),
         ],
      q(tj) => [
         q(0219),
         q(0),
         ],
      q(tk) => [
         q(0224),
         q(0),
         ],
      q(tl) => [
         q(0222),
         q(0),
         ],
      q(tm) => [
         q(0229),
         q(0),
         ],
      q(tn) => [
         q(0227),
         q(0),
         ],
      q(to) => [
         q(0225),
         q(0),
         ],
      q(tr) => [
         q(0228),
         q(0),
         ],
      q(tt) => [
         q(0226),
         q(0),
         ],
      q(tv) => [
         q(0231),
         q(0),
         ],
      q(tw) => [
         q(0218),
         q(0),
         ],
      q(tz) => [
         q(0220),
         q(0),
         ],
      q(ua) => [
         q(0233),
         q(0),
         ],
      q(ug) => [
         q(0232),
         q(0),
         ],
      q(um) => [
         q(0237),
         q(0),
         ],
      q(us) => [
         q(0236),
         q(0),
         ],
      q(uy) => [
         q(0238),
         q(0),
         ],
      q(uz) => [
         q(0239),
         q(0),
         ],
      q(va) => [
         q(0098),
         q(0),
         ],
      q(vc) => [
         q(0191),
         q(0),
         ],
      q(ve) => [
         q(0241),
         q(0),
         ],
      q(vg) => [
         q(0243),
         q(0),
         ],
      q(vi) => [
         q(0244),
         q(0),
         ],
      q(vn) => [
         q(0242),
         q(0),
         ],
      q(vu) => [
         q(0240),
         q(0),
         ],
      q(wf) => [
         q(0245),
         q(0),
         ],
      q(ws) => [
         q(0192),
         q(0),
         ],
      q(ye) => [
         q(0247),
         q(0),
         ],
      q(yt) => [
         q(0143),
         q(0),
         ],
      q(za) => [
         q(0206),
         q(0),
         ],
      q(zm) => [
         q(0248),
         q(0),
         ],
      q(zw) => [
         q(0249),
         q(0),
         ],
      },
   q(alpha-3) => {
      q(abw) => [
         q(0013),
         q(0),
         ],
      q(afg) => [
         q(0001),
         q(0),
         ],
      q(ago) => [
         q(0007),
         q(0),
         ],
      q(aia) => [
         q(0008),
         q(0),
         ],
      q(ala) => [
         q(0002),
         q(0),
         ],
      q(alb) => [
         q(0003),
         q(0),
         ],
      q(and) => [
         q(0006),
         q(0),
         ],
      q(are) => [
         q(0234),
         q(0),
         ],
      q(arg) => [
         q(0011),
         q(0),
         ],
      q(arm) => [
         q(0012),
         q(0),
         ],
      q(asm) => [
         q(0005),
         q(0),
         ],
      q(ata) => [
         q(0009),
         q(0),
         ],
      q(atf) => [
         q(0079),
         q(0),
         ],
      q(atg) => [
         q(0010),
         q(0),
         ],
      q(aus) => [
         q(0014),
         q(0),
         ],
      q(aut) => [
         q(0015),
         q(0),
         ],
      q(aze) => [
         q(0016),
         q(0),
         ],
      q(bdi) => [
         q(0037),
         q(0),
         ],
      q(bel) => [
         q(0022),
         q(0),
         ],
      q(ben) => [
         q(0024),
         q(0),
         ],
      q(bes) => [
         q(0028),
         q(0),
         ],
      q(bfa) => [
         q(0036),
         q(0),
         ],
      q(bgd) => [
         q(0019),
         q(0),
         ],
      q(bgr) => [
         q(0035),
         q(0),
         ],
      q(bhr) => [
         q(0018),
         q(0),
         ],
      q(bhs) => [
         q(0017),
         q(0),
         ],
      q(bih) => [
         q(0029),
         q(0),
         ],
      q(blm) => [
         q(0185),
         q(0),
         ],
      q(blr) => [
         q(0021),
         q(0),
         ],
      q(blz) => [
         q(0023),
         q(0),
         ],
      q(bmu) => [
         q(0025),
         q(0),
         ],
      q(bol) => [
         q(0027),
         q(0),
         ],
      q(bra) => [
         q(0032),
         q(0),
         ],
      q(brb) => [
         q(0020),
         q(0),
         ],
      q(brn) => [
         q(0034),
         q(0),
         ],
      q(btn) => [
         q(0026),
         q(0),
         ],
      q(bvt) => [
         q(0031),
         q(0),
         ],
      q(bwa) => [
         q(0030),
         q(0),
         ],
      q(caf) => [
         q(0043),
         q(0),
         ],
      q(can) => [
         q(0040),
         q(0),
         ],
      q(cck) => [
         q(0048),
         q(0),
         ],
      q(che) => [
         q(0216),
         q(0),
         ],
      q(chl) => [
         q(0045),
         q(0),
         ],
      q(chn) => [
         q(0046),
         q(0),
         ],
      q(civ) => [
         q(0055),
         q(0),
         ],
      q(cmr) => [
         q(0039),
         q(0),
         ],
      q(cod) => [
         q(0052),
         q(0),
         ],
      q(cog) => [
         q(0051),
         q(0),
         ],
      q(cok) => [
         q(0053),
         q(0),
         ],
      q(col) => [
         q(0049),
         q(0),
         ],
      q(com) => [
         q(0050),
         q(0),
         ],
      q(cpv) => [
         q(0041),
         q(0),
         ],
      q(cri) => [
         q(0054),
         q(0),
         ],
      q(cub) => [
         q(0057),
         q(0),
         ],
      q(cuw) => [
         q(0058),
         q(0),
         ],
      q(cxr) => [
         q(0047),
         q(0),
         ],
      q(cym) => [
         q(0042),
         q(0),
         ],
      q(cyp) => [
         q(0059),
         q(0),
         ],
      q(cze) => [
         q(0060),
         q(0),
         ],
      q(deu) => [
         q(0083),
         q(0),
         ],
      q(dji) => [
         q(0062),
         q(0),
         ],
      q(dma) => [
         q(0063),
         q(0),
         ],
      q(dnk) => [
         q(0061),
         q(0),
         ],
      q(dom) => [
         q(0064),
         q(0),
         ],
      q(dza) => [
         q(0004),
         q(0),
         ],
      q(ecu) => [
         q(0065),
         q(0),
         ],
      q(egy) => [
         q(0066),
         q(0),
         ],
      q(eri) => [
         q(0069),
         q(0),
         ],
      q(esh) => [
         q(0246),
         q(0),
         ],
      q(esp) => [
         q(0209),
         q(0),
         ],
      q(est) => [
         q(0070),
         q(0),
         ],
      q(eth) => [
         q(0071),
         q(0),
         ],
      q(fin) => [
         q(0075),
         q(0),
         ],
      q(fji) => [
         q(0074),
         q(0),
         ],
      q(flk) => [
         q(0072),
         q(0),
         ],
      q(fra) => [
         q(0076),
         q(0),
         ],
      q(fro) => [
         q(0073),
         q(0),
         ],
      q(fsm) => [
         q(0145),
         q(0),
         ],
      q(gab) => [
         q(0080),
         q(0),
         ],
      q(gbr) => [
         q(0235),
         q(0),
         ],
      q(geo) => [
         q(0082),
         q(0),
         ],
      q(ggy) => [
         q(0092),
         q(0),
         ],
      q(gha) => [
         q(0084),
         q(0),
         ],
      q(gib) => [
         q(0085),
         q(0),
         ],
      q(gin) => [
         q(0093),
         q(0),
         ],
      q(glp) => [
         q(0089),
         q(0),
         ],
      q(gmb) => [
         q(0081),
         q(0),
         ],
      q(gnb) => [
         q(0094),
         q(0),
         ],
      q(gnq) => [
         q(0068),
         q(0),
         ],
      q(grc) => [
         q(0086),
         q(0),
         ],
      q(grd) => [
         q(0088),
         q(0),
         ],
      q(grl) => [
         q(0087),
         q(0),
         ],
      q(gtm) => [
         q(0091),
         q(0),
         ],
      q(guf) => [
         q(0077),
         q(0),
         ],
      q(gum) => [
         q(0090),
         q(0),
         ],
      q(guy) => [
         q(0095),
         q(0),
         ],
      q(hkg) => [
         q(0100),
         q(0),
         ],
      q(hmd) => [
         q(0097),
         q(0),
         ],
      q(hnd) => [
         q(0099),
         q(0),
         ],
      q(hrv) => [
         q(0056),
         q(0),
         ],
      q(hti) => [
         q(0096),
         q(0),
         ],
      q(hun) => [
         q(0101),
         q(0),
         ],
      q(idn) => [
         q(0104),
         q(0),
         ],
      q(imn) => [
         q(0108),
         q(0),
         ],
      q(ind) => [
         q(0103),
         q(0),
         ],
      q(iot) => [
         q(0033),
         q(0),
         ],
      q(irl) => [
         q(0107),
         q(0),
         ],
      q(irn) => [
         q(0105),
         q(0),
         ],
      q(irq) => [
         q(0106),
         q(0),
         ],
      q(isl) => [
         q(0102),
         q(0),
         ],
      q(isr) => [
         q(0109),
         q(0),
         ],
      q(ita) => [
         q(0110),
         q(0),
         ],
      q(jam) => [
         q(0111),
         q(0),
         ],
      q(jey) => [
         q(0113),
         q(0),
         ],
      q(jor) => [
         q(0114),
         q(0),
         ],
      q(jpn) => [
         q(0112),
         q(0),
         ],
      q(kaz) => [
         q(0115),
         q(0),
         ],
      q(ken) => [
         q(0116),
         q(0),
         ],
      q(kgz) => [
         q(0121),
         q(0),
         ],
      q(khm) => [
         q(0038),
         q(0),
         ],
      q(kir) => [
         q(0117),
         q(0),
         ],
      q(kna) => [
         q(0187),
         q(0),
         ],
      q(kor) => [
         q(0119),
         q(0),
         ],
      q(kwt) => [
         q(0120),
         q(0),
         ],
      q(lao) => [
         q(0122),
         q(0),
         ],
      q(lbn) => [
         q(0124),
         q(0),
         ],
      q(lbr) => [
         q(0126),
         q(0),
         ],
      q(lby) => [
         q(0127),
         q(0),
         ],
      q(lca) => [
         q(0188),
         q(0),
         ],
      q(lie) => [
         q(0128),
         q(0),
         ],
      q(lka) => [
         q(0210),
         q(0),
         ],
      q(lso) => [
         q(0125),
         q(0),
         ],
      q(ltu) => [
         q(0129),
         q(0),
         ],
      q(lux) => [
         q(0130),
         q(0),
         ],
      q(lva) => [
         q(0123),
         q(0),
         ],
      q(mac) => [
         q(0131),
         q(0),
         ],
      q(maf) => [
         q(0189),
         q(0),
         ],
      q(mar) => [
         q(0151),
         q(0),
         ],
      q(mco) => [
         q(0147),
         q(0),
         ],
      q(mda) => [
         q(0146),
         q(0),
         ],
      q(mdg) => [
         q(0133),
         q(0),
         ],
      q(mdv) => [
         q(0136),
         q(0),
         ],
      q(mex) => [
         q(0144),
         q(0),
         ],
      q(mhl) => [
         q(0139),
         q(0),
         ],
      q(mkd) => [
         q(0132),
         q(0),
         ],
      q(mli) => [
         q(0137),
         q(0),
         ],
      q(mlt) => [
         q(0138),
         q(0),
         ],
      q(mmr) => [
         q(0153),
         q(0),
         ],
      q(mne) => [
         q(0149),
         q(0),
         ],
      q(mng) => [
         q(0148),
         q(0),
         ],
      q(mnp) => [
         q(0165),
         q(0),
         ],
      q(moz) => [
         q(0152),
         q(0),
         ],
      q(mrt) => [
         q(0141),
         q(0),
         ],
      q(msr) => [
         q(0150),
         q(0),
         ],
      q(mtq) => [
         q(0140),
         q(0),
         ],
      q(mus) => [
         q(0142),
         q(0),
         ],
      q(mwi) => [
         q(0134),
         q(0),
         ],
      q(mys) => [
         q(0135),
         q(0),
         ],
      q(myt) => [
         q(0143),
         q(0),
         ],
      q(nam) => [
         q(0154),
         q(0),
         ],
      q(ncl) => [
         q(0158),
         q(0),
         ],
      q(ner) => [
         q(0161),
         q(0),
         ],
      q(nfk) => [
         q(0164),
         q(0),
         ],
      q(nga) => [
         q(0162),
         q(0),
         ],
      q(nic) => [
         q(0160),
         q(0),
         ],
      q(niu) => [
         q(0163),
         q(0),
         ],
      q(nld) => [
         q(0157),
         q(0),
         ],
      q(nor) => [
         q(0166),
         q(0),
         ],
      q(npl) => [
         q(0156),
         q(0),
         ],
      q(nru) => [
         q(0155),
         q(0),
         ],
      q(nzl) => [
         q(0159),
         q(0),
         ],
      q(omn) => [
         q(0167),
         q(0),
         ],
      q(pak) => [
         q(0168),
         q(0),
         ],
      q(pan) => [
         q(0171),
         q(0),
         ],
      q(pcn) => [
         q(0176),
         q(0),
         ],
      q(per) => [
         q(0174),
         q(0),
         ],
      q(phl) => [
         q(0175),
         q(0),
         ],
      q(plw) => [
         q(0169),
         q(0),
         ],
      q(png) => [
         q(0172),
         q(0),
         ],
      q(pol) => [
         q(0177),
         q(0),
         ],
      q(pri) => [
         q(0179),
         q(0),
         ],
      q(prk) => [
         q(0118),
         q(0),
         ],
      q(prt) => [
         q(0178),
         q(0),
         ],
      q(pry) => [
         q(0173),
         q(0),
         ],
      q(pse) => [
         q(0170),
         q(0),
         ],
      q(pyf) => [
         q(0078),
         q(0),
         ],
      q(qat) => [
         q(0180),
         q(0),
         ],
      q(reu) => [
         q(0181),
         q(0),
         ],
      q(rou) => [
         q(0182),
         q(0),
         ],
      q(rus) => [
         q(0183),
         q(0),
         ],
      q(rwa) => [
         q(0184),
         q(0),
         ],
      q(sau) => [
         q(0195),
         q(0),
         ],
      q(sdn) => [
         q(0211),
         q(0),
         ],
      q(sen) => [
         q(0196),
         q(0),
         ],
      q(sgp) => [
         q(0200),
         q(0),
         ],
      q(sgs) => [
         q(0207),
         q(0),
         ],
      q(shn) => [
         q(0186),
         q(0),
         ],
      q(sjm) => [
         q(0213),
         q(0),
         ],
      q(slb) => [
         q(0204),
         q(0),
         ],
      q(sle) => [
         q(0199),
         q(0),
         ],
      q(slv) => [
         q(0067),
         q(0),
         ],
      q(smr) => [
         q(0193),
         q(0),
         ],
      q(som) => [
         q(0205),
         q(0),
         ],
      q(spm) => [
         q(0190),
         q(0),
         ],
      q(srb) => [
         q(0197),
         q(0),
         ],
      q(ssd) => [
         q(0208),
         q(0),
         ],
      q(stp) => [
         q(0194),
         q(0),
         ],
      q(sur) => [
         q(0212),
         q(0),
         ],
      q(svk) => [
         q(0202),
         q(0),
         ],
      q(svn) => [
         q(0203),
         q(0),
         ],
      q(swe) => [
         q(0215),
         q(0),
         ],
      q(swz) => [
         q(0214),
         q(0),
         ],
      q(sxm) => [
         q(0201),
         q(0),
         ],
      q(syc) => [
         q(0198),
         q(0),
         ],
      q(syr) => [
         q(0217),
         q(0),
         ],
      q(tca) => [
         q(0230),
         q(0),
         ],
      q(tcd) => [
         q(0044),
         q(0),
         ],
      q(tgo) => [
         q(0223),
         q(0),
         ],
      q(tha) => [
         q(0221),
         q(0),
         ],
      q(tjk) => [
         q(0219),
         q(0),
         ],
      q(tkl) => [
         q(0224),
         q(0),
         ],
      q(tkm) => [
         q(0229),
         q(0),
         ],
      q(tls) => [
         q(0222),
         q(0),
         ],
      q(ton) => [
         q(0225),
         q(0),
         ],
      q(tto) => [
         q(0226),
         q(0),
         ],
      q(tun) => [
         q(0227),
         q(0),
         ],
      q(tur) => [
         q(0228),
         q(0),
         ],
      q(tuv) => [
         q(0231),
         q(0),
         ],
      q(twn) => [
         q(0218),
         q(0),
         ],
      q(tza) => [
         q(0220),
         q(0),
         ],
      q(uga) => [
         q(0232),
         q(0),
         ],
      q(ukr) => [
         q(0233),
         q(0),
         ],
      q(umi) => [
         q(0237),
         q(0),
         ],
      q(ury) => [
         q(0238),
         q(0),
         ],
      q(usa) => [
         q(0236),
         q(0),
         ],
      q(uzb) => [
         q(0239),
         q(0),
         ],
      q(vat) => [
         q(0098),
         q(0),
         ],
      q(vct) => [
         q(0191),
         q(0),
         ],
      q(ven) => [
         q(0241),
         q(0),
         ],
      q(vgb) => [
         q(0243),
         q(0),
         ],
      q(vir) => [
         q(0244),
         q(0),
         ],
      q(vnm) => [
         q(0242),
         q(0),
         ],
      q(vut) => [
         q(0240),
         q(0),
         ],
      q(wlf) => [
         q(0245),
         q(0),
         ],
      q(wsm) => [
         q(0192),
         q(0),
         ],
      q(yem) => [
         q(0247),
         q(0),
         ],
      q(zaf) => [
         q(0206),
         q(0),
         ],
      q(zmb) => [
         q(0248),
         q(0),
         ],
      q(zwe) => [
         q(0249),
         q(0),
         ],
      },
   q(dom) => {
      q(ad) => [
         q(0006),
         q(0),
         ],
      q(ae) => [
         q(0234),
         q(0),
         ],
      q(af) => [
         q(0001),
         q(0),
         ],
      q(ag) => [
         q(0010),
         q(0),
         ],
      q(ai) => [
         q(0008),
         q(0),
         ],
      q(al) => [
         q(0003),
         q(0),
         ],
      q(am) => [
         q(0012),
         q(0),
         ],
      q(an) => [
         q(0250),
         q(0),
         ],
      q(ao) => [
         q(0007),
         q(0),
         ],
      q(aq) => [
         q(0009),
         q(0),
         ],
      q(ar) => [
         q(0011),
         q(0),
         ],
      q(as) => [
         q(0005),
         q(0),
         ],
      q(at) => [
         q(0015),
         q(0),
         ],
      q(au) => [
         q(0014),
         q(0),
         ],
      q(aw) => [
         q(0013),
         q(0),
         ],
      q(ax) => [
         q(0002),
         q(0),
         ],
      q(az) => [
         q(0016),
         q(0),
         ],
      q(ba) => [
         q(0029),
         q(0),
         ],
      q(bb) => [
         q(0020),
         q(0),
         ],
      q(bd) => [
         q(0019),
         q(0),
         ],
      q(be) => [
         q(0022),
         q(0),
         ],
      q(bf) => [
         q(0036),
         q(0),
         ],
      q(bg) => [
         q(0035),
         q(0),
         ],
      q(bh) => [
         q(0018),
         q(0),
         ],
      q(bi) => [
         q(0037),
         q(0),
         ],
      q(bj) => [
         q(0024),
         q(0),
         ],
      q(bl) => [
         q(0185),
         q(0),
         ],
      q(bm) => [
         q(0025),
         q(0),
         ],
      q(bn) => [
         q(0034),
         q(0),
         ],
      q(bo) => [
         q(0027),
         q(0),
         ],
      q(bq) => [
         q(0028),
         q(0),
         ],
      q(br) => [
         q(0032),
         q(0),
         ],
      q(bs) => [
         q(0017),
         q(0),
         ],
      q(bt) => [
         q(0026),
         q(0),
         ],
      q(bv) => [
         q(0031),
         q(0),
         ],
      q(bw) => [
         q(0030),
         q(0),
         ],
      q(by) => [
         q(0021),
         q(0),
         ],
      q(bz) => [
         q(0023),
         q(0),
         ],
      q(ca) => [
         q(0040),
         q(0),
         ],
      q(cc) => [
         q(0048),
         q(0),
         ],
      q(cd) => [
         q(0052),
         q(0),
         ],
      q(cf) => [
         q(0043),
         q(0),
         ],
      q(cg) => [
         q(0051),
         q(0),
         ],
      q(ch) => [
         q(0216),
         q(0),
         ],
      q(ci) => [
         q(0055),
         q(0),
         ],
      q(ck) => [
         q(0053),
         q(0),
         ],
      q(cl) => [
         q(0045),
         q(0),
         ],
      q(cm) => [
         q(0039),
         q(0),
         ],
      q(cn) => [
         q(0046),
         q(0),
         ],
      q(co) => [
         q(0049),
         q(0),
         ],
      q(cr) => [
         q(0054),
         q(0),
         ],
      q(cu) => [
         q(0057),
         q(0),
         ],
      q(cv) => [
         q(0041),
         q(0),
         ],
      q(cw) => [
         q(0058),
         q(0),
         ],
      q(cx) => [
         q(0047),
         q(0),
         ],
      q(cy) => [
         q(0059),
         q(0),
         ],
      q(cz) => [
         q(0060),
         q(0),
         ],
      q(de) => [
         q(0083),
         q(0),
         ],
      q(dj) => [
         q(0062),
         q(0),
         ],
      q(dk) => [
         q(0061),
         q(0),
         ],
      q(dm) => [
         q(0063),
         q(0),
         ],
      q(do) => [
         q(0064),
         q(0),
         ],
      q(dz) => [
         q(0004),
         q(0),
         ],
      q(ec) => [
         q(0065),
         q(0),
         ],
      q(ee) => [
         q(0070),
         q(0),
         ],
      q(eg) => [
         q(0066),
         q(0),
         ],
      q(eh) => [
         q(0246),
         q(0),
         ],
      q(er) => [
         q(0069),
         q(0),
         ],
      q(es) => [
         q(0209),
         q(0),
         ],
      q(et) => [
         q(0071),
         q(0),
         ],
      q(fi) => [
         q(0075),
         q(0),
         ],
      q(fj) => [
         q(0074),
         q(0),
         ],
      q(fk) => [
         q(0072),
         q(0),
         ],
      q(fm) => [
         q(0145),
         q(0),
         ],
      q(fo) => [
         q(0073),
         q(0),
         ],
      q(fr) => [
         q(0076),
         q(0),
         ],
      q(ga) => [
         q(0080),
         q(0),
         ],
      q(gb) => [
         q(0235),
         q(0),
         ],
      q(gd) => [
         q(0088),
         q(0),
         ],
      q(ge) => [
         q(0082),
         q(0),
         ],
      q(gf) => [
         q(0077),
         q(0),
         ],
      q(gg) => [
         q(0092),
         q(0),
         ],
      q(gh) => [
         q(0084),
         q(0),
         ],
      q(gi) => [
         q(0085),
         q(0),
         ],
      q(gl) => [
         q(0087),
         q(0),
         ],
      q(gm) => [
         q(0081),
         q(0),
         ],
      q(gn) => [
         q(0093),
         q(0),
         ],
      q(gp) => [
         q(0089),
         q(0),
         ],
      q(gq) => [
         q(0068),
         q(0),
         ],
      q(gr) => [
         q(0086),
         q(0),
         ],
      q(gs) => [
         q(0207),
         q(0),
         ],
      q(gt) => [
         q(0091),
         q(0),
         ],
      q(gu) => [
         q(0090),
         q(0),
         ],
      q(gw) => [
         q(0094),
         q(0),
         ],
      q(gy) => [
         q(0095),
         q(0),
         ],
      q(hk) => [
         q(0100),
         q(0),
         ],
      q(hm) => [
         q(0097),
         q(0),
         ],
      q(hn) => [
         q(0099),
         q(0),
         ],
      q(hr) => [
         q(0056),
         q(0),
         ],
      q(ht) => [
         q(0096),
         q(0),
         ],
      q(hu) => [
         q(0101),
         q(0),
         ],
      q(id) => [
         q(0104),
         q(0),
         ],
      q(ie) => [
         q(0107),
         q(0),
         ],
      q(il) => [
         q(0109),
         q(0),
         ],
      q(im) => [
         q(0108),
         q(0),
         ],
      q(in) => [
         q(0103),
         q(0),
         ],
      q(io) => [
         q(0033),
         q(0),
         ],
      q(iq) => [
         q(0106),
         q(0),
         ],
      q(ir) => [
         q(0105),
         q(0),
         ],
      q(is) => [
         q(0102),
         q(0),
         ],
      q(it) => [
         q(0110),
         q(0),
         ],
      q(je) => [
         q(0113),
         q(0),
         ],
      q(jm) => [
         q(0111),
         q(0),
         ],
      q(jo) => [
         q(0114),
         q(0),
         ],
      q(jp) => [
         q(0112),
         q(0),
         ],
      q(ke) => [
         q(0116),
         q(0),
         ],
      q(kg) => [
         q(0121),
         q(0),
         ],
      q(kh) => [
         q(0038),
         q(0),
         ],
      q(ki) => [
         q(0117),
         q(0),
         ],
      q(km) => [
         q(0050),
         q(0),
         ],
      q(kn) => [
         q(0187),
         q(0),
         ],
      q(kp) => [
         q(0118),
         q(0),
         ],
      q(kr) => [
         q(0119),
         q(0),
         ],
      q(kw) => [
         q(0120),
         q(0),
         ],
      q(ky) => [
         q(0042),
         q(0),
         ],
      q(kz) => [
         q(0115),
         q(0),
         ],
      q(la) => [
         q(0122),
         q(0),
         ],
      q(lb) => [
         q(0124),
         q(0),
         ],
      q(lc) => [
         q(0188),
         q(0),
         ],
      q(li) => [
         q(0128),
         q(0),
         ],
      q(lk) => [
         q(0210),
         q(0),
         ],
      q(lr) => [
         q(0126),
         q(0),
         ],
      q(ls) => [
         q(0125),
         q(0),
         ],
      q(lt) => [
         q(0129),
         q(0),
         ],
      q(lu) => [
         q(0130),
         q(0),
         ],
      q(lv) => [
         q(0123),
         q(0),
         ],
      q(ly) => [
         q(0127),
         q(0),
         ],
      q(ma) => [
         q(0151),
         q(0),
         ],
      q(mc) => [
         q(0147),
         q(0),
         ],
      q(md) => [
         q(0146),
         q(0),
         ],
      q(me) => [
         q(0149),
         q(0),
         ],
      q(mf) => [
         q(0189),
         q(0),
         ],
      q(mg) => [
         q(0133),
         q(0),
         ],
      q(mh) => [
         q(0139),
         q(0),
         ],
      q(mk) => [
         q(0132),
         q(0),
         ],
      q(ml) => [
         q(0137),
         q(0),
         ],
      q(mm) => [
         q(0153),
         q(0),
         ],
      q(mn) => [
         q(0148),
         q(0),
         ],
      q(mo) => [
         q(0131),
         q(0),
         ],
      q(mp) => [
         q(0165),
         q(0),
         ],
      q(mq) => [
         q(0140),
         q(0),
         ],
      q(mr) => [
         q(0141),
         q(0),
         ],
      q(ms) => [
         q(0150),
         q(0),
         ],
      q(mt) => [
         q(0138),
         q(0),
         ],
      q(mu) => [
         q(0142),
         q(0),
         ],
      q(mv) => [
         q(0136),
         q(0),
         ],
      q(mw) => [
         q(0134),
         q(0),
         ],
      q(mx) => [
         q(0144),
         q(0),
         ],
      q(my) => [
         q(0135),
         q(0),
         ],
      q(mz) => [
         q(0152),
         q(0),
         ],
      q(na) => [
         q(0154),
         q(0),
         ],
      q(nc) => [
         q(0158),
         q(0),
         ],
      q(ne) => [
         q(0161),
         q(0),
         ],
      q(nf) => [
         q(0164),
         q(0),
         ],
      q(ng) => [
         q(0162),
         q(0),
         ],
      q(ni) => [
         q(0160),
         q(0),
         ],
      q(nl) => [
         q(0157),
         q(0),
         ],
      q(no) => [
         q(0166),
         q(0),
         ],
      q(np) => [
         q(0156),
         q(0),
         ],
      q(nr) => [
         q(0155),
         q(0),
         ],
      q(nu) => [
         q(0163),
         q(0),
         ],
      q(nz) => [
         q(0159),
         q(0),
         ],
      q(om) => [
         q(0167),
         q(0),
         ],
      q(pa) => [
         q(0171),
         q(0),
         ],
      q(pe) => [
         q(0174),
         q(0),
         ],
      q(pf) => [
         q(0078),
         q(0),
         ],
      q(pg) => [
         q(0172),
         q(0),
         ],
      q(ph) => [
         q(0175),
         q(0),
         ],
      q(pk) => [
         q(0168),
         q(0),
         ],
      q(pl) => [
         q(0177),
         q(0),
         ],
      q(pm) => [
         q(0190),
         q(0),
         ],
      q(pn) => [
         q(0176),
         q(0),
         ],
      q(pr) => [
         q(0179),
         q(0),
         ],
      q(ps) => [
         q(0170),
         q(0),
         ],
      q(pt) => [
         q(0178),
         q(0),
         ],
      q(pw) => [
         q(0169),
         q(0),
         ],
      q(py) => [
         q(0173),
         q(0),
         ],
      q(qa) => [
         q(0180),
         q(0),
         ],
      q(re) => [
         q(0181),
         q(0),
         ],
      q(ro) => [
         q(0182),
         q(0),
         ],
      q(rs) => [
         q(0197),
         q(0),
         ],
      q(ru) => [
         q(0183),
         q(0),
         ],
      q(rw) => [
         q(0184),
         q(0),
         ],
      q(sa) => [
         q(0195),
         q(0),
         ],
      q(sb) => [
         q(0204),
         q(0),
         ],
      q(sc) => [
         q(0198),
         q(0),
         ],
      q(sd) => [
         q(0211),
         q(0),
         ],
      q(se) => [
         q(0215),
         q(0),
         ],
      q(sg) => [
         q(0200),
         q(0),
         ],
      q(sh) => [
         q(0186),
         q(0),
         ],
      q(si) => [
         q(0203),
         q(0),
         ],
      q(sj) => [
         q(0213),
         q(0),
         ],
      q(sk) => [
         q(0202),
         q(0),
         ],
      q(sl) => [
         q(0199),
         q(0),
         ],
      q(sm) => [
         q(0193),
         q(0),
         ],
      q(sn) => [
         q(0196),
         q(0),
         ],
      q(so) => [
         q(0205),
         q(0),
         ],
      q(sr) => [
         q(0212),
         q(0),
         ],
      q(ss) => [
         q(0208),
         q(0),
         ],
      q(st) => [
         q(0194),
         q(0),
         ],
      q(su) => [
         q(0251),
         q(0),
         ],
      q(sv) => [
         q(0067),
         q(0),
         ],
      q(sx) => [
         q(0201),
         q(0),
         ],
      q(sy) => [
         q(0217),
         q(0),
         ],
      q(sz) => [
         q(0214),
         q(0),
         ],
      q(tc) => [
         q(0230),
         q(0),
         ],
      q(td) => [
         q(0044),
         q(0),
         ],
      q(tf) => [
         q(0079),
         q(0),
         ],
      q(tg) => [
         q(0223),
         q(0),
         ],
      q(th) => [
         q(0221),
         q(0),
         ],
      q(tj) => [
         q(0219),
         q(0),
         ],
      q(tk) => [
         q(0224),
         q(0),
         ],
      q(tl) => [
         q(0222),
         q(0),
         ],
      q(tm) => [
         q(0229),
         q(0),
         ],
      q(tn) => [
         q(0227),
         q(0),
         ],
      q(to) => [
         q(0225),
         q(0),
         ],
      q(tp) => [
         q(0222),
         q(1),
         ],
      q(tr) => [
         q(0228),
         q(0),
         ],
      q(tt) => [
         q(0226),
         q(0),
         ],
      q(tv) => [
         q(0231),
         q(0),
         ],
      q(tw) => [
         q(0218),
         q(0),
         ],
      q(tz) => [
         q(0220),
         q(0),
         ],
      q(ua) => [
         q(0233),
         q(0),
         ],
      q(ug) => [
         q(0232),
         q(0),
         ],
      q(um) => [
         q(0237),
         q(0),
         ],
      q(us) => [
         q(0236),
         q(0),
         ],
      q(uy) => [
         q(0238),
         q(0),
         ],
      q(uz) => [
         q(0239),
         q(0),
         ],
      q(va) => [
         q(0098),
         q(0),
         ],
      q(vc) => [
         q(0191),
         q(0),
         ],
      q(ve) => [
         q(0241),
         q(0),
         ],
      q(vg) => [
         q(0243),
         q(0),
         ],
      q(vi) => [
         q(0244),
         q(0),
         ],
      q(vn) => [
         q(0242),
         q(0),
         ],
      q(vu) => [
         q(0240),
         q(0),
         ],
      q(wf) => [
         q(0245),
         q(0),
         ],
      q(ws) => [
         q(0192),
         q(0),
         ],
      q(ye) => [
         q(0247),
         q(0),
         ],
      q(yt) => [
         q(0143),
         q(0),
         ],
      q(za) => [
         q(0206),
         q(0),
         ],
      q(zm) => [
         q(0248),
         q(0),
         ],
      q(zw) => [
         q(0249),
         q(0),
         ],
      },
   q(numeric) => {
      q(004) => [
         q(0001),
         q(0),
         ],
      q(008) => [
         q(0003),
         q(0),
         ],
      q(010) => [
         q(0009),
         q(0),
         ],
      q(012) => [
         q(0004),
         q(0),
         ],
      q(016) => [
         q(0005),
         q(0),
         ],
      q(020) => [
         q(0006),
         q(0),
         ],
      q(024) => [
         q(0007),
         q(0),
         ],
      q(028) => [
         q(0010),
         q(0),
         ],
      q(031) => [
         q(0016),
         q(0),
         ],
      q(032) => [
         q(0011),
         q(0),
         ],
      q(036) => [
         q(0014),
         q(0),
         ],
      q(040) => [
         q(0015),
         q(0),
         ],
      q(044) => [
         q(0017),
         q(0),
         ],
      q(048) => [
         q(0018),
         q(0),
         ],
      q(050) => [
         q(0019),
         q(0),
         ],
      q(051) => [
         q(0012),
         q(0),
         ],
      q(052) => [
         q(0020),
         q(0),
         ],
      q(056) => [
         q(0022),
         q(0),
         ],
      q(060) => [
         q(0025),
         q(0),
         ],
      q(064) => [
         q(0026),
         q(0),
         ],
      q(068) => [
         q(0027),
         q(0),
         ],
      q(070) => [
         q(0029),
         q(0),
         ],
      q(072) => [
         q(0030),
         q(0),
         ],
      q(074) => [
         q(0031),
         q(0),
         ],
      q(076) => [
         q(0032),
         q(0),
         ],
      q(084) => [
         q(0023),
         q(0),
         ],
      q(086) => [
         q(0033),
         q(0),
         ],
      q(090) => [
         q(0204),
         q(0),
         ],
      q(092) => [
         q(0243),
         q(0),
         ],
      q(096) => [
         q(0034),
         q(0),
         ],
      q(100) => [
         q(0035),
         q(0),
         ],
      q(104) => [
         q(0153),
         q(0),
         ],
      q(108) => [
         q(0037),
         q(0),
         ],
      q(112) => [
         q(0021),
         q(0),
         ],
      q(116) => [
         q(0038),
         q(0),
         ],
      q(120) => [
         q(0039),
         q(0),
         ],
      q(124) => [
         q(0040),
         q(0),
         ],
      q(132) => [
         q(0041),
         q(0),
         ],
      q(136) => [
         q(0042),
         q(0),
         ],
      q(140) => [
         q(0043),
         q(0),
         ],
      q(144) => [
         q(0210),
         q(0),
         ],
      q(148) => [
         q(0044),
         q(0),
         ],
      q(152) => [
         q(0045),
         q(0),
         ],
      q(156) => [
         q(0046),
         q(0),
         ],
      q(158) => [
         q(0218),
         q(0),
         ],
      q(162) => [
         q(0047),
         q(0),
         ],
      q(166) => [
         q(0048),
         q(0),
         ],
      q(170) => [
         q(0049),
         q(0),
         ],
      q(174) => [
         q(0050),
         q(0),
         ],
      q(175) => [
         q(0143),
         q(0),
         ],
      q(178) => [
         q(0051),
         q(0),
         ],
      q(180) => [
         q(0052),
         q(0),
         ],
      q(184) => [
         q(0053),
         q(0),
         ],
      q(188) => [
         q(0054),
         q(0),
         ],
      q(191) => [
         q(0056),
         q(0),
         ],
      q(192) => [
         q(0057),
         q(0),
         ],
      q(196) => [
         q(0059),
         q(0),
         ],
      q(203) => [
         q(0060),
         q(0),
         ],
      q(204) => [
         q(0024),
         q(0),
         ],
      q(208) => [
         q(0061),
         q(0),
         ],
      q(212) => [
         q(0063),
         q(0),
         ],
      q(214) => [
         q(0064),
         q(0),
         ],
      q(218) => [
         q(0065),
         q(0),
         ],
      q(222) => [
         q(0067),
         q(0),
         ],
      q(226) => [
         q(0068),
         q(0),
         ],
      q(231) => [
         q(0071),
         q(0),
         ],
      q(232) => [
         q(0069),
         q(0),
         ],
      q(233) => [
         q(0070),
         q(0),
         ],
      q(234) => [
         q(0073),
         q(0),
         ],
      q(238) => [
         q(0072),
         q(0),
         ],
      q(239) => [
         q(0207),
         q(0),
         ],
      q(242) => [
         q(0074),
         q(0),
         ],
      q(246) => [
         q(0075),
         q(0),
         ],
      q(248) => [
         q(0002),
         q(0),
         ],
      q(250) => [
         q(0076),
         q(0),
         ],
      q(254) => [
         q(0077),
         q(0),
         ],
      q(258) => [
         q(0078),
         q(0),
         ],
      q(260) => [
         q(0079),
         q(0),
         ],
      q(262) => [
         q(0062),
         q(0),
         ],
      q(266) => [
         q(0080),
         q(0),
         ],
      q(268) => [
         q(0082),
         q(0),
         ],
      q(270) => [
         q(0081),
         q(0),
         ],
      q(275) => [
         q(0170),
         q(0),
         ],
      q(276) => [
         q(0083),
         q(0),
         ],
      q(288) => [
         q(0084),
         q(0),
         ],
      q(292) => [
         q(0085),
         q(0),
         ],
      q(296) => [
         q(0117),
         q(0),
         ],
      q(300) => [
         q(0086),
         q(0),
         ],
      q(304) => [
         q(0087),
         q(0),
         ],
      q(308) => [
         q(0088),
         q(0),
         ],
      q(312) => [
         q(0089),
         q(0),
         ],
      q(316) => [
         q(0090),
         q(0),
         ],
      q(320) => [
         q(0091),
         q(0),
         ],
      q(324) => [
         q(0093),
         q(0),
         ],
      q(328) => [
         q(0095),
         q(0),
         ],
      q(332) => [
         q(0096),
         q(0),
         ],
      q(334) => [
         q(0097),
         q(0),
         ],
      q(336) => [
         q(0098),
         q(0),
         ],
      q(340) => [
         q(0099),
         q(0),
         ],
      q(344) => [
         q(0100),
         q(0),
         ],
      q(348) => [
         q(0101),
         q(0),
         ],
      q(352) => [
         q(0102),
         q(0),
         ],
      q(356) => [
         q(0103),
         q(0),
         ],
      q(360) => [
         q(0104),
         q(0),
         ],
      q(364) => [
         q(0105),
         q(0),
         ],
      q(368) => [
         q(0106),
         q(0),
         ],
      q(372) => [
         q(0107),
         q(0),
         ],
      q(376) => [
         q(0109),
         q(0),
         ],
      q(380) => [
         q(0110),
         q(0),
         ],
      q(384) => [
         q(0055),
         q(0),
         ],
      q(388) => [
         q(0111),
         q(0),
         ],
      q(392) => [
         q(0112),
         q(0),
         ],
      q(398) => [
         q(0115),
         q(0),
         ],
      q(400) => [
         q(0114),
         q(0),
         ],
      q(404) => [
         q(0116),
         q(0),
         ],
      q(408) => [
         q(0118),
         q(0),
         ],
      q(410) => [
         q(0119),
         q(0),
         ],
      q(414) => [
         q(0120),
         q(0),
         ],
      q(417) => [
         q(0121),
         q(0),
         ],
      q(418) => [
         q(0122),
         q(0),
         ],
      q(422) => [
         q(0124),
         q(0),
         ],
      q(426) => [
         q(0125),
         q(0),
         ],
      q(428) => [
         q(0123),
         q(0),
         ],
      q(430) => [
         q(0126),
         q(0),
         ],
      q(434) => [
         q(0127),
         q(0),
         ],
      q(438) => [
         q(0128),
         q(0),
         ],
      q(440) => [
         q(0129),
         q(0),
         ],
      q(442) => [
         q(0130),
         q(0),
         ],
      q(446) => [
         q(0131),
         q(0),
         ],
      q(450) => [
         q(0133),
         q(0),
         ],
      q(454) => [
         q(0134),
         q(0),
         ],
      q(458) => [
         q(0135),
         q(0),
         ],
      q(462) => [
         q(0136),
         q(0),
         ],
      q(466) => [
         q(0137),
         q(0),
         ],
      q(470) => [
         q(0138),
         q(0),
         ],
      q(474) => [
         q(0140),
         q(0),
         ],
      q(478) => [
         q(0141),
         q(0),
         ],
      q(480) => [
         q(0142),
         q(0),
         ],
      q(484) => [
         q(0144),
         q(0),
         ],
      q(492) => [
         q(0147),
         q(0),
         ],
      q(496) => [
         q(0148),
         q(0),
         ],
      q(498) => [
         q(0146),
         q(0),
         ],
      q(499) => [
         q(0149),
         q(0),
         ],
      q(500) => [
         q(0150),
         q(0),
         ],
      q(504) => [
         q(0151),
         q(0),
         ],
      q(508) => [
         q(0152),
         q(0),
         ],
      q(512) => [
         q(0167),
         q(0),
         ],
      q(516) => [
         q(0154),
         q(0),
         ],
      q(520) => [
         q(0155),
         q(0),
         ],
      q(524) => [
         q(0156),
         q(0),
         ],
      q(528) => [
         q(0157),
         q(0),
         ],
      q(531) => [
         q(0058),
         q(0),
         ],
      q(533) => [
         q(0013),
         q(0),
         ],
      q(534) => [
         q(0201),
         q(0),
         ],
      q(535) => [
         q(0028),
         q(0),
         ],
      q(540) => [
         q(0158),
         q(0),
         ],
      q(548) => [
         q(0240),
         q(0),
         ],
      q(554) => [
         q(0159),
         q(0),
         ],
      q(558) => [
         q(0160),
         q(0),
         ],
      q(562) => [
         q(0161),
         q(0),
         ],
      q(566) => [
         q(0162),
         q(0),
         ],
      q(570) => [
         q(0163),
         q(0),
         ],
      q(574) => [
         q(0164),
         q(0),
         ],
      q(578) => [
         q(0166),
         q(0),
         ],
      q(580) => [
         q(0165),
         q(0),
         ],
      q(581) => [
         q(0237),
         q(0),
         ],
      q(583) => [
         q(0145),
         q(0),
         ],
      q(584) => [
         q(0139),
         q(0),
         ],
      q(585) => [
         q(0169),
         q(0),
         ],
      q(586) => [
         q(0168),
         q(0),
         ],
      q(591) => [
         q(0171),
         q(0),
         ],
      q(598) => [
         q(0172),
         q(0),
         ],
      q(600) => [
         q(0173),
         q(0),
         ],
      q(604) => [
         q(0174),
         q(0),
         ],
      q(608) => [
         q(0175),
         q(0),
         ],
      q(612) => [
         q(0176),
         q(0),
         ],
      q(616) => [
         q(0177),
         q(0),
         ],
      q(620) => [
         q(0178),
         q(0),
         ],
      q(624) => [
         q(0094),
         q(0),
         ],
      q(626) => [
         q(0222),
         q(0),
         ],
      q(630) => [
         q(0179),
         q(0),
         ],
      q(634) => [
         q(0180),
         q(0),
         ],
      q(638) => [
         q(0181),
         q(0),
         ],
      q(642) => [
         q(0182),
         q(0),
         ],
      q(643) => [
         q(0183),
         q(0),
         ],
      q(646) => [
         q(0184),
         q(0),
         ],
      q(652) => [
         q(0185),
         q(0),
         ],
      q(654) => [
         q(0186),
         q(0),
         ],
      q(659) => [
         q(0187),
         q(0),
         ],
      q(660) => [
         q(0008),
         q(0),
         ],
      q(662) => [
         q(0188),
         q(0),
         ],
      q(663) => [
         q(0189),
         q(0),
         ],
      q(666) => [
         q(0190),
         q(0),
         ],
      q(670) => [
         q(0191),
         q(0),
         ],
      q(674) => [
         q(0193),
         q(0),
         ],
      q(678) => [
         q(0194),
         q(0),
         ],
      q(682) => [
         q(0195),
         q(0),
         ],
      q(686) => [
         q(0196),
         q(0),
         ],
      q(688) => [
         q(0197),
         q(0),
         ],
      q(690) => [
         q(0198),
         q(0),
         ],
      q(694) => [
         q(0199),
         q(0),
         ],
      q(702) => [
         q(0200),
         q(0),
         ],
      q(703) => [
         q(0202),
         q(0),
         ],
      q(704) => [
         q(0242),
         q(0),
         ],
      q(705) => [
         q(0203),
         q(0),
         ],
      q(706) => [
         q(0205),
         q(0),
         ],
      q(710) => [
         q(0206),
         q(0),
         ],
      q(716) => [
         q(0249),
         q(0),
         ],
      q(724) => [
         q(0209),
         q(0),
         ],
      q(728) => [
         q(0208),
         q(0),
         ],
      q(729) => [
         q(0211),
         q(0),
         ],
      q(732) => [
         q(0246),
         q(0),
         ],
      q(740) => [
         q(0212),
         q(0),
         ],
      q(744) => [
         q(0213),
         q(0),
         ],
      q(748) => [
         q(0214),
         q(0),
         ],
      q(752) => [
         q(0215),
         q(0),
         ],
      q(756) => [
         q(0216),
         q(0),
         ],
      q(760) => [
         q(0217),
         q(0),
         ],
      q(762) => [
         q(0219),
         q(0),
         ],
      q(764) => [
         q(0221),
         q(0),
         ],
      q(768) => [
         q(0223),
         q(0),
         ],
      q(772) => [
         q(0224),
         q(0),
         ],
      q(776) => [
         q(0225),
         q(0),
         ],
      q(780) => [
         q(0226),
         q(0),
         ],
      q(784) => [
         q(0234),
         q(0),
         ],
      q(788) => [
         q(0227),
         q(0),
         ],
      q(792) => [
         q(0228),
         q(0),
         ],
      q(795) => [
         q(0229),
         q(0),
         ],
      q(796) => [
         q(0230),
         q(0),
         ],
      q(798) => [
         q(0231),
         q(0),
         ],
      q(800) => [
         q(0232),
         q(0),
         ],
      q(804) => [
         q(0233),
         q(0),
         ],
      q(807) => [
         q(0132),
         q(0),
         ],
      q(818) => [
         q(0066),
         q(0),
         ],
      q(826) => [
         q(0235),
         q(0),
         ],
      q(831) => [
         q(0092),
         q(0),
         ],
      q(832) => [
         q(0113),
         q(0),
         ],
      q(833) => [
         q(0108),
         q(0),
         ],
      q(834) => [
         q(0220),
         q(0),
         ],
      q(840) => [
         q(0236),
         q(0),
         ],
      q(850) => [
         q(0244),
         q(0),
         ],
      q(854) => [
         q(0036),
         q(0),
         ],
      q(858) => [
         q(0238),
         q(0),
         ],
      q(860) => [
         q(0239),
         q(0),
         ],
      q(862) => [
         q(0241),
         q(0),
         ],
      q(876) => [
         q(0245),
         q(0),
         ],
      q(882) => [
         q(0192),
         q(0),
         ],
      q(887) => [
         q(0247),
         q(0),
         ],
      q(894) => [
         q(0248),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'country'}{'id2code'} = {
   q(alpha-2) => {
      q(0001) => q(af),
      q(0002) => q(ax),
      q(0003) => q(al),
      q(0004) => q(dz),
      q(0005) => q(as),
      q(0006) => q(ad),
      q(0007) => q(ao),
      q(0008) => q(ai),
      q(0009) => q(aq),
      q(0010) => q(ag),
      q(0011) => q(ar),
      q(0012) => q(am),
      q(0013) => q(aw),
      q(0014) => q(au),
      q(0015) => q(at),
      q(0016) => q(az),
      q(0017) => q(bs),
      q(0018) => q(bh),
      q(0019) => q(bd),
      q(0020) => q(bb),
      q(0021) => q(by),
      q(0022) => q(be),
      q(0023) => q(bz),
      q(0024) => q(bj),
      q(0025) => q(bm),
      q(0026) => q(bt),
      q(0027) => q(bo),
      q(0028) => q(bq),
      q(0029) => q(ba),
      q(0030) => q(bw),
      q(0031) => q(bv),
      q(0032) => q(br),
      q(0033) => q(io),
      q(0034) => q(bn),
      q(0035) => q(bg),
      q(0036) => q(bf),
      q(0037) => q(bi),
      q(0038) => q(kh),
      q(0039) => q(cm),
      q(0040) => q(ca),
      q(0041) => q(cv),
      q(0042) => q(ky),
      q(0043) => q(cf),
      q(0044) => q(td),
      q(0045) => q(cl),
      q(0046) => q(cn),
      q(0047) => q(cx),
      q(0048) => q(cc),
      q(0049) => q(co),
      q(0050) => q(km),
      q(0051) => q(cg),
      q(0052) => q(cd),
      q(0053) => q(ck),
      q(0054) => q(cr),
      q(0055) => q(ci),
      q(0056) => q(hr),
      q(0057) => q(cu),
      q(0058) => q(cw),
      q(0059) => q(cy),
      q(0060) => q(cz),
      q(0061) => q(dk),
      q(0062) => q(dj),
      q(0063) => q(dm),
      q(0064) => q(do),
      q(0065) => q(ec),
      q(0066) => q(eg),
      q(0067) => q(sv),
      q(0068) => q(gq),
      q(0069) => q(er),
      q(0070) => q(ee),
      q(0071) => q(et),
      q(0072) => q(fk),
      q(0073) => q(fo),
      q(0074) => q(fj),
      q(0075) => q(fi),
      q(0076) => q(fr),
      q(0077) => q(gf),
      q(0078) => q(pf),
      q(0079) => q(tf),
      q(0080) => q(ga),
      q(0081) => q(gm),
      q(0082) => q(ge),
      q(0083) => q(de),
      q(0084) => q(gh),
      q(0085) => q(gi),
      q(0086) => q(gr),
      q(0087) => q(gl),
      q(0088) => q(gd),
      q(0089) => q(gp),
      q(0090) => q(gu),
      q(0091) => q(gt),
      q(0092) => q(gg),
      q(0093) => q(gn),
      q(0094) => q(gw),
      q(0095) => q(gy),
      q(0096) => q(ht),
      q(0097) => q(hm),
      q(0098) => q(va),
      q(0099) => q(hn),
      q(0100) => q(hk),
      q(0101) => q(hu),
      q(0102) => q(is),
      q(0103) => q(in),
      q(0104) => q(id),
      q(0105) => q(ir),
      q(0106) => q(iq),
      q(0107) => q(ie),
      q(0108) => q(im),
      q(0109) => q(il),
      q(0110) => q(it),
      q(0111) => q(jm),
      q(0112) => q(jp),
      q(0113) => q(je),
      q(0114) => q(jo),
      q(0115) => q(kz),
      q(0116) => q(ke),
      q(0117) => q(ki),
      q(0118) => q(kp),
      q(0119) => q(kr),
      q(0120) => q(kw),
      q(0121) => q(kg),
      q(0122) => q(la),
      q(0123) => q(lv),
      q(0124) => q(lb),
      q(0125) => q(ls),
      q(0126) => q(lr),
      q(0127) => q(ly),
      q(0128) => q(li),
      q(0129) => q(lt),
      q(0130) => q(lu),
      q(0131) => q(mo),
      q(0132) => q(mk),
      q(0133) => q(mg),
      q(0134) => q(mw),
      q(0135) => q(my),
      q(0136) => q(mv),
      q(0137) => q(ml),
      q(0138) => q(mt),
      q(0139) => q(mh),
      q(0140) => q(mq),
      q(0141) => q(mr),
      q(0142) => q(mu),
      q(0143) => q(yt),
      q(0144) => q(mx),
      q(0145) => q(fm),
      q(0146) => q(md),
      q(0147) => q(mc),
      q(0148) => q(mn),
      q(0149) => q(me),
      q(0150) => q(ms),
      q(0151) => q(ma),
      q(0152) => q(mz),
      q(0153) => q(mm),
      q(0154) => q(na),
      q(0155) => q(nr),
      q(0156) => q(np),
      q(0157) => q(nl),
      q(0158) => q(nc),
      q(0159) => q(nz),
      q(0160) => q(ni),
      q(0161) => q(ne),
      q(0162) => q(ng),
      q(0163) => q(nu),
      q(0164) => q(nf),
      q(0165) => q(mp),
      q(0166) => q(no),
      q(0167) => q(om),
      q(0168) => q(pk),
      q(0169) => q(pw),
      q(0170) => q(ps),
      q(0171) => q(pa),
      q(0172) => q(pg),
      q(0173) => q(py),
      q(0174) => q(pe),
      q(0175) => q(ph),
      q(0176) => q(pn),
      q(0177) => q(pl),
      q(0178) => q(pt),
      q(0179) => q(pr),
      q(0180) => q(qa),
      q(0181) => q(re),
      q(0182) => q(ro),
      q(0183) => q(ru),
      q(0184) => q(rw),
      q(0185) => q(bl),
      q(0186) => q(sh),
      q(0187) => q(kn),
      q(0188) => q(lc),
      q(0189) => q(mf),
      q(0190) => q(pm),
      q(0191) => q(vc),
      q(0192) => q(ws),
      q(0193) => q(sm),
      q(0194) => q(st),
      q(0195) => q(sa),
      q(0196) => q(sn),
      q(0197) => q(rs),
      q(0198) => q(sc),
      q(0199) => q(sl),
      q(0200) => q(sg),
      q(0201) => q(sx),
      q(0202) => q(sk),
      q(0203) => q(si),
      q(0204) => q(sb),
      q(0205) => q(so),
      q(0206) => q(za),
      q(0207) => q(gs),
      q(0208) => q(ss),
      q(0209) => q(es),
      q(0210) => q(lk),
      q(0211) => q(sd),
      q(0212) => q(sr),
      q(0213) => q(sj),
      q(0214) => q(sz),
      q(0215) => q(se),
      q(0216) => q(ch),
      q(0217) => q(sy),
      q(0218) => q(tw),
      q(0219) => q(tj),
      q(0220) => q(tz),
      q(0221) => q(th),
      q(0222) => q(tl),
      q(0223) => q(tg),
      q(0224) => q(tk),
      q(0225) => q(to),
      q(0226) => q(tt),
      q(0227) => q(tn),
      q(0228) => q(tr),
      q(0229) => q(tm),
      q(0230) => q(tc),
      q(0231) => q(tv),
      q(0232) => q(ug),
      q(0233) => q(ua),
      q(0234) => q(ae),
      q(0235) => q(gb),
      q(0236) => q(us),
      q(0237) => q(um),
      q(0238) => q(uy),
      q(0239) => q(uz),
      q(0240) => q(vu),
      q(0241) => q(ve),
      q(0242) => q(vn),
      q(0243) => q(vg),
      q(0244) => q(vi),
      q(0245) => q(wf),
      q(0246) => q(eh),
      q(0247) => q(ye),
      q(0248) => q(zm),
      q(0249) => q(zw),
      },
   q(alpha-3) => {
      q(0001) => q(afg),
      q(0002) => q(ala),
      q(0003) => q(alb),
      q(0004) => q(dza),
      q(0005) => q(asm),
      q(0006) => q(and),
      q(0007) => q(ago),
      q(0008) => q(aia),
      q(0009) => q(ata),
      q(0010) => q(atg),
      q(0011) => q(arg),
      q(0012) => q(arm),
      q(0013) => q(abw),
      q(0014) => q(aus),
      q(0015) => q(aut),
      q(0016) => q(aze),
      q(0017) => q(bhs),
      q(0018) => q(bhr),
      q(0019) => q(bgd),
      q(0020) => q(brb),
      q(0021) => q(blr),
      q(0022) => q(bel),
      q(0023) => q(blz),
      q(0024) => q(ben),
      q(0025) => q(bmu),
      q(0026) => q(btn),
      q(0027) => q(bol),
      q(0028) => q(bes),
      q(0029) => q(bih),
      q(0030) => q(bwa),
      q(0031) => q(bvt),
      q(0032) => q(bra),
      q(0033) => q(iot),
      q(0034) => q(brn),
      q(0035) => q(bgr),
      q(0036) => q(bfa),
      q(0037) => q(bdi),
      q(0038) => q(khm),
      q(0039) => q(cmr),
      q(0040) => q(can),
      q(0041) => q(cpv),
      q(0042) => q(cym),
      q(0043) => q(caf),
      q(0044) => q(tcd),
      q(0045) => q(chl),
      q(0046) => q(chn),
      q(0047) => q(cxr),
      q(0048) => q(cck),
      q(0049) => q(col),
      q(0050) => q(com),
      q(0051) => q(cog),
      q(0052) => q(cod),
      q(0053) => q(cok),
      q(0054) => q(cri),
      q(0055) => q(civ),
      q(0056) => q(hrv),
      q(0057) => q(cub),
      q(0058) => q(cuw),
      q(0059) => q(cyp),
      q(0060) => q(cze),
      q(0061) => q(dnk),
      q(0062) => q(dji),
      q(0063) => q(dma),
      q(0064) => q(dom),
      q(0065) => q(ecu),
      q(0066) => q(egy),
      q(0067) => q(slv),
      q(0068) => q(gnq),
      q(0069) => q(eri),
      q(0070) => q(est),
      q(0071) => q(eth),
      q(0072) => q(flk),
      q(0073) => q(fro),
      q(0074) => q(fji),
      q(0075) => q(fin),
      q(0076) => q(fra),
      q(0077) => q(guf),
      q(0078) => q(pyf),
      q(0079) => q(atf),
      q(0080) => q(gab),
      q(0081) => q(gmb),
      q(0082) => q(geo),
      q(0083) => q(deu),
      q(0084) => q(gha),
      q(0085) => q(gib),
      q(0086) => q(grc),
      q(0087) => q(grl),
      q(0088) => q(grd),
      q(0089) => q(glp),
      q(0090) => q(gum),
      q(0091) => q(gtm),
      q(0092) => q(ggy),
      q(0093) => q(gin),
      q(0094) => q(gnb),
      q(0095) => q(guy),
      q(0096) => q(hti),
      q(0097) => q(hmd),
      q(0098) => q(vat),
      q(0099) => q(hnd),
      q(0100) => q(hkg),
      q(0101) => q(hun),
      q(0102) => q(isl),
      q(0103) => q(ind),
      q(0104) => q(idn),
      q(0105) => q(irn),
      q(0106) => q(irq),
      q(0107) => q(irl),
      q(0108) => q(imn),
      q(0109) => q(isr),
      q(0110) => q(ita),
      q(0111) => q(jam),
      q(0112) => q(jpn),
      q(0113) => q(jey),
      q(0114) => q(jor),
      q(0115) => q(kaz),
      q(0116) => q(ken),
      q(0117) => q(kir),
      q(0118) => q(prk),
      q(0119) => q(kor),
      q(0120) => q(kwt),
      q(0121) => q(kgz),
      q(0122) => q(lao),
      q(0123) => q(lva),
      q(0124) => q(lbn),
      q(0125) => q(lso),
      q(0126) => q(lbr),
      q(0127) => q(lby),
      q(0128) => q(lie),
      q(0129) => q(ltu),
      q(0130) => q(lux),
      q(0131) => q(mac),
      q(0132) => q(mkd),
      q(0133) => q(mdg),
      q(0134) => q(mwi),
      q(0135) => q(mys),
      q(0136) => q(mdv),
      q(0137) => q(mli),
      q(0138) => q(mlt),
      q(0139) => q(mhl),
      q(0140) => q(mtq),
      q(0141) => q(mrt),
      q(0142) => q(mus),
      q(0143) => q(myt),
      q(0144) => q(mex),
      q(0145) => q(fsm),
      q(0146) => q(mda),
      q(0147) => q(mco),
      q(0148) => q(mng),
      q(0149) => q(mne),
      q(0150) => q(msr),
      q(0151) => q(mar),
      q(0152) => q(moz),
      q(0153) => q(mmr),
      q(0154) => q(nam),
      q(0155) => q(nru),
      q(0156) => q(npl),
      q(0157) => q(nld),
      q(0158) => q(ncl),
      q(0159) => q(nzl),
      q(0160) => q(nic),
      q(0161) => q(ner),
      q(0162) => q(nga),
      q(0163) => q(niu),
      q(0164) => q(nfk),
      q(0165) => q(mnp),
      q(0166) => q(nor),
      q(0167) => q(omn),
      q(0168) => q(pak),
      q(0169) => q(plw),
      q(0170) => q(pse),
      q(0171) => q(pan),
      q(0172) => q(png),
      q(0173) => q(pry),
      q(0174) => q(per),
      q(0175) => q(phl),
      q(0176) => q(pcn),
      q(0177) => q(pol),
      q(0178) => q(prt),
      q(0179) => q(pri),
      q(0180) => q(qat),
      q(0181) => q(reu),
      q(0182) => q(rou),
      q(0183) => q(rus),
      q(0184) => q(rwa),
      q(0185) => q(blm),
      q(0186) => q(shn),
      q(0187) => q(kna),
      q(0188) => q(lca),
      q(0189) => q(maf),
      q(0190) => q(spm),
      q(0191) => q(vct),
      q(0192) => q(wsm),
      q(0193) => q(smr),
      q(0194) => q(stp),
      q(0195) => q(sau),
      q(0196) => q(sen),
      q(0197) => q(srb),
      q(0198) => q(syc),
      q(0199) => q(sle),
      q(0200) => q(sgp),
      q(0201) => q(sxm),
      q(0202) => q(svk),
      q(0203) => q(svn),
      q(0204) => q(slb),
      q(0205) => q(som),
      q(0206) => q(zaf),
      q(0207) => q(sgs),
      q(0208) => q(ssd),
      q(0209) => q(esp),
      q(0210) => q(lka),
      q(0211) => q(sdn),
      q(0212) => q(sur),
      q(0213) => q(sjm),
      q(0214) => q(swz),
      q(0215) => q(swe),
      q(0216) => q(che),
      q(0217) => q(syr),
      q(0218) => q(twn),
      q(0219) => q(tjk),
      q(0220) => q(tza),
      q(0221) => q(tha),
      q(0222) => q(tls),
      q(0223) => q(tgo),
      q(0224) => q(tkl),
      q(0225) => q(ton),
      q(0226) => q(tto),
      q(0227) => q(tun),
      q(0228) => q(tur),
      q(0229) => q(tkm),
      q(0230) => q(tca),
      q(0231) => q(tuv),
      q(0232) => q(uga),
      q(0233) => q(ukr),
      q(0234) => q(are),
      q(0235) => q(gbr),
      q(0236) => q(usa),
      q(0237) => q(umi),
      q(0238) => q(ury),
      q(0239) => q(uzb),
      q(0240) => q(vut),
      q(0241) => q(ven),
      q(0242) => q(vnm),
      q(0243) => q(vgb),
      q(0244) => q(vir),
      q(0245) => q(wlf),
      q(0246) => q(esh),
      q(0247) => q(yem),
      q(0248) => q(zmb),
      q(0249) => q(zwe),
      },
   q(dom) => {
      q(0001) => q(af),
      q(0002) => q(ax),
      q(0003) => q(al),
      q(0004) => q(dz),
      q(0005) => q(as),
      q(0006) => q(ad),
      q(0007) => q(ao),
      q(0008) => q(ai),
      q(0009) => q(aq),
      q(0010) => q(ag),
      q(0011) => q(ar),
      q(0012) => q(am),
      q(0013) => q(aw),
      q(0014) => q(au),
      q(0015) => q(at),
      q(0016) => q(az),
      q(0017) => q(bs),
      q(0018) => q(bh),
      q(0019) => q(bd),
      q(0020) => q(bb),
      q(0021) => q(by),
      q(0022) => q(be),
      q(0023) => q(bz),
      q(0024) => q(bj),
      q(0025) => q(bm),
      q(0026) => q(bt),
      q(0027) => q(bo),
      q(0028) => q(bq),
      q(0029) => q(ba),
      q(0030) => q(bw),
      q(0031) => q(bv),
      q(0032) => q(br),
      q(0033) => q(io),
      q(0034) => q(bn),
      q(0035) => q(bg),
      q(0036) => q(bf),
      q(0037) => q(bi),
      q(0038) => q(kh),
      q(0039) => q(cm),
      q(0040) => q(ca),
      q(0041) => q(cv),
      q(0042) => q(ky),
      q(0043) => q(cf),
      q(0044) => q(td),
      q(0045) => q(cl),
      q(0046) => q(cn),
      q(0047) => q(cx),
      q(0048) => q(cc),
      q(0049) => q(co),
      q(0050) => q(km),
      q(0051) => q(cg),
      q(0052) => q(cd),
      q(0053) => q(ck),
      q(0054) => q(cr),
      q(0055) => q(ci),
      q(0056) => q(hr),
      q(0057) => q(cu),
      q(0058) => q(cw),
      q(0059) => q(cy),
      q(0060) => q(cz),
      q(0061) => q(dk),
      q(0062) => q(dj),
      q(0063) => q(dm),
      q(0064) => q(do),
      q(0065) => q(ec),
      q(0066) => q(eg),
      q(0067) => q(sv),
      q(0068) => q(gq),
      q(0069) => q(er),
      q(0070) => q(ee),
      q(0071) => q(et),
      q(0072) => q(fk),
      q(0073) => q(fo),
      q(0074) => q(fj),
      q(0075) => q(fi),
      q(0076) => q(fr),
      q(0077) => q(gf),
      q(0078) => q(pf),
      q(0079) => q(tf),
      q(0080) => q(ga),
      q(0081) => q(gm),
      q(0082) => q(ge),
      q(0083) => q(de),
      q(0084) => q(gh),
      q(0085) => q(gi),
      q(0086) => q(gr),
      q(0087) => q(gl),
      q(0088) => q(gd),
      q(0089) => q(gp),
      q(0090) => q(gu),
      q(0091) => q(gt),
      q(0092) => q(gg),
      q(0093) => q(gn),
      q(0094) => q(gw),
      q(0095) => q(gy),
      q(0096) => q(ht),
      q(0097) => q(hm),
      q(0098) => q(va),
      q(0099) => q(hn),
      q(0100) => q(hk),
      q(0101) => q(hu),
      q(0102) => q(is),
      q(0103) => q(in),
      q(0104) => q(id),
      q(0105) => q(ir),
      q(0106) => q(iq),
      q(0107) => q(ie),
      q(0108) => q(im),
      q(0109) => q(il),
      q(0110) => q(it),
      q(0111) => q(jm),
      q(0112) => q(jp),
      q(0113) => q(je),
      q(0114) => q(jo),
      q(0115) => q(kz),
      q(0116) => q(ke),
      q(0117) => q(ki),
      q(0118) => q(kp),
      q(0119) => q(kr),
      q(0120) => q(kw),
      q(0121) => q(kg),
      q(0122) => q(la),
      q(0123) => q(lv),
      q(0124) => q(lb),
      q(0125) => q(ls),
      q(0126) => q(lr),
      q(0127) => q(ly),
      q(0128) => q(li),
      q(0129) => q(lt),
      q(0130) => q(lu),
      q(0131) => q(mo),
      q(0132) => q(mk),
      q(0133) => q(mg),
      q(0134) => q(mw),
      q(0135) => q(my),
      q(0136) => q(mv),
      q(0137) => q(ml),
      q(0138) => q(mt),
      q(0139) => q(mh),
      q(0140) => q(mq),
      q(0141) => q(mr),
      q(0142) => q(mu),
      q(0143) => q(yt),
      q(0144) => q(mx),
      q(0145) => q(fm),
      q(0146) => q(md),
      q(0147) => q(mc),
      q(0148) => q(mn),
      q(0149) => q(me),
      q(0150) => q(ms),
      q(0151) => q(ma),
      q(0152) => q(mz),
      q(0153) => q(mm),
      q(0154) => q(na),
      q(0155) => q(nr),
      q(0156) => q(np),
      q(0157) => q(nl),
      q(0158) => q(nc),
      q(0159) => q(nz),
      q(0160) => q(ni),
      q(0161) => q(ne),
      q(0162) => q(ng),
      q(0163) => q(nu),
      q(0164) => q(nf),
      q(0165) => q(mp),
      q(0166) => q(no),
      q(0167) => q(om),
      q(0168) => q(pk),
      q(0169) => q(pw),
      q(0170) => q(ps),
      q(0171) => q(pa),
      q(0172) => q(pg),
      q(0173) => q(py),
      q(0174) => q(pe),
      q(0175) => q(ph),
      q(0176) => q(pn),
      q(0177) => q(pl),
      q(0178) => q(pt),
      q(0179) => q(pr),
      q(0180) => q(qa),
      q(0181) => q(re),
      q(0182) => q(ro),
      q(0183) => q(ru),
      q(0184) => q(rw),
      q(0185) => q(bl),
      q(0186) => q(sh),
      q(0187) => q(kn),
      q(0188) => q(lc),
      q(0189) => q(mf),
      q(0190) => q(pm),
      q(0191) => q(vc),
      q(0192) => q(ws),
      q(0193) => q(sm),
      q(0194) => q(st),
      q(0195) => q(sa),
      q(0196) => q(sn),
      q(0197) => q(rs),
      q(0198) => q(sc),
      q(0199) => q(sl),
      q(0200) => q(sg),
      q(0201) => q(sx),
      q(0202) => q(sk),
      q(0203) => q(si),
      q(0204) => q(sb),
      q(0205) => q(so),
      q(0206) => q(za),
      q(0207) => q(gs),
      q(0208) => q(ss),
      q(0209) => q(es),
      q(0210) => q(lk),
      q(0211) => q(sd),
      q(0212) => q(sr),
      q(0213) => q(sj),
      q(0214) => q(sz),
      q(0215) => q(se),
      q(0216) => q(ch),
      q(0217) => q(sy),
      q(0218) => q(tw),
      q(0219) => q(tj),
      q(0220) => q(tz),
      q(0221) => q(th),
      q(0222) => q(tp),
      q(0223) => q(tg),
      q(0224) => q(tk),
      q(0225) => q(to),
      q(0226) => q(tt),
      q(0227) => q(tn),
      q(0228) => q(tr),
      q(0229) => q(tm),
      q(0230) => q(tc),
      q(0231) => q(tv),
      q(0232) => q(ug),
      q(0233) => q(ua),
      q(0234) => q(ae),
      q(0235) => q(gb),
      q(0236) => q(us),
      q(0237) => q(um),
      q(0238) => q(uy),
      q(0239) => q(uz),
      q(0240) => q(vu),
      q(0241) => q(ve),
      q(0242) => q(vn),
      q(0243) => q(vg),
      q(0244) => q(vi),
      q(0245) => q(wf),
      q(0246) => q(eh),
      q(0247) => q(ye),
      q(0248) => q(zm),
      q(0249) => q(zw),
      q(0250) => q(an),
      q(0251) => q(su),
      },
   q(numeric) => {
      q(0001) => q(004),
      q(0002) => q(248),
      q(0003) => q(008),
      q(0004) => q(012),
      q(0005) => q(016),
      q(0006) => q(020),
      q(0007) => q(024),
      q(0008) => q(660),
      q(0009) => q(010),
      q(0010) => q(028),
      q(0011) => q(032),
      q(0012) => q(051),
      q(0013) => q(533),
      q(0014) => q(036),
      q(0015) => q(040),
      q(0016) => q(031),
      q(0017) => q(044),
      q(0018) => q(048),
      q(0019) => q(050),
      q(0020) => q(052),
      q(0021) => q(112),
      q(0022) => q(056),
      q(0023) => q(084),
      q(0024) => q(204),
      q(0025) => q(060),
      q(0026) => q(064),
      q(0027) => q(068),
      q(0028) => q(535),
      q(0029) => q(070),
      q(0030) => q(072),
      q(0031) => q(074),
      q(0032) => q(076),
      q(0033) => q(086),
      q(0034) => q(096),
      q(0035) => q(100),
      q(0036) => q(854),
      q(0037) => q(108),
      q(0038) => q(116),
      q(0039) => q(120),
      q(0040) => q(124),
      q(0041) => q(132),
      q(0042) => q(136),
      q(0043) => q(140),
      q(0044) => q(148),
      q(0045) => q(152),
      q(0046) => q(156),
      q(0047) => q(162),
      q(0048) => q(166),
      q(0049) => q(170),
      q(0050) => q(174),
      q(0051) => q(178),
      q(0052) => q(180),
      q(0053) => q(184),
      q(0054) => q(188),
      q(0055) => q(384),
      q(0056) => q(191),
      q(0057) => q(192),
      q(0058) => q(531),
      q(0059) => q(196),
      q(0060) => q(203),
      q(0061) => q(208),
      q(0062) => q(262),
      q(0063) => q(212),
      q(0064) => q(214),
      q(0065) => q(218),
      q(0066) => q(818),
      q(0067) => q(222),
      q(0068) => q(226),
      q(0069) => q(232),
      q(0070) => q(233),
      q(0071) => q(231),
      q(0072) => q(238),
      q(0073) => q(234),
      q(0074) => q(242),
      q(0075) => q(246),
      q(0076) => q(250),
      q(0077) => q(254),
      q(0078) => q(258),
      q(0079) => q(260),
      q(0080) => q(266),
      q(0081) => q(270),
      q(0082) => q(268),
      q(0083) => q(276),
      q(0084) => q(288),
      q(0085) => q(292),
      q(0086) => q(300),
      q(0087) => q(304),
      q(0088) => q(308),
      q(0089) => q(312),
      q(0090) => q(316),
      q(0091) => q(320),
      q(0092) => q(831),
      q(0093) => q(324),
      q(0094) => q(624),
      q(0095) => q(328),
      q(0096) => q(332),
      q(0097) => q(334),
      q(0098) => q(336),
      q(0099) => q(340),
      q(0100) => q(344),
      q(0101) => q(348),
      q(0102) => q(352),
      q(0103) => q(356),
      q(0104) => q(360),
      q(0105) => q(364),
      q(0106) => q(368),
      q(0107) => q(372),
      q(0108) => q(833),
      q(0109) => q(376),
      q(0110) => q(380),
      q(0111) => q(388),
      q(0112) => q(392),
      q(0113) => q(832),
      q(0114) => q(400),
      q(0115) => q(398),
      q(0116) => q(404),
      q(0117) => q(296),
      q(0118) => q(408),
      q(0119) => q(410),
      q(0120) => q(414),
      q(0121) => q(417),
      q(0122) => q(418),
      q(0123) => q(428),
      q(0124) => q(422),
      q(0125) => q(426),
      q(0126) => q(430),
      q(0127) => q(434),
      q(0128) => q(438),
      q(0129) => q(440),
      q(0130) => q(442),
      q(0131) => q(446),
      q(0132) => q(807),
      q(0133) => q(450),
      q(0134) => q(454),
      q(0135) => q(458),
      q(0136) => q(462),
      q(0137) => q(466),
      q(0138) => q(470),
      q(0139) => q(584),
      q(0140) => q(474),
      q(0141) => q(478),
      q(0142) => q(480),
      q(0143) => q(175),
      q(0144) => q(484),
      q(0145) => q(583),
      q(0146) => q(498),
      q(0147) => q(492),
      q(0148) => q(496),
      q(0149) => q(499),
      q(0150) => q(500),
      q(0151) => q(504),
      q(0152) => q(508),
      q(0153) => q(104),
      q(0154) => q(516),
      q(0155) => q(520),
      q(0156) => q(524),
      q(0157) => q(528),
      q(0158) => q(540),
      q(0159) => q(554),
      q(0160) => q(558),
      q(0161) => q(562),
      q(0162) => q(566),
      q(0163) => q(570),
      q(0164) => q(574),
      q(0165) => q(580),
      q(0166) => q(578),
      q(0167) => q(512),
      q(0168) => q(586),
      q(0169) => q(585),
      q(0170) => q(275),
      q(0171) => q(591),
      q(0172) => q(598),
      q(0173) => q(600),
      q(0174) => q(604),
      q(0175) => q(608),
      q(0176) => q(612),
      q(0177) => q(616),
      q(0178) => q(620),
      q(0179) => q(630),
      q(0180) => q(634),
      q(0181) => q(638),
      q(0182) => q(642),
      q(0183) => q(643),
      q(0184) => q(646),
      q(0185) => q(652),
      q(0186) => q(654),
      q(0187) => q(659),
      q(0188) => q(662),
      q(0189) => q(663),
      q(0190) => q(666),
      q(0191) => q(670),
      q(0192) => q(882),
      q(0193) => q(674),
      q(0194) => q(678),
      q(0195) => q(682),
      q(0196) => q(686),
      q(0197) => q(688),
      q(0198) => q(690),
      q(0199) => q(694),
      q(0200) => q(702),
      q(0201) => q(534),
      q(0202) => q(703),
      q(0203) => q(705),
      q(0204) => q(090),
      q(0205) => q(706),
      q(0206) => q(710),
      q(0207) => q(239),
      q(0208) => q(728),
      q(0209) => q(724),
      q(0210) => q(144),
      q(0211) => q(729),
      q(0212) => q(740),
      q(0213) => q(744),
      q(0214) => q(748),
      q(0215) => q(752),
      q(0216) => q(756),
      q(0217) => q(760),
      q(0218) => q(158),
      q(0219) => q(762),
      q(0220) => q(834),
      q(0221) => q(764),
      q(0222) => q(626),
      q(0223) => q(768),
      q(0224) => q(772),
      q(0225) => q(776),
      q(0226) => q(780),
      q(0227) => q(788),
      q(0228) => q(792),
      q(0229) => q(795),
      q(0230) => q(796),
      q(0231) => q(798),
      q(0232) => q(800),
      q(0233) => q(804),
      q(0234) => q(784),
      q(0235) => q(826),
      q(0236) => q(840),
      q(0237) => q(581),
      q(0238) => q(858),
      q(0239) => q(860),
      q(0240) => q(548),
      q(0241) => q(862),
      q(0242) => q(704),
      q(0243) => q(092),
      q(0244) => q(850),
      q(0245) => q(876),
      q(0246) => q(732),
      q(0247) => q(887),
      q(0248) => q(894),
      q(0249) => q(716),
      },
};

1;
                                                                                                                                                                                           usr/share/perl/5.20.2/Locale/Codes/Country_Retired.pm                                               0100644 0000000 0000000 00000061051 12744441327 020574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Country_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Mar  4 13:19:40 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'country'}{'alpha-2'}{'code'} = {
   q(an) => q(Netherlands Antilles),
   q(cs) => q(Serbia and Montenegro),
   q(fx) => q(France, Metropolitan),
   q(tp) => q(East Timor),
   q(yu) => q(Yugoslavia),
   q(zr) => q(Zaire),
};

$Locale::Codes::Retired{'country'}{'alpha-3'}{'code'} = {
   q(ant) => q(Netherlands Antilles),
   q(ata) => q(Antarctica),
   q(atf) => q(French Southern and Antarctic Lands),
   q(bvt) => q(Bouvet Island),
   q(cck) => q(Cocos (Keeling) Islands),
   q(cxr) => q(Christmas Island),
   q(fxx) => q(France, Metropolitan),
   q(hmd) => q(Heard Island and Mcdonald Islands),
   q(iot) => q(British Indian Ocean Territory),
   q(rom) => q(Romania),
   q(scg) => q(Serbia and Montenegro),
   q(sgs) => q(South Georgia and the Islands),
   q(tmp) => q(East Timor),
   q(twn) => q(Taiwan),
   q(umi) => q(United States Minor Outlying Islands),
   q(yug) => q(Yugoslavia),
   q(zar) => q(Zaire),
};

$Locale::Codes::Retired{'country'}{'dom'}{'code'} = {
   q(AC) => q(Ascension Island),
   q(AD) => q(Andorra),
   q(AE) => q(United Arab Emirates),
   q(AF) => q(Afghanistan),
   q(AG) => q(Antigua and Barbuda),
   q(AI) => q(Anguilla),
   q(AL) => q(Albania),
   q(AM) => q(Armenia),
   q(AN) => q(Netherlands Antilles),
   q(AO) => q(Angola),
   q(AQ) => q(Antarctica),
   q(AR) => q(Argentina),
   q(AS) => q(American Samoa),
   q(AT) => q(Austria),
   q(AU) => q(Australia),
   q(AW) => q(Aruba),
   q(AX) => q(Aland Islands),
   q(AZ) => q(Azerbaijan),
   q(BA) => q(Bosnia and Herzegovina),
   q(BB) => q(Barbados),
   q(BD) => q(Bangladesh),
   q(BE) => q(Belgium),
   q(BF) => q(Burkina Faso),
   q(BG) => q(Bulgaria),
   q(BH) => q(Bahrain),
   q(BI) => q(Burundi),
   q(BJ) => q(Benin),
   q(BL) => q(Saint Barthelemy),
   q(BM) => q(Bermuda),
   q(BN) => q(Brunei Darussalam),
   q(BO) => q(Bolivia, Plurinational State of),
   q(BQ) => q(Bonaire, Sint Eustatius and Saba),
   q(BR) => q(Brazil),
   q(BS) => q(Bahamas),
   q(BT) => q(Bhutan),
   q(BV) => q(Bouvet Island),
   q(BW) => q(Botswana),
   q(BY) => q(Belarus),
   q(BZ) => q(Belize),
   q(CA) => q(Canada),
   q(CC) => q(Cocos (Keeling) Islands),
   q(CD) => q(Congo, The Democratic Republic of the),
   q(CF) => q(Central African Republic),
   q(CG) => q(Congo),
   q(CH) => q(Switzerland),
   q(CI) => q(Cote d'Ivoire),
   q(CK) => q(Cook Islands),
   q(CL) => q(Chile),
   q(CM) => q(Cameroon),
   q(CN) => q(China),
   q(CO) => q(Colombia),
   q(CR) => q(Costa Rica),
   q(CU) => q(Cuba),
   q(CV) => q(Cape Verde),
   q(CW) => q(Curacao),
   q(CX) => q(Christmas Island),
   q(CY) => q(Cyprus),
   q(CZ) => q(Czech Republic),
   q(DE) => q(Germany),
   q(DJ) => q(Djibouti),
   q(DK) => q(Denmark),
   q(DM) => q(Dominica),
   q(DO) => q(Dominican Republic),
   q(DZ) => q(Algeria),
   q(EC) => q(Ecuador),
   q(EE) => q(Estonia),
   q(EG) => q(Egypt),
   q(EH) => q(Western Sahara),
   q(ER) => q(Eritrea),
   q(ES) => q(Spain),
   q(ET) => q(Ethiopia),
   q(EU) => q(European Union),
   q(FI) => q(Finland),
   q(FJ) => q(Fiji),
   q(FK) => q(Falkland Islands (Malvinas)),
   q(FM) => q(Micronesia, Federated States of),
   q(FO) => q(Faroe Islands),
   q(FR) => q(France),
   q(FX) => q(France, Metropolitan),
   q(GA) => q(Gabon),
   q(GB) => q(United Kingdom),
   q(GD) => q(Grenada),
   q(GE) => q(Georgia),
   q(GF) => q(French Guiana),
   q(GG) => q(Guernsey),
   q(GH) => q(Ghana),
   q(GI) => q(Gibraltar),
   q(GL) => q(Greenland),
   q(GM) => q(Gambia),
   q(GN) => q(Guinea),
   q(GP) => q(Guadeloupe),
   q(GQ) => q(Equatorial Guinea),
   q(GR) => q(Greece),
   q(GS) => q(South Georgia and the South Sandwich Islands),
   q(GT) => q(Guatemala),
   q(GU) => q(Guam),
   q(GW) => q(Guinea-Bissau),
   q(GY) => q(Guyana),
   q(HK) => q(Hong Kong),
   q(HM) => q(Heard Island and Mcdonald Islands),
   q(HN) => q(Honduras),
   q(HR) => q(Croatia),
   q(HT) => q(Haiti),
   q(HU) => q(Hungary),
   q(ID) => q(Indonesia),
   q(IE) => q(Ireland),
   q(IL) => q(Israel),
   q(IM) => q(Isle of Man),
   q(IN) => q(India),
   q(IO) => q(British Indian Ocean Territory),
   q(IQ) => q(Iraq),
   q(IR) => q(Iran, Islamic Republic of),
   q(IS) => q(Iceland),
   q(IT) => q(Italy),
   q(JE) => q(Jersey),
   q(JM) => q(Jamaica),
   q(JO) => q(Jordan),
   q(JP) => q(Japan),
   q(KE) => q(Kenya),
   q(KG) => q(Kyrgyzstan),
   q(KH) => q(Cambodia),
   q(KI) => q(Kiribati),
   q(KM) => q(Comoros),
   q(KN) => q(Saint Kitts and Nevis),
   q(KP) => q(Korea, Democratic People's Republic of),
   q(KR) => q(Korea, Republic of),
   q(KW) => q(Kuwait),
   q(KY) => q(Cayman Islands),
   q(KZ) => q(Kazakhstan),
   q(LA) => q(Lao People's Democratic Republic),
   q(LB) => q(Lebanon),
   q(LC) => q(Saint Lucia),
   q(LI) => q(Liechtenstein),
   q(LK) => q(Sri Lanka),
   q(LR) => q(Liberia),
   q(LS) => q(Lesotho),
   q(LT) => q(Lithuania),
   q(LU) => q(Luxembourg),
   q(LV) => q(Latvia),
   q(LY) => q(Libya),
   q(MA) => q(Morocco),
   q(MC) => q(Monaco),
   q(MD) => q(Moldova, Republic of),
   q(ME) => q(Montenegro),
   q(MF) => q(Saint Martin (French part)),
   q(MG) => q(Madagascar),
   q(MH) => q(Marshall Islands),
   q(MK) => q(Macedonia, The Former Yugoslav Republic of),
   q(ML) => q(Mali),
   q(MM) => q(Myanmar),
   q(MN) => q(Mongolia),
   q(MO) => q(Macao),
   q(MP) => q(Northern Mariana Islands),
   q(MQ) => q(Martinique),
   q(MR) => q(Mauritania),
   q(MS) => q(Montserrat),
   q(MT) => q(Malta),
   q(MU) => q(Mauritius),
   q(MV) => q(Maldives),
   q(MW) => q(Malawi),
   q(MX) => q(Mexico),
   q(MY) => q(Malaysia),
   q(MZ) => q(Mozambique),
   q(NA) => q(Namibia),
   q(NC) => q(New Caledonia),
   q(NE) => q(Niger),
   q(NF) => q(Norfolk Island),
   q(NG) => q(Nigeria),
   q(NI) => q(Nicaragua),
   q(NL) => q(Netherlands),
   q(NO) => q(Norway),
   q(NP) => q(Nepal),
   q(NR) => q(Nauru),
   q(NU) => q(Niue),
   q(NZ) => q(New Zealand),
   q(OM) => q(Oman),
   q(PA) => q(Panama),
   q(PE) => q(Peru),
   q(PF) => q(French Polynesia),
   q(PG) => q(Papua New Guinea),
   q(PH) => q(Philippines),
   q(PK) => q(Pakistan),
   q(PL) => q(Poland),
   q(PM) => q(Saint Pierre and Miquelon),
   q(PN) => q(Pitcairn),
   q(PR) => q(Puerto Rico),
   q(PS) => q(Palestinian Territory, Occupied),
   q(PT) => q(Portugal),
   q(PW) => q(Palau),
   q(PY) => q(Paraguay),
   q(QA) => q(Qatar),
   q(RE) => q(Reunion),
   q(RO) => q(Romania),
   q(RS) => q(Serbia),
   q(RU) => q(Russian Federation),
   q(RW) => q(Rwanda),
   q(SA) => q(Saudi Arabia),
   q(SB) => q(Solomon Islands),
   q(SC) => q(Seychelles),
   q(SD) => q(Sudan),
   q(SE) => q(Sweden),
   q(SG) => q(Singapore),
   q(SH) => q(Saint Helena, Ascension and Tristan da Cunha),
   q(SI) => q(Slovenia),
   q(SJ) => q(Svalbard and Jan Mayen),
   q(SK) => q(Slovakia),
   q(SL) => q(Sierra Leone),
   q(SM) => q(San Marino),
   q(SN) => q(Senegal),
   q(SO) => q(Somalia),
   q(SR) => q(Suriname),
   q(SS) => q(South Sudan),
   q(ST) => q(Sao Tome and Principe),
   q(SU) => q(Soviet Union),
   q(SV) => q(El Salvador),
   q(SX) => q(Sint Maarten (Dutch part)),
   q(SY) => q(Syrian Arab Republic),
   q(SZ) => q(Swaziland),
   q(TC) => q(Turks and Caicos Islands),
   q(TD) => q(Chad),
   q(TF) => q(French Southern Territories),
   q(TG) => q(Togo),
   q(TH) => q(Thailand),
   q(TJ) => q(Tajikistan),
   q(TK) => q(Tokelau),
   q(TL) => q(Timor-Leste),
   q(TM) => q(Turkmenistan),
   q(TN) => q(Tunisia),
   q(TO) => q(Tonga),
   q(TP) => q(Portuguese Timor),
   q(TR) => q(Turkey),
   q(TT) => q(Trinidad and Tobago),
   q(TV) => q(Tuvalu),
   q(TW) => q(Taiwan, Province of China),
   q(TZ) => q(Tanzania, United Republic of),
   q(UA) => q(Ukraine),
   q(UG) => q(Uganda),
   q(UK) => q(United Kingdom),
   q(UM) => q(United States Minor Outlying Islands),
   q(US) => q(United States),
   q(UY) => q(Uruguay),
   q(UZ) => q(Uzbekistan),
   q(VA) => q(Holy See (Vatican City State)),
   q(VC) => q(Saint Vincent and the Grenadines),
   q(VE) => q(Venezuela, Bolivarian Republic of),
   q(VG) => q(Virgin Islands, British),
   q(VI) => q(Virgin Islands, U.S.),
   q(VN) => q(Viet Nam),
   q(VU) => q(Vanuatu),
   q(WF) => q(Wallis and Futuna),
   q(WS) => q(Samoa),
   q(YE) => q(Yemen),
   q(YT) => q(Mayotte),
   q(YU) => q(Yugoslavia ),
   q(ZA) => q(South Africa),
   q(ZM) => q(Zambia),
   q(ZW) => q(Zimbabwe),
   q(ac) => q(Ascension Island),
   q(eu) => q(European Union),
   q(uk) => q(United Kingdom),
};

$Locale::Codes::Retired{'country'}{'numeric'}{'code'} = {
   q(010) => q(Antarctica),
   q(074) => q(Bouvet Island),
   q(086) => q(British Indian Ocean Territory),
   q(158) => q(Taiwan),
   q(162) => q(Christmas Island),
   q(166) => q(Cocos (Keeling) Islands),
   q(239) => q(South Georgia and the Islands),
   q(249) => q(France, Metropolitan),
   q(260) => q(French Southern and Antarctic Lands),
   q(334) => q(Heard Island and Mcdonald Islands),
   q(530) => q(Netherlands Antilles),
   q(581) => q(United States Minor Outlying Islands),
   q(680) => q(Sark),
   q(736) => q(Sudan),
   q(830) => q(Channel Islands),
   q(891) => q(Serbia and Montenegro),
};

$Locale::Codes::Retired{'country'}{'alpha-2'}{'name'} = {
   q(bolivia) => [ q(bo), q(Bolivia) ],
   q(bonaire, saint eustatius and saba) => [ q(bq), q(Bonaire, Saint Eustatius and Saba) ],
   q(bosnia and herzegowina) => [ q(ba), q(Bosnia and Herzegowina) ],
   q(congo, the democratic republic of the) => [ q(cd), q(Congo, The Democratic Republic of the) ],
   q(east timor) => [ q(tl), q(East Timor) ],
   q(falkland islands (malvinas)) => [ q(fk), q(Falkland Islands (Malvinas)) ],
   q(france, metropolitan) => [ q(fx), q(France, Metropolitan) ],
   q(heard and mc donald islands) => [ q(hm), q(Heard and Mc Donald Islands) ],
   q(holy see (vatican city state)) => [ q(va), q(Holy See (Vatican City State)) ],
   q(iran (islamic republic of)) => [ q(ir), q(Iran (Islamic Republic of)) ],
   q(iran, islamic republic of) => [ q(ir), q(Iran, Islamic Republic of) ],
   q(kazakstan) => [ q(kz), q(Kazakstan) ],
   q(korea, democratic people's republic of) => [ q(kp), q(Korea, Democratic People's Republic of) ],
   q(korea, republic of) => [ q(kr), q(Korea, Republic of) ],
   q(libyan arab jamahiriya) => [ q(ly), q(Libyan Arab Jamahiriya) ],
   q(macau) => [ q(mo), q(Macau) ],
   q(micronesia (federated states of)) => [ q(fm), q(Micronesia (Federated States of)) ],
   q(micronesia, federated states of) => [ q(fm), q(Micronesia, Federated States of) ],
   q(moldova, republic of) => [ q(md), q(Moldova, Republic of) ],
   q(netherlands antilles) => [ q(an), q(Netherlands Antilles) ],
   q(saint helena) => [ q(sh), q(Saint Helena) ],
   q(saint martin) => [ q(mf), q(Saint Martin) ],
   q(serbia and montenegro) => [ q(cs), q(Serbia and Montenegro) ],
   q(st. helena) => [ q(sh), q(St. Helena) ],
   q(st. pierre and miquelon) => [ q(pm), q(St. Pierre and Miquelon) ],
   q(svalbard and jan mayen islands) => [ q(sj), q(Svalbard and Jan Mayen Islands) ],
   q(taiwan, province of china) => [ q(tw), q(Taiwan, Province of China) ],
   q(vatican city state (holy see)) => [ q(va), q(Vatican City State (Holy See)) ],
   q(venezuela) => [ q(ve), q(Venezuela) ],
   q(venezuela, bolivarian republic of) => [ q(ve), q(Venezuela, Bolivarian Republic of) ],
   q(vietnam) => [ q(vn), q(Vietnam) ],
   q(virgin islands (british)) => [ q(vg), q(Virgin Islands (British)) ],
   q(virgin islands (u.s.)) => [ q(vi), q(Virgin Islands (U.S.)) ],
   q(virgin islands, british) => [ q(vg), q(Virgin Islands, British) ],
   q(virgin islands, u.s.) => [ q(vi), q(Virgin Islands, U.S.) ],
   q(wallis and futuna islands) => [ q(wf), q(Wallis and Futuna Islands) ],
   q(yugoslavia) => [ q(yu), q(Yugoslavia) ],
   q(zaire) => [ q(zr), q(Zaire) ],
};

$Locale::Codes::Retired{'country'}{'alpha-3'}{'name'} = {
   q(antarctica) => [ q(ata), q(Antarctica) ],
   q(bolivia) => [ q(bol), q(Bolivia) ],
   q(bolivia (plurinational state of)) => [ q(bol), q(Bolivia (Plurinational State of)) ],
   q(bonaire, saint eustatius and saba) => [ q(bes), q(Bonaire, Saint Eustatius and Saba) ],
   q(bouvet island) => [ q(bvt), q(Bouvet Island) ],
   q(british indian ocean territory) => [ q(iot), q(British Indian Ocean Territory) ],
   q(british virgin islands) => [ q(vgb), q(British Virgin Islands) ],
   q(cabo verde) => [ q(cpv), q(Cabo Verde) ],
   q(cape verde) => [ q(cpv), q(Cape Verde) ],
   q(china, hong kong special administrative region) => [ q(hkg), q(China, Hong Kong Special Administrative Region) ],
   q(china, macao special administrative region) => [ q(mac), q(China, Macao Special Administrative Region) ],
   q(christmas island) => [ q(cxr), q(Christmas Island) ],
   q(cocos (keeling) islands) => [ q(cck), q(Cocos (Keeling) Islands) ],
   q(congo, the democratic republic of the) => [ q(cod), q(Congo, The Democratic Republic of the) ],
   q(democratic people's republic of korea) => [ q(prk), q(Democratic People's Republic of Korea) ],
   q(democratic republic of the congo) => [ q(cod), q(Democratic Republic of the Congo) ],
   q(east timor) => [ q(tls), q(East Timor) ],
   q(faeroe islands) => [ q(fro), q(Faeroe Islands) ],
   q(falkland islands (malvinas)) => [ q(flk), q(Falkland Islands (Malvinas)) ],
   q(faroe islands) => [ q(fro), q(Faroe Islands) ],
   q(france, metropolitan) => [ q(fxx), q(France, Metropolitan) ],
   q(french southern and antarctic lands) => [ q(atf), q(French Southern and Antarctic Lands) ],
   q(french southern territories) => [ q(atf), q(French Southern Territories) ],
   q(heard island and mcdonald islands) => [ q(hmd), q(Heard Island and Mcdonald Islands) ],
   q(holy see) => [ q(vat), q(Holy See) ],
   q(holy see (vatican city state)) => [ q(vat), q(Holy See (Vatican City State)) ],
   q(hong kong) => [ q(hkg), q(Hong Kong) ],
   q(hong kong special administrative region of china) => [ q(hkg), q(Hong Kong Special Administrative Region of China) ],
   q(iran (islamic republic of)) => [ q(irn), q(Iran (Islamic Republic of)) ],
   q(iran, islamic republic of) => [ q(irn), q(Iran, Islamic Republic of) ],
   q(kazakstan) => [ q(kaz), q(Kazakstan) ],
   q(korea, democratic people's republic of) => [ q(prk), q(Korea, Democratic People's Republic of) ],
   q(korea, republic of) => [ q(kor), q(Korea, Republic of) ],
   q(libyan arab jamahiriya) => [ q(lby), q(Libyan Arab Jamahiriya) ],
   q(macao) => [ q(mac), q(Macao) ],
   q(macao special administrative region of china) => [ q(mac), q(Macao Special Administrative Region of China) ],
   q(macau) => [ q(mac), q(Macau) ],
   q(macedonia, the former yugoslav republic of) => [ q(mkd), q(Macedonia, the Former Yugoslav Republic of) ],
   q(micronesia (federated states of)) => [ q(fsm), q(Micronesia (Federated States of)) ],
   q(micronesia, federated states of) => [ q(fsm), q(Micronesia, Federated States of) ],
   q(moldova, republic of) => [ q(mda), q(Moldova, Republic of) ],
   q(netherlands antilles) => [ q(ant), q(Netherlands Antilles) ],
   q(palestinian territory, occupied) => [ q(pse), q(Palestinian Territory, Occupied) ],
   q(republic of korea) => [ q(kor), q(Republic of Korea) ],
   q(republic of moldova) => [ q(mda), q(Republic of Moldova) ],
   q(saint helena) => [ q(shn), q(Saint Helena) ],
   q(saint-barthelemy) => [ q(blm), q(Saint-Barthelemy) ],
   q(saint-martin (french part)) => [ q(maf), q(Saint-Martin (French part)) ],
   q(serbia and montenegro) => [ q(scg), q(Serbia and Montenegro) ],
   q(south georgia and the islands) => [ q(sgs), q(South Georgia and the Islands) ],
   q(south georgia and the south sandwich islands) => [ q(sgs), q(South Georgia and the South Sandwich Islands) ],
   q(state of palestine) => [ q(pse), q(State of Palestine) ],
   q(svalbard and jan mayen) => [ q(sjm), q(Svalbard and Jan Mayen) ],
   q(svalbard and jan mayen islands) => [ q(sjm), q(Svalbard and Jan Mayen Islands) ],
   q(taiwan) => [ q(twn), q(Taiwan) ],
   q(taiwan, province of china) => [ q(twn), q(Taiwan, Province of China) ],
   q(tanzania, united republic of) => [ q(tza), q(Tanzania, United Republic of) ],
   q(the former yugoslav republic of macedonia) => [ q(mkd), q(The former Yugoslav Republic of Macedonia) ],
   q(united kingdom) => [ q(gbr), q(United Kingdom) ],
   q(united kingdom of great britain and northern ireland) => [ q(gbr), q(United Kingdom of Great Britain and Northern Ireland) ],
   q(united republic of tanzania) => [ q(tza), q(United Republic of Tanzania) ],
   q(united states) => [ q(usa), q(United States) ],
   q(united states minor outlying islands) => [ q(umi), q(United States Minor Outlying Islands) ],
   q(united states of america) => [ q(usa), q(United States of America) ],
   q(united states virgin islands) => [ q(vir), q(United States Virgin Islands) ],
   q(venezuela) => [ q(ven), q(Venezuela) ],
   q(venezuela (bolivarian republic of)) => [ q(ven), q(Venezuela (Bolivarian Republic of)) ],
   q(vietnam) => [ q(vnm), q(Vietnam) ],
   q(virgin islands, british) => [ q(vgb), q(Virgin Islands, British) ],
   q(virgin islands, u.s.) => [ q(vir), q(Virgin Islands, U.S.) ],
   q(wallis and futuna) => [ q(wlf), q(Wallis and Futuna) ],
   q(wallis and futuna islands) => [ q(wlf), q(Wallis and Futuna Islands) ],
   q(yugoslavia) => [ q(yug), q(Yugoslavia) ],
   q(zaire) => [ q(zar), q(Zaire) ],
};

$Locale::Codes::Retired{'country'}{'dom'}{'name'} = {
   q(ascension island) => [ q(ac), q(Ascension Island) ],
   q(bonaire, saint eustatius and saba) => [ q(bq), q(Bonaire, Saint Eustatius and Saba) ],
   q(bonaire, sint eustatius and saba) => [ q(BQ), q(Bonaire, Sint Eustatius and Saba) ],
   q(congo, the democratic republic of the) => [ q(cd), q(Congo, The Democratic Republic of the) ],
   q(european union) => [ q(eu), q(European Union) ],
   q(falkland islands (malvinas)) => [ q(fk), q(Falkland Islands (Malvinas)) ],
   q(france, metropolitan) => [ q(FX), q(France, Metropolitan) ],
   q(holy see (vatican city state)) => [ q(va), q(Holy See (Vatican City State)) ],
   q(iran, islamic republic of) => [ q(ir), q(Iran, Islamic Republic of) ],
   q(korea, democratic people's republic of) => [ q(kp), q(Korea, Democratic People's Republic of) ],
   q(korea, republic of) => [ q(kr), q(Korea, Republic of) ],
   q(libyan arab jamahiriya) => [ q(LY), q(Libyan Arab Jamahiriya) ],
   q(micronesia, federated states of) => [ q(fm), q(Micronesia, Federated States of) ],
   q(moldova, republic of) => [ q(md), q(Moldova, Republic of) ],
   q(portuguese timor) => [ q(TP), q(Portuguese Timor) ],
   q(portuguese timor ) => [ q(TP), q(Portuguese Timor ) ],
   q(saint helena, ascension and tristan da cunha) => [ q(SH), q(Saint Helena, Ascension and Tristan da Cunha) ],
   q(saint martin) => [ q(MF), q(Saint Martin) ],
   q(soviet union) => [ q(SU), q(Soviet Union) ],
   q(soviet union ) => [ q(SU), q(Soviet Union ) ],
   q(taiwan) => [ q(TW), q(Taiwan) ],
   q(taiwan, province of china) => [ q(tw), q(Taiwan, Province of China) ],
   q(venezuela, bolivarian republic of) => [ q(ve), q(Venezuela, Bolivarian Republic of) ],
   q(virgin islands, british) => [ q(vg), q(Virgin Islands, British) ],
   q(virgin islands, u.s.) => [ q(vi), q(Virgin Islands, U.S.) ],
   q(yugoslavia ) => [ q(YU), q(Yugoslavia ) ],
};

$Locale::Codes::Retired{'country'}{'numeric'}{'name'} = {
   q(antarctica) => [ q(010), q(Antarctica) ],
   q(bolivia) => [ q(068), q(Bolivia) ],
   q(bolivia (plurinational state of)) => [ q(068), q(Bolivia (Plurinational State of)) ],
   q(bonaire, saint eustatius and saba) => [ q(535), q(Bonaire, Saint Eustatius and Saba) ],
   q(bouvet island) => [ q(074), q(Bouvet Island) ],
   q(british indian ocean territory) => [ q(086), q(British Indian Ocean Territory) ],
   q(british virgin islands) => [ q(092), q(British Virgin Islands) ],
   q(cabo verde) => [ q(132), q(Cabo Verde) ],
   q(cape verde) => [ q(132), q(Cape Verde) ],
   q(channel islands) => [ q(830), q(Channel Islands) ],
   q(china, hong kong special administrative region) => [ q(344), q(China, Hong Kong Special Administrative Region) ],
   q(china, macao special administrative region) => [ q(446), q(China, Macao Special Administrative Region) ],
   q(christmas island) => [ q(162), q(Christmas Island) ],
   q(cocos (keeling) islands) => [ q(166), q(Cocos (Keeling) Islands) ],
   q(congo, the democratic republic of the) => [ q(180), q(Congo, The Democratic Republic of the) ],
   q(democratic people's republic of korea) => [ q(408), q(Democratic People's Republic of Korea) ],
   q(democratic republic of the congo) => [ q(180), q(Democratic Republic of the Congo) ],
   q(east timor) => [ q(626), q(East Timor) ],
   q(faeroe islands) => [ q(234), q(Faeroe Islands) ],
   q(falkland islands (malvinas)) => [ q(238), q(Falkland Islands (Malvinas)) ],
   q(faroe islands) => [ q(234), q(Faroe Islands) ],
   q(france, metropolitan) => [ q(249), q(France, Metropolitan) ],
   q(french southern and antarctic lands) => [ q(260), q(French Southern and Antarctic Lands) ],
   q(french southern territories) => [ q(260), q(French Southern Territories) ],
   q(heard island and mcdonald islands) => [ q(334), q(Heard Island and Mcdonald Islands) ],
   q(holy see) => [ q(336), q(Holy See) ],
   q(holy see (vatican city state)) => [ q(336), q(Holy See (Vatican City State)) ],
   q(hong kong) => [ q(344), q(Hong Kong) ],
   q(hong kong special administrative region of china) => [ q(344), q(Hong Kong Special Administrative Region of China) ],
   q(iran (islamic republic of)) => [ q(364), q(Iran (Islamic Republic of)) ],
   q(iran, islamic republic of) => [ q(364), q(Iran, Islamic Republic of) ],
   q(kazakstan) => [ q(398), q(Kazakstan) ],
   q(korea, democratic people's republic of) => [ q(408), q(Korea, Democratic People's Republic of) ],
   q(korea, republic of) => [ q(410), q(Korea, Republic of) ],
   q(libyan arab jamahiriya) => [ q(434), q(Libyan Arab Jamahiriya) ],
   q(macao) => [ q(446), q(Macao) ],
   q(macao special administrative region of china) => [ q(446), q(Macao Special Administrative Region of China) ],
   q(macau) => [ q(446), q(Macau) ],
   q(macedonia, the former yugoslav republic of) => [ q(807), q(Macedonia, the Former Yugoslav Republic of) ],
   q(micronesia (federated states of)) => [ q(583), q(Micronesia (Federated States of)) ],
   q(micronesia, federated states of) => [ q(583), q(Micronesia, Federated States of) ],
   q(moldova, republic of) => [ q(498), q(Moldova, Republic of) ],
   q(netherlands antilles) => [ q(530), q(Netherlands Antilles) ],
   q(palestinian territory, occupied) => [ q(275), q(Palestinian Territory, Occupied) ],
   q(republic of korea) => [ q(410), q(Republic of Korea) ],
   q(republic of moldova) => [ q(498), q(Republic of Moldova) ],
   q(saint helena) => [ q(654), q(Saint Helena) ],
   q(saint-barthelemy) => [ q(652), q(Saint-Barthelemy) ],
   q(saint-martin (french part)) => [ q(663), q(Saint-Martin (French part)) ],
   q(sark) => [ q(680), q(Sark) ],
   q(serbia and montenegro) => [ q(891), q(Serbia and Montenegro) ],
   q(south georgia and the islands) => [ q(239), q(South Georgia and the Islands) ],
   q(south georgia and the south sandwich islands) => [ q(239), q(South Georgia and the South Sandwich Islands) ],
   q(state of palestine) => [ q(275), q(State of Palestine) ],
   q(svalbard and jan mayen) => [ q(744), q(Svalbard and Jan Mayen) ],
   q(svalbard and jan mayen islands) => [ q(744), q(Svalbard and Jan Mayen Islands) ],
   q(taiwan) => [ q(158), q(Taiwan) ],
   q(taiwan, province of china) => [ q(158), q(Taiwan, Province of China) ],
   q(tanzania, united republic of) => [ q(834), q(Tanzania, United Republic of) ],
   q(the former yugoslav republic of macedonia) => [ q(807), q(The former Yugoslav Republic of Macedonia) ],
   q(united kingdom) => [ q(826), q(United Kingdom) ],
   q(united kingdom of great britain and northern ireland) => [ q(826), q(United Kingdom of Great Britain and Northern Ireland) ],
   q(united republic of tanzania) => [ q(834), q(United Republic of Tanzania) ],
   q(united states) => [ q(840), q(United States) ],
   q(united states minor outlying islands) => [ q(581), q(United States Minor Outlying Islands) ],
   q(united states of america) => [ q(840), q(United States of America) ],
   q(united states virgin islands) => [ q(850), q(United States Virgin Islands) ],
   q(venezuela) => [ q(862), q(Venezuela) ],
   q(venezuela (bolivarian republic of)) => [ q(862), q(Venezuela (Bolivarian Republic of)) ],
   q(vietnam) => [ q(704), q(Vietnam) ],
   q(virgin islands, british) => [ q(092), q(Virgin Islands, British) ],
   q(virgin islands, u.s.) => [ q(850), q(Virgin Islands, U.S.) ],
   q(wallis and futuna) => [ q(876), q(Wallis and Futuna) ],
   q(wallis and futuna islands) => [ q(876), q(Wallis and Futuna Islands) ],
   q(yugoslavia) => [ q(891), q(Yugoslavia) ],
   q(zaire) => [ q(180), q(Zaire) ],
};


1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/perl/5.20.2/Locale/Codes/Currency.pm                                                      0100644 0000000 0000000 00000004366 12744441327 017253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::Currency;
# Copyright (C) 2001      Canon Research Centre Europe (CRE).
# Copyright (C) 2002-2009 Neil Bowers
# Copyright (c) 2010-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::Currency_Codes;
use Locale::Codes::Currency_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2currency
                currency2code
                all_currency_codes
                all_currency_names
                currency_code2code
                LOCALE_CURR_ALPHA
                LOCALE_CURR_NUMERIC
               );

sub code2currency {
   return Locale::Codes::_code2name('currency',@_);
}

sub currency2code {
   return Locale::Codes::_name2code('currency',@_);
}

sub currency_code2code {
   return Locale::Codes::_code2code('currency',@_);
}

sub all_currency_codes {
   return Locale::Codes::_all_codes('currency',@_);
}

sub all_currency_names {
   return Locale::Codes::_all_names('currency',@_);
}

sub rename_currency {
   return Locale::Codes::_rename('currency',@_);
}

sub add_currency {
   return Locale::Codes::_add_code('currency',@_);
}

sub delete_currency {
   return Locale::Codes::_delete_code('currency',@_);
}

sub add_currency_alias {
   return Locale::Codes::_add_alias('currency',@_);
}

sub delete_currency_alias {
   return Locale::Codes::_delete_alias('currency',@_);
}

sub rename_currency_code {
   return Locale::Codes::_rename_code('currency',@_);
}

sub add_currency_code_alias {
   return Locale::Codes::_add_code_alias('currency',@_);
}

sub delete_currency_code_alias {
   return Locale::Codes::_delete_code_alias('currency',@_);
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                          usr/share/perl/5.20.2/Locale/Codes/Currency.pod                                                     0100644 0000000 0000000 00000006113 12744441327 017411  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::Currency - standard codes for currency identification

=head1 SYNOPSIS

    use Locale::Codes::Currency;

    $curr = code2currency('usd');     # $curr gets 'US Dollar'
    $code = currency2code('Euro');    # $code gets 'eur'

    @codes   = all_currency_codes();
    @names   = all_currency_names();


=head1 DESCRIPTION

The C<Locale::Codes::Currency> module provides access to standard codes used
for identifying currencies and funds, such as those defined in ISO 4217.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO
4217 three-letter codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
currencies. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $curr = code2currency('usd','alpha');
   $curr = code2currency('usd',LOCALE_CURR_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha, LOCALE_CURR_ALPHA>

This is a set of three-letter (uppercase) codes from ISO 4217 such
as EUR for Euro.

Two of the codes specified by the standard (XTS which is reserved
for testing purposes and XXX which is for transactions where no
currency is involved) are omitted.

This is the default code set.

=item B<num, LOCALE_CURR_NUMERIC>

This is the set of three-digit numeric codes from ISO 4217.

=back

=head1 ROUTINES

=over 4

=item B<code2currency ( CODE [,CODESET] )>

=item B<currency2code ( NAME [,CODESET] )>

=item B<currency_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_currency_codes ( [CODESET] )>

=item B<all_currency_names ( [CODESET] )>

=item B<Locale::Codes::Currency::rename_currency  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::Currency::add_currency  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::Currency::delete_currency  ( CODE [,CODESET] )>

=item B<Locale::Codes::Currency::add_currency_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::Currency::delete_currency_alias  ( NAME )>

=item B<Locale::Codes::Currency::rename_currency_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Currency::add_currency_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::Currency::delete_currency_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.iso.org/iso/support/currency_codes_list-1.htm>

The ISO 4217 data.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001      Michael Hennecke
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/share/perl/5.20.2/Locale/Codes/Currency_Codes.pm                                                0100644 0000000 0000000 00000144154 12744441327 020370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Currency_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:44:26 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'currency'}{'id'} = '0178';

$Locale::Codes::Data{'currency'}{'id2names'} = {
   q(0001) => [
      q(Afghani),
      ],
   q(0002) => [
      q(Euro),
      ],
   q(0003) => [
      q(Lek),
      ],
   q(0004) => [
      q(Algerian Dinar),
      ],
   q(0005) => [
      q(US Dollar),
      ],
   q(0006) => [
      q(Kwanza),
      ],
   q(0007) => [
      q(East Caribbean Dollar),
      ],
   q(0008) => [
      q(Argentine Peso),
      ],
   q(0009) => [
      q(Armenian Dram),
      ],
   q(0010) => [
      q(Aruban Florin),
      ],
   q(0011) => [
      q(Australian Dollar),
      ],
   q(0012) => [
      q(Azerbaijanian Manat),
      ],
   q(0013) => [
      q(Bahamian Dollar),
      ],
   q(0014) => [
      q(Bahraini Dinar),
      ],
   q(0015) => [
      q(Taka),
      ],
   q(0016) => [
      q(Barbados Dollar),
      ],
   q(0017) => [
      q(Belarussian Ruble),
      ],
   q(0018) => [
      q(Belize Dollar),
      ],
   q(0019) => [
      q(CFA Franc BCEAO),
      ],
   q(0020) => [
      q(Bermudian Dollar),
      ],
   q(0021) => [
      q(Ngultrum),
      ],
   q(0022) => [
      q(Indian Rupee),
      ],
   q(0023) => [
      q(Boliviano),
      ],
   q(0024) => [
      q(Mvdol),
      ],
   q(0025) => [
      q(Convertible Mark),
      ],
   q(0026) => [
      q(Pula),
      ],
   q(0027) => [
      q(Norwegian Krone),
      ],
   q(0028) => [
      q(Brazilian Real),
      ],
   q(0029) => [
      q(Brunei Dollar),
      ],
   q(0030) => [
      q(Bulgarian Lev),
      ],
   q(0031) => [
      q(Burundi Franc),
      ],
   q(0032) => [
      q(Riel),
      ],
   q(0033) => [
      q(CFA Franc BEAC),
      ],
   q(0034) => [
      q(Canadian Dollar),
      ],
   q(0035) => [
      q(Cape Verde Escudo),
      ],
   q(0036) => [
      q(Cayman Islands Dollar),
      ],
   q(0037) => [
      q(Unidad de Fomento),
      ],
   q(0038) => [
      q(Chilean Peso),
      ],
   q(0039) => [
      q(Yuan Renminbi),
      ],
   q(0040) => [
      q(Colombian Peso),
      ],
   q(0041) => [
      q(Unidad de Valor Real),
      ],
   q(0042) => [
      q(Comoro Franc),
      ],
   q(0043) => [
      q(Congolese Franc),
      ],
   q(0044) => [
      q(New Zealand Dollar),
      ],
   q(0045) => [
      q(Costa Rican Colon),
      ],
   q(0046) => [
      q(Croatian Kuna),
      ],
   q(0047) => [
      q(Peso Convertible),
      ],
   q(0048) => [
      q(Cuban Peso),
      ],
   q(0049) => [
      q(Netherlands Antillean Guilder),
      ],
   q(0050) => [
      q(Czech Koruna),
      ],
   q(0051) => [
      q(Danish Krone),
      ],
   q(0052) => [
      q(Djibouti Franc),
      ],
   q(0053) => [
      q(Dominican Peso),
      ],
   q(0054) => [
      q(Egyptian Pound),
      ],
   q(0055) => [
      q(El Salvador Colon),
      ],
   q(0056) => [
      q(Nakfa),
      ],
   q(0057) => [
      q(Ethiopian Birr),
      ],
   q(0058) => [
      q(Falkland Islands Pound),
      ],
   q(0059) => [
      q(Fiji Dollar),
      ],
   q(0060) => [
      q(CFP Franc),
      ],
   q(0061) => [
      q(Dalasi),
      ],
   q(0062) => [
      q(Lari),
      ],
   q(0063) => [
      q(Ghana Cedi),
      ],
   q(0064) => [
      q(Gibraltar Pound),
      ],
   q(0065) => [
      q(Quetzal),
      ],
   q(0066) => [
      q(Pound Sterling),
      ],
   q(0067) => [
      q(Guinea Franc),
      ],
   q(0068) => [
      q(Guyana Dollar),
      ],
   q(0069) => [
      q(Gourde),
      ],
   q(0070) => [
      q(Lempira),
      ],
   q(0071) => [
      q(Hong Kong Dollar),
      ],
   q(0072) => [
      q(Forint),
      ],
   q(0073) => [
      q(Iceland Krona),
      ],
   q(0074) => [
      q(Rupiah),
      ],
   q(0075) => [
      q(SDR (Special Drawing Right)),
      ],
   q(0076) => [
      q(Iranian Rial),
      ],
   q(0077) => [
      q(Iraqi Dinar),
      ],
   q(0078) => [
      q(New Israeli Sheqel),
      ],
   q(0079) => [
      q(Jamaican Dollar),
      ],
   q(0080) => [
      q(Yen),
      ],
   q(0081) => [
      q(Jordanian Dinar),
      ],
   q(0082) => [
      q(Tenge),
      ],
   q(0083) => [
      q(Kenyan Shilling),
      ],
   q(0084) => [
      q(North Korean Won),
      ],
   q(0085) => [
      q(Won),
      ],
   q(0086) => [
      q(Kuwaiti Dinar),
      ],
   q(0087) => [
      q(Som),
      ],
   q(0088) => [
      q(Kip),
      ],
   q(0089) => [
      q(Lebanese Pound),
      ],
   q(0090) => [
      q(Loti),
      ],
   q(0091) => [
      q(Rand),
      ],
   q(0092) => [
      q(Liberian Dollar),
      ],
   q(0093) => [
      q(Libyan Dinar),
      ],
   q(0094) => [
      q(Swiss Franc),
      ],
   q(0095) => [
      q(Lithuanian Litas),
      ],
   q(0096) => [
      q(Pataca),
      ],
   q(0097) => [
      q(Denar),
      ],
   q(0098) => [
      q(Malagasy Ariary),
      ],
   q(0099) => [
      q(Kwacha),
      ],
   q(0100) => [
      q(Malaysian Ringgit),
      ],
   q(0101) => [
      q(Rufiyaa),
      ],
   q(0102) => [
      q(Ouguiya),
      ],
   q(0103) => [
      q(Mauritius Rupee),
      ],
   q(0104) => [
      q(ADB Unit of Account),
      ],
   q(0105) => [
      q(Mexican Peso),
      ],
   q(0106) => [
      q(Mexican Unidad de Inversion (UDI)),
      ],
   q(0107) => [
      q(Moldovan Leu),
      ],
   q(0108) => [
      q(Tugrik),
      ],
   q(0109) => [
      q(Moroccan Dirham),
      ],
   q(0110) => [
      q(Mozambique Metical),
      ],
   q(0111) => [
      q(Kyat),
      ],
   q(0112) => [
      q(Namibia Dollar),
      ],
   q(0113) => [
      q(Nepalese Rupee),
      ],
   q(0114) => [
      q(Cordoba Oro),
      ],
   q(0115) => [
      q(Naira),
      ],
   q(0116) => [
      q(Rial Omani),
      ],
   q(0117) => [
      q(Pakistan Rupee),
      ],
   q(0118) => [
      q(Balboa),
      ],
   q(0119) => [
      q(Kina),
      ],
   q(0120) => [
      q(Guarani),
      ],
   q(0121) => [
      q(Nuevo Sol),
      ],
   q(0122) => [
      q(Philippine Peso),
      ],
   q(0123) => [
      q(Zloty),
      ],
   q(0124) => [
      q(Qatari Rial),
      ],
   q(0125) => [
      q(New Romanian Leu),
      ],
   q(0126) => [
      q(Russian Ruble),
      ],
   q(0127) => [
      q(Rwanda Franc),
      ],
   q(0128) => [
      q(Tala),
      ],
   q(0129) => [
      q(Dobra),
      ],
   q(0130) => [
      q(Saudi Riyal),
      ],
   q(0131) => [
      q(Serbian Dinar),
      ],
   q(0132) => [
      q(Seychelles Rupee),
      ],
   q(0133) => [
      q(Leone),
      ],
   q(0134) => [
      q(Singapore Dollar),
      ],
   q(0135) => [
      q(Sucre),
      ],
   q(0136) => [
      q(Solomon Islands Dollar),
      ],
   q(0137) => [
      q(Somali Shilling),
      ],
   q(0138) => [
      q(South Sudanese Pound),
      ],
   q(0139) => [
      q(Sri Lanka Rupee),
      ],
   q(0140) => [
      q(Sudanese Pound),
      ],
   q(0141) => [
      q(Surinam Dollar),
      ],
   q(0142) => [
      q(Lilangeni),
      ],
   q(0143) => [
      q(Swedish Krona),
      ],
   q(0144) => [
      q(WIR Euro),
      ],
   q(0145) => [
      q(WIR Franc),
      ],
   q(0146) => [
      q(Syrian Pound),
      ],
   q(0147) => [
      q(New Taiwan Dollar),
      ],
   q(0148) => [
      q(Somoni),
      ],
   q(0149) => [
      q(Tanzanian Shilling),
      ],
   q(0150) => [
      q(Baht),
      ],
   q(0151) => [
      q(Pa'anga),
      ],
   q(0152) => [
      q(Trinidad and Tobago Dollar),
      ],
   q(0153) => [
      q(Tunisian Dinar),
      ],
   q(0154) => [
      q(Turkish Lira),
      ],
   q(0155) => [
      q(Turkmenistan New Manat),
      ],
   q(0156) => [
      q(Uganda Shilling),
      ],
   q(0157) => [
      q(Hryvnia),
      ],
   q(0158) => [
      q(UAE Dirham),
      ],
   q(0159) => [
      q(US Dollar (Next day)),
      ],
   q(0160) => [
      q(US Dollar (Same day)),
      ],
   q(0161) => [
      q(Uruguay Peso en Unidades Indexadas (URUIURUI)),
      ],
   q(0162) => [
      q(Peso Uruguayo),
      ],
   q(0163) => [
      q(Uzbekistan Sum),
      ],
   q(0164) => [
      q(Vatu),
      ],
   q(0165) => [
      q(Bolivar),
      ],
   q(0166) => [
      q(Dong),
      ],
   q(0167) => [
      q(Yemeni Rial),
      ],
   q(0168) => [
      q(Zambian Kwacha),
      ],
   q(0169) => [
      q(Zimbabwe Dollar),
      ],
   q(0170) => [
      q(Bond Markets Unit European Composite Unit (EURCO)),
      ],
   q(0171) => [
      q(Bond Markets Unit European Monetary Unit (E.M.U.-6)),
      ],
   q(0172) => [
      q(Bond Markets Unit European Unit of Account 9 (E.U.A.-9)),
      ],
   q(0173) => [
      q(Bond Markets Unit European Unit of Account 17 (E.U.A.-17)),
      ],
   q(0174) => [
      q(Gold),
      ],
   q(0175) => [
      q(Palladium),
      ],
   q(0176) => [
      q(Platinum),
      ],
   q(0177) => [
      q(Silver),
      ],
};

$Locale::Codes::Data{'currency'}{'alias2id'} = {
   q(adb unit of account) => [
      q(0104),
      q(0),
      ],
   q(afghani) => [
      q(0001),
      q(0),
      ],
   q(algerian dinar) => [
      q(0004),
      q(0),
      ],
   q(argentine peso) => [
      q(0008),
      q(0),
      ],
   q(armenian dram) => [
      q(0009),
      q(0),
      ],
   q(aruban florin) => [
      q(0010),
      q(0),
      ],
   q(australian dollar) => [
      q(0011),
      q(0),
      ],
   q(azerbaijanian manat) => [
      q(0012),
      q(0),
      ],
   q(bahamian dollar) => [
      q(0013),
      q(0),
      ],
   q(bahraini dinar) => [
      q(0014),
      q(0),
      ],
   q(baht) => [
      q(0150),
      q(0),
      ],
   q(balboa) => [
      q(0118),
      q(0),
      ],
   q(barbados dollar) => [
      q(0016),
      q(0),
      ],
   q(belarussian ruble) => [
      q(0017),
      q(0),
      ],
   q(belize dollar) => [
      q(0018),
      q(0),
      ],
   q(bermudian dollar) => [
      q(0020),
      q(0),
      ],
   q(bolivar) => [
      q(0165),
      q(0),
      ],
   q(boliviano) => [
      q(0023),
      q(0),
      ],
   q(bond markets unit european composite unit (eurco)) => [
      q(0170),
      q(0),
      ],
   q(bond markets unit european monetary unit (e.m.u.-6)) => [
      q(0171),
      q(0),
      ],
   q(bond markets unit european unit of account 17 (e.u.a.-17)) => [
      q(0173),
      q(0),
      ],
   q(bond markets unit european unit of account 9 (e.u.a.-9)) => [
      q(0172),
      q(0),
      ],
   q(brazilian real) => [
      q(0028),
      q(0),
      ],
   q(brunei dollar) => [
      q(0029),
      q(0),
      ],
   q(bulgarian lev) => [
      q(0030),
      q(0),
      ],
   q(burundi franc) => [
      q(0031),
      q(0),
      ],
   q(canadian dollar) => [
      q(0034),
      q(0),
      ],
   q(cape verde escudo) => [
      q(0035),
      q(0),
      ],
   q(cayman islands dollar) => [
      q(0036),
      q(0),
      ],
   q(cfa franc bceao) => [
      q(0019),
      q(0),
      ],
   q(cfa franc beac) => [
      q(0033),
      q(0),
      ],
   q(cfp franc) => [
      q(0060),
      q(0),
      ],
   q(chilean peso) => [
      q(0038),
      q(0),
      ],
   q(colombian peso) => [
      q(0040),
      q(0),
      ],
   q(comoro franc) => [
      q(0042),
      q(0),
      ],
   q(congolese franc) => [
      q(0043),
      q(0),
      ],
   q(convertible mark) => [
      q(0025),
      q(0),
      ],
   q(cordoba oro) => [
      q(0114),
      q(0),
      ],
   q(costa rican colon) => [
      q(0045),
      q(0),
      ],
   q(croatian kuna) => [
      q(0046),
      q(0),
      ],
   q(cuban peso) => [
      q(0048),
      q(0),
      ],
   q(czech koruna) => [
      q(0050),
      q(0),
      ],
   q(dalasi) => [
      q(0061),
      q(0),
      ],
   q(danish krone) => [
      q(0051),
      q(0),
      ],
   q(denar) => [
      q(0097),
      q(0),
      ],
   q(djibouti franc) => [
      q(0052),
      q(0),
      ],
   q(dobra) => [
      q(0129),
      q(0),
      ],
   q(dominican peso) => [
      q(0053),
      q(0),
      ],
   q(dong) => [
      q(0166),
      q(0),
      ],
   q(east caribbean dollar) => [
      q(0007),
      q(0),
      ],
   q(egyptian pound) => [
      q(0054),
      q(0),
      ],
   q(el salvador colon) => [
      q(0055),
      q(0),
      ],
   q(ethiopian birr) => [
      q(0057),
      q(0),
      ],
   q(euro) => [
      q(0002),
      q(0),
      ],
   q(falkland islands pound) => [
      q(0058),
      q(0),
      ],
   q(fiji dollar) => [
      q(0059),
      q(0),
      ],
   q(forint) => [
      q(0072),
      q(0),
      ],
   q(ghana cedi) => [
      q(0063),
      q(0),
      ],
   q(gibraltar pound) => [
      q(0064),
      q(0),
      ],
   q(gold) => [
      q(0174),
      q(0),
      ],
   q(gourde) => [
      q(0069),
      q(0),
      ],
   q(guarani) => [
      q(0120),
      q(0),
      ],
   q(guinea franc) => [
      q(0067),
      q(0),
      ],
   q(guyana dollar) => [
      q(0068),
      q(0),
      ],
   q(hong kong dollar) => [
      q(0071),
      q(0),
      ],
   q(hryvnia) => [
      q(0157),
      q(0),
      ],
   q(iceland krona) => [
      q(0073),
      q(0),
      ],
   q(indian rupee) => [
      q(0022),
      q(0),
      ],
   q(iranian rial) => [
      q(0076),
      q(0),
      ],
   q(iraqi dinar) => [
      q(0077),
      q(0),
      ],
   q(jamaican dollar) => [
      q(0079),
      q(0),
      ],
   q(jordanian dinar) => [
      q(0081),
      q(0),
      ],
   q(kenyan shilling) => [
      q(0083),
      q(0),
      ],
   q(kina) => [
      q(0119),
      q(0),
      ],
   q(kip) => [
      q(0088),
      q(0),
      ],
   q(kuwaiti dinar) => [
      q(0086),
      q(0),
      ],
   q(kwacha) => [
      q(0099),
      q(0),
      ],
   q(kwanza) => [
      q(0006),
      q(0),
      ],
   q(kyat) => [
      q(0111),
      q(0),
      ],
   q(lari) => [
      q(0062),
      q(0),
      ],
   q(lebanese pound) => [
      q(0089),
      q(0),
      ],
   q(lek) => [
      q(0003),
      q(0),
      ],
   q(lempira) => [
      q(0070),
      q(0),
      ],
   q(leone) => [
      q(0133),
      q(0),
      ],
   q(liberian dollar) => [
      q(0092),
      q(0),
      ],
   q(libyan dinar) => [
      q(0093),
      q(0),
      ],
   q(lilangeni) => [
      q(0142),
      q(0),
      ],
   q(lithuanian litas) => [
      q(0095),
      q(0),
      ],
   q(loti) => [
      q(0090),
      q(0),
      ],
   q(malagasy ariary) => [
      q(0098),
      q(0),
      ],
   q(malaysian ringgit) => [
      q(0100),
      q(0),
      ],
   q(mauritius rupee) => [
      q(0103),
      q(0),
      ],
   q(mexican peso) => [
      q(0105),
      q(0),
      ],
   q(mexican unidad de inversion (udi)) => [
      q(0106),
      q(0),
      ],
   q(moldovan leu) => [
      q(0107),
      q(0),
      ],
   q(moroccan dirham) => [
      q(0109),
      q(0),
      ],
   q(mozambique metical) => [
      q(0110),
      q(0),
      ],
   q(mvdol) => [
      q(0024),
      q(0),
      ],
   q(naira) => [
      q(0115),
      q(0),
      ],
   q(nakfa) => [
      q(0056),
      q(0),
      ],
   q(namibia dollar) => [
      q(0112),
      q(0),
      ],
   q(nepalese rupee) => [
      q(0113),
      q(0),
      ],
   q(netherlands antillean guilder) => [
      q(0049),
      q(0),
      ],
   q(new israeli sheqel) => [
      q(0078),
      q(0),
      ],
   q(new romanian leu) => [
      q(0125),
      q(0),
      ],
   q(new taiwan dollar) => [
      q(0147),
      q(0),
      ],
   q(new zealand dollar) => [
      q(0044),
      q(0),
      ],
   q(ngultrum) => [
      q(0021),
      q(0),
      ],
   q(north korean won) => [
      q(0084),
      q(0),
      ],
   q(norwegian krone) => [
      q(0027),
      q(0),
      ],
   q(nuevo sol) => [
      q(0121),
      q(0),
      ],
   q(ouguiya) => [
      q(0102),
      q(0),
      ],
   q(pa'anga) => [
      q(0151),
      q(0),
      ],
   q(pakistan rupee) => [
      q(0117),
      q(0),
      ],
   q(palladium) => [
      q(0175),
      q(0),
      ],
   q(pataca) => [
      q(0096),
      q(0),
      ],
   q(peso convertible) => [
      q(0047),
      q(0),
      ],
   q(peso uruguayo) => [
      q(0162),
      q(0),
      ],
   q(philippine peso) => [
      q(0122),
      q(0),
      ],
   q(platinum) => [
      q(0176),
      q(0),
      ],
   q(pound sterling) => [
      q(0066),
      q(0),
      ],
   q(pula) => [
      q(0026),
      q(0),
      ],
   q(qatari rial) => [
      q(0124),
      q(0),
      ],
   q(quetzal) => [
      q(0065),
      q(0),
      ],
   q(rand) => [
      q(0091),
      q(0),
      ],
   q(rial omani) => [
      q(0116),
      q(0),
      ],
   q(riel) => [
      q(0032),
      q(0),
      ],
   q(rufiyaa) => [
      q(0101),
      q(0),
      ],
   q(rupiah) => [
      q(0074),
      q(0),
      ],
   q(russian ruble) => [
      q(0126),
      q(0),
      ],
   q(rwanda franc) => [
      q(0127),
      q(0),
      ],
   q(saudi riyal) => [
      q(0130),
      q(0),
      ],
   q(sdr (special drawing right)) => [
      q(0075),
      q(0),
      ],
   q(serbian dinar) => [
      q(0131),
      q(0),
      ],
   q(seychelles rupee) => [
      q(0132),
      q(0),
      ],
   q(silver) => [
      q(0177),
      q(0),
      ],
   q(singapore dollar) => [
      q(0134),
      q(0),
      ],
   q(solomon islands dollar) => [
      q(0136),
      q(0),
      ],
   q(som) => [
      q(0087),
      q(0),
      ],
   q(somali shilling) => [
      q(0137),
      q(0),
      ],
   q(somoni) => [
      q(0148),
      q(0),
      ],
   q(south sudanese pound) => [
      q(0138),
      q(0),
      ],
   q(sri lanka rupee) => [
      q(0139),
      q(0),
      ],
   q(sucre) => [
      q(0135),
      q(0),
      ],
   q(sudanese pound) => [
      q(0140),
      q(0),
      ],
   q(surinam dollar) => [
      q(0141),
      q(0),
      ],
   q(swedish krona) => [
      q(0143),
      q(0),
      ],
   q(swiss franc) => [
      q(0094),
      q(0),
      ],
   q(syrian pound) => [
      q(0146),
      q(0),
      ],
   q(taka) => [
      q(0015),
      q(0),
      ],
   q(tala) => [
      q(0128),
      q(0),
      ],
   q(tanzanian shilling) => [
      q(0149),
      q(0),
      ],
   q(tenge) => [
      q(0082),
      q(0),
      ],
   q(trinidad and tobago dollar) => [
      q(0152),
      q(0),
      ],
   q(tugrik) => [
      q(0108),
      q(0),
      ],
   q(tunisian dinar) => [
      q(0153),
      q(0),
      ],
   q(turkish lira) => [
      q(0154),
      q(0),
      ],
   q(turkmenistan new manat) => [
      q(0155),
      q(0),
      ],
   q(uae dirham) => [
      q(0158),
      q(0),
      ],
   q(uganda shilling) => [
      q(0156),
      q(0),
      ],
   q(unidad de fomento) => [
      q(0037),
      q(0),
      ],
   q(unidad de valor real) => [
      q(0041),
      q(0),
      ],
   q(uruguay peso en unidades indexadas (uruiurui)) => [
      q(0161),
      q(0),
      ],
   q(us dollar) => [
      q(0005),
      q(0),
      ],
   q(us dollar (next day)) => [
      q(0159),
      q(0),
      ],
   q(us dollar (same day)) => [
      q(0160),
      q(0),
      ],
   q(uzbekistan sum) => [
      q(0163),
      q(0),
      ],
   q(vatu) => [
      q(0164),
      q(0),
      ],
   q(wir euro) => [
      q(0144),
      q(0),
      ],
   q(wir franc) => [
      q(0145),
      q(0),
      ],
   q(won) => [
      q(0085),
      q(0),
      ],
   q(yemeni rial) => [
      q(0167),
      q(0),
      ],
   q(yen) => [
      q(0080),
      q(0),
      ],
   q(yuan renminbi) => [
      q(0039),
      q(0),
      ],
   q(zambian kwacha) => [
      q(0168),
      q(0),
      ],
   q(zimbabwe dollar) => [
      q(0169),
      q(0),
      ],
   q(zloty) => [
      q(0123),
      q(0),
      ],
};

$Locale::Codes::Data{'currency'}{'code2id'} = {
   q(alpha) => {
      q(AED) => [
         q(0158),
         q(0),
         ],
      q(AFN) => [
         q(0001),
         q(0),
         ],
      q(ALL) => [
         q(0003),
         q(0),
         ],
      q(AMD) => [
         q(0009),
         q(0),
         ],
      q(ANG) => [
         q(0049),
         q(0),
         ],
      q(AOA) => [
         q(0006),
         q(0),
         ],
      q(ARS) => [
         q(0008),
         q(0),
         ],
      q(AUD) => [
         q(0011),
         q(0),
         ],
      q(AWG) => [
         q(0010),
         q(0),
         ],
      q(AZN) => [
         q(0012),
         q(0),
         ],
      q(BAM) => [
         q(0025),
         q(0),
         ],
      q(BBD) => [
         q(0016),
         q(0),
         ],
      q(BDT) => [
         q(0015),
         q(0),
         ],
      q(BGN) => [
         q(0030),
         q(0),
         ],
      q(BHD) => [
         q(0014),
         q(0),
         ],
      q(BIF) => [
         q(0031),
         q(0),
         ],
      q(BMD) => [
         q(0020),
         q(0),
         ],
      q(BND) => [
         q(0029),
         q(0),
         ],
      q(BOB) => [
         q(0023),
         q(0),
         ],
      q(BOV) => [
         q(0024),
         q(0),
         ],
      q(BRL) => [
         q(0028),
         q(0),
         ],
      q(BSD) => [
         q(0013),
         q(0),
         ],
      q(BTN) => [
         q(0021),
         q(0),
         ],
      q(BWP) => [
         q(0026),
         q(0),
         ],
      q(BYR) => [
         q(0017),
         q(0),
         ],
      q(BZD) => [
         q(0018),
         q(0),
         ],
      q(CAD) => [
         q(0034),
         q(0),
         ],
      q(CDF) => [
         q(0043),
         q(0),
         ],
      q(CHE) => [
         q(0144),
         q(0),
         ],
      q(CHF) => [
         q(0094),
         q(0),
         ],
      q(CHW) => [
         q(0145),
         q(0),
         ],
      q(CLF) => [
         q(0037),
         q(0),
         ],
      q(CLP) => [
         q(0038),
         q(0),
         ],
      q(CNY) => [
         q(0039),
         q(0),
         ],
      q(COP) => [
         q(0040),
         q(0),
         ],
      q(COU) => [
         q(0041),
         q(0),
         ],
      q(CRC) => [
         q(0045),
         q(0),
         ],
      q(CUC) => [
         q(0047),
         q(0),
         ],
      q(CUP) => [
         q(0048),
         q(0),
         ],
      q(CVE) => [
         q(0035),
         q(0),
         ],
      q(CZK) => [
         q(0050),
         q(0),
         ],
      q(DJF) => [
         q(0052),
         q(0),
         ],
      q(DKK) => [
         q(0051),
         q(0),
         ],
      q(DOP) => [
         q(0053),
         q(0),
         ],
      q(DZD) => [
         q(0004),
         q(0),
         ],
      q(EGP) => [
         q(0054),
         q(0),
         ],
      q(ERN) => [
         q(0056),
         q(0),
         ],
      q(ETB) => [
         q(0057),
         q(0),
         ],
      q(EUR) => [
         q(0002),
         q(0),
         ],
      q(FJD) => [
         q(0059),
         q(0),
         ],
      q(FKP) => [
         q(0058),
         q(0),
         ],
      q(GBP) => [
         q(0066),
         q(0),
         ],
      q(GEL) => [
         q(0062),
         q(0),
         ],
      q(GHS) => [
         q(0063),
         q(0),
         ],
      q(GIP) => [
         q(0064),
         q(0),
         ],
      q(GMD) => [
         q(0061),
         q(0),
         ],
      q(GNF) => [
         q(0067),
         q(0),
         ],
      q(GTQ) => [
         q(0065),
         q(0),
         ],
      q(GYD) => [
         q(0068),
         q(0),
         ],
      q(HKD) => [
         q(0071),
         q(0),
         ],
      q(HNL) => [
         q(0070),
         q(0),
         ],
      q(HRK) => [
         q(0046),
         q(0),
         ],
      q(HTG) => [
         q(0069),
         q(0),
         ],
      q(HUF) => [
         q(0072),
         q(0),
         ],
      q(IDR) => [
         q(0074),
         q(0),
         ],
      q(ILS) => [
         q(0078),
         q(0),
         ],
      q(INR) => [
         q(0022),
         q(0),
         ],
      q(IQD) => [
         q(0077),
         q(0),
         ],
      q(IRR) => [
         q(0076),
         q(0),
         ],
      q(ISK) => [
         q(0073),
         q(0),
         ],
      q(JMD) => [
         q(0079),
         q(0),
         ],
      q(JOD) => [
         q(0081),
         q(0),
         ],
      q(JPY) => [
         q(0080),
         q(0),
         ],
      q(KES) => [
         q(0083),
         q(0),
         ],
      q(KGS) => [
         q(0087),
         q(0),
         ],
      q(KHR) => [
         q(0032),
         q(0),
         ],
      q(KMF) => [
         q(0042),
         q(0),
         ],
      q(KPW) => [
         q(0084),
         q(0),
         ],
      q(KRW) => [
         q(0085),
         q(0),
         ],
      q(KWD) => [
         q(0086),
         q(0),
         ],
      q(KYD) => [
         q(0036),
         q(0),
         ],
      q(KZT) => [
         q(0082),
         q(0),
         ],
      q(LAK) => [
         q(0088),
         q(0),
         ],
      q(LBP) => [
         q(0089),
         q(0),
         ],
      q(LKR) => [
         q(0139),
         q(0),
         ],
      q(LRD) => [
         q(0092),
         q(0),
         ],
      q(LSL) => [
         q(0090),
         q(0),
         ],
      q(LTL) => [
         q(0095),
         q(0),
         ],
      q(LYD) => [
         q(0093),
         q(0),
         ],
      q(MAD) => [
         q(0109),
         q(0),
         ],
      q(MDL) => [
         q(0107),
         q(0),
         ],
      q(MGA) => [
         q(0098),
         q(0),
         ],
      q(MKD) => [
         q(0097),
         q(0),
         ],
      q(MMK) => [
         q(0111),
         q(0),
         ],
      q(MNT) => [
         q(0108),
         q(0),
         ],
      q(MOP) => [
         q(0096),
         q(0),
         ],
      q(MRO) => [
         q(0102),
         q(0),
         ],
      q(MUR) => [
         q(0103),
         q(0),
         ],
      q(MVR) => [
         q(0101),
         q(0),
         ],
      q(MWK) => [
         q(0099),
         q(0),
         ],
      q(MXN) => [
         q(0105),
         q(0),
         ],
      q(MXV) => [
         q(0106),
         q(0),
         ],
      q(MYR) => [
         q(0100),
         q(0),
         ],
      q(MZN) => [
         q(0110),
         q(0),
         ],
      q(NAD) => [
         q(0112),
         q(0),
         ],
      q(NGN) => [
         q(0115),
         q(0),
         ],
      q(NIO) => [
         q(0114),
         q(0),
         ],
      q(NOK) => [
         q(0027),
         q(0),
         ],
      q(NPR) => [
         q(0113),
         q(0),
         ],
      q(NZD) => [
         q(0044),
         q(0),
         ],
      q(OMR) => [
         q(0116),
         q(0),
         ],
      q(PAB) => [
         q(0118),
         q(0),
         ],
      q(PEN) => [
         q(0121),
         q(0),
         ],
      q(PGK) => [
         q(0119),
         q(0),
         ],
      q(PHP) => [
         q(0122),
         q(0),
         ],
      q(PKR) => [
         q(0117),
         q(0),
         ],
      q(PLN) => [
         q(0123),
         q(0),
         ],
      q(PYG) => [
         q(0120),
         q(0),
         ],
      q(QAR) => [
         q(0124),
         q(0),
         ],
      q(RON) => [
         q(0125),
         q(0),
         ],
      q(RSD) => [
         q(0131),
         q(0),
         ],
      q(RUB) => [
         q(0126),
         q(0),
         ],
      q(RWF) => [
         q(0127),
         q(0),
         ],
      q(SAR) => [
         q(0130),
         q(0),
         ],
      q(SBD) => [
         q(0136),
         q(0),
         ],
      q(SCR) => [
         q(0132),
         q(0),
         ],
      q(SDG) => [
         q(0140),
         q(0),
         ],
      q(SEK) => [
         q(0143),
         q(0),
         ],
      q(SGD) => [
         q(0134),
         q(0),
         ],
      q(SLL) => [
         q(0133),
         q(0),
         ],
      q(SOS) => [
         q(0137),
         q(0),
         ],
      q(SRD) => [
         q(0141),
         q(0),
         ],
      q(SSP) => [
         q(0138),
         q(0),
         ],
      q(STD) => [
         q(0129),
         q(0),
         ],
      q(SVC) => [
         q(0055),
         q(0),
         ],
      q(SYP) => [
         q(0146),
         q(0),
         ],
      q(SZL) => [
         q(0142),
         q(0),
         ],
      q(THB) => [
         q(0150),
         q(0),
         ],
      q(TJS) => [
         q(0148),
         q(0),
         ],
      q(TMT) => [
         q(0155),
         q(0),
         ],
      q(TND) => [
         q(0153),
         q(0),
         ],
      q(TOP) => [
         q(0151),
         q(0),
         ],
      q(TRY) => [
         q(0154),
         q(0),
         ],
      q(TTD) => [
         q(0152),
         q(0),
         ],
      q(TWD) => [
         q(0147),
         q(0),
         ],
      q(TZS) => [
         q(0149),
         q(0),
         ],
      q(UAH) => [
         q(0157),
         q(0),
         ],
      q(UGX) => [
         q(0156),
         q(0),
         ],
      q(USD) => [
         q(0005),
         q(0),
         ],
      q(USN) => [
         q(0159),
         q(0),
         ],
      q(USS) => [
         q(0160),
         q(0),
         ],
      q(UYI) => [
         q(0161),
         q(0),
         ],
      q(UYU) => [
         q(0162),
         q(0),
         ],
      q(UZS) => [
         q(0163),
         q(0),
         ],
      q(VEF) => [
         q(0165),
         q(0),
         ],
      q(VND) => [
         q(0166),
         q(0),
         ],
      q(VUV) => [
         q(0164),
         q(0),
         ],
      q(WST) => [
         q(0128),
         q(0),
         ],
      q(XAF) => [
         q(0033),
         q(0),
         ],
      q(XAG) => [
         q(0177),
         q(0),
         ],
      q(XAU) => [
         q(0174),
         q(0),
         ],
      q(XBA) => [
         q(0170),
         q(0),
         ],
      q(XBB) => [
         q(0171),
         q(0),
         ],
      q(XBC) => [
         q(0172),
         q(0),
         ],
      q(XBD) => [
         q(0173),
         q(0),
         ],
      q(XCD) => [
         q(0007),
         q(0),
         ],
      q(XDR) => [
         q(0075),
         q(0),
         ],
      q(XOF) => [
         q(0019),
         q(0),
         ],
      q(XPD) => [
         q(0175),
         q(0),
         ],
      q(XPF) => [
         q(0060),
         q(0),
         ],
      q(XPT) => [
         q(0176),
         q(0),
         ],
      q(XSU) => [
         q(0135),
         q(0),
         ],
      q(XUA) => [
         q(0104),
         q(0),
         ],
      q(YER) => [
         q(0167),
         q(0),
         ],
      q(ZAR) => [
         q(0091),
         q(0),
         ],
      q(ZMW) => [
         q(0168),
         q(0),
         ],
      q(ZWL) => [
         q(0169),
         q(0),
         ],
      },
   q(num) => {
      q(008) => [
         q(0003),
         q(0),
         ],
      q(012) => [
         q(0004),
         q(0),
         ],
      q(032) => [
         q(0008),
         q(0),
         ],
      q(036) => [
         q(0011),
         q(0),
         ],
      q(044) => [
         q(0013),
         q(0),
         ],
      q(048) => [
         q(0014),
         q(0),
         ],
      q(050) => [
         q(0015),
         q(0),
         ],
      q(051) => [
         q(0009),
         q(0),
         ],
      q(052) => [
         q(0016),
         q(0),
         ],
      q(060) => [
         q(0020),
         q(0),
         ],
      q(064) => [
         q(0021),
         q(0),
         ],
      q(068) => [
         q(0023),
         q(0),
         ],
      q(072) => [
         q(0026),
         q(0),
         ],
      q(084) => [
         q(0018),
         q(0),
         ],
      q(090) => [
         q(0136),
         q(0),
         ],
      q(096) => [
         q(0029),
         q(0),
         ],
      q(104) => [
         q(0111),
         q(0),
         ],
      q(108) => [
         q(0031),
         q(0),
         ],
      q(116) => [
         q(0032),
         q(0),
         ],
      q(124) => [
         q(0034),
         q(0),
         ],
      q(132) => [
         q(0035),
         q(0),
         ],
      q(136) => [
         q(0036),
         q(0),
         ],
      q(144) => [
         q(0139),
         q(0),
         ],
      q(152) => [
         q(0038),
         q(0),
         ],
      q(156) => [
         q(0039),
         q(0),
         ],
      q(170) => [
         q(0040),
         q(0),
         ],
      q(174) => [
         q(0042),
         q(0),
         ],
      q(188) => [
         q(0045),
         q(0),
         ],
      q(191) => [
         q(0046),
         q(0),
         ],
      q(192) => [
         q(0048),
         q(0),
         ],
      q(203) => [
         q(0050),
         q(0),
         ],
      q(208) => [
         q(0051),
         q(0),
         ],
      q(214) => [
         q(0053),
         q(0),
         ],
      q(222) => [
         q(0055),
         q(0),
         ],
      q(230) => [
         q(0057),
         q(0),
         ],
      q(232) => [
         q(0056),
         q(0),
         ],
      q(238) => [
         q(0058),
         q(0),
         ],
      q(242) => [
         q(0059),
         q(0),
         ],
      q(262) => [
         q(0052),
         q(0),
         ],
      q(270) => [
         q(0061),
         q(0),
         ],
      q(292) => [
         q(0064),
         q(0),
         ],
      q(320) => [
         q(0065),
         q(0),
         ],
      q(324) => [
         q(0067),
         q(0),
         ],
      q(328) => [
         q(0068),
         q(0),
         ],
      q(332) => [
         q(0069),
         q(0),
         ],
      q(340) => [
         q(0070),
         q(0),
         ],
      q(344) => [
         q(0071),
         q(0),
         ],
      q(348) => [
         q(0072),
         q(0),
         ],
      q(352) => [
         q(0073),
         q(0),
         ],
      q(356) => [
         q(0022),
         q(0),
         ],
      q(360) => [
         q(0074),
         q(0),
         ],
      q(364) => [
         q(0076),
         q(0),
         ],
      q(368) => [
         q(0077),
         q(0),
         ],
      q(376) => [
         q(0078),
         q(0),
         ],
      q(388) => [
         q(0079),
         q(0),
         ],
      q(392) => [
         q(0080),
         q(0),
         ],
      q(398) => [
         q(0082),
         q(0),
         ],
      q(400) => [
         q(0081),
         q(0),
         ],
      q(404) => [
         q(0083),
         q(0),
         ],
      q(408) => [
         q(0084),
         q(0),
         ],
      q(410) => [
         q(0085),
         q(0),
         ],
      q(414) => [
         q(0086),
         q(0),
         ],
      q(417) => [
         q(0087),
         q(0),
         ],
      q(418) => [
         q(0088),
         q(0),
         ],
      q(422) => [
         q(0089),
         q(0),
         ],
      q(426) => [
         q(0090),
         q(0),
         ],
      q(430) => [
         q(0092),
         q(0),
         ],
      q(434) => [
         q(0093),
         q(0),
         ],
      q(440) => [
         q(0095),
         q(0),
         ],
      q(446) => [
         q(0096),
         q(0),
         ],
      q(454) => [
         q(0099),
         q(0),
         ],
      q(458) => [
         q(0100),
         q(0),
         ],
      q(462) => [
         q(0101),
         q(0),
         ],
      q(478) => [
         q(0102),
         q(0),
         ],
      q(480) => [
         q(0103),
         q(0),
         ],
      q(484) => [
         q(0105),
         q(0),
         ],
      q(496) => [
         q(0108),
         q(0),
         ],
      q(498) => [
         q(0107),
         q(0),
         ],
      q(504) => [
         q(0109),
         q(0),
         ],
      q(512) => [
         q(0116),
         q(0),
         ],
      q(516) => [
         q(0112),
         q(0),
         ],
      q(524) => [
         q(0113),
         q(0),
         ],
      q(532) => [
         q(0049),
         q(0),
         ],
      q(533) => [
         q(0010),
         q(0),
         ],
      q(548) => [
         q(0164),
         q(0),
         ],
      q(554) => [
         q(0044),
         q(0),
         ],
      q(558) => [
         q(0114),
         q(0),
         ],
      q(566) => [
         q(0115),
         q(0),
         ],
      q(578) => [
         q(0027),
         q(0),
         ],
      q(586) => [
         q(0117),
         q(0),
         ],
      q(590) => [
         q(0118),
         q(0),
         ],
      q(598) => [
         q(0119),
         q(0),
         ],
      q(600) => [
         q(0120),
         q(0),
         ],
      q(604) => [
         q(0121),
         q(0),
         ],
      q(608) => [
         q(0122),
         q(0),
         ],
      q(634) => [
         q(0124),
         q(0),
         ],
      q(643) => [
         q(0126),
         q(0),
         ],
      q(646) => [
         q(0127),
         q(0),
         ],
      q(678) => [
         q(0129),
         q(0),
         ],
      q(682) => [
         q(0130),
         q(0),
         ],
      q(690) => [
         q(0132),
         q(0),
         ],
      q(694) => [
         q(0133),
         q(0),
         ],
      q(702) => [
         q(0134),
         q(0),
         ],
      q(704) => [
         q(0166),
         q(0),
         ],
      q(706) => [
         q(0137),
         q(0),
         ],
      q(710) => [
         q(0091),
         q(0),
         ],
      q(728) => [
         q(0138),
         q(0),
         ],
      q(748) => [
         q(0142),
         q(0),
         ],
      q(752) => [
         q(0143),
         q(0),
         ],
      q(756) => [
         q(0094),
         q(0),
         ],
      q(760) => [
         q(0146),
         q(0),
         ],
      q(764) => [
         q(0150),
         q(0),
         ],
      q(776) => [
         q(0151),
         q(0),
         ],
      q(780) => [
         q(0152),
         q(0),
         ],
      q(784) => [
         q(0158),
         q(0),
         ],
      q(788) => [
         q(0153),
         q(0),
         ],
      q(800) => [
         q(0156),
         q(0),
         ],
      q(807) => [
         q(0097),
         q(0),
         ],
      q(818) => [
         q(0054),
         q(0),
         ],
      q(826) => [
         q(0066),
         q(0),
         ],
      q(834) => [
         q(0149),
         q(0),
         ],
      q(840) => [
         q(0005),
         q(0),
         ],
      q(858) => [
         q(0162),
         q(0),
         ],
      q(860) => [
         q(0163),
         q(0),
         ],
      q(882) => [
         q(0128),
         q(0),
         ],
      q(886) => [
         q(0167),
         q(0),
         ],
      q(901) => [
         q(0147),
         q(0),
         ],
      q(931) => [
         q(0047),
         q(0),
         ],
      q(932) => [
         q(0169),
         q(0),
         ],
      q(934) => [
         q(0155),
         q(0),
         ],
      q(936) => [
         q(0063),
         q(0),
         ],
      q(937) => [
         q(0165),
         q(0),
         ],
      q(938) => [
         q(0140),
         q(0),
         ],
      q(940) => [
         q(0161),
         q(0),
         ],
      q(941) => [
         q(0131),
         q(0),
         ],
      q(943) => [
         q(0110),
         q(0),
         ],
      q(944) => [
         q(0012),
         q(0),
         ],
      q(946) => [
         q(0125),
         q(0),
         ],
      q(947) => [
         q(0144),
         q(0),
         ],
      q(948) => [
         q(0145),
         q(0),
         ],
      q(949) => [
         q(0154),
         q(0),
         ],
      q(950) => [
         q(0033),
         q(0),
         ],
      q(951) => [
         q(0007),
         q(0),
         ],
      q(952) => [
         q(0019),
         q(0),
         ],
      q(953) => [
         q(0060),
         q(0),
         ],
      q(955) => [
         q(0170),
         q(0),
         ],
      q(956) => [
         q(0171),
         q(0),
         ],
      q(957) => [
         q(0172),
         q(0),
         ],
      q(958) => [
         q(0173),
         q(0),
         ],
      q(959) => [
         q(0174),
         q(0),
         ],
      q(960) => [
         q(0075),
         q(0),
         ],
      q(961) => [
         q(0177),
         q(0),
         ],
      q(962) => [
         q(0176),
         q(0),
         ],
      q(964) => [
         q(0175),
         q(0),
         ],
      q(965) => [
         q(0104),
         q(0),
         ],
      q(967) => [
         q(0168),
         q(0),
         ],
      q(968) => [
         q(0141),
         q(0),
         ],
      q(969) => [
         q(0098),
         q(0),
         ],
      q(970) => [
         q(0041),
         q(0),
         ],
      q(971) => [
         q(0001),
         q(0),
         ],
      q(972) => [
         q(0148),
         q(0),
         ],
      q(973) => [
         q(0006),
         q(0),
         ],
      q(974) => [
         q(0017),
         q(0),
         ],
      q(975) => [
         q(0030),
         q(0),
         ],
      q(976) => [
         q(0043),
         q(0),
         ],
      q(977) => [
         q(0025),
         q(0),
         ],
      q(978) => [
         q(0002),
         q(0),
         ],
      q(979) => [
         q(0106),
         q(0),
         ],
      q(980) => [
         q(0157),
         q(0),
         ],
      q(981) => [
         q(0062),
         q(0),
         ],
      q(984) => [
         q(0024),
         q(0),
         ],
      q(985) => [
         q(0123),
         q(0),
         ],
      q(986) => [
         q(0028),
         q(0),
         ],
      q(990) => [
         q(0037),
         q(0),
         ],
      q(994) => [
         q(0135),
         q(0),
         ],
      q(997) => [
         q(0159),
         q(0),
         ],
      q(998) => [
         q(0160),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'currency'}{'id2code'} = {
   q(alpha) => {
      q(0001) => q(AFN),
      q(0002) => q(EUR),
      q(0003) => q(ALL),
      q(0004) => q(DZD),
      q(0005) => q(USD),
      q(0006) => q(AOA),
      q(0007) => q(XCD),
      q(0008) => q(ARS),
      q(0009) => q(AMD),
      q(0010) => q(AWG),
      q(0011) => q(AUD),
      q(0012) => q(AZN),
      q(0013) => q(BSD),
      q(0014) => q(BHD),
      q(0015) => q(BDT),
      q(0016) => q(BBD),
      q(0017) => q(BYR),
      q(0018) => q(BZD),
      q(0019) => q(XOF),
      q(0020) => q(BMD),
      q(0021) => q(BTN),
      q(0022) => q(INR),
      q(0023) => q(BOB),
      q(0024) => q(BOV),
      q(0025) => q(BAM),
      q(0026) => q(BWP),
      q(0027) => q(NOK),
      q(0028) => q(BRL),
      q(0029) => q(BND),
      q(0030) => q(BGN),
      q(0031) => q(BIF),
      q(0032) => q(KHR),
      q(0033) => q(XAF),
      q(0034) => q(CAD),
      q(0035) => q(CVE),
      q(0036) => q(KYD),
      q(0037) => q(CLF),
      q(0038) => q(CLP),
      q(0039) => q(CNY),
      q(0040) => q(COP),
      q(0041) => q(COU),
      q(0042) => q(KMF),
      q(0043) => q(CDF),
      q(0044) => q(NZD),
      q(0045) => q(CRC),
      q(0046) => q(HRK),
      q(0047) => q(CUC),
      q(0048) => q(CUP),
      q(0049) => q(ANG),
      q(0050) => q(CZK),
      q(0051) => q(DKK),
      q(0052) => q(DJF),
      q(0053) => q(DOP),
      q(0054) => q(EGP),
      q(0055) => q(SVC),
      q(0056) => q(ERN),
      q(0057) => q(ETB),
      q(0058) => q(FKP),
      q(0059) => q(FJD),
      q(0060) => q(XPF),
      q(0061) => q(GMD),
      q(0062) => q(GEL),
      q(0063) => q(GHS),
      q(0064) => q(GIP),
      q(0065) => q(GTQ),
      q(0066) => q(GBP),
      q(0067) => q(GNF),
      q(0068) => q(GYD),
      q(0069) => q(HTG),
      q(0070) => q(HNL),
      q(0071) => q(HKD),
      q(0072) => q(HUF),
      q(0073) => q(ISK),
      q(0074) => q(IDR),
      q(0075) => q(XDR),
      q(0076) => q(IRR),
      q(0077) => q(IQD),
      q(0078) => q(ILS),
      q(0079) => q(JMD),
      q(0080) => q(JPY),
      q(0081) => q(JOD),
      q(0082) => q(KZT),
      q(0083) => q(KES),
      q(0084) => q(KPW),
      q(0085) => q(KRW),
      q(0086) => q(KWD),
      q(0087) => q(KGS),
      q(0088) => q(LAK),
      q(0089) => q(LBP),
      q(0090) => q(LSL),
      q(0091) => q(ZAR),
      q(0092) => q(LRD),
      q(0093) => q(LYD),
      q(0094) => q(CHF),
      q(0095) => q(LTL),
      q(0096) => q(MOP),
      q(0097) => q(MKD),
      q(0098) => q(MGA),
      q(0099) => q(MWK),
      q(0100) => q(MYR),
      q(0101) => q(MVR),
      q(0102) => q(MRO),
      q(0103) => q(MUR),
      q(0104) => q(XUA),
      q(0105) => q(MXN),
      q(0106) => q(MXV),
      q(0107) => q(MDL),
      q(0108) => q(MNT),
      q(0109) => q(MAD),
      q(0110) => q(MZN),
      q(0111) => q(MMK),
      q(0112) => q(NAD),
      q(0113) => q(NPR),
      q(0114) => q(NIO),
      q(0115) => q(NGN),
      q(0116) => q(OMR),
      q(0117) => q(PKR),
      q(0118) => q(PAB),
      q(0119) => q(PGK),
      q(0120) => q(PYG),
      q(0121) => q(PEN),
      q(0122) => q(PHP),
      q(0123) => q(PLN),
      q(0124) => q(QAR),
      q(0125) => q(RON),
      q(0126) => q(RUB),
      q(0127) => q(RWF),
      q(0128) => q(WST),
      q(0129) => q(STD),
      q(0130) => q(SAR),
      q(0131) => q(RSD),
      q(0132) => q(SCR),
      q(0133) => q(SLL),
      q(0134) => q(SGD),
      q(0135) => q(XSU),
      q(0136) => q(SBD),
      q(0137) => q(SOS),
      q(0138) => q(SSP),
      q(0139) => q(LKR),
      q(0140) => q(SDG),
      q(0141) => q(SRD),
      q(0142) => q(SZL),
      q(0143) => q(SEK),
      q(0144) => q(CHE),
      q(0145) => q(CHW),
      q(0146) => q(SYP),
      q(0147) => q(TWD),
      q(0148) => q(TJS),
      q(0149) => q(TZS),
      q(0150) => q(THB),
      q(0151) => q(TOP),
      q(0152) => q(TTD),
      q(0153) => q(TND),
      q(0154) => q(TRY),
      q(0155) => q(TMT),
      q(0156) => q(UGX),
      q(0157) => q(UAH),
      q(0158) => q(AED),
      q(0159) => q(USN),
      q(0160) => q(USS),
      q(0161) => q(UYI),
      q(0162) => q(UYU),
      q(0163) => q(UZS),
      q(0164) => q(VUV),
      q(0165) => q(VEF),
      q(0166) => q(VND),
      q(0167) => q(YER),
      q(0168) => q(ZMW),
      q(0169) => q(ZWL),
      q(0170) => q(XBA),
      q(0171) => q(XBB),
      q(0172) => q(XBC),
      q(0173) => q(XBD),
      q(0174) => q(XAU),
      q(0175) => q(XPD),
      q(0176) => q(XPT),
      q(0177) => q(XAG),
      },
   q(num) => {
      q(0001) => q(971),
      q(0002) => q(978),
      q(0003) => q(008),
      q(0004) => q(012),
      q(0005) => q(840),
      q(0006) => q(973),
      q(0007) => q(951),
      q(0008) => q(032),
      q(0009) => q(051),
      q(0010) => q(533),
      q(0011) => q(036),
      q(0012) => q(944),
      q(0013) => q(044),
      q(0014) => q(048),
      q(0015) => q(050),
      q(0016) => q(052),
      q(0017) => q(974),
      q(0018) => q(084),
      q(0019) => q(952),
      q(0020) => q(060),
      q(0021) => q(064),
      q(0022) => q(356),
      q(0023) => q(068),
      q(0024) => q(984),
      q(0025) => q(977),
      q(0026) => q(072),
      q(0027) => q(578),
      q(0028) => q(986),
      q(0029) => q(096),
      q(0030) => q(975),
      q(0031) => q(108),
      q(0032) => q(116),
      q(0033) => q(950),
      q(0034) => q(124),
      q(0035) => q(132),
      q(0036) => q(136),
      q(0037) => q(990),
      q(0038) => q(152),
      q(0039) => q(156),
      q(0040) => q(170),
      q(0041) => q(970),
      q(0042) => q(174),
      q(0043) => q(976),
      q(0044) => q(554),
      q(0045) => q(188),
      q(0046) => q(191),
      q(0047) => q(931),
      q(0048) => q(192),
      q(0049) => q(532),
      q(0050) => q(203),
      q(0051) => q(208),
      q(0052) => q(262),
      q(0053) => q(214),
      q(0054) => q(818),
      q(0055) => q(222),
      q(0056) => q(232),
      q(0057) => q(230),
      q(0058) => q(238),
      q(0059) => q(242),
      q(0060) => q(953),
      q(0061) => q(270),
      q(0062) => q(981),
      q(0063) => q(936),
      q(0064) => q(292),
      q(0065) => q(320),
      q(0066) => q(826),
      q(0067) => q(324),
      q(0068) => q(328),
      q(0069) => q(332),
      q(0070) => q(340),
      q(0071) => q(344),
      q(0072) => q(348),
      q(0073) => q(352),
      q(0074) => q(360),
      q(0075) => q(960),
      q(0076) => q(364),
      q(0077) => q(368),
      q(0078) => q(376),
      q(0079) => q(388),
      q(0080) => q(392),
      q(0081) => q(400),
      q(0082) => q(398),
      q(0083) => q(404),
      q(0084) => q(408),
      q(0085) => q(410),
      q(0086) => q(414),
      q(0087) => q(417),
      q(0088) => q(418),
      q(0089) => q(422),
      q(0090) => q(426),
      q(0091) => q(710),
      q(0092) => q(430),
      q(0093) => q(434),
      q(0094) => q(756),
      q(0095) => q(440),
      q(0096) => q(446),
      q(0097) => q(807),
      q(0098) => q(969),
      q(0099) => q(454),
      q(0100) => q(458),
      q(0101) => q(462),
      q(0102) => q(478),
      q(0103) => q(480),
      q(0104) => q(965),
      q(0105) => q(484),
      q(0106) => q(979),
      q(0107) => q(498),
      q(0108) => q(496),
      q(0109) => q(504),
      q(0110) => q(943),
      q(0111) => q(104),
      q(0112) => q(516),
      q(0113) => q(524),
      q(0114) => q(558),
      q(0115) => q(566),
      q(0116) => q(512),
      q(0117) => q(586),
      q(0118) => q(590),
      q(0119) => q(598),
      q(0120) => q(600),
      q(0121) => q(604),
      q(0122) => q(608),
      q(0123) => q(985),
      q(0124) => q(634),
      q(0125) => q(946),
      q(0126) => q(643),
      q(0127) => q(646),
      q(0128) => q(882),
      q(0129) => q(678),
      q(0130) => q(682),
      q(0131) => q(941),
      q(0132) => q(690),
      q(0133) => q(694),
      q(0134) => q(702),
      q(0135) => q(994),
      q(0136) => q(090),
      q(0137) => q(706),
      q(0138) => q(728),
      q(0139) => q(144),
      q(0140) => q(938),
      q(0141) => q(968),
      q(0142) => q(748),
      q(0143) => q(752),
      q(0144) => q(947),
      q(0145) => q(948),
      q(0146) => q(760),
      q(0147) => q(901),
      q(0148) => q(972),
      q(0149) => q(834),
      q(0150) => q(764),
      q(0151) => q(776),
      q(0152) => q(780),
      q(0153) => q(788),
      q(0154) => q(949),
      q(0155) => q(934),
      q(0156) => q(800),
      q(0157) => q(980),
      q(0158) => q(784),
      q(0159) => q(997),
      q(0160) => q(998),
      q(0161) => q(940),
      q(0162) => q(858),
      q(0163) => q(860),
      q(0164) => q(548),
      q(0165) => q(937),
      q(0166) => q(704),
      q(0167) => q(886),
      q(0168) => q(967),
      q(0169) => q(932),
      q(0170) => q(955),
      q(0171) => q(956),
      q(0172) => q(957),
      q(0173) => q(958),
      q(0174) => q(959),
      q(0175) => q(964),
      q(0176) => q(962),
      q(0177) => q(961),
      },
};

1;
                                                                                                                                                                                                                                                                                                                                                                                                                    usr/share/perl/5.20.2/Locale/Codes/Currency_Retired.pm                                              0100644 0000000 0000000 00000014536 12744441327 020731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::Currency_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Mar  4 13:19:40 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'currency'}{'alpha'}{'code'} = {
   q(ADP) => q(Andorran Peseta),
   q(AFA) => q(Afghani),
   q(AON) => q(New Kwanza),
   q(AOR) => q(Kwanza Reajustado),
   q(ATS) => q(Schilling),
   q(AZM) => q(Azerbaijanian Manat),
   q(BEF) => q(Belgian Franc),
   q(BGL) => q(Lev),
   q(BYB) => q(Belarussian Ruble),
   q(CYP) => q(Cyprus Pound),
   q(DEM) => q(German Mark),
   q(ECS) => q(Sucre),
   q(ECV) => q(Unidad de Valor Constante (UVC)),
   q(EEK) => q(Kroon),
   q(ESP) => q(Spanish Peseta),
   q(FIM) => q(Markka),
   q(FRF) => q(French Franc),
   q(GHC) => q(Cedi),
   q(GRD) => q(Drachma),
   q(GWP) => q(Guinea-Bissau Peso),
   q(IEP) => q(Irish Pound),
   q(ITL) => q(Italian Lira),
   q(LUF) => q(Luxembourg Franc),
   q(LVL) => q(Latvian Lats),
   q(MGF) => q(Malagasy Franc),
   q(MTL) => q(Maltese Lira),
   q(MZM) => q(Metical),
   q(NLG) => q(Netherlands Guilder),
   q(PTE) => q(Portuguese Escudo),
   q(ROL) => q(Leu),
   q(RUR) => q(Russian Ruble),
   q(SDD) => q(Sudanese Dinar),
   q(SHP) => q(Saint Helena Pound),
   q(SIT) => q(Tolar),
   q(SKK) => q(Slovak Koruna),
   q(SRG) => q(Surinam Guilder),
   q(TJR) => q(Tajik Ruble),
   q(TMM) => q(Manat),
   q(TPE) => q(Timor Escudo),
   q(TRL) => q(Turkish Lira),
   q(UAK) => q(Karbovanets),
   q(VEB) => q(Bolivar),
   q(XB5) => q(European Unit of Account 17),
   q(XEU) => q(ECU (until 1998-12-31)),
   q(XFO) => q(Gold-Franc),
   q(XFU) => q(UIC-Franc),
   q(YUM) => q(New Dinar),
   q(ZAL) => q(Financial Rand),
   q(ZRN) => q(New Zaire),
   q(ZWD) => q(Zimbabwe Dollar),
};

$Locale::Codes::Retired{'currency'}{'num'}{'code'} = {
   q(428) => q(Latvian Lats),
   q(654) => q(Saint Helena Pound),
};

$Locale::Codes::Retired{'currency'}{'alpha'}{'name'} = {
   q(andorran peseta) => [ q(ADP), q(Andorran Peseta) ],
   q(aruban guilder) => [ q(AWG), q(Aruban Guilder) ],
   q(belgian franc) => [ q(BEF), q(Belgian Franc) ],
   q(bermudian dollar (customarily known as bermuda dollar)) => [ q(BMD), q(Bermudian Dollar (customarily known as Bermuda Dollar)) ],
   q(bolivar) => [ q(VEB), q(Bolivar) ],
   q(bolivar fuerte) => [ q(VEF), q(Bolivar Fuerte) ],
   q(bond markets units european composite unit (eurco)) => [ q(XBA), q(Bond Markets Units European Composite Unit (EURCO)) ],
   q(candian dollar) => [ q(CAD), q(Candian Dollar) ],
   q(cedi) => [ q(GHS), q(Cedi) ],
   q(convertible marks) => [ q(BAM), q(Convertible Marks) ],
   q(cyprus pound) => [ q(CYP), q(Cyprus Pound) ],
   q(dinar) => [ q(BHD), q(Dinar) ],
   q(drachma) => [ q(GRD), q(Drachma) ],
   q(ecu (until 1998-12-31)) => [ q(XEU), q(ECU (until 1998-12-31)) ],
   q(european composite unit) => [ q(XBA), q(European Composite Unit) ],
   q(european monetary unit) => [ q(XBB), q(European Monetary Unit) ],
   q(european monetary unit (e.m.u.-6)) => [ q(XBB), q(European Monetary Unit (E.M.U.-6)) ],
   q(european unit of account 17) => [ q(XB5), q(European Unit of Account 17) ],
   q(european unit of account 17(e.u.a.-17)) => [ q(XBD), q(European Unit of Account 17(E.U.A.-17)) ],
   q(european unit of account 9) => [ q(XBC), q(European Unit of Account 9) ],
   q(european unit of account 9(e.u.a.-9)) => [ q(XBC), q(European Unit of Account 9(E.U.A.-9)) ],
   q(financial rand) => [ q(ZAL), q(Financial Rand) ],
   q(franc congolais) => [ q(CDF), q(Franc Congolais) ],
   q(french franc) => [ q(FRF), q(French Franc) ],
   q(german mark) => [ q(DEM), q(German Mark) ],
   q(gold-franc) => [ q(XFO), q(Gold-Franc) ],
   q(guinea-bissau peso) => [ q(GWP), q(Guinea-Bissau Peso) ],
   q(irish pound) => [ q(IEP), q(Irish Pound) ],
   q(italian lira) => [ q(ITL), q(Italian Lira) ],
   q(karbovanets) => [ q(UAK), q(Karbovanets) ],
   q(kroon) => [ q(EEK), q(Kroon) ],
   q(kuna) => [ q(HRK), q(Kuna) ],
   q(kwanza reajustado) => [ q(AOR), q(Kwanza Reajustado) ],
   q(latvian lats) => [ q(LVL), q(Latvian Lats) ],
   q(leu) => [ q(RON), q(Leu) ],
   q(lev) => [ q(BGL), q(Lev) ],
   q(luxembourg franc) => [ q(LUF), q(Luxembourg Franc) ],
   q(malagasy franc) => [ q(MGF), q(Malagasy Franc) ],
   q(maltese lira) => [ q(MTL), q(Maltese Lira) ],
   q(manat) => [ q(TMT), q(Manat) ],
   q(markka) => [ q(FIM), q(Markka) ],
   q(metical) => [ q(MZN), q(Metical) ],
   q(mexican nuevo peso) => [ q(MXN), q(Mexican Nuevo Peso) ],
   q(netherlands antillian guilder) => [ q(ANG), q(Netherlands Antillian Guilder) ],
   q(netherlands guilder) => [ q(NLG), q(Netherlands Guilder) ],
   q(new dinar) => [ q(YUM), q(New Dinar) ],
   q(new kwanza) => [ q(AON), q(New Kwanza) ],
   q(new leu) => [ q(RON), q(New Leu) ],
   q(new manat) => [ q(TMT), q(New Manat) ],
   q(new zaire) => [ q(ZRN), q(New Zaire) ],
   q(portuguese escudo) => [ q(PTE), q(Portuguese Escudo) ],
   q(saint helena pound) => [ q(SHP), q(Saint Helena Pound) ],
   q(schilling) => [ q(ATS), q(Schilling) ],
   q(sdr) => [ q(XDR), q(SDR) ],
   q(shekel) => [ q(ILS), q(Shekel) ],
   q(slovak koruna) => [ q(SKK), q(Slovak Koruna) ],
   q(spanish peseta) => [ q(ESP), q(Spanish Peseta) ],
   q(st. helena pound) => [ q(SHP), q(St. Helena Pound) ],
   q(sudanese dinar) => [ q(SDD), q(Sudanese Dinar) ],
   q(surinam guilder) => [ q(SRG), q(Surinam Guilder) ],
   q(tajik ruble) => [ q(TJR), q(Tajik Ruble) ],
   q(timor escudo) => [ q(TPE), q(Timor Escudo) ],
   q(tolar) => [ q(SIT), q(Tolar) ],
   q(tunisian dollar) => [ q(TND), q(Tunisian Dollar) ],
   q(uic-franc) => [ q(XFU), q(UIC-Franc) ],
   q(unidad de valor constante (uvc)) => [ q(ECV), q(Unidad de Valor Constante (UVC)) ],
   q(unidades de fomento) => [ q(CLF), q(Unidades de fomento) ],
   q(unidades de formento) => [ q(CLF), q(Unidades de Formento) ],
   q(uruguay peso en unidades indexadas) => [ q(UYI), q(Uruguay Peso en Unidades Indexadas) ],
};

$Locale::Codes::Retired{'currency'}{'num'}{'name'} = {
   q(bolivar fuerte) => [ q(937), q(Bolivar Fuerte) ],
   q(cedi) => [ q(936), q(Cedi) ],
   q(latvian lats) => [ q(428), q(Latvian Lats) ],
   q(leu) => [ q(946), q(Leu) ],
   q(metical) => [ q(943), q(Metical) ],
   q(new manat) => [ q(934), q(New Manat) ],
   q(saint helena pound) => [ q(654), q(Saint Helena Pound) ],
   q(unidades de fomento) => [ q(990), q(Unidades de fomento) ],
};


1;
                                                                                                                                                                  usr/share/perl/5.20.2/Locale/Codes/LangExt.pm                                                       0100644 0000000 0000000 00000004117 12744441327 017015  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::LangExt;
# Copyright (c) 2011-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::LangExt_Codes;
use Locale::Codes::LangExt_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2langext
                langext2code
                all_langext_codes
                all_langext_names
                langext_code2code
                LOCALE_LANGEXT_ALPHA
               );

sub code2langext {
   return Locale::Codes::_code2name('langext',@_);
}

sub langext2code {
   return Locale::Codes::_name2code('langext',@_);
}

sub langext_code2code {
   return Locale::Codes::_code2code('langext',@_);
}

sub all_langext_codes {
   return Locale::Codes::_all_codes('langext',@_);
}

sub all_langext_names {
   return Locale::Codes::_all_names('langext',@_);
}

sub rename_langext {
   return Locale::Codes::_rename('langext',@_);
}

sub add_langext {
   return Locale::Codes::_add_code('langext',@_);
}

sub delete_langext {
   return Locale::Codes::_delete_code('langext',@_);
}

sub add_langext_alias {
   return Locale::Codes::_add_alias('langext',@_);
}

sub delete_langext_alias {
   return Locale::Codes::_delete_alias('langext',@_);
}

sub rename_langext_code {
   return Locale::Codes::_rename_code('langext',@_);
}

sub add_langext_code_alias {
   return Locale::Codes::_add_code_alias('langext',@_);
}

sub delete_langext_code_alias {
   return Locale::Codes::_delete_code_alias('langext',@_);
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Locale/Codes/LangExt.pod                                                      0100644 0000000 0000000 00000005400 12744441327 017157  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::LangExt - standard codes for language extension identification

=head1 SYNOPSIS

   use Locale::Codes::LangExt;

   $lext = code2langext('acm');                 # $lext gets 'Mesopotamian Arabic'
   $code = langext2code('Mesopotamian Arabic'); # $code gets 'acm'

   @codes   = all_langext_codes();
   @names   = all_langext_names();

=head1 DESCRIPTION

The C<Locale::Codes::LangExt> module provides access to standard codes
used for identifying language extensions, such as those as defined in
the IANA language registry.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default IANA
language registry codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
language extensions. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $lext = code2langext('acm','alpha');
   $lext = code2langext('acm',LOCALE_LANGEXT_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha>

This is the set of three-letter (lowercase) codes from the IANA
language registry, such as 'acm' for Mesopotamian Arabic. 

This is the default code set.

=back

=head1 ROUTINES

=over 4

=item B<code2langext ( CODE [,CODESET] )>

=item B<langext2code ( NAME [,CODESET] )>

=item B<langext_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_langext_codes ( [CODESET] )>

=item B<all_langext_names ( [CODESET] )>

=item B<Locale::Codes::LangExt::rename_langext  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::LangExt::add_langext  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::LangExt::delete_langext  ( CODE [,CODESET] )>

=item B<Locale::Codes::LangExt::add_langext_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::LangExt::delete_langext_alias  ( NAME )>

=item B<Locale::Codes::LangExt::rename_langext_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangExt::add_langext_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangExt::delete_langext_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.iana.org/assignments/language-subtag-registry>

The IANA language subtag registry.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 2011-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Locale/Codes/LangExt_Codes.pm                                                 0100644 0000000 0000000 00000141167 12744441327 020141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::LangExt_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:45:50 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'langext'}{'id'} = '0228';

$Locale::Codes::Data{'langext'}{'id2names'} = {
   q(0001) => [
      q(Algerian Saharan Arabic),
      ],
   q(0002) => [
      q(Tajiki Arabic),
      ],
   q(0003) => [
      q(Baharna Arabic),
      ],
   q(0004) => [
      q(Mesopotamian Arabic),
      ],
   q(0005) => [
      q(Ta'izzi-Adeni Arabic),
      ],
   q(0006) => [
      q(Hijazi Arabic),
      ],
   q(0007) => [
      q(Omani Arabic),
      ],
   q(0008) => [
      q(Cypriot Arabic),
      ],
   q(0009) => [
      q(Dhofari Arabic),
      ],
   q(0010) => [
      q(Adamorobe Sign Language),
      ],
   q(0011) => [
      q(Tunisian Arabic),
      ],
   q(0012) => [
      q(Saidi Arabic),
      ],
   q(0013) => [
      q(Argentine Sign Language),
      ],
   q(0014) => [
      q(Armenian Sign Language),
      ],
   q(0015) => [
      q(Gulf Arabic),
      ],
   q(0016) => [
      q(Afghan Sign Language),
      ],
   q(0017) => [
      q(South Levantine Arabic),
      ],
   q(0018) => [
      q(North Levantine Arabic),
      ],
   q(0019) => [
      q(Sudanese Arabic),
      ],
   q(0020) => [
      q(Standard Arabic),
      ],
   q(0021) => [
      q(Algerian Arabic),
      ],
   q(0022) => [
      q(Najdi Arabic),
      ],
   q(0023) => [
      q(Moroccan Arabic),
      ],
   q(0024) => [
      q(Egyptian Arabic),
      ],
   q(0025) => [
      q(American Sign Language),
      ],
   q(0026) => [
      q(Australian Sign Language),
      ],
   q(0027) => [
      q(Algerian Sign Language),
      ],
   q(0028) => [
      q(Austrian Sign Language),
      ],
   q(0029) => [
      q(Australian Aborigines Sign Language),
      ],
   q(0030) => [
      q(Uzbeki Arabic),
      ],
   q(0031) => [
      q(Eastern Egyptian Bedawi Arabic),
      ],
   q(0032) => [
      q(Hadrami Arabic),
      ],
   q(0033) => [
      q(Libyan Arabic),
      ],
   q(0034) => [
      q(Sanaani Arabic),
      ],
   q(0035) => [
      q(North Mesopotamian Arabic),
      ],
   q(0036) => [
      q(Babalia Creole Arabic),
      ],
   q(0037) => [
      q(British Sign Language),
      ],
   q(0038) => [
      q(Ban Khor Sign Language),
      ],
   q(0039) => [
      q(Banjar),
      ],
   q(0040) => [
      q(Bamako Sign Language),
      ],
   q(0041) => [
      q(Bulgarian Sign Language),
      ],
   q(0042) => [
      q(Bengkala Sign Language),
      ],
   q(0043) => [
      q(Bacanese Malay),
      ],
   q(0044) => [
      q(Berau Malay),
      ],
   q(0045) => [
      q(Bolivian Sign Language),
      ],
   q(0046) => [
      q(Bukit Malay),
      ],
   q(0047) => [
      q(Brazilian Sign Language),
      ],
   q(0048) => [
      q(Min Dong Chinese),
      ],
   q(0049) => [
      q(Chadian Sign Language),
      ],
   q(0050) => [
      q(Jinyu Chinese),
      ],
   q(0051) => [
      q(Mandarin Chinese),
      ],
   q(0052) => [
      q(Cocos Islands Malay),
      ],
   q(0053) => [
      q(Pu-Xian Chinese),
      ],
   q(0054) => [
      q(Catalan Sign Language),
      q(Lengua de senas catalana),
      q(Llengua de Signes Catalana),
      ],
   q(0055) => [
      q(Chiangmai Sign Language),
      ],
   q(0056) => [
      q(Czech Sign Language),
      ],
   q(0057) => [
      q(Cuba Sign Language),
      ],
   q(0058) => [
      q(Chilean Sign Language),
      ],
   q(0059) => [
      q(Chinese Sign Language),
      ],
   q(0060) => [
      q(Colombian Sign Language),
      ],
   q(0061) => [
      q(Croatia Sign Language),
      ],
   q(0062) => [
      q(Costa Rican Sign Language),
      ],
   q(0063) => [
      q(Huizhou Chinese),
      ],
   q(0064) => [
      q(Min Zhong Chinese),
      ],
   q(0065) => [
      q(Dominican Sign Language),
      ],
   q(0066) => [
      q(Dutch Sign Language),
      ],
   q(0067) => [
      q(Danish Sign Language),
      ],
   q(0068) => [
      q(Duano),
      ],
   q(0069) => [
      q(Ecuadorian Sign Language),
      ],
   q(0070) => [
      q(Egypt Sign Language),
      ],
   q(0071) => [
      q(Salvadoran Sign Language),
      ],
   q(0072) => [
      q(Estonian Sign Language),
      ],
   q(0073) => [
      q(Ethiopian Sign Language),
      ],
   q(0074) => [
      q(Quebec Sign Language),
      ],
   q(0075) => [
      q(Finnish Sign Language),
      ],
   q(0076) => [
      q(French Sign Language),
      ],
   q(0077) => [
      q(Finland-Swedish Sign Language),
      q(finlandssvenskt teckensprak),
      q(suomenruotsalainen viittomakieli),
      ],
   q(0078) => [
      q(Gan Chinese),
      ],
   q(0079) => [
      q(Ghandruk Sign Language),
      ],
   q(0080) => [
      q(Goan Konkani),
      ],
   q(0081) => [
      q(Ghanaian Sign Language),
      ],
   q(0082) => [
      q(German Sign Language),
      ],
   q(0083) => [
      q(Guatemalan Sign Language),
      ],
   q(0084) => [
      q(Greek Sign Language),
      ],
   q(0085) => [
      q(Guinean Sign Language),
      ],
   q(0086) => [
      q(Hanoi Sign Language),
      ],
   q(0087) => [
      q(Haiphong Sign Language),
      ],
   q(0088) => [
      q(Hakka Chinese),
      ],
   q(0089) => [
      q(Honduras Sign Language),
      ],
   q(0090) => [
      q(Haji),
      ],
   q(0091) => [
      q(Hong Kong Sign Language),
      q(Heung Kong Sau Yue),
      ],
   q(0092) => [
      q(Ho Chi Minh City Sign Language),
      ],
   q(0093) => [
      q(Hawai'i Pidgin Sign Language),
      ],
   q(0094) => [
      q(Hungarian Sign Language),
      ],
   q(0095) => [
      q(Hausa Sign Language),
      ],
   q(0096) => [
      q(Xiang Chinese),
      ],
   q(0097) => [
      q(Icelandic Sign Language),
      ],
   q(0098) => [
      q(International Sign),
      ],
   q(0099) => [
      q(Indonesian Sign Language),
      ],
   q(0100) => [
      q(Indian Sign Language),
      ],
   q(0101) => [
      q(Italian Sign Language),
      ],
   q(0102) => [
      q(Irish Sign Language),
      ],
   q(0103) => [
      q(Israeli Sign Language),
      ],
   q(0104) => [
      q(Jakun),
      ],
   q(0105) => [
      q(Jambi Malay),
      ],
   q(0106) => [
      q(Jamaican Country Sign Language),
      ],
   q(0107) => [
      q(Jhankot Sign Language),
      ],
   q(0108) => [
      q(Jamaican Sign Language),
      ],
   q(0109) => [
      q(Jordanian Sign Language),
      ],
   q(0110) => [
      q(Japanese Sign Language),
      ],
   q(0111) => [
      q(Jumla Sign Language),
      ],
   q(0112) => [
      q(Selangor Sign Language),
      ],
   q(0113) => [
      q(Konkani (individual language)),
      ],
   q(0114) => [
      q(Kubu),
      ],
   q(0115) => [
      q(Korean Sign Language),
      ],
   q(0116) => [
      q(Kerinci),
      ],
   q(0117) => [
      q(Brunei),
      ],
   q(0118) => [
      q(Libyan Sign Language),
      ],
   q(0119) => [
      q(Loncong),
      ],
   q(0120) => [
      q(Lubu),
      ],
   q(0121) => [
      q(Col),
      ],
   q(0122) => [
      q(Lithuanian Sign Language),
      ],
   q(0123) => [
      q(Lyons Sign Language),
      ],
   q(0124) => [
      q(Latvian Sign Language),
      ],
   q(0125) => [
      q(Laos Sign Language),
      ],
   q(0126) => [
      q(Panamanian Sign Language),
      q(Lengua de Senas Panamenas),
      ],
   q(0127) => [
      q(Trinidad and Tobago Sign Language),
      ],
   q(0128) => [
      q(Mauritian Sign Language),
      ],
   q(0129) => [
      q(Latgalian),
      ],
   q(0130) => [
      q(Standard Latvian),
      ],
   q(0131) => [
      q(Literary Chinese),
      ],
   q(0132) => [
      q(North Moluccan Malay),
      ],
   q(0133) => [
      q(Maltese Sign Language),
      ],
   q(0134) => [
      q(Kedah Malay),
      ],
   q(0135) => [
      q(Pattani Malay),
      ],
   q(0136) => [
      q(Bangka),
      ],
   q(0137) => [
      q(Mexican Sign Language),
      ],
   q(0138) => [
      q(Minangkabau),
      ],
   q(0139) => [
      q(Min Bei Chinese),
      ],
   q(0140) => [
      q(Kota Bangun Kutai Malay),
      ],
   q(0141) => [
      q(Martha's Vineyard Sign Language),
      ],
   q(0142) => [
      q(Yucatec Maya Sign Language),
      ],
   q(0143) => [
      q(Sabah Malay),
      ],
   q(0144) => [
      q(Mongolian Sign Language),
      ],
   q(0145) => [
      q(Musi),
      ],
   q(0146) => [
      q(Madagascar Sign Language),
      ],
   q(0147) => [
      q(Monastic Sign Language),
      ],
   q(0148) => [
      q(Mozambican Sign Language),
      ],
   q(0149) => [
      q(Min Nan Chinese),
      ],
   q(0150) => [
      q(Namibian Sign Language),
      ],
   q(0151) => [
      q(Nicaraguan Sign Language),
      ],
   q(0152) => [
      q(Nigerian Sign Language),
      ],
   q(0153) => [
      q(Norwegian Sign Language),
      ],
   q(0154) => [
      q(Nepalese Sign Language),
      ],
   q(0155) => [
      q(Maritime Sign Language),
      ],
   q(0156) => [
      q(New Zealand Sign Language),
      ],
   q(0157) => [
      q(Old Kentish Sign Language),
      ],
   q(0158) => [
      q(Orang Kanaq),
      ],
   q(0159) => [
      q(Orang Seletar),
      ],
   q(0160) => [
      q(Pekal),
      ],
   q(0161) => [
      q(Sudanese Creole Arabic),
      ],
   q(0162) => [
      q(Pakistan Sign Language),
      ],
   q(0163) => [
      q(Peruvian Sign Language),
      ],
   q(0164) => [
      q(Providencia Sign Language),
      ],
   q(0165) => [
      q(Persian Sign Language),
      ],
   q(0166) => [
      q(Plains Indian Sign Language),
      ],
   q(0167) => [
      q(Central Malay),
      ],
   q(0168) => [
      q(Penang Sign Language),
      ],
   q(0169) => [
      q(Puerto Rican Sign Language),
      ],
   q(0170) => [
      q(Polish Sign Language),
      ],
   q(0171) => [
      q(Philippine Sign Language),
      ],
   q(0172) => [
      q(Portuguese Sign Language),
      ],
   q(0173) => [
      q(Paraguayan Sign Language),
      q(Lengua de Senas del Paraguay),
      ],
   q(0174) => [
      q(Romanian Sign Language),
      ],
   q(0175) => [
      q(Rennellese Sign Language),
      ],
   q(0176) => [
      q(Russian Sign Language),
      ],
   q(0177) => [
      q(Saudi Arabian Sign Language),
      ],
   q(0178) => [
      q(Langue des signes de Belgique Francophone),
      q(French Belgian Sign Language),
      ],
   q(0179) => [
      q(South African Sign Language),
      ],
   q(0180) => [
      q(Swiss-German Sign Language),
      ],
   q(0181) => [
      q(Sierra Leone Sign Language),
      ],
   q(0182) => [
      q(Chadian Arabic),
      ],
   q(0183) => [
      q(Swiss-Italian Sign Language),
      ],
   q(0184) => [
      q(Singapore Sign Language),
      ],
   q(0185) => [
      q(Albanian Sign Language),
      ],
   q(0186) => [
      q(Sri Lankan Sign Language),
      ],
   q(0187) => [
      q(Shihhi Arabic),
      ],
   q(0188) => [
      q(Spanish Sign Language),
      ],
   q(0189) => [
      q(Swiss-French Sign Language),
      ],
   q(0190) => [
      q(Slovakian Sign Language),
      ],
   q(0191) => [
      q(Congo Swahili),
      ],
   q(0192) => [
      q(Swahili (individual language)),
      q(Kiswahili),
      ],
   q(0193) => [
      q(Swedish Sign Language),
      ],
   q(0194) => [
      q(Al-Sayyid Bedouin Sign Language),
      ],
   q(0195) => [
      q(Temuan),
      ],
   q(0196) => [
      q(Tunisian Sign Language),
      ],
   q(0197) => [
      q(Turkish Sign Language),
      q(Turk Isaret Dili),
      ],
   q(0198) => [
      q(Thai Sign Language),
      ],
   q(0199) => [
      q(Taiwan Sign Language),
      ],
   q(0200) => [
      q(Tebul Sign Language),
      ],
   q(0201) => [
      q(Tanzanian Sign Language),
      ],
   q(0202) => [
      q(Ugandan Sign Language),
      ],
   q(0203) => [
      q(Uruguayan Sign Language),
      ],
   q(0204) => [
      q(Ukrainian Sign Language),
      ],
   q(0205) => [
      q(Urubu-Kaapor Sign Language),
      q(Kaapor Sign Language),
      ],
   q(0206) => [
      q(Urak Lawoi'),
      ],
   q(0207) => [
      q(Northern Uzbek),
      ],
   q(0208) => [
      q(Southern Uzbek),
      ],
   q(0209) => [
      q(Vlaamse Gebarentaal),
      q(Flemish Sign Language),
      ],
   q(0210) => [
      q(Kaur),
      ],
   q(0211) => [
      q(Tenggarong Kutai Malay),
      ],
   q(0212) => [
      q(Moldova Sign Language),
      ],
   q(0213) => [
      q(Venezuelan Sign Language),
      ],
   q(0214) => [
      q(Valencian Sign Language),
      q(Llengua de signes valenciana),
      ],
   q(0215) => [
      q(Wu Chinese),
      ],
   q(0216) => [
      q(Kenyan Sign Language),
      ],
   q(0217) => [
      q(Malaysian Sign Language),
      ],
   q(0218) => [
      q(Manado Malay),
      ],
   q(0219) => [
      q(Moroccan Sign Language),
      ],
   q(0220) => [
      q(Yiddish Sign Language),
      ],
   q(0221) => [
      q(Yugoslavian Sign Language),
      ],
   q(0222) => [
      q(Yue Chinese),
      ],
   q(0223) => [
      q(Zimbabwe Sign Language),
      ],
   q(0224) => [
      q(Malay (individual language)),
      ],
   q(0225) => [
      q(Negeri Sembilan Malay),
      ],
   q(0226) => [
      q(Zambian Sign Language),
      ],
   q(0227) => [
      q(Standard Malay),
      ],
};

$Locale::Codes::Data{'langext'}{'alias2id'} = {
   q(adamorobe sign language) => [
      q(0010),
      q(0),
      ],
   q(afghan sign language) => [
      q(0016),
      q(0),
      ],
   q(al-sayyid bedouin sign language) => [
      q(0194),
      q(0),
      ],
   q(albanian sign language) => [
      q(0185),
      q(0),
      ],
   q(algerian arabic) => [
      q(0021),
      q(0),
      ],
   q(algerian saharan arabic) => [
      q(0001),
      q(0),
      ],
   q(algerian sign language) => [
      q(0027),
      q(0),
      ],
   q(american sign language) => [
      q(0025),
      q(0),
      ],
   q(argentine sign language) => [
      q(0013),
      q(0),
      ],
   q(armenian sign language) => [
      q(0014),
      q(0),
      ],
   q(australian aborigines sign language) => [
      q(0029),
      q(0),
      ],
   q(australian sign language) => [
      q(0026),
      q(0),
      ],
   q(austrian sign language) => [
      q(0028),
      q(0),
      ],
   q(babalia creole arabic) => [
      q(0036),
      q(0),
      ],
   q(bacanese malay) => [
      q(0043),
      q(0),
      ],
   q(baharna arabic) => [
      q(0003),
      q(0),
      ],
   q(bamako sign language) => [
      q(0040),
      q(0),
      ],
   q(ban khor sign language) => [
      q(0038),
      q(0),
      ],
   q(bangka) => [
      q(0136),
      q(0),
      ],
   q(banjar) => [
      q(0039),
      q(0),
      ],
   q(bengkala sign language) => [
      q(0042),
      q(0),
      ],
   q(berau malay) => [
      q(0044),
      q(0),
      ],
   q(bolivian sign language) => [
      q(0045),
      q(0),
      ],
   q(brazilian sign language) => [
      q(0047),
      q(0),
      ],
   q(british sign language) => [
      q(0037),
      q(0),
      ],
   q(brunei) => [
      q(0117),
      q(0),
      ],
   q(bukit malay) => [
      q(0046),
      q(0),
      ],
   q(bulgarian sign language) => [
      q(0041),
      q(0),
      ],
   q(catalan sign language) => [
      q(0054),
      q(0),
      ],
   q(central malay) => [
      q(0167),
      q(0),
      ],
   q(chadian arabic) => [
      q(0182),
      q(0),
      ],
   q(chadian sign language) => [
      q(0049),
      q(0),
      ],
   q(chiangmai sign language) => [
      q(0055),
      q(0),
      ],
   q(chilean sign language) => [
      q(0058),
      q(0),
      ],
   q(chinese sign language) => [
      q(0059),
      q(0),
      ],
   q(cocos islands malay) => [
      q(0052),
      q(0),
      ],
   q(col) => [
      q(0121),
      q(0),
      ],
   q(colombian sign language) => [
      q(0060),
      q(0),
      ],
   q(congo swahili) => [
      q(0191),
      q(0),
      ],
   q(costa rican sign language) => [
      q(0062),
      q(0),
      ],
   q(croatia sign language) => [
      q(0061),
      q(0),
      ],
   q(cuba sign language) => [
      q(0057),
      q(0),
      ],
   q(cypriot arabic) => [
      q(0008),
      q(0),
      ],
   q(czech sign language) => [
      q(0056),
      q(0),
      ],
   q(danish sign language) => [
      q(0067),
      q(0),
      ],
   q(dhofari arabic) => [
      q(0009),
      q(0),
      ],
   q(dominican sign language) => [
      q(0065),
      q(0),
      ],
   q(duano) => [
      q(0068),
      q(0),
      ],
   q(dutch sign language) => [
      q(0066),
      q(0),
      ],
   q(eastern egyptian bedawi arabic) => [
      q(0031),
      q(0),
      ],
   q(ecuadorian sign language) => [
      q(0069),
      q(0),
      ],
   q(egypt sign language) => [
      q(0070),
      q(0),
      ],
   q(egyptian arabic) => [
      q(0024),
      q(0),
      ],
   q(estonian sign language) => [
      q(0072),
      q(0),
      ],
   q(ethiopian sign language) => [
      q(0073),
      q(0),
      ],
   q(finland-swedish sign language) => [
      q(0077),
      q(0),
      ],
   q(finlandssvenskt teckensprak) => [
      q(0077),
      q(1),
      ],
   q(finnish sign language) => [
      q(0075),
      q(0),
      ],
   q(flemish sign language) => [
      q(0209),
      q(1),
      ],
   q(french belgian sign language) => [
      q(0178),
      q(1),
      ],
   q(french sign language) => [
      q(0076),
      q(0),
      ],
   q(gan chinese) => [
      q(0078),
      q(0),
      ],
   q(german sign language) => [
      q(0082),
      q(0),
      ],
   q(ghanaian sign language) => [
      q(0081),
      q(0),
      ],
   q(ghandruk sign language) => [
      q(0079),
      q(0),
      ],
   q(goan konkani) => [
      q(0080),
      q(0),
      ],
   q(greek sign language) => [
      q(0084),
      q(0),
      ],
   q(guatemalan sign language) => [
      q(0083),
      q(0),
      ],
   q(guinean sign language) => [
      q(0085),
      q(0),
      ],
   q(gulf arabic) => [
      q(0015),
      q(0),
      ],
   q(hadrami arabic) => [
      q(0032),
      q(0),
      ],
   q(haiphong sign language) => [
      q(0087),
      q(0),
      ],
   q(haji) => [
      q(0090),
      q(0),
      ],
   q(hakka chinese) => [
      q(0088),
      q(0),
      ],
   q(hanoi sign language) => [
      q(0086),
      q(0),
      ],
   q(hausa sign language) => [
      q(0095),
      q(0),
      ],
   q(hawai'i pidgin sign language) => [
      q(0093),
      q(0),
      ],
   q(heung kong sau yue) => [
      q(0091),
      q(1),
      ],
   q(hijazi arabic) => [
      q(0006),
      q(0),
      ],
   q(ho chi minh city sign language) => [
      q(0092),
      q(0),
      ],
   q(honduras sign language) => [
      q(0089),
      q(0),
      ],
   q(hong kong sign language) => [
      q(0091),
      q(0),
      ],
   q(huizhou chinese) => [
      q(0063),
      q(0),
      ],
   q(hungarian sign language) => [
      q(0094),
      q(0),
      ],
   q(icelandic sign language) => [
      q(0097),
      q(0),
      ],
   q(indian sign language) => [
      q(0100),
      q(0),
      ],
   q(indonesian sign language) => [
      q(0099),
      q(0),
      ],
   q(international sign) => [
      q(0098),
      q(0),
      ],
   q(irish sign language) => [
      q(0102),
      q(0),
      ],
   q(israeli sign language) => [
      q(0103),
      q(0),
      ],
   q(italian sign language) => [
      q(0101),
      q(0),
      ],
   q(jakun) => [
      q(0104),
      q(0),
      ],
   q(jamaican country sign language) => [
      q(0106),
      q(0),
      ],
   q(jamaican sign language) => [
      q(0108),
      q(0),
      ],
   q(jambi malay) => [
      q(0105),
      q(0),
      ],
   q(japanese sign language) => [
      q(0110),
      q(0),
      ],
   q(jhankot sign language) => [
      q(0107),
      q(0),
      ],
   q(jinyu chinese) => [
      q(0050),
      q(0),
      ],
   q(jordanian sign language) => [
      q(0109),
      q(0),
      ],
   q(jumla sign language) => [
      q(0111),
      q(0),
      ],
   q(kaapor sign language) => [
      q(0205),
      q(1),
      ],
   q(kaur) => [
      q(0210),
      q(0),
      ],
   q(kedah malay) => [
      q(0134),
      q(0),
      ],
   q(kenyan sign language) => [
      q(0216),
      q(0),
      ],
   q(kerinci) => [
      q(0116),
      q(0),
      ],
   q(kiswahili) => [
      q(0192),
      q(1),
      ],
   q(konkani (individual language)) => [
      q(0113),
      q(0),
      ],
   q(korean sign language) => [
      q(0115),
      q(0),
      ],
   q(kota bangun kutai malay) => [
      q(0140),
      q(0),
      ],
   q(kubu) => [
      q(0114),
      q(0),
      ],
   q(langue des signes de belgique francophone) => [
      q(0178),
      q(0),
      ],
   q(laos sign language) => [
      q(0125),
      q(0),
      ],
   q(latgalian) => [
      q(0129),
      q(0),
      ],
   q(latvian sign language) => [
      q(0124),
      q(0),
      ],
   q(lengua de senas catalana) => [
      q(0054),
      q(1),
      ],
   q(lengua de senas del paraguay) => [
      q(0173),
      q(1),
      ],
   q(lengua de senas panamenas) => [
      q(0126),
      q(1),
      ],
   q(libyan arabic) => [
      q(0033),
      q(0),
      ],
   q(libyan sign language) => [
      q(0118),
      q(0),
      ],
   q(literary chinese) => [
      q(0131),
      q(0),
      ],
   q(lithuanian sign language) => [
      q(0122),
      q(0),
      ],
   q(llengua de signes catalana) => [
      q(0054),
      q(2),
      ],
   q(llengua de signes valenciana) => [
      q(0214),
      q(1),
      ],
   q(loncong) => [
      q(0119),
      q(0),
      ],
   q(lubu) => [
      q(0120),
      q(0),
      ],
   q(lyons sign language) => [
      q(0123),
      q(0),
      ],
   q(madagascar sign language) => [
      q(0146),
      q(0),
      ],
   q(malay (individual language)) => [
      q(0224),
      q(0),
      ],
   q(malaysian sign language) => [
      q(0217),
      q(0),
      ],
   q(maltese sign language) => [
      q(0133),
      q(0),
      ],
   q(manado malay) => [
      q(0218),
      q(0),
      ],
   q(mandarin chinese) => [
      q(0051),
      q(0),
      ],
   q(maritime sign language) => [
      q(0155),
      q(0),
      ],
   q(martha's vineyard sign language) => [
      q(0141),
      q(0),
      ],
   q(mauritian sign language) => [
      q(0128),
      q(0),
      ],
   q(mesopotamian arabic) => [
      q(0004),
      q(0),
      ],
   q(mexican sign language) => [
      q(0137),
      q(0),
      ],
   q(min bei chinese) => [
      q(0139),
      q(0),
      ],
   q(min dong chinese) => [
      q(0048),
      q(0),
      ],
   q(min nan chinese) => [
      q(0149),
      q(0),
      ],
   q(min zhong chinese) => [
      q(0064),
      q(0),
      ],
   q(minangkabau) => [
      q(0138),
      q(0),
      ],
   q(moldova sign language) => [
      q(0212),
      q(0),
      ],
   q(monastic sign language) => [
      q(0147),
      q(0),
      ],
   q(mongolian sign language) => [
      q(0144),
      q(0),
      ],
   q(moroccan arabic) => [
      q(0023),
      q(0),
      ],
   q(moroccan sign language) => [
      q(0219),
      q(0),
      ],
   q(mozambican sign language) => [
      q(0148),
      q(0),
      ],
   q(musi) => [
      q(0145),
      q(0),
      ],
   q(najdi arabic) => [
      q(0022),
      q(0),
      ],
   q(namibian sign language) => [
      q(0150),
      q(0),
      ],
   q(negeri sembilan malay) => [
      q(0225),
      q(0),
      ],
   q(nepalese sign language) => [
      q(0154),
      q(0),
      ],
   q(new zealand sign language) => [
      q(0156),
      q(0),
      ],
   q(nicaraguan sign language) => [
      q(0151),
      q(0),
      ],
   q(nigerian sign language) => [
      q(0152),
      q(0),
      ],
   q(north levantine arabic) => [
      q(0018),
      q(0),
      ],
   q(north mesopotamian arabic) => [
      q(0035),
      q(0),
      ],
   q(north moluccan malay) => [
      q(0132),
      q(0),
      ],
   q(northern uzbek) => [
      q(0207),
      q(0),
      ],
   q(norwegian sign language) => [
      q(0153),
      q(0),
      ],
   q(old kentish sign language) => [
      q(0157),
      q(0),
      ],
   q(omani arabic) => [
      q(0007),
      q(0),
      ],
   q(orang kanaq) => [
      q(0158),
      q(0),
      ],
   q(orang seletar) => [
      q(0159),
      q(0),
      ],
   q(pakistan sign language) => [
      q(0162),
      q(0),
      ],
   q(panamanian sign language) => [
      q(0126),
      q(0),
      ],
   q(paraguayan sign language) => [
      q(0173),
      q(0),
      ],
   q(pattani malay) => [
      q(0135),
      q(0),
      ],
   q(pekal) => [
      q(0160),
      q(0),
      ],
   q(penang sign language) => [
      q(0168),
      q(0),
      ],
   q(persian sign language) => [
      q(0165),
      q(0),
      ],
   q(peruvian sign language) => [
      q(0163),
      q(0),
      ],
   q(philippine sign language) => [
      q(0171),
      q(0),
      ],
   q(plains indian sign language) => [
      q(0166),
      q(0),
      ],
   q(polish sign language) => [
      q(0170),
      q(0),
      ],
   q(portuguese sign language) => [
      q(0172),
      q(0),
      ],
   q(providencia sign language) => [
      q(0164),
      q(0),
      ],
   q(pu-xian chinese) => [
      q(0053),
      q(0),
      ],
   q(puerto rican sign language) => [
      q(0169),
      q(0),
      ],
   q(quebec sign language) => [
      q(0074),
      q(0),
      ],
   q(rennellese sign language) => [
      q(0175),
      q(0),
      ],
   q(romanian sign language) => [
      q(0174),
      q(0),
      ],
   q(russian sign language) => [
      q(0176),
      q(0),
      ],
   q(sabah malay) => [
      q(0143),
      q(0),
      ],
   q(saidi arabic) => [
      q(0012),
      q(0),
      ],
   q(salvadoran sign language) => [
      q(0071),
      q(0),
      ],
   q(sanaani arabic) => [
      q(0034),
      q(0),
      ],
   q(saudi arabian sign language) => [
      q(0177),
      q(0),
      ],
   q(selangor sign language) => [
      q(0112),
      q(0),
      ],
   q(shihhi arabic) => [
      q(0187),
      q(0),
      ],
   q(sierra leone sign language) => [
      q(0181),
      q(0),
      ],
   q(singapore sign language) => [
      q(0184),
      q(0),
      ],
   q(slovakian sign language) => [
      q(0190),
      q(0),
      ],
   q(south african sign language) => [
      q(0179),
      q(0),
      ],
   q(south levantine arabic) => [
      q(0017),
      q(0),
      ],
   q(southern uzbek) => [
      q(0208),
      q(0),
      ],
   q(spanish sign language) => [
      q(0188),
      q(0),
      ],
   q(sri lankan sign language) => [
      q(0186),
      q(0),
      ],
   q(standard arabic) => [
      q(0020),
      q(0),
      ],
   q(standard latvian) => [
      q(0130),
      q(0),
      ],
   q(standard malay) => [
      q(0227),
      q(0),
      ],
   q(sudanese arabic) => [
      q(0019),
      q(0),
      ],
   q(sudanese creole arabic) => [
      q(0161),
      q(0),
      ],
   q(suomenruotsalainen viittomakieli) => [
      q(0077),
      q(2),
      ],
   q(swahili (individual language)) => [
      q(0192),
      q(0),
      ],
   q(swedish sign language) => [
      q(0193),
      q(0),
      ],
   q(swiss-french sign language) => [
      q(0189),
      q(0),
      ],
   q(swiss-german sign language) => [
      q(0180),
      q(0),
      ],
   q(swiss-italian sign language) => [
      q(0183),
      q(0),
      ],
   q(ta'izzi-adeni arabic) => [
      q(0005),
      q(0),
      ],
   q(taiwan sign language) => [
      q(0199),
      q(0),
      ],
   q(tajiki arabic) => [
      q(0002),
      q(0),
      ],
   q(tanzanian sign language) => [
      q(0201),
      q(0),
      ],
   q(tebul sign language) => [
      q(0200),
      q(0),
      ],
   q(temuan) => [
      q(0195),
      q(0),
      ],
   q(tenggarong kutai malay) => [
      q(0211),
      q(0),
      ],
   q(thai sign language) => [
      q(0198),
      q(0),
      ],
   q(trinidad and tobago sign language) => [
      q(0127),
      q(0),
      ],
   q(tunisian arabic) => [
      q(0011),
      q(0),
      ],
   q(tunisian sign language) => [
      q(0196),
      q(0),
      ],
   q(turk isaret dili) => [
      q(0197),
      q(1),
      ],
   q(turkish sign language) => [
      q(0197),
      q(0),
      ],
   q(ugandan sign language) => [
      q(0202),
      q(0),
      ],
   q(ukrainian sign language) => [
      q(0204),
      q(0),
      ],
   q(urak lawoi') => [
      q(0206),
      q(0),
      ],
   q(urubu-kaapor sign language) => [
      q(0205),
      q(0),
      ],
   q(uruguayan sign language) => [
      q(0203),
      q(0),
      ],
   q(uzbeki arabic) => [
      q(0030),
      q(0),
      ],
   q(valencian sign language) => [
      q(0214),
      q(0),
      ],
   q(venezuelan sign language) => [
      q(0213),
      q(0),
      ],
   q(vlaamse gebarentaal) => [
      q(0209),
      q(0),
      ],
   q(wu chinese) => [
      q(0215),
      q(0),
      ],
   q(xiang chinese) => [
      q(0096),
      q(0),
      ],
   q(yiddish sign language) => [
      q(0220),
      q(0),
      ],
   q(yucatec maya sign language) => [
      q(0142),
      q(0),
      ],
   q(yue chinese) => [
      q(0222),
      q(0),
      ],
   q(yugoslavian sign language) => [
      q(0221),
      q(0),
      ],
   q(zambian sign language) => [
      q(0226),
      q(0),
      ],
   q(zimbabwe sign language) => [
      q(0223),
      q(0),
      ],
};

$Locale::Codes::Data{'langext'}{'code2id'} = {
   q(alpha) => {
      q(aao) => [
         q(0001),
         q(0),
         ],
      q(abh) => [
         q(0002),
         q(0),
         ],
      q(abv) => [
         q(0003),
         q(0),
         ],
      q(acm) => [
         q(0004),
         q(0),
         ],
      q(acq) => [
         q(0005),
         q(0),
         ],
      q(acw) => [
         q(0006),
         q(0),
         ],
      q(acx) => [
         q(0007),
         q(0),
         ],
      q(acy) => [
         q(0008),
         q(0),
         ],
      q(adf) => [
         q(0009),
         q(0),
         ],
      q(ads) => [
         q(0010),
         q(0),
         ],
      q(aeb) => [
         q(0011),
         q(0),
         ],
      q(aec) => [
         q(0012),
         q(0),
         ],
      q(aed) => [
         q(0013),
         q(0),
         ],
      q(aen) => [
         q(0014),
         q(0),
         ],
      q(afb) => [
         q(0015),
         q(0),
         ],
      q(afg) => [
         q(0016),
         q(0),
         ],
      q(ajp) => [
         q(0017),
         q(0),
         ],
      q(apc) => [
         q(0018),
         q(0),
         ],
      q(apd) => [
         q(0019),
         q(0),
         ],
      q(arb) => [
         q(0020),
         q(0),
         ],
      q(arq) => [
         q(0021),
         q(0),
         ],
      q(ars) => [
         q(0022),
         q(0),
         ],
      q(ary) => [
         q(0023),
         q(0),
         ],
      q(arz) => [
         q(0024),
         q(0),
         ],
      q(ase) => [
         q(0025),
         q(0),
         ],
      q(asf) => [
         q(0026),
         q(0),
         ],
      q(asp) => [
         q(0027),
         q(0),
         ],
      q(asq) => [
         q(0028),
         q(0),
         ],
      q(asw) => [
         q(0029),
         q(0),
         ],
      q(auz) => [
         q(0030),
         q(0),
         ],
      q(avl) => [
         q(0031),
         q(0),
         ],
      q(ayh) => [
         q(0032),
         q(0),
         ],
      q(ayl) => [
         q(0033),
         q(0),
         ],
      q(ayn) => [
         q(0034),
         q(0),
         ],
      q(ayp) => [
         q(0035),
         q(0),
         ],
      q(bbz) => [
         q(0036),
         q(0),
         ],
      q(bfi) => [
         q(0037),
         q(0),
         ],
      q(bfk) => [
         q(0038),
         q(0),
         ],
      q(bjn) => [
         q(0039),
         q(0),
         ],
      q(bog) => [
         q(0040),
         q(0),
         ],
      q(bqn) => [
         q(0041),
         q(0),
         ],
      q(bqy) => [
         q(0042),
         q(0),
         ],
      q(btj) => [
         q(0043),
         q(0),
         ],
      q(bve) => [
         q(0044),
         q(0),
         ],
      q(bvl) => [
         q(0045),
         q(0),
         ],
      q(bvu) => [
         q(0046),
         q(0),
         ],
      q(bzs) => [
         q(0047),
         q(0),
         ],
      q(cdo) => [
         q(0048),
         q(0),
         ],
      q(cds) => [
         q(0049),
         q(0),
         ],
      q(cjy) => [
         q(0050),
         q(0),
         ],
      q(cmn) => [
         q(0051),
         q(0),
         ],
      q(coa) => [
         q(0052),
         q(0),
         ],
      q(cpx) => [
         q(0053),
         q(0),
         ],
      q(csc) => [
         q(0054),
         q(0),
         ],
      q(csd) => [
         q(0055),
         q(0),
         ],
      q(cse) => [
         q(0056),
         q(0),
         ],
      q(csf) => [
         q(0057),
         q(0),
         ],
      q(csg) => [
         q(0058),
         q(0),
         ],
      q(csl) => [
         q(0059),
         q(0),
         ],
      q(csn) => [
         q(0060),
         q(0),
         ],
      q(csq) => [
         q(0061),
         q(0),
         ],
      q(csr) => [
         q(0062),
         q(0),
         ],
      q(czh) => [
         q(0063),
         q(0),
         ],
      q(czo) => [
         q(0064),
         q(0),
         ],
      q(doq) => [
         q(0065),
         q(0),
         ],
      q(dse) => [
         q(0066),
         q(0),
         ],
      q(dsl) => [
         q(0067),
         q(0),
         ],
      q(dup) => [
         q(0068),
         q(0),
         ],
      q(ecs) => [
         q(0069),
         q(0),
         ],
      q(esl) => [
         q(0070),
         q(0),
         ],
      q(esn) => [
         q(0071),
         q(0),
         ],
      q(eso) => [
         q(0072),
         q(0),
         ],
      q(eth) => [
         q(0073),
         q(0),
         ],
      q(fcs) => [
         q(0074),
         q(0),
         ],
      q(fse) => [
         q(0075),
         q(0),
         ],
      q(fsl) => [
         q(0076),
         q(0),
         ],
      q(fss) => [
         q(0077),
         q(0),
         ],
      q(gan) => [
         q(0078),
         q(0),
         ],
      q(gds) => [
         q(0079),
         q(0),
         ],
      q(gom) => [
         q(0080),
         q(0),
         ],
      q(gse) => [
         q(0081),
         q(0),
         ],
      q(gsg) => [
         q(0082),
         q(0),
         ],
      q(gsm) => [
         q(0083),
         q(0),
         ],
      q(gss) => [
         q(0084),
         q(0),
         ],
      q(gus) => [
         q(0085),
         q(0),
         ],
      q(hab) => [
         q(0086),
         q(0),
         ],
      q(haf) => [
         q(0087),
         q(0),
         ],
      q(hak) => [
         q(0088),
         q(0),
         ],
      q(hds) => [
         q(0089),
         q(0),
         ],
      q(hji) => [
         q(0090),
         q(0),
         ],
      q(hks) => [
         q(0091),
         q(0),
         ],
      q(hos) => [
         q(0092),
         q(0),
         ],
      q(hps) => [
         q(0093),
         q(0),
         ],
      q(hsh) => [
         q(0094),
         q(0),
         ],
      q(hsl) => [
         q(0095),
         q(0),
         ],
      q(hsn) => [
         q(0096),
         q(0),
         ],
      q(icl) => [
         q(0097),
         q(0),
         ],
      q(ils) => [
         q(0098),
         q(0),
         ],
      q(inl) => [
         q(0099),
         q(0),
         ],
      q(ins) => [
         q(0100),
         q(0),
         ],
      q(ise) => [
         q(0101),
         q(0),
         ],
      q(isg) => [
         q(0102),
         q(0),
         ],
      q(isr) => [
         q(0103),
         q(0),
         ],
      q(jak) => [
         q(0104),
         q(0),
         ],
      q(jax) => [
         q(0105),
         q(0),
         ],
      q(jcs) => [
         q(0106),
         q(0),
         ],
      q(jhs) => [
         q(0107),
         q(0),
         ],
      q(jls) => [
         q(0108),
         q(0),
         ],
      q(jos) => [
         q(0109),
         q(0),
         ],
      q(jsl) => [
         q(0110),
         q(0),
         ],
      q(jus) => [
         q(0111),
         q(0),
         ],
      q(kgi) => [
         q(0112),
         q(0),
         ],
      q(knn) => [
         q(0113),
         q(0),
         ],
      q(kvb) => [
         q(0114),
         q(0),
         ],
      q(kvk) => [
         q(0115),
         q(0),
         ],
      q(kvr) => [
         q(0116),
         q(0),
         ],
      q(kxd) => [
         q(0117),
         q(0),
         ],
      q(lbs) => [
         q(0118),
         q(0),
         ],
      q(lce) => [
         q(0119),
         q(0),
         ],
      q(lcf) => [
         q(0120),
         q(0),
         ],
      q(liw) => [
         q(0121),
         q(0),
         ],
      q(lls) => [
         q(0122),
         q(0),
         ],
      q(lsg) => [
         q(0123),
         q(0),
         ],
      q(lsl) => [
         q(0124),
         q(0),
         ],
      q(lso) => [
         q(0125),
         q(0),
         ],
      q(lsp) => [
         q(0126),
         q(0),
         ],
      q(lst) => [
         q(0127),
         q(0),
         ],
      q(lsy) => [
         q(0128),
         q(0),
         ],
      q(ltg) => [
         q(0129),
         q(0),
         ],
      q(lvs) => [
         q(0130),
         q(0),
         ],
      q(lzh) => [
         q(0131),
         q(0),
         ],
      q(max) => [
         q(0132),
         q(0),
         ],
      q(mdl) => [
         q(0133),
         q(0),
         ],
      q(meo) => [
         q(0134),
         q(0),
         ],
      q(mfa) => [
         q(0135),
         q(0),
         ],
      q(mfb) => [
         q(0136),
         q(0),
         ],
      q(mfs) => [
         q(0137),
         q(0),
         ],
      q(min) => [
         q(0138),
         q(0),
         ],
      q(mnp) => [
         q(0139),
         q(0),
         ],
      q(mqg) => [
         q(0140),
         q(0),
         ],
      q(mre) => [
         q(0141),
         q(0),
         ],
      q(msd) => [
         q(0142),
         q(0),
         ],
      q(msi) => [
         q(0143),
         q(0),
         ],
      q(msr) => [
         q(0144),
         q(0),
         ],
      q(mui) => [
         q(0145),
         q(0),
         ],
      q(mzc) => [
         q(0146),
         q(0),
         ],
      q(mzg) => [
         q(0147),
         q(0),
         ],
      q(mzy) => [
         q(0148),
         q(0),
         ],
      q(nan) => [
         q(0149),
         q(0),
         ],
      q(nbs) => [
         q(0150),
         q(0),
         ],
      q(ncs) => [
         q(0151),
         q(0),
         ],
      q(nsi) => [
         q(0152),
         q(0),
         ],
      q(nsl) => [
         q(0153),
         q(0),
         ],
      q(nsp) => [
         q(0154),
         q(0),
         ],
      q(nsr) => [
         q(0155),
         q(0),
         ],
      q(nzs) => [
         q(0156),
         q(0),
         ],
      q(okl) => [
         q(0157),
         q(0),
         ],
      q(orn) => [
         q(0158),
         q(0),
         ],
      q(ors) => [
         q(0159),
         q(0),
         ],
      q(pel) => [
         q(0160),
         q(0),
         ],
      q(pga) => [
         q(0161),
         q(0),
         ],
      q(pks) => [
         q(0162),
         q(0),
         ],
      q(prl) => [
         q(0163),
         q(0),
         ],
      q(prz) => [
         q(0164),
         q(0),
         ],
      q(psc) => [
         q(0165),
         q(0),
         ],
      q(psd) => [
         q(0166),
         q(0),
         ],
      q(pse) => [
         q(0167),
         q(0),
         ],
      q(psg) => [
         q(0168),
         q(0),
         ],
      q(psl) => [
         q(0169),
         q(0),
         ],
      q(pso) => [
         q(0170),
         q(0),
         ],
      q(psp) => [
         q(0171),
         q(0),
         ],
      q(psr) => [
         q(0172),
         q(0),
         ],
      q(pys) => [
         q(0173),
         q(0),
         ],
      q(rms) => [
         q(0174),
         q(0),
         ],
      q(rsi) => [
         q(0175),
         q(0),
         ],
      q(rsl) => [
         q(0176),
         q(0),
         ],
      q(sdl) => [
         q(0177),
         q(0),
         ],
      q(sfb) => [
         q(0178),
         q(0),
         ],
      q(sfs) => [
         q(0179),
         q(0),
         ],
      q(sgg) => [
         q(0180),
         q(0),
         ],
      q(sgx) => [
         q(0181),
         q(0),
         ],
      q(shu) => [
         q(0182),
         q(0),
         ],
      q(slf) => [
         q(0183),
         q(0),
         ],
      q(sls) => [
         q(0184),
         q(0),
         ],
      q(sqk) => [
         q(0185),
         q(0),
         ],
      q(sqs) => [
         q(0186),
         q(0),
         ],
      q(ssh) => [
         q(0187),
         q(0),
         ],
      q(ssp) => [
         q(0188),
         q(0),
         ],
      q(ssr) => [
         q(0189),
         q(0),
         ],
      q(svk) => [
         q(0190),
         q(0),
         ],
      q(swc) => [
         q(0191),
         q(0),
         ],
      q(swh) => [
         q(0192),
         q(0),
         ],
      q(swl) => [
         q(0193),
         q(0),
         ],
      q(syy) => [
         q(0194),
         q(0),
         ],
      q(tmw) => [
         q(0195),
         q(0),
         ],
      q(tse) => [
         q(0196),
         q(0),
         ],
      q(tsm) => [
         q(0197),
         q(0),
         ],
      q(tsq) => [
         q(0198),
         q(0),
         ],
      q(tss) => [
         q(0199),
         q(0),
         ],
      q(tsy) => [
         q(0200),
         q(0),
         ],
      q(tza) => [
         q(0201),
         q(0),
         ],
      q(ugn) => [
         q(0202),
         q(0),
         ],
      q(ugy) => [
         q(0203),
         q(0),
         ],
      q(ukl) => [
         q(0204),
         q(0),
         ],
      q(uks) => [
         q(0205),
         q(0),
         ],
      q(urk) => [
         q(0206),
         q(0),
         ],
      q(uzn) => [
         q(0207),
         q(0),
         ],
      q(uzs) => [
         q(0208),
         q(0),
         ],
      q(vgt) => [
         q(0209),
         q(0),
         ],
      q(vkk) => [
         q(0210),
         q(0),
         ],
      q(vkt) => [
         q(0211),
         q(0),
         ],
      q(vsi) => [
         q(0212),
         q(0),
         ],
      q(vsl) => [
         q(0213),
         q(0),
         ],
      q(vsv) => [
         q(0214),
         q(0),
         ],
      q(wuu) => [
         q(0215),
         q(0),
         ],
      q(xki) => [
         q(0216),
         q(0),
         ],
      q(xml) => [
         q(0217),
         q(0),
         ],
      q(xmm) => [
         q(0218),
         q(0),
         ],
      q(xms) => [
         q(0219),
         q(0),
         ],
      q(yds) => [
         q(0220),
         q(0),
         ],
      q(ysl) => [
         q(0221),
         q(0),
         ],
      q(yue) => [
         q(0222),
         q(0),
         ],
      q(zib) => [
         q(0223),
         q(0),
         ],
      q(zlm) => [
         q(0224),
         q(0),
         ],
      q(zmi) => [
         q(0225),
         q(0),
         ],
      q(zsl) => [
         q(0226),
         q(0),
         ],
      q(zsm) => [
         q(0227),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'langext'}{'id2code'} = {
   q(alpha) => {
      q(0001) => q(aao),
      q(0002) => q(abh),
      q(0003) => q(abv),
      q(0004) => q(acm),
      q(0005) => q(acq),
      q(0006) => q(acw),
      q(0007) => q(acx),
      q(0008) => q(acy),
      q(0009) => q(adf),
      q(0010) => q(ads),
      q(0011) => q(aeb),
      q(0012) => q(aec),
      q(0013) => q(aed),
      q(0014) => q(aen),
      q(0015) => q(afb),
      q(0016) => q(afg),
      q(0017) => q(ajp),
      q(0018) => q(apc),
      q(0019) => q(apd),
      q(0020) => q(arb),
      q(0021) => q(arq),
      q(0022) => q(ars),
      q(0023) => q(ary),
      q(0024) => q(arz),
      q(0025) => q(ase),
      q(0026) => q(asf),
      q(0027) => q(asp),
      q(0028) => q(asq),
      q(0029) => q(asw),
      q(0030) => q(auz),
      q(0031) => q(avl),
      q(0032) => q(ayh),
      q(0033) => q(ayl),
      q(0034) => q(ayn),
      q(0035) => q(ayp),
      q(0036) => q(bbz),
      q(0037) => q(bfi),
      q(0038) => q(bfk),
      q(0039) => q(bjn),
      q(0040) => q(bog),
      q(0041) => q(bqn),
      q(0042) => q(bqy),
      q(0043) => q(btj),
      q(0044) => q(bve),
      q(0045) => q(bvl),
      q(0046) => q(bvu),
      q(0047) => q(bzs),
      q(0048) => q(cdo),
      q(0049) => q(cds),
      q(0050) => q(cjy),
      q(0051) => q(cmn),
      q(0052) => q(coa),
      q(0053) => q(cpx),
      q(0054) => q(csc),
      q(0055) => q(csd),
      q(0056) => q(cse),
      q(0057) => q(csf),
      q(0058) => q(csg),
      q(0059) => q(csl),
      q(0060) => q(csn),
      q(0061) => q(csq),
      q(0062) => q(csr),
      q(0063) => q(czh),
      q(0064) => q(czo),
      q(0065) => q(doq),
      q(0066) => q(dse),
      q(0067) => q(dsl),
      q(0068) => q(dup),
      q(0069) => q(ecs),
      q(0070) => q(esl),
      q(0071) => q(esn),
      q(0072) => q(eso),
      q(0073) => q(eth),
      q(0074) => q(fcs),
      q(0075) => q(fse),
      q(0076) => q(fsl),
      q(0077) => q(fss),
      q(0078) => q(gan),
      q(0079) => q(gds),
      q(0080) => q(gom),
      q(0081) => q(gse),
      q(0082) => q(gsg),
      q(0083) => q(gsm),
      q(0084) => q(gss),
      q(0085) => q(gus),
      q(0086) => q(hab),
      q(0087) => q(haf),
      q(0088) => q(hak),
      q(0089) => q(hds),
      q(0090) => q(hji),
      q(0091) => q(hks),
      q(0092) => q(hos),
      q(0093) => q(hps),
      q(0094) => q(hsh),
      q(0095) => q(hsl),
      q(0096) => q(hsn),
      q(0097) => q(icl),
      q(0098) => q(ils),
      q(0099) => q(inl),
      q(0100) => q(ins),
      q(0101) => q(ise),
      q(0102) => q(isg),
      q(0103) => q(isr),
      q(0104) => q(jak),
      q(0105) => q(jax),
      q(0106) => q(jcs),
      q(0107) => q(jhs),
      q(0108) => q(jls),
      q(0109) => q(jos),
      q(0110) => q(jsl),
      q(0111) => q(jus),
      q(0112) => q(kgi),
      q(0113) => q(knn),
      q(0114) => q(kvb),
      q(0115) => q(kvk),
      q(0116) => q(kvr),
      q(0117) => q(kxd),
      q(0118) => q(lbs),
      q(0119) => q(lce),
      q(0120) => q(lcf),
      q(0121) => q(liw),
      q(0122) => q(lls),
      q(0123) => q(lsg),
      q(0124) => q(lsl),
      q(0125) => q(lso),
      q(0126) => q(lsp),
      q(0127) => q(lst),
      q(0128) => q(lsy),
      q(0129) => q(ltg),
      q(0130) => q(lvs),
      q(0131) => q(lzh),
      q(0132) => q(max),
      q(0133) => q(mdl),
      q(0134) => q(meo),
      q(0135) => q(mfa),
      q(0136) => q(mfb),
      q(0137) => q(mfs),
      q(0138) => q(min),
      q(0139) => q(mnp),
      q(0140) => q(mqg),
      q(0141) => q(mre),
      q(0142) => q(msd),
      q(0143) => q(msi),
      q(0144) => q(msr),
      q(0145) => q(mui),
      q(0146) => q(mzc),
      q(0147) => q(mzg),
      q(0148) => q(mzy),
      q(0149) => q(nan),
      q(0150) => q(nbs),
      q(0151) => q(ncs),
      q(0152) => q(nsi),
      q(0153) => q(nsl),
      q(0154) => q(nsp),
      q(0155) => q(nsr),
      q(0156) => q(nzs),
      q(0157) => q(okl),
      q(0158) => q(orn),
      q(0159) => q(ors),
      q(0160) => q(pel),
      q(0161) => q(pga),
      q(0162) => q(pks),
      q(0163) => q(prl),
      q(0164) => q(prz),
      q(0165) => q(psc),
      q(0166) => q(psd),
      q(0167) => q(pse),
      q(0168) => q(psg),
      q(0169) => q(psl),
      q(0170) => q(pso),
      q(0171) => q(psp),
      q(0172) => q(psr),
      q(0173) => q(pys),
      q(0174) => q(rms),
      q(0175) => q(rsi),
      q(0176) => q(rsl),
      q(0177) => q(sdl),
      q(0178) => q(sfb),
      q(0179) => q(sfs),
      q(0180) => q(sgg),
      q(0181) => q(sgx),
      q(0182) => q(shu),
      q(0183) => q(slf),
      q(0184) => q(sls),
      q(0185) => q(sqk),
      q(0186) => q(sqs),
      q(0187) => q(ssh),
      q(0188) => q(ssp),
      q(0189) => q(ssr),
      q(0190) => q(svk),
      q(0191) => q(swc),
      q(0192) => q(swh),
      q(0193) => q(swl),
      q(0194) => q(syy),
      q(0195) => q(tmw),
      q(0196) => q(tse),
      q(0197) => q(tsm),
      q(0198) => q(tsq),
      q(0199) => q(tss),
      q(0200) => q(tsy),
      q(0201) => q(tza),
      q(0202) => q(ugn),
      q(0203) => q(ugy),
      q(0204) => q(ukl),
      q(0205) => q(uks),
      q(0206) => q(urk),
      q(0207) => q(uzn),
      q(0208) => q(uzs),
      q(0209) => q(vgt),
      q(0210) => q(vkk),
      q(0211) => q(vkt),
      q(0212) => q(vsi),
      q(0213) => q(vsl),
      q(0214) => q(vsv),
      q(0215) => q(wuu),
      q(0216) => q(xki),
      q(0217) => q(xml),
      q(0218) => q(xmm),
      q(0219) => q(xms),
      q(0220) => q(yds),
      q(0221) => q(ysl),
      q(0222) => q(yue),
      q(0223) => q(zib),
      q(0224) => q(zlm),
      q(0225) => q(zmi),
      q(0226) => q(zsl),
      q(0227) => q(zsm),
      },
};

1;
                                                                                                                                                                                                                                                                                                                                                                                                         usr/share/perl/5.20.2/Locale/Codes/LangExt_Retired.pm                                               0100644 0000000 0000000 00000000647 12744441327 020477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::LangExt_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Mar  4 13:19:40 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'langext'}{'alpha'}{'code'} = {
};

$Locale::Codes::Retired{'langext'}{'alpha'}{'name'} = {
};


1;
                                                                                         usr/share/perl/5.20.2/Locale/Codes/LangFam.pm                                                       0100644 0000000 0000000 00000004117 12744441327 016760  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::LangFam;
# Copyright (c) 2011-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::LangFam_Codes;
use Locale::Codes::LangFam_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2langfam
                langfam2code
                all_langfam_codes
                all_langfam_names
                langfam_code2code
                LOCALE_LANGFAM_ALPHA
               );

sub code2langfam {
   return Locale::Codes::_code2name('langfam',@_);
}

sub langfam2code {
   return Locale::Codes::_name2code('langfam',@_);
}

sub langfam_code2code {
   return Locale::Codes::_code2code('langfam',@_);
}

sub all_langfam_codes {
   return Locale::Codes::_all_codes('langfam',@_);
}

sub all_langfam_names {
   return Locale::Codes::_all_names('langfam',@_);
}

sub rename_langfam {
   return Locale::Codes::_rename('langfam',@_);
}

sub add_langfam {
   return Locale::Codes::_add_code('langfam',@_);
}

sub delete_langfam {
   return Locale::Codes::_delete_code('langfam',@_);
}

sub add_langfam_alias {
   return Locale::Codes::_add_alias('langfam',@_);
}

sub delete_langfam_alias {
   return Locale::Codes::_delete_alias('langfam',@_);
}

sub rename_langfam_code {
   return Locale::Codes::_rename_code('langfam',@_);
}

sub add_langfam_code_alias {
   return Locale::Codes::_add_code_alias('langfam',@_);
}

sub delete_langfam_code_alias {
   return Locale::Codes::_delete_code_alias('langfam',@_);
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/perl/5.20.2/Locale/Codes/LangFam.pod                                                      0100644 0000000 0000000 00000005262 12744441327 017130  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::LangFam - standard codes for language extension identification

=head1 SYNOPSIS

   use Locale::Codes::LangFam;

   $lext = code2langfam('apa');                 # $lext gets 'Apache languages'
   $code = langfam2code('Apache languages');    # $code gets 'apa'

   @codes   = all_langfam_codes();
   @names   = all_langfam_names();

=head1 DESCRIPTION

The C<Locale::Codes::LangFam> module provides access to standard codes
used for identifying language families, such as those as defined in
ISO 639-5.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default ISO 639-5
language family codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
language families. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $lext = code2langfam('apa','alpha');
   $lext = code2langfam('apa',LOCALE_LANGFAM_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha>

This is the set of three-letter (lowercase) codes from ISO 639-5
such as 'apa' for Apache languages.

This is the default code set.

=back

=head1 ROUTINES

=over 4

=item B<code2langfam ( CODE [,CODESET] )>

=item B<langfam2code ( NAME [,CODESET] )>

=item B<langfam_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_langfam_codes ( [CODESET] )>

=item B<all_langfam_names ( [CODESET] )>

=item B<Locale::Codes::LangFam::rename_langfam  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::LangFam::add_langfam  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::LangFam::delete_langfam  ( CODE [,CODESET] )>

=item B<Locale::Codes::LangFam::add_langfam_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::LangFam::delete_langfam_alias  ( NAME )>

=item B<Locale::Codes::LangFam::rename_langfam_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangFam::add_langfam_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangFam::delete_langfam_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.loc.gov/standards/iso639-5/id.php>

ISO 639-5 .

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 2011-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                                                                                                                                                                              usr/share/perl/5.20.2/Locale/Codes/LangFam_Codes.pm                                                 0100644 0000000 0000000 00000060470 12744441327 020101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::LangFam_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:46:01 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'langfam'}{'id'} = '0116';

$Locale::Codes::Data{'langfam'}{'id2names'} = {
   q(0001) => [
      q(Austro-Asiatic languages),
      ],
   q(0002) => [
      q(Afro-Asiatic languages),
      ],
   q(0003) => [
      q(Algonquian languages),
      ],
   q(0004) => [
      q(Atlantic-Congo languages),
      ],
   q(0005) => [
      q(Apache languages),
      ],
   q(0006) => [
      q(Alacalufan languages),
      ],
   q(0007) => [
      q(Algic languages),
      ],
   q(0008) => [
      q(Artificial languages),
      ],
   q(0009) => [
      q(Athapascan languages),
      ],
   q(0010) => [
      q(Arauan languages),
      ],
   q(0011) => [
      q(Australian languages),
      ],
   q(0012) => [
      q(Arawakan languages),
      ],
   q(0013) => [
      q(Uto-Aztecan languages),
      ],
   q(0014) => [
      q(Banda languages),
      ],
   q(0015) => [
      q(Bamileke languages),
      ],
   q(0016) => [
      q(Baltic languages),
      ],
   q(0017) => [
      q(Berber languages),
      ],
   q(0018) => [
      q(Bihari languages),
      ],
   q(0019) => [
      q(Bantu languages),
      ],
   q(0020) => [
      q(Batak languages),
      ],
   q(0021) => [
      q(Central American Indian languages),
      ],
   q(0022) => [
      q(Caucasian languages),
      ],
   q(0023) => [
      q(Chibchan languages),
      ],
   q(0024) => [
      q(North Caucasian languages),
      ],
   q(0025) => [
      q(South Caucasian languages),
      ],
   q(0026) => [
      q(Chadic languages),
      ],
   q(0027) => [
      q(Caddoan languages),
      ],
   q(0028) => [
      q(Celtic languages),
      ],
   q(0029) => [
      q(Chamic languages),
      ],
   q(0030) => [
      q(Creoles and pidgins, English-based),
      ],
   q(0031) => [
      q(Creoles and pidgins, French-based),
      ],
   q(0032) => [
      q(Creoles and pidgins, Portuguese-based),
      ],
   q(0033) => [
      q(Creoles and pidgins),
      ],
   q(0034) => [
      q(Central Sudanic languages),
      ],
   q(0035) => [
      q(Cushitic languages),
      ],
   q(0036) => [
      q(Land Dayak languages),
      ],
   q(0037) => [
      q(Mande languages),
      ],
   q(0038) => [
      q(Dravidian languages),
      ],
   q(0039) => [
      q(Egyptian languages),
      ],
   q(0040) => [
      q(Eskimo-Aleut languages),
      ],
   q(0041) => [
      q(Basque (family)),
      ],
   q(0042) => [
      q(Finno-Ugrian languages),
      ],
   q(0043) => [
      q(Formosan languages),
      ],
   q(0044) => [
      q(Germanic languages),
      ],
   q(0045) => [
      q(East Germanic languages),
      ],
   q(0046) => [
      q(North Germanic languages),
      ],
   q(0047) => [
      q(West Germanic languages),
      ],
   q(0048) => [
      q(Greek languages),
      ],
   q(0049) => [
      q(Hmong-Mien languages),
      ],
   q(0050) => [
      q(Hokan languages),
      ],
   q(0051) => [
      q(Armenian (family)),
      ],
   q(0052) => [
      q(Indo-Iranian languages),
      ],
   q(0053) => [
      q(Ijo languages),
      ],
   q(0054) => [
      q(Indic languages),
      ],
   q(0055) => [
      q(Indo-European languages),
      ],
   q(0056) => [
      q(Iranian languages),
      ],
   q(0057) => [
      q(Iroquoian languages),
      ],
   q(0058) => [
      q(Italic languages),
      ],
   q(0059) => [
      q(Japanese (family)),
      ],
   q(0060) => [
      q(Karen languages),
      ],
   q(0061) => [
      q(Kordofanian languages),
      ],
   q(0062) => [
      q(Khoisan languages),
      ],
   q(0063) => [
      q(Kru languages),
      ],
   q(0064) => [
      q(Austronesian languages),
      ],
   q(0065) => [
      q(Mon-Khmer languages),
      ],
   q(0066) => [
      q(Manobo languages),
      ],
   q(0067) => [
      q(Munda languages),
      ],
   q(0068) => [
      q(Mayan languages),
      ],
   q(0069) => [
      q(Nahuatl languages),
      ],
   q(0070) => [
      q(North American Indian languages),
      ],
   q(0071) => [
      q(Trans-New Guinea languages),
      ],
   q(0072) => [
      q(Niger-Kordofanian languages),
      ],
   q(0073) => [
      q(Nubian languages),
      ],
   q(0074) => [
      q(Oto-Manguean languages),
      ],
   q(0075) => [
      q(Omotic languages),
      ],
   q(0076) => [
      q(Otomian languages),
      ],
   q(0077) => [
      q(Papuan languages),
      ],
   q(0078) => [
      q(Philippine languages),
      ],
   q(0079) => [
      q(Central Malayo-Polynesian languages),
      ],
   q(0080) => [
      q(Malayo-Polynesian languages),
      ],
   q(0081) => [
      q(Eastern Malayo-Polynesian languages),
      ],
   q(0082) => [
      q(Western Malayo-Polynesian languages),
      ],
   q(0083) => [
      q(Prakrit languages),
      ],
   q(0084) => [
      q(Quechuan (family)),
      ],
   q(0085) => [
      q(Romance languages),
      ],
   q(0086) => [
      q(South American Indian languages),
      ],
   q(0087) => [
      q(Salishan languages),
      ],
   q(0088) => [
      q(Eastern Sudanic languages),
      ],
   q(0089) => [
      q(Semitic languages),
      ],
   q(0090) => [
      q(sign languages),
      ],
   q(0091) => [
      q(Siouan languages),
      ],
   q(0092) => [
      q(Sino-Tibetan languages),
      ],
   q(0093) => [
      q(Slavic languages),
      ],
   q(0094) => [
      q(Sami languages),
      ],
   q(0095) => [
      q(Songhai languages),
      ],
   q(0096) => [
      q(Albanian languages),
      ],
   q(0097) => [
      q(Nilo-Saharan languages),
      ],
   q(0098) => [
      q(Samoyedic languages),
      ],
   q(0099) => [
      q(Tai languages),
      ],
   q(0100) => [
      q(Tibeto-Burman languages),
      ],
   q(0101) => [
      q(Turkic languages),
      ],
   q(0102) => [
      q(Tupi languages),
      ],
   q(0103) => [
      q(Altaic languages),
      ],
   q(0104) => [
      q(Tungus languages),
      ],
   q(0105) => [
      q(Uralic languages),
      ],
   q(0106) => [
      q(Wakashan languages),
      ],
   q(0107) => [
      q(Sorbian languages),
      ],
   q(0108) => [
      q(Mongolian languages),
      ],
   q(0109) => [
      q(Na-Dene languages),
      ],
   q(0110) => [
      q(Yupik languages),
      ],
   q(0111) => [
      q(Chinese (family)),
      ],
   q(0112) => [
      q(East Slavic languages),
      ],
   q(0113) => [
      q(South Slavic languages),
      ],
   q(0114) => [
      q(West Slavic languages),
      ],
   q(0115) => [
      q(Zande languages),
      ],
};

$Locale::Codes::Data{'langfam'}{'alias2id'} = {
   q(afro-asiatic languages) => [
      q(0002),
      q(0),
      ],
   q(alacalufan languages) => [
      q(0006),
      q(0),
      ],
   q(albanian languages) => [
      q(0096),
      q(0),
      ],
   q(algic languages) => [
      q(0007),
      q(0),
      ],
   q(algonquian languages) => [
      q(0003),
      q(0),
      ],
   q(altaic languages) => [
      q(0103),
      q(0),
      ],
   q(apache languages) => [
      q(0005),
      q(0),
      ],
   q(arauan languages) => [
      q(0010),
      q(0),
      ],
   q(arawakan languages) => [
      q(0012),
      q(0),
      ],
   q(armenian (family)) => [
      q(0051),
      q(0),
      ],
   q(artificial languages) => [
      q(0008),
      q(0),
      ],
   q(athapascan languages) => [
      q(0009),
      q(0),
      ],
   q(atlantic-congo languages) => [
      q(0004),
      q(0),
      ],
   q(australian languages) => [
      q(0011),
      q(0),
      ],
   q(austro-asiatic languages) => [
      q(0001),
      q(0),
      ],
   q(austronesian languages) => [
      q(0064),
      q(0),
      ],
   q(baltic languages) => [
      q(0016),
      q(0),
      ],
   q(bamileke languages) => [
      q(0015),
      q(0),
      ],
   q(banda languages) => [
      q(0014),
      q(0),
      ],
   q(bantu languages) => [
      q(0019),
      q(0),
      ],
   q(basque (family)) => [
      q(0041),
      q(0),
      ],
   q(batak languages) => [
      q(0020),
      q(0),
      ],
   q(berber languages) => [
      q(0017),
      q(0),
      ],
   q(bihari languages) => [
      q(0018),
      q(0),
      ],
   q(caddoan languages) => [
      q(0027),
      q(0),
      ],
   q(caucasian languages) => [
      q(0022),
      q(0),
      ],
   q(celtic languages) => [
      q(0028),
      q(0),
      ],
   q(central american indian languages) => [
      q(0021),
      q(0),
      ],
   q(central malayo-polynesian languages) => [
      q(0079),
      q(0),
      ],
   q(central sudanic languages) => [
      q(0034),
      q(0),
      ],
   q(chadic languages) => [
      q(0026),
      q(0),
      ],
   q(chamic languages) => [
      q(0029),
      q(0),
      ],
   q(chibchan languages) => [
      q(0023),
      q(0),
      ],
   q(chinese (family)) => [
      q(0111),
      q(0),
      ],
   q(creoles and pidgins) => [
      q(0033),
      q(0),
      ],
   q(creoles and pidgins, english-based) => [
      q(0030),
      q(0),
      ],
   q(creoles and pidgins, french-based) => [
      q(0031),
      q(0),
      ],
   q(creoles and pidgins, portuguese-based) => [
      q(0032),
      q(0),
      ],
   q(cushitic languages) => [
      q(0035),
      q(0),
      ],
   q(dravidian languages) => [
      q(0038),
      q(0),
      ],
   q(east germanic languages) => [
      q(0045),
      q(0),
      ],
   q(east slavic languages) => [
      q(0112),
      q(0),
      ],
   q(eastern malayo-polynesian languages) => [
      q(0081),
      q(0),
      ],
   q(eastern sudanic languages) => [
      q(0088),
      q(0),
      ],
   q(egyptian languages) => [
      q(0039),
      q(0),
      ],
   q(eskimo-aleut languages) => [
      q(0040),
      q(0),
      ],
   q(finno-ugrian languages) => [
      q(0042),
      q(0),
      ],
   q(formosan languages) => [
      q(0043),
      q(0),
      ],
   q(germanic languages) => [
      q(0044),
      q(0),
      ],
   q(greek languages) => [
      q(0048),
      q(0),
      ],
   q(hmong-mien languages) => [
      q(0049),
      q(0),
      ],
   q(hokan languages) => [
      q(0050),
      q(0),
      ],
   q(ijo languages) => [
      q(0053),
      q(0),
      ],
   q(indic languages) => [
      q(0054),
      q(0),
      ],
   q(indo-european languages) => [
      q(0055),
      q(0),
      ],
   q(indo-iranian languages) => [
      q(0052),
      q(0),
      ],
   q(iranian languages) => [
      q(0056),
      q(0),
      ],
   q(iroquoian languages) => [
      q(0057),
      q(0),
      ],
   q(italic languages) => [
      q(0058),
      q(0),
      ],
   q(japanese (family)) => [
      q(0059),
      q(0),
      ],
   q(karen languages) => [
      q(0060),
      q(0),
      ],
   q(khoisan languages) => [
      q(0062),
      q(0),
      ],
   q(kordofanian languages) => [
      q(0061),
      q(0),
      ],
   q(kru languages) => [
      q(0063),
      q(0),
      ],
   q(land dayak languages) => [
      q(0036),
      q(0),
      ],
   q(malayo-polynesian languages) => [
      q(0080),
      q(0),
      ],
   q(mande languages) => [
      q(0037),
      q(0),
      ],
   q(manobo languages) => [
      q(0066),
      q(0),
      ],
   q(mayan languages) => [
      q(0068),
      q(0),
      ],
   q(mon-khmer languages) => [
      q(0065),
      q(0),
      ],
   q(mongolian languages) => [
      q(0108),
      q(0),
      ],
   q(munda languages) => [
      q(0067),
      q(0),
      ],
   q(na-dene languages) => [
      q(0109),
      q(0),
      ],
   q(nahuatl languages) => [
      q(0069),
      q(0),
      ],
   q(niger-kordofanian languages) => [
      q(0072),
      q(0),
      ],
   q(nilo-saharan languages) => [
      q(0097),
      q(0),
      ],
   q(north american indian languages) => [
      q(0070),
      q(0),
      ],
   q(north caucasian languages) => [
      q(0024),
      q(0),
      ],
   q(north germanic languages) => [
      q(0046),
      q(0),
      ],
   q(nubian languages) => [
      q(0073),
      q(0),
      ],
   q(omotic languages) => [
      q(0075),
      q(0),
      ],
   q(oto-manguean languages) => [
      q(0074),
      q(0),
      ],
   q(otomian languages) => [
      q(0076),
      q(0),
      ],
   q(papuan languages) => [
      q(0077),
      q(0),
      ],
   q(philippine languages) => [
      q(0078),
      q(0),
      ],
   q(prakrit languages) => [
      q(0083),
      q(0),
      ],
   q(quechuan (family)) => [
      q(0084),
      q(0),
      ],
   q(romance languages) => [
      q(0085),
      q(0),
      ],
   q(salishan languages) => [
      q(0087),
      q(0),
      ],
   q(sami languages) => [
      q(0094),
      q(0),
      ],
   q(samoyedic languages) => [
      q(0098),
      q(0),
      ],
   q(semitic languages) => [
      q(0089),
      q(0),
      ],
   q(sign languages) => [
      q(0090),
      q(0),
      ],
   q(sino-tibetan languages) => [
      q(0092),
      q(0),
      ],
   q(siouan languages) => [
      q(0091),
      q(0),
      ],
   q(slavic languages) => [
      q(0093),
      q(0),
      ],
   q(songhai languages) => [
      q(0095),
      q(0),
      ],
   q(sorbian languages) => [
      q(0107),
      q(0),
      ],
   q(south american indian languages) => [
      q(0086),
      q(0),
      ],
   q(south caucasian languages) => [
      q(0025),
      q(0),
      ],
   q(south slavic languages) => [
      q(0113),
      q(0),
      ],
   q(tai languages) => [
      q(0099),
      q(0),
      ],
   q(tibeto-burman languages) => [
      q(0100),
      q(0),
      ],
   q(trans-new guinea languages) => [
      q(0071),
      q(0),
      ],
   q(tungus languages) => [
      q(0104),
      q(0),
      ],
   q(tupi languages) => [
      q(0102),
      q(0),
      ],
   q(turkic languages) => [
      q(0101),
      q(0),
      ],
   q(uralic languages) => [
      q(0105),
      q(0),
      ],
   q(uto-aztecan languages) => [
      q(0013),
      q(0),
      ],
   q(wakashan languages) => [
      q(0106),
      q(0),
      ],
   q(west germanic languages) => [
      q(0047),
      q(0),
      ],
   q(west slavic languages) => [
      q(0114),
      q(0),
      ],
   q(western malayo-polynesian languages) => [
      q(0082),
      q(0),
      ],
   q(yupik languages) => [
      q(0110),
      q(0),
      ],
   q(zande languages) => [
      q(0115),
      q(0),
      ],
};

$Locale::Codes::Data{'langfam'}{'code2id'} = {
   q(alpha) => {
      q(aav) => [
         q(0001),
         q(0),
         ],
      q(afa) => [
         q(0002),
         q(0),
         ],
      q(alg) => [
         q(0003),
         q(0),
         ],
      q(alv) => [
         q(0004),
         q(0),
         ],
      q(apa) => [
         q(0005),
         q(0),
         ],
      q(aqa) => [
         q(0006),
         q(0),
         ],
      q(aql) => [
         q(0007),
         q(0),
         ],
      q(art) => [
         q(0008),
         q(0),
         ],
      q(ath) => [
         q(0009),
         q(0),
         ],
      q(auf) => [
         q(0010),
         q(0),
         ],
      q(aus) => [
         q(0011),
         q(0),
         ],
      q(awd) => [
         q(0012),
         q(0),
         ],
      q(azc) => [
         q(0013),
         q(0),
         ],
      q(bad) => [
         q(0014),
         q(0),
         ],
      q(bai) => [
         q(0015),
         q(0),
         ],
      q(bat) => [
         q(0016),
         q(0),
         ],
      q(ber) => [
         q(0017),
         q(0),
         ],
      q(bih) => [
         q(0018),
         q(0),
         ],
      q(bnt) => [
         q(0019),
         q(0),
         ],
      q(btk) => [
         q(0020),
         q(0),
         ],
      q(cai) => [
         q(0021),
         q(0),
         ],
      q(cau) => [
         q(0022),
         q(0),
         ],
      q(cba) => [
         q(0023),
         q(0),
         ],
      q(ccn) => [
         q(0024),
         q(0),
         ],
      q(ccs) => [
         q(0025),
         q(0),
         ],
      q(cdc) => [
         q(0026),
         q(0),
         ],
      q(cdd) => [
         q(0027),
         q(0),
         ],
      q(cel) => [
         q(0028),
         q(0),
         ],
      q(cmc) => [
         q(0029),
         q(0),
         ],
      q(cpe) => [
         q(0030),
         q(0),
         ],
      q(cpf) => [
         q(0031),
         q(0),
         ],
      q(cpp) => [
         q(0032),
         q(0),
         ],
      q(crp) => [
         q(0033),
         q(0),
         ],
      q(csu) => [
         q(0034),
         q(0),
         ],
      q(cus) => [
         q(0035),
         q(0),
         ],
      q(day) => [
         q(0036),
         q(0),
         ],
      q(dmn) => [
         q(0037),
         q(0),
         ],
      q(dra) => [
         q(0038),
         q(0),
         ],
      q(egx) => [
         q(0039),
         q(0),
         ],
      q(esx) => [
         q(0040),
         q(0),
         ],
      q(euq) => [
         q(0041),
         q(0),
         ],
      q(fiu) => [
         q(0042),
         q(0),
         ],
      q(fox) => [
         q(0043),
         q(0),
         ],
      q(gem) => [
         q(0044),
         q(0),
         ],
      q(gme) => [
         q(0045),
         q(0),
         ],
      q(gmq) => [
         q(0046),
         q(0),
         ],
      q(gmw) => [
         q(0047),
         q(0),
         ],
      q(grk) => [
         q(0048),
         q(0),
         ],
      q(hmx) => [
         q(0049),
         q(0),
         ],
      q(hok) => [
         q(0050),
         q(0),
         ],
      q(hyx) => [
         q(0051),
         q(0),
         ],
      q(iir) => [
         q(0052),
         q(0),
         ],
      q(ijo) => [
         q(0053),
         q(0),
         ],
      q(inc) => [
         q(0054),
         q(0),
         ],
      q(ine) => [
         q(0055),
         q(0),
         ],
      q(ira) => [
         q(0056),
         q(0),
         ],
      q(iro) => [
         q(0057),
         q(0),
         ],
      q(itc) => [
         q(0058),
         q(0),
         ],
      q(jpx) => [
         q(0059),
         q(0),
         ],
      q(kar) => [
         q(0060),
         q(0),
         ],
      q(kdo) => [
         q(0061),
         q(0),
         ],
      q(khi) => [
         q(0062),
         q(0),
         ],
      q(kro) => [
         q(0063),
         q(0),
         ],
      q(map) => [
         q(0064),
         q(0),
         ],
      q(mkh) => [
         q(0065),
         q(0),
         ],
      q(mno) => [
         q(0066),
         q(0),
         ],
      q(mun) => [
         q(0067),
         q(0),
         ],
      q(myn) => [
         q(0068),
         q(0),
         ],
      q(nah) => [
         q(0069),
         q(0),
         ],
      q(nai) => [
         q(0070),
         q(0),
         ],
      q(ngf) => [
         q(0071),
         q(0),
         ],
      q(nic) => [
         q(0072),
         q(0),
         ],
      q(nub) => [
         q(0073),
         q(0),
         ],
      q(omq) => [
         q(0074),
         q(0),
         ],
      q(omv) => [
         q(0075),
         q(0),
         ],
      q(oto) => [
         q(0076),
         q(0),
         ],
      q(paa) => [
         q(0077),
         q(0),
         ],
      q(phi) => [
         q(0078),
         q(0),
         ],
      q(plf) => [
         q(0079),
         q(0),
         ],
      q(poz) => [
         q(0080),
         q(0),
         ],
      q(pqe) => [
         q(0081),
         q(0),
         ],
      q(pqw) => [
         q(0082),
         q(0),
         ],
      q(pra) => [
         q(0083),
         q(0),
         ],
      q(qwe) => [
         q(0084),
         q(0),
         ],
      q(roa) => [
         q(0085),
         q(0),
         ],
      q(sai) => [
         q(0086),
         q(0),
         ],
      q(sal) => [
         q(0087),
         q(0),
         ],
      q(sdv) => [
         q(0088),
         q(0),
         ],
      q(sem) => [
         q(0089),
         q(0),
         ],
      q(sgn) => [
         q(0090),
         q(0),
         ],
      q(sio) => [
         q(0091),
         q(0),
         ],
      q(sit) => [
         q(0092),
         q(0),
         ],
      q(sla) => [
         q(0093),
         q(0),
         ],
      q(smi) => [
         q(0094),
         q(0),
         ],
      q(son) => [
         q(0095),
         q(0),
         ],
      q(sqj) => [
         q(0096),
         q(0),
         ],
      q(ssa) => [
         q(0097),
         q(0),
         ],
      q(syd) => [
         q(0098),
         q(0),
         ],
      q(tai) => [
         q(0099),
         q(0),
         ],
      q(tbq) => [
         q(0100),
         q(0),
         ],
      q(trk) => [
         q(0101),
         q(0),
         ],
      q(tup) => [
         q(0102),
         q(0),
         ],
      q(tut) => [
         q(0103),
         q(0),
         ],
      q(tuw) => [
         q(0104),
         q(0),
         ],
      q(urj) => [
         q(0105),
         q(0),
         ],
      q(wak) => [
         q(0106),
         q(0),
         ],
      q(wen) => [
         q(0107),
         q(0),
         ],
      q(xgn) => [
         q(0108),
         q(0),
         ],
      q(xnd) => [
         q(0109),
         q(0),
         ],
      q(ypk) => [
         q(0110),
         q(0),
         ],
      q(zhx) => [
         q(0111),
         q(0),
         ],
      q(zle) => [
         q(0112),
         q(0),
         ],
      q(zls) => [
         q(0113),
         q(0),
         ],
      q(zlw) => [
         q(0114),
         q(0),
         ],
      q(znd) => [
         q(0115),
         q(0),
         ],
      },
};

$Locale::Codes::Data{'langfam'}{'id2code'} = {
   q(alpha) => {
      q(0001) => q(aav),
      q(0002) => q(afa),
      q(0003) => q(alg),
      q(0004) => q(alv),
      q(0005) => q(apa),
      q(0006) => q(aqa),
      q(0007) => q(aql),
      q(0008) => q(art),
      q(0009) => q(ath),
      q(0010) => q(auf),
      q(0011) => q(aus),
      q(0012) => q(awd),
      q(0013) => q(azc),
      q(0014) => q(bad),
      q(0015) => q(bai),
      q(0016) => q(bat),
      q(0017) => q(ber),
      q(0018) => q(bih),
      q(0019) => q(bnt),
      q(0020) => q(btk),
      q(0021) => q(cai),
      q(0022) => q(cau),
      q(0023) => q(cba),
      q(0024) => q(ccn),
      q(0025) => q(ccs),
      q(0026) => q(cdc),
      q(0027) => q(cdd),
      q(0028) => q(cel),
      q(0029) => q(cmc),
      q(0030) => q(cpe),
      q(0031) => q(cpf),
      q(0032) => q(cpp),
      q(0033) => q(crp),
      q(0034) => q(csu),
      q(0035) => q(cus),
      q(0036) => q(day),
      q(0037) => q(dmn),
      q(0038) => q(dra),
      q(0039) => q(egx),
      q(0040) => q(esx),
      q(0041) => q(euq),
      q(0042) => q(fiu),
      q(0043) => q(fox),
      q(0044) => q(gem),
      q(0045) => q(gme),
      q(0046) => q(gmq),
      q(0047) => q(gmw),
      q(0048) => q(grk),
      q(0049) => q(hmx),
      q(0050) => q(hok),
      q(0051) => q(hyx),
      q(0052) => q(iir),
      q(0053) => q(ijo),
      q(0054) => q(inc),
      q(0055) => q(ine),
      q(0056) => q(ira),
      q(0057) => q(iro),
      q(0058) => q(itc),
      q(0059) => q(jpx),
      q(0060) => q(kar),
      q(0061) => q(kdo),
      q(0062) => q(khi),
      q(0063) => q(kro),
      q(0064) => q(map),
      q(0065) => q(mkh),
      q(0066) => q(mno),
      q(0067) => q(mun),
      q(0068) => q(myn),
      q(0069) => q(nah),
      q(0070) => q(nai),
      q(0071) => q(ngf),
      q(0072) => q(nic),
      q(0073) => q(nub),
      q(0074) => q(omq),
      q(0075) => q(omv),
      q(0076) => q(oto),
      q(0077) => q(paa),
      q(0078) => q(phi),
      q(0079) => q(plf),
      q(0080) => q(poz),
      q(0081) => q(pqe),
      q(0082) => q(pqw),
      q(0083) => q(pra),
      q(0084) => q(qwe),
      q(0085) => q(roa),
      q(0086) => q(sai),
      q(0087) => q(sal),
      q(0088) => q(sdv),
      q(0089) => q(sem),
      q(0090) => q(sgn),
      q(0091) => q(sio),
      q(0092) => q(sit),
      q(0093) => q(sla),
      q(0094) => q(smi),
      q(0095) => q(son),
      q(0096) => q(sqj),
      q(0097) => q(ssa),
      q(0098) => q(syd),
      q(0099) => q(tai),
      q(0100) => q(tbq),
      q(0101) => q(trk),
      q(0102) => q(tup),
      q(0103) => q(tut),
      q(0104) => q(tuw),
      q(0105) => q(urj),
      q(0106) => q(wak),
      q(0107) => q(wen),
      q(0108) => q(xgn),
      q(0109) => q(xnd),
      q(0110) => q(ypk),
      q(0111) => q(zhx),
      q(0112) => q(zle),
      q(0113) => q(zls),
      q(0114) => q(zlw),
      q(0115) => q(znd),
      },
};

1;
                                                                                                                                                                                                        usr/share/perl/5.20.2/Locale/Codes/LangFam_Retired.pm                                               0100644 0000000 0000000 00000002072 12744441327 020434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::LangFam_Retired;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'deprecate_codes' is run.
#    Generated on: Tue Sep 27 15:40:31 EDT 2011

=pod

=head1 NAME

Locale::Codes::LangFam_Retired - retired langfam codes for the Locale::Codes::LangFam module

=head1 SYNOPSIS

This module contains data used by the Locale::Codes::LangFam module. It is
not intended to be used directly, and contains no calleable routines.

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 1997-2001 Canon Research Centre Europe (CRE).
   Copyright (c) 2001-2010 Neil Bowers
   Copyright (c) 2010-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut

use strict;
use warnings;
require 5.002;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Retired{'langfam'}{'alpha'}{'code'} = {
};

$Locale::Codes::Retired{'langfam'}{'alpha'}{'name'} = {
};


1;
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/share/perl/5.20.2/Locale/Codes/LangVar.pm                                                       0100644 0000000 0000000 00000004120 12744441327 016777  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package Locale::Codes::LangVar;
# Copyright (c) 2011-2014 Sullivan Beck
# This program is free software; you can redistribute it and/or modify it
# under the same terms as Perl itself.

use strict;
require 5.006;
use warnings;

require Exporter;
use Carp;
use Locale::Codes;
use Locale::Codes::Constants;
use Locale::Codes::LangVar_Codes;
use Locale::Codes::LangVar_Retired;

#=======================================================================
#       Public Global Variables
#=======================================================================

our($VERSION,@ISA,@EXPORT,@EXPORT_OK);

$VERSION='3.30';
@ISA       = qw(Exporter);
@EXPORT    = qw(code2langvar
                langvar2code
                all_langvar_codes
                all_langvar_names
                langvar_code2code
                LOCALE_LANGVAR_ALPHA
               );

sub code2langvar {
   return Locale::Codes::_code2name('langvar',@_);
}

sub langvar2code {
   return Locale::Codes::_name2code('langvar',@_);
}

sub langvar_code2code {

   return Locale::Codes::_code2code('langvar',@_);
}

sub all_langvar_codes {
   return Locale::Codes::_all_codes('langvar',@_);
}

sub all_langvar_names {
   return Locale::Codes::_all_names('langvar',@_);
}

sub rename_langvar {
   return Locale::Codes::_rename('langvar',@_);
}

sub add_langvar {
   return Locale::Codes::_add_code('langvar',@_);
}

sub delete_langvar {
   return Locale::Codes::_delete_code('langvar',@_);
}

sub add_langvar_alias {
   return Locale::Codes::_add_alias('langvar',@_);
}

sub delete_langvar_alias {
   return Locale::Codes::_delete_alias('langvar',@_);
}

sub rename_langvar_code {
   return Locale::Codes::_rename_code('langvar',@_);
}

sub add_langvar_code_alias {
   return Locale::Codes::_add_code_alias('langvar',@_);
}

sub delete_langvar_code_alias {
   return Locale::Codes::_delete_code_alias('langvar',@_);
}

1;
# Local Variables:
# mode: cperl
# indent-tabs-mode: nil
# cperl-indent-level: 3
# cperl-continued-statement-offset: 2
# cperl-continued-brace-offset: 0
# cperl-brace-offset: 0
# cperl-brace-imaginary-offset: 0
# cperl-label-offset: -2
# End:
                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/share/perl/5.20.2/Locale/Codes/LangVar.pod                                                      0100644 0000000 0000000 00000005502 12744441327 017152  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        =pod

=head1 NAME

Locale::Codes::LangVar - standard codes for language variation identification

=head1 SYNOPSIS

   use Locale::Codes::LangVar;

   $lvar = code2langvar('acm');                 # $lvar gets 'Mesopotamian Arabic'
   $code = langvar2code('Mesopotamian Arabic'); # $code gets 'acm'

   @codes   = all_langvar_codes();
   @names   = all_langvar_names();

=head1 DESCRIPTION

The C<Locale::Codes::LangVar> module provides access to standard codes
used for identifying language variations, such as those as defined in
the IANA language registry.

Most of the routines take an optional additional argument which
specifies the code set to use. If not specified, the default IANA
language registry codes will be used.

=head1 SUPPORTED CODE SETS

There are several different code sets you can use for identifying
language variations. A code set may be specified using either a name, or a
constant that is automatically exported by this module.

For example, the two are equivalent:

   $lvar = code2langvar('arevela','alpha');
   $lvar = code2langvar('arevela',LOCALE_LANGVAR_ALPHA);

The codesets currently supported are:

=over 4

=item B<alpha>

This is the set of alphanumeric codes from the IANA
language registry, such as 'arevela' for Eastern Armenian.

This code set is identified with the symbol C<LOCALE_LANGVAR_ALPHA>.

This is the default code set.

=back

=head1 ROUTINES

=over 4

=item B<code2langvar ( CODE [,CODESET] )>

=item B<langvar2code ( NAME [,CODESET] )>

=item B<langvar_code2code ( CODE ,CODESET ,CODESET2 )>

=item B<all_langvar_codes ( [CODESET] )>

=item B<all_langvar_names ( [CODESET] )>

=item B<Locale::Codes::LangVar::rename_langvar  ( CODE ,NEW_NAME [,CODESET] )>

=item B<Locale::Codes::LangVar::add_langvar  ( CODE ,NAME [,CODESET] )>

=item B<Locale::Codes::LangVar::delete_langvar  ( CODE [,CODESET] )>

=item B<Locale::Codes::LangVar::add_langvar_alias  ( NAME ,NEW_NAME )>

=item B<Locale::Codes::LangVar::delete_langvar_alias  ( NAME )>

=item B<Locale::Codes::LangVar::rename_langvar_code  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangVar::add_langvar_code_alias  ( CODE ,NEW_CODE [,CODESET] )>

=item B<Locale::Codes::LangVar::delete_langvar_code_alias  ( CODE [,CODESET] )>

These routines are all documented in the Locale::Codes::API man page.

=back

=head1 SEE ALSO

=over 4

=item B<Locale::Codes>

The Locale-Codes distribution.

=item B<Locale::Codes::API>

The list of functions supported by this module.

=item B<http://www.iana.org/assignments/language-subtag-registry>

The IANA language subtag registry.

=back

=head1 AUTHOR

See Locale::Codes for full author history.

Currently maintained by Sullivan Beck (sbeck@cpan.org).

=head1 COPYRIGHT

   Copyright (c) 2011-2014 Sullivan Beck

This module is free software; you can redistribute it and/or
modify it under the same terms as Perl itself.

=cut
                                                                                                                                                                                              usr/share/perl/5.20.2/Locale/Codes/LangVar_Codes.pm                                                 0100644 0000000 0000000 00000042541 12744441327 020125  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package #
Locale::Codes::LangVar_Codes;

# This file was automatically generated.  Any changes to this file will
# be lost the next time 'harvest_data' is run.
#    Generated on: Thu Feb 27 15:45:55 EST 2014

use strict;
require 5.006;
use warnings;
use utf8;

our($VERSION);
$VERSION='3.30';

$Locale::Codes::Data{'langvar'}{'id'} = '0067';

$Locale::Codes::Data{'langvar'}{'id2names'} = {
   q(0001) => [
      q(Late Middle French (to 1606)),
      ],
   q(0002) => [
      q(Early Modern French),
      ],
   q(0003) => [
      q(Traditional German orthography),
      ],
   q(0004) => [
      q("Academic" ("governmental") variant of Belarusian as),
      q("Academic" ("governmental") variant of Belarusian as),
      ],
   q(0005) => [
      q(Standardized Resian orthography),
      ],
   q(0006) => [
      q(German orthography of 1996),
      ],
   q(0007) => [
      q(ALA-LC Romanization, 1997 edition),
      ],
   q(0008) => [
      q(Aluku dialect),
      q(Boni dialect),
      ],
   q(0009) => [
      q(Eastern Armenian),
      ],
   q(0010) => [
      q(Western Armenian),
      ],
   q(0011) => [
      q(Unified Turkic Latin Alphabet (Historical)),
      ],
   q(0012) => [
      q(The Balanka dialect of Anii),
      ],
   q(0013) => [
      q(The Barlavento dialect group of Kabuverdianu),
      ],
   q(0014) => [
      q(Buddhist Hybrid Sanskrit),
      ],
   q(0015) => [
      q(Biscayan dialect of Basque),
      ],
   q(0016) => [
      q(The San Giorgio dialect of Resian),
      q(The Bila dialect of Resian),
      ],
   q(0017) => [
      q(Slovene in Bohoric alphabet),
      ],
   q(0018) => [
      q(Boontling),
      ],
   q(0019) => [
      q(Slovene in Dajnko alphabet),
      ],
   q(0020) => [
      q(Serbian with Ekavian pronunciation),
      ],
   q(0021) => [
      q(Early Modern English (1500-1700)),
      ],
   q(0022) => [
      q(International Phonetic Alphabet),
      ],
   q(0023) => [
      q(Uralic Phonetic Alphabet),
      ],
   q(0024) => [
      q(X-SAMPA transcription),
      ],
   q(0025) => [
      q(Hepburn romanization),
      ],
   q(0026) => [
      q(Norwegian in Hognorsk (High Norwegian) orthography),
      ],
   q(0027) => [
      q(Serbian with Ijekavian pronunciation),
      ],
   q(0028) => [
      q(Epic Sanskrit),
      ],
   q(0029) => [
      q(Jauer dialect of Romansh),
      ],
   q(0030) => [
      q(Jyutping Cantonese Romanization),
      ],
   q(0031) => [
      q(Common Cornish orthography of Revived Cornish),
      ],
   q(0032) => [
      q(Standard Cornish orthography of Revived Cornish),
      q(Kernowek Standard),
      ],
   q(0033) => [
      q(Classical Sanskrit),
      ],
   q(0034) => [
      q(The Lipovaz dialect of Resian),
      q(The Lipovec dialect of Resian),
      ],
   q(0035) => [
      q(Post-1917 Russian orthography),
      ],
   q(0036) => [
      q(Slovene in Metelko alphabet),
      ],
   q(0037) => [
      q(Monotonic Greek),
      ],
   q(0038) => [
      q(Ndyuka dialect),
      q(Aukan dialect),
      ],
   q(0039) => [
      q(Natisone dialect),
      q(Nadiza dialect),
      ],
   q(0040) => [
      q(The Gniva dialect of Resian),
      q(The Njiva dialect of Resian),
      ],
   q(0041) => [
      q(Volapuk nulik),
      q(Volapuk perevidol),
      q(Volapuk nuladik),
      q(de Jong's Volapuk),
      q(New Volapuk),
      q(Revised Volapuk),
      q(Modern Volapuk),
      ],
   q(0042) => [
      q(The Oseacco dialect of Resian),
      q(The Osojane dialect of Resian),
      ],
   q(0043) => [
      q(Pamaka dialect),
      ],
   q(0044) => [
      q(Petrine orthography),
      ],
   q(0045) => [
      q(Pinyin romanization),
      ],
   q(0046) => [
      q(Polytonic Greek),
      ],
   q(0047) => [
      q(Puter idiom of Romansh),
      ],
   q(0048) => [
      q(Volapuk rigik),
      q(Schleyer's Volapuk),
      q(Original Volapuk),
      q(Classic Volapuk),
      ],
   q(0049) => [
      q(Resian),
      q(Resianic),
      q(Rezijan),
      ],
   q(0050) => [
      q(Rumantsch Grischun),
      ],
   q(0051) => [
      q(Scottish Standard English),
      ],
   q(0052) => [
      q(Scouse),
      ],
   q(0053) => [
      q(The Stolvizza dialect of Resian),
      q(The Solbica dialect of Resian),
      ],
   q(0054) => [
      q(The Sotavento dialect group of Kabuverdianu),
      ],
   q(0055) => [
      q(Surmiran idiom of Romansh),
      ],
   q(0056) => [
      q(Sursilvan idiom of Romansh),
      ],
   q(0057) => [
      q(Sutsilvan idiom of Romansh),
      ],
   q(0058) => [
      q(Belarusian in Taraskievica orthography),
      ],
   q(0059) => [
      q(Unified Cornish orthography of Revived Cornish),
      ],
   q(0060) => [
      q(Unified Cornish Revised orthography of Revived Cornish),
      ],
   q(0061) => [
      q(Ulster dialect of Scots),
      ],
   q(0062) => [
      q(Unifon phonetic alphabet),
      ],
   q(0063) => [
      q(Vedic Sanskrit),
      ],
   q(0064) => [
      q(Valencian),
      ],
   q(0065) => [
      q(Vallader idiom of Romansh),
      ],
   q(0066) => [
      q(Wade-Giles romanization),
      ],
};

$Locale::Codes::Data{'langvar'}{'alias2id'} = {
   q("academic" ("governmental") variant of belarusian as) => [
      q(0004),
      q(1),
      ],
   q(ala-lc romanization, 1997 edition) => [
      q(0007),
      q(0),
      ],
   q(aluku dialect) => [
      q(0008),
      q(0),
      ],
   q(aukan dialect) => [
      q(0038),
      q(1),
      ],
   q(belarusian in taraskievica orthography) => [
      q(0058),
      q(0),
      ],
   q(biscayan dialect of basque) => [
      q(0015),
      q(0),
      ],
   q(boni dialect) => [
      q(0008),
      q(1),
      ],
   q(boontling) => [
      q(0018),
      q(0),
      ],
   q(buddhist hybrid sanskrit) => [
      q(0014),
      q(0),
      ],
   q(classic volapuk) => [
      q(0048),
      q(3),
      ],
   q(classical sanskrit) => [
      q(0033),
      q(0),
      ],
   q(common cornish orthography of revived cornish) => [
      q(0031),
      q(0),
      ],
   q(de jong's volapuk) => [
      q(0041),
      q(3),
      ],
   q(early modern english (1500-1700)) => [
      q(0021),
      q(0),
      ],
   q(early modern french) => [
      q(0002),
      q(0),
      ],
   q(eastern armenian) => [
      q(0009),
      q(0),
      ],
   q(epic sanskrit) => [
      q(0028),
      q(0),
      ],
   q(german orthography of 1996) => [
      q(0006),
      q(0),
      ],
   q(hepburn romanization) => [
      q(0025),
      q(0),
      ],
   q(international phonetic alphabet) => [
      q(0022),
      q(0),
      ],
   q(jauer dialect of romansh) => [
      q(0029),
      q(0),
      ],
   q(jyutping cantonese romanization) => [
      q(0030),
      q(0),
      ],
   q(kernowek standard) => [
      q(0032),
      q(1),
      ],
   q(late middle french (to 1606)) => [
      q(0001),
      q(0),
      ],
   q(modern volapuk) => [
      q(0041),
      q(6),
      ],
   q(monotonic greek) => [
      q(0037),
      q(0),
      ],
   q(nadiza dialect) => [
      q(0039),
      q(1),
      ],
   q(natisone dialect) => [
      q(0039),
      q(0),
      ],
   q(ndyuka dialect) => [
      q(0038),
      q(0),
      ],
   q(new volapuk) => [
      q(0041),
      q(4),
      ],
   q(norwegian in hognorsk (high norwegian) orthography) => [
      q(0026),
      q(0),
      ],
   q(original volapuk) => [
      q(0048),
      q(2),
      ],
   q(pamaka dialect) => [
      q(0043),
      q(0),
      ],
   q(petrine orthography) => [
      q(0044),
      q(0),
      ],
   q(pinyin romanization) => [
      q(0045),
      q(0),
      ],
   q(polytonic greek) => [
      q(0046),
      q(0),
      ],
   q(post-1917 russian orthography) => [
      q(0035),
      q(0),
      ],
   q(puter idiom of romansh) => [
      q(0047),
      q(0),
      ],
   q(resian) => [
      q(0049),
      q(0),
      ],
   q(resianic) => [
      q(0049),
      q(1),
      ],
   q(revised volapuk) => [
      q(0041),
      q(5),
      ],
   q(rezijan) => [
      q(0049),
      q(2),
      ],
   q(rumantsch grischun) => [
      q(0050),
      q(0),
      ],
   q(schleyer's volapuk) => [
      q(0048),
      q(1),
      ],
   q(scottish standard english) => [
      q(0051),
      q(0),
      ],
   q(scouse) => [
      q(0052),
      q(0),
      ],
   q(serbian with ekavian pronunciation) => [
      q(0020),
      q(0),
      ],
   q(serbian with ijekavian pronunciation) => [
      q(0027),
      q(0),
      ],
   q(slovene in bohoric alphabet) => [
      q(0017),
      q(0),
      ],
   q(slovene in dajnko alphabet) => [
      q(0019),
      q(0),
      ],
   q(slovene in metelko alphabet) => [
      q(0036),
      q(0),
      ],
   q(standard cornish orthography of revived cornish) => [
      q(0032),
      q(0),
      ],
   q(standardized resian orthography) => [
      q(0005),
      q(0),
      ],
   q(surmiran idiom of romansh) => [
      q(0055),
      q(0),
      ],
   q(sursilvan idiom of romansh) => [
      q(0056),
      q(0),
      ],
   q(sutsilvan idiom of romansh) => [
      q(0057),
      q(0),
      ],
   q(the balanka dialect of anii) => [
      q(0012),
      q(0),
      ],
   q(the barlavento dialect group of kabuverdianu) => [
      q(0013),
      q(0),
      ],
   q(the bila dialect of resian) => [
      q(0016),
      q(1),
      ],
   q(the gniva dialect of resian) => [
      q(0040),
      q(0),
      ],
   q(the lipovaz dialect of resian) => [
      q(0034),
      q(0),
      ],
   q(the lipovec dialect of resian) => [
      q(0034),
      q(1),
      ],
   q(the njiva dialect of resian) => [
      q(0040),
      q(1),
      ],
   q(the oseacco dialect of resian) => [
      q(0042),
      q(0),
      ],
   q(the osojane dialect of resian) => [
      q(0042),
      q(1),
      ],
   q(the san giorgio dialect of resian) => [
      q(0016),
      q(0),
      ],
   q(the solbica dialect of resian) => [
      q(0053),
      q(1),
      ],
   q(the sotavento dialect group of kabuverdianu) => [
      q(0054),
      q(0),
      ],
   q(the stolvizza dialect of resian) => [
      q(0053),
      q(0),
      ],
   q(traditional german orthography) => [
      q(0003),
      q(0),
      ],
   q(ulster dialect of scots) => [
      q(0061),
      q(0),
      ],
   q(unified cornish orthography of revived cornish) => [
      q(0059),
      q(0),
      ],
   q(unified cornish revised orthography of revived cornish) => [
      q(0060),
      q(0),
      ],
   q(unified turkic latin alphabet (historical)) => [
      q(0011),
      q(0),
      ],
   q(unifon phonetic alphabet) => [
      q(0062),
      q(0),
      ],
   q(uralic phonetic alphabet) => [
      q(0023),
      q(0),
      ],
   q(valencian) => [
      q(0064),
      q(0),
      ],
   q(vallader idiom of romansh) => [
      q(0065),
      q(0),
      ],
   q(vedic sanskrit) => [
      q(0063),
      q(0),
      ],
   q(volapuk nuladik) => [
      q(0041),
      q(2),
      ],
   q(volapuk nulik) => [
      q(0041),
      q(0),
      ],
   q(volapuk perevidol) => [
      q(0041),
      q(1),
      ],
   q(volapuk rigik) => [
      q(0048),
      q(0),
      ],
   q(wade-giles romanization) => [
      q(0066),
      q(0),
      ],
   q(western armenian) => [
      q(0010),
      q(0),
      ],
   q(x-sampa transcription) => [
      q(0024),
      q(0),
      ],
};

$Locale::Codes::Data{'langvar'}{'code2id'} = {
   q(alpha) => {
      q(1606nict) => [
         q(0001),
         q(0),
         ],
      q(1694acad) => [
         q(0002),
         q(0),
         ],
      q(1901) => [
         q(0003),
         q(0),
         ],
      q(1959acad) => [
         q(0004),
         q(0),
         ],
      q(1994) => [
         q(0005),
         q(0),
         ],
      q(1996) => [
         q(0006),
         q(0),
         ],
      q(alalc97) => [
         q(0007),
         q(0),
         ],
      q(aluku) => [
         q(0008),
         q(0),
         ],
      q(arevela) => [
         q(0009),
         q(0),
         ],
      q(arevmda) => [
         q(0010),
         q(0),
         ],
      q(baku1926) => [
         q(0011),
         q(0),
         ],
      q(balanka) => [
         q(0012),
         q(0),
         ],
      q(barla) => [
         q(0013),
         q(0),
         ],
      q(bauddha) => [
         q(0014),
         q(0),
         ],
      q(biscayan) => [
         q(0015),
         q(0),
         ],
      q(biske) => [
         q(0016),
         q(0),
         ],
      q(bohoric) => [
         q(0017),
         q(0),
         ],
      q(boont) => [
         q(0018),
         q(0),
         ],
      q(dajnko) => [
         q(0019),
         q(0),
         ],
      q(ekavsk) => [
         q(0020),
         q(0),
         ],
      q(emodeng) => [
         q(0021),
         q(0),
         ],
      q(fonipa) => [
         q(0022),
         q(0),
         ],
      q(fonupa) => [
         q(0023),
         q(0),
         ],
      q(fonxsamp) => [
         q(0024),
         q(0),
         ],
      q(hepburn) => [
         q(0025),
         q(0),
         ],
      q(hognorsk) => [
         q(0026),
         q(0),
         ],
      q(ijekavsk) => [
         q(0027),
         q(0),
         ],
      q(itihasa) => [
         q(0028),
         q(0),
         ],
      q(jauer) => [
         q(0029),
         q(0),
         ],
      q(jyutping) => [
         q(0030),
         q(0),
         ],
      q(kkcor) => [
         q(0031),
         q(0),
         ],
      q(kscor) => [
         q(0032),
         q(0),
         ],
      q(laukika) => [
         q(0033),
         q(0),
         ],
      q(lipaw) => [
         q(0034),
         q(0),
         ],
      q(luna1918) => [
         q(0035),
         q(0),
         ],
      q(metelko) => [
         q(0036),
         q(0),
         ],
      q(monoton) => [
         q(0037),
         q(0),
         ],
      q(ndyuka) => [
         q(0038),
         q(0),
         ],
      q(nedis) => [
         q(0039),
         q(0),
         ],
      q(njiva) => [
         q(0040),
         q(0),
         ],
      q(nulik) => [
         q(0041),
         q(0),
         ],
      q(osojs) => [
         q(0042),
         q(0),
         ],
      q(pamaka) => [
         q(0043),
         q(0),
         ],
      q(petr1708) => [
         q(0044),
         q(0),
         ],
      q(pinyin) => [
         q(0045),
         q(0),
         ],
      q(polyton) => [
         q(0046),
         q(0),
         ],
      q(puter) => [
         q(0047),
         q(0),
         ],
      q(rigik) => [
         q(0048),
         q(0),
         ],
      q(rozaj) => [
         q(0049),
         q(0),
         ],
      q(rumgr) => [
         q(0050),
         q(0),
         ],
      q(scotland) => [
         q(0051),
         q(0),
         ],
      q(scouse) => [
         q(0052),
         q(0),
         ],
      q(solba) => [
         q(0053),
         q(0),
         ],
      q(sotav) => [
         q(0054),
         q(0),
         ],
      q(surmiran) => [
         q(0055),
         q(0),
         ],
      q(sursilv) => [
         q(0056),
         q(0),
         ],
      q(sutsilv) => [
         q(0057),
         q(0),
         ],
      q(tarask) => [
         q(0058),
         q(0),
         ],
      q(uccor) => [
         q(0059),
         q(0),
         ],
      q(ucrcor) => [
         q(