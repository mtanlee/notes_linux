h digits
to completely fill the given bit vector, the previous contents of the
bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.
.Sp
(In fact they are ignored completely \- they are not even checked for
proper syntax. See also below for more about that.)
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.Sp
If during the process of reading the given string any character is
encountered which is not a hexadecimal digit, a fatal syntax error
ensues (\*(L"input string syntax error\*(R").
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Bin();\*(C'\fR
.Sp
Returns a binary string representing the given bit vector.
.Sp
Example:
.Sp
.Vb 4
\&  $vector = Bit::Vector\->new(8);
\&  $vector\->Primes();
\&  $string = $vector\->to_Bin();
\&  print "\*(Aq$string\*(Aq\en";
.Ve
.Sp
This prints:
.Sp
.Vb 1
\&  \*(Aq10101100\*(Aq
.Ve
.Sp
(Bits #7, #5, #3 and #2 are set.)
.Sp
Note that the \fB\s-1LEAST\s0\fR significant bit is located at the \fB\s-1RIGHT\s0\fR
end of the resulting string, and the \fB\s-1MOST\s0\fR significant bit at
the \fB\s-1LEFT\s0\fR end.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Bin($string);\*(C'\fR
.Sp
This method allows you to read in the contents of a bit vector from a
binary string, such as returned by the method "\f(CW\*(C`to_Bin()\*(C'\fR" (see above).
.Sp
Note that this method assumes that the \fB\s-1LEAST\s0\fR significant bit is located at
the \fB\s-1RIGHT\s0\fR end of the binary string, and the \fB\s-1MOST\s0\fR significant bit at the
\&\fB\s-1LEFT\s0\fR end. Therefore, the string is actually read in from right to left
while the bit vector is filled accordingly, one bit at a time, starting with
the least significant bit and going upward to the most significant bit.
.Sp
If the given string contains less binary digits ("\f(CW0\fR\*(L" and \*(R"\f(CW1\fR") than are
needed to completely fill the given bit vector, the remaining (most significant)
bits are all cleared.
.Sp
This also means that, even if the given string does not contain enough digits
to completely fill the given bit vector, the previous contents of the
bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.
.Sp
(In fact they are ignored completely \- they are not even checked for
proper syntax. See also below for more about that.)
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.Sp
If during the process of reading the given string any character is
encountered which is not either "\f(CW0\fR\*(L" or \*(R"\f(CW1\fR\*(L", a fatal syntax error
ensues (\*(R"input string syntax error").
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Dec();\*(C'\fR
.Sp
This method returns a string representing the contents of the given bit
vector converted to decimal (base \f(CW10\fR).
.Sp
Note that this method assumes the given bit vector to be \fB\s-1SIGNED\s0\fR (and
to contain a number in two's complement binary representation).
.Sp
Consequently, whenever the most significant bit of the given bit vector
is set, the number stored in it is regarded as being \fB\s-1NEGATIVE\s0\fR.
.Sp
The resulting string can be fed into "\f(CW\*(C`from_Dec()\*(C'\fR" (see below) in order
to copy the contents of this bit vector to another one (or to restore the
contents of this one). This is not advisable, though, since this would be
very inefficient (there are much more efficient methods for storing and
copying bit vectors in this module).
.Sp
Note that such conversion from binary to decimal is inherently slow
since the bit vector has to be repeatedly divided by \f(CW10\fR with remainder
until the quotient becomes \f(CW0\fR (each remainder in turn represents a single
decimal digit of the resulting string).
.Sp
This is also true for the implementation of this method in this module,
even though a considerable effort has been made to speed it up: instead of
repeatedly dividing by \f(CW10\fR, the bit vector is repeatedly divided by the
largest power of \f(CW10\fR that will fit into a machine word. The remainder is
then repeatedly divided by \f(CW10\fR using only machine word arithmetics, which
is much faster than dividing the whole bit vector (\*(L"divide and rule\*(R" principle).
.Sp
According to my own measurements, this resulted in an 8\-fold speed increase
over the straightforward approach.
.Sp
Still, conversion to decimal should be used only where absolutely necessary.
.Sp
Keep the resulting string stored in some variable if you need it again,
instead of converting the bit vector all over again.
.Sp
Beware that if you set the configuration for overloaded operators to
\&\*(L"output=decimal\*(R", this method will be called for every bit vector
enclosed in double quotes!
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Dec($string);\*(C'\fR
.Sp
This method allows you to convert a given decimal number, which may be
positive or negative, into two's complement binary representation, which
is then stored in the given bit vector.
.Sp
The decimal number should always be provided as a string, to avoid possible
truncation (due to the limited precision of integers in Perl) or formatting
(due to Perl's use of scientific notation for large numbers), which would
lead to errors.
.Sp
If the binary representation of the given decimal number is too big to fit
into the given bit vector (if the given bit vector does not contain enough
bits to hold it), a fatal \*(L"numeric overflow error\*(R" occurs.
.Sp
If the input string contains other characters than decimal digits (\f(CW\*(C`0\-9\*(C'\fR)
and an optional leading sign ("\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR\*(L"), a fatal \*(R"input string
syntax error" occurs.
.Sp
Beware that large positive numbers which cause the most significant bit to
be set (e.g. \*(L"255\*(R" in a bit vector with 8 bits) will be printed as negative
numbers when converted back to decimal using the method \*(L"\fIto_Dec()\fR\*(R" (e.g.
\&\*(L"\-1\*(R", in our example), because numbers with the most significant bit set
are considered to be negative in two's complement binary representation.
.Sp
Note also that while it is possible to thusly enter negative numbers as
large positive numbers (e.g. \*(L"255\*(R" for \*(L"\-1\*(R" in a bit vector with 8 bits),
the contrary isn't, i.e., you cannot enter \*(L"\-255\*(R" for \*(L"+1\*(R", in our example.
A fatal \*(L"numeric overflow error\*(R" will occur if you try to do so.
.Sp
If possible program abortion is unwanted or intolerable, use
"\f(CW\*(C`eval\*(C'\fR", like this:
.Sp
.Vb 5
\&  eval { $vector\->from_Dec("1152921504606846976"); };
\&  if ($@)
\&  {
\&      # an error occurred
\&  }
.Ve
.Sp
There are four possible error messages:
.Sp
.Vb 1
\&  if ($@ =~ /item is not a string/)
\&
\&  if ($@ =~ /input string syntax error/)
\&
\&  if ($@ =~ /numeric overflow error/)
\&
\&  if ($@ =~ /unable to allocate memory/)
.Ve
.Sp
Note that the conversion from decimal to binary is costly in terms of
processing time, since a lot of multiplications have to be carried out
(in principle, each decimal digit must be multiplied with the binary
representation of the power of \f(CW10\fR corresponding to its position in
the decimal number, i.e., 1, 10, 100, 1000, 10000 and so on).
.Sp
This is not as time consuming as the opposite conversion, from binary
to decimal (where successive divisions have to be carried out, which
are even more expensive than multiplications), but still noticeable.
.Sp
Again (as in the case of "\f(CW\*(C`to_Dec()\*(C'\fR\*(L"), the implementation of this
method in this module uses the principle of \*(R"divide and rule" in order
to speed up the conversion, i.e., as many decimal digits as possible
are first accumulated (converted) in a machine word and only then
stored in the given bit vector.
.Sp
Even so, use this method only where absolutely necessary if speed is
an important consideration in your application.
.Sp
Beware that if you set the configuration for overloaded operators to
\&\*(L"input=decimal\*(R", this method will be called for every scalar operand
you use!
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Enum();\*(C'\fR
.Sp
Converts the given bit vector or set into an enumeration of single
indices and ranges of indices (\*(L".newsrc\*(R" style), representing the
bits that are set ("\f(CW1\fR") in the bit vector.
.Sp
Example:
.Sp
.Vb 7
\&  $vector = Bit::Vector\->new(20);
\&  $vector\->Bit_On(2);
\&  $vector\->Bit_On(3);
\&  $vector\->Bit_On(11);
\&  $vector\->Interval_Fill(5,7);
\&  $vector\->Interval_Fill(13,19);
\&  print "\*(Aq", $vector\->to_Enum(), "\*(Aq\en";
.Ve
.Sp
which prints
.Sp
.Vb 1
\&  \*(Aq2,3,5\-7,11,13\-19\*(Aq
.Ve
.Sp
If the given bit vector is empty, the resulting string will
also be empty.
.Sp
Note, by the way, that the above example can also be written
a little handier, perhaps, as follows:
.Sp
.Vb 4
\&  Bit::Vector\->Configuration("out=enum");
\&  $vector = Bit::Vector\->new(20);
\&  $vector\->Index_List_Store(2,3,5,6,7,11,13,14,15,16,17,18,19);
\&  print "\*(Aq$vector\*(Aq\en";
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Enum($string);\*(C'\fR
.Sp
This method first empties the given bit vector and then tries to
set the bits and ranges of bits specified in the given string.
.Sp
The string "\f(CW$string\fR\*(L" must only contain unsigned integers
or ranges of integers (two unsigned integers separated by a
dash \*(R"\-\*(L"), separated by commas (\*(R",").
.Sp
All other characters are disallowed (including white space!)
and will lead to a fatal \*(L"input string syntax error\*(R".
.Sp
In each range, the first integer (the lower limit of the range)
must always be less than or equal to the second integer (the
upper limit), or a fatal \*(L"minimum > maximum index\*(R" error occurs.
.Sp
All integers must lie in the permitted range for the given
bit vector, i.e., they must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.Sp
If this condition is not met, a fatal \*(L"index out of range\*(R"
error occurs.
.Sp
If possible program abortion is unwanted or intolerable, use
"\f(CW\*(C`eval\*(C'\fR", like this:
.Sp
.Vb 5
\&  eval { $vector\->from_Enum("2,3,5\-7,11,13\-19"); };
\&  if ($@)
\&  {
\&      # an error occurred
\&  }
.Ve
.Sp
There are four possible error messages:
.Sp
.Vb 1
\&  if ($@ =~ /item is not a string/)
\&
\&  if ($@ =~ /input string syntax error/)
\&
\&  if ($@ =~ /index out of range/)
\&
\&  if ($@ =~ /minimum > maximum index/)
.Ve
.Sp
Note that the order of the indices and ranges is irrelevant,
i.e.,
.Sp
.Vb 1
\&  eval { $vector\->from_Enum("11,5\-7,3,13\-19,2"); };
.Ve
.Sp
results in the same vector as in the example above.
.Sp
Ranges and indices may also overlap.
.Sp
This is because each (single) index in the string is passed
to the method "\f(CW\*(C`Bit_On()\*(C'\fR\*(L", internally, and each range to
the method \*(R"\f(CW\*(C`Interval_Fill()\*(C'\fR".
.Sp
This means that the resulting bit vector is just the union
of all the indices and ranges specified in the given string.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_Off($index);\*(C'\fR
.Sp
Clears the bit with index "\f(CW$index\fR" in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_On($index);\*(C'\fR
.Sp
Sets the bit with index "\f(CW$index\fR" in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->bit_flip($index)\*(C'\fR
.Sp
Flips (i.e., complements) the bit with index "\f(CW$index\fR"
in the given vector.
.Sp
Moreover, this method returns the \fB\s-1NEW\s0\fR state of the
bit in question, i.e., it returns "\f(CW0\fR\*(L" if the bit is
cleared or \*(R"\f(CW1\fR" if the bit is set (\fB\s-1AFTER\s0\fR flipping it).
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector\->bit_test($index))\*(C'\fR
.Sp
\&\f(CW\*(C`if ($vector\->contains($index))\*(C'\fR
.Sp
Returns the current state of the bit with index "\f(CW$index\fR\*(L"
in the given vector, i.e., returns \*(R"\f(CW0\fR\*(L" if it is cleared
(in the \*(R"off\*(L" state) or \*(R"\f(CW1\fR\*(L" if it is set (in the \*(R"on" state).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_Copy($index,$bit);\*(C'\fR
.Sp
Sets the bit with index "\f(CW$index\fR\*(L" in the given vector either
to \*(R"\f(CW0\fR\*(L" or \*(R"\f(CW1\fR\*(L" depending on the boolean value \*(R"\f(CW$bit\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->LSB($bit);\*(C'\fR
.Sp
Allows you to set the least significant bit in the given bit
vector to the value given by the boolean parameter "\f(CW$bit\fR".
.Sp
This is a (faster) shortcut for "\f(CW\*(C`$vector\->Bit_Copy(0,$bit);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->MSB($bit);\*(C'\fR
.Sp
Allows you to set the most significant bit in the given bit
vector to the value given by the boolean parameter "\f(CW$bit\fR".
.Sp
This is a (faster) shortcut for
"\f(CW\*(C`$vector\->Bit_Copy($vector\->Size()\-1,$bit);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$bit = $vector\->lsb();\*(C'\fR
.Sp
Returns the least significant bit of the given bit vector.
.Sp
This is a (faster) shortcut for "\f(CW\*(C`$bit = $vector\->bit_test(0);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$bit = $vector\->msb();\*(C'\fR
.Sp
Returns the most significant bit of the given bit vector.
.Sp
This is a (faster) shortcut for
"\f(CW\*(C`$bit = $vector\->bit_test($vector\->Size()\-1);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->rotate_left();\*(C'\fR
.Sp
.Vb 7
\&  carry             MSB           vector:           LSB
\&   out:
\&  +\-\-\-+            +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  |   |  <\-\-\-+\-\-\-  |   |   |   |    ...    |   |   |   |  <\-\-\-+
\&  +\-\-\-+      |     +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+      |
\&             |                                                |
\&             +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->rotate_right();\*(C'\fR
.Sp
.Vb 7
\&          MSB           vector:           LSB            carry
\&                                                          out:
\&         +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+           +\-\-\-+
\&  +\-\-\->  |   |   |   |    ...    |   |   |   |  \-\-\-+\-\-\-> |   |
\&  |      +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+     |     +\-\-\-+
\&  |                                                |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->shift_left($carry_in);\*(C'\fR
.Sp
.Vb 5
\&  carry         MSB           vector:           LSB         carry
\&   out:                                                      in:
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
\&  |   |  <\-\-\-  |   |   |   |    ...    |   |   |   |  <\-\-\-  |   |
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->shift_right($carry_in);\*(C'\fR
.Sp
.Vb 5
\&  carry         MSB           vector:           LSB         carry
\&   in:                                                       out:
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
\&  |   |  \-\-\->  |   |   |   |    ...    |   |   |   |  \-\-\->  |   |
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Move_Left($bits);\*(C'\fR
.Sp
Shifts the given bit vector left by "\f(CW$bits\fR\*(L" bits, i.e., inserts \*(R"\f(CW$bits\fR\*(L"
new bits at the lower end (least significant bit) of the bit vector, moving
all other bits up by \*(R"\f(CW$bits\fR\*(L" places, thereby losing the \*(R"\f(CW$bits\fR" most
significant bits.
.Sp
The inserted new bits are all cleared (set to the \*(L"off\*(R" state).
.Sp
This method does nothing if "\f(CW$bits\fR" is equal to zero.
.Sp
Beware that the whole bit vector is cleared \fB\s-1WITHOUT\s0 \s-1WARNING\s0\fR if
"\f(CW$bits\fR" is greater than or equal to the size of the given bit vector!
.Sp
In fact this method is equivalent to
.Sp
.Vb 1
\&  for ( $i = 0; $i < $bits; $i++ ) { $vector\->shift_left(0); }
.Ve
.Sp
except that it is much more efficient (for "\f(CW$bits\fR" greater than or
equal to the number of bits in a machine word on your system) than
this straightforward approach.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Move_Right($bits);\*(C'\fR
.Sp
Shifts the given bit vector right by "\f(CW$bits\fR\*(L" bits, i.e., deletes the
\&\*(R"\f(CW$bits\fR\*(L" least significant bits of the bit vector, moving all other bits
down by \*(R"\f(CW$bits\fR\*(L" places, thereby creating \*(R"\f(CW$bits\fR" new bits at the upper
end (most significant bit) of the bit vector.
.Sp
These new bits are all cleared (set to the \*(L"off\*(R" state).
.Sp
This method does nothing if "\f(CW$bits\fR" is equal to zero.
.Sp
Beware that the whole bit vector is cleared \fB\s-1WITHOUT\s0 \s-1WARNING\s0\fR if
"\f(CW$bits\fR" is greater than or equal to the size of the given bit vector!
.Sp
In fact this method is equivalent to
.Sp
.Vb 1
\&  for ( $i = 0; $i < $bits; $i++ ) { $vector\->shift_right(0); }
.Ve
.Sp
except that it is much more efficient (for "\f(CW$bits\fR" greater than or
equal to the number of bits in a machine word on your system) than
this straightforward approach.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Insert($offset,$bits);\*(C'\fR
.Sp
This method inserts "\f(CW$bits\fR\*(L" fresh new bits at position \*(R"\f(CW$offset\fR"
in the given bit vector.
.Sp
The "\f(CW$bits\fR\*(L" most significant bits are lost, and all bits starting
with bit number \*(R"\f(CW$offset\fR\*(L" up to and including bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-$bits\-1\*(C'\fR\*(L" are moved up by \*(R"\f(CW$bits\fR" places.
.Sp
The now vacant "\f(CW$bits\fR\*(L" bits starting at bit number \*(R"\f(CW$offset\fR\*(L"
(up to and including bit number \*(R"\f(CW\*(C`$offset+$bits\-1\*(C'\fR") are then set
to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR increase the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR extended at its upper end to
\&\*(L"rescue\*(R" the "\f(CW$bits\fR" uppermost (most significant) bits \- instead,
these bits are lost forever.
.Sp
If you don't want this to happen, you have to increase the size of the
given bit vector \fB\s-1EXPLICITLY\s0\fR and \fB\s-1BEFORE\s0\fR you perform the \*(L"Insert\*(R"
operation, with a statement such as the following:
.Sp
.Vb 1
\&  $vector\->Resize($vector\->Size() + $bits);
.Ve
.Sp
Or use the method "\f(CW\*(C`Interval_Substitute()\*(C'\fR\*(L" instead of \*(R"\f(CW\*(C`Insert()\*(C'\fR",
which performs automatic growing and shrinking of its target bit vector.
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $bits\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
all the bits starting with bit number \*(R"\f(CW$offset\fR\*(L" up to bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Delete($offset,$bits);\*(C'\fR
.Sp
This method deletes, i.e., removes the bits starting at position
"\f(CW$offset\fR\*(L" up to and including bit number \*(R"\f(CW\*(C`$offset+$bits\-1\*(C'\fR"
from the given bit vector.
.Sp
The remaining uppermost bits (starting at position "\f(CW\*(C`$offset+$bits\*(C'\fR\*(L"
up to and including bit number \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L") are moved
down by \*(R"\f(CW$bits\fR" places.
.Sp
The now vacant uppermost (most significant) "\f(CW$bits\fR" bits are then
set to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR decrease the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR clipped at its upper end to
\&\*(L"get rid of\*(R" the vacant "\f(CW$bits\fR" uppermost bits.
.Sp
If you don't want this, i.e., if you want the bit vector to shrink
accordingly, you have to do so \fB\s-1EXPLICITLY\s0\fR and \fB\s-1AFTER\s0\fR the \*(L"Delete\*(R"
operation, with a couple of statements such as these:
.Sp
.Vb 3
\&  $size = $vector\->Size();
\&  if ($bits > $size) { $bits = $size; }
\&  $vector\->Resize($size \- $bits);
.Ve
.Sp
Or use the method "\f(CW\*(C`Interval_Substitute()\*(C'\fR\*(L" instead of \*(R"\f(CW\*(C`Delete()\*(C'\fR",
which performs automatic growing and shrinking of its target bit vector.
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $bits\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
all the bits starting with bit number \*(R"\f(CW$offset\fR\*(L" up to bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vector\->increment();\*(C'\fR
.Sp
This method increments the given bit vector.
.Sp
Note that this method regards bit vectors as being unsigned,
i.e., the largest possible positive number is directly
followed by the smallest possible (or greatest possible,
speaking in absolute terms) negative number:
.Sp
.Vb 2
\&  before:  2 ^ (b\-1) \- 1    (= "0111...1111")
\&  after:   2 ^ (b\-1)        (= "1000...0000")
.Ve
.Sp
where "\f(CW\*(C`b\*(C'\fR" is the number of bits of the given bit vector.
.Sp
The method returns \*(L"false\*(R" ("\f(CW0\fR\*(L") in all cases except when a
carry over occurs (in which case it returns \*(R"true\*(L", i.e., \*(R"\f(CW1\fR\*(L"),
which happens when the number \*(R"1111...1111\*(L" is incremented,
which gives \*(R"0000...0000" plus a carry over to the next higher
(binary) digit.
.Sp
This can be used for the terminating condition of a \*(L"while\*(R" loop,
for instance, in order to cycle through all possible values the
bit vector can assume.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vector\->decrement();\*(C'\fR
.Sp
This method decrements the given bit vector.
.Sp
Note that this method regards bit vectors as being unsigned,
i.e., the smallest possible (or greatest possible, speaking
in absolute terms) negative number is directly followed by
the largest possible positive number:
.Sp
.Vb 2
\&  before:  2 ^ (b\-1)        (= "1000...0000")
\&  after:   2 ^ (b\-1) \- 1    (= "0111...1111")
.Ve
.Sp
where "\f(CW\*(C`b\*(C'\fR" is the number of bits of the given bit vector.
.Sp
The method returns \*(L"false\*(R" ("\f(CW0\fR\*(L") in all cases except when a
carry over occurs (in which case it returns \*(R"true\*(L", i.e., \*(R"\f(CW1\fR\*(L"),
which happens when the number \*(R"0000...0000\*(L" is decremented,
which gives \*(R"1111...1111" minus a carry over to the next higher
(binary) digit.
.Sp
This can be used for the terminating condition of a \*(L"while\*(R" loop,
for instance, in order to cycle through all possible values the
bit vector can assume.
.IP "\(bu" 2
\&\f(CW\*(C`$overflow = $vec2\->inc($vec1);\*(C'\fR
.Sp
This method copies the contents of bit vector "\f(CW$vec1\fR\*(L" to bit
vector \*(R"\f(CW$vec2\fR" and increments the copy (not the original).
.Sp
If by incrementing the number its sign becomes invalid, the return
value (\*(L"overflow\*(R" flag) will be true ("\f(CW1\fR\*(L"), or false (\*(R"\f(CW0\fR\*(L")
if not. (See the description of the method \*(R"\fIadd()\fR\*(L" below for
a more in-depth explanation of what \*(R"overflow" means).
.Sp
Note that in-place operation is also possible, i.e., "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR" may be identical.
.IP "\(bu" 2
\&\f(CW\*(C`$overflow = $vec2\->dec($vec1);\*(C'\fR
.Sp
This method copies the contents of bit vector "\f(CW$vec1\fR\*(L" to bit
vector \*(R"\f(CW$vec2\fR" and decrements the copy (not the original).
.Sp
If by decrementing the number its sign becomes invalid, the return
value (\*(L"overflow\*(R" flag) will be true ("\f(CW1\fR\*(L"), or false (\*(R"\f(CW0\fR\*(L")
if not. (See the description of the method \*(R"\fIsubtract()\fR\*(L" below
for a more in-depth explanation of what \*(R"overflow" means).
.Sp
Note that in-place operation is also possible, i.e., "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR" may be identical.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vec3\->add($vec1,$vec2,$carry);\*(C'\fR
.Sp
\&\f(CW\*(C`($carry,$overflow) = $vec3\->add($vec1,$vec2,$carry);\*(C'\fR
.Sp
This method adds the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" with carry \*(R"\f(CW$carry\fR\*(L" and stores the result in
bit vector \*(R"\f(CW$vec3\fR".
.Sp
I.e.,
            \f(CW$vec3\fR = \f(CW$vec1\fR + \f(CW$vec2\fR + \f(CW$carry\fR
.Sp
Note that the "\f(CW$carry\fR\*(L" parameter is a boolean value, i.e.,
only its least significant bit is taken into account. (Think of
it as though \*(R"\f(CW\*(C`$carry &= 1;\*(C'\fR" was always executed internally.)
.Sp
In scalar context, the method returns a boolean value which
indicates if a carry over (to the next higher bit position)
has occured. In list context, the method returns the carry
and the overflow flag (in this order).
.Sp
The overflow flag is true ("\f(CW1\fR") if the sign (i.e., the most
significant bit) of the result is wrong. This can happen when
adding two very large positive numbers or when adding two (by
their absolute value) very large negative numbers. See also
further below.
.Sp
The carry in\- and output is needed mainly for cascading, i.e.,
to add numbers that are fragmented into several pieces.
.Sp
Example:
.Sp
.Vb 1
\&  # initialize
\&
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $a[$i] = Bit::Vector\->new($bits);
\&      $b[$i] = Bit::Vector\->new($bits);
\&      $c[$i] = Bit::Vector\->new($bits);
\&  }
\&
\&  # fill @a and @b
\&
\&  # $a[  0 ] is low order part,
\&  # $a[$n\-1] is high order part,
\&  # and same for @b
\&
\&  # add
\&
\&  $carry = 0;
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $carry = $c[$i]\->add($a[$i],$b[$i],$carry);
\&  }
.Ve
.Sp
Note that it makes no difference to this method whether the numbers
in "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" are unsigned or signed (i.e., in two's
complement binary representation).
.Sp
Note however that the return value (carry flag) is not meaningful
when the numbers are \fB\s-1SIGNED\s0\fR.
.Sp
Moreover, when the numbers are signed, a special type of error can
occur which is commonly called an \*(L"overflow error\*(R".
.Sp
An overflow error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry over
from the next-lower bit position (\*(L"\s-1MSB\-1\s0\*(R").
.Sp
In fact matters are a bit more complicated than that: the overflow
flag is set to \*(L"true\*(R" whenever there is a carry over from bit
position \s-1MSB\-1\s0 to the most significant bit (\s-1MSB\s0) but no carry
over from the \s-1MSB\s0 to the output carry flag, or vice-versa, i.e.,
when there is no carry over from bit position \s-1MSB\-1\s0 to the most
significant bit (\s-1MSB\s0) but a carry over to the output carry flag.
.Sp
Thus the overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most significant
bit position.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vec3\->subtract($vec1,$vec2,$carry);\*(C'\fR
.Sp
\&\f(CW\*(C`($carry,$overflow) = $vec3\->subtract($vec1,$vec2,$carry);\*(C'\fR
.Sp
This method subtracts the two numbers contained in bit vector
"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR\*(L" with carry \*(R"\f(CW$carry\fR\*(L" and stores the
result in bit vector \*(R"\f(CW$vec3\fR".
.Sp
I.e.,
            \f(CW$vec3\fR = \f(CW$vec1\fR \- \f(CW$vec2\fR \- \f(CW$carry\fR
.Sp
Note that the "\f(CW$carry\fR\*(L" parameter is a boolean value, i.e.,
only its least significant bit is taken into account. (Think of
it as though \*(R"\f(CW\*(C`$carry &= 1;\*(C'\fR" was always executed internally.)
.Sp
In scalar context, the method returns a boolean value which
indicates if a carry over (to the next higher bit position)
has occured. In list context, the method returns the carry
and the overflow flag (in this order).
.Sp
The overflow flag is true ("\f(CW1\fR") if the sign (i.e., the most
significant bit) of the result is wrong. This can happen when
subtracting a very large negative number from a very large
positive number or vice-versa. See also further below.
.Sp
The carry in\- and output is needed mainly for cascading, i.e.,
to subtract numbers that are fragmented into several pieces.
.Sp
Example:
.Sp
.Vb 1
\&  # initialize
\&
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $a[$i] = Bit::Vector\->new($bits);
\&      $b[$i] = Bit::Vector\->new($bits);
\&      $c[$i] = Bit::Vector\->new($bits);
\&  }
\&
\&  # fill @a and @b
\&
\&  # $a[  0 ] is low order part,
\&  # $a[$n\-1] is high order part,
\&  # and same for @b
\&
\&  # subtract
\&
\&  $carry = 0;
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $carry = $c[$i]\->subtract($a[$i],$b[$i],$carry);
\&  }
.Ve
.Sp
Note that it makes no difference to this method whether the numbers
in "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" are unsigned or signed (i.e., in two's
complement binary representation).
.Sp
Note however that the return value (carry flag) is not meaningful
when the numbers are \fB\s-1SIGNED\s0\fR.
.Sp
Moreover, when the numbers are signed, a special type of error can
occur which is commonly called an \*(L"overflow error\*(R".
.Sp
An overflow error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry over
from the next-lower bit position (\*(L"\s-1MSB\-1\s0\*(R").
.Sp
In fact matters are a bit more complicated than that: the overflow
flag is set to \*(L"true\*(R" whenever there is a carry over from bit
position \s-1MSB\-1\s0 to the most significant bit (\s-1MSB\s0) but no carry
over from the \s-1MSB\s0 to the output carry flag, or vice-versa, i.e.,
when there is no carry over from bit position \s-1MSB\-1\s0 to the most
significant bit (\s-1MSB\s0) but a carry over to the output carry flag.
.Sp
Thus the overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most significant
bit position.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Neg($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$vec2\->Negate($vec1);\*(C'\fR
.Sp
This method calculates the two's complement of the number in bit
vector "\f(CW$vec1\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec2\fR".
.Sp
Calculating the two's complement of a given number in binary representation
consists of inverting all bits and incrementing the result by one.
.Sp
This is the same as changing the sign of the given number from "\f(CW\*(C`+\*(C'\fR\*(L" to
\&\*(R"\f(CW\*(C`\-\*(C'\fR" or vice-versa. In other words, applying this method twice on a given
number yields the original number again.
.Sp
Note that in-place processing is also possible, i.e., "\f(CW$vec1\fR\*(L" and
\&\*(R"\f(CW$vec2\fR" may be identical.
.Sp
Most importantly, beware that this method produces a counter-intuitive
result if the number contained in bit vector "\f(CW$vec1\fR" is \f(CW\*(C`2 ^ (n\-1)\*(C'\fR
(i.e., \*(L"1000...0000\*(R"), where "\f(CW\*(C`n\*(C'\fR" is the number of bits the given bit
vector contains: The negated value of this number is the number itself!
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Abs($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$vec2\->Absolute($vec1);\*(C'\fR
.Sp
Depending on the sign (i.e., the most significant bit) of the number in
bit vector "\f(CW$vec1\fR\*(L", the contents of bit vector \*(R"\f(CW$vec1\fR\*(L" are copied
to bit vector \*(R"\f(CW$vec2\fR\*(L" either with the method \*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L" (if the number
in bit vector \*(R"\f(CW$vec1\fR\*(L" is positive), or with \*(R"\f(CW\*(C`Negate()\*(C'\fR\*(L" (if the number
in bit vector \*(R"\f(CW$vec1\fR" is negative).
.Sp
In other words, this method calculates the absolute value of the number
in bit vector "\f(CW$vec1\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec2\fR".
.Sp
Note that in-place processing is also possible, i.e., "\f(CW$vec1\fR\*(L" and
\&\*(R"\f(CW$vec2\fR" may be identical.
.Sp
Most importantly, beware that this method produces a counter-intuitive
result if the number contained in bit vector "\f(CW$vec1\fR" is \f(CW\*(C`2 ^ (n\-1)\*(C'\fR
(i.e., \*(L"1000...0000\*(R"), where "\f(CW\*(C`n\*(C'\fR" is the number of bits the given bit
vector contains: The absolute value of this number is the number itself,
even though this number is still negative by definition (the most
significant bit is still set)!
.IP "\(bu" 2
\&\f(CW\*(C`$sign = $vector\->Sign();\*(C'\fR
.Sp
This method returns "\f(CW0\fR\*(L" if all bits in the given bit vector are cleared,
i.e., if the given bit vector contains the number \*(R"\f(CW0\fR", or if the given
bit vector has a length of zero (contains no bits at all).
.Sp
If not all bits are cleared, this method returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if the most
significant bit is set (i.e., if the bit vector contains a negative
number), or \*(R"\f(CW1\fR" otherwise (i.e., if the bit vector contains a
positive number).
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Multiply($vec1,$vec2);\*(C'\fR
.Sp
This method multiplies the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec3\fR".
.Sp
Note that this method regards its arguments as \fB\s-1SIGNED\s0\fR.
.Sp
If you want to make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit longer than the
largest number you wish to represent, right from the start, or proceed as
follows:
.Sp
.Vb 8
\&    $msb1 = $vec1\->msb();
\&    $msb2 = $vec2\->msb();
\&    $vec1\->Resize($vec1\->Size()+1);
\&    $vec2\->Resize($vec2\->Size()+1);
\&    $vec3\->Resize($vec3\->Size()+1);
\&    $vec1\->MSB($msb1);
\&    $vec2\->MSB($msb2);
\&    $vec3\->Multiply($vec1,$vec2);
.Ve
.Sp
Note also that all three bit vector arguments must in principle obey the
rule of matching sizes, but that the bit vector "\f(CW$vec3\fR\*(L" may be larger
than the two factors \*(R"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR".
.Sp
In fact multiplying two binary numbers with "\f(CW\*(C`n\*(C'\fR\*(L" bits may yield a result
which is at most \*(R"\f(CW\*(C`2n\*(C'\fR" bits long.
.Sp
Therefore, it is usually a good idea to let bit vector "\f(CW$vec3\fR\*(L" have
twice the size of bit vector \*(R"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR", unless you are
absolutely sure that the result will fit into a bit vector of the same
size as the two factors.
.Sp
If you are wrong, a fatal \*(L"numeric overflow error\*(R" will occur.
.Sp
Finally, note that in-place processing is possible, i.e., "\f(CW$vec3\fR\*(L"
may be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR", or both.
.IP "\(bu" 2
\&\f(CW\*(C`$quot\->Divide($vec1,$vec2,$rest);\*(C'\fR
.Sp
This method divides the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" and stores the quotient in bit vector \*(R"\f(CW$quot\fR\*(L" and
the remainder in bit vector \*(R"\f(CW$rest\fR".
.Sp
I.e.,
            \f(CW$quot\fR = \f(CW$vec1\fR / \f(CW$vec2\fR;  #  div
            \f(CW$rest\fR = \f(CW$vec1\fR % \f(CW$vec2\fR;  #  mod
.Sp
Therefore, "\f(CW$quot\fR\*(L" and \*(R"\f(CW$rest\fR" must be two \fB\s-1DISTINCT\s0\fR bit vectors,
or a fatal \*(L"result vector(s) must be distinct\*(R" error will occur.
.Sp
Note also that a fatal \*(L"division by zero error\*(R" will occur if "\f(CW$vec2\fR"
is equal to zero.
.Sp
Note further that this method regards its arguments as \fB\s-1SIGNED\s0\fR.
.Sp
If you want to make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit longer than the
largest number you wish to represent, right from the start, or proceed as
follows:
.Sp
.Vb 9
\&    $msb1 = $vec1\->msb();
\&    $msb2 = $vec2\->msb();
\&    $vec1\->Resize($vec1\->Size()+1);
\&    $vec2\->Resize($vec2\->Size()+1);
\&    $quot\->Resize($quot\->Size()+1);
\&    $rest\->Resize($rest\->Size()+1);
\&    $vec1\->MSB($msb1);
\&    $vec2\->MSB($msb2);
\&    $quot\->Divide($vec1,$vec2,$rest);
.Ve
.Sp
Finally, note that in-place processing is possible, i.e., "\f(CW$quot\fR\*(L"
may be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR\*(L" or both, and \*(R"\f(CW$rest\fR\*(L"
may also be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR\*(L" or both, as long
as \*(R"\f(CW$quot\fR\*(L" and \*(R"\f(CW$rest\fR" are distinct. (!)
.IP "\(bu" 2
\&\f(CW\*(C`$vecgcd\->GCD($veca,$vecb);\*(C'\fR
.Sp
This method calculates the \*(L"Greatest Common Divisor\*(R" of the two numbers
contained in bit vector "\f(CW$veca\fR\*(L" and \*(R"\f(CW$vecb\fR\*(L" and stores the result
in bit vector \*(R"\f(CW$vecgcd\fR".
.Sp
The method uses Euklid's algorithm internally:
.Sp
.Vb 3
\&    int GCD(int a, int b)
\&    {
\&        int t;
\&
\&        while (b != 0)
\&        {
\&            t = a % b; /* = remainder of (a div b) */
\&            a = b;
\&            b = t;
\&        }
\&        return(a);
\&    }
.Ve
.Sp
Note that \f(CW\*(C`GCD(z,0) == GCD(0,z) == z\*(C'\fR.
.IP "\(bu" 2
\&\f(CW\*(C`$vecgcd\->GCD($vecx,$vecy,$veca,$vecb);\*(C'\fR
.Sp
This variant of the \*(L"\s-1GCD\s0\*(R" method calculates the \*(L"Greatest Common Divisor\*(R"
of the two numbers contained in bit vector "\f(CW$veca\fR\*(L" and \*(R"\f(CW$vecb\fR\*(L" and
stores the result in bit vector \*(R"\f(CW$vecgcd\fR".
.Sp
Moreover, it determines the two factors which are necessary in order to
represent the greatest common divisor as a linear combination of its two
arguments, i.e., the two factors \f(CW"x"\fR and \f(CW"y"\fR so that
\&\f(CW\*(C`GCD(a,b) == x * a + y * b\*(C'\fR, and stores them in bit vector "\f(CW$vecx\fR\*(L"
and \*(R"\f(CW$vecy\fR", respectively.
.Sp
For example:
.Sp
.Vb 2
\&  a = 2322
\&  b =  654
\&
\&  GCD( 2322, 654 ) == 6
\&
\&  x =  20
\&  y = \-71
\&
\&  20 * 2322 \- 71 * 654 == 6
.Ve
.Sp
Please see http://www.cut\-the\-knot.org/blue/extension.shtml
for an explanation of how this extension of Euklid's algorithm works.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Power($vec1,$vec2);\*(C'\fR
.Sp
This method calculates the exponentiation of base "\f(CW$vec1\fR\*(L" elevated to
the \*(R"\f(CW$vec2\fR\*(L" power, i.e., \*(R"\f(CW\*(C`$vec1 ** $vec2\*(C'\fR\*(L", and stores the result
in bit vector \*(R"\f(CW$vec3\fR".
.Sp
The method uses an efficient divide-and-conquer algorithm:
.Sp
Suppose the exponent is (decimal) 13, for example. The binary
representation of this exponent is \*(L"1101\*(R".
.Sp
This means we want to calculate
.Sp
.Vb 3
\&  $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 *
\&  $vec1 * $vec1 * $vec1 * $vec1 *
\&  $vec1
.Ve
.Sp
That is, "\f(CW$vec1\fR" multiplied with itself 13 times. The grouping
into lines above is no coincidence. The first line comprises 8
factors, the second contains 4, and the last line just one. This
just happens to be the binary representation of 13. \f(CW\*(C`;\-)\*(C'\fR
.Sp
We then calculate a series of squares (of squares of squares...) of
the base, i.e.,
.Sp
.Vb 5
\&  $power[0] = $vec1;
\&  $power[1] = $vec1 * $vec1;
\&  $power[2] = $power[1] * $power[1];
\&  $power[3] = $power[2] * $power[2];
\&  etc.
.Ve
.Sp
To calculate the power of our example, we simply initialize our result
with 1 and consecutively multiply it with the items of the series of
powers we just calculated, if the corresponding bit of the binary
representation of the exponent is set:
.Sp
.Vb 6
\&  $result = 1;
\&  $result *= $power[0] if ($vec2 & 1);
\&  $result *= $power[1] if ($vec2 & 2);
\&  $result *= $power[2] if ($vec2 & 4);
\&  $result *= $power[3] if ($vec2 & 8);
\&  etc.
.Ve
.Sp
The bit vector "\f(CW$vec3\fR\*(L" must be of the same size as the base
\&\*(R"\f(CW$vec1\fR\*(L" or greater. \*(R"\f(CW$vec3\fR\*(L" and \*(R"\f(CW$vec1\fR\*(L" may be the same
vector (i.e., in-place calculation as in \*(R"\f(CW\*(C`$vec1 **= $vec2;\*(C'\fR\*(L" is
possible), but \*(R"\f(CW$vec3\fR\*(L" and \*(R"\f(CW$vec2\fR\*(L" must be distinct. Finally,
the exponent \*(R"\f(CW$vec2\fR" must be positive. A fatal error occurs if
any of these conditions is not met.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Block_Store($buffer);\*(C'\fR
.Sp
This method allows you to load the contents of a given bit vector in
one go.
.Sp
This is useful when you store the contents of a bit vector in a file,
for instance (using method "\f(CW\*(C`Block_Read()\*(C'\fR"), and when you want to
restore the previously saved bit vector.
.Sp
For this, "\f(CW$buffer\fR" \fB\s-1MUST\s0\fR be a string (\fB\s-1NO\s0\fR automatic conversion
from numeric to string is provided here as would normally in Perl!)
containing the bit vector in \*(L"low order byte first\*(R" order.
.Sp
If the given string is shorter than what is needed to completely fill
the given bit vector, the remaining (most significant) bytes of the
bit vector are filled with zeros, i.e., the previous contents of the
bit vector are always erased completely.
.Sp
If the given string is longer than what is needed to completely fill
the given bit vector, the superfluous bytes are simply ignored.
.Sp
See \*(L"sysread\*(R" in perlfunc for how to read in the contents of "\f(CW$buffer\fR"
from a file prior to passing it to this method.
.IP "\(bu" 2
\&\f(CW\*(C`$buffer = $vector\->Block_Read();\*(C'\fR
.Sp
This method allows you to export the contents of a given bit vector in
one block.
.Sp
This is useful when you want to save the contents of a bit vector for
later, for instance in a file.
.Sp
The advantage of this method is that it allows you to do so in the
compactest possible format, in binary.
.Sp
The method returns a Perl string which contains an exact copy of the
contents of the given bit vector in \*(L"low order byte first\*(R" order.
.Sp
See \*(L"syswrite\*(R" in perlfunc for how to write the data from this string
to a file.
.IP "\(bu" 2
\&\f(CW\*(C`$size = $vector\->Word_Size();\*(C'\fR
.Sp
Each bit vector is internally organized as an array of machine words.
.Sp
The methods whose names begin with \*(L"Word_\*(R" allow you to access this
internal array of machine words.
.Sp
Note that because the size of a machine word may vary from system to
system, these methods are inherently \fBMACHINE-DEPENDENT\fR!
.Sp
Therefore, \fB\s-1DO\s0 \s-1NOT\s0 \s-1USE\s0\fR these methods unless you are absolutely certain
that portability of your code is not an issue!
.Sp
You have been warned!
.Sp
To be machine-independent, use the methods whose names begin with "\f(CW\*(C`Chunk_\*(C'\fR"
instead, with chunk sizes no greater than 32 bits.
.Sp
The method "\f(CW\*(C`Word_Size()\*(C'\fR" returns the number of machine words that the
internal array of words of the given bit vector contains.
.Sp
This is similar in function to the term "\f(CW\*(C`scalar(@array)\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Store($offset,$word);\*(C'\fR
.Sp
This method allows you to store a given value "\f(CW$word\fR\*(L" at a given
position \*(R"\f(CW$offset\fR" in the internal array of words of the given
bit vector.
.Sp
Note that "\f(CW$offset\fR\*(L" must lie in the permitted range between \*(R"\f(CW0\fR\*(L"
and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`$array[$offset] = $word;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$word = $vector\->Word_Read($offset);\*(C'\fR
.Sp
This method allows you to access the value of a given machine word
at position "\f(CW$offset\fR" in the internal array of words of the given
bit vector.
.Sp
Note that "\f(CW$offset\fR\*(L" must lie in the permitted range between \*(R"\f(CW0\fR\*(L"
and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`$word = $array[$offset];\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_List_Store(@words);\*(C'\fR
.Sp
This method allows you to store a list of values "\f(CW@words\fR" in the
internal array of machine words of the given bit vector.
.Sp
Thereby the \fB\s-1LEFTMOST\s0\fR value in the list ("\f(CW$words[0]\fR") is stored
in the \fB\s-1LEAST\s0\fR significant word of the internal array of words (the
one with offset "\f(CW0\fR\*(L"), the next value from the list (\*(R"\f(CW$words[1]\fR\*(L")
is stored in the word with offset \*(R"\f(CW1\fR", and so on, as intuitively
expected.
.Sp
If the list "\f(CW@words\fR" contains fewer elements than the internal
array of words of the given bit vector contains machine words,
the remaining (most significant) words are filled with zeros.
.Sp
If the list "\f(CW@words\fR" contains more elements than the internal
array of words of the given bit vector contains machine words,
the superfluous values are simply ignored.
.Sp
This method is comparable in function to the expression
"\f(CW\*(C`@array = @words;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`@words = $vector\->Word_List_Read();\*(C'\fR
.Sp
This method allows you to retrieve the internal array of machine
words of the given bit vector all at once.
.Sp
Thereby the \fB\s-1LEFTMOST\s0\fR value in the returned list ("\f(CW$words[0]\fR")
is the \fB\s-1LEAST\s0\fR significant word from the given bit vector, and the
\&\fB\s-1RIGHTMOST\s0\fR value in the returned list ("\f(CW$words[$#words]\fR") is
the \fB\s-1MOST\s0\fR significant word of the given bit vector.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`@words = @array;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Insert($offset,$count);\*(C'\fR
.Sp
This method inserts "\f(CW$count\fR\*(L" empty new machine words at position
\&\*(R"\f(CW$offset\fR" in the internal array of words of the given bit vector.
.Sp
The "\f(CW$count\fR\*(L" most significant words are lost, and all words starting
with word number \*(R"\f(CW$offset\fR\*(L" up to and including word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-$count\-1\*(C'\fR\*(L" are moved up by \*(R"\f(CW$count\fR" places.
.Sp
The now vacant "\f(CW$count\fR\*(L" words starting at word number \*(R"\f(CW$offset\fR\*(L"
(up to and including word number \*(R"\f(CW\*(C`$offset+$count\-1\*(C'\fR") are then set
to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR increase the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR extended at its upper end to
\&\*(L"rescue\*(R" the "\f(CW$count\fR" uppermost (most significant) words \- instead,
these words are lost forever.
.Sp
If you don't want this to happen, you have to increase the size of the
given bit vector \fB\s-1EXPLICITLY\s0\fR and \fB\s-1BEFORE\s0\fR you perform the \*(L"Insert\*(R"
operation, with a statement such as the following:
.Sp
.Vb 1
\&  $vector\->Resize($vector\->Size() + $count * Bit::Vector\->Word_Bits());
.Ve
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out
of range" error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $count\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L",
all the words starting with word number \*(R"\f(CW$offset\fR\*(L" up to word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Delete($offset,$count);\*(C'\fR
.Sp
This method deletes, i.e., removes the words starting at position
"\f(CW$offset\fR\*(L" up to and including word number \*(R"\f(CW\*(C`$offset+$count\-1\*(C'\fR"
from the internal array of machine words of the given bit vector.
.Sp
The remaining uppermost words (starting at position "\f(CW\*(C`$offset+$count\*(C'\fR\*(L"
up to and including word number \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L") are
moved down by \*(R"\f(CW$count\fR" places.
.Sp
The now vacant uppermost (most significant) "\f(CW$count\fR" words are then
set to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR decrease the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR clipped at its upper end to
\&\*(L"get rid of\*(R" the vacant "\f(CW$count\fR" uppermost words.
.Sp
If you don't want this, i.e., if you want the bit vector to shrink
accordingly, you have to do so \fB\s-1EXPLICITLY\s0\fR and \fB\s-1AFTER\s0\fR the \*(L"Delete\*(R"
operation, with a couple of statements such as these:
.Sp
.Vb 4
\&  $bits = $vector\->Size();
\&  $count *= Bit::Vector\->Word_Bits();
\&  if ($count > $bits) { $count = $bits; }
\&  $vector\->Resize($bits \- $count);
.Ve
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out
of range" error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $count\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L",
all the words starting with word number \*(R"\f(CW$offset\fR\*(L" up to word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Chunk_Store($chunksize,$offset,$chunk);\*(C'\fR
.Sp
This method allows you to set more than one bit at a time with
different values.
.Sp
You can access chunks (i.e., ranges of contiguous bits) between
one and at most "\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR" bits wide.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
If the given "\f(CW$chunksize\fR\*(L" does not lie between \*(R"\f(CW1\fR\*(L" and
\&\*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", a fatal \*(R"chunk size out of range"
error will occur.
.Sp
The method copies the "\f(CW$chunksize\fR\*(L" least significant bits
from the value \*(R"\f(CW$chunk\fR\*(L" to the given bit vector, starting at
bit position \*(R"\f(CW$offset\fR\*(L" and proceeding upwards until bit number
\&\*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".
.Sp
(I.e., bit number "\f(CW0\fR\*(L" of \*(R"\f(CW$chunk\fR\*(L" becomes bit number \*(R"\f(CW$offset\fR\*(L"
in the given bit vector, and bit number \*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR\*(L" becomes
bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".)
.Sp
If the term "\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
the corresponding superfluous (most significant) bits from \*(R"\f(CW$chunk\fR"
are simply ignored.
.Sp
Note that "\f(CW$offset\fR\*(L" itself must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method (as well as the other "\f(CW\*(C`Chunk_\*(C'\fR" methods) is useful, for
example, when you are reading in data in chunks of, say, 8 bits, which
you need to access later, say, using 16 bits at a time (like audio \s-1CD\s0
wave files, for instance).
.IP "\(bu" 2
\&\f(CW\*(C`$chunk = $vector\->Chunk_Read($chunksize,$offset);\*(C'\fR
.Sp
This method allows you to read the values of more than one bit at
a time.
.Sp
You can read chunks (i.e., ranges of contiguous bits) between
one and at most "\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR" bits wide.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
If the given "\f(CW$chunksize\fR\*(L" does not lie between \*(R"\f(CW1\fR\*(L" and
\&\*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", a fatal \*(R"chunk size out of range"
error will occur.
.Sp
The method returns the "\f(CW$chunksize\fR\*(L" bits from the given bit vector
starting at bit position \*(R"\f(CW$offset\fR\*(L" and proceeding upwards until
bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".
.Sp
(I.e., bit number "\f(CW$offset\fR\*(L" of the given bit vector becomes bit number
\&\*(R"\f(CW0\fR\*(L" of the returned value, and bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L"
becomes bit number \*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR".)
.Sp
If the term "\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR",
the non-existent bits are simply not returned.
.Sp
Note that "\f(CW$offset\fR\*(L" itself must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Chunk_List_Store($chunksize,@chunks);\*(C'\fR
.Sp
This method allows you to fill the given bit vector with a list of
data packets (\*(L"chunks\*(R") of any size ("\f(CW$chunksize\fR") you like
(within certain limits).
.Sp
In fact the given "\f(CW$chunksize\fR\*(L" must lie in the range between \*(R"\f(CW1\fR\*(L"
and \*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", or a fatal \*(R"chunk size out of
range" error will occur.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
The given bit vector is thereby filled in ascending order: The first
chunk from the list (i.e., "\f(CW$chunks[0]\fR\*(L") fills the \*(R"\f(CW$chunksize\fR\*(L"
least significant bits, the next chunk from the list (\*(R"\f(CW$chunks[1]\fR\*(L")
fills the bits number \*(R"\f(CW$chunksize\fR\*(L" to number \*(R"\f(CW\*(C`2*$chunksize\-1\*(C'\fR\*(L",
the third chunk (\*(R"\f(CW$chunks[2]\fR\*(L") fills the bits number \*(R"\f(CW\*(C`2*$chunksize\*(C'\fR\*(L",
to number \*(R"\f(CW\*(C`3*$chunksize\-1\*(C'\fR", and so on.
.Sp
If there a less chunks in the list than are needed to fill the entire
bit vector, the remaining (most significant) bits are cleared, i.e.,
the previous contents of the given bit vector are always erased completely.
.Sp
If there are more chunks in the list than are needed to fill the entire
bit vector, and/or if a chunk extends beyond "\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L"
(which happens whenever \*(R"\f(CW\*(C`$vector\->Size()\*(C'\fR\*(L" is not a multiple of
\&\*(R"\f(CW$chunksize\fR"), the superfluous chunks and/or bits are simply ignored.
.Sp
The method is useful, for example (and among many other applications),
for the conversion of packet sizes in a data stream.
.Sp
This method can also be used to store an octal string in a given
bit vector:
.Sp
.Vb 1
\&  $vector\->Chunk_List_Store(3, split(//, reverse $string));
.Ve
.Sp
Note however that unlike the conversion methods "\f(CW\*(C`from_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`from_Enum()\*(C'\fR",
this statement does not include any syntax checking, i.e.,
it may fail silently, without warning.
.Sp
To perform syntax checking, add the following statements:
.Sp
.Vb 8
\&  if ($string =~ /^[0\-7]+$/)
\&  {
\&      # okay, go ahead with conversion as shown above
\&  }
\&  else
\&  {
\&      # error, string contains other than octal characters
\&  }
.Ve
.Sp
Another application is to store a repetitive pattern in a given
bit vector:
.Sp
.Vb 6
\&  $pattern = 0xDEADBEEF;
\&  $length = 32;            # = length of $pattern in bits
\&  $size = $vector\->Size();
\&  $factor = int($size / $length);
\&  if ($size % $length) { $factor++; }
\&  $vector\->Chunk_List_Store($length, ($pattern) x $factor);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`@chunks = $vector\->Chunk_List_Read($chunksize);\*(C'\fR
.Sp
This method allows you to access the contents of the given bit vector in
form of a list of data packets (\*(L"chunks\*(R") of a size ("\f(CW$chunksize\fR")
of your choosing (within certain limits).
.Sp
In fact the given "\f(CW$chunksize\fR\*(L" must lie in the range between \*(R"\f(CW1\fR\*(L"
and \*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", or a fatal \*(R"chunk size out of
range" error will occur.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
The given bit vector is thereby read in ascending order: The
"\f(CW$chunksize\fR\*(L" least significant bits (bits number \*(R"\f(CW0\fR\*(L" to
\&\*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR\*(L") become the first chunk in the returned list
(i.e., \*(R"\f(CW$chunks[0]\fR\*(L"). The bits number \*(R"\f(CW$chunksize\fR\*(L" to
\&\*(R"\f(CW\*(C`2*$chunksize\-1\*(C'\fR\*(L" become the next chunk in the list
(\*(R"\f(CW$chunks[1]\fR"), and so on.
.Sp
If "\f(CW\*(C`$vector\->Size()\*(C'\fR\*(L" is not a multiple of \*(R"\f(CW$chunksize\fR\*(L",
the last chunk in the list will contain fewer bits than \*(R"\f(CW$chunksize\fR".
.Sp
\&\fB\s-1BEWARE\s0\fR that for large bit vectors and/or small values of "\f(CW$chunksize\fR",
the number of returned list elements can be extremely large! \fB\s-1BE\s0 \s-1CAREFUL\s0!\fR
.Sp
You could blow up your application with lack of memory (each list element
is a full-grown Perl scalar, internally, with an associated memory overhead
for its administration!) or at least cause a noticeable, more or less
long-lasting \*(L"freeze\*(R" of your application!
.Sp
Possible applications:
.Sp
The method is especially useful in the conversion of packet sizes in
a data stream.
.Sp
This method can also be used to convert a given bit vector to a string
of octal numbers:
.Sp
.Vb 1
\&  $string = reverse join(\*(Aq\*(Aq, $vector\->Chunk_List_Read(3));
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Index_List_Remove(@indices);\*(C'\fR
.Sp
This method allows you to specify a list of indices of bits which
should be turned off in the given bit vector.
.Sp
In fact this method is a shortcut for
.Sp
.Vb 4
\&    foreach $index (@indices)
\&    {
\&        $vector\->Bit_Off($index);
\&    }
.Ve
.Sp
In contrast to all other import methods in this module, this method
does \fB\s-1NOT\s0\fR clear the given bit vector before processing its list
of arguments.
.Sp
Instead, this method allows you to accumulate the results of various
consecutive calls.
.Sp
(The same holds for the method "\f(CW\*(C`Index_List_Store()\*(C'\fR\*(L". As a
consequence, you can \*(R"wipe out\*(L" what you did using the method
\&\*(R"\f(CW\*(C`Index_List_Remove()\*(C'\fR\*(L" by passing the identical argument list
to the method \*(R"\f(CW\*(C`Index_List_Store()\*(C'\fR".)
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Index_List_Store(@indices);\*(C'\fR
.Sp
This method allows you to specify a list of indices of bits which
should be turned on in the given bit vector.
.Sp
In fact this method is a shortcut for
.Sp
.Vb 4
\&    foreach $index (@indices)
\&    {
\&        $vector\->Bit_On($index);
\&    }
.Ve
.Sp
In contrast to all other import methods in this module, this method
does \fB\s-1NOT\s0\fR clear the given bit vector before processing its list
of arguments.
.Sp
Instead, this method allows you to accumulate the results of various
consecutive calls.
.Sp
(The same holds for the method "\f(CW\*(C`Index_List_Remove()\*(C'\fR\*(L". As a
consequence, you can \*(R"wipe out\*(L" what you did using the method
\&\*(R"\f(CW\*(C`Index_List_Store()\*(C'\fR\*(L" by passing the identical argument list
to the method \*(R"\f(CW\*(C`Index_List_Remove()\*(C'\fR".)
.IP "\(bu" 2
\&\f(CW\*(C`@indices = $vector\->Index_List_Read();\*(C'\fR
.Sp
This method returns a list of Perl scalars.
.Sp
The list contains one scalar for each set bit in the given
bit vector.
.Sp
\&\fB\s-1BEWARE\s0\fR that for large bit vectors, this can result in a literally
overwhelming number of list elements! \fB\s-1BE\s0 \s-1CAREFUL\s0!\fR You could run
out of memory or slow down your application considerably!
.Sp
Each scalar contains the number of the index corresponding to
the bit in question.
.Sp
These indices are always returned in ascending order.
.Sp
If the given bit vector is empty (contains only cleared bits)
or if it has a length of zero (if it contains no bits at all),
the method returns an empty list.
.Sp
This method can be useful, for instance, to obtain a list of
prime numbers:
.Sp
.Vb 4
\&    $limit = 1000; # or whatever
\&    $vector = Bit::Vector\->new($limit+1);
\&    $vector\->Primes();
\&    @primes = $vector\->Index_List_Read();
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Or($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Union($set1,$set2);\*(C'\fR
.Sp
This method calculates the union of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L" and stores
the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 u $set2\*(C'\fR\*(L" in set theory
(where \*(R"u\*(L" is the \*(R"cup" operator).
.Sp
(On systems where the \*(L"cup\*(R" character is unavailable this operator
is often denoted by a plus sign \*(L"+\*(R".)
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->And($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Intersection($set1,$set2);\*(C'\fR
.Sp
This method calculates the intersection of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L" and
stores the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 n $set2\*(C'\fR\*(L" in set theory
(where \*(R"n\*(L" is the \*(R"cap" operator).
.Sp
(On systems where the \*(L"cap\*(R" character is unavailable this operator
is often denoted by an asterisk \*(L"*\*(R".)
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->AndNot($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Difference($set1,$set2);\*(C'\fR
.Sp
This method calculates the difference of "\f(CW$set1\fR\*(L" less \*(R"\f(CW$set2\fR\*(L" and
stores the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 \e $set2\*(C'\fR\*(L" in set theory
(where \*(R"\e\*(L" is the \*(R"less" operator).
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Xor($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->ExclusiveOr($set1,$set2);\*(C'\fR
.Sp
This method calculates the symmetric difference of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L"
and stores the result in \*(R"\f(CW$set3\fR".
.Sp
This can be written as "\f(CW\*(C`$set3 = ($set1 u $set2) \e ($set1 n $set2)\*(C'\fR" in set
theory (the union of the two sets less their intersection).
.Sp
When sets are implemented as bit vectors then the above formula is
equivalent to the exclusive-or between corresponding bits of the two
bit vectors (hence the name of this method).
.Sp
Note that this method is also much more efficient than evaluating the
above formula explicitly since it uses a built-in machine language
instruction internally.
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Not($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$set2\->Complement($set1);\*(C'\fR
.Sp
This method calculates the complement of "\f(CW$set1\fR\*(L" and stores the result
in \*(R"\f(CW$set2\fR".
.Sp
In \*(L"big integer\*(R" arithmetic, this is equivalent to calculating the one's
complement of the number stored in the bit vector "\f(CW$set1\fR" in binary
representation.
.Sp
In-place calculation is also possible, i.e., "\f(CW$set2\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR".
.IP "\(bu" 2
\&\f(CW\*(C`if ($set1\->subset($set2))\*(C'\fR
.Sp
Returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if \*(R"\f(CW$set1\fR\*(L" is a subset of \*(R"\f(CW$set2\fR\*(L"
(i.e., completely contained in \*(R"\f(CW$set2\fR\*(L") and \*(R"false\*(L" (\*(R"\f(CW0\fR")
otherwise.
.Sp
This means that any bit which is set ("\f(CW1\fR\*(L") in \*(R"\f(CW$set1\fR\*(L" must
also be set in \*(R"\f(CW$set2\fR\*(L", but \*(R"\f(CW$set2\fR\*(L" may contain set bits
which are not set in \*(R"\f(CW$set1\fR", in order for the condition
of subset relationship to be true between these two sets.
.Sp
Note that by definition, if two sets are identical, they are
also subsets (and also supersets) of each other.
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
Uses a byte lookup table for calculating the number of set bits
per byte, and thus needs a time for evaluation (and a number of
loops) linearly proportional to the length of the given bit vector
(in bytes).
.Sp
This should be the fastest algorithm on average.
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm2();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
This does the same as the method "\f(CW\*(C`Norm()\*(C'\fR" above, only with a
different algorithm:
.Sp
This method counts the number of set and cleared bits at the same
time and will stop when either of them has been exhausted, thus
needing at most half as many loops per machine word as the total
number of bits in a machine word \- in fact it will need a number
of loops equal to the minimum of the number of set bits and the
number of cleared bits.
.Sp
This might be a faster algorithm than of the method "\f(CW\*(C`Norm()\*(C'\fR"
above on some systems, depending on the system's architecture
and the compiler and optimisation used, for bit vectors with
sparse set bits and for bit vectors with sparse cleared bits
(i.e., predominantly set bits).
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm3();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
This does the same as the two methods "\f(CW\*(C`Norm()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Norm2()\*(C'\fR"
above, however with a different algorithm.
.Sp
In fact this is the implementation of the method "\f(CW\*(C`Norm()\*(C'\fR" used
in previous versions of this module.
.Sp
The method needs a number of loops per machine word equal to the
number of set bits in that machine word.
.Sp
Only for bit vectors with sparse set bits will this method be
fast; it will depend on a system's architecture and compiler
whether the method will be faster than any of the two methods
above in such cases.
.Sp
On average however, this is probably the slowest method of the
three.
.IP "\(bu" 2
\&\f(CW\*(C`$min = $set\->Min();\*(C'\fR
.Sp
Returns the minimum of the given set, i.e., the minimum of all
indices of all set bits in the given bit vector "\f(CW$set\fR".
.Sp
If the set is empty (no set bits), plus infinity (represented
by the constant \*(L"\s-1MAX_LONG\s0\*(R" on your system) is returned.
.Sp
(This constant is usually 2\ ^\ (n\-1)\ \-\ 1, where "\f(CW\*(C`n\*(C'\fR" is the
number of bits of an unsigned long on your machine.)
.IP "\(bu" 2
\&\f(CW\*(C`$max = $set\->Max();\*(C'\fR
.Sp
Returns the maximum of the given set, i.e., the maximum of all
indices of all set bits in the given bit vector "\f(CW$set\fR".
.Sp
If the set is empty (no set bits), minus infinity (represented
by the constant \*(L"\s-1MIN_LONG\s0\*(R" on your system) is returned.
.Sp
(This constant is usually \-(2\ ^\ (n\-1)\ \-\ 1) or \-(2\ ^\ (n\-1)),
where "\f(CW\*(C`n\*(C'\fR" is the number of bits of an unsigned long on your machine.)
.IP "\(bu" 2
\&\f(CW\*(C`$m3\->Multiplication($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);\*(C'\fR
.Sp
This method multiplies two boolean matrices (stored as bit vectors)
"\f(CW$m1\fR\*(L" and \*(R"\f(CW$m2\fR\*(L" and stores the result in matrix \*(R"\f(CW$m3\fR".
.Sp
The method uses the binary \*(L"xor\*(R" operation ("\f(CW\*(C`^\*(C'\fR\*(L") as the boolean
addition operator (\*(R"\f(CW\*(C`+\*(C'\fR").
.Sp
An exception is raised if the product of the number of rows and
columns of any of the three matrices differs from the actual size
of their underlying bit vector.
.Sp
An exception is also raised if the numbers of rows and columns
of the three matrices do not harmonize in the required manner:
.Sp
.Vb 3
\&  rows3 == rows1
\&  cols3 == cols2
\&  cols1 == rows2
.Ve
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$m3\->Product($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);\*(C'\fR
.Sp
This method multiplies two boolean matrices (stored as bit vectors)
"\f(CW$m1\fR\*(L" and \*(R"\f(CW$m2\fR\*(L" and stores the result in matrix \*(R"\f(CW$m3\fR".
.Sp
This special method uses the binary \*(L"or\*(R" operation ("\f(CW\*(C`|\*(C'\fR\*(L") as the
boolean addition operator (\*(R"\f(CW\*(C`+\*(C'\fR").
.Sp
An exception is raised if the product of the number of rows and
columns of any of the three matrices differs from the actual size
of their underlying bit vector.
.Sp
An exception is also raised if the numbers of rows and columns
of the three matrices do not harmonize in the required manner:
.Sp
.Vb 3
\&  rows3 == rows1
\&  cols3 == cols2
\&  cols1 == rows2
.Ve
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$matrix\->Closure($rows,$cols);\*(C'\fR
.Sp
This method calculates the reflexive transitive closure of the
given boolean matrix (stored as a bit vector) using Kleene's
algoritm.
.Sp
(See \fIMath::Kleene\fR\|(3) for a brief introduction into the
theory behind Kleene's algorithm.)
.Sp
The reflexive transitive closure answers the question whether
a path exists between any two vertices of a graph whose edges
are given as a matrix:
.Sp
If a (directed) edge exists going from vertex \*(L"i\*(R" to vertex \*(L"j\*(R",
then the element in the matrix with coordinates (i,j) is set to
"\f(CW1\fR\*(L" (otherwise it remains set to \*(R"\f(CW0\fR").
.Sp
If the edges are undirected, the resulting matrix is symmetric,
i.e., elements (i,j) and (j,i) always contain the same value.
.Sp
The matrix representing the edges of the graph only answers the
question whether an \fB\s-1EDGE\s0\fR exists between any two vertices of
the graph or not, whereas the reflexive transitive closure
answers the question whether a \fB\s-1PATH\s0\fR (a series of adjacent
edges) exists between any two vertices of the graph!
.Sp
Note that the contents of the given matrix are modified by
this method, so make a copy of the initial matrix in time
if you are going to need it again later.
.Sp
An exception is raised if the given matrix is not quadratic,
i.e., if the number of rows and columns of the given matrix
is not identical.
.Sp
An exception is also raised if the product of the number of
rows and columns of the given matrix differs from the actual
size of its underlying bit vector.
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$matrix2\->Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);\*(C'\fR
.Sp
This method calculates the transpose of a boolean matrix "\f(CW$matrix1\fR\*(L"
(stored as a bit vector) and stores the result in matrix \*(R"\f(CW$matrix2\fR".
.Sp
The transpose of a boolean matrix, representing the edges of a graph,
can be used for finding the strongly connected components of that graph.
.Sp
An exception is raised if the product of the number of rows and
columns of any of the two matrices differs from the actual size
of its underlying bit vector.
.Sp
An exception is also raised if the following conditions are not
met:
.Sp
.Vb 2
\&  rows2 == cols1
\&  cols2 == rows1
.Ve
.Sp
Note that in-place processing ("\f(CW$matrix1\fR\*(L" and \*(R"\f(CW$matrix2\fR\*(L" are
identical) is only possible if the matrix is quadratic. Otherwise,
a fatal \*(R"matrix is not quadratic" error will occur.
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector::Overload\fR\|(3),
\&\fIBit::Vector::String\fR\|(3),
\&\fIStorable\fR\|(3).
.PP
\&\fISet::IntRange\fR\|(3),
\&\fIMath::MatrixBool\fR\|(3),
\&\fIMath::MatrixReal\fR\|(3),
\&\fIDFA::Kleene\fR\|(3),
\&\fIMath::Kleene\fR\|(3),
\&\fIGraph::Kruskal\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector\*(R" version 7.2.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995 \- 2012 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector5.18.3pm                          0100644 0001750 0001750 00000363311 12566241526 023712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Vector 3"
.TH Vector 3 "2013-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector \- Efficient bit vector, set of integers and "big int" math library
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.SS "\s-1OVERLOADED OPERATORS\s0"
.IX Subsection "OVERLOADED OPERATORS"
See \fIBit::Vector::Overload\fR\|(3).
.SS "\s-1MORE STRING IMPORT/EXPORT\s0"
.IX Subsection "MORE STRING IMPORT/EXPORT"
See \fIBit::Vector::String\fR\|(3).
.SS "\s-1CLASS METHODS\s0"
.IX Subsection "CLASS METHODS"
.Vb 2
\&  Version
\&      $version = Bit::Vector\->Version();
\&
\&  Word_Bits
\&      $bits = Bit::Vector\->Word_Bits();  #  bits in a machine word
\&
\&  Long_Bits
\&      $bits = Bit::Vector\->Long_Bits();  #  bits in an unsigned long
\&
\&  new
\&      $vector = Bit::Vector\->new($bits);  #  bit vector constructor
\&
\&      @veclist = Bit::Vector\->new($bits,$count);
\&
\&  new_Hex
\&      $vector = Bit::Vector\->new_Hex($bits,$string);
\&
\&  new_Bin
\&      $vector = Bit::Vector\->new_Bin($bits,$string);
\&
\&  new_Dec
\&      $vector = Bit::Vector\->new_Dec($bits,$string);
\&
\&  new_Enum
\&      $vector = Bit::Vector\->new_Enum($bits,$string);
\&
\&  Concat_List
\&      $vector = Bit::Vector\->Concat_List(@vectors);
.Ve
.SS "\s-1OBJECT METHODS\s0"
.IX Subsection "OBJECT METHODS"
.Vb 2
\&  new
\&      $vec2 = $vec1\->new($bits);  #  alternative call of constructor
\&
\&      @veclist = $vec\->new($bits,$count);
\&
\&  Shadow
\&      $vec2 = $vec1\->Shadow();  #  new vector, same size but empty
\&
\&  Clone
\&      $vec2 = $vec1\->Clone();  #  new vector, exact duplicate
\&
\&  Concat
\&      $vector = $vec1\->Concat($vec2);
\&
\&  Concat_List
\&      $vector = $vec1\->Concat_List($vec2,$vec3,...);
\&
\&  Size
\&      $bits = $vector\->Size();
\&
\&  Resize
\&      $vector\->Resize($bits);
\&      $vector\->Resize($vector\->Size()+5);
\&      $vector\->Resize($vector\->Size()\-5);
\&
\&  Copy
\&      $vec2\->Copy($vec1);
\&
\&  Empty
\&      $vector\->Empty();
\&
\&  Fill
\&      $vector\->Fill();
\&
\&  Flip
\&      $vector\->Flip();
\&
\&  Primes
\&      $vector\->Primes();  #  Sieve of Erathostenes
\&
\&  Reverse
\&      $vec2\->Reverse($vec1);
\&
\&  Interval_Empty
\&      $vector\->Interval_Empty($min,$max);
\&
\&  Interval_Fill
\&      $vector\->Interval_Fill($min,$max);
\&
\&  Interval_Flip
\&      $vector\->Interval_Flip($min,$max);
\&
\&  Interval_Reverse
\&      $vector\->Interval_Reverse($min,$max);
\&
\&  Interval_Scan_inc
\&      if (($min,$max) = $vector\->Interval_Scan_inc($start))
\&
\&  Interval_Scan_dec
\&      if (($min,$max) = $vector\->Interval_Scan_dec($start))
\&
\&  Interval_Copy
\&      $vec2\->Interval_Copy($vec1,$offset2,$offset1,$length);
\&
\&  Interval_Substitute
\&      $vec2\->Interval_Substitute($vec1,$off2,$len2,$off1,$len1);
\&
\&  is_empty
\&      if ($vector\->is_empty())
\&
\&  is_full
\&      if ($vector\->is_full())
\&
\&  equal
\&      if ($vec1\->equal($vec2))
\&
\&  Lexicompare (unsigned)
\&      if ($vec1\->Lexicompare($vec2) == 0)
\&      if ($vec1\->Lexicompare($vec2) != 0)
\&      if ($vec1\->Lexicompare($vec2) <  0)
\&      if ($vec1\->Lexicompare($vec2) <= 0)
\&      if ($vec1\->Lexicompare($vec2) >  0)
\&      if ($vec1\->Lexicompare($vec2) >= 0)
\&
\&  Compare (signed)
\&      if ($vec1\->Compare($vec2) == 0)
\&      if ($vec1\->Compare($vec2) != 0)
\&      if ($vec1\->Compare($vec2) <  0)
\&      if ($vec1\->Compare($vec2) <= 0)
\&      if ($vec1\->Compare($vec2) >  0)
\&      if ($vec1\->Compare($vec2) >= 0)
\&
\&  to_Hex
\&      $string = $vector\->to_Hex();
\&
\&  from_Hex
\&      $vector\->from_Hex($string);
\&
\&  to_Bin
\&      $string = $vector\->to_Bin();
\&
\&  from_Bin
\&      $vector\->from_Bin($string);
\&
\&  to_Dec
\&      $string = $vector\->to_Dec();
\&
\&  from_Dec
\&      $vector\->from_Dec($string);
\&
\&  to_Enum
\&      $string = $vector\->to_Enum();  #  e.g. "2,3,5\-7,11,13\-19"
\&
\&  from_Enum
\&      $vector\->from_Enum($string);
\&
\&  Bit_Off
\&      $vector\->Bit_Off($index);
\&
\&  Bit_On
\&      $vector\->Bit_On($index);
\&
\&  bit_flip
\&      $bit = $vector\->bit_flip($index);
\&
\&  bit_test
\&  contains
\&      $bit = $vector\->bit_test($index);
\&      $bit = $vector\->contains($index);
\&      if ($vector\->bit_test($index))
\&      if ($vector\->contains($index))
\&
\&  Bit_Copy
\&      $vector\->Bit_Copy($index,$bit);
\&
\&  LSB (least significant bit)
\&      $vector\->LSB($bit);
\&
\&  MSB (most significant bit)
\&      $vector\->MSB($bit);
\&
\&  lsb (least significant bit)
\&      $bit = $vector\->lsb();
\&
\&  msb (most significant bit)
\&      $bit = $vector\->msb();
\&
\&  rotate_left
\&      $carry = $vector\->rotate_left();
\&
\&  rotate_right
\&      $carry = $vector\->rotate_right();
\&
\&  shift_left
\&      $carry = $vector\->shift_left($carry);
\&
\&  shift_right
\&      $carry = $vector\->shift_right($carry);
\&
\&  Move_Left
\&      $vector\->Move_Left($bits);  #  shift left "$bits" positions
\&
\&  Move_Right
\&      $vector\->Move_Right($bits);  #  shift right "$bits" positions
\&
\&  Insert
\&      $vector\->Insert($offset,$bits);
\&
\&  Delete
\&      $vector\->Delete($offset,$bits);
\&
\&  increment
\&      $carry = $vector\->increment();
\&
\&  decrement
\&      $carry = $vector\->decrement();
\&
\&  inc
\&      $overflow = $vec2\->inc($vec1);
\&
\&  dec
\&      $overflow = $vec2\->dec($vec1);
\&
\&  add
\&      $carry = $vec3\->add($vec1,$vec2,$carry);
\&      ($carry,$overflow) = $vec3\->add($vec1,$vec2,$carry);
\&
\&  subtract
\&      $carry = $vec3\->subtract($vec1,$vec2,$carry);
\&      ($carry,$overflow) = $vec3\->subtract($vec1,$vec2,$carry);
\&
\&  Neg
\&  Negate
\&      $vec2\->Neg($vec1);
\&      $vec2\->Negate($vec1);
\&
\&  Abs
\&  Absolute
\&      $vec2\->Abs($vec1);
\&      $vec2\->Absolute($vec1);
\&
\&  Sign
\&      if ($vector\->Sign() == 0)
\&      if ($vector\->Sign() != 0)
\&      if ($vector\->Sign() <  0)
\&      if ($vector\->Sign() <= 0)
\&      if ($vector\->Sign() >  0)
\&      if ($vector\->Sign() >= 0)
\&
\&  Multiply
\&      $vec3\->Multiply($vec1,$vec2);
\&
\&  Divide
\&      $quot\->Divide($vec1,$vec2,$rest);
\&
\&  GCD (Greatest Common Divisor)
\&      $vecgcd\->GCD($veca,$vecb);
\&      $vecgcd\->GCD($vecx,$vecy,$veca,$vecb);
\&
\&  Power
\&      $vec3\->Power($vec1,$vec2);
\&
\&  Block_Store
\&      $vector\->Block_Store($buffer);
\&
\&  Block_Read
\&      $buffer = $vector\->Block_Read();
\&
\&  Word_Size
\&      $size = $vector\->Word_Size();  #  number of words in "$vector"
\&
\&  Word_Store
\&      $vector\->Word_Store($offset,$word);
\&
\&  Word_Read
\&      $word = $vector\->Word_Read($offset);
\&
\&  Word_List_Store
\&      $vector\->Word_List_Store(@words);
\&
\&  Word_List_Read
\&      @words = $vector\->Word_List_Read();
\&
\&  Word_Insert
\&      $vector\->Word_Insert($offset,$count);
\&
\&  Word_Delete
\&      $vector\->Word_Delete($offset,$count);
\&
\&  Chunk_Store
\&      $vector\->Chunk_Store($chunksize,$offset,$chunk);
\&
\&  Chunk_Read
\&      $chunk = $vector\->Chunk_Read($chunksize,$offset);
\&
\&  Chunk_List_Store
\&      $vector\->Chunk_List_Store($chunksize,@chunks);
\&
\&  Chunk_List_Read
\&      @chunks = $vector\->Chunk_List_Read($chunksize);
\&
\&  Index_List_Remove
\&      $vector\->Index_List_Remove(@indices);
\&
\&  Index_List_Store
\&      $vector\->Index_List_Store(@indices);
\&
\&  Index_List_Read
\&      @indices = $vector\->Index_List_Read();
\&
\&  Or
\&  Union
\&      $vec3\->Or($vec1,$vec2);
\&      $set3\->Union($set1,$set2);
\&
\&  And
\&  Intersection
\&      $vec3\->And($vec1,$vec2);
\&      $set3\->Intersection($set1,$set2);
\&
\&  AndNot
\&  Difference
\&      $vec3\->AndNot($vec1,$vec2);
\&      $set3\->Difference($set1,$set2);
\&
\&  Xor
\&  ExclusiveOr
\&      $vec3\->Xor($vec1,$vec2);
\&      $set3\->ExclusiveOr($set1,$set2);
\&
\&  Not
\&  Complement
\&      $vec2\->Not($vec1);
\&      $set2\->Complement($set1);
\&
\&  subset
\&      if ($set1\->subset($set2))  #  true if $set1 is subset of $set2
\&
\&  Norm
\&      $norm = $set\->Norm();
\&      $norm = $set\->Norm2();
\&      $norm = $set\->Norm3();
\&
\&  Min
\&      $min = $set\->Min();
\&
\&  Max
\&      $max = $set\->Max();
\&
\&  Multiplication
\&      $matrix3\->Multiplication($rows3,$cols3,
\&                      $matrix1,$rows1,$cols1,
\&                      $matrix2,$rows2,$cols2);
\&
\&  Product
\&      $matrix3\->Product($rows3,$cols3,
\&               $matrix1,$rows1,$cols1,
\&               $matrix2,$rows2,$cols2);
\&
\&  Closure
\&      $matrix\->Closure($rows,$cols);
\&
\&  Transpose
\&      $matrix2\->Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);
.Ve
.SH "IMPORTANT NOTES"
.IX Header "IMPORTANT NOTES"
.IP "\(bu" 2
Method naming conventions
.Sp
Method names completely in lower case indicate a boolean return value.
.Sp
(Except for the bit vector constructor method "\f(CW\*(C`new()\*(C'\fR", of course.)
.IP "\(bu" 2
Boolean values
.Sp
Boolean values in this module are always a numeric zero ("\f(CW0\fR\*(L") for
\&\*(R"false\*(L" and a numeric one (\*(R"\f(CW1\fR\*(L") for \*(R"true".
.IP "\(bu" 2
Negative numbers
.Sp
All numeric input parameters passed to any of the methods in this module
are regarded as being \fB\s-1UNSIGNED\s0\fR (as opposed to the contents of the
bit vectors themselves, which are usually considered to be \fB\s-1SIGNED\s0\fR).
.Sp
As a consequence, whenever you pass a negative number as an argument to
some method of this module, it will be treated as a (usually very large)
positive number due to its internal two's complement binary representation,
usually resulting in an \*(L"index out of range\*(R" error message and program
abortion.
.IP "\(bu" 2
Bit order
.Sp
Note that bit vectors are stored least order bit and least order word first
internally.
.Sp
I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.
.Sp
(Where word #0 comes first in memory, i.e., it is stored at the least memory
address in the allocated block of memory holding the given bit vector.)
.Sp
Note however that machine words can be stored least order byte first or last,
depending on your system's implementation.
.Sp
When you are exporting or importing a whole bit vector at once using the
methods "\f(CW\*(C`Block_Read()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Block_Store()\*(C'\fR\*(L" (the only time in this
module where this could make any difference), however, a conversion to and
from \*(R"least order byte first" order is automatically supplied.
.Sp
In other words, what "\f(CW\*(C`Block_Read()\*(C'\fR\*(L" provides and what \*(R"\f(CW\*(C`Block_Store()\*(C'\fR\*(L"
expects is always in \*(R"least order byte first" order, regardless of the order
in which words are stored internally on your machine.
.Sp
This is to make sure that what you export on one machine using "\f(CW\*(C`Block_Read()\*(C'\fR\*(L"
can always be read in correctly with \*(R"\f(CW\*(C`Block_Store()\*(C'\fR" on a different machine.
.Sp
Note further that whenever bit vectors are converted to and from (binary or
hexadecimal) strings, the \fB\s-1RIGHTMOST\s0\fR bit is always the \fB\s-1LEAST SIGNIFICANT\s0\fR
one, and the \fB\s-1LEFTMOST\s0\fR bit is always the \fB\s-1MOST SIGNIFICANT\s0\fR bit.
.Sp
This is because in our western culture, numbers are always represented in this
way (least significant to most significant digits go from right to left).
.Sp
Of course this requires an internal reversion of order, which the corresponding
conversion methods perform automatically (without any additional overhead, it's
just a matter of starting the internal loop at the bottom or the top end).
.IP "\(bu" 2
\&\*(L"Word\*(R" related methods
.Sp
Note that all methods whose names begin with "\f(CW\*(C`Word_\*(C'\fR" are
\&\fBMACHINE-DEPENDENT\fR!
.Sp
They depend on the size (number of bits) of an \*(L"unsigned int\*(R" (C type) on
your machine.
.Sp
Therefore, you should only use these methods if you are \fB\s-1ABSOLUTELY CERTAIN\s0\fR
that portability of your code is not an issue!
.Sp
Note that you can use arbitrarily large chunks (i.e., fragments of bit vectors)
of up to 32 bits \fB\s-1IN A PORTABLE WAY\s0\fR using the methods whose names begin with
"\f(CW\*(C`Chunk_\*(C'\fR".
.IP "\(bu" 2
Chunk sizes
.Sp
Note that legal chunk sizes for all methods whose names begin with "\f(CW\*(C`Chunk_\*(C'\fR\*(L"
range from \*(R"\f(CW1\fR\*(L" to \*(R"\f(CW\*(C`Bit::Vector\->Long_Bits();\*(C'\fR\*(L" bits (\*(R"\f(CW0\fR" is \fB\s-1NOT\s0\fR
allowed!).
.Sp
In order to make your programs portable, however, you shouldn't use chunk sizes
larger than 32 bits, since this is the minimum size of an \*(L"unsigned long\*(R"
(C type) on all systems, as prescribed by \s-1ANSI\s0\ C.
.IP "\(bu" 2
Matching sizes
.Sp
In general, for methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of bits), or a fatal
\&\*(L"size mismatch\*(R" error will occur.
.Sp
Exceptions from this rule are the methods "\f(CW\*(C`Concat()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Concat_List()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Interval_Copy()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Interval_Substitute()\*(C'\fR", where no
conditions at all are imposed on the size of their bit vector arguments.
.Sp
In method "\f(CW\*(C`Multiply()\*(C'\fR", all three bit vector arguments must in principle
obey the rule of matching sizes, but the bit vector in which the result of
the multiplication is to be stored may be larger than the two bit vector
arguments containing the factors for the multiplication.
.Sp
In method "\f(CW\*(C`Power()\*(C'\fR", the bit vector for the result must be the same
size or greater than the base of the exponentiation term. The exponent
can be any size.
.IP "\(bu" 2
Index ranges
.Sp
All indices for any given bits must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"index out of range"
error will occur.
.IP "\(bu" 2
Object persistence
.Sp
Since version 6.5, \*(L"Bit::Vector\*(R" objects can be serialized
and de-serialized automatically with \*(L"Storable\*(R", out-of-the-box,
without requiring any further user action for this to work.
.Sp
This is also true for nested data structures (since version 6.8).
.Sp
See the \fIStorable\fR\|(3) documentation for more details.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1OVERLOADED OPERATORS\s0"
.IX Subsection "OVERLOADED OPERATORS"
See \fIBit::Vector::Overload\fR\|(3).
.SS "\s-1MORE STRING IMPORT/EXPORT\s0"
.IX Subsection "MORE STRING IMPORT/EXPORT"
See \fIBit::Vector::String\fR\|(3).
.SS "\s-1CLASS METHODS\s0"
.IX Subsection "CLASS METHODS"
.IP "\(bu" 2
\&\f(CW\*(C`$version = Bit::Vector\->Version();\*(C'\fR
.Sp
Returns the current version number of this module.
.IP "\(bu" 2
\&\f(CW\*(C`$bits = Bit::Vector\->Word_Bits();\*(C'\fR
.Sp
Returns the number of bits of an \*(L"unsigned int\*(R" (C type)
on your machine.
.Sp
(An \*(L"unsigned int\*(R" is also called a \*(L"machine word\*(R",
hence the name of this method.)
.IP "\(bu" 2
\&\f(CW\*(C`$bits = Bit::Vector\->Long_Bits();\*(C'\fR
.Sp
Returns the number of bits of an \*(L"unsigned long\*(R" (C type)
on your machine.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new($bits);\*(C'\fR
.Sp
This is the bit vector constructor method.
.Sp
Call this method to create a new bit vector containing "\f(CW$bits\fR\*(L"
bits (with indices ranging from \*(R"\f(CW0\fR\*(L" to \*(R"\f(CW\*(C`$bits\-1\*(C'\fR").
.Sp
Note that \- in contrast to previous versions \- bit vectors
of length zero (i.e., with \f(CW\*(C`$bits = 0\*(C'\fR) are permitted now.
.Sp
The method returns a reference to the newly created bit vector.
.Sp
A new bit vector is always initialized so that all bits are cleared
(turned off).
.Sp
An exception will be raised if the method is unable to allocate the
necessary memory.
.Sp
Note that if you specify a negative number for "\f(CW$bits\fR" it will be
interpreted as a large positive number due to its internal two's
complement binary representation.
.Sp
In such a case, the bit vector constructor method will obediently attempt
to create a bit vector of that size, probably resulting in an exception,
as explained above.
.IP "\(bu" 2
\&\f(CW\*(C`@veclist = Bit::Vector\->new($bits,$count);\*(C'\fR
.Sp
You can also create more than one bit vector at a time if you specify the
optional second parameter "\f(CW$count\fR".
.Sp
The method returns a list of "\f(CW$count\fR\*(L" bit vectors which all have the
same number of bits \*(R"\f(CW$bits\fR" (and which are all initialized, i.e.,
all bits are cleared).
.Sp
If "\f(CW$count\fR" is zero, an empty list is returned.
.Sp
If "\f(CW$bits\fR" is zero, a list of null-sized bit vectors is returned.
.Sp
Note again that if you specify a negative number for "\f(CW$count\fR" it will
be interpreted as a large positive number due to its internal two's
complement binary representation.
.Sp
In such a case, the bit vector constructor method will obediently attempt
to create that many bit vectors, probably resulting in an exception (\*(L"out
of memory\*(R").
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Hex($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then passes the given string to the method \*(R"\f(CW\*(C`from_Hex()\*(C'\fR".
.Sp
However, this method is more efficient than performing these two steps
separately: First because in this method, the memory area occupied by
the new bit vector is not initialized to zeros (which is pointless in
this case), and second because it saves you from the associated overhead
of one additional method invocation.
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR\*(L" immediately above for
possible causes) or if the given string cannot be converted successfully
(see the description of the method \*(R"\f(CW\*(C`from_Hex()\*(C'\fR" further below for
details).
.Sp
In the latter case, the memory occupied by the new bit vector is
released first (i.e., \*(L"free\*(R"d) before the exception is actually
raised.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Bin($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then passes the given string to the method \*(R"\f(CW\*(C`from_Bin()\*(C'\fR".
.Sp
However, this method is more efficient than performing these two steps
separately: First because in this method, the memory area occupied by
the new bit vector is not initialized to zeros (which is pointless in
this case), and second because it saves you from the associated overhead
of one additional method invocation.
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR\*(L" above for possible causes)
or if the given string cannot be converted successfully (see the
description of the method \*(R"\f(CW\*(C`from_Bin()\*(C'\fR" further below for details).
.Sp
In the latter case, the memory occupied by the new bit vector is
released first (i.e., \*(L"free\*(R"d) before the exception is actually
raised.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Dec($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then passes the given string to the method \*(R"\f(CW\*(C`from_Dec()\*(C'\fR".
.Sp
However, this method is more efficient than performing these two steps
separately: First because in this method, "\f(CW\*(C`new()\*(C'\fR\*(L" does not initialize
the memory area occupied by the new bit vector with zeros (which is
pointless in this case, because \*(R"\f(CW\*(C`from_Dec()\*(C'\fR" will do it anyway),
and second because it saves you from the associated overhead of one
additional method invocation.
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR\*(L" above for possible causes)
or if the given string cannot be converted successfully (see the
description of the method \*(R"\f(CW\*(C`from_Dec()\*(C'\fR" further below for details).
.Sp
In the latter case, the memory occupied by the new bit vector is
released first (i.e., \*(L"free\*(R"d) before the exception is actually
raised.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Enum($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then passes the given string to the method \*(R"\f(CW\*(C`from_Enum()\*(C'\fR".
.Sp
However, this method is more efficient than performing these two steps
separately: First because in this method, "\f(CW\*(C`new()\*(C'\fR\*(L" does not initialize
the memory area occupied by the new bit vector with zeros (which is
pointless in this case, because \*(R"\f(CW\*(C`from_Enum()\*(C'\fR" will do it anyway),
and second because it saves you from the associated overhead of one
additional method invocation.
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR\*(L" above for possible causes)
or if the given string cannot be converted successfully (see the
description of the method \*(R"\f(CW\*(C`from_Enum()\*(C'\fR" further below for details).
.Sp
In the latter case, the memory occupied by the new bit vector is
released first (i.e., \*(L"free\*(R"d) before the exception is actually
raised.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->Concat_List(@vectors);\*(C'\fR
.Sp
This method creates a new vector containing all bit vectors from the
argument list in concatenated form.
.Sp
The argument list may contain any number of arguments (including
zero); the only condition is that all arguments must be bit vectors.
.Sp
There is no condition concerning the length (in number of bits) of
these arguments.
.Sp
The vectors from the argument list are not changed in any way.
.Sp
If the argument list is empty or if all arguments have length zero,
the resulting bit vector will also have length zero.
.Sp
Note that the \fB\s-1RIGHTMOST\s0\fR bit vector from the argument list will
become the \fB\s-1LEAST\s0\fR significant part of the resulting bit vector,
and the \fB\s-1LEFTMOST\s0\fR bit vector from the argument list will
become the \fB\s-1MOST\s0\fR significant part of the resulting bit vector.
.SS "\s-1OBJECT METHODS\s0"
.IX Subsection "OBJECT METHODS"
.IP "\(bu" 2
\&\f(CW\*(C`$vec2 = $vec1\->new($bits);\*(C'\fR
.Sp
\&\f(CW\*(C`@veclist = $vec\->new($bits);\*(C'\fR
.Sp
This is an alternative way of calling the bit vector constructor method.
.Sp
Vector "\f(CW$vec1\fR\*(L" (or \*(R"\f(CW$vec\fR") is not affected by this, it just serves
as an anchor for the method invocation mechanism.
.Sp
In fact \fB\s-1ALL\s0\fR class methods in this module can be called this way,
even though this is probably considered to be \*(L"politically incorrect\*(R"
by \s-1OO \s0(\*(L"object-orientation\*(R") aficionados. ;\-)
.Sp
So even if you are too lazy to type "\f(CW\*(C`Bit::Vector\->\*(C'\fR\*(L" instead of
\&\*(R"\f(CW\*(C`$vec1\->\*(C'\fR" (and even though laziness is \- allegedly \- a programmer's
virtue \f(CW\*(C`:\-)\*(C'\fR), maybe it is better not to use this feature if you don't
want to get booed at. ;\-)
.IP "\(bu" 2
\&\f(CW\*(C`$vec2 = $vec1\->Shadow();\*(C'\fR
.Sp
Creates a \fB\s-1NEW\s0\fR bit vector "\f(CW$vec2\fR" of the \fB\s-1SAME SIZE\s0\fR as "\f(CW$vec1\fR"
but which is \fB\s-1EMPTY\s0\fR.
.Sp
Just like a shadow that has the same shape as the object it
originates from, but is flat and has no volume, i.e., contains
nothing.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2 = $vec1\->Clone();\*(C'\fR
.Sp
Creates a \fB\s-1NEW\s0\fR bit vector "\f(CW$vec2\fR" of the \fB\s-1SAME SIZE\s0\fR as "\f(CW$vec1\fR"
which is an \fB\s-1EXACT COPY\s0\fR of "\f(CW$vec1\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector = $vec1\->Concat($vec2);\*(C'\fR
.Sp
This method returns a new bit vector object which is the result of the
concatenation of the contents of "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR".
.Sp
Note that the contents of "\f(CW$vec1\fR" become the \fB\s-1MOST\s0\fR significant part
of the resulting bit vector, and "\f(CW$vec2\fR" the \fB\s-1LEAST\s0\fR significant part.
.Sp
If both bit vector arguments have length zero, the resulting bit vector
will also have length zero.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = $vec1\->Concat_List($vec2,$vec3,...);\*(C'\fR
.Sp
This is an alternative way of calling this (class) method as an
object method.
.Sp
The method returns a new bit vector object which is the result of
the concatenation of the contents of \f(CW\*(C`$vec1 . $vec2 . $vec3 . ...\*(C'\fR
.Sp
See the section \*(L"class methods\*(R" above for a detailed description of
this method.
.Sp
Note that the argument list may be empty and that all arguments
must be bit vectors if it isn't.
.IP "\(bu" 2
\&\f(CW\*(C`$bits = $vector\->Size();\*(C'\fR
.Sp
Returns the size (number of bits) the given vector was created with
(or "\f(CW\*(C`Resize()\*(C'\fR"d to).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Resize($bits);\*(C'\fR
.Sp
Changes the size of the given vector to the specified number of bits.
.Sp
This method allows you to change the size of an existing bit vector,
preserving as many bits from the old vector as will fit into the
new one (i.e., all bits with indices smaller than the minimum of the
sizes of both vectors, old and new).
.Sp
If the number of machine words needed to store the new vector is smaller
than or equal to the number of words needed to store the old vector, the
memory allocated for the old vector is reused for the new one, and only
the relevant book-keeping information is adjusted accordingly.
.Sp
This means that even if the number of bits increases, new memory is not
necessarily being allocated (i.e., if the old and the new number of bits
fit into the same number of machine words).
.Sp
If the number of machine words needed to store the new vector is greater
than the number of words needed to store the old vector, new memory is
allocated for the new vector, the old vector is copied to the new one,
the remaining bits in the new vector are cleared (turned off) and the old
vector is deleted, i.e., the memory that was allocated for it is released.
.Sp
(An exception will be raised if the method is unable to allocate the
necessary memory for the new vector.)
.Sp
As a consequence, if you decrease the size of a given vector so that
it will use fewer machine words, and increase it again later so that it
will use more words than immediately before but still less than the
original vector, new memory will be allocated anyway because the
information about the size of the original vector is lost whenever
you resize it.
.Sp
Note also that if you specify a negative number for "\f(CW$bits\fR" it will
be interpreted as a large positive number due to its internal two's
complement binary representation.
.Sp
In such a case, \*(L"\fIResize()\fR\*(R" will obediently attempt to create a bit
vector of that size, probably resulting in an exception, as explained
above.
.Sp
Finally, note that \- in contrast to previous versions \- resizing a bit
vector to a size of zero bits (length zero) is now permitted.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Copy($vec1);\*(C'\fR
.Sp
Copies the contents of bit vector "\f(CW$vec1\fR\*(L" to bit vector \*(R"\f(CW$vec2\fR".
.Sp
The previous contents of bit vector "\f(CW$vec2\fR" get overwritten, i.e.,
are lost.
.Sp
Both vectors must exist beforehand, i.e., this method does not \fB\s-1CREATE\s0\fR
any new bit vector object.
.Sp
The two vectors may be of any size.
.Sp
If the source bit vector is larger than the target, this method will copy
as much of the least significant bits of the source vector as will fit into
the target vector, thereby discarding any extraneous most significant bits.
.Sp
\&\s-1BEWARE\s0 that this causes a brutal cutoff in the middle of your data, and it
will also leave you with an almost unpredictable sign if subsequently the
number in the target vector is going to be interpreted as a number! (You
have been warned!)
.Sp
If the target bit vector is larger than the source, this method fills up
the remaining most significant bits in the target bit vector with either
0's or 1's, depending on the sign (= the most significant bit) of the
source bit vector. This is also known as \*(L"sign extension\*(R".
.Sp
This makes it possible to copy numbers from a smaller bit vector into
a larger one while preserving the number's absolute value as well as
its sign (due to the two's complement binary representation of numbers).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Empty();\*(C'\fR
.Sp
Clears all bits in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Fill();\*(C'\fR
.Sp
Sets all bits in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Flip();\*(C'\fR
.Sp
Flips (i.e., complements) all bits in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Primes();\*(C'\fR
.Sp
Clears the given bit vector and sets all bits whose
indices are prime numbers.
.Sp
This method uses the algorithm known as the \*(L"Sieve of
Erathostenes\*(R" internally.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Reverse($vec1);\*(C'\fR
.Sp
This method copies the given vector "\f(CW$vec1\fR\*(L" to
the vector \*(R"\f(CW$vec2\fR", thereby reversing the order
of all bits.
.Sp
I.e., the least significant bit of "\f(CW$vec1\fR\*(L" becomes the
most significant bit of \*(R"\f(CW$vec2\fR\*(L", whereas the most
significant bit of \*(R"\f(CW$vec1\fR\*(L" becomes the least
significant bit of \*(R"\f(CW$vec2\fR", and so forth
for all bits in between.
.Sp
Note that in-place processing is also possible, i.e.,
"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" may be identical.
.Sp
(Internally, this is the same as
\&\f(CW\*(C`$vec1\->Interval_Reverse(0,$vec1\->Size()\-1);\*(C'\fR.)
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Interval_Empty($min,$max);\*(C'\fR
.Sp
Clears all bits in the interval \f(CW\*(C`[$min..$max]\*(C'\fR (including both limits)
in the given vector.
.Sp
"\f(CW$min\fR\*(L" and \*(R"\f(CW$max\fR\*(L" may have the same value; this is the same
as clearing a single bit with \*(R"\f(CW\*(C`Bit_Off()\*(C'\fR" (but less efficient).
.Sp
Note that \f(CW\*(C`$vector\->Interval_Empty(0,$vector\->Size()\-1);\*(C'\fR
is the same as \f(CW\*(C`$vector\->Empty();\*(C'\fR (but less efficient).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Interval_Fill($min,$max);\*(C'\fR
.Sp
Sets all bits in the interval \f(CW\*(C`[$min..$max]\*(C'\fR (including both limits)
in the given vector.
.Sp
"\f(CW$min\fR\*(L" and \*(R"\f(CW$max\fR\*(L" may have the same value; this is the same
as setting a single bit with \*(R"\f(CW\*(C`Bit_On()\*(C'\fR" (but less efficient).
.Sp
Note that \f(CW\*(C`$vector\->Interval_Fill(0,$vector\->Size()\-1);\*(C'\fR
is the same as \f(CW\*(C`$vector\->Fill();\*(C'\fR (but less efficient).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Interval_Flip($min,$max);\*(C'\fR
.Sp
Flips (i.e., complements) all bits in the interval \f(CW\*(C`[$min..$max]\*(C'\fR
(including both limits) in the given vector.
.Sp
"\f(CW$min\fR\*(L" and \*(R"\f(CW$max\fR\*(L" may have the same value; this is the same
as flipping a single bit with \*(R"\f(CW\*(C`bit_flip()\*(C'\fR" (but less efficient).
.Sp
Note that \f(CW\*(C`$vector\->Interval_Flip(0,$vector\->Size()\-1);\*(C'\fR
is the same as \f(CW\*(C`$vector\->Flip();\*(C'\fR and
\&\f(CW\*(C`$vector\->Complement($vector);\*(C'\fR
(but less efficient).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Interval_Reverse($min,$max);\*(C'\fR
.Sp
Reverses the order of all bits in the interval \f(CW\*(C`[$min..$max]\*(C'\fR
(including both limits) in the given vector.
.Sp
I.e., bits "\f(CW$min\fR\*(L" and \*(R"\f(CW$max\fR" swap places, and so forth
for all bits in between.
.Sp
"\f(CW$min\fR\*(L" and \*(R"\f(CW$max\fR" may have the same value; this has no
effect whatsoever, though.
.IP "\(bu" 2
\&\f(CW\*(C`if (($min,$max) = $vector\->Interval_Scan_inc($start))\*(C'\fR
.Sp
Returns the minimum and maximum indices of the next contiguous block
of set bits (i.e., bits in the \*(L"on\*(R" state).
.Sp
The search starts at index "\f(CW$start\fR" (i.e., \f(CW"$min" >= "$start"\fR)
and proceeds upwards (i.e., \f(CW"$max" >= "$min"\fR), thus repeatedly
increments the search pointer "\f(CW$start\fR" (internally).
.Sp
Note though that the contents of the variable (or scalar literal value)
"\f(CW$start\fR" is \fB\s-1NOT\s0\fR altered. I.e., you have to set it to the desired
value yourself prior to each call to "\f(CW\*(C`Interval_Scan_inc()\*(C'\fR" (see also
the example given below).
.Sp
Actually, the bit vector is not searched bit by bit, but one machine
word at a time, in order to speed up execution (which means that this
method is quite efficient).
.Sp
An empty list is returned if no such block can be found.
.Sp
Note that a single set bit (surrounded by cleared bits) is a valid
block by this definition. In that case the return values for "\f(CW$min\fR\*(L"
and \*(R"\f(CW$max\fR" are the same.
.Sp
Typical use:
.Sp
.Vb 5
\&    $start = 0;
\&    while (($start < $vector\->Size()) &&
\&        (($min,$max) = $vector\->Interval_Scan_inc($start)))
\&    {
\&        $start = $max + 2;
\&
\&        # do something with $min and $max
\&    }
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`if (($min,$max) = $vector\->Interval_Scan_dec($start))\*(C'\fR
.Sp
Returns the minimum and maximum indices of the next contiguous block
of set bits (i.e., bits in the \*(L"on\*(R" state).
.Sp
The search starts at index "\f(CW$start\fR" (i.e., \f(CW"$max" <= "$start"\fR)
and proceeds downwards (i.e., \f(CW"$min" <= "$max"\fR), thus repeatedly
decrements the search pointer "\f(CW$start\fR" (internally).
.Sp
Note though that the contents of the variable (or scalar literal value)
"\f(CW$start\fR" is \fB\s-1NOT\s0\fR altered. I.e., you have to set it to the desired
value yourself prior to each call to "\f(CW\*(C`Interval_Scan_dec()\*(C'\fR" (see also
the example given below).
.Sp
Actually, the bit vector is not searched bit by bit, but one machine
word at a time, in order to speed up execution (which means that this
method is quite efficient).
.Sp
An empty list is returned if no such block can be found.
.Sp
Note that a single set bit (surrounded by cleared bits) is a valid
block by this definition. In that case the return values for "\f(CW$min\fR\*(L"
and \*(R"\f(CW$max\fR" are the same.
.Sp
Typical use:
.Sp
.Vb 5
\&    $start = $vector\->Size() \- 1;
\&    while (($start >= 0) &&
\&        (($min,$max) = $vector\->Interval_Scan_dec($start)))
\&    {
\&        $start = $min \- 2;
\&
\&        # do something with $min and $max
\&    }
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Interval_Copy($vec1,$offset2,$offset1,$length);\*(C'\fR
.Sp
This method allows you to copy a stretch of contiguous bits (starting
at any position "\f(CW$offset1\fR\*(L" you choose, with a length of \*(R"\f(CW$length\fR\*(L"
bits) from a given \*(R"source\*(L" bit vector \*(R"\f(CW$vec1\fR\*(L" to another position
\&\*(R"\f(CW$offset2\fR\*(L" in a \*(R"target\*(L" bit vector \*(R"\f(CW$vec2\fR".
.Sp
Note that the two bit vectors "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" do \fB\s-1NOT\s0\fR
need to have the same (matching) size!
.Sp
Consequently, any of the two terms "\f(CW\*(C`$offset1 + $length\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`$offset2 + $length\*(C'\fR\*(L" (or both) may exceed the actual length
of its corresponding bit vector (\*(R"\f(CW\*(C`$vec1\->Size()\*(C'\fR\*(L" and
\&\*(R"\f(CW\*(C`$vec2\->Size()\*(C'\fR", respectively).
.Sp
In such a case, the "\f(CW$length\fR" parameter is automatically reduced
internally so that both terms above are bounded by the number of bits
of their corresponding bit vector.
.Sp
This may even result in a length of zero, in which case nothing is
copied at all.
.Sp
(Of course the value of the "\f(CW$length\fR" parameter, supplied by you
in the initial method call, may also be zero right from the start!)
.Sp
Note also that "\f(CW$offset1\fR\*(L" and \*(R"\f(CW$offset2\fR\*(L" must lie within the
range \*(R"\f(CW0\fR\*(L" and, respectively, \*(R"\f(CW\*(C`$vec1\->Size()\-1\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`$vec2\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range" error
will occur.
.Sp
Note further that "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" may be identical, i.e.,
you may copy a stretch of contiguous bits from one part of a given
bit vector to another part.
.Sp
The source and the target interval may even overlap, in which case
the copying is automatically performed in ascending or descending
order (depending on the direction of the copy \- downwards or upwards
in the bit vector, respectively) to handle this situation correctly,
i.e., so that no bits are being overwritten before they have been
copied themselves.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Interval_Substitute($vec1,$off2,$len2,$off1,$len1);\*(C'\fR
.Sp
This method is (roughly) the same for bit vectors (i.e., arrays
of booleans) as what the \*(L"splice\*(R" function in Perl is for lists
(i.e., arrays of scalars).
.Sp
(See \*(L"splice\*(R" in perlfunc for more details about this function.)
.Sp
The method allows you to substitute a stretch of contiguous bits
(defined by a position (offset) "\f(CW$off1\fR\*(L" and a length of \*(R"\f(CW$len1\fR\*(L"
bits) from a given \*(R"source\*(L" bit vector \*(R"\f(CW$vec1\fR\*(L" for a different
stretch of contiguous bits (defined by a position (offset) \*(R"\f(CW$off2\fR\*(L"
and a length of \*(R"\f(CW$len2\fR\*(L" bits) in another, \*(R"target\*(L" bit vector
\&\*(R"\f(CW$vec2\fR".
.Sp
Note that the two bit vectors "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" do \fB\s-1NOT\s0\fR
need to have the same (matching) size!
.Sp
Note further that "\f(CW$off1\fR\*(L" and \*(R"\f(CW$off2\fR\*(L" must lie within the
range \*(R"\f(CW0\fR\*(L" and, respectively, \*(R"\f(CW\*(C`$vec1\->Size()\*(C'\fR\*(L" or
\&\*(R"\f(CW\*(C`$vec2\->Size()\*(C'\fR\*(L", or a fatal \*(R"offset out of range" error
will occur.
.Sp
Alert readers will have noticed that these upper limits are \fB\s-1NOT\s0\fR
"\f(CW\*(C`$vec1\->Size()\-1\*(C'\fR\*(L" and \*(R"\f(CW\*(C`$vec2\->Size()\-1\*(C'\fR", as they would
be for any other method in this module, but that these offsets may
actually point to one position \fB\s-1PAST THE END\s0\fR of the corresponding
bit vector.
.Sp
This is necessary in order to make it possible to \fB\s-1APPEND\s0\fR a given
stretch of bits to the target bit vector instead of \fB\s-1REPLACING\s0\fR
something in it.
.Sp
For reasons of symmetry and generality, the same applies to the offset
in the source bit vector, even though such an offset (one position past
the end of the bit vector) does not serve any practical purpose there
(but does not cause any harm either).
.Sp
(Actually this saves you from the need of testing for this special case,
in certain circumstances.)
.Sp
Note that whenever the term "\f(CW\*(C`$off1 + $len1\*(C'\fR\*(L" exceeds the size
\&\*(R"\f(CW\*(C`$vec1\->Size()\*(C'\fR\*(L" of bit vector \*(R"\f(CW$vec1\fR\*(L" (or if \*(R"\f(CW\*(C`$off2 + $len2\*(C'\fR\*(L"
exceeds \*(R"\f(CW\*(C`$vec2\->Size()\*(C'\fR\*(L"), the corresponding length (\*(R"\f(CW$len1\fR\*(L"
or \*(R"\f(CW$len2\fR\*(L", respectively) is automatically reduced internally
so that \*(R"\f(CW\*(C`$off1 + $len1 <= $vec1\->Size()\*(C'\fR\*(L" (and
\&\*(R"\f(CW\*(C`$off2 + $len2 <= $vec2\->Size()\*(C'\fR") holds.
.Sp
(Note that this does \fB\s-1NOT\s0\fR alter the intended result, even though
this may seem counter-intuitive at first!)
.Sp
This may even result in a length ("\f(CW$len1\fR\*(L" or \*(R"\f(CW$len2\fR") of zero.
.Sp
A length of zero for the interval in the \fB\s-1SOURCE\s0\fR bit vector
("\f(CW\*(C`$len1 == 0\*(C'\fR\*(L") means that the indicated stretch of bits in
the target bit vector (starting at position \*(R"\f(CW$off2\fR") is to
be replaced by \fB\s-1NOTHING\s0\fR, i.e., is to be \fB\s-1DELETED\s0\fR.
.Sp
A length of zero for the interval in the \fB\s-1TARGET\s0\fR bit vector
("\f(CW$len2\fR == 0") means that \fB\s-1NOTHING\s0\fR is replaced, and that the
stretch of bits from the source bit vector is simply \fB\s-1INSERTED\s0\fR
into the target bit vector at the indicated position ("\f(CW$off2\fR").
.Sp
If both length parameters are zero, nothing is done at all.
.Sp
Note that in contrast to any other method in this module (especially
"\f(CW\*(C`Interval_Copy()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Insert()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Delete()\*(C'\fR"), this method
\&\fB\s-1IMPLICITLY\s0\fR and \fB\s-1AUTOMATICALLY\s0\fR adapts the length of the resulting
bit vector as needed, as given by
.Sp
.Vb 2
\&        $size = $vec2\->Size();   #  before
\&        $size += $len1 \- $len2;  #  after
.Ve
.Sp
(The only other method in this module that changes the size of a bit
vector is the method "\f(CW\*(C`Resize()\*(C'\fR".)
.Sp
In other words, replacing a given interval of bits in the target bit
vector with a longer or shorter stretch of bits from the source bit
vector, or simply inserting ("\f(CW\*(C`$len2 == 0\*(C'\fR\*(L") a stretch of bits into
or deleting (\*(R"\f(CW\*(C`$len1 == 0\*(C'\fR") an interval of bits from the target bit
vector will automatically increase or decrease, respectively, the size
of the target bit vector accordingly.
.Sp
For the sake of generality, this may even result in a bit vector with
a size of zero (containing no bits at all).
.Sp
This is also the reason why bit vectors of length zero are permitted
in this module in the first place, starting with version 5.0.
.Sp
Finally, note that "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" may be identical, i.e.,
in-place processing is possible.
.Sp
(If you think about that for a while or if you look at the code,
you will see that this is far from trivial!)
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector\->is_empty())\*(C'\fR
.Sp
Tests whether the given bit vector is empty, i.e., whether \fB\s-1ALL\s0\fR of
its bits are cleared (in the \*(L"off\*(R" state).
.Sp
In \*(L"big integer\*(R" arithmetic, this is equivalent to testing whether
the number stored in the bit vector is zero ("\f(CW0\fR").
.Sp
Returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the bit vector is empty and \*(R"false\*(L" (\*(R"\f(CW0\fR")
otherwise.
.Sp
Note that this method also returns \*(L"true\*(R" ("\f(CW1\fR") if the given bit
vector has a length of zero, i.e., if it contains no bits at all.
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector\->is_full())\*(C'\fR
.Sp
Tests whether the given bit vector is full, i.e., whether \fB\s-1ALL\s0\fR of
its bits are set (in the \*(L"on\*(R" state).
.Sp
In \*(L"big integer\*(R" arithmetic, this is equivalent to testing whether
the number stored in the bit vector is minus one (\*(L"\-1\*(R").
.Sp
Returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the bit vector is full and \*(R"false\*(L" (\*(R"\f(CW0\fR")
otherwise.
.Sp
If the given bit vector has a length of zero (i.e., if it contains
no bits at all), this method returns \*(L"false\*(R" ("\f(CW0\fR").
.IP "\(bu" 2
\&\f(CW\*(C`if ($vec1\->equal($vec2))\*(C'\fR
.Sp
Tests the two given bit vectors for equality.
.Sp
Returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if the two bit vectors are exact
copies of one another and \*(R"false\*(L" (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`$cmp = $vec1\->Lexicompare($vec2);\*(C'\fR
.Sp
Compares the two given bit vectors, which are
regarded as \fB\s-1UNSIGNED\s0\fR numbers in binary representation.
.Sp
The method returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if the first bit vector is smaller
than the second bit vector, \*(R"\f(CW0\fR\*(L" if the two bit vectors are
exact copies of one another and \*(R"\f(CW1\fR" if the first bit vector
is greater than the second bit vector.
.IP "\(bu" 2
\&\f(CW\*(C`$cmp = $vec1\->Compare($vec2);\*(C'\fR
.Sp
Compares the two given bit vectors, which are
regarded as \fB\s-1SIGNED\s0\fR numbers in binary representation.
.Sp
The method returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if the first bit vector is smaller
than the second bit vector, \*(R"\f(CW0\fR\*(L" if the two bit vectors are
exact copies of one another and \*(R"\f(CW1\fR" if the first bit vector
is greater than the second bit vector.
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Hex();\*(C'\fR
.Sp
Returns a hexadecimal string representing the given bit vector.
.Sp
Note that this representation is quite compact, in that it only
needs at most twice the number of bytes needed to store the bit
vector itself, internally.
.Sp
Note also that since a hexadecimal digit is always worth four bits,
the length of the resulting string is always a multiple of four bits,
regardless of the true length (in bits) of the given bit vector.
.Sp
Finally, note that the \fB\s-1LEAST\s0\fR significant hexadecimal digit is
located at the \fB\s-1RIGHT\s0\fR end of the resulting string, and the \fB\s-1MOST\s0\fR
significant digit at the \fB\s-1LEFT\s0\fR end.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Hex($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from a hexadecimal
string, such as returned by the method "\f(CW\*(C`to_Hex()\*(C'\fR" (see above).
.Sp
Remember that the least significant bits are always to the right of a
hexadecimal string, and the most significant bits to the left. Therefore,
the string is actually read in from right to left while the bit vector
is filled accordingly, 4 bits at a time, starting with the least significant
bits and going upward to the most significant bits.
.Sp
If the given string contains less hexadecimal digits than are needed
to completely fill the given bit vector, the remaining (most significant)
bits are all cleared.
.Sp
This also means that, even if the given string does not contain enough digits
to completely fill the given bit vector, the previous contents of the
bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.
.Sp
(In fact they are ignored completely \- they are not even checked for
proper syntax. See also below for more about that.)
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.Sp
If during the process of reading the given string any character is
encountered which is not a hexadecimal digit, a fatal syntax error
ensues (\*(L"input string syntax error\*(R").
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Bin();\*(C'\fR
.Sp
Returns a binary string representing the given bit vector.
.Sp
Example:
.Sp
.Vb 4
\&  $vector = Bit::Vector\->new(8);
\&  $vector\->Primes();
\&  $string = $vector\->to_Bin();
\&  print "\*(Aq$string\*(Aq\en";
.Ve
.Sp
This prints:
.Sp
.Vb 1
\&  \*(Aq10101100\*(Aq
.Ve
.Sp
(Bits #7, #5, #3 and #2 are set.)
.Sp
Note that the \fB\s-1LEAST\s0\fR significant bit is located at the \fB\s-1RIGHT\s0\fR
end of the resulting string, and the \fB\s-1MOST\s0\fR significant bit at
the \fB\s-1LEFT\s0\fR end.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Bin($string);\*(C'\fR
.Sp
This method allows you to read in the contents of a bit vector from a
binary string, such as returned by the method "\f(CW\*(C`to_Bin()\*(C'\fR" (see above).
.Sp
Note that this method assumes that the \fB\s-1LEAST\s0\fR significant bit is located at
the \fB\s-1RIGHT\s0\fR end of the binary string, and the \fB\s-1MOST\s0\fR significant bit at the
\&\fB\s-1LEFT\s0\fR end. Therefore, the string is actually read in from right to left
while the bit vector is filled accordingly, one bit at a time, starting with
the least significant bit and going upward to the most significant bit.
.Sp
If the given string contains less binary digits ("\f(CW0\fR\*(L" and \*(R"\f(CW1\fR") than are
needed to completely fill the given bit vector, the remaining (most significant)
bits are all cleared.
.Sp
This also means that, even if the given string does not contain enough digits
to completely fill the given bit vector, the previous contents of the
bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit vector,
the superfluous characters are simply ignored.
.Sp
(In fact they are ignored completely \- they are not even checked for
proper syntax. See also below for more about that.)
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.Sp
If during the process of reading the given string any character is
encountered which is not either "\f(CW0\fR\*(L" or \*(R"\f(CW1\fR\*(L", a fatal syntax error
ensues (\*(R"input string syntax error").
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Dec();\*(C'\fR
.Sp
This method returns a string representing the contents of the given bit
vector converted to decimal (base \f(CW10\fR).
.Sp
Note that this method assumes the given bit vector to be \fB\s-1SIGNED\s0\fR (and
to contain a number in two's complement binary representation).
.Sp
Consequently, whenever the most significant bit of the given bit vector
is set, the number stored in it is regarded as being \fB\s-1NEGATIVE\s0\fR.
.Sp
The resulting string can be fed into "\f(CW\*(C`from_Dec()\*(C'\fR" (see below) in order
to copy the contents of this bit vector to another one (or to restore the
contents of this one). This is not advisable, though, since this would be
very inefficient (there are much more efficient methods for storing and
copying bit vectors in this module).
.Sp
Note that such conversion from binary to decimal is inherently slow
since the bit vector has to be repeatedly divided by \f(CW10\fR with remainder
until the quotient becomes \f(CW0\fR (each remainder in turn represents a single
decimal digit of the resulting string).
.Sp
This is also true for the implementation of this method in this module,
even though a considerable effort has been made to speed it up: instead of
repeatedly dividing by \f(CW10\fR, the bit vector is repeatedly divided by the
largest power of \f(CW10\fR that will fit into a machine word. The remainder is
then repeatedly divided by \f(CW10\fR using only machine word arithmetics, which
is much faster than dividing the whole bit vector (\*(L"divide and rule\*(R" principle).
.Sp
According to my own measurements, this resulted in an 8\-fold speed increase
over the straightforward approach.
.Sp
Still, conversion to decimal should be used only where absolutely necessary.
.Sp
Keep the resulting string stored in some variable if you need it again,
instead of converting the bit vector all over again.
.Sp
Beware that if you set the configuration for overloaded operators to
\&\*(L"output=decimal\*(R", this method will be called for every bit vector
enclosed in double quotes!
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Dec($string);\*(C'\fR
.Sp
This method allows you to convert a given decimal number, which may be
positive or negative, into two's complement binary representation, which
is then stored in the given bit vector.
.Sp
The decimal number should always be provided as a string, to avoid possible
truncation (due to the limited precision of integers in Perl) or formatting
(due to Perl's use of scientific notation for large numbers), which would
lead to errors.
.Sp
If the binary representation of the given decimal number is too big to fit
into the given bit vector (if the given bit vector does not contain enough
bits to hold it), a fatal \*(L"numeric overflow error\*(R" occurs.
.Sp
If the input string contains other characters than decimal digits (\f(CW\*(C`0\-9\*(C'\fR)
and an optional leading sign ("\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR\*(L"), a fatal \*(R"input string
syntax error" occurs.
.Sp
Beware that large positive numbers which cause the most significant bit to
be set (e.g. \*(L"255\*(R" in a bit vector with 8 bits) will be printed as negative
numbers when converted back to decimal using the method \*(L"\fIto_Dec()\fR\*(R" (e.g.
\&\*(L"\-1\*(R", in our example), because numbers with the most significant bit set
are considered to be negative in two's complement binary representation.
.Sp
Note also that while it is possible to thusly enter negative numbers as
large positive numbers (e.g. \*(L"255\*(R" for \*(L"\-1\*(R" in a bit vector with 8 bits),
the contrary isn't, i.e., you cannot enter \*(L"\-255\*(R" for \*(L"+1\*(R", in our example.
A fatal \*(L"numeric overflow error\*(R" will occur if you try to do so.
.Sp
If possible program abortion is unwanted or intolerable, use
"\f(CW\*(C`eval\*(C'\fR", like this:
.Sp
.Vb 5
\&  eval { $vector\->from_Dec("1152921504606846976"); };
\&  if ($@)
\&  {
\&      # an error occurred
\&  }
.Ve
.Sp
There are four possible error messages:
.Sp
.Vb 1
\&  if ($@ =~ /item is not a string/)
\&
\&  if ($@ =~ /input string syntax error/)
\&
\&  if ($@ =~ /numeric overflow error/)
\&
\&  if ($@ =~ /unable to allocate memory/)
.Ve
.Sp
Note that the conversion from decimal to binary is costly in terms of
processing time, since a lot of multiplications have to be carried out
(in principle, each decimal digit must be multiplied with the binary
representation of the power of \f(CW10\fR corresponding to its position in
the decimal number, i.e., 1, 10, 100, 1000, 10000 and so on).
.Sp
This is not as time consuming as the opposite conversion, from binary
to decimal (where successive divisions have to be carried out, which
are even more expensive than multiplications), but still noticeable.
.Sp
Again (as in the case of "\f(CW\*(C`to_Dec()\*(C'\fR\*(L"), the implementation of this
method in this module uses the principle of \*(R"divide and rule" in order
to speed up the conversion, i.e., as many decimal digits as possible
are first accumulated (converted) in a machine word and only then
stored in the given bit vector.
.Sp
Even so, use this method only where absolutely necessary if speed is
an important consideration in your application.
.Sp
Beware that if you set the configuration for overloaded operators to
\&\*(L"input=decimal\*(R", this method will be called for every scalar operand
you use!
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Enum();\*(C'\fR
.Sp
Converts the given bit vector or set into an enumeration of single
indices and ranges of indices (\*(L".newsrc\*(R" style), representing the
bits that are set ("\f(CW1\fR") in the bit vector.
.Sp
Example:
.Sp
.Vb 7
\&  $vector = Bit::Vector\->new(20);
\&  $vector\->Bit_On(2);
\&  $vector\->Bit_On(3);
\&  $vector\->Bit_On(11);
\&  $vector\->Interval_Fill(5,7);
\&  $vector\->Interval_Fill(13,19);
\&  print "\*(Aq", $vector\->to_Enum(), "\*(Aq\en";
.Ve
.Sp
which prints
.Sp
.Vb 1
\&  \*(Aq2,3,5\-7,11,13\-19\*(Aq
.Ve
.Sp
If the given bit vector is empty, the resulting string will
also be empty.
.Sp
Note, by the way, that the above example can also be written
a little handier, perhaps, as follows:
.Sp
.Vb 4
\&  Bit::Vector\->Configuration("out=enum");
\&  $vector = Bit::Vector\->new(20);
\&  $vector\->Index_List_Store(2,3,5,6,7,11,13,14,15,16,17,18,19);
\&  print "\*(Aq$vector\*(Aq\en";
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Enum($string);\*(C'\fR
.Sp
This method first empties the given bit vector and then tries to
set the bits and ranges of bits specified in the given string.
.Sp
The string "\f(CW$string\fR\*(L" must only contain unsigned integers
or ranges of integers (two unsigned integers separated by a
dash \*(R"\-\*(L"), separated by commas (\*(R",").
.Sp
All other characters are disallowed (including white space!)
and will lead to a fatal \*(L"input string syntax error\*(R".
.Sp
In each range, the first integer (the lower limit of the range)
must always be less than or equal to the second integer (the
upper limit), or a fatal \*(L"minimum > maximum index\*(R" error occurs.
.Sp
All integers must lie in the permitted range for the given
bit vector, i.e., they must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.Sp
If this condition is not met, a fatal \*(L"index out of range\*(R"
error occurs.
.Sp
If possible program abortion is unwanted or intolerable, use
"\f(CW\*(C`eval\*(C'\fR", like this:
.Sp
.Vb 5
\&  eval { $vector\->from_Enum("2,3,5\-7,11,13\-19"); };
\&  if ($@)
\&  {
\&      # an error occurred
\&  }
.Ve
.Sp
There are four possible error messages:
.Sp
.Vb 1
\&  if ($@ =~ /item is not a string/)
\&
\&  if ($@ =~ /input string syntax error/)
\&
\&  if ($@ =~ /index out of range/)
\&
\&  if ($@ =~ /minimum > maximum index/)
.Ve
.Sp
Note that the order of the indices and ranges is irrelevant,
i.e.,
.Sp
.Vb 1
\&  eval { $vector\->from_Enum("11,5\-7,3,13\-19,2"); };
.Ve
.Sp
results in the same vector as in the example above.
.Sp
Ranges and indices may also overlap.
.Sp
This is because each (single) index in the string is passed
to the method "\f(CW\*(C`Bit_On()\*(C'\fR\*(L", internally, and each range to
the method \*(R"\f(CW\*(C`Interval_Fill()\*(C'\fR".
.Sp
This means that the resulting bit vector is just the union
of all the indices and ranges specified in the given string.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_Off($index);\*(C'\fR
.Sp
Clears the bit with index "\f(CW$index\fR" in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_On($index);\*(C'\fR
.Sp
Sets the bit with index "\f(CW$index\fR" in the given vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->bit_flip($index)\*(C'\fR
.Sp
Flips (i.e., complements) the bit with index "\f(CW$index\fR"
in the given vector.
.Sp
Moreover, this method returns the \fB\s-1NEW\s0\fR state of the
bit in question, i.e., it returns "\f(CW0\fR\*(L" if the bit is
cleared or \*(R"\f(CW1\fR" if the bit is set (\fB\s-1AFTER\s0\fR flipping it).
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector\->bit_test($index))\*(C'\fR
.Sp
\&\f(CW\*(C`if ($vector\->contains($index))\*(C'\fR
.Sp
Returns the current state of the bit with index "\f(CW$index\fR\*(L"
in the given vector, i.e., returns \*(R"\f(CW0\fR\*(L" if it is cleared
(in the \*(R"off\*(L" state) or \*(R"\f(CW1\fR\*(L" if it is set (in the \*(R"on" state).
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Bit_Copy($index,$bit);\*(C'\fR
.Sp
Sets the bit with index "\f(CW$index\fR\*(L" in the given vector either
to \*(R"\f(CW0\fR\*(L" or \*(R"\f(CW1\fR\*(L" depending on the boolean value \*(R"\f(CW$bit\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->LSB($bit);\*(C'\fR
.Sp
Allows you to set the least significant bit in the given bit
vector to the value given by the boolean parameter "\f(CW$bit\fR".
.Sp
This is a (faster) shortcut for "\f(CW\*(C`$vector\->Bit_Copy(0,$bit);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->MSB($bit);\*(C'\fR
.Sp
Allows you to set the most significant bit in the given bit
vector to the value given by the boolean parameter "\f(CW$bit\fR".
.Sp
This is a (faster) shortcut for
"\f(CW\*(C`$vector\->Bit_Copy($vector\->Size()\-1,$bit);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$bit = $vector\->lsb();\*(C'\fR
.Sp
Returns the least significant bit of the given bit vector.
.Sp
This is a (faster) shortcut for "\f(CW\*(C`$bit = $vector\->bit_test(0);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$bit = $vector\->msb();\*(C'\fR
.Sp
Returns the most significant bit of the given bit vector.
.Sp
This is a (faster) shortcut for
"\f(CW\*(C`$bit = $vector\->bit_test($vector\->Size()\-1);\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->rotate_left();\*(C'\fR
.Sp
.Vb 7
\&  carry             MSB           vector:           LSB
\&   out:
\&  +\-\-\-+            +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+
\&  |   |  <\-\-\-+\-\-\-  |   |   |   |    ...    |   |   |   |  <\-\-\-+
\&  +\-\-\-+      |     +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+      |
\&             |                                                |
\&             +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->rotate_right();\*(C'\fR
.Sp
.Vb 7
\&          MSB           vector:           LSB            carry
\&                                                          out:
\&         +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+           +\-\-\-+
\&  +\-\-\->  |   |   |   |    ...    |   |   |   |  \-\-\-+\-\-\-> |   |
\&  |      +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+     |     +\-\-\-+
\&  |                                                |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->shift_left($carry_in);\*(C'\fR
.Sp
.Vb 5
\&  carry         MSB           vector:           LSB         carry
\&   out:                                                      in:
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
\&  |   |  <\-\-\-  |   |   |   |    ...    |   |   |   |  <\-\-\-  |   |
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$carry_out = $vector\->shift_right($carry_in);\*(C'\fR
.Sp
.Vb 5
\&  carry         MSB           vector:           LSB         carry
\&   in:                                                       out:
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
\&  |   |  \-\-\->  |   |   |   |    ...    |   |   |   |  \-\-\->  |   |
\&  +\-\-\-+        +\-\-\-+\-\-\-+\-\-\-+\-\-\-     \-\-\-+\-\-\-+\-\-\-+\-\-\-+        +\-\-\-+
.Ve
.Sp
The least significant bit (\s-1LSB\s0) is the bit with index "\f(CW0\fR\*(L", the most
significant bit (\s-1MSB\s0) is the bit with index \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR".
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Move_Left($bits);\*(C'\fR
.Sp
Shifts the given bit vector left by "\f(CW$bits\fR\*(L" bits, i.e., inserts \*(R"\f(CW$bits\fR\*(L"
new bits at the lower end (least significant bit) of the bit vector, moving
all other bits up by \*(R"\f(CW$bits\fR\*(L" places, thereby losing the \*(R"\f(CW$bits\fR" most
significant bits.
.Sp
The inserted new bits are all cleared (set to the \*(L"off\*(R" state).
.Sp
This method does nothing if "\f(CW$bits\fR" is equal to zero.
.Sp
Beware that the whole bit vector is cleared \fB\s-1WITHOUT WARNING\s0\fR if
"\f(CW$bits\fR" is greater than or equal to the size of the given bit vector!
.Sp
In fact this method is equivalent to
.Sp
.Vb 1
\&  for ( $i = 0; $i < $bits; $i++ ) { $vector\->shift_left(0); }
.Ve
.Sp
except that it is much more efficient (for "\f(CW$bits\fR" greater than or
equal to the number of bits in a machine word on your system) than
this straightforward approach.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Move_Right($bits);\*(C'\fR
.Sp
Shifts the given bit vector right by "\f(CW$bits\fR\*(L" bits, i.e., deletes the
\&\*(R"\f(CW$bits\fR\*(L" least significant bits of the bit vector, moving all other bits
down by \*(R"\f(CW$bits\fR\*(L" places, thereby creating \*(R"\f(CW$bits\fR" new bits at the upper
end (most significant bit) of the bit vector.
.Sp
These new bits are all cleared (set to the \*(L"off\*(R" state).
.Sp
This method does nothing if "\f(CW$bits\fR" is equal to zero.
.Sp
Beware that the whole bit vector is cleared \fB\s-1WITHOUT WARNING\s0\fR if
"\f(CW$bits\fR" is greater than or equal to the size of the given bit vector!
.Sp
In fact this method is equivalent to
.Sp
.Vb 1
\&  for ( $i = 0; $i < $bits; $i++ ) { $vector\->shift_right(0); }
.Ve
.Sp
except that it is much more efficient (for "\f(CW$bits\fR" greater than or
equal to the number of bits in a machine word on your system) than
this straightforward approach.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Insert($offset,$bits);\*(C'\fR
.Sp
This method inserts "\f(CW$bits\fR\*(L" fresh new bits at position \*(R"\f(CW$offset\fR"
in the given bit vector.
.Sp
The "\f(CW$bits\fR\*(L" most significant bits are lost, and all bits starting
with bit number \*(R"\f(CW$offset\fR\*(L" up to and including bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-$bits\-1\*(C'\fR\*(L" are moved up by \*(R"\f(CW$bits\fR" places.
.Sp
The now vacant "\f(CW$bits\fR\*(L" bits starting at bit number \*(R"\f(CW$offset\fR\*(L"
(up to and including bit number \*(R"\f(CW\*(C`$offset+$bits\-1\*(C'\fR") are then set
to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR increase the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR extended at its upper end to
\&\*(L"rescue\*(R" the "\f(CW$bits\fR" uppermost (most significant) bits \- instead,
these bits are lost forever.
.Sp
If you don't want this to happen, you have to increase the size of the
given bit vector \fB\s-1EXPLICITLY\s0\fR and \fB\s-1BEFORE\s0\fR you perform the \*(L"Insert\*(R"
operation, with a statement such as the following:
.Sp
.Vb 1
\&  $vector\->Resize($vector\->Size() + $bits);
.Ve
.Sp
Or use the method "\f(CW\*(C`Interval_Substitute()\*(C'\fR\*(L" instead of \*(R"\f(CW\*(C`Insert()\*(C'\fR",
which performs automatic growing and shrinking of its target bit vector.
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $bits\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
all the bits starting with bit number \*(R"\f(CW$offset\fR\*(L" up to bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Delete($offset,$bits);\*(C'\fR
.Sp
This method deletes, i.e., removes the bits starting at position
"\f(CW$offset\fR\*(L" up to and including bit number \*(R"\f(CW\*(C`$offset+$bits\-1\*(C'\fR"
from the given bit vector.
.Sp
The remaining uppermost bits (starting at position "\f(CW\*(C`$offset+$bits\*(C'\fR\*(L"
up to and including bit number \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L") are moved
down by \*(R"\f(CW$bits\fR" places.
.Sp
The now vacant uppermost (most significant) "\f(CW$bits\fR" bits are then
set to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR decrease the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR clipped at its upper end to
\&\*(L"get rid of\*(R" the vacant "\f(CW$bits\fR" uppermost bits.
.Sp
If you don't want this, i.e., if you want the bit vector to shrink
accordingly, you have to do so \fB\s-1EXPLICITLY\s0\fR and \fB\s-1AFTER\s0\fR the \*(L"Delete\*(R"
operation, with a couple of statements such as these:
.Sp
.Vb 3
\&  $size = $vector\->Size();
\&  if ($bits > $size) { $bits = $size; }
\&  $vector\->Resize($size \- $bits);
.Ve
.Sp
Or use the method "\f(CW\*(C`Interval_Substitute()\*(C'\fR\*(L" instead of \*(R"\f(CW\*(C`Delete()\*(C'\fR",
which performs automatic growing and shrinking of its target bit vector.
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $bits\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
all the bits starting with bit number \*(R"\f(CW$offset\fR\*(L" up to bit number
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vector\->increment();\*(C'\fR
.Sp
This method increments the given bit vector.
.Sp
Note that this method regards bit vectors as being unsigned,
i.e., the largest possible positive number is directly
followed by the smallest possible (or greatest possible,
speaking in absolute terms) negative number:
.Sp
.Vb 2
\&  before:  2 ^ (b\-1) \- 1    (= "0111...1111")
\&  after:   2 ^ (b\-1)        (= "1000...0000")
.Ve
.Sp
where "\f(CW\*(C`b\*(C'\fR" is the number of bits of the given bit vector.
.Sp
The method returns \*(L"false\*(R" ("\f(CW0\fR\*(L") in all cases except when a
carry over occurs (in which case it returns \*(R"true\*(L", i.e., \*(R"\f(CW1\fR\*(L"),
which happens when the number \*(R"1111...1111\*(L" is incremented,
which gives \*(R"0000...0000" plus a carry over to the next higher
(binary) digit.
.Sp
This can be used for the terminating condition of a \*(L"while\*(R" loop,
for instance, in order to cycle through all possible values the
bit vector can assume.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vector\->decrement();\*(C'\fR
.Sp
This method decrements the given bit vector.
.Sp
Note that this method regards bit vectors as being unsigned,
i.e., the smallest possible (or greatest possible, speaking
in absolute terms) negative number is directly followed by
the largest possible positive number:
.Sp
.Vb 2
\&  before:  2 ^ (b\-1)        (= "1000...0000")
\&  after:   2 ^ (b\-1) \- 1    (= "0111...1111")
.Ve
.Sp
where "\f(CW\*(C`b\*(C'\fR" is the number of bits of the given bit vector.
.Sp
The method returns \*(L"false\*(R" ("\f(CW0\fR\*(L") in all cases except when a
carry over occurs (in which case it returns \*(R"true\*(L", i.e., \*(R"\f(CW1\fR\*(L"),
which happens when the number \*(R"0000...0000\*(L" is decremented,
which gives \*(R"1111...1111" minus a carry over to the next higher
(binary) digit.
.Sp
This can be used for the terminating condition of a \*(L"while\*(R" loop,
for instance, in order to cycle through all possible values the
bit vector can assume.
.IP "\(bu" 2
\&\f(CW\*(C`$overflow = $vec2\->inc($vec1);\*(C'\fR
.Sp
This method copies the contents of bit vector "\f(CW$vec1\fR\*(L" to bit
vector \*(R"\f(CW$vec2\fR" and increments the copy (not the original).
.Sp
If by incrementing the number its sign becomes invalid, the return
value (\*(L"overflow\*(R" flag) will be true ("\f(CW1\fR\*(L"), or false (\*(R"\f(CW0\fR\*(L")
if not. (See the description of the method \*(R"\fIadd()\fR\*(L" below for
a more in-depth explanation of what \*(R"overflow" means).
.Sp
Note that in-place operation is also possible, i.e., "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR" may be identical.
.IP "\(bu" 2
\&\f(CW\*(C`$overflow = $vec2\->dec($vec1);\*(C'\fR
.Sp
This method copies the contents of bit vector "\f(CW$vec1\fR\*(L" to bit
vector \*(R"\f(CW$vec2\fR" and decrements the copy (not the original).
.Sp
If by decrementing the number its sign becomes invalid, the return
value (\*(L"overflow\*(R" flag) will be true ("\f(CW1\fR\*(L"), or false (\*(R"\f(CW0\fR\*(L")
if not. (See the description of the method \*(R"\fIsubtract()\fR\*(L" below
for a more in-depth explanation of what \*(R"overflow" means).
.Sp
Note that in-place operation is also possible, i.e., "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR" may be identical.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vec3\->add($vec1,$vec2,$carry);\*(C'\fR
.Sp
\&\f(CW\*(C`($carry,$overflow) = $vec3\->add($vec1,$vec2,$carry);\*(C'\fR
.Sp
This method adds the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" with carry \*(R"\f(CW$carry\fR\*(L" and stores the result in
bit vector \*(R"\f(CW$vec3\fR".
.Sp
I.e.,
            \f(CW$vec3\fR = \f(CW$vec1\fR + \f(CW$vec2\fR + \f(CW$carry\fR
.Sp
Note that the "\f(CW$carry\fR\*(L" parameter is a boolean value, i.e.,
only its least significant bit is taken into account. (Think of
it as though \*(R"\f(CW\*(C`$carry &= 1;\*(C'\fR" was always executed internally.)
.Sp
In scalar context, the method returns a boolean value which
indicates if a carry over (to the next higher bit position)
has occured. In list context, the method returns the carry
and the overflow flag (in this order).
.Sp
The overflow flag is true ("\f(CW1\fR") if the sign (i.e., the most
significant bit) of the result is wrong. This can happen when
adding two very large positive numbers or when adding two (by
their absolute value) very large negative numbers. See also
further below.
.Sp
The carry in\- and output is needed mainly for cascading, i.e.,
to add numbers that are fragmented into several pieces.
.Sp
Example:
.Sp
.Vb 1
\&  # initialize
\&
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $a[$i] = Bit::Vector\->new($bits);
\&      $b[$i] = Bit::Vector\->new($bits);
\&      $c[$i] = Bit::Vector\->new($bits);
\&  }
\&
\&  # fill @a and @b
\&
\&  # $a[  0 ] is low order part,
\&  # $a[$n\-1] is high order part,
\&  # and same for @b
\&
\&  # add
\&
\&  $carry = 0;
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $carry = $c[$i]\->add($a[$i],$b[$i],$carry);
\&  }
.Ve
.Sp
Note that it makes no difference to this method whether the numbers
in "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" are unsigned or signed (i.e., in two's
complement binary representation).
.Sp
Note however that the return value (carry flag) is not meaningful
when the numbers are \fB\s-1SIGNED\s0\fR.
.Sp
Moreover, when the numbers are signed, a special type of error can
occur which is commonly called an \*(L"overflow error\*(R".
.Sp
An overflow error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry over
from the next-lower bit position (\*(L"\s-1MSB\-1\*(R"\s0).
.Sp
In fact matters are a bit more complicated than that: the overflow
flag is set to \*(L"true\*(R" whenever there is a carry over from bit
position \s-1MSB\-1\s0 to the most significant bit (\s-1MSB\s0) but no carry
over from the \s-1MSB\s0 to the output carry flag, or vice-versa, i.e.,
when there is no carry over from bit position \s-1MSB\-1\s0 to the most
significant bit (\s-1MSB\s0) but a carry over to the output carry flag.
.Sp
Thus the overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most significant
bit position.
.IP "\(bu" 2
\&\f(CW\*(C`$carry = $vec3\->subtract($vec1,$vec2,$carry);\*(C'\fR
.Sp
\&\f(CW\*(C`($carry,$overflow) = $vec3\->subtract($vec1,$vec2,$carry);\*(C'\fR
.Sp
This method subtracts the two numbers contained in bit vector
"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR\*(L" with carry \*(R"\f(CW$carry\fR\*(L" and stores the
result in bit vector \*(R"\f(CW$vec3\fR".
.Sp
I.e.,
            \f(CW$vec3\fR = \f(CW$vec1\fR \- \f(CW$vec2\fR \- \f(CW$carry\fR
.Sp
Note that the "\f(CW$carry\fR\*(L" parameter is a boolean value, i.e.,
only its least significant bit is taken into account. (Think of
it as though \*(R"\f(CW\*(C`$carry &= 1;\*(C'\fR" was always executed internally.)
.Sp
In scalar context, the method returns a boolean value which
indicates if a carry over (to the next higher bit position)
has occured. In list context, the method returns the carry
and the overflow flag (in this order).
.Sp
The overflow flag is true ("\f(CW1\fR") if the sign (i.e., the most
significant bit) of the result is wrong. This can happen when
subtracting a very large negative number from a very large
positive number or vice-versa. See also further below.
.Sp
The carry in\- and output is needed mainly for cascading, i.e.,
to subtract numbers that are fragmented into several pieces.
.Sp
Example:
.Sp
.Vb 1
\&  # initialize
\&
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $a[$i] = Bit::Vector\->new($bits);
\&      $b[$i] = Bit::Vector\->new($bits);
\&      $c[$i] = Bit::Vector\->new($bits);
\&  }
\&
\&  # fill @a and @b
\&
\&  # $a[  0 ] is low order part,
\&  # $a[$n\-1] is high order part,
\&  # and same for @b
\&
\&  # subtract
\&
\&  $carry = 0;
\&  for ( $i = 0; $i < $n; $i++ )
\&  {
\&      $carry = $c[$i]\->subtract($a[$i],$b[$i],$carry);
\&  }
.Ve
.Sp
Note that it makes no difference to this method whether the numbers
in "\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR" are unsigned or signed (i.e., in two's
complement binary representation).
.Sp
Note however that the return value (carry flag) is not meaningful
when the numbers are \fB\s-1SIGNED\s0\fR.
.Sp
Moreover, when the numbers are signed, a special type of error can
occur which is commonly called an \*(L"overflow error\*(R".
.Sp
An overflow error occurs when the sign of the result (its most
significant bit) is flipped (i.e., falsified) by a carry over
from the next-lower bit position (\*(L"\s-1MSB\-1\*(R"\s0).
.Sp
In fact matters are a bit more complicated than that: the overflow
flag is set to \*(L"true\*(R" whenever there is a carry over from bit
position \s-1MSB\-1\s0 to the most significant bit (\s-1MSB\s0) but no carry
over from the \s-1MSB\s0 to the output carry flag, or vice-versa, i.e.,
when there is no carry over from bit position \s-1MSB\-1\s0 to the most
significant bit (\s-1MSB\s0) but a carry over to the output carry flag.
.Sp
Thus the overflow flag is the result of an exclusive-or operation
between incoming and outgoing carry over at the most significant
bit position.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Neg($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$vec2\->Negate($vec1);\*(C'\fR
.Sp
This method calculates the two's complement of the number in bit
vector "\f(CW$vec1\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec2\fR".
.Sp
Calculating the two's complement of a given number in binary representation
consists of inverting all bits and incrementing the result by one.
.Sp
This is the same as changing the sign of the given number from "\f(CW\*(C`+\*(C'\fR\*(L" to
\&\*(R"\f(CW\*(C`\-\*(C'\fR" or vice-versa. In other words, applying this method twice on a given
number yields the original number again.
.Sp
Note that in-place processing is also possible, i.e., "\f(CW$vec1\fR\*(L" and
\&\*(R"\f(CW$vec2\fR" may be identical.
.Sp
Most importantly, beware that this method produces a counter-intuitive
result if the number contained in bit vector "\f(CW$vec1\fR" is \f(CW\*(C`2 ^ (n\-1)\*(C'\fR
(i.e., \*(L"1000...0000\*(R"), where "\f(CW\*(C`n\*(C'\fR" is the number of bits the given bit
vector contains: The negated value of this number is the number itself!
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Abs($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$vec2\->Absolute($vec1);\*(C'\fR
.Sp
Depending on the sign (i.e., the most significant bit) of the number in
bit vector "\f(CW$vec1\fR\*(L", the contents of bit vector \*(R"\f(CW$vec1\fR\*(L" are copied
to bit vector \*(R"\f(CW$vec2\fR\*(L" either with the method \*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L" (if the number
in bit vector \*(R"\f(CW$vec1\fR\*(L" is positive), or with \*(R"\f(CW\*(C`Negate()\*(C'\fR\*(L" (if the number
in bit vector \*(R"\f(CW$vec1\fR" is negative).
.Sp
In other words, this method calculates the absolute value of the number
in bit vector "\f(CW$vec1\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec2\fR".
.Sp
Note that in-place processing is also possible, i.e., "\f(CW$vec1\fR\*(L" and
\&\*(R"\f(CW$vec2\fR" may be identical.
.Sp
Most importantly, beware that this method produces a counter-intuitive
result if the number contained in bit vector "\f(CW$vec1\fR" is \f(CW\*(C`2 ^ (n\-1)\*(C'\fR
(i.e., \*(L"1000...0000\*(R"), where "\f(CW\*(C`n\*(C'\fR" is the number of bits the given bit
vector contains: The absolute value of this number is the number itself,
even though this number is still negative by definition (the most
significant bit is still set)!
.IP "\(bu" 2
\&\f(CW\*(C`$sign = $vector\->Sign();\*(C'\fR
.Sp
This method returns "\f(CW0\fR\*(L" if all bits in the given bit vector are cleared,
i.e., if the given bit vector contains the number \*(R"\f(CW0\fR", or if the given
bit vector has a length of zero (contains no bits at all).
.Sp
If not all bits are cleared, this method returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if the most
significant bit is set (i.e., if the bit vector contains a negative
number), or \*(R"\f(CW1\fR" otherwise (i.e., if the bit vector contains a
positive number).
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Multiply($vec1,$vec2);\*(C'\fR
.Sp
This method multiplies the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" and stores the result in bit vector \*(R"\f(CW$vec3\fR".
.Sp
Note that this method regards its arguments as \fB\s-1SIGNED\s0\fR.
.Sp
If you want to make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit longer than the
largest number you wish to represent, right from the start, or proceed as
follows:
.Sp
.Vb 8
\&    $msb1 = $vec1\->msb();
\&    $msb2 = $vec2\->msb();
\&    $vec1\->Resize($vec1\->Size()+1);
\&    $vec2\->Resize($vec2\->Size()+1);
\&    $vec3\->Resize($vec3\->Size()+1);
\&    $vec1\->MSB($msb1);
\&    $vec2\->MSB($msb2);
\&    $vec3\->Multiply($vec1,$vec2);
.Ve
.Sp
Note also that all three bit vector arguments must in principle obey the
rule of matching sizes, but that the bit vector "\f(CW$vec3\fR\*(L" may be larger
than the two factors \*(R"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR".
.Sp
In fact multiplying two binary numbers with "\f(CW\*(C`n\*(C'\fR\*(L" bits may yield a result
which is at most \*(R"\f(CW\*(C`2n\*(C'\fR" bits long.
.Sp
Therefore, it is usually a good idea to let bit vector "\f(CW$vec3\fR\*(L" have
twice the size of bit vector \*(R"\f(CW$vec1\fR\*(L" and \*(R"\f(CW$vec2\fR", unless you are
absolutely sure that the result will fit into a bit vector of the same
size as the two factors.
.Sp
If you are wrong, a fatal \*(L"numeric overflow error\*(R" will occur.
.Sp
Finally, note that in-place processing is possible, i.e., "\f(CW$vec3\fR\*(L"
may be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR", or both.
.IP "\(bu" 2
\&\f(CW\*(C`$quot\->Divide($vec1,$vec2,$rest);\*(C'\fR
.Sp
This method divides the two numbers contained in bit vector "\f(CW$vec1\fR\*(L"
and \*(R"\f(CW$vec2\fR\*(L" and stores the quotient in bit vector \*(R"\f(CW$quot\fR\*(L" and
the remainder in bit vector \*(R"\f(CW$rest\fR".
.Sp
I.e.,
            \f(CW$quot\fR = \f(CW$vec1\fR / \f(CW$vec2\fR;  #  div
            \f(CW$rest\fR = \f(CW$vec1\fR % \f(CW$vec2\fR;  #  mod
.Sp
Therefore, "\f(CW$quot\fR\*(L" and \*(R"\f(CW$rest\fR" must be two \fB\s-1DISTINCT\s0\fR bit vectors,
or a fatal \*(L"result vector(s) must be distinct\*(R" error will occur.
.Sp
Note also that a fatal \*(L"division by zero error\*(R" will occur if "\f(CW$vec2\fR"
is equal to zero.
.Sp
Note further that this method regards its arguments as \fB\s-1SIGNED\s0\fR.
.Sp
If you want to make sure that a large number can never be treated as being
negative by mistake, make your bit vectors at least one bit longer than the
largest number you wish to represent, right from the start, or proceed as
follows:
.Sp
.Vb 9
\&    $msb1 = $vec1\->msb();
\&    $msb2 = $vec2\->msb();
\&    $vec1\->Resize($vec1\->Size()+1);
\&    $vec2\->Resize($vec2\->Size()+1);
\&    $quot\->Resize($quot\->Size()+1);
\&    $rest\->Resize($rest\->Size()+1);
\&    $vec1\->MSB($msb1);
\&    $vec2\->MSB($msb2);
\&    $quot\->Divide($vec1,$vec2,$rest);
.Ve
.Sp
Finally, note that in-place processing is possible, i.e., "\f(CW$quot\fR\*(L"
may be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR\*(L" or both, and \*(R"\f(CW$rest\fR\*(L"
may also be identical with \*(R"\f(CW$vec1\fR\*(L" or \*(R"\f(CW$vec2\fR\*(L" or both, as long
as \*(R"\f(CW$quot\fR\*(L" and \*(R"\f(CW$rest\fR" are distinct. (!)
.IP "\(bu" 2
\&\f(CW\*(C`$vecgcd\->GCD($veca,$vecb);\*(C'\fR
.Sp
This method calculates the \*(L"Greatest Common Divisor\*(R" of the two numbers
contained in bit vector "\f(CW$veca\fR\*(L" and \*(R"\f(CW$vecb\fR\*(L" and stores the result
in bit vector \*(R"\f(CW$vecgcd\fR".
.Sp
The method uses Euklid's algorithm internally:
.Sp
.Vb 3
\&    int GCD(int a, int b)
\&    {
\&        int t;
\&
\&        while (b != 0)
\&        {
\&            t = a % b; /* = remainder of (a div b) */
\&            a = b;
\&            b = t;
\&        }
\&        return(a);
\&    }
.Ve
.Sp
Note that \f(CW\*(C`GCD(z,0) == GCD(0,z) == z\*(C'\fR.
.IP "\(bu" 2
\&\f(CW\*(C`$vecgcd\->GCD($vecx,$vecy,$veca,$vecb);\*(C'\fR
.Sp
This variant of the \*(L"\s-1GCD\*(R"\s0 method calculates the \*(L"Greatest Common Divisor\*(R"
of the two numbers contained in bit vector "\f(CW$veca\fR\*(L" and \*(R"\f(CW$vecb\fR\*(L" and
stores the result in bit vector \*(R"\f(CW$vecgcd\fR".
.Sp
Moreover, it determines the two factors which are necessary in order to
represent the greatest common divisor as a linear combination of its two
arguments, i.e., the two factors \f(CW"x"\fR and \f(CW"y"\fR so that
\&\f(CW\*(C`GCD(a,b) == x * a + y * b\*(C'\fR, and stores them in bit vector "\f(CW$vecx\fR\*(L"
and \*(R"\f(CW$vecy\fR", respectively.
.Sp
For example:
.Sp
.Vb 2
\&  a = 2322
\&  b =  654
\&
\&  GCD( 2322, 654 ) == 6
\&
\&  x =  20
\&  y = \-71
\&
\&  20 * 2322 \- 71 * 654 == 6
.Ve
.Sp
Please see http://www.cut\-the\-knot.org/blue/extension.shtml
for an explanation of how this extension of Euklid's algorithm works.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Power($vec1,$vec2);\*(C'\fR
.Sp
This method calculates the exponentiation of base "\f(CW$vec1\fR\*(L" elevated to
the \*(R"\f(CW$vec2\fR\*(L" power, i.e., \*(R"\f(CW\*(C`$vec1 ** $vec2\*(C'\fR\*(L", and stores the result
in bit vector \*(R"\f(CW$vec3\fR".
.Sp
The method uses an efficient divide-and-conquer algorithm:
.Sp
Suppose the exponent is (decimal) 13, for example. The binary
representation of this exponent is \*(L"1101\*(R".
.Sp
This means we want to calculate
.Sp
.Vb 3
\&  $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 * $vec1 *
\&  $vec1 * $vec1 * $vec1 * $vec1 *
\&  $vec1
.Ve
.Sp
That is, "\f(CW$vec1\fR" multiplied with itself 13 times. The grouping
into lines above is no coincidence. The first line comprises 8
factors, the second contains 4, and the last line just one. This
just happens to be the binary representation of 13. \f(CW\*(C`;\-)\*(C'\fR
.Sp
We then calculate a series of squares (of squares of squares...) of
the base, i.e.,
.Sp
.Vb 5
\&  $power[0] = $vec1;
\&  $power[1] = $vec1 * $vec1;
\&  $power[2] = $power[1] * $power[1];
\&  $power[3] = $power[2] * $power[2];
\&  etc.
.Ve
.Sp
To calculate the power of our example, we simply initialize our result
with 1 and consecutively multiply it with the items of the series of
powers we just calculated, if the corresponding bit of the binary
representation of the exponent is set:
.Sp
.Vb 6
\&  $result = 1;
\&  $result *= $power[0] if ($vec2 & 1);
\&  $result *= $power[1] if ($vec2 & 2);
\&  $result *= $power[2] if ($vec2 & 4);
\&  $result *= $power[3] if ($vec2 & 8);
\&  etc.
.Ve
.Sp
The bit vector "\f(CW$vec3\fR\*(L" must be of the same size as the base
\&\*(R"\f(CW$vec1\fR\*(L" or greater. \*(R"\f(CW$vec3\fR\*(L" and \*(R"\f(CW$vec1\fR\*(L" may be the same
vector (i.e., in-place calculation as in \*(R"\f(CW\*(C`$vec1 **= $vec2;\*(C'\fR\*(L" is
possible), but \*(R"\f(CW$vec3\fR\*(L" and \*(R"\f(CW$vec2\fR\*(L" must be distinct. Finally,
the exponent \*(R"\f(CW$vec2\fR" must be positive. A fatal error occurs if
any of these conditions is not met.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Block_Store($buffer);\*(C'\fR
.Sp
This method allows you to load the contents of a given bit vector in
one go.
.Sp
This is useful when you store the contents of a bit vector in a file,
for instance (using method "\f(CW\*(C`Block_Read()\*(C'\fR"), and when you want to
restore the previously saved bit vector.
.Sp
For this, "\f(CW$buffer\fR" \fB\s-1MUST\s0\fR be a string (\fB\s-1NO\s0\fR automatic conversion
from numeric to string is provided here as would normally in Perl!)
containing the bit vector in \*(L"low order byte first\*(R" order.
.Sp
If the given string is shorter than what is needed to completely fill
the given bit vector, the remaining (most significant) bytes of the
bit vector are filled with zeros, i.e., the previous contents of the
bit vector are always erased completely.
.Sp
If the given string is longer than what is needed to completely fill
the given bit vector, the superfluous bytes are simply ignored.
.Sp
See \*(L"sysread\*(R" in perlfunc for how to read in the contents of "\f(CW$buffer\fR"
from a file prior to passing it to this method.
.IP "\(bu" 2
\&\f(CW\*(C`$buffer = $vector\->Block_Read();\*(C'\fR
.Sp
This method allows you to export the contents of a given bit vector in
one block.
.Sp
This is useful when you want to save the contents of a bit vector for
later, for instance in a file.
.Sp
The advantage of this method is that it allows you to do so in the
compactest possible format, in binary.
.Sp
The method returns a Perl string which contains an exact copy of the
contents of the given bit vector in \*(L"low order byte first\*(R" order.
.Sp
See \*(L"syswrite\*(R" in perlfunc for how to write the data from this string
to a file.
.IP "\(bu" 2
\&\f(CW\*(C`$size = $vector\->Word_Size();\*(C'\fR
.Sp
Each bit vector is internally organized as an array of machine words.
.Sp
The methods whose names begin with \*(L"Word_\*(R" allow you to access this
internal array of machine words.
.Sp
Note that because the size of a machine word may vary from system to
system, these methods are inherently \fBMACHINE-DEPENDENT\fR!
.Sp
Therefore, \fB\s-1DO NOT USE\s0\fR these methods unless you are absolutely certain
that portability of your code is not an issue!
.Sp
You have been warned!
.Sp
To be machine-independent, use the methods whose names begin with "\f(CW\*(C`Chunk_\*(C'\fR"
instead, with chunk sizes no greater than 32 bits.
.Sp
The method "\f(CW\*(C`Word_Size()\*(C'\fR" returns the number of machine words that the
internal array of words of the given bit vector contains.
.Sp
This is similar in function to the term "\f(CW\*(C`scalar(@array)\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Store($offset,$word);\*(C'\fR
.Sp
This method allows you to store a given value "\f(CW$word\fR\*(L" at a given
position \*(R"\f(CW$offset\fR" in the internal array of words of the given
bit vector.
.Sp
Note that "\f(CW$offset\fR\*(L" must lie in the permitted range between \*(R"\f(CW0\fR\*(L"
and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`$array[$offset] = $word;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$word = $vector\->Word_Read($offset);\*(C'\fR
.Sp
This method allows you to access the value of a given machine word
at position "\f(CW$offset\fR" in the internal array of words of the given
bit vector.
.Sp
Note that "\f(CW$offset\fR\*(L" must lie in the permitted range between \*(R"\f(CW0\fR\*(L"
and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`$word = $array[$offset];\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_List_Store(@words);\*(C'\fR
.Sp
This method allows you to store a list of values "\f(CW@words\fR" in the
internal array of machine words of the given bit vector.
.Sp
Thereby the \fB\s-1LEFTMOST\s0\fR value in the list ("\f(CW$words[0]\fR") is stored
in the \fB\s-1LEAST\s0\fR significant word of the internal array of words (the
one with offset "\f(CW0\fR\*(L"), the next value from the list (\*(R"\f(CW$words[1]\fR\*(L")
is stored in the word with offset \*(R"\f(CW1\fR", and so on, as intuitively
expected.
.Sp
If the list "\f(CW@words\fR" contains fewer elements than the internal
array of words of the given bit vector contains machine words,
the remaining (most significant) words are filled with zeros.
.Sp
If the list "\f(CW@words\fR" contains more elements than the internal
array of words of the given bit vector contains machine words,
the superfluous values are simply ignored.
.Sp
This method is comparable in function to the expression
"\f(CW\*(C`@array = @words;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`@words = $vector\->Word_List_Read();\*(C'\fR
.Sp
This method allows you to retrieve the internal array of machine
words of the given bit vector all at once.
.Sp
Thereby the \fB\s-1LEFTMOST\s0\fR value in the returned list ("\f(CW$words[0]\fR")
is the \fB\s-1LEAST\s0\fR significant word from the given bit vector, and the
\&\fB\s-1RIGHTMOST\s0\fR value in the returned list ("\f(CW$words[$#words]\fR") is
the \fB\s-1MOST\s0\fR significant word of the given bit vector.
.Sp
This method is similar in function to the expression
"\f(CW\*(C`@words = @array;\*(C'\fR" for a Perl array.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Insert($offset,$count);\*(C'\fR
.Sp
This method inserts "\f(CW$count\fR\*(L" empty new machine words at position
\&\*(R"\f(CW$offset\fR" in the internal array of words of the given bit vector.
.Sp
The "\f(CW$count\fR\*(L" most significant words are lost, and all words starting
with word number \*(R"\f(CW$offset\fR\*(L" up to and including word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-$count\-1\*(C'\fR\*(L" are moved up by \*(R"\f(CW$count\fR" places.
.Sp
The now vacant "\f(CW$count\fR\*(L" words starting at word number \*(R"\f(CW$offset\fR\*(L"
(up to and including word number \*(R"\f(CW\*(C`$offset+$count\-1\*(C'\fR") are then set
to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR increase the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR extended at its upper end to
\&\*(L"rescue\*(R" the "\f(CW$count\fR" uppermost (most significant) words \- instead,
these words are lost forever.
.Sp
If you don't want this to happen, you have to increase the size of the
given bit vector \fB\s-1EXPLICITLY\s0\fR and \fB\s-1BEFORE\s0\fR you perform the \*(L"Insert\*(R"
operation, with a statement such as the following:
.Sp
.Vb 1
\&  $vector\->Resize($vector\->Size() + $count * Bit::Vector\->Word_Bits());
.Ve
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out
of range" error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $count\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L",
all the words starting with word number \*(R"\f(CW$offset\fR\*(L" up to word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Word_Delete($offset,$count);\*(C'\fR
.Sp
This method deletes, i.e., removes the words starting at position
"\f(CW$offset\fR\*(L" up to and including word number \*(R"\f(CW\*(C`$offset+$count\-1\*(C'\fR"
from the internal array of machine words of the given bit vector.
.Sp
The remaining uppermost words (starting at position "\f(CW\*(C`$offset+$count\*(C'\fR\*(L"
up to and including word number \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L") are
moved down by \*(R"\f(CW$count\fR" places.
.Sp
The now vacant uppermost (most significant) "\f(CW$count\fR" words are then
set to zero (cleared).
.Sp
Note that this method does \fB\s-1NOT\s0\fR decrease the size of the given bit
vector, i.e., the bit vector is \fB\s-1NOT\s0\fR clipped at its upper end to
\&\*(L"get rid of\*(R" the vacant "\f(CW$count\fR" uppermost words.
.Sp
If you don't want this, i.e., if you want the bit vector to shrink
accordingly, you have to do so \fB\s-1EXPLICITLY\s0\fR and \fB\s-1AFTER\s0\fR the \*(L"Delete\*(R"
operation, with a couple of statements such as these:
.Sp
.Vb 4
\&  $bits = $vector\->Size();
\&  $count *= Bit::Vector\->Word_Bits();
\&  if ($count > $bits) { $count = $bits; }
\&  $vector\->Resize($bits \- $count);
.Ve
.Sp
Note also that "\f(CW$offset\fR\*(L" must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out
of range" error will occur.
.Sp
If the term "\f(CW\*(C`$offset + $count\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR\*(L",
all the words starting with word number \*(R"\f(CW$offset\fR\*(L" up to word number
\&\*(R"\f(CW\*(C`$vector\->Word_Size()\-1\*(C'\fR" are simply cleared.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Chunk_Store($chunksize,$offset,$chunk);\*(C'\fR
.Sp
This method allows you to set more than one bit at a time with
different values.
.Sp
You can access chunks (i.e., ranges of contiguous bits) between
one and at most "\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR" bits wide.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
If the given "\f(CW$chunksize\fR\*(L" does not lie between \*(R"\f(CW1\fR\*(L" and
\&\*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", a fatal \*(R"chunk size out of range"
error will occur.
.Sp
The method copies the "\f(CW$chunksize\fR\*(L" least significant bits
from the value \*(R"\f(CW$chunk\fR\*(L" to the given bit vector, starting at
bit position \*(R"\f(CW$offset\fR\*(L" and proceeding upwards until bit number
\&\*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".
.Sp
(I.e., bit number "\f(CW0\fR\*(L" of \*(R"\f(CW$chunk\fR\*(L" becomes bit number \*(R"\f(CW$offset\fR\*(L"
in the given bit vector, and bit number \*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR\*(L" becomes
bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".)
.Sp
If the term "\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L",
the corresponding superfluous (most significant) bits from \*(R"\f(CW$chunk\fR"
are simply ignored.
.Sp
Note that "\f(CW$offset\fR\*(L" itself must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.Sp
This method (as well as the other "\f(CW\*(C`Chunk_\*(C'\fR" methods) is useful, for
example, when you are reading in data in chunks of, say, 8 bits, which
you need to access later, say, using 16 bits at a time (like audio \s-1CD\s0
wave files, for instance).
.IP "\(bu" 2
\&\f(CW\*(C`$chunk = $vector\->Chunk_Read($chunksize,$offset);\*(C'\fR
.Sp
This method allows you to read the values of more than one bit at
a time.
.Sp
You can read chunks (i.e., ranges of contiguous bits) between
one and at most "\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR" bits wide.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
If the given "\f(CW$chunksize\fR\*(L" does not lie between \*(R"\f(CW1\fR\*(L" and
\&\*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", a fatal \*(R"chunk size out of range"
error will occur.
.Sp
The method returns the "\f(CW$chunksize\fR\*(L" bits from the given bit vector
starting at bit position \*(R"\f(CW$offset\fR\*(L" and proceeding upwards until
bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR".
.Sp
(I.e., bit number "\f(CW$offset\fR\*(L" of the given bit vector becomes bit number
\&\*(R"\f(CW0\fR\*(L" of the returned value, and bit number \*(R"\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L"
becomes bit number \*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR".)
.Sp
If the term "\f(CW\*(C`$offset+$chunksize\-1\*(C'\fR\*(L" exceeds \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR",
the non-existent bits are simply not returned.
.Sp
Note that "\f(CW$offset\fR\*(L" itself must lie in the permitted range between
\&\*(R"\f(CW0\fR\*(L" and \*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"offset out of range"
error will occur.
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Chunk_List_Store($chunksize,@chunks);\*(C'\fR
.Sp
This method allows you to fill the given bit vector with a list of
data packets (\*(L"chunks\*(R") of any size ("\f(CW$chunksize\fR") you like
(within certain limits).
.Sp
In fact the given "\f(CW$chunksize\fR\*(L" must lie in the range between \*(R"\f(CW1\fR\*(L"
and \*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", or a fatal \*(R"chunk size out of
range" error will occur.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
The given bit vector is thereby filled in ascending order: The first
chunk from the list (i.e., "\f(CW$chunks[0]\fR\*(L") fills the \*(R"\f(CW$chunksize\fR\*(L"
least significant bits, the next chunk from the list (\*(R"\f(CW$chunks[1]\fR\*(L")
fills the bits number \*(R"\f(CW$chunksize\fR\*(L" to number \*(R"\f(CW\*(C`2*$chunksize\-1\*(C'\fR\*(L",
the third chunk (\*(R"\f(CW$chunks[2]\fR\*(L") fills the bits number \*(R"\f(CW\*(C`2*$chunksize\*(C'\fR\*(L",
to number \*(R"\f(CW\*(C`3*$chunksize\-1\*(C'\fR", and so on.
.Sp
If there a less chunks in the list than are needed to fill the entire
bit vector, the remaining (most significant) bits are cleared, i.e.,
the previous contents of the given bit vector are always erased completely.
.Sp
If there are more chunks in the list than are needed to fill the entire
bit vector, and/or if a chunk extends beyond "\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L"
(which happens whenever \*(R"\f(CW\*(C`$vector\->Size()\*(C'\fR\*(L" is not a multiple of
\&\*(R"\f(CW$chunksize\fR"), the superfluous chunks and/or bits are simply ignored.
.Sp
The method is useful, for example (and among many other applications),
for the conversion of packet sizes in a data stream.
.Sp
This method can also be used to store an octal string in a given
bit vector:
.Sp
.Vb 1
\&  $vector\->Chunk_List_Store(3, split(//, reverse $string));
.Ve
.Sp
Note however that unlike the conversion methods "\f(CW\*(C`from_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`from_Enum()\*(C'\fR",
this statement does not include any syntax checking, i.e.,
it may fail silently, without warning.
.Sp
To perform syntax checking, add the following statements:
.Sp
.Vb 8
\&  if ($string =~ /^[0\-7]+$/)
\&  {
\&      # okay, go ahead with conversion as shown above
\&  }
\&  else
\&  {
\&      # error, string contains other than octal characters
\&  }
.Ve
.Sp
Another application is to store a repetitive pattern in a given
bit vector:
.Sp
.Vb 6
\&  $pattern = 0xDEADBEEF;
\&  $length = 32;            # = length of $pattern in bits
\&  $size = $vector\->Size();
\&  $factor = int($size / $length);
\&  if ($size % $length) { $factor++; }
\&  $vector\->Chunk_List_Store($length, ($pattern) x $factor);
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`@chunks = $vector\->Chunk_List_Read($chunksize);\*(C'\fR
.Sp
This method allows you to access the contents of the given bit vector in
form of a list of data packets (\*(L"chunks\*(R") of a size ("\f(CW$chunksize\fR")
of your choosing (within certain limits).
.Sp
In fact the given "\f(CW$chunksize\fR\*(L" must lie in the range between \*(R"\f(CW1\fR\*(L"
and \*(R"\f(CW\*(C`Bit::Vector\->Long_Bits()\*(C'\fR\*(L", or a fatal \*(R"chunk size out of
range" error will occur.
.Sp
In order to be portable, though, you should never use chunk sizes
larger than 32 bits.
.Sp
The given bit vector is thereby read in ascending order: The
"\f(CW$chunksize\fR\*(L" least significant bits (bits number \*(R"\f(CW0\fR\*(L" to
\&\*(R"\f(CW\*(C`$chunksize\-1\*(C'\fR\*(L") become the first chunk in the returned list
(i.e., \*(R"\f(CW$chunks[0]\fR\*(L"). The bits number \*(R"\f(CW$chunksize\fR\*(L" to
\&\*(R"\f(CW\*(C`2*$chunksize\-1\*(C'\fR\*(L" become the next chunk in the list
(\*(R"\f(CW$chunks[1]\fR"), and so on.
.Sp
If "\f(CW\*(C`$vector\->Size()\*(C'\fR\*(L" is not a multiple of \*(R"\f(CW$chunksize\fR\*(L",
the last chunk in the list will contain fewer bits than \*(R"\f(CW$chunksize\fR".
.Sp
\&\fB\s-1BEWARE\s0\fR that for large bit vectors and/or small values of "\f(CW$chunksize\fR",
the number of returned list elements can be extremely large! \fB\s-1BE CAREFUL\s0!\fR
.Sp
You could blow up your application with lack of memory (each list element
is a full-grown Perl scalar, internally, with an associated memory overhead
for its administration!) or at least cause a noticeable, more or less
long-lasting \*(L"freeze\*(R" of your application!
.Sp
Possible applications:
.Sp
The method is especially useful in the conversion of packet sizes in
a data stream.
.Sp
This method can also be used to convert a given bit vector to a string
of octal numbers:
.Sp
.Vb 1
\&  $string = reverse join(\*(Aq\*(Aq, $vector\->Chunk_List_Read(3));
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Index_List_Remove(@indices);\*(C'\fR
.Sp
This method allows you to specify a list of indices of bits which
should be turned off in the given bit vector.
.Sp
In fact this method is a shortcut for
.Sp
.Vb 4
\&    foreach $index (@indices)
\&    {
\&        $vector\->Bit_Off($index);
\&    }
.Ve
.Sp
In contrast to all other import methods in this module, this method
does \fB\s-1NOT\s0\fR clear the given bit vector before processing its list
of arguments.
.Sp
Instead, this method allows you to accumulate the results of various
consecutive calls.
.Sp
(The same holds for the method "\f(CW\*(C`Index_List_Store()\*(C'\fR\*(L". As a
consequence, you can \*(R"wipe out\*(L" what you did using the method
\&\*(R"\f(CW\*(C`Index_List_Remove()\*(C'\fR\*(L" by passing the identical argument list
to the method \*(R"\f(CW\*(C`Index_List_Store()\*(C'\fR".)
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->Index_List_Store(@indices);\*(C'\fR
.Sp
This method allows you to specify a list of indices of bits which
should be turned on in the given bit vector.
.Sp
In fact this method is a shortcut for
.Sp
.Vb 4
\&    foreach $index (@indices)
\&    {
\&        $vector\->Bit_On($index);
\&    }
.Ve
.Sp
In contrast to all other import methods in this module, this method
does \fB\s-1NOT\s0\fR clear the given bit vector before processing its list
of arguments.
.Sp
Instead, this method allows you to accumulate the results of various
consecutive calls.
.Sp
(The same holds for the method "\f(CW\*(C`Index_List_Remove()\*(C'\fR\*(L". As a
consequence, you can \*(R"wipe out\*(L" what you did using the method
\&\*(R"\f(CW\*(C`Index_List_Store()\*(C'\fR\*(L" by passing the identical argument list
to the method \*(R"\f(CW\*(C`Index_List_Remove()\*(C'\fR".)
.IP "\(bu" 2
\&\f(CW\*(C`@indices = $vector\->Index_List_Read();\*(C'\fR
.Sp
This method returns a list of Perl scalars.
.Sp
The list contains one scalar for each set bit in the given
bit vector.
.Sp
\&\fB\s-1BEWARE\s0\fR that for large bit vectors, this can result in a literally
overwhelming number of list elements! \fB\s-1BE CAREFUL\s0!\fR You could run
out of memory or slow down your application considerably!
.Sp
Each scalar contains the number of the index corresponding to
the bit in question.
.Sp
These indices are always returned in ascending order.
.Sp
If the given bit vector is empty (contains only cleared bits)
or if it has a length of zero (if it contains no bits at all),
the method returns an empty list.
.Sp
This method can be useful, for instance, to obtain a list of
prime numbers:
.Sp
.Vb 4
\&    $limit = 1000; # or whatever
\&    $vector = Bit::Vector\->new($limit+1);
\&    $vector\->Primes();
\&    @primes = $vector\->Index_List_Read();
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Or($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Union($set1,$set2);\*(C'\fR
.Sp
This method calculates the union of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L" and stores
the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 u $set2\*(C'\fR\*(L" in set theory
(where \*(R"u\*(L" is the \*(R"cup" operator).
.Sp
(On systems where the \*(L"cup\*(R" character is unavailable this operator
is often denoted by a plus sign \*(L"+\*(R".)
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->And($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Intersection($set1,$set2);\*(C'\fR
.Sp
This method calculates the intersection of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L" and
stores the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 n $set2\*(C'\fR\*(L" in set theory
(where \*(R"n\*(L" is the \*(R"cap" operator).
.Sp
(On systems where the \*(L"cap\*(R" character is unavailable this operator
is often denoted by an asterisk \*(L"*\*(R".)
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->AndNot($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->Difference($set1,$set2);\*(C'\fR
.Sp
This method calculates the difference of "\f(CW$set1\fR\*(L" less \*(R"\f(CW$set2\fR\*(L" and
stores the result in \*(R"\f(CW$set3\fR".
.Sp
This is usually written as "\f(CW\*(C`$set3 = $set1 \e $set2\*(C'\fR\*(L" in set theory
(where \*(R"\e\*(L" is the \*(R"less" operator).
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec3\->Xor($vec1,$vec2);\*(C'\fR
.Sp
\&\f(CW\*(C`$set3\->ExclusiveOr($set1,$set2);\*(C'\fR
.Sp
This method calculates the symmetric difference of "\f(CW$set1\fR\*(L" and \*(R"\f(CW$set2\fR\*(L"
and stores the result in \*(R"\f(CW$set3\fR".
.Sp
This can be written as "\f(CW\*(C`$set3 = ($set1 u $set2) \e ($set1 n $set2)\*(C'\fR" in set
theory (the union of the two sets less their intersection).
.Sp
When sets are implemented as bit vectors then the above formula is
equivalent to the exclusive-or between corresponding bits of the two
bit vectors (hence the name of this method).
.Sp
Note that this method is also much more efficient than evaluating the
above formula explicitly since it uses a built-in machine language
instruction internally.
.Sp
In-place calculation is also possible, i.e., "\f(CW$set3\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR\*(L" or \*(R"\f(CW$set2\fR" or both.
.IP "\(bu" 2
\&\f(CW\*(C`$vec2\->Not($vec1);\*(C'\fR
.Sp
\&\f(CW\*(C`$set2\->Complement($set1);\*(C'\fR
.Sp
This method calculates the complement of "\f(CW$set1\fR\*(L" and stores the result
in \*(R"\f(CW$set2\fR".
.Sp
In \*(L"big integer\*(R" arithmetic, this is equivalent to calculating the one's
complement of the number stored in the bit vector "\f(CW$set1\fR" in binary
representation.
.Sp
In-place calculation is also possible, i.e., "\f(CW$set2\fR\*(L" may be identical
with \*(R"\f(CW$set1\fR".
.IP "\(bu" 2
\&\f(CW\*(C`if ($set1\->subset($set2))\*(C'\fR
.Sp
Returns \*(L"true\*(R" ("\f(CW1\fR\*(L") if \*(R"\f(CW$set1\fR\*(L" is a subset of \*(R"\f(CW$set2\fR\*(L"
(i.e., completely contained in \*(R"\f(CW$set2\fR\*(L") and \*(R"false\*(L" (\*(R"\f(CW0\fR")
otherwise.
.Sp
This means that any bit which is set ("\f(CW1\fR\*(L") in \*(R"\f(CW$set1\fR\*(L" must
also be set in \*(R"\f(CW$set2\fR\*(L", but \*(R"\f(CW$set2\fR\*(L" may contain set bits
which are not set in \*(R"\f(CW$set1\fR", in order for the condition
of subset relationship to be true between these two sets.
.Sp
Note that by definition, if two sets are identical, they are
also subsets (and also supersets) of each other.
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
Uses a byte lookup table for calculating the number of set bits
per byte, and thus needs a time for evaluation (and a number of
loops) linearly proportional to the length of the given bit vector
(in bytes).
.Sp
This should be the fastest algorithm on average.
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm2();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
This does the same as the method "\f(CW\*(C`Norm()\*(C'\fR" above, only with a
different algorithm:
.Sp
This method counts the number of set and cleared bits at the same
time and will stop when either of them has been exhausted, thus
needing at most half as many loops per machine word as the total
number of bits in a machine word \- in fact it will need a number
of loops equal to the minimum of the number of set bits and the
number of cleared bits.
.Sp
This might be a faster algorithm than of the method "\f(CW\*(C`Norm()\*(C'\fR"
above on some systems, depending on the system's architecture
and the compiler and optimisation used, for bit vectors with
sparse set bits and for bit vectors with sparse cleared bits
(i.e., predominantly set bits).
.IP "\(bu" 2
\&\f(CW\*(C`$norm = $set\->Norm3();\*(C'\fR
.Sp
Returns the norm (number of bits which are set) of the given vector.
.Sp
This is equivalent to the number of elements contained in the given
set.
.Sp
This does the same as the two methods "\f(CW\*(C`Norm()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Norm2()\*(C'\fR"
above, however with a different algorithm.
.Sp
In fact this is the implementation of the method "\f(CW\*(C`Norm()\*(C'\fR" used
in previous versions of this module.
.Sp
The method needs a number of loops per machine word equal to the
number of set bits in that machine word.
.Sp
Only for bit vectors with sparse set bits will this method be
fast; it will depend on a system's architecture and compiler
whether the method will be faster than any of the two methods
above in such cases.
.Sp
On average however, this is probably the slowest method of the
three.
.IP "\(bu" 2
\&\f(CW\*(C`$min = $set\->Min();\*(C'\fR
.Sp
Returns the minimum of the given set, i.e., the minimum of all
indices of all set bits in the given bit vector "\f(CW$set\fR".
.Sp
If the set is empty (no set bits), plus infinity (represented
by the constant \*(L"\s-1MAX_LONG\*(R"\s0 on your system) is returned.
.Sp
(This constant is usually 2\ ^\ (n\-1)\ \-\ 1, where "\f(CW\*(C`n\*(C'\fR" is the
number of bits of an unsigned long on your machine.)
.IP "\(bu" 2
\&\f(CW\*(C`$max = $set\->Max();\*(C'\fR
.Sp
Returns the maximum of the given set, i.e., the maximum of all
indices of all set bits in the given bit vector "\f(CW$set\fR".
.Sp
If the set is empty (no set bits), minus infinity (represented
by the constant \*(L"\s-1MIN_LONG\*(R"\s0 on your system) is returned.
.Sp
(This constant is usually \-(2\ ^\ (n\-1)\ \-\ 1) or \-(2\ ^\ (n\-1)),
where "\f(CW\*(C`n\*(C'\fR" is the number of bits of an unsigned long on your machine.)
.IP "\(bu" 2
\&\f(CW\*(C`$m3\->Multiplication($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);\*(C'\fR
.Sp
This method multiplies two boolean matrices (stored as bit vectors)
"\f(CW$m1\fR\*(L" and \*(R"\f(CW$m2\fR\*(L" and stores the result in matrix \*(R"\f(CW$m3\fR".
.Sp
The method uses the binary \*(L"xor\*(R" operation ("\f(CW\*(C`^\*(C'\fR\*(L") as the boolean
addition operator (\*(R"\f(CW\*(C`+\*(C'\fR").
.Sp
An exception is raised if the product of the number of rows and
columns of any of the three matrices differs from the actual size
of their underlying bit vector.
.Sp
An exception is also raised if the numbers of rows and columns
of the three matrices do not harmonize in the required manner:
.Sp
.Vb 3
\&  rows3 == rows1
\&  cols3 == cols2
\&  cols1 == rows2
.Ve
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$m3\->Product($r3,$c3,$m1,$r1,$c1,$m2,$r2,$c2);\*(C'\fR
.Sp
This method multiplies two boolean matrices (stored as bit vectors)
"\f(CW$m1\fR\*(L" and \*(R"\f(CW$m2\fR\*(L" and stores the result in matrix \*(R"\f(CW$m3\fR".
.Sp
This special method uses the binary \*(L"or\*(R" operation ("\f(CW\*(C`|\*(C'\fR\*(L") as the
boolean addition operator (\*(R"\f(CW\*(C`+\*(C'\fR").
.Sp
An exception is raised if the product of the number of rows and
columns of any of the three matrices differs from the actual size
of their underlying bit vector.
.Sp
An exception is also raised if the numbers of rows and columns
of the three matrices do not harmonize in the required manner:
.Sp
.Vb 3
\&  rows3 == rows1
\&  cols3 == cols2
\&  cols1 == rows2
.Ve
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$matrix\->Closure($rows,$cols);\*(C'\fR
.Sp
This method calculates the reflexive transitive closure of the
given boolean matrix (stored as a bit vector) using Kleene's
algoritm.
.Sp
(See \fIMath::Kleene\fR\|(3) for a brief introduction into the
theory behind Kleene's algorithm.)
.Sp
The reflexive transitive closure answers the question whether
a path exists between any two vertices of a graph whose edges
are given as a matrix:
.Sp
If a (directed) edge exists going from vertex \*(L"i\*(R" to vertex \*(L"j\*(R",
then the element in the matrix with coordinates (i,j) is set to
"\f(CW1\fR\*(L" (otherwise it remains set to \*(R"\f(CW0\fR").
.Sp
If the edges are undirected, the resulting matrix is symmetric,
i.e., elements (i,j) and (j,i) always contain the same value.
.Sp
The matrix representing the edges of the graph only answers the
question whether an \fB\s-1EDGE\s0\fR exists between any two vertices of
the graph or not, whereas the reflexive transitive closure
answers the question whether a \fB\s-1PATH\s0\fR (a series of adjacent
edges) exists between any two vertices of the graph!
.Sp
Note that the contents of the given matrix are modified by
this method, so make a copy of the initial matrix in time
if you are going to need it again later.
.Sp
An exception is raised if the given matrix is not quadratic,
i.e., if the number of rows and columns of the given matrix
is not identical.
.Sp
An exception is also raised if the product of the number of
rows and columns of the given matrix differs from the actual
size of its underlying bit vector.
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.IP "\(bu" 2
\&\f(CW\*(C`$matrix2\->Transpose($rows2,$cols2,$matrix1,$rows1,$cols1);\*(C'\fR
.Sp
This method calculates the transpose of a boolean matrix "\f(CW$matrix1\fR\*(L"
(stored as a bit vector) and stores the result in matrix \*(R"\f(CW$matrix2\fR".
.Sp
The transpose of a boolean matrix, representing the edges of a graph,
can be used for finding the strongly connected components of that graph.
.Sp
An exception is raised if the product of the number of rows and
columns of any of the two matrices differs from the actual size
of its underlying bit vector.
.Sp
An exception is also raised if the following conditions are not
met:
.Sp
.Vb 2
\&  rows2 == cols1
\&  cols2 == rows1
.Ve
.Sp
Note that in-place processing ("\f(CW$matrix1\fR\*(L" and \*(R"\f(CW$matrix2\fR\*(L" are
identical) is only possible if the matrix is quadratic. Otherwise,
a fatal \*(R"matrix is not quadratic" error will occur.
.Sp
This method is used by the module \*(L"Math::MatrixBool\*(R".
.Sp
See \fIMath::MatrixBool\fR\|(3) for details.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector::Overload\fR\|(3),
\&\fIBit::Vector::String\fR\|(3),
\&\fIStorable\fR\|(3).
.PP
\&\fISet::IntRange\fR\|(3),
\&\fIMath::MatrixBool\fR\|(3),
\&\fIMath::MatrixReal\fR\|(3),
\&\fIDFA::Kleene\fR\|(3),
\&\fIMath::Kleene\fR\|(3),
\&\fIGraph::Kruskal\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector\*(R" version 7.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995 \- 2013 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::Overload.3pm                    0100644 0001750 0001750 00000152355 12566241526 025262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::Overload 3"
.TH Bit::Vector::Overload 3 "2013-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::Overload \- Overloaded operators add\-on for Bit::Vector
.SH "USAGE"
.IX Header "USAGE"
Note that you do not need to "\f(CW\*(C`use Bit::Vector;\*(C'\fR"
in addition to this module.
.PP
Simply "\f(CW\*(C`use Bit::Vector::Overload;\*(C'\fR" \fB\s-1INSTEAD\s0\fR
of "\f(CW\*(C`use Bit::Vector;\*(C'\fR\*(L". You can still use all the
methods from the \*(R"Bit::Vector" module in addition
to the overloaded operators and methods provided
here after that.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  Configuration
\&      $config = Bit::Vector\->Configuration();
\&      Bit::Vector\->Configuration($config);
\&      $oldconfig = Bit::Vector\->Configuration($newconfig);
\&
\&  String Conversion
\&      $string = "$vector";             #  depending on configuration
\&      print "\e$vector = \*(Aq$vector\*(Aq\en";
\&
\&  Emptyness
\&      if ($vector)  #  if not empty (non\-zero)
\&      if (! $vector)  #  if empty (zero)
\&      unless ($vector)  #  if empty (zero)
\&
\&  Complement (one\*(Aqs complement)
\&      $vector2 = ~$vector1;
\&      $vector = ~$vector;
\&
\&  Negation (two\*(Aqs complement)
\&      $vector2 = \-$vector1;
\&      $vector = \-$vector;
\&
\&  Norm
\&      $norm = abs($vector);  #  depending on configuration
\&
\&  Absolute
\&      $vector2 = abs($vector1);  #  depending on configuration
\&
\&  Concatenation
\&      $vector3 = $vector1 . $vector2;
\&      $vector1 .= $vector2;
\&      $vector1 = $vector2 . $vector1;
\&      $vector2 = $vector1 . $scalar;  #  depending on configuration
\&      $vector2 = $scalar . $vector1;
\&      $vector .= $scalar;
\&
\&  Duplication
\&      $vector2 = $vector1 x $factor;
\&      $vector x= $factor;
\&
\&  Shift Left
\&      $vector2 = $vector1 << $bits;
\&      $vector <<= $bits;
\&
\&  Shift Right
\&      $vector2 = $vector1 >> $bits;
\&      $vector >>= $bits;
\&
\&  Union
\&      $vector3 = $vector1 | $vector2;
\&      $vector1 |= $vector2;
\&      $vector2 = $vector1 | $scalar;
\&      $vector |= $scalar;
\&
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Intersection
\&      $vector3 = $vector1 & $vector2;
\&      $vector1 &= $vector2;
\&      $vector2 = $vector1 & $scalar;
\&      $vector &= $scalar;
\&
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  ExclusiveOr
\&      $vector3 = $vector1 ^ $vector2;
\&      $vector1 ^= $vector2;
\&      $vector2 = $vector1 ^ $scalar;
\&      $vector ^= $scalar;
\&
\&  Set Difference
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Addition
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Subtraction
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Multiplication
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  Division
\&      $vector3 = $vector1 / $vector2;
\&      $vector1 /= $vector2;
\&      $vector1 = $vector2 / $vector1;
\&      $vector2 = $vector1 / $scalar;
\&      $vector2 = $scalar / $vector1;
\&      $vector /= $scalar;
\&
\&  Modulo
\&      $vector3 = $vector1 % $vector2;
\&      $vector1 %= $vector2;
\&      $vector1 = $vector2 % $vector1;
\&      $vector2 = $vector1 % $scalar;
\&      $vector2 = $scalar % $vector1;
\&      $vector %= $scalar;
\&
\&  Exponentiation
\&      $vector3 = $vector1 ** $vector2;
\&      $vector1 **= $vector2;
\&      $vector2 = $vector1 ** $scalar;
\&      $vector2 = $scalar ** $vector1;
\&      $vector **= $scalar;
\&
\&  Increment
\&      ++$vector;
\&      $vector++;
\&
\&  Decrement
\&      \-\-$vector;
\&      $vector\-\-;
\&
\&  Lexical Comparison (unsigned)
\&      $cmp = $vector1 cmp $vector2;
\&      if ($vector1 lt $vector2)
\&      if ($vector1 le $vector2)
\&      if ($vector1 gt $vector2)
\&      if ($vector1 ge $vector2)
\&
\&      $cmp = $vector cmp $scalar;
\&      if ($vector lt $scalar)
\&      if ($vector le $scalar)
\&      if ($vector gt $scalar)
\&      if ($vector ge $scalar)
\&
\&  Comparison (signed)
\&      $cmp = $vector1 <=> $vector2;
\&      if ($vector1 < $vector2)  #  depending on configuration
\&      if ($vector1 <= $vector2)
\&      if ($vector1 > $vector2)
\&      if ($vector1 >= $vector2)
\&
\&      $cmp = $vector <=> $scalar;
\&      if ($vector < $scalar)  #  depending on configuration
\&      if ($vector <= $scalar)
\&      if ($vector > $scalar)
\&      if ($vector >= $scalar)
\&
\&  Equality
\&      if ($vector1 eq $vector2)
\&      if ($vector1 ne $vector2)
\&      if ($vector eq $scalar)
\&      if ($vector ne $scalar)
\&
\&      if ($vector1 == $vector2)
\&      if ($vector1 != $vector2)
\&      if ($vector == $scalar)
\&      if ($vector != $scalar)
\&
\&  Subset Relationship
\&      if ($vector1 <= $vector2)  #  depending on configuration
\&
\&  True Subset Relationship
\&      if ($vector1 < $vector2)  #  depending on configuration
\&
\&  Superset Relationship
\&      if ($vector1 >= $vector2)  #  depending on configuration
\&
\&  True Superset Relationship
\&      if ($vector1 > $vector2)  #  depending on configuration
.Ve
.SH "IMPORTANT NOTES"
.IX Header "IMPORTANT NOTES"
.IP "\(bu" 2
Boolean values
.Sp
Boolean values in this module are always a numeric zero ("\f(CW0\fR\*(L") for
\&\*(R"false\*(L" and a numeric one (\*(R"\f(CW1\fR\*(L") for \*(R"true".
.IP "\(bu" 2
Negative numbers
.Sp
Numeric factors (as needed for the "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`x\*(C'\fR" operators) and bit numbers are always regarded as being
\&\fB\s-1UNSIGNED\s0\fR.
.Sp
As a consequence, whenever you pass a negative number for such a factor
or bit number, it will be treated as a (usually very large) positive
number due to its internal two's complement binary representation, usually
resulting in malfunctions or an \*(L"index out of range\*(R" error message and
program abortion.
.Sp
Note that this does not apply to \*(L"big integer\*(R" decimal numbers, which
are (usually) passed as strings, and which may of course be negative
(see also the section \*(L"Big integers\*(R" a little further below).
.IP "\(bu" 2
Overloaded operators configuration
.Sp
Note that the behaviour of certain overloaded operators can be changed
in various ways by means of the "\f(CW\*(C`Configuration()\*(C'\fR" method (for more
details, see the description of this method further below).
.Sp
For instance, scalars (i.e., numbers and strings) provided as operands
to overloaded operators are automatically converted to bit vectors,
internally.
.Sp
These scalars are thereby automatically assumed to be indices or to be
in hexadecimal, binary, decimal or enumeration format, depending on the
configuration.
.Sp
Similarly, when converting bit vectors to strings using double quotes
(""), the output format will also depend on the previously chosen
configuration.
.Sp
Finally, some overloaded operators may have different semantics depending
on the proper configuration; for instance, the operator \*(L"+\*(R" can be the
\&\*(L"union\*(R" operator from set theory or the arithmetic \*(L"add\*(R" operator.
.Sp
In all cases (input, output and operator semantics), the defaults have
been chosen in such a way so that the behaviour of the module is backward
compatible with previous versions.
.IP "\(bu" 2
\&\*(L"Big integers\*(R"
.Sp
As long as \*(L"big integers\*(R" (for \*(L"big integer\*(R" arithmetic) are small enough
so that Perl doesn't need scientific notation (exponents) to be able to
represent them internally, you can provide these \*(L"big integer\*(R" constants
to the overloaded operators of this module (or to the method "\f(CW\*(C`from_Dec()\*(C'\fR")
in numeric form (i.e., either as a numeric constant or expression or as a
Perl variable containing a numeric value).
.Sp
Note that you will get an error message (resulting in program abortion)
if your \*(L"big integer\*(R" numbers exceed that limit.
.Sp
Because this limit is machine-dependent and not obvious to find out,
it is strongly recommended that you enclose \fB\s-1ALL\s0\fR your \*(L"big integer\*(R"
constants in your programs in (double or single) quotes.
.Sp
Examples:
.Sp
.Vb 1
\&    $vector /= 10;  #  ok because number is small
\&
\&    $vector /= \-10;  #  ok for same reason
\&
\&    $vector /= "10";  #  always correct
\&
\&    $vector += "1152921504606846976";  #  quotes probably required here
.Ve
.Sp
All examples assume
.Sp
.Vb 1
\&    Bit::Vector\->Configuration("input=decimal");
.Ve
.Sp
having been set beforehand.
.Sp
Note also that this module does not support scientific notation (exponents)
for \*(L"big integer\*(R" decimal numbers because you can always make the bit vector
large enough for the whole number to fit without loss of precision (as it
would occur if scientific notation were used).
.Sp
Finally, note that the only characters allowed in \*(L"big integer\*(R" constant
strings are the digits \f(CW0..9\fR and an optional leading sign ("\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR").
.Sp
All other characters produce a syntax error.
.IP "\(bu" 2
Valid operands for overloaded operators
.Sp
All overloaded operators expect at least one bit vector operand,
in order for the operator to \*(L"know\*(R" that not the usual operation
is to be carried out, but rather the overloaded variant.
.Sp
This is especially true for all unary operators:
.Sp
.Vb 10
\&                    "$vector"
\&                    if ($vector)
\&                    if (!$vector)
\&                    ~$vector
\&                    \-$vector
\&                    abs($vector)
\&                    ++$vector
\&                    $vector++
\&                    \-\-$vector
\&                    $vector\-\-
.Ve
.Sp
For obvious reasons the left operand (the \*(L"lvalue\*(R") of all
assignment operators is also required to be a bit vector:
.Sp
.Vb 10
\&                        .=
\&                        x=
\&                        <<=
\&                        >>=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
In the case of three special operators, namely "\f(CW\*(C`<<\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x\*(C'\fR\*(L", as well as their related assignment
variants, \*(R"\f(CW\*(C`<<=\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>=\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x=\*(C'\fR", the
left operand is \fB\s-1ALWAYS\s0\fR a bit vector and the right operand is
\&\fB\s-1ALWAYS\s0\fR a number (which is the factor indicating how many times
the operator is to be applied).
.Sp
In all truly binary operators, i.e.,
.Sp
.Vb 10
\&                        .
\&                        |
\&                        &
\&                        ^
\&                        +
\&                        \-
\&                        *
\&                        /
\&                        %
\&                       **
\&                    <=>   cmp
\&                     ==    eq
\&                     !=    ne
\&                     <     lt
\&                     <=    le
\&                     >     gt
\&                     >=    ge
.Ve
.Sp
one of either operands may be replaced by a Perl scalar, i.e.,
a number or a string, either as a Perl constant, a Perl expression
or a Perl variable yielding a number or a string.
.Sp
The same applies to the right side operand (the \*(L"rvalue\*(R") of the
remaining assignment operators, i.e.,
.Sp
.Vb 10
\&                        .=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
Note that this Perl scalar should be of the correct type, i.e.,
numeric or string, for the chosen configuration, because otherwise
a warning message will occur if your program runs under the "\f(CW\*(C`\-w\*(C'\fR"
switch of Perl.
.Sp
The acceptable scalar types for each possible configuration are
the following:
.Sp
.Vb 6
\&    input = bit indices    (default)  :    numeric
\&    input = hexadecimal               :    string
\&    input = binary                    :    string
\&    input = decimal                   :    string     (in general)
\&    input = decimal                   :    numeric    (if small enough)
\&    input = enumeration               :    string
.Ve
.Sp
\&\s-1NOTE ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT VECTORS OF
THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER OPERAND.\s0
.Sp
The only exception from this rule is the concatenation operator
("\f(CW\*(C`.\*(C'\fR\*(L") and its assignment variant (\*(R"\f(CW\*(C`.=\*(C'\fR"):
.Sp
If one of the two operands of the concatenation operator ("\f(CW\*(C`.\*(C'\fR\*(L") is
not a bit vector object but a Perl scalar, the contents of the remaining
bit vector operand are converted into a string (the format of which
depends on the configuration set with the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method),
which is then concatenated in the proper order (i.e., as indicated by the
order of the two operands) with the Perl scalar (in other words, a string
is returned in such a case instead of a bit vector object!).
.Sp
If the right side operand (the \*(L"rvalue\*(R") of the assignment variant
("\f(CW\*(C`.=\*(C'\fR") of the concatenation operator is a Perl scalar, it is converted
internally to a bit vector of the same size as the left side operand provided
that the configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.Sp
If a decimal number (\*(L"big integer\*(R") is too large to be stored in a
bit vector of the given size, a \*(L"numeric overflow error\*(R" occurs.
.Sp
If a bit index is out of range for the given bit vector, an \*(L"index
out of range\*(R" error occurs.
.Sp
If a scalar operand cannot be converted successfully due to invalid
syntax, a fatal \*(L"input string syntax error\*(R" is issued.
.Sp
If the two operands of the operator "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`x\*(C'\fR\*(L" are reversed, a fatal \*(R"reversed operands error" occurs.
.Sp
If an operand is neither a bit vector nor a scalar, then a fatal
\&\*(L"illegal operand type error\*(R" occurs.
.IP "\(bu" 2
Bit order
.Sp
Note that bit vectors are stored least order bit and least order word first
internally.
.Sp
I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.
.Sp
(Where word #0 comes first in memory, i.e., it is stored at the least memory
address in the allocated block of memory holding the given bit vector.)
.Sp
Note however that machine words can be stored least order byte first or last,
depending on your system's implementation.
.Sp
Note further that whenever bit vectors are converted to and from (binary or
hexadecimal) strings, the \fB\s-1RIGHTMOST\s0\fR bit is always the \fB\s-1LEAST SIGNIFICANT\s0\fR
one, and the \fB\s-1LEFTMOST\s0\fR bit is always the \fB\s-1MOST SIGNIFICANT\s0\fR bit.
.Sp
This is because in our western culture, numbers are always represented in this
way (least significant to most significant digits go from right to left).
.Sp
Of course this requires an internal reversion of order, which the corresponding
conversion methods perform automatically (without any additional overhead, it's
just a matter of starting the internal loop at the bottom or the top end).
.IP "\(bu" 2
Matching sizes
.Sp
In general, for methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of bits), or a fatal
\&\*(L"size mismatch\*(R" error will occur.
.Sp
Exceptions from this rule are the methods "\f(CW\*(C`Concat()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Concat_List()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Interval_Copy()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Interval_Substitute()\*(C'\fR", where no
conditions at all are imposed on the size of their bit vector arguments.
.Sp
In method "\f(CW\*(C`Multiply()\*(C'\fR", all three bit vector arguments must in principle
obey the rule of matching sizes, but the bit vector in which the result of
the multiplication is to be stored may be larger than the two bit vector
arguments containing the factors for the multiplication.
.Sp
In method "\f(CW\*(C`Power()\*(C'\fR", the bit vector for the result must be the same
size or greater than the base of the exponentiation term. The exponent
can be any size.
.Sp
The same applies to the corresponding overloaded operators.
.IP "\(bu" 2
Index ranges
.Sp
All indices for any given bits must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"index out of range"
error will occur.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$config = Bit::Vector\->Configuration();\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`Bit::Vector\->Configuration($config);\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`$oldconfig = Bit::Vector\->Configuration($newconfig);\*(C'\fR
.Sp
This method serves to alter the semantics (i.e., behaviour) of certain
overloaded operators (which are all implemented in Perl, by the way).
.Sp
It does not have any effect whatsoever on anything else. In particular,
it does not affect the methods implemented in C.
.Sp
The method accepts an (optional) string as input in which certain keywords
are expected, which influence some or almost all of the overloaded operators
in several possible ways.
.Sp
The method always returns a string (which you do not need to take care of,
i.e., to store, in case you aren't interested in keeping it) which is a
complete representation of the current configuration (i.e., \fB\s-1BEFORE\s0\fR
any modifications are applied) and which can be fed back to this method
later in order to restore the previous configuration.
.Sp
There are three aspects of the way certain overloaded operators behave which
can be controlled with this method:
.Sp
.Vb 4
\&  +  the way scalar operands (replacing one of the two
\&     bit vector object operands) are automatically
\&     converted internally into a bit vector object of
\&     their own,
\&
\&  +  the operation certain overloaded operators perform,
\&     i.e., an operation with sets or an arithmetic
\&     operation,
\&
\&  +  the format to which bit vectors are converted
\&     automatically when they are enclosed in double
\&     quotes.
.Ve
.Sp
The input string may contain any number of assignments, each of which
controls one of these three aspects.
.Sp
Each assignment has the form "\f(CW\*(C`<which>=<value>\*(C'\fR".
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`<value>\*(C'\fR" thereby consist of letters
(\f(CW\*(C`[a\-zA\-Z]\*(C'\fR) and white space.
.Sp
Multiple assignments have to be separated by one or more comma (\*(L",\*(R"),
semi-colon (\*(L";\*(R"), colon (\*(L":\*(R"), vertical bar (\*(L"|\*(R"), slash (\*(L"/\*(R"),
newline (\*(L"\en\*(R"), ampersand (\*(L"&\*(R"), plus (\*(L"+\*(R") or dash (\*(L"\-\*(R").
.Sp
Empty lines or statements (only white space) are allowed but will be
ignored.
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" has to contain one or more keywords from one of
three groups, each group representing one of the three aspects that
the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method controls:
.Sp
.Vb 1
\&  +  "^scalar", "^input", "^in$"
\&
\&  +  "^operator", "^semantic", "^ops$"
\&
\&  +  "^string", "^output", "^out$"
.Ve
.Sp
The character \*(L"^\*(R" thereby denotes the beginning of a word, and \*(L"$\*(R"
denotes the end. Case is ignored (!).
.Sp
Using these keywords, you can build any phrase you like to select one
of the three aspects (see also examples given below).
.Sp
The only condition is that no other keyword from any of the other two
groups may match \- otherwise a syntax error will occur (i.e., ambiguities
are forbidden). A syntax error also occurs if none of the keywords
matches.
.Sp
This same principle applies to "\f(CW\*(C`<value>\*(C'\fR":
.Sp
Depending on which aspect you specified for "\f(CW\*(C`<which>\*(C'\fR",
there are different groups of keywords that determine the value
the selected aspect will be set to:
.Sp
.Vb 1
\&  +  "<which>" = "^scalar", "^input", "^in$":
\&
\&       "<value>" =
\&
\&       *  "^bit$", "^index", "^indice"
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
\&
\&  +  "<which>" = "^operator", "^semantic", "^ops$":
\&
\&       "<value>" =
\&
\&       *  "^set$"
\&       *  "^arithmetic"
\&
\&  +  "<which>" = "^string", "^output", "^out$":
\&
\&       "<value>" =
\&
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
.Ve
.Sp
Examples:
.Sp
.Vb 1
\&  "Any scalar input I provide should be considered to be = a bit index"
\&
\&  "I want to have operator semantics suitable for = arithmetics"
\&
\&  "Any bit vector in double quotes is to be output as = an enumeration"
.Ve
.Sp
\&\fB\s-1SCALAR INPUT:\s0\fR
.Sp
In the case of scalar input, "\f(CW\*(C`^bit$\*(C'\fR\*(L", \*(R"\f(CW\*(C`^index\*(C'\fR\*(L", or \*(R"\f(CW\*(C`^indice\*(C'\fR\*(L"
all cause scalar input to be considered to represent a bit index, i.e.,
\&\*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #5 in the given bit vector (this is
essentially the same as \*(R"\f(CW\*(C`$vector\->bit_flip(5);\*(C'\fR").
.Sp
Note that \*(L"bit indices\*(R" is the default setting for \*(L"scalar input\*(R".
.Sp
The keyword "\f(CW\*(C`^hex\*(C'\fR\*(L" will cause scalar input to be considered as being in
hexadecimal, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2 (because
hexadecimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that hexadecimal input should always be enclosed in quotes,
otherwise it will be interpreted as a decimal number by Perl! The example
relies on the fact that hexadecimal \f(CW\*(C`0\-9\*(C'\fR and decimal \f(CW\*(C`0\-9\*(C'\fR are the same.)
.Sp
The keyword "\f(CW\*(C`^bin\*(C'\fR\*(L" will cause scalar input to be considered as being in
binary format. All characters except \*(R"\f(CW0\fR\*(L" and \*(R"\f(CW1\fR" are forbidden in
this case (i.e., produce a syntax error).
.Sp
"\f(CW\*(C`$vector ^= \*(Aq0101\*(Aq;\*(C'\fR", for instance, will flip bit #0 and bit #2.
.Sp
The keyword "\f(CW\*(C`^dec\*(C'\fR\*(L" causes scalar input to be considered as integers
in decimal format, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2
(because decimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that all decimal input should be enclosed in quotes, because
for large numbers, Perl will use scientific notation internally for
representing them, which produces a syntax error because scientific
notation is neither supported by this module nor needed.)
.Sp
Finally, the keyword "\f(CW\*(C`^enum\*(C'\fR\*(L" causes scalar input to be considered
as being a list (\*(R"enumeration\*(L") of indices and ranges of (contiguous)
indices, i.e., \*(R"\f(CW\*(C`$vector |= \*(Aq2,3,5,7\-13,17\-23\*(Aq;\*(C'\fR" will cause bits #2,
#3, #5, #7 through #13 and #17 through #23 to be set.
.Sp
\&\fB\s-1OPERATOR SEMANTICS:\s0\fR
.Sp
Several overloaded operators can have two distinct functions depending
on this setting.
.Sp
The affected operators are: "\f(CW\*(C`+\*(C'\fR\*(L", \*(R"\f(CW\*(C`\-\*(C'\fR\*(L", \*(R"\f(CW\*(C`*\*(C'\fR\*(L", \*(R"\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR".
.Sp
With the default setting, \*(L"set operations\*(R", these operators perform:
.Sp
.Vb 7
\&  +       set union                           ( set1  u   set2 )
\&  \-       set difference                      ( set1  \e   set2 )
\&  *       set intersection                    ( set1  n   set2 )
\&  <       true subset relationship            ( set1  <   set2 )
\&  <=      subset relationship                 ( set1  <=  set2 )
\&  >       true superset relationship          ( set1  >   set2 )
\&  >=      superset relationship               ( set1  >=  set2 )
.Ve
.Sp
With the alternative setting, \*(L"arithmetic operations\*(R", these operators
perform:
.Sp
.Vb 7
\&  +       addition                            ( num1  +   num2 )
\&  \-       subtraction                         ( num1  \-   num2 )
\&  *       multiplication                      ( num1  *   num2 )
\&  <       "less than" comparison              ( num1  <   num2 )
\&  <=      "less than or equal" comparison     ( num1  <=  num2 )
\&  >       "greater than" comparison           ( num1  >   num2 )
\&  >=      "greater than or equal" comparison  ( num1  >=  num2 )
.Ve
.Sp
Note that these latter comparison operators ("\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR") regard their operands as being \fB\s-1SIGNED\s0\fR.
.Sp
To perform comparisons with \fB\s-1UNSIGNED\s0\fR operands, use the operators
"\f(CW\*(C`lt\*(C'\fR\*(L", \*(R"\f(CW\*(C`le\*(C'\fR\*(L", \*(R"\f(CW\*(C`gt\*(C'\fR\*(L" and \*(R"\f(CW\*(C`ge\*(C'\fR" instead (in contrast to the
operators above, these operators are \fB\s-1NOT\s0\fR affected by the
\&\*(L"operator semantics\*(R" setting).
.Sp
\&\fB\s-1STRING OUTPUT:\s0\fR
.Sp
There are four methods which convert the contents of a given bit vector
into a string: "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L"
(not counting \*(R"\f(CW\*(C`Block_Read()\*(C'\fR", since this method does not return a
human-readable string).
.Sp
(For conversion to octal, see the description of the method
"\f(CW\*(C`Chunk_List_Read()\*(C'\fR".)
.Sp
Therefore, there are four possible formats into which a bit vector can
be converted when it is enclosed in double quotes, for example:
.Sp
.Vb 2
\&  print "\e$vector = \*(Aq$vector\*(Aq\en";
\&  $string = "$vector";
.Ve
.Sp
Hence you can set \*(L"string output\*(R" to four different values: To \*(L"hex\*(R"
for hexadecimal format (which is the default), to \*(L"bin\*(R" for binary
format, to \*(L"dec\*(R" for conversion to decimal numbers and to \*(L"enum\*(R"
for conversion to enumerations (\*(L".newsrc\*(R" style sets).
.Sp
\&\fB\s-1BEWARE\s0\fR that the conversion to decimal numbers is inherently slow;
it can easily take up several seconds for a single large bit vector!
.Sp
Therefore you should store the decimal strings returned to you
rather than converting a given bit vector again.
.Sp
\&\fB\s-1EXAMPLES:\s0\fR
.Sp
The default setting as returned by the method "\f(CW\*(C`Configuration()\*(C'\fR"
is:
.Sp
.Vb 3
\&        Scalar Input       = Bit Index
\&        Operator Semantics = Set Operators
\&        String Output      = Hexadecimal
.Ve
.Sp
Performing a statement such as:
.Sp
.Vb 2
\&  Bit::Vector\->Configuration("in=bin,ops=arithmetic,out=bin");
\&  print Bit::Vector\->Configuration(), "\en";
.Ve
.Sp
yields the following output:
.Sp
.Vb 3
\&        Scalar Input       = Binary
\&        Operator Semantics = Arithmetic Operators
\&        String Output      = Binary
.Ve
.Sp
Note that you can always feed this output back into the "\f(CW\*(C`Configuration()\*(C'\fR"
method to restore that setting later.
.Sp
This also means that you can enter the same given setting with almost any
degree of verbosity you like (as long as the required keywords appear and
no ambiguities arise).
.Sp
Note further that any aspect you do not specify is not changed, i.e.,
the statement
.Sp
.Vb 1
\&  Bit::Vector\->Configuration("operators = arithmetic");
.Ve
.Sp
leaves all other aspects unchanged.
.IP "\(bu" 2
\&\f(CW"$vector"\fR
.Sp
Remember that variables enclosed in double quotes are always
interpolated in Perl.
.Sp
Whenever a Perl variable containing the reference of a \*(L"Bit::Vector\*(R"
object is enclosed in double quotes (either alone or together with
other text and/or variables), the contents of the corresponding
bit vector are converted into a printable string.
.Sp
Since there are several conversion methods available in this module
(see the description of the methods "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR"), it is of course desirable to
be able to choose which of these methods should be applied in this
case.
.Sp
This can actually be done by changing the configuration of this
module using the method "\f(CW\*(C`Configure()\*(C'\fR" (see the previous chapter,
immediately above).
.Sp
The default is conversion to hexadecimal.
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector)\*(C'\fR
.Sp
It is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression.
.Sp
The condition above is true if the corresponding bit vector contains
at least one set bit, and it is false if \fB\s-1ALL\s0\fR bits of the corresponding
bit vector are cleared.
.IP "\(bu" 2
\&\f(CW\*(C`if (!$vector)\*(C'\fR
.Sp
Since it is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression, you can of course also negate
this boolean expression.
.Sp
The condition above is true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector
are cleared, and it is false if the corresponding bit vector contains at
least one set bit.
.Sp
Note that this is \fB\s-1NOT\s0\fR the same as using the method "\f(CW\*(C`is_full()\*(C'\fR",
which returns true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector are
\&\fB\s-1SET\s0\fR.
.IP "\(bu" 2
\&\f(CW\*(C`~$vector\*(C'\fR
.Sp
This term returns a new bit vector object which is the one's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits.
.IP "\(bu" 2
\&\f(CW\*(C`\-$vector\*(C'\fR (unary minus)
.Sp
This term returns a new bit vector object which is the two's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits and incrementing the result by one.
.Sp
(This is the same as changing the sign of a number in two's complement
binary representation.)
.IP "\(bu" 2
\&\f(CW\*(C`abs($vector)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
the number of set bits in the given bit vector (this is the same
as calculating the number of elements which are contained in the
given set) \- which is the default behaviour, or it returns a new
bit vector object which contains the absolute value of the number
stored in the given bit vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 . $vector2\*(C'\fR
.Sp
This term usually returns a new bit vector object which is the
result of the concatenation of the two bit vector operands.
.Sp
The left operand becomes the most significant, and the right operand
becomes the least significant part of the new bit vector object.
.Sp
If one of the two operands is not a bit vector object but a Perl scalar,
however, the contents of the remaining bit vector operand are converted
into a string (the format of which depends on the configuration set with
the "\f(CW\*(C`Configuration()\*(C'\fR" method), which is then concatenated in the proper
order (i.e., as indicated by the order of the two operands) with the Perl
scalar.
.Sp
In other words, a string is returned in such a case instead of a
bit vector object!
.IP "\(bu" 2
\&\f(CW\*(C`$vector x $factor\*(C'\fR
.Sp
This term returns a new bit vector object which is the concatenation
of as many copies of the given bit vector operand (the left operand)
as the factor (the right operand) specifies.
.Sp
If the factor is zero, a bit vector object with a length of zero bits
is returned.
.Sp
If the factor is one, just a new copy of the given bit vector is
returned.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector << $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted left (towards the
most significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector >> $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted right (towards the
least significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 | $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1OR\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 & $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1AND\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^ $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1XOR \s0(exclusive-or) operation between the two bit vector
operands.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 + $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1OR\s0 operation
between the two bit vector operands (this is the same as calculating
the union of two sets) \- which is the default behaviour, or it returns
a new bit vector object which contains the sum of the two numbers
stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \- $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the set difference of the two sets
represented in the two bit vector operands \- which is the default
behaviour, or it returns a new bit vector object which contains
the difference of the two numbers stored in the two bit vector
operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 * $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1AND\s0 operation
between the two bit vector operands (this is the same as calculating
the intersection of two sets) \- which is the default behaviour, or it
returns a new bit vector object which contains the product of the two
numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 / $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 % $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the remainder of
the division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ** $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
exponentiation of the left bit vector elevated to the right bit vector's
power.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 .= $vector2;\*(C'\fR
.Sp
This statement \*(L"appends\*(R" the right bit vector operand (the \*(L"rvalue\*(R")
to the left one (the \*(L"lvalue\*(R").
.Sp
The former contents of the left operand become the most significant
part of the resulting bit vector, and the right operand becomes the
least significant part.
.Sp
Since bit vectors are stored in \*(L"least order bit first\*(R" order, this
actually requires the left operand to be shifted \*(L"up\*(R" by the length
of the right operand, which is then copied to the now freed least
significant part of the left operand.
.Sp
If the right operand is a Perl scalar, it is first converted to a
bit vector of the same size as the left operand, provided that the
configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.IP "\(bu" 2
\&\f(CW\*(C`$vector x= $factor;\*(C'\fR
.Sp
This statement replaces the given bit vector by a concatenation of as many
copies of the original contents of the given bit vector as the factor (the
right operand) specifies.
.Sp
If the factor is zero, the given bit vector is resized to a length of zero
bits.
.Sp
If the factor is one, the given bit vector is not changed at all.
.IP "\(bu" 2
\&\f(CW\*(C`$vector <<= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector left by "\f(CW$bits\fR"
positions (towards the most significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector >>= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector right by "\f(CW$bits\fR"
positions (towards the least significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 |= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1OR\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 &= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1AND\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1XOR \s0(exclusive-or) operation
between the two bit vector operands and stores the result in the
left operand.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 += $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1OR\s0 operation between the two bit vector operands (this is
the same as calculating the union of two sets) \- which is the default
behaviour, or it calculates the sum of the two numbers stored in the
two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \-= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either calculates
the set difference of the two sets represented in the two bit vector
operands \- which is the default behaviour, or it calculates the
difference of the two numbers stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 *= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1AND\s0 operation between the two bit vector operands (this is
the same as calculating the intersection of two sets) \- which is the
default behaviour, or it calculates the product of the two numbers
stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 /= $vector2;\*(C'\fR
.Sp
This statement puts the result of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 %= $vector2;\*(C'\fR
.Sp
This statement puts the remainder of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 **= $vector2;\*(C'\fR
.Sp
This statement puts the result of the exponentiation of the left
operand elevated to the right operand's power into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`++$vector\*(C'\fR, \f(CW\*(C`$vector++\*(C'\fR
.Sp
This operator performs pre\- and post-incrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the incrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`\-\-$vector\*(C'\fR, \f(CW\*(C`$vector\-\-\*(C'\fR
.Sp
This operator performs pre\- and post-decrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the decrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 cmp $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 eq $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ne $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 lt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 le $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 gt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ge $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <=> $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 == $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 != $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 < $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true subset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a subset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 > $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true superset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 >= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a superset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::String\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::Overload\*(R" version 7.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 \- 2013 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::Overload5.16.3pm                0100644 0001750 0001750 00000152405 12566241525 025567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::Overload 3"
.TH Bit::Vector::Overload 3 "2012-05-17" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::Overload \- Overloaded operators add\-on for Bit::Vector
.SH "USAGE"
.IX Header "USAGE"
Note that you do not need to "\f(CW\*(C`use Bit::Vector;\*(C'\fR"
in addition to this module.
.PP
Simply "\f(CW\*(C`use Bit::Vector::Overload;\*(C'\fR" \fB\s-1INSTEAD\s0\fR
of "\f(CW\*(C`use Bit::Vector;\*(C'\fR\*(L". You can still use all the
methods from the \*(R"Bit::Vector" module in addition
to the overloaded operators and methods provided
here after that.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  Configuration
\&      $config = Bit::Vector\->Configuration();
\&      Bit::Vector\->Configuration($config);
\&      $oldconfig = Bit::Vector\->Configuration($newconfig);
\&
\&  String Conversion
\&      $string = "$vector";             #  depending on configuration
\&      print "\e$vector = \*(Aq$vector\*(Aq\en";
\&
\&  Emptyness
\&      if ($vector)  #  if not empty (non\-zero)
\&      if (! $vector)  #  if empty (zero)
\&      unless ($vector)  #  if empty (zero)
\&
\&  Complement (one\*(Aqs complement)
\&      $vector2 = ~$vector1;
\&      $vector = ~$vector;
\&
\&  Negation (two\*(Aqs complement)
\&      $vector2 = \-$vector1;
\&      $vector = \-$vector;
\&
\&  Norm
\&      $norm = abs($vector);  #  depending on configuration
\&
\&  Absolute
\&      $vector2 = abs($vector1);  #  depending on configuration
\&
\&  Concatenation
\&      $vector3 = $vector1 . $vector2;
\&      $vector1 .= $vector2;
\&      $vector1 = $vector2 . $vector1;
\&      $vector2 = $vector1 . $scalar;  #  depending on configuration
\&      $vector2 = $scalar . $vector1;
\&      $vector .= $scalar;
\&
\&  Duplication
\&      $vector2 = $vector1 x $factor;
\&      $vector x= $factor;
\&
\&  Shift Left
\&      $vector2 = $vector1 << $bits;
\&      $vector <<= $bits;
\&
\&  Shift Right
\&      $vector2 = $vector1 >> $bits;
\&      $vector >>= $bits;
\&
\&  Union
\&      $vector3 = $vector1 | $vector2;
\&      $vector1 |= $vector2;
\&      $vector2 = $vector1 | $scalar;
\&      $vector |= $scalar;
\&
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Intersection
\&      $vector3 = $vector1 & $vector2;
\&      $vector1 &= $vector2;
\&      $vector2 = $vector1 & $scalar;
\&      $vector &= $scalar;
\&
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  ExclusiveOr
\&      $vector3 = $vector1 ^ $vector2;
\&      $vector1 ^= $vector2;
\&      $vector2 = $vector1 ^ $scalar;
\&      $vector ^= $scalar;
\&
\&  Set Difference
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Addition
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Subtraction
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Multiplication
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  Division
\&      $vector3 = $vector1 / $vector2;
\&      $vector1 /= $vector2;
\&      $vector1 = $vector2 / $vector1;
\&      $vector2 = $vector1 / $scalar;
\&      $vector2 = $scalar / $vector1;
\&      $vector /= $scalar;
\&
\&  Modulo
\&      $vector3 = $vector1 % $vector2;
\&      $vector1 %= $vector2;
\&      $vector1 = $vector2 % $vector1;
\&      $vector2 = $vector1 % $scalar;
\&      $vector2 = $scalar % $vector1;
\&      $vector %= $scalar;
\&
\&  Exponentiation
\&      $vector3 = $vector1 ** $vector2;
\&      $vector1 **= $vector2;
\&      $vector2 = $vector1 ** $scalar;
\&      $vector2 = $scalar ** $vector1;
\&      $vector **= $scalar;
\&
\&  Increment
\&      ++$vector;
\&      $vector++;
\&
\&  Decrement
\&      \-\-$vector;
\&      $vector\-\-;
\&
\&  Lexical Comparison (unsigned)
\&      $cmp = $vector1 cmp $vector2;
\&      if ($vector1 lt $vector2)
\&      if ($vector1 le $vector2)
\&      if ($vector1 gt $vector2)
\&      if ($vector1 ge $vector2)
\&
\&      $cmp = $vector cmp $scalar;
\&      if ($vector lt $scalar)
\&      if ($vector le $scalar)
\&      if ($vector gt $scalar)
\&      if ($vector ge $scalar)
\&
\&  Comparison (signed)
\&      $cmp = $vector1 <=> $vector2;
\&      if ($vector1 < $vector2)  #  depending on configuration
\&      if ($vector1 <= $vector2)
\&      if ($vector1 > $vector2)
\&      if ($vector1 >= $vector2)
\&
\&      $cmp = $vector <=> $scalar;
\&      if ($vector < $scalar)  #  depending on configuration
\&      if ($vector <= $scalar)
\&      if ($vector > $scalar)
\&      if ($vector >= $scalar)
\&
\&  Equality
\&      if ($vector1 eq $vector2)
\&      if ($vector1 ne $vector2)
\&      if ($vector eq $scalar)
\&      if ($vector ne $scalar)
\&
\&      if ($vector1 == $vector2)
\&      if ($vector1 != $vector2)
\&      if ($vector == $scalar)
\&      if ($vector != $scalar)
\&
\&  Subset Relationship
\&      if ($vector1 <= $vector2)  #  depending on configuration
\&
\&  True Subset Relationship
\&      if ($vector1 < $vector2)  #  depending on configuration
\&
\&  Superset Relationship
\&      if ($vector1 >= $vector2)  #  depending on configuration
\&
\&  True Superset Relationship
\&      if ($vector1 > $vector2)  #  depending on configuration
.Ve
.SH "IMPORTANT NOTES"
.IX Header "IMPORTANT NOTES"
.IP "\(bu" 2
Boolean values
.Sp
Boolean values in this module are always a numeric zero ("\f(CW0\fR\*(L") for
\&\*(R"false\*(L" and a numeric one (\*(R"\f(CW1\fR\*(L") for \*(R"true".
.IP "\(bu" 2
Negative numbers
.Sp
Numeric factors (as needed for the "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`x\*(C'\fR" operators) and bit numbers are always regarded as being
\&\fB\s-1UNSIGNED\s0\fR.
.Sp
As a consequence, whenever you pass a negative number for such a factor
or bit number, it will be treated as a (usually very large) positive
number due to its internal two's complement binary representation, usually
resulting in malfunctions or an \*(L"index out of range\*(R" error message and
program abortion.
.Sp
Note that this does not apply to \*(L"big integer\*(R" decimal numbers, which
are (usually) passed as strings, and which may of course be negative
(see also the section \*(L"Big integers\*(R" a little further below).
.IP "\(bu" 2
Overloaded operators configuration
.Sp
Note that the behaviour of certain overloaded operators can be changed
in various ways by means of the "\f(CW\*(C`Configuration()\*(C'\fR" method (for more
details, see the description of this method further below).
.Sp
For instance, scalars (i.e., numbers and strings) provided as operands
to overloaded operators are automatically converted to bit vectors,
internally.
.Sp
These scalars are thereby automatically assumed to be indices or to be
in hexadecimal, binary, decimal or enumeration format, depending on the
configuration.
.Sp
Similarly, when converting bit vectors to strings using double quotes
(""), the output format will also depend on the previously chosen
configuration.
.Sp
Finally, some overloaded operators may have different semantics depending
on the proper configuration; for instance, the operator \*(L"+\*(R" can be the
\&\*(L"union\*(R" operator from set theory or the arithmetic \*(L"add\*(R" operator.
.Sp
In all cases (input, output and operator semantics), the defaults have
been chosen in such a way so that the behaviour of the module is backward
compatible with previous versions.
.IP "\(bu" 2
\&\*(L"Big integers\*(R"
.Sp
As long as \*(L"big integers\*(R" (for \*(L"big integer\*(R" arithmetic) are small enough
so that Perl doesn't need scientific notation (exponents) to be able to
represent them internally, you can provide these \*(L"big integer\*(R" constants
to the overloaded operators of this module (or to the method "\f(CW\*(C`from_Dec()\*(C'\fR")
in numeric form (i.e., either as a numeric constant or expression or as a
Perl variable containing a numeric value).
.Sp
Note that you will get an error message (resulting in program abortion)
if your \*(L"big integer\*(R" numbers exceed that limit.
.Sp
Because this limit is machine-dependent and not obvious to find out,
it is strongly recommended that you enclose \fB\s-1ALL\s0\fR your \*(L"big integer\*(R"
constants in your programs in (double or single) quotes.
.Sp
Examples:
.Sp
.Vb 1
\&    $vector /= 10;  #  ok because number is small
\&
\&    $vector /= \-10;  #  ok for same reason
\&
\&    $vector /= "10";  #  always correct
\&
\&    $vector += "1152921504606846976";  #  quotes probably required here
.Ve
.Sp
All examples assume
.Sp
.Vb 1
\&    Bit::Vector\->Configuration("input=decimal");
.Ve
.Sp
having been set beforehand.
.Sp
Note also that this module does not support scientific notation (exponents)
for \*(L"big integer\*(R" decimal numbers because you can always make the bit vector
large enough for the whole number to fit without loss of precision (as it
would occur if scientific notation were used).
.Sp
Finally, note that the only characters allowed in \*(L"big integer\*(R" constant
strings are the digits \f(CW0..9\fR and an optional leading sign ("\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR").
.Sp
All other characters produce a syntax error.
.IP "\(bu" 2
Valid operands for overloaded operators
.Sp
All overloaded operators expect at least one bit vector operand,
in order for the operator to \*(L"know\*(R" that not the usual operation
is to be carried out, but rather the overloaded variant.
.Sp
This is especially true for all unary operators:
.Sp
.Vb 10
\&                    "$vector"
\&                    if ($vector)
\&                    if (!$vector)
\&                    ~$vector
\&                    \-$vector
\&                    abs($vector)
\&                    ++$vector
\&                    $vector++
\&                    \-\-$vector
\&                    $vector\-\-
.Ve
.Sp
For obvious reasons the left operand (the \*(L"lvalue\*(R") of all
assignment operators is also required to be a bit vector:
.Sp
.Vb 10
\&                        .=
\&                        x=
\&                        <<=
\&                        >>=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
In the case of three special operators, namely "\f(CW\*(C`<<\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x\*(C'\fR\*(L", as well as their related assignment
variants, \*(R"\f(CW\*(C`<<=\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>=\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x=\*(C'\fR", the
left operand is \fB\s-1ALWAYS\s0\fR a bit vector and the right operand is
\&\fB\s-1ALWAYS\s0\fR a number (which is the factor indicating how many times
the operator is to be applied).
.Sp
In all truly binary operators, i.e.,
.Sp
.Vb 10
\&                        .
\&                        |
\&                        &
\&                        ^
\&                        +
\&                        \-
\&                        *
\&                        /
\&                        %
\&                       **
\&                    <=>   cmp
\&                     ==    eq
\&                     !=    ne
\&                     <     lt
\&                     <=    le
\&                     >     gt
\&                     >=    ge
.Ve
.Sp
one of either operands may be replaced by a Perl scalar, i.e.,
a number or a string, either as a Perl constant, a Perl expression
or a Perl variable yielding a number or a string.
.Sp
The same applies to the right side operand (the \*(L"rvalue\*(R") of the
remaining assignment operators, i.e.,
.Sp
.Vb 10
\&                        .=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
Note that this Perl scalar should be of the correct type, i.e.,
numeric or string, for the chosen configuration, because otherwise
a warning message will occur if your program runs under the "\f(CW\*(C`\-w\*(C'\fR"
switch of Perl.
.Sp
The acceptable scalar types for each possible configuration are
the following:
.Sp
.Vb 6
\&    input = bit indices    (default)  :    numeric
\&    input = hexadecimal               :    string
\&    input = binary                    :    string
\&    input = decimal                   :    string     (in general)
\&    input = decimal                   :    numeric    (if small enough)
\&    input = enumeration               :    string
.Ve
.Sp
\&\s-1NOTE\s0 \s-1ALSO\s0 \s-1THAT\s0 \s-1THESE\s0 \s-1SCALAR\s0 \s-1OPERANDS\s0 \s-1ARE\s0 \s-1CONVERTED\s0 \s-1TO\s0 \s-1BIT\s0 \s-1VECTORS\s0 \s-1OF\s0
\&\s-1THE\s0 \s-1SAME\s0 \s-1SIZE\s0 \s-1AS\s0 \s-1THE\s0 \s-1BIT\s0 \s-1VECTOR\s0 \s-1WHICH\s0 \s-1IS\s0 \s-1THE\s0 \s-1OTHER\s0 \s-1OPERAND\s0.
.Sp
The only exception from this rule is the concatenation operator
("\f(CW\*(C`.\*(C'\fR\*(L") and its assignment variant (\*(R"\f(CW\*(C`.=\*(C'\fR"):
.Sp
If one of the two operands of the concatenation operator ("\f(CW\*(C`.\*(C'\fR\*(L") is
not a bit vector object but a Perl scalar, the contents of the remaining
bit vector operand are converted into a string (the format of which
depends on the configuration set with the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method),
which is then concatenated in the proper order (i.e., as indicated by the
order of the two operands) with the Perl scalar (in other words, a string
is returned in such a case instead of a bit vector object!).
.Sp
If the right side operand (the \*(L"rvalue\*(R") of the assignment variant
("\f(CW\*(C`.=\*(C'\fR") of the concatenation operator is a Perl scalar, it is converted
internally to a bit vector of the same size as the left side operand provided
that the configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.Sp
If a decimal number (\*(L"big integer\*(R") is too large to be stored in a
bit vector of the given size, a \*(L"numeric overflow error\*(R" occurs.
.Sp
If a bit index is out of range for the given bit vector, an \*(L"index
out of range\*(R" error occurs.
.Sp
If a scalar operand cannot be converted successfully due to invalid
syntax, a fatal \*(L"input string syntax error\*(R" is issued.
.Sp
If the two operands of the operator "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`x\*(C'\fR\*(L" are reversed, a fatal \*(R"reversed operands error" occurs.
.Sp
If an operand is neither a bit vector nor a scalar, then a fatal
\&\*(L"illegal operand type error\*(R" occurs.
.IP "\(bu" 2
Bit order
.Sp
Note that bit vectors are stored least order bit and least order word first
internally.
.Sp
I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.
.Sp
(Where word #0 comes first in memory, i.e., it is stored at the least memory
address in the allocated block of memory holding the given bit vector.)
.Sp
Note however that machine words can be stored least order byte first or last,
depending on your system's implementation.
.Sp
Note further that whenever bit vectors are converted to and from (binary or
hexadecimal) strings, the \fB\s-1RIGHTMOST\s0\fR bit is always the \fB\s-1LEAST\s0 \s-1SIGNIFICANT\s0\fR
one, and the \fB\s-1LEFTMOST\s0\fR bit is always the \fB\s-1MOST\s0 \s-1SIGNIFICANT\s0\fR bit.
.Sp
This is because in our western culture, numbers are always represented in this
way (least significant to most significant digits go from right to left).
.Sp
Of course this requires an internal reversion of order, which the corresponding
conversion methods perform automatically (without any additional overhead, it's
just a matter of starting the internal loop at the bottom or the top end).
.IP "\(bu" 2
Matching sizes
.Sp
In general, for methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of bits), or a fatal
\&\*(L"size mismatch\*(R" error will occur.
.Sp
Exceptions from this rule are the methods "\f(CW\*(C`Concat()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Concat_List()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Interval_Copy()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Interval_Substitute()\*(C'\fR", where no
conditions at all are imposed on the size of their bit vector arguments.
.Sp
In method "\f(CW\*(C`Multiply()\*(C'\fR", all three bit vector arguments must in principle
obey the rule of matching sizes, but the bit vector in which the result of
the multiplication is to be stored may be larger than the two bit vector
arguments containing the factors for the multiplication.
.Sp
In method "\f(CW\*(C`Power()\*(C'\fR", the bit vector for the result must be the same
size or greater than the base of the exponentiation term. The exponent
can be any size.
.Sp
The same applies to the corresponding overloaded operators.
.IP "\(bu" 2
Index ranges
.Sp
All indices for any given bits must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"index out of range"
error will occur.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$config = Bit::Vector\->Configuration();\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`Bit::Vector\->Configuration($config);\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`$oldconfig = Bit::Vector\->Configuration($newconfig);\*(C'\fR
.Sp
This method serves to alter the semantics (i.e., behaviour) of certain
overloaded operators (which are all implemented in Perl, by the way).
.Sp
It does not have any effect whatsoever on anything else. In particular,
it does not affect the methods implemented in C.
.Sp
The method accepts an (optional) string as input in which certain keywords
are expected, which influence some or almost all of the overloaded operators
in several possible ways.
.Sp
The method always returns a string (which you do not need to take care of,
i.e., to store, in case you aren't interested in keeping it) which is a
complete representation of the current configuration (i.e., \fB\s-1BEFORE\s0\fR
any modifications are applied) and which can be fed back to this method
later in order to restore the previous configuration.
.Sp
There are three aspects of the way certain overloaded operators behave which
can be controlled with this method:
.Sp
.Vb 4
\&  +  the way scalar operands (replacing one of the two
\&     bit vector object operands) are automatically
\&     converted internally into a bit vector object of
\&     their own,
\&
\&  +  the operation certain overloaded operators perform,
\&     i.e., an operation with sets or an arithmetic
\&     operation,
\&
\&  +  the format to which bit vectors are converted
\&     automatically when they are enclosed in double
\&     quotes.
.Ve
.Sp
The input string may contain any number of assignments, each of which
controls one of these three aspects.
.Sp
Each assignment has the form "\f(CW\*(C`<which>=<value>\*(C'\fR".
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`<value>\*(C'\fR" thereby consist of letters
(\f(CW\*(C`[a\-zA\-Z]\*(C'\fR) and white space.
.Sp
Multiple assignments have to be separated by one or more comma (\*(L",\*(R"),
semi-colon (\*(L";\*(R"), colon (\*(L":\*(R"), vertical bar (\*(L"|\*(R"), slash (\*(L"/\*(R"),
newline (\*(L"\en\*(R"), ampersand (\*(L"&\*(R"), plus (\*(L"+\*(R") or dash (\*(L"\-\*(R").
.Sp
Empty lines or statements (only white space) are allowed but will be
ignored.
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" has to contain one or more keywords from one of
three groups, each group representing one of the three aspects that
the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method controls:
.Sp
.Vb 1
\&  +  "^scalar", "^input", "^in$"
\&
\&  +  "^operator", "^semantic", "^ops$"
\&
\&  +  "^string", "^output", "^out$"
.Ve
.Sp
The character \*(L"^\*(R" thereby denotes the beginning of a word, and \*(L"$\*(R"
denotes the end. Case is ignored (!).
.Sp
Using these keywords, you can build any phrase you like to select one
of the three aspects (see also examples given below).
.Sp
The only condition is that no other keyword from any of the other two
groups may match \- otherwise a syntax error will occur (i.e., ambiguities
are forbidden). A syntax error also occurs if none of the keywords
matches.
.Sp
This same principle applies to "\f(CW\*(C`<value>\*(C'\fR":
.Sp
Depending on which aspect you specified for "\f(CW\*(C`<which>\*(C'\fR",
there are different groups of keywords that determine the value
the selected aspect will be set to:
.Sp
.Vb 1
\&  +  "<which>" = "^scalar", "^input", "^in$":
\&
\&       "<value>" =
\&
\&       *  "^bit$", "^index", "^indice"
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
\&
\&  +  "<which>" = "^operator", "^semantic", "^ops$":
\&
\&       "<value>" =
\&
\&       *  "^set$"
\&       *  "^arithmetic"
\&
\&  +  "<which>" = "^string", "^output", "^out$":
\&
\&       "<value>" =
\&
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
.Ve
.Sp
Examples:
.Sp
.Vb 1
\&  "Any scalar input I provide should be considered to be = a bit index"
\&
\&  "I want to have operator semantics suitable for = arithmetics"
\&
\&  "Any bit vector in double quotes is to be output as = an enumeration"
.Ve
.Sp
\&\fB\s-1SCALAR\s0 \s-1INPUT:\s0\fR
.Sp
In the case of scalar input, "\f(CW\*(C`^bit$\*(C'\fR\*(L", \*(R"\f(CW\*(C`^index\*(C'\fR\*(L", or \*(R"\f(CW\*(C`^indice\*(C'\fR\*(L"
all cause scalar input to be considered to represent a bit index, i.e.,
\&\*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #5 in the given bit vector (this is
essentially the same as \*(R"\f(CW\*(C`$vector\->bit_flip(5);\*(C'\fR").
.Sp
Note that \*(L"bit indices\*(R" is the default setting for \*(L"scalar input\*(R".
.Sp
The keyword "\f(CW\*(C`^hex\*(C'\fR\*(L" will cause scalar input to be considered as being in
hexadecimal, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2 (because
hexadecimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that hexadecimal input should always be enclosed in quotes,
otherwise it will be interpreted as a decimal number by Perl! The example
relies on the fact that hexadecimal \f(CW\*(C`0\-9\*(C'\fR and decimal \f(CW\*(C`0\-9\*(C'\fR are the same.)
.Sp
The keyword "\f(CW\*(C`^bin\*(C'\fR\*(L" will cause scalar input to be considered as being in
binary format. All characters except \*(R"\f(CW0\fR\*(L" and \*(R"\f(CW1\fR" are forbidden in
this case (i.e., produce a syntax error).
.Sp
"\f(CW\*(C`$vector ^= \*(Aq0101\*(Aq;\*(C'\fR", for instance, will flip bit #0 and bit #2.
.Sp
The keyword "\f(CW\*(C`^dec\*(C'\fR\*(L" causes scalar input to be considered as integers
in decimal format, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2
(because decimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that all decimal input should be enclosed in quotes, because
for large numbers, Perl will use scientific notation internally for
representing them, which produces a syntax error because scientific
notation is neither supported by this module nor needed.)
.Sp
Finally, the keyword "\f(CW\*(C`^enum\*(C'\fR\*(L" causes scalar input to be considered
as being a list (\*(R"enumeration\*(L") of indices and ranges of (contiguous)
indices, i.e., \*(R"\f(CW\*(C`$vector |= \*(Aq2,3,5,7\-13,17\-23\*(Aq;\*(C'\fR" will cause bits #2,
#3, #5, #7 through #13 and #17 through #23 to be set.
.Sp
\&\fB\s-1OPERATOR\s0 \s-1SEMANTICS:\s0\fR
.Sp
Several overloaded operators can have two distinct functions depending
on this setting.
.Sp
The affected operators are: "\f(CW\*(C`+\*(C'\fR\*(L", \*(R"\f(CW\*(C`\-\*(C'\fR\*(L", \*(R"\f(CW\*(C`*\*(C'\fR\*(L", \*(R"\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR".
.Sp
With the default setting, \*(L"set operations\*(R", these operators perform:
.Sp
.Vb 7
\&  +       set union                           ( set1  u   set2 )
\&  \-       set difference                      ( set1  \e   set2 )
\&  *       set intersection                    ( set1  n   set2 )
\&  <       true subset relationship            ( set1  <   set2 )
\&  <=      subset relationship                 ( set1  <=  set2 )
\&  >       true superset relationship          ( set1  >   set2 )
\&  >=      superset relationship               ( set1  >=  set2 )
.Ve
.Sp
With the alternative setting, \*(L"arithmetic operations\*(R", these operators
perform:
.Sp
.Vb 7
\&  +       addition                            ( num1  +   num2 )
\&  \-       subtraction                         ( num1  \-   num2 )
\&  *       multiplication                      ( num1  *   num2 )
\&  <       "less than" comparison              ( num1  <   num2 )
\&  <=      "less than or equal" comparison     ( num1  <=  num2 )
\&  >       "greater than" comparison           ( num1  >   num2 )
\&  >=      "greater than or equal" comparison  ( num1  >=  num2 )
.Ve
.Sp
Note that these latter comparison operators ("\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR") regard their operands as being \fB\s-1SIGNED\s0\fR.
.Sp
To perform comparisons with \fB\s-1UNSIGNED\s0\fR operands, use the operators
"\f(CW\*(C`lt\*(C'\fR\*(L", \*(R"\f(CW\*(C`le\*(C'\fR\*(L", \*(R"\f(CW\*(C`gt\*(C'\fR\*(L" and \*(R"\f(CW\*(C`ge\*(C'\fR" instead (in contrast to the
operators above, these operators are \fB\s-1NOT\s0\fR affected by the
\&\*(L"operator semantics\*(R" setting).
.Sp
\&\fB\s-1STRING\s0 \s-1OUTPUT:\s0\fR
.Sp
There are four methods which convert the contents of a given bit vector
into a string: "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L"
(not counting \*(R"\f(CW\*(C`Block_Read()\*(C'\fR", since this method does not return a
human-readable string).
.Sp
(For conversion to octal, see the description of the method
"\f(CW\*(C`Chunk_List_Read()\*(C'\fR".)
.Sp
Therefore, there are four possible formats into which a bit vector can
be converted when it is enclosed in double quotes, for example:
.Sp
.Vb 2
\&  print "\e$vector = \*(Aq$vector\*(Aq\en";
\&  $string = "$vector";
.Ve
.Sp
Hence you can set \*(L"string output\*(R" to four different values: To \*(L"hex\*(R"
for hexadecimal format (which is the default), to \*(L"bin\*(R" for binary
format, to \*(L"dec\*(R" for conversion to decimal numbers and to \*(L"enum\*(R"
for conversion to enumerations (\*(L".newsrc\*(R" style sets).
.Sp
\&\fB\s-1BEWARE\s0\fR that the conversion to decimal numbers is inherently slow;
it can easily take up several seconds for a single large bit vector!
.Sp
Therefore you should store the decimal strings returned to you
rather than converting a given bit vector again.
.Sp
\&\fB\s-1EXAMPLES:\s0\fR
.Sp
The default setting as returned by the method "\f(CW\*(C`Configuration()\*(C'\fR"
is:
.Sp
.Vb 3
\&        Scalar Input       = Bit Index
\&        Operator Semantics = Set Operators
\&        String Output      = Hexadecimal
.Ve
.Sp
Performing a statement such as:
.Sp
.Vb 2
\&  Bit::Vector\->Configuration("in=bin,ops=arithmetic,out=bin");
\&  print Bit::Vector\->Configuration(), "\en";
.Ve
.Sp
yields the following output:
.Sp
.Vb 3
\&        Scalar Input       = Binary
\&        Operator Semantics = Arithmetic Operators
\&        String Output      = Binary
.Ve
.Sp
Note that you can always feed this output back into the "\f(CW\*(C`Configuration()\*(C'\fR"
method to restore that setting later.
.Sp
This also means that you can enter the same given setting with almost any
degree of verbosity you like (as long as the required keywords appear and
no ambiguities arise).
.Sp
Note further that any aspect you do not specify is not changed, i.e.,
the statement
.Sp
.Vb 1
\&  Bit::Vector\->Configuration("operators = arithmetic");
.Ve
.Sp
leaves all other aspects unchanged.
.IP "\(bu" 2
\&\f(CW"$vector"\fR
.Sp
Remember that variables enclosed in double quotes are always
interpolated in Perl.
.Sp
Whenever a Perl variable containing the reference of a \*(L"Bit::Vector\*(R"
object is enclosed in double quotes (either alone or together with
other text and/or variables), the contents of the corresponding
bit vector are converted into a printable string.
.Sp
Since there are several conversion methods available in this module
(see the description of the methods "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR"), it is of course desirable to
be able to choose which of these methods should be applied in this
case.
.Sp
This can actually be done by changing the configuration of this
module using the method "\f(CW\*(C`Configure()\*(C'\fR" (see the previous chapter,
immediately above).
.Sp
The default is conversion to hexadecimal.
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector)\*(C'\fR
.Sp
It is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression.
.Sp
The condition above is true if the corresponding bit vector contains
at least one set bit, and it is false if \fB\s-1ALL\s0\fR bits of the corresponding
bit vector are cleared.
.IP "\(bu" 2
\&\f(CW\*(C`if (!$vector)\*(C'\fR
.Sp
Since it is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression, you can of course also negate
this boolean expression.
.Sp
The condition above is true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector
are cleared, and it is false if the corresponding bit vector contains at
least one set bit.
.Sp
Note that this is \fB\s-1NOT\s0\fR the same as using the method "\f(CW\*(C`is_full()\*(C'\fR",
which returns true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector are
\&\fB\s-1SET\s0\fR.
.IP "\(bu" 2
\&\f(CW\*(C`~$vector\*(C'\fR
.Sp
This term returns a new bit vector object which is the one's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits.
.IP "\(bu" 2
\&\f(CW\*(C`\-$vector\*(C'\fR (unary minus)
.Sp
This term returns a new bit vector object which is the two's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits and incrementing the result by one.
.Sp
(This is the same as changing the sign of a number in two's complement
binary representation.)
.IP "\(bu" 2
\&\f(CW\*(C`abs($vector)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
the number of set bits in the given bit vector (this is the same
as calculating the number of elements which are contained in the
given set) \- which is the default behaviour, or it returns a new
bit vector object which contains the absolute value of the number
stored in the given bit vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 . $vector2\*(C'\fR
.Sp
This term usually returns a new bit vector object which is the
result of the concatenation of the two bit vector operands.
.Sp
The left operand becomes the most significant, and the right operand
becomes the least significant part of the new bit vector object.
.Sp
If one of the two operands is not a bit vector object but a Perl scalar,
however, the contents of the remaining bit vector operand are converted
into a string (the format of which depends on the configuration set with
the "\f(CW\*(C`Configuration()\*(C'\fR" method), which is then concatenated in the proper
order (i.e., as indicated by the order of the two operands) with the Perl
scalar.
.Sp
In other words, a string is returned in such a case instead of a
bit vector object!
.IP "\(bu" 2
\&\f(CW\*(C`$vector x $factor\*(C'\fR
.Sp
This term returns a new bit vector object which is the concatenation
of as many copies of the given bit vector operand (the left operand)
as the factor (the right operand) specifies.
.Sp
If the factor is zero, a bit vector object with a length of zero bits
is returned.
.Sp
If the factor is one, just a new copy of the given bit vector is
returned.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector << $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted left (towards the
most significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector >> $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted right (towards the
least significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 | $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1OR\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 & $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1AND\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^ $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1XOR\s0 (exclusive-or) operation between the two bit vector
operands.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 + $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1OR\s0 operation
between the two bit vector operands (this is the same as calculating
the union of two sets) \- which is the default behaviour, or it returns
a new bit vector object which contains the sum of the two numbers
stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \- $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the set difference of the two sets
represented in the two bit vector operands \- which is the default
behaviour, or it returns a new bit vector object which contains
the difference of the two numbers stored in the two bit vector
operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 * $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1AND\s0 operation
between the two bit vector operands (this is the same as calculating
the intersection of two sets) \- which is the default behaviour, or it
returns a new bit vector object which contains the product of the two
numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 / $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 % $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the remainder of
the division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ** $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
exponentiation of the left bit vector elevated to the right bit vector's
power.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 .= $vector2;\*(C'\fR
.Sp
This statement \*(L"appends\*(R" the right bit vector operand (the \*(L"rvalue\*(R")
to the left one (the \*(L"lvalue\*(R").
.Sp
The former contents of the left operand become the most significant
part of the resulting bit vector, and the right operand becomes the
least significant part.
.Sp
Since bit vectors are stored in \*(L"least order bit first\*(R" order, this
actually requires the left operand to be shifted \*(L"up\*(R" by the length
of the right operand, which is then copied to the now freed least
significant part of the left operand.
.Sp
If the right operand is a Perl scalar, it is first converted to a
bit vector of the same size as the left operand, provided that the
configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.IP "\(bu" 2
\&\f(CW\*(C`$vector x= $factor;\*(C'\fR
.Sp
This statement replaces the given bit vector by a concatenation of as many
copies of the original contents of the given bit vector as the factor (the
right operand) specifies.
.Sp
If the factor is zero, the given bit vector is resized to a length of zero
bits.
.Sp
If the factor is one, the given bit vector is not changed at all.
.IP "\(bu" 2
\&\f(CW\*(C`$vector <<= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector left by "\f(CW$bits\fR"
positions (towards the most significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector >>= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector right by "\f(CW$bits\fR"
positions (towards the least significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 |= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1OR\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 &= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1AND\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1XOR\s0 (exclusive-or) operation
between the two bit vector operands and stores the result in the
left operand.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 += $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1OR\s0 operation between the two bit vector operands (this is
the same as calculating the union of two sets) \- which is the default
behaviour, or it calculates the sum of the two numbers stored in the
two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \-= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either calculates
the set difference of the two sets represented in the two bit vector
operands \- which is the default behaviour, or it calculates the
difference of the two numbers stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 *= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1AND\s0 operation between the two bit vector operands (this is
the same as calculating the intersection of two sets) \- which is the
default behaviour, or it calculates the product of the two numbers
stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 /= $vector2;\*(C'\fR
.Sp
This statement puts the result of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 %= $vector2;\*(C'\fR
.Sp
This statement puts the remainder of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 **= $vector2;\*(C'\fR
.Sp
This statement puts the result of the exponentiation of the left
operand elevated to the right operand's power into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`++$vector\*(C'\fR, \f(CW\*(C`$vector++\*(C'\fR
.Sp
This operator performs pre\- and post-incrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the incrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`\-\-$vector\*(C'\fR, \f(CW\*(C`$vector\-\-\*(C'\fR
.Sp
This operator performs pre\- and post-decrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the decrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 cmp $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 eq $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ne $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 lt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 le $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 gt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ge $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <=> $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 == $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 != $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 < $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true subset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a subset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 > $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true superset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 >= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a superset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::String\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::Overload\*(R" version 7.2.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 \- 2012 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::Overload5.18.3pm                0100644 0001750 0001750 00000152355 12566241526 025576  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::Overload 3"
.TH Bit::Vector::Overload 3 "2013-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::Overload \- Overloaded operators add\-on for Bit::Vector
.SH "USAGE"
.IX Header "USAGE"
Note that you do not need to "\f(CW\*(C`use Bit::Vector;\*(C'\fR"
in addition to this module.
.PP
Simply "\f(CW\*(C`use Bit::Vector::Overload;\*(C'\fR" \fB\s-1INSTEAD\s0\fR
of "\f(CW\*(C`use Bit::Vector;\*(C'\fR\*(L". You can still use all the
methods from the \*(R"Bit::Vector" module in addition
to the overloaded operators and methods provided
here after that.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\&  Configuration
\&      $config = Bit::Vector\->Configuration();
\&      Bit::Vector\->Configuration($config);
\&      $oldconfig = Bit::Vector\->Configuration($newconfig);
\&
\&  String Conversion
\&      $string = "$vector";             #  depending on configuration
\&      print "\e$vector = \*(Aq$vector\*(Aq\en";
\&
\&  Emptyness
\&      if ($vector)  #  if not empty (non\-zero)
\&      if (! $vector)  #  if empty (zero)
\&      unless ($vector)  #  if empty (zero)
\&
\&  Complement (one\*(Aqs complement)
\&      $vector2 = ~$vector1;
\&      $vector = ~$vector;
\&
\&  Negation (two\*(Aqs complement)
\&      $vector2 = \-$vector1;
\&      $vector = \-$vector;
\&
\&  Norm
\&      $norm = abs($vector);  #  depending on configuration
\&
\&  Absolute
\&      $vector2 = abs($vector1);  #  depending on configuration
\&
\&  Concatenation
\&      $vector3 = $vector1 . $vector2;
\&      $vector1 .= $vector2;
\&      $vector1 = $vector2 . $vector1;
\&      $vector2 = $vector1 . $scalar;  #  depending on configuration
\&      $vector2 = $scalar . $vector1;
\&      $vector .= $scalar;
\&
\&  Duplication
\&      $vector2 = $vector1 x $factor;
\&      $vector x= $factor;
\&
\&  Shift Left
\&      $vector2 = $vector1 << $bits;
\&      $vector <<= $bits;
\&
\&  Shift Right
\&      $vector2 = $vector1 >> $bits;
\&      $vector >>= $bits;
\&
\&  Union
\&      $vector3 = $vector1 | $vector2;
\&      $vector1 |= $vector2;
\&      $vector2 = $vector1 | $scalar;
\&      $vector |= $scalar;
\&
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Intersection
\&      $vector3 = $vector1 & $vector2;
\&      $vector1 &= $vector2;
\&      $vector2 = $vector1 & $scalar;
\&      $vector &= $scalar;
\&
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  ExclusiveOr
\&      $vector3 = $vector1 ^ $vector2;
\&      $vector1 ^= $vector2;
\&      $vector2 = $vector1 ^ $scalar;
\&      $vector ^= $scalar;
\&
\&  Set Difference
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Addition
\&      $vector3 = $vector1 + $vector2;  #  depending on configuration
\&      $vector1 += $vector2;
\&      $vector2 = $vector1 + $scalar;
\&      $vector += $scalar;
\&
\&  Subtraction
\&      $vector3 = $vector1 \- $vector2;  #  depending on configuration
\&      $vector1 \-= $vector2;
\&      $vector1 = $vector2 \- $vector1;
\&      $vector2 = $vector1 \- $scalar;
\&      $vector2 = $scalar \- $vector1;
\&      $vector \-= $scalar;
\&
\&  Multiplication
\&      $vector3 = $vector1 * $vector2;  #  depending on configuration
\&      $vector1 *= $vector2;
\&      $vector2 = $vector1 * $scalar;
\&      $vector *= $scalar;
\&
\&  Division
\&      $vector3 = $vector1 / $vector2;
\&      $vector1 /= $vector2;
\&      $vector1 = $vector2 / $vector1;
\&      $vector2 = $vector1 / $scalar;
\&      $vector2 = $scalar / $vector1;
\&      $vector /= $scalar;
\&
\&  Modulo
\&      $vector3 = $vector1 % $vector2;
\&      $vector1 %= $vector2;
\&      $vector1 = $vector2 % $vector1;
\&      $vector2 = $vector1 % $scalar;
\&      $vector2 = $scalar % $vector1;
\&      $vector %= $scalar;
\&
\&  Exponentiation
\&      $vector3 = $vector1 ** $vector2;
\&      $vector1 **= $vector2;
\&      $vector2 = $vector1 ** $scalar;
\&      $vector2 = $scalar ** $vector1;
\&      $vector **= $scalar;
\&
\&  Increment
\&      ++$vector;
\&      $vector++;
\&
\&  Decrement
\&      \-\-$vector;
\&      $vector\-\-;
\&
\&  Lexical Comparison (unsigned)
\&      $cmp = $vector1 cmp $vector2;
\&      if ($vector1 lt $vector2)
\&      if ($vector1 le $vector2)
\&      if ($vector1 gt $vector2)
\&      if ($vector1 ge $vector2)
\&
\&      $cmp = $vector cmp $scalar;
\&      if ($vector lt $scalar)
\&      if ($vector le $scalar)
\&      if ($vector gt $scalar)
\&      if ($vector ge $scalar)
\&
\&  Comparison (signed)
\&      $cmp = $vector1 <=> $vector2;
\&      if ($vector1 < $vector2)  #  depending on configuration
\&      if ($vector1 <= $vector2)
\&      if ($vector1 > $vector2)
\&      if ($vector1 >= $vector2)
\&
\&      $cmp = $vector <=> $scalar;
\&      if ($vector < $scalar)  #  depending on configuration
\&      if ($vector <= $scalar)
\&      if ($vector > $scalar)
\&      if ($vector >= $scalar)
\&
\&  Equality
\&      if ($vector1 eq $vector2)
\&      if ($vector1 ne $vector2)
\&      if ($vector eq $scalar)
\&      if ($vector ne $scalar)
\&
\&      if ($vector1 == $vector2)
\&      if ($vector1 != $vector2)
\&      if ($vector == $scalar)
\&      if ($vector != $scalar)
\&
\&  Subset Relationship
\&      if ($vector1 <= $vector2)  #  depending on configuration
\&
\&  True Subset Relationship
\&      if ($vector1 < $vector2)  #  depending on configuration
\&
\&  Superset Relationship
\&      if ($vector1 >= $vector2)  #  depending on configuration
\&
\&  True Superset Relationship
\&      if ($vector1 > $vector2)  #  depending on configuration
.Ve
.SH "IMPORTANT NOTES"
.IX Header "IMPORTANT NOTES"
.IP "\(bu" 2
Boolean values
.Sp
Boolean values in this module are always a numeric zero ("\f(CW0\fR\*(L") for
\&\*(R"false\*(L" and a numeric one (\*(R"\f(CW1\fR\*(L") for \*(R"true".
.IP "\(bu" 2
Negative numbers
.Sp
Numeric factors (as needed for the "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`x\*(C'\fR" operators) and bit numbers are always regarded as being
\&\fB\s-1UNSIGNED\s0\fR.
.Sp
As a consequence, whenever you pass a negative number for such a factor
or bit number, it will be treated as a (usually very large) positive
number due to its internal two's complement binary representation, usually
resulting in malfunctions or an \*(L"index out of range\*(R" error message and
program abortion.
.Sp
Note that this does not apply to \*(L"big integer\*(R" decimal numbers, which
are (usually) passed as strings, and which may of course be negative
(see also the section \*(L"Big integers\*(R" a little further below).
.IP "\(bu" 2
Overloaded operators configuration
.Sp
Note that the behaviour of certain overloaded operators can be changed
in various ways by means of the "\f(CW\*(C`Configuration()\*(C'\fR" method (for more
details, see the description of this method further below).
.Sp
For instance, scalars (i.e., numbers and strings) provided as operands
to overloaded operators are automatically converted to bit vectors,
internally.
.Sp
These scalars are thereby automatically assumed to be indices or to be
in hexadecimal, binary, decimal or enumeration format, depending on the
configuration.
.Sp
Similarly, when converting bit vectors to strings using double quotes
(""), the output format will also depend on the previously chosen
configuration.
.Sp
Finally, some overloaded operators may have different semantics depending
on the proper configuration; for instance, the operator \*(L"+\*(R" can be the
\&\*(L"union\*(R" operator from set theory or the arithmetic \*(L"add\*(R" operator.
.Sp
In all cases (input, output and operator semantics), the defaults have
been chosen in such a way so that the behaviour of the module is backward
compatible with previous versions.
.IP "\(bu" 2
\&\*(L"Big integers\*(R"
.Sp
As long as \*(L"big integers\*(R" (for \*(L"big integer\*(R" arithmetic) are small enough
so that Perl doesn't need scientific notation (exponents) to be able to
represent them internally, you can provide these \*(L"big integer\*(R" constants
to the overloaded operators of this module (or to the method "\f(CW\*(C`from_Dec()\*(C'\fR")
in numeric form (i.e., either as a numeric constant or expression or as a
Perl variable containing a numeric value).
.Sp
Note that you will get an error message (resulting in program abortion)
if your \*(L"big integer\*(R" numbers exceed that limit.
.Sp
Because this limit is machine-dependent and not obvious to find out,
it is strongly recommended that you enclose \fB\s-1ALL\s0\fR your \*(L"big integer\*(R"
constants in your programs in (double or single) quotes.
.Sp
Examples:
.Sp
.Vb 1
\&    $vector /= 10;  #  ok because number is small
\&
\&    $vector /= \-10;  #  ok for same reason
\&
\&    $vector /= "10";  #  always correct
\&
\&    $vector += "1152921504606846976";  #  quotes probably required here
.Ve
.Sp
All examples assume
.Sp
.Vb 1
\&    Bit::Vector\->Configuration("input=decimal");
.Ve
.Sp
having been set beforehand.
.Sp
Note also that this module does not support scientific notation (exponents)
for \*(L"big integer\*(R" decimal numbers because you can always make the bit vector
large enough for the whole number to fit without loss of precision (as it
would occur if scientific notation were used).
.Sp
Finally, note that the only characters allowed in \*(L"big integer\*(R" constant
strings are the digits \f(CW0..9\fR and an optional leading sign ("\f(CW\*(C`+\*(C'\fR\*(L" or \*(R"\f(CW\*(C`\-\*(C'\fR").
.Sp
All other characters produce a syntax error.
.IP "\(bu" 2
Valid operands for overloaded operators
.Sp
All overloaded operators expect at least one bit vector operand,
in order for the operator to \*(L"know\*(R" that not the usual operation
is to be carried out, but rather the overloaded variant.
.Sp
This is especially true for all unary operators:
.Sp
.Vb 10
\&                    "$vector"
\&                    if ($vector)
\&                    if (!$vector)
\&                    ~$vector
\&                    \-$vector
\&                    abs($vector)
\&                    ++$vector
\&                    $vector++
\&                    \-\-$vector
\&                    $vector\-\-
.Ve
.Sp
For obvious reasons the left operand (the \*(L"lvalue\*(R") of all
assignment operators is also required to be a bit vector:
.Sp
.Vb 10
\&                        .=
\&                        x=
\&                        <<=
\&                        >>=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
In the case of three special operators, namely "\f(CW\*(C`<<\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x\*(C'\fR\*(L", as well as their related assignment
variants, \*(R"\f(CW\*(C`<<=\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>=\*(C'\fR\*(L" and \*(R"\f(CW\*(C`x=\*(C'\fR", the
left operand is \fB\s-1ALWAYS\s0\fR a bit vector and the right operand is
\&\fB\s-1ALWAYS\s0\fR a number (which is the factor indicating how many times
the operator is to be applied).
.Sp
In all truly binary operators, i.e.,
.Sp
.Vb 10
\&                        .
\&                        |
\&                        &
\&                        ^
\&                        +
\&                        \-
\&                        *
\&                        /
\&                        %
\&                       **
\&                    <=>   cmp
\&                     ==    eq
\&                     !=    ne
\&                     <     lt
\&                     <=    le
\&                     >     gt
\&                     >=    ge
.Ve
.Sp
one of either operands may be replaced by a Perl scalar, i.e.,
a number or a string, either as a Perl constant, a Perl expression
or a Perl variable yielding a number or a string.
.Sp
The same applies to the right side operand (the \*(L"rvalue\*(R") of the
remaining assignment operators, i.e.,
.Sp
.Vb 10
\&                        .=
\&                        |=
\&                        &=
\&                        ^=
\&                        +=
\&                        \-=
\&                        *=
\&                        /=
\&                        %=
\&                       **=
.Ve
.Sp
Note that this Perl scalar should be of the correct type, i.e.,
numeric or string, for the chosen configuration, because otherwise
a warning message will occur if your program runs under the "\f(CW\*(C`\-w\*(C'\fR"
switch of Perl.
.Sp
The acceptable scalar types for each possible configuration are
the following:
.Sp
.Vb 6
\&    input = bit indices    (default)  :    numeric
\&    input = hexadecimal               :    string
\&    input = binary                    :    string
\&    input = decimal                   :    string     (in general)
\&    input = decimal                   :    numeric    (if small enough)
\&    input = enumeration               :    string
.Ve
.Sp
\&\s-1NOTE ALSO THAT THESE SCALAR OPERANDS ARE CONVERTED TO BIT VECTORS OF
THE SAME SIZE AS THE BIT VECTOR WHICH IS THE OTHER OPERAND.\s0
.Sp
The only exception from this rule is the concatenation operator
("\f(CW\*(C`.\*(C'\fR\*(L") and its assignment variant (\*(R"\f(CW\*(C`.=\*(C'\fR"):
.Sp
If one of the two operands of the concatenation operator ("\f(CW\*(C`.\*(C'\fR\*(L") is
not a bit vector object but a Perl scalar, the contents of the remaining
bit vector operand are converted into a string (the format of which
depends on the configuration set with the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method),
which is then concatenated in the proper order (i.e., as indicated by the
order of the two operands) with the Perl scalar (in other words, a string
is returned in such a case instead of a bit vector object!).
.Sp
If the right side operand (the \*(L"rvalue\*(R") of the assignment variant
("\f(CW\*(C`.=\*(C'\fR") of the concatenation operator is a Perl scalar, it is converted
internally to a bit vector of the same size as the left side operand provided
that the configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.Sp
If a decimal number (\*(L"big integer\*(R") is too large to be stored in a
bit vector of the given size, a \*(L"numeric overflow error\*(R" occurs.
.Sp
If a bit index is out of range for the given bit vector, an \*(L"index
out of range\*(R" error occurs.
.Sp
If a scalar operand cannot be converted successfully due to invalid
syntax, a fatal \*(L"input string syntax error\*(R" is issued.
.Sp
If the two operands of the operator "\f(CW\*(C`<<\*(C'\fR\*(L", \*(R"\f(CW\*(C`>>\*(C'\fR\*(L"
or \*(R"\f(CW\*(C`x\*(C'\fR\*(L" are reversed, a fatal \*(R"reversed operands error" occurs.
.Sp
If an operand is neither a bit vector nor a scalar, then a fatal
\&\*(L"illegal operand type error\*(R" occurs.
.IP "\(bu" 2
Bit order
.Sp
Note that bit vectors are stored least order bit and least order word first
internally.
.Sp
I.e., bit #0 of any given bit vector corresponds to bit #0 of word #0 in the
array of machine words representing the bit vector.
.Sp
(Where word #0 comes first in memory, i.e., it is stored at the least memory
address in the allocated block of memory holding the given bit vector.)
.Sp
Note however that machine words can be stored least order byte first or last,
depending on your system's implementation.
.Sp
Note further that whenever bit vectors are converted to and from (binary or
hexadecimal) strings, the \fB\s-1RIGHTMOST\s0\fR bit is always the \fB\s-1LEAST SIGNIFICANT\s0\fR
one, and the \fB\s-1LEFTMOST\s0\fR bit is always the \fB\s-1MOST SIGNIFICANT\s0\fR bit.
.Sp
This is because in our western culture, numbers are always represented in this
way (least significant to most significant digits go from right to left).
.Sp
Of course this requires an internal reversion of order, which the corresponding
conversion methods perform automatically (without any additional overhead, it's
just a matter of starting the internal loop at the bottom or the top end).
.IP "\(bu" 2
Matching sizes
.Sp
In general, for methods involving several bit vectors at the same time, all
bit vector arguments must have identical sizes (number of bits), or a fatal
\&\*(L"size mismatch\*(R" error will occur.
.Sp
Exceptions from this rule are the methods "\f(CW\*(C`Concat()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Concat_List()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`Copy()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Interval_Copy()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Interval_Substitute()\*(C'\fR", where no
conditions at all are imposed on the size of their bit vector arguments.
.Sp
In method "\f(CW\*(C`Multiply()\*(C'\fR", all three bit vector arguments must in principle
obey the rule of matching sizes, but the bit vector in which the result of
the multiplication is to be stored may be larger than the two bit vector
arguments containing the factors for the multiplication.
.Sp
In method "\f(CW\*(C`Power()\*(C'\fR", the bit vector for the result must be the same
size or greater than the base of the exponentiation term. The exponent
can be any size.
.Sp
The same applies to the corresponding overloaded operators.
.IP "\(bu" 2
Index ranges
.Sp
All indices for any given bits must lie between "\f(CW0\fR\*(L" and
\&\*(R"\f(CW\*(C`$vector\->Size()\-1\*(C'\fR\*(L", or a fatal \*(R"index out of range"
error will occur.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$config = Bit::Vector\->Configuration();\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`Bit::Vector\->Configuration($config);\*(C'\fR
.IP "\(bu" 2
\&\f(CW\*(C`$oldconfig = Bit::Vector\->Configuration($newconfig);\*(C'\fR
.Sp
This method serves to alter the semantics (i.e., behaviour) of certain
overloaded operators (which are all implemented in Perl, by the way).
.Sp
It does not have any effect whatsoever on anything else. In particular,
it does not affect the methods implemented in C.
.Sp
The method accepts an (optional) string as input in which certain keywords
are expected, which influence some or almost all of the overloaded operators
in several possible ways.
.Sp
The method always returns a string (which you do not need to take care of,
i.e., to store, in case you aren't interested in keeping it) which is a
complete representation of the current configuration (i.e., \fB\s-1BEFORE\s0\fR
any modifications are applied) and which can be fed back to this method
later in order to restore the previous configuration.
.Sp
There are three aspects of the way certain overloaded operators behave which
can be controlled with this method:
.Sp
.Vb 4
\&  +  the way scalar operands (replacing one of the two
\&     bit vector object operands) are automatically
\&     converted internally into a bit vector object of
\&     their own,
\&
\&  +  the operation certain overloaded operators perform,
\&     i.e., an operation with sets or an arithmetic
\&     operation,
\&
\&  +  the format to which bit vectors are converted
\&     automatically when they are enclosed in double
\&     quotes.
.Ve
.Sp
The input string may contain any number of assignments, each of which
controls one of these three aspects.
.Sp
Each assignment has the form "\f(CW\*(C`<which>=<value>\*(C'\fR".
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`<value>\*(C'\fR" thereby consist of letters
(\f(CW\*(C`[a\-zA\-Z]\*(C'\fR) and white space.
.Sp
Multiple assignments have to be separated by one or more comma (\*(L",\*(R"),
semi-colon (\*(L";\*(R"), colon (\*(L":\*(R"), vertical bar (\*(L"|\*(R"), slash (\*(L"/\*(R"),
newline (\*(L"\en\*(R"), ampersand (\*(L"&\*(R"), plus (\*(L"+\*(R") or dash (\*(L"\-\*(R").
.Sp
Empty lines or statements (only white space) are allowed but will be
ignored.
.Sp
"\f(CW\*(C`<which>\*(C'\fR\*(L" has to contain one or more keywords from one of
three groups, each group representing one of the three aspects that
the \*(R"\f(CW\*(C`Configuration()\*(C'\fR" method controls:
.Sp
.Vb 1
\&  +  "^scalar", "^input", "^in$"
\&
\&  +  "^operator", "^semantic", "^ops$"
\&
\&  +  "^string", "^output", "^out$"
.Ve
.Sp
The character \*(L"^\*(R" thereby denotes the beginning of a word, and \*(L"$\*(R"
denotes the end. Case is ignored (!).
.Sp
Using these keywords, you can build any phrase you like to select one
of the three aspects (see also examples given below).
.Sp
The only condition is that no other keyword from any of the other two
groups may match \- otherwise a syntax error will occur (i.e., ambiguities
are forbidden). A syntax error also occurs if none of the keywords
matches.
.Sp
This same principle applies to "\f(CW\*(C`<value>\*(C'\fR":
.Sp
Depending on which aspect you specified for "\f(CW\*(C`<which>\*(C'\fR",
there are different groups of keywords that determine the value
the selected aspect will be set to:
.Sp
.Vb 1
\&  +  "<which>" = "^scalar", "^input", "^in$":
\&
\&       "<value>" =
\&
\&       *  "^bit$", "^index", "^indice"
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
\&
\&  +  "<which>" = "^operator", "^semantic", "^ops$":
\&
\&       "<value>" =
\&
\&       *  "^set$"
\&       *  "^arithmetic"
\&
\&  +  "<which>" = "^string", "^output", "^out$":
\&
\&       "<value>" =
\&
\&       *  "^hex"
\&       *  "^bin"
\&       *  "^dec"
\&       *  "^enum"
.Ve
.Sp
Examples:
.Sp
.Vb 1
\&  "Any scalar input I provide should be considered to be = a bit index"
\&
\&  "I want to have operator semantics suitable for = arithmetics"
\&
\&  "Any bit vector in double quotes is to be output as = an enumeration"
.Ve
.Sp
\&\fB\s-1SCALAR INPUT:\s0\fR
.Sp
In the case of scalar input, "\f(CW\*(C`^bit$\*(C'\fR\*(L", \*(R"\f(CW\*(C`^index\*(C'\fR\*(L", or \*(R"\f(CW\*(C`^indice\*(C'\fR\*(L"
all cause scalar input to be considered to represent a bit index, i.e.,
\&\*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #5 in the given bit vector (this is
essentially the same as \*(R"\f(CW\*(C`$vector\->bit_flip(5);\*(C'\fR").
.Sp
Note that \*(L"bit indices\*(R" is the default setting for \*(L"scalar input\*(R".
.Sp
The keyword "\f(CW\*(C`^hex\*(C'\fR\*(L" will cause scalar input to be considered as being in
hexadecimal, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2 (because
hexadecimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that hexadecimal input should always be enclosed in quotes,
otherwise it will be interpreted as a decimal number by Perl! The example
relies on the fact that hexadecimal \f(CW\*(C`0\-9\*(C'\fR and decimal \f(CW\*(C`0\-9\*(C'\fR are the same.)
.Sp
The keyword "\f(CW\*(C`^bin\*(C'\fR\*(L" will cause scalar input to be considered as being in
binary format. All characters except \*(R"\f(CW0\fR\*(L" and \*(R"\f(CW1\fR" are forbidden in
this case (i.e., produce a syntax error).
.Sp
"\f(CW\*(C`$vector ^= \*(Aq0101\*(Aq;\*(C'\fR", for instance, will flip bit #0 and bit #2.
.Sp
The keyword "\f(CW\*(C`^dec\*(C'\fR\*(L" causes scalar input to be considered as integers
in decimal format, i.e., \*(R"\f(CW\*(C`$vector ^= 5;\*(C'\fR\*(L" will flip bit #0 and bit #2
(because decimal \*(R"\f(CW5\fR\*(L" is binary \*(R"\f(CW0101\fR").
.Sp
(Note though that all decimal input should be enclosed in quotes, because
for large numbers, Perl will use scientific notation internally for
representing them, which produces a syntax error because scientific
notation is neither supported by this module nor needed.)
.Sp
Finally, the keyword "\f(CW\*(C`^enum\*(C'\fR\*(L" causes scalar input to be considered
as being a list (\*(R"enumeration\*(L") of indices and ranges of (contiguous)
indices, i.e., \*(R"\f(CW\*(C`$vector |= \*(Aq2,3,5,7\-13,17\-23\*(Aq;\*(C'\fR" will cause bits #2,
#3, #5, #7 through #13 and #17 through #23 to be set.
.Sp
\&\fB\s-1OPERATOR SEMANTICS:\s0\fR
.Sp
Several overloaded operators can have two distinct functions depending
on this setting.
.Sp
The affected operators are: "\f(CW\*(C`+\*(C'\fR\*(L", \*(R"\f(CW\*(C`\-\*(C'\fR\*(L", \*(R"\f(CW\*(C`*\*(C'\fR\*(L", \*(R"\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR".
.Sp
With the default setting, \*(L"set operations\*(R", these operators perform:
.Sp
.Vb 7
\&  +       set union                           ( set1  u   set2 )
\&  \-       set difference                      ( set1  \e   set2 )
\&  *       set intersection                    ( set1  n   set2 )
\&  <       true subset relationship            ( set1  <   set2 )
\&  <=      subset relationship                 ( set1  <=  set2 )
\&  >       true superset relationship          ( set1  >   set2 )
\&  >=      superset relationship               ( set1  >=  set2 )
.Ve
.Sp
With the alternative setting, \*(L"arithmetic operations\*(R", these operators
perform:
.Sp
.Vb 7
\&  +       addition                            ( num1  +   num2 )
\&  \-       subtraction                         ( num1  \-   num2 )
\&  *       multiplication                      ( num1  *   num2 )
\&  <       "less than" comparison              ( num1  <   num2 )
\&  <=      "less than or equal" comparison     ( num1  <=  num2 )
\&  >       "greater than" comparison           ( num1  >   num2 )
\&  >=      "greater than or equal" comparison  ( num1  >=  num2 )
.Ve
.Sp
Note that these latter comparison operators ("\f(CW\*(C`<\*(C'\fR\*(L", \*(R"\f(CW\*(C`<=\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`>\*(C'\fR\*(L" and \*(R"\f(CW\*(C`>=\*(C'\fR") regard their operands as being \fB\s-1SIGNED\s0\fR.
.Sp
To perform comparisons with \fB\s-1UNSIGNED\s0\fR operands, use the operators
"\f(CW\*(C`lt\*(C'\fR\*(L", \*(R"\f(CW\*(C`le\*(C'\fR\*(L", \*(R"\f(CW\*(C`gt\*(C'\fR\*(L" and \*(R"\f(CW\*(C`ge\*(C'\fR" instead (in contrast to the
operators above, these operators are \fB\s-1NOT\s0\fR affected by the
\&\*(L"operator semantics\*(R" setting).
.Sp
\&\fB\s-1STRING OUTPUT:\s0\fR
.Sp
There are four methods which convert the contents of a given bit vector
into a string: "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L"
(not counting \*(R"\f(CW\*(C`Block_Read()\*(C'\fR", since this method does not return a
human-readable string).
.Sp
(For conversion to octal, see the description of the method
"\f(CW\*(C`Chunk_List_Read()\*(C'\fR".)
.Sp
Therefore, there are four possible formats into which a bit vector can
be converted when it is enclosed in double quotes, for example:
.Sp
.Vb 2
\&  print "\e$vector = \*(Aq$vector\*(Aq\en";
\&  $string = "$vector";
.Ve
.Sp
Hence you can set \*(L"string output\*(R" to four different values: To \*(L"hex\*(R"
for hexadecimal format (which is the default), to \*(L"bin\*(R" for binary
format, to \*(L"dec\*(R" for conversion to decimal numbers and to \*(L"enum\*(R"
for conversion to enumerations (\*(L".newsrc\*(R" style sets).
.Sp
\&\fB\s-1BEWARE\s0\fR that the conversion to decimal numbers is inherently slow;
it can easily take up several seconds for a single large bit vector!
.Sp
Therefore you should store the decimal strings returned to you
rather than converting a given bit vector again.
.Sp
\&\fB\s-1EXAMPLES:\s0\fR
.Sp
The default setting as returned by the method "\f(CW\*(C`Configuration()\*(C'\fR"
is:
.Sp
.Vb 3
\&        Scalar Input       = Bit Index
\&        Operator Semantics = Set Operators
\&        String Output      = Hexadecimal
.Ve
.Sp
Performing a statement such as:
.Sp
.Vb 2
\&  Bit::Vector\->Configuration("in=bin,ops=arithmetic,out=bin");
\&  print Bit::Vector\->Configuration(), "\en";
.Ve
.Sp
yields the following output:
.Sp
.Vb 3
\&        Scalar Input       = Binary
\&        Operator Semantics = Arithmetic Operators
\&        String Output      = Binary
.Ve
.Sp
Note that you can always feed this output back into the "\f(CW\*(C`Configuration()\*(C'\fR"
method to restore that setting later.
.Sp
This also means that you can enter the same given setting with almost any
degree of verbosity you like (as long as the required keywords appear and
no ambiguities arise).
.Sp
Note further that any aspect you do not specify is not changed, i.e.,
the statement
.Sp
.Vb 1
\&  Bit::Vector\->Configuration("operators = arithmetic");
.Ve
.Sp
leaves all other aspects unchanged.
.IP "\(bu" 2
\&\f(CW"$vector"\fR
.Sp
Remember that variables enclosed in double quotes are always
interpolated in Perl.
.Sp
Whenever a Perl variable containing the reference of a \*(L"Bit::Vector\*(R"
object is enclosed in double quotes (either alone or together with
other text and/or variables), the contents of the corresponding
bit vector are converted into a printable string.
.Sp
Since there are several conversion methods available in this module
(see the description of the methods "\f(CW\*(C`to_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR"), it is of course desirable to
be able to choose which of these methods should be applied in this
case.
.Sp
This can actually be done by changing the configuration of this
module using the method "\f(CW\*(C`Configure()\*(C'\fR" (see the previous chapter,
immediately above).
.Sp
The default is conversion to hexadecimal.
.IP "\(bu" 2
\&\f(CW\*(C`if ($vector)\*(C'\fR
.Sp
It is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression.
.Sp
The condition above is true if the corresponding bit vector contains
at least one set bit, and it is false if \fB\s-1ALL\s0\fR bits of the corresponding
bit vector are cleared.
.IP "\(bu" 2
\&\f(CW\*(C`if (!$vector)\*(C'\fR
.Sp
Since it is possible to use a Perl variable containing the reference of a
\&\*(L"Bit::Vector\*(R" object as a boolean expression, you can of course also negate
this boolean expression.
.Sp
The condition above is true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector
are cleared, and it is false if the corresponding bit vector contains at
least one set bit.
.Sp
Note that this is \fB\s-1NOT\s0\fR the same as using the method "\f(CW\*(C`is_full()\*(C'\fR",
which returns true if \fB\s-1ALL\s0\fR bits of the corresponding bit vector are
\&\fB\s-1SET\s0\fR.
.IP "\(bu" 2
\&\f(CW\*(C`~$vector\*(C'\fR
.Sp
This term returns a new bit vector object which is the one's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits.
.IP "\(bu" 2
\&\f(CW\*(C`\-$vector\*(C'\fR (unary minus)
.Sp
This term returns a new bit vector object which is the two's complement
of the given bit vector.
.Sp
This is equivalent to inverting all bits and incrementing the result by one.
.Sp
(This is the same as changing the sign of a number in two's complement
binary representation.)
.IP "\(bu" 2
\&\f(CW\*(C`abs($vector)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
the number of set bits in the given bit vector (this is the same
as calculating the number of elements which are contained in the
given set) \- which is the default behaviour, or it returns a new
bit vector object which contains the absolute value of the number
stored in the given bit vector.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 . $vector2\*(C'\fR
.Sp
This term usually returns a new bit vector object which is the
result of the concatenation of the two bit vector operands.
.Sp
The left operand becomes the most significant, and the right operand
becomes the least significant part of the new bit vector object.
.Sp
If one of the two operands is not a bit vector object but a Perl scalar,
however, the contents of the remaining bit vector operand are converted
into a string (the format of which depends on the configuration set with
the "\f(CW\*(C`Configuration()\*(C'\fR" method), which is then concatenated in the proper
order (i.e., as indicated by the order of the two operands) with the Perl
scalar.
.Sp
In other words, a string is returned in such a case instead of a
bit vector object!
.IP "\(bu" 2
\&\f(CW\*(C`$vector x $factor\*(C'\fR
.Sp
This term returns a new bit vector object which is the concatenation
of as many copies of the given bit vector operand (the left operand)
as the factor (the right operand) specifies.
.Sp
If the factor is zero, a bit vector object with a length of zero bits
is returned.
.Sp
If the factor is one, just a new copy of the given bit vector is
returned.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector << $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted left (towards the
most significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector >> $bits\*(C'\fR
.Sp
This term returns a new bit vector object which is a copy of the given
bit vector (the left operand), which is then shifted right (towards the
least significant bit) by as many places as the right operand, "\f(CW$bits\fR",
specifies.
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
this term returns an empty bit vector (i.e., with all bits cleared) of
the same size as the given bit vector.
.Sp
Note that a fatal \*(L"reversed operands error\*(R" occurs if the two operands
are swapped.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 | $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1OR\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 & $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1AND\s0 operation between the two bit vector operands.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^ $vector2\*(C'\fR
.Sp
This term returns a new bit vector object which is the result of
a bitwise \s-1XOR \s0(exclusive-or) operation between the two bit vector
operands.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 + $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1OR\s0 operation
between the two bit vector operands (this is the same as calculating
the union of two sets) \- which is the default behaviour, or it returns
a new bit vector object which contains the sum of the two numbers
stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \- $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the set difference of the two sets
represented in the two bit vector operands \- which is the default
behaviour, or it returns a new bit vector object which contains
the difference of the two numbers stored in the two bit vector
operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 * $vector2\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this term either returns
a new bit vector object which is the result of a bitwise \s-1AND\s0 operation
between the two bit vector operands (this is the same as calculating
the intersection of two sets) \- which is the default behaviour, or it
returns a new bit vector object which contains the product of the two
numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 / $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 % $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the remainder of
the division of the two numbers stored in the two bit vector operands.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ** $vector2\*(C'\fR
.Sp
This term returns a new bit vector object containing the result of the
exponentiation of the left bit vector elevated to the right bit vector's
power.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 .= $vector2;\*(C'\fR
.Sp
This statement \*(L"appends\*(R" the right bit vector operand (the \*(L"rvalue\*(R")
to the left one (the \*(L"lvalue\*(R").
.Sp
The former contents of the left operand become the most significant
part of the resulting bit vector, and the right operand becomes the
least significant part.
.Sp
Since bit vectors are stored in \*(L"least order bit first\*(R" order, this
actually requires the left operand to be shifted \*(L"up\*(R" by the length
of the right operand, which is then copied to the now freed least
significant part of the left operand.
.Sp
If the right operand is a Perl scalar, it is first converted to a
bit vector of the same size as the left operand, provided that the
configuration states that scalars are to be regarded as indices,
decimal strings or enumerations.
.Sp
If the configuration states that scalars are to be regarded as hexadecimal
or boolean strings, however, these strings are converted to bit vectors of
a size matching the length of the input string, i.e., four times the length
for hexadecimal strings (because each hexadecimal digit is worth 4 bits) and
once the length for binary strings.
.IP "\(bu" 2
\&\f(CW\*(C`$vector x= $factor;\*(C'\fR
.Sp
This statement replaces the given bit vector by a concatenation of as many
copies of the original contents of the given bit vector as the factor (the
right operand) specifies.
.Sp
If the factor is zero, the given bit vector is resized to a length of zero
bits.
.Sp
If the factor is one, the given bit vector is not changed at all.
.IP "\(bu" 2
\&\f(CW\*(C`$vector <<= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector left by "\f(CW$bits\fR"
positions (towards the most significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" most significant bits are lost, all other
bits move up by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" least significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector >>= $bits;\*(C'\fR
.Sp
This statement moves the contents of the given bit vector right by "\f(CW$bits\fR"
positions (towards the least significant bit).
.Sp
This means that the "\f(CW$bits\fR\*(L" least significant bits are lost, all other
bits move down by \*(R"\f(CW$bits\fR\*(L" positions, and the \*(R"\f(CW$bits\fR" most significant
bits that have been left unoccupied by this shift are all set to zero.
.Sp
If "\f(CW$bits\fR" is greater than the number of bits of the given bit vector,
the given bit vector is erased completely (i.e., all bits are cleared).
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 |= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1OR\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the union of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 &= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1AND\s0 operation between the two
bit vector operands and stores the result in the left operand.
.Sp
This is the same as calculating the intersection of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 ^= $vector2;\*(C'\fR
.Sp
This statement performs a bitwise \s-1XOR \s0(exclusive-or) operation
between the two bit vector operands and stores the result in the
left operand.
.Sp
This is the same as calculating the symmetric difference of two sets.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 += $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1OR\s0 operation between the two bit vector operands (this is
the same as calculating the union of two sets) \- which is the default
behaviour, or it calculates the sum of the two numbers stored in the
two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 \-= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either calculates
the set difference of the two sets represented in the two bit vector
operands \- which is the default behaviour, or it calculates the
difference of the two numbers stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 *= $vector2;\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR" for more details), this statement either performs
a bitwise \s-1AND\s0 operation between the two bit vector operands (this is
the same as calculating the intersection of two sets) \- which is the
default behaviour, or it calculates the product of the two numbers
stored in the two bit vector operands.
.Sp
The result of this operation is stored in the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 /= $vector2;\*(C'\fR
.Sp
This statement puts the result of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 %= $vector2;\*(C'\fR
.Sp
This statement puts the remainder of the division of the two numbers
stored in the two bit vector operands into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`$vector1 **= $vector2;\*(C'\fR
.Sp
This statement puts the result of the exponentiation of the left
operand elevated to the right operand's power into the left operand.
.IP "\(bu" 2
\&\f(CW\*(C`++$vector\*(C'\fR, \f(CW\*(C`$vector++\*(C'\fR
.Sp
This operator performs pre\- and post-incrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the incrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`\-\-$vector\*(C'\fR, \f(CW\*(C`$vector\-\-\*(C'\fR
.Sp
This operator performs pre\- and post-decrementation of the
given bit vector.
.Sp
The value returned by this term is a reference of the given
bit vector object (after or before the decrementation,
respectively).
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 cmp $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 eq $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ne $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 lt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 le $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 gt $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR\*(L",
and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 ge $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L", and false (\*(R"\f(CW0\fR") otherwise.
.Sp
This comparison assumes \fB\s-1UNSIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <=> $vector2)\*(C'\fR
.Sp
This term returns "\f(CW\*(C`\-1\*(C'\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" is less than \*(R"\f(CW$vector2\fR\*(L",
\&\*(R"\f(CW0\fR\*(L" if \*(R"\f(CW$vector1\fR\*(L" and \*(R"\f(CW$vector2\fR\*(L" are the same, and \*(R"\f(CW1\fR\*(L"
if \*(R"\f(CW$vector1\fR\*(L" is greater than \*(R"\f(CW$vector2\fR".
.Sp
This comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 == $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the contents of the two bit vector
operands are the same and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 != $vector2)\*(C'\fR
.Sp
This term returns true ("\f(CW1\fR\*(L") if the two bit vector operands differ
and false (\*(R"\f(CW0\fR") otherwise.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 < $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true subset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 <= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a subset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is less than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 > $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a true superset of \*(R"\f(CW$vector2\fR\*(L"
(and false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour,
or it returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.IP "\(bu" 2
\&\f(CW\*(C`($vector1 >= $vector2)\*(C'\fR
.Sp
Depending on the configuration (see the description of the method
"\f(CW\*(C`Configuration()\*(C'\fR\*(L" for more details), this term either returns
true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is a superset of \*(R"\f(CW$vector2\fR\*(L" (and
false (\*(R"\f(CW0\fR\*(L") otherwise) \- which is the default behaviour, or it
returns true (\*(R"\f(CW1\fR\*(L") if \*(R"\f(CW$vector1\fR\*(L" is greater than or equal to
\&\*(R"\f(CW$vector2\fR\*(L" (and false (\*(R"\f(CW0\fR") otherwise).
.Sp
The latter comparison assumes \fB\s-1SIGNED\s0\fR bit vectors.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::String\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::Overload\*(R" version 7.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2000 \- 2013 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::String.3pm                      0100644 0001750 0001750 00000051327 12566241526 024752  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::String 3"
.TH Bit::Vector::String 3 "2013-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::String \- Generic string import/export for Bit::Vector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bit::Vector::String;
\&
\&  to_Oct
\&      $string = $vector\->to_Oct();
\&
\&  from_Oct
\&      $vector\->from_Oct($string);
\&
\&  new_Oct
\&      $vector = Bit::Vector\->new_Oct($bits,$string);
\&
\&  String_Export
\&      $string = $vector\->String_Export($type);
\&
\&  String_Import
\&      $type = $vector\->String_Import($string);
\&
\&  new_String
\&      $vector = Bit::Vector\->new_String($bits,$string);
\&      ($vector,$type) = Bit::Vector\->new_String($bits,$string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Oct();\*(C'\fR
.Sp
Returns an octal string representing the given bit vector.
.Sp
Note that this method is not particularly efficient, since it
is almost completely realized in Perl, and moreover internally
operates on a Perl list of individual octal digits which it
concatenates into the final string using "\f(CW\*(C`join(\*(Aq\*(Aq, ...)\*(C'\fR".
.Sp
A benchmark reveals that this method is about 40 times slower
than the method "\f(CW\*(C`to_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of to_Bin, to_Hex, to_Oct...
\&     to_Bin:  1 wallclock secs ( 1.09 usr +  0.00 sys =  1.09 CPU)
\&     to_Hex:  1 wallclock secs ( 0.53 usr +  0.00 sys =  0.53 CPU)
\&     to_Oct: 40 wallclock secs (40.16 usr +  0.05 sys = 40.21 CPU)
.Ve
.Sp
Note that since an octal digit is always worth three bits,
the length of the resulting string is always a multiple of
three bits, regardless of the true length (in bits) of the
given bit vector.
.Sp
Also note that the \fB\s-1LEAST\s0\fR significant octal digit is
located at the \fB\s-1RIGHT\s0\fR end of the resulting string, and
the \fB\s-1MOST\s0\fR significant digit at the \fB\s-1LEFT\s0\fR end.
.Sp
Finally, note that this method does \fB\s-1NOT\s0\fR prepend any uniquely
identifying format prefix (such as \*(L"0o\*(R") to the resulting string
(which means that the result of this method only contains valid
octal digits, i.e., [0\-7]).
.Sp
However, this can of course most easily be done as needed,
as follows:
.Sp
.Vb 1
\&  $string = \*(Aq0o\*(Aq . $vector\->to_Oct();
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Oct($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from an octal string,
such as returned by the method "\f(CW\*(C`to_Oct()\*(C'\fR" (see above).
.Sp
Note that this method is not particularly efficient, since it is
almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
Remember also that the least significant bits are always to the
right of an octal string, and the most significant bits to the left.
Therefore, the string is actually reversed internally before storing
it in the given bit vector using the method "\f(CW\*(C`Chunk_List_Store()\*(C'\fR",
which expects the least significant chunks of data at the beginning
of a list.
.Sp
A benchmark reveals that this method is about 40 times slower than
the method "\f(CW\*(C`from_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of from_Bin, from_Hex, from_Oct...
\&   from_Bin:  1 wallclock secs ( 1.13 usr +  0.00 sys =  1.13 CPU)
\&   from_Hex:  1 wallclock secs ( 0.80 usr +  0.00 sys =  0.80 CPU)
\&   from_Oct: 46 wallclock secs (44.95 usr +  0.00 sys = 44.95 CPU)
.Ve
.Sp
If the given string contains any character which is not an octal digit
(i.e., [0\-7]), a fatal syntax error ensues (\*(L"unknown string type\*(R").
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string; the
presence of such a prefix will also lead to the fatal \*(L"unknown
string type\*(R" error.
.Sp
If the given string contains less octal digits than are needed to
completely fill the given bit vector, the remaining (most significant)
bits all remain cleared (i.e., set to zero).
.Sp
This also means that, even if the given string does not contain
enough digits to completely fill the given bit vector, the previous
contents of the bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit
vector, the superfluous characters are simply ignored.
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Oct($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`from_Oct()\*(C'\fR"
(described above).
.Sp
Note that this approach is not particularly efficient, since it
is almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`from_Oct()\*(C'\fR" above for details).
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string and that
such a prefix will lead to a fatal \*(L"unknown string type\*(R" error.
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR",
the method will automatically allocate a bit vector with a size
(i.e., number of bits) of three times the length of the given string
(since every octal digit is worth three bits).
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->String_Export($type);\*(C'\fR
.Sp
Returns a string representing the given bit vector in the
format specified by "\f(CW$type\fR":
.Sp
.Vb 6
\&  1 | b | bin      =>  binary        (using "to_Bin()")
\&  2 | o | oct      =>  octal         (using "to_Oct()")
\&  3 | d | dec      =>  decimal       (using "to_Dec()")
\&  4 | h | hex | x  =>  hexadecimal   (using "to_Hex()")
\&  5 | e | enum     =>  enumeration   (using "to_Enum()")
\&  6 | p | pack     =>  packed binary (using "Block_Read()")
.Ve
.Sp
The case (lower/upper/mixed case) of "\f(CW$type\fR" is ignored.
.Sp
If "\f(CW$type\fR\*(L" is omitted or \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" or false (\*(R"0"
or the empty string), a hexadecimal string is returned
as the default format.
.Sp
If "\f(CW$type\fR\*(L" does not have any of the values described
above, a fatal \*(R"unknown string type" will occur.
.Sp
Beware that in order to guarantee that the strings can
be correctly parsed and read in by the methods
"\f(CW\*(C`String_Import()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_String()\*(C'\fR\*(L" (described
below), the method \*(R"\f(CW\*(C`String_Export()\*(C'\fR" provides
uniquely identifying prefixes (and, in one case,
a suffix) as follows:
.Sp
.Vb 7
\&  1 | b | bin      =>  \*(Aq0b\*(Aq . $vector\->to_Bin();
\&  2 | o | oct      =>  \*(Aq0o\*(Aq . $vector\->to_Oct();
\&  3 | d | dec      =>         $vector\->to_Dec(); # prefix is [+\-]
\&  4 | h | hex | x  =>  \*(Aq0x\*(Aq . $vector\->to_Hex();
\&  5 | e | enum     =>  \*(Aq{\*(Aq  . $vector\->to_Enum() . \*(Aq}\*(Aq;
\&  6 | p | pack     =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                       \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
This is necessary because certain strings can be valid
representations in more than one format.
.Sp
All strings in binary format, i.e., which only contain \*(L"0\*(R"
and \*(L"1\*(R", are also valid number representations (of a different
value, of course) in octal, decimal and hexadecimal.
.Sp
Likewise, a string in octal format is also valid in decimal
and hexadecimal, and a string in decimal format is also valid
in hexadecimal.
.Sp
Moreover, if the enumeration of set bits (as returned by
"\f(CW\*(C`to_Enum()\*(C'\fR") only contains one element, this element could
be mistaken for a representation of the entire bit vector
(instead of just one bit) in decimal.
.Sp
Beware also that the string returned by format \*(L"6\*(R" (\*(L"packed
binary\*(R") will in general \fB\s-1NOT BE PRINTABLE\s0\fR, because it will
usually consist of many unprintable characters!
.IP "\(bu" 2
\&\f(CW\*(C`$type = $vector\->String_Import($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from a string
which has previously been produced by "\f(CW\*(C`String_Export()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Block_Read()\*(C'\fR" or manually or by another
program.
.Sp
Beware however that the string must have the correct format;
otherwise a fatal \*(L"unknown string type\*(R" error will occur.
.Sp
The correct format is the one returned by "\f(CW\*(C`String_Export()\*(C'\fR"
(see immediately above).
.Sp
The method will also try to automatically recognize formats
without identifying prefix such as returned by the methods
"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR".
.Sp
However, as explained above for the method "\f(CW\*(C`String_Export()\*(C'\fR",
due to the fact that a string may be a valid representation in
more than one format, this may lead to unwanted results.
.Sp
The method will try to match the format of the given string
in the following order:
.Sp
If the string consists only of [01], it will be considered
to be in binary format (although it could be in octal, decimal
or hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-7], it will be considered
to be in octal format (although it could be in decimal or
hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-9], it will be considered
to be in decimal format (although it could be in hexadecimal
format or even be an enumeration with only one element as well).
.Sp
If the string consists only of [0\-9A\-Fa\-f], it will be considered
to be in hexadecimal format.
.Sp
If the string only contains numbers in decimal format, separated
by commas (\*(L",\*(R") or dashes (\*(L"\-\*(R"), it is considered to be an
enumeration (a single decimal number also qualifies).
.Sp
And if the string starts with \*(L":[0\-9]:\*(R", the remainder of the
string is read in with "\f(CW\*(C`Block_Store()\*(C'\fR".
.Sp
To avoid misinterpretations, it is therefore recommendable to
always either use the method "\f(CW\*(C`String_Export()\*(C'\fR" or to provide
some uniquely identifying prefix (and suffix, in one case)
yourself:
.Sp
.Vb 12
\&  binary         =>  \*(Aq0b\*(Aq . $string;
\&  octal          =>  \*(Aq0o\*(Aq . $string;
\&  decimal        =>  \*(Aq+\*(Aq  . $string; # in case "$string"
\&                 =>  \*(Aq\-\*(Aq  . $string; # has no sign yet
\&  hexadecimal    =>  \*(Aq0x\*(Aq . $string;
\&                 =>  \*(Aq0h\*(Aq . $string;
\&  enumeration    =>  \*(Aq{\*(Aq  . $string . \*(Aq}\*(Aq;
\&                 =>  \*(Aq[\*(Aq  . $string . \*(Aq]\*(Aq;
\&                 =>  \*(Aq<\*(Aq  . $string . \*(Aq>\*(Aq;
\&                 =>  \*(Aq(\*(Aq  . $string . \*(Aq)\*(Aq;
\&  packed binary  =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                     \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
Note that case (lower/upper/mixed case) is not important
and will be ignored by this method.
.Sp
Internally, the method uses the methods "\f(CW\*(C`from_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Enum()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Block_Store()\*(C'\fR" for actually
importing the contents of the string into the given
bit vector. See their descriptions here in this document
and in \fIBit::Vector\fR\|(3) for any further conditions that
must be met and corresponding possible fatal error messages.
.Sp
The method returns the number of the format that has been
recognized:
.Sp
.Vb 6
\&                1    =>    binary
\&                2    =>    octal
\&                3    =>    decimal
\&                4    =>    hexadecimal
\&                5    =>    enumeration
\&                6    =>    packed binary
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
\&\f(CW\*(C`($vector,$type) = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`String_Import()\*(C'\fR"
(described immediately above).
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`String_Import()\*(C'\fR" above for details).
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR", the
method will automatically determine this value for you and allocate
a bit vector of the calculated size.
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.Sp
The necessary number of bits is calculated as follows:
.Sp
.Vb 6
\&  binary         =>       length($string);
\&  octal          =>   3 * length($string);
\&  decimal        =>  int( length($string) * log(10) / log(2) + 1 );
\&  hexadecimal    =>   4 * length($string);
\&  enumeration    =>  maximum of values found in $string + 1
\&  packed binary  =>  $string =~ /^:(\ed+):/;
.Ve
.Sp
If called in scalar context, the method returns the newly created
bit vector object.
.Sp
If called in list context, the method additionally returns the
number of the format which has been recognized, as explained
above for the method "\f(CW\*(C`String_Import()\*(C'\fR".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::Overload\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::String\*(R" version 7.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 \- 2013 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::String5.16.3pm                  0100644 0001750 0001750 00000051067 12566241525 025264  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::String 3"
.TH Bit::Vector::String 3 "2012-05-17" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::String \- Generic string import/export for Bit::Vector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bit::Vector::String;
\&
\&  to_Oct
\&      $string = $vector\->to_Oct();
\&
\&  from_Oct
\&      $vector\->from_Oct($string);
\&
\&  new_Oct
\&      $vector = Bit::Vector\->new_Oct($bits,$string);
\&
\&  String_Export
\&      $string = $vector\->String_Export($type);
\&
\&  String_Import
\&      $type = $vector\->String_Import($string);
\&
\&  new_String
\&      $vector = Bit::Vector\->new_String($bits,$string);
\&      ($vector,$type) = Bit::Vector\->new_String($bits,$string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Oct();\*(C'\fR
.Sp
Returns an octal string representing the given bit vector.
.Sp
Note that this method is not particularly efficient, since it
is almost completely realized in Perl, and moreover internally
operates on a Perl list of individual octal digits which it
concatenates into the final string using "\f(CW\*(C`join(\*(Aq\*(Aq, ...)\*(C'\fR".
.Sp
A benchmark reveals that this method is about 40 times slower
than the method "\f(CW\*(C`to_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of to_Bin, to_Hex, to_Oct...
\&     to_Bin:  1 wallclock secs ( 1.09 usr +  0.00 sys =  1.09 CPU)
\&     to_Hex:  1 wallclock secs ( 0.53 usr +  0.00 sys =  0.53 CPU)
\&     to_Oct: 40 wallclock secs (40.16 usr +  0.05 sys = 40.21 CPU)
.Ve
.Sp
Note that since an octal digit is always worth three bits,
the length of the resulting string is always a multiple of
three bits, regardless of the true length (in bits) of the
given bit vector.
.Sp
Also note that the \fB\s-1LEAST\s0\fR significant octal digit is
located at the \fB\s-1RIGHT\s0\fR end of the resulting string, and
the \fB\s-1MOST\s0\fR significant digit at the \fB\s-1LEFT\s0\fR end.
.Sp
Finally, note that this method does \fB\s-1NOT\s0\fR prepend any uniquely
identifying format prefix (such as \*(L"0o\*(R") to the resulting string
(which means that the result of this method only contains valid
octal digits, i.e., [0\-7]).
.Sp
However, this can of course most easily be done as needed,
as follows:
.Sp
.Vb 1
\&  $string = \*(Aq0o\*(Aq . $vector\->to_Oct();
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Oct($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from an octal string,
such as returned by the method "\f(CW\*(C`to_Oct()\*(C'\fR" (see above).
.Sp
Note that this method is not particularly efficient, since it is
almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
Remember also that the least significant bits are always to the
right of an octal string, and the most significant bits to the left.
Therefore, the string is actually reversed internally before storing
it in the given bit vector using the method "\f(CW\*(C`Chunk_List_Store()\*(C'\fR",
which expects the least significant chunks of data at the beginning
of a list.
.Sp
A benchmark reveals that this method is about 40 times slower than
the method "\f(CW\*(C`from_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of from_Bin, from_Hex, from_Oct...
\&   from_Bin:  1 wallclock secs ( 1.13 usr +  0.00 sys =  1.13 CPU)
\&   from_Hex:  1 wallclock secs ( 0.80 usr +  0.00 sys =  0.80 CPU)
\&   from_Oct: 46 wallclock secs (44.95 usr +  0.00 sys = 44.95 CPU)
.Ve
.Sp
If the given string contains any character which is not an octal digit
(i.e., [0\-7]), a fatal syntax error ensues (\*(L"unknown string type\*(R").
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string; the
presence of such a prefix will also lead to the fatal \*(L"unknown
string type\*(R" error.
.Sp
If the given string contains less octal digits than are needed to
completely fill the given bit vector, the remaining (most significant)
bits all remain cleared (i.e., set to zero).
.Sp
This also means that, even if the given string does not contain
enough digits to completely fill the given bit vector, the previous
contents of the bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit
vector, the superfluous characters are simply ignored.
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Oct($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`from_Oct()\*(C'\fR"
(described above).
.Sp
Note that this approach is not particularly efficient, since it
is almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`from_Oct()\*(C'\fR" above for details).
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string and that
such a prefix will lead to a fatal \*(L"unknown string type\*(R" error.
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR",
the method will automatically allocate a bit vector with a size
(i.e., number of bits) of three times the length of the given string
(since every octal digit is worth three bits).
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->String_Export($type);\*(C'\fR
.Sp
Returns a string representing the given bit vector in the
format specified by "\f(CW$type\fR":
.Sp
.Vb 6
\&  1 | b | bin      =>  binary        (using "to_Bin()")
\&  2 | o | oct      =>  octal         (using "to_Oct()")
\&  3 | d | dec      =>  decimal       (using "to_Dec()")
\&  4 | h | hex | x  =>  hexadecimal   (using "to_Hex()")
\&  5 | e | enum     =>  enumeration   (using "to_Enum()")
\&  6 | p | pack     =>  packed binary (using "Block_Read()")
.Ve
.Sp
The case (lower/upper/mixed case) of "\f(CW$type\fR" is ignored.
.Sp
If "\f(CW$type\fR\*(L" is omitted or \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" or false (\*(R"0"
or the empty string), a hexadecimal string is returned
as the default format.
.Sp
If "\f(CW$type\fR\*(L" does not have any of the values described
above, a fatal \*(R"unknown string type" will occur.
.Sp
Beware that in order to guarantee that the strings can
be correctly parsed and read in by the methods
"\f(CW\*(C`String_Import()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_String()\*(C'\fR\*(L" (described
below), the method \*(R"\f(CW\*(C`String_Export()\*(C'\fR" provides
uniquely identifying prefixes (and, in one case,
a suffix) as follows:
.Sp
.Vb 7
\&  1 | b | bin      =>  \*(Aq0b\*(Aq . $vector\->to_Bin();
\&  2 | o | oct      =>  \*(Aq0o\*(Aq . $vector\->to_Oct();
\&  3 | d | dec      =>         $vector\->to_Dec(); # prefix is [+\-]
\&  4 | h | hex | x  =>  \*(Aq0x\*(Aq . $vector\->to_Hex();
\&  5 | e | enum     =>  \*(Aq{\*(Aq  . $vector\->to_Enum() . \*(Aq}\*(Aq;
\&  6 | p | pack     =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                       \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
This is necessary because certain strings can be valid
representations in more than one format.
.Sp
All strings in binary format, i.e., which only contain \*(L"0\*(R"
and \*(L"1\*(R", are also valid number representations (of a different
value, of course) in octal, decimal and hexadecimal.
.Sp
Likewise, a string in octal format is also valid in decimal
and hexadecimal, and a string in decimal format is also valid
in hexadecimal.
.Sp
Moreover, if the enumeration of set bits (as returned by
"\f(CW\*(C`to_Enum()\*(C'\fR") only contains one element, this element could
be mistaken for a representation of the entire bit vector
(instead of just one bit) in decimal.
.Sp
Beware also that the string returned by format \*(L"6\*(R" (\*(L"packed
binary\*(R") will in general \fB\s-1NOT\s0 \s-1BE\s0 \s-1PRINTABLE\s0\fR, because it will
usually consist of many unprintable characters!
.IP "\(bu" 2
\&\f(CW\*(C`$type = $vector\->String_Import($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from a string
which has previously been produced by "\f(CW\*(C`String_Export()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Block_Read()\*(C'\fR" or manually or by another
program.
.Sp
Beware however that the string must have the correct format;
otherwise a fatal \*(L"unknown string type\*(R" error will occur.
.Sp
The correct format is the one returned by "\f(CW\*(C`String_Export()\*(C'\fR"
(see immediately above).
.Sp
The method will also try to automatically recognize formats
without identifying prefix such as returned by the methods
"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR".
.Sp
However, as explained above for the method "\f(CW\*(C`String_Export()\*(C'\fR",
due to the fact that a string may be a valid representation in
more than one format, this may lead to unwanted results.
.Sp
The method will try to match the format of the given string
in the following order:
.Sp
If the string consists only of [01], it will be considered
to be in binary format (although it could be in octal, decimal
or hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-7], it will be considered
to be in octal format (although it could be in decimal or
hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-9], it will be considered
to be in decimal format (although it could be in hexadecimal
format or even be an enumeration with only one element as well).
.Sp
If the string consists only of [0\-9A\-Fa\-f], it will be considered
to be in hexadecimal format.
.Sp
If the string only contains numbers in decimal format, separated
by commas (\*(L",\*(R") or dashes (\*(L"\-\*(R"), it is considered to be an
enumeration (a single decimal number also qualifies).
.Sp
And if the string starts with \*(L":[0\-9]:\*(R", the remainder of the
string is read in with "\f(CW\*(C`Block_Store()\*(C'\fR".
.Sp
To avoid misinterpretations, it is therefore recommendable to
always either use the method "\f(CW\*(C`String_Export()\*(C'\fR" or to provide
some uniquely identifying prefix (and suffix, in one case)
yourself:
.Sp
.Vb 12
\&  binary         =>  \*(Aq0b\*(Aq . $string;
\&  octal          =>  \*(Aq0o\*(Aq . $string;
\&  decimal        =>  \*(Aq+\*(Aq  . $string; # in case "$string"
\&                 =>  \*(Aq\-\*(Aq  . $string; # has no sign yet
\&  hexadecimal    =>  \*(Aq0x\*(Aq . $string;
\&                 =>  \*(Aq0h\*(Aq . $string;
\&  enumeration    =>  \*(Aq{\*(Aq  . $string . \*(Aq}\*(Aq;
\&                 =>  \*(Aq[\*(Aq  . $string . \*(Aq]\*(Aq;
\&                 =>  \*(Aq<\*(Aq  . $string . \*(Aq>\*(Aq;
\&                 =>  \*(Aq(\*(Aq  . $string . \*(Aq)\*(Aq;
\&  packed binary  =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                     \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
Note that case (lower/upper/mixed case) is not important
and will be ignored by this method.
.Sp
Internally, the method uses the methods "\f(CW\*(C`from_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Enum()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Block_Store()\*(C'\fR" for actually
importing the contents of the string into the given
bit vector. See their descriptions here in this document
and in \fIBit::Vector\fR\|(3) for any further conditions that
must be met and corresponding possible fatal error messages.
.Sp
The method returns the number of the format that has been
recognized:
.Sp
.Vb 6
\&                1    =>    binary
\&                2    =>    octal
\&                3    =>    decimal
\&                4    =>    hexadecimal
\&                5    =>    enumeration
\&                6    =>    packed binary
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
\&\f(CW\*(C`($vector,$type) = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`String_Import()\*(C'\fR"
(described immediately above).
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`String_Import()\*(C'\fR" above for details).
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR", the
method will automatically determine this value for you and allocate
a bit vector of the calculated size.
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.Sp
The necessary number of bits is calculated as follows:
.Sp
.Vb 6
\&  binary         =>       length($string);
\&  octal          =>   3 * length($string);
\&  decimal        =>  int( length($string) * log(10) / log(2) + 1 );
\&  hexadecimal    =>   4 * length($string);
\&  enumeration    =>  maximum of values found in $string + 1
\&  packed binary  =>  $string =~ /^:(\ed+):/;
.Ve
.Sp
If called in scalar context, the method returns the newly created
bit vector object.
.Sp
If called in list context, the method additionally returns the
number of the format which has been recognized, as explained
above for the method "\f(CW\*(C`String_Import()\*(C'\fR".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::Overload\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::String\*(R" version 7.2.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 \- 2012 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bit::Vector::String5.18.3pm                  0100644 0001750 0001750 00000051327 12566241526 025266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bit::Vector::String 3"
.TH Bit::Vector::String 3 "2013-06-01" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bit::Vector::String \- Generic string import/export for Bit::Vector
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Bit::Vector::String;
\&
\&  to_Oct
\&      $string = $vector\->to_Oct();
\&
\&  from_Oct
\&      $vector\->from_Oct($string);
\&
\&  new_Oct
\&      $vector = Bit::Vector\->new_Oct($bits,$string);
\&
\&  String_Export
\&      $string = $vector\->String_Export($type);
\&
\&  String_Import
\&      $type = $vector\->String_Import($string);
\&
\&  new_String
\&      $vector = Bit::Vector\->new_String($bits,$string);
\&      ($vector,$type) = Bit::Vector\->new_String($bits,$string);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->to_Oct();\*(C'\fR
.Sp
Returns an octal string representing the given bit vector.
.Sp
Note that this method is not particularly efficient, since it
is almost completely realized in Perl, and moreover internally
operates on a Perl list of individual octal digits which it
concatenates into the final string using "\f(CW\*(C`join(\*(Aq\*(Aq, ...)\*(C'\fR".
.Sp
A benchmark reveals that this method is about 40 times slower
than the method "\f(CW\*(C`to_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of to_Bin, to_Hex, to_Oct...
\&     to_Bin:  1 wallclock secs ( 1.09 usr +  0.00 sys =  1.09 CPU)
\&     to_Hex:  1 wallclock secs ( 0.53 usr +  0.00 sys =  0.53 CPU)
\&     to_Oct: 40 wallclock secs (40.16 usr +  0.05 sys = 40.21 CPU)
.Ve
.Sp
Note that since an octal digit is always worth three bits,
the length of the resulting string is always a multiple of
three bits, regardless of the true length (in bits) of the
given bit vector.
.Sp
Also note that the \fB\s-1LEAST\s0\fR significant octal digit is
located at the \fB\s-1RIGHT\s0\fR end of the resulting string, and
the \fB\s-1MOST\s0\fR significant digit at the \fB\s-1LEFT\s0\fR end.
.Sp
Finally, note that this method does \fB\s-1NOT\s0\fR prepend any uniquely
identifying format prefix (such as \*(L"0o\*(R") to the resulting string
(which means that the result of this method only contains valid
octal digits, i.e., [0\-7]).
.Sp
However, this can of course most easily be done as needed,
as follows:
.Sp
.Vb 1
\&  $string = \*(Aq0o\*(Aq . $vector\->to_Oct();
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector\->from_Oct($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from an octal string,
such as returned by the method "\f(CW\*(C`to_Oct()\*(C'\fR" (see above).
.Sp
Note that this method is not particularly efficient, since it is
almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
Remember also that the least significant bits are always to the
right of an octal string, and the most significant bits to the left.
Therefore, the string is actually reversed internally before storing
it in the given bit vector using the method "\f(CW\*(C`Chunk_List_Store()\*(C'\fR",
which expects the least significant chunks of data at the beginning
of a list.
.Sp
A benchmark reveals that this method is about 40 times slower than
the method "\f(CW\*(C`from_Bin()\*(C'\fR" (which is realized in C):
.Sp
.Vb 4
\& Benchmark: timing 10000 iterations of from_Bin, from_Hex, from_Oct...
\&   from_Bin:  1 wallclock secs ( 1.13 usr +  0.00 sys =  1.13 CPU)
\&   from_Hex:  1 wallclock secs ( 0.80 usr +  0.00 sys =  0.80 CPU)
\&   from_Oct: 46 wallclock secs (44.95 usr +  0.00 sys = 44.95 CPU)
.Ve
.Sp
If the given string contains any character which is not an octal digit
(i.e., [0\-7]), a fatal syntax error ensues (\*(L"unknown string type\*(R").
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string; the
presence of such a prefix will also lead to the fatal \*(L"unknown
string type\*(R" error.
.Sp
If the given string contains less octal digits than are needed to
completely fill the given bit vector, the remaining (most significant)
bits all remain cleared (i.e., set to zero).
.Sp
This also means that, even if the given string does not contain
enough digits to completely fill the given bit vector, the previous
contents of the bit vector are erased completely.
.Sp
If the given string is longer than it needs to fill the given bit
vector, the superfluous characters are simply ignored.
.Sp
This behaviour is intentional so that you may read in the string
representing one bit vector into another bit vector of different
size, i.e., as much of it as will fit.
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_Oct($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`from_Oct()\*(C'\fR"
(described above).
.Sp
Note that this approach is not particularly efficient, since it
is almost completely realized in Perl, and moreover chops the input
string into individual characters using "\f(CW\*(C`split(//, $string)\*(C'\fR".
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`from_Oct()\*(C'\fR" above for details).
.Sp
Note especially that this method does \fB\s-1NOT\s0\fR accept any uniquely
identifying format prefix (such as \*(L"0o\*(R") in the given string and that
such a prefix will lead to a fatal \*(L"unknown string type\*(R" error.
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR",
the method will automatically allocate a bit vector with a size
(i.e., number of bits) of three times the length of the given string
(since every octal digit is worth three bits).
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.IP "\(bu" 2
\&\f(CW\*(C`$string = $vector\->String_Export($type);\*(C'\fR
.Sp
Returns a string representing the given bit vector in the
format specified by "\f(CW$type\fR":
.Sp
.Vb 6
\&  1 | b | bin      =>  binary        (using "to_Bin()")
\&  2 | o | oct      =>  octal         (using "to_Oct()")
\&  3 | d | dec      =>  decimal       (using "to_Dec()")
\&  4 | h | hex | x  =>  hexadecimal   (using "to_Hex()")
\&  5 | e | enum     =>  enumeration   (using "to_Enum()")
\&  6 | p | pack     =>  packed binary (using "Block_Read()")
.Ve
.Sp
The case (lower/upper/mixed case) of "\f(CW$type\fR" is ignored.
.Sp
If "\f(CW$type\fR\*(L" is omitted or \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" or false (\*(R"0"
or the empty string), a hexadecimal string is returned
as the default format.
.Sp
If "\f(CW$type\fR\*(L" does not have any of the values described
above, a fatal \*(R"unknown string type" will occur.
.Sp
Beware that in order to guarantee that the strings can
be correctly parsed and read in by the methods
"\f(CW\*(C`String_Import()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_String()\*(C'\fR\*(L" (described
below), the method \*(R"\f(CW\*(C`String_Export()\*(C'\fR" provides
uniquely identifying prefixes (and, in one case,
a suffix) as follows:
.Sp
.Vb 7
\&  1 | b | bin      =>  \*(Aq0b\*(Aq . $vector\->to_Bin();
\&  2 | o | oct      =>  \*(Aq0o\*(Aq . $vector\->to_Oct();
\&  3 | d | dec      =>         $vector\->to_Dec(); # prefix is [+\-]
\&  4 | h | hex | x  =>  \*(Aq0x\*(Aq . $vector\->to_Hex();
\&  5 | e | enum     =>  \*(Aq{\*(Aq  . $vector\->to_Enum() . \*(Aq}\*(Aq;
\&  6 | p | pack     =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                       \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
This is necessary because certain strings can be valid
representations in more than one format.
.Sp
All strings in binary format, i.e., which only contain \*(L"0\*(R"
and \*(L"1\*(R", are also valid number representations (of a different
value, of course) in octal, decimal and hexadecimal.
.Sp
Likewise, a string in octal format is also valid in decimal
and hexadecimal, and a string in decimal format is also valid
in hexadecimal.
.Sp
Moreover, if the enumeration of set bits (as returned by
"\f(CW\*(C`to_Enum()\*(C'\fR") only contains one element, this element could
be mistaken for a representation of the entire bit vector
(instead of just one bit) in decimal.
.Sp
Beware also that the string returned by format \*(L"6\*(R" (\*(L"packed
binary\*(R") will in general \fB\s-1NOT BE PRINTABLE\s0\fR, because it will
usually consist of many unprintable characters!
.IP "\(bu" 2
\&\f(CW\*(C`$type = $vector\->String_Import($string);\*(C'\fR
.Sp
Allows to read in the contents of a bit vector from a string
which has previously been produced by "\f(CW\*(C`String_Export()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`to_Enum()\*(C'\fR\*(L", \*(R"\f(CW\*(C`Block_Read()\*(C'\fR" or manually or by another
program.
.Sp
Beware however that the string must have the correct format;
otherwise a fatal \*(L"unknown string type\*(R" error will occur.
.Sp
The correct format is the one returned by "\f(CW\*(C`String_Export()\*(C'\fR"
(see immediately above).
.Sp
The method will also try to automatically recognize formats
without identifying prefix such as returned by the methods
"\f(CW\*(C`to_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`to_Hex()\*(C'\fR\*(L"
and \*(R"\f(CW\*(C`to_Enum()\*(C'\fR".
.Sp
However, as explained above for the method "\f(CW\*(C`String_Export()\*(C'\fR",
due to the fact that a string may be a valid representation in
more than one format, this may lead to unwanted results.
.Sp
The method will try to match the format of the given string
in the following order:
.Sp
If the string consists only of [01], it will be considered
to be in binary format (although it could be in octal, decimal
or hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-7], it will be considered
to be in octal format (although it could be in decimal or
hexadecimal format or even be an enumeration with only
one element as well).
.Sp
If the string consists only of [0\-9], it will be considered
to be in decimal format (although it could be in hexadecimal
format or even be an enumeration with only one element as well).
.Sp
If the string consists only of [0\-9A\-Fa\-f], it will be considered
to be in hexadecimal format.
.Sp
If the string only contains numbers in decimal format, separated
by commas (\*(L",\*(R") or dashes (\*(L"\-\*(R"), it is considered to be an
enumeration (a single decimal number also qualifies).
.Sp
And if the string starts with \*(L":[0\-9]:\*(R", the remainder of the
string is read in with "\f(CW\*(C`Block_Store()\*(C'\fR".
.Sp
To avoid misinterpretations, it is therefore recommendable to
always either use the method "\f(CW\*(C`String_Export()\*(C'\fR" or to provide
some uniquely identifying prefix (and suffix, in one case)
yourself:
.Sp
.Vb 12
\&  binary         =>  \*(Aq0b\*(Aq . $string;
\&  octal          =>  \*(Aq0o\*(Aq . $string;
\&  decimal        =>  \*(Aq+\*(Aq  . $string; # in case "$string"
\&                 =>  \*(Aq\-\*(Aq  . $string; # has no sign yet
\&  hexadecimal    =>  \*(Aq0x\*(Aq . $string;
\&                 =>  \*(Aq0h\*(Aq . $string;
\&  enumeration    =>  \*(Aq{\*(Aq  . $string . \*(Aq}\*(Aq;
\&                 =>  \*(Aq[\*(Aq  . $string . \*(Aq]\*(Aq;
\&                 =>  \*(Aq<\*(Aq  . $string . \*(Aq>\*(Aq;
\&                 =>  \*(Aq(\*(Aq  . $string . \*(Aq)\*(Aq;
\&  packed binary  =>  \*(Aq:\*(Aq  . $vector\->Size() .
\&                     \*(Aq:\*(Aq  . $vector\->Block_Read();
.Ve
.Sp
Note that case (lower/upper/mixed case) is not important
and will be ignored by this method.
.Sp
Internally, the method uses the methods "\f(CW\*(C`from_Bin()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Oct()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Dec()\*(C'\fR\*(L", \*(R"\f(CW\*(C`from_Hex()\*(C'\fR\*(L",
\&\*(R"\f(CW\*(C`from_Enum()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`Block_Store()\*(C'\fR" for actually
importing the contents of the string into the given
bit vector. See their descriptions here in this document
and in \fIBit::Vector\fR\|(3) for any further conditions that
must be met and corresponding possible fatal error messages.
.Sp
The method returns the number of the format that has been
recognized:
.Sp
.Vb 6
\&                1    =>    binary
\&                2    =>    octal
\&                3    =>    decimal
\&                4    =>    hexadecimal
\&                5    =>    enumeration
\&                6    =>    packed binary
.Ve
.IP "\(bu" 2
\&\f(CW\*(C`$vector = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
\&\f(CW\*(C`($vector,$type) = Bit::Vector\->new_String($bits,$string);\*(C'\fR
.Sp
This method is an alternative constructor which allows you to create
a new bit vector object (with "\f(CW$bits\fR" bits) and to initialize it
all in one go.
.Sp
The method internally first calls the bit vector constructor method
"\f(CW\*(C`new()\*(C'\fR\*(L" and then stores the given string in the newly created
bit vector using the same approach as the method \*(R"\f(CW\*(C`String_Import()\*(C'\fR"
(described immediately above).
.Sp
An exception will be raised if the necessary memory cannot be allocated
(see the description of the method "\f(CW\*(C`new()\*(C'\fR" in \fIBit::Vector\fR\|(3) for
possible causes) or if the given string cannot be converted successfully
(see the description of the method "\f(CW\*(C`String_Import()\*(C'\fR" above for details).
.Sp
In case of an error, the memory occupied by the new bit vector is
released again before the exception is actually thrown.
.Sp
If the number of bits "\f(CW$bits\fR\*(L" given has the value \*(R"\f(CW\*(C`undef\*(C'\fR", the
method will automatically determine this value for you and allocate
a bit vector of the calculated size.
.Sp
Note that this behaviour is different from that of the methods
"\f(CW\*(C`new_Hex()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Bin()\*(C'\fR\*(L", \*(R"\f(CW\*(C`new_Dec()\*(C'\fR\*(L" and \*(R"\f(CW\*(C`new_Enum()\*(C'\fR\*(L"
(which are realized in C, internally); these methods will silently
assume a value of 0 bits if \*(R"\f(CW\*(C`undef\*(C'\fR\*(L" is given (and may warn
about the \*(R"Use of uninitialized value" if warnings are enabled).
.Sp
The necessary number of bits is calculated as follows:
.Sp
.Vb 6
\&  binary         =>       length($string);
\&  octal          =>   3 * length($string);
\&  decimal        =>  int( length($string) * log(10) / log(2) + 1 );
\&  hexadecimal    =>   4 * length($string);
\&  enumeration    =>  maximum of values found in $string + 1
\&  packed binary  =>  $string =~ /^:(\ed+):/;
.Ve
.Sp
If called in scalar context, the method returns the newly created
bit vector object.
.Sp
If called in list context, the method additionally returns the
number of the format which has been recognized, as explained
above for the method "\f(CW\*(C`String_Import()\*(C'\fR".
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIBit::Vector\fR\|(3), \fIBit::Vector::Overload\fR\|(3).
.SH "VERSION"
.IX Header "VERSION"
This man page documents \*(L"Bit::Vector::String\*(R" version 7.3.
.SH "AUTHOR"
.IX Header "AUTHOR"
.Vb 3
\&  Steffen Beyer
\&  mailto:STBEY@cpan.org
\&  http://www.engelschall.com/u/sb/download/
.Ve
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 2004 \- 2013 by Steffen Beyer. All rights reserved.
.SH "LICENSE"
.IX Header "LICENSE"
This package is free software; you can redistribute it and/or
modify it under the same terms as Perl itself, i.e., under the
terms of the \*(L"Artistic License\*(R" or the \*(L"\s-1GNU\s0 General Public License\*(R".
.PP
The C library at the core of this Perl module can additionally
be redistributed and/or modified under the terms of the \*(L"\s-1GNU\s0
Library General Public License\*(R".
.PP
Please refer to the files \*(L"Artistic.txt\*(R", \*(L"\s-1GNU_GPL\s0.txt\*(R" and
\&\*(L"\s-1GNU_LGPL\s0.txt\*(R" in this distribution for details!
.SH "DISCLAIMER"
.IX Header "DISCLAIMER"
This package is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE.\s0
.PP
See the \*(L"\s-1GNU\s0 General Public License\*(R" for more details.
                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::DBI.3pm                              0100644 0001750 0001750 00000012213 12566241601 023207  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::DBI 3"
.TH Bundle::DBI 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::DBI \- A bundle to install DBI and required modules.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perl \-MCPAN \-e \*(Aqinstall Bundle::DBI\*(Aq
.Ve
.SH "CONTENTS"
.IX Header "CONTENTS"
\&\s-1DBI \-\s0 for to get to know thyself
.PP
DBI::Shell 11.91 \- the \s-1DBI\s0 command line shell
.PP
Storable 2.06 \- for DBD::Proxy, DBI::ProxyServer, DBD::Forward
.PP
Net::Daemon 0.37 \- for DBD::Proxy and DBI::ProxyServer
.PP
RPC::PlServer 0.2016 \- for DBD::Proxy and DBI::ProxyServer
.PP
DBD::Multiplex 1.19 \- treat multiple db handles as one
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle includes all the modules used by the Perl Database
Interface (\s-1DBI\s0) module, created by Tim Bunce.
.PP
A \fIBundle\fR is a module that simply defines a collection of other
modules.  It is used by the \s-1CPAN\s0 module to automate the fetching,
building and installing of modules from the \s-1CPAN\s0 ftp archive sites.
.PP
This bundle does not deal with the various database drivers (e.g.
DBD::Informix, DBD::Oracle etc), most of which require software from
sources other than \s-1CPAN.\s0 You'll need to fetch and build those drivers
yourself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler, Jochen Wiedmann and Tim Bunce.
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::DBI5.16.3pm                          0100644 0001750 0001750 00000011672 12566241600 023530  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::DBI 3"
.TH Bundle::DBI 3 "2007-01-24" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::DBI \- A bundle to install DBI and required modules.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perl \-MCPAN \-e \*(Aqinstall Bundle::DBI\*(Aq
.Ve
.SH "CONTENTS"
.IX Header "CONTENTS"
\&\s-1DBI\s0 \- for to get to know thyself
.PP
DBI::Shell 11.91 \- the \s-1DBI\s0 command line shell
.PP
Storable 2.06 \- for DBD::Proxy, DBI::ProxyServer, DBD::Forward
.PP
Net::Daemon 0.37 \- for DBD::Proxy and DBI::ProxyServer
.PP
RPC::PlServer 0.2016 \- for DBD::Proxy and DBI::ProxyServer
.PP
DBD::Multiplex 1.19 \- treat multiple db handles as one
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle includes all the modules used by the Perl Database
Interface (\s-1DBI\s0) module, created by Tim Bunce.
.PP
A \fIBundle\fR is a module that simply defines a collection of other
modules.  It is used by the \s-1CPAN\s0 module to automate the fetching,
building and installing of modules from the \s-1CPAN\s0 ftp archive sites.
.PP
This bundle does not deal with the various database drivers (e.g.
DBD::Informix, DBD::Oracle etc), most of which require software from
sources other than \s-1CPAN\s0. You'll need to fetch and build those drivers
yourself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler, Jochen Wiedmann and Tim Bunce.
                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::DBI5.18.3pm                          0100644 0001750 0001750 00000012213 12566241601 023523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::DBI 3"
.TH Bundle::DBI 3 "2013-06-24" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::DBI \- A bundle to install DBI and required modules.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  perl \-MCPAN \-e \*(Aqinstall Bundle::DBI\*(Aq
.Ve
.SH "CONTENTS"
.IX Header "CONTENTS"
\&\s-1DBI \-\s0 for to get to know thyself
.PP
DBI::Shell 11.91 \- the \s-1DBI\s0 command line shell
.PP
Storable 2.06 \- for DBD::Proxy, DBI::ProxyServer, DBD::Forward
.PP
Net::Daemon 0.37 \- for DBD::Proxy and DBI::ProxyServer
.PP
RPC::PlServer 0.2016 \- for DBD::Proxy and DBI::ProxyServer
.PP
DBD::Multiplex 1.19 \- treat multiple db handles as one
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle includes all the modules used by the Perl Database
Interface (\s-1DBI\s0) module, created by Tim Bunce.
.PP
A \fIBundle\fR is a module that simply defines a collection of other
modules.  It is used by the \s-1CPAN\s0 module to automate the fetching,
building and installing of modules from the \s-1CPAN\s0 ftp archive sites.
.PP
This bundle does not deal with the various database drivers (e.g.
DBD::Informix, DBD::Oracle etc), most of which require software from
sources other than \s-1CPAN.\s0 You'll need to fetch and build those drivers
yourself.
.SH "AUTHORS"
.IX Header "AUTHORS"
Jonathan Leffler, Jochen Wiedmann and Tim Bunce.
                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::Net::LDAP.3pm                        0100644 0001750 0001750 00000010571 12566241570 024176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::Net::LDAP 3"
.TH Bundle::Net::LDAP 3 "2013-07-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::Net::LDAP \- A bundle for Net::LDAP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`perl \-MCPAN \-e \*(Aqinstall Bundle::Net::LDAP\*(Aq\*(C'\fR
.SH "CONTENTS"
.IX Header "CONTENTS"
Convert::ASN1
.PP
Digest::MD5
.PP
\&\s-1URI\s0
.PP
URI::ldap
.PP
IO::Socket::SSL
.PP
XML::Parser
.PP
Net::LDAP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle all modules that Net::LDAP depends on.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr
                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::Net::LDAP5.16.3pm                    0100644 0001750 0001750 00000010250 12566241566 024507  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::Net::LDAP 3"
.TH Bundle::Net::LDAP 3 "2012-09-20" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::Net::LDAP \- A bundle for Net::LDAP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`perl \-MCPAN \-e \*(Aqinstall Bundle::Net::LDAP\*(Aq\*(C'\fR
.SH "CONTENTS"
.IX Header "CONTENTS"
Convert::ASN1
.PP
Digest::MD5
.PP
\&\s-1URI\s0
.PP
URI::ldap
.PP
IO::Socket::SSL
.PP
XML::Parser
.PP
Net::LDAP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle all modules that Net::LDAP depends on.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr
                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Bundle::Net::LDAP5.18.3pm                    0100644 0001750 0001750 00000010571 12566241570 024512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Bundle::Net::LDAP 3"
.TH Bundle::Net::LDAP 3 "2013-07-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Bundle::Net::LDAP \- A bundle for Net::LDAP
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\f(CW\*(C`perl \-MCPAN \-e \*(Aqinstall Bundle::Net::LDAP\*(Aq\*(C'\fR
.SH "CONTENTS"
.IX Header "CONTENTS"
Convert::ASN1
.PP
Digest::MD5
.PP
\&\s-1URI\s0
.PP
URI::ldap
.PP
IO::Socket::SSL
.PP
XML::Parser
.PP
Net::LDAP
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This bundle all modules that Net::LDAP depends on.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr
                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCrypt.3cc                                  0100644 0001750 0001750 00000000026 12566166757 022574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptor.3cc                                0100644 0001750 0001750 00000020071 12566166757 023137  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd March 22, 2007
.Dt CCCryptor 3cc
.Os
.Sh NAME
.Nm CCCryptorCreate ,
.Nm CCryptorCreateFromData ,
.Nm CCCryptorRelease ,
.Nm CCCryptorUpdate ,
.Nm CCCryptorFinal ,
.Nm CCCryptorGetOutputLength ,
.Nm CCCryptorReset ,
.Nm CCCrypt
.Nd Common Cryptographic Algorithm Interfaces
.Sh LIBRARY
These functions are found in libSystem.
.Sh SYNOPSIS
.In CommonCrypto/CommonCryptor.h
.Ft CCCryptorStatus
.Fn CCCryptorCreate "CCOperation op" "CCAlgorithm alg" "CCOptions options" \
"const void *key" "size_t keyLength" "const void *iv" "CCCryptorRef *cryptorRef"
.Ft CCCryptorStatus
.Fn CCCryptorCreateFromData "CCOperation op" "CCAlgorithm alg" "CCOptions options" \
"const void *key" "size_t keyLength" "const void *iv" "const void *data" \
"size_t dataLength" "CCCryptorRef *cryptorRef" "size_t *dataUsed"
.Ft CCCryptorStatus
.Fn CCCryptorRelease "CCCryptorRef cryptorRef"
.Ft CCCryptorStatus
.Fn CCCryptorUpdate "CCCryptorRef cryptorRef" "const void *dataIn" \
"size_t dataInLength" "void *dataOut" "size_t dataOutAvailable" "size_t *dataOutMoved"
.Ft CCCryptorStatus
.Fn CCCryptorFinal "CCCryptorRef cryptorRef" "void *dataOut" \
"size_t dataOutAvailable" "size_t *dataOutMoved"
.Ft size_t
.Fn CCCryptorGetOutputLength "CCCryptorRef cryptorRef" "size_t inputLength" "bool final"
.Ft CCCryptorStatus
.Fn CCCryptorReset "CCCryptorRef cryptorRef" "const void *iv"
.Ft CCCryptorStatus
.Fn CCCrypt "CCOperation op" "CCAlgorithm alg" "CCOptions options" "const void *key" \
"size_t keyLength" "const void *iv" "const void *dataIn" "size_t dataInLength" \
"void *dataOut" "size_t dataOutAvailable" "size_t *dataOutMoved"
.Sh DESCRIPTION
This interface provides access to a number of symmetric encryption
algorithms. Symmetric encryption algorithms come in two "flavors" -
block ciphers, and stream ciphers. Block ciphers process data
(while both encrypting and decrypting) in discrete chunks of
data called blocks; stream ciphers operate on arbitrary sized
data.
.Pp
The object declared in this interface, CCCryptor, provides
access to both block ciphers and stream ciphers with the same
API; however some options are available for block ciphers that
do not apply to stream ciphers.
.Pp
The general operation of a CCCryptor is: initialize it
with raw key data and other optional fields with CCCryptorCreate();
process input data via one or more calls to CCCryptorUpdate(),
each of which may result in output data being written to
caller-supplied memory; and obtain possible remaining output data
with CCCryptorFinal(). The CCCryptor is disposed of via
CCCryptorRelease(), or it can be reused (with the same key data
as provided to CCCryptorCreate()) by calling CCCryptorReset().
.Pp
CCCryptors can be dynamically allocated by this module, or
their memory can be allocated by the caller.
.Pp
One option for block ciphers is padding, as defined in PKCS7;
when padding is enabled, the total amount of data encrypted
does not have to be an even multiple of the block size, and
the actual length of plaintext is calculated during decryption.
.Pp
Another option for block ciphers is Cipher Block Chaining, known
as CBC mode. When using CBC mode, an Initialization Vector (IV)
is provided along with the key when starting an encrypt
or decrypt operation. If CBC mode is selected and no IV is
provided, an IV of all zeroes will be used.
.Pp
CCCryptor also implements block bufferring, so that individual
calls to CCCryptorUpdate() do not have to provide data whose length
is aligned to the block size. (If padding is disabled, encrypting
with block ciphers does require that the *total* length of data
input to CCCryptorUpdate() call(s) be aligned to the block size.)
.Pp
A given CCCryptor can only be used by one thread at a time;
multiple threads can use safely different CCCryptors at the
same time. 
.Pp
.Ft CCCryptorRef
objects created with
.Fn CCCryptorCreate
or
.Fn CCCryptorCreateFromData
*may* be disposed of
via
.Fn CCCRyptorRelease
; that call is not strictly necessary, but
if it's not performed, good security practice dictates that the
caller should zero the memory provided to create the
.Ft CCCryptorRef
when the caller is finished using the
.Ft CCCryptorRef.
.Pp
.Fn CCCryptorUpdate
is used to encrypt or decrypt data.  This routine can be called multiple times. The caller does
not need to align input data lengths to block sizes; input is
bufferred as necessary for block ciphers.
.Pp
When performing symmetric encryption with block ciphers,
and padding is enabled via
.Ft kCCOptionPKCS7Padding,
the total
number of bytes provided by all the calls to this function
when encrypting can be arbitrary (i.e., the total number
of bytes does not have to be block aligned). However if
padding is disabled, or when decrypting, the total number
of bytes does have to be aligned to the block size; otherwise
.Fn CCCryptFinal
will return
.Ft kCCAlignmentError.
.Pp
A general rule for the size of the output buffer which must be
provided by the caller is that for block ciphers, the output
length is never larger than the input length plus the block size.
For stream ciphers, the output length is always exactly the same
as the input length. See the discussion for
.Fn CCCryptorGetOutputLength
for more information on this topic.
.Pp
.Fn CCCryptFinal
finishes encryption and decryption operations and obtains the final data output.
Except when
.Ft kCCBufferTooSmall
is returned, the
.Ft CCCryptorRef
can no longer be used for subsequent operations unless
.Fn CCCryptorReset
is called on it.
.Pp
It is not necessary to call
.Fn CCCryptorFinal
when performing
symmetric encryption or decryption if padding is disabled, or
when using a stream cipher.
.Pp
It is not necessary to call
.Fn CCCryptorFinal
prior to
.Fn CCCryptorRelease
when aborting an operation.
.Pp
Use
.Fn CCCryptorGetOutputLength
to determine output buffer size required to process a given input size.
Some general rules apply that allow clients of this module to
know a priori how much output buffer space will be required
in a given situation. For stream ciphers, the output size is
always equal to the input size, and
.Fn CCCryptorFinal
never
produces any data. For block ciphers, the output size will
always be less than or equal to the input size plus the size
of one block. For block ciphers, if the input size provided
to each call to
.Fn CCCryptorUpdate
is is an integral multiple
of the block size, then the output size for each call to
.Fn CCCryptorUpdate
is less than or equal to the input size
for that call to
.Fn CCCryptorUpdate .
.Fn CCCryptorFinal
only produces output when using a block cipher with padding enabled.
.Pp
.Fn CCCryptorReset
reinitializes an existing
.Ft CCCryptorRef
with a (possibly) new initialization vector. The key contained in the
.Ft CCCryptorRef
is unchanged. This function is not implemented for stream ciphers.  This can be called on a CCCryptorRef with data pending (i.e.
in a padded mode operation before 
.Fn CCCryptFinal
is called); however any pending data will be lost in that case.
.Pp
.Fn CCCrypt
is a stateless, one-shot encrypt or decrypt operation.
This basically performs a sequence of
.Fn CCCrytorCreate ,
.Fn CCCryptorUpdate ,
.Fn CCCryptorFinal ,
and
.Fn CCCryptorRelease .
.Sh RETURN VALUES
The following values may be returned as a status of type
.Ft CCCryptorStatus .
.Pp
.Er kCCSuccess
- Operation completed normally.
.Pp
.Er kCCParamError
- Illegal parameter value.
.Pp
.Er kCCBufferTooSmall
- Insufficent buffer provided for specified operation.
.Pp
.Er kCCMemoryFailure
- Memory allocation failure.
.Pp
.Er kCCAlignmentError
- Input size was not aligned properly.
.Pp
.Er kCCDecodeError
- Input data did not decode or decrypt properly.
.Pp
.Er kCCUnimplemented
- Function not implemented for the current algorithm.
.Sh HISTORY
These functions are available in OS X 10.5 and later.
.Sh SEE ALSO
.Xr CCHmac 3cc ,
.Xr CC_MD5 3cc ,
.Xr CC_SHA 3cc ,
.Xr CC_crypto 3cc
.Sh STANDARDS
.Bl -tag
.It AES:
Federal Information Processing Standard \s-1FIPS\s0 \s-1PUB\s0 197 (Advanced Encryption Standard),
.It DES:
Federal Information Processing Standard \s-1FIPS\s0 \s-1PUB\s0 46\-3 (Data Encryption Standard)
.It 3DES:
NIST Special Publication\s-1PUB\s0 800\-67 (Recommendation for the Triple Data Encryption Algorithm (TDEA) Block Cipher)
.El
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorCreate.3cc                          0100644 0001750 0001750 00000000026 12566166757 024261  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorFinal.3cc                           0100644 0001750 0001750 00000000026 12566166757 024107  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorGetOutputLength.3cc                 0100644 0001750 0001750 00000000026 12566166757 026160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorRelease.3cc                         0100644 0001750 0001750 00000000026 12566166757 024436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorReset.3cc                           0100644 0001750 0001750 00000000026 12566166757 024140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCCryptorUpdate.3cc                          0100644 0001750 0001750 00000000026 12566166757 024300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCHmac.3cc                                   0100644 0001750 0001750 00000002750 12566166757 022351  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd March 22, 2007
.Dt CCHMAC 3
.Os
.Sh NAME
.Nm CCHmacInit ,
.Nm CCHmacUpdate ,
.Nm CCHmacFinal ,
.Nm CCHmac
.Nd Common HMAC Algorithm Interfaces
.Sh LIBRARY
These functions are found in libSystem.
.Sh SYNOPSIS
.In CommonCrypto/CommonHMAC.h
.Ft void
.Fn CCHmacInit "CCHmacContext *ctx" "CCHmacAlgorithm algorithm" "const void *key" "size_t keyLength"
.Ft void
.Fn CCHmacUpdate "CCHmacContext *ctx" "const void *data" "size_t dataLength"
.Ft void
.Fn CCHmacFinal "CCHmacContext *ctx" "void *macOut"
.Ft void
.Fn CCHmac "CCHmacAlgorithm algorithm" "const void *key" "size_t keyLength" "const void *data" "size_t dataLength" "void *macOut"
.Sh DESCRIPTION
This interface provides access to a number of HMAC
algorithms. The following algorithms are available:
.Bl -tag -width "kCCHmacAlgSHA224"
.It kCCHmacAlgSHA1
- HMAC with SHA1 digest
.It kCCHmacAlgMD5
- HMAC with MD5 digest
.It kCCHmacAlgSHA256
- HMAC with SHA256 digest
.It kCCHmacAlgSHA384
- HMAC with SHA384 digest
.It kCCHmacAlgSHA224
- HMAC with SHA224 digest
.It kCCHmacAlgSHA512
- HMAC with SHA512 digest
.El
.Pp
The object declared in this interface, CCHmacContext, provides
a handle for use with the
.Fn CCHmacInit
.Fn CCHmacUpdate
and
.Fn CCHmacFinal
calls to complete the HMAC operation.  In addition there is a one shot function,
.Fn CCHmac
that performs a complete HMAC on a single piece of data.
.Sh HISTORY
These functions are available in OS X 10.5 and later.
.Sh SEE ALSO
.Xr CC_MD5 3cc ,
.Xr CC_SHA 3cc ,
.Xr CC_crypto 3cc ,
.Xr CCCrypto 3cc
                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCHmacFinal.3cc                              0100644 0001750 0001750 00000000023 12566166757 023312  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCHmac.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCHmacInit.3cc                               0100644 0001750 0001750 00000000023 12566166757 023164  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCHmac.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCHmacUpdate.3cc                             0100644 0001750 0001750 00000000023 12566166757 023503  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCHmac.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD2.3cc                                   0100644 0001750 0001750 00000000024 12566166757 022212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD2_Final.3cc                             0100644 0001750 0001750 00000000023 12566166757 023322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD2_Init.3cc                              0100644 0001750 0001750 00000000023 12566166757 023174  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD2_Update.3cc                            0100644 0001750 0001750 00000000023 12566166757 023513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD4.3cc                                   0100644 0001750 0001750 00000000023 12566166757 022213  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD4_Final.3cc                             0100644 0001750 0001750 00000000023 12566166757 023324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD4_Init.3cc                              0100644 0001750 0001750 00000000023 12566166757 023176  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD4_Update.3cc                            0100644 0001750 0001750 00000000023 12566166757 023515  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD5.3cc                                   0100644 0001750 0001750 00000005147 12566166757 022230  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 5, 2007
.Dt CC_MD5 3cc
.Os
.Sh NAME
.Nm CC_MD2_Init
.Nm CC_MD2_Update
.Nm CC_MD2_Final
.Nm CC_MD2
.Pp
.Nm CC_MD4_Init
.Nm CC_MD4_Update
.Nm CC_MD4_Final
.Nm CC_MD4
.Pp
.Nm CC_MD5_Init
.Nm CC_MD5_Update
.Nm CC_MD5_Final
.Nm CC_MD5
.Pp
.Nd MD2, MD4, and MD5 hash functions
.Sh SYNOPSIS
.In CommonCrypto/CommonDigest.h
.Ft extern int
.Fn CC_MD2_Init "CC_MD2_CTX *c"
.Ft extern int
.Fn CC_MD2_Update "CC_MD2_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_MD2_Final "unsigned char *md" "CC_MD2_CTX *c"
.Ft extern unsigned char *
.Fn CC_MD2 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_MD4_Init "CC_MD4_CTX *c"
.Ft extern int
.Fn CC_MD4_Update "CC_MD4_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_MD4_Final "unsigned char *md" "CC_MD4_CTX *c"
.Ft extern unsigned char *
.Fn CC_MD4 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_MD5_Init "CC_MD5_CTX *c"
.Ft extern int
.Fn CC_MD5_Update "CC_MD5_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_MD5_Final "unsigned char *md" "CC_MD5_CTX *c"
.Ft extern unsigned char *
.Fn CC_MD5 "const void *data" "CC_LONG len" "unsigned char *md"
.Sh DESCRIPTION
The following functions are used to produce an hash from data:
.Pp
.Fn CC_MD2_Init
initializes a 
.Ft CC_MD2_CTX
structure.
.Pp
.Fn CC_MD2_Update
can be called repeatedly with chunks of the message to
be hashed (len bytes at data).
.Pp
.Fn CC_MD2_Final
places the MD2 message digest in md, which must have space
for 
.Ft CC_MD2_DIGEST_LENGTH
== 16 bytes of output, and erases the 
.Ft CC_MD2_CTX .
.Pp
.Fn CC_MD2
computes the MD2 message digest of the len
bytes at data and places it in md (which must have space for
.Ft CC_MD2_DIGEST_LENGTH
== 16 bytes of output). It returns the md pointer.
.Pp
.Fn CC_MD4_Init , 
.Fn CC_MD4_Update , 
.Fn CC_MD4_Final , 
.Fn CC_MD4 , 
.Fn CC_MD5_Init , 
.Fn CC_MD5_Update , 
.Fn CC_MD5_Final ,
and 
.Fn CC_MD5
are analogous using an 
.Ft CC_MD4_CTX
and 
.Ft CC_MD5_CTX
structure.
.Sh NOTE
MD2, MD4, and MD5 are recommended only for compatibility with existing
applications. In new applications, SHA\-256(or greater) should be
preferred.
.Sh RETURN VALUES
All routines return 1 except for the one-shot routines (
.Fn CC_MD2
, etc.), which return the pointer passed in via the md parameter.
.Sh CONFORMING TO
RFC 1319, RFC 1320, RFC 1321
.Sh SEE ALSO
.Xr CC_crypto 3cc ,
.Xr CC_SHA 3cc ,
.Xr CCHmac 3cc ,
.Xr CCCryptor 3cc
.Sh HISTORY
These functions are available in OS X 10.4 and later.
.Pp
These functions provide similar functionality to the routines found
in OpenSSL 0.9.6 and may use the same implementation.
                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD5_Final.3cc                             0100644 0001750 0001750 00000000023 12566166757 023325  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD5_Init.3cc                              0100644 0001750 0001750 00000000023 12566166757 023177  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_MD5_Update.3cc                            0100644 0001750 0001750 00000000023 12566166757 023516  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_MD5.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA.3cc                                   0100644 0001750 0001750 00000007514 12566166757 022256  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 5, 2007
.Dt CC_SHA 3cc
.Os
.Sh NAME
.Nm CC_SHA1_Init
.Nm CC_SHA1_Update
.Nm CC_SHA1_Final
.Nm CC_SHA1
.Pp
.Nm CC_SHA224_Init
.Nm CC_SHA224_Update
.Nm CC_SHA224_Final
.Nm CC_SHA224
.Pp
.Nm CC_SHA256_Init
.Nm CC_SHA256_Update
.Nm CC_SHA256_Final
.Nm CC_SHA256
.Pp
.Nm CC_SHA384_Init
.Nm CC_SHA384_Update
.Nm CC_SHA384_Final
.Nm CC_SHA384
.Pp
.Nm CC_SHA512_Init
.Nm CC_SHA512_Update
.Nm CC_SHA512_Final
.Nm CC_SHA512
.Pp
.Nd Secure Hash Algorithms
.Sh SYNOPSIS
.In CommonCrypto/CommonDigest.h
.Pp
.Ft extern int
.Fn CC_SHA1_Init "CC_SHA1_CTX *c"
.Ft extern int
.Fn CC_SHA1_Update "CC_SHA1_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_SHA1_Final "unsigned char *md" "CC_SHA1_CTX *c"
.Ft extern unsigned char *
.Fn CC_SHA1 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_SHA224_Init "CC_SHA256_CTX *c"
.Ft extern int
.Fn CC_SHA224_Update "CC_SHA256_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_SHA224_Final "unsigned char *md" "CC_SHA256_CTX *c"
.Ft extern unsigned char *
.Fn CC_SHA224 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_SHA256_Init "CC_SHA256_CTX *c"
.Ft extern int
.Fn CC_SHA256_Update "CC_SHA256_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_SHA256_Final "unsigned char *md" "CC_SHA256_CTX *c"
.Ft extern unsigned char *
.Fn CC_SHA256 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_SHA384_Init "CC_SHA512_CTX *c"
.Ft extern int
.Fn CC_SHA384_Update "CC_SHA512_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_SHA384_Final "unsigned char *md" "CC_SHA512_CTX *c"
.Ft extern unsigned char *
.Fn CC_SHA384 "const void *data" "CC_LONG len" "unsigned char *md"
.Pp
.Ft extern int
.Fn CC_SHA512_Init "CC_SHA512_CTX *c"
.Ft extern int
.Fn CC_SHA512_Update "CC_SHA512_CTX *c" "const void *data" "CC_LONG len"
.Ft extern int
.Fn CC_SHA512_Final "unsigned char *md" "CC_SHA512_CTX *c"
.Ft extern unsigned char *
.Fn CC_SHA512 "const void *data" "CC_LONG len" "unsigned char *md"
.Sh DESCRIPTION
SHA\-1 (Secure Hash Algorithm) is a cryptographic hash function with a
160 bit output.
.Pp
.Fn CC_SHA1
computes the SHA\-1 message digest of the len
bytes at data and places it in md (which must have space for
.Ft CC_SHA1_DIGEST_LENGTH
== 20 bytes of output). It returns the md pointer.
.Pp
.Fn CC_SHA1_Init
initializes a
.Ft CC_SHA1_CTX
structure.
.Pp
.Fn CC_SHA1_Update
can be called repeatedly with chunks of the message to
be hashed (len bytes at data).
.Pp
.Fn CC_SHA1_Final
places the message digest in md, which must have space
for
.Ft CC_SHA1_DIGEST_LENGTH
== 20 bytes of output, and erases the
.Ft CC_SHA1_CTX .
.Pp
The successor versions of SHA\-1, SHA-2, are also implemented for hash
bit lengths of 224, 256, 384, and 512.  The functions to call to invoke the larger hash-size
versions of the algorithms include the hash size as part of the function names:
.Pp
.Fn CC_SHA224_Init ,
.Fn CC_SHA224_Update ,
.Fn CC_SHA224_Final ,
.Fn CC_SHA224
.Pp
.Fn CC_SHA256_Init ,
.Fn CC_SHA256_Update ,
.Fn CC_SHA256_Final ,
.Fn CC_SHA256
.Pp
.Fn CC_SHA384_Init ,
.Fn CC_SHA384_Update ,
.Fn CC_SHA384_Final ,
.Fn CC_SHA384
.Pp
.Fn CC_SHA512_Init ,
.Fn CC_SHA512_Update ,
.Fn CC_SHA512_Final ,
.Fn CC_SHA512
.Sh RETURN VALUES
All routines return 1 except for the one-shot routines (
.Fn CC_SHA1 ,
etc.), which
return the pointer passed in via the md parameter.
.Sh CONFORMING TO
SHA\-1: US Federal Information Processing Standard FIPS PUB 180\-1 (Secure Hash
Standard),
ANSI X9.30
.Pp
SHA\-2: US Federal Information Processing Standard FIPS PUB 180\-2 (Secure Hash
Standard)
.Sh HISTORY
These functions are available in OS X 10.4 and later.
.Pp
These functions provide similar functionality to the routines found in OpenSSL 0.9.6
and may use the same implementation.
.Sh SEE ALSO
.Xr CC_MD5 3cc ,
.Xr CCCryptor 3cc ,
.Xr CCHmac 3cc ,
.Xr CC_crypto 3cc
                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA1.3cc                                  0100644 0001750 0001750 00000000023 12566166757 022323  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA1_Final.3cc                            0100644 0001750 0001750 00000000023 12566166757 023434  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA1_Init.3cc                             0100644 0001750 0001750 00000000023 12566166757 023306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA1_Update.3cc                           0100644 0001750 0001750 00000000023 12566166757 023625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA224.3cc                                0100644 0001750 0001750 00000000023 12566166757 022472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA224_Final.3cc                          0100644 0001750 0001750 00000000023 12566166757 023603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA224_Init.3cc                           0100644 0001750 0001750 00000000023 12566166757 023455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA224_Update.3cc                         0100644 0001750 0001750 00000000023 12566166757 023774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA256.3cc                                0100644 0001750 0001750 00000000023 12566166757 022477  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA256_Final.3cc                          0100644 0001750 0001750 00000000023 12566166757 023610  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA256_Init.3cc                           0100644 0001750 0001750 00000000023 12566166757 023462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA256_Update.3cc                         0100644 0001750 0001750 00000000023 12566166757 024001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA384.3cc                                0100644 0001750 0001750 00000000023 12566166757 022501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA384_Final.3cc                          0100644 0001750 0001750 00000000023 12566166757 023612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA384_Init.3cc                           0100644 0001750 0001750 00000000023 12566166757 023464  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA384_Update.3cc                         0100644 0001750 0001750 00000000023 12566166757 024003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA512.3cc                                0100644 0001750 0001750 00000000023 12566166757 022472  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA512_Final.3cc                          0100644 0001750 0001750 00000000023 12566166757 023603  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA512_Init.3cc                           0100644 0001750 0001750 00000000023 12566166757 023455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_SHA512_Update.3cc                         0100644 0001750 0001750 00000000023 12566166757 023774  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CC_SHA.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CC_crypto.3cc                                0100644 0001750 0001750 00000003045 12566166757 023156  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .Dd April 5, 2007
.Dt CC_crypto 3cc
.Os
.Sh NAME
.Nm Common Crypto
.Nd libSystem digest library
.Sh DESCRIPTION
The libSystem \fBCommon Crypto\fR library implements a wide range of cryptographic
algorithms used in various Internet standards. The services provided
by this library are used by the CDSA implementations of \s-1SSL\s0, \s-1TLS\s0
and S/MIME.
.Sh OVERVIEW
\&\fBlibSystem\fR contains the Common Crypto collection of algorithms. Digest
and encryption algorithms contained in this library are optimized for speed.
The algorithms have been collected from various sources and chosen for their
performance characteristics.  Since libSystem is linked into all executables
it is preferable for applications to use these functions rather than
implementing their own versions.
.Sh NOTES
To use the digest functions with existing code which uses
the corresponding openssl functions, #define the symbol 
COMMON_DIGEST_FOR_OPENSSL in your client code (BEFORE including
.In CommonCrypto/CommonDigest.h
).
.Pp
You can *NOT* mix and match functions operating on a given data
type from the two implementations; i.e., if you do a 
.Fn CC_MD5_Init
on a 
.Ft CC_MD5_CTX
object, do not assume that you can do an openssl-style
.Fn MD5_Update
on that same context.
.Pp
The interfaces to the encryption and HMAC algorithms have a calling interface
that is different from that provided by OpenSSL.
.Sh HISTORY
The Common Crypto collection of functions started to become available in OS X 10.4 and later.
.Sh SEE ALSO
.Xr CC_MD5 3cc ,
.Xr CC_SHA 3cc ,
.Xr CCHmac 3cc ,
.Xr CCCryptor 3cc
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CCryptorCreateFromData.3cc                   0100644 0001750 0001750 00000000026 12566166757 025574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .so man3/CCCryptor.3cc                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI.3pm                                      0100644 0001750 0001750 00000477566 12566207451 021734  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI 3pm"
.TH CGI 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI \- Handle Common Gateway Interface requests and responses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CGI;
\&
\&    my $q = CGI\->new;
\&
\&    # Process an HTTP request
\&     @values  = $q\->param(\*(Aqform_field\*(Aq);
\&
\&     $fh      = $q\->upload(\*(Aqfile_field\*(Aq);
\&
\&     $riddle  = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&     %answers = $query\->cookie(\*(Aqanswers\*(Aq);
\&
\&    # Prepare various HTTP responses
\&    print $q\->header();
\&    print $q\->header(\*(Aqapplication/json\*(Aq);
\&
\&        $cookie1 = $q\->cookie(\-name=>\*(Aqriddle_name\*(Aq, \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = $q\->cookie(\-name=>\*(Aqanswers\*(Aq, \-value=>\e%answers);
\&    print $q\->header(
\&        \-type    => \*(Aqimage/gif\*(Aq,
\&        \-expires => \*(Aq+3d\*(Aq,
\&        \-cookie  => [$cookie1,$cookie2]
\&        );
\&
\&   print  $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1CGI\s0.pm is a stable, complete and mature solution for processing and preparing
\&\s-1HTTP\s0 requests and responses.  Major features including processing form
submissions, file uploads, reading and writing cookies, query string generation
and manipulation, and processing and preparing \s-1HTTP\s0 headers. Some \s-1HTML\s0
generation utilities are included as well.
.PP
\&\s-1CGI\s0.pm performs very well in in a vanilla \s-1CGI\s0.pm environment and also comes
with built-in support for mod_perl and mod_perl2 as well as FastCGI.
.PP
It has the benefit of having developed and refined over 10 years with input
from dozens of contributors and being deployed on thousands of websites.
\&\s-1CGI\s0.pm has been included in the Perl distribution since Perl 5.4, and has
become a de-facto standard.
.SS "\s-1PROGRAMMING STYLE\s0"
.IX Subsection "PROGRAMMING STYLE"
There are two styles of programming with \s-1CGI\s0.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more \s-1CGI\s0 objects and then use object methods to create
the various elements of the page.  Each \s-1CGI\s0 object starts out with the
list of named parameters that were passed to your \s-1CGI\s0 script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the \*(L"state\*(R" of
the \s-1CGI\s0 script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.
.PP
For example, using the object oriented style, here is how you create
a simple \*(L"Hello World\*(R" \s-1HTML\s0 page:
.PP
.Vb 7
\&   #!/usr/local/bin/perl \-w
\&   use CGI;                             # load CGI routines
\&   $q = CGI\->new;                        # create new CGI object
\&   print $q\->header,                    # create the HTTP header
\&         $q\->start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         $q\->h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         $q\->end_html;                  # end the HTML
.Ve
.PP
In the function-oriented style, there is one default \s-1CGI\s0 object that
you rarely deal with directly.  Instead you just call functions to
retrieve \s-1CGI\s0 parameters, create \s-1HTML\s0 tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one \s-1CGI\s0 object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the \*(L"standard\*(R" functions), and we don't
need to create the \s-1CGI\s0 object.
.PP
.Vb 6
\&   #!/usr/local/bin/perl
\&   use CGI qw/:standard/;           # load standard CGI routines
\&   print header,                    # create the HTTP header
\&         start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         end_html;                  # end the HTML
.Ve
.PP
The examples in this document mainly use the object-oriented style.
See \s-1HOW TO IMPORT FUNCTIONS\s0 for important information on
function-oriented programming in \s-1CGI\s0.pm
.SS "\s-1CALLING CGI.PM ROUTINES\s0"
.IX Subsection "CALLING CGI.PM ROUTINES"
Most \s-1CGI\s0.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:
.PP
.Vb 1
\&   print $q\->header(\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq);
.Ve
.PP
Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  \-type, \-Type, and \-TYPE are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, \s-1CGI\s0.pm assumes
dashes for the subsequent ones.
.PP
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  \fIheader()\fR happens to be one of these routines.  In this
case, the single argument is the document type.
.PP
.Vb 1
\&   print $q\->header(\*(Aqtext/html\*(Aq);
.Ve
.PP
Other such routines are documented below.
.PP
Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the \fIparam()\fR routine is used to set a \s-1CGI\s0 parameter to a
single or a multi-valued value.  The two cases are shown below:
.PP
.Vb 2
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>\*(Aqtomato\*(Aq);
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>[\*(Aqtomato\*(Aq,\*(Aqtomahto\*(Aq,\*(Aqpotato\*(Aq,\*(Aqpotahto\*(Aq]);
.Ve
.PP
A large number of routines in \s-1CGI\s0.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the \*(L"\s-1HTML\s0 shortcuts,\*(R" routines that generate \s-1HTML\s0 tags for
use in dynamically-generated pages.  \s-1HTML\s0 tags have both attributes
(the attribute=\*(L"value\*(R" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, \s-1CGI\s0.pm uses the convention of passing \s-1HTML\s0
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:
.PP
.Vb 6
\&   Code                           Generated HTML
\&   \-\-\-\-                           \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   h1()                           <h1>
\&   h1(\*(Aqsome\*(Aq,\*(Aqcontents\*(Aq);         <h1>some contents</h1>
\&   h1({\-align=>left});            <h1 align="LEFT">
\&   h1({\-align=>left},\*(Aqcontents\*(Aq); <h1 align="LEFT">contents</h1>
.Ve
.PP
\&\s-1HTML\s0 tags are described in more detail later.
.PP
Many newcomers to \s-1CGI\s0.pm are puzzled by the difference between the
calling conventions for the \s-1HTML\s0 shortcuts, which require curly braces
around the \s-1HTML\s0 tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the \s-1HTML\s0 shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:
.PP
.Vb 1
\&   print $q\->header( {\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq} );
.Ve
.PP
If you use the \fB\-w\fR switch, you will be warned that some \s-1CGI\s0.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the \-values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:
.IP "1." 4
Use another name for the argument, if one is available. 
For example, \-value is an alias for \-values.
.IP "2." 4
Change the capitalization, e.g. \-Values
.IP "3." 4
Put quotes around the argument name, e.g. '\-values'
.PP
Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard \s-1HTTP\s0
header fields by providing them as named arguments:
.PP
.Vb 4
\&  print $q\->header(\-type  =>  \*(Aqtext/html\*(Aq,
\&                   \-cost  =>  \*(AqThree smackers\*(Aq,
\&                   \-annoyance_level => \*(Aqhigh\*(Aq,
\&                   \-complaints_to   => \*(Aqbit bucket\*(Aq);
.Ve
.PP
This will produce the following nonstandard \s-1HTTP\s0 header:
.PP
.Vb 5
\&   HTTP/1.0 200 OK
\&   Cost: Three smackers
\&   Annoyance\-level: high
\&   Complaints\-to: bit bucket
\&   Content\-type: text/html
.Ve
.PP
Notice the way that underscores are translated automatically into
hyphens.  HTML-generating routines perform a different type of
translation.
.PP
This feature allows you to keep up with the rapidly changing \s-1HTTP\s0 and
\&\s-1HTML \s0\*(L"standards\*(R".
.SS "\s-1CREATING A NEW QUERY OBJECT \s0(OBJECT-ORIENTED \s-1STYLE\s0):"
.IX Subsection "CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):"
.Vb 1
\&     $query = CGI\->new;
.Ve
.PP
This will parse the input (from \s-1POST, GET\s0 and \s-1DELETE\s0 methods) and store
it into a perl5 object called \f(CW$query\fR.
.PP
Any filehandles from file uploads will have their position reset to 
the beginning of the file.
.SS "\s-1CREATING A NEW QUERY OBJECT FROM AN INPUT FILE\s0"
.IX Subsection "CREATING A NEW QUERY OBJECT FROM AN INPUT FILE"
.Vb 1
\&     $query = CGI\->new(INPUTFILE);
.Ve
.PP
If you provide a file handle to the \fInew()\fR method, it will read
parameters from the file (or \s-1STDIN,\s0 or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited TAG=VALUE pairs will work).  Conveniently, this type
of file is created by the \fIsave()\fR method (see below).  Multiple records
can be saved and restored.
.PP
Perl purists will be pleased to know that this syntax accepts
references to file handles, or even references to filehandle globs,
which is the \*(L"official\*(R" way to pass a filehandle:
.PP
.Vb 1
\&    $query = CGI\->new(\e*STDIN);
.Ve
.PP
You can also initialize the \s-1CGI\s0 object with a FileHandle or IO::File
object.
.PP
If you are using the function-oriented interface and want to
initialize \s-1CGI\s0 state from a file handle, the way to do this is with
\&\fB\f(BIrestore_parameters()\fB\fR.  This will (re)initialize the
default \s-1CGI\s0 object from the indicated file handle.
.PP
.Vb 3
\&    open (IN,"test.in") || die;
\&    restore_parameters(IN);
\&    close IN;
.Ve
.PP
You can also initialize the query object from a hash
reference:
.PP
.Vb 4
\&    $query = CGI\->new( {\*(Aqdinosaur\*(Aq=>\*(Aqbarney\*(Aq,
\&                       \*(Aqsong\*(Aq=>\*(AqI love you\*(Aq,
\&                       \*(Aqfriends\*(Aq=>[qw/Jessica George Nancy/]}
\&                    );
.Ve
.PP
or from a properly formatted, URL-escaped query string:
.PP
.Vb 1
\&    $query = CGI\->new(\*(Aqdinosaur=barney&color=purple\*(Aq);
.Ve
.PP
or from a previously existing \s-1CGI\s0 object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):
.PP
.Vb 2
\&    $old_query = CGI\->new;
\&    $new_query = CGI\->new($old_query);
.Ve
.PP
To create an empty query, initialize it from an empty string or hash:
.PP
.Vb 1
\&   $empty_query = CGI\->new("");
\&
\&       \-or\-
\&
\&   $empty_query = CGI\->new({});
.Ve
.SS "\s-1FETCHING A LIST OF KEYWORDS FROM THE QUERY:\s0"
.IX Subsection "FETCHING A LIST OF KEYWORDS FROM THE QUERY:"
.Vb 1
\&     @keywords = $query\->keywords
.Ve
.PP
If the script was invoked as the result of an <\s-1ISINDEX\s0> search, the
parsed keywords can be obtained as an array using the \fIkeywords()\fR method.
.SS "\s-1FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:\s0"
.IX Subsection "FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:"
.Vb 1
\&     @names = $query\->param
.Ve
.PP
If the script was invoked with a parameter list
(e.g. \*(L"name1=value1&name2=value2&name3=value3\*(R"), the \fIparam()\fR method
will return the parameter names as a list.  If the script was invoked
as an <\s-1ISINDEX\s0> script and contains a string without ampersands
(e.g. \*(L"value1+value2+value3\*(R") , there will be a single parameter named
\&\*(L"keywords\*(R" containing the \*(L"+\*(R"\-delimited keywords.
.PP
\&\s-1NOTE:\s0 As of version 1.5, the array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the 
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).
.SS "\s-1FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:\s0"
.IX Subsection "FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:"
.Vb 1
\&    @values = $query\->param(\*(Aqfoo\*(Aq);
\&
\&              \-or\-
\&
\&    $value = $query\->param(\*(Aqfoo\*(Aq);
.Ve
.PP
Pass the \fIparam()\fR method a single argument to fetch the value of the
named parameter. If the parameter is multivalued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.
.PP
If a value is not given in the query string, as in the queries
\&\*(L"name1=&name2=\*(R", it will be returned as an empty string.
.PP
If the parameter does not exist at all, then \fIparam()\fR will return undef
in a scalar context, and the empty list in a list context.
.SS "\s-1SETTING THE VALUE\s0(S) \s-1OF A NAMED PARAMETER:\s0"
.IX Subsection "SETTING THE VALUE(S) OF A NAMED PARAMETER:"
.Vb 1
\&    $query\->param(\*(Aqfoo\*(Aq,\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq);
.Ve
.PP
This sets the value for the named parameter 'foo' to an array of
values.  This is one way to change the value of a field \s-1AFTER\s0
the script has been invoked once before.  (Another way is with
the \-override parameter accepted by all methods that generate
form elements.)
.PP
\&\fIparam()\fR also recognizes a named parameter style of calling described
in more detail later:
.PP
.Vb 1
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq]);
\&
\&                              \-or\-
\&
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-value=>\*(Aqthe value\*(Aq);
.Ve
.SS "\s-1APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:\s0"
.IX Subsection "APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:"
.Vb 1
\&   $query\->append(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqyet\*(Aq,\*(Aqmore\*(Aq,\*(Aqvalues\*(Aq]);
.Ve
.PP
This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.
.SS "\s-1IMPORTING ALL PARAMETERS INTO A NAMESPACE:\s0"
.IX Subsection "IMPORTING ALL PARAMETERS INTO A NAMESPACE:"
.Vb 1
\&   $query\->import_names(\*(AqR\*(Aq);
.Ve
.PP
This creates a series of variables in the 'R' namespace.  For example,
\&\f(CW$R::foo\fR, \f(CW@R:foo\fR.  For keyword lists, a variable \f(CW@R::keywords\fR will appear.
If no namespace is given, this method will assume 'Q'.
\&\s-1WARNING: \s0 don't import anything into 'main'; this is a major security
risk!!!!
.PP
\&\s-1NOTE 1:\s0 Variable names are transformed as necessary into legal Perl
variable names.  All non-legal characters are transformed into
underscores.  If you need to keep the original names, you should use
the \fIparam()\fR method instead to access \s-1CGI\s0 variables by name.
.PP
\&\s-1NOTE 2:\s0 In older versions, this method was called \fB\f(BIimport()\fB\fR.  As of version 2.20, 
this name has been removed completely to avoid conflict with the built-in
Perl module \fBimport\fR operator.
.SS "\s-1DELETING A PARAMETER COMPLETELY:\s0"
.IX Subsection "DELETING A PARAMETER COMPLETELY:"
.Vb 1
\&    $query\->delete(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq);
.Ve
.PP
This completely clears a list of parameters.  It sometimes useful for
resetting parameters that you don't want passed down between script
invocations.
.PP
If you are using the function call interface, use \*(L"\fIDelete()\fR\*(R" instead
to avoid conflicts with Perl's built-in delete operator.
.SS "\s-1DELETING ALL PARAMETERS:\s0"
.IX Subsection "DELETING ALL PARAMETERS:"
.Vb 1
\&   $query\->delete_all();
.Ve
.PP
This clears the \s-1CGI\s0 object completely.  It might be useful to ensure
that all the defaults are taken when you create a fill-out form.
.PP
Use \fIDelete_all()\fR instead if you are using the function call interface.
.SS "\s-1HANDLING\s0 NON-URLENCODED \s-1ARGUMENTS\s0"
.IX Subsection "HANDLING NON-URLENCODED ARGUMENTS"
If POSTed data is not of type application/x\-www\-form\-urlencoded or
multipart/form\-data, then the POSTed data will not be processed, but
instead be returned as-is in a parameter named \s-1POSTDATA. \s0 To retrieve
it, use code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPOSTDATA\*(Aq);
.Ve
.PP
Likewise if PUTed data can be retrieved with code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPUTDATA\*(Aq);
.Ve
.PP
(If you don't know what the preceding means, don't worry about it.  It
only affects people trying to use \s-1CGI\s0 for \s-1XML\s0 processing and other
specialized tasks.)
.SS "\s-1DIRECT ACCESS TO THE PARAMETER LIST:\s0"
.IX Subsection "DIRECT ACCESS TO THE PARAMETER LIST:"
.Vb 2
\&   $q\->param_fetch(\*(Aqaddress\*(Aq)\->[1] = \*(Aq1313 Mockingbird Lane\*(Aq;
\&   unshift @{$q\->param_fetch(\-name=>\*(Aqaddress\*(Aq)},\*(AqGeorge Munster\*(Aq;
.Ve
.PP
If you need access to the parameter list in a way that isn't covered
by the methods given in the previous sections, you can obtain a direct 
reference to it by
calling the \fB\f(BIparam_fetch()\fB\fR method with the name of the parameter.  This
will return an array reference to the named parameter, which you then
can manipulate in any way you like.
.PP
You can also use a named argument style using the \fB\-name\fR argument.
.SS "\s-1FETCHING THE PARAMETER LIST AS A HASH:\s0"
.IX Subsection "FETCHING THE PARAMETER LIST AS A HASH:"
.Vb 4
\&    $params = $q\->Vars;
\&    print $params\->{\*(Aqaddress\*(Aq};
\&    @foo = split("\e0",$params\->{\*(Aqfoo\*(Aq});
\&    %params = $q\->Vars;
\&
\&    use CGI \*(Aq:cgi\-lib\*(Aq;
\&    $params = Vars;
.Ve
.PP
Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the \s-1CGI\s0 parameters, and the values are the
parameters' values.  The \fIVars()\fR method does this.  Called in a scalar
context, it returns the parameter list as a tied hash reference.
Changing a key changes the value of the parameter in the underlying
\&\s-1CGI\s0 parameter list.  Called in a list context, it returns the
parameter list as an ordinary hash.  This allows you to read the
contents of the parameter list, but not to change it.
.PP
When using this, the thing you must watch out for are multivalued \s-1CGI\s0
parameters.  Because a hash cannot distinguish between scalar and
list context, multivalued parameters will be returned as a packed
string, separated by the \*(L"\e0\*(R" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi\-lib.pl
module for Perl version 4.
.PP
If you wish to use \fIVars()\fR as a function, import the \fI:cgi\-lib\fR set of
function calls (also see the section on CGI-LIB compatibility).
.SS "\s-1SAVING THE STATE OF THE SCRIPT TO A FILE:\s0"
.IX Subsection "SAVING THE STATE OF THE SCRIPT TO A FILE:"
.Vb 1
\&    $query\->save(\e*FILEHANDLE)
.Ve
.PP
This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the \fInew()\fR method.  Note that the filehandle can be a file, a pipe,
or whatever!
.PP
The format of the saved file is:
.PP
.Vb 5
\&        NAME1=VALUE1
\&        NAME1=VALUE1\*(Aq
\&        NAME2=VALUE2
\&        NAME3=VALUE3
\&        =
.Ve
.PP
Both name and value are \s-1URL\s0 escaped.  Multi-valued \s-1CGI\s0 parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to \fBnew\fR.  You can do this across several
sessions by opening the file in append mode, allowing you to create
primitive guest books, or to keep a history of users' queries.  Here's
a short example of creating multiple session records:
.PP
.Vb 1
\&   use CGI;
\&
\&   open (OUT,\*(Aq>>\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   $records = 5;
\&   for (0..$records) {
\&       my $q = CGI\->new;
\&       $q\->param(\-name=>\*(Aqcounter\*(Aq,\-value=>$_);
\&       $q\->save(\e*OUT);
\&   }
\&   close OUT;
\&
\&   # reopen for reading
\&   open (IN,\*(Aq<\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   while (!eof(IN)) {
\&       my $q = CGI\->new(\e*IN);
\&       print $q\->param(\*(Aqcounter\*(Aq),"\en";
\&   }
.Ve
.PP
The file format used for save/restore is identical to that used by the
Whitehead Genome Center's data exchange format \*(L"Boulderio\*(R", and can be
manipulated and even databased using Boulderio utilities.  See
.PP
.Vb 1
\&  http://stein.cshl.org/boulder/
.Ve
.PP
for further details.
.PP
If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is \fB\f(BIsave_parameters()\fB\fR.
.SS "\s-1RETRIEVING CGI ERRORS\s0"
.IX Subsection "RETRIEVING CGI ERRORS"
Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, \s-1CGI\s0 will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the \fI\fIcgi_error()\fI\fR function.
The error messages are formatted as \s-1HTTP\s0 status codes. You can either
incorporate the error text into an \s-1HTML\s0 page, or use it as the value
of the \s-1HTTP\s0 status:
.PP
.Vb 8
\&    my $error = $q\->cgi_error;
\&    if ($error) {
\&        print $q\->header(\-status=>$error),
\&              $q\->start_html(\*(AqProblems\*(Aq),
\&              $q\->h2(\*(AqRequest not processed\*(Aq),
\&              $q\->strong($error);
\&        exit 0;
\&    }
.Ve
.PP
When using the function-oriented interface (see the next section),
errors may only occur the first time you call \fI\fIparam()\fI\fR. Be ready
for this!
.SS "\s-1USING THE\s0 FUNCTION-ORIENTED \s-1INTERFACE\s0"
.IX Subsection "USING THE FUNCTION-ORIENTED INTERFACE"
To use the function-oriented interface, you must specify which \s-1CGI\s0.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.
.PP
.Vb 1
\&   use CGI <list of methods>;
.Ve
.PP
The listed methods will be imported into the current package; you can
call them directly without creating a \s-1CGI\s0 object first.  This example
shows how to import the \fB\f(BIparam()\fB\fR and \fB\f(BIheader()\fB\fR
methods, and then use them directly:
.PP
.Vb 3
\&   use CGI \*(Aqparam\*(Aq,\*(Aqheader\*(Aq;
\&   print header(\*(Aqtext/plain\*(Aq);
\&   $zipcode = param(\*(Aqzipcode\*(Aq);
.Ve
.PP
More frequently, you'll import common sets of functions by referring
to the groups by name.  All function sets are preceded with a \*(L":\*(R"
character as in \*(L":html3\*(R" (for tags defined in the \s-1HTML 3\s0 standard).
.PP
Here is a list of the function sets you can import:
.IP "\fB:cgi\fR" 4
.IX Item ":cgi"
Import all CGI-handling methods, such as \fB\f(BIparam()\fB\fR, \fB\f(BIpath_info()\fB\fR
and the like.
.IP "\fB:form\fR" 4
.IX Item ":form"
Import all fill-out form generating methods, such as \fB\f(BItextfield()\fB\fR.
.IP "\fB:html2\fR" 4
.IX Item ":html2"
Import all methods that generate \s-1HTML 2.0\s0 standard elements.
.IP "\fB:html3\fR" 4
.IX Item ":html3"
Import all methods that generate \s-1HTML 3.0\s0 elements (such as
<table>, <super> and <sub>).
.IP "\fB:html4\fR" 4
.IX Item ":html4"
Import all methods that generate \s-1HTML 4\s0 elements (such as
<abbrev>, <acronym> and <thead>).
.IP "\fB:netscape\fR" 4
.IX Item ":netscape"
Import the <blink>, <fontsize> and <center> tags.
.IP "\fB:html\fR" 4
.IX Item ":html"
Import all HTML-generating shortcuts (i.e. 'html2', 'html3', 'html4' and 'netscape')
.IP "\fB:standard\fR" 4
.IX Item ":standard"
Import \*(L"standard\*(R" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.
.IP "\fB:all\fR" 4
.IX Item ":all"
Import all the available methods.  For the full list, see the \s-1CGI\s0.pm
code, where the variable \f(CW%EXPORT_TAGS\fR is defined.
.PP
If you import a function name that is not part of \s-1CGI\s0.pm, the module
will treat it as a new \s-1HTML\s0 tag and generate the appropriate
subroutine.  You can then use it like any other \s-1HTML\s0 tag.  This is to
provide for the rapidly-evolving \s-1HTML \s0\*(L"standard.\*(R"  For example, say
Microsoft comes out with a new tag called <gradient> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of \s-1CGI\s0.pm
to start using it immediately:
.PP
.Vb 2
\&   use CGI qw/:standard :html3 gradient/;
\&   print gradient({\-start=>\*(Aqred\*(Aq,\-end=>\*(Aqblue\*(Aq});
.Ve
.PP
Note that in the interests of execution speed \s-1CGI\s0.pm does \fBnot\fR use
the standard Exporter syntax for specifying load symbols.  This may
change in the future.
.PP
If you import any of the state-maintaining \s-1CGI\s0 or form-generating
methods, a default \s-1CGI\s0 object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes \fB\f(BIparam()\fB\fR, \fB\f(BItextfield()\fB\fR,
\&\fB\f(BIsubmit()\fB\fR and the like.  (If you need direct access to the \s-1CGI\s0
object, you can find it in the global variable \fB\f(CB$CGI::Q\fB\fR).  By
importing \s-1CGI\s0.pm methods, you can create visually elegant scripts:
.PP
.Vb 10
\&   use CGI qw/:standard/;
\&   print 
\&       header,
\&       start_html(\*(AqSimple Script\*(Aq),
\&       h1(\*(AqSimple Script\*(Aq),
\&       start_form,
\&       "What\*(Aqs your name? ",textfield(\*(Aqname\*(Aq),p,
\&       "What\*(Aqs the combination?",
\&       checkbox_group(\-name=>\*(Aqwords\*(Aq,
\&                      \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                      \-defaults=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq]),p,
\&       "What\*(Aqs your favorite color?",
\&       popup_menu(\-name=>\*(Aqcolor\*(Aq,
\&                  \-values=>[\*(Aqred\*(Aq,\*(Aqgreen\*(Aq,\*(Aqblue\*(Aq,\*(Aqchartreuse\*(Aq]),p,
\&       submit,
\&       end_form,
\&       hr,"\en";
\&
\&    if (param) {
\&       print 
\&           "Your name is ",em(param(\*(Aqname\*(Aq)),p,
\&           "The keywords are: ",em(join(", ",param(\*(Aqwords\*(Aq))),p,
\&           "Your favorite color is ",em(param(\*(Aqcolor\*(Aq)),".\en";
\&    }
\&    print end_html;
.Ve
.SS "\s-1PRAGMAS\s0"
.IX Subsection "PRAGMAS"
In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that \s-1CGI\s0.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same \fIuse()\fR line.  For example, the following use statement imports the
standard set of functions and enables debugging mode (pragma
\&\-debug):
.PP
.Vb 1
\&   use CGI qw/:standard \-debug/;
.Ve
.PP
The current list of pragmas is as follows:
.IP "\-any" 4
.IX Item "-any"
When you \fIuse \s-1CGI\s0 \-any\fR, then any method that the query object
doesn't recognize will be interpreted as a new \s-1HTML\s0 tag.  This allows
you to support the next \fIad hoc\fR \s-1HTML\s0
extension.  This lets you go wild with new and unsupported tags:
.Sp
.Vb 3
\&   use CGI qw(\-any);
\&   $q=CGI\->new;
\&   print $q\->gradient({speed=>\*(Aqfast\*(Aq,start=>\*(Aqred\*(Aq,end=>\*(Aqblue\*(Aq});
.Ve
.Sp
Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an \s-1HTML\s0 tag, use it with care or not at
all.
.IP "\-compile" 4
.IX Item "-compile"
This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcolm Beattie's Perl compiler.  Use
it in conjunction with the methods or method families you plan to use.
.Sp
.Vb 1
\&   use CGI qw(\-compile :standard :html3);
.Ve
.Sp
or even
.Sp
.Vb 1
\&   use CGI qw(\-compile :all);
.Ve
.Sp
Note that using the \-compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
\&\fIcompile()\fR method instead:
.Sp
.Vb 2
\&   use CGI();
\&   CGI\->compile();
.Ve
.Sp
This is particularly useful in a mod_perl environment, in which you
might want to precompile all \s-1CGI\s0 routines in a startup script, and
then import the functions individually in each mod_perl script.
.IP "\-nosticky" 4
.IX Item "-nosticky"
By default the \s-1CGI\s0 module implements a state-preserving behavior
called \*(L"sticky\*(R" fields.  The way this works is that if you are
regenerating a form, the methods that generate the form field values
will interrogate \fIparam()\fR to see if similarly-named parameters are
present in the query string. If they find a like-named parameter, they
will use it to set their default values.
.Sp
Sometimes this isn't what you want.  The \fB\-nosticky\fR pragma prevents
this behavior.  You can also selectively change the sticky behavior in
each element that you generate.
.IP "\-tabindex" 4
.IX Item "-tabindex"
Automatically add tab index attributes to each form field. With this
option turned off, you can still add tab indexes manually by passing a
\&\-tabindex option to each field-generating method.
.IP "\-no_undef_params" 4
.IX Item "-no_undef_params"
This keeps \s-1CGI\s0.pm from including undef params in the parameter list.
.IP "\-no_xhtml" 4
.IX Item "-no_xhtml"
By default, \s-1CGI\s0.pm versions 2.69 and higher emit \s-1XHTML
\&\s0(http://www.w3.org/TR/xhtml1/).  The \-no_xhtml pragma disables this
feature.  Thanks to Michalis Kabrianis <kabrianis@hellug.gr> for this
feature.
.Sp
If \fIstart_html()\fR's \-dtd parameter specifies an \s-1HTML 2.0, 
3.2, 4.0\s0 or 4.01 \s-1DTD, 
XHTML\s0 will automatically be disabled without needing to use this 
pragma.
.IP "\-utf8" 4
.IX Item "-utf8"
This makes \s-1CGI\s0.pm treat all parameters as \s-1UTF\-8\s0 strings. Use this with
care, as it will interfere with the processing of binary uploads. It
is better to manually select which fields are expected to return utf\-8
strings and convert them using code like this:
.Sp
.Vb 2
\& use Encode;
\& my $arg = decode utf8=>param(\*(Aqfoo\*(Aq);
.Ve
.IP "\-nph" 4
.IX Item "-nph"
This makes \s-1CGI\s0.pm produce a header appropriate for an \s-1NPH \s0(no
parsed header) script.  You may need to do other things as well
to tell the server that the script is \s-1NPH. \s0 See the discussion
of \s-1NPH\s0 scripts below.
.IP "\-newstyle_urls" 4
.IX Item "-newstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
semicolons rather than ampersands.  For example:
.Sp
.Vb 1
\&   ?name=fred;age=24;favorite_color=3
.Ve
.Sp
Semicolon-delimited query strings are always accepted, and will be emitted by
\&\fIself_url()\fR and \fIquery_string()\fR. newstyle_urls became the default in version
2.64.
.IP "\-oldstyle_urls" 4
.IX Item "-oldstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
ampersands rather than semicolons.  This is no longer the default.
.IP "\-autoload" 4
.IX Item "-autoload"
This overrides the autoloader so that any function in your program
that is not recognized is referred to \s-1CGI\s0.pm for possible evaluation.
This allows you to use all the \s-1CGI\s0.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  \fIWarning:\fR when
\&\fI\-autoload\fR is in effect, you cannot use \*(L"poetry mode\*(R"
(functions without the parenthesis).  Use \fI\fIhr()\fI\fR rather
than \fIhr\fR, or add something like \fIuse subs qw/hr p header/\fR 
to the top of your script.
.IP "\-no_debug" 4
.IX Item "-no_debug"
This turns off the command-line processing features.  If you want to
run a \s-1CGI\s0.pm script from the command line to produce \s-1HTML,\s0 and you
don't want it to read \s-1CGI\s0 parameters from the command line or \s-1STDIN,\s0
then use this pragma:
.Sp
.Vb 1
\&   use CGI qw(\-no_debug :standard);
.Ve
.IP "\-debug" 4
.IX Item "-debug"
This turns on full debugging.  In addition to reading \s-1CGI\s0 arguments
from the command-line processing, \s-1CGI\s0.pm will pause and try to read
arguments from \s-1STDIN,\s0 producing the message \*(L"(offline mode: enter
name=value pairs on standard input)\*(R" features.
.Sp
See the section on debugging for more details.
.IP "\-private_tempfiles" 4
.IX Item "-private_tempfiles"
\&\s-1CGI\s0.pm can process uploaded file. Ordinarily it spools the uploaded
file to a temporary directory, then deletes the file when done.
However, this opens the risk of eavesdropping as described in the file
upload section.  Another \s-1CGI\s0 script author could peek at this data
during the upload, even if it is confidential information. On Unix
systems, the \-private_tempfiles pragma will cause the temporary file
to be unlinked as soon as it is opened and before any data is written
into it, reducing, but not eliminating the risk of eavesdropping
(there is still a potential race condition).  To make life harder for
the attacker, the program chooses tempfile names by calculating a 32
bit checksum of the incoming \s-1HTTP\s0 headers.
.Sp
To ensure that the temporary file cannot be read by other \s-1CGI\s0 scripts,
use suEXEC or a \s-1CGI\s0 wrapper program to run your script.  The temporary
file is created with mode 0600 (neither world nor group readable).
.Sp
The temporary directory is selected using the following algorithm:
.Sp
.Vb 1
\&    1. if $CGITempFile::TMPDIRECTORY is already set, use that
\&
\&    2. if the environment variable TMPDIR exists, use the location
\&    indicated.
\&
\&    3. Otherwise try the locations /usr/tmp, /var/tmp, C:\etemp,
\&    /tmp, /temp, ::Temporary Items, and \eWWW_ROOT.
.Ve
.Sp
Each of these locations is checked that it is a directory and is
writable.  If not, the algorithm tries the next choice.
.SS "\s-1SPECIAL FORMS FOR IMPORTING\s0 HTML-TAG \s-1FUNCTIONS\s0"
.IX Subsection "SPECIAL FORMS FOR IMPORTING HTML-TAG FUNCTIONS"
Many of the methods generate \s-1HTML\s0 tags.  As described below, tag
functions automatically generate both the opening and closing tags.
For example:
.PP
.Vb 1
\&  print h1(\*(AqLevel 1 Header\*(Aq);
.Ve
.PP
produces
.PP
.Vb 1
\&  <h1>Level 1 Header</h1>
.Ve
.PP
There will be some times when you want to produce the start and end
tags yourself.  In this case, you can use the form start_\fItag_name\fR
and end_\fItag_name\fR, as in:
.PP
.Vb 1
\&  print start_h1,\*(AqLevel 1 Header\*(Aq,end_h1;
.Ve
.PP
With a few exceptions (described below), start_\fItag_name\fR and
end_\fItag_name\fR functions are not generated automatically when you
\&\fIuse \s-1CGI\s0\fR.  However, you can specify the tags you want to generate
\&\fIstart/end\fR functions for by putting an asterisk in front of their
name, or, alternatively, requesting either "start_\fItag_name\fR\*(L" or
\&\*(R"end_\fItag_name\fR" in the import list.
.PP
Example:
.PP
.Vb 1
\&  use CGI qw/:standard *table start_ul/;
.Ve
.PP
In this example, the following functions are generated in addition to
the standard ones:
.IP "1. \fIstart_table()\fR (generates a <table> tag)" 4
.IX Item "1. start_table() (generates a <table> tag)"
.PD 0
.IP "2. \fIend_table()\fR (generates a </table> tag)" 4
.IX Item "2. end_table() (generates a </table> tag)"
.IP "3. \fIstart_ul()\fR (generates a <ul> tag)" 4
.IX Item "3. start_ul() (generates a <ul> tag)"
.IP "4. \fIend_ul()\fR (generates a </ul> tag)" 4
.IX Item "4. end_ul() (generates a </ul> tag)"
.PD
.SH "GENERATING DYNAMIC DOCUMENTS"
.IX Header "GENERATING DYNAMIC DOCUMENTS"
Most of \s-1CGI\s0.pm's functions deal with creating documents on the fly.
Generally you will produce the \s-1HTTP\s0 header first, followed by the
document itself.  \s-1CGI\s0.pm provides functions for generating \s-1HTTP\s0
headers of various types as well as for generating \s-1HTML. \s0 For creating
\&\s-1GIF\s0 images, see the \s-1GD\s0.pm module.
.PP
Each of these functions produces a fragment of \s-1HTML\s0 or \s-1HTTP\s0 which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.
.SS "\s-1CREATING A STANDARD HTTP HEADER:\s0"
.IX Subsection "CREATING A STANDARD HTTP HEADER:"
Normally the first thing you will do in any \s-1CGI\s0 script is print out an
\&\s-1HTTP\s0 header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
.PP
.Vb 1
\&        print header;
\&
\&             \-or\-
\&
\&        print header(\*(Aqimage/gif\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\*(Aqtext/html\*(Aq,\*(Aq204 No response\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\-type=>\*(Aqimage/gif\*(Aq,
\&                             \-nph=>1,
\&                             \-status=>\*(Aq402 Payment required\*(Aq,
\&                             \-expires=>\*(Aq+3d\*(Aq,
\&                             \-cookie=>$cookie,
\&                             \-charset=>\*(Aqutf\-7\*(Aq,
\&                             \-attachment=>\*(Aqfoo.gif\*(Aq,
\&                             \-Cost=>\*(Aq$2.00\*(Aq);
.Ve
.PP
\&\fIheader()\fR returns the Content-type: header.  You can provide your own
\&\s-1MIME\s0 type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, \*(L"No response\*(R" to create a
script that tells the browser to do nothing at all. Note that \s-1RFC 2616\s0 expects
the human-readable phase to be there as well as the numeric status code.
.PP
The last example shows the named argument style for passing arguments
to the \s-1CGI\s0 methods using named parameters.  Recognized parameters are
\&\fB\-type\fR, \fB\-status\fR, \fB\-expires\fR, and \fB\-cookie\fR.  Any other named
parameters will be stripped of their initial hyphens and turned into
header fields, allowing you to specify any \s-1HTTP\s0 header you desire.
Internal underscores will be turned into hyphens:
.PP
.Vb 1
\&    print header(\-Content_length=>3002);
.Ve
.PP
Most browsers will not cache the output from \s-1CGI\s0 scripts.  Every time
the browser reloads the page, the script is invoked anew.  You can
change this behavior with the \fB\-expires\fR parameter.  When you specify
an absolute or relative expiration interval with this parameter, some
browsers and proxy servers will cache the script's output until the
indicated expiration date.  The following forms are all valid for the
\&\-expires field:
.PP
.Vb 8
\&        +30s                              30 seconds from now
\&        +10m                              ten minutes from now
\&        +1h                               one hour from now
\&        \-1d                               yesterday (i.e. "ASAP!")
\&        now                               immediately
\&        +3M                               in three months
\&        +10y                              in ten years time
\&        Thursday, 25\-Apr\-1999 00:40:33 GMT  at the indicated time & date
.Ve
.PP
The \fB\-cookie\fR parameter generates a header that tells the browser to provide
a \*(L"magic cookie\*(R" during all subsequent transactions with your script.
Some cookies have a special format that includes interesting attributes
such as expiration time.  Use the \fIcookie()\fR method to create and retrieve
session cookies.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH \s0(no-parse-header) script.  This is important
to use with certain servers that expect all their scripts to be \s-1NPH.\s0
.PP
The \fB\-charset\fR parameter can be used to control the character set
sent to the browser.  If not provided, defaults to \s-1ISO\-8859\-1. \s0 As a
side effect, this sets the \fIcharset()\fR method as well.
.PP
The \fB\-attachment\fR parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the \fB\-type\fR to \*(L"application/octet\-stream\*(R".
.PP
The \fB\-p3p\fR parameter will add a P3P tag to the outgoing header.  The
parameter can be an arrayref or a space-delimited string of P3P tags.
For example:
.PP
.Vb 2
\&   print header(\-p3p=>[qw(CAO DSP LAW CURa)]);
\&   print header(\-p3p=>\*(AqCAO DSP LAW CURa\*(Aq);
.Ve
.PP
In either case, the outgoing header will be formatted as:
.PP
.Vb 1
\&  P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"
.Ve
.PP
\&\s-1CGI\s0.pm will accept valid multi-line headers when each line is separated with a
\&\s-1CRLF\s0 value (\*(L"\er\en\*(R" on most platforms) followed by at least one space. For example:
.PP
.Vb 1
\&    print header( \-ingredients => "ham\er\en\eseggs\er\en\esbacon" );
.Ve
.PP
Invalid multi-line header input will trigger in an exception. When multi-line headers
are received, \s-1CGI\s0.pm will always output them back as a single line, according to the
folding rules of \s-1RFC 2616:\s0 the newlines will be removed, while the white space remains.
.SS "\s-1GENERATING A REDIRECTION HEADER\s0"
.IX Subsection "GENERATING A REDIRECTION HEADER"
.Vb 1
\&   print $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.PP
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a \s-1URL\s0 based on the
time of day or the identity of the user.
.PP
The \fIredirect()\fR method redirects the browser to a different \s-1URL. \s0 If
you use redirection like this, you should \fBnot\fR print out a header as
well.
.PP
You should always use full URLs (including the http: or ftp: part) in
redirection requests.  Relative URLs will not work correctly.
.PP
You can also use named arguments:
.PP
.Vb 4
\&    print $q\->redirect(
\&        \-uri=>\*(Aqhttp://somewhere.else/in/movie/land\*(Aq,
\&            \-nph=>1,
\&         \-status=>\*(Aq301 Moved Permanently\*(Aq);
.Ve
.PP
All names arguments recognized by \fIheader()\fR are also recognized by
\&\fIredirect()\fR. However, most \s-1HTTP\s0 headers, including those generated by
\&\-cookie and \-target, are ignored by the browser.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH \s0(no-parse-header) script.  This is important
to use with certain servers, such as Microsoft \s-1IIS,\s0 which
expect all their scripts to be \s-1NPH.\s0
.PP
The \fB\-status\fR parameter will set the status of the redirect.  \s-1HTTP\s0
defines three different possible redirection status codes:
.PP
.Vb 3
\&     301 Moved Permanently
\&     302 Found
\&     303 See Other
.Ve
.PP
The default if not specified is 302, which means \*(L"moved temporarily.\*(R"
You may change the status to another status code if you wish.  Be
advised that changing the status to anything other than 301, 302 or
303 will probably break redirection.
.PP
Note that the human-readable phrase is also expected to be present to conform
with \s-1RFC 2616,\s0 section 6.1.
.SS "\s-1CREATING THE HTML DOCUMENT HEADER\s0"
.IX Subsection "CREATING THE HTML DOCUMENT HEADER"
.Vb 8
\&   print start_html(\-title=>\*(AqSecrets of the Pyramids\*(Aq,
\&                            \-author=>\*(Aqfred@capricorn.org\*(Aq,
\&                            \-base=>\*(Aqtrue\*(Aq,
\&                            \-target=>\*(Aq_blank\*(Aq,
\&                            \-meta=>{\*(Aqkeywords\*(Aq=>\*(Aqpharaoh secret mummy\*(Aq,
\&                                    \*(Aqcopyright\*(Aq=>\*(Aqcopyright 1996 King Tut\*(Aq},
\&                            \-style=>{\*(Aqsrc\*(Aq=>\*(Aq/styles/style1.css\*(Aq},
\&                            \-BGCOLOR=>\*(Aqblue\*(Aq);
.Ve
.PP
The \fIstart_html()\fR routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.
.PP
This method returns a canned \s-1HTML\s0 header and the opening <body> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are \-title, \-author, \-base, \-xbase, \-dtd, \-lang and \-target
(see below for the explanation).  Any additional parameters you
provide, such as the unofficial \s-1BGCOLOR\s0 attribute, are added
to the <body> tag.  Additional parameters must be proceeded by a
hyphen.
.PP
The argument \fB\-xbase\fR allows you to provide an \s-1HREF\s0 for the <base> tag
different from the current location, as in
.PP
.Vb 1
\&    \-xbase=>"http://home.mcom.com/"
.Ve
.PP
All relative links will be interpreted relative to this tag.
.PP
The argument \fB\-target\fR allows you to provide a default target frame
for all the links and fill-out forms on the page.  \fBThis is a
non-standard \s-1HTTP\s0 feature which only works with some browsers!\fR
.PP
.Vb 1
\&    \-target=>"answer_window"
.Ve
.PP
All relative links will be interpreted relative to this tag.
You add arbitrary meta information to the header with the \fB\-meta\fR
argument.  This argument expects a reference to a hash
containing name/value pairs of meta information.  These will be turned
into a series of header <meta> tags that look something like this:
.PP
.Vb 2
\&    <meta name="keywords" content="pharaoh secret mummy">
\&    <meta name="description" content="copyright 1996 King Tut">
.Ve
.PP
To create an HTTP-EQUIV type of <meta> tag, use \fB\-head\fR, described
below.
.PP
The \fB\-style\fR argument is used to incorporate cascading stylesheets
into your code.  See the section on \s-1CASCADING STYLESHEETS\s0 for more
information.
.PP
The \fB\-lang\fR argument is used to incorporate a language attribute into
the <html> tag.  For example:
.PP
.Vb 1
\&    print $q\->start_html(\-lang=>\*(Aqfr\-CA\*(Aq);
.Ve
.PP
The default if not specified is \*(L"en-US\*(R" for \s-1US\s0 English, unless the 
\&\-dtd parameter specifies an \s-1HTML 2.0\s0 or 3.2 \s-1DTD,\s0 in which case the
lang attribute is left off.  You can force the lang attribute to left
off in other cases by passing an empty string (\-lang=>'').
.PP
The \fB\-encoding\fR argument can be used to specify the character set for
\&\s-1XHTML. \s0 It defaults to iso\-8859\-1 if not specified.
.PP
The \fB\-dtd\fR argument can be used to specify a public \s-1DTD\s0 identifier string. For example:
.PP
.Vb 1
\&    \-dtd => \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq)
.Ve
.PP
Alternatively, it can take public and system \s-1DTD\s0 identifiers as an array:
.PP
.Vb 1
\&    dtd => [ \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq, \*(Aqhttp://www.w3.org/TR/html4/loose.dtd\*(Aq ]
.Ve
.PP
For the public \s-1DTD\s0 identifier to be considered, it must be valid. Otherwise it
will be replaced by the default \s-1DTD.\s0 If the public \s-1DTD\s0 contains '\s-1XHTML\s0', \s-1CGI\s0.pm
will emit \s-1XML.\s0
.PP
The \fB\-declare_xml\fR argument, when used in conjunction with \s-1XHTML,\s0
will put a <?xml> declaration at the top of the \s-1HTML\s0 header. The sole
purpose of this declaration is to declare the character set
encoding. In the absence of \-declare_xml, the output \s-1HTML\s0 will contain
a <meta> tag that specifies the encoding, allowing the \s-1HTML\s0 to pass
most validators.  The default for \-declare_xml is false.
.PP
You can place other arbitrary \s-1HTML\s0 elements to the <head> section with the
\&\fB\-head\fR tag.  For example, to place a <link> element in the
head section, use this:
.PP
.Vb 2
\&    print start_html(\-head=>Link({\-rel=>\*(Aqshortcut icon\*(Aq,
\&                                  \-href=>\*(Aqfavicon.ico\*(Aq}));
.Ve
.PP
To incorporate multiple \s-1HTML\s0 elements into the <head> section, just pass an
array reference:
.PP
.Vb 7
\&    print start_html(\-head=>[ 
\&                             Link({\-rel=>\*(Aqnext\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s2.html\*(Aq}),
\&                             Link({\-rel=>\*(Aqprevious\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s1.html\*(Aq})
\&                             ]
\&                     );
.Ve
.PP
And here's how to create an HTTP-EQUIV <meta> tag:
.PP
.Vb 2
\&      print start_html(\-head=>meta({\-http_equiv => \*(AqContent\-Type\*(Aq,
\&                                    \-content    => \*(Aqtext/html\*(Aq}))
.Ve
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-script\fR, \fB\-noScript\fR, \fB\-onLoad\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onUnload\fR parameters are used
to add JavaScript calls to your pages.  \fB\-script\fR should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <script> block inside the \s-1HTML \s0(not
\&\s-1HTTP\s0) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  \s-1CGI\s0.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.
.PP
The \fB\-onLoad\fR and \fB\-onUnload\fR parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
\&\fB\-script\fR field:
.PP
.Vb 10
\&      $query = CGI\->new;
\&      print header;
\&      $JSCRIPT=<<END;
\&      // Ask a silly question
\&      function riddle_me_this() {
\&         var r = prompt("What walks on four legs in the morning, " +
\&                       "two legs in the afternoon, " +
\&                       "and three legs in the evening?");
\&         response(r);
\&      }
\&      // Get a silly answer
\&      function response(answer) {
\&         if (answer == "man")
\&            alert("Right you are!");
\&         else
\&            alert("Wrong!  Guess again.");
\&      }
\&      END
\&      print start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                               \-script=>$JSCRIPT);
.Ve
.PP
Use the \fB\-noScript\fR parameter to pass some \s-1HTML\s0 text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).
.PP
The <script> tag, has several attributes including \*(L"type\*(R", \*(L"charset\*(R" and \*(L"src\*(R".
\&\*(L"src\*(R" allows you to keep JavaScript code in an external file. To use these
attributes pass a \s-1HASH\s0 reference in the \fB\-script\fR parameter containing one or
more of \-type, \-src, or \-code:
.PP
.Vb 4
\&    print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                         \-script=>{\-type=>\*(AqJAVASCRIPT\*(Aq,
\&                                   \-src=>\*(Aq/javascript/sphinx.js\*(Aq}
\&                         );
\&
\&    print $q\->(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&               \-script=>{\-type=>\*(AqPERLSCRIPT\*(Aq,
\&                         \-code=>\*(Aqprint "hello world!\en;"\*(Aq}
\&               );
.Ve
.PP
A final feature allows you to incorporate multiple <script> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:
.PP
.Vb 10
\&     print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                          \-script=>[
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities10.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities11.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/jscript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities12.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/ecmascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities219.js\*(Aq
\&                                    }
\&                                 ]
\&                             );
.Ve
.PP
The option \*(L"\-language\*(R" is a synonym for \-type, and is supported for
backwards compatibility.
.PP
The old-style positional parameters are as follows:
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The title
.IP "2." 4
.IX Item "2."
The author's e\-mail address (will create a <link rev=\*(L"\s-1MADE\*(R"\s0> tag if present
.IP "3." 4
.IX Item "3."
A 'true' flag if you want to include a <base> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!
.IP "4, 5, 6..." 4
.IX Item "4, 5, 6..."
Any other parameters you want to include in the <body> tag.  This is a good
place to put \s-1HTML\s0 extensions, such as colors and wallpaper patterns.
.SS "\s-1ENDING THE HTML DOCUMENT:\s0"
.IX Subsection "ENDING THE HTML DOCUMENT:"
.Vb 1
\&        print $q\->end_html;
.Ve
.PP
This ends an \s-1HTML\s0 document by printing the </body></html> tags.
.SS "\s-1CREATING A\s0 SELF-REFERENCING \s-1URL THAT PRESERVES STATE INFORMATION:\s0"
.IX Subsection "CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:"
.Vb 2
\&    $myself = $q\->self_url;
\&    print q(<a href="$myself">I\*(Aqm talking to myself.</a>);
.Ve
.PP
\&\fIself_url()\fR will return a \s-1URL,\s0 that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.
.PP
.Vb 4
\&     $myself = $q\->self_url;
\&     print "<a href=\e"$myself#table1\e">See table 1</a>";
\&     print "<a href=\e"$myself#table2\e">See table 2</a>";
\&     print "<a href=\e"$myself#yourself\e">See for yourself</a>";
.Ve
.PP
If you want more control over what's returned, using the \fB\f(BIurl()\fB\fR
method instead.
.PP
You can also retrieve the unprocessed query string with \fIquery_string()\fR:
.PP
.Vb 1
\&    $the_string = $q\->query_string();
.Ve
.PP
The behavior of calling query_string is currently undefined when the \s-1HTTP\s0 method is
something other than \s-1GET.\s0
.SS "\s-1OBTAINING THE SCRIPT\s0'S \s-1URL\s0"
.IX Subsection "OBTAINING THE SCRIPT'S URL"
.Vb 7
\&    $full_url      = url();
\&    $full_url      = url(\-full=>1);  #alternative syntax
\&    $relative_url  = url(\-relative=>1);
\&    $absolute_url  = url(\-absolute=>1);
\&    $url_with_path = url(\-path_info=>1);
\&    $url_with_path_and_query = url(\-path_info=>1,\-query=>1);
\&    $netloc        = url(\-base => 1);
.Ve
.PP
\&\fB\f(BIurl()\fB\fR returns the script's \s-1URL\s0 in a variety of formats.  Called
without any arguments, it returns the full form of the \s-1URL,\s0 including
host name and port number
.PP
.Vb 1
\&    http://your.host.com/path/to/script.cgi
.Ve
.PP
You can modify this format with the following named arguments:
.IP "\fB\-absolute\fR" 4
.IX Item "-absolute"
If true, produce an absolute \s-1URL,\s0 e.g.
.Sp
.Vb 1
\&    /path/to/script.cgi
.Ve
.IP "\fB\-relative\fR" 4
.IX Item "-relative"
Produce a relative \s-1URL. \s0 This is useful if you want to reinvoke your
script with different parameters. For example:
.Sp
.Vb 1
\&    script.cgi
.Ve
.IP "\fB\-full\fR" 4
.IX Item "-full"
Produce the full \s-1URL,\s0 exactly as if called without any arguments.
This overrides the \-relative and \-absolute arguments.
.IP "\fB\-path\fR (\fB\-path_info\fR)" 4
.IX Item "-path (-path_info)"
Append the additional path information to the \s-1URL. \s0 This can be
combined with \fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-path_info\fR
is provided as a synonym.
.IP "\fB\-query\fR (\fB\-query_string\fR)" 4
.IX Item "-query (-query_string)"
Append the query string to the \s-1URL. \s0 This can be combined with
\&\fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-query_string\fR is provided
as a synonym.
.IP "\fB\-base\fR" 4
.IX Item "-base"
Generate just the protocol and net location, as in http://www.foo.com:8000
.IP "\fB\-rewrite\fR" 4
.IX Item "-rewrite"
If Apache's mod_rewrite is turned on, then the script name and path
info probably won't match the request that the user sent. Set
\&\-rewrite=>1 (default) to return URLs that match what the user sent
(the original request \s-1URI\s0). Set \-rewrite=>0 to return URLs that match
the \s-1URL\s0 after mod_rewrite's rules have run.
.SS "\s-1MIXING POST AND URL PARAMETERS\s0"
.IX Subsection "MIXING POST AND URL PARAMETERS"
.Vb 1
\&   $color = url_param(\*(Aqcolor\*(Aq);
.Ve
.PP
It is possible for a script to receive \s-1CGI\s0 parameters in the \s-1URL\s0 as
well as in the fill-out form by creating a form that POSTs to a \s-1URL\s0
containing a query string (a \*(L"?\*(R" mark followed by arguments).  The
\&\fB\f(BIparam()\fB\fR method will always return the contents of the POSTed
fill-out form, ignoring the \s-1URL\s0's query string.  To retrieve \s-1URL\s0
parameters, call the \fB\f(BIurl_param()\fB\fR method.  Use it in the same way as
\&\fB\f(BIparam()\fB\fR.  The main difference is that it allows you to read the
parameters, but not set them.
.PP
Under no circumstances will the contents of the \s-1URL\s0 query string
interfere with similarly-named \s-1CGI\s0 parameters in POSTed forms.  If you
try to mix a \s-1URL\s0 query string with a form submitted with the \s-1GET\s0
method, the results will not be what you expect.
.SH "CREATING STANDARD HTML ELEMENTS:"
.IX Header "CREATING STANDARD HTML ELEMENTS:"
\&\s-1CGI\s0.pm defines general \s-1HTML\s0 shortcut methods for many \s-1HTML\s0 tags.  \s-1HTML\s0 shortcuts are named after a single
\&\s-1HTML\s0 element and return a fragment of \s-1HTML\s0 text. Example:
.PP
.Vb 7
\&   print $q\->blockquote(
\&                     "Many years ago on the island of",
\&                     $q\->a({href=>"http://crete.org/"},"Crete"),
\&                     "there lived a Minotaur named",
\&                     $q\->strong("Fred."),
\&                    ),
\&       $q\->hr;
.Ve
.PP
This results in the following \s-1HTML\s0 code (extra newlines have been
added for readability):
.PP
.Vb 6
\&   <blockquote>
\&   Many years ago on the island of
\&   <a href="http://crete.org/">Crete</a> there lived
\&   a minotaur named <strong>Fred.</strong> 
\&   </blockquote>
\&   <hr>
.Ve
.PP
If you find the syntax for calling the \s-1HTML\s0 shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):
.PP
.Vb 8
\&   use CGI \*(Aq:standard\*(Aq;
\&   print blockquote(
\&      "Many years ago on the island of",
\&      a({href=>"http://crete.org/"},"Crete"),
\&      "there lived a minotaur named",
\&      strong("Fred."),
\&      ),
\&      hr;
.Ve
.SS "\s-1PROVIDING ARGUMENTS TO HTML SHORTCUTS\s0"
.IX Subsection "PROVIDING ARGUMENTS TO HTML SHORTCUTS"
The \s-1HTML\s0 methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:
.PP
.Vb 1
\&   print hr;    #  <hr>
.Ve
.PP
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
.PP
.Vb 1
\&   print h1("Chapter","1"); # <h1>Chapter 1</h1>"
.Ve
.PP
If the first argument is a hash reference, then the keys
and values of the hash become the \s-1HTML\s0 tag's attributes:
.PP
.Vb 2
\&   print a({\-href=>\*(Aqfred.html\*(Aq,\-target=>\*(Aq_new\*(Aq},
\&      "Open a new frame");
\&
\&            <a href="fred.html",target="_new">Open a new frame</a>
.Ve
.PP
You may dispense with the dashes in front of the attribute names if
you prefer:
.PP
.Vb 1
\&   print img {src=>\*(Aqfred.gif\*(Aq,align=>\*(AqLEFT\*(Aq};
\&
\&           <img align="LEFT" src="fred.gif">
.Ve
.PP
Sometimes an \s-1HTML\s0 tag attribute has no argument.  For example, ordered
lists can be marked as \s-1COMPACT. \s0 The syntax for this is an argument that
that points to an undef string:
.PP
.Vb 1
\&   print ol({compact=>undef},li(\*(Aqone\*(Aq),li(\*(Aqtwo\*(Aq),li(\*(Aqthree\*(Aq));
.Ve
.PP
Prior to \s-1CGI\s0.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accommodate those who want to create tags of the form 
<img alt="">.  The difference is shown in these two pieces of code:
.PP
.Vb 3
\&   CODE                   RESULT
\&   img({alt=>undef})      <img alt>
\&   img({alt=>\*(Aq\*(Aq})         <img alt="">
.Ve
.SS "\s-1THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS\s0"
.IX Subsection "THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS"
One of the cool features of the \s-1HTML\s0 shortcuts is that they are
distributive.  If you give them an argument consisting of a
\&\fBreference\fR to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:
.PP
.Vb 3
\&   print ul(
\&             li({\-type=>\*(Aqdisc\*(Aq},[\*(AqSneezy\*(Aq,\*(AqDoc\*(Aq,\*(AqSleepy\*(Aq,\*(AqHappy\*(Aq])
\&           );
.Ve
.PP
This example will result in \s-1HTML\s0 output that looks like this:
.PP
.Vb 6
\&   <ul>
\&     <li type="disc">Sneezy</li>
\&     <li type="disc">Doc</li>
\&     <li type="disc">Sleepy</li>
\&     <li type="disc">Happy</li>
\&   </ul>
.Ve
.PP
This is extremely useful for creating tables.  For example:
.PP
.Vb 11
\&   print table({\-border=>undef},
\&           caption(\*(AqWhen Should You Eat Your Vegetables?\*(Aq),
\&           Tr({\-align=>\*(AqCENTER\*(Aq,\-valign=>\*(AqTOP\*(Aq},
\&           [
\&              th([\*(AqVegetable\*(Aq, \*(AqBreakfast\*(Aq,\*(AqLunch\*(Aq,\*(AqDinner\*(Aq]),
\&              td([\*(AqTomatoes\*(Aq , \*(Aqno\*(Aq, \*(Aqyes\*(Aq, \*(Aqyes\*(Aq]),
\&              td([\*(AqBroccoli\*(Aq , \*(Aqno\*(Aq, \*(Aqno\*(Aq,  \*(Aqyes\*(Aq]),
\&              td([\*(AqOnions\*(Aq   , \*(Aqyes\*(Aq,\*(Aqyes\*(Aq, \*(Aqyes\*(Aq])
\&           ]
\&           )
\&        );
.Ve
.SS "\s-1HTML SHORTCUTS AND LIST INTERPOLATION\s0"
.IX Subsection "HTML SHORTCUTS AND LIST INTERPOLATION"
Consider this bit of code:
.PP
.Vb 1
\&   print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
.Ve
.PP
It will ordinarily return the string that you probably expect, namely:
.PP
.Vb 1
\&   <blockquote><em>Hi</em> mom!</blockquote>
.Ve
.PP
Note the space between the element \*(L"Hi\*(R" and the element \*(L"mom!\*(R".
\&\s-1CGI\s0.pm puts the extra space there using array interpolation, which is
controlled by the magic $\*(L" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $\*(R" to an
empty string.
.PP
.Vb 4
\&   {
\&      local($") = \*(Aq\*(Aq;
\&      print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
\&    }
.Ve
.PP
I suggest you put the code in a block as shown here.  Otherwise the
change to $" will affect all subsequent code until you explicitly
reset it.
.SS "NON-STANDARD \s-1HTML SHORTCUTS\s0"
.IX Subsection "NON-STANDARD HTML SHORTCUTS"
A few \s-1HTML\s0 tags don't follow the standard pattern for various
reasons.
.PP
\&\fB\f(BIcomment()\fB\fR generates an \s-1HTML\s0 comment (<!\-\- comment \-\->).  Call it
like
.PP
.Vb 1
\&    print comment(\*(Aqhere is my comment\*(Aq);
.Ve
.PP
Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:
.PP
.Vb 6
\&    Select
\&    Tr
\&    Link
\&    Delete
\&    Accept
\&    Sub
.Ve
.PP
In addition, \fIstart_html()\fR, \fIend_html()\fR, \fIstart_form()\fR, \fIend_form()\fR,
\&\fIstart_multipart_form()\fR and all the fill-out form tags are special.
See their respective sections.
.SS "\s-1AUTOESCAPING HTML\s0"
.IX Subsection "AUTOESCAPING HTML"
By default, all \s-1HTML\s0 that is emitted by the form-generating functions
is passed through a function called \fIescapeHTML()\fR:
.ie n .IP "$escaped_string = escapeHTML(""unescaped string"");" 4
.el .IP "\f(CW$escaped_string\fR = escapeHTML(``unescaped string'');" 4
.IX Item "$escaped_string = escapeHTML(unescaped string);"
Escape \s-1HTML\s0 formatting characters in a string.
.PP
Provided that you have specified a character set of \s-1ISO\-8859\-1 \s0(the
default), the standard \s-1HTML\s0 escaping rules will be used.  The \*(L"<\*(R"
character becomes \*(L"&lt;\*(R", \*(L">\*(R" becomes \*(L"&gt;\*(R", \*(L"&\*(R" becomes \*(L"&amp;\*(R", and
the quote character becomes \*(L"&quot;\*(R".  In addition, the hexadecimal
0x8b and 0x9b characters, which some browsers incorrectly interpret
as the left and right angle-bracket characters, are replaced by their
numeric character entities (\*(L"&#8249\*(R" and \*(L"&#8250;\*(R").  If you manually change
the charset, either by calling the \fIcharset()\fR method explicitly or by
passing a \-charset argument to \fIheader()\fR, then \fBall\fR characters will
be replaced by their numeric entities, since \s-1CGI\s0.pm has no lookup
table for all the possible encodings.
.PP
\&\f(CW\*(C`escapeHTML()\*(C'\fR expects the supplied string to be a character string. This means you
should Encode::decode data received from \*(L"outside\*(R" and Encode::encode your
strings before sending them back outside. If your source code \s-1UTF\-8\s0 encoded and
you want to upgrade string literals in your source to character strings, you
can use \*(L"use utf8\*(R". See perlunitut, perlunifaq and perlunicode for more
information on how Perl handles the difference between bytes and characters.
.PP
The automatic escaping does not apply to other shortcuts, such as
\&\fIh1()\fR.  You should call \fIescapeHTML()\fR yourself on untrusted data in
order to protect your pages against nasty tricks that people may enter
into guestbooks, etc..  To change the character set, use \fIcharset()\fR.
To turn autoescaping off completely, use \fIautoEscape\fR\|(0):
.ie n .IP "$charset = charset([$charset]);" 4
.el .IP "\f(CW$charset\fR = charset([$charset]);" 4
.IX Item "$charset = charset([$charset]);"
Get or set the current character set.
.ie n .IP "$flag = autoEscape([$flag]);" 4
.el .IP "\f(CW$flag\fR = autoEscape([$flag]);" 4
.IX Item "$flag = autoEscape([$flag]);"
Get or set the value of the autoescape flag.
.SS "PRETTY-PRINTING \s-1HTML\s0"
.IX Subsection "PRETTY-PRINTING HTML"
By default, all the \s-1HTML\s0 produced by these functions comes out as one
long line without carriage returns or indentation. This is yuck, but
it does reduce the size of the documents by 10\-20%.  To get
pretty-printed output, please use CGI::Pretty, a subclass
contributed by Brian Paulsen.
.SH "CREATING FILL-OUT FORMS:"
.IX Header "CREATING FILL-OUT FORMS:"
\&\fIGeneral note\fR  The various form-creating methods all return strings
to the caller, containing the tag or tags that will create the requested
form element.  You are responsible for actually printing out these strings.
It's set up this way so that you can place formatting tags
around the form elements.
.PP
\&\fIAnother note\fR The default values that you specify for the forms are only
used the \fBfirst\fR time the script is invoked (when there is no query
string).  On subsequent invocations of the script (when there is a query
string), the former values are used even if they are blank.
.PP
If you want to change the value of a field from its previous value, you have two
choices:
.PP
(1) call the \fIparam()\fR method to set it.
.PP
(2) use the \-override (alias \-force) parameter (a new feature in version 2.15).
This forces the default value to be used, regardless of the previous value:
.PP
.Vb 5
\&   print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                           \-default=>\*(Aqstarting value\*(Aq,
\&                           \-override=>1,
\&                           \-size=>50,
\&                           \-maxlength=>80);
.Ve
.PP
\&\fIYet another note\fR By default, the text and labels of form elements are
escaped according to \s-1HTML\s0 rules.  This means that you can safely use
\&\*(L"<\s-1CLICK ME\s0>\*(R" as the label for a button.  However, it also interferes with
your ability to incorporate special \s-1HTML\s0 character sequences, such as &Aacute;,
into your fields.  If you wish to turn off automatic escaping, call the
\&\fIautoEscape()\fR method with a false value immediately after creating the \s-1CGI\s0 object:
.PP
.Vb 2
\&   $query = CGI\->new;
\&   $query\->autoEscape(0);
.Ve
.PP
Note that \fIautoEscape()\fR is exclusively used to effect the behavior of how some
\&\s-1CGI\s0.pm \s-1HTML\s0 generation functions handle escaping. Calling \fIescapeHTML()\fR
explicitly will always escape the \s-1HTML.\s0
.PP
\&\fIA Lurking Trap!\fR Some of the form-element generating methods return
multiple tags.  In a scalar context, the tags will be concatenated
together with spaces, or whatever is the current value of the $"
global.  In a list context, the methods will return a list of
elements, allowing you to modify them if you wish.  Usually you will
not notice this behavior, but beware of this:
.PP
.Vb 1
\&    printf("%s\en",end_form())
.Ve
.PP
\&\fIend_form()\fR produces several tags, and only the first of them will be
printed because the format only expects one value.
.PP
<p>
.SS "\s-1CREATING AN ISINDEX TAG\s0"
.IX Subsection "CREATING AN ISINDEX TAG"
.Vb 1
\&   print isindex(\-action=>$action);
\&
\&         \-or\-
\&
\&   print isindex($action);
.Ve
.PP
Prints out an <isindex> tag.  Not very exciting.  The parameter
\&\-action specifies the \s-1URL\s0 of the script to process the query.  The
default is to process the query with the current script.
.SS "\s-1STARTING AND ENDING A FORM\s0"
.IX Subsection "STARTING AND ENDING A FORM"
.Vb 5
\&    print start_form(\-method=>$method,
\&                    \-action=>$action,
\&                    \-enctype=>$encoding);
\&      <... various form stuff ...>
\&    print end_form;
\&
\&        \-or\-
\&
\&    print start_form($method,$action,$encoding);
\&      <... various form stuff ...>
\&    print end_form;
.Ve
.PP
\&\fIstart_form()\fR will return a <form> tag with the optional method,
action and form encoding that you specify.  The defaults are:
.PP
.Vb 4
\&    method: POST
\&    action: this script
\&    enctype: application/x\-www\-form\-urlencoded for non\-XHTML
\&             multipart/form\-data for XHTML, see multipart/form\-data below.
.Ve
.PP
\&\fIend_form()\fR returns the closing </form> tag.
.PP
\&\fIStart_form()\fR's enctype argument tells the browser how to package the various
fields of the form before sending the form to the server.  Two
values are possible:
.PP
\&\fBNote:\fR These methods were previously named \fIstartform()\fR and \fIendform()\fR.
These methods are now \s-1DEPRECATED.\s0
Please use \fIstart_form()\fR and \fIend_form()\fR instead.
.IP "\fBapplication/x\-www\-form\-urlencoded\fR" 4
.IX Item "application/x-www-form-urlencoded"
This is the older type of encoding.  It is compatible with many \s-1CGI\s0 scripts and is
suitable for short fields containing text data.  For your
convenience, \s-1CGI\s0.pm stores the name of this encoding
type in \fB&CGI::URL_ENCODED\fR.
.IP "\fBmultipart/form\-data\fR" 4
.IX Item "multipart/form-data"
This is the newer type of encoding.
It is suitable for forms that contain very large fields or that
are intended for transferring binary data.  Most importantly,
it enables the \*(L"file upload\*(R" feature.  For
your convenience, \s-1CGI\s0.pm stores the name of this encoding type
in \fB&CGI::MULTIPART\fR
.Sp
Forms that use this type of encoding are not easily interpreted
by \s-1CGI\s0 scripts unless they use \s-1CGI\s0.pm or another library designed
to handle them.
.Sp
If \s-1XHTML\s0 is activated (the default), then forms will be automatically
created using this type of encoding.
.PP
The \fIstart_form()\fR method uses the older form of encoding by
default unless \s-1XHTML\s0 is requested.  If you want to use the
newer form of encoding by default, you can call
\&\fB\f(BIstart_multipart_form()\fB\fR instead of \fB\f(BIstart_form()\fB\fR.  The
method \fB\f(BIend_multipart_form()\fB\fR is an alias to \fB\f(BIend_form()\fB\fR.
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-name\fR and \fB\-onSubmit\fR parameters are provided
for use with JavaScript.  The \-name parameter gives the
form a name so that it can be identified and manipulated by
JavaScript functions.  \-onSubmit should point to a JavaScript
function that will be executed just before the form is submitted to your
server.  You can use this opportunity to check the contents of the form 
for consistency and completeness.  If you find something wrong, you
can put up an alert box or maybe fix things up yourself.  You can 
abort the submission by returning false from this function.
.PP
Usually the bulk of JavaScript functions are defined in a <script>
block in the \s-1HTML\s0 header and \-onSubmit points to one of these function
call.  See \fIstart_html()\fR for details.
.SS "\s-1FORM ELEMENTS\s0"
.IX Subsection "FORM ELEMENTS"
After starting a form, you will typically create one or more
textfields, popup menus, radio groups and other form elements.  Each
of these elements takes a standard set of named arguments.  Some
elements also have optional arguments.  The standard arguments are as
follows:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the field. After submission this name can be used to
retrieve the field's value using the \fIparam()\fR method.
.IP "\fB\-value\fR, \fB\-values\fR" 4
.IX Item "-value, -values"
The initial value of the field which will be returned to the script
after form submission.  Some form elements, such as text fields, take
a single scalar \-value argument. Others, such as popup menus, take a
reference to an array of values. The two arguments are synonyms.
.IP "\fB\-tabindex\fR" 4
.IX Item "-tabindex"
A numeric value that sets the order in which the form element receives
focus when the user presses the tab key. Elements with lower values
receive focus first.
.IP "\fB\-id\fR" 4
.IX Item "-id"
A string identifier that can be used to identify this element to
JavaScript and \s-1DHTML.\s0
.IP "\fB\-override\fR" 4
.IX Item "-override"
A boolean, which, if true, forces the element to take on the value
specified by \fB\-value\fR, overriding the sticky behavior described
earlier for the \fB\-nosticky\fR pragma.
.IP "\fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR, \fB\-onSelect\fR" 4
.IX Item "-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut, -onSelect"
These are used to assign JavaScript event handlers. See the
JavaScripting section for more details.
.PP
Other common arguments are described in the next section. In addition
to these, all attributes described in the \s-1HTML\s0 specifications are
supported.
.SS "\s-1CREATING A TEXT FIELD\s0"
.IX Subsection "CREATING A TEXT FIELD"
.Vb 5
\&    print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                    \-value=>\*(Aqstarting value\*(Aq,
\&                    \-size=>50,
\&                    \-maxlength=>80);
\&        \-or\-
\&
\&    print textfield(\*(Aqfield_name\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fItextfield()\fR will return a text input field.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the default starting value for the field
contents (\-value, formerly known as \-default).
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
      characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
      field will accept (\-maxlength).
.PP
As with all these methods, the field will be initialized with its 
previous contents from earlier invocations of the script.
When the form is processed, the value of the text field can be
retrieved with:
.PP
.Vb 1
\&       $value = param(\*(Aqfoo\*(Aq);
.Ve
.PP
If you want to reset it from its initial value after the script has been
called once, you can do so like this:
.PP
.Vb 1
\&       param(\*(Aqfoo\*(Aq,"I\*(Aqm taking over this value!");
.Ve
.SS "\s-1CREATING A BIG TEXT FIELD\s0"
.IX Subsection "CREATING A BIG TEXT FIELD"
.Vb 4
\&   print textarea(\-name=>\*(Aqfoo\*(Aq,
\&                          \-default=>\*(Aqstarting value\*(Aq,
\&                          \-rows=>10,
\&                          \-columns=>50);
\&
\&        \-or
\&
\&   print textarea(\*(Aqfoo\*(Aq,\*(Aqstarting value\*(Aq,10,50);
.Ve
.PP
\&\fItextarea()\fR is just like textfield, but it allows you to specify
rows and columns for a multiline text entry box.  You can provide
a starting value for the field, which can be long and contain
multiple lines.
.SS "\s-1CREATING A PASSWORD FIELD\s0"
.IX Subsection "CREATING A PASSWORD FIELD"
.Vb 5
\&   print password_field(\-name=>\*(Aqsecret\*(Aq,
\&                                \-value=>\*(Aqstarting value\*(Aq,
\&                                \-size=>50,
\&                                \-maxlength=>80);
\&        \-or\-
\&
\&   print password_field(\*(Aqsecret\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIpassword_field()\fR is identical to \fItextfield()\fR, except that its contents 
will be starred out on the web page.
.SS "\s-1CREATING A FILE UPLOAD FIELD\s0"
.IX Subsection "CREATING A FILE UPLOAD FIELD"
.Vb 5
\&    print filefield(\-name=>\*(Aquploaded_file\*(Aq,
\&                            \-default=>\*(Aqstarting value\*(Aq,
\&                            \-size=>50,
\&                            \-maxlength=>80);
\&        \-or\-
\&
\&    print filefield(\*(Aquploaded_file\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIfilefield()\fR will return a file upload field.
In order to take full advantage of this \fIyou must use the new 
multipart encoding scheme\fR for the form.  You can do this either
by calling \fB\f(BIstart_form()\fB\fR with an encoding type of \fB&CGI::MULTIPART\fR,
or by calling the new method \fB\f(BIstart_multipart_form()\fB\fR instead of
vanilla \fB\f(BIstart_form()\fB\fR.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the starting value for the field contents
to be used as the default file name (\-default).
.Sp
For security reasons, browsers don't pay any attention to this field,
and so the starting value will always be blank.  Worse, the field
loses its \*(L"sticky\*(R" behavior and forgets its previous contents.  The
starting value field is called for in the \s-1HTML\s0 specification, however,
and possibly some browser will eventually provide support for it.
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
field will accept (\-maxlength).
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR for details.
.SS "\s-1PROCESSING A FILE UPLOAD FIELD\s0"
.IX Subsection "PROCESSING A FILE UPLOAD FIELD"
\fIBasics\fR
.IX Subsection "Basics"
.PP
When the form is processed, you can retrieve an IO::Handle compatible
handle for a file upload field like this:
.PP
.Vb 1
\&  $lightweight_fh  = $q\->upload(\*(Aqfield_name\*(Aq);
\&
\&  # undef may be returned if it\*(Aqs not a valid file handle
\&  if (defined $lightweight_fh) {
\&    # Upgrade the handle to one compatible with IO::Handle:
\&    my $io_handle = $lightweight_fh\->handle;
\&
\&    open (OUTFILE,\*(Aq>>\*(Aq,\*(Aq/usr/local/web/users/feedback\*(Aq);
\&    while ($bytesread = $io_handle\->read($buffer,1024)) {
\&      print OUTFILE $buffer;
\&    }
\&  }
.Ve
.PP
In a list context, \fIupload()\fR will return an array of filehandles.
This makes it possible to process forms that use the same name for
multiple upload fields.
.PP
If you want the entered file name for the file, you can just call \fIparam()\fR:
.PP
.Vb 1
\&  $filename = $q\->param(\*(Aqfield_name\*(Aq);
.Ve
.PP
Different browsers will return slightly different things for the
name.  Some browsers return the filename only.  Others return the full
path to the file, using the path conventions of the user's machine.
Regardless, the name returned is always the name of the file on the
\&\fIuser's\fR machine, and is unrelated to the name of the temporary file
that \s-1CGI\s0.pm creates during upload spooling (see below).
.PP
When a file is uploaded the browser usually sends along some
information along with it in the format of headers.  The information
usually includes the \s-1MIME\s0 content type. To
retrieve this information, call \fIuploadInfo()\fR.  It returns a reference to
a hash containing all the document headers.
.PP
.Vb 5
\&       $filename = $q\->param(\*(Aquploaded_file\*(Aq);
\&       $type = $q\->uploadInfo($filename)\->{\*(AqContent\-Type\*(Aq};
\&       unless ($type eq \*(Aqtext/html\*(Aq) {
\&        die "HTML FILES ONLY!";
\&       }
.Ve
.PP
If you are using a machine that recognizes \*(L"text\*(R" and \*(L"binary\*(R" data
modes, be sure to understand when and how to use them (see the Camel book).  
Otherwise you may find that binary files are corrupted during file
uploads.
.PP
\fIAccessing the temp files directly\fR
.IX Subsection "Accessing the temp files directly"
.PP
When processing an uploaded file, \s-1CGI\s0.pm creates a temporary file on your hard
disk and passes you a file handle to that file. After you are finished with the
file handle, \s-1CGI\s0.pm unlinks (deletes) the temporary file. If you need to you
can access the temporary file directly. You can access the temp file for a file
upload by passing the file name to the \fItmpFileName()\fR method:
.PP
.Vb 2
\&       $filename = $query\->param(\*(Aquploaded_file\*(Aq);
\&       $tmpfilename = $query\->tmpFileName($filename);
.Ve
.PP
The temporary file will be deleted automatically when your program exits unless
you manually rename it. On some operating systems (such as Windows \s-1NT\s0), you
will need to close the temporary file's filehandle before your program exits.
Otherwise the attempt to delete the temporary file will fail.
.PP
\fIHandling interrupted file uploads\fR
.IX Subsection "Handling interrupted file uploads"
.PP
There are occasionally problems involving parsing the uploaded file.
This usually happens when the user presses \*(L"Stop\*(R" before the upload is
finished.  In this case, \s-1CGI\s0.pm will return undef for the name of the
uploaded file and set \fI\fIcgi_error()\fI\fR to the string \*(L"400 Bad request
(malformed multipart \s-1POST\s0)\*(R".  This error message is designed so that
you can incorporate it into a status code to be sent to the browser.
Example:
.PP
.Vb 5
\&   $file = $q\->upload(\*(Aquploaded_file\*(Aq);
\&   if (!$file && $q\->cgi_error) {
\&      print $q\->header(\-status=>$q\->cgi_error);
\&      exit 0;
\&   }
.Ve
.PP
You are free to create a custom \s-1HTML\s0 page to complain about the error,
if you wish.
.PP
\fIProgress bars for file uploads and avoiding temp files\fR
.IX Subsection "Progress bars for file uploads and avoiding temp files"
.PP
\&\s-1CGI\s0.pm gives you low-level access to file upload management through
a file upload hook. You can use this feature to completely turn off
the temp file storage of file uploads, or potentially write your own
file upload progress meter.
.PP
This is much like the \s-1UPLOAD_HOOK\s0 facility available in Apache::Request, with
the exception that the first argument to the callback is an Apache::Upload
object, here it's the remote filename.
.PP
.Vb 1
\& $q = CGI\->new(\e&hook [,$data [,$use_tempfile]]);
\&
\& sub hook {
\&        my ($filename, $buffer, $bytes_read, $data) = @_;
\&        print  "Read $bytes_read bytes of $filename\en";
\& }
.Ve
.PP
The \f(CW$data\fR field is optional; it lets you pass configuration
information (e.g. a database handle) to your hook callback.
.PP
The \f(CW$use_tempfile\fR field is a flag that lets you turn on and off
\&\s-1CGI\s0.pm's use of a temporary disk-based file during file upload. If you
set this to a \s-1FALSE\s0 value (default true) then \f(CW$q\fR\->param('uploaded_file')
will no longer work, and the only way to get at the uploaded data is
via the hook you provide.
.PP
If using the function-oriented interface, call the \fICGI::upload_hook()\fR
method before calling \fIparam()\fR or any other \s-1CGI\s0 functions:
.PP
.Vb 1
\&  CGI::upload_hook(\e&hook [,$data [,$use_tempfile]]);
.Ve
.PP
This method is not exported by default.  You will have to import it
explicitly if you wish to use it without the \s-1CGI::\s0 prefix.
.PP
\fITroubleshooting file uploads on Windows\fR
.IX Subsection "Troubleshooting file uploads on Windows"
.PP
If you are using \s-1CGI\s0.pm on a Windows platform and find that binary
files get slightly larger when uploaded but that text files remain the
same, then you have forgotten to activate binary mode on the output
filehandle.  Be sure to call \fIbinmode()\fR on any handle that you create
to write the uploaded file to disk.
.PP
\fIOlder ways to process file uploads\fR
.IX Subsection "Older ways to process file uploads"
.PP
( This section is here for completeness. if you are building a new application with \s-1CGI\s0.pm, you can skip it. )
.PP
The original way to process file uploads with \s-1CGI\s0.pm was to use \fIparam()\fR. The
value it returns has a dual nature as both a file name and a lightweight
filehandle. This dual nature is problematic if you following the recommended
practice of having \f(CW\*(C`use strict\*(C'\fR in your code. Perl will complain when you try
to use a string as a filehandle.  More seriously, it is possible for the remote
user to type garbage into the upload field, in which case what you get from
\&\fIparam()\fR is not a filehandle at all, but a string.
.PP
To solve this problem the \fIupload()\fR method was added, which always returns a
lightweight filehandle. This generally works well, but will have trouble
interoperating with some other modules because the file handle is not derived
from IO::Handle. So that brings us to current recommendation given above,
which is to call the \fIhandle()\fR method on the file handle returned by \fIupload()\fR.
That upgrades the handle to an IO::Handle. It's a big win for compatibility for
a small penalty of loading IO::Handle the first time you call it.
.SS "\s-1CREATING A POPUP MENU\s0"
.IX Subsection "CREATING A POPUP MENU"
.Vb 3
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \*(Aqmeenie\*(Aq);
\&
\&      \-or\-
\&
\&   %labels = (\*(Aqeenie\*(Aq=>\*(Aqyour first choice\*(Aq,
\&              \*(Aqmeenie\*(Aq=>\*(Aqyour second choice\*(Aq,
\&              \*(Aqminie\*(Aq=>\*(Aqyour third choice\*(Aq);
\&   %attributes = (\*(Aqeenie\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqclass of first choice\*(Aq});
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \*(Aqmeenie\*(Aq,\e%labels,\e%attributes);
\&
\&        \-or (named parameter style)\-
\&
\&   print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                            \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \-default=>[\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \-labels=>\e%labels,
\&          \-attributes=>\e%attributes);
.Ve
.PP
\&\fIpopup_menu()\fR creates a menu.
.IP "1." 4
The required first argument is the menu's name (\-name).
.IP "2." 4
The required second argument (\-values) is an array \fBreference\fR
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference to
a named array, such as \*(L"\e@foo\*(R".
.IP "3." 4
The optional third parameter (\-default) is the name of the default
menu choice.  If not specified, the first item will be the default.
The values of the previous choice will be maintained across
queries. Pass an array reference to select multiple defaults.
.IP "4." 4
The optional fourth parameter (\-labels) is provided for people who
want to use different values for the user-visible label inside the
popup menu and the value returned to your script.  It's a pointer to an
hash relating menu values to user-visible labels.  If you
leave this parameter blank, the menu values will be displayed by
default.  (You can also leave a label undefined if you want to).
.IP "5." 4
The optional fifth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.PP
When the form is processed, the selected value of the popup menu can
be retrieved using:
.PP
.Vb 1
\&      $popup_menu_value = param(\*(Aqmenu_name\*(Aq);
.Ve
.SS "\s-1CREATING AN OPTION GROUP\s0"
.IX Subsection "CREATING AN OPTION GROUP"
Named parameter style
.PP
.Vb 9
\&  print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                  \-values=>[qw/eenie meenie minie/,
\&                            optgroup(\-name=>\*(Aqoptgroup_name\*(Aq,
\&                                             \-values => [\*(Aqmoe\*(Aq,\*(Aqcatch\*(Aq],
\&                                             \-attributes=>{\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],
\&                  \-labels=>{\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,
\&                            \*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,
\&                            \*(Aqminie\*(Aq=>\*(Aqthree\*(Aq},
\&                  \-default=>\*(Aqmeenie\*(Aq);
\&
\&  Old style
\&  print popup_menu(\*(Aqmenu_name\*(Aq,
\&                  [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,
\&                   optgroup(\*(Aqoptgroup_name\*(Aq, [\*(Aqmoe\*(Aq, \*(Aqcatch\*(Aq],
\&                                   {\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],\*(Aqmeenie\*(Aq,
\&                  {\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,\*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,\*(Aqminie\*(Aq=>\*(Aqthree\*(Aq});
.Ve
.PP
\&\fIoptgroup()\fR creates an option group within a popup menu.
.IP "1." 4
The required first argument (\fB\-name\fR) is the label attribute of the
optgroup and is \fBnot\fR inserted in the parameter list of the query.
.IP "2." 4
The required second argument (\fB\-values\fR)  is an array reference
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference
to a named array, such as \e@foo.  If you pass a \s-1HASH\s0 reference,
the keys will be used for the menu values, and the values will be
used for the menu labels (see \-labels below).
.IP "3." 4
The optional third parameter (\fB\-labels\fR) allows you to pass a reference
to a hash containing user-visible labels for one or more
of the menu items.  You can use this when you want the user to see one
menu string, but have the browser return your program a different one.
If you don't specify this, the value string will be used instead
(\*(L"eenie\*(R", \*(L"meenie\*(R" and \*(L"minie\*(R" in this example).  This is equivalent
to using a hash reference for the \-values parameter.
.IP "4." 4
An optional fourth parameter (\fB\-labeled\fR) can be set to a true value
and indicates that the values should be used as the label attribute
for each option element within the optgroup.
.IP "5." 4
An optional fifth parameter (\-novals) can be set to a true value and
indicates to suppress the val attribute in each option element within
the optgroup.
.Sp
See the discussion on optgroup at W3C
(http://www.w3.org/TR/REC\-html40/interact/forms.html#edef\-OPTGROUP)
for details.
.IP "6." 4
An optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.SS "\s-1CREATING A SCROLLING LIST\s0"
.IX Subsection "CREATING A SCROLLING LIST"
.Vb 4
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,{\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&      \-or\-
\&
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,
\&        \e%labels,%attributes);
\&
\&        \-or\-
\&
\&   print scrolling_list(\-name=>\*(Aqlist_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-size=>5,
\&                                \-multiple=>\*(Aqtrue\*(Aq,
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
.Ve
.PP
\&\fIscrolling_list()\fR creates a scrolling list.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the list name (\-name) and values
(\-values).  As in the popup menu, the second argument should be an
array reference.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be selected by default, or can be a
single value to select.  If this argument is missing or undefined,
then nothing is selected when the list first appears.  In the named
parameter version, you can use the synonym \*(L"\-defaults\*(R" for this
parameter.
.IP "3." 4
.IX Item "3."
The optional fourth argument is the size of the list (\-size).
.IP "4." 4
.IX Item "4."
The optional fifth argument can be set to true to allow multiple
simultaneous selections (\-multiple).  Otherwise only one selection
will be allowed at a time.
.IP "5." 4
.IX Item "5."
The optional sixth argument is a pointer to a hash
containing long user-visible labels for the list items (\-labels).
If not provided, the values will be displayed.
.IP "6." 4
.IX Item "6."
The optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.Sp
When this form is processed, all selected list items will be returned as
a list under the parameter name 'list_name'.  The values of the
selected items can be retrieved with:
.Sp
.Vb 1
\&      @selected = param(\*(Aqlist_name\*(Aq);
.Ve
.SS "\s-1CREATING A GROUP OF RELATED CHECKBOXES\s0"
.IX Subsection "CREATING A GROUP OF RELATED CHECKBOXES"
.Vb 7
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-linebreak=>\*(Aqtrue\*(Aq,
\&                                \-disabled => [\*(Aqmoe\*(Aq],
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
\&
\&   print checkbox_group(\*(Aqgroup_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],\*(Aqtrue\*(Aq,\e%labels,
\&        {\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIcheckbox_group()\fR creates a list of checkboxes that are related
by the same name.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the checkbox name and values,
respectively (\-name and \-values).  As in the popup menu, the second
argument should be an array reference.  These values are used for the
user-readable labels printed next to the checkboxes as well as for the
values passed to your script in the query string.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be checked by default, or can be a
single value to checked.  If this argument is missing or undefined,
then nothing is selected when the list first appears.
.IP "3." 4
.IX Item "3."
The optional fourth argument (\-linebreak) can be set to true to place
line breaks between the checkboxes so that they appear as a vertical
list.  Otherwise, they will be strung together on a horizontal line.
.PP
The optional \fB\-labels\fR argument is a pointer to a hash
relating the checkbox values to the user-visible labels that will be
printed next to them.  If not provided, the values will be used as the
default.
.PP
The optional parameters \fB\-rows\fR, and \fB\-columns\fR cause
\&\fIcheckbox_group()\fR to return an \s-1HTML3\s0 compatible table containing the
checkbox group formatted with the specified number of rows and
columns.  You can provide just the \-columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
.PP
The option \fB\-disabled\fR takes an array of checkbox values and disables
them by greying them out (this may not be supported by all browsers).
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, all checked boxes will be returned as
a list under the parameter name 'group_name'.  The values of the
\&\*(L"on\*(R" checkboxes can be retrieved with:
.PP
.Vb 1
\&      @turned_on = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIcheckbox_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING A STANDALONE CHECKBOX\s0"
.IX Subsection "CREATING A STANDALONE CHECKBOX"
.Vb 4
\&    print checkbox(\-name=>\*(Aqcheckbox_name\*(Aq,
\&                           \-checked=>1,
\&                           \-value=>\*(AqON\*(Aq,
\&                           \-label=>\*(AqCLICK ME\*(Aq);
\&
\&        \-or\-
\&
\&    print checkbox(\*(Aqcheckbox_name\*(Aq,\*(Aqchecked\*(Aq,\*(AqON\*(Aq,\*(AqCLICK ME\*(Aq);
.Ve
.PP
\&\fIcheckbox()\fR is used to create an isolated checkbox that isn't logically
related to any others.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the checkbox (\-name).  It
will also be used for the user-readable label printed next to the
checkbox.
.IP "2." 4
.IX Item "2."
The optional second parameter (\-checked) specifies that the checkbox
is turned on by default.  Synonyms are \-selected and \-on.
.IP "3." 4
.IX Item "3."
The optional third parameter (\-value) specifies the value of the
checkbox when it is checked.  If not provided, the word \*(L"on\*(R" is
assumed.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-label) is the user-readable label to
be attached to the checkbox.  If not provided, the checkbox name is
used.
.PP
The value of the checkbox can be retrieved using:
.PP
.Vb 1
\&    $turned_on = param(\*(Aqcheckbox_name\*(Aq);
.Ve
.SS "\s-1CREATING A RADIO BUTTON GROUP\s0"
.IX Subsection "CREATING A RADIO BUTTON GROUP"
.Vb 6
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                             \-default=>\*(Aqmeenie\*(Aq,
\&                             \-linebreak=>\*(Aqtrue\*(Aq,
\&           \-labels=>\e%labels,
\&           \-attributes=>\e%attributes);
\&
\&        \-or\-
\&
\&   print radio_group(\*(Aqgroup_name\*(Aq,[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&            \*(Aqmeenie\*(Aq,\*(Aqtrue\*(Aq,\e%labels,\e%attributes);
\&
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                             \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIradio_group()\fR creates a set of logically-related radio buttons
(turning one member of the group on turns the others off)
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is the name of the group and is required (\-name).
.IP "2." 4
.IX Item "2."
The second argument (\-values) is the list of values for the radio
buttons.  The values and the labels that appear on the page are
identical.  Pass an array \fIreference\fR in the second argument, either
using an anonymous array, as shown, or by referencing a named array as
in \*(L"\e@foo\*(R".
.IP "3." 4
.IX Item "3."
The optional third parameter (\-default) is the name of the default
button to turn on. If not specified, the first item will be the
default.  You can provide a nonexistent button name, such as \*(L"\-\*(R" to
start up with no buttons selected.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-linebreak) can be set to 'true' to put
line breaks between the buttons, creating a vertical list.
.IP "5." 4
.IX Item "5."
The optional fifth parameter (\-labels) is a pointer to an associative
array relating the radio button values to user-visible labels to be
used in the display.  If not provided, the values themselves are
displayed.
.PP
All modern browsers can take advantage of the optional parameters
\&\fB\-rows\fR, and \fB\-columns\fR.  These parameters cause \fIradio_group()\fR to
return an \s-1HTML3\s0 compatible table containing the radio group formatted
with the specified number of rows and columns.  You can provide just
the \-columns parameter if you wish; radio_group will calculate the
correct number of rows for you.
.PP
To include row and column headings in the returned table, you
can use the \fB\-rowheaders\fR and \fB\-colheaders\fR parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the radio buttons \*(-- they're still a single named
unit.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, the selected radio button can
be retrieved using:
.PP
.Vb 1
\&      $which_radio_button = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIradio_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = radio_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING A SUBMIT BUTTON \s0"
.IX Subsection "CREATING A SUBMIT BUTTON "
.Vb 2
\&   print submit(\-name=>\*(Aqbutton_name\*(Aq,
\&                        \-value=>\*(Aqvalue\*(Aq);
\&
\&        \-or\-
\&
\&   print submit(\*(Aqbutton_name\*(Aq,\*(Aqvalue\*(Aq);
.Ve
.PP
\&\fIsubmit()\fR will create the query submission button.  Every form
should have one of these.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is optional.  You can give the button a
name if you have several submission buttons in your form and you want
to distinguish between them.
.IP "2." 4
.IX Item "2."
The second argument (\-value) is also optional.  This gives the button
a value that will be passed to your script in the query string. The
name will also be used as the user-visible label.
.IP "3." 4
.IX Item "3."
You can use \-label as an alias for \-value.  I always get confused
about which of \-name and \-value changes the user-visible label on the
button.
.PP
You can figure out which button was pressed by using different
values for each one:
.PP
.Vb 1
\&     $which_one = param(\*(Aqbutton_name\*(Aq);
.Ve
.SS "\s-1CREATING A RESET BUTTON\s0"
.IX Subsection "CREATING A RESET BUTTON"
.Vb 1
\&   print reset
.Ve
.PP
\&\fIreset()\fR creates the \*(L"reset\*(R" button.  Note that it restores the
form to its value from the last time the script was called, 
\&\s-1NOT\s0 necessarily to the defaults.
.PP
Note that this conflicts with the Perl \fIreset()\fR built-in.  Use
\&\fICORE::reset()\fR to get the original reset function.
.SS "\s-1CREATING A DEFAULT BUTTON\s0"
.IX Subsection "CREATING A DEFAULT BUTTON"
.Vb 1
\&   print defaults(\*(Aqbutton_label\*(Aq)
.Ve
.PP
\&\fIdefaults()\fR creates a button that, when invoked, will cause the
form to be completely reset to its defaults, wiping out all the
changes the user ever made.
.SS "\s-1CREATING A HIDDEN FIELD\s0"
.IX Subsection "CREATING A HIDDEN FIELD"
.Vb 2
\&        print hidden(\-name=>\*(Aqhidden_name\*(Aq,
\&                             \-default=>[\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...]);
\&
\&                \-or\-
\&
\&        print hidden(\*(Aqhidden_name\*(Aq,\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...);
.Ve
.PP
\&\fIhidden()\fR produces a text field that can't be seen by the user.  It
is useful for passing state variable information from one invocation
of the script to the next.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is required and specifies the name of this
field (\-name).
.IP "2." 4
.IX Item "2."
The second argument is also required and specifies its value
(\-default).  In the named parameter style of calling, you can provide
a single value here or a reference to a whole list
.PP
Fetch the value of a hidden field this way:
.PP
.Vb 1
\&     $hidden_value = param(\*(Aqhidden_name\*(Aq);
.Ve
.PP
Note, that just like all the other form elements, the value of a
hidden field is \*(L"sticky\*(R".  If you want to replace a hidden field with
some other values after the script has been called once you'll have to
do it manually:
.PP
.Vb 1
\&     param(\*(Aqhidden_name\*(Aq,\*(Aqnew\*(Aq,\*(Aqvalues\*(Aq,\*(Aqhere\*(Aq);
.Ve
.SS "\s-1CREATING A CLICKABLE IMAGE BUTTON\s0"
.IX Subsection "CREATING A CLICKABLE IMAGE BUTTON"
.Vb 3
\&     print image_button(\-name=>\*(Aqbutton_name\*(Aq,
\&                                \-src=>\*(Aq/source/URL\*(Aq,
\&                                \-align=>\*(AqMIDDLE\*(Aq);      
\&
\&        \-or\-
\&
\&     print image_button(\*(Aqbutton_name\*(Aq,\*(Aq/source/URL\*(Aq,\*(AqMIDDLE\*(Aq);
.Ve
.PP
\&\fIimage_button()\fR produces a clickable image.  When it's clicked on the
position of the click is returned to your script as \*(L"button_name.x\*(R"
and \*(L"button_name.y\*(R", where \*(L"button_name\*(R" is the name you've assigned
to it.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is required and specifies the name of this
field.
.IP "2." 4
.IX Item "2."
The second argument (\-src) is also required and specifies the \s-1URL\s0
.IP "3. The third option (\-align, optional) is an alignment type, and may be \s-1TOP, BOTTOM\s0 or \s-1MIDDLE\s0" 4
.IX Item "3. The third option (-align, optional) is an alignment type, and may be TOP, BOTTOM or MIDDLE"
.PP
Fetch the value of the button this way:
     \f(CW$x\fR = param('button_name.x');
     \f(CW$y\fR = param('button_name.y');
.SS "\s-1CREATING A JAVASCRIPT ACTION BUTTON\s0"
.IX Subsection "CREATING A JAVASCRIPT ACTION BUTTON"
.Vb 3
\&     print button(\-name=>\*(Aqbutton_name\*(Aq,
\&                          \-value=>\*(Aquser visible label\*(Aq,
\&                          \-onClick=>"do_something()");
\&
\&        \-or\-
\&
\&     print button(\*(Aqbutton_name\*(Aq,"user visible value","do_something()");
.Ve
.PP
\&\fIbutton()\fR produces an \f(CW\*(C`<input>\*(C'\fR tag with \f(CW\*(C`type="button"\*(C'\fR.  When it's
pressed the fragment of JavaScript code pointed to by the \fB\-onClick\fR parameter
will be executed.
.SH "HTTP COOKIES"
.IX Header "HTTP COOKIES"
Browsers support a so-called \*(L"cookie\*(R" designed to help maintain state
within a browser session.  \s-1CGI\s0.pm has several methods that support
cookies.
.PP
A cookie is a name=value pair much like the named parameters in a \s-1CGI\s0
query string.  \s-1CGI\s0 scripts create one or more cookies and send
them to the browser in the \s-1HTTP\s0 header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the \s-1CGI\s0 script during subsequent interactions.
.PP
In addition to the required name=value pair, each cookie has several
optional attributes:
.IP "1. an expiration time" 4
.IX Item "1. an expiration time"
This is a time/date string (in a special \s-1GMT\s0 format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.
.IP "2. a domain" 4
.IX Item "2. a domain"
This is a partial or complete domain name for which the cookie is 
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of \*(L".capricorn.com\*(R", then the browser will return the cookie to
Web servers running on any of the machines \*(L"www.capricorn.com\*(R", 
\&\*(L"www2.capricorn.com\*(R", \*(L"feckless.capricorn.com\*(R", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like \*(L".edu\*(R".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.
.IP "3. a path" 4
.IX Item "3. a path"
If you provide a cookie path attribute, the browser will check it
against your script's \s-1URL\s0 before returning the cookie.  For example,
if you specify the path \*(L"/cgi\-bin\*(R", then the cookie will be returned
to each of the scripts \*(L"/cgi\-bin/tally.pl\*(R", \*(L"/cgi\-bin/order.pl\*(R",
and \*(L"/cgi\-bin/customer_service/complain.pl\*(R", but not to the script
\&\*(L"/cgi\-private/site_admin.pl\*(R".  By default, path is set to \*(L"/\*(R", which
causes the cookie to be sent to any \s-1CGI\s0 script on your site.
.ie n .IP "4. a ""secure"" flag" 4
.el .IP "4. a ``secure'' flag" 4
.IX Item "4. a secure flag"
If the \*(L"secure\*(R" attribute is set, the cookie will only be sent to your
script if the \s-1CGI\s0 request is occurring on a secure channel, such as \s-1SSL.\s0
.PP
The interface to \s-1HTTP\s0 cookies is the \fB\f(BIcookie()\fB\fR method:
.PP
.Vb 7
\&    $cookie = cookie(\-name=>\*(AqsessionID\*(Aq,
\&                             \-value=>\*(Aqxyzzy\*(Aq,
\&                             \-expires=>\*(Aq+1h\*(Aq,
\&                             \-path=>\*(Aq/cgi\-bin/database\*(Aq,
\&                             \-domain=>\*(Aq.capricorn.org\*(Aq,
\&                             \-secure=>1);
\&    print header(\-cookie=>$cookie);
.Ve
.PP
\&\fB\f(BIcookie()\fB\fR creates a new cookie.  Its parameters include:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the cookie (required).  This can be any string at all.
Although browsers limit their cookie names to non-whitespace
alphanumeric characters, \s-1CGI\s0.pm removes this restriction by escaping
and unescaping cookies behind the scenes.
.IP "\fB\-value\fR" 4
.IX Item "-value"
The value of the cookie.  This can be any scalar value,
array reference, or even hash reference.  For example,
you can store an entire hash into a cookie this way:
.Sp
.Vb 2
\&        $cookie=cookie(\-name=>\*(Aqfamily information\*(Aq,
\&                               \-value=>\e%childrens_ages);
.Ve
.IP "\fB\-path\fR" 4
.IX Item "-path"
The optional partial path for which this cookie will be valid, as described
above.
.IP "\fB\-domain\fR" 4
.IX Item "-domain"
The optional partial domain for which this cookie will be valid, as described
above.
.IP "\fB\-expires\fR" 4
.IX Item "-expires"
The optional expiration date for this cookie.  The format is as described 
in the section on the \fB\f(BIheader()\fB\fR method:
.Sp
.Vb 1
\&        "+1h"  one hour from now
.Ve
.IP "\fB\-secure\fR" 4
.IX Item "-secure"
If set to true, this cookie will only be used within a secure
\&\s-1SSL\s0 session.
.PP
The cookie created by \fIcookie()\fR must be incorporated into the \s-1HTTP\s0
header within the string returned by the \fIheader()\fR method:
.PP
.Vb 2
\&        use CGI \*(Aq:standard\*(Aq;
\&        print header(\-cookie=>$my_cookie);
.Ve
.PP
To create multiple cookies, give \fIheader()\fR an array reference:
.PP
.Vb 5
\&        $cookie1 = cookie(\-name=>\*(Aqriddle_name\*(Aq,
\&                                  \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = cookie(\-name=>\*(Aqanswers\*(Aq,
\&                                  \-value=>\e%answers);
\&        print header(\-cookie=>[$cookie1,$cookie2]);
.Ve
.PP
To retrieve a cookie, request it by name by calling \fIcookie()\fR method
without the \fB\-value\fR parameter. This example uses the object-oriented
form:
.PP
.Vb 4
\&        use CGI;
\&        $query = CGI\->new;
\&        $riddle = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&        %answers = $query\->cookie(\*(Aqanswers\*(Aq);
.Ve
.PP
Cookies created with a single scalar value, such as the \*(L"riddle_name\*(R"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.
.PP
The cookie and \s-1CGI\s0 namespaces are separate.  If you have a parameter
named 'answers' and a cookie named 'answers', the values retrieved by
\&\fIparam()\fR and \fIcookie()\fR are independent of each other.  However, it's
simple to turn a \s-1CGI\s0 parameter into a cookie, and vice-versa:
.PP
.Vb 4
\&   # turn a CGI parameter into a cookie
\&   $c=cookie(\-name=>\*(Aqanswers\*(Aq,\-value=>[param(\*(Aqanswers\*(Aq)]);
\&   # vice\-versa
\&   param(\-name=>\*(Aqanswers\*(Aq,\-value=>[cookie(\*(Aqanswers\*(Aq)]);
.Ve
.PP
If you call \fIcookie()\fR without any parameters, it will return a list of
the names of all cookies passed to your script:
.PP
.Vb 1
\&  @cookies = cookie();
.Ve
.PP
See the \fBcookie.cgi\fR example script for some ideas on how to use
cookies effectively.
.SH "WORKING WITH FRAMES"
.IX Header "WORKING WITH FRAMES"
It's possible for \s-1CGI\s0.pm scripts to write into several browser panels
and windows using the \s-1HTML 4\s0 frame mechanism.  There are three
techniques for defining new frames programmatically:
.IP "1. Create a <Frameset> document" 4
.IX Item "1. Create a <Frameset> document"
After writing out the \s-1HTTP\s0 header, instead of creating a standard
\&\s-1HTML\s0 document using the \fIstart_html()\fR call, create a <frameset> 
document that defines the frames on the page.  Specify your script(s)
(with appropriate parameters) as the \s-1SRC\s0 for each of the frames.
.Sp
There is no specific support for creating <frameset> sections 
in \s-1CGI\s0.pm, but the \s-1HTML\s0 is very simple to write.
.IP "2. Specify the destination for the document in the \s-1HTTP\s0 header" 4
.IX Item "2. Specify the destination for the document in the HTTP header"
You may provide a \fB\-target\fR parameter to the \fIheader()\fR method:
.Sp
.Vb 1
\&    print header(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
This will tell the browser to load the output of your script into the
frame named \*(L"ResultsWindow\*(R".  If a frame of that name doesn't already
exist, the browser will pop up a new window and load your script's
document into that.  There are a number of magic names that you can
use for targets.  See the \s-1HTML \s0\f(CW\*(C`<frame>\*(C'\fR documentation for details.
.IP "3. Specify the destination for the document in the <form> tag" 4
.IX Item "3. Specify the destination for the document in the <form> tag"
You can specify the frame to load in the \s-1FORM\s0 tag itself.  With
\&\s-1CGI\s0.pm it looks like this:
.Sp
.Vb 1
\&    print start_form(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
When your script is reinvoked by the form, its output will be loaded
into the frame named \*(L"ResultsWindow\*(R".  If one doesn't already exist
a new window will be created.
.PP
The script \*(L"frameset.cgi\*(R" in the examples directory shows one way to
create pages in which the fill-out form and the response live in
side-by-side frames.
.SH "SUPPORT FOR JAVASCRIPT"
.IX Header "SUPPORT FOR JAVASCRIPT"
The usual way to use JavaScript is to define a set of functions in a
<\s-1SCRIPT\s0> block inside the \s-1HTML\s0 header and then to register event
handlers in the various elements of the page. Events include such
things as the mouse passing over a form element, a button being
clicked, the contents of a text field changing, or a form being
submitted. When an event occurs that involves an element that has
registered an event handler, its associated JavaScript code gets
called.
.PP
The elements that can register event handlers include the <\s-1BODY\s0> of an
\&\s-1HTML\s0 document, hypertext links, all the various elements of a fill-out
form, and the form itself. There are a large number of events, and
each applies only to the elements for which it is relevant. Here is a
partial list:
.IP "\fBonLoad\fR" 4
.IX Item "onLoad"
The browser is loading the current document. Valid in:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonUnload\fR" 4
.IX Item "onUnload"
The browser is closing the current page or frame. Valid for:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonSubmit\fR" 4
.IX Item "onSubmit"
The user has pressed the submit button of a form. This event happens
just before the form is submitted, and your function can return a
value of false in order to abort the submission.  Valid for:
.Sp
.Vb 1
\&     + Forms only.
.Ve
.IP "\fBonClick\fR" 4
.IX Item "onClick"
The mouse has clicked on an item in a fill-out form. Valid for:
.Sp
.Vb 3
\&     + Buttons (including submit, reset, and image buttons)
\&     + Checkboxes
\&     + Radio buttons
.Ve
.IP "\fBonChange\fR" 4
.IX Item "onChange"
The user has changed the contents of a field. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonFocus\fR" 4
.IX Item "onFocus"
The user has selected a field to work with. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonBlur\fR" 4
.IX Item "onBlur"
The user has deselected a field (gone to work somewhere else).  Valid
for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonSelect\fR" 4
.IX Item "onSelect"
The user has changed the part of a text field that is selected.  Valid
for:
.Sp
.Vb 4
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
.Ve
.IP "\fBonMouseOver\fR" 4
.IX Item "onMouseOver"
The mouse has moved over an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonMouseOut\fR" 4
.IX Item "onMouseOut"
The mouse has moved off an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.PP
In order to register a JavaScript event handler with an \s-1HTML\s0 element,
just use the event name as a parameter when you call the corresponding
\&\s-1CGI\s0 method. For example, to have your \fIvalidateAge()\fR JavaScript code
executed every time the textfield named \*(L"age\*(R" changes, generate the
field like this:
.PP
.Vb 1
\& print textfield(\-name=>\*(Aqage\*(Aq,\-onChange=>"validateAge(this)");
.Ve
.PP
This example assumes that you've already declared the \fIvalidateAge()\fR
function by incorporating it into a <\s-1SCRIPT\s0> block. The \s-1CGI\s0.pm
\&\fIstart_html()\fR method provides a convenient way to create this section.
.PP
Similarly, you can create a form that checks itself over for
consistency and alerts the user if some essential value is missing by
creating it this way: 
  print start_form(\-onSubmit=>\*(L"validateMe(this)\*(R");
.PP
See the javascript.cgi script for a demonstration of how this all
works.
.SH "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
.IX Header "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
\&\s-1CGI\s0.pm has limited support for \s-1HTML3\s0's cascading style sheets (css).
To incorporate a stylesheet into your document, pass the
\&\fIstart_html()\fR method a \fB\-style\fR parameter.  The value of this
parameter may be a scalar, in which case it is treated as the source
\&\s-1URL\s0 for the stylesheet, or it may be a hash reference.  In the latter
case you should provide the hash with one or more of \fB\-src\fR or
\&\fB\-code\fR.  \fB\-src\fR points to a \s-1URL\s0 where an externally-defined
stylesheet can be found.  \fB\-code\fR points to a scalar value to be
incorporated into a <style> section.  Style definitions in \fB\-code\fR
override similarly-named ones in \fB\-src\fR, hence the name \*(L"cascading.\*(R"
.PP
You may also specify the type of the stylesheet by adding the optional
\&\fB\-type\fR parameter to the hash pointed to by \fB\-style\fR.  If not
specified, the style defaults to 'text/css'.
.PP
To refer to a style within the body of your document, add the
\&\fB\-class\fR parameter to any \s-1HTML\s0 element:
.PP
.Vb 1
\&    print h1({\-class=>\*(AqFancy\*(Aq},\*(AqWelcome to the Party\*(Aq);
.Ve
.PP
Or define styles on the fly with the \fB\-style\fR parameter:
.PP
.Vb 1
\&    print h1({\-style=>\*(AqColor: red;\*(Aq},\*(AqWelcome to Hell\*(Aq);
.Ve
.PP
You may also use the new \fB\f(BIspan()\fB\fR element to apply a style to a
section of text:
.PP
.Vb 4
\&    print span({\-style=>\*(AqColor: red;\*(Aq},
\&               h1(\*(AqWelcome to Hell\*(Aq),
\&               "Where did that handbasket get to?"
\&               );
.Ve
.PP
Note that you must import the \*(L":html3\*(R" definitions to have the
\&\fB\f(BIspan()\fB\fR method available.  Here's a quick and dirty example of using
\&\s-1CSS\s0's.  See the \s-1CSS\s0 specification at
http://www.w3.org/Style/CSS/ for more information.
.PP
.Vb 1
\&    use CGI qw/:standard :html3/;
\&
\&    #here\*(Aqs a stylesheet incorporated directly into the page
\&    $newStyle=<<END;
\&    <!\-\- 
\&    P.Tip {
\&        margin\-right: 50pt;
\&        margin\-left: 50pt;
\&        color: red;
\&    }
\&    P.Alert {
\&        font\-size: 30pt;
\&        font\-family: sans\-serif;
\&      color: red;
\&    }
\&    \-\->
\&    END
\&    print header();
\&    print start_html( \-title=>\*(AqCGI with Style\*(Aq,
\&                      \-style=>{\-src=>\*(Aqhttp://www.capricorn.com/style/st1.css\*(Aq,
\&                               \-code=>$newStyle}
\&                     );
\&    print h1(\*(AqCGI with Style\*(Aq),
\&          p({\-class=>\*(AqTip\*(Aq},
\&            "Better read the cascading style sheet spec before playing with this!"),
\&          span({\-style=>\*(Aqcolor: magenta\*(Aq},
\&               "Look Mom, no hands!",
\&               p(),
\&               "Whooo wee!"
\&               );
\&    print end_html;
.Ve
.PP
Pass an array reference to \fB\-code\fR or \fB\-src\fR in order to incorporate
multiple stylesheets into your document.
.PP
Should you wish to incorporate a verbatim stylesheet that includes
arbitrary formatting in the header, you may pass a \-verbatim tag to
the \-style hash, as follows:
.PP
print start_html (\-style  =>  {\-verbatim => '@import url(\*(L"/server\-common/css/'.$cssFile.'\*(R");',
                  \-src    =>  '/server\-common/css/core.css'});
.PP
This will generate an \s-1HTML\s0 header that contains this:
.PP
.Vb 4
\& <link rel="stylesheet" type="text/css"  href="/server\-common/css/core.css">
\&   <style type="text/css">
\&   @import url("/server\-common/css/main.css");
\&   </style>
.Ve
.PP
Any additional arguments passed in the \-style value will be
incorporated into the <link> tag.  For example:
.PP
.Vb 2
\& start_html(\-style=>{\-src=>[\*(Aq/styles/print.css\*(Aq,\*(Aq/styles/layout.css\*(Aq],
\&                          \-media => \*(Aqall\*(Aq});
.Ve
.PP
This will give:
.PP
.Vb 2
\& <link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/>
\& <link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/>
.Ve
.PP
<p>
.PP
To make more complicated <link> tags, use the \fILink()\fR function
and pass it to \fIstart_html()\fR in the \-head argument, as in:
.PP
.Vb 3
\&  @h = (Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/ss.css\*(Aq,\-media=>\*(Aqall\*(Aq}),
\&        Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/fred.css\*(Aq,\-media=>\*(Aqpaper\*(Aq}));
\&  print start_html({\-head=>\e@h})
.Ve
.PP
To create primary and  \*(L"alternate\*(R" stylesheet, use the \fB\-alternate\fR option:
.PP
.Vb 5
\& start_html(\-style=>{\-src=>[
\&                           {\-src=>\*(Aq/styles/print.css\*(Aq},
\&                           {\-src=>\*(Aq/styles/alt.css\*(Aq,\-alternate=>1}
\&                           ]
\&                    });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  You can pass keywords like this:
.PP
.Vb 1
\&    your_script.pl keyword1 keyword2 keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&   your_script.pl keyword1+keyword2+keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1 name2=value2
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1&name2=value2
.Ve
.PP
To turn off this feature, use the \-no_debug pragma.
.PP
To test the \s-1POST\s0 method, you may enable full debugging with the \-debug
pragma.  This will allow you to feed newline-delimited name=value
pairs to the script on standard input.
.PP
When debugging, you can use quotes and backslashes to escape 
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:
.PP
.Vb 1
\&   your_script.pl "name1=\*(AqI am a long value\*(Aq" "name2=two\e words"
.Ve
.PP
Finally, you can set the path info for the script by prefixing the first
name/value parameter with the path followed by a question mark (?):
.PP
.Vb 1
\&    your_script.pl /your/path/here?name1=value1&name2=value2
.Ve
.SS "\s-1DUMPING OUT ALL THE NAME/VALUE PAIRS\s0"
.IX Subsection "DUMPING OUT ALL THE NAME/VALUE PAIRS"
The \fIDump()\fR method produces a string consisting of all the query's
name/value pairs formatted nicely as a nested list.  This is useful
for debugging purposes:
.PP
.Vb 1
\&    print Dump
.Ve
.PP
Produces something that looks like:
.PP
.Vb 11
\&    <ul>
\&    <li>name1
\&        <ul>
\&        <li>value1
\&        <li>value2
\&        </ul>
\&    <li>name2
\&        <ul>
\&        <li>value1
\&        </ul>
\&    </ul>
.Ve
.PP
As a shortcut, you can interpolate the entire \s-1CGI\s0 object into a string
and it will be replaced with the a nice \s-1HTML\s0 dump shown above:
.PP
.Vb 2
\&    $query=CGI\->new;
\&    print "<h2>Current Values</h2> $query\en";
.Ve
.SH "FETCHING ENVIRONMENT VARIABLES"
.IX Header "FETCHING ENVIRONMENT VARIABLES"
Some of the more useful environment variables can be fetched
through this interface.  The methods are as follows:
.IP "\fB\f(BIAccept()\fB\fR" 4
.IX Item "Accept()"
Return a list of \s-1MIME\s0 types that the remote browser accepts. If you
give this method a single argument corresponding to a \s-1MIME\s0 type, as in
Accept('text/html'), it will return a floating point value
corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.
.Sp
Note that the capitalization changed between version 2.43 and 2.44 in
order to avoid conflict with Perl's \fIaccept()\fR function.
.IP "\fB\f(BIraw_cookie()\fB\fR" 4
.IX Item "raw_cookie()"
Returns the \s-1HTTP_COOKIE\s0 variable.  Cookies have a special format, and
this method call just returns the raw form (?cookie dough).  See
\&\fIcookie()\fR for ways of setting and retrieving cooked cookies.
.Sp
Called with no parameters, \fIraw_cookie()\fR returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence \*(L"; \*(R".  Called with the name of a cookie,
retrieves the \fBunescaped\fR form of the cookie.  You can use the
regular \fIcookie()\fR method to get the names, or use the \fIraw_fetch()\fR
method from the CGI::Cookie module.
.IP "\fB\f(BIuser_agent()\fB\fR" 4
.IX Item "user_agent()"
Returns the \s-1HTTP_USER_AGENT\s0 variable.  If you give
this method a single argument, it will attempt to
pattern match on it, allowing you to do something
like user_agent(Mozilla);
.IP "\fB\f(BIpath_info()\fB\fR" 4
.IX Item "path_info()"
Returns additional path information from the script \s-1URL.
E.G.\s0 fetching /cgi\-bin/your_script/additional/stuff will result in
\&\fIpath_info()\fR returning \*(L"/additional/stuff\*(R".
.Sp
\&\s-1NOTE:\s0 The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl \s-1DLL\s0 library, the \s-1IIS\s0 server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment, 
but incorrect.  The best thing to do is to avoid using additional
path information in \s-1CGI\s0 scripts destined for use with \s-1IIS.\s0
.IP "\fB\f(BIpath_translated()\fB\fR" 4
.IX Item "path_translated()"
As per \fIpath_info()\fR but returns the additional
path information translated into a physical path, e.g.
\&\*(L"/usr/local/etc/httpd/htdocs/additional/stuff\*(R".
.Sp
The Microsoft \s-1IIS\s0 is broken with respect to the translated
path as well.
.IP "\fB\f(BIremote_host()\fB\fR" 4
.IX Item "remote_host()"
Returns either the remote host name or \s-1IP\s0 address.
if the former is unavailable.
.IP "\fB\f(BIremote_addr()\fB\fR" 4
.IX Item "remote_addr()"
Returns the remote host \s-1IP\s0 address, or 
127.0.0.1 if the address is unavailable.
.IP "\fB\f(BIscript_name()\fB\fR Return the script name as a partial \s-1URL,\s0 for self-referring scripts." 4
.IX Item "script_name() Return the script name as a partial URL, for self-referring scripts."
.PD 0
.IP "\fB\f(BIreferer()\fB\fR" 4
.IX Item "referer()"
.PD
Return the \s-1URL\s0 of the page the browser was viewing
prior to fetching your script.  Not available for all
browsers.
.IP "\fBauth_type ()\fR" 4
.IX Item "auth_type ()"
Return the authorization/verification method in use for this
script, if any.
.IP "\fBserver_name ()\fR" 4
.IX Item "server_name ()"
Returns the name of the server, usually the machine's host
name.
.IP "\fBvirtual_host ()\fR" 4
.IX Item "virtual_host ()"
When using virtual hosts, returns the name of the host that
the browser attempted to contact
.IP "\fBserver_port ()\fR" 4
.IX Item "server_port ()"
Return the port that the server is listening on.
.IP "\fBvirtual_port ()\fR" 4
.IX Item "virtual_port ()"
Like \fIserver_port()\fR except that it takes virtual hosts into account.
Use this when running with virtual hosts.
.IP "\fBserver_software ()\fR" 4
.IX Item "server_software ()"
Returns the server software and version number.
.IP "\fBremote_user ()\fR" 4
.IX Item "remote_user ()"
Return the authorization/verification name used for user
verification, if this script is protected.
.IP "\fBuser_name ()\fR" 4
.IX Item "user_name ()"
Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!
.IP "\fB\f(BIrequest_method()\fB\fR" 4
.IX Item "request_method()"
Returns the method used to access your script, usually
one of '\s-1POST\s0', '\s-1GET\s0' or '\s-1HEAD\s0'.
.IP "\fB\f(BIcontent_type()\fB\fR" 4
.IX Item "content_type()"
Returns the content_type of data submitted in a \s-1POST,\s0 generally 
multipart/form\-data or application/x\-www\-form\-urlencoded
.IP "\fB\f(BIhttp()\fB\fR" 4
.IX Item "http()"
Called with no arguments returns the list of \s-1HTTP\s0 environment
variables, including such things as \s-1HTTP_USER_AGENT,
HTTP_ACCEPT_LANGUAGE,\s0 and \s-1HTTP_ACCEPT_CHARSET,\s0 corresponding to the
like-named \s-1HTTP\s0 header fields in the request.  Called with the name of
an \s-1HTTP\s0 header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.
.Sp
For example, all three of these examples are equivalent:
.Sp
.Vb 3
\&   $requested_language = http(\*(AqAccept\-language\*(Aq);
\&   $requested_language = http(\*(AqAccept_language\*(Aq);
\&   $requested_language = http(\*(AqHTTP_ACCEPT_LANGUAGE\*(Aq);
.Ve
.IP "\fB\f(BIhttps()\fB\fR" 4
.IX Item "https()"
The same as \fI\fIhttp()\fI\fR, but operates on the \s-1HTTPS\s0 environment variables
present when the \s-1SSL\s0 protocol is in effect.  Can be used to determine
whether \s-1SSL\s0 is turned on.
.SH "USING NPH SCRIPTS"
.IX Header "USING NPH SCRIPTS"
\&\s-1NPH,\s0 or \*(L"no-parsed-header\*(R", scripts bypass the server completely by
sending the complete \s-1HTTP\s0 header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of \s-1HTTP\s0 extensions that are not directly supported by your server,
such as server push and \s-1PICS\s0 headers.
.PP
Servers use a variety of conventions for designating \s-1CGI\s0 scripts as
\&\s-1NPH. \s0 Many Unix servers look at the beginning of the script's name for
the prefix \*(L"nph\-\*(R".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an \s-1NPH\s0 script by examining the first line of script output.
.PP
\&\s-1CGI\s0.pm supports \s-1NPH\s0 scripts with a special \s-1NPH\s0 mode.  When in this
mode, \s-1CGI\s0.pm will output the necessary extra header information when
the \fIheader()\fR and \fIredirect()\fR methods are
called.
.PP
The Microsoft Internet Information Server requires \s-1NPH\s0 mode.  As of
version 2.30, \s-1CGI\s0.pm will automatically detect when the script is
running under \s-1IIS\s0 and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of \s-1NPH\s0 scripts, including the ability to redirect while
setting a cookie, \fBdo not work at all\fR on \s-1IIS\s0 without a special patch
from Microsoft.  See
http://web.archive.org/web/20010812012030/http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP
Non-Parsed Headers Stripped From \s-1CGI\s0 Applications That Have nph\-
Prefix in Name.
.IP "In the \fBuse\fR statement" 4
.IX Item "In the use statement"
Simply add the \*(L"\-nph\*(R" pragma to the list of symbols to be imported into
your script:
.Sp
.Vb 1
\&      use CGI qw(:standard \-nph)
.Ve
.IP "By calling the \fB\f(BInph()\fB\fR method:" 4
.IX Item "By calling the nph() method:"
Call \fB\f(BInph()\fB\fR with a non-zero parameter at any point after using \s-1CGI\s0.pm in your program.
.Sp
.Vb 1
\&      CGI\->nph(1)
.Ve
.IP "By using \fB\-nph\fR parameters" 4
.IX Item "By using -nph parameters"
in the \fB\f(BIheader()\fB\fR and \fB\f(BIredirect()\fB\fR  statements:
.Sp
.Vb 1
\&      print header(\-nph=>1);
.Ve
.SH "Server Push"
.IX Header "Server Push"
\&\s-1CGI\s0.pm provides four simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@fidalgo.net>.  To
import these into your namespace, you must import the \*(L":push\*(R" set.
You are also advised to put the script into \s-1NPH\s0 mode and to set $| to
1 to avoid buffering problems.
.PP
Here is a simple script that demonstrates server push:
.PP
.Vb 10
\&  #!/usr/local/bin/perl
\&  use CGI qw/:push \-nph/;
\&  $| = 1;
\&  print multipart_init(\-boundary=>\*(Aq\-\-\-\-here we go!\*(Aq);
\&  for (0 .. 4) {
\&      print multipart_start(\-type=>\*(Aqtext/plain\*(Aq),
\&            "The current time is ",scalar(localtime),"\en";
\&      if ($_ < 4) {
\&              print multipart_end;
\&      } else {
\&              print multipart_final;
\&      }
\&      sleep 1;
\&  }
.Ve
.PP
This script initializes server push by calling \fB\f(BImultipart_init()\fB\fR.
It then enters a loop in which it begins a new multipart section by
calling \fB\f(BImultipart_start()\fB\fR, prints the current local time,
and ends a multipart section with \fB\f(BImultipart_end()\fB\fR.  It then sleeps
a second, and begins again. On the final iteration, it ends the
multipart section with \fB\f(BImultipart_final()\fB\fR rather than with
\&\fB\f(BImultipart_end()\fB\fR.
.IP "\fImultipart_init()\fR" 4
.IX Item "multipart_init()"
.Vb 1
\&  multipart_init(\-boundary=>$boundary);
.Ve
.Sp
Initialize the multipart system.  The \-boundary argument specifies
what \s-1MIME\s0 boundary string to use to separate parts of the document.
If not provided, \s-1CGI\s0.pm chooses a reasonable boundary for you.
.IP "\fImultipart_start()\fR" 4
.IX Item "multipart_start()"
.Vb 1
\&  multipart_start(\-type=>$type)
.Ve
.Sp
Start a new part of the multipart document using the specified \s-1MIME\s0
type.  If not specified, text/html is assumed.
.IP "\fImultipart_end()\fR" 4
.IX Item "multipart_end()"
.Vb 1
\&  multipart_end()
.Ve
.Sp
End a part.  You must remember to call \fImultipart_end()\fR once for each
\&\fImultipart_start()\fR, except at the end of the last part of the multipart
document when \fImultipart_final()\fR should be called instead of \fImultipart_end()\fR.
.IP "\fImultipart_final()\fR" 4
.IX Item "multipart_final()"
.Vb 1
\&  multipart_final()
.Ve
.Sp
End all parts.  You should call \fImultipart_final()\fR rather than
\&\fImultipart_end()\fR at the end of the last part of the multipart document.
.PP
Users interested in server push applications should also have a look
at the CGI::Push module.
.SH "Avoiding Denial of Service Attacks"
.IX Header "Avoiding Denial of Service Attacks"
A potential problem with \s-1CGI\s0.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a \s-1CGI\s0 script a huge \s-1POST\s0 of many
megabytes.  \s-1CGI\s0.pm will attempt to read the entire \s-1POST\s0 into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.
.PP
Another possible attack is for the remote user to force \s-1CGI\s0.pm to
accept a huge file upload.  \s-1CGI\s0.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  \s-1CGI\s0.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.
.PP
The best way to avoid denial of service attacks is to limit the amount
of memory, \s-1CPU\s0 time and disk space that \s-1CGI\s0 scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell \fIlimit\fR or \fIulimit\fR
commands to put ceilings on \s-1CGI\s0 resource usage.
.PP
\&\s-1CGI\s0.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the \s-1CGI\s0 name space:
.ie n .IP "\fB\fB$CGI::POST_MAX\fB\fR" 4
.el .IP "\fB\f(CB$CGI::POST_MAX\fB\fR" 4
.IX Item "$CGI::POST_MAX"
If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If \s-1CGI\s0.pm detects a \s-1POST\s0
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.
.ie n .IP "\fB\fB$CGI::DISABLE_UPLOADS\fB\fR" 4
.el .IP "\fB\f(CB$CGI::DISABLE_UPLOADS\fB\fR" 4
.IX Item "$CGI::DISABLE_UPLOADS"
If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.
.PP
You can use these variables in either of two ways.
.IP "\fB1. On a script-by-script basis\fR" 4
.IX Item "1. On a script-by-script basis"
Set the variable at the top of the script, right after the \*(L"use\*(R" statement:
.Sp
.Vb 4
\&    use CGI qw/:standard/;
\&    use CGI::Carp \*(AqfatalsToBrowser\*(Aq;
\&    $CGI::POST_MAX=1024 * 100;  # max 100K posts
\&    $CGI::DISABLE_UPLOADS = 1;  # no uploads
.Ve
.IP "\fB2. Globally for all scripts\fR" 4
.IX Item "2. Globally for all scripts"
Open up \s-1CGI\s0.pm, find the definitions for \f(CW$POST_MAX\fR and 
\&\f(CW$DISABLE_UPLOADS\fR, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
\&\fIinitialize_globals()\fR.
.PP
An attempt to send a \s-1POST\s0 larger than \f(CW$POST_MAX\fR bytes will cause
\&\fI\fIparam()\fI\fR to return an empty \s-1CGI\s0 parameter list.  You can test for
this event by checking \fI\fIcgi_error()\fI\fR, either after you create the \s-1CGI\s0
object or, if you are using the function-oriented interface, call
<\fIparam()\fR> for the first time.  If the \s-1POST\s0 was intercepted, then
\&\fIcgi_error()\fR will return the message \*(L"413 \s-1POST\s0 too large\*(R".
.PP
This error message is actually defined by the \s-1HTTP\s0 protocol, and is
designed to be returned to the browser as the \s-1CGI\s0 script's status
 code.  For example:
.PP
.Vb 5
\&   $uploaded_file = param(\*(Aqupload\*(Aq);
\&   if (!$uploaded_file && cgi_error()) {
\&      print header(\-status=>cgi_error());
\&      exit 0;
\&   }
.Ve
.PP
However it isn't clear that any browser currently knows what to do
with this status code.  It might be better just to create an
\&\s-1HTML\s0 page that warns the user of the problem.
.SH "COMPATIBILITY WITH CGI\-LIB.PL"
.IX Header "COMPATIBILITY WITH CGI-LIB.PL"
To make it easier to port existing programs that use cgi\-lib.pl the
compatibility routine \*(L"ReadParse\*(R" is provided.  Porting is simple:
.PP
\&\s-1OLD VERSION\s0
.PP
.Vb 3
\&    require "cgi\-lib.pl";
\&    &ReadParse;
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1NEW VERSION\s0
.PP
.Vb 3
\&    use CGI;
\&    CGI::ReadParse();
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1CGI\s0.pm's \fIReadParse()\fR routine creates a tied variable named \f(CW%in\fR,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of \f(CW@in\fR and \f(CW$in\fR
variables, are not supported.
.PP
Once you use ReadParse, you can retrieve the query object itself
this way:
.PP
.Vb 3
\&    $q = $in{CGI};
\&    print $q\->textfield(\-name=>\*(Aqwow\*(Aq,
\&            \-value=>\*(Aqdoes this really work?\*(Aq);
.Ve
.PP
This allows you to start using the more interesting features
of \s-1CGI\s0.pm without rewriting your old scripts from scratch.
.PP
An even simpler way to mix cgi-lib calls with \s-1CGI\s0.pm calls is to import both the
\&\f(CW\*(C`:cgi\-lib\*(C'\fR and \f(CW\*(C`:standard\*(C'\fR method:
.PP
.Vb 4
\& use CGI qw(:cgi\-lib :standard);
\& &ReadParse;
\& print "The price of your purchase is $in{price}.\en";
\& print textfield(\-name=>\*(Aqprice\*(Aq, \-default=>\*(Aq$1.99\*(Aq);
.Ve
.SS "Cgi-lib functions that are available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are available in CGI.pm"
In compatibility mode, the following cgi\-lib.pl functions are
available for your use:
.PP
.Vb 7
\& ReadParse()
\& PrintHeader()
\& HtmlTop()
\& HtmlBot()
\& SplitParam()
\& MethGet()
\& MethPost()
.Ve
.SS "Cgi-lib functions that are not available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are not available in CGI.pm"
.Vb 3
\&  * Extended form of ReadParse()
\&    The extended form of ReadParse() that provides for file upload
\&    spooling, is not available.
\&
\&  * MyBaseURL()
\&    This function is not available.  Use CGI.pm\*(Aqs url() method instead.
\&
\&  * MyFullURL()
\&    This function is not available.  Use CGI.pm\*(Aqs self_url() method
\&    instead.
\&
\&  * CgiError(), CgiDie()
\&    These functions are not supported.  Look at CGI::Carp for the way I
\&    prefer to handle error messages.
\&
\&  * PrintVariables()
\&    This function is not available.  To achieve the same effect,
\&       just print out the CGI object:
\&
\&       use CGI qw(:standard);
\&       $q = CGI\->new;
\&       print h1("The Variables Are"),$q;
\&
\&  * PrintEnv()
\&    This function is not available. You\*(Aqll have to roll your own if you really need it.
.Ve
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
The \s-1CGI\s0.pm distribution is copyright 1995\-2007, Lincoln D. Stein. It is
distributed under \s-1GPL\s0 and the Artistic License 2.0. It is currently
maintained by Mark Stosberg with help from many contributors.
.PP
Address bug reports and comments to: https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm
When sending bug reports, please provide the version of \s-1CGI\s0.pm, the version of
Perl, the name and version of your Web server, and the name and version of the
operating system you are using.  If the problem is even remotely browser
dependent, please provide information about the affected browsers as well.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks very much to:
.IP "Matt Heffron (heffron@falstaff.css.beckman.com)" 4
.IX Item "Matt Heffron (heffron@falstaff.css.beckman.com)"
.PD 0
.IP "James Taylor (james.taylor@srs.gov)" 4
.IX Item "James Taylor (james.taylor@srs.gov)"
.IP "Scott Anguish <sanguish@digifix.com>" 4
.IX Item "Scott Anguish <sanguish@digifix.com>"
.IP "Mike Jewell (mlj3u@virginia.edu)" 4
.IX Item "Mike Jewell (mlj3u@virginia.edu)"
.IP "Timothy Shimmin (tes@kbs.citri.edu.au)" 4
.IX Item "Timothy Shimmin (tes@kbs.citri.edu.au)"
.IP "Joergen Haegg (jh@axis.se)" 4
.IX Item "Joergen Haegg (jh@axis.se)"
.IP "Laurent Delfosse (delfosse@delfosse.com)" 4
.IX Item "Laurent Delfosse (delfosse@delfosse.com)"
.IP "Richard Resnick (applepi1@aol.com)" 4
.IX Item "Richard Resnick (applepi1@aol.com)"
.IP "Craig Bishop (csb@barwonwater.vic.gov.au)" 4
.IX Item "Craig Bishop (csb@barwonwater.vic.gov.au)"
.IP "Tony Curtis (tc@vcpc.univie.ac.at)" 4
.IX Item "Tony Curtis (tc@vcpc.univie.ac.at)"
.IP "Tim Bunce (Tim.Bunce@ig.co.uk)" 4
.IX Item "Tim Bunce (Tim.Bunce@ig.co.uk)"
.IP "Tom Christiansen (tchrist@convex.com)" 4
.IX Item "Tom Christiansen (tchrist@convex.com)"
.IP "Andreas Koenig (k@franz.ww.TU\-Berlin.DE)" 4
.IX Item "Andreas Koenig (k@franz.ww.TU-Berlin.DE)"
.IP "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)" 4
.IX Item "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)"
.IP "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)" 4
.IX Item "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)"
.IP "Stephen Dahmen (joyfire@inxpress.net)" 4
.IX Item "Stephen Dahmen (joyfire@inxpress.net)"
.IP "Ed Jordan (ed@fidalgo.net)" 4
.IX Item "Ed Jordan (ed@fidalgo.net)"
.IP "David Alan Pisoni (david@cnation.com)" 4
.IX Item "David Alan Pisoni (david@cnation.com)"
.IP "Doug MacEachern (dougm@opengroup.org)" 4
.IX Item "Doug MacEachern (dougm@opengroup.org)"
.IP "Robin Houston (robin@oneworld.org)" 4
.IX Item "Robin Houston (robin@oneworld.org)"
.IP "...and many many more..." 4
.IX Item "...and many many more..."
.PD
for suggestions and bug fixes.
.SH "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.IX Header "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.Vb 1
\&        #!/usr/local/bin/perl
\&
\&        use CGI \*(Aq:standard\*(Aq;
\&
\&        print header;
\&        print start_html("Example CGI.pm Form");
\&        print "<h1> Example CGI.pm Form</h1>\en";
\&        print_prompt();
\&        do_work();
\&        print_tail();
\&        print end_html;
\&
\&        sub print_prompt {
\&           print start_form;
\&           print "<em>What\*(Aqs your name?</em><br>";
\&           print textfield(\*(Aqname\*(Aq);
\&           print checkbox(\*(AqNot my real name\*(Aq);
\&
\&           print "<p><em>Where can you find English Sparrows?</em><br>";
\&           print checkbox_group(
\&                                 \-name=>\*(AqSparrow locations\*(Aq,
\&                                 \-values=>[England,France,Spain,Asia,Hoboken],
\&                                 \-linebreak=>\*(Aqyes\*(Aq,
\&                                 \-defaults=>[England,Asia]);
\&
\&           print "<p><em>How far can they fly?</em><br>",
\&                radio_group(
\&                        \-name=>\*(Aqhow far\*(Aq,
\&                        \-values=>[\*(Aq10 ft\*(Aq,\*(Aq1 mile\*(Aq,\*(Aq10 miles\*(Aq,\*(Aqreal far\*(Aq],
\&                        \-default=>\*(Aq1 mile\*(Aq);
\&
\&           print "<p><em>What\*(Aqs your favorite color?</em>  ";
\&           print popup_menu(\-name=>\*(AqColor\*(Aq,
\&                                    \-values=>[\*(Aqblack\*(Aq,\*(Aqbrown\*(Aq,\*(Aqred\*(Aq,\*(Aqyellow\*(Aq],
\&                                    \-default=>\*(Aqred\*(Aq);
\&
\&           print hidden(\*(AqReference\*(Aq,\*(AqMonty Python and the Holy Grail\*(Aq);
\&
\&           print "<p><em>What have you got there?</em><br>";
\&           print scrolling_list(
\&                         \-name=>\*(Aqpossessions\*(Aq,
\&                         \-values=>[\*(AqA Coconut\*(Aq,\*(AqA Grail\*(Aq,\*(AqAn Icon\*(Aq,
\&                                   \*(AqA Sword\*(Aq,\*(AqA Ticket\*(Aq],
\&                         \-size=>5,
\&                         \-multiple=>\*(Aqtrue\*(Aq);
\&
\&           print "<p><em>Any parting comments?</em><br>";
\&           print textarea(\-name=>\*(AqComments\*(Aq,
\&                                  \-rows=>10,
\&                                  \-columns=>50);
\&
\&           print "<p>",reset;
\&           print submit(\*(AqAction\*(Aq,\*(AqShout\*(Aq);
\&           print submit(\*(AqAction\*(Aq,\*(AqScream\*(Aq);
\&           print end_form;
\&           print "<hr>\en";
\&        }
\&
\&        sub do_work {
\&
\&           print "<h2>Here are the current settings in this form</h2>";
\&
\&           for my $key (param) {
\&              print "<strong>$key</strong> \-> ";
\&              my @values = param($key);
\&              print join(", ",@values),"<br>\en";
\&          }
\&        }
\&
\&        sub print_tail {
\&           print <<END;
\&        <hr>
\&        <address>Lincoln D. Stein</address><br>
\&        <a href="/">Home Page</a>
\&        END
\&        }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please report them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::Carp \- provides a Carp implementation tailored to the \s-1CGI\s0 environment.
.PP
CGI::Fast \- supports running \s-1CGI\s0 applications under FastCGI
.PP
CGI::Pretty \- pretty prints \s-1HTML\s0 generated by \s-1CGI\s0.pm (with a performance penalty)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 5513:" 4
.IX Item "Around line 5513:"
Expected text after =item, not a number
.IP "Around line 5517:" 4
.IX Item "Around line 5517:"
Expected text after =item, not a number
.IP "Around line 5521:" 4
.IX Item "Around line 5521:"
Expected text after =item, not a number
.IP "Around line 6083:" 4
.IX Item "Around line 6083:"
Expected text after =item, not a number
.IP "Around line 6087:" 4
.IX Item "Around line 6087:"
Expected text after =item, not a number
.IP "Around line 6092:" 4
.IX Item "Around line 6092:"
Expected text after =item, not a number
.IP "Around line 6097:" 4
.IX Item "Around line 6097:"
Expected text after =item, not a number
.IP "Around line 6166:" 4
.IX Item "Around line 6166:"
Expected text after =item, not a number
.IP "Around line 6170:" 4
.IX Item "Around line 6170:"
Expected text after =item, not a number
.IP "Around line 6181:" 4
.IX Item "Around line 6181:"
Expected text after =item, not a number
.IP "Around line 6186:" 4
.IX Item "Around line 6186:"
Expected text after =item, not a number
.IP "Around line 6521:" 4
.IX Item "Around line 6521:"
Expected text after =item, not a number
.IP "Around line 6527:" 4
.IX Item "Around line 6527:"
Expected text after =item, not a number
.IP "Around line 6536:" 4
.IX Item "Around line 6536:"
Expected text after =item, not a number
.IP "Around line 6540:" 4
.IX Item "Around line 6540:"
Expected text after =item, not a number
.IP "Around line 6546:" 4
.IX Item "Around line 6546:"
Expected text after =item, not a number
.IP "Around line 6552:" 4
.IX Item "Around line 6552:"
Expected text after =item, not a number
.IP "Around line 6597:" 4
.IX Item "Around line 6597:"
Expected text after =item, not a number
.IP "Around line 6605:" 4
.IX Item "Around line 6605:"
Expected text after =item, not a number
.IP "Around line 6612:" 4
.IX Item "Around line 6612:"
Expected text after =item, not a number
.IP "Around line 6690:" 4
.IX Item "Around line 6690:"
Expected text after =item, not a number
.IP "Around line 6696:" 4
.IX Item "Around line 6696:"
Expected text after =item, not a number
.IP "Around line 6701:" 4
.IX Item "Around line 6701:"
Expected text after =item, not a number
.IP "Around line 6707:" 4
.IX Item "Around line 6707:"
Expected text after =item, not a number
.IP "Around line 6747:" 4
.IX Item "Around line 6747:"
Expected text after =item, not a number
.IP "Around line 6751:" 4
.IX Item "Around line 6751:"
Expected text after =item, not a number
.IP "Around line 6759:" 4
.IX Item "Around line 6759:"
Expected text after =item, not a number
.IP "Around line 6766:" 4
.IX Item "Around line 6766:"
Expected text after =item, not a number
.IP "Around line 6771:" 4
.IX Item "Around line 6771:"
Expected text after =item, not a number
.IP "Around line 6847:" 4
.IX Item "Around line 6847:"
Expected text after =item, not a number
.IP "Around line 6853:" 4
.IX Item "Around line 6853:"
Expected text after =item, not a number
.IP "Around line 6859:" 4
.IX Item "Around line 6859:"
Expected text after =item, not a number
.IP "Around line 6908:" 4
.IX Item "Around line 6908:"
Expected text after =item, not a number
.IP "Around line 6913:" 4
.IX Item "Around line 6913:"
Expected text after =item, not a number
.IP "Around line 6951:" 4
.IX Item "Around line 6951:"
Expected text after =item, not a number
.IP "Around line 6956:" 4
.IX Item "Around line 6956:"
Expected text after =item, not a number
                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI5.16.3pm                                  0100644 0001750 0001750 00000472277 12566207430 022235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI 3pm"
.TH CGI 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI \- Handle Common Gateway Interface requests and responses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CGI;
\&
\&    my $q = CGI\->new;
\&
\&    # Process an HTTP request
\&     @values  = $q\->param(\*(Aqform_field\*(Aq);
\&
\&     $fh      = $q\->upload(\*(Aqfile_field\*(Aq);
\&
\&     $riddle  = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&     %answers = $query\->cookie(\*(Aqanswers\*(Aq);
\&
\&    # Prepare various HTTP responses
\&    print $q\->header();
\&    print $q\->header(\*(Aqapplication/json\*(Aq);
\&
\&        $cookie1 = $q\->cookie(\-name=>\*(Aqriddle_name\*(Aq, \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = $q\->cookie(\-name=>\*(Aqanswers\*(Aq, \-value=>\e%answers);
\&    print $q\->header(
\&        \-type    => \*(Aqimage/gif\*(Aq,
\&        \-expires => \*(Aq+3d\*(Aq,
\&        \-cookie  => [$cookie1,$cookie2]
\&        );
\&
\&   print  $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1CGI\s0.pm is a stable, complete and mature solution for processing and preparing
\&\s-1HTTP\s0 requests and responses.  Major features including processing form
submissions, file uploads, reading and writing cookies, query string generation
and manipulation, and processing and preparing \s-1HTTP\s0 headers. Some \s-1HTML\s0
generation utilities are included as well.
.PP
\&\s-1CGI\s0.pm performs very well in in a vanilla \s-1CGI\s0.pm environment and also comes
with built-in support for mod_perl and mod_perl2 as well as FastCGI.
.PP
It has the benefit of having developed and refined over 10 years with input
from dozens of contributors and being deployed on thousands of websites.
\&\s-1CGI\s0.pm has been included in the Perl distribution since Perl 5.4, and has
become a de-facto standard.
.SS "\s-1PROGRAMMING\s0 \s-1STYLE\s0"
.IX Subsection "PROGRAMMING STYLE"
There are two styles of programming with \s-1CGI\s0.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more \s-1CGI\s0 objects and then use object methods to create
the various elements of the page.  Each \s-1CGI\s0 object starts out with the
list of named parameters that were passed to your \s-1CGI\s0 script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the \*(L"state\*(R" of
the \s-1CGI\s0 script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.
.PP
For example, using the object oriented style, here is how you create
a simple \*(L"Hello World\*(R" \s-1HTML\s0 page:
.PP
.Vb 7
\&   #!/usr/local/bin/perl \-w
\&   use CGI;                             # load CGI routines
\&   $q = CGI\->new;                        # create new CGI object
\&   print $q\->header,                    # create the HTTP header
\&         $q\->start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         $q\->h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         $q\->end_html;                  # end the HTML
.Ve
.PP
In the function-oriented style, there is one default \s-1CGI\s0 object that
you rarely deal with directly.  Instead you just call functions to
retrieve \s-1CGI\s0 parameters, create \s-1HTML\s0 tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one \s-1CGI\s0 object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the \*(L"standard\*(R" functions), and we don't
need to create the \s-1CGI\s0 object.
.PP
.Vb 6
\&   #!/usr/local/bin/perl
\&   use CGI qw/:standard/;           # load standard CGI routines
\&   print header,                    # create the HTTP header
\&         start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         end_html;                  # end the HTML
.Ve
.PP
The examples in this document mainly use the object-oriented style.
See \s-1HOW\s0 \s-1TO\s0 \s-1IMPORT\s0 \s-1FUNCTIONS\s0 for important information on
function-oriented programming in \s-1CGI\s0.pm
.SS "\s-1CALLING\s0 \s-1CGI\s0.PM \s-1ROUTINES\s0"
.IX Subsection "CALLING CGI.PM ROUTINES"
Most \s-1CGI\s0.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:
.PP
.Vb 1
\&   print $q\->header(\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq);
.Ve
.PP
Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  \-type, \-Type, and \-TYPE are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, \s-1CGI\s0.pm assumes
dashes for the subsequent ones.
.PP
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  \fIheader()\fR happens to be one of these routines.  In this
case, the single argument is the document type.
.PP
.Vb 1
\&   print $q\->header(\*(Aqtext/html\*(Aq);
.Ve
.PP
Other such routines are documented below.
.PP
Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the \fIparam()\fR routine is used to set a \s-1CGI\s0 parameter to a
single or a multi-valued value.  The two cases are shown below:
.PP
.Vb 2
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>\*(Aqtomato\*(Aq);
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>[\*(Aqtomato\*(Aq,\*(Aqtomahto\*(Aq,\*(Aqpotato\*(Aq,\*(Aqpotahto\*(Aq]);
.Ve
.PP
A large number of routines in \s-1CGI\s0.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the \*(L"\s-1HTML\s0 shortcuts,\*(R" routines that generate \s-1HTML\s0 tags for
use in dynamically-generated pages.  \s-1HTML\s0 tags have both attributes
(the attribute=\*(L"value\*(R" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, \s-1CGI\s0.pm uses the convention of passing \s-1HTML\s0
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:
.PP
.Vb 6
\&   Code                           Generated HTML
\&   \-\-\-\-                           \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   h1()                           <h1>
\&   h1(\*(Aqsome\*(Aq,\*(Aqcontents\*(Aq);         <h1>some contents</h1>
\&   h1({\-align=>left});            <h1 align="LEFT">
\&   h1({\-align=>left},\*(Aqcontents\*(Aq); <h1 align="LEFT">contents</h1>
.Ve
.PP
\&\s-1HTML\s0 tags are described in more detail later.
.PP
Many newcomers to \s-1CGI\s0.pm are puzzled by the difference between the
calling conventions for the \s-1HTML\s0 shortcuts, which require curly braces
around the \s-1HTML\s0 tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the \s-1HTML\s0 shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:
.PP
.Vb 1
\&   print $q\->header( {\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq} );
.Ve
.PP
If you use the \fB\-w\fR switch, you will be warned that some \s-1CGI\s0.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the \-values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:
.IP "1." 4
Use another name for the argument, if one is available. 
For example, \-value is an alias for \-values.
.IP "2." 4
Change the capitalization, e.g. \-Values
.IP "3." 4
Put quotes around the argument name, e.g. '\-values'
.PP
Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard \s-1HTTP\s0
header fields by providing them as named arguments:
.PP
.Vb 4
\&  print $q\->header(\-type  =>  \*(Aqtext/html\*(Aq,
\&                   \-cost  =>  \*(AqThree smackers\*(Aq,
\&                   \-annoyance_level => \*(Aqhigh\*(Aq,
\&                   \-complaints_to   => \*(Aqbit bucket\*(Aq);
.Ve
.PP
This will produce the following nonstandard \s-1HTTP\s0 header:
.PP
.Vb 5
\&   HTTP/1.0 200 OK
\&   Cost: Three smackers
\&   Annoyance\-level: high
\&   Complaints\-to: bit bucket
\&   Content\-type: text/html
.Ve
.PP
Notice the way that underscores are translated automatically into
hyphens.  HTML-generating routines perform a different type of
translation.
.PP
This feature allows you to keep up with the rapidly changing \s-1HTTP\s0 and
\&\s-1HTML\s0 \*(L"standards\*(R".
.SS "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 (OBJECT-ORIENTED \s-1STYLE\s0):"
.IX Subsection "CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):"
.Vb 1
\&     $query = CGI\->new;
.Ve
.PP
This will parse the input (from \s-1POST\s0, \s-1GET\s0 and \s-1DELETE\s0 methods) and store
it into a perl5 object called \f(CW$query\fR.
.PP
Any filehandles from file uploads will have their position reset to 
the beginning of the file.
.SS "\s-1CREATING\s0 A \s-1NEW\s0 \s-1QUERY\s0 \s-1OBJECT\s0 \s-1FROM\s0 \s-1AN\s0 \s-1INPUT\s0 \s-1FILE\s0"
.IX Subsection "CREATING A NEW QUERY OBJECT FROM AN INPUT FILE"
.Vb 1
\&     $query = CGI\->new(INPUTFILE);
.Ve
.PP
If you provide a file handle to the \fInew()\fR method, it will read
parameters from the file (or \s-1STDIN\s0, or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited TAG=VALUE pairs will work).  Conveniently, this type
of file is created by the \fIsave()\fR method (see below).  Multiple records
can be saved and restored.
.PP
Perl purists will be pleased to know that this syntax accepts
references to file handles, or even references to filehandle globs,
which is the \*(L"official\*(R" way to pass a filehandle:
.PP
.Vb 1
\&    $query = CGI\->new(\e*STDIN);
.Ve
.PP
You can also initialize the \s-1CGI\s0 object with a FileHandle or IO::File
object.
.PP
If you are using the function-oriented interface and want to
initialize \s-1CGI\s0 state from a file handle, the way to do this is with
\&\fB\f(BIrestore_parameters()\fB\fR.  This will (re)initialize the
default \s-1CGI\s0 object from the indicated file handle.
.PP
.Vb 3
\&    open (IN,"test.in") || die;
\&    restore_parameters(IN);
\&    close IN;
.Ve
.PP
You can also initialize the query object from a hash
reference:
.PP
.Vb 4
\&    $query = CGI\->new( {\*(Aqdinosaur\*(Aq=>\*(Aqbarney\*(Aq,
\&                       \*(Aqsong\*(Aq=>\*(AqI love you\*(Aq,
\&                       \*(Aqfriends\*(Aq=>[qw/Jessica George Nancy/]}
\&                    );
.Ve
.PP
or from a properly formatted, URL-escaped query string:
.PP
.Vb 1
\&    $query = CGI\->new(\*(Aqdinosaur=barney&color=purple\*(Aq);
.Ve
.PP
or from a previously existing \s-1CGI\s0 object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):
.PP
.Vb 2
\&    $old_query = CGI\->new;
\&    $new_query = CGI\->new($old_query);
.Ve
.PP
To create an empty query, initialize it from an empty string or hash:
.PP
.Vb 1
\&   $empty_query = CGI\->new("");
\&
\&       \-or\-
\&
\&   $empty_query = CGI\->new({});
.Ve
.SS "\s-1FETCHING\s0 A \s-1LIST\s0 \s-1OF\s0 \s-1KEYWORDS\s0 \s-1FROM\s0 \s-1THE\s0 \s-1QUERY:\s0"
.IX Subsection "FETCHING A LIST OF KEYWORDS FROM THE QUERY:"
.Vb 1
\&     @keywords = $query\->keywords
.Ve
.PP
If the script was invoked as the result of an <\s-1ISINDEX\s0> search, the
parsed keywords can be obtained as an array using the \fIkeywords()\fR method.
.SS "\s-1FETCHING\s0 \s-1THE\s0 \s-1NAMES\s0 \s-1OF\s0 \s-1ALL\s0 \s-1THE\s0 \s-1PARAMETERS\s0 \s-1PASSED\s0 \s-1TO\s0 \s-1YOUR\s0 \s-1SCRIPT:\s0"
.IX Subsection "FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:"
.Vb 1
\&     @names = $query\->param
.Ve
.PP
If the script was invoked with a parameter list
(e.g. \*(L"name1=value1&name2=value2&name3=value3\*(R"), the \fIparam()\fR method
will return the parameter names as a list.  If the script was invoked
as an <\s-1ISINDEX\s0> script and contains a string without ampersands
(e.g. \*(L"value1+value2+value3\*(R") , there will be a single parameter named
\&\*(L"keywords\*(R" containing the \*(L"+\*(R"\-delimited keywords.
.PP
\&\s-1NOTE:\s0 As of version 1.5, the array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the 
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).
.SS "\s-1FETCHING\s0 \s-1THE\s0 \s-1VALUE\s0 \s-1OR\s0 \s-1VALUES\s0 \s-1OF\s0 A \s-1SINGLE\s0 \s-1NAMED\s0 \s-1PARAMETER:\s0"
.IX Subsection "FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:"
.Vb 1
\&    @values = $query\->param(\*(Aqfoo\*(Aq);
\&
\&              \-or\-
\&
\&    $value = $query\->param(\*(Aqfoo\*(Aq);
.Ve
.PP
Pass the \fIparam()\fR method a single argument to fetch the value of the
named parameter. If the parameter is multivalued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.
.PP
If a value is not given in the query string, as in the queries
\&\*(L"name1=&name2=\*(R", it will be returned as an empty string.
.PP
If the parameter does not exist at all, then \fIparam()\fR will return undef
in a scalar context, and the empty list in a list context.
.SS "\s-1SETTING\s0 \s-1THE\s0 \s-1VALUE\s0(S) \s-1OF\s0 A \s-1NAMED\s0 \s-1PARAMETER:\s0"
.IX Subsection "SETTING THE VALUE(S) OF A NAMED PARAMETER:"
.Vb 1
\&    $query\->param(\*(Aqfoo\*(Aq,\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq);
.Ve
.PP
This sets the value for the named parameter 'foo' to an array of
values.  This is one way to change the value of a field \s-1AFTER\s0
the script has been invoked once before.  (Another way is with
the \-override parameter accepted by all methods that generate
form elements.)
.PP
\&\fIparam()\fR also recognizes a named parameter style of calling described
in more detail later:
.PP
.Vb 1
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq]);
\&
\&                              \-or\-
\&
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-value=>\*(Aqthe value\*(Aq);
.Ve
.SS "\s-1APPENDING\s0 \s-1ADDITIONAL\s0 \s-1VALUES\s0 \s-1TO\s0 A \s-1NAMED\s0 \s-1PARAMETER:\s0"
.IX Subsection "APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:"
.Vb 1
\&   $query\->append(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqyet\*(Aq,\*(Aqmore\*(Aq,\*(Aqvalues\*(Aq]);
.Ve
.PP
This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.
.SS "\s-1IMPORTING\s0 \s-1ALL\s0 \s-1PARAMETERS\s0 \s-1INTO\s0 A \s-1NAMESPACE:\s0"
.IX Subsection "IMPORTING ALL PARAMETERS INTO A NAMESPACE:"
.Vb 1
\&   $query\->import_names(\*(AqR\*(Aq);
.Ve
.PP
This creates a series of variables in the 'R' namespace.  For example,
\&\f(CW$R::foo\fR, \f(CW@R:foo\fR.  For keyword lists, a variable \f(CW@R::keywords\fR will appear.
If no namespace is given, this method will assume 'Q'.
\&\s-1WARNING:\s0  don't import anything into 'main'; this is a major security
risk!!!!
.PP
\&\s-1NOTE\s0 1: Variable names are transformed as necessary into legal Perl
variable names.  All non-legal characters are transformed into
underscores.  If you need to keep the original names, you should use
the \fIparam()\fR method instead to access \s-1CGI\s0 variables by name.
.PP
\&\s-1NOTE\s0 2: In older versions, this method was called \fB\f(BIimport()\fB\fR.  As of version 2.20, 
this name has been removed completely to avoid conflict with the built-in
Perl module \fBimport\fR operator.
.SS "\s-1DELETING\s0 A \s-1PARAMETER\s0 \s-1COMPLETELY:\s0"
.IX Subsection "DELETING A PARAMETER COMPLETELY:"
.Vb 1
\&    $query\->delete(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq);
.Ve
.PP
This completely clears a list of parameters.  It sometimes useful for
resetting parameters that you don't want passed down between script
invocations.
.PP
If you are using the function call interface, use \*(L"\fIDelete()\fR\*(R" instead
to avoid conflicts with Perl's built-in delete operator.
.SS "\s-1DELETING\s0 \s-1ALL\s0 \s-1PARAMETERS:\s0"
.IX Subsection "DELETING ALL PARAMETERS:"
.Vb 1
\&   $query\->delete_all();
.Ve
.PP
This clears the \s-1CGI\s0 object completely.  It might be useful to ensure
that all the defaults are taken when you create a fill-out form.
.PP
Use \fIDelete_all()\fR instead if you are using the function call interface.
.SS "\s-1HANDLING\s0 NON-URLENCODED \s-1ARGUMENTS\s0"
.IX Subsection "HANDLING NON-URLENCODED ARGUMENTS"
If POSTed data is not of type application/x\-www\-form\-urlencoded or
multipart/form\-data, then the POSTed data will not be processed, but
instead be returned as-is in a parameter named \s-1POSTDATA\s0.  To retrieve
it, use code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPOSTDATA\*(Aq);
.Ve
.PP
Likewise if PUTed data can be retrieved with code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPUTDATA\*(Aq);
.Ve
.PP
(If you don't know what the preceding means, don't worry about it.  It
only affects people trying to use \s-1CGI\s0 for \s-1XML\s0 processing and other
specialized tasks.)
.SS "\s-1DIRECT\s0 \s-1ACCESS\s0 \s-1TO\s0 \s-1THE\s0 \s-1PARAMETER\s0 \s-1LIST:\s0"
.IX Subsection "DIRECT ACCESS TO THE PARAMETER LIST:"
.Vb 2
\&   $q\->param_fetch(\*(Aqaddress\*(Aq)\->[1] = \*(Aq1313 Mockingbird Lane\*(Aq;
\&   unshift @{$q\->param_fetch(\-name=>\*(Aqaddress\*(Aq)},\*(AqGeorge Munster\*(Aq;
.Ve
.PP
If you need access to the parameter list in a way that isn't covered
by the methods given in the previous sections, you can obtain a direct 
reference to it by
calling the \fB\f(BIparam_fetch()\fB\fR method with the name of the parameter.  This
will return an array reference to the named parameter, which you then
can manipulate in any way you like.
.PP
You can also use a named argument style using the \fB\-name\fR argument.
.SS "\s-1FETCHING\s0 \s-1THE\s0 \s-1PARAMETER\s0 \s-1LIST\s0 \s-1AS\s0 A \s-1HASH:\s0"
.IX Subsection "FETCHING THE PARAMETER LIST AS A HASH:"
.Vb 4
\&    $params = $q\->Vars;
\&    print $params\->{\*(Aqaddress\*(Aq};
\&    @foo = split("\e0",$params\->{\*(Aqfoo\*(Aq});
\&    %params = $q\->Vars;
\&
\&    use CGI \*(Aq:cgi\-lib\*(Aq;
\&    $params = Vars;
.Ve
.PP
Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the \s-1CGI\s0 parameters, and the values are the
parameters' values.  The \fIVars()\fR method does this.  Called in a scalar
context, it returns the parameter list as a tied hash reference.
Changing a key changes the value of the parameter in the underlying
\&\s-1CGI\s0 parameter list.  Called in a list context, it returns the
parameter list as an ordinary hash.  This allows you to read the
contents of the parameter list, but not to change it.
.PP
When using this, the thing you must watch out for are multivalued \s-1CGI\s0
parameters.  Because a hash cannot distinguish between scalar and
list context, multivalued parameters will be returned as a packed
string, separated by the \*(L"\e0\*(R" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi\-lib.pl
module for Perl version 4.
.PP
If you wish to use \fIVars()\fR as a function, import the \fI:cgi\-lib\fR set of
function calls (also see the section on CGI-LIB compatibility).
.SS "\s-1SAVING\s0 \s-1THE\s0 \s-1STATE\s0 \s-1OF\s0 \s-1THE\s0 \s-1SCRIPT\s0 \s-1TO\s0 A \s-1FILE:\s0"
.IX Subsection "SAVING THE STATE OF THE SCRIPT TO A FILE:"
.Vb 1
\&    $query\->save(\e*FILEHANDLE)
.Ve
.PP
This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the \fInew()\fR method.  Note that the filehandle can be a file, a pipe,
or whatever!
.PP
The format of the saved file is:
.PP
.Vb 5
\&        NAME1=VALUE1
\&        NAME1=VALUE1\*(Aq
\&        NAME2=VALUE2
\&        NAME3=VALUE3
\&        =
.Ve
.PP
Both name and value are \s-1URL\s0 escaped.  Multi-valued \s-1CGI\s0 parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to \fBnew\fR.  You can do this across several
sessions by opening the file in append mode, allowing you to create
primitive guest books, or to keep a history of users' queries.  Here's
a short example of creating multiple session records:
.PP
.Vb 1
\&   use CGI;
\&
\&   open (OUT,\*(Aq>>\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   $records = 5;
\&   for (0..$records) {
\&       my $q = CGI\->new;
\&       $q\->param(\-name=>\*(Aqcounter\*(Aq,\-value=>$_);
\&       $q\->save(\e*OUT);
\&   }
\&   close OUT;
\&
\&   # reopen for reading
\&   open (IN,\*(Aq<\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   while (!eof(IN)) {
\&       my $q = CGI\->new(\e*IN);
\&       print $q\->param(\*(Aqcounter\*(Aq),"\en";
\&   }
.Ve
.PP
The file format used for save/restore is identical to that used by the
Whitehead Genome Center's data exchange format \*(L"Boulderio\*(R", and can be
manipulated and even databased using Boulderio utilities.  See
.PP
.Vb 1
\&  http://stein.cshl.org/boulder/
.Ve
.PP
for further details.
.PP
If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is \fB\f(BIsave_parameters()\fB\fR.
.SS "\s-1RETRIEVING\s0 \s-1CGI\s0 \s-1ERRORS\s0"
.IX Subsection "RETRIEVING CGI ERRORS"
Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, \s-1CGI\s0 will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the \fI\fIcgi_error()\fI\fR function.
The error messages are formatted as \s-1HTTP\s0 status codes. You can either
incorporate the error text into an \s-1HTML\s0 page, or use it as the value
of the \s-1HTTP\s0 status:
.PP
.Vb 8
\&    my $error = $q\->cgi_error;
\&    if ($error) {
\&        print $q\->header(\-status=>$error),
\&              $q\->start_html(\*(AqProblems\*(Aq),
\&              $q\->h2(\*(AqRequest not processed\*(Aq),
\&              $q\->strong($error);
\&        exit 0;
\&    }
.Ve
.PP
When using the function-oriented interface (see the next section),
errors may only occur the first time you call \fI\fIparam()\fI\fR. Be ready
for this!
.SS "\s-1USING\s0 \s-1THE\s0 FUNCTION-ORIENTED \s-1INTERFACE\s0"
.IX Subsection "USING THE FUNCTION-ORIENTED INTERFACE"
To use the function-oriented interface, you must specify which \s-1CGI\s0.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.
.PP
.Vb 1
\&   use CGI <list of methods>;
.Ve
.PP
The listed methods will be imported into the current package; you can
call them directly without creating a \s-1CGI\s0 object first.  This example
shows how to import the \fB\f(BIparam()\fB\fR and \fB\f(BIheader()\fB\fR
methods, and then use them directly:
.PP
.Vb 3
\&   use CGI \*(Aqparam\*(Aq,\*(Aqheader\*(Aq;
\&   print header(\*(Aqtext/plain\*(Aq);
\&   $zipcode = param(\*(Aqzipcode\*(Aq);
.Ve
.PP
More frequently, you'll import common sets of functions by referring
to the groups by name.  All function sets are preceded with a \*(L":\*(R"
character as in \*(L":html3\*(R" (for tags defined in the \s-1HTML\s0 3 standard).
.PP
Here is a list of the function sets you can import:
.IP "\fB:cgi\fR" 4
.IX Item ":cgi"
Import all CGI-handling methods, such as \fB\f(BIparam()\fB\fR, \fB\f(BIpath_info()\fB\fR
and the like.
.IP "\fB:form\fR" 4
.IX Item ":form"
Import all fill-out form generating methods, such as \fB\f(BItextfield()\fB\fR.
.IP "\fB:html2\fR" 4
.IX Item ":html2"
Import all methods that generate \s-1HTML\s0 2.0 standard elements.
.IP "\fB:html3\fR" 4
.IX Item ":html3"
Import all methods that generate \s-1HTML\s0 3.0 elements (such as
<table>, <super> and <sub>).
.IP "\fB:html4\fR" 4
.IX Item ":html4"
Import all methods that generate \s-1HTML\s0 4 elements (such as
<abbrev>, <acronym> and <thead>).
.IP "\fB:netscape\fR" 4
.IX Item ":netscape"
Import the <blink>, <fontsize> and <center> tags.
.IP "\fB:html\fR" 4
.IX Item ":html"
Import all HTML-generating shortcuts (i.e. 'html2', 'html3', 'html4' and 'netscape')
.IP "\fB:standard\fR" 4
.IX Item ":standard"
Import \*(L"standard\*(R" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.
.IP "\fB:all\fR" 4
.IX Item ":all"
Import all the available methods.  For the full list, see the \s-1CGI\s0.pm
code, where the variable \f(CW%EXPORT_TAGS\fR is defined.
.PP
If you import a function name that is not part of \s-1CGI\s0.pm, the module
will treat it as a new \s-1HTML\s0 tag and generate the appropriate
subroutine.  You can then use it like any other \s-1HTML\s0 tag.  This is to
provide for the rapidly-evolving \s-1HTML\s0 \*(L"standard.\*(R"  For example, say
Microsoft comes out with a new tag called <gradient> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of \s-1CGI\s0.pm
to start using it immediately:
.PP
.Vb 2
\&   use CGI qw/:standard :html3 gradient/;
\&   print gradient({\-start=>\*(Aqred\*(Aq,\-end=>\*(Aqblue\*(Aq});
.Ve
.PP
Note that in the interests of execution speed \s-1CGI\s0.pm does \fBnot\fR use
the standard Exporter syntax for specifying load symbols.  This may
change in the future.
.PP
If you import any of the state-maintaining \s-1CGI\s0 or form-generating
methods, a default \s-1CGI\s0 object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes \fB\f(BIparam()\fB\fR, \fB\f(BItextfield()\fB\fR,
\&\fB\f(BIsubmit()\fB\fR and the like.  (If you need direct access to the \s-1CGI\s0
object, you can find it in the global variable \fB\f(CB$CGI::Q\fB\fR).  By
importing \s-1CGI\s0.pm methods, you can create visually elegant scripts:
.PP
.Vb 10
\&   use CGI qw/:standard/;
\&   print 
\&       header,
\&       start_html(\*(AqSimple Script\*(Aq),
\&       h1(\*(AqSimple Script\*(Aq),
\&       start_form,
\&       "What\*(Aqs your name? ",textfield(\*(Aqname\*(Aq),p,
\&       "What\*(Aqs the combination?",
\&       checkbox_group(\-name=>\*(Aqwords\*(Aq,
\&                      \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                      \-defaults=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq]),p,
\&       "What\*(Aqs your favorite color?",
\&       popup_menu(\-name=>\*(Aqcolor\*(Aq,
\&                  \-values=>[\*(Aqred\*(Aq,\*(Aqgreen\*(Aq,\*(Aqblue\*(Aq,\*(Aqchartreuse\*(Aq]),p,
\&       submit,
\&       end_form,
\&       hr,"\en";
\&
\&    if (param) {
\&       print 
\&           "Your name is ",em(param(\*(Aqname\*(Aq)),p,
\&           "The keywords are: ",em(join(", ",param(\*(Aqwords\*(Aq))),p,
\&           "Your favorite color is ",em(param(\*(Aqcolor\*(Aq)),".\en";
\&    }
\&    print end_html;
.Ve
.SS "\s-1PRAGMAS\s0"
.IX Subsection "PRAGMAS"
In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that \s-1CGI\s0.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same \fIuse()\fR line.  For example, the following use statement imports the
standard set of functions and enables debugging mode (pragma
\&\-debug):
.PP
.Vb 1
\&   use CGI qw/:standard \-debug/;
.Ve
.PP
The current list of pragmas is as follows:
.IP "\-any" 4
.IX Item "-any"
When you \fIuse \s-1CGI\s0 \-any\fR, then any method that the query object
doesn't recognize will be interpreted as a new \s-1HTML\s0 tag.  This allows
you to support the next \fIad hoc\fR \s-1HTML\s0
extension.  This lets you go wild with new and unsupported tags:
.Sp
.Vb 3
\&   use CGI qw(\-any);
\&   $q=CGI\->new;
\&   print $q\->gradient({speed=>\*(Aqfast\*(Aq,start=>\*(Aqred\*(Aq,end=>\*(Aqblue\*(Aq});
.Ve
.Sp
Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an \s-1HTML\s0 tag, use it with care or not at
all.
.IP "\-compile" 4
.IX Item "-compile"
This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcolm Beattie's Perl compiler.  Use
it in conjunction with the methods or method families you plan to use.
.Sp
.Vb 1
\&   use CGI qw(\-compile :standard :html3);
.Ve
.Sp
or even
.Sp
.Vb 1
\&   use CGI qw(\-compile :all);
.Ve
.Sp
Note that using the \-compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
\&\fIcompile()\fR method instead:
.Sp
.Vb 2
\&   use CGI();
\&   CGI\->compile();
.Ve
.Sp
This is particularly useful in a mod_perl environment, in which you
might want to precompile all \s-1CGI\s0 routines in a startup script, and
then import the functions individually in each mod_perl script.
.IP "\-nosticky" 4
.IX Item "-nosticky"
By default the \s-1CGI\s0 module implements a state-preserving behavior
called \*(L"sticky\*(R" fields.  The way this works is that if you are
regenerating a form, the methods that generate the form field values
will interrogate \fIparam()\fR to see if similarly-named parameters are
present in the query string. If they find a like-named parameter, they
will use it to set their default values.
.Sp
Sometimes this isn't what you want.  The \fB\-nosticky\fR pragma prevents
this behavior.  You can also selectively change the sticky behavior in
each element that you generate.
.IP "\-tabindex" 4
.IX Item "-tabindex"
Automatically add tab index attributes to each form field. With this
option turned off, you can still add tab indexes manually by passing a
\&\-tabindex option to each field-generating method.
.IP "\-no_undef_params" 4
.IX Item "-no_undef_params"
This keeps \s-1CGI\s0.pm from including undef params in the parameter list.
.IP "\-no_xhtml" 4
.IX Item "-no_xhtml"
By default, \s-1CGI\s0.pm versions 2.69 and higher emit \s-1XHTML\s0
(http://www.w3.org/TR/xhtml1/).  The \-no_xhtml pragma disables this
feature.  Thanks to Michalis Kabrianis <kabrianis@hellug.gr> for this
feature.
.Sp
If \fIstart_html()\fR's \-dtd parameter specifies an \s-1HTML\s0 2.0, 
3.2, 4.0 or 4.01 \s-1DTD\s0, 
\&\s-1XHTML\s0 will automatically be disabled without needing to use this 
pragma.
.IP "\-utf8" 4
.IX Item "-utf8"
This makes \s-1CGI\s0.pm treat all parameters as \s-1UTF\-8\s0 strings. Use this with
care, as it will interfere with the processing of binary uploads. It
is better to manually select which fields are expected to return utf\-8
strings and convert them using code like this:
.Sp
.Vb 2
\& use Encode;
\& my $arg = decode utf8=>param(\*(Aqfoo\*(Aq);
.Ve
.IP "\-nph" 4
.IX Item "-nph"
This makes \s-1CGI\s0.pm produce a header appropriate for an \s-1NPH\s0 (no
parsed header) script.  You may need to do other things as well
to tell the server that the script is \s-1NPH\s0.  See the discussion
of \s-1NPH\s0 scripts below.
.IP "\-newstyle_urls" 4
.IX Item "-newstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
semicolons rather than ampersands.  For example:
.Sp
.Vb 1
\&   ?name=fred;age=24;favorite_color=3
.Ve
.Sp
Semicolon-delimited query strings are always accepted, and will be emitted by
\&\fIself_url()\fR and \fIquery_string()\fR. newstyle_urls became the default in version
2.64.
.IP "\-oldstyle_urls" 4
.IX Item "-oldstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
ampersands rather than semicolons.  This is no longer the default.
.IP "\-autoload" 4
.IX Item "-autoload"
This overrides the autoloader so that any function in your program
that is not recognized is referred to \s-1CGI\s0.pm for possible evaluation.
This allows you to use all the \s-1CGI\s0.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  \fIWarning:\fR when
\&\fI\-autoload\fR is in effect, you cannot use \*(L"poetry mode\*(R"
(functions without the parenthesis).  Use \fI\fIhr()\fI\fR rather
than \fIhr\fR, or add something like \fIuse subs qw/hr p header/\fR 
to the top of your script.
.IP "\-no_debug" 4
.IX Item "-no_debug"
This turns off the command-line processing features.  If you want to
run a \s-1CGI\s0.pm script from the command line to produce \s-1HTML\s0, and you
don't want it to read \s-1CGI\s0 parameters from the command line or \s-1STDIN\s0,
then use this pragma:
.Sp
.Vb 1
\&   use CGI qw(\-no_debug :standard);
.Ve
.IP "\-debug" 4
.IX Item "-debug"
This turns on full debugging.  In addition to reading \s-1CGI\s0 arguments
from the command-line processing, \s-1CGI\s0.pm will pause and try to read
arguments from \s-1STDIN\s0, producing the message \*(L"(offline mode: enter
name=value pairs on standard input)\*(R" features.
.Sp
See the section on debugging for more details.
.IP "\-private_tempfiles" 4
.IX Item "-private_tempfiles"
\&\s-1CGI\s0.pm can process uploaded file. Ordinarily it spools the uploaded
file to a temporary directory, then deletes the file when done.
However, this opens the risk of eavesdropping as described in the file
upload section.  Another \s-1CGI\s0 script author could peek at this data
during the upload, even if it is confidential information. On Unix
systems, the \-private_tempfiles pragma will cause the temporary file
to be unlinked as soon as it is opened and before any data is written
into it, reducing, but not eliminating the risk of eavesdropping
(there is still a potential race condition).  To make life harder for
the attacker, the program chooses tempfile names by calculating a 32
bit checksum of the incoming \s-1HTTP\s0 headers.
.Sp
To ensure that the temporary file cannot be read by other \s-1CGI\s0 scripts,
use suEXEC or a \s-1CGI\s0 wrapper program to run your script.  The temporary
file is created with mode 0600 (neither world nor group readable).
.Sp
The temporary directory is selected using the following algorithm:
.Sp
.Vb 1
\&    1. if $CGITempFile::TMPDIRECTORY is already set, use that
\&
\&    2. if the environment variable TMPDIR exists, use the location
\&    indicated.
\&
\&    3. Otherwise try the locations /usr/tmp, /var/tmp, C:\etemp,
\&    /tmp, /temp, ::Temporary Items, and \eWWW_ROOT.
.Ve
.Sp
Each of these locations is checked that it is a directory and is
writable.  If not, the algorithm tries the next choice.
.SS "\s-1SPECIAL\s0 \s-1FORMS\s0 \s-1FOR\s0 \s-1IMPORTING\s0 HTML-TAG \s-1FUNCTIONS\s0"
.IX Subsection "SPECIAL FORMS FOR IMPORTING HTML-TAG FUNCTIONS"
Many of the methods generate \s-1HTML\s0 tags.  As described below, tag
functions automatically generate both the opening and closing tags.
For example:
.PP
.Vb 1
\&  print h1(\*(AqLevel 1 Header\*(Aq);
.Ve
.PP
produces
.PP
.Vb 1
\&  <h1>Level 1 Header</h1>
.Ve
.PP
There will be some times when you want to produce the start and end
tags yourself.  In this case, you can use the form start_\fItag_name\fR
and end_\fItag_name\fR, as in:
.PP
.Vb 1
\&  print start_h1,\*(AqLevel 1 Header\*(Aq,end_h1;
.Ve
.PP
With a few exceptions (described below), start_\fItag_name\fR and
end_\fItag_name\fR functions are not generated automatically when you
\&\fIuse \s-1CGI\s0\fR.  However, you can specify the tags you want to generate
\&\fIstart/end\fR functions for by putting an asterisk in front of their
name, or, alternatively, requesting either "start_\fItag_name\fR\*(L" or
\&\*(R"end_\fItag_name\fR" in the import list.
.PP
Example:
.PP
.Vb 1
\&  use CGI qw/:standard *table start_ul/;
.Ve
.PP
In this example, the following functions are generated in addition to
the standard ones:
.IP "1. \fIstart_table()\fR (generates a <table> tag)" 4
.IX Item "1. start_table() (generates a <table> tag)"
.PD 0
.IP "2. \fIend_table()\fR (generates a </table> tag)" 4
.IX Item "2. end_table() (generates a </table> tag)"
.IP "3. \fIstart_ul()\fR (generates a <ul> tag)" 4
.IX Item "3. start_ul() (generates a <ul> tag)"
.IP "4. \fIend_ul()\fR (generates a </ul> tag)" 4
.IX Item "4. end_ul() (generates a </ul> tag)"
.PD
.SH "GENERATING DYNAMIC DOCUMENTS"
.IX Header "GENERATING DYNAMIC DOCUMENTS"
Most of \s-1CGI\s0.pm's functions deal with creating documents on the fly.
Generally you will produce the \s-1HTTP\s0 header first, followed by the
document itself.  \s-1CGI\s0.pm provides functions for generating \s-1HTTP\s0
headers of various types as well as for generating \s-1HTML\s0.  For creating
\&\s-1GIF\s0 images, see the \s-1GD\s0.pm module.
.PP
Each of these functions produces a fragment of \s-1HTML\s0 or \s-1HTTP\s0 which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.
.SS "\s-1CREATING\s0 A \s-1STANDARD\s0 \s-1HTTP\s0 \s-1HEADER:\s0"
.IX Subsection "CREATING A STANDARD HTTP HEADER:"
Normally the first thing you will do in any \s-1CGI\s0 script is print out an
\&\s-1HTTP\s0 header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
.PP
.Vb 1
\&        print header;
\&
\&             \-or\-
\&
\&        print header(\*(Aqimage/gif\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\*(Aqtext/html\*(Aq,\*(Aq204 No response\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\-type=>\*(Aqimage/gif\*(Aq,
\&                             \-nph=>1,
\&                             \-status=>\*(Aq402 Payment required\*(Aq,
\&                             \-expires=>\*(Aq+3d\*(Aq,
\&                             \-cookie=>$cookie,
\&                             \-charset=>\*(Aqutf\-7\*(Aq,
\&                             \-attachment=>\*(Aqfoo.gif\*(Aq,
\&                             \-Cost=>\*(Aq$2.00\*(Aq);
.Ve
.PP
\&\fIheader()\fR returns the Content-type: header.  You can provide your own
\&\s-1MIME\s0 type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, \*(L"No response\*(R" to create a
script that tells the browser to do nothing at all.
.PP
The last example shows the named argument style for passing arguments
to the \s-1CGI\s0 methods using named parameters.  Recognized parameters are
\&\fB\-type\fR, \fB\-status\fR, \fB\-expires\fR, and \fB\-cookie\fR.  Any other named
parameters will be stripped of their initial hyphens and turned into
header fields, allowing you to specify any \s-1HTTP\s0 header you desire.
Internal underscores will be turned into hyphens:
.PP
.Vb 1
\&    print header(\-Content_length=>3002);
.Ve
.PP
Most browsers will not cache the output from \s-1CGI\s0 scripts.  Every time
the browser reloads the page, the script is invoked anew.  You can
change this behavior with the \fB\-expires\fR parameter.  When you specify
an absolute or relative expiration interval with this parameter, some
browsers and proxy servers will cache the script's output until the
indicated expiration date.  The following forms are all valid for the
\&\-expires field:
.PP
.Vb 8
\&        +30s                              30 seconds from now
\&        +10m                              ten minutes from now
\&        +1h                               one hour from now
\&        \-1d                               yesterday (i.e. "ASAP!")
\&        now                               immediately
\&        +3M                               in three months
\&        +10y                              in ten years time
\&        Thursday, 25\-Apr\-1999 00:40:33 GMT  at the indicated time & date
.Ve
.PP
The \fB\-cookie\fR parameter generates a header that tells the browser to provide
a \*(L"magic cookie\*(R" during all subsequent transactions with your script.
Some cookies have a special format that includes interesting attributes
such as expiration time.  Use the \fIcookie()\fR method to create and retrieve
session cookies.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers that expect all their scripts to be \s-1NPH\s0.
.PP
The \fB\-charset\fR parameter can be used to control the character set
sent to the browser.  If not provided, defaults to \s-1ISO\-8859\-1\s0.  As a
side effect, this sets the \fIcharset()\fR method as well.
.PP
The \fB\-attachment\fR parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the \fB\-type\fR to \*(L"application/octet\-stream\*(R".
.PP
The \fB\-p3p\fR parameter will add a P3P tag to the outgoing header.  The
parameter can be an arrayref or a space-delimited string of P3P tags.
For example:
.PP
.Vb 2
\&   print header(\-p3p=>[qw(CAO DSP LAW CURa)]);
\&   print header(\-p3p=>\*(AqCAO DSP LAW CURa\*(Aq);
.Ve
.PP
In either case, the outgoing header will be formatted as:
.PP
.Vb 1
\&  P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"
.Ve
.PP
\&\s-1CGI\s0.pm will accept valid multi-line headers when each line is separated with a
\&\s-1CRLF\s0 value (\*(L"\er\en\*(R" on most platforms) followed by at least one space. For example:
.PP
.Vb 1
\&    print header( \-ingredients => "ham\er\en\eseggs\er\en\esbacon" );
.Ve
.PP
Invalid multi-line header input will trigger in an exception. When multi-line headers
are received, \s-1CGI\s0.pm will always output them back as a single line, according to the
folding rules of \s-1RFC\s0 2616: the newlines will be removed, while the white space remains.
.SS "\s-1GENERATING\s0 A \s-1REDIRECTION\s0 \s-1HEADER\s0"
.IX Subsection "GENERATING A REDIRECTION HEADER"
.Vb 1
\&   print $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.PP
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a \s-1URL\s0 based on the
time of day or the identity of the user.
.PP
The \fIredirect()\fR method redirects the browser to a different \s-1URL\s0.  If
you use redirection like this, you should \fBnot\fR print out a header as
well.
.PP
You should always use full URLs (including the http: or ftp: part) in
redirection requests.  Relative URLs will not work correctly.
.PP
You can also use named arguments:
.PP
.Vb 4
\&    print $q\->redirect(
\&        \-uri=>\*(Aqhttp://somewhere.else/in/movie/land\*(Aq,
\&            \-nph=>1,
\&         \-status=>301);
.Ve
.PP
All names arguments recognized by \fIheader()\fR are also recognized by
\&\fIredirect()\fR. However, most \s-1HTTP\s0 headers, including those generated by
\&\-cookie and \-target, are ignored by the browser.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH\s0 (no-parse-header) script.  This is important
to use with certain servers, such as Microsoft \s-1IIS\s0, which
expect all their scripts to be \s-1NPH\s0.
.PP
The \fB\-status\fR parameter will set the status of the redirect.  \s-1HTTP\s0
defines three different possible redirection status codes:
.PP
.Vb 3
\&     301 Moved Permanently
\&     302 Found
\&     303 See Other
.Ve
.PP
The default if not specified is 302, which means \*(L"moved temporarily.\*(R"
You may change the status to another status code if you wish.  Be
advised that changing the status to anything other than 301, 302 or
303 will probably break redirection.
.SS "\s-1CREATING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT\s0 \s-1HEADER\s0"
.IX Subsection "CREATING THE HTML DOCUMENT HEADER"
.Vb 8
\&   print start_html(\-title=>\*(AqSecrets of the Pyramids\*(Aq,
\&                            \-author=>\*(Aqfred@capricorn.org\*(Aq,
\&                            \-base=>\*(Aqtrue\*(Aq,
\&                            \-target=>\*(Aq_blank\*(Aq,
\&                            \-meta=>{\*(Aqkeywords\*(Aq=>\*(Aqpharaoh secret mummy\*(Aq,
\&                                    \*(Aqcopyright\*(Aq=>\*(Aqcopyright 1996 King Tut\*(Aq},
\&                            \-style=>{\*(Aqsrc\*(Aq=>\*(Aq/styles/style1.css\*(Aq},
\&                            \-BGCOLOR=>\*(Aqblue\*(Aq);
.Ve
.PP
The \fIstart_html()\fR routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.
.PP
This method returns a canned \s-1HTML\s0 header and the opening <body> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are \-title, \-author, \-base, \-xbase, \-dtd, \-lang and \-target
(see below for the explanation).  Any additional parameters you
provide, such as the unofficial \s-1BGCOLOR\s0 attribute, are added
to the <body> tag.  Additional parameters must be proceeded by a
hyphen.
.PP
The argument \fB\-xbase\fR allows you to provide an \s-1HREF\s0 for the <base> tag
different from the current location, as in
.PP
.Vb 1
\&    \-xbase=>"http://home.mcom.com/"
.Ve
.PP
All relative links will be interpreted relative to this tag.
.PP
The argument \fB\-target\fR allows you to provide a default target frame
for all the links and fill-out forms on the page.  \fBThis is a
non-standard \s-1HTTP\s0 feature which only works with some browsers!\fR
.PP
.Vb 1
\&    \-target=>"answer_window"
.Ve
.PP
All relative links will be interpreted relative to this tag.
You add arbitrary meta information to the header with the \fB\-meta\fR
argument.  This argument expects a reference to a hash
containing name/value pairs of meta information.  These will be turned
into a series of header <meta> tags that look something like this:
.PP
.Vb 2
\&    <meta name="keywords" content="pharaoh secret mummy">
\&    <meta name="description" content="copyright 1996 King Tut">
.Ve
.PP
To create an HTTP-EQUIV type of <meta> tag, use \fB\-head\fR, described
below.
.PP
The \fB\-style\fR argument is used to incorporate cascading stylesheets
into your code.  See the section on \s-1CASCADING\s0 \s-1STYLESHEETS\s0 for more
information.
.PP
The \fB\-lang\fR argument is used to incorporate a language attribute into
the <html> tag.  For example:
.PP
.Vb 1
\&    print $q\->start_html(\-lang=>\*(Aqfr\-CA\*(Aq);
.Ve
.PP
The default if not specified is \*(L"en-US\*(R" for \s-1US\s0 English, unless the 
\&\-dtd parameter specifies an \s-1HTML\s0 2.0 or 3.2 \s-1DTD\s0, in which case the
lang attribute is left off.  You can force the lang attribute to left
off in other cases by passing an empty string (\-lang=>'').
.PP
The \fB\-encoding\fR argument can be used to specify the character set for
\&\s-1XHTML\s0.  It defaults to iso\-8859\-1 if not specified.
.PP
The \fB\-dtd\fR argument can be used to specify a public \s-1DTD\s0 identifier string. For example:
.PP
.Vb 1
\&    \-dtd => \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq)
.Ve
.PP
Alternatively, it can take public and system \s-1DTD\s0 identifiers as an array:
.PP
.Vb 1
\&    dtd => [ \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq, \*(Aqhttp://www.w3.org/TR/html4/loose.dtd\*(Aq ]
.Ve
.PP
For the public \s-1DTD\s0 identifier to be considered, it must be valid. Otherwise it
will be replaced by the default \s-1DTD\s0. If the public \s-1DTD\s0 contains '\s-1XHTML\s0', \s-1CGI\s0.pm
will emit \s-1XML\s0.
.PP
The \fB\-declare_xml\fR argument, when used in conjunction with \s-1XHTML\s0,
will put a <?xml> declaration at the top of the \s-1HTML\s0 header. The sole
purpose of this declaration is to declare the character set
encoding. In the absence of \-declare_xml, the output \s-1HTML\s0 will contain
a <meta> tag that specifies the encoding, allowing the \s-1HTML\s0 to pass
most validators.  The default for \-declare_xml is false.
.PP
You can place other arbitrary \s-1HTML\s0 elements to the <head> section with the
\&\fB\-head\fR tag.  For example, to place a <link> element in the
head section, use this:
.PP
.Vb 2
\&    print start_html(\-head=>Link({\-rel=>\*(Aqshortcut icon\*(Aq,
\&                                  \-href=>\*(Aqfavicon.ico\*(Aq}));
.Ve
.PP
To incorporate multiple \s-1HTML\s0 elements into the <head> section, just pass an
array reference:
.PP
.Vb 7
\&    print start_html(\-head=>[ 
\&                             Link({\-rel=>\*(Aqnext\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s2.html\*(Aq}),
\&                             Link({\-rel=>\*(Aqprevious\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s1.html\*(Aq})
\&                             ]
\&                     );
.Ve
.PP
And here's how to create an HTTP-EQUIV <meta> tag:
.PP
.Vb 2
\&      print start_html(\-head=>meta({\-http_equiv => \*(AqContent\-Type\*(Aq,
\&                                    \-content    => \*(Aqtext/html\*(Aq}))
.Ve
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-script\fR, \fB\-noScript\fR, \fB\-onLoad\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onUnload\fR parameters are used
to add JavaScript calls to your pages.  \fB\-script\fR should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <script> block inside the \s-1HTML\s0 (not
\&\s-1HTTP\s0) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  \s-1CGI\s0.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.
.PP
The \fB\-onLoad\fR and \fB\-onUnload\fR parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
\&\fB\-script\fR field:
.PP
.Vb 10
\&      $query = CGI\->new;
\&      print header;
\&      $JSCRIPT=<<END;
\&      // Ask a silly question
\&      function riddle_me_this() {
\&         var r = prompt("What walks on four legs in the morning, " +
\&                       "two legs in the afternoon, " +
\&                       "and three legs in the evening?");
\&         response(r);
\&      }
\&      // Get a silly answer
\&      function response(answer) {
\&         if (answer == "man")
\&            alert("Right you are!");
\&         else
\&            alert("Wrong!  Guess again.");
\&      }
\&      END
\&      print start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                               \-script=>$JSCRIPT);
.Ve
.PP
Use the \fB\-noScript\fR parameter to pass some \s-1HTML\s0 text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).
.PP
The <script> tag, has several attributes including \*(L"type\*(R", \*(L"charset\*(R" and \*(L"src\*(R".
\&\*(L"src\*(R" allows you to keep JavaScript code in an external file. To use these
attributes pass a \s-1HASH\s0 reference in the \fB\-script\fR parameter containing one or
more of \-type, \-src, or \-code:
.PP
.Vb 4
\&    print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                         \-script=>{\-type=>\*(AqJAVASCRIPT\*(Aq,
\&                                   \-src=>\*(Aq/javascript/sphinx.js\*(Aq}
\&                         );
\&
\&    print $q\->(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&               \-script=>{\-type=>\*(AqPERLSCRIPT\*(Aq,
\&                         \-code=>\*(Aqprint "hello world!\en;"\*(Aq}
\&               );
.Ve
.PP
A final feature allows you to incorporate multiple <script> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:
.PP
.Vb 10
\&     print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                          \-script=>[
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities10.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities11.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/jscript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities12.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/ecmascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities219.js\*(Aq
\&                                    }
\&                                 ]
\&                             );
.Ve
.PP
The option \*(L"\-language\*(R" is a synonym for \-type, and is supported for
backwards compatibility.
.PP
The old-style positional parameters are as follows:
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The title
.IP "2." 4
.IX Item "2."
The author's e\-mail address (will create a <link rev=\*(L"\s-1MADE\s0\*(R"> tag if present
.IP "3." 4
.IX Item "3."
A 'true' flag if you want to include a <base> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!
.IP "4, 5, 6..." 4
.IX Item "4, 5, 6..."
Any other parameters you want to include in the <body> tag.  This is a good
place to put \s-1HTML\s0 extensions, such as colors and wallpaper patterns.
.SS "\s-1ENDING\s0 \s-1THE\s0 \s-1HTML\s0 \s-1DOCUMENT:\s0"
.IX Subsection "ENDING THE HTML DOCUMENT:"
.Vb 1
\&        print $q\->end_html;
.Ve
.PP
This ends an \s-1HTML\s0 document by printing the </body></html> tags.
.SS "\s-1CREATING\s0 A SELF-REFERENCING \s-1URL\s0 \s-1THAT\s0 \s-1PRESERVES\s0 \s-1STATE\s0 \s-1INFORMATION:\s0"
.IX Subsection "CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:"
.Vb 2
\&    $myself = $q\->self_url;
\&    print q(<a href="$myself">I\*(Aqm talking to myself.</a>);
.Ve
.PP
\&\fIself_url()\fR will return a \s-1URL\s0, that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.
.PP
.Vb 4
\&     $myself = $q\->self_url;
\&     print "<a href=\e"$myself#table1\e">See table 1</a>";
\&     print "<a href=\e"$myself#table2\e">See table 2</a>";
\&     print "<a href=\e"$myself#yourself\e">See for yourself</a>";
.Ve
.PP
If you want more control over what's returned, using the \fB\f(BIurl()\fB\fR
method instead.
.PP
You can also retrieve the unprocessed query string with \fIquery_string()\fR:
.PP
.Vb 1
\&    $the_string = $q\->query_string();
.Ve
.PP
The behavior of calling query_string is currently undefined when the \s-1HTTP\s0 method is
something other than \s-1GET\s0.
.SS "\s-1OBTAINING\s0 \s-1THE\s0 \s-1SCRIPT\s0'S \s-1URL\s0"
.IX Subsection "OBTAINING THE SCRIPT'S URL"
.Vb 7
\&    $full_url      = url();
\&    $full_url      = url(\-full=>1);  #alternative syntax
\&    $relative_url  = url(\-relative=>1);
\&    $absolute_url  = url(\-absolute=>1);
\&    $url_with_path = url(\-path_info=>1);
\&    $url_with_path_and_query = url(\-path_info=>1,\-query=>1);
\&    $netloc        = url(\-base => 1);
.Ve
.PP
\&\fB\f(BIurl()\fB\fR returns the script's \s-1URL\s0 in a variety of formats.  Called
without any arguments, it returns the full form of the \s-1URL\s0, including
host name and port number
.PP
.Vb 1
\&    http://your.host.com/path/to/script.cgi
.Ve
.PP
You can modify this format with the following named arguments:
.IP "\fB\-absolute\fR" 4
.IX Item "-absolute"
If true, produce an absolute \s-1URL\s0, e.g.
.Sp
.Vb 1
\&    /path/to/script.cgi
.Ve
.IP "\fB\-relative\fR" 4
.IX Item "-relative"
Produce a relative \s-1URL\s0.  This is useful if you want to reinvoke your
script with different parameters. For example:
.Sp
.Vb 1
\&    script.cgi
.Ve
.IP "\fB\-full\fR" 4
.IX Item "-full"
Produce the full \s-1URL\s0, exactly as if called without any arguments.
This overrides the \-relative and \-absolute arguments.
.IP "\fB\-path\fR (\fB\-path_info\fR)" 4
.IX Item "-path (-path_info)"
Append the additional path information to the \s-1URL\s0.  This can be
combined with \fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-path_info\fR
is provided as a synonym.
.IP "\fB\-query\fR (\fB\-query_string\fR)" 4
.IX Item "-query (-query_string)"
Append the query string to the \s-1URL\s0.  This can be combined with
\&\fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-query_string\fR is provided
as a synonym.
.IP "\fB\-base\fR" 4
.IX Item "-base"
Generate just the protocol and net location, as in http://www.foo.com:8000
.IP "\fB\-rewrite\fR" 4
.IX Item "-rewrite"
If Apache's mod_rewrite is turned on, then the script name and path
info probably won't match the request that the user sent. Set
\&\-rewrite=>1 (default) to return URLs that match what the user sent
(the original request \s-1URI\s0). Set \-rewrite=>0 to return URLs that match
the \s-1URL\s0 after mod_rewrite's rules have run.
.SS "\s-1MIXING\s0 \s-1POST\s0 \s-1AND\s0 \s-1URL\s0 \s-1PARAMETERS\s0"
.IX Subsection "MIXING POST AND URL PARAMETERS"
.Vb 1
\&   $color = url_param(\*(Aqcolor\*(Aq);
.Ve
.PP
It is possible for a script to receive \s-1CGI\s0 parameters in the \s-1URL\s0 as
well as in the fill-out form by creating a form that POSTs to a \s-1URL\s0
containing a query string (a \*(L"?\*(R" mark followed by arguments).  The
\&\fB\f(BIparam()\fB\fR method will always return the contents of the POSTed
fill-out form, ignoring the \s-1URL\s0's query string.  To retrieve \s-1URL\s0
parameters, call the \fB\f(BIurl_param()\fB\fR method.  Use it in the same way as
\&\fB\f(BIparam()\fB\fR.  The main difference is that it allows you to read the
parameters, but not set them.
.PP
Under no circumstances will the contents of the \s-1URL\s0 query string
interfere with similarly-named \s-1CGI\s0 parameters in POSTed forms.  If you
try to mix a \s-1URL\s0 query string with a form submitted with the \s-1GET\s0
method, the results will not be what you expect.
.SH "CREATING STANDARD HTML ELEMENTS:"
.IX Header "CREATING STANDARD HTML ELEMENTS:"
\&\s-1CGI\s0.pm defines general \s-1HTML\s0 shortcut methods for many \s-1HTML\s0 tags.  \s-1HTML\s0 shortcuts are named after a single
\&\s-1HTML\s0 element and return a fragment of \s-1HTML\s0 text. Example:
.PP
.Vb 7
\&   print $q\->blockquote(
\&                     "Many years ago on the island of",
\&                     $q\->a({href=>"http://crete.org/"},"Crete"),
\&                     "there lived a Minotaur named",
\&                     $q\->strong("Fred."),
\&                    ),
\&       $q\->hr;
.Ve
.PP
This results in the following \s-1HTML\s0 code (extra newlines have been
added for readability):
.PP
.Vb 6
\&   <blockquote>
\&   Many years ago on the island of
\&   <a href="http://crete.org/">Crete</a> there lived
\&   a minotaur named <strong>Fred.</strong> 
\&   </blockquote>
\&   <hr>
.Ve
.PP
If you find the syntax for calling the \s-1HTML\s0 shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):
.PP
.Vb 8
\&   use CGI \*(Aq:standard\*(Aq;
\&   print blockquote(
\&      "Many years ago on the island of",
\&      a({href=>"http://crete.org/"},"Crete"),
\&      "there lived a minotaur named",
\&      strong("Fred."),
\&      ),
\&      hr;
.Ve
.SS "\s-1PROVIDING\s0 \s-1ARGUMENTS\s0 \s-1TO\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"
.IX Subsection "PROVIDING ARGUMENTS TO HTML SHORTCUTS"
The \s-1HTML\s0 methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:
.PP
.Vb 1
\&   print hr;    #  <hr>
.Ve
.PP
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
.PP
.Vb 1
\&   print h1("Chapter","1"); # <h1>Chapter 1</h1>"
.Ve
.PP
If the first argument is a hash reference, then the keys
and values of the hash become the \s-1HTML\s0 tag's attributes:
.PP
.Vb 2
\&   print a({\-href=>\*(Aqfred.html\*(Aq,\-target=>\*(Aq_new\*(Aq},
\&      "Open a new frame");
\&
\&            <a href="fred.html",target="_new">Open a new frame</a>
.Ve
.PP
You may dispense with the dashes in front of the attribute names if
you prefer:
.PP
.Vb 1
\&   print img {src=>\*(Aqfred.gif\*(Aq,align=>\*(AqLEFT\*(Aq};
\&
\&           <img align="LEFT" src="fred.gif">
.Ve
.PP
Sometimes an \s-1HTML\s0 tag attribute has no argument.  For example, ordered
lists can be marked as \s-1COMPACT\s0.  The syntax for this is an argument that
that points to an undef string:
.PP
.Vb 1
\&   print ol({compact=>undef},li(\*(Aqone\*(Aq),li(\*(Aqtwo\*(Aq),li(\*(Aqthree\*(Aq));
.Ve
.PP
Prior to \s-1CGI\s0.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accommodate those who want to create tags of the form 
<img alt="">.  The difference is shown in these two pieces of code:
.PP
.Vb 3
\&   CODE                   RESULT
\&   img({alt=>undef})      <img alt>
\&   img({alt=>\*(Aq\*(Aq})         <img alt="">
.Ve
.SS "\s-1THE\s0 \s-1DISTRIBUTIVE\s0 \s-1PROPERTY\s0 \s-1OF\s0 \s-1HTML\s0 \s-1SHORTCUTS\s0"
.IX Subsection "THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS"
One of the cool features of the \s-1HTML\s0 shortcuts is that they are
distributive.  If you give them an argument consisting of a
\&\fBreference\fR to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:
.PP
.Vb 3
\&   print ul(
\&             li({\-type=>\*(Aqdisc\*(Aq},[\*(AqSneezy\*(Aq,\*(AqDoc\*(Aq,\*(AqSleepy\*(Aq,\*(AqHappy\*(Aq])
\&           );
.Ve
.PP
This example will result in \s-1HTML\s0 output that looks like this:
.PP
.Vb 6
\&   <ul>
\&     <li type="disc">Sneezy</li>
\&     <li type="disc">Doc</li>
\&     <li type="disc">Sleepy</li>
\&     <li type="disc">Happy</li>
\&   </ul>
.Ve
.PP
This is extremely useful for creating tables.  For example:
.PP
.Vb 11
\&   print table({\-border=>undef},
\&           caption(\*(AqWhen Should You Eat Your Vegetables?\*(Aq),
\&           Tr({\-align=>\*(AqCENTER\*(Aq,\-valign=>\*(AqTOP\*(Aq},
\&           [
\&              th([\*(AqVegetable\*(Aq, \*(AqBreakfast\*(Aq,\*(AqLunch\*(Aq,\*(AqDinner\*(Aq]),
\&              td([\*(AqTomatoes\*(Aq , \*(Aqno\*(Aq, \*(Aqyes\*(Aq, \*(Aqyes\*(Aq]),
\&              td([\*(AqBroccoli\*(Aq , \*(Aqno\*(Aq, \*(Aqno\*(Aq,  \*(Aqyes\*(Aq]),
\&              td([\*(AqOnions\*(Aq   , \*(Aqyes\*(Aq,\*(Aqyes\*(Aq, \*(Aqyes\*(Aq])
\&           ]
\&           )
\&        );
.Ve
.SS "\s-1HTML\s0 \s-1SHORTCUTS\s0 \s-1AND\s0 \s-1LIST\s0 \s-1INTERPOLATION\s0"
.IX Subsection "HTML SHORTCUTS AND LIST INTERPOLATION"
Consider this bit of code:
.PP
.Vb 1
\&   print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
.Ve
.PP
It will ordinarily return the string that you probably expect, namely:
.PP
.Vb 1
\&   <blockquote><em>Hi</em> mom!</blockquote>
.Ve
.PP
Note the space between the element \*(L"Hi\*(R" and the element \*(L"mom!\*(R".
\&\s-1CGI\s0.pm puts the extra space there using array interpolation, which is
controlled by the magic $\*(L" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $\*(R" to an
empty string.
.PP
.Vb 4
\&   {
\&      local($") = \*(Aq\*(Aq;
\&      print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
\&    }
.Ve
.PP
I suggest you put the code in a block as shown here.  Otherwise the
change to $" will affect all subsequent code until you explicitly
reset it.
.SS "NON-STANDARD \s-1HTML\s0 \s-1SHORTCUTS\s0"
.IX Subsection "NON-STANDARD HTML SHORTCUTS"
A few \s-1HTML\s0 tags don't follow the standard pattern for various
reasons.
.PP
\&\fB\f(BIcomment()\fB\fR generates an \s-1HTML\s0 comment (<!\-\- comment \-\->).  Call it
like
.PP
.Vb 1
\&    print comment(\*(Aqhere is my comment\*(Aq);
.Ve
.PP
Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:
.PP
.Vb 6
\&    Select
\&    Tr
\&    Link
\&    Delete
\&    Accept
\&    Sub
.Ve
.PP
In addition, \fIstart_html()\fR, \fIend_html()\fR, \fIstart_form()\fR, \fIend_form()\fR,
\&\fIstart_multipart_form()\fR and all the fill-out form tags are special.
See their respective sections.
.SS "\s-1AUTOESCAPING\s0 \s-1HTML\s0"
.IX Subsection "AUTOESCAPING HTML"
By default, all \s-1HTML\s0 that is emitted by the form-generating functions
is passed through a function called \fIescapeHTML()\fR:
.ie n .IP "$escaped_string = escapeHTML(""unescaped string"");" 4
.el .IP "\f(CW$escaped_string\fR = escapeHTML(``unescaped string'');" 4
.IX Item "$escaped_string = escapeHTML(unescaped string);"
Escape \s-1HTML\s0 formatting characters in a string.
.PP
Provided that you have specified a character set of \s-1ISO\-8859\-1\s0 (the
default), the standard \s-1HTML\s0 escaping rules will be used.  The \*(L"<\*(R"
character becomes \*(L"&lt;\*(R", \*(L">\*(R" becomes \*(L"&gt;\*(R", \*(L"&\*(R" becomes \*(L"&amp;\*(R", and
the quote character becomes \*(L"&quot;\*(R".  In addition, the hexadecimal
0x8b and 0x9b characters, which some browsers incorrectly interpret
as the left and right angle-bracket characters, are replaced by their
numeric character entities (\*(L"&#8249\*(R" and \*(L"&#8250;\*(R").  If you manually change
the charset, either by calling the \fIcharset()\fR method explicitly or by
passing a \-charset argument to \fIheader()\fR, then \fBall\fR characters will
be replaced by their numeric entities, since \s-1CGI\s0.pm has no lookup
table for all the possible encodings.
.PP
\&\f(CW\*(C`escapeHTML()\*(C'\fR expects the supplied string to be a character string. This means you
should Encode::decode data received from \*(L"outside\*(R" and Encode::encode your
strings before sending them back outside. If your source code \s-1UTF\-8\s0 encoded and
you want to upgrade string literals in your source to character strings, you
can use \*(L"use utf8\*(R". See perlunitut, perlunifaq and perlunicode for more
information on how Perl handles the difference between bytes and characters.
.PP
The automatic escaping does not apply to other shortcuts, such as
\&\fIh1()\fR.  You should call \fIescapeHTML()\fR yourself on untrusted data in
order to protect your pages against nasty tricks that people may enter
into guestbooks, etc..  To change the character set, use \fIcharset()\fR.
To turn autoescaping off completely, use \fIautoEscape\fR\|(0):
.ie n .IP "$charset = charset([$charset]);" 4
.el .IP "\f(CW$charset\fR = charset([$charset]);" 4
.IX Item "$charset = charset([$charset]);"
Get or set the current character set.
.ie n .IP "$flag = autoEscape([$flag]);" 4
.el .IP "\f(CW$flag\fR = autoEscape([$flag]);" 4
.IX Item "$flag = autoEscape([$flag]);"
Get or set the value of the autoescape flag.
.SS "PRETTY-PRINTING \s-1HTML\s0"
.IX Subsection "PRETTY-PRINTING HTML"
By default, all the \s-1HTML\s0 produced by these functions comes out as one
long line without carriage returns or indentation. This is yuck, but
it does reduce the size of the documents by 10\-20%.  To get
pretty-printed output, please use CGI::Pretty, a subclass
contributed by Brian Paulsen.
.SH "CREATING FILL-OUT FORMS:"
.IX Header "CREATING FILL-OUT FORMS:"
\&\fIGeneral note\fR  The various form-creating methods all return strings
to the caller, containing the tag or tags that will create the requested
form element.  You are responsible for actually printing out these strings.
It's set up this way so that you can place formatting tags
around the form elements.
.PP
\&\fIAnother note\fR The default values that you specify for the forms are only
used the \fBfirst\fR time the script is invoked (when there is no query
string).  On subsequent invocations of the script (when there is a query
string), the former values are used even if they are blank.
.PP
If you want to change the value of a field from its previous value, you have two
choices:
.PP
(1) call the \fIparam()\fR method to set it.
.PP
(2) use the \-override (alias \-force) parameter (a new feature in version 2.15).
This forces the default value to be used, regardless of the previous value:
.PP
.Vb 5
\&   print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                           \-default=>\*(Aqstarting value\*(Aq,
\&                           \-override=>1,
\&                           \-size=>50,
\&                           \-maxlength=>80);
.Ve
.PP
\&\fIYet another note\fR By default, the text and labels of form elements are
escaped according to \s-1HTML\s0 rules.  This means that you can safely use
\&\*(L"<\s-1CLICK\s0 \s-1ME\s0>\*(R" as the label for a button.  However, it also interferes with
your ability to incorporate special \s-1HTML\s0 character sequences, such as &Aacute;,
into your fields.  If you wish to turn off automatic escaping, call the
\&\fIautoEscape()\fR method with a false value immediately after creating the \s-1CGI\s0 object:
.PP
.Vb 2
\&   $query = CGI\->new;
\&   $query\->autoEscape(0);
.Ve
.PP
Note that \fIautoEscape()\fR is exclusively used to effect the behavior of how some
\&\s-1CGI\s0.pm \s-1HTML\s0 generation functions handle escaping. Calling \fIescapeHTML()\fR
explicitly will always escape the \s-1HTML\s0.
.PP
\&\fIA Lurking Trap!\fR Some of the form-element generating methods return
multiple tags.  In a scalar context, the tags will be concatenated
together with spaces, or whatever is the current value of the $"
global.  In a list context, the methods will return a list of
elements, allowing you to modify them if you wish.  Usually you will
not notice this behavior, but beware of this:
.PP
.Vb 1
\&    printf("%s\en",end_form())
.Ve
.PP
\&\fIend_form()\fR produces several tags, and only the first of them will be
printed because the format only expects one value.
.PP
<p>
.SS "\s-1CREATING\s0 \s-1AN\s0 \s-1ISINDEX\s0 \s-1TAG\s0"
.IX Subsection "CREATING AN ISINDEX TAG"
.Vb 1
\&   print isindex(\-action=>$action);
\&
\&         \-or\-
\&
\&   print isindex($action);
.Ve
.PP
Prints out an <isindex> tag.  Not very exciting.  The parameter
\&\-action specifies the \s-1URL\s0 of the script to process the query.  The
default is to process the query with the current script.
.SS "\s-1STARTING\s0 \s-1AND\s0 \s-1ENDING\s0 A \s-1FORM\s0"
.IX Subsection "STARTING AND ENDING A FORM"
.Vb 5
\&    print start_form(\-method=>$method,
\&                    \-action=>$action,
\&                    \-enctype=>$encoding);
\&      <... various form stuff ...>
\&    print end_form;
\&
\&        \-or\-
\&
\&    print start_form($method,$action,$encoding);
\&      <... various form stuff ...>
\&    print end_form;
.Ve
.PP
\&\fIstart_form()\fR will return a <form> tag with the optional method,
action and form encoding that you specify.  The defaults are:
.PP
.Vb 4
\&    method: POST
\&    action: this script
\&    enctype: application/x\-www\-form\-urlencoded for non\-XHTML
\&             multipart/form\-data for XHTML, see multipart/form\-data below.
.Ve
.PP
\&\fIend_form()\fR returns the closing </form> tag.
.PP
\&\fIStart_form()\fR's enctype argument tells the browser how to package the various
fields of the form before sending the form to the server.  Two
values are possible:
.PP
\&\fBNote:\fR These methods were previously named \fIstartform()\fR and \fIendform()\fR.
These methods are now \s-1DEPRECATED\s0.
Please use \fIstart_form()\fR and \fIend_form()\fR instead.
.IP "\fBapplication/x\-www\-form\-urlencoded\fR" 4
.IX Item "application/x-www-form-urlencoded"
This is the older type of encoding.  It is compatible with many \s-1CGI\s0 scripts and is
suitable for short fields containing text data.  For your
convenience, \s-1CGI\s0.pm stores the name of this encoding
type in \fB&CGI::URL_ENCODED\fR.
.IP "\fBmultipart/form\-data\fR" 4
.IX Item "multipart/form-data"
This is the newer type of encoding.
It is suitable for forms that contain very large fields or that
are intended for transferring binary data.  Most importantly,
it enables the \*(L"file upload\*(R" feature.  For
your convenience, \s-1CGI\s0.pm stores the name of this encoding type
in \fB&CGI::MULTIPART\fR
.Sp
Forms that use this type of encoding are not easily interpreted
by \s-1CGI\s0 scripts unless they use \s-1CGI\s0.pm or another library designed
to handle them.
.Sp
If \s-1XHTML\s0 is activated (the default), then forms will be automatically
created using this type of encoding.
.PP
The \fIstart_form()\fR method uses the older form of encoding by
default unless \s-1XHTML\s0 is requested.  If you want to use the
newer form of encoding by default, you can call
\&\fB\f(BIstart_multipart_form()\fB\fR instead of \fB\f(BIstart_form()\fB\fR.  The
method \fB\f(BIend_multipart_form()\fB\fR is an alias to \fB\f(BIend_form()\fB\fR.
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-name\fR and \fB\-onSubmit\fR parameters are provided
for use with JavaScript.  The \-name parameter gives the
form a name so that it can be identified and manipulated by
JavaScript functions.  \-onSubmit should point to a JavaScript
function that will be executed just before the form is submitted to your
server.  You can use this opportunity to check the contents of the form 
for consistency and completeness.  If you find something wrong, you
can put up an alert box or maybe fix things up yourself.  You can 
abort the submission by returning false from this function.
.PP
Usually the bulk of JavaScript functions are defined in a <script>
block in the \s-1HTML\s0 header and \-onSubmit points to one of these function
call.  See \fIstart_html()\fR for details.
.SS "\s-1FORM\s0 \s-1ELEMENTS\s0"
.IX Subsection "FORM ELEMENTS"
After starting a form, you will typically create one or more
textfields, popup menus, radio groups and other form elements.  Each
of these elements takes a standard set of named arguments.  Some
elements also have optional arguments.  The standard arguments are as
follows:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the field. After submission this name can be used to
retrieve the field's value using the \fIparam()\fR method.
.IP "\fB\-value\fR, \fB\-values\fR" 4
.IX Item "-value, -values"
The initial value of the field which will be returned to the script
after form submission.  Some form elements, such as text fields, take
a single scalar \-value argument. Others, such as popup menus, take a
reference to an array of values. The two arguments are synonyms.
.IP "\fB\-tabindex\fR" 4
.IX Item "-tabindex"
A numeric value that sets the order in which the form element receives
focus when the user presses the tab key. Elements with lower values
receive focus first.
.IP "\fB\-id\fR" 4
.IX Item "-id"
A string identifier that can be used to identify this element to
JavaScript and \s-1DHTML\s0.
.IP "\fB\-override\fR" 4
.IX Item "-override"
A boolean, which, if true, forces the element to take on the value
specified by \fB\-value\fR, overriding the sticky behavior described
earlier for the \fB\-nosticky\fR pragma.
.IP "\fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR, \fB\-onSelect\fR" 4
.IX Item "-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut, -onSelect"
These are used to assign JavaScript event handlers. See the
JavaScripting section for more details.
.PP
Other common arguments are described in the next section. In addition
to these, all attributes described in the \s-1HTML\s0 specifications are
supported.
.SS "\s-1CREATING\s0 A \s-1TEXT\s0 \s-1FIELD\s0"
.IX Subsection "CREATING A TEXT FIELD"
.Vb 5
\&    print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                    \-value=>\*(Aqstarting value\*(Aq,
\&                    \-size=>50,
\&                    \-maxlength=>80);
\&        \-or\-
\&
\&    print textfield(\*(Aqfield_name\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fItextfield()\fR will return a text input field.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the default starting value for the field
contents (\-value, formerly known as \-default).
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
      characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
      field will accept (\-maxlength).
.PP
As with all these methods, the field will be initialized with its 
previous contents from earlier invocations of the script.
When the form is processed, the value of the text field can be
retrieved with:
.PP
.Vb 1
\&       $value = param(\*(Aqfoo\*(Aq);
.Ve
.PP
If you want to reset it from its initial value after the script has been
called once, you can do so like this:
.PP
.Vb 1
\&       param(\*(Aqfoo\*(Aq,"I\*(Aqm taking over this value!");
.Ve
.SS "\s-1CREATING\s0 A \s-1BIG\s0 \s-1TEXT\s0 \s-1FIELD\s0"
.IX Subsection "CREATING A BIG TEXT FIELD"
.Vb 4
\&   print textarea(\-name=>\*(Aqfoo\*(Aq,
\&                          \-default=>\*(Aqstarting value\*(Aq,
\&                          \-rows=>10,
\&                          \-columns=>50);
\&
\&        \-or
\&
\&   print textarea(\*(Aqfoo\*(Aq,\*(Aqstarting value\*(Aq,10,50);
.Ve
.PP
\&\fItextarea()\fR is just like textfield, but it allows you to specify
rows and columns for a multiline text entry box.  You can provide
a starting value for the field, which can be long and contain
multiple lines.
.SS "\s-1CREATING\s0 A \s-1PASSWORD\s0 \s-1FIELD\s0"
.IX Subsection "CREATING A PASSWORD FIELD"
.Vb 5
\&   print password_field(\-name=>\*(Aqsecret\*(Aq,
\&                                \-value=>\*(Aqstarting value\*(Aq,
\&                                \-size=>50,
\&                                \-maxlength=>80);
\&        \-or\-
\&
\&   print password_field(\*(Aqsecret\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIpassword_field()\fR is identical to \fItextfield()\fR, except that its contents 
will be starred out on the web page.
.SS "\s-1CREATING\s0 A \s-1FILE\s0 \s-1UPLOAD\s0 \s-1FIELD\s0"
.IX Subsection "CREATING A FILE UPLOAD FIELD"
.Vb 5
\&    print filefield(\-name=>\*(Aquploaded_file\*(Aq,
\&                            \-default=>\*(Aqstarting value\*(Aq,
\&                            \-size=>50,
\&                            \-maxlength=>80);
\&        \-or\-
\&
\&    print filefield(\*(Aquploaded_file\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIfilefield()\fR will return a file upload field.
In order to take full advantage of this \fIyou must use the new 
multipart encoding scheme\fR for the form.  You can do this either
by calling \fB\f(BIstart_form()\fB\fR with an encoding type of \fB&CGI::MULTIPART\fR,
or by calling the new method \fB\f(BIstart_multipart_form()\fB\fR instead of
vanilla \fB\f(BIstart_form()\fB\fR.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the starting value for the field contents
to be used as the default file name (\-default).
.Sp
For security reasons, browsers don't pay any attention to this field,
and so the starting value will always be blank.  Worse, the field
loses its \*(L"sticky\*(R" behavior and forgets its previous contents.  The
starting value field is called for in the \s-1HTML\s0 specification, however,
and possibly some browser will eventually provide support for it.
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
field will accept (\-maxlength).
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR for details.
.SS "\s-1PROCESSING\s0 A \s-1FILE\s0 \s-1UPLOAD\s0 \s-1FIELD\s0"
.IX Subsection "PROCESSING A FILE UPLOAD FIELD"
\fIBasics\fR
.IX Subsection "Basics"
.PP
When the form is processed, you can retrieve an IO::Handle compatible
handle for a file upload field like this:
.PP
.Vb 1
\&  $lightweight_fh  = $q\->upload(\*(Aqfield_name\*(Aq);
\&
\&  # undef may be returned if it\*(Aqs not a valid file handle
\&  if (defined $lightweight_fh) {
\&    # Upgrade the handle to one compatible with IO::Handle:
\&    my $io_handle = $lightweight_fh\->handle;
\&
\&    open (OUTFILE,\*(Aq>>\*(Aq,\*(Aq/usr/local/web/users/feedback\*(Aq);
\&    while ($bytesread = $io_handle\->read($buffer,1024)) {
\&      print OUTFILE $buffer;
\&    }
\&  }
.Ve
.PP
In a list context, \fIupload()\fR will return an array of filehandles.
This makes it possible to process forms that use the same name for
multiple upload fields.
.PP
If you want the entered file name for the file, you can just call \fIparam()\fR:
.PP
.Vb 1
\&  $filename = $q\->param(\*(Aqfield_name\*(Aq);
.Ve
.PP
Different browsers will return slightly different things for the
name.  Some browsers return the filename only.  Others return the full
path to the file, using the path conventions of the user's machine.
Regardless, the name returned is always the name of the file on the
\&\fIuser's\fR machine, and is unrelated to the name of the temporary file
that \s-1CGI\s0.pm creates during upload spooling (see below).
.PP
When a file is uploaded the browser usually sends along some
information along with it in the format of headers.  The information
usually includes the \s-1MIME\s0 content type. To
retrieve this information, call \fIuploadInfo()\fR.  It returns a reference to
a hash containing all the document headers.
.PP
.Vb 5
\&       $filename = $q\->param(\*(Aquploaded_file\*(Aq);
\&       $type = $q\->uploadInfo($filename)\->{\*(AqContent\-Type\*(Aq};
\&       unless ($type eq \*(Aqtext/html\*(Aq) {
\&        die "HTML FILES ONLY!";
\&       }
.Ve
.PP
If you are using a machine that recognizes \*(L"text\*(R" and \*(L"binary\*(R" data
modes, be sure to understand when and how to use them (see the Camel book).  
Otherwise you may find that binary files are corrupted during file
uploads.
.PP
\fIAccessing the temp files directly\fR
.IX Subsection "Accessing the temp files directly"
.PP
When processing an uploaded file, \s-1CGI\s0.pm creates a temporary file on your hard
disk and passes you a file handle to that file. After you are finished with the
file handle, \s-1CGI\s0.pm unlinks (deletes) the temporary file. If you need to you
can access the temporary file directly. You can access the temp file for a file
upload by passing the file name to the \fItmpFileName()\fR method:
.PP
.Vb 2
\&       $filename = $query\->param(\*(Aquploaded_file\*(Aq);
\&       $tmpfilename = $query\->tmpFileName($filename);
.Ve
.PP
The temporary file will be deleted automatically when your program exits unless
you manually rename it. On some operating systems (such as Windows \s-1NT\s0), you
will need to close the temporary file's filehandle before your program exits.
Otherwise the attempt to delete the temporary file will fail.
.PP
\fIHandling interrupted file uploads\fR
.IX Subsection "Handling interrupted file uploads"
.PP
There are occasionally problems involving parsing the uploaded file.
This usually happens when the user presses \*(L"Stop\*(R" before the upload is
finished.  In this case, \s-1CGI\s0.pm will return undef for the name of the
uploaded file and set \fI\fIcgi_error()\fI\fR to the string \*(L"400 Bad request
(malformed multipart \s-1POST\s0)\*(R".  This error message is designed so that
you can incorporate it into a status code to be sent to the browser.
Example:
.PP
.Vb 5
\&   $file = $q\->upload(\*(Aquploaded_file\*(Aq);
\&   if (!$file && $q\->cgi_error) {
\&      print $q\->header(\-status=>$q\->cgi_error);
\&      exit 0;
\&   }
.Ve
.PP
You are free to create a custom \s-1HTML\s0 page to complain about the error,
if you wish.
.PP
\fIProgress bars for file uploads and avoiding temp files\fR
.IX Subsection "Progress bars for file uploads and avoiding temp files"
.PP
\&\s-1CGI\s0.pm gives you low-level access to file upload management through
a file upload hook. You can use this feature to completely turn off
the temp file storage of file uploads, or potentially write your own
file upload progress meter.
.PP
This is much like the \s-1UPLOAD_HOOK\s0 facility available in Apache::Request, with
the exception that the first argument to the callback is an Apache::Upload
object, here it's the remote filename.
.PP
.Vb 1
\& $q = CGI\->new(\e&hook [,$data [,$use_tempfile]]);
\&
\& sub hook {
\&        my ($filename, $buffer, $bytes_read, $data) = @_;
\&        print  "Read $bytes_read bytes of $filename\en";
\& }
.Ve
.PP
The \f(CW$data\fR field is optional; it lets you pass configuration
information (e.g. a database handle) to your hook callback.
.PP
The \f(CW$use_tempfile\fR field is a flag that lets you turn on and off
\&\s-1CGI\s0.pm's use of a temporary disk-based file during file upload. If you
set this to a \s-1FALSE\s0 value (default true) then \f(CW$q\fR\->param('uploaded_file')
will no longer work, and the only way to get at the uploaded data is
via the hook you provide.
.PP
If using the function-oriented interface, call the \fICGI::upload_hook()\fR
method before calling \fIparam()\fR or any other \s-1CGI\s0 functions:
.PP
.Vb 1
\&  CGI::upload_hook(\e&hook [,$data [,$use_tempfile]]);
.Ve
.PP
This method is not exported by default.  You will have to import it
explicitly if you wish to use it without the \s-1CGI::\s0 prefix.
.PP
\fITroubleshooting file uploads on Windows\fR
.IX Subsection "Troubleshooting file uploads on Windows"
.PP
If you are using \s-1CGI\s0.pm on a Windows platform and find that binary
files get slightly larger when uploaded but that text files remain the
same, then you have forgotten to activate binary mode on the output
filehandle.  Be sure to call \fIbinmode()\fR on any handle that you create
to write the uploaded file to disk.
.PP
\fIOlder ways to process file uploads\fR
.IX Subsection "Older ways to process file uploads"
.PP
( This section is here for completeness. if you are building a new application with \s-1CGI\s0.pm, you can skip it. )
.PP
The original way to process file uploads with \s-1CGI\s0.pm was to use \fIparam()\fR. The
value it returns has a dual nature as both a file name and a lightweight
filehandle. This dual nature is problematic if you following the recommended
practice of having \f(CW\*(C`use strict\*(C'\fR in your code. Perl will complain when you try
to use a string as a filehandle.  More seriously, it is possible for the remote
user to type garbage into the upload field, in which case what you get from
\&\fIparam()\fR is not a filehandle at all, but a string.
.PP
To solve this problem the \fIupload()\fR method was added, which always returns a
lightweight filehandle. This generally works well, but will have trouble
interoperating with some other modules because the file handle is not derived
from IO::Handle. So that brings us to current recommendation given above,
which is to call the \fIhandle()\fR method on the file handle returned by \fIupload()\fR.
That upgrades the handle to an IO::Handle. It's a big win for compatibility for
a small penalty of loading IO::Handle the first time you call it.
.SS "\s-1CREATING\s0 A \s-1POPUP\s0 \s-1MENU\s0"
.IX Subsection "CREATING A POPUP MENU"
.Vb 3
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \*(Aqmeenie\*(Aq);
\&
\&      \-or\-
\&
\&   %labels = (\*(Aqeenie\*(Aq=>\*(Aqyour first choice\*(Aq,
\&              \*(Aqmeenie\*(Aq=>\*(Aqyour second choice\*(Aq,
\&              \*(Aqminie\*(Aq=>\*(Aqyour third choice\*(Aq);
\&   %attributes = (\*(Aqeenie\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqclass of first choice\*(Aq});
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \*(Aqmeenie\*(Aq,\e%labels,\e%attributes);
\&
\&        \-or (named parameter style)\-
\&
\&   print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                            \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \-default=>[\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \-labels=>\e%labels,
\&          \-attributes=>\e%attributes);
.Ve
.PP
\&\fIpopup_menu()\fR creates a menu.
.IP "1." 4
The required first argument is the menu's name (\-name).
.IP "2." 4
The required second argument (\-values) is an array \fBreference\fR
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference to
a named array, such as \*(L"\e@foo\*(R".
.IP "3." 4
The optional third parameter (\-default) is the name of the default
menu choice.  If not specified, the first item will be the default.
The values of the previous choice will be maintained across
queries. Pass an array reference to select multiple defaults.
.IP "4." 4
The optional fourth parameter (\-labels) is provided for people who
want to use different values for the user-visible label inside the
popup menu and the value returned to your script.  It's a pointer to an
hash relating menu values to user-visible labels.  If you
leave this parameter blank, the menu values will be displayed by
default.  (You can also leave a label undefined if you want to).
.IP "5." 4
The optional fifth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.PP
When the form is processed, the selected value of the popup menu can
be retrieved using:
.PP
.Vb 1
\&      $popup_menu_value = param(\*(Aqmenu_name\*(Aq);
.Ve
.SS "\s-1CREATING\s0 \s-1AN\s0 \s-1OPTION\s0 \s-1GROUP\s0"
.IX Subsection "CREATING AN OPTION GROUP"
Named parameter style
.PP
.Vb 9
\&  print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                  \-values=>[qw/eenie meenie minie/,
\&                            optgroup(\-name=>\*(Aqoptgroup_name\*(Aq,
\&                                             \-values => [\*(Aqmoe\*(Aq,\*(Aqcatch\*(Aq],
\&                                             \-attributes=>{\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],
\&                  \-labels=>{\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,
\&                            \*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,
\&                            \*(Aqminie\*(Aq=>\*(Aqthree\*(Aq},
\&                  \-default=>\*(Aqmeenie\*(Aq);
\&
\&  Old style
\&  print popup_menu(\*(Aqmenu_name\*(Aq,
\&                  [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,
\&                   optgroup(\*(Aqoptgroup_name\*(Aq, [\*(Aqmoe\*(Aq, \*(Aqcatch\*(Aq],
\&                                   {\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],\*(Aqmeenie\*(Aq,
\&                  {\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,\*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,\*(Aqminie\*(Aq=>\*(Aqthree\*(Aq});
.Ve
.PP
\&\fIoptgroup()\fR creates an option group within a popup menu.
.IP "1." 4
The required first argument (\fB\-name\fR) is the label attribute of the
optgroup and is \fBnot\fR inserted in the parameter list of the query.
.IP "2." 4
The required second argument (\fB\-values\fR)  is an array reference
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference
to a named array, such as \e@foo.  If you pass a \s-1HASH\s0 reference,
the keys will be used for the menu values, and the values will be
used for the menu labels (see \-labels below).
.IP "3." 4
The optional third parameter (\fB\-labels\fR) allows you to pass a reference
to a hash containing user-visible labels for one or more
of the menu items.  You can use this when you want the user to see one
menu string, but have the browser return your program a different one.
If you don't specify this, the value string will be used instead
(\*(L"eenie\*(R", \*(L"meenie\*(R" and \*(L"minie\*(R" in this example).  This is equivalent
to using a hash reference for the \-values parameter.
.IP "4." 4
An optional fourth parameter (\fB\-labeled\fR) can be set to a true value
and indicates that the values should be used as the label attribute
for each option element within the optgroup.
.IP "5." 4
An optional fifth parameter (\-novals) can be set to a true value and
indicates to suppress the val attribute in each option element within
the optgroup.
.Sp
See the discussion on optgroup at W3C
(http://www.w3.org/TR/REC\-html40/interact/forms.html#edef\-OPTGROUP)
for details.
.IP "6." 4
An optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.SS "\s-1CREATING\s0 A \s-1SCROLLING\s0 \s-1LIST\s0"
.IX Subsection "CREATING A SCROLLING LIST"
.Vb 4
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,{\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&      \-or\-
\&
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,
\&        \e%labels,%attributes);
\&
\&        \-or\-
\&
\&   print scrolling_list(\-name=>\*(Aqlist_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-size=>5,
\&                                \-multiple=>\*(Aqtrue\*(Aq,
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
.Ve
.PP
\&\fIscrolling_list()\fR creates a scrolling list.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the list name (\-name) and values
(\-values).  As in the popup menu, the second argument should be an
array reference.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be selected by default, or can be a
single value to select.  If this argument is missing or undefined,
then nothing is selected when the list first appears.  In the named
parameter version, you can use the synonym \*(L"\-defaults\*(R" for this
parameter.
.IP "3." 4
.IX Item "3."
The optional fourth argument is the size of the list (\-size).
.IP "4." 4
.IX Item "4."
The optional fifth argument can be set to true to allow multiple
simultaneous selections (\-multiple).  Otherwise only one selection
will be allowed at a time.
.IP "5." 4
.IX Item "5."
The optional sixth argument is a pointer to a hash
containing long user-visible labels for the list items (\-labels).
If not provided, the values will be displayed.
.IP "6." 4
.IX Item "6."
The optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.Sp
When this form is processed, all selected list items will be returned as
a list under the parameter name 'list_name'.  The values of the
selected items can be retrieved with:
.Sp
.Vb 1
\&      @selected = param(\*(Aqlist_name\*(Aq);
.Ve
.SS "\s-1CREATING\s0 A \s-1GROUP\s0 \s-1OF\s0 \s-1RELATED\s0 \s-1CHECKBOXES\s0"
.IX Subsection "CREATING A GROUP OF RELATED CHECKBOXES"
.Vb 7
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-linebreak=>\*(Aqtrue\*(Aq,
\&                                \-disabled => [\*(Aqmoe\*(Aq],
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
\&
\&   print checkbox_group(\*(Aqgroup_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],\*(Aqtrue\*(Aq,\e%labels,
\&        {\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIcheckbox_group()\fR creates a list of checkboxes that are related
by the same name.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the checkbox name and values,
respectively (\-name and \-values).  As in the popup menu, the second
argument should be an array reference.  These values are used for the
user-readable labels printed next to the checkboxes as well as for the
values passed to your script in the query string.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be checked by default, or can be a
single value to checked.  If this argument is missing or undefined,
then nothing is selected when the list first appears.
.IP "3." 4
.IX Item "3."
The optional fourth argument (\-linebreak) can be set to true to place
line breaks between the checkboxes so that they appear as a vertical
list.  Otherwise, they will be strung together on a horizontal line.
.PP
The optional \fB\-labels\fR argument is a pointer to a hash
relating the checkbox values to the user-visible labels that will be
printed next to them.  If not provided, the values will be used as the
default.
.PP
The optional parameters \fB\-rows\fR, and \fB\-columns\fR cause
\&\fIcheckbox_group()\fR to return an \s-1HTML3\s0 compatible table containing the
checkbox group formatted with the specified number of rows and
columns.  You can provide just the \-columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
.PP
The option \fB\-disabled\fR takes an array of checkbox values and disables
them by greying them out (this may not be supported by all browsers).
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, all checked boxes will be returned as
a list under the parameter name 'group_name'.  The values of the
\&\*(L"on\*(R" checkboxes can be retrieved with:
.PP
.Vb 1
\&      @turned_on = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIcheckbox_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING\s0 A \s-1STANDALONE\s0 \s-1CHECKBOX\s0"
.IX Subsection "CREATING A STANDALONE CHECKBOX"
.Vb 4
\&    print checkbox(\-name=>\*(Aqcheckbox_name\*(Aq,
\&                           \-checked=>1,
\&                           \-value=>\*(AqON\*(Aq,
\&                           \-label=>\*(AqCLICK ME\*(Aq);
\&
\&        \-or\-
\&
\&    print checkbox(\*(Aqcheckbox_name\*(Aq,\*(Aqchecked\*(Aq,\*(AqON\*(Aq,\*(AqCLICK ME\*(Aq);
.Ve
.PP
\&\fIcheckbox()\fR is used to create an isolated checkbox that isn't logically
related to any others.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the checkbox (\-name).  It
will also be used for the user-readable label printed next to the
checkbox.
.IP "2." 4
.IX Item "2."
The optional second parameter (\-checked) specifies that the checkbox
is turned on by default.  Synonyms are \-selected and \-on.
.IP "3." 4
.IX Item "3."
The optional third parameter (\-value) specifies the value of the
checkbox when it is checked.  If not provided, the word \*(L"on\*(R" is
assumed.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-label) is the user-readable label to
be attached to the checkbox.  If not provided, the checkbox name is
used.
.PP
The value of the checkbox can be retrieved using:
.PP
.Vb 1
\&    $turned_on = param(\*(Aqcheckbox_name\*(Aq);
.Ve
.SS "\s-1CREATING\s0 A \s-1RADIO\s0 \s-1BUTTON\s0 \s-1GROUP\s0"
.IX Subsection "CREATING A RADIO BUTTON GROUP"
.Vb 6
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                             \-default=>\*(Aqmeenie\*(Aq,
\&                             \-linebreak=>\*(Aqtrue\*(Aq,
\&           \-labels=>\e%labels,
\&           \-attributes=>\e%attributes);
\&
\&        \-or\-
\&
\&   print radio_group(\*(Aqgroup_name\*(Aq,[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&            \*(Aqmeenie\*(Aq,\*(Aqtrue\*(Aq,\e%labels,\e%attributes);
\&
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                             \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIradio_group()\fR creates a set of logically-related radio buttons
(turning one member of the group on turns the others off)
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is the name of the group and is required (\-name).
.IP "2." 4
.IX Item "2."
The second argument (\-values) is the list of values for the radio
buttons.  The values and the labels that appear on the page are
identical.  Pass an array \fIreference\fR in the second argument, either
using an anonymous array, as shown, or by referencing a named array as
in \*(L"\e@foo\*(R".
.IP "3." 4
.IX Item "3."
The optional third parameter (\-default) is the name of the default
button to turn on. If not specified, the first item will be the
default.  You can provide a nonexistent button name, such as \*(L"\-\*(R" to
start up with no buttons selected.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-linebreak) can be set to 'true' to put
line breaks between the buttons, creating a vertical list.
.IP "5." 4
.IX Item "5."
The optional fifth parameter (\-labels) is a pointer to an associative
array relating the radio button values to user-visible labels to be
used in the display.  If not provided, the values themselves are
displayed.
.PP
All modern browsers can take advantage of the optional parameters
\&\fB\-rows\fR, and \fB\-columns\fR.  These parameters cause \fIradio_group()\fR to
return an \s-1HTML3\s0 compatible table containing the radio group formatted
with the specified number of rows and columns.  You can provide just
the \-columns parameter if you wish; radio_group will calculate the
correct number of rows for you.
.PP
To include row and column headings in the returned table, you
can use the \fB\-rowheaders\fR and \fB\-colheaders\fR parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the radio buttons \*(-- they're still a single named
unit.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, the selected radio button can
be retrieved using:
.PP
.Vb 1
\&      $which_radio_button = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIradio_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = radio_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING\s0 A \s-1SUBMIT\s0 \s-1BUTTON\s0"
.IX Subsection "CREATING A SUBMIT BUTTON"
.Vb 2
\&   print submit(\-name=>\*(Aqbutton_name\*(Aq,
\&                        \-value=>\*(Aqvalue\*(Aq);
\&
\&        \-or\-
\&
\&   print submit(\*(Aqbutton_name\*(Aq,\*(Aqvalue\*(Aq);
.Ve
.PP
\&\fIsubmit()\fR will create the query submission button.  Every form
should have one of these.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is optional.  You can give the button a
name if you have several submission buttons in your form and you want
to distinguish between them.
.IP "2." 4
.IX Item "2."
The second argument (\-value) is also optional.  This gives the button
a value that will be passed to your script in the query string. The
name will also be used as the user-visible label.
.IP "3." 4
.IX Item "3."
You can use \-label as an alias for \-value.  I always get confused
about which of \-name and \-value changes the user-visible label on the
button.
.PP
You can figure out which button was pressed by using different
values for each one:
.PP
.Vb 1
\&     $which_one = param(\*(Aqbutton_name\*(Aq);
.Ve
.SS "\s-1CREATING\s0 A \s-1RESET\s0 \s-1BUTTON\s0"
.IX Subsection "CREATING A RESET BUTTON"
.Vb 1
\&   print reset
.Ve
.PP
\&\fIreset()\fR creates the \*(L"reset\*(R" button.  Note that it restores the
form to its value from the last time the script was called, 
\&\s-1NOT\s0 necessarily to the defaults.
.PP
Note that this conflicts with the Perl \fIreset()\fR built-in.  Use
\&\fICORE::reset()\fR to get the original reset function.
.SS "\s-1CREATING\s0 A \s-1DEFAULT\s0 \s-1BUTTON\s0"
.IX Subsection "CREATING A DEFAULT BUTTON"
.Vb 1
\&   print defaults(\*(Aqbutton_label\*(Aq)
.Ve
.PP
\&\fIdefaults()\fR creates a button that, when invoked, will cause the
form to be completely reset to its defaults, wiping out all the
changes the user ever made.
.SS "\s-1CREATING\s0 A \s-1HIDDEN\s0 \s-1FIELD\s0"
.IX Subsection "CREATING A HIDDEN FIELD"
.Vb 2
\&        print hidden(\-name=>\*(Aqhidden_name\*(Aq,
\&                             \-default=>[\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...]);
\&
\&                \-or\-
\&
\&        print hidden(\*(Aqhidden_name\*(Aq,\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...);
.Ve
.PP
\&\fIhidden()\fR produces a text field that can't be seen by the user.  It
is useful for passing state variable information from one invocation
of the script to the next.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is required and specifies the name of this
field (\-name).
.IP "2." 4
.IX Item "2."
The second argument is also required and specifies its value
(\-default).  In the named parameter style of calling, you can provide
a single value here or a reference to a whole list
.PP
Fetch the value of a hidden field this way:
.PP
.Vb 1
\&     $hidden_value = param(\*(Aqhidden_name\*(Aq);
.Ve
.PP
Note, that just like all the other form elements, the value of a
hidden field is \*(L"sticky\*(R".  If you want to replace a hidden field with
some other values after the script has been called once you'll have to
do it manually:
.PP
.Vb 1
\&     param(\*(Aqhidden_name\*(Aq,\*(Aqnew\*(Aq,\*(Aqvalues\*(Aq,\*(Aqhere\*(Aq);
.Ve
.SS "\s-1CREATING\s0 A \s-1CLICKABLE\s0 \s-1IMAGE\s0 \s-1BUTTON\s0"
.IX Subsection "CREATING A CLICKABLE IMAGE BUTTON"
.Vb 3
\&     print image_button(\-name=>\*(Aqbutton_name\*(Aq,
\&                                \-src=>\*(Aq/source/URL\*(Aq,
\&                                \-align=>\*(AqMIDDLE\*(Aq);      
\&
\&        \-or\-
\&
\&     print image_button(\*(Aqbutton_name\*(Aq,\*(Aq/source/URL\*(Aq,\*(AqMIDDLE\*(Aq);
.Ve
.PP
\&\fIimage_button()\fR produces a clickable image.  When it's clicked on the
position of the click is returned to your script as \*(L"button_name.x\*(R"
and \*(L"button_name.y\*(R", where \*(L"button_name\*(R" is the name you've assigned
to it.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is required and specifies the name of this
field.
.IP "2." 4
.IX Item "2."
The second argument (\-src) is also required and specifies the \s-1URL\s0
.IP "3. The third option (\-align, optional) is an alignment type, and may be \s-1TOP\s0, \s-1BOTTOM\s0 or \s-1MIDDLE\s0" 4
.IX Item "3. The third option (-align, optional) is an alignment type, and may be TOP, BOTTOM or MIDDLE"
.PP
Fetch the value of the button this way:
     \f(CW$x\fR = param('button_name.x');
     \f(CW$y\fR = param('button_name.y');
.SS "\s-1CREATING\s0 A \s-1JAVASCRIPT\s0 \s-1ACTION\s0 \s-1BUTTON\s0"
.IX Subsection "CREATING A JAVASCRIPT ACTION BUTTON"
.Vb 3
\&     print button(\-name=>\*(Aqbutton_name\*(Aq,
\&                          \-value=>\*(Aquser visible label\*(Aq,
\&                          \-onClick=>"do_something()");
\&
\&        \-or\-
\&
\&     print button(\*(Aqbutton_name\*(Aq,"user visible value","do_something()");
.Ve
.PP
\&\fIbutton()\fR produces an \f(CW\*(C`<input>\*(C'\fR tag with \f(CW\*(C`type="button"\*(C'\fR.  When it's
pressed the fragment of JavaScript code pointed to by the \fB\-onClick\fR parameter
will be executed.
.SH "HTTP COOKIES"
.IX Header "HTTP COOKIES"
Browsers support a so-called \*(L"cookie\*(R" designed to help maintain state
within a browser session.  \s-1CGI\s0.pm has several methods that support
cookies.
.PP
A cookie is a name=value pair much like the named parameters in a \s-1CGI\s0
query string.  \s-1CGI\s0 scripts create one or more cookies and send
them to the browser in the \s-1HTTP\s0 header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the \s-1CGI\s0 script during subsequent interactions.
.PP
In addition to the required name=value pair, each cookie has several
optional attributes:
.IP "1. an expiration time" 4
.IX Item "1. an expiration time"
This is a time/date string (in a special \s-1GMT\s0 format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.
.IP "2. a domain" 4
.IX Item "2. a domain"
This is a partial or complete domain name for which the cookie is 
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of \*(L".capricorn.com\*(R", then the browser will return the cookie to
Web servers running on any of the machines \*(L"www.capricorn.com\*(R", 
\&\*(L"www2.capricorn.com\*(R", \*(L"feckless.capricorn.com\*(R", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like \*(L".edu\*(R".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.
.IP "3. a path" 4
.IX Item "3. a path"
If you provide a cookie path attribute, the browser will check it
against your script's \s-1URL\s0 before returning the cookie.  For example,
if you specify the path \*(L"/cgi\-bin\*(R", then the cookie will be returned
to each of the scripts \*(L"/cgi\-bin/tally.pl\*(R", \*(L"/cgi\-bin/order.pl\*(R",
and \*(L"/cgi\-bin/customer_service/complain.pl\*(R", but not to the script
\&\*(L"/cgi\-private/site_admin.pl\*(R".  By default, path is set to \*(L"/\*(R", which
causes the cookie to be sent to any \s-1CGI\s0 script on your site.
.ie n .IP "4. a ""secure"" flag" 4
.el .IP "4. a ``secure'' flag" 4
.IX Item "4. a secure flag"
If the \*(L"secure\*(R" attribute is set, the cookie will only be sent to your
script if the \s-1CGI\s0 request is occurring on a secure channel, such as \s-1SSL\s0.
.PP
The interface to \s-1HTTP\s0 cookies is the \fB\f(BIcookie()\fB\fR method:
.PP
.Vb 7
\&    $cookie = cookie(\-name=>\*(AqsessionID\*(Aq,
\&                             \-value=>\*(Aqxyzzy\*(Aq,
\&                             \-expires=>\*(Aq+1h\*(Aq,
\&                             \-path=>\*(Aq/cgi\-bin/database\*(Aq,
\&                             \-domain=>\*(Aq.capricorn.org\*(Aq,
\&                             \-secure=>1);
\&    print header(\-cookie=>$cookie);
.Ve
.PP
\&\fB\f(BIcookie()\fB\fR creates a new cookie.  Its parameters include:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the cookie (required).  This can be any string at all.
Although browsers limit their cookie names to non-whitespace
alphanumeric characters, \s-1CGI\s0.pm removes this restriction by escaping
and unescaping cookies behind the scenes.
.IP "\fB\-value\fR" 4
.IX Item "-value"
The value of the cookie.  This can be any scalar value,
array reference, or even hash reference.  For example,
you can store an entire hash into a cookie this way:
.Sp
.Vb 2
\&        $cookie=cookie(\-name=>\*(Aqfamily information\*(Aq,
\&                               \-value=>\e%childrens_ages);
.Ve
.IP "\fB\-path\fR" 4
.IX Item "-path"
The optional partial path for which this cookie will be valid, as described
above.
.IP "\fB\-domain\fR" 4
.IX Item "-domain"
The optional partial domain for which this cookie will be valid, as described
above.
.IP "\fB\-expires\fR" 4
.IX Item "-expires"
The optional expiration date for this cookie.  The format is as described 
in the section on the \fB\f(BIheader()\fB\fR method:
.Sp
.Vb 1
\&        "+1h"  one hour from now
.Ve
.IP "\fB\-secure\fR" 4
.IX Item "-secure"
If set to true, this cookie will only be used within a secure
\&\s-1SSL\s0 session.
.PP
The cookie created by \fIcookie()\fR must be incorporated into the \s-1HTTP\s0
header within the string returned by the \fIheader()\fR method:
.PP
.Vb 2
\&        use CGI \*(Aq:standard\*(Aq;
\&        print header(\-cookie=>$my_cookie);
.Ve
.PP
To create multiple cookies, give \fIheader()\fR an array reference:
.PP
.Vb 5
\&        $cookie1 = cookie(\-name=>\*(Aqriddle_name\*(Aq,
\&                                  \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = cookie(\-name=>\*(Aqanswers\*(Aq,
\&                                  \-value=>\e%answers);
\&        print header(\-cookie=>[$cookie1,$cookie2]);
.Ve
.PP
To retrieve a cookie, request it by name by calling \fIcookie()\fR method
without the \fB\-value\fR parameter. This example uses the object-oriented
form:
.PP
.Vb 4
\&        use CGI;
\&        $query = CGI\->new;
\&        $riddle = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&        %answers = $query\->cookie(\*(Aqanswers\*(Aq);
.Ve
.PP
Cookies created with a single scalar value, such as the \*(L"riddle_name\*(R"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.
.PP
The cookie and \s-1CGI\s0 namespaces are separate.  If you have a parameter
named 'answers' and a cookie named 'answers', the values retrieved by
\&\fIparam()\fR and \fIcookie()\fR are independent of each other.  However, it's
simple to turn a \s-1CGI\s0 parameter into a cookie, and vice-versa:
.PP
.Vb 4
\&   # turn a CGI parameter into a cookie
\&   $c=cookie(\-name=>\*(Aqanswers\*(Aq,\-value=>[param(\*(Aqanswers\*(Aq)]);
\&   # vice\-versa
\&   param(\-name=>\*(Aqanswers\*(Aq,\-value=>[cookie(\*(Aqanswers\*(Aq)]);
.Ve
.PP
If you call \fIcookie()\fR without any parameters, it will return a list of
the names of all cookies passed to your script:
.PP
.Vb 1
\&  @cookies = cookie();
.Ve
.PP
See the \fBcookie.cgi\fR example script for some ideas on how to use
cookies effectively.
.SH "WORKING WITH FRAMES"
.IX Header "WORKING WITH FRAMES"
It's possible for \s-1CGI\s0.pm scripts to write into several browser panels
and windows using the \s-1HTML\s0 4 frame mechanism.  There are three
techniques for defining new frames programmatically:
.IP "1. Create a <Frameset> document" 4
.IX Item "1. Create a <Frameset> document"
After writing out the \s-1HTTP\s0 header, instead of creating a standard
\&\s-1HTML\s0 document using the \fIstart_html()\fR call, create a <frameset> 
document that defines the frames on the page.  Specify your script(s)
(with appropriate parameters) as the \s-1SRC\s0 for each of the frames.
.Sp
There is no specific support for creating <frameset> sections 
in \s-1CGI\s0.pm, but the \s-1HTML\s0 is very simple to write.
.IP "2. Specify the destination for the document in the \s-1HTTP\s0 header" 4
.IX Item "2. Specify the destination for the document in the HTTP header"
You may provide a \fB\-target\fR parameter to the \fIheader()\fR method:
.Sp
.Vb 1
\&    print header(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
This will tell the browser to load the output of your script into the
frame named \*(L"ResultsWindow\*(R".  If a frame of that name doesn't already
exist, the browser will pop up a new window and load your script's
document into that.  There are a number of magic names that you can
use for targets.  See the \s-1HTML\s0 \f(CW\*(C`<frame>\*(C'\fR documentation for details.
.IP "3. Specify the destination for the document in the <form> tag" 4
.IX Item "3. Specify the destination for the document in the <form> tag"
You can specify the frame to load in the \s-1FORM\s0 tag itself.  With
\&\s-1CGI\s0.pm it looks like this:
.Sp
.Vb 1
\&    print start_form(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
When your script is reinvoked by the form, its output will be loaded
into the frame named \*(L"ResultsWindow\*(R".  If one doesn't already exist
a new window will be created.
.PP
The script \*(L"frameset.cgi\*(R" in the examples directory shows one way to
create pages in which the fill-out form and the response live in
side-by-side frames.
.SH "SUPPORT FOR JAVASCRIPT"
.IX Header "SUPPORT FOR JAVASCRIPT"
The usual way to use JavaScript is to define a set of functions in a
<\s-1SCRIPT\s0> block inside the \s-1HTML\s0 header and then to register event
handlers in the various elements of the page. Events include such
things as the mouse passing over a form element, a button being
clicked, the contents of a text field changing, or a form being
submitted. When an event occurs that involves an element that has
registered an event handler, its associated JavaScript code gets
called.
.PP
The elements that can register event handlers include the <\s-1BODY\s0> of an
\&\s-1HTML\s0 document, hypertext links, all the various elements of a fill-out
form, and the form itself. There are a large number of events, and
each applies only to the elements for which it is relevant. Here is a
partial list:
.IP "\fBonLoad\fR" 4
.IX Item "onLoad"
The browser is loading the current document. Valid in:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonUnload\fR" 4
.IX Item "onUnload"
The browser is closing the current page or frame. Valid for:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonSubmit\fR" 4
.IX Item "onSubmit"
The user has pressed the submit button of a form. This event happens
just before the form is submitted, and your function can return a
value of false in order to abort the submission.  Valid for:
.Sp
.Vb 1
\&     + Forms only.
.Ve
.IP "\fBonClick\fR" 4
.IX Item "onClick"
The mouse has clicked on an item in a fill-out form. Valid for:
.Sp
.Vb 3
\&     + Buttons (including submit, reset, and image buttons)
\&     + Checkboxes
\&     + Radio buttons
.Ve
.IP "\fBonChange\fR" 4
.IX Item "onChange"
The user has changed the contents of a field. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonFocus\fR" 4
.IX Item "onFocus"
The user has selected a field to work with. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonBlur\fR" 4
.IX Item "onBlur"
The user has deselected a field (gone to work somewhere else).  Valid
for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonSelect\fR" 4
.IX Item "onSelect"
The user has changed the part of a text field that is selected.  Valid
for:
.Sp
.Vb 4
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
.Ve
.IP "\fBonMouseOver\fR" 4
.IX Item "onMouseOver"
The mouse has moved over an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonMouseOut\fR" 4
.IX Item "onMouseOut"
The mouse has moved off an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.PP
In order to register a JavaScript event handler with an \s-1HTML\s0 element,
just use the event name as a parameter when you call the corresponding
\&\s-1CGI\s0 method. For example, to have your \fIvalidateAge()\fR JavaScript code
executed every time the textfield named \*(L"age\*(R" changes, generate the
field like this:
.PP
.Vb 1
\& print textfield(\-name=>\*(Aqage\*(Aq,\-onChange=>"validateAge(this)");
.Ve
.PP
This example assumes that you've already declared the \fIvalidateAge()\fR
function by incorporating it into a <\s-1SCRIPT\s0> block. The \s-1CGI\s0.pm
\&\fIstart_html()\fR method provides a convenient way to create this section.
.PP
Similarly, you can create a form that checks itself over for
consistency and alerts the user if some essential value is missing by
creating it this way: 
  print start_form(\-onSubmit=>\*(L"validateMe(this)\*(R");
.PP
See the javascript.cgi script for a demonstration of how this all
works.
.SH "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
.IX Header "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
\&\s-1CGI\s0.pm has limited support for \s-1HTML3\s0's cascading style sheets (css).
To incorporate a stylesheet into your document, pass the
\&\fIstart_html()\fR method a \fB\-style\fR parameter.  The value of this
parameter may be a scalar, in which case it is treated as the source
\&\s-1URL\s0 for the stylesheet, or it may be a hash reference.  In the latter
case you should provide the hash with one or more of \fB\-src\fR or
\&\fB\-code\fR.  \fB\-src\fR points to a \s-1URL\s0 where an externally-defined
stylesheet can be found.  \fB\-code\fR points to a scalar value to be
incorporated into a <style> section.  Style definitions in \fB\-code\fR
override similarly-named ones in \fB\-src\fR, hence the name \*(L"cascading.\*(R"
.PP
You may also specify the type of the stylesheet by adding the optional
\&\fB\-type\fR parameter to the hash pointed to by \fB\-style\fR.  If not
specified, the style defaults to 'text/css'.
.PP
To refer to a style within the body of your document, add the
\&\fB\-class\fR parameter to any \s-1HTML\s0 element:
.PP
.Vb 1
\&    print h1({\-class=>\*(AqFancy\*(Aq},\*(AqWelcome to the Party\*(Aq);
.Ve
.PP
Or define styles on the fly with the \fB\-style\fR parameter:
.PP
.Vb 1
\&    print h1({\-style=>\*(AqColor: red;\*(Aq},\*(AqWelcome to Hell\*(Aq);
.Ve
.PP
You may also use the new \fB\f(BIspan()\fB\fR element to apply a style to a
section of text:
.PP
.Vb 4
\&    print span({\-style=>\*(AqColor: red;\*(Aq},
\&               h1(\*(AqWelcome to Hell\*(Aq),
\&               "Where did that handbasket get to?"
\&               );
.Ve
.PP
Note that you must import the \*(L":html3\*(R" definitions to have the
\&\fB\f(BIspan()\fB\fR method available.  Here's a quick and dirty example of using
\&\s-1CSS\s0's.  See the \s-1CSS\s0 specification at
http://www.w3.org/Style/CSS/ for more information.
.PP
.Vb 1
\&    use CGI qw/:standard :html3/;
\&
\&    #here\*(Aqs a stylesheet incorporated directly into the page
\&    $newStyle=<<END;
\&    <!\-\- 
\&    P.Tip {
\&        margin\-right: 50pt;
\&        margin\-left: 50pt;
\&        color: red;
\&    }
\&    P.Alert {
\&        font\-size: 30pt;
\&        font\-family: sans\-serif;
\&      color: red;
\&    }
\&    \-\->
\&    END
\&    print header();
\&    print start_html( \-title=>\*(AqCGI with Style\*(Aq,
\&                      \-style=>{\-src=>\*(Aqhttp://www.capricorn.com/style/st1.css\*(Aq,
\&                               \-code=>$newStyle}
\&                     );
\&    print h1(\*(AqCGI with Style\*(Aq),
\&          p({\-class=>\*(AqTip\*(Aq},
\&            "Better read the cascading style sheet spec before playing with this!"),
\&          span({\-style=>\*(Aqcolor: magenta\*(Aq},
\&               "Look Mom, no hands!",
\&               p(),
\&               "Whooo wee!"
\&               );
\&    print end_html;
.Ve
.PP
Pass an array reference to \fB\-code\fR or \fB\-src\fR in order to incorporate
multiple stylesheets into your document.
.PP
Should you wish to incorporate a verbatim stylesheet that includes
arbitrary formatting in the header, you may pass a \-verbatim tag to
the \-style hash, as follows:
.PP
print start_html (\-style  =>  {\-verbatim => '@import url(\*(L"/server\-common/css/'.$cssFile.'\*(R");',
                  \-src    =>  '/server\-common/css/core.css'});
.PP
This will generate an \s-1HTML\s0 header that contains this:
.PP
.Vb 4
\& <link rel="stylesheet" type="text/css"  href="/server\-common/css/core.css">
\&   <style type="text/css">
\&   @import url("/server\-common/css/main.css");
\&   </style>
.Ve
.PP
Any additional arguments passed in the \-style value will be
incorporated into the <link> tag.  For example:
.PP
.Vb 2
\& start_html(\-style=>{\-src=>[\*(Aq/styles/print.css\*(Aq,\*(Aq/styles/layout.css\*(Aq],
\&                          \-media => \*(Aqall\*(Aq});
.Ve
.PP
This will give:
.PP
.Vb 2
\& <link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/>
\& <link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/>
.Ve
.PP
<p>
.PP
To make more complicated <link> tags, use the \fILink()\fR function
and pass it to \fIstart_html()\fR in the \-head argument, as in:
.PP
.Vb 3
\&  @h = (Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/ss.css\*(Aq,\-media=>\*(Aqall\*(Aq}),
\&        Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/fred.css\*(Aq,\-media=>\*(Aqpaper\*(Aq}));
\&  print start_html({\-head=>\e@h})
.Ve
.PP
To create primary and  \*(L"alternate\*(R" stylesheet, use the \fB\-alternate\fR option:
.PP
.Vb 5
\& start_html(\-style=>{\-src=>[
\&                           {\-src=>\*(Aq/styles/print.css\*(Aq},
\&                           {\-src=>\*(Aq/styles/alt.css\*(Aq,\-alternate=>1}
\&                           ]
\&                    });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  You can pass keywords like this:
.PP
.Vb 1
\&    your_script.pl keyword1 keyword2 keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&   your_script.pl keyword1+keyword2+keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1 name2=value2
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1&name2=value2
.Ve
.PP
To turn off this feature, use the \-no_debug pragma.
.PP
To test the \s-1POST\s0 method, you may enable full debugging with the \-debug
pragma.  This will allow you to feed newline-delimited name=value
pairs to the script on standard input.
.PP
When debugging, you can use quotes and backslashes to escape 
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:
.PP
.Vb 1
\&   your_script.pl "name1=\*(AqI am a long value\*(Aq" "name2=two\e words"
.Ve
.PP
Finally, you can set the path info for the script by prefixing the first
name/value parameter with the path followed by a question mark (?):
.PP
.Vb 1
\&    your_script.pl /your/path/here?name1=value1&name2=value2
.Ve
.SS "\s-1DUMPING\s0 \s-1OUT\s0 \s-1ALL\s0 \s-1THE\s0 \s-1NAME/VALUE\s0 \s-1PAIRS\s0"
.IX Subsection "DUMPING OUT ALL THE NAME/VALUE PAIRS"
The \fIDump()\fR method produces a string consisting of all the query's
name/value pairs formatted nicely as a nested list.  This is useful
for debugging purposes:
.PP
.Vb 1
\&    print Dump
.Ve
.PP
Produces something that looks like:
.PP
.Vb 11
\&    <ul>
\&    <li>name1
\&        <ul>
\&        <li>value1
\&        <li>value2
\&        </ul>
\&    <li>name2
\&        <ul>
\&        <li>value1
\&        </ul>
\&    </ul>
.Ve
.PP
As a shortcut, you can interpolate the entire \s-1CGI\s0 object into a string
and it will be replaced with the a nice \s-1HTML\s0 dump shown above:
.PP
.Vb 2
\&    $query=CGI\->new;
\&    print "<h2>Current Values</h2> $query\en";
.Ve
.SH "FETCHING ENVIRONMENT VARIABLES"
.IX Header "FETCHING ENVIRONMENT VARIABLES"
Some of the more useful environment variables can be fetched
through this interface.  The methods are as follows:
.IP "\fB\f(BIAccept()\fB\fR" 4
.IX Item "Accept()"
Return a list of \s-1MIME\s0 types that the remote browser accepts. If you
give this method a single argument corresponding to a \s-1MIME\s0 type, as in
Accept('text/html'), it will return a floating point value
corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.
.Sp
Note that the capitalization changed between version 2.43 and 2.44 in
order to avoid conflict with Perl's \fIaccept()\fR function.
.IP "\fB\f(BIraw_cookie()\fB\fR" 4
.IX Item "raw_cookie()"
Returns the \s-1HTTP_COOKIE\s0 variable.  Cookies have a special format, and
this method call just returns the raw form (?cookie dough).  See
\&\fIcookie()\fR for ways of setting and retrieving cooked cookies.
.Sp
Called with no parameters, \fIraw_cookie()\fR returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence \*(L"; \*(R".  Called with the name of a cookie,
retrieves the \fBunescaped\fR form of the cookie.  You can use the
regular \fIcookie()\fR method to get the names, or use the \fIraw_fetch()\fR
method from the CGI::Cookie module.
.IP "\fB\f(BIuser_agent()\fB\fR" 4
.IX Item "user_agent()"
Returns the \s-1HTTP_USER_AGENT\s0 variable.  If you give
this method a single argument, it will attempt to
pattern match on it, allowing you to do something
like user_agent(Mozilla);
.IP "\fB\f(BIpath_info()\fB\fR" 4
.IX Item "path_info()"
Returns additional path information from the script \s-1URL\s0.
E.G. fetching /cgi\-bin/your_script/additional/stuff will result in
\&\fIpath_info()\fR returning \*(L"/additional/stuff\*(R".
.Sp
\&\s-1NOTE:\s0 The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl \s-1DLL\s0 library, the \s-1IIS\s0 server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment, 
but incorrect.  The best thing to do is to avoid using additional
path information in \s-1CGI\s0 scripts destined for use with \s-1IIS\s0.
.IP "\fB\f(BIpath_translated()\fB\fR" 4
.IX Item "path_translated()"
As per \fIpath_info()\fR but returns the additional
path information translated into a physical path, e.g.
\&\*(L"/usr/local/etc/httpd/htdocs/additional/stuff\*(R".
.Sp
The Microsoft \s-1IIS\s0 is broken with respect to the translated
path as well.
.IP "\fB\f(BIremote_host()\fB\fR" 4
.IX Item "remote_host()"
Returns either the remote host name or \s-1IP\s0 address.
if the former is unavailable.
.IP "\fB\f(BIremote_addr()\fB\fR" 4
.IX Item "remote_addr()"
Returns the remote host \s-1IP\s0 address, or 
127.0.0.1 if the address is unavailable.
.IP "\fB\f(BIscript_name()\fB\fR Return the script name as a partial \s-1URL\s0, for self-referring scripts." 4
.IX Item "script_name() Return the script name as a partial URL, for self-referring scripts."
.PD 0
.IP "\fB\f(BIreferer()\fB\fR" 4
.IX Item "referer()"
.PD
Return the \s-1URL\s0 of the page the browser was viewing
prior to fetching your script.  Not available for all
browsers.
.IP "\fBauth_type ()\fR" 4
.IX Item "auth_type ()"
Return the authorization/verification method in use for this
script, if any.
.IP "\fBserver_name ()\fR" 4
.IX Item "server_name ()"
Returns the name of the server, usually the machine's host
name.
.IP "\fBvirtual_host ()\fR" 4
.IX Item "virtual_host ()"
When using virtual hosts, returns the name of the host that
the browser attempted to contact
.IP "\fBserver_port ()\fR" 4
.IX Item "server_port ()"
Return the port that the server is listening on.
.IP "\fBvirtual_port ()\fR" 4
.IX Item "virtual_port ()"
Like \fIserver_port()\fR except that it takes virtual hosts into account.
Use this when running with virtual hosts.
.IP "\fBserver_software ()\fR" 4
.IX Item "server_software ()"
Returns the server software and version number.
.IP "\fBremote_user ()\fR" 4
.IX Item "remote_user ()"
Return the authorization/verification name used for user
verification, if this script is protected.
.IP "\fBuser_name ()\fR" 4
.IX Item "user_name ()"
Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!
.IP "\fB\f(BIrequest_method()\fB\fR" 4
.IX Item "request_method()"
Returns the method used to access your script, usually
one of '\s-1POST\s0', '\s-1GET\s0' or '\s-1HEAD\s0'.
.IP "\fB\f(BIcontent_type()\fB\fR" 4
.IX Item "content_type()"
Returns the content_type of data submitted in a \s-1POST\s0, generally 
multipart/form\-data or application/x\-www\-form\-urlencoded
.IP "\fB\f(BIhttp()\fB\fR" 4
.IX Item "http()"
Called with no arguments returns the list of \s-1HTTP\s0 environment
variables, including such things as \s-1HTTP_USER_AGENT\s0,
\&\s-1HTTP_ACCEPT_LANGUAGE\s0, and \s-1HTTP_ACCEPT_CHARSET\s0, corresponding to the
like-named \s-1HTTP\s0 header fields in the request.  Called with the name of
an \s-1HTTP\s0 header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.
.Sp
For example, all three of these examples are equivalent:
.Sp
.Vb 3
\&   $requested_language = http(\*(AqAccept\-language\*(Aq);
\&   $requested_language = http(\*(AqAccept_language\*(Aq);
\&   $requested_language = http(\*(AqHTTP_ACCEPT_LANGUAGE\*(Aq);
.Ve
.IP "\fB\f(BIhttps()\fB\fR" 4
.IX Item "https()"
The same as \fI\fIhttp()\fI\fR, but operates on the \s-1HTTPS\s0 environment variables
present when the \s-1SSL\s0 protocol is in effect.  Can be used to determine
whether \s-1SSL\s0 is turned on.
.SH "USING NPH SCRIPTS"
.IX Header "USING NPH SCRIPTS"
\&\s-1NPH\s0, or \*(L"no-parsed-header\*(R", scripts bypass the server completely by
sending the complete \s-1HTTP\s0 header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of \s-1HTTP\s0 extensions that are not directly supported by your server,
such as server push and \s-1PICS\s0 headers.
.PP
Servers use a variety of conventions for designating \s-1CGI\s0 scripts as
\&\s-1NPH\s0.  Many Unix servers look at the beginning of the script's name for
the prefix \*(L"nph\-\*(R".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an \s-1NPH\s0 script by examining the first line of script output.
.PP
\&\s-1CGI\s0.pm supports \s-1NPH\s0 scripts with a special \s-1NPH\s0 mode.  When in this
mode, \s-1CGI\s0.pm will output the necessary extra header information when
the \fIheader()\fR and \fIredirect()\fR methods are
called.
.PP
The Microsoft Internet Information Server requires \s-1NPH\s0 mode.  As of
version 2.30, \s-1CGI\s0.pm will automatically detect when the script is
running under \s-1IIS\s0 and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of \s-1NPH\s0 scripts, including the ability to redirect while
setting a cookie, \fBdo not work at all\fR on \s-1IIS\s0 without a special patch
from Microsoft.  See
http://web.archive.org/web/20010812012030/http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP
Non-Parsed Headers Stripped From \s-1CGI\s0 Applications That Have nph\-
Prefix in Name.
.IP "In the \fBuse\fR statement" 4
.IX Item "In the use statement"
Simply add the \*(L"\-nph\*(R" pragma to the list of symbols to be imported into
your script:
.Sp
.Vb 1
\&      use CGI qw(:standard \-nph)
.Ve
.IP "By calling the \fB\f(BInph()\fB\fR method:" 4
.IX Item "By calling the nph() method:"
Call \fB\f(BInph()\fB\fR with a non-zero parameter at any point after using \s-1CGI\s0.pm in your program.
.Sp
.Vb 1
\&      CGI\->nph(1)
.Ve
.IP "By using \fB\-nph\fR parameters" 4
.IX Item "By using -nph parameters"
in the \fB\f(BIheader()\fB\fR and \fB\f(BIredirect()\fB\fR  statements:
.Sp
.Vb 1
\&      print header(\-nph=>1);
.Ve
.SH "Server Push"
.IX Header "Server Push"
\&\s-1CGI\s0.pm provides four simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@fidalgo.net>.  To
import these into your namespace, you must import the \*(L":push\*(R" set.
You are also advised to put the script into \s-1NPH\s0 mode and to set $| to
1 to avoid buffering problems.
.PP
Here is a simple script that demonstrates server push:
.PP
.Vb 10
\&  #!/usr/local/bin/perl
\&  use CGI qw/:push \-nph/;
\&  $| = 1;
\&  print multipart_init(\-boundary=>\*(Aq\-\-\-\-here we go!\*(Aq);
\&  for (0 .. 4) {
\&      print multipart_start(\-type=>\*(Aqtext/plain\*(Aq),
\&            "The current time is ",scalar(localtime),"\en";
\&      if ($_ < 4) {
\&              print multipart_end;
\&      } else {
\&              print multipart_final;
\&      }
\&      sleep 1;
\&  }
.Ve
.PP
This script initializes server push by calling \fB\f(BImultipart_init()\fB\fR.
It then enters a loop in which it begins a new multipart section by
calling \fB\f(BImultipart_start()\fB\fR, prints the current local time,
and ends a multipart section with \fB\f(BImultipart_end()\fB\fR.  It then sleeps
a second, and begins again. On the final iteration, it ends the
multipart section with \fB\f(BImultipart_final()\fB\fR rather than with
\&\fB\f(BImultipart_end()\fB\fR.
.IP "\fImultipart_init()\fR" 4
.IX Item "multipart_init()"
.Vb 1
\&  multipart_init(\-boundary=>$boundary);
.Ve
.Sp
Initialize the multipart system.  The \-boundary argument specifies
what \s-1MIME\s0 boundary string to use to separate parts of the document.
If not provided, \s-1CGI\s0.pm chooses a reasonable boundary for you.
.IP "\fImultipart_start()\fR" 4
.IX Item "multipart_start()"
.Vb 1
\&  multipart_start(\-type=>$type)
.Ve
.Sp
Start a new part of the multipart document using the specified \s-1MIME\s0
type.  If not specified, text/html is assumed.
.IP "\fImultipart_end()\fR" 4
.IX Item "multipart_end()"
.Vb 1
\&  multipart_end()
.Ve
.Sp
End a part.  You must remember to call \fImultipart_end()\fR once for each
\&\fImultipart_start()\fR, except at the end of the last part of the multipart
document when \fImultipart_final()\fR should be called instead of \fImultipart_end()\fR.
.IP "\fImultipart_final()\fR" 4
.IX Item "multipart_final()"
.Vb 1
\&  multipart_final()
.Ve
.Sp
End all parts.  You should call \fImultipart_final()\fR rather than
\&\fImultipart_end()\fR at the end of the last part of the multipart document.
.PP
Users interested in server push applications should also have a look
at the CGI::Push module.
.SH "Avoiding Denial of Service Attacks"
.IX Header "Avoiding Denial of Service Attacks"
A potential problem with \s-1CGI\s0.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a \s-1CGI\s0 script a huge \s-1POST\s0 of many
megabytes.  \s-1CGI\s0.pm will attempt to read the entire \s-1POST\s0 into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.
.PP
Another possible attack is for the remote user to force \s-1CGI\s0.pm to
accept a huge file upload.  \s-1CGI\s0.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  \s-1CGI\s0.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.
.PP
The best way to avoid denial of service attacks is to limit the amount
of memory, \s-1CPU\s0 time and disk space that \s-1CGI\s0 scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell \fIlimit\fR or \fIulimit\fR
commands to put ceilings on \s-1CGI\s0 resource usage.
.PP
\&\s-1CGI\s0.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the \s-1CGI\s0 name space:
.ie n .IP "\fB\fB$CGI::POST_MAX\fB\fR" 4
.el .IP "\fB\f(CB$CGI::POST_MAX\fB\fR" 4
.IX Item "$CGI::POST_MAX"
If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If \s-1CGI\s0.pm detects a \s-1POST\s0
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.
.ie n .IP "\fB\fB$CGI::DISABLE_UPLOADS\fB\fR" 4
.el .IP "\fB\f(CB$CGI::DISABLE_UPLOADS\fB\fR" 4
.IX Item "$CGI::DISABLE_UPLOADS"
If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.
.PP
You can use these variables in either of two ways.
.IP "\fB1. On a script-by-script basis\fR" 4
.IX Item "1. On a script-by-script basis"
Set the variable at the top of the script, right after the \*(L"use\*(R" statement:
.Sp
.Vb 4
\&    use CGI qw/:standard/;
\&    use CGI::Carp \*(AqfatalsToBrowser\*(Aq;
\&    $CGI::POST_MAX=1024 * 100;  # max 100K posts
\&    $CGI::DISABLE_UPLOADS = 1;  # no uploads
.Ve
.IP "\fB2. Globally for all scripts\fR" 4
.IX Item "2. Globally for all scripts"
Open up \s-1CGI\s0.pm, find the definitions for \f(CW$POST_MAX\fR and 
\&\f(CW$DISABLE_UPLOADS\fR, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
\&\fIinitialize_globals()\fR.
.PP
An attempt to send a \s-1POST\s0 larger than \f(CW$POST_MAX\fR bytes will cause
\&\fI\fIparam()\fI\fR to return an empty \s-1CGI\s0 parameter list.  You can test for
this event by checking \fI\fIcgi_error()\fI\fR, either after you create the \s-1CGI\s0
object or, if you are using the function-oriented interface, call
<\fIparam()\fR> for the first time.  If the \s-1POST\s0 was intercepted, then
\&\fIcgi_error()\fR will return the message \*(L"413 \s-1POST\s0 too large\*(R".
.PP
This error message is actually defined by the \s-1HTTP\s0 protocol, and is
designed to be returned to the browser as the \s-1CGI\s0 script's status
 code.  For example:
.PP
.Vb 5
\&   $uploaded_file = param(\*(Aqupload\*(Aq);
\&   if (!$uploaded_file && cgi_error()) {
\&      print header(\-status=>cgi_error());
\&      exit 0;
\&   }
.Ve
.PP
However it isn't clear that any browser currently knows what to do
with this status code.  It might be better just to create an
\&\s-1HTML\s0 page that warns the user of the problem.
.SH "COMPATIBILITY WITH CGI\-LIB.PL"
.IX Header "COMPATIBILITY WITH CGI-LIB.PL"
To make it easier to port existing programs that use cgi\-lib.pl the
compatibility routine \*(L"ReadParse\*(R" is provided.  Porting is simple:
.PP
\&\s-1OLD\s0 \s-1VERSION\s0
.PP
.Vb 3
\&    require "cgi\-lib.pl";
\&    &ReadParse;
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1NEW\s0 \s-1VERSION\s0
.PP
.Vb 3
\&    use CGI;
\&    CGI::ReadParse();
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1CGI\s0.pm's \fIReadParse()\fR routine creates a tied variable named \f(CW%in\fR,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of \f(CW@in\fR and \f(CW$in\fR
variables, are not supported.
.PP
Once you use ReadParse, you can retrieve the query object itself
this way:
.PP
.Vb 3
\&    $q = $in{CGI};
\&    print $q\->textfield(\-name=>\*(Aqwow\*(Aq,
\&            \-value=>\*(Aqdoes this really work?\*(Aq);
.Ve
.PP
This allows you to start using the more interesting features
of \s-1CGI\s0.pm without rewriting your old scripts from scratch.
.PP
An even simpler way to mix cgi-lib calls with \s-1CGI\s0.pm calls is to import both the
\&\f(CW\*(C`:cgi\-lib\*(C'\fR and \f(CW\*(C`:standard\*(C'\fR method:
.PP
.Vb 4
\& use CGI qw(:cgi\-lib :standard);
\& &ReadParse;
\& print "The price of your purchase is $in{price}.\en";
\& print textfield(\-name=>\*(Aqprice\*(Aq, \-default=>\*(Aq$1.99\*(Aq);
.Ve
.SS "Cgi-lib functions that are available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are available in CGI.pm"
In compatibility mode, the following cgi\-lib.pl functions are
available for your use:
.PP
.Vb 7
\& ReadParse()
\& PrintHeader()
\& HtmlTop()
\& HtmlBot()
\& SplitParam()
\& MethGet()
\& MethPost()
.Ve
.SS "Cgi-lib functions that are not available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are not available in CGI.pm"
.Vb 3
\&  * Extended form of ReadParse()
\&    The extended form of ReadParse() that provides for file upload
\&    spooling, is not available.
\&
\&  * MyBaseURL()
\&    This function is not available.  Use CGI.pm\*(Aqs url() method instead.
\&
\&  * MyFullURL()
\&    This function is not available.  Use CGI.pm\*(Aqs self_url() method
\&    instead.
\&
\&  * CgiError(), CgiDie()
\&    These functions are not supported.  Look at CGI::Carp for the way I
\&    prefer to handle error messages.
\&
\&  * PrintVariables()
\&    This function is not available.  To achieve the same effect,
\&       just print out the CGI object:
\&
\&       use CGI qw(:standard);
\&       $q = CGI\->new;
\&       print h1("The Variables Are"),$q;
\&
\&  * PrintEnv()
\&    This function is not available. You\*(Aqll have to roll your own if you really need it.
.Ve
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
The \s-1CGI\s0.pm distribution is copyright 1995\-2007, Lincoln D. Stein. It is
distributed under \s-1GPL\s0 and the Artistic License 2.0. It is currently
maintained by Mark Stosberg with help from many contributors.
.PP
Address bug reports and comments to: https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm
When sending bug reports, please provide the version of \s-1CGI\s0.pm, the version of
Perl, the name and version of your Web server, and the name and version of the
operating system you are using.  If the problem is even remotely browser
dependent, please provide information about the affected browsers as well.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks very much to:
.IP "Matt Heffron (heffron@falstaff.css.beckman.com)" 4
.IX Item "Matt Heffron (heffron@falstaff.css.beckman.com)"
.PD 0
.IP "James Taylor (james.taylor@srs.gov)" 4
.IX Item "James Taylor (james.taylor@srs.gov)"
.IP "Scott Anguish <sanguish@digifix.com>" 4
.IX Item "Scott Anguish <sanguish@digifix.com>"
.IP "Mike Jewell (mlj3u@virginia.edu)" 4
.IX Item "Mike Jewell (mlj3u@virginia.edu)"
.IP "Timothy Shimmin (tes@kbs.citri.edu.au)" 4
.IX Item "Timothy Shimmin (tes@kbs.citri.edu.au)"
.IP "Joergen Haegg (jh@axis.se)" 4
.IX Item "Joergen Haegg (jh@axis.se)"
.IP "Laurent Delfosse (delfosse@delfosse.com)" 4
.IX Item "Laurent Delfosse (delfosse@delfosse.com)"
.IP "Richard Resnick (applepi1@aol.com)" 4
.IX Item "Richard Resnick (applepi1@aol.com)"
.IP "Craig Bishop (csb@barwonwater.vic.gov.au)" 4
.IX Item "Craig Bishop (csb@barwonwater.vic.gov.au)"
.IP "Tony Curtis (tc@vcpc.univie.ac.at)" 4
.IX Item "Tony Curtis (tc@vcpc.univie.ac.at)"
.IP "Tim Bunce (Tim.Bunce@ig.co.uk)" 4
.IX Item "Tim Bunce (Tim.Bunce@ig.co.uk)"
.IP "Tom Christiansen (tchrist@convex.com)" 4
.IX Item "Tom Christiansen (tchrist@convex.com)"
.IP "Andreas Koenig (k@franz.ww.TU\-Berlin.DE)" 4
.IX Item "Andreas Koenig (k@franz.ww.TU-Berlin.DE)"
.IP "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)" 4
.IX Item "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)"
.IP "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)" 4
.IX Item "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)"
.IP "Stephen Dahmen (joyfire@inxpress.net)" 4
.IX Item "Stephen Dahmen (joyfire@inxpress.net)"
.IP "Ed Jordan (ed@fidalgo.net)" 4
.IX Item "Ed Jordan (ed@fidalgo.net)"
.IP "David Alan Pisoni (david@cnation.com)" 4
.IX Item "David Alan Pisoni (david@cnation.com)"
.IP "Doug MacEachern (dougm@opengroup.org)" 4
.IX Item "Doug MacEachern (dougm@opengroup.org)"
.IP "Robin Houston (robin@oneworld.org)" 4
.IX Item "Robin Houston (robin@oneworld.org)"
.IP "...and many many more..." 4
.IX Item "...and many many more..."
.PD
for suggestions and bug fixes.
.SH "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.IX Header "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.Vb 1
\&        #!/usr/local/bin/perl
\&
\&        use CGI \*(Aq:standard\*(Aq;
\&
\&        print header;
\&        print start_html("Example CGI.pm Form");
\&        print "<h1> Example CGI.pm Form</h1>\en";
\&        print_prompt();
\&        do_work();
\&        print_tail();
\&        print end_html;
\&
\&        sub print_prompt {
\&           print start_form;
\&           print "<em>What\*(Aqs your name?</em><br>";
\&           print textfield(\*(Aqname\*(Aq);
\&           print checkbox(\*(AqNot my real name\*(Aq);
\&
\&           print "<p><em>Where can you find English Sparrows?</em><br>";
\&           print checkbox_group(
\&                                 \-name=>\*(AqSparrow locations\*(Aq,
\&                                 \-values=>[England,France,Spain,Asia,Hoboken],
\&                                 \-linebreak=>\*(Aqyes\*(Aq,
\&                                 \-defaults=>[England,Asia]);
\&
\&           print "<p><em>How far can they fly?</em><br>",
\&                radio_group(
\&                        \-name=>\*(Aqhow far\*(Aq,
\&                        \-values=>[\*(Aq10 ft\*(Aq,\*(Aq1 mile\*(Aq,\*(Aq10 miles\*(Aq,\*(Aqreal far\*(Aq],
\&                        \-default=>\*(Aq1 mile\*(Aq);
\&
\&           print "<p><em>What\*(Aqs your favorite color?</em>  ";
\&           print popup_menu(\-name=>\*(AqColor\*(Aq,
\&                                    \-values=>[\*(Aqblack\*(Aq,\*(Aqbrown\*(Aq,\*(Aqred\*(Aq,\*(Aqyellow\*(Aq],
\&                                    \-default=>\*(Aqred\*(Aq);
\&
\&           print hidden(\*(AqReference\*(Aq,\*(AqMonty Python and the Holy Grail\*(Aq);
\&
\&           print "<p><em>What have you got there?</em><br>";
\&           print scrolling_list(
\&                         \-name=>\*(Aqpossessions\*(Aq,
\&                         \-values=>[\*(AqA Coconut\*(Aq,\*(AqA Grail\*(Aq,\*(AqAn Icon\*(Aq,
\&                                   \*(AqA Sword\*(Aq,\*(AqA Ticket\*(Aq],
\&                         \-size=>5,
\&                         \-multiple=>\*(Aqtrue\*(Aq);
\&
\&           print "<p><em>Any parting comments?</em><br>";
\&           print textarea(\-name=>\*(AqComments\*(Aq,
\&                                  \-rows=>10,
\&                                  \-columns=>50);
\&
\&           print "<p>",reset;
\&           print submit(\*(AqAction\*(Aq,\*(AqShout\*(Aq);
\&           print submit(\*(AqAction\*(Aq,\*(AqScream\*(Aq);
\&           print end_form;
\&           print "<hr>\en";
\&        }
\&
\&        sub do_work {
\&
\&           print "<h2>Here are the current settings in this form</h2>";
\&
\&           for my $key (param) {
\&              print "<strong>$key</strong> \-> ";
\&              my @values = param($key);
\&              print join(", ",@values),"<br>\en";
\&          }
\&        }
\&
\&        sub print_tail {
\&           print <<END;
\&        <hr>
\&        <address>Lincoln D. Stein</address><br>
\&        <a href="/">Home Page</a>
\&        END
\&        }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please report them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::Carp \- provides a Carp implementation tailored to the \s-1CGI\s0 environment.
.PP
CGI::Fast \- supports running \s-1CGI\s0 applications under FastCGI
.PP
CGI::Pretty \- pretty prints \s-1HTML\s0 generated by \s-1CGI\s0.pm (with a performance penalty)
                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI5.18.3pm                                  0100644 0001750 0001750 00000477566 12566207451 022250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI 3pm"
.TH CGI 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI \- Handle Common Gateway Interface requests and responses
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CGI;
\&
\&    my $q = CGI\->new;
\&
\&    # Process an HTTP request
\&     @values  = $q\->param(\*(Aqform_field\*(Aq);
\&
\&     $fh      = $q\->upload(\*(Aqfile_field\*(Aq);
\&
\&     $riddle  = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&     %answers = $query\->cookie(\*(Aqanswers\*(Aq);
\&
\&    # Prepare various HTTP responses
\&    print $q\->header();
\&    print $q\->header(\*(Aqapplication/json\*(Aq);
\&
\&        $cookie1 = $q\->cookie(\-name=>\*(Aqriddle_name\*(Aq, \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = $q\->cookie(\-name=>\*(Aqanswers\*(Aq, \-value=>\e%answers);
\&    print $q\->header(
\&        \-type    => \*(Aqimage/gif\*(Aq,
\&        \-expires => \*(Aq+3d\*(Aq,
\&        \-cookie  => [$cookie1,$cookie2]
\&        );
\&
\&   print  $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1CGI\s0.pm is a stable, complete and mature solution for processing and preparing
\&\s-1HTTP\s0 requests and responses.  Major features including processing form
submissions, file uploads, reading and writing cookies, query string generation
and manipulation, and processing and preparing \s-1HTTP\s0 headers. Some \s-1HTML\s0
generation utilities are included as well.
.PP
\&\s-1CGI\s0.pm performs very well in in a vanilla \s-1CGI\s0.pm environment and also comes
with built-in support for mod_perl and mod_perl2 as well as FastCGI.
.PP
It has the benefit of having developed and refined over 10 years with input
from dozens of contributors and being deployed on thousands of websites.
\&\s-1CGI\s0.pm has been included in the Perl distribution since Perl 5.4, and has
become a de-facto standard.
.SS "\s-1PROGRAMMING STYLE\s0"
.IX Subsection "PROGRAMMING STYLE"
There are two styles of programming with \s-1CGI\s0.pm, an object-oriented
style and a function-oriented style.  In the object-oriented style you
create one or more \s-1CGI\s0 objects and then use object methods to create
the various elements of the page.  Each \s-1CGI\s0 object starts out with the
list of named parameters that were passed to your \s-1CGI\s0 script by the
server.  You can modify the objects, save them to a file or database
and recreate them.  Because each object corresponds to the \*(L"state\*(R" of
the \s-1CGI\s0 script, and because each object's parameter list is
independent of the others, this allows you to save the state of the
script and restore it later.
.PP
For example, using the object oriented style, here is how you create
a simple \*(L"Hello World\*(R" \s-1HTML\s0 page:
.PP
.Vb 7
\&   #!/usr/local/bin/perl \-w
\&   use CGI;                             # load CGI routines
\&   $q = CGI\->new;                        # create new CGI object
\&   print $q\->header,                    # create the HTTP header
\&         $q\->start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         $q\->h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         $q\->end_html;                  # end the HTML
.Ve
.PP
In the function-oriented style, there is one default \s-1CGI\s0 object that
you rarely deal with directly.  Instead you just call functions to
retrieve \s-1CGI\s0 parameters, create \s-1HTML\s0 tags, manage cookies, and so
on.  This provides you with a cleaner programming interface, but
limits you to using one \s-1CGI\s0 object at a time.  The following example
prints the same page, but uses the function-oriented interface.
The main differences are that we now need to import a set of functions
into our name space (usually the \*(L"standard\*(R" functions), and we don't
need to create the \s-1CGI\s0 object.
.PP
.Vb 6
\&   #!/usr/local/bin/perl
\&   use CGI qw/:standard/;           # load standard CGI routines
\&   print header,                    # create the HTTP header
\&         start_html(\*(Aqhello world\*(Aq), # start the HTML
\&         h1(\*(Aqhello world\*(Aq),         # level 1 header
\&         end_html;                  # end the HTML
.Ve
.PP
The examples in this document mainly use the object-oriented style.
See \s-1HOW TO IMPORT FUNCTIONS\s0 for important information on
function-oriented programming in \s-1CGI\s0.pm
.SS "\s-1CALLING CGI.PM ROUTINES\s0"
.IX Subsection "CALLING CGI.PM ROUTINES"
Most \s-1CGI\s0.pm routines accept several arguments, sometimes as many as 20
optional ones!  To simplify this interface, all routines use a named
argument calling style that looks like this:
.PP
.Vb 1
\&   print $q\->header(\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq);
.Ve
.PP
Each argument name is preceded by a dash.  Neither case nor order
matters in the argument list.  \-type, \-Type, and \-TYPE are all
acceptable.  In fact, only the first argument needs to begin with a
dash.  If a dash is present in the first argument, \s-1CGI\s0.pm assumes
dashes for the subsequent ones.
.PP
Several routines are commonly called with just one argument.  In the
case of these routines you can provide the single argument without an
argument name.  \fIheader()\fR happens to be one of these routines.  In this
case, the single argument is the document type.
.PP
.Vb 1
\&   print $q\->header(\*(Aqtext/html\*(Aq);
.Ve
.PP
Other such routines are documented below.
.PP
Sometimes named arguments expect a scalar, sometimes a reference to an
array, and sometimes a reference to a hash.  Often, you can pass any
type of argument and the routine will do whatever is most appropriate.
For example, the \fIparam()\fR routine is used to set a \s-1CGI\s0 parameter to a
single or a multi-valued value.  The two cases are shown below:
.PP
.Vb 2
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>\*(Aqtomato\*(Aq);
\&   $q\->param(\-name=>\*(Aqveggie\*(Aq,\-value=>[\*(Aqtomato\*(Aq,\*(Aqtomahto\*(Aq,\*(Aqpotato\*(Aq,\*(Aqpotahto\*(Aq]);
.Ve
.PP
A large number of routines in \s-1CGI\s0.pm actually aren't specifically
defined in the module, but are generated automatically as needed.
These are the \*(L"\s-1HTML\s0 shortcuts,\*(R" routines that generate \s-1HTML\s0 tags for
use in dynamically-generated pages.  \s-1HTML\s0 tags have both attributes
(the attribute=\*(L"value\*(R" pairs within the tag itself) and contents (the
part between the opening and closing pairs.)  To distinguish between
attributes and contents, \s-1CGI\s0.pm uses the convention of passing \s-1HTML\s0
attributes as a hash reference as the first argument, and the
contents, if any, as any subsequent arguments.  It works out like
this:
.PP
.Vb 6
\&   Code                           Generated HTML
\&   \-\-\-\-                           \-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&   h1()                           <h1>
\&   h1(\*(Aqsome\*(Aq,\*(Aqcontents\*(Aq);         <h1>some contents</h1>
\&   h1({\-align=>left});            <h1 align="LEFT">
\&   h1({\-align=>left},\*(Aqcontents\*(Aq); <h1 align="LEFT">contents</h1>
.Ve
.PP
\&\s-1HTML\s0 tags are described in more detail later.
.PP
Many newcomers to \s-1CGI\s0.pm are puzzled by the difference between the
calling conventions for the \s-1HTML\s0 shortcuts, which require curly braces
around the \s-1HTML\s0 tag attributes, and the calling conventions for other
routines, which manage to generate attributes without the curly
brackets.  Don't be confused.  As a convenience the curly braces are
optional in all but the \s-1HTML\s0 shortcuts.  If you like, you can use
curly braces when calling any routine that takes named arguments.  For
example:
.PP
.Vb 1
\&   print $q\->header( {\-type=>\*(Aqimage/gif\*(Aq,\-expires=>\*(Aq+3d\*(Aq} );
.Ve
.PP
If you use the \fB\-w\fR switch, you will be warned that some \s-1CGI\s0.pm argument
names conflict with built-in Perl functions.  The most frequent of
these is the \-values argument, used to create multi-valued menus,
radio button clusters and the like.  To get around this warning, you
have several choices:
.IP "1." 4
Use another name for the argument, if one is available. 
For example, \-value is an alias for \-values.
.IP "2." 4
Change the capitalization, e.g. \-Values
.IP "3." 4
Put quotes around the argument name, e.g. '\-values'
.PP
Many routines will do something useful with a named argument that it
doesn't recognize.  For example, you can produce non-standard \s-1HTTP\s0
header fields by providing them as named arguments:
.PP
.Vb 4
\&  print $q\->header(\-type  =>  \*(Aqtext/html\*(Aq,
\&                   \-cost  =>  \*(AqThree smackers\*(Aq,
\&                   \-annoyance_level => \*(Aqhigh\*(Aq,
\&                   \-complaints_to   => \*(Aqbit bucket\*(Aq);
.Ve
.PP
This will produce the following nonstandard \s-1HTTP\s0 header:
.PP
.Vb 5
\&   HTTP/1.0 200 OK
\&   Cost: Three smackers
\&   Annoyance\-level: high
\&   Complaints\-to: bit bucket
\&   Content\-type: text/html
.Ve
.PP
Notice the way that underscores are translated automatically into
hyphens.  HTML-generating routines perform a different type of
translation.
.PP
This feature allows you to keep up with the rapidly changing \s-1HTTP\s0 and
\&\s-1HTML \s0\*(L"standards\*(R".
.SS "\s-1CREATING A NEW QUERY OBJECT \s0(OBJECT-ORIENTED \s-1STYLE\s0):"
.IX Subsection "CREATING A NEW QUERY OBJECT (OBJECT-ORIENTED STYLE):"
.Vb 1
\&     $query = CGI\->new;
.Ve
.PP
This will parse the input (from \s-1POST, GET\s0 and \s-1DELETE\s0 methods) and store
it into a perl5 object called \f(CW$query\fR.
.PP
Any filehandles from file uploads will have their position reset to 
the beginning of the file.
.SS "\s-1CREATING A NEW QUERY OBJECT FROM AN INPUT FILE\s0"
.IX Subsection "CREATING A NEW QUERY OBJECT FROM AN INPUT FILE"
.Vb 1
\&     $query = CGI\->new(INPUTFILE);
.Ve
.PP
If you provide a file handle to the \fInew()\fR method, it will read
parameters from the file (or \s-1STDIN,\s0 or whatever).  The file can be in
any of the forms describing below under debugging (i.e. a series of
newline delimited TAG=VALUE pairs will work).  Conveniently, this type
of file is created by the \fIsave()\fR method (see below).  Multiple records
can be saved and restored.
.PP
Perl purists will be pleased to know that this syntax accepts
references to file handles, or even references to filehandle globs,
which is the \*(L"official\*(R" way to pass a filehandle:
.PP
.Vb 1
\&    $query = CGI\->new(\e*STDIN);
.Ve
.PP
You can also initialize the \s-1CGI\s0 object with a FileHandle or IO::File
object.
.PP
If you are using the function-oriented interface and want to
initialize \s-1CGI\s0 state from a file handle, the way to do this is with
\&\fB\f(BIrestore_parameters()\fB\fR.  This will (re)initialize the
default \s-1CGI\s0 object from the indicated file handle.
.PP
.Vb 3
\&    open (IN,"test.in") || die;
\&    restore_parameters(IN);
\&    close IN;
.Ve
.PP
You can also initialize the query object from a hash
reference:
.PP
.Vb 4
\&    $query = CGI\->new( {\*(Aqdinosaur\*(Aq=>\*(Aqbarney\*(Aq,
\&                       \*(Aqsong\*(Aq=>\*(AqI love you\*(Aq,
\&                       \*(Aqfriends\*(Aq=>[qw/Jessica George Nancy/]}
\&                    );
.Ve
.PP
or from a properly formatted, URL-escaped query string:
.PP
.Vb 1
\&    $query = CGI\->new(\*(Aqdinosaur=barney&color=purple\*(Aq);
.Ve
.PP
or from a previously existing \s-1CGI\s0 object (currently this clones the
parameter list, but none of the other object-specific fields, such as
autoescaping):
.PP
.Vb 2
\&    $old_query = CGI\->new;
\&    $new_query = CGI\->new($old_query);
.Ve
.PP
To create an empty query, initialize it from an empty string or hash:
.PP
.Vb 1
\&   $empty_query = CGI\->new("");
\&
\&       \-or\-
\&
\&   $empty_query = CGI\->new({});
.Ve
.SS "\s-1FETCHING A LIST OF KEYWORDS FROM THE QUERY:\s0"
.IX Subsection "FETCHING A LIST OF KEYWORDS FROM THE QUERY:"
.Vb 1
\&     @keywords = $query\->keywords
.Ve
.PP
If the script was invoked as the result of an <\s-1ISINDEX\s0> search, the
parsed keywords can be obtained as an array using the \fIkeywords()\fR method.
.SS "\s-1FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:\s0"
.IX Subsection "FETCHING THE NAMES OF ALL THE PARAMETERS PASSED TO YOUR SCRIPT:"
.Vb 1
\&     @names = $query\->param
.Ve
.PP
If the script was invoked with a parameter list
(e.g. \*(L"name1=value1&name2=value2&name3=value3\*(R"), the \fIparam()\fR method
will return the parameter names as a list.  If the script was invoked
as an <\s-1ISINDEX\s0> script and contains a string without ampersands
(e.g. \*(L"value1+value2+value3\*(R") , there will be a single parameter named
\&\*(L"keywords\*(R" containing the \*(L"+\*(R"\-delimited keywords.
.PP
\&\s-1NOTE:\s0 As of version 1.5, the array of parameter names returned will
be in the same order as they were submitted by the browser.
Usually this order is the same as the order in which the 
parameters are defined in the form (however, this isn't part
of the spec, and so isn't guaranteed).
.SS "\s-1FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:\s0"
.IX Subsection "FETCHING THE VALUE OR VALUES OF A SINGLE NAMED PARAMETER:"
.Vb 1
\&    @values = $query\->param(\*(Aqfoo\*(Aq);
\&
\&              \-or\-
\&
\&    $value = $query\->param(\*(Aqfoo\*(Aq);
.Ve
.PP
Pass the \fIparam()\fR method a single argument to fetch the value of the
named parameter. If the parameter is multivalued (e.g. from multiple
selections in a scrolling list), you can ask to receive an array.  Otherwise
the method will return a single value.
.PP
If a value is not given in the query string, as in the queries
\&\*(L"name1=&name2=\*(R", it will be returned as an empty string.
.PP
If the parameter does not exist at all, then \fIparam()\fR will return undef
in a scalar context, and the empty list in a list context.
.SS "\s-1SETTING THE VALUE\s0(S) \s-1OF A NAMED PARAMETER:\s0"
.IX Subsection "SETTING THE VALUE(S) OF A NAMED PARAMETER:"
.Vb 1
\&    $query\->param(\*(Aqfoo\*(Aq,\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq);
.Ve
.PP
This sets the value for the named parameter 'foo' to an array of
values.  This is one way to change the value of a field \s-1AFTER\s0
the script has been invoked once before.  (Another way is with
the \-override parameter accepted by all methods that generate
form elements.)
.PP
\&\fIparam()\fR also recognizes a named parameter style of calling described
in more detail later:
.PP
.Vb 1
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqan\*(Aq,\*(Aqarray\*(Aq,\*(Aqof\*(Aq,\*(Aqvalues\*(Aq]);
\&
\&                              \-or\-
\&
\&    $query\->param(\-name=>\*(Aqfoo\*(Aq,\-value=>\*(Aqthe value\*(Aq);
.Ve
.SS "\s-1APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:\s0"
.IX Subsection "APPENDING ADDITIONAL VALUES TO A NAMED PARAMETER:"
.Vb 1
\&   $query\->append(\-name=>\*(Aqfoo\*(Aq,\-values=>[\*(Aqyet\*(Aq,\*(Aqmore\*(Aq,\*(Aqvalues\*(Aq]);
.Ve
.PP
This adds a value or list of values to the named parameter.  The
values are appended to the end of the parameter if it already exists.
Otherwise the parameter is created.  Note that this method only
recognizes the named argument calling syntax.
.SS "\s-1IMPORTING ALL PARAMETERS INTO A NAMESPACE:\s0"
.IX Subsection "IMPORTING ALL PARAMETERS INTO A NAMESPACE:"
.Vb 1
\&   $query\->import_names(\*(AqR\*(Aq);
.Ve
.PP
This creates a series of variables in the 'R' namespace.  For example,
\&\f(CW$R::foo\fR, \f(CW@R:foo\fR.  For keyword lists, a variable \f(CW@R::keywords\fR will appear.
If no namespace is given, this method will assume 'Q'.
\&\s-1WARNING: \s0 don't import anything into 'main'; this is a major security
risk!!!!
.PP
\&\s-1NOTE 1:\s0 Variable names are transformed as necessary into legal Perl
variable names.  All non-legal characters are transformed into
underscores.  If you need to keep the original names, you should use
the \fIparam()\fR method instead to access \s-1CGI\s0 variables by name.
.PP
\&\s-1NOTE 2:\s0 In older versions, this method was called \fB\f(BIimport()\fB\fR.  As of version 2.20, 
this name has been removed completely to avoid conflict with the built-in
Perl module \fBimport\fR operator.
.SS "\s-1DELETING A PARAMETER COMPLETELY:\s0"
.IX Subsection "DELETING A PARAMETER COMPLETELY:"
.Vb 1
\&    $query\->delete(\*(Aqfoo\*(Aq,\*(Aqbar\*(Aq,\*(Aqbaz\*(Aq);
.Ve
.PP
This completely clears a list of parameters.  It sometimes useful for
resetting parameters that you don't want passed down between script
invocations.
.PP
If you are using the function call interface, use \*(L"\fIDelete()\fR\*(R" instead
to avoid conflicts with Perl's built-in delete operator.
.SS "\s-1DELETING ALL PARAMETERS:\s0"
.IX Subsection "DELETING ALL PARAMETERS:"
.Vb 1
\&   $query\->delete_all();
.Ve
.PP
This clears the \s-1CGI\s0 object completely.  It might be useful to ensure
that all the defaults are taken when you create a fill-out form.
.PP
Use \fIDelete_all()\fR instead if you are using the function call interface.
.SS "\s-1HANDLING\s0 NON-URLENCODED \s-1ARGUMENTS\s0"
.IX Subsection "HANDLING NON-URLENCODED ARGUMENTS"
If POSTed data is not of type application/x\-www\-form\-urlencoded or
multipart/form\-data, then the POSTed data will not be processed, but
instead be returned as-is in a parameter named \s-1POSTDATA. \s0 To retrieve
it, use code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPOSTDATA\*(Aq);
.Ve
.PP
Likewise if PUTed data can be retrieved with code like this:
.PP
.Vb 1
\&   my $data = $query\->param(\*(AqPUTDATA\*(Aq);
.Ve
.PP
(If you don't know what the preceding means, don't worry about it.  It
only affects people trying to use \s-1CGI\s0 for \s-1XML\s0 processing and other
specialized tasks.)
.SS "\s-1DIRECT ACCESS TO THE PARAMETER LIST:\s0"
.IX Subsection "DIRECT ACCESS TO THE PARAMETER LIST:"
.Vb 2
\&   $q\->param_fetch(\*(Aqaddress\*(Aq)\->[1] = \*(Aq1313 Mockingbird Lane\*(Aq;
\&   unshift @{$q\->param_fetch(\-name=>\*(Aqaddress\*(Aq)},\*(AqGeorge Munster\*(Aq;
.Ve
.PP
If you need access to the parameter list in a way that isn't covered
by the methods given in the previous sections, you can obtain a direct 
reference to it by
calling the \fB\f(BIparam_fetch()\fB\fR method with the name of the parameter.  This
will return an array reference to the named parameter, which you then
can manipulate in any way you like.
.PP
You can also use a named argument style using the \fB\-name\fR argument.
.SS "\s-1FETCHING THE PARAMETER LIST AS A HASH:\s0"
.IX Subsection "FETCHING THE PARAMETER LIST AS A HASH:"
.Vb 4
\&    $params = $q\->Vars;
\&    print $params\->{\*(Aqaddress\*(Aq};
\&    @foo = split("\e0",$params\->{\*(Aqfoo\*(Aq});
\&    %params = $q\->Vars;
\&
\&    use CGI \*(Aq:cgi\-lib\*(Aq;
\&    $params = Vars;
.Ve
.PP
Many people want to fetch the entire parameter list as a hash in which
the keys are the names of the \s-1CGI\s0 parameters, and the values are the
parameters' values.  The \fIVars()\fR method does this.  Called in a scalar
context, it returns the parameter list as a tied hash reference.
Changing a key changes the value of the parameter in the underlying
\&\s-1CGI\s0 parameter list.  Called in a list context, it returns the
parameter list as an ordinary hash.  This allows you to read the
contents of the parameter list, but not to change it.
.PP
When using this, the thing you must watch out for are multivalued \s-1CGI\s0
parameters.  Because a hash cannot distinguish between scalar and
list context, multivalued parameters will be returned as a packed
string, separated by the \*(L"\e0\*(R" (null) character.  You must split this
packed string in order to get at the individual values.  This is the
convention introduced long ago by Steve Brenner in his cgi\-lib.pl
module for Perl version 4.
.PP
If you wish to use \fIVars()\fR as a function, import the \fI:cgi\-lib\fR set of
function calls (also see the section on CGI-LIB compatibility).
.SS "\s-1SAVING THE STATE OF THE SCRIPT TO A FILE:\s0"
.IX Subsection "SAVING THE STATE OF THE SCRIPT TO A FILE:"
.Vb 1
\&    $query\->save(\e*FILEHANDLE)
.Ve
.PP
This will write the current state of the form to the provided
filehandle.  You can read it back in by providing a filehandle
to the \fInew()\fR method.  Note that the filehandle can be a file, a pipe,
or whatever!
.PP
The format of the saved file is:
.PP
.Vb 5
\&        NAME1=VALUE1
\&        NAME1=VALUE1\*(Aq
\&        NAME2=VALUE2
\&        NAME3=VALUE3
\&        =
.Ve
.PP
Both name and value are \s-1URL\s0 escaped.  Multi-valued \s-1CGI\s0 parameters are
represented as repeated names.  A session record is delimited by a
single = symbol.  You can write out multiple records and read them
back in with several calls to \fBnew\fR.  You can do this across several
sessions by opening the file in append mode, allowing you to create
primitive guest books, or to keep a history of users' queries.  Here's
a short example of creating multiple session records:
.PP
.Vb 1
\&   use CGI;
\&
\&   open (OUT,\*(Aq>>\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   $records = 5;
\&   for (0..$records) {
\&       my $q = CGI\->new;
\&       $q\->param(\-name=>\*(Aqcounter\*(Aq,\-value=>$_);
\&       $q\->save(\e*OUT);
\&   }
\&   close OUT;
\&
\&   # reopen for reading
\&   open (IN,\*(Aq<\*(Aq,\*(Aqtest.out\*(Aq) || die;
\&   while (!eof(IN)) {
\&       my $q = CGI\->new(\e*IN);
\&       print $q\->param(\*(Aqcounter\*(Aq),"\en";
\&   }
.Ve
.PP
The file format used for save/restore is identical to that used by the
Whitehead Genome Center's data exchange format \*(L"Boulderio\*(R", and can be
manipulated and even databased using Boulderio utilities.  See
.PP
.Vb 1
\&  http://stein.cshl.org/boulder/
.Ve
.PP
for further details.
.PP
If you wish to use this method from the function-oriented (non-OO)
interface, the exported name for this method is \fB\f(BIsave_parameters()\fB\fR.
.SS "\s-1RETRIEVING CGI ERRORS\s0"
.IX Subsection "RETRIEVING CGI ERRORS"
Errors can occur while processing user input, particularly when
processing uploaded files.  When these errors occur, \s-1CGI\s0 will stop
processing and return an empty parameter list.  You can test for
the existence and nature of errors using the \fI\fIcgi_error()\fI\fR function.
The error messages are formatted as \s-1HTTP\s0 status codes. You can either
incorporate the error text into an \s-1HTML\s0 page, or use it as the value
of the \s-1HTTP\s0 status:
.PP
.Vb 8
\&    my $error = $q\->cgi_error;
\&    if ($error) {
\&        print $q\->header(\-status=>$error),
\&              $q\->start_html(\*(AqProblems\*(Aq),
\&              $q\->h2(\*(AqRequest not processed\*(Aq),
\&              $q\->strong($error);
\&        exit 0;
\&    }
.Ve
.PP
When using the function-oriented interface (see the next section),
errors may only occur the first time you call \fI\fIparam()\fI\fR. Be ready
for this!
.SS "\s-1USING THE\s0 FUNCTION-ORIENTED \s-1INTERFACE\s0"
.IX Subsection "USING THE FUNCTION-ORIENTED INTERFACE"
To use the function-oriented interface, you must specify which \s-1CGI\s0.pm
routines or sets of routines to import into your script's namespace.
There is a small overhead associated with this importation, but it
isn't much.
.PP
.Vb 1
\&   use CGI <list of methods>;
.Ve
.PP
The listed methods will be imported into the current package; you can
call them directly without creating a \s-1CGI\s0 object first.  This example
shows how to import the \fB\f(BIparam()\fB\fR and \fB\f(BIheader()\fB\fR
methods, and then use them directly:
.PP
.Vb 3
\&   use CGI \*(Aqparam\*(Aq,\*(Aqheader\*(Aq;
\&   print header(\*(Aqtext/plain\*(Aq);
\&   $zipcode = param(\*(Aqzipcode\*(Aq);
.Ve
.PP
More frequently, you'll import common sets of functions by referring
to the groups by name.  All function sets are preceded with a \*(L":\*(R"
character as in \*(L":html3\*(R" (for tags defined in the \s-1HTML 3\s0 standard).
.PP
Here is a list of the function sets you can import:
.IP "\fB:cgi\fR" 4
.IX Item ":cgi"
Import all CGI-handling methods, such as \fB\f(BIparam()\fB\fR, \fB\f(BIpath_info()\fB\fR
and the like.
.IP "\fB:form\fR" 4
.IX Item ":form"
Import all fill-out form generating methods, such as \fB\f(BItextfield()\fB\fR.
.IP "\fB:html2\fR" 4
.IX Item ":html2"
Import all methods that generate \s-1HTML 2.0\s0 standard elements.
.IP "\fB:html3\fR" 4
.IX Item ":html3"
Import all methods that generate \s-1HTML 3.0\s0 elements (such as
<table>, <super> and <sub>).
.IP "\fB:html4\fR" 4
.IX Item ":html4"
Import all methods that generate \s-1HTML 4\s0 elements (such as
<abbrev>, <acronym> and <thead>).
.IP "\fB:netscape\fR" 4
.IX Item ":netscape"
Import the <blink>, <fontsize> and <center> tags.
.IP "\fB:html\fR" 4
.IX Item ":html"
Import all HTML-generating shortcuts (i.e. 'html2', 'html3', 'html4' and 'netscape')
.IP "\fB:standard\fR" 4
.IX Item ":standard"
Import \*(L"standard\*(R" features, 'html2', 'html3', 'html4', 'form' and 'cgi'.
.IP "\fB:all\fR" 4
.IX Item ":all"
Import all the available methods.  For the full list, see the \s-1CGI\s0.pm
code, where the variable \f(CW%EXPORT_TAGS\fR is defined.
.PP
If you import a function name that is not part of \s-1CGI\s0.pm, the module
will treat it as a new \s-1HTML\s0 tag and generate the appropriate
subroutine.  You can then use it like any other \s-1HTML\s0 tag.  This is to
provide for the rapidly-evolving \s-1HTML \s0\*(L"standard.\*(R"  For example, say
Microsoft comes out with a new tag called <gradient> (which causes the
user's desktop to be flooded with a rotating gradient fill until his
machine reboots).  You don't need to wait for a new version of \s-1CGI\s0.pm
to start using it immediately:
.PP
.Vb 2
\&   use CGI qw/:standard :html3 gradient/;
\&   print gradient({\-start=>\*(Aqred\*(Aq,\-end=>\*(Aqblue\*(Aq});
.Ve
.PP
Note that in the interests of execution speed \s-1CGI\s0.pm does \fBnot\fR use
the standard Exporter syntax for specifying load symbols.  This may
change in the future.
.PP
If you import any of the state-maintaining \s-1CGI\s0 or form-generating
methods, a default \s-1CGI\s0 object will be created and initialized
automatically the first time you use any of the methods that require
one to be present.  This includes \fB\f(BIparam()\fB\fR, \fB\f(BItextfield()\fB\fR,
\&\fB\f(BIsubmit()\fB\fR and the like.  (If you need direct access to the \s-1CGI\s0
object, you can find it in the global variable \fB\f(CB$CGI::Q\fB\fR).  By
importing \s-1CGI\s0.pm methods, you can create visually elegant scripts:
.PP
.Vb 10
\&   use CGI qw/:standard/;
\&   print 
\&       header,
\&       start_html(\*(AqSimple Script\*(Aq),
\&       h1(\*(AqSimple Script\*(Aq),
\&       start_form,
\&       "What\*(Aqs your name? ",textfield(\*(Aqname\*(Aq),p,
\&       "What\*(Aqs the combination?",
\&       checkbox_group(\-name=>\*(Aqwords\*(Aq,
\&                      \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                      \-defaults=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq]),p,
\&       "What\*(Aqs your favorite color?",
\&       popup_menu(\-name=>\*(Aqcolor\*(Aq,
\&                  \-values=>[\*(Aqred\*(Aq,\*(Aqgreen\*(Aq,\*(Aqblue\*(Aq,\*(Aqchartreuse\*(Aq]),p,
\&       submit,
\&       end_form,
\&       hr,"\en";
\&
\&    if (param) {
\&       print 
\&           "Your name is ",em(param(\*(Aqname\*(Aq)),p,
\&           "The keywords are: ",em(join(", ",param(\*(Aqwords\*(Aq))),p,
\&           "Your favorite color is ",em(param(\*(Aqcolor\*(Aq)),".\en";
\&    }
\&    print end_html;
.Ve
.SS "\s-1PRAGMAS\s0"
.IX Subsection "PRAGMAS"
In addition to the function sets, there are a number of pragmas that
you can import.  Pragmas, which are always preceded by a hyphen,
change the way that \s-1CGI\s0.pm functions in various ways.  Pragmas,
function sets, and individual functions can all be imported in the
same \fIuse()\fR line.  For example, the following use statement imports the
standard set of functions and enables debugging mode (pragma
\&\-debug):
.PP
.Vb 1
\&   use CGI qw/:standard \-debug/;
.Ve
.PP
The current list of pragmas is as follows:
.IP "\-any" 4
.IX Item "-any"
When you \fIuse \s-1CGI\s0 \-any\fR, then any method that the query object
doesn't recognize will be interpreted as a new \s-1HTML\s0 tag.  This allows
you to support the next \fIad hoc\fR \s-1HTML\s0
extension.  This lets you go wild with new and unsupported tags:
.Sp
.Vb 3
\&   use CGI qw(\-any);
\&   $q=CGI\->new;
\&   print $q\->gradient({speed=>\*(Aqfast\*(Aq,start=>\*(Aqred\*(Aq,end=>\*(Aqblue\*(Aq});
.Ve
.Sp
Since using <cite>any</cite> causes any mistyped method name
to be interpreted as an \s-1HTML\s0 tag, use it with care or not at
all.
.IP "\-compile" 4
.IX Item "-compile"
This causes the indicated autoloaded methods to be compiled up front,
rather than deferred to later.  This is useful for scripts that run
for an extended period of time under FastCGI or mod_perl, and for
those destined to be crunched by Malcolm Beattie's Perl compiler.  Use
it in conjunction with the methods or method families you plan to use.
.Sp
.Vb 1
\&   use CGI qw(\-compile :standard :html3);
.Ve
.Sp
or even
.Sp
.Vb 1
\&   use CGI qw(\-compile :all);
.Ve
.Sp
Note that using the \-compile pragma in this way will always have
the effect of importing the compiled functions into the current
namespace.  If you want to compile without importing use the
\&\fIcompile()\fR method instead:
.Sp
.Vb 2
\&   use CGI();
\&   CGI\->compile();
.Ve
.Sp
This is particularly useful in a mod_perl environment, in which you
might want to precompile all \s-1CGI\s0 routines in a startup script, and
then import the functions individually in each mod_perl script.
.IP "\-nosticky" 4
.IX Item "-nosticky"
By default the \s-1CGI\s0 module implements a state-preserving behavior
called \*(L"sticky\*(R" fields.  The way this works is that if you are
regenerating a form, the methods that generate the form field values
will interrogate \fIparam()\fR to see if similarly-named parameters are
present in the query string. If they find a like-named parameter, they
will use it to set their default values.
.Sp
Sometimes this isn't what you want.  The \fB\-nosticky\fR pragma prevents
this behavior.  You can also selectively change the sticky behavior in
each element that you generate.
.IP "\-tabindex" 4
.IX Item "-tabindex"
Automatically add tab index attributes to each form field. With this
option turned off, you can still add tab indexes manually by passing a
\&\-tabindex option to each field-generating method.
.IP "\-no_undef_params" 4
.IX Item "-no_undef_params"
This keeps \s-1CGI\s0.pm from including undef params in the parameter list.
.IP "\-no_xhtml" 4
.IX Item "-no_xhtml"
By default, \s-1CGI\s0.pm versions 2.69 and higher emit \s-1XHTML
\&\s0(http://www.w3.org/TR/xhtml1/).  The \-no_xhtml pragma disables this
feature.  Thanks to Michalis Kabrianis <kabrianis@hellug.gr> for this
feature.
.Sp
If \fIstart_html()\fR's \-dtd parameter specifies an \s-1HTML 2.0, 
3.2, 4.0\s0 or 4.01 \s-1DTD, 
XHTML\s0 will automatically be disabled without needing to use this 
pragma.
.IP "\-utf8" 4
.IX Item "-utf8"
This makes \s-1CGI\s0.pm treat all parameters as \s-1UTF\-8\s0 strings. Use this with
care, as it will interfere with the processing of binary uploads. It
is better to manually select which fields are expected to return utf\-8
strings and convert them using code like this:
.Sp
.Vb 2
\& use Encode;
\& my $arg = decode utf8=>param(\*(Aqfoo\*(Aq);
.Ve
.IP "\-nph" 4
.IX Item "-nph"
This makes \s-1CGI\s0.pm produce a header appropriate for an \s-1NPH \s0(no
parsed header) script.  You may need to do other things as well
to tell the server that the script is \s-1NPH. \s0 See the discussion
of \s-1NPH\s0 scripts below.
.IP "\-newstyle_urls" 4
.IX Item "-newstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
semicolons rather than ampersands.  For example:
.Sp
.Vb 1
\&   ?name=fred;age=24;favorite_color=3
.Ve
.Sp
Semicolon-delimited query strings are always accepted, and will be emitted by
\&\fIself_url()\fR and \fIquery_string()\fR. newstyle_urls became the default in version
2.64.
.IP "\-oldstyle_urls" 4
.IX Item "-oldstyle_urls"
Separate the name=value pairs in \s-1CGI\s0 parameter query strings with
ampersands rather than semicolons.  This is no longer the default.
.IP "\-autoload" 4
.IX Item "-autoload"
This overrides the autoloader so that any function in your program
that is not recognized is referred to \s-1CGI\s0.pm for possible evaluation.
This allows you to use all the \s-1CGI\s0.pm functions without adding them to
your symbol table, which is of concern for mod_perl users who are
worried about memory consumption.  \fIWarning:\fR when
\&\fI\-autoload\fR is in effect, you cannot use \*(L"poetry mode\*(R"
(functions without the parenthesis).  Use \fI\fIhr()\fI\fR rather
than \fIhr\fR, or add something like \fIuse subs qw/hr p header/\fR 
to the top of your script.
.IP "\-no_debug" 4
.IX Item "-no_debug"
This turns off the command-line processing features.  If you want to
run a \s-1CGI\s0.pm script from the command line to produce \s-1HTML,\s0 and you
don't want it to read \s-1CGI\s0 parameters from the command line or \s-1STDIN,\s0
then use this pragma:
.Sp
.Vb 1
\&   use CGI qw(\-no_debug :standard);
.Ve
.IP "\-debug" 4
.IX Item "-debug"
This turns on full debugging.  In addition to reading \s-1CGI\s0 arguments
from the command-line processing, \s-1CGI\s0.pm will pause and try to read
arguments from \s-1STDIN,\s0 producing the message \*(L"(offline mode: enter
name=value pairs on standard input)\*(R" features.
.Sp
See the section on debugging for more details.
.IP "\-private_tempfiles" 4
.IX Item "-private_tempfiles"
\&\s-1CGI\s0.pm can process uploaded file. Ordinarily it spools the uploaded
file to a temporary directory, then deletes the file when done.
However, this opens the risk of eavesdropping as described in the file
upload section.  Another \s-1CGI\s0 script author could peek at this data
during the upload, even if it is confidential information. On Unix
systems, the \-private_tempfiles pragma will cause the temporary file
to be unlinked as soon as it is opened and before any data is written
into it, reducing, but not eliminating the risk of eavesdropping
(there is still a potential race condition).  To make life harder for
the attacker, the program chooses tempfile names by calculating a 32
bit checksum of the incoming \s-1HTTP\s0 headers.
.Sp
To ensure that the temporary file cannot be read by other \s-1CGI\s0 scripts,
use suEXEC or a \s-1CGI\s0 wrapper program to run your script.  The temporary
file is created with mode 0600 (neither world nor group readable).
.Sp
The temporary directory is selected using the following algorithm:
.Sp
.Vb 1
\&    1. if $CGITempFile::TMPDIRECTORY is already set, use that
\&
\&    2. if the environment variable TMPDIR exists, use the location
\&    indicated.
\&
\&    3. Otherwise try the locations /usr/tmp, /var/tmp, C:\etemp,
\&    /tmp, /temp, ::Temporary Items, and \eWWW_ROOT.
.Ve
.Sp
Each of these locations is checked that it is a directory and is
writable.  If not, the algorithm tries the next choice.
.SS "\s-1SPECIAL FORMS FOR IMPORTING\s0 HTML-TAG \s-1FUNCTIONS\s0"
.IX Subsection "SPECIAL FORMS FOR IMPORTING HTML-TAG FUNCTIONS"
Many of the methods generate \s-1HTML\s0 tags.  As described below, tag
functions automatically generate both the opening and closing tags.
For example:
.PP
.Vb 1
\&  print h1(\*(AqLevel 1 Header\*(Aq);
.Ve
.PP
produces
.PP
.Vb 1
\&  <h1>Level 1 Header</h1>
.Ve
.PP
There will be some times when you want to produce the start and end
tags yourself.  In this case, you can use the form start_\fItag_name\fR
and end_\fItag_name\fR, as in:
.PP
.Vb 1
\&  print start_h1,\*(AqLevel 1 Header\*(Aq,end_h1;
.Ve
.PP
With a few exceptions (described below), start_\fItag_name\fR and
end_\fItag_name\fR functions are not generated automatically when you
\&\fIuse \s-1CGI\s0\fR.  However, you can specify the tags you want to generate
\&\fIstart/end\fR functions for by putting an asterisk in front of their
name, or, alternatively, requesting either "start_\fItag_name\fR\*(L" or
\&\*(R"end_\fItag_name\fR" in the import list.
.PP
Example:
.PP
.Vb 1
\&  use CGI qw/:standard *table start_ul/;
.Ve
.PP
In this example, the following functions are generated in addition to
the standard ones:
.IP "1. \fIstart_table()\fR (generates a <table> tag)" 4
.IX Item "1. start_table() (generates a <table> tag)"
.PD 0
.IP "2. \fIend_table()\fR (generates a </table> tag)" 4
.IX Item "2. end_table() (generates a </table> tag)"
.IP "3. \fIstart_ul()\fR (generates a <ul> tag)" 4
.IX Item "3. start_ul() (generates a <ul> tag)"
.IP "4. \fIend_ul()\fR (generates a </ul> tag)" 4
.IX Item "4. end_ul() (generates a </ul> tag)"
.PD
.SH "GENERATING DYNAMIC DOCUMENTS"
.IX Header "GENERATING DYNAMIC DOCUMENTS"
Most of \s-1CGI\s0.pm's functions deal with creating documents on the fly.
Generally you will produce the \s-1HTTP\s0 header first, followed by the
document itself.  \s-1CGI\s0.pm provides functions for generating \s-1HTTP\s0
headers of various types as well as for generating \s-1HTML. \s0 For creating
\&\s-1GIF\s0 images, see the \s-1GD\s0.pm module.
.PP
Each of these functions produces a fragment of \s-1HTML\s0 or \s-1HTTP\s0 which you
can print out directly so that it displays in the browser window,
append to a string, or save to a file for later use.
.SS "\s-1CREATING A STANDARD HTTP HEADER:\s0"
.IX Subsection "CREATING A STANDARD HTTP HEADER:"
Normally the first thing you will do in any \s-1CGI\s0 script is print out an
\&\s-1HTTP\s0 header.  This tells the browser what type of document to expect,
and gives other optional information, such as the language, expiration
date, and whether to cache the document.  The header can also be
manipulated for special purposes, such as server push and pay per view
pages.
.PP
.Vb 1
\&        print header;
\&
\&             \-or\-
\&
\&        print header(\*(Aqimage/gif\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\*(Aqtext/html\*(Aq,\*(Aq204 No response\*(Aq);
\&
\&             \-or\-
\&
\&        print header(\-type=>\*(Aqimage/gif\*(Aq,
\&                             \-nph=>1,
\&                             \-status=>\*(Aq402 Payment required\*(Aq,
\&                             \-expires=>\*(Aq+3d\*(Aq,
\&                             \-cookie=>$cookie,
\&                             \-charset=>\*(Aqutf\-7\*(Aq,
\&                             \-attachment=>\*(Aqfoo.gif\*(Aq,
\&                             \-Cost=>\*(Aq$2.00\*(Aq);
.Ve
.PP
\&\fIheader()\fR returns the Content-type: header.  You can provide your own
\&\s-1MIME\s0 type if you choose, otherwise it defaults to text/html.  An
optional second parameter specifies the status code and a human-readable
message.  For example, you can specify 204, \*(L"No response\*(R" to create a
script that tells the browser to do nothing at all. Note that \s-1RFC 2616\s0 expects
the human-readable phase to be there as well as the numeric status code.
.PP
The last example shows the named argument style for passing arguments
to the \s-1CGI\s0 methods using named parameters.  Recognized parameters are
\&\fB\-type\fR, \fB\-status\fR, \fB\-expires\fR, and \fB\-cookie\fR.  Any other named
parameters will be stripped of their initial hyphens and turned into
header fields, allowing you to specify any \s-1HTTP\s0 header you desire.
Internal underscores will be turned into hyphens:
.PP
.Vb 1
\&    print header(\-Content_length=>3002);
.Ve
.PP
Most browsers will not cache the output from \s-1CGI\s0 scripts.  Every time
the browser reloads the page, the script is invoked anew.  You can
change this behavior with the \fB\-expires\fR parameter.  When you specify
an absolute or relative expiration interval with this parameter, some
browsers and proxy servers will cache the script's output until the
indicated expiration date.  The following forms are all valid for the
\&\-expires field:
.PP
.Vb 8
\&        +30s                              30 seconds from now
\&        +10m                              ten minutes from now
\&        +1h                               one hour from now
\&        \-1d                               yesterday (i.e. "ASAP!")
\&        now                               immediately
\&        +3M                               in three months
\&        +10y                              in ten years time
\&        Thursday, 25\-Apr\-1999 00:40:33 GMT  at the indicated time & date
.Ve
.PP
The \fB\-cookie\fR parameter generates a header that tells the browser to provide
a \*(L"magic cookie\*(R" during all subsequent transactions with your script.
Some cookies have a special format that includes interesting attributes
such as expiration time.  Use the \fIcookie()\fR method to create and retrieve
session cookies.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH \s0(no-parse-header) script.  This is important
to use with certain servers that expect all their scripts to be \s-1NPH.\s0
.PP
The \fB\-charset\fR parameter can be used to control the character set
sent to the browser.  If not provided, defaults to \s-1ISO\-8859\-1. \s0 As a
side effect, this sets the \fIcharset()\fR method as well.
.PP
The \fB\-attachment\fR parameter can be used to turn the page into an
attachment.  Instead of displaying the page, some browsers will prompt
the user to save it to disk.  The value of the argument is the
suggested name for the saved file.  In order for this to work, you may
have to set the \fB\-type\fR to \*(L"application/octet\-stream\*(R".
.PP
The \fB\-p3p\fR parameter will add a P3P tag to the outgoing header.  The
parameter can be an arrayref or a space-delimited string of P3P tags.
For example:
.PP
.Vb 2
\&   print header(\-p3p=>[qw(CAO DSP LAW CURa)]);
\&   print header(\-p3p=>\*(AqCAO DSP LAW CURa\*(Aq);
.Ve
.PP
In either case, the outgoing header will be formatted as:
.PP
.Vb 1
\&  P3P: policyref="/w3c/p3p.xml" cp="CAO DSP LAW CURa"
.Ve
.PP
\&\s-1CGI\s0.pm will accept valid multi-line headers when each line is separated with a
\&\s-1CRLF\s0 value (\*(L"\er\en\*(R" on most platforms) followed by at least one space. For example:
.PP
.Vb 1
\&    print header( \-ingredients => "ham\er\en\eseggs\er\en\esbacon" );
.Ve
.PP
Invalid multi-line header input will trigger in an exception. When multi-line headers
are received, \s-1CGI\s0.pm will always output them back as a single line, according to the
folding rules of \s-1RFC 2616:\s0 the newlines will be removed, while the white space remains.
.SS "\s-1GENERATING A REDIRECTION HEADER\s0"
.IX Subsection "GENERATING A REDIRECTION HEADER"
.Vb 1
\&   print $q\->redirect(\*(Aqhttp://somewhere.else/in/movie/land\*(Aq);
.Ve
.PP
Sometimes you don't want to produce a document yourself, but simply
redirect the browser elsewhere, perhaps choosing a \s-1URL\s0 based on the
time of day or the identity of the user.
.PP
The \fIredirect()\fR method redirects the browser to a different \s-1URL. \s0 If
you use redirection like this, you should \fBnot\fR print out a header as
well.
.PP
You should always use full URLs (including the http: or ftp: part) in
redirection requests.  Relative URLs will not work correctly.
.PP
You can also use named arguments:
.PP
.Vb 4
\&    print $q\->redirect(
\&        \-uri=>\*(Aqhttp://somewhere.else/in/movie/land\*(Aq,
\&            \-nph=>1,
\&         \-status=>\*(Aq301 Moved Permanently\*(Aq);
.Ve
.PP
All names arguments recognized by \fIheader()\fR are also recognized by
\&\fIredirect()\fR. However, most \s-1HTTP\s0 headers, including those generated by
\&\-cookie and \-target, are ignored by the browser.
.PP
The \fB\-nph\fR parameter, if set to a true value, will issue the correct
headers to work with a \s-1NPH \s0(no-parse-header) script.  This is important
to use with certain servers, such as Microsoft \s-1IIS,\s0 which
expect all their scripts to be \s-1NPH.\s0
.PP
The \fB\-status\fR parameter will set the status of the redirect.  \s-1HTTP\s0
defines three different possible redirection status codes:
.PP
.Vb 3
\&     301 Moved Permanently
\&     302 Found
\&     303 See Other
.Ve
.PP
The default if not specified is 302, which means \*(L"moved temporarily.\*(R"
You may change the status to another status code if you wish.  Be
advised that changing the status to anything other than 301, 302 or
303 will probably break redirection.
.PP
Note that the human-readable phrase is also expected to be present to conform
with \s-1RFC 2616,\s0 section 6.1.
.SS "\s-1CREATING THE HTML DOCUMENT HEADER\s0"
.IX Subsection "CREATING THE HTML DOCUMENT HEADER"
.Vb 8
\&   print start_html(\-title=>\*(AqSecrets of the Pyramids\*(Aq,
\&                            \-author=>\*(Aqfred@capricorn.org\*(Aq,
\&                            \-base=>\*(Aqtrue\*(Aq,
\&                            \-target=>\*(Aq_blank\*(Aq,
\&                            \-meta=>{\*(Aqkeywords\*(Aq=>\*(Aqpharaoh secret mummy\*(Aq,
\&                                    \*(Aqcopyright\*(Aq=>\*(Aqcopyright 1996 King Tut\*(Aq},
\&                            \-style=>{\*(Aqsrc\*(Aq=>\*(Aq/styles/style1.css\*(Aq},
\&                            \-BGCOLOR=>\*(Aqblue\*(Aq);
.Ve
.PP
The \fIstart_html()\fR routine creates the top of the
page, along with a lot of optional information that controls the
page's appearance and behavior.
.PP
This method returns a canned \s-1HTML\s0 header and the opening <body> tag.
All parameters are optional.  In the named parameter form, recognized
parameters are \-title, \-author, \-base, \-xbase, \-dtd, \-lang and \-target
(see below for the explanation).  Any additional parameters you
provide, such as the unofficial \s-1BGCOLOR\s0 attribute, are added
to the <body> tag.  Additional parameters must be proceeded by a
hyphen.
.PP
The argument \fB\-xbase\fR allows you to provide an \s-1HREF\s0 for the <base> tag
different from the current location, as in
.PP
.Vb 1
\&    \-xbase=>"http://home.mcom.com/"
.Ve
.PP
All relative links will be interpreted relative to this tag.
.PP
The argument \fB\-target\fR allows you to provide a default target frame
for all the links and fill-out forms on the page.  \fBThis is a
non-standard \s-1HTTP\s0 feature which only works with some browsers!\fR
.PP
.Vb 1
\&    \-target=>"answer_window"
.Ve
.PP
All relative links will be interpreted relative to this tag.
You add arbitrary meta information to the header with the \fB\-meta\fR
argument.  This argument expects a reference to a hash
containing name/value pairs of meta information.  These will be turned
into a series of header <meta> tags that look something like this:
.PP
.Vb 2
\&    <meta name="keywords" content="pharaoh secret mummy">
\&    <meta name="description" content="copyright 1996 King Tut">
.Ve
.PP
To create an HTTP-EQUIV type of <meta> tag, use \fB\-head\fR, described
below.
.PP
The \fB\-style\fR argument is used to incorporate cascading stylesheets
into your code.  See the section on \s-1CASCADING STYLESHEETS\s0 for more
information.
.PP
The \fB\-lang\fR argument is used to incorporate a language attribute into
the <html> tag.  For example:
.PP
.Vb 1
\&    print $q\->start_html(\-lang=>\*(Aqfr\-CA\*(Aq);
.Ve
.PP
The default if not specified is \*(L"en-US\*(R" for \s-1US\s0 English, unless the 
\&\-dtd parameter specifies an \s-1HTML 2.0\s0 or 3.2 \s-1DTD,\s0 in which case the
lang attribute is left off.  You can force the lang attribute to left
off in other cases by passing an empty string (\-lang=>'').
.PP
The \fB\-encoding\fR argument can be used to specify the character set for
\&\s-1XHTML. \s0 It defaults to iso\-8859\-1 if not specified.
.PP
The \fB\-dtd\fR argument can be used to specify a public \s-1DTD\s0 identifier string. For example:
.PP
.Vb 1
\&    \-dtd => \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq)
.Ve
.PP
Alternatively, it can take public and system \s-1DTD\s0 identifiers as an array:
.PP
.Vb 1
\&    dtd => [ \*(Aq\-//W3C//DTD HTML 4.01 Transitional//EN\*(Aq, \*(Aqhttp://www.w3.org/TR/html4/loose.dtd\*(Aq ]
.Ve
.PP
For the public \s-1DTD\s0 identifier to be considered, it must be valid. Otherwise it
will be replaced by the default \s-1DTD.\s0 If the public \s-1DTD\s0 contains '\s-1XHTML\s0', \s-1CGI\s0.pm
will emit \s-1XML.\s0
.PP
The \fB\-declare_xml\fR argument, when used in conjunction with \s-1XHTML,\s0
will put a <?xml> declaration at the top of the \s-1HTML\s0 header. The sole
purpose of this declaration is to declare the character set
encoding. In the absence of \-declare_xml, the output \s-1HTML\s0 will contain
a <meta> tag that specifies the encoding, allowing the \s-1HTML\s0 to pass
most validators.  The default for \-declare_xml is false.
.PP
You can place other arbitrary \s-1HTML\s0 elements to the <head> section with the
\&\fB\-head\fR tag.  For example, to place a <link> element in the
head section, use this:
.PP
.Vb 2
\&    print start_html(\-head=>Link({\-rel=>\*(Aqshortcut icon\*(Aq,
\&                                  \-href=>\*(Aqfavicon.ico\*(Aq}));
.Ve
.PP
To incorporate multiple \s-1HTML\s0 elements into the <head> section, just pass an
array reference:
.PP
.Vb 7
\&    print start_html(\-head=>[ 
\&                             Link({\-rel=>\*(Aqnext\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s2.html\*(Aq}),
\&                             Link({\-rel=>\*(Aqprevious\*(Aq,
\&                                   \-href=>\*(Aqhttp://www.capricorn.com/s1.html\*(Aq})
\&                             ]
\&                     );
.Ve
.PP
And here's how to create an HTTP-EQUIV <meta> tag:
.PP
.Vb 2
\&      print start_html(\-head=>meta({\-http_equiv => \*(AqContent\-Type\*(Aq,
\&                                    \-content    => \*(Aqtext/html\*(Aq}))
.Ve
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-script\fR, \fB\-noScript\fR, \fB\-onLoad\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onUnload\fR parameters are used
to add JavaScript calls to your pages.  \fB\-script\fR should
point to a block of text containing JavaScript function definitions.
This block will be placed within a <script> block inside the \s-1HTML \s0(not
\&\s-1HTTP\s0) header.  The block is placed in the header in order to give your
page a fighting chance of having all its JavaScript functions in place
even if the user presses the stop button before the page has loaded
completely.  \s-1CGI\s0.pm attempts to format the script in such a way that
JavaScript-naive browsers will not choke on the code: unfortunately
there are some browsers, such as Chimera for Unix, that get confused
by it nevertheless.
.PP
The \fB\-onLoad\fR and \fB\-onUnload\fR parameters point to fragments of JavaScript
code to execute when the page is respectively opened and closed by the
browser.  Usually these parameters are calls to functions defined in the
\&\fB\-script\fR field:
.PP
.Vb 10
\&      $query = CGI\->new;
\&      print header;
\&      $JSCRIPT=<<END;
\&      // Ask a silly question
\&      function riddle_me_this() {
\&         var r = prompt("What walks on four legs in the morning, " +
\&                       "two legs in the afternoon, " +
\&                       "and three legs in the evening?");
\&         response(r);
\&      }
\&      // Get a silly answer
\&      function response(answer) {
\&         if (answer == "man")
\&            alert("Right you are!");
\&         else
\&            alert("Wrong!  Guess again.");
\&      }
\&      END
\&      print start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                               \-script=>$JSCRIPT);
.Ve
.PP
Use the \fB\-noScript\fR parameter to pass some \s-1HTML\s0 text that will be displayed on 
browsers that do not have JavaScript (or browsers where JavaScript is turned
off).
.PP
The <script> tag, has several attributes including \*(L"type\*(R", \*(L"charset\*(R" and \*(L"src\*(R".
\&\*(L"src\*(R" allows you to keep JavaScript code in an external file. To use these
attributes pass a \s-1HASH\s0 reference in the \fB\-script\fR parameter containing one or
more of \-type, \-src, or \-code:
.PP
.Vb 4
\&    print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                         \-script=>{\-type=>\*(AqJAVASCRIPT\*(Aq,
\&                                   \-src=>\*(Aq/javascript/sphinx.js\*(Aq}
\&                         );
\&
\&    print $q\->(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&               \-script=>{\-type=>\*(AqPERLSCRIPT\*(Aq,
\&                         \-code=>\*(Aqprint "hello world!\en;"\*(Aq}
\&               );
.Ve
.PP
A final feature allows you to incorporate multiple <script> sections into the
header.  Just pass the list of script sections as an array reference.
this allows you to specify different source files for different dialects
of JavaScript.  Example:
.PP
.Vb 10
\&     print $q\->start_html(\-title=>\*(AqThe Riddle of the Sphinx\*(Aq,
\&                          \-script=>[
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities10.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/javascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities11.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/jscript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities12.js\*(Aq
\&                                    },
\&                                    { \-type => \*(Aqtext/ecmascript\*(Aq,
\&                                      \-src      => \*(Aq/javascript/utilities219.js\*(Aq
\&                                    }
\&                                 ]
\&                             );
.Ve
.PP
The option \*(L"\-language\*(R" is a synonym for \-type, and is supported for
backwards compatibility.
.PP
The old-style positional parameters are as follows:
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The title
.IP "2." 4
.IX Item "2."
The author's e\-mail address (will create a <link rev=\*(L"\s-1MADE\*(R"\s0> tag if present
.IP "3." 4
.IX Item "3."
A 'true' flag if you want to include a <base> tag in the header.  This
helps resolve relative addresses to absolute ones when the document is moved, 
but makes the document hierarchy non-portable.  Use with care!
.IP "4, 5, 6..." 4
.IX Item "4, 5, 6..."
Any other parameters you want to include in the <body> tag.  This is a good
place to put \s-1HTML\s0 extensions, such as colors and wallpaper patterns.
.SS "\s-1ENDING THE HTML DOCUMENT:\s0"
.IX Subsection "ENDING THE HTML DOCUMENT:"
.Vb 1
\&        print $q\->end_html;
.Ve
.PP
This ends an \s-1HTML\s0 document by printing the </body></html> tags.
.SS "\s-1CREATING A\s0 SELF-REFERENCING \s-1URL THAT PRESERVES STATE INFORMATION:\s0"
.IX Subsection "CREATING A SELF-REFERENCING URL THAT PRESERVES STATE INFORMATION:"
.Vb 2
\&    $myself = $q\->self_url;
\&    print q(<a href="$myself">I\*(Aqm talking to myself.</a>);
.Ve
.PP
\&\fIself_url()\fR will return a \s-1URL,\s0 that, when selected, will reinvoke
this script with all its state information intact.  This is most
useful when you want to jump around within the document using
internal anchors but you don't want to disrupt the current contents
of the form(s).  Something like this will do the trick.
.PP
.Vb 4
\&     $myself = $q\->self_url;
\&     print "<a href=\e"$myself#table1\e">See table 1</a>";
\&     print "<a href=\e"$myself#table2\e">See table 2</a>";
\&     print "<a href=\e"$myself#yourself\e">See for yourself</a>";
.Ve
.PP
If you want more control over what's returned, using the \fB\f(BIurl()\fB\fR
method instead.
.PP
You can also retrieve the unprocessed query string with \fIquery_string()\fR:
.PP
.Vb 1
\&    $the_string = $q\->query_string();
.Ve
.PP
The behavior of calling query_string is currently undefined when the \s-1HTTP\s0 method is
something other than \s-1GET.\s0
.SS "\s-1OBTAINING THE SCRIPT\s0'S \s-1URL\s0"
.IX Subsection "OBTAINING THE SCRIPT'S URL"
.Vb 7
\&    $full_url      = url();
\&    $full_url      = url(\-full=>1);  #alternative syntax
\&    $relative_url  = url(\-relative=>1);
\&    $absolute_url  = url(\-absolute=>1);
\&    $url_with_path = url(\-path_info=>1);
\&    $url_with_path_and_query = url(\-path_info=>1,\-query=>1);
\&    $netloc        = url(\-base => 1);
.Ve
.PP
\&\fB\f(BIurl()\fB\fR returns the script's \s-1URL\s0 in a variety of formats.  Called
without any arguments, it returns the full form of the \s-1URL,\s0 including
host name and port number
.PP
.Vb 1
\&    http://your.host.com/path/to/script.cgi
.Ve
.PP
You can modify this format with the following named arguments:
.IP "\fB\-absolute\fR" 4
.IX Item "-absolute"
If true, produce an absolute \s-1URL,\s0 e.g.
.Sp
.Vb 1
\&    /path/to/script.cgi
.Ve
.IP "\fB\-relative\fR" 4
.IX Item "-relative"
Produce a relative \s-1URL. \s0 This is useful if you want to reinvoke your
script with different parameters. For example:
.Sp
.Vb 1
\&    script.cgi
.Ve
.IP "\fB\-full\fR" 4
.IX Item "-full"
Produce the full \s-1URL,\s0 exactly as if called without any arguments.
This overrides the \-relative and \-absolute arguments.
.IP "\fB\-path\fR (\fB\-path_info\fR)" 4
.IX Item "-path (-path_info)"
Append the additional path information to the \s-1URL. \s0 This can be
combined with \fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-path_info\fR
is provided as a synonym.
.IP "\fB\-query\fR (\fB\-query_string\fR)" 4
.IX Item "-query (-query_string)"
Append the query string to the \s-1URL. \s0 This can be combined with
\&\fB\-full\fR, \fB\-absolute\fR or \fB\-relative\fR.  \fB\-query_string\fR is provided
as a synonym.
.IP "\fB\-base\fR" 4
.IX Item "-base"
Generate just the protocol and net location, as in http://www.foo.com:8000
.IP "\fB\-rewrite\fR" 4
.IX Item "-rewrite"
If Apache's mod_rewrite is turned on, then the script name and path
info probably won't match the request that the user sent. Set
\&\-rewrite=>1 (default) to return URLs that match what the user sent
(the original request \s-1URI\s0). Set \-rewrite=>0 to return URLs that match
the \s-1URL\s0 after mod_rewrite's rules have run.
.SS "\s-1MIXING POST AND URL PARAMETERS\s0"
.IX Subsection "MIXING POST AND URL PARAMETERS"
.Vb 1
\&   $color = url_param(\*(Aqcolor\*(Aq);
.Ve
.PP
It is possible for a script to receive \s-1CGI\s0 parameters in the \s-1URL\s0 as
well as in the fill-out form by creating a form that POSTs to a \s-1URL\s0
containing a query string (a \*(L"?\*(R" mark followed by arguments).  The
\&\fB\f(BIparam()\fB\fR method will always return the contents of the POSTed
fill-out form, ignoring the \s-1URL\s0's query string.  To retrieve \s-1URL\s0
parameters, call the \fB\f(BIurl_param()\fB\fR method.  Use it in the same way as
\&\fB\f(BIparam()\fB\fR.  The main difference is that it allows you to read the
parameters, but not set them.
.PP
Under no circumstances will the contents of the \s-1URL\s0 query string
interfere with similarly-named \s-1CGI\s0 parameters in POSTed forms.  If you
try to mix a \s-1URL\s0 query string with a form submitted with the \s-1GET\s0
method, the results will not be what you expect.
.SH "CREATING STANDARD HTML ELEMENTS:"
.IX Header "CREATING STANDARD HTML ELEMENTS:"
\&\s-1CGI\s0.pm defines general \s-1HTML\s0 shortcut methods for many \s-1HTML\s0 tags.  \s-1HTML\s0 shortcuts are named after a single
\&\s-1HTML\s0 element and return a fragment of \s-1HTML\s0 text. Example:
.PP
.Vb 7
\&   print $q\->blockquote(
\&                     "Many years ago on the island of",
\&                     $q\->a({href=>"http://crete.org/"},"Crete"),
\&                     "there lived a Minotaur named",
\&                     $q\->strong("Fred."),
\&                    ),
\&       $q\->hr;
.Ve
.PP
This results in the following \s-1HTML\s0 code (extra newlines have been
added for readability):
.PP
.Vb 6
\&   <blockquote>
\&   Many years ago on the island of
\&   <a href="http://crete.org/">Crete</a> there lived
\&   a minotaur named <strong>Fred.</strong> 
\&   </blockquote>
\&   <hr>
.Ve
.PP
If you find the syntax for calling the \s-1HTML\s0 shortcuts awkward, you can
import them into your namespace and dispense with the object syntax
completely (see the next section for more details):
.PP
.Vb 8
\&   use CGI \*(Aq:standard\*(Aq;
\&   print blockquote(
\&      "Many years ago on the island of",
\&      a({href=>"http://crete.org/"},"Crete"),
\&      "there lived a minotaur named",
\&      strong("Fred."),
\&      ),
\&      hr;
.Ve
.SS "\s-1PROVIDING ARGUMENTS TO HTML SHORTCUTS\s0"
.IX Subsection "PROVIDING ARGUMENTS TO HTML SHORTCUTS"
The \s-1HTML\s0 methods will accept zero, one or multiple arguments.  If you
provide no arguments, you get a single tag:
.PP
.Vb 1
\&   print hr;    #  <hr>
.Ve
.PP
If you provide one or more string arguments, they are concatenated
together with spaces and placed between opening and closing tags:
.PP
.Vb 1
\&   print h1("Chapter","1"); # <h1>Chapter 1</h1>"
.Ve
.PP
If the first argument is a hash reference, then the keys
and values of the hash become the \s-1HTML\s0 tag's attributes:
.PP
.Vb 2
\&   print a({\-href=>\*(Aqfred.html\*(Aq,\-target=>\*(Aq_new\*(Aq},
\&      "Open a new frame");
\&
\&            <a href="fred.html",target="_new">Open a new frame</a>
.Ve
.PP
You may dispense with the dashes in front of the attribute names if
you prefer:
.PP
.Vb 1
\&   print img {src=>\*(Aqfred.gif\*(Aq,align=>\*(AqLEFT\*(Aq};
\&
\&           <img align="LEFT" src="fred.gif">
.Ve
.PP
Sometimes an \s-1HTML\s0 tag attribute has no argument.  For example, ordered
lists can be marked as \s-1COMPACT. \s0 The syntax for this is an argument that
that points to an undef string:
.PP
.Vb 1
\&   print ol({compact=>undef},li(\*(Aqone\*(Aq),li(\*(Aqtwo\*(Aq),li(\*(Aqthree\*(Aq));
.Ve
.PP
Prior to \s-1CGI\s0.pm version 2.41, providing an empty ('') string as an
attribute argument was the same as providing undef.  However, this has
changed in order to accommodate those who want to create tags of the form 
<img alt="">.  The difference is shown in these two pieces of code:
.PP
.Vb 3
\&   CODE                   RESULT
\&   img({alt=>undef})      <img alt>
\&   img({alt=>\*(Aq\*(Aq})         <img alt="">
.Ve
.SS "\s-1THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS\s0"
.IX Subsection "THE DISTRIBUTIVE PROPERTY OF HTML SHORTCUTS"
One of the cool features of the \s-1HTML\s0 shortcuts is that they are
distributive.  If you give them an argument consisting of a
\&\fBreference\fR to a list, the tag will be distributed across each
element of the list.  For example, here's one way to make an ordered
list:
.PP
.Vb 3
\&   print ul(
\&             li({\-type=>\*(Aqdisc\*(Aq},[\*(AqSneezy\*(Aq,\*(AqDoc\*(Aq,\*(AqSleepy\*(Aq,\*(AqHappy\*(Aq])
\&           );
.Ve
.PP
This example will result in \s-1HTML\s0 output that looks like this:
.PP
.Vb 6
\&   <ul>
\&     <li type="disc">Sneezy</li>
\&     <li type="disc">Doc</li>
\&     <li type="disc">Sleepy</li>
\&     <li type="disc">Happy</li>
\&   </ul>
.Ve
.PP
This is extremely useful for creating tables.  For example:
.PP
.Vb 11
\&   print table({\-border=>undef},
\&           caption(\*(AqWhen Should You Eat Your Vegetables?\*(Aq),
\&           Tr({\-align=>\*(AqCENTER\*(Aq,\-valign=>\*(AqTOP\*(Aq},
\&           [
\&              th([\*(AqVegetable\*(Aq, \*(AqBreakfast\*(Aq,\*(AqLunch\*(Aq,\*(AqDinner\*(Aq]),
\&              td([\*(AqTomatoes\*(Aq , \*(Aqno\*(Aq, \*(Aqyes\*(Aq, \*(Aqyes\*(Aq]),
\&              td([\*(AqBroccoli\*(Aq , \*(Aqno\*(Aq, \*(Aqno\*(Aq,  \*(Aqyes\*(Aq]),
\&              td([\*(AqOnions\*(Aq   , \*(Aqyes\*(Aq,\*(Aqyes\*(Aq, \*(Aqyes\*(Aq])
\&           ]
\&           )
\&        );
.Ve
.SS "\s-1HTML SHORTCUTS AND LIST INTERPOLATION\s0"
.IX Subsection "HTML SHORTCUTS AND LIST INTERPOLATION"
Consider this bit of code:
.PP
.Vb 1
\&   print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
.Ve
.PP
It will ordinarily return the string that you probably expect, namely:
.PP
.Vb 1
\&   <blockquote><em>Hi</em> mom!</blockquote>
.Ve
.PP
Note the space between the element \*(L"Hi\*(R" and the element \*(L"mom!\*(R".
\&\s-1CGI\s0.pm puts the extra space there using array interpolation, which is
controlled by the magic $\*(L" variable.  Sometimes this extra space is
not what you want, for example, when you are trying to align a series
of images.  In this case, you can simply change the value of $\*(R" to an
empty string.
.PP
.Vb 4
\&   {
\&      local($") = \*(Aq\*(Aq;
\&      print blockquote(em(\*(AqHi\*(Aq),\*(Aqmom!\*(Aq));
\&    }
.Ve
.PP
I suggest you put the code in a block as shown here.  Otherwise the
change to $" will affect all subsequent code until you explicitly
reset it.
.SS "NON-STANDARD \s-1HTML SHORTCUTS\s0"
.IX Subsection "NON-STANDARD HTML SHORTCUTS"
A few \s-1HTML\s0 tags don't follow the standard pattern for various
reasons.
.PP
\&\fB\f(BIcomment()\fB\fR generates an \s-1HTML\s0 comment (<!\-\- comment \-\->).  Call it
like
.PP
.Vb 1
\&    print comment(\*(Aqhere is my comment\*(Aq);
.Ve
.PP
Because of conflicts with built-in Perl functions, the following functions
begin with initial caps:
.PP
.Vb 6
\&    Select
\&    Tr
\&    Link
\&    Delete
\&    Accept
\&    Sub
.Ve
.PP
In addition, \fIstart_html()\fR, \fIend_html()\fR, \fIstart_form()\fR, \fIend_form()\fR,
\&\fIstart_multipart_form()\fR and all the fill-out form tags are special.
See their respective sections.
.SS "\s-1AUTOESCAPING HTML\s0"
.IX Subsection "AUTOESCAPING HTML"
By default, all \s-1HTML\s0 that is emitted by the form-generating functions
is passed through a function called \fIescapeHTML()\fR:
.ie n .IP "$escaped_string = escapeHTML(""unescaped string"");" 4
.el .IP "\f(CW$escaped_string\fR = escapeHTML(``unescaped string'');" 4
.IX Item "$escaped_string = escapeHTML(unescaped string);"
Escape \s-1HTML\s0 formatting characters in a string.
.PP
Provided that you have specified a character set of \s-1ISO\-8859\-1 \s0(the
default), the standard \s-1HTML\s0 escaping rules will be used.  The \*(L"<\*(R"
character becomes \*(L"&lt;\*(R", \*(L">\*(R" becomes \*(L"&gt;\*(R", \*(L"&\*(R" becomes \*(L"&amp;\*(R", and
the quote character becomes \*(L"&quot;\*(R".  In addition, the hexadecimal
0x8b and 0x9b characters, which some browsers incorrectly interpret
as the left and right angle-bracket characters, are replaced by their
numeric character entities (\*(L"&#8249\*(R" and \*(L"&#8250;\*(R").  If you manually change
the charset, either by calling the \fIcharset()\fR method explicitly or by
passing a \-charset argument to \fIheader()\fR, then \fBall\fR characters will
be replaced by their numeric entities, since \s-1CGI\s0.pm has no lookup
table for all the possible encodings.
.PP
\&\f(CW\*(C`escapeHTML()\*(C'\fR expects the supplied string to be a character string. This means you
should Encode::decode data received from \*(L"outside\*(R" and Encode::encode your
strings before sending them back outside. If your source code \s-1UTF\-8\s0 encoded and
you want to upgrade string literals in your source to character strings, you
can use \*(L"use utf8\*(R". See perlunitut, perlunifaq and perlunicode for more
information on how Perl handles the difference between bytes and characters.
.PP
The automatic escaping does not apply to other shortcuts, such as
\&\fIh1()\fR.  You should call \fIescapeHTML()\fR yourself on untrusted data in
order to protect your pages against nasty tricks that people may enter
into guestbooks, etc..  To change the character set, use \fIcharset()\fR.
To turn autoescaping off completely, use \fIautoEscape\fR\|(0):
.ie n .IP "$charset = charset([$charset]);" 4
.el .IP "\f(CW$charset\fR = charset([$charset]);" 4
.IX Item "$charset = charset([$charset]);"
Get or set the current character set.
.ie n .IP "$flag = autoEscape([$flag]);" 4
.el .IP "\f(CW$flag\fR = autoEscape([$flag]);" 4
.IX Item "$flag = autoEscape([$flag]);"
Get or set the value of the autoescape flag.
.SS "PRETTY-PRINTING \s-1HTML\s0"
.IX Subsection "PRETTY-PRINTING HTML"
By default, all the \s-1HTML\s0 produced by these functions comes out as one
long line without carriage returns or indentation. This is yuck, but
it does reduce the size of the documents by 10\-20%.  To get
pretty-printed output, please use CGI::Pretty, a subclass
contributed by Brian Paulsen.
.SH "CREATING FILL-OUT FORMS:"
.IX Header "CREATING FILL-OUT FORMS:"
\&\fIGeneral note\fR  The various form-creating methods all return strings
to the caller, containing the tag or tags that will create the requested
form element.  You are responsible for actually printing out these strings.
It's set up this way so that you can place formatting tags
around the form elements.
.PP
\&\fIAnother note\fR The default values that you specify for the forms are only
used the \fBfirst\fR time the script is invoked (when there is no query
string).  On subsequent invocations of the script (when there is a query
string), the former values are used even if they are blank.
.PP
If you want to change the value of a field from its previous value, you have two
choices:
.PP
(1) call the \fIparam()\fR method to set it.
.PP
(2) use the \-override (alias \-force) parameter (a new feature in version 2.15).
This forces the default value to be used, regardless of the previous value:
.PP
.Vb 5
\&   print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                           \-default=>\*(Aqstarting value\*(Aq,
\&                           \-override=>1,
\&                           \-size=>50,
\&                           \-maxlength=>80);
.Ve
.PP
\&\fIYet another note\fR By default, the text and labels of form elements are
escaped according to \s-1HTML\s0 rules.  This means that you can safely use
\&\*(L"<\s-1CLICK ME\s0>\*(R" as the label for a button.  However, it also interferes with
your ability to incorporate special \s-1HTML\s0 character sequences, such as &Aacute;,
into your fields.  If you wish to turn off automatic escaping, call the
\&\fIautoEscape()\fR method with a false value immediately after creating the \s-1CGI\s0 object:
.PP
.Vb 2
\&   $query = CGI\->new;
\&   $query\->autoEscape(0);
.Ve
.PP
Note that \fIautoEscape()\fR is exclusively used to effect the behavior of how some
\&\s-1CGI\s0.pm \s-1HTML\s0 generation functions handle escaping. Calling \fIescapeHTML()\fR
explicitly will always escape the \s-1HTML.\s0
.PP
\&\fIA Lurking Trap!\fR Some of the form-element generating methods return
multiple tags.  In a scalar context, the tags will be concatenated
together with spaces, or whatever is the current value of the $"
global.  In a list context, the methods will return a list of
elements, allowing you to modify them if you wish.  Usually you will
not notice this behavior, but beware of this:
.PP
.Vb 1
\&    printf("%s\en",end_form())
.Ve
.PP
\&\fIend_form()\fR produces several tags, and only the first of them will be
printed because the format only expects one value.
.PP
<p>
.SS "\s-1CREATING AN ISINDEX TAG\s0"
.IX Subsection "CREATING AN ISINDEX TAG"
.Vb 1
\&   print isindex(\-action=>$action);
\&
\&         \-or\-
\&
\&   print isindex($action);
.Ve
.PP
Prints out an <isindex> tag.  Not very exciting.  The parameter
\&\-action specifies the \s-1URL\s0 of the script to process the query.  The
default is to process the query with the current script.
.SS "\s-1STARTING AND ENDING A FORM\s0"
.IX Subsection "STARTING AND ENDING A FORM"
.Vb 5
\&    print start_form(\-method=>$method,
\&                    \-action=>$action,
\&                    \-enctype=>$encoding);
\&      <... various form stuff ...>
\&    print end_form;
\&
\&        \-or\-
\&
\&    print start_form($method,$action,$encoding);
\&      <... various form stuff ...>
\&    print end_form;
.Ve
.PP
\&\fIstart_form()\fR will return a <form> tag with the optional method,
action and form encoding that you specify.  The defaults are:
.PP
.Vb 4
\&    method: POST
\&    action: this script
\&    enctype: application/x\-www\-form\-urlencoded for non\-XHTML
\&             multipart/form\-data for XHTML, see multipart/form\-data below.
.Ve
.PP
\&\fIend_form()\fR returns the closing </form> tag.
.PP
\&\fIStart_form()\fR's enctype argument tells the browser how to package the various
fields of the form before sending the form to the server.  Two
values are possible:
.PP
\&\fBNote:\fR These methods were previously named \fIstartform()\fR and \fIendform()\fR.
These methods are now \s-1DEPRECATED.\s0
Please use \fIstart_form()\fR and \fIend_form()\fR instead.
.IP "\fBapplication/x\-www\-form\-urlencoded\fR" 4
.IX Item "application/x-www-form-urlencoded"
This is the older type of encoding.  It is compatible with many \s-1CGI\s0 scripts and is
suitable for short fields containing text data.  For your
convenience, \s-1CGI\s0.pm stores the name of this encoding
type in \fB&CGI::URL_ENCODED\fR.
.IP "\fBmultipart/form\-data\fR" 4
.IX Item "multipart/form-data"
This is the newer type of encoding.
It is suitable for forms that contain very large fields or that
are intended for transferring binary data.  Most importantly,
it enables the \*(L"file upload\*(R" feature.  For
your convenience, \s-1CGI\s0.pm stores the name of this encoding type
in \fB&CGI::MULTIPART\fR
.Sp
Forms that use this type of encoding are not easily interpreted
by \s-1CGI\s0 scripts unless they use \s-1CGI\s0.pm or another library designed
to handle them.
.Sp
If \s-1XHTML\s0 is activated (the default), then forms will be automatically
created using this type of encoding.
.PP
The \fIstart_form()\fR method uses the older form of encoding by
default unless \s-1XHTML\s0 is requested.  If you want to use the
newer form of encoding by default, you can call
\&\fB\f(BIstart_multipart_form()\fB\fR instead of \fB\f(BIstart_form()\fB\fR.  The
method \fB\f(BIend_multipart_form()\fB\fR is an alias to \fB\f(BIend_form()\fB\fR.
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-name\fR and \fB\-onSubmit\fR parameters are provided
for use with JavaScript.  The \-name parameter gives the
form a name so that it can be identified and manipulated by
JavaScript functions.  \-onSubmit should point to a JavaScript
function that will be executed just before the form is submitted to your
server.  You can use this opportunity to check the contents of the form 
for consistency and completeness.  If you find something wrong, you
can put up an alert box or maybe fix things up yourself.  You can 
abort the submission by returning false from this function.
.PP
Usually the bulk of JavaScript functions are defined in a <script>
block in the \s-1HTML\s0 header and \-onSubmit points to one of these function
call.  See \fIstart_html()\fR for details.
.SS "\s-1FORM ELEMENTS\s0"
.IX Subsection "FORM ELEMENTS"
After starting a form, you will typically create one or more
textfields, popup menus, radio groups and other form elements.  Each
of these elements takes a standard set of named arguments.  Some
elements also have optional arguments.  The standard arguments are as
follows:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the field. After submission this name can be used to
retrieve the field's value using the \fIparam()\fR method.
.IP "\fB\-value\fR, \fB\-values\fR" 4
.IX Item "-value, -values"
The initial value of the field which will be returned to the script
after form submission.  Some form elements, such as text fields, take
a single scalar \-value argument. Others, such as popup menus, take a
reference to an array of values. The two arguments are synonyms.
.IP "\fB\-tabindex\fR" 4
.IX Item "-tabindex"
A numeric value that sets the order in which the form element receives
focus when the user presses the tab key. Elements with lower values
receive focus first.
.IP "\fB\-id\fR" 4
.IX Item "-id"
A string identifier that can be used to identify this element to
JavaScript and \s-1DHTML.\s0
.IP "\fB\-override\fR" 4
.IX Item "-override"
A boolean, which, if true, forces the element to take on the value
specified by \fB\-value\fR, overriding the sticky behavior described
earlier for the \fB\-nosticky\fR pragma.
.IP "\fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR, \fB\-onMouseOver\fR, \fB\-onMouseOut\fR, \fB\-onSelect\fR" 4
.IX Item "-onChange, -onFocus, -onBlur, -onMouseOver, -onMouseOut, -onSelect"
These are used to assign JavaScript event handlers. See the
JavaScripting section for more details.
.PP
Other common arguments are described in the next section. In addition
to these, all attributes described in the \s-1HTML\s0 specifications are
supported.
.SS "\s-1CREATING A TEXT FIELD\s0"
.IX Subsection "CREATING A TEXT FIELD"
.Vb 5
\&    print textfield(\-name=>\*(Aqfield_name\*(Aq,
\&                    \-value=>\*(Aqstarting value\*(Aq,
\&                    \-size=>50,
\&                    \-maxlength=>80);
\&        \-or\-
\&
\&    print textfield(\*(Aqfield_name\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fItextfield()\fR will return a text input field.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the default starting value for the field
contents (\-value, formerly known as \-default).
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
      characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
      field will accept (\-maxlength).
.PP
As with all these methods, the field will be initialized with its 
previous contents from earlier invocations of the script.
When the form is processed, the value of the text field can be
retrieved with:
.PP
.Vb 1
\&       $value = param(\*(Aqfoo\*(Aq);
.Ve
.PP
If you want to reset it from its initial value after the script has been
called once, you can do so like this:
.PP
.Vb 1
\&       param(\*(Aqfoo\*(Aq,"I\*(Aqm taking over this value!");
.Ve
.SS "\s-1CREATING A BIG TEXT FIELD\s0"
.IX Subsection "CREATING A BIG TEXT FIELD"
.Vb 4
\&   print textarea(\-name=>\*(Aqfoo\*(Aq,
\&                          \-default=>\*(Aqstarting value\*(Aq,
\&                          \-rows=>10,
\&                          \-columns=>50);
\&
\&        \-or
\&
\&   print textarea(\*(Aqfoo\*(Aq,\*(Aqstarting value\*(Aq,10,50);
.Ve
.PP
\&\fItextarea()\fR is just like textfield, but it allows you to specify
rows and columns for a multiline text entry box.  You can provide
a starting value for the field, which can be long and contain
multiple lines.
.SS "\s-1CREATING A PASSWORD FIELD\s0"
.IX Subsection "CREATING A PASSWORD FIELD"
.Vb 5
\&   print password_field(\-name=>\*(Aqsecret\*(Aq,
\&                                \-value=>\*(Aqstarting value\*(Aq,
\&                                \-size=>50,
\&                                \-maxlength=>80);
\&        \-or\-
\&
\&   print password_field(\*(Aqsecret\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIpassword_field()\fR is identical to \fItextfield()\fR, except that its contents 
will be starred out on the web page.
.SS "\s-1CREATING A FILE UPLOAD FIELD\s0"
.IX Subsection "CREATING A FILE UPLOAD FIELD"
.Vb 5
\&    print filefield(\-name=>\*(Aquploaded_file\*(Aq,
\&                            \-default=>\*(Aqstarting value\*(Aq,
\&                            \-size=>50,
\&                            \-maxlength=>80);
\&        \-or\-
\&
\&    print filefield(\*(Aquploaded_file\*(Aq,\*(Aqstarting value\*(Aq,50,80);
.Ve
.PP
\&\fIfilefield()\fR will return a file upload field.
In order to take full advantage of this \fIyou must use the new 
multipart encoding scheme\fR for the form.  You can do this either
by calling \fB\f(BIstart_form()\fB\fR with an encoding type of \fB&CGI::MULTIPART\fR,
or by calling the new method \fB\f(BIstart_multipart_form()\fB\fR instead of
vanilla \fB\f(BIstart_form()\fB\fR.
.IP "\fBParameters\fR" 4
.IX Item "Parameters"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the field (\-name).
.IP "2." 4
.IX Item "2."
The optional second parameter is the starting value for the field contents
to be used as the default file name (\-default).
.Sp
For security reasons, browsers don't pay any attention to this field,
and so the starting value will always be blank.  Worse, the field
loses its \*(L"sticky\*(R" behavior and forgets its previous contents.  The
starting value field is called for in the \s-1HTML\s0 specification, however,
and possibly some browser will eventually provide support for it.
.IP "3." 4
.IX Item "3."
The optional third parameter is the size of the field in
characters (\-size).
.IP "4." 4
.IX Item "4."
The optional fourth parameter is the maximum number of characters the
field will accept (\-maxlength).
.PP
\&\s-1JAVASCRIPTING:\s0 The \fB\-onChange\fR, \fB\-onFocus\fR, \fB\-onBlur\fR,
\&\fB\-onMouseOver\fR, \fB\-onMouseOut\fR and \fB\-onSelect\fR parameters are
recognized.  See \fItextfield()\fR for details.
.SS "\s-1PROCESSING A FILE UPLOAD FIELD\s0"
.IX Subsection "PROCESSING A FILE UPLOAD FIELD"
\fIBasics\fR
.IX Subsection "Basics"
.PP
When the form is processed, you can retrieve an IO::Handle compatible
handle for a file upload field like this:
.PP
.Vb 1
\&  $lightweight_fh  = $q\->upload(\*(Aqfield_name\*(Aq);
\&
\&  # undef may be returned if it\*(Aqs not a valid file handle
\&  if (defined $lightweight_fh) {
\&    # Upgrade the handle to one compatible with IO::Handle:
\&    my $io_handle = $lightweight_fh\->handle;
\&
\&    open (OUTFILE,\*(Aq>>\*(Aq,\*(Aq/usr/local/web/users/feedback\*(Aq);
\&    while ($bytesread = $io_handle\->read($buffer,1024)) {
\&      print OUTFILE $buffer;
\&    }
\&  }
.Ve
.PP
In a list context, \fIupload()\fR will return an array of filehandles.
This makes it possible to process forms that use the same name for
multiple upload fields.
.PP
If you want the entered file name for the file, you can just call \fIparam()\fR:
.PP
.Vb 1
\&  $filename = $q\->param(\*(Aqfield_name\*(Aq);
.Ve
.PP
Different browsers will return slightly different things for the
name.  Some browsers return the filename only.  Others return the full
path to the file, using the path conventions of the user's machine.
Regardless, the name returned is always the name of the file on the
\&\fIuser's\fR machine, and is unrelated to the name of the temporary file
that \s-1CGI\s0.pm creates during upload spooling (see below).
.PP
When a file is uploaded the browser usually sends along some
information along with it in the format of headers.  The information
usually includes the \s-1MIME\s0 content type. To
retrieve this information, call \fIuploadInfo()\fR.  It returns a reference to
a hash containing all the document headers.
.PP
.Vb 5
\&       $filename = $q\->param(\*(Aquploaded_file\*(Aq);
\&       $type = $q\->uploadInfo($filename)\->{\*(AqContent\-Type\*(Aq};
\&       unless ($type eq \*(Aqtext/html\*(Aq) {
\&        die "HTML FILES ONLY!";
\&       }
.Ve
.PP
If you are using a machine that recognizes \*(L"text\*(R" and \*(L"binary\*(R" data
modes, be sure to understand when and how to use them (see the Camel book).  
Otherwise you may find that binary files are corrupted during file
uploads.
.PP
\fIAccessing the temp files directly\fR
.IX Subsection "Accessing the temp files directly"
.PP
When processing an uploaded file, \s-1CGI\s0.pm creates a temporary file on your hard
disk and passes you a file handle to that file. After you are finished with the
file handle, \s-1CGI\s0.pm unlinks (deletes) the temporary file. If you need to you
can access the temporary file directly. You can access the temp file for a file
upload by passing the file name to the \fItmpFileName()\fR method:
.PP
.Vb 2
\&       $filename = $query\->param(\*(Aquploaded_file\*(Aq);
\&       $tmpfilename = $query\->tmpFileName($filename);
.Ve
.PP
The temporary file will be deleted automatically when your program exits unless
you manually rename it. On some operating systems (such as Windows \s-1NT\s0), you
will need to close the temporary file's filehandle before your program exits.
Otherwise the attempt to delete the temporary file will fail.
.PP
\fIHandling interrupted file uploads\fR
.IX Subsection "Handling interrupted file uploads"
.PP
There are occasionally problems involving parsing the uploaded file.
This usually happens when the user presses \*(L"Stop\*(R" before the upload is
finished.  In this case, \s-1CGI\s0.pm will return undef for the name of the
uploaded file and set \fI\fIcgi_error()\fI\fR to the string \*(L"400 Bad request
(malformed multipart \s-1POST\s0)\*(R".  This error message is designed so that
you can incorporate it into a status code to be sent to the browser.
Example:
.PP
.Vb 5
\&   $file = $q\->upload(\*(Aquploaded_file\*(Aq);
\&   if (!$file && $q\->cgi_error) {
\&      print $q\->header(\-status=>$q\->cgi_error);
\&      exit 0;
\&   }
.Ve
.PP
You are free to create a custom \s-1HTML\s0 page to complain about the error,
if you wish.
.PP
\fIProgress bars for file uploads and avoiding temp files\fR
.IX Subsection "Progress bars for file uploads and avoiding temp files"
.PP
\&\s-1CGI\s0.pm gives you low-level access to file upload management through
a file upload hook. You can use this feature to completely turn off
the temp file storage of file uploads, or potentially write your own
file upload progress meter.
.PP
This is much like the \s-1UPLOAD_HOOK\s0 facility available in Apache::Request, with
the exception that the first argument to the callback is an Apache::Upload
object, here it's the remote filename.
.PP
.Vb 1
\& $q = CGI\->new(\e&hook [,$data [,$use_tempfile]]);
\&
\& sub hook {
\&        my ($filename, $buffer, $bytes_read, $data) = @_;
\&        print  "Read $bytes_read bytes of $filename\en";
\& }
.Ve
.PP
The \f(CW$data\fR field is optional; it lets you pass configuration
information (e.g. a database handle) to your hook callback.
.PP
The \f(CW$use_tempfile\fR field is a flag that lets you turn on and off
\&\s-1CGI\s0.pm's use of a temporary disk-based file during file upload. If you
set this to a \s-1FALSE\s0 value (default true) then \f(CW$q\fR\->param('uploaded_file')
will no longer work, and the only way to get at the uploaded data is
via the hook you provide.
.PP
If using the function-oriented interface, call the \fICGI::upload_hook()\fR
method before calling \fIparam()\fR or any other \s-1CGI\s0 functions:
.PP
.Vb 1
\&  CGI::upload_hook(\e&hook [,$data [,$use_tempfile]]);
.Ve
.PP
This method is not exported by default.  You will have to import it
explicitly if you wish to use it without the \s-1CGI::\s0 prefix.
.PP
\fITroubleshooting file uploads on Windows\fR
.IX Subsection "Troubleshooting file uploads on Windows"
.PP
If you are using \s-1CGI\s0.pm on a Windows platform and find that binary
files get slightly larger when uploaded but that text files remain the
same, then you have forgotten to activate binary mode on the output
filehandle.  Be sure to call \fIbinmode()\fR on any handle that you create
to write the uploaded file to disk.
.PP
\fIOlder ways to process file uploads\fR
.IX Subsection "Older ways to process file uploads"
.PP
( This section is here for completeness. if you are building a new application with \s-1CGI\s0.pm, you can skip it. )
.PP
The original way to process file uploads with \s-1CGI\s0.pm was to use \fIparam()\fR. The
value it returns has a dual nature as both a file name and a lightweight
filehandle. This dual nature is problematic if you following the recommended
practice of having \f(CW\*(C`use strict\*(C'\fR in your code. Perl will complain when you try
to use a string as a filehandle.  More seriously, it is possible for the remote
user to type garbage into the upload field, in which case what you get from
\&\fIparam()\fR is not a filehandle at all, but a string.
.PP
To solve this problem the \fIupload()\fR method was added, which always returns a
lightweight filehandle. This generally works well, but will have trouble
interoperating with some other modules because the file handle is not derived
from IO::Handle. So that brings us to current recommendation given above,
which is to call the \fIhandle()\fR method on the file handle returned by \fIupload()\fR.
That upgrades the handle to an IO::Handle. It's a big win for compatibility for
a small penalty of loading IO::Handle the first time you call it.
.SS "\s-1CREATING A POPUP MENU\s0"
.IX Subsection "CREATING A POPUP MENU"
.Vb 3
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \*(Aqmeenie\*(Aq);
\&
\&      \-or\-
\&
\&   %labels = (\*(Aqeenie\*(Aq=>\*(Aqyour first choice\*(Aq,
\&              \*(Aqmeenie\*(Aq=>\*(Aqyour second choice\*(Aq,
\&              \*(Aqminie\*(Aq=>\*(Aqyour third choice\*(Aq);
\&   %attributes = (\*(Aqeenie\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqclass of first choice\*(Aq});
\&   print popup_menu(\*(Aqmenu_name\*(Aq,
\&                            [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \*(Aqmeenie\*(Aq,\e%labels,\e%attributes);
\&
\&        \-or (named parameter style)\-
\&
\&   print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                            \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                            \-default=>[\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&          \-labels=>\e%labels,
\&          \-attributes=>\e%attributes);
.Ve
.PP
\&\fIpopup_menu()\fR creates a menu.
.IP "1." 4
The required first argument is the menu's name (\-name).
.IP "2." 4
The required second argument (\-values) is an array \fBreference\fR
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference to
a named array, such as \*(L"\e@foo\*(R".
.IP "3." 4
The optional third parameter (\-default) is the name of the default
menu choice.  If not specified, the first item will be the default.
The values of the previous choice will be maintained across
queries. Pass an array reference to select multiple defaults.
.IP "4." 4
The optional fourth parameter (\-labels) is provided for people who
want to use different values for the user-visible label inside the
popup menu and the value returned to your script.  It's a pointer to an
hash relating menu values to user-visible labels.  If you
leave this parameter blank, the menu values will be displayed by
default.  (You can also leave a label undefined if you want to).
.IP "5." 4
The optional fifth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.PP
When the form is processed, the selected value of the popup menu can
be retrieved using:
.PP
.Vb 1
\&      $popup_menu_value = param(\*(Aqmenu_name\*(Aq);
.Ve
.SS "\s-1CREATING AN OPTION GROUP\s0"
.IX Subsection "CREATING AN OPTION GROUP"
Named parameter style
.PP
.Vb 9
\&  print popup_menu(\-name=>\*(Aqmenu_name\*(Aq,
\&                  \-values=>[qw/eenie meenie minie/,
\&                            optgroup(\-name=>\*(Aqoptgroup_name\*(Aq,
\&                                             \-values => [\*(Aqmoe\*(Aq,\*(Aqcatch\*(Aq],
\&                                             \-attributes=>{\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],
\&                  \-labels=>{\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,
\&                            \*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,
\&                            \*(Aqminie\*(Aq=>\*(Aqthree\*(Aq},
\&                  \-default=>\*(Aqmeenie\*(Aq);
\&
\&  Old style
\&  print popup_menu(\*(Aqmenu_name\*(Aq,
\&                  [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,
\&                   optgroup(\*(Aqoptgroup_name\*(Aq, [\*(Aqmoe\*(Aq, \*(Aqcatch\*(Aq],
\&                                   {\*(Aqcatch\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}})],\*(Aqmeenie\*(Aq,
\&                  {\*(Aqeenie\*(Aq=>\*(Aqone\*(Aq,\*(Aqmeenie\*(Aq=>\*(Aqtwo\*(Aq,\*(Aqminie\*(Aq=>\*(Aqthree\*(Aq});
.Ve
.PP
\&\fIoptgroup()\fR creates an option group within a popup menu.
.IP "1." 4
The required first argument (\fB\-name\fR) is the label attribute of the
optgroup and is \fBnot\fR inserted in the parameter list of the query.
.IP "2." 4
The required second argument (\fB\-values\fR)  is an array reference
containing the list of menu items in the menu.  You can pass the
method an anonymous array, as shown in the example, or a reference
to a named array, such as \e@foo.  If you pass a \s-1HASH\s0 reference,
the keys will be used for the menu values, and the values will be
used for the menu labels (see \-labels below).
.IP "3." 4
The optional third parameter (\fB\-labels\fR) allows you to pass a reference
to a hash containing user-visible labels for one or more
of the menu items.  You can use this when you want the user to see one
menu string, but have the browser return your program a different one.
If you don't specify this, the value string will be used instead
(\*(L"eenie\*(R", \*(L"meenie\*(R" and \*(L"minie\*(R" in this example).  This is equivalent
to using a hash reference for the \-values parameter.
.IP "4." 4
An optional fourth parameter (\fB\-labeled\fR) can be set to a true value
and indicates that the values should be used as the label attribute
for each option element within the optgroup.
.IP "5." 4
An optional fifth parameter (\-novals) can be set to a true value and
indicates to suppress the val attribute in each option element within
the optgroup.
.Sp
See the discussion on optgroup at W3C
(http://www.w3.org/TR/REC\-html40/interact/forms.html#edef\-OPTGROUP)
for details.
.IP "6." 4
An optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.SS "\s-1CREATING A SCROLLING LIST\s0"
.IX Subsection "CREATING A SCROLLING LIST"
.Vb 4
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,{\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&      \-or\-
\&
\&   print scrolling_list(\*(Aqlist_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],5,\*(Aqtrue\*(Aq,
\&        \e%labels,%attributes);
\&
\&        \-or\-
\&
\&   print scrolling_list(\-name=>\*(Aqlist_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-size=>5,
\&                                \-multiple=>\*(Aqtrue\*(Aq,
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
.Ve
.PP
\&\fIscrolling_list()\fR creates a scrolling list.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the list name (\-name) and values
(\-values).  As in the popup menu, the second argument should be an
array reference.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be selected by default, or can be a
single value to select.  If this argument is missing or undefined,
then nothing is selected when the list first appears.  In the named
parameter version, you can use the synonym \*(L"\-defaults\*(R" for this
parameter.
.IP "3." 4
.IX Item "3."
The optional fourth argument is the size of the list (\-size).
.IP "4." 4
.IX Item "4."
The optional fifth argument can be set to true to allow multiple
simultaneous selections (\-multiple).  Otherwise only one selection
will be allowed at a time.
.IP "5." 4
.IX Item "5."
The optional sixth argument is a pointer to a hash
containing long user-visible labels for the list items (\-labels).
If not provided, the values will be displayed.
.IP "6." 4
.IX Item "6."
The optional sixth parameter (\-attributes) is provided to assign
any of the common \s-1HTML\s0 attributes to an individual menu item. It's
a pointer to a hash relating menu values to another
hash with the attribute's name as the key and the
attribute's value as the value.
.Sp
When this form is processed, all selected list items will be returned as
a list under the parameter name 'list_name'.  The values of the
selected items can be retrieved with:
.Sp
.Vb 1
\&      @selected = param(\*(Aqlist_name\*(Aq);
.Ve
.SS "\s-1CREATING A GROUP OF RELATED CHECKBOXES\s0"
.IX Subsection "CREATING A GROUP OF RELATED CHECKBOXES"
.Vb 7
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-default=>[\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-linebreak=>\*(Aqtrue\*(Aq,
\&                                \-disabled => [\*(Aqmoe\*(Aq],
\&        \-labels=>\e%labels,
\&        \-attributes=>\e%attributes);
\&
\&   print checkbox_group(\*(Aqgroup_name\*(Aq,
\&                                [\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&        [\*(Aqeenie\*(Aq,\*(Aqmoe\*(Aq],\*(Aqtrue\*(Aq,\e%labels,
\&        {\*(Aqmoe\*(Aq=>{\*(Aqclass\*(Aq=>\*(Aqred\*(Aq}});
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                                \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                                \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIcheckbox_group()\fR creates a list of checkboxes that are related
by the same name.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first and second arguments are the checkbox name and values,
respectively (\-name and \-values).  As in the popup menu, the second
argument should be an array reference.  These values are used for the
user-readable labels printed next to the checkboxes as well as for the
values passed to your script in the query string.
.IP "2." 4
.IX Item "2."
The optional third argument (\-default) can be either a reference to a
list containing the values to be checked by default, or can be a
single value to checked.  If this argument is missing or undefined,
then nothing is selected when the list first appears.
.IP "3." 4
.IX Item "3."
The optional fourth argument (\-linebreak) can be set to true to place
line breaks between the checkboxes so that they appear as a vertical
list.  Otherwise, they will be strung together on a horizontal line.
.PP
The optional \fB\-labels\fR argument is a pointer to a hash
relating the checkbox values to the user-visible labels that will be
printed next to them.  If not provided, the values will be used as the
default.
.PP
The optional parameters \fB\-rows\fR, and \fB\-columns\fR cause
\&\fIcheckbox_group()\fR to return an \s-1HTML3\s0 compatible table containing the
checkbox group formatted with the specified number of rows and
columns.  You can provide just the \-columns parameter if you wish;
checkbox_group will calculate the correct number of rows for you.
.PP
The option \fB\-disabled\fR takes an array of checkbox values and disables
them by greying them out (this may not be supported by all browsers).
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, all checked boxes will be returned as
a list under the parameter name 'group_name'.  The values of the
\&\*(L"on\*(R" checkboxes can be retrieved with:
.PP
.Vb 1
\&      @turned_on = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIcheckbox_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = checkbox_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING A STANDALONE CHECKBOX\s0"
.IX Subsection "CREATING A STANDALONE CHECKBOX"
.Vb 4
\&    print checkbox(\-name=>\*(Aqcheckbox_name\*(Aq,
\&                           \-checked=>1,
\&                           \-value=>\*(AqON\*(Aq,
\&                           \-label=>\*(AqCLICK ME\*(Aq);
\&
\&        \-or\-
\&
\&    print checkbox(\*(Aqcheckbox_name\*(Aq,\*(Aqchecked\*(Aq,\*(AqON\*(Aq,\*(AqCLICK ME\*(Aq);
.Ve
.PP
\&\fIcheckbox()\fR is used to create an isolated checkbox that isn't logically
related to any others.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first parameter is the required name for the checkbox (\-name).  It
will also be used for the user-readable label printed next to the
checkbox.
.IP "2." 4
.IX Item "2."
The optional second parameter (\-checked) specifies that the checkbox
is turned on by default.  Synonyms are \-selected and \-on.
.IP "3." 4
.IX Item "3."
The optional third parameter (\-value) specifies the value of the
checkbox when it is checked.  If not provided, the word \*(L"on\*(R" is
assumed.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-label) is the user-readable label to
be attached to the checkbox.  If not provided, the checkbox name is
used.
.PP
The value of the checkbox can be retrieved using:
.PP
.Vb 1
\&    $turned_on = param(\*(Aqcheckbox_name\*(Aq);
.Ve
.SS "\s-1CREATING A RADIO BUTTON GROUP\s0"
.IX Subsection "CREATING A RADIO BUTTON GROUP"
.Vb 6
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&                             \-default=>\*(Aqmeenie\*(Aq,
\&                             \-linebreak=>\*(Aqtrue\*(Aq,
\&           \-labels=>\e%labels,
\&           \-attributes=>\e%attributes);
\&
\&        \-or\-
\&
\&   print radio_group(\*(Aqgroup_name\*(Aq,[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq],
\&            \*(Aqmeenie\*(Aq,\*(Aqtrue\*(Aq,\e%labels,\e%attributes);
\&
\&
\&   HTML3\-COMPATIBLE BROWSERS ONLY:
\&
\&   print radio_group(\-name=>\*(Aqgroup_name\*(Aq,
\&                             \-values=>[\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq,\*(Aqminie\*(Aq,\*(Aqmoe\*(Aq],
\&                             \-rows=2,\-columns=>2);
.Ve
.PP
\&\fIradio_group()\fR creates a set of logically-related radio buttons
(turning one member of the group on turns the others off)
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is the name of the group and is required (\-name).
.IP "2." 4
.IX Item "2."
The second argument (\-values) is the list of values for the radio
buttons.  The values and the labels that appear on the page are
identical.  Pass an array \fIreference\fR in the second argument, either
using an anonymous array, as shown, or by referencing a named array as
in \*(L"\e@foo\*(R".
.IP "3." 4
.IX Item "3."
The optional third parameter (\-default) is the name of the default
button to turn on. If not specified, the first item will be the
default.  You can provide a nonexistent button name, such as \*(L"\-\*(R" to
start up with no buttons selected.
.IP "4." 4
.IX Item "4."
The optional fourth parameter (\-linebreak) can be set to 'true' to put
line breaks between the buttons, creating a vertical list.
.IP "5." 4
.IX Item "5."
The optional fifth parameter (\-labels) is a pointer to an associative
array relating the radio button values to user-visible labels to be
used in the display.  If not provided, the values themselves are
displayed.
.PP
All modern browsers can take advantage of the optional parameters
\&\fB\-rows\fR, and \fB\-columns\fR.  These parameters cause \fIradio_group()\fR to
return an \s-1HTML3\s0 compatible table containing the radio group formatted
with the specified number of rows and columns.  You can provide just
the \-columns parameter if you wish; radio_group will calculate the
correct number of rows for you.
.PP
To include row and column headings in the returned table, you
can use the \fB\-rowheaders\fR and \fB\-colheaders\fR parameters.  Both
of these accept a pointer to an array of headings to use.
The headings are just decorative.  They don't reorganize the
interpretation of the radio buttons \*(-- they're still a single named
unit.
.PP
The optional \fB\-tabindex\fR argument can be used to control the order in which
radio buttons receive focus when the user presses the tab button.  If
passed a scalar numeric value, the first element in the group will
receive this tab index and subsequent elements will be incremented by
one.  If given a reference to an array of radio button values, then
the indexes will be jiggered so that the order specified in the array
will correspond to the tab order.  You can also pass a reference to a
hash in which the hash keys are the radio button values and the values
are the tab indexes of each button.  Examples:
.PP
.Vb 3
\&  \-tabindex => 100    #  this group starts at index 100 and counts up
\&  \-tabindex => [\*(Aqmoe\*(Aq,\*(Aqminie\*(Aq,\*(Aqeenie\*(Aq,\*(Aqmeenie\*(Aq]  # tab in this order
\&  \-tabindex => {meenie=>100,moe=>101,minie=>102,eenie=>200} # tab in this order
.Ve
.PP
The optional \fB\-attributes\fR argument is provided to assign any of the
common \s-1HTML\s0 attributes to an individual menu item. It's a pointer to
a hash relating menu values to another hash
with the attribute's name as the key and the attribute's value as the
value.
.PP
The optional \fB\-labelattributes\fR argument will contain attributes
attached to the <label> element that surrounds each button.
.PP
When the form is processed, the selected radio button can
be retrieved using:
.PP
.Vb 1
\&      $which_radio_button = param(\*(Aqgroup_name\*(Aq);
.Ve
.PP
The value returned by \fIradio_group()\fR is actually an array of button
elements.  You can capture them and use them within tables, lists,
or in other creative ways:
.PP
.Vb 2
\&    @h = radio_group(\-name=>\*(Aqgroup_name\*(Aq,\-values=>\e@values);
\&    &use_in_creative_way(@h);
.Ve
.SS "\s-1CREATING A SUBMIT BUTTON \s0"
.IX Subsection "CREATING A SUBMIT BUTTON "
.Vb 2
\&   print submit(\-name=>\*(Aqbutton_name\*(Aq,
\&                        \-value=>\*(Aqvalue\*(Aq);
\&
\&        \-or\-
\&
\&   print submit(\*(Aqbutton_name\*(Aq,\*(Aqvalue\*(Aq);
.Ve
.PP
\&\fIsubmit()\fR will create the query submission button.  Every form
should have one of these.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is optional.  You can give the button a
name if you have several submission buttons in your form and you want
to distinguish between them.
.IP "2." 4
.IX Item "2."
The second argument (\-value) is also optional.  This gives the button
a value that will be passed to your script in the query string. The
name will also be used as the user-visible label.
.IP "3." 4
.IX Item "3."
You can use \-label as an alias for \-value.  I always get confused
about which of \-name and \-value changes the user-visible label on the
button.
.PP
You can figure out which button was pressed by using different
values for each one:
.PP
.Vb 1
\&     $which_one = param(\*(Aqbutton_name\*(Aq);
.Ve
.SS "\s-1CREATING A RESET BUTTON\s0"
.IX Subsection "CREATING A RESET BUTTON"
.Vb 1
\&   print reset
.Ve
.PP
\&\fIreset()\fR creates the \*(L"reset\*(R" button.  Note that it restores the
form to its value from the last time the script was called, 
\&\s-1NOT\s0 necessarily to the defaults.
.PP
Note that this conflicts with the Perl \fIreset()\fR built-in.  Use
\&\fICORE::reset()\fR to get the original reset function.
.SS "\s-1CREATING A DEFAULT BUTTON\s0"
.IX Subsection "CREATING A DEFAULT BUTTON"
.Vb 1
\&   print defaults(\*(Aqbutton_label\*(Aq)
.Ve
.PP
\&\fIdefaults()\fR creates a button that, when invoked, will cause the
form to be completely reset to its defaults, wiping out all the
changes the user ever made.
.SS "\s-1CREATING A HIDDEN FIELD\s0"
.IX Subsection "CREATING A HIDDEN FIELD"
.Vb 2
\&        print hidden(\-name=>\*(Aqhidden_name\*(Aq,
\&                             \-default=>[\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...]);
\&
\&                \-or\-
\&
\&        print hidden(\*(Aqhidden_name\*(Aq,\*(Aqvalue1\*(Aq,\*(Aqvalue2\*(Aq...);
.Ve
.PP
\&\fIhidden()\fR produces a text field that can't be seen by the user.  It
is useful for passing state variable information from one invocation
of the script to the next.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument is required and specifies the name of this
field (\-name).
.IP "2." 4
.IX Item "2."
The second argument is also required and specifies its value
(\-default).  In the named parameter style of calling, you can provide
a single value here or a reference to a whole list
.PP
Fetch the value of a hidden field this way:
.PP
.Vb 1
\&     $hidden_value = param(\*(Aqhidden_name\*(Aq);
.Ve
.PP
Note, that just like all the other form elements, the value of a
hidden field is \*(L"sticky\*(R".  If you want to replace a hidden field with
some other values after the script has been called once you'll have to
do it manually:
.PP
.Vb 1
\&     param(\*(Aqhidden_name\*(Aq,\*(Aqnew\*(Aq,\*(Aqvalues\*(Aq,\*(Aqhere\*(Aq);
.Ve
.SS "\s-1CREATING A CLICKABLE IMAGE BUTTON\s0"
.IX Subsection "CREATING A CLICKABLE IMAGE BUTTON"
.Vb 3
\&     print image_button(\-name=>\*(Aqbutton_name\*(Aq,
\&                                \-src=>\*(Aq/source/URL\*(Aq,
\&                                \-align=>\*(AqMIDDLE\*(Aq);      
\&
\&        \-or\-
\&
\&     print image_button(\*(Aqbutton_name\*(Aq,\*(Aq/source/URL\*(Aq,\*(AqMIDDLE\*(Aq);
.Ve
.PP
\&\fIimage_button()\fR produces a clickable image.  When it's clicked on the
position of the click is returned to your script as \*(L"button_name.x\*(R"
and \*(L"button_name.y\*(R", where \*(L"button_name\*(R" is the name you've assigned
to it.
.IP "\fBParameters:\fR" 4
.IX Item "Parameters:"
.PD 0
.IP "1." 4
.IX Item "1."
.PD
The first argument (\-name) is required and specifies the name of this
field.
.IP "2." 4
.IX Item "2."
The second argument (\-src) is also required and specifies the \s-1URL\s0
.IP "3. The third option (\-align, optional) is an alignment type, and may be \s-1TOP, BOTTOM\s0 or \s-1MIDDLE\s0" 4
.IX Item "3. The third option (-align, optional) is an alignment type, and may be TOP, BOTTOM or MIDDLE"
.PP
Fetch the value of the button this way:
     \f(CW$x\fR = param('button_name.x');
     \f(CW$y\fR = param('button_name.y');
.SS "\s-1CREATING A JAVASCRIPT ACTION BUTTON\s0"
.IX Subsection "CREATING A JAVASCRIPT ACTION BUTTON"
.Vb 3
\&     print button(\-name=>\*(Aqbutton_name\*(Aq,
\&                          \-value=>\*(Aquser visible label\*(Aq,
\&                          \-onClick=>"do_something()");
\&
\&        \-or\-
\&
\&     print button(\*(Aqbutton_name\*(Aq,"user visible value","do_something()");
.Ve
.PP
\&\fIbutton()\fR produces an \f(CW\*(C`<input>\*(C'\fR tag with \f(CW\*(C`type="button"\*(C'\fR.  When it's
pressed the fragment of JavaScript code pointed to by the \fB\-onClick\fR parameter
will be executed.
.SH "HTTP COOKIES"
.IX Header "HTTP COOKIES"
Browsers support a so-called \*(L"cookie\*(R" designed to help maintain state
within a browser session.  \s-1CGI\s0.pm has several methods that support
cookies.
.PP
A cookie is a name=value pair much like the named parameters in a \s-1CGI\s0
query string.  \s-1CGI\s0 scripts create one or more cookies and send
them to the browser in the \s-1HTTP\s0 header.  The browser maintains a list
of cookies that belong to a particular Web server, and returns them
to the \s-1CGI\s0 script during subsequent interactions.
.PP
In addition to the required name=value pair, each cookie has several
optional attributes:
.IP "1. an expiration time" 4
.IX Item "1. an expiration time"
This is a time/date string (in a special \s-1GMT\s0 format) that indicates
when a cookie expires.  The cookie will be saved and returned to your
script until this expiration date is reached if the user exits
the browser and restarts it.  If an expiration date isn't specified, the cookie
will remain active until the user quits the browser.
.IP "2. a domain" 4
.IX Item "2. a domain"
This is a partial or complete domain name for which the cookie is 
valid.  The browser will return the cookie to any host that matches
the partial domain name.  For example, if you specify a domain name
of \*(L".capricorn.com\*(R", then the browser will return the cookie to
Web servers running on any of the machines \*(L"www.capricorn.com\*(R", 
\&\*(L"www2.capricorn.com\*(R", \*(L"feckless.capricorn.com\*(R", etc.  Domain names
must contain at least two periods to prevent attempts to match
on top level domains like \*(L".edu\*(R".  If no domain is specified, then
the browser will only return the cookie to servers on the host the
cookie originated from.
.IP "3. a path" 4
.IX Item "3. a path"
If you provide a cookie path attribute, the browser will check it
against your script's \s-1URL\s0 before returning the cookie.  For example,
if you specify the path \*(L"/cgi\-bin\*(R", then the cookie will be returned
to each of the scripts \*(L"/cgi\-bin/tally.pl\*(R", \*(L"/cgi\-bin/order.pl\*(R",
and \*(L"/cgi\-bin/customer_service/complain.pl\*(R", but not to the script
\&\*(L"/cgi\-private/site_admin.pl\*(R".  By default, path is set to \*(L"/\*(R", which
causes the cookie to be sent to any \s-1CGI\s0 script on your site.
.ie n .IP "4. a ""secure"" flag" 4
.el .IP "4. a ``secure'' flag" 4
.IX Item "4. a secure flag"
If the \*(L"secure\*(R" attribute is set, the cookie will only be sent to your
script if the \s-1CGI\s0 request is occurring on a secure channel, such as \s-1SSL.\s0
.PP
The interface to \s-1HTTP\s0 cookies is the \fB\f(BIcookie()\fB\fR method:
.PP
.Vb 7
\&    $cookie = cookie(\-name=>\*(AqsessionID\*(Aq,
\&                             \-value=>\*(Aqxyzzy\*(Aq,
\&                             \-expires=>\*(Aq+1h\*(Aq,
\&                             \-path=>\*(Aq/cgi\-bin/database\*(Aq,
\&                             \-domain=>\*(Aq.capricorn.org\*(Aq,
\&                             \-secure=>1);
\&    print header(\-cookie=>$cookie);
.Ve
.PP
\&\fB\f(BIcookie()\fB\fR creates a new cookie.  Its parameters include:
.IP "\fB\-name\fR" 4
.IX Item "-name"
The name of the cookie (required).  This can be any string at all.
Although browsers limit their cookie names to non-whitespace
alphanumeric characters, \s-1CGI\s0.pm removes this restriction by escaping
and unescaping cookies behind the scenes.
.IP "\fB\-value\fR" 4
.IX Item "-value"
The value of the cookie.  This can be any scalar value,
array reference, or even hash reference.  For example,
you can store an entire hash into a cookie this way:
.Sp
.Vb 2
\&        $cookie=cookie(\-name=>\*(Aqfamily information\*(Aq,
\&                               \-value=>\e%childrens_ages);
.Ve
.IP "\fB\-path\fR" 4
.IX Item "-path"
The optional partial path for which this cookie will be valid, as described
above.
.IP "\fB\-domain\fR" 4
.IX Item "-domain"
The optional partial domain for which this cookie will be valid, as described
above.
.IP "\fB\-expires\fR" 4
.IX Item "-expires"
The optional expiration date for this cookie.  The format is as described 
in the section on the \fB\f(BIheader()\fB\fR method:
.Sp
.Vb 1
\&        "+1h"  one hour from now
.Ve
.IP "\fB\-secure\fR" 4
.IX Item "-secure"
If set to true, this cookie will only be used within a secure
\&\s-1SSL\s0 session.
.PP
The cookie created by \fIcookie()\fR must be incorporated into the \s-1HTTP\s0
header within the string returned by the \fIheader()\fR method:
.PP
.Vb 2
\&        use CGI \*(Aq:standard\*(Aq;
\&        print header(\-cookie=>$my_cookie);
.Ve
.PP
To create multiple cookies, give \fIheader()\fR an array reference:
.PP
.Vb 5
\&        $cookie1 = cookie(\-name=>\*(Aqriddle_name\*(Aq,
\&                                  \-value=>"The Sphynx\*(Aqs Question");
\&        $cookie2 = cookie(\-name=>\*(Aqanswers\*(Aq,
\&                                  \-value=>\e%answers);
\&        print header(\-cookie=>[$cookie1,$cookie2]);
.Ve
.PP
To retrieve a cookie, request it by name by calling \fIcookie()\fR method
without the \fB\-value\fR parameter. This example uses the object-oriented
form:
.PP
.Vb 4
\&        use CGI;
\&        $query = CGI\->new;
\&        $riddle = $query\->cookie(\*(Aqriddle_name\*(Aq);
\&        %answers = $query\->cookie(\*(Aqanswers\*(Aq);
.Ve
.PP
Cookies created with a single scalar value, such as the \*(L"riddle_name\*(R"
cookie, will be returned in that form.  Cookies with array and hash
values can also be retrieved.
.PP
The cookie and \s-1CGI\s0 namespaces are separate.  If you have a parameter
named 'answers' and a cookie named 'answers', the values retrieved by
\&\fIparam()\fR and \fIcookie()\fR are independent of each other.  However, it's
simple to turn a \s-1CGI\s0 parameter into a cookie, and vice-versa:
.PP
.Vb 4
\&   # turn a CGI parameter into a cookie
\&   $c=cookie(\-name=>\*(Aqanswers\*(Aq,\-value=>[param(\*(Aqanswers\*(Aq)]);
\&   # vice\-versa
\&   param(\-name=>\*(Aqanswers\*(Aq,\-value=>[cookie(\*(Aqanswers\*(Aq)]);
.Ve
.PP
If you call \fIcookie()\fR without any parameters, it will return a list of
the names of all cookies passed to your script:
.PP
.Vb 1
\&  @cookies = cookie();
.Ve
.PP
See the \fBcookie.cgi\fR example script for some ideas on how to use
cookies effectively.
.SH "WORKING WITH FRAMES"
.IX Header "WORKING WITH FRAMES"
It's possible for \s-1CGI\s0.pm scripts to write into several browser panels
and windows using the \s-1HTML 4\s0 frame mechanism.  There are three
techniques for defining new frames programmatically:
.IP "1. Create a <Frameset> document" 4
.IX Item "1. Create a <Frameset> document"
After writing out the \s-1HTTP\s0 header, instead of creating a standard
\&\s-1HTML\s0 document using the \fIstart_html()\fR call, create a <frameset> 
document that defines the frames on the page.  Specify your script(s)
(with appropriate parameters) as the \s-1SRC\s0 for each of the frames.
.Sp
There is no specific support for creating <frameset> sections 
in \s-1CGI\s0.pm, but the \s-1HTML\s0 is very simple to write.
.IP "2. Specify the destination for the document in the \s-1HTTP\s0 header" 4
.IX Item "2. Specify the destination for the document in the HTTP header"
You may provide a \fB\-target\fR parameter to the \fIheader()\fR method:
.Sp
.Vb 1
\&    print header(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
This will tell the browser to load the output of your script into the
frame named \*(L"ResultsWindow\*(R".  If a frame of that name doesn't already
exist, the browser will pop up a new window and load your script's
document into that.  There are a number of magic names that you can
use for targets.  See the \s-1HTML \s0\f(CW\*(C`<frame>\*(C'\fR documentation for details.
.IP "3. Specify the destination for the document in the <form> tag" 4
.IX Item "3. Specify the destination for the document in the <form> tag"
You can specify the frame to load in the \s-1FORM\s0 tag itself.  With
\&\s-1CGI\s0.pm it looks like this:
.Sp
.Vb 1
\&    print start_form(\-target=>\*(AqResultsWindow\*(Aq);
.Ve
.Sp
When your script is reinvoked by the form, its output will be loaded
into the frame named \*(L"ResultsWindow\*(R".  If one doesn't already exist
a new window will be created.
.PP
The script \*(L"frameset.cgi\*(R" in the examples directory shows one way to
create pages in which the fill-out form and the response live in
side-by-side frames.
.SH "SUPPORT FOR JAVASCRIPT"
.IX Header "SUPPORT FOR JAVASCRIPT"
The usual way to use JavaScript is to define a set of functions in a
<\s-1SCRIPT\s0> block inside the \s-1HTML\s0 header and then to register event
handlers in the various elements of the page. Events include such
things as the mouse passing over a form element, a button being
clicked, the contents of a text field changing, or a form being
submitted. When an event occurs that involves an element that has
registered an event handler, its associated JavaScript code gets
called.
.PP
The elements that can register event handlers include the <\s-1BODY\s0> of an
\&\s-1HTML\s0 document, hypertext links, all the various elements of a fill-out
form, and the form itself. There are a large number of events, and
each applies only to the elements for which it is relevant. Here is a
partial list:
.IP "\fBonLoad\fR" 4
.IX Item "onLoad"
The browser is loading the current document. Valid in:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonUnload\fR" 4
.IX Item "onUnload"
The browser is closing the current page or frame. Valid for:
.Sp
.Vb 1
\&     + The HTML <BODY> section only.
.Ve
.IP "\fBonSubmit\fR" 4
.IX Item "onSubmit"
The user has pressed the submit button of a form. This event happens
just before the form is submitted, and your function can return a
value of false in order to abort the submission.  Valid for:
.Sp
.Vb 1
\&     + Forms only.
.Ve
.IP "\fBonClick\fR" 4
.IX Item "onClick"
The mouse has clicked on an item in a fill-out form. Valid for:
.Sp
.Vb 3
\&     + Buttons (including submit, reset, and image buttons)
\&     + Checkboxes
\&     + Radio buttons
.Ve
.IP "\fBonChange\fR" 4
.IX Item "onChange"
The user has changed the contents of a field. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonFocus\fR" 4
.IX Item "onFocus"
The user has selected a field to work with. Valid for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonBlur\fR" 4
.IX Item "onBlur"
The user has deselected a field (gone to work somewhere else).  Valid
for:
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonSelect\fR" 4
.IX Item "onSelect"
The user has changed the part of a text field that is selected.  Valid
for:
.Sp
.Vb 4
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
.Ve
.IP "\fBonMouseOver\fR" 4
.IX Item "onMouseOver"
The mouse has moved over an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.IP "\fBonMouseOut\fR" 4
.IX Item "onMouseOut"
The mouse has moved off an element.
.Sp
.Vb 6
\&     + Text fields
\&     + Text areas
\&     + Password fields
\&     + File fields
\&     + Popup Menus
\&     + Scrolling lists
.Ve
.PP
In order to register a JavaScript event handler with an \s-1HTML\s0 element,
just use the event name as a parameter when you call the corresponding
\&\s-1CGI\s0 method. For example, to have your \fIvalidateAge()\fR JavaScript code
executed every time the textfield named \*(L"age\*(R" changes, generate the
field like this:
.PP
.Vb 1
\& print textfield(\-name=>\*(Aqage\*(Aq,\-onChange=>"validateAge(this)");
.Ve
.PP
This example assumes that you've already declared the \fIvalidateAge()\fR
function by incorporating it into a <\s-1SCRIPT\s0> block. The \s-1CGI\s0.pm
\&\fIstart_html()\fR method provides a convenient way to create this section.
.PP
Similarly, you can create a form that checks itself over for
consistency and alerts the user if some essential value is missing by
creating it this way: 
  print start_form(\-onSubmit=>\*(L"validateMe(this)\*(R");
.PP
See the javascript.cgi script for a demonstration of how this all
works.
.SH "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
.IX Header "LIMITED SUPPORT FOR CASCADING STYLE SHEETS"
\&\s-1CGI\s0.pm has limited support for \s-1HTML3\s0's cascading style sheets (css).
To incorporate a stylesheet into your document, pass the
\&\fIstart_html()\fR method a \fB\-style\fR parameter.  The value of this
parameter may be a scalar, in which case it is treated as the source
\&\s-1URL\s0 for the stylesheet, or it may be a hash reference.  In the latter
case you should provide the hash with one or more of \fB\-src\fR or
\&\fB\-code\fR.  \fB\-src\fR points to a \s-1URL\s0 where an externally-defined
stylesheet can be found.  \fB\-code\fR points to a scalar value to be
incorporated into a <style> section.  Style definitions in \fB\-code\fR
override similarly-named ones in \fB\-src\fR, hence the name \*(L"cascading.\*(R"
.PP
You may also specify the type of the stylesheet by adding the optional
\&\fB\-type\fR parameter to the hash pointed to by \fB\-style\fR.  If not
specified, the style defaults to 'text/css'.
.PP
To refer to a style within the body of your document, add the
\&\fB\-class\fR parameter to any \s-1HTML\s0 element:
.PP
.Vb 1
\&    print h1({\-class=>\*(AqFancy\*(Aq},\*(AqWelcome to the Party\*(Aq);
.Ve
.PP
Or define styles on the fly with the \fB\-style\fR parameter:
.PP
.Vb 1
\&    print h1({\-style=>\*(AqColor: red;\*(Aq},\*(AqWelcome to Hell\*(Aq);
.Ve
.PP
You may also use the new \fB\f(BIspan()\fB\fR element to apply a style to a
section of text:
.PP
.Vb 4
\&    print span({\-style=>\*(AqColor: red;\*(Aq},
\&               h1(\*(AqWelcome to Hell\*(Aq),
\&               "Where did that handbasket get to?"
\&               );
.Ve
.PP
Note that you must import the \*(L":html3\*(R" definitions to have the
\&\fB\f(BIspan()\fB\fR method available.  Here's a quick and dirty example of using
\&\s-1CSS\s0's.  See the \s-1CSS\s0 specification at
http://www.w3.org/Style/CSS/ for more information.
.PP
.Vb 1
\&    use CGI qw/:standard :html3/;
\&
\&    #here\*(Aqs a stylesheet incorporated directly into the page
\&    $newStyle=<<END;
\&    <!\-\- 
\&    P.Tip {
\&        margin\-right: 50pt;
\&        margin\-left: 50pt;
\&        color: red;
\&    }
\&    P.Alert {
\&        font\-size: 30pt;
\&        font\-family: sans\-serif;
\&      color: red;
\&    }
\&    \-\->
\&    END
\&    print header();
\&    print start_html( \-title=>\*(AqCGI with Style\*(Aq,
\&                      \-style=>{\-src=>\*(Aqhttp://www.capricorn.com/style/st1.css\*(Aq,
\&                               \-code=>$newStyle}
\&                     );
\&    print h1(\*(AqCGI with Style\*(Aq),
\&          p({\-class=>\*(AqTip\*(Aq},
\&            "Better read the cascading style sheet spec before playing with this!"),
\&          span({\-style=>\*(Aqcolor: magenta\*(Aq},
\&               "Look Mom, no hands!",
\&               p(),
\&               "Whooo wee!"
\&               );
\&    print end_html;
.Ve
.PP
Pass an array reference to \fB\-code\fR or \fB\-src\fR in order to incorporate
multiple stylesheets into your document.
.PP
Should you wish to incorporate a verbatim stylesheet that includes
arbitrary formatting in the header, you may pass a \-verbatim tag to
the \-style hash, as follows:
.PP
print start_html (\-style  =>  {\-verbatim => '@import url(\*(L"/server\-common/css/'.$cssFile.'\*(R");',
                  \-src    =>  '/server\-common/css/core.css'});
.PP
This will generate an \s-1HTML\s0 header that contains this:
.PP
.Vb 4
\& <link rel="stylesheet" type="text/css"  href="/server\-common/css/core.css">
\&   <style type="text/css">
\&   @import url("/server\-common/css/main.css");
\&   </style>
.Ve
.PP
Any additional arguments passed in the \-style value will be
incorporated into the <link> tag.  For example:
.PP
.Vb 2
\& start_html(\-style=>{\-src=>[\*(Aq/styles/print.css\*(Aq,\*(Aq/styles/layout.css\*(Aq],
\&                          \-media => \*(Aqall\*(Aq});
.Ve
.PP
This will give:
.PP
.Vb 2
\& <link rel="stylesheet" type="text/css" href="/styles/print.css" media="all"/>
\& <link rel="stylesheet" type="text/css" href="/styles/layout.css" media="all"/>
.Ve
.PP
<p>
.PP
To make more complicated <link> tags, use the \fILink()\fR function
and pass it to \fIstart_html()\fR in the \-head argument, as in:
.PP
.Vb 3
\&  @h = (Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/ss.css\*(Aq,\-media=>\*(Aqall\*(Aq}),
\&        Link({\-rel=>\*(Aqstylesheet\*(Aq,\-type=>\*(Aqtext/css\*(Aq,\-src=>\*(Aq/ss/fred.css\*(Aq,\-media=>\*(Aqpaper\*(Aq}));
\&  print start_html({\-head=>\e@h})
.Ve
.PP
To create primary and  \*(L"alternate\*(R" stylesheet, use the \fB\-alternate\fR option:
.PP
.Vb 5
\& start_html(\-style=>{\-src=>[
\&                           {\-src=>\*(Aq/styles/print.css\*(Aq},
\&                           {\-src=>\*(Aq/styles/alt.css\*(Aq,\-alternate=>1}
\&                           ]
\&                    });
.Ve
.SH "DEBUGGING"
.IX Header "DEBUGGING"
If you are running the script from the command line or in the perl
debugger, you can pass the script a list of keywords or
parameter=value pairs on the command line or from standard input (you
don't have to worry about tricking your script into reading from
environment variables).  You can pass keywords like this:
.PP
.Vb 1
\&    your_script.pl keyword1 keyword2 keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&   your_script.pl keyword1+keyword2+keyword3
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1 name2=value2
.Ve
.PP
or this:
.PP
.Vb 1
\&    your_script.pl name1=value1&name2=value2
.Ve
.PP
To turn off this feature, use the \-no_debug pragma.
.PP
To test the \s-1POST\s0 method, you may enable full debugging with the \-debug
pragma.  This will allow you to feed newline-delimited name=value
pairs to the script on standard input.
.PP
When debugging, you can use quotes and backslashes to escape 
characters in the familiar shell manner, letting you place
spaces and other funny characters in your parameter=value
pairs:
.PP
.Vb 1
\&   your_script.pl "name1=\*(AqI am a long value\*(Aq" "name2=two\e words"
.Ve
.PP
Finally, you can set the path info for the script by prefixing the first
name/value parameter with the path followed by a question mark (?):
.PP
.Vb 1
\&    your_script.pl /your/path/here?name1=value1&name2=value2
.Ve
.SS "\s-1DUMPING OUT ALL THE NAME/VALUE PAIRS\s0"
.IX Subsection "DUMPING OUT ALL THE NAME/VALUE PAIRS"
The \fIDump()\fR method produces a string consisting of all the query's
name/value pairs formatted nicely as a nested list.  This is useful
for debugging purposes:
.PP
.Vb 1
\&    print Dump
.Ve
.PP
Produces something that looks like:
.PP
.Vb 11
\&    <ul>
\&    <li>name1
\&        <ul>
\&        <li>value1
\&        <li>value2
\&        </ul>
\&    <li>name2
\&        <ul>
\&        <li>value1
\&        </ul>
\&    </ul>
.Ve
.PP
As a shortcut, you can interpolate the entire \s-1CGI\s0 object into a string
and it will be replaced with the a nice \s-1HTML\s0 dump shown above:
.PP
.Vb 2
\&    $query=CGI\->new;
\&    print "<h2>Current Values</h2> $query\en";
.Ve
.SH "FETCHING ENVIRONMENT VARIABLES"
.IX Header "FETCHING ENVIRONMENT VARIABLES"
Some of the more useful environment variables can be fetched
through this interface.  The methods are as follows:
.IP "\fB\f(BIAccept()\fB\fR" 4
.IX Item "Accept()"
Return a list of \s-1MIME\s0 types that the remote browser accepts. If you
give this method a single argument corresponding to a \s-1MIME\s0 type, as in
Accept('text/html'), it will return a floating point value
corresponding to the browser's preference for this type from 0.0
(don't want) to 1.0.  Glob types (e.g. text/*) in the browser's accept
list are handled correctly.
.Sp
Note that the capitalization changed between version 2.43 and 2.44 in
order to avoid conflict with Perl's \fIaccept()\fR function.
.IP "\fB\f(BIraw_cookie()\fB\fR" 4
.IX Item "raw_cookie()"
Returns the \s-1HTTP_COOKIE\s0 variable.  Cookies have a special format, and
this method call just returns the raw form (?cookie dough).  See
\&\fIcookie()\fR for ways of setting and retrieving cooked cookies.
.Sp
Called with no parameters, \fIraw_cookie()\fR returns the packed cookie
structure.  You can separate it into individual cookies by splitting
on the character sequence \*(L"; \*(R".  Called with the name of a cookie,
retrieves the \fBunescaped\fR form of the cookie.  You can use the
regular \fIcookie()\fR method to get the names, or use the \fIraw_fetch()\fR
method from the CGI::Cookie module.
.IP "\fB\f(BIuser_agent()\fB\fR" 4
.IX Item "user_agent()"
Returns the \s-1HTTP_USER_AGENT\s0 variable.  If you give
this method a single argument, it will attempt to
pattern match on it, allowing you to do something
like user_agent(Mozilla);
.IP "\fB\f(BIpath_info()\fB\fR" 4
.IX Item "path_info()"
Returns additional path information from the script \s-1URL.
E.G.\s0 fetching /cgi\-bin/your_script/additional/stuff will result in
\&\fIpath_info()\fR returning \*(L"/additional/stuff\*(R".
.Sp
\&\s-1NOTE:\s0 The Microsoft Internet Information Server
is broken with respect to additional path information.  If
you use the Perl \s-1DLL\s0 library, the \s-1IIS\s0 server will attempt to
execute the additional path information as a Perl script.
If you use the ordinary file associations mapping, the
path information will be present in the environment, 
but incorrect.  The best thing to do is to avoid using additional
path information in \s-1CGI\s0 scripts destined for use with \s-1IIS.\s0
.IP "\fB\f(BIpath_translated()\fB\fR" 4
.IX Item "path_translated()"
As per \fIpath_info()\fR but returns the additional
path information translated into a physical path, e.g.
\&\*(L"/usr/local/etc/httpd/htdocs/additional/stuff\*(R".
.Sp
The Microsoft \s-1IIS\s0 is broken with respect to the translated
path as well.
.IP "\fB\f(BIremote_host()\fB\fR" 4
.IX Item "remote_host()"
Returns either the remote host name or \s-1IP\s0 address.
if the former is unavailable.
.IP "\fB\f(BIremote_addr()\fB\fR" 4
.IX Item "remote_addr()"
Returns the remote host \s-1IP\s0 address, or 
127.0.0.1 if the address is unavailable.
.IP "\fB\f(BIscript_name()\fB\fR Return the script name as a partial \s-1URL,\s0 for self-referring scripts." 4
.IX Item "script_name() Return the script name as a partial URL, for self-referring scripts."
.PD 0
.IP "\fB\f(BIreferer()\fB\fR" 4
.IX Item "referer()"
.PD
Return the \s-1URL\s0 of the page the browser was viewing
prior to fetching your script.  Not available for all
browsers.
.IP "\fBauth_type ()\fR" 4
.IX Item "auth_type ()"
Return the authorization/verification method in use for this
script, if any.
.IP "\fBserver_name ()\fR" 4
.IX Item "server_name ()"
Returns the name of the server, usually the machine's host
name.
.IP "\fBvirtual_host ()\fR" 4
.IX Item "virtual_host ()"
When using virtual hosts, returns the name of the host that
the browser attempted to contact
.IP "\fBserver_port ()\fR" 4
.IX Item "server_port ()"
Return the port that the server is listening on.
.IP "\fBvirtual_port ()\fR" 4
.IX Item "virtual_port ()"
Like \fIserver_port()\fR except that it takes virtual hosts into account.
Use this when running with virtual hosts.
.IP "\fBserver_software ()\fR" 4
.IX Item "server_software ()"
Returns the server software and version number.
.IP "\fBremote_user ()\fR" 4
.IX Item "remote_user ()"
Return the authorization/verification name used for user
verification, if this script is protected.
.IP "\fBuser_name ()\fR" 4
.IX Item "user_name ()"
Attempt to obtain the remote user's name, using a variety of different
techniques.  This only works with older browsers such as Mosaic.
Newer browsers do not report the user name for privacy reasons!
.IP "\fB\f(BIrequest_method()\fB\fR" 4
.IX Item "request_method()"
Returns the method used to access your script, usually
one of '\s-1POST\s0', '\s-1GET\s0' or '\s-1HEAD\s0'.
.IP "\fB\f(BIcontent_type()\fB\fR" 4
.IX Item "content_type()"
Returns the content_type of data submitted in a \s-1POST,\s0 generally 
multipart/form\-data or application/x\-www\-form\-urlencoded
.IP "\fB\f(BIhttp()\fB\fR" 4
.IX Item "http()"
Called with no arguments returns the list of \s-1HTTP\s0 environment
variables, including such things as \s-1HTTP_USER_AGENT,
HTTP_ACCEPT_LANGUAGE,\s0 and \s-1HTTP_ACCEPT_CHARSET,\s0 corresponding to the
like-named \s-1HTTP\s0 header fields in the request.  Called with the name of
an \s-1HTTP\s0 header field, returns its value.  Capitalization and the use
of hyphens versus underscores are not significant.
.Sp
For example, all three of these examples are equivalent:
.Sp
.Vb 3
\&   $requested_language = http(\*(AqAccept\-language\*(Aq);
\&   $requested_language = http(\*(AqAccept_language\*(Aq);
\&   $requested_language = http(\*(AqHTTP_ACCEPT_LANGUAGE\*(Aq);
.Ve
.IP "\fB\f(BIhttps()\fB\fR" 4
.IX Item "https()"
The same as \fI\fIhttp()\fI\fR, but operates on the \s-1HTTPS\s0 environment variables
present when the \s-1SSL\s0 protocol is in effect.  Can be used to determine
whether \s-1SSL\s0 is turned on.
.SH "USING NPH SCRIPTS"
.IX Header "USING NPH SCRIPTS"
\&\s-1NPH,\s0 or \*(L"no-parsed-header\*(R", scripts bypass the server completely by
sending the complete \s-1HTTP\s0 header directly to the browser.  This has
slight performance benefits, but is of most use for taking advantage
of \s-1HTTP\s0 extensions that are not directly supported by your server,
such as server push and \s-1PICS\s0 headers.
.PP
Servers use a variety of conventions for designating \s-1CGI\s0 scripts as
\&\s-1NPH. \s0 Many Unix servers look at the beginning of the script's name for
the prefix \*(L"nph\-\*(R".  The Macintosh WebSTAR server and Microsoft's
Internet Information Server, in contrast, try to decide whether a
program is an \s-1NPH\s0 script by examining the first line of script output.
.PP
\&\s-1CGI\s0.pm supports \s-1NPH\s0 scripts with a special \s-1NPH\s0 mode.  When in this
mode, \s-1CGI\s0.pm will output the necessary extra header information when
the \fIheader()\fR and \fIredirect()\fR methods are
called.
.PP
The Microsoft Internet Information Server requires \s-1NPH\s0 mode.  As of
version 2.30, \s-1CGI\s0.pm will automatically detect when the script is
running under \s-1IIS\s0 and put itself into this mode.  You do not need to
do this manually, although it won't hurt anything if you do.  However,
note that if you have applied Service Pack 6, much of the
functionality of \s-1NPH\s0 scripts, including the ability to redirect while
setting a cookie, \fBdo not work at all\fR on \s-1IIS\s0 without a special patch
from Microsoft.  See
http://web.archive.org/web/20010812012030/http://support.microsoft.com/support/kb/articles/Q280/3/41.ASP
Non-Parsed Headers Stripped From \s-1CGI\s0 Applications That Have nph\-
Prefix in Name.
.IP "In the \fBuse\fR statement" 4
.IX Item "In the use statement"
Simply add the \*(L"\-nph\*(R" pragma to the list of symbols to be imported into
your script:
.Sp
.Vb 1
\&      use CGI qw(:standard \-nph)
.Ve
.IP "By calling the \fB\f(BInph()\fB\fR method:" 4
.IX Item "By calling the nph() method:"
Call \fB\f(BInph()\fB\fR with a non-zero parameter at any point after using \s-1CGI\s0.pm in your program.
.Sp
.Vb 1
\&      CGI\->nph(1)
.Ve
.IP "By using \fB\-nph\fR parameters" 4
.IX Item "By using -nph parameters"
in the \fB\f(BIheader()\fB\fR and \fB\f(BIredirect()\fB\fR  statements:
.Sp
.Vb 1
\&      print header(\-nph=>1);
.Ve
.SH "Server Push"
.IX Header "Server Push"
\&\s-1CGI\s0.pm provides four simple functions for producing multipart
documents of the type needed to implement server push.  These
functions were graciously provided by Ed Jordan <ed@fidalgo.net>.  To
import these into your namespace, you must import the \*(L":push\*(R" set.
You are also advised to put the script into \s-1NPH\s0 mode and to set $| to
1 to avoid buffering problems.
.PP
Here is a simple script that demonstrates server push:
.PP
.Vb 10
\&  #!/usr/local/bin/perl
\&  use CGI qw/:push \-nph/;
\&  $| = 1;
\&  print multipart_init(\-boundary=>\*(Aq\-\-\-\-here we go!\*(Aq);
\&  for (0 .. 4) {
\&      print multipart_start(\-type=>\*(Aqtext/plain\*(Aq),
\&            "The current time is ",scalar(localtime),"\en";
\&      if ($_ < 4) {
\&              print multipart_end;
\&      } else {
\&              print multipart_final;
\&      }
\&      sleep 1;
\&  }
.Ve
.PP
This script initializes server push by calling \fB\f(BImultipart_init()\fB\fR.
It then enters a loop in which it begins a new multipart section by
calling \fB\f(BImultipart_start()\fB\fR, prints the current local time,
and ends a multipart section with \fB\f(BImultipart_end()\fB\fR.  It then sleeps
a second, and begins again. On the final iteration, it ends the
multipart section with \fB\f(BImultipart_final()\fB\fR rather than with
\&\fB\f(BImultipart_end()\fB\fR.
.IP "\fImultipart_init()\fR" 4
.IX Item "multipart_init()"
.Vb 1
\&  multipart_init(\-boundary=>$boundary);
.Ve
.Sp
Initialize the multipart system.  The \-boundary argument specifies
what \s-1MIME\s0 boundary string to use to separate parts of the document.
If not provided, \s-1CGI\s0.pm chooses a reasonable boundary for you.
.IP "\fImultipart_start()\fR" 4
.IX Item "multipart_start()"
.Vb 1
\&  multipart_start(\-type=>$type)
.Ve
.Sp
Start a new part of the multipart document using the specified \s-1MIME\s0
type.  If not specified, text/html is assumed.
.IP "\fImultipart_end()\fR" 4
.IX Item "multipart_end()"
.Vb 1
\&  multipart_end()
.Ve
.Sp
End a part.  You must remember to call \fImultipart_end()\fR once for each
\&\fImultipart_start()\fR, except at the end of the last part of the multipart
document when \fImultipart_final()\fR should be called instead of \fImultipart_end()\fR.
.IP "\fImultipart_final()\fR" 4
.IX Item "multipart_final()"
.Vb 1
\&  multipart_final()
.Ve
.Sp
End all parts.  You should call \fImultipart_final()\fR rather than
\&\fImultipart_end()\fR at the end of the last part of the multipart document.
.PP
Users interested in server push applications should also have a look
at the CGI::Push module.
.SH "Avoiding Denial of Service Attacks"
.IX Header "Avoiding Denial of Service Attacks"
A potential problem with \s-1CGI\s0.pm is that, by default, it attempts to
process form POSTings no matter how large they are.  A wily hacker
could attack your site by sending a \s-1CGI\s0 script a huge \s-1POST\s0 of many
megabytes.  \s-1CGI\s0.pm will attempt to read the entire \s-1POST\s0 into a
variable, growing hugely in size until it runs out of memory.  While
the script attempts to allocate the memory the system may slow down
dramatically.  This is a form of denial of service attack.
.PP
Another possible attack is for the remote user to force \s-1CGI\s0.pm to
accept a huge file upload.  \s-1CGI\s0.pm will accept the upload and store it
in a temporary directory even if your script doesn't expect to receive
an uploaded file.  \s-1CGI\s0.pm will delete the file automatically when it
terminates, but in the meantime the remote user may have filled up the
server's disk space, causing problems for other programs.
.PP
The best way to avoid denial of service attacks is to limit the amount
of memory, \s-1CPU\s0 time and disk space that \s-1CGI\s0 scripts can use.  Some Web
servers come with built-in facilities to accomplish this. In other
cases, you can use the shell \fIlimit\fR or \fIulimit\fR
commands to put ceilings on \s-1CGI\s0 resource usage.
.PP
\&\s-1CGI\s0.pm also has some simple built-in protections against denial of
service attacks, but you must activate them before you can use them.
These take the form of two global variables in the \s-1CGI\s0 name space:
.ie n .IP "\fB\fB$CGI::POST_MAX\fB\fR" 4
.el .IP "\fB\f(CB$CGI::POST_MAX\fB\fR" 4
.IX Item "$CGI::POST_MAX"
If set to a non-negative integer, this variable puts a ceiling
on the size of POSTings, in bytes.  If \s-1CGI\s0.pm detects a \s-1POST\s0
that is greater than the ceiling, it will immediately exit with an error
message.  This value will affect both ordinary POSTs and
multipart POSTs, meaning that it limits the maximum size of file
uploads as well.  You should set this to a reasonably high
value, such as 1 megabyte.
.ie n .IP "\fB\fB$CGI::DISABLE_UPLOADS\fB\fR" 4
.el .IP "\fB\f(CB$CGI::DISABLE_UPLOADS\fB\fR" 4
.IX Item "$CGI::DISABLE_UPLOADS"
If set to a non-zero value, this will disable file uploads
completely.  Other fill-out form values will work as usual.
.PP
You can use these variables in either of two ways.
.IP "\fB1. On a script-by-script basis\fR" 4
.IX Item "1. On a script-by-script basis"
Set the variable at the top of the script, right after the \*(L"use\*(R" statement:
.Sp
.Vb 4
\&    use CGI qw/:standard/;
\&    use CGI::Carp \*(AqfatalsToBrowser\*(Aq;
\&    $CGI::POST_MAX=1024 * 100;  # max 100K posts
\&    $CGI::DISABLE_UPLOADS = 1;  # no uploads
.Ve
.IP "\fB2. Globally for all scripts\fR" 4
.IX Item "2. Globally for all scripts"
Open up \s-1CGI\s0.pm, find the definitions for \f(CW$POST_MAX\fR and 
\&\f(CW$DISABLE_UPLOADS\fR, and set them to the desired values.  You'll 
find them towards the top of the file in a subroutine named 
\&\fIinitialize_globals()\fR.
.PP
An attempt to send a \s-1POST\s0 larger than \f(CW$POST_MAX\fR bytes will cause
\&\fI\fIparam()\fI\fR to return an empty \s-1CGI\s0 parameter list.  You can test for
this event by checking \fI\fIcgi_error()\fI\fR, either after you create the \s-1CGI\s0
object or, if you are using the function-oriented interface, call
<\fIparam()\fR> for the first time.  If the \s-1POST\s0 was intercepted, then
\&\fIcgi_error()\fR will return the message \*(L"413 \s-1POST\s0 too large\*(R".
.PP
This error message is actually defined by the \s-1HTTP\s0 protocol, and is
designed to be returned to the browser as the \s-1CGI\s0 script's status
 code.  For example:
.PP
.Vb 5
\&   $uploaded_file = param(\*(Aqupload\*(Aq);
\&   if (!$uploaded_file && cgi_error()) {
\&      print header(\-status=>cgi_error());
\&      exit 0;
\&   }
.Ve
.PP
However it isn't clear that any browser currently knows what to do
with this status code.  It might be better just to create an
\&\s-1HTML\s0 page that warns the user of the problem.
.SH "COMPATIBILITY WITH CGI\-LIB.PL"
.IX Header "COMPATIBILITY WITH CGI-LIB.PL"
To make it easier to port existing programs that use cgi\-lib.pl the
compatibility routine \*(L"ReadParse\*(R" is provided.  Porting is simple:
.PP
\&\s-1OLD VERSION\s0
.PP
.Vb 3
\&    require "cgi\-lib.pl";
\&    &ReadParse;
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1NEW VERSION\s0
.PP
.Vb 3
\&    use CGI;
\&    CGI::ReadParse();
\&    print "The value of the antique is $in{antique}.\en";
.Ve
.PP
\&\s-1CGI\s0.pm's \fIReadParse()\fR routine creates a tied variable named \f(CW%in\fR,
which can be accessed to obtain the query variables.  Like
ReadParse, you can also provide your own variable.  Infrequently
used features of ReadParse, such as the creation of \f(CW@in\fR and \f(CW$in\fR
variables, are not supported.
.PP
Once you use ReadParse, you can retrieve the query object itself
this way:
.PP
.Vb 3
\&    $q = $in{CGI};
\&    print $q\->textfield(\-name=>\*(Aqwow\*(Aq,
\&            \-value=>\*(Aqdoes this really work?\*(Aq);
.Ve
.PP
This allows you to start using the more interesting features
of \s-1CGI\s0.pm without rewriting your old scripts from scratch.
.PP
An even simpler way to mix cgi-lib calls with \s-1CGI\s0.pm calls is to import both the
\&\f(CW\*(C`:cgi\-lib\*(C'\fR and \f(CW\*(C`:standard\*(C'\fR method:
.PP
.Vb 4
\& use CGI qw(:cgi\-lib :standard);
\& &ReadParse;
\& print "The price of your purchase is $in{price}.\en";
\& print textfield(\-name=>\*(Aqprice\*(Aq, \-default=>\*(Aq$1.99\*(Aq);
.Ve
.SS "Cgi-lib functions that are available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are available in CGI.pm"
In compatibility mode, the following cgi\-lib.pl functions are
available for your use:
.PP
.Vb 7
\& ReadParse()
\& PrintHeader()
\& HtmlTop()
\& HtmlBot()
\& SplitParam()
\& MethGet()
\& MethPost()
.Ve
.SS "Cgi-lib functions that are not available in \s-1CGI\s0.pm"
.IX Subsection "Cgi-lib functions that are not available in CGI.pm"
.Vb 3
\&  * Extended form of ReadParse()
\&    The extended form of ReadParse() that provides for file upload
\&    spooling, is not available.
\&
\&  * MyBaseURL()
\&    This function is not available.  Use CGI.pm\*(Aqs url() method instead.
\&
\&  * MyFullURL()
\&    This function is not available.  Use CGI.pm\*(Aqs self_url() method
\&    instead.
\&
\&  * CgiError(), CgiDie()
\&    These functions are not supported.  Look at CGI::Carp for the way I
\&    prefer to handle error messages.
\&
\&  * PrintVariables()
\&    This function is not available.  To achieve the same effect,
\&       just print out the CGI object:
\&
\&       use CGI qw(:standard);
\&       $q = CGI\->new;
\&       print h1("The Variables Are"),$q;
\&
\&  * PrintEnv()
\&    This function is not available. You\*(Aqll have to roll your own if you really need it.
.Ve
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
The \s-1CGI\s0.pm distribution is copyright 1995\-2007, Lincoln D. Stein. It is
distributed under \s-1GPL\s0 and the Artistic License 2.0. It is currently
maintained by Mark Stosberg with help from many contributors.
.PP
Address bug reports and comments to: https://rt.cpan.org/Public/Dist/Display.html?Queue=CGI.pm
When sending bug reports, please provide the version of \s-1CGI\s0.pm, the version of
Perl, the name and version of your Web server, and the name and version of the
operating system you are using.  If the problem is even remotely browser
dependent, please provide information about the affected browsers as well.
.SH "CREDITS"
.IX Header "CREDITS"
Thanks very much to:
.IP "Matt Heffron (heffron@falstaff.css.beckman.com)" 4
.IX Item "Matt Heffron (heffron@falstaff.css.beckman.com)"
.PD 0
.IP "James Taylor (james.taylor@srs.gov)" 4
.IX Item "James Taylor (james.taylor@srs.gov)"
.IP "Scott Anguish <sanguish@digifix.com>" 4
.IX Item "Scott Anguish <sanguish@digifix.com>"
.IP "Mike Jewell (mlj3u@virginia.edu)" 4
.IX Item "Mike Jewell (mlj3u@virginia.edu)"
.IP "Timothy Shimmin (tes@kbs.citri.edu.au)" 4
.IX Item "Timothy Shimmin (tes@kbs.citri.edu.au)"
.IP "Joergen Haegg (jh@axis.se)" 4
.IX Item "Joergen Haegg (jh@axis.se)"
.IP "Laurent Delfosse (delfosse@delfosse.com)" 4
.IX Item "Laurent Delfosse (delfosse@delfosse.com)"
.IP "Richard Resnick (applepi1@aol.com)" 4
.IX Item "Richard Resnick (applepi1@aol.com)"
.IP "Craig Bishop (csb@barwonwater.vic.gov.au)" 4
.IX Item "Craig Bishop (csb@barwonwater.vic.gov.au)"
.IP "Tony Curtis (tc@vcpc.univie.ac.at)" 4
.IX Item "Tony Curtis (tc@vcpc.univie.ac.at)"
.IP "Tim Bunce (Tim.Bunce@ig.co.uk)" 4
.IX Item "Tim Bunce (Tim.Bunce@ig.co.uk)"
.IP "Tom Christiansen (tchrist@convex.com)" 4
.IX Item "Tom Christiansen (tchrist@convex.com)"
.IP "Andreas Koenig (k@franz.ww.TU\-Berlin.DE)" 4
.IX Item "Andreas Koenig (k@franz.ww.TU-Berlin.DE)"
.IP "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)" 4
.IX Item "Tim MacKenzie (Tim.MacKenzie@fulcrum.com.au)"
.IP "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)" 4
.IX Item "Kevin B. Hendricks (kbhend@dogwood.tyler.wm.edu)"
.IP "Stephen Dahmen (joyfire@inxpress.net)" 4
.IX Item "Stephen Dahmen (joyfire@inxpress.net)"
.IP "Ed Jordan (ed@fidalgo.net)" 4
.IX Item "Ed Jordan (ed@fidalgo.net)"
.IP "David Alan Pisoni (david@cnation.com)" 4
.IX Item "David Alan Pisoni (david@cnation.com)"
.IP "Doug MacEachern (dougm@opengroup.org)" 4
.IX Item "Doug MacEachern (dougm@opengroup.org)"
.IP "Robin Houston (robin@oneworld.org)" 4
.IX Item "Robin Houston (robin@oneworld.org)"
.IP "...and many many more..." 4
.IX Item "...and many many more..."
.PD
for suggestions and bug fixes.
.SH "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.IX Header "A COMPLETE EXAMPLE OF A SIMPLE FORM-BASED SCRIPT"
.Vb 1
\&        #!/usr/local/bin/perl
\&
\&        use CGI \*(Aq:standard\*(Aq;
\&
\&        print header;
\&        print start_html("Example CGI.pm Form");
\&        print "<h1> Example CGI.pm Form</h1>\en";
\&        print_prompt();
\&        do_work();
\&        print_tail();
\&        print end_html;
\&
\&        sub print_prompt {
\&           print start_form;
\&           print "<em>What\*(Aqs your name?</em><br>";
\&           print textfield(\*(Aqname\*(Aq);
\&           print checkbox(\*(AqNot my real name\*(Aq);
\&
\&           print "<p><em>Where can you find English Sparrows?</em><br>";
\&           print checkbox_group(
\&                                 \-name=>\*(AqSparrow locations\*(Aq,
\&                                 \-values=>[England,France,Spain,Asia,Hoboken],
\&                                 \-linebreak=>\*(Aqyes\*(Aq,
\&                                 \-defaults=>[England,Asia]);
\&
\&           print "<p><em>How far can they fly?</em><br>",
\&                radio_group(
\&                        \-name=>\*(Aqhow far\*(Aq,
\&                        \-values=>[\*(Aq10 ft\*(Aq,\*(Aq1 mile\*(Aq,\*(Aq10 miles\*(Aq,\*(Aqreal far\*(Aq],
\&                        \-default=>\*(Aq1 mile\*(Aq);
\&
\&           print "<p><em>What\*(Aqs your favorite color?</em>  ";
\&           print popup_menu(\-name=>\*(AqColor\*(Aq,
\&                                    \-values=>[\*(Aqblack\*(Aq,\*(Aqbrown\*(Aq,\*(Aqred\*(Aq,\*(Aqyellow\*(Aq],
\&                                    \-default=>\*(Aqred\*(Aq);
\&
\&           print hidden(\*(AqReference\*(Aq,\*(AqMonty Python and the Holy Grail\*(Aq);
\&
\&           print "<p><em>What have you got there?</em><br>";
\&           print scrolling_list(
\&                         \-name=>\*(Aqpossessions\*(Aq,
\&                         \-values=>[\*(AqA Coconut\*(Aq,\*(AqA Grail\*(Aq,\*(AqAn Icon\*(Aq,
\&                                   \*(AqA Sword\*(Aq,\*(AqA Ticket\*(Aq],
\&                         \-size=>5,
\&                         \-multiple=>\*(Aqtrue\*(Aq);
\&
\&           print "<p><em>Any parting comments?</em><br>";
\&           print textarea(\-name=>\*(AqComments\*(Aq,
\&                                  \-rows=>10,
\&                                  \-columns=>50);
\&
\&           print "<p>",reset;
\&           print submit(\*(AqAction\*(Aq,\*(AqShout\*(Aq);
\&           print submit(\*(AqAction\*(Aq,\*(AqScream\*(Aq);
\&           print end_form;
\&           print "<hr>\en";
\&        }
\&
\&        sub do_work {
\&
\&           print "<h2>Here are the current settings in this form</h2>";
\&
\&           for my $key (param) {
\&              print "<strong>$key</strong> \-> ";
\&              my @values = param($key);
\&              print join(", ",@values),"<br>\en";
\&          }
\&        }
\&
\&        sub print_tail {
\&           print <<END;
\&        <hr>
\&        <address>Lincoln D. Stein</address><br>
\&        <a href="/">Home Page</a>
\&        END
\&        }
.Ve
.SH "BUGS"
.IX Header "BUGS"
Please report them.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
CGI::Carp \- provides a Carp implementation tailored to the \s-1CGI\s0 environment.
.PP
CGI::Fast \- supports running \s-1CGI\s0 applications under FastCGI
.PP
CGI::Pretty \- pretty prints \s-1HTML\s0 generated by \s-1CGI\s0.pm (with a performance penalty)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 5513:" 4
.IX Item "Around line 5513:"
Expected text after =item, not a number
.IP "Around line 5517:" 4
.IX Item "Around line 5517:"
Expected text after =item, not a number
.IP "Around line 5521:" 4
.IX Item "Around line 5521:"
Expected text after =item, not a number
.IP "Around line 6083:" 4
.IX Item "Around line 6083:"
Expected text after =item, not a number
.IP "Around line 6087:" 4
.IX Item "Around line 6087:"
Expected text after =item, not a number
.IP "Around line 6092:" 4
.IX Item "Around line 6092:"
Expected text after =item, not a number
.IP "Around line 6097:" 4
.IX Item "Around line 6097:"
Expected text after =item, not a number
.IP "Around line 6166:" 4
.IX Item "Around line 6166:"
Expected text after =item, not a number
.IP "Around line 6170:" 4
.IX Item "Around line 6170:"
Expected text after =item, not a number
.IP "Around line 6181:" 4
.IX Item "Around line 6181:"
Expected text after =item, not a number
.IP "Around line 6186:" 4
.IX Item "Around line 6186:"
Expected text after =item, not a number
.IP "Around line 6521:" 4
.IX Item "Around line 6521:"
Expected text after =item, not a number
.IP "Around line 6527:" 4
.IX Item "Around line 6527:"
Expected text after =item, not a number
.IP "Around line 6536:" 4
.IX Item "Around line 6536:"
Expected text after =item, not a number
.IP "Around line 6540:" 4
.IX Item "Around line 6540:"
Expected text after =item, not a number
.IP "Around line 6546:" 4
.IX Item "Around line 6546:"
Expected text after =item, not a number
.IP "Around line 6552:" 4
.IX Item "Around line 6552:"
Expected text after =item, not a number
.IP "Around line 6597:" 4
.IX Item "Around line 6597:"
Expected text after =item, not a number
.IP "Around line 6605:" 4
.IX Item "Around line 6605:"
Expected text after =item, not a number
.IP "Around line 6612:" 4
.IX Item "Around line 6612:"
Expected text after =item, not a number
.IP "Around line 6690:" 4
.IX Item "Around line 6690:"
Expected text after =item, not a number
.IP "Around line 6696:" 4
.IX Item "Around line 6696:"
Expected text after =item, not a number
.IP "Around line 6701:" 4
.IX Item "Around line 6701:"
Expected text after =item, not a number
.IP "Around line 6707:" 4
.IX Item "Around line 6707:"
Expected text after =item, not a number
.IP "Around line 6747:" 4
.IX Item "Around line 6747:"
Expected text after =item, not a number
.IP "Around line 6751:" 4
.IX Item "Around line 6751:"
Expected text after =item, not a number
.IP "Around line 6759:" 4
.IX Item "Around line 6759:"
Expected text after =item, not a number
.IP "Around line 6766:" 4
.IX Item "Around line 6766:"
Expected text after =item, not a number
.IP "Around line 6771:" 4
.IX Item "Around line 6771:"
Expected text after =item, not a number
.IP "Around line 6847:" 4
.IX Item "Around line 6847:"
Expected text after =item, not a number
.IP "Around line 6853:" 4
.IX Item "Around line 6853:"
Expected text after =item, not a number
.IP "Around line 6859:" 4
.IX Item "Around line 6859:"
Expected text after =item, not a number
.IP "Around line 6908:" 4
.IX Item "Around line 6908:"
Expected text after =item, not a number
.IP "Around line 6913:" 4
.IX Item "Around line 6913:"
Expected text after =item, not a number
.IP "Around line 6951:" 4
.IX Item "Around line 6951:"
Expected text after =item, not a number
.IP "Around line 6956:" 4
.IX Item "Around line 6956:"
Expected text after =item, not a number
                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI::Apache.3pm                              0100644 0001750 0001750 00000010410 12566207451 023165  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Apache 3pm"
.TH CGI::Apache 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Apache \- Backward compatibility module for CGI.pm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Do not use this module.  It is deprecated.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI::Apache5.16.3pm                          0100644 0001750 0001750 00000010067 12566207430 023504  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Apache 3pm"
.TH CGI::Apache 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Apache \- Backward compatibility module for CGI.pm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Do not use this module.  It is deprecated.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI::Apache5.18.3pm                          0100644 0001750 0001750 00000010410 12566207451 023501  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Apache 3pm"
.TH CGI::Apache 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Apache \- Backward compatibility module for CGI.pm
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Do not use this module.  It is deprecated.
.SH "ABSTRACT"
.IX Header "ABSTRACT"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SH "AUTHOR INFORMATION"
.IX Header "AUTHOR INFORMATION"
.SH "BUGS"
.IX Header "BUGS"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/CGI::Carp.3pm                                0100644 0001750 0001750 00000041044 12566207451 022700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CGI::Carp 3pm"
.TH CGI::Carp 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
CGI::Carp \- CGI routines for writing to the HTTPD (or other) error log
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use CGI::Carp;
\&
\&    croak "We\*(Aqre outta here!";
\&    confess "It was my fault: $!";
\&    carp "It was your fault!";   
\&    warn "I\*(Aqm confused";
\&    die  "I\*(Aqm dying.\en";
\&
\&    use CGI::Carp qw(cluck);
\&    cluck "I wouldn\*(Aqt do that if I were you";
\&
\&    use CGI::Carp qw(fatalsToBrowser);
\&    die "Fatal error messages are now sent to browser";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1CGI\s0 scripts have a nasty habit of leaving warning messages in the error
logs that are neither time stamped nor fully identified.  Tracking down
the script that caused the error is a pain.  This fixes that.  Replace
the usual
.PP
.Vb 1
\&    use Carp;
.Ve
.PP
with
.PP
.Vb 1
\&    use CGI::Carp
.Ve
.PP
The standard \fIwarn()\fR, die (), \fIcroak()\fR, \fIconfess()\fR and \fIcarp()\fR calls will
be replaced with functions that write time-stamped messages to the
\&\s-1HTTP\s0 server error log.
.PP
For example:
.PP
.Vb 3
\&   [Fri Nov 17 21:40:43 1995] test.pl: I\*(Aqm confused at test.pl line 3.
\&   [Fri Nov 17 21:40:43 1995] test.pl: Got an error message: Permission denied.
\&   [Fri Nov 17 21:40:43 1995] test.pl: I\*(Aqm dying.
.Ve
.SH "REDIRECTING ERROR MESSAGES"
.IX Header "REDIRECTING ERROR MESSAGES"
By default, error messages are sent to \s-1STDERR. \s0 Most \s-1HTTPD\s0 servers
direct \s-1STDERR\s0 to the server's error log.  Some applications may wish
to keep private error logs, distinct from the server's error log, or
they may wish to direct error messages to \s-1STDOUT\s0 so that the browser
will receive them.
.PP
The \f(CW\*(C`carpout()\*(C'\fR function is provided for this purpose.  Since
\&\fIcarpout()\fR is not exported by default, you must import it explicitly by
saying
.PP
.Vb 1
\&   use CGI::Carp qw(carpout);
.Ve
.PP
The \fIcarpout()\fR function requires one argument, a reference to an open
filehandle for writing errors.  It should be called in a \f(CW\*(C`BEGIN\*(C'\fR
block at the top of the \s-1CGI\s0 application so that compiler errors will
be caught.  Example:
.PP
.Vb 6
\&   BEGIN {
\&     use CGI::Carp qw(carpout);
\&     open(LOG, ">>/usr/local/cgi\-logs/mycgi\-log") or
\&       die("Unable to open mycgi\-log: $!\en");
\&     carpout(LOG);
\&   }
.Ve
.PP
\&\fIcarpout()\fR does not handle file locking on the log for you at this
point.  Also, note that \fIcarpout()\fR does not work with in-memory file
handles, although a patch would be welcome to address that.
.PP
The real \s-1STDERR\s0 is not closed \*(-- it is moved to CGI::Carp::SAVEERR.
Some servers, when dealing with \s-1CGI\s0 scripts, close their connection to
the browser when the script closes \s-1STDOUT\s0 and \s-1STDERR.\s0
CGI::Carp::SAVEERR is there to prevent this from happening
prematurely.
.PP
You can pass filehandles to \fIcarpout()\fR in a variety of ways.  The \*(L"correct\*(R"
way according to Tom Christiansen is to pass a reference to a filehandle
\&\s-1GLOB:\s0
.PP
.Vb 1
\&    carpout(\e*LOG);
.Ve
.PP
This looks weird to mere mortals however, so the following syntaxes are
accepted as well:
.PP
.Vb 5
\&    carpout(LOG);
\&    carpout(main::LOG);
\&    carpout(main\*(AqLOG);
\&    carpout(\eLOG);
\&    carpout(\e\*(Aqmain::LOG\*(Aq);
\&
\&    ... and so on
.Ve
.PP
FileHandle and other objects work as well.
.PP
Use of \fIcarpout()\fR is not great for performance, so it is recommended
for debugging purposes or for moderate-use applications.  A future
version of this module may delay redirecting \s-1STDERR\s0 until one of the
CGI::Carp methods is called to prevent the performance hit.
.SH "MAKING PERL ERRORS APPEAR IN THE BROWSER WINDOW"
.IX Header "MAKING PERL ERRORS APPEAR IN THE BROWSER WINDOW"
If you want to send fatal (die, confess) errors to the browser, import
the special \*(L"fatalsToBrowser\*(R" subroutine:
.PP
.Vb 2
\&    use CGI::Carp qw(fatalsToBrowser);
\&    die "Bad error here";
.Ve
.PP
Fatal errors will now be echoed to the browser as well as to the log.
CGI::Carp arranges to send a minimal \s-1HTTP\s0 header to the browser so
that even errors that occur in the early compile phase will be seen.
Nonfatal errors will still be directed to the log file only (unless
redirected with carpout).
.PP
Note that fatalsToBrowser may \fBnot\fR work well with mod_perl version 2.0
and higher.
.SS "Changing the default message"
.IX Subsection "Changing the default message"
By default, the software error message is followed by a note to
contact the Webmaster by e\-mail with the time and date of the error.
If this message is not to your liking, you can change it using the
\&\fIset_message()\fR routine.  This is not imported by default; you should
import it on the \fIuse()\fR line:
.PP
.Vb 2
\&    use CGI::Carp qw(fatalsToBrowser set_message);
\&    set_message("It\*(Aqs not a bug, it\*(Aqs a feature!");
.Ve
.PP
You may also pass in a code reference in order to create a custom
error message.  At run time, your code will be called with the text
of the error message that caused the script to die.  Example:
.PP
.Vb 9
\&    use CGI::Carp qw(fatalsToBrowser set_message);
\&    BEGIN {
\&       sub handle_errors {
\&          my $msg = shift;
\&          print "<h1>Oh gosh</h1>";
\&          print "<p>Got an error: $msg</p>";
\&      }
\&      set_message(\e&handle_errors);
\&    }
.Ve
.PP
In order to correctly intercept compile-time errors, you should call
\&\fIset_message()\fR from within a BEGIN{} block.
.SH "DOING MORE THAN PRINTING A MESSAGE IN THE EVENT OF PERL ERRORS"
.IX Header "DOING MORE THAN PRINTING A MESSAGE IN THE EVENT OF PERL ERRORS"
If fatalsToBrowser in conjunction with set_message does not provide 
you with all of the functionality you need, you can go one step 
further by specifying a function to be executed any time a script
calls \*(L"die\*(R", has a syntax error, or dies unexpectedly at runtime
with a line like \*(L"undef\->\fIexplode()\fR;\*(R".
.PP
.Vb 7
\&    use CGI::Carp qw(set_die_handler);
\&    BEGIN {
\&       sub handle_errors {
\&          my $msg = shift;
\&          print "content\-type: text/html\en\en";
\&          print "<h1>Oh gosh</h1>";
\&          print "<p>Got an error: $msg</p>";
\&
\&          #proceed to send an email to a system administrator,
\&          #write a detailed message to the browser and/or a log,
\&          #etc....
\&      }
\&      set_die_handler(\e&handle_errors);
\&    }
.Ve
.PP
Notice that if you use \fIset_die_handler()\fR, you must handle sending
\&\s-1HTML\s0 headers to the browser yourself if you are printing a message.
.PP
If you use \fIset_die_handler()\fR, you will most likely interfere with 
the behavior of fatalsToBrowser, so you must use this or that, not 
both.
.PP
Using \fIset_die_handler()\fR sets SIG{_\|_DIE_\|_} (as does fatalsToBrowser),
and there is only one SIG{_\|_DIE_\|_}. This means that if you are 
attempting to set SIG{_\|_DIE_\|_} yourself, you may interfere with 
this module's functionality, or this module may interfere with 
your module's functionality.
.SS "\s-1SUPPRESSING PERL ERRORS APPEARING IN THE BROWSER WINDOW\s0"
.IX Subsection "SUPPRESSING PERL ERRORS APPEARING IN THE BROWSER WINDOW"
A problem sometimes encountered when using fatalsToBrowser is
when a \f(CW\*(C`die()\*(C'\fR is done inside an \f(CW\*(C`eval\*(C'\fR body or expression.
Even though the
fatalsToBrower support takes precautions to avoid this,
you still may get the error message printed to \s-1STDOUT.\s0
This may have some undesireable effects when the purpose of doing the
eval is to determine which of several algorithms is to be used.
.PP
By setting \f(CW$CGI::Carp::TO_BROWSER\fR to 0 you can suppress printing
the \f(CW\*(C`die\