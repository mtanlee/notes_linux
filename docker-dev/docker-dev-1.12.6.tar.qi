925,
	0xC4, 6954,
	0xC5, 6976,
	0xC6, 6998,
	0xC7, 7020,
	0xc8, 7149,
	0xc9, 7149,
	0xca, 7149,
	0xcb, 7149,
	0xcc, 7149,
	0xcd, 7149,
	0xce, 7149,
	0xcf, 7149,
	0xD0, 7172,
	0xD1, 7190,
	0xD2, 7208,
	0xD3, 7226,
	0xD4, 7244,
	0xD5, 7262,
	0xD6, 7280,
	0xD7, 7306,
	0xD8, 7324,
	0xD9, 7342,
	0xDA, 7360,
	0xDB, 7378,
	0xDC, 7396,
	0xDD, 7414,
	0xDE, 7432,
	0xDF, 7450,
	0xE0, 7468,
	0xE1, 7486,
	0xE2, 7504,
	0xE3, 7522,
	0xE4, 7540,
	0xE5, 7558,
	0xE6, 7576,
	0xE7, 7602,
	0xE8, 7620,
	0xE9, 7638,
	0xEA, 7656,
	0xEB, 7674,
	0xEC, 7692,
	0xED, 7710,
	0xEE, 7728,
	0xEF, 7746,
	0xF0, 7764,
	0xF1, 7774,
	0xF2, 7792,
	0xF3, 7810,
	0xF4, 7828,
	0xF5, 7846,
	0xF6, 7864,
	0xF7, 7882,
	0xF8, 7900,
	0xF9, 7918,
	0xFA, 7936,
	0xFB, 7954,
	0xFC, 7972,
	0xFD, 7990,
	0xFE, 8008,
	uint16(xFail),
	/*1180*/ uint16(xCondSlashR),
	1189, // 0
	1205, // 1
	1221, // 2
	1225, // 3
	1229, // 4
	1233, // 5
	0,    // 6
	0,    // 7
	/*1189*/ uint16(xCondDataSize), 1193, 1197, 1201,
	/*1193*/ uint16(xSetOp), uint16(SLDT),
	/*1195*/ uint16(xArgRM16),
	/*1196*/ uint16(xMatch),
	/*1197*/ uint16(xSetOp), uint16(SLDT),
	/*1199*/ uint16(xArgR32M16),
	/*1200*/ uint16(xMatch),
	/*1201*/ uint16(xSetOp), uint16(SLDT),
	/*1203*/ uint16(xArgR64M16),
	/*1204*/ uint16(xMatch),
	/*1205*/ uint16(xCondDataSize), 1209, 1213, 1217,
	/*1209*/ uint16(xSetOp), uint16(STR),
	/*1211*/ uint16(xArgRM16),
	/*1212*/ uint16(xMatch),
	/*1213*/ uint16(xSetOp), uint16(STR),
	/*1215*/ uint16(xArgR32M16),
	/*1216*/ uint16(xMatch),
	/*1217*/ uint16(xSetOp), uint16(STR),
	/*1219*/ uint16(xArgR64M16),
	/*1220*/ uint16(xMatch),
	/*1221*/ uint16(xSetOp), uint16(LLDT),
	/*1223*/ uint16(xArgRM16),
	/*1224*/ uint16(xMatch),
	/*1225*/ uint16(xSetOp), uint16(LTR),
	/*1227*/ uint16(xArgRM16),
	/*1228*/ uint16(xMatch),
	/*1229*/ uint16(xSetOp), uint16(VERR),
	/*1231*/ uint16(xArgRM16),
	/*1232*/ uint16(xMatch),
	/*1233*/ uint16(xSetOp), uint16(VERW),
	/*1235*/ uint16(xArgRM16),
	/*1236*/ uint16(xMatch),
	/*1237*/ uint16(xCondByte), 8,
	0xC8, 1318,
	0xC9, 1321,
	0xD0, 1324,
	0xD1, 1327,
	0xD5, 1330,
	0xD6, 1333,
	0xF8, 1336,
	0xF9, 1342,
	/*1255*/ uint16(xCondSlashR),
	1264, // 0
	1268, // 1
	1272, // 2
	1283, // 3
	1294, // 4
	0,    // 5
	1310, // 6
	1314, // 7
	/*1264*/ uint16(xSetOp), uint16(SGDT),
	/*1266*/ uint16(xArgM),
	/*1267*/ uint16(xMatch),
	/*1268*/ uint16(xSetOp), uint16(SIDT),
	/*1270*/ uint16(xArgM),
	/*1271*/ uint16(xMatch),
	/*1272*/ uint16(xCondIs64), 1275, 1279,
	/*1275*/ uint16(xSetOp), uint16(LGDT),
	/*1277*/ uint16(xArgM16and32),
	/*1278*/ uint16(xMatch),
	/*1279*/ uint16(xSetOp), uint16(LGDT),
	/*1281*/ uint16(xArgM16and64),
	/*1282*/ uint16(xMatch),
	/*1283*/ uint16(xCondIs64), 1286, 1290,
	/*1286*/ uint16(xSetOp), uint16(LIDT),
	/*1288*/ uint16(xArgM16and32),
	/*1289*/ uint16(xMatch),
	/*1290*/ uint16(xSetOp), uint16(LIDT),
	/*1292*/ uint16(xArgM16and64),
	/*1293*/ uint16(xMatch),
	/*1294*/ uint16(xCondDataSize), 1298, 1302, 1306,
	/*1298*/ uint16(xSetOp), uint16(SMSW),
	/*1300*/ uint16(xArgRM16),
	/*1301*/ uint16(xMatch),
	/*1302*/ uint16(xSetOp), uint16(SMSW),
	/*1304*/ uint16(xArgR32M16),
	/*1305*/ uint16(xMatch),
	/*1306*/ uint16(xSetOp), uint16(SMSW),
	/*1308*/ uint16(xArgR64M16),
	/*1309*/ uint16(xMatch),
	/*1310*/ uint16(xSetOp), uint16(LMSW),
	/*1312*/ uint16(xArgRM16),
	/*1313*/ uint16(xMatch),
	/*1314*/ uint16(xSetOp), uint16(INVLPG),
	/*1316*/ uint16(xArgM),
	/*1317*/ uint16(xMatch),
	/*1318*/ uint16(xSetOp), uint16(MONITOR),
	/*1320*/ uint16(xMatch),
	/*1321*/ uint16(xSetOp), uint16(MWAIT),
	/*1323*/ uint16(xMatch),
	/*1324*/ uint16(xSetOp), uint16(XGETBV),
	/*1326*/ uint16(xMatch),
	/*1327*/ uint16(xSetOp), uint16(XSETBV),
	/*1329*/ uint16(xMatch),
	/*1330*/ uint16(xSetOp), uint16(XEND),
	/*1332*/ uint16(xMatch),
	/*1333*/ uint16(xSetOp), uint16(XTEST),
	/*1335*/ uint16(xMatch),
	/*1336*/ uint16(xCondIs64), 0, 1339,
	/*1339*/ uint16(xSetOp), uint16(SWAPGS),
	/*1341*/ uint16(xMatch),
	/*1342*/ uint16(xSetOp), uint16(RDTSCP),
	/*1344*/ uint16(xMatch),
	/*1345*/ uint16(xCondDataSize), 1349, 1355, 1361,
	/*1349*/ uint16(xSetOp), uint16(LAR),
	/*1351*/ uint16(xReadSlashR),
	/*1352*/ uint16(xArgR16),
	/*1353*/ uint16(xArgRM16),
	/*1354*/ uint16(xMatch),
	/*1355*/ uint16(xSetOp), uint16(LAR),
	/*1357*/ uint16(xReadSlashR),
	/*1358*/ uint16(xArgR32),
	/*1359*/ uint16(xArgR32M16),
	/*1360*/ uint16(xMatch),
	/*1361*/ uint16(xSetOp), uint16(LAR),
	/*1363*/ uint16(xReadSlashR),
	/*1364*/ uint16(xArgR64),
	/*1365*/ uint16(xArgR64M16),
	/*1366*/ uint16(xMatch),
	/*1367*/ uint16(xCondDataSize), 1371, 1377, 1383,
	/*1371*/ uint16(xSetOp), uint16(LSL),
	/*1373*/ uint16(xReadSlashR),
	/*1374*/ uint16(xArgR16),
	/*1375*/ uint16(xArgRM16),
	/*1376*/ uint16(xMatch),
	/*1377*/ uint16(xSetOp), uint16(LSL),
	/*1379*/ uint16(xReadSlashR),
	/*1380*/ uint16(xArgR32),
	/*1381*/ uint16(xArgR32M16),
	/*1382*/ uint16(xMatch),
	/*1383*/ uint16(xSetOp), uint16(LSL),
	/*1385*/ uint16(xReadSlashR),
	/*1386*/ uint16(xArgR64),
	/*1387*/ uint16(xArgR32M16),
	/*1388*/ uint16(xMatch),
	/*1389*/ uint16(xCondIs64), 0, 1392,
	/*1392*/ uint16(xSetOp), uint16(SYSCALL),
	/*1394*/ uint16(xMatch),
	/*1395*/ uint16(xSetOp), uint16(CLTS),
	/*1397*/ uint16(xMatch),
	/*1398*/ uint16(xCondIs64), 0, 1401,
	/*1401*/ uint16(xSetOp), uint16(SYSRET),
	/*1403*/ uint16(xMatch),
	/*1404*/ uint16(xSetOp), uint16(INVD),
	/*1406*/ uint16(xMatch),
	/*1407*/ uint16(xSetOp), uint16(WBINVD),
	/*1409*/ uint16(xMatch),
	/*1410*/ uint16(xSetOp), uint16(UD2),
	/*1412*/ uint16(xMatch),
	/*1413*/ uint16(xCondSlashR),
	0,    // 0
	1422, // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1422*/ uint16(xSetOp), uint16(PREFETCHW),
	/*1424*/ uint16(xArgM8),
	/*1425*/ uint16(xMatch),
	/*1426*/ uint16(xCondPrefix), 4,
	0xF3, 1454,
	0xF2, 1448,
	0x66, 1442,
	0x0, 1436,
	/*1436*/ uint16(xSetOp), uint16(MOVUPS),
	/*1438*/ uint16(xReadSlashR),
	/*1439*/ uint16(xArgXmm1),
	/*1440*/ uint16(xArgXmm2M128),
	/*1441*/ uint16(xMatch),
	/*1442*/ uint16(xSetOp), uint16(MOVUPD),
	/*1444*/ uint16(xReadSlashR),
	/*1445*/ uint16(xArgXmm1),
	/*1446*/ uint16(xArgXmm2M128),
	/*1447*/ uint16(xMatch),
	/*1448*/ uint16(xSetOp), uint16(MOVSD_XMM),
	/*1450*/ uint16(xReadSlashR),
	/*1451*/ uint16(xArgXmm1),
	/*1452*/ uint16(xArgXmm2M64),
	/*1453*/ uint16(xMatch),
	/*1454*/ uint16(xSetOp), uint16(MOVSS),
	/*1456*/ uint16(xReadSlashR),
	/*1457*/ uint16(xArgXmm1),
	/*1458*/ uint16(xArgXmm2M32),
	/*1459*/ uint16(xMatch),
	/*1460*/ uint16(xCondPrefix), 4,
	0xF3, 1488,
	0xF2, 1482,
	0x66, 1476,
	0x0, 1470,
	/*1470*/ uint16(xSetOp), uint16(MOVUPS),
	/*1472*/ uint16(xReadSlashR),
	/*1473*/ uint16(xArgXmm2M128),
	/*1474*/ uint16(xArgXmm1),
	/*1475*/ uint16(xMatch),
	/*1476*/ uint16(xSetOp), uint16(MOVUPD),
	/*1478*/ uint16(xReadSlashR),
	/*1479*/ uint16(xArgXmm2M128),
	/*1480*/ uint16(xArgXmm),
	/*1481*/ uint16(xMatch),
	/*1482*/ uint16(xSetOp), uint16(MOVSD_XMM),
	/*1484*/ uint16(xReadSlashR),
	/*1485*/ uint16(xArgXmm2M64),
	/*1486*/ uint16(xArgXmm1),
	/*1487*/ uint16(xMatch),
	/*1488*/ uint16(xSetOp), uint16(MOVSS),
	/*1490*/ uint16(xReadSlashR),
	/*1491*/ uint16(xArgXmm2M32),
	/*1492*/ uint16(xArgXmm),
	/*1493*/ uint16(xMatch),
	/*1494*/ uint16(xCondPrefix), 4,
	0xF3, 1531,
	0xF2, 1525,
	0x66, 1519,
	0x0, 1504,
	/*1504*/ uint16(xCondIsMem), 1507, 1513,
	/*1507*/ uint16(xSetOp), uint16(MOVHLPS),
	/*1509*/ uint16(xReadSlashR),
	/*1510*/ uint16(xArgXmm1),
	/*1511*/ uint16(xArgXmm2),
	/*1512*/ uint16(xMatch),
	/*1513*/ uint16(xSetOp), uint16(MOVLPS),
	/*1515*/ uint16(xReadSlashR),
	/*1516*/ uint16(xArgXmm),
	/*1517*/ uint16(xArgM64),
	/*1518*/ uint16(xMatch),
	/*1519*/ uint16(xSetOp), uint16(MOVLPD),
	/*1521*/ uint16(xReadSlashR),
	/*1522*/ uint16(xArgXmm),
	/*1523*/ uint16(xArgXmm2M64),
	/*1524*/ uint16(xMatch),
	/*1525*/ uint16(xSetOp), uint16(MOVDDUP),
	/*1527*/ uint16(xReadSlashR),
	/*1528*/ uint16(xArgXmm1),
	/*1529*/ uint16(xArgXmm2M64),
	/*1530*/ uint16(xMatch),
	/*1531*/ uint16(xSetOp), uint16(MOVSLDUP),
	/*1533*/ uint16(xReadSlashR),
	/*1534*/ uint16(xArgXmm1),
	/*1535*/ uint16(xArgXmm2M128),
	/*1536*/ uint16(xMatch),
	/*1537*/ uint16(xCondPrefix), 2,
	0x66, 1549,
	0x0, 1543,
	/*1543*/ uint16(xSetOp), uint16(MOVLPS),
	/*1545*/ uint16(xReadSlashR),
	/*1546*/ uint16(xArgM64),
	/*1547*/ uint16(xArgXmm),
	/*1548*/ uint16(xMatch),
	/*1549*/ uint16(xSetOp), uint16(MOVLPD),
	/*1551*/ uint16(xReadSlashR),
	/*1552*/ uint16(xArgXmm2M64),
	/*1553*/ uint16(xArgXmm),
	/*1554*/ uint16(xMatch),
	/*1555*/ uint16(xCondPrefix), 2,
	0x66, 1567,
	0x0, 1561,
	/*1561*/ uint16(xSetOp), uint16(UNPCKLPS),
	/*1563*/ uint16(xReadSlashR),
	/*1564*/ uint16(xArgXmm1),
	/*1565*/ uint16(xArgXmm2M128),
	/*1566*/ uint16(xMatch),
	/*1567*/ uint16(xSetOp), uint16(UNPCKLPD),
	/*1569*/ uint16(xReadSlashR),
	/*1570*/ uint16(xArgXmm1),
	/*1571*/ uint16(xArgXmm2M128),
	/*1572*/ uint16(xMatch),
	/*1573*/ uint16(xCondPrefix), 2,
	0x66, 1585,
	0x0, 1579,
	/*1579*/ uint16(xSetOp), uint16(UNPCKHPS),
	/*1581*/ uint16(xReadSlashR),
	/*1582*/ uint16(xArgXmm1),
	/*1583*/ uint16(xArgXmm2M128),
	/*1584*/ uint16(xMatch),
	/*1585*/ uint16(xSetOp), uint16(UNPCKHPD),
	/*1587*/ uint16(xReadSlashR),
	/*1588*/ uint16(xArgXmm1),
	/*1589*/ uint16(xArgXmm2M128),
	/*1590*/ uint16(xMatch),
	/*1591*/ uint16(xCondPrefix), 3,
	0xF3, 1620,
	0x66, 1614,
	0x0, 1599,
	/*1599*/ uint16(xCondIsMem), 1602, 1608,
	/*1602*/ uint16(xSetOp), uint16(MOVLHPS),
	/*1604*/ uint16(xReadSlashR),
	/*1605*/ uint16(xArgXmm1),
	/*1606*/ uint16(xArgXmm2),
	/*1607*/ uint16(xMatch),
	/*1608*/ uint16(xSetOp), uint16(MOVHPS),
	/*1610*/ uint16(xReadSlashR),
	/*1611*/ uint16(xArgXmm),
	/*1612*/ uint16(xArgM64),
	/*1613*/ uint16(xMatch),
	/*1614*/ uint16(xSetOp), uint16(MOVHPD),
	/*1616*/ uint16(xReadSlashR),
	/*1617*/ uint16(xArgXmm),
	/*1618*/ uint16(xArgXmm2M64),
	/*1619*/ uint16(xMatch),
	/*1620*/ uint16(xSetOp), uint16(MOVSHDUP),
	/*1622*/ uint16(xReadSlashR),
	/*1623*/ uint16(xArgXmm1),
	/*1624*/ uint16(xArgXmm2M128),
	/*1625*/ uint16(xMatch),
	/*1626*/ uint16(xCondPrefix), 2,
	0x66, 1638,
	0x0, 1632,
	/*1632*/ uint16(xSetOp), uint16(MOVHPS),
	/*1634*/ uint16(xReadSlashR),
	/*1635*/ uint16(xArgM64),
	/*1636*/ uint16(xArgXmm),
	/*1637*/ uint16(xMatch),
	/*1638*/ uint16(xSetOp), uint16(MOVHPD),
	/*1640*/ uint16(xReadSlashR),
	/*1641*/ uint16(xArgXmm2M64),
	/*1642*/ uint16(xArgXmm),
	/*1643*/ uint16(xMatch),
	/*1644*/ uint16(xCondSlashR),
	1653, // 0
	1657, // 1
	1661, // 2
	1665, // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1653*/ uint16(xSetOp), uint16(PREFETCHNTA),
	/*1655*/ uint16(xArgM8),
	/*1656*/ uint16(xMatch),
	/*1657*/ uint16(xSetOp), uint16(PREFETCHT0),
	/*1659*/ uint16(xArgM8),
	/*1660*/ uint16(xMatch),
	/*1661*/ uint16(xSetOp), uint16(PREFETCHT1),
	/*1663*/ uint16(xArgM8),
	/*1664*/ uint16(xMatch),
	/*1665*/ uint16(xSetOp), uint16(PREFETCHT2),
	/*1667*/ uint16(xArgM8),
	/*1668*/ uint16(xMatch),
	/*1669*/ uint16(xCondSlashR),
	1678, // 0
	0,    // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*1678*/ uint16(xCondDataSize), 1682, 1686, 0,
	/*1682*/ uint16(xSetOp), uint16(NOP),
	/*1684*/ uint16(xArgRM16),
	/*1685*/ uint16(xMatch),
	/*1686*/ uint16(xSetOp), uint16(NOP),
	/*1688*/ uint16(xArgRM32),
	/*1689*/ uint16(xMatch),
	/*1690*/ uint16(xCondIs64), 1693, 1699,
	/*1693*/ uint16(xSetOp), uint16(MOV),
	/*1695*/ uint16(xReadSlashR),
	/*1696*/ uint16(xArgRmf32),
	/*1697*/ uint16(xArgCR0dashCR7),
	/*1698*/ uint16(xMatch),
	/*1699*/ uint16(xSetOp), uint16(MOV),
	/*1701*/ uint16(xReadSlashR),
	/*1702*/ uint16(xArgRmf64),
	/*1703*/ uint16(xArgCR0dashCR7),
	/*1704*/ uint16(xMatch),
	/*1705*/ uint16(xCondIs64), 1708, 1714,
	/*1708*/ uint16(xSetOp), uint16(MOV),
	/*1710*/ uint16(xReadSlashR),
	/*1711*/ uint16(xArgRmf32),
	/*1712*/ uint16(xArgDR0dashDR7),
	/*1713*/ uint16(xMatch),
	/*1714*/ uint16(xSetOp), uint16(MOV),
	/*1716*/ uint16(xReadSlashR),
	/*1717*/ uint16(xArgRmf64),
	/*1718*/ uint16(xArgDR0dashDR7),
	/*1719*/ uint16(xMatch),
	/*1720*/ uint16(xCondIs64), 1723, 1729,
	/*1723*/ uint16(xSetOp), uint16(MOV),
	/*1725*/ uint16(xReadSlashR),
	/*1726*/ uint16(xArgCR0dashCR7),
	/*1727*/ uint16(xArgRmf32),
	/*1728*/ uint16(xMatch),
	/*1729*/ uint16(xSetOp), uint16(MOV),
	/*1731*/ uint16(xReadSlashR),
	/*1732*/ uint16(xArgCR0dashCR7),
	/*1733*/ uint16(xArgRmf64),
	/*1734*/ uint16(xMatch),
	/*1735*/ uint16(xCondIs64), 1738, 1744,
	/*1738*/ uint16(xSetOp), uint16(MOV),
	/*1740*/ uint16(xReadSlashR),
	/*1741*/ uint16(xArgDR0dashDR7),
	/*1742*/ uint16(xArgRmf32),
	/*1743*/ uint16(xMatch),
	/*1744*/ uint16(xSetOp), uint16(MOV),
	/*1746*/ uint16(xReadSlashR),
	/*1747*/ uint16(xArgDR0dashDR7),
	/*1748*/ uint16(xArgRmf64),
	/*1749*/ uint16(xMatch),
	/*1750*/ uint16(xCondIs64), 1753, 1759,
	/*1753*/ uint16(xSetOp), uint16(MOV),
	/*1755*/ uint16(xReadSlashR),
	/*1756*/ uint16(xArgRmf32),
	/*1757*/ uint16(xArgTR0dashTR7),
	/*1758*/ uint16(xMatch),
	/*1759*/ uint16(xSetOp), uint16(MOV),
	/*1761*/ uint16(xReadSlashR),
	/*1762*/ uint16(xArgRmf64),
	/*1763*/ uint16(xArgTR0dashTR7),
	/*1764*/ uint16(xMatch),
	/*1765*/ uint16(xCondIs64), 1768, 1774,
	/*1768*/ uint16(xSetOp), uint16(MOV),
	/*1770*/ uint16(xReadSlashR),
	/*1771*/ uint16(xArgTR0dashTR7),
	/*1772*/ uint16(xArgRmf32),
	/*1773*/ uint16(xMatch),
	/*1774*/ uint16(xSetOp), uint16(MOV),
	/*1776*/ uint16(xReadSlashR),
	/*1777*/ uint16(xArgTR0dashTR7),
	/*1778*/ uint16(xArgRmf64),
	/*1779*/ uint16(xMatch),
	/*1780*/ uint16(xCondPrefix), 2,
	0x66, 1792,
	0x0, 1786,
	/*1786*/ uint16(xSetOp), uint16(MOVAPS),
	/*1788*/ uint16(xReadSlashR),
	/*1789*/ uint16(xArgXmm1),
	/*1790*/ uint16(xArgXmm2M128),
	/*1791*/ uint16(xMatch),
	/*1792*/ uint16(xSetOp), uint16(MOVAPD),
	/*1794*/ uint16(xReadSlashR),
	/*1795*/ uint16(xArgXmm1),
	/*1796*/ uint16(xArgXmm2M128),
	/*1797*/ uint16(xMatch),
	/*1798*/ uint16(xCondPrefix), 2,
	0x66, 1810,
	0x0, 1804,
	/*1804*/ uint16(xSetOp), uint16(MOVAPS),
	/*1806*/ uint16(xReadSlashR),
	/*1807*/ uint16(xArgXmm2M128),
	/*1808*/ uint16(xArgXmm1),
	/*1809*/ uint16(xMatch),
	/*1810*/ uint16(xSetOp), uint16(MOVAPD),
	/*1812*/ uint16(xReadSlashR),
	/*1813*/ uint16(xArgXmm2M128),
	/*1814*/ uint16(xArgXmm1),
	/*1815*/ uint16(xMatch),
	/*1816*/ uint16(xCondIs64), 1819, 1873,
	/*1819*/ uint16(xCondPrefix), 4,
	0xF3, 1857,
	0xF2, 1841,
	0x66, 1835,
	0x0, 1829,
	/*1829*/ uint16(xSetOp), uint16(CVTPI2PS),
	/*1831*/ uint16(xReadSlashR),
	/*1832*/ uint16(xArgXmm),
	/*1833*/ uint16(xArgMmM64),
	/*1834*/ uint16(xMatch),
	/*1835*/ uint16(xSetOp), uint16(CVTPI2PD),
	/*1837*/ uint16(xReadSlashR),
	/*1838*/ uint16(xArgXmm),
	/*1839*/ uint16(xArgMmM64),
	/*1840*/ uint16(xMatch),
	/*1841*/ uint16(xCondDataSize), 1845, 1851, 0,
	/*1845*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1847*/ uint16(xReadSlashR),
	/*1848*/ uint16(xArgXmm),
	/*1849*/ uint16(xArgRM32),
	/*1850*/ uint16(xMatch),
	/*1851*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1853*/ uint16(xReadSlashR),
	/*1854*/ uint16(xArgXmm),
	/*1855*/ uint16(xArgRM32),
	/*1856*/ uint16(xMatch),
	/*1857*/ uint16(xCondDataSize), 1861, 1867, 0,
	/*1861*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1863*/ uint16(xReadSlashR),
	/*1864*/ uint16(xArgXmm),
	/*1865*/ uint16(xArgRM32),
	/*1866*/ uint16(xMatch),
	/*1867*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1869*/ uint16(xReadSlashR),
	/*1870*/ uint16(xArgXmm),
	/*1871*/ uint16(xArgRM32),
	/*1872*/ uint16(xMatch),
	/*1873*/ uint16(xCondPrefix), 4,
	0xF3, 1893,
	0xF2, 1883,
	0x66, 1835,
	0x0, 1829,
	/*1883*/ uint16(xCondDataSize), 1845, 1851, 1887,
	/*1887*/ uint16(xSetOp), uint16(CVTSI2SD),
	/*1889*/ uint16(xReadSlashR),
	/*1890*/ uint16(xArgXmm),
	/*1891*/ uint16(xArgRM64),
	/*1892*/ uint16(xMatch),
	/*1893*/ uint16(xCondDataSize), 1861, 1867, 1897,
	/*1897*/ uint16(xSetOp), uint16(CVTSI2SS),
	/*1899*/ uint16(xReadSlashR),
	/*1900*/ uint16(xArgXmm),
	/*1901*/ uint16(xArgRM64),
	/*1902*/ uint16(xMatch),
	/*1903*/ uint16(xCondPrefix), 4,
	0xF3, 1931,
	0xF2, 1925,
	0x66, 1919,
	0x0, 1913,
	/*1913*/ uint16(xSetOp), uint16(MOVNTPS),
	/*1915*/ uint16(xReadSlashR),
	/*1916*/ uint16(xArgM128),
	/*1917*/ uint16(xArgXmm),
	/*1918*/ uint16(xMatch),
	/*1919*/ uint16(xSetOp), uint16(MOVNTPD),
	/*1921*/ uint16(xReadSlashR),
	/*1922*/ uint16(xArgM128),
	/*1923*/ uint16(xArgXmm),
	/*1924*/ uint16(xMatch),
	/*1925*/ uint16(xSetOp), uint16(MOVNTSD),
	/*1927*/ uint16(xReadSlashR),
	/*1928*/ uint16(xArgM64),
	/*1929*/ uint16(xArgXmm),
	/*1930*/ uint16(xMatch),
	/*1931*/ uint16(xSetOp), uint16(MOVNTSS),
	/*1933*/ uint16(xReadSlashR),
	/*1934*/ uint16(xArgM32),
	/*1935*/ uint16(xArgXmm),
	/*1936*/ uint16(xMatch),
	/*1937*/ uint16(xCondIs64), 1940, 1994,
	/*1940*/ uint16(xCondPrefix), 4,
	0xF3, 1978,
	0xF2, 1962,
	0x66, 1956,
	0x0, 1950,
	/*1950*/ uint16(xSetOp), uint16(CVTTPS2PI),
	/*1952*/ uint16(xReadSlashR),
	/*1953*/ uint16(xArgMm),
	/*1954*/ uint16(xArgXmmM64),
	/*1955*/ uint16(xMatch),
	/*1956*/ uint16(xSetOp), uint16(CVTTPD2PI),
	/*1958*/ uint16(xReadSlashR),
	/*1959*/ uint16(xArgMm),
	/*1960*/ uint16(xArgXmmM128),
	/*1961*/ uint16(xMatch),
	/*1962*/ uint16(xCondDataSize), 1966, 1972, 0,
	/*1966*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*1968*/ uint16(xReadSlashR),
	/*1969*/ uint16(xArgR32),
	/*1970*/ uint16(xArgXmmM64),
	/*1971*/ uint16(xMatch),
	/*1972*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*1974*/ uint16(xReadSlashR),
	/*1975*/ uint16(xArgR32),
	/*1976*/ uint16(xArgXmmM64),
	/*1977*/ uint16(xMatch),
	/*1978*/ uint16(xCondDataSize), 1982, 1988, 0,
	/*1982*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*1984*/ uint16(xReadSlashR),
	/*1985*/ uint16(xArgR32),
	/*1986*/ uint16(xArgXmmM32),
	/*1987*/ uint16(xMatch),
	/*1988*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*1990*/ uint16(xReadSlashR),
	/*1991*/ uint16(xArgR32),
	/*1992*/ uint16(xArgXmmM32),
	/*1993*/ uint16(xMatch),
	/*1994*/ uint16(xCondPrefix), 4,
	0xF3, 2014,
	0xF2, 2004,
	0x66, 1956,
	0x0, 1950,
	/*2004*/ uint16(xCondDataSize), 1966, 1972, 2008,
	/*2008*/ uint16(xSetOp), uint16(CVTTSD2SI),
	/*2010*/ uint16(xReadSlashR),
	/*2011*/ uint16(xArgR64),
	/*2012*/ uint16(xArgXmmM64),
	/*2013*/ uint16(xMatch),
	/*2014*/ uint16(xCondDataSize), 1982, 1988, 2018,
	/*2018*/ uint16(xSetOp), uint16(CVTTSS2SI),
	/*2020*/ uint16(xReadSlashR),
	/*2021*/ uint16(xArgR64),
	/*2022*/ uint16(xArgXmmM32),
	/*2023*/ uint16(xMatch),
	/*2024*/ uint16(xCondIs64), 2027, 2081,
	/*2027*/ uint16(xCondPrefix), 4,
	0xF3, 2065,
	0xF2, 2049,
	0x66, 2043,
	0x0, 2037,
	/*2037*/ uint16(xSetOp), uint16(CVTPS2PI),
	/*2039*/ uint16(xReadSlashR),
	/*2040*/ uint16(xArgMm),
	/*2041*/ uint16(xArgXmmM64),
	/*2042*/ uint16(xMatch),
	/*2043*/ uint16(xSetOp), uint16(CVTPD2PI),
	/*2045*/ uint16(xReadSlashR),
	/*2046*/ uint16(xArgMm),
	/*2047*/ uint16(xArgXmmM128),
	/*2048*/ uint16(xMatch),
	/*2049*/ uint16(xCondDataSize), 2053, 2059, 0,
	/*2053*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2055*/ uint16(xReadSlashR),
	/*2056*/ uint16(xArgR32),
	/*2057*/ uint16(xArgXmmM64),
	/*2058*/ uint16(xMatch),
	/*2059*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2061*/ uint16(xReadSlashR),
	/*2062*/ uint16(xArgR32),
	/*2063*/ uint16(xArgXmmM64),
	/*2064*/ uint16(xMatch),
	/*2065*/ uint16(xCondDataSize), 2069, 2075, 0,
	/*2069*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2071*/ uint16(xReadSlashR),
	/*2072*/ uint16(xArgR32),
	/*2073*/ uint16(xArgXmmM32),
	/*2074*/ uint16(xMatch),
	/*2075*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2077*/ uint16(xReadSlashR),
	/*2078*/ uint16(xArgR32),
	/*2079*/ uint16(xArgXmmM32),
	/*2080*/ uint16(xMatch),
	/*2081*/ uint16(xCondPrefix), 4,
	0xF3, 2101,
	0xF2, 2091,
	0x66, 2043,
	0x0, 2037,
	/*2091*/ uint16(xCondDataSize), 2053, 2059, 2095,
	/*2095*/ uint16(xSetOp), uint16(CVTSD2SI),
	/*2097*/ uint16(xReadSlashR),
	/*2098*/ uint16(xArgR64),
	/*2099*/ uint16(xArgXmmM64),
	/*2100*/ uint16(xMatch),
	/*2101*/ uint16(xCondDataSize), 2069, 2075, 2105,
	/*2105*/ uint16(xSetOp), uint16(CVTSS2SI),
	/*2107*/ uint16(xReadSlashR),
	/*2108*/ uint16(xArgR64),
	/*2109*/ uint16(xArgXmmM32),
	/*2110*/ uint16(xMatch),
	/*2111*/ uint16(xCondPrefix), 2,
	0x66, 2123,
	0x0, 2117,
	/*2117*/ uint16(xSetOp), uint16(UCOMISS),
	/*2119*/ uint16(xReadSlashR),
	/*2120*/ uint16(xArgXmm1),
	/*2121*/ uint16(xArgXmm2M32),
	/*2122*/ uint16(xMatch),
	/*2123*/ uint16(xSetOp), uint16(UCOMISD),
	/*2125*/ uint16(xReadSlashR),
	/*2126*/ uint16(xArgXmm1),
	/*2127*/ uint16(xArgXmm2M64),
	/*2128*/ uint16(xMatch),
	/*2129*/ uint16(xCondPrefix), 2,
	0x66, 2141,
	0x0, 2135,
	/*2135*/ uint16(xSetOp), uint16(COMISS),
	/*2137*/ uint16(xReadSlashR),
	/*2138*/ uint16(xArgXmm1),
	/*2139*/ uint16(xArgXmm2M32),
	/*2140*/ uint16(xMatch),
	/*2141*/ uint16(xSetOp), uint16(COMISD),
	/*2143*/ uint16(xReadSlashR),
	/*2144*/ uint16(xArgXmm1),
	/*2145*/ uint16(xArgXmm2M64),
	/*2146*/ uint16(xMatch),
	/*2147*/ uint16(xSetOp), uint16(WRMSR),
	/*2149*/ uint16(xMatch),
	/*2150*/ uint16(xSetOp), uint16(RDTSC),
	/*2152*/ uint16(xMatch),
	/*2153*/ uint16(xSetOp), uint16(RDMSR),
	/*2155*/ uint16(xMatch),
	/*2156*/ uint16(xSetOp), uint16(RDPMC),
	/*2158*/ uint16(xMatch),
	/*2159*/ uint16(xSetOp), uint16(SYSENTER),
	/*2161*/ uint16(xMatch),
	/*2162*/ uint16(xCondDataSize), 2166, 2166, 2169,
	/*2166*/ uint16(xSetOp), uint16(SYSEXIT),
	/*2168*/ uint16(xMatch),
	/*2169*/ uint16(xSetOp), uint16(SYSEXIT),
	/*2171*/ uint16(xMatch),
	/*2172*/ uint16(xCondByte), 54,
	0x00, 2283,
	0x01, 2301,
	0x02, 2319,
	0x03, 2337,
	0x04, 2355,
	0x05, 2373,
	0x06, 2391,
	0x07, 2409,
	0x08, 2427,
	0x09, 2445,
	0x0A, 2463,
	0x0B, 2481,
	0x10, 2499,
	0x14, 2510,
	0x15, 2521,
	0x17, 2532,
	0x1C, 2542,
	0x1D, 2560,
	0x1E, 2578,
	0x20, 2596,
	0x21, 2606,
	0x22, 2616,
	0x23, 2626,
	0x24, 2636,
	0x25, 2646,
	0x28, 2656,
	0x29, 2666,
	0x2A, 2676,
	0x2B, 2686,
	0x30, 2696,
	0x31, 2706,
	0x32, 2716,
	0x33, 2726,
	0x34, 2736,
	0x35, 2746,
	0x37, 2756,
	0x38, 2766,
	0x39, 2776,
	0x3A, 2786,
	0x3B, 2796,
	0x3C, 2806,
	0x3D, 2816,
	0x3E, 2826,
	0x3F, 2836,
	0x40, 2846,
	0x41, 2856,
	0x82, 2866,
	0xDB, 2889,
	0xDC, 2899,
	0xDD, 2909,
	0xDE, 2919,
	0xDF, 2929,
	0xF0, 2939,
	0xF1, 3006,
	uint16(xFail),
	/*2283*/ uint16(xCondPrefix), 2,
	0x66, 2295,
	0x0, 2289,
	/*2289*/ uint16(xSetOp), uint16(PSHUFB),
	/*2291*/ uint16(xReadSlashR),
	/*2292*/ uint16(xArgMm1),
	/*2293*/ uint16(xArgMm2M64),
	/*2294*/ uint16(xMatch),
	/*2295*/ uint16(xSetOp), uint16(PSHUFB),
	/*2297*/ uint16(xReadSlashR),
	/*2298*/ uint16(xArgXmm1),
	/*2299*/ uint16(xArgXmm2M128),
	/*2300*/ uint16(xMatch),
	/*2301*/ uint16(xCondPrefix), 2,
	0x66, 2313,
	0x0, 2307,
	/*2307*/ uint16(xSetOp), uint16(PHADDW),
	/*2309*/ uint16(xReadSlashR),
	/*2310*/ uint16(xArgMm1),
	/*2311*/ uint16(xArgMm2M64),
	/*2312*/ uint16(xMatch),
	/*2313*/ uint16(xSetOp), uint16(PHADDW),
	/*2315*/ uint16(xReadSlashR),
	/*2316*/ uint16(xArgXmm1),
	/*2317*/ uint16(xArgXmm2M128),
	/*2318*/ uint16(xMatch),
	/*2319*/ uint16(xCondPrefix), 2,
	0x66, 2331,
	0x0, 2325,
	/*2325*/ uint16(xSetOp), uint16(PHADDD),
	/*2327*/ uint16(xReadSlashR),
	/*2328*/ uint16(xArgMm1),
	/*2329*/ uint16(xArgMm2M64),
	/*2330*/ uint16(xMatch),
	/*2331*/ uint16(xSetOp), uint16(PHADDD),
	/*2333*/ uint16(xReadSlashR),
	/*2334*/ uint16(xArgXmm1),
	/*2335*/ uint16(xArgXmm2M128),
	/*2336*/ uint16(xMatch),
	/*2337*/ uint16(xCondPrefix), 2,
	0x66, 2349,
	0x0, 2343,
	/*2343*/ uint16(xSetOp), uint16(PHADDSW),
	/*2345*/ uint16(xReadSlashR),
	/*2346*/ uint16(xArgMm1),
	/*2347*/ uint16(xArgMm2M64),
	/*2348*/ uint16(xMatch),
	/*2349*/ uint16(xSetOp), uint16(PHADDSW),
	/*2351*/ uint16(xReadSlashR),
	/*2352*/ uint16(xArgXmm1),
	/*2353*/ uint16(xArgXmm2M128),
	/*2354*/ uint16(xMatch),
	/*2355*/ uint16(xCondPrefix), 2,
	0x66, 2367,
	0x0, 2361,
	/*2361*/ uint16(xSetOp), uint16(PMADDUBSW),
	/*2363*/ uint16(xReadSlashR),
	/*2364*/ uint16(xArgMm1),
	/*2365*/ uint16(xArgMm2M64),
	/*2366*/ uint16(xMatch),
	/*2367*/ uint16(xSetOp), uint16(PMADDUBSW),
	/*2369*/ uint16(xReadSlashR),
	/*2370*/ uint16(xArgXmm1),
	/*2371*/ uint16(xArgXmm2M128),
	/*2372*/ uint16(xMatch),
	/*2373*/ uint16(xCondPrefix), 2,
	0x66, 2385,
	0x0, 2379,
	/*2379*/ uint16(xSetOp), uint16(PHSUBW),
	/*2381*/ uint16(xReadSlashR),
	/*2382*/ uint16(xArgMm1),
	/*2383*/ uint16(xArgMm2M64),
	/*2384*/ uint16(xMatch),
	/*2385*/ uint16(xSetOp), uint16(PHSUBW),
	/*2387*/ uint16(xReadSlashR),
	/*2388*/ uint16(xArgXmm1),
	/*2389*/ uint16(xArgXmm2M128),
	/*2390*/ uint16(xMatch),
	/*2391*/ uint16(xCondPrefix), 2,
	0x66, 2403,
	0x0, 2397,
	/*2397*/ uint16(xSetOp), uint16(PHSUBD),
	/*2399*/ uint16(xReadSlashR),
	/*2400*/ uint16(xArgMm1),
	/*2401*/ uint16(xArgMm2M64),
	/*2402*/ uint16(xMatch),
	/*2403*/ uint16(xSetOp), uint16(PHSUBD),
	/*2405*/ uint16(xReadSlashR),
	/*2406*/ uint16(xArgXmm1),
	/*2407*/ uint16(xArgXmm2M128),
	/*2408*/ uint16(xMatch),
	/*2409*/ uint16(xCondPrefix), 2,
	0x66, 2421,
	0x0, 2415,
	/*2415*/ uint16(xSetOp), uint16(PHSUBSW),
	/*2417*/ uint16(xReadSlashR),
	/*2418*/ uint16(xArgMm1),
	/*2419*/ uint16(xArgMm2M64),
	/*2420*/ uint16(xMatch),
	/*2421*/ uint16(xSetOp), uint16(PHSUBSW),
	/*2423*/ uint16(xReadSlashR),
	/*2424*/ uint16(xArgXmm1),
	/*2425*/ uint16(xArgXmm2M128),
	/*2426*/ uint16(xMatch),
	/*2427*/ uint16(xCondPrefix), 2,
	0x66, 2439,
	0x0, 2433,
	/*2433*/ uint16(xSetOp), uint16(PSIGNB),
	/*2435*/ uint16(xReadSlashR),
	/*2436*/ uint16(xArgMm1),
	/*2437*/ uint16(xArgMm2M64),
	/*2438*/ uint16(xMatch),
	/*2439*/ uint16(xSetOp), uint16(PSIGNB),
	/*2441*/ uint16(xReadSlashR),
	/*2442*/ uint16(xArgXmm1),
	/*2443*/ uint16(xArgXmm2M128),
	/*2444*/ uint16(xMatch),
	/*2445*/ uint16(xCondPrefix), 2,
	0x66, 2457,
	0x0, 2451,
	/*2451*/ uint16(xSetOp), uint16(PSIGNW),
	/*2453*/ uint16(xReadSlashR),
	/*2454*/ uint16(xArgMm1),
	/*2455*/ uint16(xArgMm2M64),
	/*2456*/ uint16(xMatch),
	/*2457*/ uint16(xSetOp), uint16(PSIGNW),
	/*2459*/ uint16(xReadSlashR),
	/*2460*/ uint16(xArgXmm1),
	/*2461*/ uint16(xArgXmm2M128),
	/*2462*/ uint16(xMatch),
	/*2463*/ uint16(xCondPrefix), 2,
	0x66, 2475,
	0x0, 2469,
	/*2469*/ uint16(xSetOp), uint16(PSIGND),
	/*2471*/ uint16(xReadSlashR),
	/*2472*/ uint16(xArgMm1),
	/*2473*/ uint16(xArgMm2M64),
	/*2474*/ uint16(xMatch),
	/*2475*/ uint16(xSetOp), uint16(PSIGND),
	/*2477*/ uint16(xReadSlashR),
	/*2478*/ uint16(xArgXmm1),
	/*2479*/ uint16(xArgXmm2M128),
	/*2480*/ uint16(xMatch),
	/*2481*/ uint16(xCondPrefix), 2,
	0x66, 2493,
	0x0, 2487,
	/*2487*/ uint16(xSetOp), uint16(PMULHRSW),
	/*2489*/ uint16(xReadSlashR),
	/*2490*/ uint16(xArgMm1),
	/*2491*/ uint16(xArgMm2M64),
	/*2492*/ uint16(xMatch),
	/*2493*/ uint16(xSetOp), uint16(PMULHRSW),
	/*2495*/ uint16(xReadSlashR),
	/*2496*/ uint16(xArgXmm1),
	/*2497*/ uint16(xArgXmm2M128),
	/*2498*/ uint16(xMatch),
	/*2499*/ uint16(xCondPrefix), 1,
	0x66, 2503,
	/*2503*/ uint16(xSetOp), uint16(PBLENDVB),
	/*2505*/ uint16(xReadSlashR),
	/*2506*/ uint16(xArgXmm1),
	/*2507*/ uint16(xArgXmm2M128),
	/*2508*/ uint16(xArgXMM0),
	/*2509*/ uint16(xMatch),
	/*2510*/ uint16(xCondPrefix), 1,
	0x66, 2514,
	/*2514*/ uint16(xSetOp), uint16(BLENDVPS),
	/*2516*/ uint16(xReadSlashR),
	/*2517*/ uint16(xArgXmm1),
	/*2518*/ uint16(xArgXmm2M128),
	/*2519*/ uint16(xArgXMM0),
	/*2520*/ uint16(xMatch),
	/*2521*/ uint16(xCondPrefix), 1,
	0x66, 2525,
	/*2525*/ uint16(xSetOp), uint16(BLENDVPD),
	/*2527*/ uint16(xReadSlashR),
	/*2528*/ uint16(xArgXmm1),
	/*2529*/ uint16(xArgXmm2M128),
	/*2530*/ uint16(xArgXMM0),
	/*2531*/ uint16(xMatch),
	/*2532*/ uint16(xCondPrefix), 1,
	0x66, 2536,
	/*2536*/ uint16(xSetOp), uint16(PTEST),
	/*2538*/ uint16(xReadSlashR),
	/*2539*/ uint16(xArgXmm1),
	/*2540*/ uint16(xArgXmm2M128),
	/*2541*/ uint16(xMatch),
	/*2542*/ uint16(xCondPrefix), 2,
	0x66, 2554,
	0x0, 2548,
	/*2548*/ uint16(xSetOp), uint16(PABSB),
	/*2550*/ uint16(xReadSlashR),
	/*2551*/ uint16(xArgMm1),
	/*2552*/ uint16(xArgMm2M64),
	/*2553*/ uint16(xMatch),
	/*2554*/ uint16(xSetOp), uint16(PABSB),
	/*2556*/ uint16(xReadSlashR),
	/*2557*/ uint16(xArgXmm1),
	/*2558*/ uint16(xArgXmm2M128),
	/*2559*/ uint16(xMatch),
	/*2560*/ uint16(xCondPrefix), 2,
	0x66, 2572,
	0x0, 2566,
	/*2566*/ uint16(xSetOp), uint16(PABSW),
	/*2568*/ uint16(xReadSlashR),
	/*2569*/ uint16(xArgMm1),
	/*2570*/ uint16(xArgMm2M64),
	/*2571*/ uint16(xMatch),
	/*2572*/ uint16(xSetOp), uint16(PABSW),
	/*2574*/ uint16(xReadSlashR),
	/*2575*/ uint16(xArgXmm1),
	/*2576*/ uint16(xArgXmm2M128),
	/*2577*/ uint16(xMatch),
	/*2578*/ uint16(xCondPrefix), 2,
	0x66, 2590,
	0x0, 2584,
	/*2584*/ uint16(xSetOp), uint16(PABSD),
	/*2586*/ uint16(xReadSlashR),
	/*2587*/ uint16(xArgMm1),
	/*2588*/ uint16(xArgMm2M64),
	/*2589*/ uint16(xMatch),
	/*2590*/ uint16(xSetOp), uint16(PABSD),
	/*2592*/ uint16(xReadSlashR),
	/*2593*/ uint16(xArgXmm1),
	/*2594*/ uint16(xArgXmm2M128),
	/*2595*/ uint16(xMatch),
	/*2596*/ uint16(xCondPrefix), 1,
	0x66, 2600,
	/*2600*/ uint16(xSetOp), uint16(PMOVSXBW),
	/*2602*/ uint16(xReadSlashR),
	/*2603*/ uint16(xArgXmm1),
	/*2604*/ uint16(xArgXmm2M64),
	/*2605*/ uint16(xMatch),
	/*2606*/ uint16(xCondPrefix), 1,
	0x66, 2610,
	/*2610*/ uint16(xSetOp), uint16(PMOVSXBD),
	/*2612*/ uint16(xReadSlashR),
	/*2613*/ uint16(xArgXmm1),
	/*2614*/ uint16(xArgXmm2M32),
	/*2615*/ uint16(xMatch),
	/*2616*/ uint16(xCondPrefix), 1,
	0x66, 2620,
	/*2620*/ uint16(xSetOp), uint16(PMOVSXBQ),
	/*2622*/ uint16(xReadSlashR),
	/*2623*/ uint16(xArgXmm1),
	/*2624*/ uint16(xArgXmm2M16),
	/*2625*/ uint16(xMatch),
	/*2626*/ uint16(xCondPrefix), 1,
	0x66, 2630,
	/*2630*/ uint16(xSetOp), uint16(PMOVSXWD),
	/*2632*/ uint16(xReadSlashR),
	/*2633*/ uint16(xArgXmm1),
	/*2634*/ uint16(xArgXmm2M64),
	/*2635*/ uint16(xMatch),
	/*2636*/ uint16(xCondPrefix), 1,
	0x66, 2640,
	/*2640*/ uint16(xSetOp), uint16(PMOVSXWQ),
	/*2642*/ uint16(xReadSlashR),
	/*2643*/ uint16(xArgXmm1),
	/*2644*/ uint16(xArgXmm2M32),
	/*2645*/ uint16(xMatch),
	/*2646*/ uint16(xCondPrefix), 1,
	0x66, 2650,
	/*2650*/ uint16(xSetOp), uint16(PMOVSXDQ),
	/*2652*/ uint16(xReadSlashR),
	/*2653*/ uint16(xArgXmm1),
	/*2654*/ uint16(xArgXmm2M64),
	/*2655*/ uint16(xMatch),
	/*2656*/ uint16(xCondPrefix), 1,
	0x66, 2660,
	/*2660*/ uint16(xSetOp), uint16(PMULDQ),
	/*2662*/ uint16(xReadSlashR),
	/*2663*/ uint16(xArgXmm1),
	/*2664*/ uint16(xArgXmm2M128),
	/*2665*/ uint16(xMatch),
	/*2666*/ uint16(xCondPrefix), 1,
	0x66, 2670,
	/*2670*/ uint16(xSetOp), uint16(PCMPEQQ),
	/*2672*/ uint16(xReadSlashR),
	/*2673*/ uint16(xArgXmm1),
	/*2674*/ uint16(xArgXmm2M128),
	/*2675*/ uint16(xMatch),
	/*2676*/ uint16(xCondPrefix), 1,
	0x66, 2680,
	/*2680*/ uint16(xSetOp), uint16(MOVNTDQA),
	/*2682*/ uint16(xReadSlashR),
	/*2683*/ uint16(xArgXmm1),
	/*2684*/ uint16(xArgM128),
	/*2685*/ uint16(xMatch),
	/*2686*/ uint16(xCondPrefix), 1,
	0x66, 2690,
	/*2690*/ uint16(xSetOp), uint16(PACKUSDW),
	/*2692*/ uint16(xReadSlashR),
	/*2693*/ uint16(xArgXmm1),
	/*2694*/ uint16(xArgXmm2M128),
	/*2695*/ uint16(xMatch),
	/*2696*/ uint16(xCondPrefix), 1,
	0x66, 2700,
	/*2700*/ uint16(xSetOp), uint16(PMOVZXBW),
	/*2702*/ uint16(xReadSlashR),
	/*2703*/ uint16(xArgXmm1),
	/*2704*/ uint16(xArgXmm2M64),
	/*2705*/ uint16(xMatch),
	/*2706*/ uint16(xCondPrefix), 1,
	0x66, 2710,
	/*2710*/ uint16(xSetOp), uint16(PMOVZXBD),
	/*2712*/ uint16(xReadSlashR),
	/*2713*/ uint16(xArgXmm1),
	/*2714*/ uint16(xArgXmm2M32),
	/*2715*/ uint16(xMatch),
	/*2716*/ uint16(xCondPrefix), 1,
	0x66, 2720,
	/*2720*/ uint16(xSetOp), uint16(PMOVZXBQ),
	/*2722*/ uint16(xReadSlashR),
	/*2723*/ uint16(xArgXmm1),
	/*2724*/ uint16(xArgXmm2M16),
	/*2725*/ uint16(xMatch),
	/*2726*/ uint16(xCondPrefix), 1,
	0x66, 2730,
	/*2730*/ uint16(xSetOp), uint16(PMOVZXWD),
	/*2732*/ uint16(xReadSlashR),
	/*2733*/ uint16(xArgXmm1),
	/*2734*/ uint16(xArgXmm2M64),
	/*2735*/ uint16(xMatch),
	/*2736*/ uint16(xCondPrefix), 1,
	0x66, 2740,
	/*2740*/ uint16(xSetOp), uint16(PMOVZXWQ),
	/*2742*/ uint16(xReadSlashR),
	/*2743*/ uint16(xArgXmm1),
	/*2744*/ uint16(xArgXmm2M32),
	/*2745*/ uint16(xMatch),
	/*2746*/ uint16(xCondPrefix), 1,
	0x66, 2750,
	/*2750*/ uint16(xSetOp), uint16(PMOVZXDQ),
	/*2752*/ uint16(xReadSlashR),
	/*2753*/ uint16(xArgXmm1),
	/*2754*/ uint16(xArgXmm2M64),
	/*2755*/ uint16(xMatch),
	/*2756*/ uint16(xCondPrefix), 1,
	0x66, 2760,
	/*2760*/ uint16(xSetOp), uint16(PCMPGTQ),
	/*2762*/ uint16(xReadSlashR),
	/*2763*/ uint16(xArgXmm1),
	/*2764*/ uint16(xArgXmm2M128),
	/*2765*/ uint16(xMatch),
	/*2766*/ uint16(xCondPrefix), 1,
	0x66, 2770,
	/*2770*/ uint16(xSetOp), uint16(PMINSB),
	/*2772*/ uint16(xReadSlashR),
	/*2773*/ uint16(xArgXmm1),
	/*2774*/ uint16(xArgXmm2M128),
	/*2775*/ uint16(xMatch),
	/*2776*/ uint16(xCondPrefix), 1,
	0x66, 2780,
	/*2780*/ uint16(xSetOp), uint16(PMINSD),
	/*2782*/ uint16(xReadSlashR),
	/*2783*/ uint16(xArgXmm1),
	/*2784*/ uint16(xArgXmm2M128),
	/*2785*/ uint16(xMatch),
	/*2786*/ uint16(xCondPrefix), 1,
	0x66, 2790,
	/*2790*/ uint16(xSetOp), uint16(PMINUW),
	/*2792*/ uint16(xReadSlashR),
	/*2793*/ uint16(xArgXmm1),
	/*2794*/ uint16(xArgXmm2M128),
	/*2795*/ uint16(xMatch),
	/*2796*/ uint16(xCondPrefix), 1,
	0x66, 2800,
	/*2800*/ uint16(xSetOp), uint16(PMINUD),
	/*2802*/ uint16(xReadSlashR),
	/*2803*/ uint16(xArgXmm1),
	/*2804*/ uint16(xArgXmm2M128),
	/*2805*/ uint16(xMatch),
	/*2806*/ uint16(xCondPrefix), 1,
	0x66, 2810,
	/*2810*/ uint16(xSetOp), uint16(PMAXSB),
	/*2812*/ uint16(xReadSlashR),
	/*2813*/ uint16(xArgXmm1),
	/*2814*/ uint16(xArgXmm2M128),
	/*2815*/ uint16(xMatch),
	/*2816*/ uint16(xCondPrefix), 1,
	0x66, 2820,
	/*2820*/ uint16(xSetOp), uint16(PMAXSD),
	/*2822*/ uint16(xReadSlashR),
	/*2823*/ uint16(xArgXmm1),
	/*2824*/ uint16(xArgXmm2M128),
	/*2825*/ uint16(xMatch),
	/*2826*/ uint16(xCondPrefix), 1,
	0x66, 2830,
	/*2830*/ uint16(xSetOp), uint16(PMAXUW),
	/*2832*/ uint16(xReadSlashR),
	/*2833*/ uint16(xArgXmm1),
	/*2834*/ uint16(xArgXmm2M128),
	/*2835*/ uint16(xMatch),
	/*2836*/ uint16(xCondPrefix), 1,
	0x66, 2840,
	/*2840*/ uint16(xSetOp), uint16(PMAXUD),
	/*2842*/ uint16(xReadSlashR),
	/*2843*/ uint16(xArgXmm1),
	/*2844*/ uint16(xArgXmm2M128),
	/*2845*/ uint16(xMatch),
	/*2846*/ uint16(xCondPrefix), 1,
	0x66, 2850,
	/*2850*/ uint16(xSetOp), uint16(PMULLD),
	/*2852*/ uint16(xReadSlashR),
	/*2853*/ uint16(xArgXmm1),
	/*2854*/ uint16(xArgXmm2M128),
	/*2855*/ uint16(xMatch),
	/*2856*/ uint16(xCondPrefix), 1,
	0x66, 2860,
	/*2860*/ uint16(xSetOp), uint16(PHMINPOSUW),
	/*2862*/ uint16(xReadSlashR),
	/*2863*/ uint16(xArgXmm1),
	/*2864*/ uint16(xArgXmm2M128),
	/*2865*/ uint16(xMatch),
	/*2866*/ uint16(xCondIs64), 2869, 2879,
	/*2869*/ uint16(xCondPrefix), 1,
	0x66, 2873,
	/*2873*/ uint16(xSetOp), uint16(INVPCID),
	/*2875*/ uint16(xReadSlashR),
	/*2876*/ uint16(xArgR32),
	/*2877*/ uint16(xArgM128),
	/*2878*/ uint16(xMatch),
	/*2879*/ uint16(xCondPrefix), 1,
	0x66, 2883,
	/*2883*/ uint16(xSetOp), uint16(INVPCID),
	/*2885*/ uint16(xReadSlashR),
	/*2886*/ uint16(xArgR64),
	/*2887*/ uint16(xArgM128),
	/*2888*/ uint16(xMatch),
	/*2889*/ uint16(xCondPrefix), 1,
	0x66, 2893,
	/*2893*/ uint16(xSetOp), uint16(AESIMC),
	/*2895*/ uint16(xReadSlashR),
	/*2896*/ uint16(xArgXmm1),
	/*2897*/ uint16(xArgXmm2M128),
	/*2898*/ uint16(xMatch),
	/*2899*/ uint16(xCondPrefix), 1,
	0x66, 2903,
	/*2903*/ uint16(xSetOp), uint16(AESENC),
	/*2905*/ uint16(xReadSlashR),
	/*2906*/ uint16(xArgXmm1),
	/*2907*/ uint16(xArgXmm2M128),
	/*2908*/ uint16(xMatch),
	/*2909*/ uint16(xCondPrefix), 1,
	0x66, 2913,
	/*2913*/ uint16(xSetOp), uint16(AESENCLAST),
	/*2915*/ uint16(xReadSlashR),
	/*2916*/ uint16(xArgXmm1),
	/*2917*/ uint16(xArgXmm2M128),
	/*2918*/ uint16(xMatch),
	/*2919*/ uint16(xCondPrefix), 1,
	0x66, 2923,
	/*2923*/ uint16(xSetOp), uint16(AESDEC),
	/*2925*/ uint16(xReadSlashR),
	/*2926*/ uint16(xArgXmm1),
	/*2927*/ uint16(xArgXmm2M128),
	/*2928*/ uint16(xMatch),
	/*2929*/ uint16(xCondPrefix), 1,
	0x66, 2933,
	/*2933*/ uint16(xSetOp), uint16(AESDECLAST),
	/*2935*/ uint16(xReadSlashR),
	/*2936*/ uint16(xArgXmm1),
	/*2937*/ uint16(xArgXmm2M128),
	/*2938*/ uint16(xMatch),
	/*2939*/ uint16(xCondIs64), 2942, 2980,
	/*2942*/ uint16(xCondPrefix), 2,
	0xF2, 2964,
	0x0, 2948,
	/*2948*/ uint16(xCondDataSize), 2952, 2958, 0,
	/*2952*/ uint16(xSetOp), uint16(MOVBE),
	/*2954*/ uint16(xReadSlashR),
	/*2955*/ uint16(xArgR16),
	/*2956*/ uint16(xArgM16),
	/*2957*/ uint16(xMatch),
	/*2958*/ uint16(xSetOp), uint16(MOVBE),
	/*2960*/ uint16(xReadSlashR),
	/*2961*/ uint16(xArgR32),
	/*2962*/ uint16(xArgM32),
	/*2963*/ uint16(xMatch),
	/*2964*/ uint16(xCondDataSize), 2968, 2974, 0,
	/*2968*/ uint16(xSetOp), uint16(CRC32),
	/*2970*/ uint16(xReadSlashR),
	/*2971*/ uint16(xArgR32),
	/*2972*/ uint16(xArgRM8),
	/*2973*/ uint16(xMatch),
	/*2974*/ uint16(xSetOp), uint16(CRC32),
	/*2976*/ uint16(xReadSlashR),
	/*2977*/ uint16(xArgR32),
	/*2978*/ uint16(xArgRM8),
	/*2979*/ uint16(xMatch),
	/*2980*/ uint16(xCondPrefix), 2,
	0xF2, 2996,
	0x0, 2986,
	/*2986*/ uint16(xCondDataSize), 2952, 2958, 2990,
	/*2990*/ uint16(xSetOp), uint16(MOVBE),
	/*2992*/ uint16(xReadSlashR),
	/*2993*/ uint16(xArgR64),
	/*2994*/ uint16(xArgM64),
	/*2995*/ uint16(xMatch),
	/*2996*/ uint16(xCondDataSize), 2968, 2974, 3000,
	/*3000*/ uint16(xSetOp), uint16(CRC32),
	/*3002*/ uint16(xReadSlashR),
	/*3003*/ uint16(xArgR64),
	/*3004*/ uint16(xArgRM8),
	/*3005*/ uint16(xMatch),
	/*3006*/ uint16(xCondIs64), 3009, 3047,
	/*3009*/ uint16(xCondPrefix), 2,
	0xF2, 3031,
	0x0, 3015,
	/*3015*/ uint16(xCondDataSize), 3019, 3025, 0,
	/*3019*/ uint16(xSetOp), uint16(MOVBE),
	/*3021*/ uint16(xReadSlashR),
	/*3022*/ uint16(xArgM16),
	/*3023*/ uint16(xArgR16),
	/*3024*/ uint16(xMatch),
	/*3025*/ uint16(xSetOp), uint16(MOVBE),
	/*3027*/ uint16(xReadSlashR),
	/*3028*/ uint16(xArgM32),
	/*3029*/ uint16(xArgR32),
	/*3030*/ uint16(xMatch),
	/*3031*/ uint16(xCondDataSize), 3035, 3041, 0,
	/*3035*/ uint16(xSetOp), uint16(CRC32),
	/*3037*/ uint16(xReadSlashR),
	/*3038*/ uint16(xArgR32),
	/*3039*/ uint16(xArgRM16),
	/*3040*/ uint16(xMatch),
	/*3041*/ uint16(xSetOp), uint16(CRC32),
	/*3043*/ uint16(xReadSlashR),
	/*3044*/ uint16(xArgR32),
	/*3045*/ uint16(xArgRM32),
	/*3046*/ uint16(xMatch),
	/*3047*/ uint16(xCondPrefix), 2,
	0xF2, 3063,
	0x0, 3053,
	/*3053*/ uint16(xCondDataSize), 3019, 3025, 3057,
	/*3057*/ uint16(xSetOp), uint16(MOVBE),
	/*3059*/ uint16(xReadSlashR),
	/*3060*/ uint16(xArgM64),
	/*3061*/ uint16(xArgR64),
	/*3062*/ uint16(xMatch),
	/*3063*/ uint16(xCondDataSize), 3035, 3041, 3067,
	/*3067*/ uint16(xSetOp), uint16(CRC32),
	/*3069*/ uint16(xReadSlashR),
	/*3070*/ uint16(xArgR64),
	/*3071*/ uint16(xArgRM64),
	/*3072*/ uint16(xMatch),
	/*3073*/ uint16(xCondByte), 24,
	0x08, 3124,
	0x09, 3136,
	0x0A, 3148,
	0x0B, 3160,
	0x0C, 3172,
	0x0D, 3184,
	0x0E, 3196,
	0x0F, 3208,
	0x14, 3230,
	0x15, 3242,
	0x16, 3254,
	0x17, 3297,
	0x20, 3309,
	0x21, 3321,
	0x22, 3333,
	0x40, 3376,
	0x41, 3388,
	0x42, 3400,
	0x44, 3412,
	0x60, 3424,
	0x61, 3436,
	0x62, 3448,
	0x63, 3460,
	0xDF, 3472,
	uint16(xFail),
	/*3124*/ uint16(xCondPrefix), 1,
	0x66, 3128,
	/*3128*/ uint16(xSetOp), uint16(ROUNDPS),
	/*3130*/ uint16(xReadSlashR),
	/*3131*/ uint16(xReadIb),
	/*3132*/ uint16(xArgXmm1),
	/*3133*/ uint16(xArgXmm2M128),
	/*3134*/ uint16(xArgImm8u),
	/*3135*/ uint16(xMatch),
	/*3136*/ uint16(xCondPrefix), 1,
	0x66, 3140,
	/*3140*/ uint16(xSetOp), uint16(ROUNDPD),
	/*3142*/ uint16(xReadSlashR),
	/*3143*/ uint16(xReadIb),
	/*3144*/ uint16(xArgXmm1),
	/*3145*/ uint16(xArgXmm2M128),
	/*3146*/ uint16(xArgImm8u),
	/*3147*/ uint16(xMatch),
	/*3148*/ uint16(xCondPrefix), 1,
	0x66, 3152,
	/*3152*/ uint16(xSetOp), uint16(ROUNDSS),
	/*3154*/ uint16(xReadSlashR),
	/*3155*/ uint16(xReadIb),
	/*3156*/ uint16(xArgXmm1),
	/*3157*/ uint16(xArgXmm2M32),
	/*3158*/ uint16(xArgImm8u),
	/*3159*/ uint16(xMatch),
	/*3160*/ uint16(xCondPrefix), 1,
	0x66, 3164,
	/*3164*/ uint16(xSetOp), uint16(ROUNDSD),
	/*3166*/ uint16(xReadSlashR),
	/*3167*/ uint16(xReadIb),
	/*3168*/ uint16(xArgXmm1),
	/*3169*/ uint16(xArgXmm2M64),
	/*3170*/ uint16(xArgImm8u),
	/*3171*/ uint16(xMatch),
	/*3172*/ uint16(xCondPrefix), 1,
	0x66, 3176,
	/*3176*/ uint16(xSetOp), uint16(BLENDPS),
	/*3178*/ uint16(xReadSlashR),
	/*3179*/ uint16(xReadIb),
	/*3180*/ uint16(xArgXmm1),
	/*3181*/ uint16(xArgXmm2M128),
	/*3182*/ uint16(xArgImm8u),
	/*3183*/ uint16(xMatch),
	/*3184*/ uint16(xCondPrefix), 1,
	0x66, 3188,
	/*3188*/ uint16(xSetOp), uint16(BLENDPD),
	/*3190*/ uint16(xReadSlashR),
	/*3191*/ uint16(xReadIb),
	/*3192*/ uint16(xArgXmm1),
	/*3193*/ uint16(xArgXmm2M128),
	/*3194*/ uint16(xArgImm8u),
	/*3195*/ uint16(xMatch),
	/*3196*/ uint16(xCondPrefix), 1,
	0x66, 3200,
	/*3200*/ uint16(xSetOp), uint16(PBLENDW),
	/*3202*/ uint16(xReadSlashR),
	/*3203*/ uint16(xReadIb),
	/*3204*/ uint16(xArgXmm1),
	/*3205*/ uint16(xArgXmm2M128),
	/*3206*/ uint16(xArgImm8u),
	/*3207*/ uint16(xMatch),
	/*3208*/ uint16(xCondPrefix), 2,
	0x66, 3222,
	0x0, 3214,
	/*3214*/ uint16(xSetOp), uint16(PALIGNR),
	/*3216*/ uint16(xReadSlashR),
	/*3217*/ uint16(xReadIb),
	/*3218*/ uint16(xArgMm1),
	/*3219*/ uint16(xArgMm2M64),
	/*3220*/ uint16(xArgImm8u),
	/*3221*/ uint16(xMatch),
	/*3222*/ uint16(xSetOp), uint16(PALIGNR),
	/*3224*/ uint16(xReadSlashR),
	/*3225*/ uint16(xReadIb),
	/*3226*/ uint16(xArgXmm1),
	/*3227*/ uint16(xArgXmm2M128),
	/*3228*/ uint16(xArgImm8u),
	/*3229*/ uint16(xMatch),
	/*3230*/ uint16(xCondPrefix), 1,
	0x66, 3234,
	/*3234*/ uint16(xSetOp), uint16(PEXTRB),
	/*3236*/ uint16(xReadSlashR),
	/*3237*/ uint16(xReadIb),
	/*3238*/ uint16(xArgR32M8),
	/*3239*/ uint16(xArgXmm1),
	/*3240*/ uint16(xArgImm8u),
	/*3241*/ uint16(xMatch),
	/*3242*/ uint16(xCondPrefix), 1,
	0x66, 3246,
	/*3246*/ uint16(xSetOp), uint16(PEXTRW),
	/*3248*/ uint16(xReadSlashR),
	/*3249*/ uint16(xReadIb),
	/*3250*/ uint16(xArgR32M16),
	/*3251*/ uint16(xArgXmm1),
	/*3252*/ uint16(xArgImm8u),
	/*3253*/ uint16(xMatch),
	/*3254*/ uint16(xCondIs64), 3257, 3281,
	/*3257*/ uint16(xCondPrefix), 1,
	0x66, 3261,
	/*3261*/ uint16(xCondDataSize), 3265, 3273, 0,
	/*3265*/ uint16(xSetOp), uint16(PEXTRD),
	/*3267*/ uint16(xReadSlashR),
	/*3268*/ uint16(xReadIb),
	/*3269*/ uint16(xArgRM32),
	/*3270*/ uint16(xArgXmm1),
	/*3271*/ uint16(xArgImm8u),
	/*3272*/ uint16(xMatch),
	/*3273*/ uint16(xSetOp), uint16(PEXTRD),
	/*3275*/ uint16(xReadSlashR),
	/*3276*/ uint16(xReadIb),
	/*3277*/ uint16(xArgRM32),
	/*3278*/ uint16(xArgXmm1),
	/*3279*/ uint16(xArgImm8u),
	/*3280*/ uint16(xMatch),
	/*3281*/ uint16(xCondPrefix), 1,
	0x66, 3285,
	/*3285*/ uint16(xCondDataSize), 3265, 3273, 3289,
	/*3289*/ uint16(xSetOp), uint16(PEXTRQ),
	/*3291*/ uint16(xReadSlashR),
	/*3292*/ uint16(xReadIb),
	/*3293*/ uint16(xArgRM64),
	/*3294*/ uint16(xArgXmm1),
	/*3295*/ uint16(xArgImm8u),
	/*3296*/ uint16(xMatch),
	/*3297*/ uint16(xCondPrefix), 1,
	0x66, 3301,
	/*3301*/ uint16(xSetOp), uint16(EXTRACTPS),
	/*3303*/ uint16(xReadSlashR),
	/*3304*/ uint16(xReadIb),
	/*3305*/ uint16(xArgRM32),
	/*3306*/ uint16(xArgXmm1),
	/*3307*/ uint16(xArgImm8u),
	/*3308*/ uint16(xMatch),
	/*3309*/ uint16(xCondPrefix), 1,
	0x66, 3313,
	/*3313*/ uint16(xSetOp), uint16(PINSRB),
	/*3315*/ uint16(xReadSlashR),
	/*3316*/ uint16(xReadIb),
	/*3317*/ uint16(xArgXmm1),
	/*3318*/ uint16(xArgR32M8),
	/*3319*/ uint16(xArgImm8u),
	/*3320*/ uint16(xMatch),
	/*3321*/ uint16(xCondPrefix), 1,
	0x66, 3325,
	/*3325*/ uint16(xSetOp), uint16(INSERTPS),
	/*3327*/ uint16(xReadSlashR),
	/*3328*/ uint16(xReadIb),
	/*3329*/ uint16(xArgXmm1),
	/*3330*/ uint16(xArgXmm2M32),
	/*3331*/ uint16(xArgImm8u),
	/*3332*/ uint16(xMatch),
	/*3333*/ uint16(xCondIs64), 3336, 3360,
	/*3336*/ uint16(xCondPrefix), 1,
	0x66, 3340,
	/*3340*/ uint16(xCondDataSize), 3344, 3352, 0,
	/*3344*/ uint16(xSetOp), uint16(PINSRD),
	/*3346*/ uint16(xReadSlashR),
	/*3347*/ uint16(xReadIb),
	/*3348*/ uint16(xArgXmm1),
	/*3349*/ uint16(xArgRM32),
	/*3350*/ uint16(xArgImm8u),
	/*3351*/ uint16(xMatch),
	/*3352*/ uint16(xSetOp), uint16(PINSRD),
	/*3354*/ uint16(xReadSlashR),
	/*3355*/ uint16(xReadIb),
	/*3356*/ uint16(xArgXmm1),
	/*3357*/ uint16(xArgRM32),
	/*3358*/ uint16(xArgImm8u),
	/*3359*/ uint16(xMatch),
	/*3360*/ uint16(xCondPrefix), 1,
	0x66, 3364,
	/*3364*/ uint16(xCondDataSize), 3344, 3352, 3368,
	/*3368*/ uint16(xSetOp), uint16(PINSRQ),
	/*3370*/ uint16(xReadSlashR),
	/*3371*/ uint16(xReadIb),
	/*3372*/ uint16(xArgXmm1),
	/*3373*/ uint16(xArgRM64),
	/*3374*/ uint16(xArgImm8u),
	/*3375*/ uint16(xMatch),
	/*3376*/ uint16(xCondPrefix), 1,
	0x66, 3380,
	/*3380*/ uint16(xSetOp), uint16(DPPS),
	/*3382*/ uint16(xReadSlashR),
	/*3383*/ uint16(xReadIb),
	/*3384*/ uint16(xArgXmm1),
	/*3385*/ uint16(xArgXmm2M128),
	/*3386*/ uint16(xArgImm8u),
	/*3387*/ uint16(xMatch),
	/*3388*/ uint16(xCondPrefix), 1,
	0x66, 3392,
	/*3392*/ uint16(xSetOp), uint16(DPPD),
	/*3394*/ uint16(xReadSlashR),
	/*3395*/ uint16(xReadIb),
	/*3396*/ uint16(xArgXmm1),
	/*3397*/ uint16(xArgXmm2M128),
	/*3398*/ uint16(xArgImm8u),
	/*3399*/ uint16(xMatch),
	/*3400*/ uint16(xCondPrefix), 1,
	0x66, 3404,
	/*3404*/ uint16(xSetOp), uint16(MPSADBW),
	/*3406*/ uint16(xReadSlashR),
	/*3407*/ uint16(xReadIb),
	/*3408*/ uint16(xArgXmm1),
	/*3409*/ uint16(xArgXmm2M128),
	/*3410*/ uint16(xArgImm8u),
	/*3411*/ uint16(xMatch),
	/*3412*/ uint16(xCondPrefix), 1,
	0x66, 3416,
	/*3416*/ uint16(xSetOp), uint16(PCLMULQDQ),
	/*3418*/ uint16(xReadSlashR),
	/*3419*/ uint16(xReadIb),
	/*3420*/ uint16(xArgXmm1),
	/*3421*/ uint16(xArgXmm2M128),
	/*3422*/ uint16(xArgImm8u),
	/*3423*/ uint16(xMatch),
	/*3424*/ uint16(xCondPrefix), 1,
	0x66, 3428,
	/*3428*/ uint16(xSetOp), uint16(PCMPESTRM),
	/*3430*/ uint16(xReadSlashR),
	/*3431*/ uint16(xReadIb),
	/*3432*/ uint16(xArgXmm1),
	/*3433*/ uint16(xArgXmm2M128),
	/*3434*/ uint16(xArgImm8u),
	/*3435*/ uint16(xMatch),
	/*3436*/ uint16(xCondPrefix), 1,
	0x66, 3440,
	/*3440*/ uint16(xSetOp), uint16(PCMPESTRI),
	/*3442*/ uint16(xReadSlashR),
	/*3443*/ uint16(xReadIb),
	/*3444*/ uint16(xArgXmm1),
	/*3445*/ uint16(xArgXmm2M128),
	/*3446*/ uint16(xArgImm8u),
	/*3447*/ uint16(xMatch),
	/*3448*/ uint16(xCondPrefix), 1,
	0x66, 3452,
	/*3452*/ uint16(xSetOp), uint16(PCMPISTRM),
	/*3454*/ uint16(xReadSlashR),
	/*3455*/ uint16(xReadIb),
	/*3456*/ uint16(xArgXmm1),
	/*3457*/ uint16(xArgXmm2M128),
	/*3458*/ uint16(xArgImm8u),
	/*3459*/ uint16(xMatch),
	/*3460*/ uint16(xCondPrefix), 1,
	0x66, 3464,
	/*3464*/ uint16(xSetOp), uint16(PCMPISTRI),
	/*3466*/ uint16(xReadSlashR),
	/*3467*/ uint16(xReadIb),
	/*3468*/ uint16(xArgXmm1),
	/*3469*/ uint16(xArgXmm2M128),
	/*3470*/ uint16(xArgImm8u),
	/*3471*/ uint16(xMatch),
	/*3472*/ uint16(xCondPrefix), 1,
	0x66, 3476,
	/*3476*/ uint16(xSetOp), uint16(AESKEYGENASSIST),
	/*3478*/ uint16(xReadSlashR),
	/*3479*/ uint16(xReadIb),
	/*3480*/ uint16(xArgXmm1),
	/*3481*/ uint16(xArgXmm2M128),
	/*3482*/ uint16(xArgImm8u),
	/*3483*/ uint16(xMatch),
	/*3484*/ uint16(xCondIs64), 3487, 3503,
	/*3487*/ uint16(xCondDataSize), 3491, 3497, 0,
	/*3491*/ uint16(xSetOp), uint16(CMOVO),
	/*3493*/ uint16(xReadSlashR),
	/*3494*/ uint16(xArgR16),
	/*3495*/ uint16(xArgRM16),
	/*3496*/ uint16(xMatch),
	/*3497*/ uint16(xSetOp), uint16(CMOVO),
	/*3499*/ uint16(xReadSlashR),
	/*3500*/ uint16(xArgR32),
	/*3501*/ uint16(xArgRM32),
	/*3502*/ uint16(xMatch),
	/*3503*/ uint16(xCondDataSize), 3491, 3497, 3507,
	/*3507*/ uint16(xSetOp), uint16(CMOVO),
	/*3509*/ uint16(xReadSlashR),
	/*3510*/ uint16(xArgR64),
	/*3511*/ uint16(xArgRM64),
	/*3512*/ uint16(xMatch),
	/*3513*/ uint16(xCondIs64), 3516, 3532,
	/*3516*/ uint16(xCondDataSize), 3520, 3526, 0,
	/*3520*/ uint16(xSetOp), uint16(CMOVNO),
	/*3522*/ uint16(xReadSlashR),
	/*3523*/ uint16(xArgR16),
	/*3524*/ uint16(xArgRM16),
	/*3525*/ uint16(xMatch),
	/*3526*/ uint16(xSetOp), uint16(CMOVNO),
	/*3528*/ uint16(xReadSlashR),
	/*3529*/ uint16(xArgR32),
	/*3530*/ uint16(xArgRM32),
	/*3531*/ uint16(xMatch),
	/*3532*/ uint16(xCondDataSize), 3520, 3526, 3536,
	/*3536*/ uint16(xSetOp), uint16(CMOVNO),
	/*3538*/ uint16(xReadSlashR),
	/*3539*/ uint16(xArgR64),
	/*3540*/ uint16(xArgRM64),
	/*3541*/ uint16(xMatch),
	/*3542*/ uint16(xCondIs64), 3545, 3561,
	/*3545*/ uint16(xCondDataSize), 3549, 3555, 0,
	/*3549*/ uint16(xSetOp), uint16(CMOVB),
	/*3551*/ uint16(xReadSlashR),
	/*3552*/ uint16(xArgR16),
	/*3553*/ uint16(xArgRM16),
	/*3554*/ uint16(xMatch),
	/*3555*/ uint16(xSetOp), uint16(CMOVB),
	/*3557*/ uint16(xReadSlashR),
	/*3558*/ uint16(xArgR32),
	/*3559*/ uint16(xArgRM32),
	/*3560*/ uint16(xMatch),
	/*3561*/ uint16(xCondDataSize), 3549, 3555, 3565,
	/*3565*/ uint16(xSetOp), uint16(CMOVB),
	/*3567*/ uint16(xReadSlashR),
	/*3568*/ uint16(xArgR64),
	/*3569*/ uint16(xArgRM64),
	/*3570*/ uint16(xMatch),
	/*3571*/ uint16(xCondIs64), 3574, 3590,
	/*3574*/ uint16(xCondDataSize), 3578, 3584, 0,
	/*3578*/ uint16(xSetOp), uint16(CMOVAE),
	/*3580*/ uint16(xReadSlashR),
	/*3581*/ uint16(xArgR16),
	/*3582*/ uint16(xArgRM16),
	/*3583*/ uint16(xMatch),
	/*3584*/ uint16(xSetOp), uint16(CMOVAE),
	/*3586*/ uint16(xReadSlashR),
	/*3587*/ uint16(xArgR32),
	/*3588*/ uint16(xArgRM32),
	/*3589*/ uint16(xMatch),
	/*3590*/ uint16(xCondDataSize), 3578, 3584, 3594,
	/*3594*/ uint16(xSetOp), uint16(CMOVAE),
	/*3596*/ uint16(xReadSlashR),
	/*3597*/ uint16(xArgR64),
	/*3598*/ uint16(xArgRM64),
	/*3599*/ uint16(xMatch),
	/*3600*/ uint16(xCondIs64), 3603, 3619,
	/*3603*/ uint16(xCondDataSize), 3607, 3613, 0,
	/*3607*/ uint16(xSetOp), uint16(CMOVE),
	/*3609*/ uint16(xReadSlashR),
	/*3610*/ uint16(xArgR16),
	/*3611*/ uint16(xArgRM16),
	/*3612*/ uint16(xMatch),
	/*3613*/ uint16(xSetOp), uint16(CMOVE),
	/*3615*/ uint16(xReadSlashR),
	/*3616*/ uint16(xArgR32),
	/*3617*/ uint16(xArgRM32),
	/*3618*/ uint16(xMatch),
	/*3619*/ uint16(xCondDataSize), 3607, 3613, 3623,
	/*3623*/ uint16(xSetOp), uint16(CMOVE),
	/*3625*/ uint16(xReadSlashR),
	/*3626*/ uint16(xArgR64),
	/*3627*/ uint16(xArgRM64),
	/*3628*/ uint16(xMatch),
	/*3629*/ uint16(xCondIs64), 3632, 3648,
	/*3632*/ uint16(xCondDataSize), 3636, 3642, 0,
	/*3636*/ uint16(xSetOp), uint16(CMOVNE),
	/*3638*/ uint16(xReadSlashR),
	/*3639*/ uint16(xArgR16),
	/*3640*/ uint16(xArgRM16),
	/*3641*/ uint16(xMatch),
	/*3642*/ uint16(xSetOp), uint16(CMOVNE),
	/*3644*/ uint16(xReadSlashR),
	/*3645*/ uint16(xArgR32),
	/*3646*/ uint16(xArgRM32),
	/*3647*/ uint16(xMatch),
	/*3648*/ uint16(xCondDataSize), 3636, 3642, 3652,
	/*3652*/ uint16(xSetOp), uint16(CMOVNE),
	/*3654*/ uint16(xReadSlashR),
	/*3655*/ uint16(xArgR64),
	/*3656*/ uint16(xArgRM64),
	/*3657*/ uint16(xMatch),
	/*3658*/ uint16(xCondIs64), 3661, 3677,
	/*3661*/ uint16(xCondDataSize), 3665, 3671, 0,
	/*3665*/ uint16(xSetOp), uint16(CMOVBE),
	/*3667*/ uint16(xReadSlashR),
	/*3668*/ uint16(xArgR16),
	/*3669*/ uint16(xArgRM16),
	/*3670*/ uint16(xMatch),
	/*3671*/ uint16(xSetOp), uint16(CMOVBE),
	/*3673*/ uint16(xReadSlashR),
	/*3674*/ uint16(xArgR32),
	/*3675*/ uint16(xArgRM32),
	/*3676*/ uint16(xMatch),
	/*3677*/ uint16(xCondDataSize), 3665, 3671, 3681,
	/*3681*/ uint16(xSetOp), uint16(CMOVBE),
	/*3683*/ uint16(xReadSlashR),
	/*3684*/ uint16(xArgR64),
	/*3685*/ uint16(xArgRM64),
	/*3686*/ uint16(xMatch),
	/*3687*/ uint16(xCondIs64), 3690, 3706,
	/*3690*/ uint16(xCondDataSize), 3694, 3700, 0,
	/*3694*/ uint16(xSetOp), uint16(CMOVA),
	/*3696*/ uint16(xReadSlashR),
	/*3697*/ uint16(xArgR16),
	/*3698*/ uint16(xArgRM16),
	/*3699*/ uint16(xMatch),
	/*3700*/ uint16(xSetOp), uint16(CMOVA),
	/*3702*/ uint16(xReadSlashR),
	/*3703*/ uint16(xArgR32),
	/*3704*/ uint16(xArgRM32),
	/*3705*/ uint16(xMatch),
	/*3706*/ uint16(xCondDataSize), 3694, 3700, 3710,
	/*3710*/ uint16(xSetOp), uint16(CMOVA),
	/*3712*/ uint16(xReadSlashR),
	/*3713*/ uint16(xArgR64),
	/*3714*/ uint16(xArgRM64),
	/*3715*/ uint16(xMatch),
	/*3716*/ uint16(xCondIs64), 3719, 3735,
	/*3719*/ uint16(xCondDataSize), 3723, 3729, 0,
	/*3723*/ uint16(xSetOp), uint16(CMOVS),
	/*3725*/ uint16(xReadSlashR),
	/*3726*/ uint16(xArgR16),
	/*3727*/ uint16(xArgRM16),
	/*3728*/ uint16(xMatch),
	/*3729*/ uint16(xSetOp), uint16(CMOVS),
	/*3731*/ uint16(xReadSlashR),
	/*3732*/ uint16(xArgR32),
	/*3733*/ uint16(xArgRM32),
	/*3734*/ uint16(xMatch),
	/*3735*/ uint16(xCondDataSize), 3723, 3729, 3739,
	/*3739*/ uint16(xSetOp), uint16(CMOVS),
	/*3741*/ uint16(xReadSlashR),
	/*3742*/ uint16(xArgR64),
	/*3743*/ uint16(xArgRM64),
	/*3744*/ uint16(xMatch),
	/*3745*/ uint16(xCondIs64), 3748, 3764,
	/*3748*/ uint16(xCondDataSize), 3752, 3758, 0,
	/*3752*/ uint16(xSetOp), uint16(CMOVNS),
	/*3754*/ uint16(xReadSlashR),
	/*3755*/ uint16(xArgR16),
	/*3756*/ uint16(xArgRM16),
	/*3757*/ uint16(xMatch),
	/*3758*/ uint16(xSetOp), uint16(CMOVNS),
	/*3760*/ uint16(xReadSlashR),
	/*3761*/ uint16(xArgR32),
	/*3762*/ uint16(xArgRM32),
	/*3763*/ uint16(xMatch),
	/*3764*/ uint16(xCondDataSize), 3752, 3758, 3768,
	/*3768*/ uint16(xSetOp), uint16(CMOVNS),
	/*3770*/ uint16(xReadSlashR),
	/*3771*/ uint16(xArgR64),
	/*3772*/ uint16(xArgRM64),
	/*3773*/ uint16(xMatch),
	/*3774*/ uint16(xCondIs64), 3777, 3793,
	/*3777*/ uint16(xCondDataSize), 3781, 3787, 0,
	/*3781*/ uint16(xSetOp), uint16(CMOVP),
	/*3783*/ uint16(xReadSlashR),
	/*3784*/ uint16(xArgR16),
	/*3785*/ uint16(xArgRM16),
	/*3786*/ uint16(xMatch),
	/*3787*/ uint16(xSetOp), uint16(CMOVP),
	/*3789*/ uint16(xReadSlashR),
	/*3790*/ uint16(xArgR32),
	/*3791*/ uint16(xArgRM32),
	/*3792*/ uint16(xMatch),
	/*3793*/ uint16(xCondDataSize), 3781, 3787, 3797,
	/*3797*/ uint16(xSetOp), uint16(CMOVP),
	/*3799*/ uint16(xReadSlashR),
	/*3800*/ uint16(xArgR64),
	/*3801*/ uint16(xArgRM64),
	/*3802*/ uint16(xMatch),
	/*3803*/ uint16(xCondIs64), 3806, 3822,
	/*3806*/ uint16(xCondDataSize), 3810, 3816, 0,
	/*3810*/ uint16(xSetOp), uint16(CMOVNP),
	/*3812*/ uint16(xReadSlashR),
	/*3813*/ uint16(xArgR16),
	/*3814*/ uint16(xArgRM16),
	/*3815*/ uint16(xMatch),
	/*3816*/ uint16(xSetOp), uint16(CMOVNP),
	/*3818*/ uint16(xReadSlashR),
	/*3819*/ uint16(xArgR32),
	/*3820*/ uint16(xArgRM32),
	/*3821*/ uint16(xMatch),
	/*3822*/ uint16(xCondDataSize), 3810, 3816, 3826,
	/*3826*/ uint16(xSetOp), uint16(CMOVNP),
	/*3828*/ uint16(xReadSlashR),
	/*3829*/ uint16(xArgR64),
	/*3830*/ uint16(xArgRM64),
	/*3831*/ uint16(xMatch),
	/*3832*/ uint16(xCondIs64), 3835, 3851,
	/*3835*/ uint16(xCondDataSize), 3839, 3845, 0,
	/*3839*/ uint16(xSetOp), uint16(CMOVL),
	/*3841*/ uint16(xReadSlashR),
	/*3842*/ uint16(xArgR16),
	/*3843*/ uint16(xArgRM16),
	/*3844*/ uint16(xMatch),
	/*3845*/ uint16(xSetOp), uint16(CMOVL),
	/*3847*/ uint16(xReadSlashR),
	/*3848*/ uint16(xArgR32),
	/*3849*/ uint16(xArgRM32),
	/*3850*/ uint16(xMatch),
	/*3851*/ uint16(xCondDataSize), 3839, 3845, 3855,
	/*3855*/ uint16(xSetOp), uint16(CMOVL),
	/*3857*/ uint16(xReadSlashR),
	/*3858*/ uint16(xArgR64),
	/*3859*/ uint16(xArgRM64),
	/*3860*/ uint16(xMatch),
	/*3861*/ uint16(xCondIs64), 3864, 3880,
	/*3864*/ uint16(xCondDataSize), 3868, 3874, 0,
	/*3868*/ uint16(xSetOp), uint16(CMOVGE),
	/*3870*/ uint16(xReadSlashR),
	/*3871*/ uint16(xArgR16),
	/*3872*/ uint16(xArgRM16),
	/*3873*/ uint16(xMatch),
	/*3874*/ uint16(xSetOp), uint16(CMOVGE),
	/*3876*/ uint16(xReadSlashR),
	/*3877*/ uint16(xArgR32),
	/*3878*/ uint16(xArgRM32),
	/*3879*/ uint16(xMatch),
	/*3880*/ uint16(xCondDataSize), 3868, 3874, 3884,
	/*3884*/ uint16(xSetOp), uint16(CMOVGE),
	/*3886*/ uint16(xReadSlashR),
	/*3887*/ uint16(xArgR64),
	/*3888*/ uint16(xArgRM64),
	/*3889*/ uint16(xMatch),
	/*3890*/ uint16(xCondIs64), 3893, 3909,
	/*3893*/ uint16(xCondDataSize), 3897, 3903, 0,
	/*3897*/ uint16(xSetOp), uint16(CMOVLE),
	/*3899*/ uint16(xReadSlashR),
	/*3900*/ uint16(xArgR16),
	/*3901*/ uint16(xArgRM16),
	/*3902*/ uint16(xMatch),
	/*3903*/ uint16(xSetOp), uint16(CMOVLE),
	/*3905*/ uint16(xReadSlashR),
	/*3906*/ uint16(xArgR32),
	/*3907*/ uint16(xArgRM32),
	/*3908*/ uint16(xMatch),
	/*3909*/ uint16(xCondDataSize), 3897, 3903, 3913,
	/*3913*/ uint16(xSetOp), uint16(CMOVLE),
	/*3915*/ uint16(xReadSlashR),
	/*3916*/ uint16(xArgR64),
	/*3917*/ uint16(xArgRM64),
	/*3918*/ uint16(xMatch),
	/*3919*/ uint16(xCondIs64), 3922, 3938,
	/*3922*/ uint16(xCondDataSize), 3926, 3932, 0,
	/*3926*/ uint16(xSetOp), uint16(CMOVG),
	/*3928*/ uint16(xReadSlashR),
	/*3929*/ uint16(xArgR16),
	/*3930*/ uint16(xArgRM16),
	/*3931*/ uint16(xMatch),
	/*3932*/ uint16(xSetOp), uint16(CMOVG),
	/*3934*/ uint16(xReadSlashR),
	/*3935*/ uint16(xArgR32),
	/*3936*/ uint16(xArgRM32),
	/*3937*/ uint16(xMatch),
	/*3938*/ uint16(xCondDataSize), 3926, 3932, 3942,
	/*3942*/ uint16(xSetOp), uint16(CMOVG),
	/*3944*/ uint16(xReadSlashR),
	/*3945*/ uint16(xArgR64),
	/*3946*/ uint16(xArgRM64),
	/*3947*/ uint16(xMatch),
	/*3948*/ uint16(xCondPrefix), 2,
	0x66, 3960,
	0x0, 3954,
	/*3954*/ uint16(xSetOp), uint16(MOVMSKPS),
	/*3956*/ uint16(xReadSlashR),
	/*3957*/ uint16(xArgR32),
	/*3958*/ uint16(xArgXmm2),
	/*3959*/ uint16(xMatch),
	/*3960*/ uint16(xSetOp), uint16(MOVMSKPD),
	/*3962*/ uint16(xReadSlashR),
	/*3963*/ uint16(xArgR32),
	/*3964*/ uint16(xArgXmm2),
	/*3965*/ uint16(xMatch),
	/*3966*/ uint16(xCondPrefix), 4,
	0xF3, 3994,
	0xF2, 3988,
	0x66, 3982,
	0x0, 3976,
	/*3976*/ uint16(xSetOp), uint16(SQRTPS),
	/*3978*/ uint16(xReadSlashR),
	/*3979*/ uint16(xArgXmm1),
	/*3980*/ uint16(xArgXmm2M128),
	/*3981*/ uint16(xMatch),
	/*3982*/ uint16(xSetOp), uint16(SQRTPD),
	/*3984*/ uint16(xReadSlashR),
	/*3985*/ uint16(xArgXmm1),
	/*3986*/ uint16(xArgXmm2M128),
	/*3987*/ uint16(xMatch),
	/*3988*/ uint16(xSetOp), uint16(SQRTSD),
	/*3990*/ uint16(xReadSlashR),
	/*3991*/ uint16(xArgXmm1),
	/*3992*/ uint16(xArgXmm2M64),
	/*3993*/ uint16(xMatch),
	/*3994*/ uint16(xSetOp), uint16(SQRTSS),
	/*3996*/ uint16(xReadSlashR),
	/*3997*/ uint16(xArgXmm1),
	/*3998*/ uint16(xArgXmm2M32),
	/*3999*/ uint16(xMatch),
	/*4000*/ uint16(xCondPrefix), 2,
	0xF3, 4012,
	0x0, 4006,
	/*4006*/ uint16(xSetOp), uint16(RSQRTPS),
	/*4008*/ uint16(xReadSlashR),
	/*4009*/ uint16(xArgXmm1),
	/*4010*/ uint16(xArgXmm2M128),
	/*4011*/ uint16(xMatch),
	/*4012*/ uint16(xSetOp), uint16(RSQRTSS),
	/*4014*/ uint16(xReadSlashR),
	/*4015*/ uint16(xArgXmm1),
	/*4016*/ uint16(xArgXmm2M32),
	/*4017*/ uint16(xMatch),
	/*4018*/ uint16(xCondPrefix), 2,
	0xF3, 4030,
	0x0, 4024,
	/*4024*/ uint16(xSetOp), uint16(RCPPS),
	/*4026*/ uint16(xReadSlashR),
	/*4027*/ uint16(xArgXmm1),
	/*4028*/ uint16(xArgXmm2M128),
	/*4029*/ uint16(xMatch),
	/*4030*/ uint16(xSetOp), uint16(RCPSS),
	/*4032*/ uint16(xReadSlashR),
	/*4033*/ uint16(xArgXmm1),
	/*4034*/ uint16(xArgXmm2M32),
	/*4035*/ uint16(xMatch),
	/*4036*/ uint16(xCondPrefix), 2,
	0x66, 4048,
	0x0, 4042,
	/*4042*/ uint16(xSetOp), uint16(ANDPS),
	/*4044*/ uint16(xReadSlashR),
	/*4045*/ uint16(xArgXmm1),
	/*4046*/ uint16(xArgXmm2M128),
	/*4047*/ uint16(xMatch),
	/*4048*/ uint16(xSetOp), uint16(ANDPD),
	/*4050*/ uint16(xReadSlashR),
	/*4051*/ uint16(xArgXmm1),
	/*4052*/ uint16(xArgXmm2M128),
	/*4053*/ uint16(xMatch),
	/*4054*/ uint16(xCondPrefix), 2,
	0x66, 4066,
	0x0, 4060,
	/*4060*/ uint16(xSetOp), uint16(ANDNPS),
	/*4062*/ uint16(xReadSlashR),
	/*4063*/ uint16(xArgXmm1),
	/*4064*/ uint16(xArgXmm2M128),
	/*4065*/ uint16(xMatch),
	/*4066*/ uint16(xSetOp), uint16(ANDNPD),
	/*4068*/ uint16(xReadSlashR),
	/*4069*/ uint16(xArgXmm1),
	/*4070*/ uint16(xArgXmm2M128),
	/*4071*/ uint16(xMatch),
	/*4072*/ uint16(xCondPrefix), 2,
	0x66, 4084,
	0x0, 4078,
	/*4078*/ uint16(xSetOp), uint16(ORPS),
	/*4080*/ uint16(xReadSlashR),
	/*4081*/ uint16(xArgXmm1),
	/*4082*/ uint16(xArgXmm2M128),
	/*4083*/ uint16(xMatch),
	/*4084*/ uint16(xSetOp), uint16(ORPD),
	/*4086*/ uint16(xReadSlashR),
	/*4087*/ uint16(xArgXmm1),
	/*4088*/ uint16(xArgXmm2M128),
	/*4089*/ uint16(xMatch),
	/*4090*/ uint16(xCondPrefix), 2,
	0x66, 4102,
	0x0, 4096,
	/*4096*/ uint16(xSetOp), uint16(XORPS),
	/*4098*/ uint16(xReadSlashR),
	/*4099*/ uint16(xArgXmm1),
	/*4100*/ uint16(xArgXmm2M128),
	/*4101*/ uint16(xMatch),
	/*4102*/ uint16(xSetOp), uint16(XORPD),
	/*4104*/ uint16(xReadSlashR),
	/*4105*/ uint16(xArgXmm1),
	/*4106*/ uint16(xArgXmm2M128),
	/*4107*/ uint16(xMatch),
	/*4108*/ uint16(xCondPrefix), 4,
	0xF3, 4136,
	0xF2, 4130,
	0x66, 4124,
	0x0, 4118,
	/*4118*/ uint16(xSetOp), uint16(ADDPS),
	/*4120*/ uint16(xReadSlashR),
	/*4121*/ uint16(xArgXmm1),
	/*4122*/ uint16(xArgXmm2M128),
	/*4123*/ uint16(xMatch),
	/*4124*/ uint16(xSetOp), uint16(ADDPD),
	/*4126*/ uint16(xReadSlashR),
	/*4127*/ uint16(xArgXmm1),
	/*4128*/ uint16(xArgXmm2M128),
	/*4129*/ uint16(xMatch),
	/*4130*/ uint16(xSetOp), uint16(ADDSD),
	/*4132*/ uint16(xReadSlashR),
	/*4133*/ uint16(xArgXmm1),
	/*4134*/ uint16(xArgXmm2M64),
	/*4135*/ uint16(xMatch),
	/*4136*/ uint16(xSetOp), uint16(ADDSS),
	/*4138*/ uint16(xReadSlashR),
	/*4139*/ uint16(xArgXmm1),
	/*4140*/ uint16(xArgXmm2M32),
	/*4141*/ uint16(xMatch),
	/*4142*/ uint16(xCondPrefix), 4,
	0xF3, 4170,
	0xF2, 4164,
	0x66, 4158,
	0x0, 4152,
	/*4152*/ uint16(xSetOp), uint16(MULPS),
	/*4154*/ uint16(xReadSlashR),
	/*4155*/ uint16(xArgXmm1),
	/*4156*/ uint16(xArgXmm2M128),
	/*4157*/ uint16(xMatch),
	/*4158*/ uint16(xSetOp), uint16(MULPD),
	/*4160*/ uint16(xReadSlashR),
	/*4161*/ uint16(xArgXmm1),
	/*4162*/ uint16(xArgXmm2M128),
	/*4163*/ uint16(xMatch),
	/*4164*/ uint16(xSetOp), uint16(MULSD),
	/*4166*/ uint16(xReadSlashR),
	/*4167*/ uint16(xArgXmm1),
	/*4168*/ uint16(xArgXmm2M64),
	/*4169*/ uint16(xMatch),
	/*4170*/ uint16(xSetOp), uint16(MULSS),
	/*4172*/ uint16(xReadSlashR),
	/*4173*/ uint16(xArgXmm1),
	/*4174*/ uint16(xArgXmm2M32),
	/*4175*/ uint16(xMatch),
	/*4176*/ uint16(xCondPrefix), 4,
	0xF3, 4204,
	0xF2, 4198,
	0x66, 4192,
	0x0, 4186,
	/*4186*/ uint16(xSetOp), uint16(CVTPS2PD),
	/*4188*/ uint16(xReadSlashR),
	/*4189*/ uint16(xArgXmm1),
	/*4190*/ uint16(xArgXmm2M64),
	/*4191*/ uint16(xMatch),
	/*4192*/ uint16(xSetOp), uint16(CVTPD2PS),
	/*4194*/ uint16(xReadSlashR),
	/*4195*/ uint16(xArgXmm1),
	/*4196*/ uint16(xArgXmm2M128),
	/*4197*/ uint16(xMatch),
	/*4198*/ uint16(xSetOp), uint16(CVTSD2SS),
	/*4200*/ uint16(xReadSlashR),
	/*4201*/ uint16(xArgXmm1),
	/*4202*/ uint16(xArgXmm2M64),
	/*4203*/ uint16(xMatch),
	/*4204*/ uint16(xSetOp), uint16(CVTSS2SD),
	/*4206*/ uint16(xReadSlashR),
	/*4207*/ uint16(xArgXmm1),
	/*4208*/ uint16(xArgXmm2M32),
	/*4209*/ uint16(xMatch),
	/*4210*/ uint16(xCondPrefix), 3,
	0xF3, 4230,
	0x66, 4224,
	0x0, 4218,
	/*4218*/ uint16(xSetOp), uint16(CVTDQ2PS),
	/*4220*/ uint16(xReadSlashR),
	/*4221*/ uint16(xArgXmm1),
	/*4222*/ uint16(xArgXmm2M128),
	/*4223*/ uint16(xMatch),
	/*4224*/ uint16(xSetOp), uint16(CVTPS2DQ),
	/*4226*/ uint16(xReadSlashR),
	/*4227*/ uint16(xArgXmm1),
	/*4228*/ uint16(xArgXmm2M128),
	/*4229*/ uint16(xMatch),
	/*4230*/ uint16(xSetOp), uint16(CVTTPS2DQ),
	/*4232*/ uint16(xReadSlashR),
	/*4233*/ uint16(xArgXmm1),
	/*4234*/ uint16(xArgXmm2M128),
	/*4235*/ uint16(xMatch),
	/*4236*/ uint16(xCondPrefix), 4,
	0xF3, 4264,
	0xF2, 4258,
	0x66, 4252,
	0x0, 4246,
	/*4246*/ uint16(xSetOp), uint16(SUBPS),
	/*4248*/ uint16(xReadSlashR),
	/*4249*/ uint16(xArgXmm1),
	/*4250*/ uint16(xArgXmm2M128),
	/*4251*/ uint16(xMatch),
	/*4252*/ uint16(xSetOp), uint16(SUBPD),
	/*4254*/ uint16(xReadSlashR),
	/*4255*/ uint16(xArgXmm1),
	/*4256*/ uint16(xArgXmm2M128),
	/*4257*/ uint16(xMatch),
	/*4258*/ uint16(xSetOp), uint16(SUBSD),
	/*4260*/ uint16(xReadSlashR),
	/*4261*/ uint16(xArgXmm1),
	/*4262*/ uint16(xArgXmm2M64),
	/*4263*/ uint16(xMatch),
	/*4264*/ uint16(xSetOp), uint16(SUBSS),
	/*4266*/ uint16(xReadSlashR),
	/*4267*/ uint16(xArgXmm1),
	/*4268*/ uint16(xArgXmm2M32),
	/*4269*/ uint16(xMatch),
	/*4270*/ uint16(xCondPrefix), 4,
	0xF3, 4298,
	0xF2, 4292,
	0x66, 4286,
	0x0, 4280,
	/*4280*/ uint16(xSetOp), uint16(MINPS),
	/*4282*/ uint16(xReadSlashR),
	/*4283*/ uint16(xArgXmm1),
	/*4284*/ uint16(xArgXmm2M128),
	/*4285*/ uint16(xMatch),
	/*4286*/ uint16(xSetOp), uint16(MINPD),
	/*4288*/ uint16(xReadSlashR),
	/*4289*/ uint16(xArgXmm1),
	/*4290*/ uint16(xArgXmm2M128),
	/*4291*/ uint16(xMatch),
	/*4292*/ uint16(xSetOp), uint16(MINSD),
	/*4294*/ uint16(xReadSlashR),
	/*4295*/ uint16(xArgXmm1),
	/*4296*/ uint16(xArgXmm2M64),
	/*4297*/ uint16(xMatch),
	/*4298*/ uint16(xSetOp), uint16(MINSS),
	/*4300*/ uint16(xReadSlashR),
	/*4301*/ uint16(xArgXmm1),
	/*4302*/ uint16(xArgXmm2M32),
	/*4303*/ uint16(xMatch),
	/*4304*/ uint16(xCondPrefix), 4,
	0xF3, 4332,
	0xF2, 4326,
	0x66, 4320,
	0x0, 4314,
	/*4314*/ uint16(xSetOp), uint16(DIVPS),
	/*4316*/ uint16(xReadSlashR),
	/*4317*/ uint16(xArgXmm1),
	/*4318*/ uint16(xArgXmm2M128),
	/*4319*/ uint16(xMatch),
	/*4320*/ uint16(xSetOp), uint16(DIVPD),
	/*4322*/ uint16(xReadSlashR),
	/*4323*/ uint16(xArgXmm1),
	/*4324*/ uint16(xArgXmm2M128),
	/*4325*/ uint16(xMatch),
	/*4326*/ uint16(xSetOp), uint16(DIVSD),
	/*4328*/ uint16(xReadSlashR),
	/*4329*/ uint16(xArgXmm1),
	/*4330*/ uint16(xArgXmm2M64),
	/*4331*/ uint16(xMatch),
	/*4332*/ uint16(xSetOp), uint16(DIVSS),
	/*4334*/ uint16(xReadSlashR),
	/*4335*/ uint16(xArgXmm1),
	/*4336*/ uint16(xArgXmm2M32),
	/*4337*/ uint16(xMatch),
	/*4338*/ uint16(xCondPrefix), 4,
	0xF3, 4366,
	0xF2, 4360,
	0x66, 4354,
	0x0, 4348,
	/*4348*/ uint16(xSetOp), uint16(MAXPS),
	/*4350*/ uint16(xReadSlashR),
	/*4351*/ uint16(xArgXmm1),
	/*4352*/ uint16(xArgXmm2M128),
	/*4353*/ uint16(xMatch),
	/*4354*/ uint16(xSetOp), uint16(MAXPD),
	/*4356*/ uint16(xReadSlashR),
	/*4357*/ uint16(xArgXmm1),
	/*4358*/ uint16(xArgXmm2M128),
	/*4359*/ uint16(xMatch),
	/*4360*/ uint16(xSetOp), uint16(MAXSD),
	/*4362*/ uint16(xReadSlashR),
	/*4363*/ uint16(xArgXmm1),
	/*4364*/ uint16(xArgXmm2M64),
	/*4365*/ uint16(xMatch),
	/*4366*/ uint16(xSetOp), uint16(MAXSS),
	/*4368*/ uint16(xReadSlashR),
	/*4369*/ uint16(xArgXmm1),
	/*4370*/ uint16(xArgXmm2M32),
	/*4371*/ uint16(xMatch),
	/*4372*/ uint16(xCondPrefix), 2,
	0x66, 4384,
	0x0, 4378,
	/*4378*/ uint16(xSetOp), uint16(PUNPCKLBW),
	/*4380*/ uint16(xReadSlashR),
	/*4381*/ uint16(xArgMm),
	/*4382*/ uint16(xArgMmM32),
	/*4383*/ uint16(xMatch),
	/*4384*/ uint16(xSetOp), uint16(PUNPCKLBW),
	/*4386*/ uint16(xReadSlashR),
	/*4387*/ uint16(xArgXmm1),
	/*4388*/ uint16(xArgXmm2M128),
	/*4389*/ uint16(xMatch),
	/*4390*/ uint16(xCondPrefix), 2,
	0x66, 4402,
	0x0, 4396,
	/*4396*/ uint16(xSetOp), uint16(PUNPCKLWD),
	/*4398*/ uint16(xReadSlashR),
	/*4399*/ uint16(xArgMm),
	/*4400*/ uint16(xArgMmM32),
	/*4401*/ uint16(xMatch),
	/*4402*/ uint16(xSetOp), uint16(PUNPCKLWD),
	/*4404*/ uint16(xReadSlashR),
	/*4405*/ uint16(xArgXmm1),
	/*4406*/ uint16(xArgXmm2M128),
	/*4407*/ uint16(xMatch),
	/*4408*/ uint16(xCondPrefix), 2,
	0x66, 4420,
	0x0, 4414,
	/*4414*/ uint16(xSetOp), uint16(PUNPCKLDQ),
	/*4416*/ uint16(xReadSlashR),
	/*4417*/ uint16(xArgMm),
	/*4418*/ uint16(xArgMmM32),
	/*4419*/ uint16(xMatch),
	/*4420*/ uint16(xSetOp), uint16(PUNPCKLDQ),
	/*4422*/ uint16(xReadSlashR),
	/*4423*/ uint16(xArgXmm1),
	/*4424*/ uint16(xArgXmm2M128),
	/*4425*/ uint16(xMatch),
	/*4426*/ uint16(xCondPrefix), 2,
	0x66, 4438,
	0x0, 4432,
	/*4432*/ uint16(xSetOp), uint16(PACKSSWB),
	/*4434*/ uint16(xReadSlashR),
	/*4435*/ uint16(xArgMm1),
	/*4436*/ uint16(xArgMm2M64),
	/*4437*/ uint16(xMatch),
	/*4438*/ uint16(xSetOp), uint16(PACKSSWB),
	/*4440*/ uint16(xReadSlashR),
	/*4441*/ uint16(xArgXmm1),
	/*4442*/ uint16(xArgXmm2M128),
	/*4443*/ uint16(xMatch),
	/*4444*/ uint16(xCondPrefix), 2,
	0x66, 4456,
	0x0, 4450,
	/*4450*/ uint16(xSetOp), uint16(PCMPGTB),
	/*4452*/ uint16(xReadSlashR),
	/*4453*/ uint16(xArgMm),
	/*4454*/ uint16(xArgMmM64),
	/*4455*/ uint16(xMatch),
	/*4456*/ uint16(xSetOp), uint16(PCMPGTB),
	/*4458*/ uint16(xReadSlashR),
	/*4459*/ uint16(xArgXmm1),
	/*4460*/ uint16(xArgXmm2M128),
	/*4461*/ uint16(xMatch),
	/*4462*/ uint16(xCondPrefix), 2,
	0x66, 4474,
	0x0, 4468,
	/*4468*/ uint16(xSetOp), uint16(PCMPGTW),
	/*4470*/ uint16(xReadSlashR),
	/*4471*/ uint16(xArgMm),
	/*4472*/ uint16(xArgMmM64),
	/*4473*/ uint16(xMatch),
	/*4474*/ uint16(xSetOp), uint16(PCMPGTW),
	/*4476*/ uint16(xReadSlashR),
	/*4477*/ uint16(xArgXmm1),
	/*4478*/ uint16(xArgXmm2M128),
	/*4479*/ uint16(xMatch),
	/*4480*/ uint16(xCondPrefix), 2,
	0x66, 4492,
	0x0, 4486,
	/*4486*/ uint16(xSetOp), uint16(PCMPGTD),
	/*4488*/ uint16(xReadSlashR),
	/*4489*/ uint16(xArgMm),
	/*4490*/ uint16(xArgMmM64),
	/*4491*/ uint16(xMatch),
	/*4492*/ uint16(xSetOp), uint16(PCMPGTD),
	/*4494*/ uint16(xReadSlashR),
	/*4495*/ uint16(xArgXmm1),
	/*4496*/ uint16(xArgXmm2M128),
	/*4497*/ uint16(xMatch),
	/*4498*/ uint16(xCondPrefix), 2,
	0x66, 4510,
	0x0, 4504,
	/*4504*/ uint16(xSetOp), uint16(PACKUSWB),
	/*4506*/ uint16(xReadSlashR),
	/*4507*/ uint16(xArgMm),
	/*4508*/ uint16(xArgMmM64),
	/*4509*/ uint16(xMatch),
	/*4510*/ uint16(xSetOp), uint16(PACKUSWB),
	/*4512*/ uint16(xReadSlashR),
	/*4513*/ uint16(xArgXmm1),
	/*4514*/ uint16(xArgXmm2M128),
	/*4515*/ uint16(xMatch),
	/*4516*/ uint16(xCondPrefix), 2,
	0x66, 4528,
	0x0, 4522,
	/*4522*/ uint16(xSetOp), uint16(PUNPCKHBW),
	/*4524*/ uint16(xReadSlashR),
	/*4525*/ uint16(xArgMm),
	/*4526*/ uint16(xArgMmM64),
	/*4527*/ uint16(xMatch),
	/*4528*/ uint16(xSetOp), uint16(PUNPCKHBW),
	/*4530*/ uint16(xReadSlashR),
	/*4531*/ uint16(xArgXmm1),
	/*4532*/ uint16(xArgXmm2M128),
	/*4533*/ uint16(xMatch),
	/*4534*/ uint16(xCondPrefix), 2,
	0x66, 4546,
	0x0, 4540,
	/*4540*/ uint16(xSetOp), uint16(PUNPCKHWD),
	/*4542*/ uint16(xReadSlashR),
	/*4543*/ uint16(xArgMm),
	/*4544*/ uint16(xArgMmM64),
	/*4545*/ uint16(xMatch),
	/*4546*/ uint16(xSetOp), uint16(PUNPCKHWD),
	/*4548*/ uint16(xReadSlashR),
	/*4549*/ uint16(xArgXmm1),
	/*4550*/ uint16(xArgXmm2M128),
	/*4551*/ uint16(xMatch),
	/*4552*/ uint16(xCondPrefix), 2,
	0x66, 4564,
	0x0, 4558,
	/*4558*/ uint16(xSetOp), uint16(PUNPCKHDQ),
	/*4560*/ uint16(xReadSlashR),
	/*4561*/ uint16(xArgMm),
	/*4562*/ uint16(xArgMmM64),
	/*4563*/ uint16(xMatch),
	/*4564*/ uint16(xSetOp), uint16(PUNPCKHDQ),
	/*4566*/ uint16(xReadSlashR),
	/*4567*/ uint16(xArgXmm1),
	/*4568*/ uint16(xArgXmm2M128),
	/*4569*/ uint16(xMatch),
	/*4570*/ uint16(xCondPrefix), 2,
	0x66, 4582,
	0x0, 4576,
	/*4576*/ uint16(xSetOp), uint16(PACKSSDW),
	/*4578*/ uint16(xReadSlashR),
	/*4579*/ uint16(xArgMm1),
	/*4580*/ uint16(xArgMm2M64),
	/*4581*/ uint16(xMatch),
	/*4582*/ uint16(xSetOp), uint16(PACKSSDW),
	/*4584*/ uint16(xReadSlashR),
	/*4585*/ uint16(xArgXmm1),
	/*4586*/ uint16(xArgXmm2M128),
	/*4587*/ uint16(xMatch),
	/*4588*/ uint16(xCondPrefix), 1,
	0x66, 4592,
	/*4592*/ uint16(xSetOp), uint16(PUNPCKLQDQ),
	/*4594*/ uint16(xReadSlashR),
	/*4595*/ uint16(xArgXmm1),
	/*4596*/ uint16(xArgXmm2M128),
	/*4597*/ uint16(xMatch),
	/*4598*/ uint16(xCondPrefix), 1,
	0x66, 4602,
	/*4602*/ uint16(xSetOp), uint16(PUNPCKHQDQ),
	/*4604*/ uint16(xReadSlashR),
	/*4605*/ uint16(xArgXmm1),
	/*4606*/ uint16(xArgXmm2M128),
	/*4607*/ uint16(xMatch),
	/*4608*/ uint16(xCondIs64), 4611, 4649,
	/*4611*/ uint16(xCondPrefix), 2,
	0x66, 4633,
	0x0, 4617,
	/*4617*/ uint16(xCondDataSize), 4621, 4627, 0,
	/*4621*/ uint16(xSetOp), uint16(MOVD),
	/*4623*/ uint16(xReadSlashR),
	/*4624*/ uint16(xArgMm),
	/*4625*/ uint16(xArgRM32),
	/*4626*/ uint16(xMatch),
	/*4627*/ uint16(xSetOp), uint16(MOVD),
	/*4629*/ uint16(xReadSlashR),
	/*4630*/ uint16(xArgMm),
	/*4631*/ uint16(xArgRM32),
	/*4632*/ uint16(xMatch),
	/*4633*/ uint16(xCondDataSize), 4637, 4643, 0,
	/*4637*/ uint16(xSetOp), uint16(MOVD),
	/*4639*/ uint16(xReadSlashR),
	/*4640*/ uint16(xArgXmm),
	/*4641*/ uint16(xArgRM32),
	/*4642*/ uint16(xMatch),
	/*4643*/ uint16(xSetOp), uint16(MOVD),
	/*4645*/ uint16(xReadSlashR),
	/*4646*/ uint16(xArgXmm),
	/*4647*/ uint16(xArgRM32),
	/*4648*/ uint16(xMatch),
	/*4649*/ uint16(xCondPrefix), 2,
	0x66, 4665,
	0x0, 4655,
	/*4655*/ uint16(xCondDataSize), 4621, 4627, 4659,
	/*4659*/ uint16(xSetOp), uint16(MOVQ),
	/*4661*/ uint16(xReadSlashR),
	/*4662*/ uint16(xArgMm),
	/*4663*/ uint16(xArgRM64),
	/*4664*/ uint16(xMatch),
	/*4665*/ uint16(xCondDataSize), 4637, 4643, 4669,
	/*4669*/ uint16(xSetOp), uint16(MOVQ),
	/*4671*/ uint16(xReadSlashR),
	/*4672*/ uint16(xArgXmm),
	/*4673*/ uint16(xArgRM64),
	/*4674*/ uint16(xMatch),
	/*4675*/ uint16(xCondPrefix), 3,
	0xF3, 4695,
	0x66, 4689,
	0x0, 4683,
	/*4683*/ uint16(xSetOp), uint16(MOVQ),
	/*4685*/ uint16(xReadSlashR),
	/*4686*/ uint16(xArgMm),
	/*4687*/ uint16(xArgMmM64),
	/*4688*/ uint16(xMatch),
	/*4689*/ uint16(xSetOp), uint16(MOVDQA),
	/*4691*/ uint16(xReadSlashR),
	/*4692*/ uint16(xArgXmm1),
	/*4693*/ uint16(xArgXmm2M128),
	/*4694*/ uint16(xMatch),
	/*4695*/ uint16(xSetOp), uint16(MOVDQU),
	/*4697*/ uint16(xReadSlashR),
	/*4698*/ uint16(xArgXmm1),
	/*4699*/ uint16(xArgXmm2M128),
	/*4700*/ uint16(xMatch),
	/*4701*/ uint16(xCondPrefix), 4,
	0xF3, 4735,
	0xF2, 4727,
	0x66, 4719,
	0x0, 4711,
	/*4711*/ uint16(xSetOp), uint16(PSHUFW),
	/*4713*/ uint16(xReadSlashR),
	/*4714*/ uint16(xReadIb),
	/*4715*/ uint16(xArgMm1),
	/*4716*/ uint16(xArgMm2M64),
	/*4717*/ uint16(xArgImm8u),
	/*4718*/ uint16(xMatch),
	/*4719*/ uint16(xSetOp), uint16(PSHUFD),
	/*4721*/ uint16(xReadSlashR),
	/*4722*/ uint16(xReadIb),
	/*4723*/ uint16(xArgXmm1),
	/*4724*/ uint16(xArgXmm2M128),
	/*4725*/ uint16(xArgImm8u),
	/*4726*/ uint16(xMatch),
	/*4727*/ uint16(xSetOp), uint16(PSHUFLW),
	/*4729*/ uint16(xReadSlashR),
	/*4730*/ uint16(xReadIb),
	/*4731*/ uint16(xArgXmm1),
	/*4732*/ uint16(xArgXmm2M128),
	/*4733*/ uint16(xArgImm8u),
	/*4734*/ uint16(xMatch),
	/*4735*/ uint16(xSetOp), uint16(PSHUFHW),
	/*4737*/ uint16(xReadSlashR),
	/*4738*/ uint16(xReadIb),
	/*4739*/ uint16(xArgXmm1),
	/*4740*/ uint16(xArgXmm2M128),
	/*4741*/ uint16(xArgImm8u),
	/*4742*/ uint16(xMatch),
	/*4743*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4752, // 2
	0,    // 3
	4770, // 4
	0,    // 5
	4788, // 6
	0,    // 7
	/*4752*/ uint16(xCondPrefix), 2,
	0x66, 4764,
	0x0, 4758,
	/*4758*/ uint16(xSetOp), uint16(PSRLW),
	/*4760*/ uint16(xReadIb),
	/*4761*/ uint16(xArgMm2),
	/*4762*/ uint16(xArgImm8u),
	/*4763*/ uint16(xMatch),
	/*4764*/ uint16(xSetOp), uint16(PSRLW),
	/*4766*/ uint16(xReadIb),
	/*4767*/ uint16(xArgXmm2),
	/*4768*/ uint16(xArgImm8u),
	/*4769*/ uint16(xMatch),
	/*4770*/ uint16(xCondPrefix), 2,
	0x66, 4782,
	0x0, 4776,
	/*4776*/ uint16(xSetOp), uint16(PSRAW),
	/*4778*/ uint16(xReadIb),
	/*4779*/ uint16(xArgMm2),
	/*4780*/ uint16(xArgImm8u),
	/*4781*/ uint16(xMatch),
	/*4782*/ uint16(xSetOp), uint16(PSRAW),
	/*4784*/ uint16(xReadIb),
	/*4785*/ uint16(xArgXmm2),
	/*4786*/ uint16(xArgImm8u),
	/*4787*/ uint16(xMatch),
	/*4788*/ uint16(xCondPrefix), 2,
	0x66, 4800,
	0x0, 4794,
	/*4794*/ uint16(xSetOp), uint16(PSLLW),
	/*4796*/ uint16(xReadIb),
	/*4797*/ uint16(xArgMm2),
	/*4798*/ uint16(xArgImm8u),
	/*4799*/ uint16(xMatch),
	/*4800*/ uint16(xSetOp), uint16(PSLLW),
	/*4802*/ uint16(xReadIb),
	/*4803*/ uint16(xArgXmm2),
	/*4804*/ uint16(xArgImm8u),
	/*4805*/ uint16(xMatch),
	/*4806*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4815, // 2
	0,    // 3
	4833, // 4
	0,    // 5
	4851, // 6
	0,    // 7
	/*4815*/ uint16(xCondPrefix), 2,
	0x66, 4827,
	0x0, 4821,
	/*4821*/ uint16(xSetOp), uint16(PSRLD),
	/*4823*/ uint16(xReadIb),
	/*4824*/ uint16(xArgMm2),
	/*4825*/ uint16(xArgImm8u),
	/*4826*/ uint16(xMatch),
	/*4827*/ uint16(xSetOp), uint16(PSRLD),
	/*4829*/ uint16(xReadIb),
	/*4830*/ uint16(xArgXmm2),
	/*4831*/ uint16(xArgImm8u),
	/*4832*/ uint16(xMatch),
	/*4833*/ uint16(xCondPrefix), 2,
	0x66, 4845,
	0x0, 4839,
	/*4839*/ uint16(xSetOp), uint16(PSRAD),
	/*4841*/ uint16(xReadIb),
	/*4842*/ uint16(xArgMm2),
	/*4843*/ uint16(xArgImm8u),
	/*4844*/ uint16(xMatch),
	/*4845*/ uint16(xSetOp), uint16(PSRAD),
	/*4847*/ uint16(xReadIb),
	/*4848*/ uint16(xArgXmm2),
	/*4849*/ uint16(xArgImm8u),
	/*4850*/ uint16(xMatch),
	/*4851*/ uint16(xCondPrefix), 2,
	0x66, 4863,
	0x0, 4857,
	/*4857*/ uint16(xSetOp), uint16(PSLLD),
	/*4859*/ uint16(xReadIb),
	/*4860*/ uint16(xArgMm2),
	/*4861*/ uint16(xArgImm8u),
	/*4862*/ uint16(xMatch),
	/*4863*/ uint16(xSetOp), uint16(PSLLD),
	/*4865*/ uint16(xReadIb),
	/*4866*/ uint16(xArgXmm2),
	/*4867*/ uint16(xArgImm8u),
	/*4868*/ uint16(xMatch),
	/*4869*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	4878, // 2
	4896, // 3
	0,    // 4
	0,    // 5
	4906, // 6
	4924, // 7
	/*4878*/ uint16(xCondPrefix), 2,
	0x66, 4890,
	0x0, 4884,
	/*4884*/ uint16(xSetOp), uint16(PSRLQ),
	/*4886*/ uint16(xReadIb),
	/*4887*/ uint16(xArgMm2),
	/*4888*/ uint16(xArgImm8u),
	/*4889*/ uint16(xMatch),
	/*4890*/ uint16(xSetOp), uint16(PSRLQ),
	/*4892*/ uint16(xReadIb),
	/*4893*/ uint16(xArgXmm2),
	/*4894*/ uint16(xArgImm8u),
	/*4895*/ uint16(xMatch),
	/*4896*/ uint16(xCondPrefix), 1,
	0x66, 4900,
	/*4900*/ uint16(xSetOp), uint16(PSRLDQ),
	/*4902*/ uint16(xReadIb),
	/*4903*/ uint16(xArgXmm2),
	/*4904*/ uint16(xArgImm8u),
	/*4905*/ uint16(xMatch),
	/*4906*/ uint16(xCondPrefix), 2,
	0x66, 4918,
	0x0, 4912,
	/*4912*/ uint16(xSetOp), uint16(PSLLQ),
	/*4914*/ uint16(xReadIb),
	/*4915*/ uint16(xArgMm2),
	/*4916*/ uint16(xArgImm8u),
	/*4917*/ uint16(xMatch),
	/*4918*/ uint16(xSetOp), uint16(PSLLQ),
	/*4920*/ uint16(xReadIb),
	/*4921*/ uint16(xArgXmm2),
	/*4922*/ uint16(xArgImm8u),
	/*4923*/ uint16(xMatch),
	/*4924*/ uint16(xCondPrefix), 1,
	0x66, 4928,
	/*4928*/ uint16(xSetOp), uint16(PSLLDQ),
	/*4930*/ uint16(xReadIb),
	/*4931*/ uint16(xArgXmm2),
	/*4932*/ uint16(xArgImm8u),
	/*4933*/ uint16(xMatch),
	/*4934*/ uint16(xCondPrefix), 2,
	0x66, 4946,
	0x0, 4940,
	/*4940*/ uint16(xSetOp), uint16(PCMPEQB),
	/*4942*/ uint16(xReadSlashR),
	/*4943*/ uint16(xArgMm),
	/*4944*/ uint16(xArgMmM64),
	/*4945*/ uint16(xMatch),
	/*4946*/ uint16(xSetOp), uint16(PCMPEQB),
	/*4948*/ uint16(xReadSlashR),
	/*4949*/ uint16(xArgXmm1),
	/*4950*/ uint16(xArgXmm2M128),
	/*4951*/ uint16(xMatch),
	/*4952*/ uint16(xCondPrefix), 2,
	0x66, 4964,
	0x0, 4958,
	/*4958*/ uint16(xSetOp), uint16(PCMPEQW),
	/*4960*/ uint16(xReadSlashR),
	/*4961*/ uint16(xArgMm),
	/*4962*/ uint16(xArgMmM64),
	/*4963*/ uint16(xMatch),
	/*4964*/ uint16(xSetOp), uint16(PCMPEQW),
	/*4966*/ uint16(xReadSlashR),
	/*4967*/ uint16(xArgXmm1),
	/*4968*/ uint16(xArgXmm2M128),
	/*4969*/ uint16(xMatch),
	/*4970*/ uint16(xCondPrefix), 2,
	0x66, 4982,
	0x0, 4976,
	/*4976*/ uint16(xSetOp), uint16(PCMPEQD),
	/*4978*/ uint16(xReadSlashR),
	/*4979*/ uint16(xArgMm),
	/*4980*/ uint16(xArgMmM64),
	/*4981*/ uint16(xMatch),
	/*4982*/ uint16(xSetOp), uint16(PCMPEQD),
	/*4984*/ uint16(xReadSlashR),
	/*4985*/ uint16(xArgXmm1),
	/*4986*/ uint16(xArgXmm2M128),
	/*4987*/ uint16(xMatch),
	/*4988*/ uint16(xSetOp), uint16(EMMS),
	/*4990*/ uint16(xMatch),
	/*4991*/ uint16(xCondPrefix), 2,
	0xF2, 5003,
	0x66, 4997,
	/*4997*/ uint16(xSetOp), uint16(HADDPD),
	/*4999*/ uint16(xReadSlashR),
	/*5000*/ uint16(xArgXmm1),
	/*5001*/ uint16(xArgXmm2M128),
	/*5002*/ uint16(xMatch),
	/*5003*/ uint16(xSetOp), uint16(HADDPS),
	/*5005*/ uint16(xReadSlashR),
	/*5006*/ uint16(xArgXmm1),
	/*5007*/ uint16(xArgXmm2M128),
	/*5008*/ uint16(xMatch),
	/*5009*/ uint16(xCondPrefix), 2,
	0xF2, 5021,
	0x66, 5015,
	/*5015*/ uint16(xSetOp), uint16(HSUBPD),
	/*5017*/ uint16(xReadSlashR),
	/*5018*/ uint16(xArgXmm1),
	/*5019*/ uint16(xArgXmm2M128),
	/*5020*/ uint16(xMatch),
	/*5021*/ uint16(xSetOp), uint16(HSUBPS),
	/*5023*/ uint16(xReadSlashR),
	/*5024*/ uint16(xArgXmm1),
	/*5025*/ uint16(xArgXmm2M128),
	/*5026*/ uint16(xMatch),
	/*5027*/ uint16(xCondIs64), 5030, 5076,
	/*5030*/ uint16(xCondPrefix), 3,
	0xF3, 5070,
	0x66, 5054,
	0x0, 5038,
	/*5038*/ uint16(xCondDataSize), 5042, 5048, 0,
	/*5042*/ uint16(xSetOp), uint16(MOVD),
	/*5044*/ uint16(xReadSlashR),
	/*5045*/ uint16(xArgRM32),
	/*5046*/ uint16(xArgMm),
	/*5047*/ uint16(xMatch),
	/*5048*/ uint16(xSetOp), uint16(MOVD),
	/*5050*/ uint16(xReadSlashR),
	/*5051*/ uint16(xArgRM32),
	/*5052*/ uint16(xArgMm),
	/*5053*/ uint16(xMatch),
	/*5054*/ uint16(xCondDataSize), 5058, 5064, 0,
	/*5058*/ uint16(xSetOp), uint16(MOVD),
	/*5060*/ uint16(xReadSlashR),
	/*5061*/ uint16(xArgRM32),
	/*5062*/ uint16(xArgXmm),
	/*5063*/ uint16(xMatch),
	/*5064*/ uint16(xSetOp), uint16(MOVD),
	/*5066*/ uint16(xReadSlashR),
	/*5067*/ uint16(xArgRM32),
	/*5068*/ uint16(xArgXmm),
	/*5069*/ uint16(xMatch),
	/*5070*/ uint16(xSetOp), uint16(MOVQ),
	/*5072*/ uint16(xReadSlashR),
	/*5073*/ uint16(xArgXmm1),
	/*5074*/ uint16(xArgXmm2M64),
	/*5075*/ uint16(xMatch),
	/*5076*/ uint16(xCondPrefix), 3,
	0xF3, 5070,
	0x66, 5094,
	0x0, 5084,
	/*5084*/ uint16(xCondDataSize), 5042, 5048, 5088,
	/*5088*/ uint16(xSetOp), uint16(MOVQ),
	/*5090*/ uint16(xReadSlashR),
	/*5091*/ uint16(xArgRM64),
	/*5092*/ uint16(xArgMm),
	/*5093*/ uint16(xMatch),
	/*5094*/ uint16(xCondDataSize), 5058, 5064, 5098,
	/*5098*/ uint16(xSetOp), uint16(MOVQ),
	/*5100*/ uint16(xReadSlashR),
	/*5101*/ uint16(xArgRM64),
	/*5102*/ uint16(xArgXmm),
	/*5103*/ uint16(xMatch),
	/*5104*/ uint16(xCondPrefix), 3,
	0xF3, 5124,
	0x66, 5118,
	0x0, 5112,
	/*5112*/ uint16(xSetOp), uint16(MOVQ),
	/*5114*/ uint16(xReadSlashR),
	/*5115*/ uint16(xArgMmM64),
	/*5116*/ uint16(xArgMm),
	/*5117*/ uint16(xMatch),
	/*5118*/ uint16(xSetOp), uint16(MOVDQA),
	/*5120*/ uint16(xReadSlashR),
	/*5121*/ uint16(xArgXmm2M128),
	/*5122*/ uint16(xArgXmm1),
	/*5123*/ uint16(xMatch),
	/*5124*/ uint16(xSetOp), uint16(MOVDQU),
	/*5126*/ uint16(xReadSlashR),
	/*5127*/ uint16(xArgXmm2M128),
	/*5128*/ uint16(xArgXmm1),
	/*5129*/ uint16(xMatch),
	/*5130*/ uint16(xCondIs64), 5133, 5147,
	/*5133*/ uint16(xCondDataSize), 5137, 5142, 0,
	/*5137*/ uint16(xSetOp), uint16(JO),
	/*5139*/ uint16(xReadCw),
	/*5140*/ uint16(xArgRel16),
	/*5141*/ uint16(xMatch),
	/*5142*/ uint16(xSetOp), uint16(JO),
	/*5144*/ uint16(xReadCd),
	/*5145*/ uint16(xArgRel32),
	/*5146*/ uint16(xMatch),
	/*5147*/ uint16(xCondDataSize), 5151, 5142, 5156,
	/*5151*/ uint16(xSetOp), uint16(JO),
	/*5153*/ uint16(xReadCd),
	/*5154*/ uint16(xArgRel32),
	/*5155*/ uint16(xMatch),
	/*5156*/ uint16(xSetOp), uint16(JO),
	/*5158*/ uint16(xReadCd),
	/*5159*/ uint16(xArgRel32),
	/*5160*/ uint16(xMatch),
	/*5161*/ uint16(xCondIs64), 5164, 5178,
	/*5164*/ uint16(xCondDataSize), 5168, 5173, 0,
	/*5168*/ uint16(xSetOp), uint16(JNO),
	/*5170*/ uint16(xReadCw),
	/*5171*/ uint16(xArgRel16),
	/*5172*/ uint16(xMatch),
	/*5173*/ uint16(xSetOp), uint16(JNO),
	/*5175*/ uint16(xReadCd),
	/*5176*/ uint16(xArgRel32),
	/*5177*/ uint16(xMatch),
	/*5178*/ uint16(xCondDataSize), 5182, 5173, 5187,
	/*5182*/ uint16(xSetOp), uint16(JNO),
	/*5184*/ uint16(xReadCd),
	/*5185*/ uint16(xArgRel32),
	/*5186*/ uint16(xMatch),
	/*5187*/ uint16(xSetOp), uint16(JNO),
	/*5189*/ uint16(xReadCd),
	/*5190*/ uint16(xArgRel32),
	/*5191*/ uint16(xMatch),
	/*5192*/ uint16(xCondIs64), 5195, 5209,
	/*5195*/ uint16(xCondDataSize), 5199, 5204, 0,
	/*5199*/ uint16(xSetOp), uint16(JB),
	/*5201*/ uint16(xReadCw),
	/*5202*/ uint16(xArgRel16),
	/*5203*/ uint16(xMatch),
	/*5204*/ uint16(xSetOp), uint16(JB),
	/*5206*/ uint16(xReadCd),
	/*5207*/ uint16(xArgRel32),
	/*5208*/ uint16(xMatch),
	/*5209*/ uint16(xCondDataSize), 5213, 5204, 5218,
	/*5213*/ uint16(xSetOp), uint16(JB),
	/*5215*/ uint16(xReadCd),
	/*5216*/ uint16(xArgRel32),
	/*5217*/ uint16(xMatch),
	/*5218*/ uint16(xSetOp), uint16(JB),
	/*5220*/ uint16(xReadCd),
	/*5221*/ uint16(xArgRel32),
	/*5222*/ uint16(xMatch),
	/*5223*/ uint16(xCondIs64), 5226, 5240,
	/*5226*/ uint16(xCondDataSize), 5230, 5235, 0,
	/*5230*/ uint16(xSetOp), uint16(JAE),
	/*5232*/ uint16(xReadCw),
	/*5233*/ uint16(xArgRel16),
	/*5234*/ uint16(xMatch),
	/*5235*/ uint16(xSetOp), uint16(JAE),
	/*5237*/ uint16(xReadCd),
	/*5238*/ uint16(xArgRel32),
	/*5239*/ uint16(xMatch),
	/*5240*/ uint16(xCondDataSize), 5244, 5235, 5249,
	/*5244*/ uint16(xSetOp), uint16(JAE),
	/*5246*/ uint16(xReadCd),
	/*5247*/ uint16(xArgRel32),
	/*5248*/ uint16(xMatch),
	/*5249*/ uint16(xSetOp), uint16(JAE),
	/*5251*/ uint16(xReadCd),
	/*5252*/ uint16(xArgRel32),
	/*5253*/ uint16(xMatch),
	/*5254*/ uint16(xCondIs64), 5257, 5271,
	/*5257*/ uint16(xCondDataSize), 5261, 5266, 0,
	/*5261*/ uint16(xSetOp), uint16(JE),
	/*5263*/ uint16(xReadCw),
	/*5264*/ uint16(xArgRel16),
	/*5265*/ uint16(xMatch),
	/*5266*/ uint16(xSetOp), uint16(JE),
	/*5268*/ uint16(xReadCd),
	/*5269*/ uint16(xArgRel32),
	/*5270*/ uint16(xMatch),
	/*5271*/ uint16(xCondDataSize), 5275, 5266, 5280,
	/*5275*/ uint16(xSetOp), uint16(JE),
	/*5277*/ uint16(xReadCd),
	/*5278*/ uint16(xArgRel32),
	/*5279*/ uint16(xMatch),
	/*5280*/ uint16(xSetOp), uint16(JE),
	/*5282*/ uint16(xReadCd),
	/*5283*/ uint16(xArgRel32),
	/*5284*/ uint16(xMatch),
	/*5285*/ uint16(xCondIs64), 5288, 5302,
	/*5288*/ uint16(xCondDataSize), 5292, 5297, 0,
	/*5292*/ uint16(xSetOp), uint16(JNE),
	/*5294*/ uint16(xReadCw),
	/*5295*/ uint16(xArgRel16),
	/*5296*/ uint16(xMatch),
	/*5297*/ uint16(xSetOp), uint16(JNE),
	/*5299*/ uint16(xReadCd),
	/*5300*/ uint16(xArgRel32),
	/*5301*/ uint16(xMatch),
	/*5302*/ uint16(xCondDataSize), 5306, 5297, 5311,
	/*5306*/ uint16(xSetOp), uint16(JNE),
	/*5308*/ uint16(xReadCd),
	/*5309*/ uint16(xArgRel32),
	/*5310*/ uint16(xMatch),
	/*5311*/ uint16(xSetOp), uint16(JNE),
	/*5313*/ uint16(xReadCd),
	/*5314*/ uint16(xArgRel32),
	/*5315*/ uint16(xMatch),
	/*5316*/ uint16(xCondIs64), 5319, 5333,
	/*5319*/ uint16(xCondDataSize), 5323, 5328, 0,
	/*5323*/ uint16(xSetOp), uint16(JBE),
	/*5325*/ uint16(xReadCw),
	/*5326*/ uint16(xArgRel16),
	/*5327*/ uint16(xMatch),
	/*5328*/ uint16(xSetOp), uint16(JBE),
	/*5330*/ uint16(xReadCd),
	/*5331*/ uint16(xArgRel32),
	/*5332*/ uint16(xMatch),
	/*5333*/ uint16(xCondDataSize), 5337, 5328, 5342,
	/*5337*/ uint16(xSetOp), uint16(JBE),
	/*5339*/ uint16(xReadCd),
	/*5340*/ uint16(xArgRel32),
	/*5341*/ uint16(xMatch),
	/*5342*/ uint16(xSetOp), uint16(JBE),
	/*5344*/ uint16(xReadCd),
	/*5345*/ uint16(xArgRel32),
	/*5346*/ uint16(xMatch),
	/*5347*/ uint16(xCondIs64), 5350, 5364,
	/*5350*/ uint16(xCondDataSize), 5354, 5359, 0,
	/*5354*/ uint16(xSetOp), uint16(JA),
	/*5356*/ uint16(xReadCw),
	/*5357*/ uint16(xArgRel16),
	/*5358*/ uint16(xMatch),
	/*5359*/ uint16(xSetOp), uint16(JA),
	/*5361*/ uint16(xReadCd),
	/*5362*/ uint16(xArgRel32),
	/*5363*/ uint16(xMatch),
	/*5364*/ uint16(xCondDataSize), 5368, 5359, 5373,
	/*5368*/ uint16(xSetOp), uint16(JA),
	/*5370*/ uint16(xReadCd),
	/*5371*/ uint16(xArgRel32),
	/*5372*/ uint16(xMatch),
	/*5373*/ uint16(xSetOp), uint16(JA),
	/*5375*/ uint16(xReadCd),
	/*5376*/ uint16(xArgRel32),
	/*5377*/ uint16(xMatch),
	/*5378*/ uint16(xCondIs64), 5381, 5395,
	/*5381*/ uint16(xCondDataSize), 5385, 5390, 0,
	/*5385*/ uint16(xSetOp), uint16(JS),
	/*5387*/ uint16(xReadCw),
	/*5388*/ uint16(xArgRel16),
	/*5389*/ uint16(xMatch),
	/*5390*/ uint16(xSetOp), uint16(JS),
	/*5392*/ uint16(xReadCd),
	/*5393*/ uint16(xArgRel32),
	/*5394*/ uint16(xMatch),
	/*5395*/ uint16(xCondDataSize), 5399, 5390, 5404,
	/*5399*/ uint16(xSetOp), uint16(JS),
	/*5401*/ uint16(xReadCd),
	/*5402*/ uint16(xArgRel32),
	/*5403*/ uint16(xMatch),
	/*5404*/ uint16(xSetOp), uint16(JS),
	/*5406*/ uint16(xReadCd),
	/*5407*/ uint16(xArgRel32),
	/*5408*/ uint16(xMatch),
	/*5409*/ uint16(xCondIs64), 5412, 5426,
	/*5412*/ uint16(xCondDataSize), 5416, 5421, 0,
	/*5416*/ uint16(xSetOp), uint16(JNS),
	/*5418*/ uint16(xReadCw),
	/*5419*/ uint16(xArgRel16),
	/*5420*/ uint16(xMatch),
	/*5421*/ uint16(xSetOp), uint16(JNS),
	/*5423*/ uint16(xReadCd),
	/*5424*/ uint16(xArgRel32),
	/*5425*/ uint16(xMatch),
	/*5426*/ uint16(xCondDataSize), 5430, 5421, 5435,
	/*5430*/ uint16(xSetOp), uint16(JNS),
	/*5432*/ uint16(xReadCd),
	/*5433*/ uint16(xArgRel32),
	/*5434*/ uint16(xMatch),
	/*5435*/ uint16(xSetOp), uint16(JNS),
	/*5437*/ uint16(xReadCd),
	/*5438*/ uint16(xArgRel32),
	/*5439*/ uint16(xMatch),
	/*5440*/ uint16(xCondIs64), 5443, 5457,
	/*5443*/ uint16(xCondDataSize), 5447, 5452, 0,
	/*5447*/ uint16(xSetOp), uint16(JP),
	/*5449*/ uint16(xReadCw),
	/*5450*/ uint16(xArgRel16),
	/*5451*/ uint16(xMatch),
	/*5452*/ uint16(xSetOp), uint16(JP),
	/*5454*/ uint16(xReadCd),
	/*5455*/ uint16(xArgRel32),
	/*5456*/ uint16(xMatch),
	/*5457*/ uint16(xCondDataSize), 5461, 5452, 5466,
	/*5461*/ uint16(xSetOp), uint16(JP),
	/*5463*/ uint16(xReadCd),
	/*5464*/ uint16(xArgRel32),
	/*5465*/ uint16(xMatch),
	/*5466*/ uint16(xSetOp), uint16(JP),
	/*5468*/ uint16(xReadCd),
	/*5469*/ uint16(xArgRel32),
	/*5470*/ uint16(xMatch),
	/*5471*/ uint16(xCondIs64), 5474, 5488,
	/*5474*/ uint16(xCondDataSize), 5478, 5483, 0,
	/*5478*/ uint16(xSetOp), uint16(JNP),
	/*5480*/ uint16(xReadCw),
	/*5481*/ uint16(xArgRel16),
	/*5482*/ uint16(xMatch),
	/*5483*/ uint16(xSetOp), uint16(JNP),
	/*5485*/ uint16(xReadCd),
	/*5486*/ uint16(xArgRel32),
	/*5487*/ uint16(xMatch),
	/*5488*/ uint16(xCondDataSize), 5492, 5483, 5497,
	/*5492*/ uint16(xSetOp), uint16(JNP),
	/*5494*/ uint16(xReadCd),
	/*5495*/ uint16(xArgRel32),
	/*5496*/ uint16(xMatch),
	/*5497*/ uint16(xSetOp), uint16(JNP),
	/*5499*/ uint16(xReadCd),
	/*5500*/ uint16(xArgRel32),
	/*5501*/ uint16(xMatch),
	/*5502*/ uint16(xCondIs64), 5505, 5519,
	/*5505*/ uint16(xCondDataSize), 5509, 5514, 0,
	/*5509*/ uint16(xSetOp), uint16(JL),
	/*5511*/ uint16(xReadCw),
	/*5512*/ uint16(xArgRel16),
	/*5513*/ uint16(xMatch),
	/*5514*/ uint16(xSetOp), uint16(JL),
	/*5516*/ uint16(xReadCd),
	/*5517*/ uint16(xArgRel32),
	/*5518*/ uint16(xMatch),
	/*5519*/ uint16(xCondDataSize), 5523, 5514, 5528,
	/*5523*/ uint16(xSetOp), uint16(JL),
	/*5525*/ uint16(xReadCd),
	/*5526*/ uint16(xArgRel32),
	/*5527*/ uint16(xMatch),
	/*5528*/ uint16(xSetOp), uint16(JL),
	/*5530*/ uint16(xReadCd),
	/*5531*/ uint16(xArgRel32),
	/*5532*/ uint16(xMatch),
	/*5533*/ uint16(xCondIs64), 5536, 5550,
	/*5536*/ uint16(xCondDataSize), 5540, 5545, 0,
	/*5540*/ uint16(xSetOp), uint16(JGE),
	/*5542*/ uint16(xReadCw),
	/*5543*/ uint16(xArgRel16),
	/*5544*/ uint16(xMatch),
	/*5545*/ uint16(xSetOp), uint16(JGE),
	/*5547*/ uint16(xReadCd),
	/*5548*/ uint16(xArgRel32),
	/*5549*/ uint16(xMatch),
	/*5550*/ uint16(xCondDataSize), 5554, 5545, 5559,
	/*5554*/ uint16(xSetOp), uint16(JGE),
	/*5556*/ uint16(xReadCd),
	/*5557*/ uint16(xArgRel32),
	/*5558*/ uint16(xMatch),
	/*5559*/ uint16(xSetOp), uint16(JGE),
	/*5561*/ uint16(xReadCd),
	/*5562*/ uint16(xArgRel32),
	/*5563*/ uint16(xMatch),
	/*5564*/ uint16(xCondIs64), 5567, 5581,
	/*5567*/ uint16(xCondDataSize), 5571, 5576, 0,
	/*5571*/ uint16(xSetOp), uint16(JLE),
	/*5573*/ uint16(xReadCw),
	/*5574*/ uint16(xArgRel16),
	/*5575*/ uint16(xMatch),
	/*5576*/ uint16(xSetOp), uint16(JLE),
	/*5578*/ uint16(xReadCd),
	/*5579*/ uint16(xArgRel32),
	/*5580*/ uint16(xMatch),
	/*5581*/ uint16(xCondDataSize), 5585, 5576, 5590,
	/*5585*/ uint16(xSetOp), uint16(JLE),
	/*5587*/ uint16(xReadCd),
	/*5588*/ uint16(xArgRel32),
	/*5589*/ uint16(xMatch),
	/*5590*/ uint16(xSetOp), uint16(JLE),
	/*5592*/ uint16(xReadCd),
	/*5593*/ uint16(xArgRel32),
	/*5594*/ uint16(xMatch),
	/*5595*/ uint16(xCondIs64), 5598, 5612,
	/*5598*/ uint16(xCondDataSize), 5602, 5607, 0,
	/*5602*/ uint16(xSetOp), uint16(JG),
	/*5604*/ uint16(xReadCw),
	/*5605*/ uint16(xArgRel16),
	/*5606*/ uint16(xMatch),
	/*5607*/ uint16(xSetOp), uint16(JG),
	/*5609*/ uint16(xReadCd),
	/*5610*/ uint16(xArgRel32),
	/*5611*/ uint16(xMatch),
	/*5612*/ uint16(xCondDataSize), 5616, 5607, 5621,
	/*5616*/ uint16(xSetOp), uint16(JG),
	/*5618*/ uint16(xReadCd),
	/*5619*/ uint16(xArgRel32),
	/*5620*/ uint16(xMatch),
	/*5621*/ uint16(xSetOp), uint16(JG),
	/*5623*/ uint16(xReadCd),
	/*5624*/ uint16(xArgRel32),
	/*5625*/ uint16(xMatch),
	/*5626*/ uint16(xSetOp), uint16(SETO),
	/*5628*/ uint16(xReadSlashR),
	/*5629*/ uint16(xArgRM8),
	/*5630*/ uint16(xMatch),
	/*5631*/ uint16(xSetOp), uint16(SETNO),
	/*5633*/ uint16(xReadSlashR),
	/*5634*/ uint16(xArgRM8),
	/*5635*/ uint16(xMatch),
	/*5636*/ uint16(xSetOp), uint16(SETB),
	/*5638*/ uint16(xReadSlashR),
	/*5639*/ uint16(xArgRM8),
	/*5640*/ uint16(xMatch),
	/*5641*/ uint16(xSetOp), uint16(SETAE),
	/*5643*/ uint16(xReadSlashR),
	/*5644*/ uint16(xArgRM8),
	/*5645*/ uint16(xMatch),
	/*5646*/ uint16(xSetOp), uint16(SETE),
	/*5648*/ uint16(xReadSlashR),
	/*5649*/ uint16(xArgRM8),
	/*5650*/ uint16(xMatch),
	/*5651*/ uint16(xSetOp), uint16(SETNE),
	/*5653*/ uint16(xReadSlashR),
	/*5654*/ uint16(xArgRM8),
	/*5655*/ uint16(xMatch),
	/*5656*/ uint16(xSetOp), uint16(SETBE),
	/*5658*/ uint16(xReadSlashR),
	/*5659*/ uint16(xArgRM8),
	/*5660*/ uint16(xMatch),
	/*5661*/ uint16(xSetOp), uint16(SETA),
	/*5663*/ uint16(xReadSlashR),
	/*5664*/ uint16(xArgRM8),
	/*5665*/ uint16(xMatch),
	/*5666*/ uint16(xSetOp), uint16(SETS),
	/*5668*/ uint16(xReadSlashR),
	/*5669*/ uint16(xArgRM8),
	/*5670*/ uint16(xMatch),
	/*5671*/ uint16(xSetOp), uint16(SETNS),
	/*5673*/ uint16(xReadSlashR),
	/*5674*/ uint16(xArgRM8),
	/*5675*/ uint16(xMatch),
	/*5676*/ uint16(xSetOp), uint16(SETP),
	/*5678*/ uint16(xReadSlashR),
	/*5679*/ uint16(xArgRM8),
	/*5680*/ uint16(xMatch),
	/*5681*/ uint16(xSetOp), uint16(SETNP),
	/*5683*/ uint16(xReadSlashR),
	/*5684*/ uint16(xArgRM8),
	/*5685*/ uint16(xMatch),
	/*5686*/ uint16(xSetOp), uint16(SETL),
	/*5688*/ uint16(xReadSlashR),
	/*5689*/ uint16(xArgRM8),
	/*5690*/ uint16(xMatch),
	/*5691*/ uint16(xSetOp), uint16(SETGE),
	/*5693*/ uint16(xReadSlashR),
	/*5694*/ uint16(xArgRM8),
	/*5695*/ uint16(xMatch),
	/*5696*/ uint16(xSetOp), uint16(SETLE),
	/*5698*/ uint16(xReadSlashR),
	/*5699*/ uint16(xArgRM8),
	/*5700*/ uint16(xMatch),
	/*5701*/ uint16(xSetOp), uint16(SETG),
	/*5703*/ uint16(xReadSlashR),
	/*5704*/ uint16(xArgRM8),
	/*5705*/ uint16(xMatch),
	/*5706*/ uint16(xSetOp), uint16(PUSH),
	/*5708*/ uint16(xArgFS),
	/*5709*/ uint16(xMatch),
	/*5710*/ uint16(xCondIs64), 5713, 5725,
	/*5713*/ uint16(xCondDataSize), 5717, 5721, 0,
	/*5717*/ uint16(xSetOp), uint16(POP),
	/*5719*/ uint16(xArgFS),
	/*5720*/ uint16(xMatch),
	/*5721*/ uint16(xSetOp), uint16(POP),
	/*5723*/ uint16(xArgFS),
	/*5724*/ uint16(xMatch),
	/*5725*/ uint16(xCondDataSize), 5717, 5729, 5733,
	/*5729*/ uint16(xSetOp), uint16(POP),
	/*5731*/ uint16(xArgFS),
	/*5732*/ uint16(xMatch),
	/*5733*/ uint16(xSetOp), uint16(POP),
	/*5735*/ uint16(xArgFS),
	/*5736*/ uint16(xMatch),
	/*5737*/ uint16(xSetOp), uint16(CPUID),
	/*5739*/ uint16(xMatch),
	/*5740*/ uint16(xCondIs64), 5743, 5759,
	/*5743*/ uint16(xCondDataSize), 5747, 5753, 0,
	/*5747*/ uint16(xSetOp), uint16(BT),
	/*5749*/ uint16(xReadSlashR),
	/*5750*/ uint16(xArgRM16),
	/*5751*/ uint16(xArgR16),
	/*5752*/ uint16(xMatch),
	/*5753*/ uint16(xSetOp), uint16(BT),
	/*5755*/ uint16(xReadSlashR),
	/*5756*/ uint16(xArgRM32),
	/*5757*/ uint16(xArgR32),
	/*5758*/ uint16(xMatch),
	/*5759*/ uint16(xCondDataSize), 5747, 5753, 5763,
	/*5763*/ uint16(xSetOp), uint16(BT),
	/*5765*/ uint16(xReadSlashR),
	/*5766*/ uint16(xArgRM64),
	/*5767*/ uint16(xArgR64),
	/*5768*/ uint16(xMatch),
	/*5769*/ uint16(xCondIs64), 5772, 5792,
	/*5772*/ uint16(xCondDataSize), 5776, 5784, 0,
	/*5776*/ uint16(xSetOp), uint16(SHLD),
	/*5778*/ uint16(xReadSlashR),
	/*5779*/ uint16(xReadIb),
	/*5780*/ uint16(xArgRM16),
	/*5781*/ uint16(xArgR16),
	/*5782*/ uint16(xArgImm8u),
	/*5783*/ uint16(xMatch),
	/*5784*/ uint16(xSetOp), uint16(SHLD),
	/*5786*/ uint16(xReadSlashR),
	/*5787*/ uint16(xReadIb),
	/*5788*/ uint16(xArgRM32),
	/*5789*/ uint16(xArgR32),
	/*5790*/ uint16(xArgImm8u),
	/*5791*/ uint16(xMatch),
	/*5792*/ uint16(xCondDataSize), 5776, 5784, 5796,
	/*5796*/ uint16(xSetOp), uint16(SHLD),
	/*5798*/ uint16(xReadSlashR),
	/*5799*/ uint16(xReadIb),
	/*5800*/ uint16(xArgRM64),
	/*5801*/ uint16(xArgR64),
	/*5802*/ uint16(xArgImm8u),
	/*5803*/ uint16(xMatch),
	/*5804*/ uint16(xCondIs64), 5807, 5825,
	/*5807*/ uint16(xCondDataSize), 5811, 5818, 0,
	/*5811*/ uint16(xSetOp), uint16(SHLD),
	/*5813*/ uint16(xReadSlashR),
	/*5814*/ uint16(xArgRM16),
	/*5815*/ uint16(xArgR16),
	/*5816*/ uint16(xArgCL),
	/*5817*/ uint16(xMatch),
	/*5818*/ uint16(xSetOp), uint16(SHLD),
	/*5820*/ uint16(xReadSlashR),
	/*5821*/ uint16(xArgRM32),
	/*5822*/ uint16(xArgR32),
	/*5823*/ uint16(xArgCL),
	/*5824*/ uint16(xMatch),
	/*5825*/ uint16(xCondDataSize), 5811, 5818, 5829,
	/*5829*/ uint16(xSetOp), uint16(SHLD),
	/*5831*/ uint16(xReadSlashR),
	/*5832*/ uint16(xArgRM64),
	/*5833*/ uint16(xArgR64),
	/*5834*/ uint16(xArgCL),
	/*5835*/ uint16(xMatch),
	/*5836*/ uint16(xSetOp), uint16(PUSH),
	/*5838*/ uint16(xArgGS),
	/*5839*/ uint16(xMatch),
	/*5840*/ uint16(xCondIs64), 5843, 5855,
	/*5843*/ uint16(xCondDataSize), 5847, 5851, 0,
	/*5847*/ uint16(xSetOp), uint16(POP),
	/*5849*/ uint16(xArgGS),
	/*5850*/ uint16(xMatch),
	/*5851*/ uint16(xSetOp), uint16(POP),
	/*5853*/ uint16(xArgGS),
	/*5854*/ uint16(xMatch),
	/*5855*/ uint16(xCondDataSize), 5847, 5859, 5863,
	/*5859*/ uint16(xSetOp), uint16(POP),
	/*5861*/ uint16(xArgGS),
	/*5862*/ uint16(xMatch),
	/*5863*/ uint16(xSetOp), uint16(POP),
	/*5865*/ uint16(xArgGS),
	/*5866*/ uint16(xMatch),
	/*5867*/ uint16(xSetOp), uint16(RSM),
	/*5869*/ uint16(xMatch),
	/*5870*/ uint16(xCondIs64), 5873, 5889,
	/*5873*/ uint16(xCondDataSize), 5877, 5883, 0,
	/*5877*/ uint16(xSetOp), uint16(BTS),
	/*5879*/ uint16(xReadSlashR),
	/*5880*/ uint16(xArgRM16),
	/*5881*/ uint16(xArgR16),
	/*5882*/ uint16(xMatch),
	/*5883*/ uint16(xSetOp), uint16(BTS),
	/*5885*/ uint16(xReadSlashR),
	/*5886*/ uint16(xArgRM32),
	/*5887*/ uint16(xArgR32),
	/*5888*/ uint16(xMatch),
	/*5889*/ uint16(xCondDataSize), 5877, 5883, 5893,
	/*5893*/ uint16(xSetOp), uint16(BTS),
	/*5895*/ uint16(xReadSlashR),
	/*5896*/ uint16(xArgRM64),
	/*5897*/ uint16(xArgR64),
	/*5898*/ uint16(xMatch),
	/*5899*/ uint16(xCondIs64), 5902, 5922,
	/*5902*/ uint16(xCondDataSize), 5906, 5914, 0,
	/*5906*/ uint16(xSetOp), uint16(SHRD),
	/*5908*/ uint16(xReadSlashR),
	/*5909*/ uint16(xReadIb),
	/*5910*/ uint16(xArgRM16),
	/*5911*/ uint16(xArgR16),
	/*5912*/ uint16(xArgImm8u),
	/*5913*/ uint16(xMatch),
	/*5914*/ uint16(xSetOp), uint16(SHRD),
	/*5916*/ uint16(xReadSlashR),
	/*5917*/ uint16(xReadIb),
	/*5918*/ uint16(xArgRM32),
	/*5919*/ uint16(xArgR32),
	/*5920*/ uint16(xArgImm8u),
	/*5921*/ uint16(xMatch),
	/*5922*/ uint16(xCondDataSize), 5906, 5914, 5926,
	/*5926*/ uint16(xSetOp), uint16(SHRD),
	/*5928*/ uint16(xReadSlashR),
	/*5929*/ uint16(xReadIb),
	/*5930*/ uint16(xArgRM64),
	/*5931*/ uint16(xArgR64),
	/*5932*/ uint16(xArgImm8u),
	/*5933*/ uint16(xMatch),
	/*5934*/ uint16(xCondIs64), 5937, 5955,
	/*5937*/ uint16(xCondDataSize), 5941, 5948, 0,
	/*5941*/ uint16(xSetOp), uint16(SHRD),
	/*5943*/ uint16(xReadSlashR),
	/*5944*/ uint16(xArgRM16),
	/*5945*/ uint16(xArgR16),
	/*5946*/ uint16(xArgCL),
	/*5947*/ uint16(xMatch),
	/*5948*/ uint16(xSetOp), uint16(SHRD),
	/*5950*/ uint16(xReadSlashR),
	/*5951*/ uint16(xArgRM32),
	/*5952*/ uint16(xArgR32),
	/*5953*/ uint16(xArgCL),
	/*5954*/ uint16(xMatch),
	/*5955*/ uint16(xCondDataSize), 5941, 5948, 5959,
	/*5959*/ uint16(xSetOp), uint16(SHRD),
	/*5961*/ uint16(xReadSlashR),
	/*5962*/ uint16(xArgRM64),
	/*5963*/ uint16(xArgR64),
	/*5964*/ uint16(xArgCL),
	/*5965*/ uint16(xMatch),
	/*5966*/ uint16(xCondByte), 3,
	0xE8, 6215,
	0xF0, 6218,
	0xF8, 6221,
	/*5974*/ uint16(xCondSlashR),
	5983, // 0
	6037, // 1
	6091, // 2
	6120, // 3
	6149, // 4
	6172, // 5
	6195, // 6
	6211, // 7
	/*5983*/ uint16(xCondIs64), 5986, 5998,
	/*5986*/ uint16(xCondDataSize), 5990, 5994, 0,
	/*5990*/ uint16(xSetOp), uint16(FXSAVE),
	/*5992*/ uint16(xArgM512byte),
	/*5993*/ uint16(xMatch),
	/*5994*/ uint16(xSetOp), uint16(FXSAVE),
	/*5996*/ uint16(xArgM512byte),
	/*5997*/ uint16(xMatch),
	/*5998*/ uint16(xCondPrefix), 2,
	0xF3, 6012,
	0x0, 6004,
	/*6004*/ uint16(xCondDataSize), 5990, 5994, 6008,
	/*6008*/ uint16(xSetOp), uint16(FXSAVE64),
	/*6010*/ uint16(xArgM512byte),
	/*6011*/ uint16(xMatch),
	/*6012*/ uint16(xCondDataSize), 6016, 6023, 6030,
	/*6016*/ uint16(xCondIsMem), 6019, 0,
	/*6019*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6021*/ uint16(xArgRM32),
	/*6022*/ uint16(xMatch),
	/*6023*/ uint16(xCondIsMem), 6026, 0,
	/*6026*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6028*/ uint16(xArgRM32),
	/*6029*/ uint16(xMatch),
	/*6030*/ uint16(xCondIsMem), 6033, 0,
	/*6033*/ uint16(xSetOp), uint16(RDFSBASE),
	/*6035*/ uint16(xArgRM64),
	/*6036*/ uint16(xMatch),
	/*6037*/ uint16(xCondIs64), 6040, 6052,
	/*6040*/ uint16(xCondDataSize), 6044, 6048, 0,
	/*6044*/ uint16(xSetOp), uint16(FXRSTOR),
	/*6046*/ uint16(xArgM512byte),
	/*6047*/ uint16(xMatch),
	/*6048*/ uint16(xSetOp), uint16(FXRSTOR),
	/*6050*/ uint16(xArgM512byte),
	/*6051*/ uint16(xMatch),
	/*6052*/ uint16(xCondPrefix), 2,
	0xF3, 6066,
	0x0, 6058,
	/*6058*/ uint16(xCondDataSize), 6044, 6048, 6062,
	/*6062*/ uint16(xSetOp), uint16(FXRSTOR64),
	/*6064*/ uint16(xArgM512byte),
	/*6065*/ uint16(xMatch),
	/*6066*/ uint16(xCondDataSize), 6070, 6077, 6084,
	/*6070*/ uint16(xCondIsMem), 6073, 0,
	/*6073*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6075*/ uint16(xArgRM32),
	/*6076*/ uint16(xMatch),
	/*6077*/ uint16(xCondIsMem), 6080, 0,
	/*6080*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6082*/ uint16(xArgRM32),
	/*6083*/ uint16(xMatch),
	/*6084*/ uint16(xCondIsMem), 6087, 0,
	/*6087*/ uint16(xSetOp), uint16(RDGSBASE),
	/*6089*/ uint16(xArgRM64),
	/*6090*/ uint16(xMatch),
	/*6091*/ uint16(xCondIs64), 6094, 6098,
	/*6094*/ uint16(xSetOp), uint16(LDMXCSR),
	/*6096*/ uint16(xArgM32),
	/*6097*/ uint16(xMatch),
	/*6098*/ uint16(xCondPrefix), 2,
	0xF3, 6104,
	0x0, 6094,
	/*6104*/ uint16(xCondDataSize), 6108, 6112, 6116,
	/*6108*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6110*/ uint16(xArgRM32),
	/*6111*/ uint16(xMatch),
	/*6112*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6114*/ uint16(xArgRM32),
	/*6115*/ uint16(xMatch),
	/*6116*/ uint16(xSetOp), uint16(WRFSBASE),
	/*6118*/ uint16(xArgRM64),
	/*6119*/ uint16(xMatch),
	/*6120*/ uint16(xCondIs64), 6123, 6127,
	/*6123*/ uint16(xSetOp), uint16(STMXCSR),
	/*6125*/ uint16(xArgM32),
	/*6126*/ uint16(xMatch),
	/*6127*/ uint16(xCondPrefix), 2,
	0xF3, 6133,
	0x0, 6123,
	/*6133*/ uint16(xCondDataSize), 6137, 6141, 6145,
	/*6137*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6139*/ uint16(xArgRM32),
	/*6140*/ uint16(xMatch),
	/*6141*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6143*/ uint16(xArgRM32),
	/*6144*/ uint16(xMatch),
	/*6145*/ uint16(xSetOp), uint16(WRGSBASE),
	/*6147*/ uint16(xArgRM64),
	/*6148*/ uint16(xMatch),
	/*6149*/ uint16(xCondIs64), 6152, 6164,
	/*6152*/ uint16(xCondDataSize), 6156, 6160, 0,
	/*6156*/ uint16(xSetOp), uint16(XSAVE),
	/*6158*/ uint16(xArgMem),
	/*6159*/ uint16(xMatch),
	/*6160*/ uint16(xSetOp), uint16(XSAVE),
	/*6162*/ uint16(xArgMem),
	/*6163*/ uint16(xMatch),
	/*6164*/ uint16(xCondDataSize), 6156, 6160, 6168,
	/*6168*/ uint16(xSetOp), uint16(XSAVE64),
	/*6170*/ uint16(xArgMem),
	/*6171*/ uint16(xMatch),
	/*6172*/ uint16(xCondIs64), 6175, 6187,
	/*6175*/ uint16(xCondDataSize), 6179, 6183, 0,
	/*6179*/ uint16(xSetOp), uint16(XRSTOR),
	/*6181*/ uint16(xArgMem),
	/*6182*/ uint16(xMatch),
	/*6183*/ uint16(xSetOp), uint16(XRSTOR),
	/*6185*/ uint16(xArgMem),
	/*6186*/ uint16(xMatch),
	/*6187*/ uint16(xCondDataSize), 6179, 6183, 6191,
	/*6191*/ uint16(xSetOp), uint16(XRSTOR64),
	/*6193*/ uint16(xArgMem),
	/*6194*/ uint16(xMatch),
	/*6195*/ uint16(xCondDataSize), 6199, 6203, 6207,
	/*6199*/ uint16(xSetOp), uint16(XSAVEOPT),
	/*6201*/ uint16(xArgMem),
	/*6202*/ uint16(xMatch),
	/*6203*/ uint16(xSetOp), uint16(XSAVEOPT),
	/*6205*/ uint16(xArgMem),
	/*6206*/ uint16(xMatch),
	/*6207*/ uint16(xSetOp), uint16(XSAVEOPT64),
	/*6209*/ uint16(xArgMem),
	/*6210*/ uint16(xMatch),
	/*6211*/ uint16(xSetOp), uint16(CLFLUSH),
	/*6213*/ uint16(xArgM8),
	/*6214*/ uint16(xMatch),
	/*6215*/ uint16(xSetOp), uint16(LFENCE),
	/*6217*/ uint16(xMatch),
	/*6218*/ uint16(xSetOp), uint16(MFENCE),
	/*6220*/ uint16(xMatch),
	/*6221*/ uint16(xSetOp), uint16(SFENCE),
	/*6223*/ uint16(xMatch),
	/*6224*/ uint16(xCondIs64), 6227, 6243,
	/*6227*/ uint16(xCondDataSize), 6231, 6237, 0,
	/*6231*/ uint16(xSetOp), uint16(IMUL),
	/*6233*/ uint16(xReadSlashR),
	/*6234*/ uint16(xArgR16),
	/*6235*/ uint16(xArgRM16),
	/*6236*/ uint16(xMatch),
	/*6237*/ uint16(xSetOp), uint16(IMUL),
	/*6239*/ uint16(xReadSlashR),
	/*6240*/ uint16(xArgR32),
	/*6241*/ uint16(xArgRM32),
	/*6242*/ uint16(xMatch),
	/*6243*/ uint16(xCondDataSize), 6231, 6237, 6247,
	/*6247*/ uint16(xSetOp), uint16(IMUL),
	/*6249*/ uint16(xReadSlashR),
	/*6250*/ uint16(xArgR64),
	/*6251*/ uint16(xArgRM64),
	/*6252*/ uint16(xMatch),
	/*6253*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6255*/ uint16(xReadSlashR),
	/*6256*/ uint16(xArgRM8),
	/*6257*/ uint16(xArgR8),
	/*6258*/ uint16(xMatch),
	/*6259*/ uint16(xCondIs64), 6262, 6278,
	/*6262*/ uint16(xCondDataSize), 6266, 6272, 0,
	/*6266*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6268*/ uint16(xReadSlashR),
	/*6269*/ uint16(xArgRM16),
	/*6270*/ uint16(xArgR16),
	/*6271*/ uint16(xMatch),
	/*6272*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6274*/ uint16(xReadSlashR),
	/*6275*/ uint16(xArgRM32),
	/*6276*/ uint16(xArgR32),
	/*6277*/ uint16(xMatch),
	/*6278*/ uint16(xCondDataSize), 6266, 6272, 6282,
	/*6282*/ uint16(xSetOp), uint16(CMPXCHG),
	/*6284*/ uint16(xReadSlashR),
	/*6285*/ uint16(xArgRM64),
	/*6286*/ uint16(xArgR64),
	/*6287*/ uint16(xMatch),
	/*6288*/ uint16(xCondIs64), 6291, 6307,
	/*6291*/ uint16(xCondDataSize), 6295, 6301, 0,
	/*6295*/ uint16(xSetOp), uint16(LSS),
	/*6297*/ uint16(xReadSlashR),
	/*6298*/ uint16(xArgR16),
	/*6299*/ uint16(xArgM16colon16),
	/*6300*/ uint16(xMatch),
	/*6301*/ uint16(xSetOp), uint16(LSS),
	/*6303*/ uint16(xReadSlashR),
	/*6304*/ uint16(xArgR32),
	/*6305*/ uint16(xArgM16colon32),
	/*6306*/ uint16(xMatch),
	/*6307*/ uint16(xCondDataSize), 6295, 6301, 6311,
	/*6311*/ uint16(xSetOp), uint16(LSS),
	/*6313*/ uint16(xReadSlashR),
	/*6314*/ uint16(xArgR64),
	/*6315*/ uint16(xArgM16colon64),
	/*6316*/ uint16(xMatch),
	/*6317*/ uint16(xCondIs64), 6320, 6336,
	/*6320*/ uint16(xCondDataSize), 6324, 6330, 0,
	/*6324*/ uint16(xSetOp), uint16(BTR),
	/*6326*/ uint16(xReadSlashR),
	/*6327*/ uint16(xArgRM16),
	/*6328*/ uint16(xArgR16),
	/*6329*/ uint16(xMatch),
	/*6330*/ uint16(xSetOp), uint16(BTR),
	/*6332*/ uint16(xReadSlashR),
	/*6333*/ uint16(xArgRM32),
	/*6334*/ uint16(xArgR32),
	/*6335*/ uint16(xMatch),
	/*6336*/ uint16(xCondDataSize), 6324, 6330, 6340,
	/*6340*/ uint16(xSetOp), uint16(BTR),
	/*6342*/ uint16(xReadSlashR),
	/*6343*/ uint16(xArgRM64),
	/*6344*/ uint16(xArgR64),
	/*6345*/ uint16(xMatch),
	/*6346*/ uint16(xCondIs64), 6349, 6365,
	/*6349*/ uint16(xCondDataSize), 6353, 6359, 0,
	/*6353*/ uint16(xSetOp), uint16(LFS),
	/*6355*/ uint16(xReadSlashR),
	/*6356*/ uint16(xArgR16),
	/*6357*/ uint16(xArgM16colon16),
	/*6358*/ uint16(xMatch),
	/*6359*/ uint16(xSetOp), uint16(LFS),
	/*6361*/ uint16(xReadSlashR),
	/*6362*/ uint16(xArgR32),
	/*6363*/ uint16(xArgM16colon32),
	/*6364*/ uint16(xMatch),
	/*6365*/ uint16(xCondDataSize), 6353, 6359, 6369,
	/*6369*/ uint16(xSetOp), uint16(LFS),
	/*6371*/ uint16(xReadSlashR),
	/*6372*/ uint16(xArgR64),
	/*6373*/ uint16(xArgM16colon64),
	/*6374*/ uint16(xMatch),
	/*6375*/ uint16(xCondIs64), 6378, 6394,
	/*6378*/ uint16(xCondDataSize), 6382, 6388, 0,
	/*6382*/ uint16(xSetOp), uint16(LGS),
	/*6384*/ uint16(xReadSlashR),
	/*6385*/ uint16(xArgR16),
	/*6386*/ uint16(xArgM16colon16),
	/*6387*/ uint16(xMatch),
	/*6388*/ uint16(xSetOp), uint16(LGS),
	/*6390*/ uint16(xReadSlashR),
	/*6391*/ uint16(xArgR32),
	/*6392*/ uint16(xArgM16colon32),
	/*6393*/ uint16(xMatch),
	/*6394*/ uint16(xCondDataSize), 6382, 6388, 6398,
	/*6398*/ uint16(xSetOp), uint16(LGS),
	/*6400*/ uint16(xReadSlashR),
	/*6401*/ uint16(xArgR64),
	/*6402*/ uint16(xArgM16colon64),
	/*6403*/ uint16(xMatch),
	/*6404*/ uint16(xCondIs64), 6407, 6423,
	/*6407*/ uint16(xCondDataSize), 6411, 6417, 0,
	/*6411*/ uint16(xSetOp), uint16(MOVZX),
	/*6413*/ uint16(xReadSlashR),
	/*6414*/ uint16(xArgR16),
	/*6415*/ uint16(xArgRM8),
	/*6416*/ uint16(xMatch),
	/*6417*/ uint16(xSetOp), uint16(MOVZX),
	/*6419*/ uint16(xReadSlashR),
	/*6420*/ uint16(xArgR32),
	/*6421*/ uint16(xArgRM8),
	/*6422*/ uint16(xMatch),
	/*6423*/ uint16(xCondDataSize), 6411, 6417, 6427,
	/*6427*/ uint16(xSetOp), uint16(MOVZX),
	/*6429*/ uint16(xReadSlashR),
	/*6430*/ uint16(xArgR64),
	/*6431*/ uint16(xArgRM8),
	/*6432*/ uint16(xMatch),
	/*6433*/ uint16(xCondIs64), 6436, 6452,
	/*6436*/ uint16(xCondDataSize), 6440, 6446, 0,
	/*6440*/ uint16(xSetOp), uint16(MOVZX),
	/*6442*/ uint16(xReadSlashR),
	/*6443*/ uint16(xArgR16),
	/*6444*/ uint16(xArgRM16),
	/*6445*/ uint16(xMatch),
	/*6446*/ uint16(xSetOp), uint16(MOVZX),
	/*6448*/ uint16(xReadSlashR),
	/*6449*/ uint16(xArgR32),
	/*6450*/ uint16(xArgRM16),
	/*6451*/ uint16(xMatch),
	/*6452*/ uint16(xCondDataSize), 6440, 6446, 6456,
	/*6456*/ uint16(xSetOp), uint16(MOVZX),
	/*6458*/ uint16(xReadSlashR),
	/*6459*/ uint16(xArgR64),
	/*6460*/ uint16(xArgRM16),
	/*6461*/ uint16(xMatch),
	/*6462*/ uint16(xCondIs64), 6465, 6485,
	/*6465*/ uint16(xCondPrefix), 1,
	0xF3, 6469,
	/*6469*/ uint16(xCondDataSize), 6473, 6479, 0,
	/*6473*/ uint16(xSetOp), uint16(POPCNT),
	/*6475*/ uint16(xReadSlashR),
	/*6476*/ uint16(xArgR16),
	/*6477*/ uint16(xArgRM16),
	/*6478*/ uint16(xMatch),
	/*6479*/ uint16(xSetOp), uint16(POPCNT),
	/*6481*/ uint16(xReadSlashR),
	/*6482*/ uint16(xArgR32),
	/*6483*/ uint16(xArgRM32),
	/*6484*/ uint16(xMatch),
	/*6485*/ uint16(xCondPrefix), 1,
	0xF3, 6489,
	/*6489*/ uint16(xCondDataSize), 6473, 6479, 6493,
	/*6493*/ uint16(xSetOp), uint16(POPCNT),
	/*6495*/ uint16(xReadSlashR),
	/*6496*/ uint16(xArgR64),
	/*6497*/ uint16(xArgRM64),
	/*6498*/ uint16(xMatch),
	/*6499*/ uint16(xSetOp), uint16(UD1),
	/*6501*/ uint16(xMatch),
	/*6502*/ uint16(xCondSlashR),
	0,    // 0
	0,    // 1
	0,    // 2
	0,    // 3
	6511, // 4
	6540, // 5
	6569, // 6
	6598, // 7
	/*6511*/ uint16(xCondIs64), 6514, 6530,
	/*6514*/ uint16(xCondDataSize), 6518, 6524, 0,
	/*6518*/ uint16(xSetOp), uint16(BT),
	/*6520*/ uint16(xReadIb),
	/*6521*/ uint16(xArgRM16),
	/*6522*/ uint16(xArgImm8u),
	/*6523*/ uint16(xMatch),
	/*6524*/ uint16(xSetOp), uint16(BT),
	/*6526*/ uint16(xReadIb),
	/*6527*/ uint16(xArgRM32),
	/*6528*/ uint16(xArgImm8u),
	/*6529*/ uint16(xMatch),
	/*6530*/ uint16(xCondDataSize), 6518, 6524, 6534,
	/*6534*/ uint16(xSetOp), uint16(BT),
	/*6536*/ uint16(xReadIb),
	/*6537*/ uint16(xArgRM64),
	/*6538*/ uint16(xArgImm8u),
	/*6539*/ uint16(xMatch),
	/*6540*/ uint16(xCondIs64), 6543, 6559,
	/*6543*/ uint16(xCondDataSize), 6547, 6553, 0,
	/*6547*/ uint16(xSetOp), uint16(BTS),
	/*6549*/ uint16(xReadIb),
	/*6550*/ uint16(xArgRM16),
	/*6551*/ uint16(xArgImm8u),
	/*6552*/ uint16(xMatch),
	/*6553*/ uint16(xSetOp), uint16(BTS),
	/*6555*/ uint16(xReadIb),
	/*6556*/ uint16(xArgRM32),
	/*6557*/ uint16(xArgImm8u),
	/*6558*/ uint16(xMatch),
	/*6559*/ uint16(xCondDataSize), 6547, 6553, 6563,
	/*6563*/ uint16(xSetOp), uint16(BTS),
	/*6565*/ uint16(xReadIb),
	/*6566*/ uint16(xArgRM64),
	/*6567*/ uint16(xArgImm8u),
	/*6568*/ uint16(xMatch),
	/*6569*/ uint16(xCondIs64), 6572, 6588,
	/*6572*/ uint16(xCondDataSize), 6576, 6582, 0,
	/*6576*/ uint16(xSetOp), uint16(BTR),
	/*6578*/ uint16(xReadIb),
	/*6579*/ uint16(xArgRM16),
	/*6580*/ uint16(xArgImm8u),
	/*6581*/ uint16(xMatch),
	/*6582*/ uint16(xSetOp), uint16(BTR),
	/*6584*/ uint16(xReadIb),
	/*6585*/ uint16(xArgRM32),
	/*6586*/ uint16(xArgImm8u),
	/*6587*/ uint16(xMatch),
	/*6588*/ uint16(xCondDataSize), 6576, 6582, 6592,
	/*6592*/ uint16(xSetOp), uint16(BTR),
	/*6594*/ uint16(xReadIb),
	/*6595*/ uint16(xArgRM64),
	/*6596*/ uint16(xArgImm8u),
	/*6597*/ uint16(xMatch),
	/*6598*/ uint16(xCondIs64), 6601, 6617,
	/*6601*/ uint16(xCondDataSize), 6605, 6611, 0,
	/*6605*/ uint16(xSetOp), uint16(BTC),
	/*6607*/ uint16(xReadIb),
	/*6608*/ uint16(xArgRM16),
	/*6609*/ uint16(xArgImm8u),
	/*6610*/ uint16(xMatch),
	/*6611*/ uint16(xSetOp), uint16(BTC),
	/*6613*/ uint16(xReadIb),
	/*6614*/ uint16(xArgRM32),
	/*6615*/ uint16(xArgImm8u),
	/*6616*/ uint16(xMatch),
	/*6617*/ uint16(xCondDataSize), 6605, 6611, 6621,
	/*6621*/ uint16(xSetOp), uint16(BTC),
	/*6623*/ uint16(xReadIb),
	/*6624*/ uint16(xArgRM64),
	/*6625*/ uint16(xArgImm8u),
	/*6626*/ uint16(xMatch),
	/*6627*/ uint16(xCondIs64), 6630, 6646,
	/*6630*/ uint16(xCondDataSize), 6634, 6640, 0,
	/*6634*/ uint16(xSetOp), uint16(BTC),
	/*6636*/ uint16(xReadSlashR),
	/*6637*/ uint16(xArgRM16),
	/*6638*/ uint16(xArgR16),
	/*6639*/ uint16(xMatch),
	/*6640*/ uint16(xSetOp), uint16(BTC),
	/*6642*/ uint16(xReadSlashR),
	/*6643*/ uint16(xArgRM32),
	/*6644*/ uint16(xArgR32),
	/*6645*/ uint16(xMatch),
	/*6646*/ uint16(xCondDataSize), 6634, 6640, 6650,
	/*6650*/ uint16(xSetOp), uint16(BTC),
	/*6652*/ uint16(xReadSlashR),
	/*6653*/ uint16(xArgRM64),
	/*6654*/ uint16(xArgR64),
	/*6655*/ uint16(xMatch),
	/*6656*/ uint16(xCondIs64), 6659, 6697,
	/*6659*/ uint16(xCondPrefix), 2,
	0xF3, 6681,
	0x0, 6665,
	/*6665*/ uint16(xCondDataSize), 6669, 6675, 0,
	/*6669*/ uint16(xSetOp), uint16(BSF),
	/*6671*/ uint16(xReadSlashR),
	/*6672*/ uint16(xArgR16),
	/*6673*/ uint16(xArgRM16),
	/*6674*/ uint16(xMatch),
	/*6675*/ uint16(xSetOp), uint16(BSF),
	/*6677*/ uint16(xReadSlashR),
	/*6678*/ uint16(xArgR32),
	/*6679*/ uint16(xArgRM32),
	/*6680*/ uint16(xMatch),
	/*6681*/ uint16(xCondDataSize), 6685, 6691, 0,
	/*6685*/ uint16(xSetOp), uint16(TZCNT),
	/*6687*/ uint16(xReadSlashR),
	/*6688*/ uint16(xArgR16),
	/*6689*/ uint16(xArgRM16),
	/*6690*/ uint16(xMatch),
	/*6691*/ uint16(xSetOp), uint16(TZCNT),
	/*6693*/ uint16(xReadSlashR),
	/*6694*/ uint16(xArgR32),
	/*6695*/ uint16(xArgRM32),
	/*6696*/ uint16(xMatch),
	/*6697*/ uint16(xCondPrefix), 2,
	0xF3, 6713,
	0x0, 6703,
	/*6703*/ uint16(xCondDataSize), 6669, 6675, 6707,
	/*6707*/ uint16(xSetOp), uint16(BSF),
	/*6709*/ uint16(xReadSlashR),
	/*6710*/ uint16(xArgR64),
	/*6711*/ uint16(xArgRM64),
	/*6712*/ uint16(xMatch),
	/*6713*/ uint16(xCondDataSize), 6685, 6691, 6717,
	/*6717*/ uint16(xSetOp), uint16(TZCNT),
	/*6719*/ uint16(xReadSlashR),
	/*6720*/ uint16(xArgR64),
	/*6721*/ uint16(xArgRM64),
	/*6722*/ uint16(xMatch),
	/*6723*/ uint16(xCondIs64), 6726, 6764,
	/*6726*/ uint16(xCondPrefix), 2,
	0xF3, 6748,
	0x0, 6732,
	/*6732*/ uint16(xCondDataSize), 6736, 6742, 0,
	/*6736*/ uint16(xSetOp), uint16(BSR),
	/*6738*/ uint16(xReadSlashR),
	/*6739*/ uint16(xArgR16),
	/*6740*/ uint16(xArgRM16),
	/*6741*/ uint16(xMatch),
	/*6742*/ uint16(xSetOp), uint16(BSR),
	/*6744*/ uint16(xReadSlashR),
	/*6745*/ uint16(xArgR32),
	/*6746*/ uint16(xArgRM32),
	/*6747*/ uint16(xMatch),
	/*6748*/ uint16(xCondDataSize), 6752, 6758, 0,
	/*6752*/ uint16(xSetOp), uint16(LZCNT),
	/*6754*/ uint16(xReadSlashR),
	/*6755*/ uint16(xArgR16),
	/*6756*/ uint16(xArgRM16),
	/*6757*/ uint16(xMatch),
	/*6758*/ uint16(xSetOp), uint16(LZCNT),
	/*6760*/ uint16(xReadSlashR),
	/*6761*/ uint16(xArgR32),
	/*6762*/ uint16(xArgRM32),
	/*6763*/ uint16(xMatch),
	/*6764*/ uint16(xCondPrefix), 2,
	0xF3, 6780,
	0x0, 6770,
	/*6770*/ uint16(xCondDataSize), 6736, 6742, 6774,
	/*6774*/ uint16(xSetOp), uint16(BSR),
	/*6776*/ uint16(xReadSlashR),
	/*6777*/ uint16(xArgR64),
	/*6778*/ uint16(xArgRM64),
	/*6779*/ uint16(xMatch),
	/*6780*/ uint16(xCondDataSize), 6752, 6758, 6784,
	/*6784*/ uint16(xSetOp), uint16(LZCNT),
	/*6786*/ uint16(xReadSlashR),
	/*6787*/ uint16(xArgR64),
	/*6788*/ uint16(xArgRM64),
	/*6789*/ uint16(xMatch),
	/*6790*/ uint16(xCondIs64), 6793, 6809,
	/*6793*/ uint16(xCondDataSize), 6797, 6803, 0,
	/*6797*/ uint16(xSetOp), uint16(MOVSX),
	/*6799*/ uint16(xReadSlashR),
	/*6800*/ uint16(xArgR16),
	/*6801*/ uint16(xArgRM8),
	/*6802*/ uint16(xMatch),
	/*6803*/ uint16(xSetOp), uint16(MOVSX),
	/*6805*/ uint16(xReadSlashR),
	/*6806*/ uint16(xArgR32),
	/*6807*/ uint16(xArgRM8),
	/*6808*/ uint16(xMatch),
	/*6809*/ uint16(xCondDataSize), 6797, 6803, 6813,
	/*6813*/ uint16(xSetOp), uint16(MOVSX),
	/*6815*/ uint16(xReadSlashR),
	/*6816*/ uint16(xArgR64),
	/*6817*/ uint16(xArgRM8),
	/*6818*/ uint16(xMatch),
	/*6819*/ uint16(xCondIs64), 6822, 6838,
	/*6822*/ uint16(xCondDataSize), 6826, 6832, 0,
	/*6826*/ uint16(xSetOp), uint16(MOVSX),
	/*6828*/ uint16(xReadSlashR),
	/*6829*/ uint16(xArgR16),
	/*6830*/ uint16(xArgRM16),
	/*6831*/ uint16(xMatch),
	/*6832*/ uint16(xSetOp), uint16(MOVSX),
	/*6834*/ uint16(xReadSlashR),
	/*6835*/ uint16(xArgR32),
	/*6836*/ uint16(xArgRM16),
	/*6837*/ uint16(xMatch),
	/*6838*/ uint16(xCondDataSize), 6826, 6832, 6842,
	/*6842*/ uint16(xSetOp), uint16(MOVSX),
	/*6844*/ uint16(xReadSlashR),
	/*6845*/ uint16(xArgR64),
	/*6846*/ uint16(xArgRM16),
	/*6847*/ uint16(xMatch),
	/*6848*/ uint16(xSetOp), uint16(XADD),
	/*6850*/ uint16(xReadSlashR),
	/*6851*/ uint16(xArgRM8),
	/*6852*/ uint16(xArgR8),
	/*6853*/ uint16(xMatch),
	/*6854*/ uint16(xCondIs64), 6857, 6873,
	/*6857*/ uint16(xCondDataSize), 6861, 6867, 0,
	/*6861*/ uint16(xSetOp), uint16(XADD),
	/*6863*/ uint16(xReadSlashR),
	/*6864*/ uint16(xArgRM16),
	/*6865*/ uint16(xArgR16),
	/*6866*/ uint16(xMatch),
	/*6867*/ uint16(xSetOp), uint16(XADD),
	/*6869*/ uint16(xReadSlashR),
	/*6870*/ uint16(xArgRM32),
	/*6871*/ uint16(xArgR32),
	/*6872*/ uint16(xMatch),
	/*6873*/ uint16(xCondDataSize), 6861, 6867, 6877,
	/*6877*/ uint16(xSetOp), uint16(XADD),
	/*6879*/ uint16(xReadSlashR),
	/*6880*/ uint16(xArgRM64),
	/*6881*/ uint16(xArgR64),
	/*6882*/ uint16(xMatch),
	/*6883*/ uint16(xCondPrefix), 4,
	0xF3, 6917,
	0xF2, 6909,
	0x66, 6901,
	0x0, 6893,
	/*6893*/ uint16(xSetOp), uint16(CMPPS),
	/*6895*/ uint16(xReadSlashR),
	/*6896*/ uint16(xReadIb),
	/*6897*/ uint16(xArgXmm1),
	/*6898*/ uint16(xArgXmm2M128),
	/*6899*/ uint16(xArgImm8u),
	/*6900*/ uint16(xMatch),
	/*6901*/ uint16(xSetOp), uint16(CMPPD),
	/*6903*/ uint16(xReadSlashR),
	/*6904*/ uint16(xReadIb),
	/*6905*/ uint16(xArgXmm1),
	/*6906*/ uint16(xArgXmm2M128),
	/*6907*/ uint16(xArgImm8u),
	/*6908*/ uint16(xMatch),
	/*6909*/ uint16(xSetOp), uint16(CMPSD_XMM),
	/*6911*/ uint16(xReadSlashR),
	/*6912*/ uint16(xReadIb),
	/*6913*/ uint16(xArgXmm1),
	/*6914*/ uint16(xArgXmm2M64),
	/*6915*/ uint16(xArgImm8u),
	/*6916*/ uint16(xMatch),
	/*6917*/ uint16(xSetOp), uint16(CMPSS),
	/*6919*/ uint16(xReadSlashR),
	/*6920*/ uint16(xReadIb),
	/*6921*/ uint16(xArgXmm1),
	/*6922*/ uint16(xArgXmm2M32),
	/*6923*/ uint16(xArgImm8u),
	/*6924*/ uint16(xMatch),
	/*6925*/ uint16(xCondIs64), 6928, 6944,
	/*6928*/ uint16(xCondDataSize), 6932, 6938, 0,
	/*6932*/ uint16(xSetOp), uint16(MOVNTI),
	/*6934*/ uint16(xReadSlashR),
	/*6935*/ uint16(xArgM32),
	/*6936*/ uint16(xArgR32),
	/*6937*/ uint16(xMatch),
	/*6938*/ uint16(xSetOp), uint16(MOVNTI),
	/*6940*/ uint16(xReadSlashR),
	/*6941*/ uint16(xArgM32),
	/*6942*/ uint16(xArgR32),
	/*6943*/ uint16(xMatch),
	/*6944*/ uint16(xCondDataSize), 6932, 6938, 6948,
	/*6948*/ uint16(xSetOp), uint16(MOVNTI),
	/*6950*/ uint16(xReadSlashR),
	/*6951*/ uint16(xArgM64),
	/*6952*/ uint16(xArgR64),
	/*6953*/ uint16(xMatch),
	/*6954*/ uint16(xCondPrefix), 2,
	0x66, 6968,
	0x0, 6960,
	/*6960*/ uint16(xSetOp), uint16(PINSRW),
	/*6962*/ uint16(xReadSlashR),
	/*6963*/ uint16(xReadIb),
	/*6964*/ uint16(xArgMm),
	/*6965*/ uint16(xArgR32M16),
	/*6966*/ uint16(xArgImm8u),
	/*6967*/ uint16(xMatch),
	/*6968*/ uint16(xSetOp), uint16(PINSRW),
	/*6970*/ uint16(xReadSlashR),
	/*6971*/ uint16(xReadIb),
	/*6972*/ uint16(xArgXmm),
	/*6973*/ uint16(xArgR32M16),
	/*6974*/ uint16(xArgImm8u),
	/*6975*/ uint16(xMatch),
	/*6976*/ uint16(xCondPrefix), 2,
	0x66, 6990,
	0x0, 6982,
	/*6982*/ uint16(xSetOp), uint16(PEXTRW),
	/*6984*/ uint16(xReadSlashR),
	/*6985*/ uint16(xReadIb),
	/*6986*/ uint16(xArgR32),
	/*6987*/ uint16(xArgMm2),
	/*6988*/ uint16(xArgImm8u),
	/*6989*/ uint16(xMatch),
	/*6990*/ uint16(xSetOp), uint16(PEXTRW),
	/*6992*/ uint16(xReadSlashR),
	/*6993*/ uint16(xReadIb),
	/*6994*/ uint16(xArgR32),
	/*6995*/ uint16(xArgXmm2),
	/*6996*/ uint16(xArgImm8u),
	/*6997*/ uint16(xMatch),
	/*6998*/ uint16(xCondPrefix), 2,
	0x66, 7012,
	0x0, 7004,
	/*7004*/ uint16(xSetOp), uint16(SHUFPS),
	/*7006*/ uint16(xReadSlashR),
	/*7007*/ uint16(xReadIb),
	/*7008*/ uint16(xArgXmm1),
	/*7009*/ uint16(xArgXmm2M128),
	/*7010*/ uint16(xArgImm8u),
	/*7011*/ uint16(xMatch),
	/*7012*/ uint16(xSetOp), uint16(SHUFPD),
	/*7014*/ uint16(xReadSlashR),
	/*7015*/ uint16(xReadIb),
	/*7016*/ uint16(xArgXmm1),
	/*7017*/ uint16(xArgXmm2M128),
	/*7018*/ uint16(xArgImm8u),
	/*7019*/ uint16(xMatch),
	/*7020*/ uint16(xCondSlashR),
	0,    // 0
	7029, // 1
	0,    // 2
	7052, // 3
	7075, // 4
	7098, // 5
	7121, // 6
	0,    // 7
	/*7029*/ uint16(xCondIs64), 7032, 7044,
	/*7032*/ uint16(xCondDataSize), 7036, 7040, 0,
	/*7036*/ uint16(xSetOp), uint16(CMPXCHG8B),
	/*7038*/ uint16(xArgM64),
	/*7039*/ uint16(xMatch),
	/*7040*/ uint16(xSetOp), uint16(CMPXCHG8B),
	/*7042*/ uint16(xArgM64),
	/*7043*/ uint16(xMatch),
	/*7044*/ uint16(xCondDataSize), 7036, 7040, 7048,
	/*7048*/ uint16(xSetOp), uint16(CMPXCHG16B),
	/*7050*/ uint16(xArgM128),
	/*7051*/ uint16(xMatch),
	/*7052*/ uint16(xCondIs64), 7055, 7067,
	/*7055*/ uint16(xCondDataSize), 7059, 7063, 0,
	/*7059*/ uint16(xSetOp), uint16(XRSTORS),
	/*7061*/ uint16(xArgMem),
	/*7062*/ uint16(xMatch),
	/*7063*/ uint16(xSetOp), uint16(XRSTORS),
	/*7065*/ uint16(xArgMem),
	/*7066*/ uint16(xMatch),
	/*7067*/ uint16(xCondDataSize), 7059, 7063, 7071,
	/*7071*/ uint16(xSetOp), uint16(XRSTORS64),
	/*7073*/ uint16(xArgMem),
	/*7074*/ uint16(xMatch),
	/*7075*/ uint16(xCondIs64), 7078, 7090,
	/*7078*/ uint16(xCondDataSize), 7082, 7086, 0,
	/*7082*/ uint16(xSetOp), uint16(XSAVEC),
	/*7084*/ uint16(xArgMem),
	/*7085*/ uint16(xMatch),
	/*7086*/ uint16(xSetOp), uint16(XSAVEC),
	/*7088*/ uint16(xArgMem),
	/*7089*/ uint16(xMatch),
	/*7090*/ uint16(xCondDataSize), 7082, 7086, 7094,
	/*7094*/ uint16(xSetOp), uint16(XSAVEC64),
	/*7096*/ uint16(xArgMem),
	/*7097*/ uint16(xMatch),
	/*7098*/ uint16(xCondIs64), 7101, 7113,
	/*7101*/ uint16(xCondDataSize), 7105, 7109, 0,
	/*7105*/ uint16(xSetOp), uint16(XSAVES),
	/*7107*/ uint16(xArgMem),
	/*7108*/ uint16(xMatch),
	/*7109*/ uint16(xSetOp), uint16(XSAVES),
	/*7111*/ uint16(xArgMem),
	/*7112*/ uint16(xMatch),
	/*7113*/ uint16(xCondDataSize), 7105, 7109, 7117,
	/*7117*/ uint16(xSetOp), uint16(XSAVES64),
	/*7119*/ uint16(xArgMem),
	/*7120*/ uint16(xMatch),
	/*7121*/ uint16(xCondIs64), 7124, 7142,
	/*7124*/ uint16(xCondDataSize), 7128, 7135, 0,
	/*7128*/ uint16(xCondIsMem), 7131, 0,
	/*7131*/ uint16(xSetOp), uint16(RDRAND),
	/*7133*/ uint16(xArgRmf16),
	/*7134*/ uint16(xMatch),
	/*7135*/ uint16(xCondIsMem), 7138, 0,
	/*7138*/ uint16(xSetOp), uint16(RDRAND),
	/*7140*/ uint16(xArgRmf32),
	/*7141*/ uint16(xMatch),
	/*7142*/ uint16(xCondDataSize), 7128, 7135, 7146,
	/*7146*/ uint16(xSetOp), uint16(RDRAND),
	/*7148*/ uint16(xMatch),
	/*7149*/ uint16(xCondIs64), 7152, 7164,
	/*7152*/ uint16(xCondDataSize), 7156, 7160, 0,
	/*7156*/ uint16(xSetOp), uint16(BSWAP),
	/*7158*/ uint16(xArgR16op),
	/*7159*/ uint16(xMatch),
	/*7160*/ uint16(xSetOp), uint16(BSWAP),
	/*7162*/ uint16(xArgR32op),
	/*7163*/ uint16(xMatch),
	/*7164*/ uint16(xCondDataSize), 7156, 7160, 7168,
	/*7168*/ uint16(xSetOp), uint16(BSWAP),
	/*7170*/ uint16(xArgR64op),
	/*7171*/ uint16(xMatch),
	/*7172*/ uint16(xCondPrefix), 2,
	0xF2, 7184,
	0x66, 7178,
	/*7178*/ uint16(xSetOp), uint16(ADDSUBPD),
	/*7180*/ uint16(xReadSlashR),
	/*7181*/ uint16(xArgXmm1),
	/*7182*/ uint16(xArgXmm2M128),
	/*7183*/ uint16(xMatch),
	/*7184*/ uint16(xSetOp), uint16(ADDSUBPS),
	/*7186*/ uint16(xReadSlashR),
	/*7187*/ uint16(xArgXmm1),
	/*7188*/ uint16(xArgXmm2M128),
	/*7189*/ uint16(xMatch),
	/*7190*/ uint16(xCondPrefix), 2,
	0x66, 7202,
	0x0, 7196,
	/*7196*/ uint16(xSetOp), uint16(PSRLW),
	/*7198*/ uint16(xReadSlashR),
	/*7199*/ uint16(xArgMm),
	/*7200*/ uint16(xArgMmM64),
	/*7201*/ uint16(xMatch),
	/*7202*/ uint16(xSetOp), uint16(PSRLW),
	/*7204*/ uint16(xReadSlashR),
	/*7205*/ uint16(xArgXmm1),
	/*7206*/ uint16(xArgXmm2M128),
	/*7207*/ uint16(xMatch),
	/*7208*/ uint16(xCondPrefix), 2,
	0x66, 7220,
	0x0, 7214,
	/*7214*/ uint16(xSetOp), uint16(PSRLD),
	/*7216*/ uint16(xReadSlashR),
	/*7217*/ uint16(xArgMm),
	/*7218*/ uint16(xArgMmM64),
	/*7219*/ uint16(xMatch),
	/*7220*/ uint16(xSetOp), uint16(PSRLD),
	/*7222*/ uint16(xReadSlashR),
	/*7223*/ uint16(xArgXmm1),
	/*7224*/ uint16(xArgXmm2M128),
	/*7225*/ uint16(xMatch),
	/*7226*/ uint16(xCondPrefix), 2,
	0x66, 7238,
	0x0, 7232,
	/*7232*/ uint16(xSetOp), uint16(PSRLQ),
	/*7234*/ uint16(xReadSlashR),
	/*7235*/ uint16(xArgMm),
	/*7236*/ uint16(xArgMmM64),
	/*7237*/ uint16(xMatch),
	/*7238*/ uint16(xSetOp), uint16(PSRLQ),
	/*7240*/ uint16(xReadSlashR),
	/*7241*/ uint16(xArgXmm1),
	/*7242*/ uint16(xArgXmm2M128),
	/*7243*/ uint16(xMatch),
	/*7244*/ uint16(xCondPrefix), 2,
	0x66, 7256,
	0x0, 7250,
	/*7250*/ uint16(xSetOp), uint16(PADDQ),
	/*7252*/ uint16(xReadSlashR),
	/*7253*/ uint16(xArgMm1),
	/*7254*/ uint16(xArgMm2M64),
	/*7255*/ uint16(xMatch),
	/*7256*/ uint16(xSetOp), uint16(PADDQ),
	/*7258*/ uint16(xReadSlashR),
	/*7259*/ uint16(xArgXmm1),
	/*7260*/ uint16(xArgXmm2M128),
	/*7261*/ uint16(xMatch),
	/*7262*/ uint16(xCondPrefix), 2,
	0x66, 7274,
	0x0, 7268,
	/*7268*/ uint16(xSetOp), uint16(PMULLW),
	/*7270*/ uint16(xReadSlashR),
	/*7271*/ uint16(xArgMm),
	/*7272*/ uint16(xArgMmM64),
	/*7273*/ uint16(xMatch),
	/*7274*/ uint16(xSetOp), uint16(PMULLW),
	/*7276*/ uint16(xReadSlashR),
	/*7277*/ uint16(xArgXmm1),
	/*7278*/ uint16(xArgXmm2M128),
	/*7279*/ uint16(xMatch),
	/*7280*/ uint16(xCondPrefix), 3,
	0xF3, 7300,
	0xF2, 7294,
	0x66, 7288,
	/*7288*/ uint16(xSetOp), uint16(MOVQ),
	/*7290*/ uint16(xReadSlashR),
	/*7291*/ uint16(xArgXmm2M64),
	/*7292*/ uint16(xArgXmm1),
	/*7293*/ uint16(xMatch),
	/*7294*/ uint16(xSetOp), uint16(MOVDQ2Q),
	/*7296*/ uint16(xReadSlashR),
	/*7297*/ uint16(xArgMm),
	/*7298*/ uint16(xArgXmm2),
	/*7299*/ uint16(xMatch),
	/*7300*/ uint16(xSetOp), uint16(MOVQ2DQ),
	/*7302*/ uint16(xReadSlashR),
	/*7303*/ uint16(xArgXmm1),
	/*7304*/ uint16(xArgMm2),
	/*7305*/ uint16(xMatch),
	/*7306*/ uint16(xCondPrefix), 2,
	0x66, 7318,
	0x0, 7312,
	/*7312*/ uint16(xSetOp), uint16(PMOVMSKB),
	/*7314*/ uint16(xReadSlashR),
	/*7315*/ uint16(xArgR32),
	/*7316*/ uint16(xArgMm2),
	/*7317*/ uint16(xMatch),
	/*7318*/ uint16(xSetOp), uint16(PMOVMSKB),
	/*7320*/ uint16(xReadSlashR),
	/*7321*/ uint16(xArgR32),
	/*7322*/ uint16(xArgXmm2),
	/*7323*/ uint16(xMatch),
	/*7324*/ uint16(xCondPrefix), 2,
	0x66, 7336,
	0x0, 7330,
	/*7330*/ uint16(xSetOp), uint16(PSUBUSB),
	/*7332*/ uint16(xReadSlashR),
	/*7333*/ uint16(xArgMm),
	/*7334*/ uint16(xArgMmM64),
	/*7335*/ uint16(xMatch),
	/*7336*/ uint16(xSetOp), uint16(PSUBUSB),
	/*7338*/ uint16(xReadSlashR),
	/*7339*/ uint16(xArgXmm1),
	/*7340*/ uint16(xArgXmm2M128),
	/*7341*/ uint16(xMatch),
	/*7342*/ uint16(xCondPrefix), 2,
	0x66, 7354,
	0x0, 7348,
	/*7348*/ uint16(xSetOp), uint16(PSUBUSW),
	/*7350*/ uint16(xReadSlashR),
	/*7351*/ uint16(xArgMm),
	/*7352*/ uint16(xArgMmM64),
	/*7353*/ uint16(xMatch),
	/*7354*/ uint16(xSetOp), uint16(PSUBUSW),
	/*7356*/ uint16(xReadSlashR),
	/*7357*/ uint16(xArgXmm1),
	/*7358*/ uint16(xArgXmm2M128),
	/*7359*/ uint16(xMatch),
	/*7360*/ uint16(xCondPrefix), 2,
	0x66, 7372,
	0x0, 7366,
	/*7366*/ uint16(xSetOp), uint16(PMINUB),
	/*7368*/ uint16(xReadSlashR),
	/*7369*/ uint16(xArgMm1),
	/*7370*/ uint16(xArgMm2M64),
	/*7371*/ uint16(xMatch),
	/*7372*/ uint16(xSetOp), uint16(PMINUB),
	/*7374*/ uint16(xReadSlashR),
	/*7375*/ uint16(xArgXmm1),
	/*7376*/ uint16(xArgXmm2M128),
	/*7377*/ uint16(xMatch),
	/*7378*/ uint16(xCondPrefix), 2,
	0x66, 7390,
	0x0, 7384,
	/*7384*/ uint16(xSetOp), uint16(PAND),
	/*7386*/ uint16(xReadSlashR),
	/*7387*/ uint16(xArgMm),
	/*7388*/ uint16(xArgMmM64),
	/*7389*/ uint16(xMatch),
	/*7390*/ uint16(xSetOp), uint16(PAND),
	/*7392*/ uint16(xReadSlashR),
	/*7393*/ uint16(xArgXmm1),
	/*7394*/ uint16(xArgXmm2M128),
	/*7395*/ uint16(xMatch),
	/*7396*/ uint16(xCondPrefix), 2,
	0x66, 7408,
	0x0, 7402,
	/*7402*/ uint16(xSetOp), uint16(PADDUSB),
	/*7404*/ uint16(xReadSlashR),
	/*7405*/ uint16(xArgMm),
	/*7406*/ uint16(xArgMmM64),
	/*7407*/ uint16(xMatch),
	/*7408*/ uint16(xSetOp), uint16(PADDUSB),
	/*7410*/ uint16(xReadSlashR),
	/*7411*/ uint16(xArgXmm1),
	/*7412*/ uint16(xArgXmm2M128),
	/*7413*/ uint16(xMatch),
	/*7414*/ uint16(xCondPrefix), 2,
	0x66, 7426,
	0x0, 7420,
	/*7420*/ uint16(xSetOp), uint16(PADDUSW),
	/*7422*/ uint16(xReadSlashR),
	/*7423*/ uint16(xArgMm),
	/*7424*/ uint16(xArgMmM64),
	/*7425*/ uint16(xMatch),
	/*7426*/ uint16(xSetOp), uint16(PADDUSW),
	/*7428*/ uint16(xReadSlashR),
	/*7429*/ uint16(xArgXmm1),
	/*7430*/ uint16(xArgXmm2M128),
	/*7431*/ uint16(xMatch),
	/*7432*/ uint16(xCondPrefix), 2,
	0x66, 7444,
	0x0, 7438,
	/*7438*/ uint16(xSetOp), uint16(PMAXUB),
	/*7440*/ uint16(xReadSlashR),
	/*7441*/ uint16(xArgMm1),
	/*7442*/ uint16(xArgMm2M64),
	/*7443*/ uint16(xMatch),
	/*7444*/ uint16(xSetOp), uint16(PMAXUB),
	/*7446*/ uint16(xReadSlashR),
	/*7447*/ uint16(xArgXmm1),
	/*7448*/ uint16(xArgXmm2M128),
	/*7449*/ uint16(xMatch),
	/*7450*/ uint16(xCondPrefix), 2,
	0x66, 7462,
	0x0, 7456,
	/*7456*/ uint16(xSetOp), uint16(PANDN),
	/*7458*/ uint16(xReadSlashR),
	/*7459*/ uint16(xArgMm),
	/*7460*/ uint16(xArgMmM64),
	/*7461*/ uint16(xMatch),
	/*7462*/ uint16(xSetOp), uint16(PANDN),
	/*7464*/ uint16(xReadSlashR),
	/*7465*/ uint16(xArgXmm1),
	/*7466*/ uint16(xArgXmm2M128),
	/*7467*/ uint16(xMatch),
	/*7468*/ uint16(xCondPrefix), 2,
	0x66, 7480,
	0x0, 7474,
	/*7474*/ uint16(xSetOp), uint16(PAVGB),
	/*7476*/ uint16(xReadSlashR),
	/*7477*/ uint16(xArgMm1),
	/*7478*/ uint16(xArgMm2M64),
	/*7479*/ uint16(xMatch),
	/*7480*/ uint16(xSetOp), uint16(PAVGB),
	/*7482*/ uint16(xReadSlashR),
	/*7483*/ uint16(xArgXmm1),
	/*7484*/ uint16(xArgXmm2M128),
	/*7485*/ uint16(xMatch),
	/*7486*/ uint16(xCondPrefix), 2,
	0x66, 7498,
	0x0, 7492,
	/*7492*/ uint16(xSetOp), uint16(PSRAW),
	/*7494*/ uint16(xReadSlashR),
	/*7495*/ uint16(xArgMm),
	/*7496*/ uint16(xArgMmM64),
	/*7497*/ uint16(xMatch),
	/*7498*/ uint16(xSetOp), uint16(PSRAW),
	/*7500*/ uint16(xReadSlashR),
	/*7501*/ uint16(xArgXmm1),
	/*7502*/ uint16(xArgXmm2M128),
	/*7503*/ uint16(xMatch),
	/*7504*/ uint16(xCondPrefix), 2,
	0x66, 7516,
	0x0, 7510,
	/*7510*/ uint16(xSetOp), uint16(PSRAD),
	/*7512*/ uint16(xReadSlashR),
	/*7513*/ uint16(xArgMm),
	/*7514*/ uint16(xArgMmM64),
	/*7515*/ uint16(xMatch),
	/*7516*/ uint16(xSetOp), uint16(PSRAD),
	/*7518*/ uint16(xReadSlashR),
	/*7519*/ uint16(xArgXmm1),
	/*7520*/ uint16(xArgXmm2M128),
	/*7521*/ uint16(xMatch),
	/*7522*/ uint16(xCondPrefix), 2,
	0x66, 7534,
	0x0, 7528,
	/*7528*/ uint16(xSetOp), uint16(PAVGW),
	/*7530*/ uint16(xReadSlashR),
	/*7531*/ uint16(xArgMm1),
	/*7532*/ uint16(xArgMm2M64),
	/*7533*/ uint16(xMatch),
	/*7534*/ uint16(xSetOp), uint16(PAVGW),
	/*7536*/ uint16(xReadSlashR),
	/*7537*/ uint16(xArgXmm1),
	/*7538*/ uint16(xArgXmm2M128),
	/*7539*/ uint16(xMatch),
	/*7540*/ uint16(xCondPrefix), 2,
	0x66, 7552,
	0x0, 7546,
	/*7546*/ uint16(xSetOp), uint16(PMULHUW),
	/*7548*/ uint16(xReadSlashR),
	/*7549*/ uint16(xArgMm1),
	/*7550*/ uint16(xArgMm2M64),
	/*7551*/ uint16(xMatch),
	/*7552*/ uint16(xSetOp), uint16(PMULHUW),
	/*7554*/ uint16(xReadSlashR),
	/*7555*/ uint16(xArgXmm1),
	/*7556*/ uint16(xArgXmm2M128),
	/*7557*/ uint16(xMatch),
	/*7558*/ uint16(xCondPrefix), 2,
	0x66, 7570,
	0x0, 7564,
	/*7564*/ uint16(xSetOp), uint16(PMULHW),
	/*7566*/ uint16(xReadSlashR),
	/*7567*/ uint16(xArgMm),
	/*7568*/ uint16(xArgMmM64),
	/*7569*/ uint16(xMatch),
	/*7570*/ uint16(xSetOp), uint16(PMULHW),
	/*7572*/ uint16(xReadSlashR),
	/*7573*/ uint16(xArgXmm1),
	/*7574*/ uint16(xArgXmm2M128),
	/*7575*/ uint16(xMatch),
	/*7576*/ uint16(xCondPrefix), 3,
	0xF3, 7596,
	0xF2, 7590,
	0x66, 7584,
	/*7584*/ uint16(xSetOp), uint16(CVTTPD2DQ),
	/*7586*/ uint16(xReadSlashR),
	/*7587*/ uint16(xArgXmm1),
	/*7588*/ uint16(xArgXmm2M128),
	/*7589*/ uint16(xMatch),
	/*7590*/ uint16(xSetOp), uint16(CVTPD2DQ),
	/*7592*/ uint16(xReadSlashR),
	/*7593*/ uint16(xArgXmm1),
	/*7594*/ uint16(xArgXmm2M128),
	/*7595*/ uint16(xMatch),
	/*7596*/ uint16(xSetOp), uint16(CVTDQ2PD),
	/*7598*/ uint16(xReadSlashR),
	/*7599*/ uint16(xArgXmm1),
	/*7600*/ uint16(xArgXmm2M64),
	/*7601*/ uint16(xMatch),
	/*7602*/ uint16(xCondPrefix), 2,
	0x66, 7614,
	0x0, 7608,
	/*7608*/ uint16(xSetOp), uint16(MOVNTQ),
	/*7610*/ uint16(xReadSlashR),
	/*7611*/ uint16(xArgM64),
	/*7612*/ uint16(xArgMm),
	/*7613*/ uint16(xMatch),
	/*7614*/ uint16(xSetOp), uint16(MOVNTDQ),
	/*7616*/ uint16(xReadSlashR),
	/*7617*/ uint16(xArgM128),
	/*7618*/ uint16(xArgXmm),
	/*7619*/ uint16(xMatch),
	/*7620*/ uint16(xCondPrefix), 2,
	0x66, 7632,
	0x0, 7626,
	/*7626*/ uint16(xSetOp), uint16(PSUBSB),
	/*7628*/ uint16(xReadSlashR),
	/*7629*/ uint16(xArgMm),
	/*7630*/ uint16(xArgMmM64),
	/*7631*/ uint16(xMatch),
	/*7632*/ uint16(xSetOp), uint16(PSUBSB),
	/*7634*/ uint16(xReadSlashR),
	/*7635*/ uint16(xArgXmm1),
	/*7636*/ uint16(xArgXmm2M128),
	/*7637*/ uint16(xMatch),
	/*7638*/ uint16(xCondPrefix), 2,
	0x66, 7650,
	0x0, 7644,
	/*7644*/ uint16(xSetOp), uint16(PSUBSW),
	/*7646*/ uint16(xReadSlashR),
	/*7647*/ uint16(xArgMm),
	/*7648*/ uint16(xArgMmM64),
	/*7649*/ uint16(xMatch),
	/*7650*/ uint16(xSetOp), uint16(PSUBSW),
	/*7652*/ uint16(xReadSlashR),
	/*7653*/ uint16(xArgXmm1),
	/*7654*/ uint16(xArgXmm2M128),
	/*7655*/ uint16(xMatch),
	/*7656*/ uint16(xCondPrefix), 2,
	0x66, 7668,
	0x0, 7662,
	/*7662*/ uint16(xSetOp), uint16(PMINSW),
	/*7664*/ uint16(xReadSlashR),
	/*7665*/ uint16(xArgMm1),
	/*7666*/ uint16(xArgMm2M64),
	/*7667*/ uint16(xMatch),
	/*7668*/ uint16(xSetOp), uint16(PMINSW),
	/*7670*/ uint16(xReadSlashR),
	/*7671*/ uint16(xArgXmm1),
	/*7672*/ uint16(xArgXmm2M128),
	/*7673*/ uint16(xMatch),
	/*7674*/ uint16(xCondPrefix), 2,
	0x66, 7686,
	0x0, 7680,
	/*7680*/ uint16(xSetOp), uint16(POR),
	/*7682*/ uint16(xReadSlashR),
	/*7683*/ uint16(xArgMm),
	/*7684*/ uint16(xArgMmM64),
	/*7685*/ uint16(xMatch),
	/*7686*/ uint16(xSetOp), uint16(POR),
	/*7688*/ uint16(xReadSlashR),
	/*7689*/ uint16(xArgXmm1),
	/*7690*/ uint16(xArgXmm2M128),
	/*7691*/ uint16(xMatch),
	/*7692*/ uint16(xCondPrefix), 2,
	0x66, 7704,
	0x0, 7698,
	/*7698*/ uint16(xSetOp), uint16(PADDSB),
	/*7700*/ uint16(xReadSlashR),
	/*7701*/ uint16(xArgMm),
	/*7702*/ uint16(xArgMmM64),
	/*7703*/ uint16(xMatch),
	/*7704*/ uint16(xSetOp), uint16(PADDSB),
	/*7706*/ uint16(xReadSlashR),
	/*7707*/ uint16(xArgXmm1),
	/*7708*/ uint16(xArgXmm2M128),
	/*7709*/ uint16(xMatch),
	/*7710*/ uint16(xCondPrefix), 2,
	0x66, 7722,
	0x0, 7716,
	/*7716*/ uint16(xSetOp), uint16(PADDSW),
	/*7718*/ uint16(xReadSlashR),
	/*7719*/ uint16(xArgMm),
	/*7720*/ uint16(xArgMmM64),
	/*7721*/ uint16(xMatch),
	/*7722*/ uint16(xSetOp), uint16(PADDSW),
	/*7724*/ uint16(xReadSlashR),
	/*7725*/ uint16(xArgXmm1),
	/*7726*/ uint16(xArgXmm2M128),
	/*7727*/ uint16(xMatch),
	/*7728*/ uint16(xCondPrefix), 2,
	0x66, 7740,
	0x0, 7734,
	/*7734*/ uint16(xSetOp), uint16(PMAXSW),
	/*7736*/ uint16(xReadSlashR),
	/*7737*/ uint16(xArgMm1),
	/*7738*/ uint16(xArgMm2M64),
	/*7739*/ uint16(xMatch),
	/*7740*/ uint16(xSetOp), uint16(PMAXSW),
	/*7742*/ uint16(xReadSlashR),
	/*7743*/ uint16(xArgXmm1),
	/*7744*/ uint16(xArgXmm2M128),
	/*7745*/ uint16(xMatch),
	/*7746*/ uint16(xCondPrefix), 2,
	0x66, 7758,
	0x0, 7752,
	/*7752*/ uint16(xSetOp), uint16(PXOR),
	/*7754*/ uint16(xReadSlashR),
	/*7755*/ uint16(xArgMm),
	/*7756*/ uint16(xArgMmM64),
	/*7757*/ uint16(xMatch),
	/*7758*/ uint16(xSetOp), uint16(PXOR),
	/*7760*/ uint16(xReadSlashR),
	/*7761*/ uint16(xArgXmm1),
	/*7762*/ uint16(xArgXmm2M128),
	/*7763*/ uint16(xMatch),
	/*7764*/ uint16(xCondPrefix), 1,
	0xF2, 7768,
	/*7768*/ uint16(xSetOp), uint16(LDDQU),
	/*7770*/ uint16(xReadSlashR),
	/*7771*/ uint16(xArgXmm1),
	/*7772*/ uint16(xArgM128),
	/*7773*/ uint16(xMatch),
	/*7774*/ uint16(xCondPrefix), 2,
	0x66, 7786,
	0x0, 7780,
	/*7780*/ uint16(xSetOp), uint16(PSLLW),
	/*7782*/ uint16(xReadSlashR),
	/*7783*/ uint16(xArgMm),
	/*7784*/ uint16(xArgMmM64),
	/*7785*/ uint16(xMatch),
	/*7786*/ uint16(xSetOp), uint16(PSLLW),
	/*7788*/ uint16(xReadSlashR),
	/*7789*/ uint16(xArgXmm1),
	/*7790*/ uint16(xArgXmm2M128),
	/*7791*/ uint16(xMatch),
	/*7792*/ uint16(xCondPrefix), 2,
	0x66, 7804,
	0x0, 7798,
	/*7798*/ uint16(xSetOp), uint16(PSLLD),
	/*7800*/ uint16(xReadSlashR),
	/*7801*/ uint16(xArgMm),
	/*7802*/ uint16(xArgMmM64),
	/*7803*/ uint16(xMatch),
	/*7804*/ uint16(xSetOp), uint16(PSLLD),
	/*7806*/ uint16(xReadSlashR),
	/*7807*/ uint16(xArgXmm1),
	/*7808*/ uint16(xArgXmm2M128),
	/*7809*/ uint16(xMatch),
	/*7810*/ uint16(xCondPrefix), 2,
	0x66, 7822,
	0x0, 7816,
	/*7816*/ uint16(xSetOp), uint16(PSLLQ),
	/*7818*/ uint16(xReadSlashR),
	/*7819*/ uint16(xArgMm),
	/*7820*/ uint16(xArgMmM64),
	/*7821*/ uint16(xMatch),
	/*7822*/ uint16(xSetOp), uint16(PSLLQ),
	/*7824*/ uint16(xReadSlashR),
	/*7825*/ uint16(xArgXmm1),
	/*7826*/ uint16(xArgXmm2M128),
	/*7827*/ uint16(xMatch),
	/*7828*/ uint16(xCondPrefix), 2,
	0x66, 7840,
	0x0, 7834,
	/*7834*/ uint16(xSetOp), uint16(PMULUDQ),
	/*7836*/ uint16(xReadSlashR),
	/*7837*/ uint16(xArgMm1),
	/*7838*/ uint16(xArgMm2M64),
	/*7839*/ uint16(xMatch),
	/*7840*/ uint16(xSetOp), uint16(PMULUDQ),
	/*7842*/ uint16(xReadSlashR),
	/*7843*/ uint16(xArgXmm1),
	/*7844*/ uint16(xArgXmm2M128),
	/*7845*/ uint16(xMatch),
	/*7846*/ uint16(xCondPrefix), 2,
	0x66, 7858,
	0x0, 7852,
	/*7852*/ uint16(xSetOp), uint16(PMADDWD),
	/*7854*/ uint16(xReadSlashR),
	/*7855*/ uint16(xArgMm),
	/*7856*/ uint16(xArgMmM64),
	/*7857*/ uint16(xMatch),
	/*7858*/ uint16(xSetOp), uint16(PMADDWD),
	/*7860*/ uint16(xReadSlashR),
	/*7861*/ uint16(xArgXmm1),
	/*7862*/ uint16(xArgXmm2M128),
	/*7863*/ uint16(xMatch),
	/*7864*/ uint16(xCondPrefix), 2,
	0x66, 7876,
	0x0, 7870,
	/*7870*/ uint16(xSetOp), uint16(PSADBW),
	/*7872*/ uint16(xReadSlashR),
	/*7873*/ uint16(xArgMm1),
	/*7874*/ uint16(xArgMm2M64),
	/*7875*/ uint16(xMatch),
	/*7876*/ uint16(xSetOp), uint16(PSADBW),
	/*7878*/ uint16(xReadSlashR),
	/*7879*/ uint16(xArgXmm1),
	/*7880*/ uint16(xArgXmm2M128),
	/*7881*/ uint16(xMatch),
	/*7882*/ uint16(xCondPrefix), 2,
	0x66, 7894,
	0x0, 7888,
	/*7888*/ uint16(xSetOp), uint16(MASKMOVQ),
	/*7890*/ uint16(xReadSlashR),
	/*7891*/ uint16(xArgMm1),
	/*7892*/ uint16(xArgMm2),
	/*7893*/ uint16(xMatch),
	/*7894*/ uint16(xSetOp), uint16(MASKMOVDQU),
	/*7896*/ uint16(xReadSlashR),
	/*7897*/ uint16(xArgXmm1),
	/*7898*/ uint16(xArgXmm2),
	/*7899*/ uint16(xMatch),
	/*7900*/ uint16(xCondPrefix), 2,
	0x66, 7912,
	0x0, 7906,
	/*7906*/ uint16(xSetOp), uint16(PSUBB),
	/*7908*/ uint16(xReadSlashR),
	/*7909*/ uint16(xArgMm),
	/*7910*/ uint16(xArgMmM64),
	/*7911*/ uint16(xMatch),
	/*7912*/ uint16(xSetOp), uint16(PSUBB),
	/*7914*/ uint16(xReadSlashR),
	/*7915*/ uint16(xArgXmm1),
	/*7916*/ uint16(xArgXmm2M128),
	/*7917*/ uint16(xMatch),
	/*7918*/ uint16(xCondPrefix), 2,
	0x66, 7930,
	0x0, 7924,
	/*7924*/ uint16(xSetOp), uint16(PSUBW),
	/*7926*/ uint16(xReadSlashR),
	/*7927*/ uint16(xArgMm),
	/*7928*/ uint16(xArgMmM64),
	/*7929*/ uint16(xMatch),
	/*7930*/ uint16(xSetOp), uint16(PSUBW),
	/*7932*/ uint16(xReadSlashR),
	/*7933*/ uint16(xArgXmm1),
	/*7934*/ uint16(xArgXmm2M128),
	/*7935*/ uint16(xMatch),
	/*7936*/ uint16(xCondPrefix), 2,
	0x66, 7948,
	0x0, 7942,
	/*7942*/ uint16(xSetOp), uint16(PSUBD),
	/*7944*/ uint16(xReadSlashR),
	/*7945*/ uint16(xArgMm),
	/*7946*/ uint16(xArgMmM64),
	/*7947*/ uint16(xMatch),
	/*7948*/ uint16(xSetOp), uint16(PSUBD),
	/*7950*/ uint16(xReadSlashR),
	/*7951*/ uint16(xArgXmm1),
	/*7952*/ uint16(xArgXmm2M128),
	/*7953*/ uint16(xMatch),
	/*7954*/ uint16(xCondPrefix), 2,
	0x66, 7966,
	0x0, 7960,
	/*7960*/ uint16(xSetOp), uint16(PSUBQ),
	/*7962*/ uint16(xReadSlashR),
	/*7963*/ uint16(xArgMm1),
	/*7964*/ uint16(xArgMm2M64),
	/*7965*/ uint16(xMatch),
	/*7966*/ uint16(xSetOp), uint16(PSUBQ),
	/*7968*/ uint16(xReadSlashR),
	/*7969*/ uint16(xArgXmm1),
	/*7970*/ uint16(xArgXmm2M128),
	/*7971*/ uint16(xMatch),
	/*7972*/ uint16(xCondPrefix), 2,
	0x66, 7984,
	0x0, 7978,
	/*7978*/ uint16(xSetOp), uint16(PADDB),
	/*7980*/ uint16(xReadSlashR),
	/*7981*/ uint16(xArgMm),
	/*7982*/ uint16(xArgMmM64),
	/*7983*/ uint16(xMatch),
	/*7984*/ uint16(xSetOp), uint16(PADDB),
	/*7986*/ uint16(xReadSlashR),
	/*7987*/ uint16(xArgXmm1),
	/*7988*/ uint16(xArgXmm2M128),
	/*7989*/ uint16(xMatch),
	/*7990*/ uint16(xCondPrefix), 2,
	0x66, 8002,
	0x0, 7996,
	/*7996*/ uint16(xSetOp), uint16(PADDW),
	/*7998*/ uint16(xReadSlashR),
	/*7999*/ uint16(xArgMm),
	/*8000*/ uint16(xArgMmM64),
	/*8001*/ uint16(xMatch),
	/*8002*/ uint16(xSetOp), uint16(PADDW),
	/*8004*/ uint16(xReadSlashR),
	/*8005*/ uint16(xArgXmm1),
	/*8006*/ uint16(xArgXmm2M128),
	/*8007*/ uint16(xMatch),
	/*8008*/ uint16(xCondPrefix), 2,
	0x66, 8020,
	0x0, 8014,
	/*8014*/ uint16(xSetOp), uint16(PADDD),
	/*8016*/ uint16(xReadSlashR),
	/*8017*/ uint16(xArgMm),
	/*8018*/ uint16(xArgMmM64),
	/*8019*/ uint16(xMatch),
	/*8020*/ uint16(xSetOp), uint16(PADDD),
	/*8022*/ uint16(xReadSlashR),
	/*8023*/ uint16(xArgXmm1),
	/*8024*/ uint16(xArgXmm2M128),
	/*8025*/ uint16(xMatch),
	/*8026*/ uint16(xSetOp), uint16(ADC),
	/*8028*/ uint16(xReadSlashR),
	/*8029*/ uint16(xArgRM8),
	/*8030*/ uint16(xArgR8),
	/*8031*/ uint16(xMatch),
	/*8032*/ uint16(xCondIs64), 8035, 8051,
	/*8035*/ uint16(xCondDataSize), 8039, 8045, 0,
	/*8039*/ uint16(xSetOp), uint16(ADC),
	/*8041*/ uint16(xReadSlashR),
	/*8042*/ uint16(xArgRM16),
	/*8043*/ uint16(xArgR16),
	/*8044*/ uint16(xMatch),
	/*8045*/ uint16(xSetOp), uint16(ADC),
	/*8047*/ uint16(xReadSlashR),
	/*8048*/ uint16(xArgRM32),
	/*8049*/ uint16(xArgR32),
	/*8050*/ uint16(xMatch),
	/*8051*/ uint16(xCondDataSize), 8039, 8045, 8055,
	/*8055*/ uint16(xSetOp), uint16(ADC),
	/*8057*/ uint16(xReadSlashR),
	/*8058*/ uint16(xArgRM64),
	/*8059*/ uint16(xArgR64),
	/*8060*/ uint16(xMatch),
	/*8061*/ uint16(xSetOp), uint16(ADC),
	/*8063*/ uint16(xReadSlashR),
	/*8064*/ uint16(xArgR8),
	/*8065*/ uint16(xArgRM8),
	/*8066*/ uint16(xMatch),
	/*8067*/ uint16(xCondIs64), 8070, 8086,
	/*8070*/ uint16(xCondDataSize), 8074, 8080, 0,
	/*8074*/ uint16(xSetOp), uint16(ADC),
	/*8076*/ uint16(xReadSlashR),
	/*8077*/ uint16(xArgR16),
	/*8078*/ uint16(xArgRM16),
	/*8079*/ uint16(xMatch),
	/*8080*/ uint16(xSetOp), uint16(ADC),
	/*8082*/ uint16(xReadSlashR),
	/*8083*/ uint16(xArgR32),
	/*8084*/ uint16(xArgRM32),
	/*8085*/ uint16(xMatch),
	/*8086*/ uint16(xCondDataSize), 8074, 8080, 8090,
	/*8090*/ uint16(xSetOp), uint16(ADC),
	/*8092*/ uint16(xReadSlashR),
	/*8093*/ uint16(xArgR64),
	/*8094*/ uint16(xArgRM64),
	/*8095*/ uint16(xMatch),
	/*8096*/ uint16(xSetOp), uint16(ADC),
	/*8098*/ uint16(xReadIb),
	/*8099*/ uint16(xArgAL),
	/*8100*/ uint16(xArgImm8u),
	/*8101*/ uint16(xMatch),
	/*8102*/ uint16(xCondIs64), 8105, 8121,
	/*8105*/ uint16(xCondDataSize), 8109, 8115, 0,
	/*8109*/ uint16(xSetOp), uint16(ADC),
	/*8111*/ uint16(xReadIw),
	/*8112*/ uint16(xArgAX),
	/*8113*/ uint16(xArgImm16),
	/*8114*/ uint16(xMatch),
	/*8115*/ uint16(xSetOp), uint16(ADC),
	/*8117*/ uint16(xReadId),
	/*8118*/ uint16(xArgEAX),
	/*8119*/ uint16(xArgImm32),
	/*8120*/ uint16(xMatch),
	/*8121*/ uint16(xCondDataSize), 8109, 8115, 8125,
	/*8125*/ uint16(xSetOp), uint16(ADC),
	/*8127*/ uint16(xReadId),
	/*8128*/ uint16(xArgRAX),
	/*8129*/ uint16(xArgImm32),
	/*8130*/ uint16(xMatch),
	/*8131*/ uint16(xCondIs64), 8134, 0,
	/*8134*/ uint16(xSetOp), uint16(PUSH),
	/*8136*/ uint16(xArgSS),
	/*8137*/ uint16(xMatch),
	/*8138*/ uint16(xCondIs64), 8141, 0,
	/*8141*/ uint16(xSetOp), uint16(POP),
	/*8143*/ uint16(xArgSS),
	/*8144*/ uint16(xMatch),
	/*8145*/ uint16(xSetOp), uint16(SBB),
	/*8147*/ uint16(xReadSlashR),
	/*8148*/ uint16(xArgRM8),
	/*8149*/ uint16(xArgR8),
	/*8150*/ uint16(xMatch),
	/*8151*/ uint16(xCondIs64), 8154, 8170,
	/*8154*/ uint16(xCondDataSize), 8158, 8164, 0,
	/*8158*/ uint16(xSetOp), uint16(SBB),
	/*8160*/ uint16(xReadSlashR),
	/*8161*/ uint16(xArgRM16),
	/*8162*/ uint16(xArgR16),
	/*8163*/ uint16(xMatch),
	/*8164*/ uint16(xSetOp), uint16(SBB),
	/*8166*/ uint16(xReadSlashR),
	/*8167*/ uint16(xArgRM32),
	/*8168*/ uint16(xArgR32),
	/*8169*/ uint16(xMatch),
	/*8170*/ uint16(xCondDataSize), 8158, 8164, 8174,
	/*8174*/ uint16(xSetOp), uint16(SBB),
	/*8176*/ uint16(xReadSlashR),
	/*8177*/ uint16(xArgRM64),
	/*8178*/ uint16(xArgR64),
	/*8179*/ uint16(xMatch),
	/*8180*/ uint16(xSetOp), uint16(SBB),
	/*8182*/ uint16(xReadSlashR),
	/*8183*/ uint16(xArgR8),
	/*8184*/ uint16(xArgRM8),
	/*8185*/ uint16(xMatch),
	/*8186*/ uint16(xCondIs64), 8189, 8205,
	/*8189*/ uint16(xCondDataSize), 8193, 8199, 0,
	/*8193*/ uint16(xSetOp), uint16(SBB),
	/*8195*/ uint16(xReadSlashR),
	/*8196*/ uint16(xArgR16),
	/*8197*/ uint16(xArgRM16),
	/*8198*/ uint16(xMatch),
	/*8199*/ uint16(xSetOp), uint16(SBB),
	/*8201*/ uint16(xReadSlashR),
	/*8202*/ uint16(xArgR32),
	/*8203*/ uint16(xArgRM32),
	/*8204*/ uint16(xMatch),
	/*8205*/ uint16(xCondDataSize), 8193, 8199, 8209,
	/*8209*/ uint16(xSetOp), uint16(SBB),
	/*8211*/ uint16(xReadSlashR),
	/*8212*/ uint16(xArgR64),
	/*8213*/ uint16(xArgRM64),
	/*8214*/ uint16(xMatch),
	/*8215*/ uint16(xSetOp), uint16(SBB),
	/*8217*/ uint16(xReadIb),
	/*8218*/ uint16(xArgAL),
	/*8219*/ uint16(xArgImm8u),
	/*8220*/ uint16(xMatch),
	/*8221*/ uint16(xCondIs64), 8224, 8240,
	/*8224*/ uint16(xCondDataSize), 8228, 8234, 0,
	/*8228*/ uint16(xSetOp), uint16(SBB),
	/*8230*/ uint16(xReadIw),
	/*8231*/ uint16(xArgAX),
	/*8232*/ uint16(xArgImm16),
	/*8233*/ uint16(xMatch),
	/*8234*/ uint16(xSetOp), uint16(SBB),
	/*8236*/ uint16(xReadId),
	/*8237*/ uint16(xArgEAX),
	/*8238*/ uint16(xArgImm32),
	/*8239*/ uint16(xMatch),
	/*8240*/ uint16(xCondDataSize), 8228, 8234, 8244,
	/*8244*/ uint16(xSetOp), uint16(SBB),
	/*8246*/ uint16(xReadId),
	/*8247*/ uint16(xArgRAX),
	/*8248*/ uint16(xArgImm32),
	/*8249*/ uint16(xMatch),
	/*8250*/ uint16(xCondIs64), 8253, 0,
	/*8253*/ uint16(xSetOp), uint16(PUSH),
	/*8255*/ uint16(xArgDS),
	/*8256*/ uint16(xMatch),
	/*8257*/ uint16(xCondIs64), 8260, 0,
	/*8260*/ uint16(xSetOp), uint16(POP),
	/*8262*/ uint16(xArgDS),
	/*8263*/ uint16(xMatch),
	/*8264*/ uint16(xSetOp), uint16(AND),
	/*8266*/ uint16(xReadSlashR),
	/*8267*/ uint16(xArgRM8),
	/*8268*/ uint16(xArgR8),
	/*8269*/ uint16(xMatch),
	/*8270*/ uint16(xCondIs64), 8273, 8289,
	/*8273*/ uint16(xCondDataSize), 8277, 8283, 0,
	/*8277*/ uint16(xSetOp), uint16(AND),
	/*8279*/ uint16(xReadSlashR),
	/*8280*/ uint16(xArgRM16),
	/*8281*/ uint16(xArgR16),
	/*8282*/ uint16(xMatch),
	/*8283*/ uint16(xSetOp), uint16(AND),
	/*8285*/ uint16(xReadSlashR),
	/*8286*/ uint16(xArgRM32),
	/*8287*/ uint16(xArgR32),
	/*8288*/ uint16(xMatch),
	/*8289*/ uint16(xCondDataSize), 8277, 8283, 8293,
	/*8293*/ uint16(xSetOp), uint16(AND),
	/*8295*/ uint16(xReadSlashR),
	/*8296*/ uint16(xArgRM64),
	/*8297*/ uint16(xArgR64),
	/*8298*/ uint16(xMatch),
	/*8299*/ uint16(xSetOp), uint16(AND),
	/*8301*/ uint16(xReadSlashR),
	/*8302*/ uint16(xArgR8),
	/*8303*/ uint16(xArgRM8),
	/*8304*/ uint16(xMatch),
	/*8305*/ uint16(xCondIs64), 8308, 8324,
	/*8308*/ uint16(xCondDataSize), 8312, 8318, 0,
	/*8312*/ uint16(xSetOp), uint16(AND),
	/*8314*/ uint16(xReadSlashR),
	/*8315*/ uint16(xArgR16),
	/*8316*/ uint16(xArgRM16),
	/*8317*/ uint16(xMatch),
	/*8318*/ uint16(xSetOp), uint16(AND),
	/*8320*/ uint16(xReadSlashR),
	/*8321*/ uint16(xArgR32),
	/*8322*/ uint16(xArgRM32),
	/*8323*/ uint16(xMatch),
	/*8324*/ uint16(xCondDataSize), 8312, 8318, 8328,
	/*8328*/ uint16(xSetOp), uint16(AND),
	/*8330*/ uint16(xReadSlashR),
	/*8331*/ uint16(xArgR64),
	/*8332*/ uint16(xArgRM64),
	/*8333*/ uint16(xMatch),
	/*8334*/ uint16(xSetOp), uint16(AND),
	/*8336*/ uint16(xReadIb),
	/*8337*/ uint16(xArgAL),
	/*8338*/ uint16(xArgImm8u),
	/*8339*/ uint16(xMatch),
	/*8340*/ uint16(xCondIs64), 8343, 8359,
	/*8343*/ uint16(xCondDataSize), 8347, 8353, 0,
	/*8347*/ uint16(xSetOp), uint16(AND),
	/*8349*/ uint16(xReadIw),
	/*8350*/ uint16(xArgAX),
	/*8351*/ uint16(xArgImm16),
	/*8352*/ uint16(xMatch),
	/*8353*/ uint16(xSetOp), uint16(AND),
	/*8355*/ uint16(xReadId),
	/*8356*/ uint16(xArgEAX),
	/*8357*/ uint16(xArgImm32),
	/*8358*/ uint16(xMatch),
	/*8359*/ uint16(xCondDataSize), 8347, 8353, 8363,
	/*8363*/ uint16(xSetOp), uint16(AND),
	/*8365*/ uint16(xReadId),
	/*8366*/ uint16(xArgRAX),
	/*8367*/ uint16(xArgImm32),
	/*8368*/ uint16(xMatch),
	/*8369*/ uint16(xCondIs64), 8372, 0,
	/*8372*/ uint16(xSetOp), uint16(DAA),
	/*8374*/ uint16(xMatch),
	/*8375*/ uint16(xSetOp), uint16(SUB),
	/*8377*/ uint16(xReadSlashR),
	/*8378*/ uint16(xArgRM8),
	/*8379*/ uint16(xArgR8),
	/*8380*/ uint16(xMatch),
	/*8381*/ uint16(xCondIs64), 8384, 8400,
	/*8384*/ uint16(xCondDataSize), 8388, 8394, 0,
	/*8388*/ uint16(xSetOp), uint16(SUB),
	/*8390*/ uint16(xReadSlashR),
	/*8391*/ uint16(xArgRM16),
	/*8392*/ uint16(xArgR16),
	/*8393*/ uint16(xMatch),
	/*8394*/ uint16(xSetOp), uint16(SUB),
	/*8396*/ uint16(xReadSlashR),
	/*8397*/ uint16(xArgRM32),
	/*8398*/ uint16(xArgR32),
	/*8399*/ uint16(xMatch),
	/*8400*/ uint16(xCondDataSize), 8388, 8394, 8404,
	/*8404*/ uint16(xSetOp), uint16(SUB),
	/*8406*/ uint16(xReadSlashR),
	/*8407*/ uint16(xArgRM64),
	/*8408*/ uint16(xArgR64),
	/*8409*/ uint16(xMatch),
	/*8410*/ uint16(xSetOp), uint16(SUB),
	/*8412*/ uint16(xReadSlashR),
	/*8413*/ uint16(xArgR8),
	/*8414*/ uint16(xArgRM8),
	/*8415*/ uint16(xMatch),
	/*8416*/ uint16(xCondIs64), 8419, 8435,
	/*8419*/ uint16(xCondDataSize), 8423, 8429, 0,
	/*8423*/ uint16(xSetOp), uint16(SUB),
	/*8425*/ uint16(xReadSlashR),
	/*8426*/ uint16(xArgR16),
	/*8427*/ uint16(xArgRM16),
	/*8428*/ uint16(xMatch),
	/*8429*/ uint16(xSetOp), uint16(SUB),
	/*8431*/ uint16(xReadSlashR),
	/*8432*/ uint16(xArgR32),
	/*8433*/ uint16(xArgRM32),
	/*8434*/ uint16(xMatch),
	/*8435*/ uint16(xCondDataSize), 8423, 8429, 8439,
	/*8439*/ uint16(xSetOp), uint16(SUB),
	/*8441*/ uint16(xReadSlashR),
	/*8442*/ uint16(xArgR64),
	/*8443*/ uint16(xArgRM64),
	/*8444*/ uint16(xMatch),
	/*8445*/ uint16(xSetOp), uint16(SUB),
	/*8447*/ uint16(xReadIb),
	/*8448*/ uint16(xArgAL),
	/*8449*/ uint16(xArgImm8u),
	/*8450*/ uint16(xMatch),
	/*8451*/ uint16(xCondIs64), 8454, 8470,
	/*8454*/ uint16(xCondDataSize), 8458, 8464, 0,
	/*8458*/ uint16(xSetOp), uint16(SUB),
	/*8460*/ uint16(xReadIw),
	/*8461*/ uint16(xArgAX),
	/*8462*/ uint16(xArgImm16),
	/*8463*/ uint16(xMatch),
	/*8464*/ uint16(xSetOp), uint16(SUB),
	/*8466*/ uint16(xReadId),
	/*8467*/ uint16(xArgEAX),
	/*8468*/ uint16(xArgImm32),
	/*8469*/ uint16(xMatch),
	/*8470*/ uint16(xCondDataSize), 8458, 8464, 8474,
	/*8474*/ uint16(xSetOp), uint16(SUB),
	/*8476*/ uint16(xReadId),
	/*8477*/ uint16(xArgRAX),
	/*8478*/ uint16(xArgImm32),
	/*8479*/ uint16(xMatch),
	/*8480*/ uint16(xCondIs64), 8483, 0,
	/*8483*/ uint16(xSetOp), uint16(DAS),
	/*8485*/ uint16(xMatch),
	/*8486*/ uint16(xSetOp), uint16(XOR),
	/*8488*/ uint16(xReadSlashR),
	/*8489*/ uint16(xArgRM8),
	/*8490*/ uint16(xArgR8),
	/*8491*/ uint16(xMatch),
	/*8492*/ uint16(xCondIs64), 8495, 8511,
	/*8495*/ uint16(xCondDataSize), 8499, 8505, 0,
	/*8499*/ uint16(xSetOp), uint16(XOR),
	/*8501*/ uint16(xReadSlashR),
	/*8502*/ uint16(xArgRM16),
	/*8503*/ uint16(xArgR16),
	/*8504*/ uint16(xMatch),
	/*8505*/ uint16(xSetOp), uint16(XOR),
	/*8507*/ uint16(xReadSlashR),
	/*8508*/ uint16(xArgRM32),
	/*8509*/ uint16(xArgR32),
	/*8510*/ uint16(xMatch),
	/*8511*/ uint16(xCondDataSize), 8499, 8505, 8515,
	/*8515*/ uint16(xSetOp), uint16(XOR),
	/*8517*/ uint16(xReadSlashR),
	/*8518*/ uint16(xArgRM64),
	/*8519*/ uint16(xArgR64),
	/*8520*/ uint16(xMatch),
	/*8521*/ uint16(xSetOp), uint16(XOR),
	/*8523*/ uint16(xReadSlashR),
	/*8524*/ uint16(xArgR8),
	/*8525*/ uint16(xArgRM8),
	/*8526*/ uint16(xMatch),
	/*8527*/ uint16(xCondIs64), 8530, 8546,
	/*8530*/ uint16(xCondDataSize), 8534, 8540, 0,
	/*8534*/ uint16(xSetOp), uint16(XOR),
	/*8536*/ uint16(xReadSlashR),
	/*8537*/ uint16(xArgR16),
	/*8538*/ uint16(xArgRM16),
	/*8539*/ uint16(xMatch),
	/*8540*/ uint16(xSetOp), uint16(XOR),
	/*8542*/ uint16(xReadSlashR),
	/*8543*/ uint16(xArgR32),
	/*8544*/ uint16(xArgRM32),
	/*8545*/ uint16(xMatch),
	/*8546*/ uint16(xCondDataSize), 8534, 8540, 8550,
	/*8550*/ uint16(xSetOp), uint16(XOR),
	/*8552*/ uint16(xReadSlashR),
	/*8553*/ uint16(xArgR64),
	/*8554*/ uint16(xArgRM64),
	/*8555*/ uint16(xMatch),
	/*8556*/ uint16(xSetOp), uint16(XOR),
	/*8558*/ uint16(xReadIb),
	/*8559*/ uint16(xArgAL),
	/*8560*/ uint16(xArgImm8u),
	/*8561*/ uint16(xMatch),
	/*8562*/ uint16(xCondIs64), 8565, 8581,
	/*8565*/ uint16(xCondDataSize), 8569, 8575, 0,
	/*8569*/ uint16(xSetOp), uint16(XOR),
	/*8571*/ uint16(xReadIw),
	/*8572*/ uint16(xArgAX),
	/*8573*/ uint16(xArgImm16),
	/*8574*/ uint16(xMatch),
	/*8575*/ uint16(xSetOp), uint16(XOR),
	/*8577*/ uint16(xReadId),
	/*8578*/ uint16(xArgEAX),
	/*8579*/ uint16(xArgImm32),
	/*8580*/ uint16(xMatch),
	/*8581*/ uint16(xCondDataSize), 8569, 8575, 8585,
	/*8585*/ uint16(xSetOp), uint16(XOR),
	/*8587*/ uint16(xReadId),
	/*8588*/ uint16(xArgRAX),
	/*8589*/ uint16(xArgImm32),
	/*8590*/ uint16(xMatch),
	/*8591*/ uint16(xCondIs64), 8594, 0,
	/*8594*/ uint16(xSetOp), uint16(AAA),
	/*8596*/ uint16(xMatch),
	/*8597*/ uint16(xSetOp), uint16(CMP),
	/*8599*/ uint16(xReadSlashR),
	/*8600*/ uint16(xArgRM8),
	/*8601*/ uint16(xArgR8),
	/*8602*/ uint16(xMatch),
	/*8603*/ uint16(xCondIs64), 8606, 8622,
	/*8606*/ uint16(xCondDataSize), 8610, 8616, 0,
	/*8610*/ uint16(xSetOp), uint16(CMP),
	/*8612*/ uint16(xReadSlashR),
	/*8613*/ uint16(xArgRM16),
	/*8614*/ uint16(xArgR16),
	/*8615*/ uint16(xMatch),
	/*8616*/ uint16(xSetOp), uint16(CMP),
	/*8618*/ uint16(xReadSlashR),
	/*8619*/ uint16(xArgRM32),
	/*8620*/ uint16(xArgR32),
	/*8621*/ uint16(xMatch),
	/*8622*/ uint16(xCondDataSize), 8610, 8616, 8626,
	/*8626*/ uint16(xSetOp), uint16(CMP),
	/*8628*/ uint16(xReadSlashR),
	/*8629*/ uint16(xArgRM64),
	/*8630*/ uint16(xArgR64),
	/*8631*/ uint16(xMatch),
	/*8632*/ uint16(xSetOp), uint16(CMP),
	/*8634*/ uint16(xReadSlashR),
	/*8635*/ uint16(xArgR8),
	/*8636*/ uint16(xArgRM8),
	/*8637*/ uint16(xMatch),
	/*8638*/ uint16(xCondIs64), 8641, 8657,
	/*8641*/ uint16(xCondDataSize), 8645, 8651, 0,
	/*8645*/ uint16(xSetOp), uint16(CMP),
	/*8647*/ uint16(xReadSlashR),
	/*8648*/ uint16(xArgR16),
	/*8649*/ uint16(xArgRM16),
	/*8650*/ uint16(xMatch),
	/*8651*/ uint16(xSetOp), uint16(CMP),
	/*8653*/ uint16(xReadSlashR),
	/*8654*/ uint16(xArgR32),
	/*8655*/ uint16(xArgRM32),
	/*8656*/ uint16(xMatch),
	/*8657*/ uint16(xCondDataSize), 8645, 8651, 8661,
	/*8661*/ uint16(xSetOp), uint16(CMP),
	/*8663*/ uint16(xReadSlashR),
	/*8664*/ uint16(xArgR64),
	/*8665*/ uint16(xArgRM64),
	/*8666*/ uint16(xMatch),
	/*8667*/ uint16(xSetOp), uint16(CMP),
	/*8669*/ uint16(xReadIb),
	/*8670*/ uint16(xArgAL),
	/*8671*/ uint16(xArgImm8u),
	/*8672*/ uint16(xMatch),
	/*8673*/ uint16(xCondIs64), 8676, 8692,
	/*8676*/ uint16(xCondDataSize), 8680, 8686, 0,
	/*8680*/ uint16(xSetOp), uint16(CMP),
	/*8682*/ uint16(xReadIw),
	/*8683*/ uint16(xArgAX),
	/*8684*/ uint16(xArgImm16),
	/*8685*/ uint16(xMatch),
	/*8686*/ uint16(xSetOp), uint16(CMP),
	/*8688*/ uint16(xReadId),
	/*8689*/ uint16(xArgEAX),
	/*8690*/ uint16(xArgImm32),
	/*8691*/ uint16(xMatch),
	/*8692*/ uint16(xCondDataSize), 8680, 8686, 8696,
	/*8696*/ uint16(xSetOp), uint16(CMP),
	/*8698*/ uint16(xReadId),
	/*8699*/ uint16(xArgRAX),
	/*8700*/ uint16(xArgImm32),
	/*8701*/ uint16(xMatch),
	/*8702*/ uint16(xCondIs64), 8705, 0,
	/*8705*/ uint16(xSetOp), uint16(AAS),
	/*8707*/ uint16(xMatch),
	/*8708*/ uint16(xCondIs64), 8711, 0,
	/*8711*/ uint16(xCondDataSize), 8715, 8719, 0,
	/*8715*/ uint16(xSetOp), uint16(INC),
	/*8717*/ uint16(xArgR16op),
	/*8718*/ uint16(xMatch),
	/*8719*/ uint16(xSetOp), uint16(INC),
	/*8721*/ uint16(xArgR32op),
	/*8722*/ uint16(xMatch),
	/*8723*/ uint16(xCondIs64), 8726, 0,
	/*8726*/ uint16(xCondDataSize), 8730, 8734, 0,
	/*8730*/ uint16(xSetOp), uint16(DEC),
	/*8732*/ uint16(xArgR16op),
	/*8733*/ uint16(xMatch),
	/*8734*/ uint16(xSetOp), uint16(DEC),
	/*8736*/ uint16(xArgR32op),
	/*8737*/ uint16(xMatch),
	/*8738*/ uint16(xCondIs64), 8741, 8753,
	/*8741*/ uint16(xCondDataSize), 8745, 8749, 0,
	/*8745*/ uint16(xSetOp), uint16(PUSH),
	/*8747*/ uint16(xArgR16op),
	/*8748*/ uint16(xMatch),
	/*8749*/ uint16(xSetOp), uint16(PUSH),
	/*8751*/ uint16(xArgR32op),
	/*8752*/ uint16(xMatch),
	/*8753*/ uint16(xCondDataSize), 8745, 8757, 8761,
	/*8757*/ uint16(xSetOp), uint16(PUSH),
	/*8759*/ uint16(xArgR64op),
	/*8760*/ uint16(xMatch),
	/*8761*/ uint16(xSetOp), uint16(PUSH),
	/*8763*/ uint16(xArgR64op),
	/*8764*/ uint16(xMatch),
	/*8765*/ uint16(xCondIs64), 8768, 8780,
	/*8768*/ uint16(xCondDataSize), 8772, 8776, 0,
	/*8772*/ uint16(xSetOp), uint16(POP),
	/*8774*/ uint16(xArgR16op),
	/*8775*/ uint16(xMatch),
	/*8776*/ uint16(xSetOp), uint16(POP),
	/*8778*/ uint16(xArgR32op),
	/*8779*/ uint16(xMatch),
	/*8780*/ uint16(xCondDataSize), 8772, 8784, 8788,
	/*8784*/ uint16(xSetOp), uint16(POP),
	/*8786*/ uint16(xArgR64op),
	/*8787*/ uint16(xMatch),
	/*8788*/ uint16(xSetOp), uint16(POP),
	/*8790*/ uint16(xArgR64op),
	/*8791*/ uint16(xMatch),
	/*8792*/ uint16(xCondIs64), 8795, 0,
	/*8795*/ uint16(xCondDataSize), 8799, 8802, 0,
	/*8799*/ uint16(xSetOp), uint16(PUSHA),
	/*8801*/ uint16(xMatch),
	/*8802*/ uint16(xSetOp), uint16(PUSHAD),
	/*8804*/ uint16(xMatch),
	/*8805*/ uint16(xCondIs64), 8808, 0,
	/*8808*/ uint16(xCondDataSize), 8812, 8815, 0,
	/*8812*/ uint16(xSetOp), uint16(POPA),
	/*8814*/ uint16(xMatch),
	/*8815*/ uint16(xSetOp), uint16(POPAD),
	/*8817*/ uint16(xMatch),
	/*8818*/ uint16(xCondIs64), 8821, 0,
	/*8821*/ uint16(xCondDataSize), 8825, 8831, 0,
	/*8825*/ uint16(xSetOp), uint16(BOUND),
	/*8827*/ uint16(xReadSlashR),
	/*8828*/ uint16(xArgR16),
	/*8829*/ uint16(xArgM16and16),
	/*8830*/ uint16(xMatch),
	/*8831*/ uint16(xSetOp), uint16(BOUND),
	/*8833*/ uint16(xReadSlashR),
	/*8834*/ uint16(xArgR32),
	/*8835*/ uint16(xArgM32and32),
	/*8836*/ uint16(xMatch),
	/*8837*/ uint16(xCondIs64), 8840, 8846,
	/*8840*/ uint16(xSetOp), uint16(ARPL),
	/*8842*/ uint16(xReadSlashR),
	/*8843*/ uint16(xArgRM16),
	/*8844*/ uint16(xArgR16),
	/*8845*/ uint16(xMatch),
	/*8846*/ uint16(xCondDataSize), 8850, 8856, 8862,
	/*8850*/ uint16(xSetOp), uint16(MOVSXD),
	/*8852*/ uint16(xReadSlashR),
	/*8853*/ uint16(xArgR16),
	/*8854*/ uint16(xArgRM32),
	/*8855*/ uint16(xMatch),
	/*8856*/ uint16(xSetOp), uint16(MOVSXD),
	/*8858*/ uint16(xReadSlashR),
	/*8859*/ uint16(xArgR32),
	/*8860*/ uint16(xArgRM32),
	/*8861*/ uint16(xMatch),
	/*8862*/ uint16(xSetOp), uint16(MOVSXD),
	/*8864*/ uint16(xReadSlashR),
	/*8865*/ uint16(xArgR64),
	/*8866*/ uint16(xArgRM32),
	/*8867*/ uint16(xMatch),
	/*8868*/ uint16(xCondDataSize), 8872, 8877, 8882,
	/*8872*/ uint16(xSetOp), uint16(PUSH),
	/*8874*/ uint16(xReadIw),
	/*8875*/ uint16(xArgImm16),
	/*8876*/ uint16(xMatch),
	/*8877*/ uint16(xSetOp), uint16(PUSH),
	/*8879*/ uint16(xReadId),
	/*8880*/ uint16(xArgImm32),
	/*8881*/ uint16(xMatch),
	/*8882*/ uint16(xSetOp), uint16(PUSH),
	/*8884*/ uint16(xReadId),
	/*8885*/ uint16(xArgImm32),
	/*8886*/ uint16(xMatch),
	/*8887*/ uint16(xCondIs64), 8890, 8910,
	/*8890*/ uint16(xCondDataSize), 8894, 8902, 0,
	/*8894*/ uint16(xSetOp), uint16(IMUL),
	/*8896*/ uint16(xReadSlashR),
	/*8897*/ uint16(xReadIw),
	/*8898*/ uint16(xArgR16),
	/*8899*/ uint16(xArgRM16),
	/*8900*/ uint16(xArgImm16),
	/*8901*/ uint16(xMatch),
	/*8902*/ uint16(xSetOp), uint16(IMUL),
	/*8904*/ uint16(xReadSlashR),
	/*8905*/ uint16(xReadId),
	/*8906*/ uint16(xArgR32),
	/*8907*/ uint16(xArgRM32),
	/*8908*/ uint16(xArgImm32),
	/*8909*/ uint16(xMatch),
	/*8910*/ uint16(xCondDataSize), 8894, 8902, 8914,
	/*8914*/ uint16(xSetOp), uint16(IMUL),
	/*8916*/ uint16(xReadSlashR),
	/*8917*/ uint16(xReadId),
	/*8918*/ uint16(xArgR64),
	/*8919*/ uint16(xArgRM64),
	/*8920*/ uint16(xArgImm32),
	/*8921*/ uint16(xMatch),
	/*8922*/ uint16(xSetOp), uint16(PUSH),
	/*8924*/ uint16(xReadIb),
	/*8925*/ uint16(xArgImm8),
	/*8926*/ uint16(xMatch),
	/*8927*/ uint16(xCondIs64), 8930, 8950,
	/*8930*/ uint16(xCondDataSize), 8934, 8942, 0,
	/*8934*/ uint16(xSetOp), uint16(IMUL),
	/*8936*/ uint16(xReadSlashR),
	/*8937*/ uint16(xReadIb),
	/*8938*/ uint16(xArgR16),
	/*8939*/ uint16(xArgRM16),
	/*8940*/ uint16(xArgImm8),
	/*8941*/ uint16(xMatch),
	/*8942*/ uint16(xSetOp), uint16(IMUL),
	/*8944*/ uint16(xReadSlashR),
	/*8945*/ uint16(xReadIb),
	/*8946*/ uint16(xArgR32),
	/*8947*/ uint16(xArgRM32),
	/*8948*/ uint16(xArgImm8),
	/*8949*/ uint16(xMatch),
	/*8950*/ uint16(xCondDataSize), 8934, 8942, 8954,
	/*8954*/ uint16(xSetOp), uint16(IMUL),
	/*8956*/ uint16(xReadSlashR),
	/*8957*/ uint16(xReadIb),
	/*8958*/ uint16(xArgR64),
	/*8959*/ uint16(xArgRM64),
	/*8960*/ uint16(xArgImm8),
	/*8961*/ uint16(xMatch),
	/*8962*/ uint16(xSetOp), uint16(INSB),
	/*8964*/ uint16(xMatch),
	/*8965*/ uint16(xCondDataSize), 8969, 8972, 8975,
	/*8969*/ uint16(xSetOp), uint16(INSW),
	/*8971*/ uint16(xMatch),
	/*8972*/ uint16(xSetOp), uint16(INSD),
	/*8974*/ uint16(xMatch),
	/*8975*/ uint16(xSetOp), uint16(INSD),
	/*8977*/ uint16(xMatch),
	/*8978*/ uint16(xSetOp), uint16(OUTSB),
	/*8980*/ uint16(xMatch),
	/*8981*/ uint16(xCondDataSize), 8985, 8988, 8991,
	/*8985*/ uint16(xSetOp), uint16(OUTSW),
	/*8987*/ uint16(xMatch),
	/*8988*/ uint16(xSetOp), uint16(OUTSD),
	/*8990*/ uint16(xMatch),
	/*8991*/ uint16(xSetOp), uint16(OUTSD),
	/*8993*/ uint16(xMatch),
	/*8994*/ uint16(xSetOp), uint16(JO),
	/*8996*/ uint16(xReadCb),
	/*8997*/ uint16(xArgRel8),
	/*8998*/ uint16(xMatch),
	/*8999*/ uint16(xSetOp), uint16(JNO),
	/*9001*/ uint16(xReadCb),
	/*9002*/ uint16(xArgRel8),
	/*9003*/ uint16(xMatch),
	/*9004*/ uint16(xSetOp), uint16(JB),
	/*9006*/ uint16(xReadCb),
	/*9007*/ uint16(xArgRel8),
	/*9008*/ uint16(xMatch),
	/*9009*/ uint16(xSetOp), uint16(JAE),
	/*9011*/ uint16(xReadCb),
	/*9012*/ uint16(xArgRel8),
	/*9013*/ uint16(xMatch),
	/*9014*/ uint16(xSetOp), uint16(JE),
	/*9016*/ uint16(xReadCb),
	/*9017*/ uint16(xArgRel8),
	/*9018*/ uint16(xMatch),
	/*9019*/ uint16(xSetOp), uint16(JNE),
	/*9021*/ uint16(xReadCb),
	/*9022*/ uint16(xArgRel8),
	/*9023*/ uint16(xMatch),
	/*9024*/ uint16(xSetOp), uint16(JBE),
	/*9026*/ uint16(xReadCb),
	/*9027*/ uint16(xArgRel8),
	/*9028*/ uint16(xMatch),
	/*9029*/ uint16(xSetOp), uint16(JA),
	/*9031*/ uint16(xReadCb),
	/*9032*/ uint16(xArgRel8),
	/*9033*/ uint16(xMatch),
	/*9034*/ uint16(xSetOp), uint16(JS),
	/*9036*/ uint16(xReadCb),
	/*9037*/ uint16(xArgRel8),
	/*9038*/ uint16(xMatch),
	/*9039*/ uint16(xSetOp), uint16(JNS),
	/*9041*/ uint16(xReadCb),
	/*9042*/ uint16(xArgRel8),
	/*9043*/ uint16(xMatch),
	/*9044*/ uint16(xSetOp), uint16(JP),
	/*9046*/ uint16(xReadCb),
	/*9047*/ uint16(xArgRel8),
	/*9048*/ uint16(xMatch),
	/*9049*/ uint16(xSetOp), uint16(JNP),
	/*9051*/ uint16(xReadCb),
	/*9052*/ uint16(xArgRel8),
	/*9053*/ uint16(xMatch),
	/*9054*/ uint16(xSetOp), uint16(JL),
	/*9056*/ uint16(xReadCb),
	/*9057*/ uint16(xArgRel8),
	/*9058*/ uint16(xMatch),
	/*9059*/ uint16(xSetOp), uint16(JGE),
	/*9061*/ uint16(xReadCb),
	/*9062*/ uint16(xArgRel8),
	/*9063*/ uint16(xMatch),
	/*9064*/ uint16(xSetOp), uint16(JLE),
	/*9066*/ uint16(xReadCb),
	/*9067*/ uint16(xArgRel8),
	/*9068*/ uint16(xMatch),
	/*9069*/ uint16(xSetOp), uint16(JG),
	/*9071*/ uint16(xReadCb),
	/*9072*/ uint16(xArgRel8),
	/*9073*/ uint16(xMatch),
	/*9074*/ uint16(xCondSlashR),
	9083, // 0
	9089, // 1
	9095, // 2
	9101, // 3
	9107, // 4
	9113, // 5
	9119, // 6
	9125, // 7
	/*9083*/ uint16(xSetOp), uint16(ADD),
	/*9085*/ uint16(xReadIb),
	/*9086*/ uint16(xArgRM8),
	/*9087*/ uint16(xArgImm8u),
	/*9088*/ uint16(xMatch),
	/*9089*/ uint16(xSetOp), uint16(OR),
	/*9091*/ uint16(xReadIb),
	/*9092*/ uint16(xArgRM8),
	/*9093*/ uint16(xArgImm8u),
	/*9094*/ uint16(xMatch),
	/*9095*/ uint16(xSetOp), uint16(ADC),
	/*9097*/ uint16(xReadIb),
	/*9098*/ uint16(xArgRM8),
	/*9099*/ uint16(xArgImm8u),
	/*9100*/ uint16(xMatch),
	/*9101*/ uint16(xSetOp), uint16(SBB),
	/*9103*/ uint16(xReadIb),
	/*9104*/ uint16(xArgRM8),
	/*9105*/ uint16(xArgImm8u),
	/*9106*/ uint16(xMatch),
	/*9107*/ uint16(xSetOp), uint16(AND),
	/*9109*/ uint16(xReadIb),
	/*9110*/ uint16(xArgRM8),
	/*9111*/ uint16(xArgImm8u),
	/*9112*/ uint16(xMatch),
	/*9113*/ uint16(xSetOp), uint16(SUB),
	/*9115*/ uint16(xReadIb),
	/*9116*/ uint16(xArgRM8),
	/*9117*/ uint16(xArgImm8u),
	/*9118*/ uint16(xMatch),
	/*9119*/ uint16(xSetOp), uint16(XOR),
	/*9121*/ uint16(xReadIb),
	/*9122*/ uint16(xArgRM8),
	/*9123*/ uint16(xArgImm8u),
	/*9124*/ uint16(xMatch),
	/*9125*/ uint16(xSetOp), uint16(CMP),
	/*9127*/ uint16(xReadIb),
	/*9128*/ uint16(xArgRM8),
	/*9129*/ uint16(xArgImm8u),
	/*9130*/ uint16(xMatch),
	/*9131*/ uint16(xCondSlashR),
	9140, // 0
	9169, // 1
	9198, // 2
	9227, // 3
	9256, // 4
	9285, // 5
	9314, // 6
	9343, // 7
	/*9140*/ uint16(xCondIs64), 9143, 9159,
	/*9143*/ uint16(xCondDataSize), 9147, 9153, 0,
	/*9147*/ uint16(xSetOp), uint16(ADD),
	/*9149*/ uint16(xReadIw),
	/*9150*/ uint16(xArgRM16),
	/*9151*/ uint16(xArgImm16),
	/*9152*/ uint16(xMatch),
	/*9153*/ uint16(xSetOp), uint16(ADD),
	/*9155*/ uint16(xReadId),
	/*9156*/ uint16(xArgRM32),
	/*9157*/ uint16(xArgImm32),
	/*9158*/ uint16(xMatch),
	/*9159*/ uint16(xCondDataSize), 9147, 9153, 9163,
	/*9163*/ uint16(xSetOp), uint16(ADD),
	/*9165*/ uint16(xReadId),
	/*9166*/ uint16(xArgRM64),
	/*9167*/ uint16(xArgImm32),
	/*9168*/ uint16(xMatch),
	/*9169*/ uint16(xCondIs64), 9172, 9188,
	/*9172*/ uint16(xCondDataSize), 9176, 9182, 0,
	/*9176*/ uint16(xSetOp), uint16(OR),
	/*9178*/ uint16(xReadIw),
	/*9179*/ uint16(xArgRM16),
	/*9180*/ uint16(xArgImm16),
	/*9181*/ uint16(xMatch),
	/*9182*/ uint16(xSetOp), uint16(OR),
	/*9184*/ uint16(xReadId),
	/*9185*/ uint16(xArgRM32),
	/*9186*/ uint16(xArgImm32),
	/*9187*/ uint16(xMatch),
	/*9188*/ uint16(xCondDataSize), 9176, 9182, 9192,
	/*9192*/ uint16(xSetOp), uint16(OR),
	/*9194*/ uint16(xReadId),
	/*9195*/ uint16(xArgRM64),
	/*9196*/ uint16(xArgImm32),
	/*9197*/ uint16(xMatch),
	/*9198*/ uint16(xCondIs64), 9201, 9217,
	/*9201*/ uint16(xCondDataSize), 9205, 9211, 0,
	/*9205*/ uint16(xSetOp), uint16(ADC),
	/*9207*/ uint16(xReadIw),
	/*9208*/ uint16(xArgRM16),
	/*9209*/ uint16(xArgImm16),
	/*9210*/ uint16(xMatch),
	/*9211*/ uint16(xSetOp), uint16(ADC),
	/*9213*/ uint16(xReadId),
	/*9214*/ uint16(xArgRM32),
	/*9215*/ uint16(xArgImm32),
	/*9216*/ uint16(xMatch),
	/*9217*/ uint16(xCondDataSize), 9205, 9211, 9221,
	/*9221*/ uint16(xSetOp), uint16(ADC),
	/*9223*/ uint16(xReadId),
	/*9224*/ uint16(xArgRM64),
	/*9225*/ uint16(xArgImm32),
	/*9226*/ uint16(xMatch),
	/*9227*/ uint16(xCondIs64), 9230, 9246,
	/*9230*/ uint16(xCondDataSize), 9234, 9240, 0,
	/*9234*/ uint16(xSetOp), uint16(SBB),
	/*9236*/ uint16(xReadIw),
	/*9237*/ uint16(xArgRM16),
	/*9238*/ uint16(xArgImm16),
	/*9239*/ uint16(xMatch),
	/*9240*/ uint16(xSetOp), uint16(SBB),
	/*9242*/ uint16(xReadId),
	/*9243*/ uint16(xArgRM32),
	/*9244*/ uint16(xArgImm32),
	/*9245*/ uint16(xMatch),
	/*9246*/ uint16(xCondDataSize), 9234, 9240, 9250,
	/*9250*/ uint16(xSetOp), uint16(SBB),
	/*9252*/ uint16(xReadId),
	/*9253*/ uint16(xArgRM64),
	/*9254*/ uint16(xArgImm32),
	/*9255*/ uint16(xMatch),
	/*9256*/ uint16(xCondIs64), 9259, 9275,
	/*9259*/ uint16(xCondDataSize), 9263, 9269, 0,
	/*9263*/ uint16(xSetOp), uint16(AND),
	/*9265*/ uint16(xReadIw),
	/*9266*/ uint16(xArgRM16),
	/*9267*/ uint16(xArgImm16),
	/*9268*/ uint16(xMatch),
	/*9269*/ uint16(xSetOp), uint16(AND),
	/*9271*/ uint16(xReadId),
	/*9272*/ uint16(xArgRM32),
	/*9273*/ uint16(xArgImm32),
	/*9274*/ uint16(xMatch),
	/*9275*/ uint16(xCondDataSize), 9263, 9269, 9279,
	/*9279*/ uint16(xSetOp), uint16(AND),
	/*9281*/ uint16(xReadId),
	/*9282*/ uint16(xArgRM64),
	/*9283*/ uint16(xArgImm32),
	/*9284*/ uint16(xMatch),
	/*9285*/ uint16(xCondIs64), 9288, 9304,
	/*9288*/ uint16(xCondDataSize), 9292, 9298, 0,
	/*9292*/ uint16(xSetOp), uint16(SUB),
	/*9294*/ uint16(xReadIw),
	/*9295*/ uint16(xArgRM16),
	/*9296*/ uint16(xArgImm16),
	/*9297*/ uint16(xMatch),
	/*9298*/ uint16(xSetOp), uint16(SUB),
	/*9300*/ uint16(xReadId),
	/*9301*/ uint16(xArgRM32),
	/*9302*/ uint16(xArgImm32),
	/*9303*/ uint16(xMatch),
	/*9304*/ uint16(xCondDataSize), 9292, 9298, 9308,
	/*9308*/ uint16(xSetOp), uint16(SUB),
	/*9310*/ uint16(xReadId),
	/*9311*/ uint16(xArgRM64),
	/*9312*/ uint16(xArgImm32),
	/*9313*/ uint16(xMatch),
	/*9314*/ uint16(xCondIs64), 9317, 9333,
	/*9317*/ uint16(xCondDataSize), 9321, 9327, 0,
	/*9321*/ uint16(xSetOp), uint16(XOR),
	/*9323*/ uint16(xReadIw),
	/*9324*/ uint16(xArgRM16),
	/*9325*/ uint16(xArgImm16),
	/*9326*/ uint16(xMatch),
	/*9327*/ uint16(xSetOp), uint16(XOR),
	/*9329*/ uint16(xReadId),
	/*9330*/ uint16(xArgRM32),
	/*9331*/ uint16(xArgImm32),
	/*9332*/ uint16(xMatch),
	/*9333*/ uint16(xCondDataSize), 9321, 9327, 9337,
	/*9337*/ uint16(xSetOp), uint16(XOR),
	/*9339*/ uint16(xReadId),
	/*9340*/ uint16(xArgRM64),
	/*9341*/ uint16(xArgImm32),
	/*9342*/ uint16(xMatch),
	/*9343*/ uint16(xCondIs64), 9346, 9362,
	/*9346*/ uint16(xCondDataSize), 9350, 9356, 0,
	/*9350*/ uint16(xSetOp), uint16(CMP),
	/*9352*/ uint16(xReadIw),
	/*9353*/ uint16(xArgRM16),
	/*9354*/ uint16(xArgImm16),
	/*9355*/ uint16(xMatch),
	/*9356*/ uint16(xSetOp), uint16(CMP),
	/*9358*/ uint16(xReadId),
	/*9359*/ uint16(xArgRM32),
	/*9360*/ uint16(xArgImm32),
	/*9361*/ uint16(xMatch),
	/*9362*/ uint16(xCondDataSize), 9350, 9356, 9366,
	/*9366*/ uint16(xSetOp), uint16(CMP),
	/*9368*/ uint16(xReadId),
	/*9369*/ uint16(xArgRM64),
	/*9370*/ uint16(xArgImm32),
	/*9371*/ uint16(xMatch),
	/*9372*/ uint16(xCondSlashR),
	9381, // 0
	9410, // 1
	9439, // 2
	9468, // 3
	9497, // 4
	9526, // 5
	9555, // 6
	9584, // 7
	/*9381*/ uint16(xCondIs64), 9384, 9400,
	/*9384*/ uint16(xCondDataSize), 9388, 9394, 0,
	/*9388*/ uint16(xSetOp), uint16(ADD),
	/*9390*/ uint16(xReadIb),
	/*9391*/ uint16(xArgRM16),
	/*9392*/ uint16(xArgImm8),
	/*9393*/ uint16(xMatch),
	/*9394*/ uint16(xSetOp), uint16(ADD),
	/*9396*/ uint16(xReadIb),
	/*9397*/ uint16(xArgRM32),
	/*9398*/ uint16(xArgImm8),
	/*9399*/ uint16(xMatch),
	/*9400*/ uint16(xCondDataSize), 9388, 9394, 9404,
	/*9404*/ uint16(xSetOp), uint16(ADD),
	/*9406*/ uint16(xReadIb),
	/*9407*/ uint16(xArgRM64),
	/*9408*/ uint16(xArgImm8),
	/*9409*/ uint16(xMatch),
	/*9410*/ uint16(xCondIs64), 9413, 9429,
	/*9413*/ uint16(xCondDataSize), 9417, 9423, 0,
	/*9417*/ uint16(xSetOp), uint16(OR),
	/*9419*/ uint16(xReadIb),
	/*9420*/ uint16(xArgRM16),
	/*9421*/ uint16(xArgImm8),
	/*9422*/ uint16(xMatch),
	/*9423*/ uint16(xSetOp), uint16(OR),
	/*9425*/ uint16(xReadIb),
	/*9426*/ uint16(xArgRM32),
	/*9427*/ uint16(xArgImm8),
	/*9428*/ uint16(xMatch),
	/*9429*/ uint16(xCondDataSize), 9417, 9423, 9433,
	/*9433*/ uint16(xSetOp), uint16(OR),
	/*9435*/ uint16(xReadIb),
	/*9436*/ uint16(xArgRM64),
	/*9437*/ uint16(xArgImm8),
	/*9438*/ uint16(xMatch),
	/*9439*/ uint16(xCondIs64), 9442, 9458,
	/*9442*/ uint16(xCondDataSize), 9446, 9452, 0,
	/*9446*/ uint16(xSetOp), uint16(ADC),
	/*9448*/ uint16(xReadIb),
	/*9449*/ uint16(xArgRM16),
	/*9450*/ uint16(xArgImm8),
	/*9451*/ uint16(xMatch),
	/*9452*/ uint16(xSetOp), uint16(ADC),
	/*9454*/ uint16(xReadIb),
	/*9455*/ uint16(xArgRM32),
	/*9456*/ uint16(xArgImm8),
	/*9457*/ uint16(xMatch),
	/*9458*/ uint16(xCondDataSize), 9446, 9452, 9462,
	/*9462*/ uint16(xSetOp), uint16(ADC),
	/*9464*/ uint16(xReadIb),
	/*9465*/ uint16(xArgRM64),
	/*9466*/ uint16(xArgImm8),
	/*9467*/ uint16(xMatch),
	/*9468*/ uint16(xCondIs64), 9471, 9487,
	/*9471*/ uint16(xCondDataSize), 9475, 9481, 0,
	/*9475*/ uint16(xSetOp), uint16(SBB),
	/*9477*/ uint16(xReadIb),
	/*9478*/ uint16(xArgRM16),
	/*9479*/ uint16(xArgImm8),
	/*9480*/ uint16(xMatch),
	/*9481*/ uint16(xSetOp), uint16(SBB),
	/*9483*/ uint16(xReadIb),
	/*9484*/ uint16(xArgRM32),
	/*9485*/ uint16(xArgImm8),
	/*9486*/ uint16(xMatch),
	/*9487*/ uint16(xCondDataSize), 9475, 9481, 9491,
	/*9491*/ uint16(xSetOp), uint16(SBB),
	/*9493*/ uint16(xReadIb),
	/*9494*/ uint16(xArgRM64),
	/*9495*/ uint16(xArgImm8),
	/*9496*/ uint16(xMatch),
	/*9497*/ uint16(xCondIs64), 9500, 9516,
	/*9500*/ uint16(xCondDataSize), 9504, 9510, 0,
	/*9504*/ uint16(xSetOp), uint16(AND),
	/*9506*/ uint16(xReadIb),
	/*9507*/ uint16(xArgRM16),
	/*9508*/ uint16(xArgImm8),
	/*9509*/ uint16(xMatch),
	/*9510*/ uint16(xSetOp), uint16(AND),
	/*9512*/ uint16(xReadIb),
	/*9513*/ uint16(xArgRM32),
	/*9514*/ uint16(xArgImm8),
	/*9515*/ uint16(xMatch),
	/*9516*/ uint16(xCondDataSize), 9504, 9510, 9520,
	/*9520*/ uint16(xSetOp), uint16(AND),
	/*9522*/ uint16(xReadIb),
	/*9523*/ uint16(xArgRM64),
	/*9524*/ uint16(xArgImm8),
	/*9525*/ uint16(xMatch),
	/*9526*/ uint16(xCondIs64), 9529, 9545,
	/*9529*/ uint16(xCondDataSize), 9533, 9539, 0,
	/*9533*/ uint16(xSetOp), uint16(SUB),
	/*9535*/ uint16(xReadIb),
	/*9536*/ uint16(xArgRM16),
	/*9537*/ uint16(xArgImm8),
	/*9538*/ uint16(xMatch),
	/*9539*/ uint16(xSetOp), uint16(SUB),
	/*9541*/ uint16(xReadIb),
	/*9542*/ uint16(xArgRM32),
	/*9543*/ uint16(xArgImm8),
	/*9544*/ uint16(xMatch),
	/*9545*/ uint16(xCondDataSize), 9533, 9539, 9549,
	/*9549*/ uint16(xSetOp), uint16(SUB),
	/*9551*/ uint16(xReadIb),
	/*9552*/ uint16(xArgRM64),
	/*9553*/ uint16(xArgImm8),
	/*9554*/ uint16(xMatch),
	/*9555*/ uint16(xCondIs64), 9558, 9574,
	/*9558*/ uint16(xCondDataSize), 9562, 9568, 0,
	/*9562*/ uint16(xSetOp), uint16(XOR),
	/*9564*/ uint16(xReadIb),
	/*9565*/ uint16(xArgRM16),
	/*9566*/ uint16(xArgImm8),
	/*9567*/ uint16(xMatch),
	/*9568*/ uint16(xSetOp), uint16(XOR),
	/*9570*/ uint16(xReadIb),
	/*9571*/ uint16(xArgRM32),
	/*9572*/ uint16(xArgImm8),
	/*9573*/ uint16(xMatch),
	/*9574*/ uint16(xCondDataSize), 9562, 9568, 9578,
	/*9578*/ uint16(xSetOp), uint16(XOR),
	/*9580*/ uint16(xReadIb),
	/*9581*/ uint16(xArgRM64),
	/*9582*/ uint16(xArgImm8),
	/*9583*/ uint16(xMatch),
	/*9584*/ uint16(xCondIs64), 9587, 9603,
	/*9587*/ uint16(xCondDataSize), 9591, 9597, 0,
	/*9591*/ uint16(xSetOp), uint16(CMP),
	/*9593*/ uint16(xReadIb),
	/*9594*/ uint16(xArgRM16),
	/*9595*/ uint16(xArgImm8),
	/*9596*/ uint16(xMatch),
	/*9597*/ uint16(xSetOp), uint16(CMP),
	/*9599*/ uint16(xReadIb),
	/*9600*/ uint16(xArgRM32),
	/*9601*/ uint16(xArgImm8),
	/*9602*/ uint16(xMatch),
	/*9603*/ uint16(xCondDataSize), 9591, 9597, 9607,
	/*9607*/ uint16(xSetOp), uint16(CMP),
	/*9609*/ uint16(xReadIb),
	/*9610*/ uint16(xArgRM64),
	/*9611*/ uint16(xArgImm8),
	/*9612*/ uint16(xMatch),
	/*9613*/ uint16(xSetOp), uint16(TEST),
	/*9615*/ uint16(xReadSlashR),
	/*9616*/ uint16(xArgRM8),
	/*9617*/ uint16(xArgR8),
	/*9618*/ uint16(xMatch),
	/*9619*/ uint16(xCondIs64), 9622, 9638,
	/*9622*/ uint16(xCondDataSize), 9626, 9632, 0,
	/*9626*/ uint16(xSetOp), uint16(TEST),
	/*9628*/ uint16(xReadSlashR),
	/*9629*/ uint16(xArgRM16),
	/*9630*/ uint16(xArgR16),
	/*9631*/ uint16(xMatch),
	/*9632*/ uint16(xSetOp), uint16(TEST),
	/*9634*/ uint16(xReadSlashR),
	/*9635*/ uint16(xArgRM32),
	/*9636*/ uint16(xArgR32),
	/*9637*/ uint16(xMatch),
	/*9638*/ uint16(xCondDataSize), 9626, 9632, 9642,
	/*9642*/ uint16(xSetOp), uint16(TEST),
	/*9644*/ uint16(xReadSlashR),
	/*9645*/ uint16(xArgRM64),
	/*9646*/ uint16(xArgR64),
	/*9647*/ uint16(xMatch),
	/*9648*/ uint16(xSetOp), uint16(XCHG),
	/*9650*/ uint16(xReadSlashR),
	/*9651*/ uint16(xArgRM8),
	/*9652*/ uint16(xArgR8),
	/*9653*/ uint16(xMatch),
	/*9654*/ uint16(xCondIs64), 9657, 9673,
	/*9657*/ uint16(xCondDataSize), 9661, 9667, 0,
	/*9661*/ uint16(xSetOp), uint16(XCHG),
	/*9663*/ uint16(xReadSlashR),
	/*9664*/ uint16(xArgRM16),
	/*9665*/ uint16(xArgR16),
	/*9666*/ uint16(xMatch),
	/*9667*/ uint16(xSetOp), uint16(XCHG),
	/*9669*/ uint16(xReadSlashR),
	/*9670*/ uint16(xArgRM32),
	/*9671*/ uint16(xArgR32),
	/*9672*/ uint16(xMatch),
	/*9673*/ uint16(xCondDataSize), 9661, 9667, 9677,
	/*9677*/ uint16(xSetOp), uint16(XCHG),
	/*9679*/ uint16(xReadSlashR),
	/*9680*/ uint16(xArgRM64),
	/*9681*/ uint16(xArgR64),
	/*9682*/ uint16(xMatch),
	/*9683*/ uint16(xSetOp), uint16(MOV),
	/*9685*/ uint16(xReadSlashR),
	/*9686*/ uint16(xArgRM8),
	/*9687*/ uint16(xArgR8),
	/*9688*/ uint16(xMatch),
	/*9689*/ uint16(xCondDataSize), 9693, 9699, 9705,
	/*9693*/ uint16(xSetOp), uint16(MOV),
	/*9695*/ uint16(xReadSlashR),
	/*9696*/ uint16(xArgRM16),
	/*9697*/ uint16(xArgR16),
	/*9698*/ uint16(xMatch),
	/*9699*/ uint16(xSetOp), uint16(MOV),
	/*9701*/ uint16(xReadSlashR),
	/*9702*/ uint16(xArgRM32),
	/*9703*/ uint16(xArgR32),
	/*9704*/ uint16(xMatch),
	/*9705*/ uint16(xSetOp), uint16(MOV),
	/*9707*/ uint16(xReadSlashR),
	/*9708*/ uint16(xArgRM64),
	/*9709*/ uint16(xArgR64),
	/*9710*/ uint16(xMatch),
	/*9711*/ uint16(xSetOp), uint16(MOV),
	/*9713*/ uint16(xReadSlashR),
	/*9714*/ uint16(xArgR8),
	/*9715*/ uint16(xArgRM8),
	/*9716*/ uint16(xMatch),
	/*9717*/ uint16(xCondDataSize), 9721, 9727, 9733,
	/*9721*/ uint16(xSetOp), uint16(MOV),
	/*9723*/ uint16(xReadSlashR),
	/*9724*/ uint16(xArgR16),
	/*9725*/ uint16(xArgRM16),
	/*9726*/ uint16(xMatch),
	/*9727*/ uint16(xSetOp), uint16(MOV),
	/*9729*/ uint16(xReadSlashR),
	/*9730*/ uint16(xArgR32),
	/*9731*/ uint16(xArgRM32),
	/*9732*/ uint16(xMatch),
	/*9733*/ uint16(xSetOp), uint16(MOV),
	/*9735*/ uint16(xReadSlashR),
	/*9736*/ uint16(xArgR64),
	/*9737*/ uint16(xArgRM64),
	/*9738*/ uint16(xMatch),
	/*9739*/ uint16(xCondIs64), 9742, 9758,
	/*9742*/ uint16(xCondDataSize), 9746, 9752, 0,
	/*9746*/ uint16(xSetOp), uint16(MOV),
	/*9748*/ uint16(xReadSlashR),
	/*9749*/ uint16(xArgRM16),
	/*9750*/ uint16(xArgSreg),
	/*9751*/ uint16(xMatch),
	/*9752*/ uint16(xSetOp), uint16(MOV),
	/*9754*/ uint16(xReadSlashR),
	/*9755*/ uint16(xArgR32M16),
	/*9756*/ uint16(xArgSreg),
	/*9757*/ uint16(xMatch),
	/*9758*/ uint16(xCondDataSize), 9746, 9752, 9762,
	/*9762*/ uint16(xSetOp), uint16(MOV),
	/*9764*/ uint16(xReadSlashR),
	/*9765*/ uint16(xArgR64M16),
	/*9766*/ uint16(xArgSreg),
	/*9767*/ uint16(xMatch),
	/*9768*/ uint16(xCondIs64), 9771, 9787,
	/*9771*/ uint16(xCondDataSize), 9775, 9781, 0,
	/*9775*/ uint16(xSetOp), uint16(LEA),
	/*9777*/ uint16(xReadSlashR),
	/*9778*/ uint16(xArgR16),
	/*9779*/ uint16(xArgM),
	/*9780*/ uint16(xMatch),
	/*9781*/ uint16(xSetOp), uint16(LEA),
	/*9783*/ uint16(xReadSlashR),
	/*9784*/ uint16(xArgR32),
	/*9785*/ uint16(xArgM),
	/*9786*/ uint16(xMatch),
	/*9787*/ uint16(xCondDataSize), 9775, 9781, 9791,
	/*9791*/ uint16(xSetOp), uint16(LEA),
	/*9793*/ uint16(xReadSlashR),
	/*9794*/ uint16(xArgR64),
	/*9795*/ uint16(xArgM),
	/*9796*/ uint16(xMatch),
	/*9797*/ uint16(xCondIs64), 9800, 9816,
	/*9800*/ uint16(xCondDataSize), 9804, 9810, 0,
	/*9804*/ uint16(xSetOp), uint16(MOV),
	/*9806*/ uint16(xReadSlashR),
	/*9807*/ uint16(xArgSreg),
	/*9808*/ uint16(xArgRM16),
	/*9809*/ uint16(xMatch),
	/*9810*/ uint16(xSetOp), uint16(MOV),
	/*9812*/ uint16(xReadSlashR),
	/*9813*/ uint16(xArgSreg),
	/*9814*/ uint16(xArgR32M16),
	/*9815*/ uint16(xMatch),
	/*9816*/ uint16(xCondDataSize), 9804, 9810, 9820,
	/*9820*/ uint16(xSetOp), uint16(MOV),
	/*9822*/ uint16(xReadSlashR),
	/*9823*/ uint16(xArgSreg),
	/*9824*/ uint16(xArgR64M16),
	/*9825*/ uint16(xMatch),
	/*9826*/ uint16(xCondSlashR),
	9835, // 0
	0,    // 1
	0,    // 2
	0,    // 3
	0,    // 4
	0,    // 5
	0,    // 6
	0,    // 7
	/*9835*/ uint16(xCondIs64), 9838, 9850,
	/*9838*/ uint16(xCondDataSize), 9842, 9846, 0,
	/*9842*/ uint16(xSetOp), uint16(POP),
	/*9844*/ uint16(xArgRM16),
	/*9845*/ uint16(xMatch),
	/*9846*/ uint16(xSetOp), uint16(POP),
	/*9848*/ uint16(xArgRM32),
	/*9849*/ uint16(xMatch),
	/*9850*/ uint16(xCondDataSize), 9842, 9854, 9858,
	/*9854*/ uint16(xSetOp), uint16(POP),
	/*9856*/ uint16(xArgRM64),
	/*9857*/ uint16(xMatch),
	/*9858*/ uint16(xSetOp), uint16(POP),
	/*9860*/ uint16(xArgRM64),
	/*9861*/ uint16(xMatch),
	/*9862*/ uint16(xCondIs64), 9865, 9879,
	/*9865*/ uint16(xCondDataSize), 9869, 9874, 0,
	/*9869*/ uint16(xSetOp), uint16(XCHG),
	/*9871*/ uint16(xArgR16op),
	/*9872*/ uint16(xArgAX),
	/*9873*/ uint16(xMatch),
	/*9874*/ uint16(xSetOp), uint16(XCHG),
	/*9876*/ uint16(xArgR32op),
	/*9877*/ uint16(xArgEAX),
	/*9878*/ uint16(xMatch),
	/*9879*/ uint16(xCondDataSize), 9869, 9874, 9883,
	/*9883*/ uint16(xSetOp), uint16(XCHG),
	/*9885*/ uint16(xArgR64op),
	/*9886*/ uint16(xArgRAX),
	/*9887*/ uint16(xMatch),
	/*9888*/ uint16(xCondIs64), 9891, 9901,
	/*9891*/ uint16(xCondDataSize), 9895, 9898, 0,
	/*9895*/ uint16(xSetOp), uint16(CBW),
	/*9897*/ uint16(xMatch),
	/*9898*/ uint16(xSetOp), uint16(CWDE),
	/*9900*/ uint16(xMatch),
	/*9901*/ uint16(xCondDataSize), 9895, 9898, 9905,
	/*9905*/ uint16(xSetOp), uint16(CDQE),
	/*9907*/ uint16(xMatch),
	/*9908*/ uint16(xCondIs64), 9911, 9921,
	/*9911*/ uint16(xCondDataSize), 9915, 9918, 0,
	/*9915*/ uint16(xSetOp), uint16(CWD),
	/*9917*/ uint16(xMatch),
	/*9918*/ uint16(xSetOp), uint16(CDQ),
	/*9920*/ uint16(xMatch),
	/*9921*/ uint16(xCondDataSize), 9915, 9918, 9925,
	/*9925*/ uint16(xSetOp), uint16(CQO),
	/*9927*/ uint16(xMatch),
	/*9928*/ uint16(xCondIs64), 9931, 0,
	/*9931*/ uint16(xCondDataSize), 9935, 9940, 0,
	/*9935*/ uint16(xSetOp), uint16(LCALL),
	/*9937*/ uint16(xReadCd),
	/*9938*/ uint16(xArgPtr16colon16),
	/*9939*/ uint16(xMatch),
	/*9940*/ uint16(xSetOp), uint16(LCALL),
	/*9942*/ uint16(xReadCp),
	/*9943*/ uint16(xArgPtr16colon32),
	/*9944*/ uint16(xMatch),
	/*9945*/ uint16(xSetOp), uint16(FWAIT),
	/*9947*/ uint16(xMatch),
	/*9948*/ uint16(xCondIs64), 9951, 9961,
	/*9951*/ uint16(xCondDataSize), 9955, 9958, 0,
	/*9955*/ uint16(xSetOp), uint16(PUSHF),
	/*9957*/ uint16(xMatch),
	/*9958*/ uint16(xSetOp), uint16(PUSHFD),
	/*9960*/ uint16(xMatch),
	/*9961*/ uint16(xCondDataSize), 9955, 9965, 9968,
	/*9965*/ uint16(xSetOp), uint16(PUSHFQ),
	/*9967*/ uint16(xMatch),
	/*9968*/ uint16(xSetOp), uint16(PUSHFQ),
	/*9970*/ uint16(xMatch),
	/*9971*/ uint16(xCondIs64), 9974, 9984,
	/*9974*/ uint16(xCondDataSize), 9978, 9981, 0,
	/*9978*/ uint16(xSetOp), uint16(POPF),
	/*9980*/ uint16(xMatch),
	/*9981*/ uint16(xSetOp), uint16(POPFD),
	/*9983*/ uint16(xMatch),
	/*9984*/ uint16(xCondDataSize), 9978, 9988, 9991,
	/*9988*/ uint16(xSetOp), uint16(POPFQ),
	/*9990*/ uint16(xMatch),
	/*9991*/ uint16(xSetOp), uint16(POPFQ),
	/*9993*/ uint16(xMatch),
	/*9994*/ uint16(xSetOp), uint16(SAHF),
	/*9996*/ uint16(xMatch),
	/*9997*/ uint16(xSetOp), uint16(LAHF),
	/*9999*/ uint16(xMatch),
	/*10000*/ uint16(xCondIs64), 10003, 10009,
	/*10003*/ uint16(xSetOp), uint16(MOV),
	/*10005*/ uint16(xReadCm),
	/*10006*/ uint16(xArgAL),
	/*10007*/ uint16(xArgMoffs8),
	/*10008*/ uint16(xMatch),
	/*10009*/ uint16(xCondDataSize), 10003, 10003, 10013,
	/*10013*/ uint16(xSetOp), uint16(MOV),
	/*10015*/ uint16(xReadCm),
	/*10016*/ uint16(xArgAL),
	/*10017*/ uint16(xArgMoffs8),
	/*10018*/ uint16(xMatch),
	/*10019*/ uint16(xCondDataSize), 10023, 10029, 10035,
	/*10023*/ uint16(xSetOp), uint16(MOV),
	/*10025*/ uint16(xReadCm),
	/*10026*/ uint16(xArgAX),
	/*10027*/ uint16(xArgMoffs16),
	/*10028*/ uint16(xMatch),
	/*10029*/ uint16(xSetOp), uint16(MOV),
	/*10031*/ uint16(xReadCm),
	/*10032*/ uint16(xArgEAX),
	/*10033*/ uint16(xArgMoffs32),
	/*10034*/ uint16(xMatch),
	/*10035*/ uint16(xSetOp), uint16(MOV),
	/*10037*/ uint16(xReadCm),
	/*10038*/ uint16(xArgRAX),
	/*10039*/ uint16(xArgMoffs64),
	/*10040*/ uint16(xMatch),
	/*10041*/ uint16(xCondIs64), 10044, 10050,
	/*10044*/ uint16(xSetOp), uint16(MOV),
	/*10046*/ uint16(xReadCm),
	/*10047*/ uint16(xArgMoffs8),
	/*10048*/ uint16(xArgAL),
	/*10049*/ uint16(xMatch),
	/*10050*/ uint16(xCondDataSize), 10044, 10044, 10054,
	/*10054*/ uint16(xSetOp), uint16(MOV),
	/*10056*/ uint16(xReadCm),
	/*10057*/ uint16(xArgMoffs8),
	/*10058*/ uint16(xArgAL),
	/*10059*/ uint16(xMatch),
	/*10060*/ uint16(xCondDataSize), 10064, 10070, 10076,
	/*10064*/ uint16(xSetOp), uint16(MOV),
	/*10066*/ uint16(xReadCm),
	/*10067*/ uint16(xArgMoffs16),
	/*10068*/ uint16(xArgAX),
	/*10069*/ uint16(xMatch),
	/*10070*/ uint16(xSetOp), uint16(MOV),
	/*10072*/ uint16(xReadCm),
	/*10073*/ uint16(xArgMoffs32),
	/*10074*/ uint16(xArgEAX),
	/*10075*/ uint16(xMatch),
	/*10076*/ uint16(xSetOp), uint16(MOV),
	/*10078*/ uint16(xReadCm),
	/*10079*/ uint16(xArgMoffs64),
	/*10080*/ uint16(xArgRAX),
	/*10081*/ uint16(xMatch),
	/*10082*/ uint16(xSetOp), uint16(MOVSB),
	/*10084*/ uint16(xMatch),
	/*10085*/ uint16(xCondIs64), 10088, 10098,
	/*10088*/ uint16(xCondDataSize), 10092, 10095, 0,
	/*10092*/ uint16(xSetOp), uint16(MOVSW),
	/*10094*/ uint16(xMatch),
	/*10095*/ uint16(xSetOp), uint16(MOVSD),
	/*10097*/ uint16(xMatch),
	/*10098*/ uint16(xCondDataSize), 10092, 10095, 10102,
	/*10102*/ uint16(xSetOp), uint16(MOVSQ),
	/*10104*/ uint16(xMatch),
	/*10105*/ uint16(xSetOp), uint16(CMPSB),
	/*10107*/ uint16(xMatch),
	/*10108*/ uint16(xCondIs64), 10111, 10121,
	/*10111*/ uint16(xCondDataSize), 10115, 10118, 0,
	/*10115*/ uint16(xSetOp), uint16(CMPSW),
	/*10117*/ uint16(xMatch),
	/*10118*/ uint16(xSetOp), uint16(CMPSD),
	/*10120*/ uint16(xMatch),
	/*10121*/ uint16(xCondDataSize), 10115, 10118, 10125,
	/*10125*/ uint16(xSetOp), uint16(CMPSQ),
	/*10127*/ uint16(xMatch),
	/*10128*/ uint16(xSetOp), uint16(TEST),
	/*10130*/ uint16(xReadIb),
	/*10131*/ uint16(xArgAL),
	/*10132*/ uint16(xArgImm8u),
	/*10133*/ uint16(xMatch),
	/*10134*/ uint16(xCondIs64), 10137, 10153,
	/*10137*/ uint16(xCondDataSize), 10141, 10147, 0,
	/*10141*/ uint16(xSetOp), uint16(TEST),
	/*10143*/ uint16(xReadIw),
	/*10144*/ uint16(xArgAX),
	/*10145*/ uint16(xArgImm16),
	/*10146*/ uint16(xMatch),
	/*10147*/ uint16(xSetOp), uint16(TEST),
	/*10149*/ uint16(xReadId),
	/*10150*/ uint16(xArgEAX),
	/*10151*/ uint16(xArgImm32),
	/*10152*/ uint16(xMatch),
	/*10153*/ uint16(xCondDataSize), 10141, 10147, 10157,
	/*10157*/ uint16(xSetOp), uint16(TEST),
	/*10159*/ uint16(xReadId),
	/*10160*/ uint16(xArgRAX),
	/*10161*/ uint16(xArgImm32),
	/*10162*/ uint16(xMatch),
	/*10163*/ uint16(xSetOp), uint16(STOSB),
	/*10165*/ uint16(xMatch),
	/*10166*/ uint16(xCondIs64), 10169, 10179,
	/*10169*/ uint16(xCondDataSize), 10173, 10176, 0,
	/*10173*/ uint16(xSetOp), uint16(STOSW),
	/*10175*/ uint16(xMatch),
	/*10176*/ uint16(xSetOp), uint16(STOSD),
	/*10178*/ uint16(xMatch),
	/*10179*/ uint16(xCondDataSize), 10173, 10176, 10183,
	/*10183*/ uint16(xSetOp), uint16(STOSQ),
	/*10185*/ uint16(xMatch),
	/*10186*/ uint16(xSetOp), uint16(LODSB),
	/*10188*/ uint16(xMatch),
	/*10189*/ uint16(xCondIs64), 10192, 10202,
	/*10192*/ uint16(xCondDataSize), 10196, 10199, 0,
	/*10196*/ uint16(xSetOp), uint16(LODSW),
	/*10198*/ uint16(xMatch),
	/*10199*/ uint16(xSetOp), uint16(LODSD),
	/*10201*/ uint16(xMatch),
	/*10202*/ uint16(xCondDataSize), 10196, 10199, 10206,
	/*10206*/ uint16(xSetOp), uint16(LODSQ),
	/*10208*/ uint16(xMatch),
	/*10209*/ uint16(xSetOp), uint16(SCASB),
	/*10211*/ uint16(xMatch),
	/*10212*/ uint16(xCondIs64), 10215, 10225,
	/*10215*/ uint16(xCondDataSize), 10219, 10222, 0,
	/*10219*/ uint16(xSetOp), uint16(SCASW),
	/*10221*/ uint16(xMatch),
	/*10222*/ uint16(xSetOp), uint16(SCASD),
	/*10224*/ uint16(xMatch),
	/*10225*/ uint16(xCondDataSize), 10219, 10222, 10229,
	/*10229*/ uint16(xSetOp), uint16(SCASQ),
	/*10231*/ uint16(xMatch),
	/*10232*/ uint16(xSetOp), uint16(MOV),
	/*10234*/ uint16(xReadIb),
	/*10235*/ uint16(xArgR8op),
	/*10236*/ uint16(xArgImm8u),
	/*10237*/ uint16(xMatch),
	/*10238*/ uint16(xCondIs64), 10241, 10257,
	/*10241*/ uint16(xCondDataSize), 10245, 10251, 0,
	/*10245*/ uint16(xSetOp), uint16(MOV),
	/*10247*/ uint16(xReadIw),
	/*10248*/ uint16(xArgR16op),
	/*10249*/ uint16(xArgImm16),
	/*10250*/ uint16(xMatch),
	/*10251*/ uint16(xSetOp), uint16(MOV),
	/*10253*/ uint16(xReadId),
	/*10254*/ uint16(xArgR32op),
	/*10255*/ uint16(xArgImm32),
	/*10256*/ uint16(xMatch),
	/*10257*/ uint16(xCondDataSize), 10245, 10251, 10261,
	/*10261*/ uint16(xSetOp), uint16(MOV),
	/*10263*/ uint16(xReadIo),
	/*10264*/ uint16(xArgR64op),
	/*10265*/ uint16(xArgImm64),
	/*10266*/ uint16(xMatch),
	/*10267*/ uint16(xCondSlashR),
	10276, // 0
	10282, // 1
	10288, // 2
	10294, // 3
	10300, // 4
	10306, // 5
	0,     // 6
	10312, // 7
	/*10276*/ uint16(xSetOp), uint16(ROL),
	/*10278*/ uint16(xReadIb),
	/*10279*/ uint16(xArgRM8),
	/*10280*/ uint16(xArgImm8u),
	/*10281*/ uint16(xMatch),
	/*10282*/ uint16(xSetOp), uint16(ROR),
	/*10284*/ uint16(xReadIb),
	/*10285*/ uint16(xArgRM8),
	/*10286*/ uint16(xArgImm8u),
	/*10287*/ uint16(xMatch),
	/*10288*/ uint16(xSetOp), uint16(RCL),
	/*10290*/ uint16(xReadIb),
	/*10291*/ uint16(xArgRM8),
	/*10292*/ uint16(xArgImm8u),
	/*10293*/ uint16(xMatch),
	/*10294*/ uint16(xSetOp), uint16(RCR),
	/*10296*/ uint16(xReadIb),
	/*10297*/ uint16(xArgRM8),
	/*10298*/ uint16(xArgImm8u),
	/*10299*/ uint16(xMatch),
	/*10300*/ uint16(xSetOp), uint16(SHL),
	/*10302*/ uint16(xReadIb),
	/*10303*/ uint16(xArgRM8),
	/*10304*/ uint16(xArgImm8u),
	/*10305*/ uint16(xMatch),
	/*10306*/ uint16(xSetOp), uint16(SHR),
	/*10308*/ uint16(xReadIb),
	/*10309*/ uint16(xArgRM8),
	/*10310*/ uint16(xArgImm8u),
	/*10311*/ uint16(xMatch),
	/*10312*/ uint16(xSetOp), uint16(SAR),
	/*10314*/ uint16(xReadIb),
	/*10315*/ uint16(xArgRM8),
	/*10316*/ uint16(xArgImm8u),
	/*10317*/ uint16(xMatch),
	/*10318*/ uint16(xCondSlashR),
	10327, // 0
	10349, // 1
	10371, // 2
	10400, // 3
	10429, // 4
	10458, // 5
	0,     // 6
	10487, // 7
	/*10327*/ uint16(xCondDataSize), 10331, 10337, 10343,
	/*10331*/ uint16(xSetOp), uint16(ROL),
	/*10333*/ uint16(xReadIb),
	/*10334*/ uint16(xArgRM16),
	/*10335*/ uint16(xArgImm8u),
	/*10336*/ uint16(xMatch),
	/*10337*/ uint16(xSetOp), uint16(ROL),
	/*10339*/ uint16(xReadIb),
	/*10340*/ uint16(xArgRM32),
	/*10341*/ uint16(xArgImm8u),
	/*10342*/ uint16(xMatch),
	/*10343*/ uint16(xSetOp), uint16(ROL),
	/*10345*/ uint16(xReadIb),
	/*10346*/ uint16(xArgRM64),
	/*10347*/ uint16(xArgImm8u),
	/*10348*/ uint16(xMatch),
	/*10349*/ uint16(xCondDataSize), 10353, 10359, 10365,
	/*10353*/ uint16(xSetOp), uint16(ROR),
	/*10355*/ uint16(xReadIb),
	/*10356*/ uint16(xArgRM16),
	/*10357*/ uint16(xArgImm8u),
	/*10358*/ uint16(xMatch),
	/*10359*/ uint16(xSetOp), uint16(ROR),
	/*10361*/ uint16(xReadIb),
	/*10362*/ uint16(xArgRM32),
	/*10363*/ uint16(xArgImm8u),
	/*10364*/ uint16(xMatch),
	/*10365*/ uint16(xSetOp), uint16(ROR),
	/*10367*/ uint16(xReadIb),
	/*10368*/ uint16(xArgRM64),
	/*10369*/ uint16(xArgImm8u),
	/*10370*/ uint16(xMatch),
	/*10371*/ uint16(xCondIs64), 10374, 10390,
	/*10374*/ uint16(xCondDataSize), 10378, 10384, 0,
	/*10378*/ uint16(xSetOp), uint16(RCL),
	/*10380*/ uint16(xReadIb),
	/*10381*/ uint16(xArgRM16),
	/*10382*/ uint16(xArgImm8u),
	/*10383*/ uint16(xMatch),
	/*10384*/ uint16(xSetOp), uint16(RCL),
	/*10386*/ uint16(xReadIb),
	/*10387*/ uint16(xArgRM32),
	/*10388*/ uint16(xArgImm8u),
	/*10389*/ uint16(xMatch),
	/*10390*/ uint16(xCondDataSize), 10378, 10384, 10394,
	/*10394*/ uint16(xSetOp), uint16(RCL),
	/*10396*/ uint16(xReadIb),
	/*10397*/ uint16(xArgRM64),
	/*10398*/ uint16(xArgImm8u),
	/*10399*/ uint16(xMatch),
	/*10400*/ uint16(xCondIs64), 10403, 10419,
	/*10403*/ uint16(xCondDataSize), 10407, 10413, 0,
	/*10407*/ uint16(xSetOp), uint16(RCR),
	/*10409*/ uint16(xReadIb),
	/*10410*/ uint16(xArgRM16),
	/*10411*/ uint16(xArgImm8u),
	/*10412*/ uint16(xMatch),
	/*10413*/ uint16(xSetOp), uint16(RCR),
	/*10415*/ uint16(xReadIb),
	/*10416*/ uint16(xArgRM32),
	/*10417*/ uint16(xArgImm8u),
	/*10418*/ uint16(xMatch),
	/*10419*/ uint16(xCondDataSize), 10407, 10413, 10423,
	/*10423*/ uint16(xSetOp), uint16(RCR),
	/*10425*/ uint16(xReadIb),
	/*10426*/ uint16(xArgRM64),
	/*10427*/ uint16(xArgImm8u),
	/*10428*/ uint16(xMatch),
	/*10429*/ uint16(xCondIs64), 10432, 10448,
	/*10432*/ uint16(xCondDataSize), 10436, 10442, 0,
	/*10436*/ uint16(xSetOp), uint16(SHL),
	/*10438*/ uint16(xReadIb),
	/*10439*/ uint16(xArgRM16),
	/*10440*/ uint16(xArgImm8u),
	/*10441*/ uint16(xMatch),
	/*10442*/ uint16(xSetOp), uint16(SHL),
	/*10444*/ uint16(xReadIb),
	/*10445*/ uint16(xArgRM32),
	/*10446*/ uint16(xArgImm8u),
	/*10447*/ uint16(xMatch),
	/*10448*/ uint16(xCondDataSize), 10436, 10442, 10452,
	/*10452*/ uint16(xSetOp), uint16(SHL),
	/*10454*/ uint16(xReadIb),
	/*10455*/ uint16(xArgRM64),
	/*10456*/ uint16(xArgImm8u),
	/*10457*/ uint16(xMatch),
	/*10458*/ uint16(xCondIs64), 10461, 10477,
	/*10461*/ uint16(xCondDataSize), 10465, 10471, 0,
	/*10465*/ uint16(xSetOp), uint16(SHR),
	/*10467*/ uint16(xReadIb),
	/*10468*/ uint16(xArgRM16),
	/*10469*/ uint16(xArgImm8u),
	/*10470*/ uint16(xMatch),
	/*10471*/ uint16(xSetOp), uint16(SHR),
	/*10473*/ uint16(xReadIb),
	/*10474*/ uint16(xArgRM32),
	/*10475*/ uint16(xArgImm8u),
	/*10476*/ uint16(xMatch),
	/*10477*/ uint16(xCondDataSize), 10465, 10471, 10481,
	/*10481*/ uint16(xSetOp), uint16(SHR),
	/*10483*/ uint16(xReadIb),
	/*10484*/ uint16(xArgRM64),
	/*10485*/ uint16(xArgImm8u),
	/*10486*/ uint16(xMatch),
	/*10487*/ uint16(xCondIs64), 10490, 10506,
	/*10490*/ uint16(xCondDataSize), 10494, 10500, 0,
	/*10494*/ uint16(xSetOp), uint16(SAR),
	/*10496*/ uint16(xReadIb),
	/*10497*/ uint16(xArgRM16),
	/*10498*/ uint16(xArgImm8u),
	/*10499*/ uint16(xMatch),
	/*10500*/ uint16(xSetOp), uint16(SAR),
	/*10502*/ uint16(xReadIb),
	/*10503*/ uint16(xArgRM32),
	/*10504*/ uint16(xArgImm8u),
	/*10505*/ uint16(xMatch),
	/*10506*/ uint16(xCondDataSize), 10494, 10500, 10510,
	/*10510*/ uint16(xSetOp), uint16(SAR),
	/*10512*/ uint16(xReadIb),
	/*10513*/ uint16(xArgRM64),
	/*10514*/ uint16(xArgImm8u),
	/*10515*/ uint16(xMatch),
	/*10516*/ uint16(xSetOp), uint16(RET),
	/*10518*/ uint16(xReadIw),
	/*10519*/ uint16(xArgImm16u),
	/*10520*/ uint16(xMatch),
	/*10521*/ uint16(xSetOp), uint16(RET),
	/*10523*/ uint16(xMatch),
	/*10524*/ uint16(xCondIs64), 10527, 0,
	/*10527*/ uint16(xCondDataSize), 10531, 10537, 0,
	/*10531*/ uint16(xSetOp), uint16(LES),
	/*10533*/ uint16(xReadSlashR),
	/*10534*/ uint16(xArgR16),
	/*10535*/ uint16(xArgM16colon16),
	/*10536*/ uint16(xMatch),
	/*10537*/ uint16(xSetOp), uint16(LES),
	/*10539*/ uint16(xReadSlashR),
	/*10540*/ uint16(xArgR32),
	/*10541*/ uint16(xArgM16colon32),
	/*10542*/ uint16(xMatch),
	/*10543*/ uint16(xCondIs64), 10546, 0,
	/*10546*/ uint16(xCondDataSize), 10550, 10556, 0,
	/*10550*/ uint16(xSetOp), uint16(LDS),
	/*10552*/ uint16(xReadSlashR),
	/*10553*/ uint16(xArgR16),
	/*10554*/ uint16(xArgM16colon16),
	/*10555*/ uint16(xMatch),
	/*10556*/ uint16(xSetOp), uint16(LDS),
	/*10558*/ uint16(xReadSlashR),
	/*10559*/ uint16(xArgR32),
	/*10560*/ uint16(xArgM16colon32),
	/*10561*/ uint16(xMatch),
	/*10562*/ uint16(xCondByte), 1,
	0xF8, 10581,
	/*10566*/ uint16(xCondSlashR),
	10575, // 0
	0,     // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*10575*/ uint16(xSetOp), uint16(MOV),
	/*10577*/ uint16(xReadIb),
	/*10578*/ uint16(xArgRM8),
	/*10579*/ uint16(xArgImm8u),
	/*10580*/ uint16(xMatch),
	/*10581*/ uint16(xSetOp), uint16(XABORT),
	/*10583*/ uint16(xReadIb),
	/*10584*/ uint16(xArgImm8u),
	/*10585*/ uint16(xMatch),
	/*10586*/ uint16(xCondByte), 1,
	0xF8, 10628,
	/*10590*/ uint16(xCondSlashR),
	10599, // 0
	0,     // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*10599*/ uint16(xCondIs64), 10602, 10618,
	/*10602*/ uint16(xCondDataSize), 10606, 10612, 0,
	/*10606*/ uint16(xSetOp), uint16(MOV),
	/*10608*/ uint16(xReadIw),
	/*10609*/ uint16(xArgRM16),
	/*10610*/ uint16(xArgImm16),
	/*10611*/ uint16(xMatch),
	/*10612*/ uint16(xSetOp), uint16(MOV),
	/*10614*/ uint16(xReadId),
	/*10615*/ uint16(xArgRM32),
	/*10616*/ uint16(xArgImm32),
	/*10617*/ uint16(xMatch),
	/*10618*/ uint16(xCondDataSize), 10606, 10612, 10622,
	/*10622*/ uint16(xSetOp), uint16(MOV),
	/*10624*/ uint16(xReadId),
	/*10625*/ uint16(xArgRM64),
	/*10626*/ uint16(xArgImm32),
	/*10627*/ uint16(xMatch),
	/*10628*/ uint16(xCondDataSize), 10632, 10637, 10642,
	/*10632*/ uint16(xSetOp), uint16(XBEGIN),
	/*10634*/ uint16(xReadCw),
	/*10635*/ uint16(xArgRel16),
	/*10636*/ uint16(xMatch),
	/*10637*/ uint16(xSetOp), uint16(XBEGIN),
	/*10639*/ uint16(xReadCd),
	/*10640*/ uint16(xArgRel32),
	/*10641*/ uint16(xMatch),
	/*10642*/ uint16(xSetOp), uint16(XBEGIN),
	/*10644*/ uint16(xReadCd),
	/*10645*/ uint16(xArgRel32),
	/*10646*/ uint16(xMatch),
	/*10647*/ uint16(xSetOp), uint16(ENTER),
	/*10649*/ uint16(xReadIw),
	/*10650*/ uint16(xReadIb),
	/*10651*/ uint16(xArgImm16u),
	/*10652*/ uint16(xArgImm8u),
	/*10653*/ uint16(xMatch),
	/*10654*/ uint16(xCondIs64), 10657, 10667,
	/*10657*/ uint16(xCondDataSize), 10661, 10664, 0,
	/*10661*/ uint16(xSetOp), uint16(LEAVE),
	/*10663*/ uint16(xMatch),
	/*10664*/ uint16(xSetOp), uint16(LEAVE),
	/*10666*/ uint16(xMatch),
	/*10667*/ uint16(xCondDataSize), 10661, 10671, 10674,
	/*10671*/ uint16(xSetOp), uint16(LEAVE),
	/*10673*/ uint16(xMatch),
	/*10674*/ uint16(xSetOp), uint16(LEAVE),
	/*10676*/ uint16(xMatch),
	/*10677*/ uint16(xSetOp), uint16(LRET),
	/*10679*/ uint16(xReadIw),
	/*10680*/ uint16(xArgImm16u),
	/*10681*/ uint16(xMatch),
	/*10682*/ uint16(xSetOp), uint16(LRET),
	/*10684*/ uint16(xMatch),
	/*10685*/ uint16(xSetOp), uint16(INT),
	/*10687*/ uint16(xArg3),
	/*10688*/ uint16(xMatch),
	/*10689*/ uint16(xSetOp), uint16(INT),
	/*10691*/ uint16(xReadIb),
	/*10692*/ uint16(xArgImm8u),
	/*10693*/ uint16(xMatch),
	/*10694*/ uint16(xCondIs64), 10697, 0,
	/*10697*/ uint16(xSetOp), uint16(INTO),
	/*10699*/ uint16(xMatch),
	/*10700*/ uint16(xCondIs64), 10703, 10713,
	/*10703*/ uint16(xCondDataSize), 10707, 10710, 0,
	/*10707*/ uint16(xSetOp), uint16(IRET),
	/*10709*/ uint16(xMatch),
	/*10710*/ uint16(xSetOp), uint16(IRETD),
	/*10712*/ uint16(xMatch),
	/*10713*/ uint16(xCondDataSize), 10707, 10710, 10717,
	/*10717*/ uint16(xSetOp), uint16(IRETQ),
	/*10719*/ uint16(xMatch),
	/*10720*/ uint16(xCondSlashR),
	10729, // 0
	10734, // 1
	10739, // 2
	10744, // 3
	10749, // 4
	10754, // 5
	0,     // 6
	10759, // 7
	/*10729*/ uint16(xSetOp), uint16(ROL),
	/*10731*/ uint16(xArgRM8),
	/*10732*/ uint16(xArg1),
	/*10733*/ uint16(xMatch),
	/*10734*/ uint16(xSetOp), uint16(ROR),
	/*10736*/ uint16(xArgRM8),
	/*10737*/ uint16(xArg1),
	/*10738*/ uint16(xMatch),
	/*10739*/ uint16(xSetOp), uint16(RCL),
	/*10741*/ uint16(xArgRM8),
	/*10742*/ uint16(xArg1),
	/*10743*/ uint16(xMatch),
	/*10744*/ uint16(xSetOp), uint16(RCR),
	/*10746*/ uint16(xArgRM8),
	/*10747*/ uint16(xArg1),
	/*10748*/ uint16(xMatch),
	/*10749*/ uint16(xSetOp), uint16(SHL),
	/*10751*/ uint16(xArgRM8),
	/*10752*/ uint16(xArg1),
	/*10753*/ uint16(xMatch),
	/*10754*/ uint16(xSetOp), uint16(SHR),
	/*10756*/ uint16(xArgRM8),
	/*10757*/ uint16(xArg1),
	/*10758*/ uint16(xMatch),
	/*10759*/ uint16(xSetOp), uint16(SAR),
	/*10761*/ uint16(xArgRM8),
	/*10762*/ uint16(xArg1),
	/*10763*/ uint16(xMatch),
	/*10764*/ uint16(xCondSlashR),
	10773, // 0
	10799, // 1
	10825, // 2
	10851, // 3
	10877, // 4
	10903, // 5
	0,     // 6
	10929, // 7
	/*10773*/ uint16(xCondIs64), 10776, 10790,
	/*10776*/ uint16(xCondDataSize), 10780, 10785, 0,
	/*10780*/ uint16(xSetOp), uint16(ROL),
	/*10782*/ uint16(xArgRM16),
	/*10783*/ uint16(xArg1),
	/*10784*/ uint16(xMatch),
	/*10785*/ uint16(xSetOp), uint16(ROL),
	/*10787*/ uint16(xArgRM32),
	/*10788*/ uint16(xArg1),
	/*10789*/ uint16(xMatch),
	/*10790*/ uint16(xCondDataSize), 10780, 10785, 10794,
	/*10794*/ uint16(xSetOp), uint16(ROL),
	/*10796*/ uint16(xArgRM64),
	/*10797*/ uint16(xArg1),
	/*10798*/ uint16(xMatch),
	/*10799*/ uint16(xCondIs64), 10802, 10816,
	/*10802*/ uint16(xCondDataSize), 10806, 10811, 0,
	/*10806*/ uint16(xSetOp), uint16(ROR),
	/*10808*/ uint16(xArgRM16),
	/*10809*/ uint16(xArg1),
	/*10810*/ uint16(xMatch),
	/*10811*/ uint16(xSetOp), uint16(ROR),
	/*10813*/ uint16(xArgRM32),
	/*10814*/ uint16(xArg1),
	/*10815*/ uint16(xMatch),
	/*10816*/ uint16(xCondDataSize), 10806, 10811, 10820,
	/*10820*/ uint16(xSetOp), uint16(ROR),
	/*10822*/ uint16(xArgRM64),
	/*10823*/ uint16(xArg1),
	/*10824*/ uint16(xMatch),
	/*10825*/ uint16(xCondIs64), 10828, 10842,
	/*10828*/ uint16(xCondDataSize), 10832, 10837, 0,
	/*10832*/ uint16(xSetOp), uint16(RCL),
	/*10834*/ uint16(xArgRM16),
	/*10835*/ uint16(xArg1),
	/*10836*/ uint16(xMatch),
	/*10837*/ uint16(xSetOp), uint16(RCL),
	/*10839*/ uint16(xArgRM32),
	/*10840*/ uint16(xArg1),
	/*10841*/ uint16(xMatch),
	/*10842*/ uint16(xCondDataSize), 10832, 10837, 10846,
	/*10846*/ uint16(xSetOp), uint16(RCL),
	/*10848*/ uint16(xArgRM64),
	/*10849*/ uint16(xArg1),
	/*10850*/ uint16(xMatch),
	/*10851*/ uint16(xCondIs64), 10854, 10868,
	/*10854*/ uint16(xCondDataSize), 10858, 10863, 0,
	/*10858*/ uint16(xSetOp), uint16(RCR),
	/*10860*/ uint16(xArgRM16),
	/*10861*/ uint16(xArg1),
	/*10862*/ uint16(xMatch),
	/*10863*/ uint16(xSetOp), uint16(RCR),
	/*10865*/ uint16(xArgRM32),
	/*10866*/ uint16(xArg1),
	/*10867*/ uint16(xMatch),
	/*10868*/ uint16(xCondDataSize), 10858, 10863, 10872,
	/*10872*/ uint16(xSetOp), uint16(RCR),
	/*10874*/ uint16(xArgRM64),
	/*10875*/ uint16(xArg1),
	/*10876*/ uint16(xMatch),
	/*10877*/ uint16(xCondIs64), 10880, 10894,
	/*10880*/ uint16(xCondDataSize), 10884, 10889, 0,
	/*10884*/ uint16(xSetOp), uint16(SHL),
	/*10886*/ uint16(xArgRM16),
	/*10887*/ uint16(xArg1),
	/*10888*/ uint16(xMatch),
	/*10889*/ uint16(xSetOp), uint16(SHL),
	/*10891*/ uint16(xArgRM32),
	/*10892*/ uint16(xArg1),
	/*10893*/ uint16(xMatch),
	/*10894*/ uint16(xCondDataSize), 10884, 10889, 10898,
	/*10898*/ uint16(xSetOp), uint16(SHL),
	/*10900*/ uint16(xArgRM64),
	/*10901*/ uint16(xArg1),
	/*10902*/ uint16(xMatch),
	/*10903*/ uint16(xCondIs64), 10906, 10920,
	/*10906*/ uint16(xCondDataSize), 10910, 10915, 0,
	/*10910*/ uint16(xSetOp), uint16(SHR),
	/*10912*/ uint16(xArgRM16),
	/*10913*/ uint16(xArg1),
	/*10914*/ uint16(xMatch),
	/*10915*/ uint16(xSetOp), uint16(SHR),
	/*10917*/ uint16(xArgRM32),
	/*10918*/ uint16(xArg1),
	/*10919*/ uint16(xMatch),
	/*10920*/ uint16(xCondDataSize), 10910, 10915, 10924,
	/*10924*/ uint16(xSetOp), uint16(SHR),
	/*10926*/ uint16(xArgRM64),
	/*10927*/ uint16(xArg1),
	/*10928*/ uint16(xMatch),
	/*10929*/ uint16(xCondIs64), 10932, 10946,
	/*10932*/ uint16(xCondDataSize), 10936, 10941, 0,
	/*10936*/ uint16(xSetOp), uint16(SAR),
	/*10938*/ uint16(xArgRM16),
	/*10939*/ uint16(xArg1),
	/*10940*/ uint16(xMatch),
	/*10941*/ uint16(xSetOp), uint16(SAR),
	/*10943*/ uint16(xArgRM32),
	/*10944*/ uint16(xArg1),
	/*10945*/ uint16(xMatch),
	/*10946*/ uint16(xCondDataSize), 10936, 10941, 10950,
	/*10950*/ uint16(xSetOp), uint16(SAR),
	/*10952*/ uint16(xArgRM64),
	/*10953*/ uint16(xArg1),
	/*10954*/ uint16(xMatch),
	/*10955*/ uint16(xCondSlashR),
	10964, // 0
	10969, // 1
	10974, // 2
	10979, // 3
	10984, // 4
	10989, // 5
	0,     // 6
	10994, // 7
	/*10964*/ uint16(xSetOp), uint16(ROL),
	/*10966*/ uint16(xArgRM8),
	/*10967*/ uint16(xArgCL),
	/*10968*/ uint16(xMatch),
	/*10969*/ uint16(xSetOp), uint16(ROR),
	/*10971*/ uint16(xArgRM8),
	/*10972*/ uint16(xArgCL),
	/*10973*/ uint16(xMatch),
	/*10974*/ uint16(xSetOp), uint16(RCL),
	/*10976*/ uint16(xArgRM8),
	/*10977*/ uint16(xArgCL),
	/*10978*/ uint16(xMatch),
	/*10979*/ uint16(xSetOp), uint16(RCR),
	/*10981*/ uint16(xArgRM8),
	/*10982*/ uint16(xArgCL),
	/*10983*/ uint16(xMatch),
	/*10984*/ uint16(xSetOp), uint16(SHL),
	/*10986*/ uint16(xArgRM8),
	/*10987*/ uint16(xArgCL),
	/*10988*/ uint16(xMatch),
	/*10989*/ uint16(xSetOp), uint16(SHR),
	/*10991*/ uint16(xArgRM8),
	/*10992*/ uint16(xArgCL),
	/*10993*/ uint16(xMatch),
	/*10994*/ uint16(xSetOp), uint16(SAR),
	/*10996*/ uint16(xArgRM8),
	/*10997*/ uint16(xArgCL),
	/*10998*/ uint16(xMatch),
	/*10999*/ uint16(xCondSlashR),
	11008, // 0
	11034, // 1
	11060, // 2
	11086, // 3
	11112, // 4
	11138, // 5
	0,     // 6
	11164, // 7
	/*11008*/ uint16(xCondIs64), 11011, 11025,
	/*11011*/ uint16(xCondDataSize), 11015, 11020, 0,
	/*11015*/ uint16(xSetOp), uint16(ROL),
	/*11017*/ uint16(xArgRM16),
	/*11018*/ uint16(xArgCL),
	/*11019*/ uint16(xMatch),
	/*11020*/ uint16(xSetOp), uint16(ROL),
	/*11022*/ uint16(xArgRM32),
	/*11023*/ uint16(xArgCL),
	/*11024*/ uint16(xMatch),
	/*11025*/ uint16(xCondDataSize), 11015, 11020, 11029,
	/*11029*/ uint16(xSetOp), uint16(ROL),
	/*11031*/ uint16(xArgRM64),
	/*11032*/ uint16(xArgCL),
	/*11033*/ uint16(xMatch),
	/*11034*/ uint16(xCondIs64), 11037, 11051,
	/*11037*/ uint16(xCondDataSize), 11041, 11046, 0,
	/*11041*/ uint16(xSetOp), uint16(ROR),
	/*11043*/ uint16(xArgRM16),
	/*11044*/ uint16(xArgCL),
	/*11045*/ uint16(xMatch),
	/*11046*/ uint16(xSetOp), uint16(ROR),
	/*11048*/ uint16(xArgRM32),
	/*11049*/ uint16(xArgCL),
	/*11050*/ uint16(xMatch),
	/*11051*/ uint16(xCondDataSize), 11041, 11046, 11055,
	/*11055*/ uint16(xSetOp), uint16(ROR),
	/*11057*/ uint16(xArgRM64),
	/*11058*/ uint16(xArgCL),
	/*11059*/ uint16(xMatch),
	/*11060*/ uint16(xCondIs64), 11063, 11077,
	/*11063*/ uint16(xCondDataSize), 11067, 11072, 0,
	/*11067*/ uint16(xSetOp), uint16(RCL),
	/*11069*/ uint16(xArgRM16),
	/*11070*/ uint16(xArgCL),
	/*11071*/ uint16(xMatch),
	/*11072*/ uint16(xSetOp), uint16(RCL),
	/*11074*/ uint16(xArgRM32),
	/*11075*/ uint16(xArgCL),
	/*11076*/ uint16(xMatch),
	/*11077*/ uint16(xCondDataSize), 11067, 11072, 11081,
	/*11081*/ uint16(xSetOp), uint16(RCL),
	/*11083*/ uint16(xArgRM64),
	/*11084*/ uint16(xArgCL),
	/*11085*/ uint16(xMatch),
	/*11086*/ uint16(xCondIs64), 11089, 11103,
	/*11089*/ uint16(xCondDataSize), 11093, 11098, 0,
	/*11093*/ uint16(xSetOp), uint16(RCR),
	/*11095*/ uint16(xArgRM16),
	/*11096*/ uint16(xArgCL),
	/*11097*/ uint16(xMatch),
	/*11098*/ uint16(xSetOp), uint16(RCR),
	/*11100*/ uint16(xArgRM32),
	/*11101*/ uint16(xArgCL),
	/*11102*/ uint16(xMatch),
	/*11103*/ uint16(xCondDataSize), 11093, 11098, 11107,
	/*11107*/ uint16(xSetOp), uint16(RCR),
	/*11109*/ uint16(xArgRM64),
	/*11110*/ uint16(xArgCL),
	/*11111*/ uint16(xMatch),
	/*11112*/ uint16(xCondIs64), 11115, 11129,
	/*11115*/ uint16(xCondDataSize), 11119, 11124, 0,
	/*11119*/ uint16(xSetOp), uint16(SHL),
	/*11121*/ uint16(xArgRM16),
	/*11122*/ uint16(xArgCL),
	/*11123*/ uint16(xMatch),
	/*11124*/ uint16(xSetOp), uint16(SHL),
	/*11126*/ uint16(xArgRM32),
	/*11127*/ uint16(xArgCL),
	/*11128*/ uint16(xMatch),
	/*11129*/ uint16(xCondDataSize), 11119, 11124, 11133,
	/*11133*/ uint16(xSetOp), uint16(SHL),
	/*11135*/ uint16(xArgRM64),
	/*11136*/ uint16(xArgCL),
	/*11137*/ uint16(xMatch),
	/*11138*/ uint16(xCondIs64), 11141, 11155,
	/*11141*/ uint16(xCondDataSize), 11145, 11150, 0,
	/*11145*/ uint16(xSetOp), uint16(SHR),
	/*11147*/ uint16(xArgRM16),
	/*11148*/ uint16(xArgCL),
	/*11149*/ uint16(xMatch),
	/*11150*/ uint16(xSetOp), uint16(SHR),
	/*11152*/ uint16(xArgRM32),
	/*11153*/ uint16(xArgCL),
	/*11154*/ uint16(xMatch),
	/*11155*/ uint16(xCondDataSize), 11145, 11150, 11159,
	/*11159*/ uint16(xSetOp), uint16(SHR),
	/*11161*/ uint16(xArgRM64),
	/*11162*/ uint16(xArgCL),
	/*11163*/ uint16(xMatch),
	/*11164*/ uint16(xCondIs64), 11167, 11181,
	/*11167*/ uint16(xCondDataSize), 11171, 11176, 0,
	/*11171*/ uint16(xSetOp), uint16(SAR),
	/*11173*/ uint16(xArgRM16),
	/*11174*/ uint16(xArgCL),
	/*11175*/ uint16(xMatch),
	/*11176*/ uint16(xSetOp), uint16(SAR),
	/*11178*/ uint16(xArgRM32),
	/*11179*/ uint16(xArgCL),
	/*11180*/ uint16(xMatch),
	/*11181*/ uint16(xCondDataSize), 11171, 11176, 11185,
	/*11185*/ uint16(xSetOp), uint16(SAR),
	/*11187*/ uint16(xArgRM64),
	/*11188*/ uint16(xArgCL),
	/*11189*/ uint16(xMatch),
	/*11190*/ uint16(xCondIs64), 11193, 0,
	/*11193*/ uint16(xSetOp), uint16(AAM),
	/*11195*/ uint16(xReadIb),
	/*11196*/ uint16(xArgImm8u),
	/*11197*/ uint16(xMatch),
	/*11198*/ uint16(xCondIs64), 11201, 0,
	/*11201*/ uint16(xSetOp), uint16(AAD),
	/*11203*/ uint16(xReadIb),
	/*11204*/ uint16(xArgImm8u),
	/*11205*/ uint16(xMatch),
	/*11206*/ uint16(xCondIs64), 11209, 11212,
	/*11209*/ uint16(xSetOp), uint16(XLATB),
	/*11211*/ uint16(xMatch),
	/*11212*/ uint16(xCondDataSize), 11209, 11209, 11216,
	/*11216*/ uint16(xSetOp), uint16(XLATB),
	/*11218*/ uint16(xMatch),
	/*11219*/ uint16(xCondByte), 64,
	0xc0, 11390,
	0xc1, 11390,
	0xc2, 11390,
	0xc3, 11390,
	0xc4, 11390,
	0xc5, 11390,
	0xc6, 11390,
	0xc7, 11390,
	0xc8, 11395,
	0xc9, 11395,
	0xca, 11395,
	0xcb, 11395,
	0xcc, 11395,
	0xcd, 11395,
	0xce, 11395,
	0xcf, 11395,
	0xd0, 11400,
	0xd1, 11400,
	0xd2, 11400,
	0xd3, 11400,
	0xd4, 11400,
	0xd5, 11400,
	0xd6, 11400,
	0xd7, 11400,
	0xd8, 11404,
	0xd9, 11404,
	0xda, 11404,
	0xdb, 11404,
	0xdc, 11404,
	0xdd, 11404,
	0xde, 11404,
	0xdf, 11404,
	0xe0, 11408,
	0xe1, 11408,
	0xe2, 11408,
	0xe3, 11408,
	0xe4, 11408,
	0xe5, 11408,
	0xe6, 11408,
	0xe7, 11408,
	0xe8, 11413,
	0xe9, 11413,
	0xea, 11413,
	0xeb, 11413,
	0xec, 11413,
	0xed, 11413,
	0xee, 11413,
	0xef, 11413,
	0xf0, 11418,
	0xf1, 11418,
	0xf2, 11418,
	0xf3, 11418,
	0xf4, 11418,
	0xf5, 11418,
	0xf6, 11418,
	0xf7, 11418,
	0xf8, 11423,
	0xf9, 11423,
	0xfa, 11423,
	0xfb, 11423,
	0xfc, 11423,
	0xfd, 11423,
	0xfe, 11423,
	0xff, 11423,
	/*11349*/ uint16(xCondSlashR),
	11358, // 0
	11362, // 1
	11366, // 2
	11370, // 3
	11374, // 4
	11378, // 5
	11382, // 6
	11386, // 7
	/*11358*/ uint16(xSetOp), uint16(FADD),
	/*11360*/ uint16(xArgM32fp),
	/*11361*/ uint16(xMatch),
	/*11362*/ uint16(xSetOp), uint16(FMUL),
	/*11364*/ uint16(xArgM32fp),
	/*11365*/ uint16(xMatch),
	/*11366*/ uint16(xSetOp), uint16(FCOM),
	/*11368*/ uint16(xArgM32fp),
	/*11369*/ uint16(xMatch),
	/*11370*/ uint16(xSetOp), uint16(FCOMP),
	/*11372*/ uint16(xArgM32fp),
	/*11373*/ uint16(xMatch),
	/*11374*/ uint16(xSetOp), uint16(FSUB),
	/*11376*/ uint16(xArgM32fp),
	/*11377*/ uint16(xMatch),
	/*11378*/ uint16(xSetOp), uint16(FSUBR),
	/*11380*/ uint16(xArgM32fp),
	/*11381*/ uint16(xMatch),
	/*11382*/ uint16(xSetOp), uint16(FDIV),
	/*11384*/ uint16(xArgM32fp),
	/*11385*/ uint16(xMatch),
	/*11386*/ uint16(xSetOp), uint16(FDIVR),
	/*11388*/ uint16(xArgM32fp),
	/*11389*/ uint16(xMatch),
	/*11390*/ uint16(xSetOp), uint16(FADD),
	/*11392*/ uint16(xArgST),
	/*11393*/ uint16(xArgSTi),
	/*11394*/ uint16(xMatch),
	/*11395*/ uint16(xSetOp), uint16(FMUL),
	/*11397*/ uint16(xArgST),
	/*11398*/ uint16(xArgSTi),
	/*11399*/ uint16(xMatch),
	/*11400*/ uint16(xSetOp), uint16(FCOM),
	/*11402*/ uint16(xArgSTi),
	/*11403*/ uint16(xMatch),
	/*11404*/ uint16(xSetOp), uint16(FCOMP),
	/*11406*/ uint16(xArgSTi),
	/*11407*/ uint16(xMatch),
	/*11408*/ uint16(xSetOp), uint16(FSUB),
	/*11410*/ uint16(xArgST),
	/*11411*/ uint16(xArgSTi),
	/*11412*/ uint16(xMatch),
	/*11413*/ uint16(xSetOp), uint16(FSUBR),
	/*11415*/ uint16(xArgST),
	/*11416*/ uint16(xArgSTi),
	/*11417*/ uint16(xMatch),
	/*11418*/ uint16(xSetOp), uint16(FDIV),
	/*11420*/ uint16(xArgST),
	/*11421*/ uint16(xArgSTi),
	/*11422*/ uint16(xMatch),
	/*11423*/ uint16(xSetOp), uint16(FDIVR),
	/*11425*/ uint16(xArgST),
	/*11426*/ uint16(xArgSTi),
	/*11427*/ uint16(xMatch),
	/*11428*/ uint16(xCondByte), 42,
	0xc0, 11551,
	0xc1, 11551,
	0xc2, 11551,
	0xc3, 11551,
	0xc4, 11551,
	0xc5, 11551,
	0xc6, 11551,
	0xc7, 11551,
	0xc8, 11555,
	0xc9, 11555,
	0xca, 11555,
	0xcb, 11555,
	0xcc, 11555,
	0xcd, 11555,
	0xce, 11555,
	0xcf, 11555,
	0xD0, 11559,
	0xE0, 11562,
	0xE1, 11565,
	0xE4, 11568,
	0xE5, 11571,
	0xE8, 11574,
	0xE9, 11577,
	0xEA, 11580,
	0xEB, 11583,
	0xEC, 11586,
	0xF0, 11589,
	0xF1, 11592,
	0xF2, 11595,
	0xF3, 11598,
	0xF4, 11601,
	0xF5, 11604,
	0xF6, 11607,
	0xF7, 11610,
	0xF8, 11613,
	0xF9, 11616,
	0xFA, 11619,
	0xFB, 11622,
	0xFC, 11625,
	0xFD, 11628,
	0xFE, 11631,
	0xFF, 11634,
	/*11514*/ uint16(xCondSlashR),
	11523, // 0
	0,     // 1
	11527, // 2
	11531, // 3
	11535, // 4
	11539, // 5
	11543, // 6
	11547, // 7
	/*11523*/ uint16(xSetOp), uint16(FLD),
	/*11525*/ uint16(xArgM32fp),
	/*11526*/ uint16(xMatch),
	/*11527*/ uint16(xSetOp), uint16(FST),
	/*11529*/ uint16(xArgM32fp),
	/*11530*/ uint16(xMatch),
	/*11531*/ uint16(xSetOp), uint16(FSTP),
	/*11533*/ uint16(xArgM32fp),
	/*11534*/ uint16(xMatch),
	/*11535*/ uint16(xSetOp), uint16(FLDENV),
	/*11537*/ uint16(xArgM1428byte),
	/*11538*/ uint16(xMatch),
	/*11539*/ uint16(xSetOp), uint16(FLDCW),
	/*11541*/ uint16(xArgM2byte),
	/*11542*/ uint16(xMatch),
	/*11543*/ uint16(xSetOp), uint16(FNSTENV),
	/*11545*/ uint16(xArgM1428byte),
	/*11546*/ uint16(xMatch),
	/*11547*/ uint16(xSetOp), uint16(FNSTCW),
	/*11549*/ uint16(xArgM2byte),
	/*11550*/ uint16(xMatch),
	/*11551*/ uint16(xSetOp), uint16(FLD),
	/*11553*/ uint16(xArgSTi),
	/*11554*/ uint16(xMatch),
	/*11555*/ uint16(xSetOp), uint16(FXCH),
	/*11557*/ uint16(xArgSTi),
	/*11558*/ uint16(xMatch),
	/*11559*/ uint16(xSetOp), uint16(FNOP),
	/*11561*/ uint16(xMatch),
	/*11562*/ uint16(xSetOp), uint16(FCHS),
	/*11564*/ uint16(xMatch),
	/*11565*/ uint16(xSetOp), uint16(FABS),
	/*11567*/ uint16(xMatch),
	/*11568*/ uint16(xSetOp), uint16(FTST),
	/*11570*/ uint16(xMatch),
	/*11571*/ uint16(xSetOp), uint16(FXAM),
	/*11573*/ uint16(xMatch),
	/*11574*/ uint16(xSetOp), uint16(FLD1),
	/*11576*/ uint16(xMatch),
	/*11577*/ uint16(xSetOp), uint16(FLDL2T),
	/*11579*/ uint16(xMatch),
	/*11580*/ uint16(xSetOp), uint16(FLDL2E),
	/*11582*/ uint16(xMatch),
	/*11583*/ uint16(xSetOp), uint16(FLDPI),
	/*11585*/ uint16(xMatch),
	/*11586*/ uint16(xSetOp), uint16(FLDLG2),
	/*11588*/ uint16(xMatch),
	/*11589*/ uint16(xSetOp), uint16(F2XM1),
	/*11591*/ uint16(xMatch),
	/*11592*/ uint16(xSetOp), uint16(FYL2X),
	/*11594*/ uint16(xMatch),
	/*11595*/ uint16(xSetOp), uint16(FPTAN),
	/*11597*/ uint16(xMatch),
	/*11598*/ uint16(xSetOp), uint16(FPATAN),
	/*11600*/ uint16(xMatch),
	/*11601*/ uint16(xSetOp), uint16(FXTRACT),
	/*11603*/ uint16(xMatch),
	/*11604*/ uint16(xSetOp), uint16(FPREM1),
	/*11606*/ uint16(xMatch),
	/*11607*/ uint16(xSetOp), uint16(FDECSTP),
	/*11609*/ uint16(xMatch),
	/*11610*/ uint16(xSetOp), uint16(FINCSTP),
	/*11612*/ uint16(xMatch),
	/*11613*/ uint16(xSetOp), uint16(FPREM),
	/*11615*/ uint16(xMatch),
	/*11616*/ uint16(xSetOp), uint16(FYL2XP1),
	/*11618*/ uint16(xMatch),
	/*11619*/ uint16(xSetOp), uint16(FSQRT),
	/*11621*/ uint16(xMatch),
	/*11622*/ uint16(xSetOp), uint16(FSINCOS),
	/*11624*/ uint16(xMatch),
	/*11625*/ uint16(xSetOp), uint16(FRNDINT),
	/*11627*/ uint16(xMatch),
	/*11628*/ uint16(xSetOp), uint16(FSCALE),
	/*11630*/ uint16(xMatch),
	/*11631*/ uint16(xSetOp), uint16(FSIN),
	/*11633*/ uint16(xMatch),
	/*11634*/ uint16(xSetOp), uint16(FCOS),
	/*11636*/ uint16(xMatch),
	/*11637*/ uint16(xCondByte), 33,
	0xc0, 11746,
	0xc1, 11746,
	0xc2, 11746,
	0xc3, 11746,
	0xc4, 11746,
	0xc5, 11746,
	0xc6, 11746,
	0xc7, 11746,
	0xc8, 11751,
	0xc9, 11751,
	0xca, 11751,
	0xcb, 11751,
	0xcc, 11751,
	0xcd, 11751,
	0xce, 11751,
	0xcf, 11751,
	0xd0, 11756,
	0xd1, 11756,
	0xd2, 11756,
	0xd3, 11756,
	0xd4, 11756,
	0xd5, 11756,
	0xd6, 11756,
	0xd7, 11756,
	0xd8, 11761,
	0xd9, 11761,
	0xda, 11761,
	0xdb, 11761,
	0xdc, 11761,
	0xdd, 11761,
	0xde, 11761,
	0xdf, 11761,
	0xE9, 11766,
	/*11705*/ uint16(xCondSlashR),
	11714, // 0
	11718, // 1
	11722, // 2
	11726, // 3
	11730, // 4
	11734, // 5
	11738, // 6
	11742, // 7
	/*11714*/ uint16(xSetOp), uint16(FIADD),
	/*11716*/ uint16(xArgM32int),
	/*11717*/ uint16(xMatch),
	/*11718*/ uint16(xSetOp), uint16(FIMUL),
	/*11720*/ uint16(xArgM32int),
	/*11721*/ uint16(xMatch),
	/*11722*/ uint16(xSetOp), uint16(FICOM),
	/*11724*/ uint16(xArgM32int),
	/*11725*/ uint16(xMatch),
	/*11726*/ uint16(xSetOp), uint16(FICOMP),
	/*11728*/ uint16(xArgM32int),
	/*11729*/ uint16(xMatch),
	/*11730*/ uint16(xSetOp), uint16(FISUB),
	/*11732*/ uint16(xArgM32int),
	/*11733*/ uint16(xMatch),
	/*11734*/ uint16(xSetOp), uint16(FISUBR),
	/*11736*/ uint16(xArgM32int),
	/*11737*/ uint16(xMatch),
	/*11738*/ uint16(xSetOp), uint16(FIDIV),
	/*11740*/ uint16(xArgM32int),
	/*11741*/ uint16(xMatch),
	/*11742*/ uint16(xSetOp), uint16(FIDIVR),
	/*11744*/ uint16(xArgM32int),
	/*11745*/ uint16(xMatch),
	/*11746*/ uint16(xSetOp), uint16(FCMOVB),
	/*11748*/ uint16(xArgST),
	/*11749*/ uint16(xArgSTi),
	/*11750*/ uint16(xMatch),
	/*11751*/ uint16(xSetOp), uint16(FCMOVE),
	/*11753*/ uint16(xArgST),
	/*11754*/ uint16(xArgSTi),
	/*11755*/ uint16(xMatch),
	/*11756*/ uint16(xSetOp), uint16(FCMOVBE),
	/*11758*/ uint16(xArgST),
	/*11759*/ uint16(xArgSTi),
	/*11760*/ uint16(xMatch),
	/*11761*/ uint16(xSetOp), uint16(FCMOVU),
	/*11763*/ uint16(xArgST),
	/*11764*/ uint16(xArgSTi),
	/*11765*/ uint16(xMatch),
	/*11766*/ uint16(xSetOp), uint16(FUCOMPP),
	/*11768*/ uint16(xMatch),
	/*11769*/ uint16(xCondByte), 50,
	0xc0, 11904,
	0xc1, 11904,
	0xc2, 11904,
	0xc3, 11904,
	0xc4, 11904,
	0xc5, 11904,
	0xc6, 11904,
	0xc7, 11904,
	0xc8, 11909,
	0xc9, 11909,
	0xca, 11909,
	0xcb, 11909,
	0xcc, 11909,
	0xcd, 11909,
	0xce, 11909,
	0xcf, 11909,
	0xd0, 11914,
	0xd1, 11914,
	0xd2, 11914,
	0xd3, 11914,
	0xd4, 11914,
	0xd5, 11914,
	0xd6, 11914,
	0xd7, 11914,
	0xd8, 11919,
	0xd9, 11919,
	0xda, 11919,
	0xdb, 11919,
	0xdc, 11919,
	0xdd, 11919,
	0xde, 11919,
	0xdf, 11919,
	0xE2, 11924,
	0xE3, 11927,
	0xe8, 11930,
	0xe9, 11930,
	0xea, 11930,
	0xeb, 11930,
	0xec, 11930,
	0xed, 11930,
	0xee, 11930,
	0xef, 11930,
	0xf0, 11935,
	0xf1, 11935,
	0xf2, 11935,
	0xf3, 11935,
	0xf4, 11935,
	0xf5, 11935,
	0xf6, 11935,
	0xf7, 11935,
	/*11871*/ uint16(xCondSlashR),
	11880, // 0
	11884, // 1
	11888, // 2
	11892, // 3
	0,     // 4
	11896, // 5
	0,     // 6
	11900, // 7
	/*11880*/ uint16(xSetOp), uint16(FILD),
	/*11882*/ uint16(xArgM32int),
	/*11883*/ uint16(xMatch),
	/*11884*/ uint16(xSetOp), uint16(FISTTP),
	/*11886*/ uint16(xArgM32int),
	/*11887*/ uint16(xMatch),
	/*11888*/ uint16(xSetOp), uint16(FIST),
	/*11890*/ uint16(xArgM32int),
	/*11891*/ uint16(xMatch),
	/*11892*/ uint16(xSetOp), uint16(FISTP),
	/*11894*/ uint16(xArgM32int),
	/*11895*/ uint16(xMatch),
	/*11896*/ uint16(xSetOp), uint16(FLD),
	/*11898*/ uint16(xArgM80fp),
	/*11899*/ uint16(xMatch),
	/*11900*/ uint16(xSetOp), uint16(FSTP),
	/*11902*/ uint16(xArgM80fp),
	/*11903*/ uint16(xMatch),
	/*11904*/ uint16(xSetOp), uint16(FCMOVNB),
	/*11906*/ uint16(xArgST),
	/*11907*/ uint16(xArgSTi),
	/*11908*/ uint16(xMatch),
	/*11909*/ uint16(xSetOp), uint16(FCMOVNE),
	/*11911*/ uint16(xArgST),
	/*11912*/ uint16(xArgSTi),
	/*11913*/ uint16(xMatch),
	/*11914*/ uint16(xSetOp), uint16(FCMOVNBE),
	/*11916*/ uint16(xArgST),
	/*11917*/ uint16(xArgSTi),
	/*11918*/ uint16(xMatch),
	/*11919*/ uint16(xSetOp), uint16(FCMOVNU),
	/*11921*/ uint16(xArgST),
	/*11922*/ uint16(xArgSTi),
	/*11923*/ uint16(xMatch),
	/*11924*/ uint16(xSetOp), uint16(FNCLEX),
	/*11926*/ uint16(xMatch),
	/*11927*/ uint16(xSetOp), uint16(FNINIT),
	/*11929*/ uint16(xMatch),
	/*11930*/ uint16(xSetOp), uint16(FUCOMI),
	/*11932*/ uint16(xArgST),
	/*11933*/ uint16(xArgSTi),
	/*11934*/ uint16(xMatch),
	/*11935*/ uint16(xSetOp), uint16(FCOMI),
	/*11937*/ uint16(xArgST),
	/*11938*/ uint16(xArgSTi),
	/*11939*/ uint16(xMatch),
	/*11940*/ uint16(xCondByte), 48,
	0xc0, 12079,
	0xc1, 12079,
	0xc2, 12079,
	0xc3, 12079,
	0xc4, 12079,
	0xc5, 12079,
	0xc6, 12079,
	0xc7, 12079,
	0xc8, 12084,
	0xc9, 12084,
	0xca, 12084,
	0xcb, 12084,
	0xcc, 12084,
	0xcd, 12084,
	0xce, 12084,
	0xcf, 12084,
	0xe0, 12089,
	0xe1, 12089,
	0xe2, 12089,
	0xe3, 12089,
	0xe4, 12089,
	0xe5, 12089,
	0xe6, 12089,
	0xe7, 12089,
	0xe8, 12094,
	0xe9, 12094,
	0xea, 12094,
	0xeb, 12094,
	0xec, 12094,
	0xed, 12094,
	0xee, 12094,
	0xef, 12094,
	0xf0, 12099,
	0xf1, 12099,
	0xf2, 12099,
	0xf3, 12099,
	0xf4, 12099,
	0xf5, 12099,
	0xf6, 12099,
	0xf7, 12099,
	0xf8, 12104,
	0xf9, 12104,
	0xfa, 12104,
	0xfb, 12104,
	0xfc, 12104,
	0xfd, 12104,
	0xfe, 12104,
	0xff, 12104,
	/*12038*/ uint16(xCondSlashR),
	12047, // 0
	12051, // 1
	12055, // 2
	12059, // 3
	12063, // 4
	12067, // 5
	12071, // 6
	12075, // 7
	/*12047*/ uint16(xSetOp), uint16(FADD),
	/*12049*/ uint16(xArgM64fp),
	/*12050*/ uint16(xMatch),
	/*12051*/ uint16(xSetOp), uint16(FMUL),
	/*12053*/ uint16(xArgM64fp),
	/*12054*/ uint16(xMatch),
	/*12055*/ uint16(xSetOp), uint16(FCOM),
	/*12057*/ uint16(xArgM64fp),
	/*12058*/ uint16(xMatch),
	/*12059*/ uint16(xSetOp), uint16(FCOMP),
	/*12061*/ uint16(xArgM64fp),
	/*12062*/ uint16(xMatch),
	/*12063*/ uint16(xSetOp), uint16(FSUB),
	/*12065*/ uint16(xArgM64fp),
	/*12066*/ uint16(xMatch),
	/*12067*/ uint16(xSetOp), uint16(FSUBR),
	/*12069*/ uint16(xArgM64fp),
	/*12070*/ uint16(xMatch),
	/*12071*/ uint16(xSetOp), uint16(FDIV),
	/*12073*/ uint16(xArgM64fp),
	/*12074*/ uint16(xMatch),
	/*12075*/ uint16(xSetOp), uint16(FDIVR),
	/*12077*/ uint16(xArgM64fp),
	/*12078*/ uint16(xMatch),
	/*12079*/ uint16(xSetOp), uint16(FADD),
	/*12081*/ uint16(xArgSTi),
	/*12082*/ uint16(xArgST),
	/*12083*/ uint16(xMatch),
	/*12084*/ uint16(xSetOp), uint16(FMUL),
	/*12086*/ uint16(xArgSTi),
	/*12087*/ uint16(xArgST),
	/*12088*/ uint16(xMatch),
	/*12089*/ uint16(xSetOp), uint16(FSUBR),
	/*12091*/ uint16(xArgSTi),
	/*12092*/ uint16(xArgST),
	/*12093*/ uint16(xMatch),
	/*12094*/ uint16(xSetOp), uint16(FSUB),
	/*12096*/ uint16(xArgSTi),
	/*12097*/ uint16(xArgST),
	/*12098*/ uint16(xMatch),
	/*12099*/ uint16(xSetOp), uint16(FDIVR),
	/*12101*/ uint16(xArgSTi),
	/*12102*/ uint16(xArgST),
	/*12103*/ uint16(xMatch),
	/*12104*/ uint16(xSetOp), uint16(FDIV),
	/*12106*/ uint16(xArgSTi),
	/*12107*/ uint16(xArgST),
	/*12108*/ uint16(xMatch),
	/*12109*/ uint16(xCondByte), 40,
	0xc0, 12228,
	0xc1, 12228,
	0xc2, 12228,
	0xc3, 12228,
	0xc4, 12228,
	0xc5, 12228,
	0xc6, 12228,
	0xc7, 12228,
	0xd0, 12232,
	0xd1, 12232,
	0xd2, 12232,
	0xd3, 12232,
	0xd4, 12232,
	0xd5, 12232,
	0xd6, 12232,
	0xd7, 12232,
	0xd8, 12236,
	0xd9, 12236,
	0xda, 12236,
	0xdb, 12236,
	0xdc, 12236,
	0xdd, 12236,
	0xde, 12236,
	0xdf, 12236,
	0xe0, 12240,
	0xe1, 12240,
	0xe2, 12240,
	0xe3, 12240,
	0xe4, 12240,
	0xe5, 12240,
	0xe6, 12240,
	0xe7, 12240,
	0xe8, 12244,
	0xe9, 12244,
	0xea, 12244,
	0xeb, 12244,
	0xec, 12244,
	0xed, 12244,
	0xee, 12244,
	0xef, 12244,
	/*12191*/ uint16(xCondSlashR),
	12200, // 0
	12204, // 1
	12208, // 2
	12212, // 3
	12216, // 4
	0,     // 5
	12220, // 6
	12224, // 7
	/*12200*/ uint16(xSetOp), uint16(FLD),
	/*12202*/ uint16(xArgM64fp),
	/*12203*/ uint16(xMatch),
	/*12204*/ uint16(xSetOp), uint16(FISTTP),
	/*12206*/ uint16(xArgM64int),
	/*12207*/ uint16(xMatch),
	/*12208*/ uint16(xSetOp), uint16(FST),
	/*12210*/ uint16(xArgM64fp),
	/*12211*/ uint16(xMatch),
	/*12212*/ uint16(xSetOp), uint16(FSTP),
	/*12214*/ uint16(xArgM64fp),
	/*12215*/ uint16(xMatch),
	/*12216*/ uint16(xSetOp), uint16(FRSTOR),
	/*12218*/ uint16(xArgM94108byte),
	/*12219*/ uint16(xMatch),
	/*12220*/ uint16(xSetOp), uint16(FNSAVE),
	/*12222*/ uint16(xArgM94108byte),
	/*12223*/ uint16(xMatch),
	/*12224*/ uint16(xSetOp), uint16(FNSTSW),
	/*12226*/ uint16(xArgM2byte),
	/*12227*/ uint16(xMatch),
	/*12228*/ uint16(xSetOp), uint16(FFREE),
	/*12230*/ uint16(xArgSTi),
	/*12231*/ uint16(xMatch),
	/*12232*/ uint16(xSetOp), uint16(FST),
	/*12234*/ uint16(xArgSTi),
	/*12235*/ uint16(xMatch),
	/*12236*/ uint16(xSetOp), uint16(FSTP),
	/*12238*/ uint16(xArgSTi),
	/*12239*/ uint16(xMatch),
	/*12240*/ uint16(xSetOp), uint16(FUCOM),
	/*12242*/ uint16(xArgSTi),
	/*12243*/ uint16(xMatch),
	/*12244*/ uint16(xSetOp), uint16(FUCOMP),
	/*12246*/ uint16(xArgSTi),
	/*12247*/ uint16(xMatch),
	/*12248*/ uint16(xCondByte), 49,
	0xc0, 12389,
	0xc1, 12389,
	0xc2, 12389,
	0xc3, 12389,
	0xc4, 12389,
	0xc5, 12389,
	0xc6, 12389,
	0xc7, 12389,
	0xc8, 12394,
	0xc9, 12394,
	0xca, 12394,
	0xcb, 12394,
	0xcc, 12394,
	0xcd, 12394,
	0xce, 12394,
	0xcf, 12394,
	0xD9, 12399,
	0xe0, 12402,
	0xe1, 12402,
	0xe2, 12402,
	0xe3, 12402,
	0xe4, 12402,
	0xe5, 12402,
	0xe6, 12402,
	0xe7, 12402,
	0xe8, 12407,
	0xe9, 12407,
	0xea, 12407,
	0xeb, 12407,
	0xec, 12407,
	0xed, 12407,
	0xee, 12407,
	0xef, 12407,
	0xf0, 12412,
	0xf1, 12412,
	0xf2, 12412,
	0xf3, 12412,
	0xf4, 12412,
	0xf5, 12412,
	0xf6, 12412,
	0xf7, 12412,
	0xf8, 12417,
	0xf9, 12417,
	0xfa, 12417,
	0xfb, 12417,
	0xfc, 12417,
	0xfd, 12417,
	0xfe, 12417,
	0xff, 12417,
	/*12348*/ uint16(xCondSlashR),
	12357, // 0
	12361, // 1
	12365, // 2
	12369, // 3
	12373, // 4
	12377, // 5
	12381, // 6
	12385, // 7
	/*12357*/ uint16(xSetOp), uint16(FIADD),
	/*12359*/ uint16(xArgM16int),
	/*12360*/ uint16(xMatch),
	/*12361*/ uint16(xSetOp), uint16(FIMUL),
	/*12363*/ uint16(xArgM16int),
	/*12364*/ uint16(xMatch),
	/*12365*/ uint16(xSetOp), uint16(FICOM),
	/*12367*/ uint16(xArgM16int),
	/*12368*/ uint16(xMatch),
	/*12369*/ uint16(xSetOp), uint16(FICOMP),
	/*12371*/ uint16(xArgM16int),
	/*12372*/ uint16(xMatch),
	/*12373*/ uint16(xSetOp), uint16(FISUB),
	/*12375*/ uint16(xArgM16int),
	/*12376*/ uint16(xMatch),
	/*12377*/ uint16(xSetOp), uint16(FISUBR),
	/*12379*/ uint16(xArgM16int),
	/*12380*/ uint16(xMatch),
	/*12381*/ uint16(xSetOp), uint16(FIDIV),
	/*12383*/ uint16(xArgM16int),
	/*12384*/ uint16(xMatch),
	/*12385*/ uint16(xSetOp), uint16(FIDIVR),
	/*12387*/ uint16(xArgM16int),
	/*12388*/ uint16(xMatch),
	/*12389*/ uint16(xSetOp), uint16(FADDP),
	/*12391*/ uint16(xArgSTi),
	/*12392*/ uint16(xArgST),
	/*12393*/ uint16(xMatch),
	/*12394*/ uint16(xSetOp), uint16(FMULP),
	/*12396*/ uint16(xArgSTi),
	/*12397*/ uint16(xArgST),
	/*12398*/ uint16(xMatch),
	/*12399*/ uint16(xSetOp), uint16(FCOMPP),
	/*12401*/ uint16(xMatch),
	/*12402*/ uint16(xSetOp), uint16(FSUBRP),
	/*12404*/ uint16(xArgSTi),
	/*12405*/ uint16(xArgST),
	/*12406*/ uint16(xMatch),
	/*12407*/ uint16(xSetOp), uint16(FSUBP),
	/*12409*/ uint16(xArgSTi),
	/*12410*/ uint16(xArgST),
	/*12411*/ uint16(xMatch),
	/*12412*/ uint16(xSetOp), uint16(FDIVRP),
	/*12414*/ uint16(xArgSTi),
	/*12415*/ uint16(xArgST),
	/*12416*/ uint16(xMatch),
	/*12417*/ uint16(xSetOp), uint16(FDIVP),
	/*12419*/ uint16(xArgSTi),
	/*12420*/ uint16(xArgST),
	/*12421*/ uint16(xMatch),
	/*12422*/ uint16(xCondByte), 25,
	0xc0, 12515,
	0xc1, 12515,
	0xc2, 12515,
	0xc3, 12515,
	0xc4, 12515,
	0xc5, 12515,
	0xc6, 12515,
	0xc7, 12515,
	0xE0, 12519,
	0xe8, 12523,
	0xe9, 12523,
	0xea, 12523,
	0xeb, 12523,
	0xec, 12523,
	0xed, 12523,
	0xee, 12523,
	0xef, 12523,
	0xf0, 12528,
	0xf1, 12528,
	0xf2, 12528,
	0xf3, 12528,
	0xf4, 12528,
	0xf5, 12528,
	0xf6, 12528,
	0xf7, 12528,
	/*12474*/ uint16(xCondSlashR),
	12483, // 0
	12487, // 1
	12491, // 2
	12495, // 3
	12499, // 4
	12503, // 5
	12507, // 6
	12511, // 7
	/*12483*/ uint16(xSetOp), uint16(FILD),
	/*12485*/ uint16(xArgM16int),
	/*12486*/ uint16(xMatch),
	/*12487*/ uint16(xSetOp), uint16(FISTTP),
	/*12489*/ uint16(xArgM16int),
	/*12490*/ uint16(xMatch),
	/*12491*/ uint16(xSetOp), uint16(FIST),
	/*12493*/ uint16(xArgM16int),
	/*12494*/ uint16(xMatch),
	/*12495*/ uint16(xSetOp), uint16(FISTP),
	/*12497*/ uint16(xArgM16int),
	/*12498*/ uint16(xMatch),
	/*12499*/ uint16(xSetOp), uint16(FBLD),
	/*12501*/ uint16(xArgM80dec),
	/*12502*/ uint16(xMatch),
	/*12503*/ uint16(xSetOp), uint16(FILD),
	/*12505*/ uint16(xArgM64int),
	/*12506*/ uint16(xMatch),
	/*12507*/ uint16(xSetOp), uint16(FBSTP),
	/*12509*/ uint16(xArgM80bcd),
	/*12510*/ uint16(xMatch),
	/*12511*/ uint16(xSetOp), uint16(FISTP),
	/*12513*/ uint16(xArgM64int),
	/*12514*/ uint16(xMatch),
	/*12515*/ uint16(xSetOp), uint16(FFREEP),
	/*12517*/ uint16(xArgSTi),
	/*12518*/ uint16(xMatch),
	/*12519*/ uint16(xSetOp), uint16(FNSTSW),
	/*12521*/ uint16(xArgAX),
	/*12522*/ uint16(xMatch),
	/*12523*/ uint16(xSetOp), uint16(FUCOMIP),
	/*12525*/ uint16(xArgST),
	/*12526*/ uint16(xArgSTi),
	/*12527*/ uint16(xMatch),
	/*12528*/ uint16(xSetOp), uint16(FCOMIP),
	/*12530*/ uint16(xArgST),
	/*12531*/ uint16(xArgSTi),
	/*12532*/ uint16(xMatch),
	/*12533*/ uint16(xSetOp), uint16(LOOPNE),
	/*12535*/ uint16(xReadCb),
	/*12536*/ uint16(xArgRel8),
	/*12537*/ uint16(xMatch),
	/*12538*/ uint16(xSetOp), uint16(LOOPE),
	/*12540*/ uint16(xReadCb),
	/*12541*/ uint16(xArgRel8),
	/*12542*/ uint16(xMatch),
	/*12543*/ uint16(xSetOp), uint16(LOOP),
	/*12545*/ uint16(xReadCb),
	/*12546*/ uint16(xArgRel8),
	/*12547*/ uint16(xMatch),
	/*12548*/ uint16(xCondIs64), 12551, 12565,
	/*12551*/ uint16(xCondAddrSize), 12555, 12560, 0,
	/*12555*/ uint16(xSetOp), uint16(JCXZ),
	/*12557*/ uint16(xReadCb),
	/*12558*/ uint16(xArgRel8),
	/*12559*/ uint16(xMatch),
	/*12560*/ uint16(xSetOp), uint16(JECXZ),
	/*12562*/ uint16(xReadCb),
	/*12563*/ uint16(xArgRel8),
	/*12564*/ uint16(xMatch),
	/*12565*/ uint16(xCondAddrSize), 0, 12560, 12569,
	/*12569*/ uint16(xSetOp), uint16(JRCXZ),
	/*12571*/ uint16(xReadCb),
	/*12572*/ uint16(xArgRel8),
	/*12573*/ uint16(xMatch),
	/*12574*/ uint16(xSetOp), uint16(IN),
	/*12576*/ uint16(xReadIb),
	/*12577*/ uint16(xArgAL),
	/*12578*/ uint16(xArgImm8u),
	/*12579*/ uint16(xMatch),
	/*12580*/ uint16(xCondDataSize), 12584, 12590, 12596,
	/*12584*/ uint16(xSetOp), uint16(IN),
	/*12586*/ uint16(xReadIb),
	/*12587*/ uint16(xArgAX),
	/*12588*/ uint16(xArgImm8u),
	/*12589*/ uint16(xMatch),
	/*12590*/ uint16(xSetOp), uint16(IN),
	/*12592*/ uint16(xReadIb),
	/*12593*/ uint16(xArgEAX),
	/*12594*/ uint16(xArgImm8u),
	/*12595*/ uint16(xMatch),
	/*12596*/ uint16(xSetOp), uint16(IN),
	/*12598*/ uint16(xReadIb),
	/*12599*/ uint16(xArgEAX),
	/*12600*/ uint16(xArgImm8u),
	/*12601*/ uint16(xMatch),
	/*12602*/ uint16(xSetOp), uint16(OUT),
	/*12604*/ uint16(xReadIb),
	/*12605*/ uint16(xArgImm8u),
	/*12606*/ uint16(xArgAL),
	/*12607*/ uint16(xMatch),
	/*12608*/ uint16(xCondDataSize), 12612, 12618, 12624,
	/*12612*/ uint16(xSetOp), uint16(OUT),
	/*12614*/ uint16(xReadIb),
	/*12615*/ uint16(xArgImm8u),
	/*12616*/ uint16(xArgAX),
	/*12617*/ uint16(xMatch),
	/*12618*/ uint16(xSetOp), uint16(OUT),
	/*12620*/ uint16(xReadIb),
	/*12621*/ uint16(xArgImm8u),
	/*12622*/ uint16(xArgEAX),
	/*12623*/ uint16(xMatch),
	/*12624*/ uint16(xSetOp), uint16(OUT),
	/*12626*/ uint16(xReadIb),
	/*12627*/ uint16(xArgImm8u),
	/*12628*/ uint16(xArgEAX),
	/*12629*/ uint16(xMatch),
	/*12630*/ uint16(xCondIs64), 12633, 12647,
	/*12633*/ uint16(xCondDataSize), 12637, 12642, 0,
	/*12637*/ uint16(xSetOp), uint16(CALL),
	/*12639*/ uint16(xReadCw),
	/*12640*/ uint16(xArgRel16),
	/*12641*/ uint16(xMatch),
	/*12642*/ uint16(xSetOp), uint16(CALL),
	/*12644*/ uint16(xReadCd),
	/*12645*/ uint16(xArgRel32),
	/*12646*/ uint16(xMatch),
	/*12647*/ uint16(xCondDataSize), 12651, 12642, 12656,
	/*12651*/ uint16(xSetOp), uint16(CALL),
	/*12653*/ uint16(xReadCd),
	/*12654*/ uint16(xArgRel32),
	/*12655*/ uint16(xMatch),
	/*12656*/ uint16(xSetOp), uint16(CALL),
	/*12658*/ uint16(xReadCd),
	/*12659*/ uint16(xArgRel32),
	/*12660*/ uint16(xMatch),
	/*12661*/ uint16(xCondIs64), 12664, 12678,
	/*12664*/ uint16(xCondDataSize), 12668, 12673, 0,
	/*12668*/ uint16(xSetOp), uint16(JMP),
	/*12670*/ uint16(xReadCw),
	/*12671*/ uint16(xArgRel16),
	/*12672*/ uint16(xMatch),
	/*12673*/ uint16(xSetOp), uint16(JMP),
	/*12675*/ uint16(xReadCd),
	/*12676*/ uint16(xArgRel32),
	/*12677*/ uint16(xMatch),
	/*12678*/ uint16(xCondDataSize), 12682, 12673, 12687,
	/*12682*/ uint16(xSetOp), uint16(JMP),
	/*12684*/ uint16(xReadCd),
	/*12685*/ uint16(xArgRel32),
	/*12686*/ uint16(xMatch),
	/*12687*/ uint16(xSetOp), uint16(JMP),
	/*12689*/ uint16(xReadCd),
	/*12690*/ uint16(xArgRel32),
	/*12691*/ uint16(xMatch),
	/*12692*/ uint16(xCondIs64), 12695, 0,
	/*12695*/ uint16(xCondDataSize), 12699, 12704, 0,
	/*12699*/ uint16(xSetOp), uint16(LJMP),
	/*12701*/ uint16(xReadCd),
	/*12702*/ uint16(xArgPtr16colon16),
	/*12703*/ uint16(xMatch),
	/*12704*/ uint16(xSetOp), uint16(LJMP),
	/*12706*/ uint16(xReadCp),
	/*12707*/ uint16(xArgPtr16colon32),
	/*12708*/ uint16(xMatch),
	/*12709*/ uint16(xSetOp), uint16(JMP),
	/*12711*/ uint16(xReadCb),
	/*12712*/ uint16(xArgRel8),
	/*12713*/ uint16(xMatch),
	/*12714*/ uint16(xSetOp), uint16(IN),
	/*12716*/ uint16(xArgAL),
	/*12717*/ uint16(xArgDX),
	/*12718*/ uint16(xMatch),
	/*12719*/ uint16(xCondDataSize), 12723, 12728, 12733,
	/*12723*/ uint16(xSetOp), uint16(IN),
	/*12725*/ uint16(xArgAX),
	/*12726*/ uint16(xArgDX),
	/*12727*/ uint16(xMatch),
	/*12728*/ uint16(xSetOp), uint16(IN),
	/*12730*/ uint16(xArgEAX),
	/*12731*/ uint16(xArgDX),
	/*12732*/ uint16(xMatch),
	/*12733*/ uint16(xSetOp), uint16(IN),
	/*12735*/ uint16(xArgEAX),
	/*12736*/ uint16(xArgDX),
	/*12737*/ uint16(xMatch),
	/*12738*/ uint16(xSetOp), uint16(OUT),
	/*12740*/ uint16(xArgDX),
	/*12741*/ uint16(xArgAL),
	/*12742*/ uint16(xMatch),
	/*12743*/ uint16(xCondDataSize), 12747, 12752, 12757,
	/*12747*/ uint16(xSetOp), uint16(OUT),
	/*12749*/ uint16(xArgDX),
	/*12750*/ uint16(xArgAX),
	/*12751*/ uint16(xMatch),
	/*12752*/ uint16(xSetOp), uint16(OUT),
	/*12754*/ uint16(xArgDX),
	/*12755*/ uint16(xArgEAX),
	/*12756*/ uint16(xMatch),
	/*12757*/ uint16(xSetOp), uint16(OUT),
	/*12759*/ uint16(xArgDX),
	/*12760*/ uint16(xArgEAX),
	/*12761*/ uint16(xMatch),
	/*12762*/ uint16(xSetOp), uint16(ICEBP),
	/*12764*/ uint16(xMatch),
	/*12765*/ uint16(xSetOp), uint16(HLT),
	/*12767*/ uint16(xMatch),
	/*12768*/ uint16(xSetOp), uint16(CMC),
	/*12770*/ uint16(xMatch),
	/*12771*/ uint16(xCondSlashR),
	12780, // 0
	0,     // 1
	12786, // 2
	12790, // 3
	12794, // 4
	12798, // 5
	12802, // 6
	12806, // 7
	/*12780*/ uint16(xSetOp), uint16(TEST),
	/*12782*/ uint16(xReadIb),
	/*12783*/ uint16(xArgRM8),
	/*12784*/ uint16(xArgImm8u),
	/*12785*/ uint16(xMatch),
	/*12786*/ uint16(xSetOp), uint16(NOT),
	/*12788*/ uint16(xArgRM8),
	/*12789*/ uint16(xMatch),
	/*12790*/ uint16(xSetOp), uint16(NEG),
	/*12792*/ uint16(xArgRM8),
	/*12793*/ uint16(xMatch),
	/*12794*/ uint16(xSetOp), uint16(MUL),
	/*12796*/ uint16(xArgRM8),
	/*12797*/ uint16(xMatch),
	/*12798*/ uint16(xSetOp), uint16(IMUL),
	/*12800*/ uint16(xArgRM8),
	/*12801*/ uint16(xMatch),
	/*12802*/ uint16(xSetOp), uint16(DIV),
	/*12804*/ uint16(xArgRM8),
	/*12805*/ uint16(xMatch),
	/*12806*/ uint16(xSetOp), uint16(IDIV),
	/*12808*/ uint16(xArgRM8),
	/*12809*/ uint16(xMatch),
	/*12810*/ uint16(xCondSlashR),
	12819, // 0
	0,     // 1
	12848, // 2
	12871, // 3
	12894, // 4
	12917, // 5
	12940, // 6
	12963, // 7
	/*12819*/ uint16(xCondIs64), 12822, 12838,
	/*12822*/ uint16(xCondDataSize), 12826, 12832, 0,
	/*12826*/ uint16(xSetOp), uint16(TEST),
	/*12828*/ uint16(xReadIw),
	/*12829*/ uint16(xArgRM16),
	/*12830*/ uint16(xArgImm16),
	/*12831*/ uint16(xMatch),
	/*12832*/ uint16(xSetOp), uint16(TEST),
	/*12834*/ uint16(xReadId),
	/*12835*/ uint16(xArgRM32),
	/*12836*/ uint16(xArgImm32),
	/*12837*/ uint16(xMatch),
	/*12838*/ uint16(xCondDataSize), 12826, 12832, 12842,
	/*12842*/ uint16(xSetOp), uint16(TEST),
	/*12844*/ uint16(xReadId),
	/*12845*/ uint16(xArgRM64),
	/*12846*/ uint16(xArgImm32),
	/*12847*/ uint16(xMatch),
	/*12848*/ uint16(xCondIs64), 12851, 12863,
	/*12851*/ uint16(xCondDataSize), 12855, 12859, 0,
	/*12855*/ uint16(xSetOp), uint16(NOT),
	/*12857*/ uint16(xArgRM16),
	/*12858*/ uint16(xMatch),
	/*12859*/ uint16(xSetOp), uint16(NOT),
	/*12861*/ uint16(xArgRM32),
	/*12862*/ uint16(xMatch),
	/*12863*/ uint16(xCondDataSize), 12855, 12859, 12867,
	/*12867*/ uint16(xSetOp), uint16(NOT),
	/*12869*/ uint16(xArgRM64),
	/*12870*/ uint16(xMatch),
	/*12871*/ uint16(xCondIs64), 12874, 12886,
	/*12874*/ uint16(xCondDataSize), 12878, 12882, 0,
	/*12878*/ uint16(xSetOp), uint16(NEG),
	/*12880*/ uint16(xArgRM16),
	/*12881*/ uint16(xMatch),
	/*12882*/ uint16(xSetOp), uint16(NEG),
	/*12884*/ uint16(xArgRM32),
	/*12885*/ uint16(xMatch),
	/*12886*/ uint16(xCondDataSize), 12878, 12882, 12890,
	/*12890*/ uint16(xSetOp), uint16(NEG),
	/*12892*/ uint16(xArgRM64),
	/*12893*/ uint16(xMatch),
	/*12894*/ uint16(xCondIs64), 12897, 12909,
	/*12897*/ uint16(xCondDataSize), 12901, 12905, 0,
	/*12901*/ uint16(xSetOp), uint16(MUL),
	/*12903*/ uint16(xArgRM16),
	/*12904*/ uint16(xMatch),
	/*12905*/ uint16(xSetOp), uint16(MUL),
	/*12907*/ uint16(xArgRM32),
	/*12908*/ uint16(xMatch),
	/*12909*/ uint16(xCondDataSize), 12901, 12905, 12913,
	/*12913*/ uint16(xSetOp), uint16(MUL),
	/*12915*/ uint16(xArgRM64),
	/*12916*/ uint16(xMatch),
	/*12917*/ uint16(xCondIs64), 12920, 12932,
	/*12920*/ uint16(xCondDataSize), 12924, 12928, 0,
	/*12924*/ uint16(xSetOp), uint16(IMUL),
	/*12926*/ uint16(xArgRM16),
	/*12927*/ uint16(xMatch),
	/*12928*/ uint16(xSetOp), uint16(IMUL),
	/*12930*/ uint16(xArgRM32),
	/*12931*/ uint16(xMatch),
	/*12932*/ uint16(xCondDataSize), 12924, 12928, 12936,
	/*12936*/ uint16(xSetOp), uint16(IMUL),
	/*12938*/ uint16(xArgRM64),
	/*12939*/ uint16(xMatch),
	/*12940*/ uint16(xCondIs64), 12943, 12955,
	/*12943*/ uint16(xCondDataSize), 12947, 12951, 0,
	/*12947*/ uint16(xSetOp), uint16(DIV),
	/*12949*/ uint16(xArgRM16),
	/*12950*/ uint16(xMatch),
	/*12951*/ uint16(xSetOp), uint16(DIV),
	/*12953*/ uint16(xArgRM32),
	/*12954*/ uint16(xMatch),
	/*12955*/ uint16(xCondDataSize), 12947, 12951, 12959,
	/*12959*/ uint16(xSetOp), uint16(DIV),
	/*12961*/ uint16(xArgRM64),
	/*12962*/ uint16(xMatch),
	/*12963*/ uint16(xCondIs64), 12966, 12978,
	/*12966*/ uint16(xCondDataSize), 12970, 12974, 0,
	/*12970*/ uint16(xSetOp), uint16(IDIV),
	/*12972*/ uint16(xArgRM16),
	/*12973*/ uint16(xMatch),
	/*12974*/ uint16(xSetOp), uint16(IDIV),
	/*12976*/ uint16(xArgRM32),
	/*12977*/ uint16(xMatch),
	/*12978*/ uint16(xCondDataSize), 12970, 12974, 12982,
	/*12982*/ uint16(xSetOp), uint16(IDIV),
	/*12984*/ uint16(xArgRM64),
	/*12985*/ uint16(xMatch),
	/*12986*/ uint16(xSetOp), uint16(CLC),
	/*12988*/ uint16(xMatch),
	/*12989*/ uint16(xSetOp), uint16(STC),
	/*12991*/ uint16(xMatch),
	/*12992*/ uint16(xSetOp), uint16(CLI),
	/*12994*/ uint16(xMatch),
	/*12995*/ uint16(xSetOp), uint16(STI),
	/*12997*/ uint16(xMatch),
	/*12998*/ uint16(xSetOp), uint16(CLD),
	/*13000*/ uint16(xMatch),
	/*13001*/ uint16(xSetOp), uint16(STD),
	/*13003*/ uint16(xMatch),
	/*13004*/ uint16(xCondSlashR),
	13013, // 0
	13017, // 1
	0,     // 2
	0,     // 3
	0,     // 4
	0,     // 5
	0,     // 6
	0,     // 7
	/*13013*/ uint16(xSetOp), uint16(INC),
	/*13015*/ uint16(xArgRM8),
	/*13016*/ uint16(xMatch),
	/*13017*/ uint16(xSetOp), uint16(DEC),
	/*13019*/ uint16(xArgRM8),
	/*13020*/ uint16(xMatch),
	/*13021*/ uint16(xCondSlashR),
	13030, // 0
	13053, // 1
	13076, // 2
	13095, // 3
	13118, // 4
	13137, // 5
	13160, // 6
	0,     // 7
	/*13030*/ uint16(xCondIs64), 13033, 13045,
	/*13033*/ uint16(xCondDataSize), 13037, 13041, 0,
	/*13037*/ uint16(xSetOp), uint16(INC),
	/*13039*/ uint16(xArgRM16),
	/*13040*/ uint16(xMatch),
	/*13041*/ uint16(xSetOp), uint16(INC),
	/*13043*/ uint16(xArgRM32),
	/*13044*/ uint16(xMatch),
	/*13045*/ uint16(xCondDataSize), 13037, 13041, 13049,
	/*13049*/ uint16(xSetOp), uint16(INC),
	/*13051*/ uint16(xArgRM64),
	/*13052*/ uint16(xMatch),
	/*13053*/ uint16(xCondIs64), 13056, 13068,
	/*13056*/ uint16(xCondDataSize), 13060, 13064, 0,
	/*13060*/ uint16(xSetOp), uint16(DEC),
	/*13062*/ uint16(xArgRM16),
	/*13063*/ uint16(xMatch),
	/*13064*/ uint16(xSetOp), uint16(DEC),
	/*13066*/ uint16(xArgRM32),
	/*13067*/ uint16(xMatch),
	/*13068*/ uint16(xCondDataSize), 13060, 13064, 13072,
	/*13072*/ uint16(xSetOp), uint16(DEC),
	/*13074*/ uint16(xArgRM64),
	/*13075*/ uint16(xMatch),
	/*13076*/ uint16(xCondIs64), 13079, 13091,
	/*13079*/ uint16(xCondDataSize), 13083, 13087, 0,
	/*13083*/ uint16(xSetOp), uint16(CALL),
	/*13085*/ uint16(xArgRM16),
	/*13086*/ uint16(xMatch),
	/*13087*/ uint16(xSetOp), uint16(CALL),
	/*13089*/ uint16(xArgRM32),
	/*13090*/ uint16(xMatch),
	/*13091*/ uint16(xSetOp), uint16(CALL),
	/*13093*/ uint16(xArgRM64),
	/*13094*/ uint16(xMatch),
	/*13095*/ uint16(xCondIs64), 13098, 13110,
	/*13098*/ uint16(xCondDataSize), 13102, 13106, 0,
	/*13102*/ uint16(xSetOp), uint16(LCALL),
	/*13104*/ uint16(xArgM16colon16),
	/*13105*/ uint16(xMatch),
	/*13106*/ uint16(xSetOp), uint16(LCALL),
	/*13108*/ uint16(xArgM16colon32),
	/*13109*/ uint16(xMatch),
	/*13110*/ uint16(xCondDataSize), 13102, 13106, 13114,
	/*13114*/ uint16(xSetOp), uint16(LCALL),
	/*13116*/ uint16(xArgM16colon64),
	/*13117*/ uint16(xMatch),
	/*13118*/ uint16(xCondIs64), 13121, 13133,
	/*13121*/ uint16(xCondDataSize), 13125, 13129, 0,
	/*13125*/ uint16(xSetOp), uint16(JMP),
	/*13127*/ uint16(xArgRM16),
	/*13128*/ uint16(xMatch),
	/*13129*/ uint16(xSetOp), uint16(JMP),
	/*13131*/ uint16(xArgRM32),
	/*13132*/ uint16(xMatch),
	/*13133*/ uint16(xSetOp), uint16(JMP),
	/*13135*/ uint16(xArgRM64),
	/*13136*/ uint16(xMatch),
	/*13137*/ uint16(xCondIs64), 13140, 13152,
	/*13140*/ uint16(xCondDataSize), 13144, 13148, 0,
	/*13144*/ uint16(xSetOp), uint16(LJMP),
	/*13146*/ uint16(xArgM16colon16),
	/*13147*/ uint16(xMatch),
	/*13148*/ uint16(xSetOp), uint16(LJMP),
	/*13150*/ uint16(xArgM16colon32),
	/*13151*/ uint16(xMatch),
	/*13152*/ uint16(xCondDataSize), 13144, 13148, 13156,
	/*13156*/ uint16(xSetOp), uint16(LJMP),
	/*13158*/ uint16(xArgM16colon64),
	/*13159*/ uint16(xMatch),
	/*13160*/ uint16(xCondIs64), 13163, 13175,
	/*13163*/ uint16(xCondDataSize), 13167, 13171, 0,
	/*13167*/ uint16(xSetOp), uint16(PUSH),
	/*13169*/ uint16(xArgRM16),
	/*13170*/ uint16(xMatch),
	/*13171*/ uint16(xSetOp), uint16(PUSH),
	/*13173*/ uint16(xArgRM32),
	/*13174*/ uint16(xMatch),
	/*13175*/ uint16(xCondDataSize), 13167, 13179, 13183,
	/*13179*/ uint16(xSetOp), uint16(PUSH),
	/*13181*/ uint16(xArgRM64),
	/*13182*/ uint16(xMatch),
	/*13183*/ uint16(xSetOp), uint16(PUSH),
	/*13185*/ uint16(xArgRM64),
	/*13186*/ uint16(xMatch),
}

const (
	_ Op = iota

	AAA
	AAD
	AAM
	AAS
	ADC
	ADD
	ADDPD
	ADDPS
	ADDSD
	ADDSS
	ADDSUBPD
	ADDSUBPS
	AESDEC
	AESDECLAST
	AESENC
	AESENCLAST
	AESIMC
	AESKEYGENASSIST
	AND
	ANDNPD
	ANDNPS
	ANDPD
	ANDPS
	ARPL
	BLENDPD
	BLENDPS
	BLENDVPD
	BLENDVPS
	BOUND
	BSF
	BSR
	BSWAP
	BT
	BTC
	BTR
	BTS
	CALL
	CBW
	CDQ
	CDQE
	CLC
	CLD
	CLFLUSH
	CLI
	CLTS
	CMC
	CMOVA
	CMOVAE
	CMOVB
	CMOVBE
	CMOVE
	CMOVG
	CMOVGE
	CMOVL
	CMOVLE
	CMOVNE
	CMOVNO
	CMOVNP
	CMOVNS
	CMOVO
	CMOVP
	CMOVS
	CMP
	CMPPD
	CMPPS
	CMPSB
	CMPSD
	CMPSD_XMM
	CMPSQ
	CMPSS
	CMPSW
	CMPXCHG
	CMPXCHG16B
	CMPXCHG8B
	COMISD
	COMISS
	CPUID
	CQO
	CRC32
	CVTDQ2PD
	CVTDQ2PS
	CVTPD2DQ
	CVTPD2PI
	CVTPD2PS
	CVTPI2PD
	CVTPI2PS
	CVTPS2DQ
	CVTPS2PD
	CVTPS2PI
	CVTSD2SI
	CVTSD2SS
	CVTSI2SD
	CVTSI2SS
	CVTSS2SD
	CVTSS2SI
	CVTTPD2DQ
	CVTTPD2PI
	CVTTPS2DQ
	CVTTPS2PI
	CVTTSD2SI
	CVTTSS2SI
	CWD
	CWDE
	DAA
	DAS
	DEC
	DIV
	DIVPD
	DIVPS
	DIVSD
	DIVSS
	DPPD
	DPPS
	EMMS
	ENTER
	EXTRACTPS
	F2XM1
	FABS
	FADD
	FADDP
	FBLD
	FBSTP
	FCHS
	FCMOVB
	FCMOVBE
	FCMOVE
	FCMOVNB
	FCMOVNBE
	FCMOVNE
	FCMOVNU
	FCMOVU
	FCOM
	FCOMI
	FCOMIP
	FCOMP
	FCOMPP
	FCOS
	FDECSTP
	FDIV
	FDIVP
	FDIVR
	FDIVRP
	FFREE
	FFREEP
	FIADD
	FICOM
	FICOMP
	FIDIV
	FIDIVR
	FILD
	FIMUL
	FINCSTP
	FIST
	FISTP
	FISTTP
	FISUB
	FISUBR
	FLD
	FLD1
	FLDCW
	FLDENV
	FLDL2E
	FLDL2T
	FLDLG2
	FLDPI
	FMUL
	FMULP
	FNCLEX
	FNINIT
	FNOP
	FNSAVE
	FNSTCW
	FNSTENV
	FNSTSW
	FPATAN
	FPREM
	FPREM1
	FPTAN
	FRNDINT
	FRSTOR
	FSCALE
	FSIN
	FSINCOS
	FSQRT
	FST
	FSTP
	FSUB
	FSUBP
	FSUBR
	FSUBRP
	FTST
	FUCOM
	FUCOMI
	FUCOMIP
	FUCOMP
	FUCOMPP
	FWAIT
	FXAM
	FXCH
	FXRSTOR
	FXRSTOR64
	FXSAVE
	FXSAVE64
	FXTRACT
	FYL2X
	FYL2XP1
	HADDPD
	HADDPS
	HLT
	HSUBPD
	HSUBPS
	ICEBP
	IDIV
	IMUL
	IN
	INC
	INSB
	INSD
	INSERTPS
	INSW
	INT
	INTO
	INVD
	INVLPG
	INVPCID
	IRET
	IRETD
	IRETQ
	JA
	JAE
	JB
	JBE
	JCXZ
	JE
	JECXZ
	JG
	JGE
	JL
	JLE
	JMP
	JNE
	JNO
	JNP
	JNS
	JO
	JP
	JRCXZ
	JS
	LAHF
	LAR
	LCALL
	LDDQU
	LDMXCSR
	LDS
	LEA
	LEAVE
	LES
	LFENCE
	LFS
	LGDT
	LGS
	LIDT
	LJMP
	LLDT
	LMSW
	LODSB
	LODSD
	LODSQ
	LODSW
	LOOP
	LOOPE
	LOOPNE
	LRET
	LSL
	LSS
	LTR
	LZCNT
	MASKMOVDQU
	MASKMOVQ
	MAXPD
	MAXPS
	MAXSD
	MAXSS
	MFENCE
	MINPD
	MINPS
	MINSD
	MINSS
	MONITOR
	MOV
	MOVAPD
	MOVAPS
	MOVBE
	MOVD
	MOVDDUP
	MOVDQ2Q
	MOVDQA
	MOVDQU
	MOVHLPS
	MOVHPD
	MOVHPS
	MOVLHPS
	MOVLPD
	MOVLPS
	MOVMSKPD
	MOVMSKPS
	MOVNTDQ
	MOVNTDQA
	MOVNTI
	MOVNTPD
	MOVNTPS
	MOVNTQ
	MOVNTSD
	MOVNTSS
	MOVQ
	MOVQ2DQ
	MOVSB
	MOVSD
	MOVSD_XMM
	MOVSHDUP
	MOVSLDUP
	MOVSQ
	MOVSS
	MOVSW
	MOVSX
	MOVSXD
	MOVUPD
	MOVUPS
	MOVZX
	MPSADBW
	MUL
	MULPD
	MULPS
	MULSD
	MULSS
	MWAIT
	NEG
	NOP
	NOT
	OR
	ORPD
	ORPS
	OUT
	OUTSB
	OUTSD
	OUTSW
	PABSB
	PABSD
	PABSW
	PACKSSDW
	PACKSSWB
	PACKUSDW
	PACKUSWB
	PADDB
	PADDD
	PADDQ
	PADDSB
	PADDSW
	PADDUSB
	PADDUSW
	PADDW
	PALIGNR
	PAND
	PANDN
	PAUSE
	PAVGB
	PAVGW
	PBLENDVB
	PBLENDW
	PCLMULQDQ
	PCMPEQB
	PCMPEQD
	PCMPEQQ
	PCMPEQW
	PCMPESTRI
	PCMPESTRM
	PCMPGTB
	PCMPGTD
	PCMPGTQ
	PCMPGTW
	PCMPISTRI
	PCMPISTRM
	PEXTRB
	PEXTRD
	PEXTRQ
	PEXTRW
	PHADDD
	PHADDSW
	PHADDW
	PHMINPOSUW
	PHSUBD
	PHSUBSW
	PHSUBW
	PINSRB
	PINSRD
	PINSRQ
	PINSRW
	PMADDUBSW
	PMADDWD
	PMAXSB
	PMAXSD
	PMAXSW
	PMAXUB
	PMAXUD
	PMAXUW
	PMINSB
	PMINSD
	PMINSW
	PMINUB
	PMINUD
	PMINUW
	PMOVMSKB
	PMOVSXBD
	PMOVSXBQ
	PMOVSXBW
	PMOVSXDQ
	PMOVSXWD
	PMOVSXWQ
	PMOVZXBD
	PMOVZXBQ
	PMOVZXBW
	PMOVZXDQ
	PMOVZXWD
	PMOVZXWQ
	PMULDQ
	PMULHRSW
	PMULHUW
	PMULHW
	PMULLD
	PMULLW
	PMULUDQ
	POP
	POPA
	POPAD
	POPCNT
	POPF
	POPFD
	POPFQ
	POR
	PREFETCHNTA
	PREFETCHT0
	PREFETCHT1
	PREFETCHT2
	PREFETCHW
	PSADBW
	PSHUFB
	PSHUFD
	PSHUFHW
	PSHUFLW
	PSHUFW
	PSIGNB
	PSIGND
	PSIGNW
	PSLLD
	PSLLDQ
	PSLLQ
	PSLLW
	PSRAD
	PSRAW
	PSRLD
	PSRLDQ
	PSRLQ
	PSRLW
	PSUBB
	PSUBD
	PSUBQ
	PSUBSB
	PSUBSW
	PSUBUSB
	PSUBUSW
	PSUBW
	PTEST
	PUNPCKHBW
	PUNPCKHDQ
	PUNPCKHQDQ
	PUNPCKHWD
	PUNPCKLBW
	PUNPCKLDQ
	PUNPCKLQDQ
	PUNPCKLWD
	PUSH
	PUSHA
	PUSHAD
	PUSHF
	PUSHFD
	PUSHFQ
	PXOR
	RCL
	RCPPS
	RCPSS
	RCR
	RDFSBASE
	RDGSBASE
	RDMSR
	RDPMC
	RDRAND
	RDTSC
	RDTSCP
	RET
	ROL
	ROR
	ROUNDPD
	ROUNDPS
	ROUNDSD
	ROUNDSS
	RSM
	RSQRTPS
	RSQRTSS
	SAHF
	SAR
	SBB
	SCASB
	SCASD
	SCASQ
	SCASW
	SETA
	SETAE
	SETB
	SETBE
	SETE
	SETG
	SETGE
	SETL
	SETLE
	SETNE
	SETNO
	SETNP
	SETNS
	SETO
	SETP
	SETS
	SFENCE
	SGDT
	SHL
	SHLD
	SHR
	SHRD
	SHUFPD
	SHUFPS
	SIDT
	SLDT
	SMSW
	SQRTPD
	SQRTPS
	SQRTSD
	SQRTSS
	STC
	STD
	STI
	STMXCSR
	STOSB
	STOSD
	STOSQ
	STOSW
	STR
	SUB
	SUBPD
	SUBPS
	SUBSD
	SUBSS
	SWAPGS
	SYSCALL
	SYSENTER
	SYSEXIT
	SYSRET
	TEST
	TZCNT
	UCOMISD
	UCOMISS
	UD1
	UD2
	UNPCKHPD
	UNPCKHPS
	UNPCKLPD
	UNPCKLPS
	VERR
	VERW
	WBINVD
	WRFSBASE
	WRGSBASE
	WRMSR
	XABORT
	XADD
	XBEGIN
	XCHG
	XEND
	XGETBV
	XLATB
	XOR
	XORPD
	XORPS
	XRSTOR
	XRSTOR64
	XRSTORS
	XRSTORS64
	XSAVE
	XSAVE64
	XSAVEC
	XSAVEC64
	XSAVEOPT
	XSAVEOPT64
	XSAVES
	XSAVES64
	XSETBV
	XTEST
)

const maxOp = XTEST

var opNames = [...]string{
	AAA:             "AAA",
	AAD:             "AAD",
	AAM:             "AAM",
	AAS:             "AAS",
	ADC:             "ADC",
	ADD:             "ADD",
	ADDPD:           "ADDPD",
	ADDPS:           "ADDPS",
	ADDSD:           "ADDSD",
	ADDSS:           "ADDSS",
	ADDSUBPD:        "ADDSUBPD",
	ADDSUBPS:        "ADDSUBPS",
	AESDEC:          "AESDEC",
	AESDECLAST:      "AESDECLAST",
	AESENC:          "AESENC",
	AESENCLAST:      "AESENCLAST",
	AESIMC:          "AESIMC",
	AESKEYGENASSIST: "AESKEYGENASSIST",
	AND:             "AND",
	ANDNPD:          "ANDNPD",
	ANDNPS:          "ANDNPS",
	ANDPD:           "ANDPD",
	ANDPS:           "ANDPS",
	ARPL:            "ARPL",
	BLENDPD:         "BLENDPD",
	BLENDPS:         "BLENDPS",
	BLENDVPD:        "BLENDVPD",
	BLENDVPS:        "BLENDVPS",
	BOUND:           "BOUND",
	BSF:             "BSF",
	BSR:             "BSR",
	BSWAP:           "BSWAP",
	BT:              "BT",
	BTC:             "BTC",
	BTR:             "BTR",
	BTS:             "BTS",
	CALL:            "CALL",
	CBW:             "CBW",
	CDQ:             "CDQ",
	CDQE:            "CDQE",
	CLC:             "CLC",
	CLD:             "CLD",
	CLFLUSH:         "CLFLUSH",
	CLI:             "CLI",
	CLTS:            "CLTS",
	CMC:             "CMC",
	CMOVA:           "CMOVA",
	CMOVAE:          "CMOVAE",
	CMOVB:           "CMOVB",
	CMOVBE:          "CMOVBE",
	CMOVE:           "CMOVE",
	CMOVG:           "CMOVG",
	CMOVGE:          "CMOVGE",
	CMOVL:           "CMOVL",
	CMOVLE:          "CMOVLE",
	CMOVNE:          "CMOVNE",
	CMOVNO:          "CMOVNO",
	CMOVNP:          "CMOVNP",
	CMOVNS:          "CMOVNS",
	CMOVO:           "CMOVO",
	CMOVP:           "CMOVP",
	CMOVS:           "CMOVS",
	CMP:             "CMP",
	CMPPD:           "CMPPD",
	CMPPS:           "CMPPS",
	CMPSB:           "CMPSB",
	CMPSD:           "CMPSD",
	CMPSD_XMM:       "CMPSD_XMM",
	CMPSQ:           "CMPSQ",
	CMPSS:           "CMPSS",
	CMPSW:           "CMPSW",
	CMPXCHG:         "CMPXCHG",
	CMPXCHG16B:      "CMPXCHG16B",
	CMPXCHG8B:       "CMPXCHG8B",
	COMISD:          "COMISD",
	COMISS:          "COMISS",
	CPUID:           "CPUID",
	CQO:             "CQO",
	CRC32:           "CRC32",
	CVTDQ2PD:        "CVTDQ2PD",
	CVTDQ2PS:        "CVTDQ2PS",
	CVTPD2DQ:        "CVTPD2DQ",
	CVTPD2PI:        "CVTPD2PI",
	CVTPD2PS:        "CVTPD2PS",
	CVTPI2PD:        "CVTPI2PD",
	CVTPI2PS:        "CVTPI2PS",
	CVTPS2DQ:        "CVTPS2DQ",
	CVTPS2PD:        "CVTPS2PD",
	CVTPS2PI:        "CVTPS2PI",
	CVTSD2SI:        "CVTSD2SI",
	CVTSD2SS:        "CVTSD2SS",
	CVTSI2SD:        "CVTSI2SD",
	CVTSI2SS:        "CVTSI2SS",
	CVTSS2SD:        "CVTSS2SD",
	CVTSS2SI:        "CVTSS2SI",
	CVTTPD2DQ:       "CVTTPD2DQ",
	CVTTPD2PI:       "CVTTPD2PI",
	CVTTPS2DQ:       "CVTTPS2DQ",
	CVTTPS2PI:       "CVTTPS2PI",
	CVTTSD2SI:       "CVTTSD2SI",
	CVTTSS2SI:       "CVTTSS2SI",
	CWD:             "CWD",
	CWDE:            "CWDE",
	DAA:             "DAA",
	DAS:             "DAS",
	DEC:             "DEC",
	DIV:             "DIV",
	DIVPD:           "DIVPD",
	DIVPS:           "DIVPS",
	DIVSD:           "DIVSD",
	DIVSS:           "DIVSS",
	DPPD:            "DPPD",
	DPPS:            "DPPS",
	EMMS:            "EMMS",
	ENTER:           "ENTER",
	EXTRACTPS:       "EXTRACTPS",
	F2XM1:           "F2XM1",
	FABS:            "FABS",
	FADD:            "FADD",
	FADDP:           "FADDP",
	FBLD:            "FBLD",
	FBSTP:           "FBSTP",
	FCHS:            "FCHS",
	FCMOVB:          "FCMOVB",
	FCMOVBE:         "FCMOVBE",
	FCMOVE:          "FCMOVE",
	FCMOVNB:         "FCMOVNB",
	FCMOVNBE:        "FCMOVNBE",
	FCMOVNE:         "FCMOVNE",
	FCMOVNU:         "FCMOVNU",
	FCMOVU:          "FCMOVU",
	FCOM:            "FCOM",
	FCOMI:           "FCOMI",
	FCOMIP:          "FCOMIP",
	FCOMP:           "FCOMP",
	FCOMPP:          "FCOMPP",
	FCOS:            "FCOS",
	FDECSTP:         "FDECSTP",
	FDIV:            "FDIV",
	FDIVP:           "FDIVP",
	FDIVR:           "FDIVR",
	FDIVRP:          "FDIVRP",
	FFREE:           "FFREE",
	FFREEP:          "FFREEP",
	FIADD:           "FIADD",
	FICOM:           "FICOM",
	FICOMP:          "FICOMP",
	FIDIV:           "FIDIV",
	FIDIVR:          "FIDIVR",
	FILD:            "FILD",
	FIMUL:           "FIMUL",
	FINCSTP:         "FINCSTP",
	FIST:            "FIST",
	FISTP:           "FISTP",
	FISTTP:          "FISTTP",
	FISUB:           "FISUB",
	FISUBR:          "FISUBR",
	FLD:             "FLD",
	FLD1:            "FLD1",
	FLDCW:           "FLDCW",
	FLDENV:          "FLDENV",
	FLDL2E:          "FLDL2E",
	FLDL2T:          "FLDL2T",
	FLDLG2:          "FLDLG2",
	FLDPI:           "FLDPI",
	FMUL:            "FMUL",
	FMULP:           "FMULP",
	FNCLEX:          "FNCLEX",
	FNINIT:          "FNINIT",
	FNOP:            "FNOP",
	FNSAVE:          "FNSAVE",
	FNSTCW:          "FNSTCW",
	FNSTENV:         "FNSTENV",
	FNSTSW:          "FNSTSW",
	FPATAN:          "FPATAN",
	FPREM:           "FPREM",
	FPREM1:          "FPREM1",
	FPTAN:           "FPTAN",
	FRNDINT:         "FRNDINT",
	FRSTOR:          "FRSTOR",
	FSCALE:          "FSCALE",
	FSIN:            "FSIN",
	FSINCOS:         "FSINCOS",
	FSQRT:           "FSQRT",
	FST:             "FST",
	FSTP:            "FSTP",
	FSUB:            "FSUB",
	FSUBP:           "FSUBP",
	FSUBR:           "FSUBR",
	FSUBRP:          "FSUBRP",
	FTST:            "FTST",
	FUCOM:           "FUCOM",
	FUCOMI:          "FUCOMI",
	FUCOMIP:         "FUCOMIP",
	FUCOMP:          "FUCOMP",
	FUCOMPP:         "FUCOMPP",
	FWAIT:           "FWAIT",
	FXAM:            "FXAM",
	FXCH:            "FXCH",
	FXRSTOR:         "FXRSTOR",
	FXRSTOR64:       "FXRSTOR64",
	FXSAVE:          "FXSAVE",
	FXSAVE64:        "FXSAVE64",
	FXTRACT:         "FXTRACT",
	FYL2X:           "FYL2X",
	FYL2XP1:         "FYL2XP1",
	HADDPD:          "HADDPD",
	HADDPS:          "HADDPS",
	HLT:             "HLT",
	HSUBPD:          "HSUBPD",
	HSUBPS:          "HSUBPS",
	ICEBP:           "ICEBP",
	IDIV:            "IDIV",
	IMUL:            "IMUL",
	IN:              "IN",
	INC:             "INC",
	INSB:            "INSB",
	INSD:            "INSD",
	INSERTPS:        "INSERTPS",
	INSW:            "INSW",
	INT:             "INT",
	INTO:            "INTO",
	INVD:            "INVD",
	INVLPG:          "INVLPG",
	INVPCID:         "INVPCID",
	IRET:            "IRET",
	IRETD:           "IRETD",
	IRETQ:           "IRETQ",
	JA:              "JA",
	JAE:             "JAE",
	JB:              "JB",
	JBE:             "JBE",
	JCXZ:            "JCXZ",
	JE:              "JE",
	JECXZ:           "JECXZ",
	JG:              "JG",
	JGE:             "JGE",
	JL:              "JL",
	JLE:             "JLE",
	JMP:             "JMP",
	JNE:             "JNE",
	JNO:             "JNO",
	JNP:             "JNP",
	JNS:             "JNS",
	JO:              "JO",
	JP:              "JP",
	JRCXZ:           "JRCXZ",
	JS:              "JS",
	LAHF:            "LAHF",
	LAR:             "LAR",
	LCALL:           "LCALL",
	LDDQU:           "LDDQU",
	LDMXCSR:         "LDMXCSR",
	LDS:             "LDS",
	LEA:             "LEA",
	LEAVE:           "LEAVE",
	LES:             "LES",
	LFENCE:          "LFENCE",
	LFS:             "LFS",
	LGDT:            "LGDT",
	LGS:             "LGS",
	LIDT:            "LIDT",
	LJMP:            "LJMP",
	LLDT:            "LLDT",
	LMSW:            "LMSW",
	LODSB:           "LODSB",
	LODSD:           "LODSD",
	LODSQ:           "LODSQ",
	LODSW:           "LODSW",
	LOOP:            "LOOP",
	LOOPE:           "LOOPE",
	LOOPNE:          "LOOPNE",
	LRET:            "LRET",
	LSL:             "LSL",
	LSS:             "LSS",
	LTR:             "LTR",
	LZCNT:           "LZCNT",
	MASKMOVDQU:      "MASKMOVDQU",
	MASKMOVQ:        "MASKMOVQ",
	MAXPD:           "MAXPD",
	MAXPS:           "MAXPS",
	MAXSD:           "MAXSD",
	MAXSS:           "MAXSS",
	MFENCE:          "MFENCE",
	MINPD:           "MINPD",
	MINPS:           "MINPS",
	MINSD:           "MINSD",
	MINSS:           "MINSS",
	MONITOR:         "MONITOR",
	MOV:             "MOV",
	MOVAPD:          "MOVAPD",
	MOVAPS:          "MOVAPS",
	MOVBE:           "MOVBE",
	MOVD:            "MOVD",
	MOVDDUP:         "MOVDDUP",
	MOVDQ2Q:         "MOVDQ2Q",
	MOVDQA:          "MOVDQA",
	MOVDQU:          "MOVDQU",
	MOVHLPS:         "MOVHLPS",
	MOVHPD:          "MOVHPD",
	MOVHPS:          "MOVHPS",
	MOVLHPS:         "MOVLHPS",
	MOVLPD:          "MOVLPD",
	MOVLPS:          "MOVLPS",
	MOVMSKPD:        "MOVMSKPD",
	MOVMSKPS:        "MOVMSKPS",
	MOVNTDQ:         "MOVNTDQ",
	MOVNTDQA:        "MOVNTDQA",
	MOVNTI:          "MOVNTI",
	MOVNTPD:         "MOVNTPD",
	MOVNTPS:         "MOVNTPS",
	MOVNTQ:          "MOVNTQ",
	MOVNTSD:         "MOVNTSD",
	MOVNTSS:         "MOVNTSS",
	MOVQ:            "MOVQ",
	MOVQ2DQ:         "MOVQ2DQ",
	MOVSB:           "MOVSB",
	MOVSD:           "MOVSD",
	MOVSD_XMM:       "MOVSD_XMM",
	MOVSHDUP:        "MOVSHDUP",
	MOVSLDUP:        "MOVSLDUP",
	MOVSQ:           "MOVSQ",
	MOVSS:           "MOVSS",
	MOVSW:           "MOVSW",
	MOVSX:           "MOVSX",
	MOVSXD:          "MOVSXD",
	MOVUPD:          "MOVUPD",
	MOVUPS:          "MOVUPS",
	MOVZX:           "MOVZX",
	MPSADBW:         "MPSADBW",
	MUL:             "MUL",
	MULPD:           "MULPD",
	MULPS:           "MULPS",
	MULSD:           "MULSD",
	MULSS:           "MULSS",
	MWAIT:           "MWAIT",
	NEG:             "NEG",
	NOP:             "NOP",
	NOT:             "NOT",
	OR:              "OR",
	ORPD:            "ORPD",
	ORPS:            "ORPS",
	OUT:             "OUT",
	OUTSB:           "OUTSB",
	OUTSD:           "OUTSD",
	OUTSW:           "OUTSW",
	PABSB:           "PABSB",
	PABSD:           "PABSD",
	PABSW:           "PABSW",
	PACKSSDW:        "PACKSSDW",
	PACKSSWB:        "PACKSSWB",
	PACKUSDW:        "PACKUSDW",
	PACKUSWB:        "PACKUSWB",
	PADDB:           "PADDB",
	PADDD:           "PADDD",
	PADDQ:           "PADDQ",
	PADDSB:          "PADDSB",
	PADDSW:          "PADDSW",
	PADDUSB:         "PADDUSB",
	PADDUSW:         "PADDUSW",
	PADDW:           "PADDW",
	PALIGNR:         "PALIGNR",
	PAND:            "PAND",
	PANDN:           "PANDN",
	PAUSE:           "PAUSE",
	PAVGB:           "PAVGB",
	PAVGW:           "PAVGW",
	PBLENDVB:        "PBLENDVB",
	PBLENDW:         "PBLENDW",
	PCLMULQDQ:       "PCLMULQDQ",
	PCMPEQB:         "PCMPEQB",
	PCMPEQD:         "PCMPEQD",
	PCMPEQQ:         "PCMPEQQ",
	PCMPEQW:         "PCMPEQW",
	PCMPESTRI:       "PCMPESTRI",
	PCMPESTRM:       "PCMPESTRM",
	PCMPGTB:         "PCMPGTB",
	PCMPGTD:         "PCMPGTD",
	PCMPGTQ:         "PCMPGTQ",
	PCMPGTW:         "PCMPGTW",
	PCMPISTRI:       "PCMPISTRI",
	PCMPISTRM:       "PCMPISTRM",
	PEXTRB:          "PEXTRB",
	PEXTRD:          "PEXTRD",
	PEXTRQ:          "PEXTRQ",
	PEXTRW:          "PEXTRW",
	PHADDD:          "PHADDD",
	PHADDSW:         "PHADDSW",
	PHADDW:          "PHADDW",
	PHMINPOSUW:      "PHMINPOSUW",
	PHSUBD:          "PHSUBD",
	PHSUBSW:         "PHSUBSW",
	PHSUBW:          "PHSUBW",
	PINSRB:          "PINSRB",
	PINSRD:          "PINSRD",
	PINSRQ:          "PINSRQ",
	PINSRW:          "PINSRW",
	PMADDUBSW:       "PMADDUBSW",
	PMADDWD:         "PMADDWD",
	PMAXSB:          "PMAXSB",
	PMAXSD:          "PMAXSD",
	PMAXSW:          "PMAXSW",
	PMAXUB:          "PMAXUB",
	PMAXUD:          "PMAXUD",
	PMAXUW:          "PMAXUW",
	PMINSB:          "PMINSB",
	PMINSD:          "PMINSD",
	PMINSW:          "PMINSW",
	PMINUB:          "PMINUB",
	PMINUD:          "PMINUD",
	PMINUW:          "PMINUW",
	PMOVMSKB:        "PMOVMSKB",
	PMOVSXBD:        "PMOVSXBD",
	PMOVSXBQ:        "PMOVSXBQ",
	PMOVSXBW:        "PMOVSXBW",
	PMOVSXDQ:        "PMOVSXDQ",
	PMOVSXWD:        "PMOVSXWD",
	PMOVSXWQ:        "PMOVSXWQ",
	PMOVZXBD:        "PMOVZXBD",
	PMOVZXBQ:        "PMOVZXBQ",
	PMOVZXBW:        "PMOVZXBW",
	PMOVZXDQ:        "PMOVZXDQ",
	PMOVZXWD:        "PMOVZXWD",
	PMOVZXWQ:        "PMOVZXWQ",
	PMULDQ:          "PMULDQ",
	PMULHRSW:        "PMULHRSW",
	PMULHUW:         "PMULHUW",
	PMULHW:          "PMULHW",
	PMULLD:          "PMULLD",
	PMULLW:          "PMULLW",
	PMULUDQ:         "PMULUDQ",
	POP:             "POP",
	POPA:            "POPA",
	POPAD:           "POPAD",
	POPCNT:          "POPCNT",
	POPF:            "POPF",
	POPFD:           "POPFD",
	POPFQ:           "POPFQ",
	POR:             "POR",
	PREFETCHNTA:     "PREFETCHNTA",
	PREFETCHT0:      "PREFETCHT0",
	PREFETCHT1:      "PREFETCHT1",
	PREFETCHT2:      "PREFETCHT2",
	PREFETCHW:       "PREFETCHW",
	PSADBW:          "PSADBW",
	PSHUFB:          "PSHUFB",
	PSHUFD:          "PSHUFD",
	PSHUFHW:         "PSHUFHW",
	PSHUFLW:         "PSHUFLW",
	PSHUFW:          "PSHUFW",
	PSIGNB:          "PSIGNB",
	PSIGND:          "PSIGND",
	PSIGNW:          "PSIGNW",
	PSLLD:           "PSLLD",
	PSLLDQ:          "PSLLDQ",
	PSLLQ:           "PSLLQ",
	PSLLW:           "PSLLW",
	PSRAD:           "PSRAD",
	PSRAW:           "PSRAW",
	PSRLD:           "PSRLD",
	PSRLDQ:          "PSRLDQ",
	PSRLQ:           "PSRLQ",
	PSRLW:           "PSRLW",
	PSUBB:           "PSUBB",
	PSUBD:           "PSUBD",
	PSUBQ:           "PSUBQ",
	PSUBSB:          "PSUBSB",
	PSUBSW:          "PSUBSW",
	PSUBUSB:         "PSUBUSB",
	PSUBUSW:         "PSUBUSW",
	PSUBW:           "PSUBW",
	PTEST:           "PTEST",
	PUNPCKHBW:       "PUNPCKHBW",
	PUNPCKHDQ:       "PUNPCKHDQ",
	PUNPCKHQDQ:      "PUNPCKHQDQ",
	PUNPCKHWD:       "PUNPCKHWD",
	PUNPCKLBW:       "PUNPCKLBW",
	PUNPCKLDQ:       "PUNPCKLDQ",
	PUNPCKLQDQ:      "PUNPCKLQDQ",
	PUNPCKLWD:       "PUNPCKLWD",
	PUSH:            "PUSH",
	PUSHA:           "PUSHA",
	PUSHAD:          "PUSHAD",
	PUSHF:           "PUSHF",
	PUSHFD:          "PUSHFD",
	PUSHFQ:          "PUSHFQ",
	PXOR:            "PXOR",
	RCL:             "RCL",
	RCPPS:           "RCPPS",
	RCPSS:           "RCPSS",
	RCR:             "RCR",
	RDFSBASE:        "RDFSBASE",
	RDGSBASE:        "RDGSBASE",
	RDMSR:           "RDMSR",
	RDPMC:           "RDPMC",
	RDRAND:          "RDRAND",
	RDTSC:           "RDTSC",
	RDTSCP:          "RDTSCP",
	RET:             "RET",
	ROL:             "ROL",
	ROR:             "ROR",
	ROUNDPD:         "ROUNDPD",
	ROUNDPS:         "ROUNDPS",
	ROUNDSD:         "ROUNDSD",
	ROUNDSS:         "ROUNDSS",
	RSM:             "RSM",
	RSQRTPS:         "RSQRTPS",
	RSQRTSS:         "RSQRTSS",
	SAHF:            "SAHF",
	SAR:             "SAR",
	SBB:             "SBB",
	SCASB:           "SCASB",
	SCASD:           "SCASD",
	SCASQ:           "SCASQ",
	SCASW:           "SCASW",
	SETA:            "SETA",
	SETAE:           "SETAE",
	SETB:            "SETB",
	SETBE:           "SETBE",
	SETE:            "SETE",
	SETG:            "SETG",
	SETGE:           "SETGE",
	SETL:            "SETL",
	SETLE:           "SETLE",
	SETNE:           "SETNE",
	SETNO:           "SETNO",
	SETNP:           "SETNP",
	SETNS:           "SETNS",
	SETO:            "SETO",
	SETP:            "SETP",
	SETS:            "SETS",
	SFENCE:          "SFENCE",
	SGDT:            "SGDT",
	SHL:             "SHL",
	SHLD:            "SHLD",
	SHR:             "SHR",
	SHRD:            "SHRD",
	SHUFPD:          "SHUFPD",
	SHUFPS:          "SHUFPS",
	SIDT:            "SIDT",
	SLDT:            "SLDT",
	SMSW:            "SMSW",
	SQRTPD:          "SQRTPD",
	SQRTPS:          "SQRTPS",
	SQRTSD:          "SQRTSD",
	SQRTSS:          "SQRTSS",
	STC:             "STC",
	STD:             "STD",
	STI:             "STI",
	STMXCSR:         "STMXCSR",
	STOSB:           "STOSB",
	STOSD:           "STOSD",
	STOSQ:           "STOSQ",
	STOSW:           "STOSW",
	STR:             "STR",
	SUB:             "SUB",
	SUBPD:           "SUBPD",
	SUBPS:           "SUBPS",
	SUBSD:           "SUBSD",
	SUBSS:           "SUBSS",
	SWAPGS:          "SWAPGS",
	SYSCALL:         "SYSCALL",
	SYSENTER:        "SYSENTER",
	SYSEXIT:         "SYSEXIT",
	SYSRET:          "SYSRET",
	TEST:            "TEST",
	TZCNT:           "TZCNT",
	UCOMISD:         "UCOMISD",
	UCOMISS:         "UCOMISS",
	UD1:             "UD1",
	UD2:             "UD2",
	UNPCKHPD:        "UNPCKHPD",
	UNPCKHPS:        "UNPCKHPS",
	UNPCKLPD:        "UNPCKLPD",
	UNPCKLPS:        "UNPCKLPS",
	VERR:            "VERR",
	VERW:            "VERW",
	WBINVD:          "WBINVD",
	WRFSBASE:        "WRFSBASE",
	WRGSBASE:        "WRGSBASE",
	WRMSR:           "WRMSR",
	XABORT:          "XABORT",
	XADD:            "XADD",
	XBEGIN:          "XBEGIN",
	XCHG:            "XCHG",
	XEND:            "XEND",
	XGETBV:          "XGETBV",
	XLATB:           "XLATB",
	XOR:             "XOR",
	XORPD:           "XORPD",
	XORPS:           "XORPS",
	XRSTOR:          "XRSTOR",
	XRSTOR64:        "XRSTOR64",
	XRSTORS:         "XRSTORS",
	XRSTORS64:       "XRSTORS64",
	XSAVE:           "XSAVE",
	XSAVE64:         "XSAVE64",
	XSAVEC:          "XSAVEC",
	XSAVEC64:        "XSAVEC64",
	XSAVEOPT:        "XSAVEOPT",
	XSAVEOPT64:      "XSAVEOPT64",
	XSAVES:          "XSAVES",
	XSAVES64:        "XSAVES64",
	XSETBV:          "XSETBV",
	XTEST:           "XTEST",
}
                                                                                                                      root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/testdata/                                             0040755 0000000 0000000 00000000000 12600426233 021010  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/testdata/Makefile                                     0100644 0000000 0000000 00000001247 12600426226 022453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        libmach8db: libmach8db.c
	9c libmach8db.c && 9l -o libmach8db libmach8db.o; rm libmach8db.o

newdecode.txt:
	cd ..; go test -cover -run 'Objdump.*32' -v -timeout 10h -printtests 2>&1 | tee log
	cd ..; go test -cover -run 'Objdump.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Xed.*32' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Xed.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Plan9.*32' -v -timeout 10h -printtests 2>&1 | tee -a log
	cd ..; go test -cover -run 'Plan9.*64' -v -timeout 10h -printtests 2>&1 | tee -a log
	egrep '	(gnu|intel|plan9)	' ../log |sort >newdecode.txt

                                                                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/testdata/decode.txt                                   0100644 0000000 0000000 00001464511 12600426226 023007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        000511223344|556677885f5f5f5f5f5f	32	intel	add byte ptr [0x44332211], al
000511223344|556677885f5f5f5f5f5f	64	gnu	add %al,0x44332211(%rip)
000511223344|556677885f5f5f5f5f5f	64	intel	add byte ptr [rip+0x44332211], al
0100|11223344556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], eax
0100|11223344556677885f5f5f5f5f5f	32	plan9	ADDL AX, 0(AX)
0100|11223344556677885f5f5f5f5f5f	64	gnu	add %eax,(%rax)
0100|11223344556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], eax
0100|11223344556677885f5f5f5f5f5f	64	plan9	ADDL AX, 0(AX)
0211|223344556677885f5f5f5f5f5f5f	32	intel	add dl, byte ptr [ecx]
0211|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL 0(CX), DL
0211|223344556677885f5f5f5f5f5f5f	64	gnu	add (%rcx),%dl
0211|223344556677885f5f5f5f5f5f5f	64	intel	add dl, byte ptr [rcx]
0211|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL 0(CX), DL
0311|223344556677885f5f5f5f5f5f5f	32	intel	add edx, dword ptr [ecx]
0311|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL 0(CX), DX
0311|223344556677885f5f5f5f5f5f5f	64	gnu	add (%rcx),%edx
0311|223344556677885f5f5f5f5f5f5f	64	intel	add edx, dword ptr [rcx]
0311|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL 0(CX), DX
0411|223344556677885f5f5f5f5f5f5f	32	intel	add al, 0x11
0411|223344556677885f5f5f5f5f5f5f	32	plan9	ADDL $0x11, AL
0411|223344556677885f5f5f5f5f5f5f	64	gnu	add $0x11,%al
0411|223344556677885f5f5f5f5f5f5f	64	intel	add al, 0x11
0411|223344556677885f5f5f5f5f5f5f	64	plan9	ADDL $0x11, AL
0511223344|556677885f5f5f5f5f5f5f	32	intel	add eax, 0x44332211
0511223344|556677885f5f5f5f5f5f5f	32	plan9	ADDL $0x44332211, AX
0511223344|556677885f5f5f5f5f5f5f	64	gnu	add $0x44332211,%eax
0511223344|556677885f5f5f5f5f5f5f	64	intel	add eax, 0x44332211
0511223344|556677885f5f5f5f5f5f5f	64	plan9	ADDL $0x44332211, AX
06|11223344556677885f5f5f5f5f5f5f	32	intel	push es
06|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL ES
06|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
06|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
06|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	32	intel	pop es
07|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL ES
07|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
07|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0811|223344556677885f5f5f5f5f5f5f	32	intel	or byte ptr [ecx], dl
0811|223344556677885f5f5f5f5f5f5f	32	plan9	ORL DL, 0(CX)
0811|223344556677885f5f5f5f5f5f5f	64	gnu	or %dl,(%rcx)
0811|223344556677885f5f5f5f5f5f5f	64	intel	or byte ptr [rcx], dl
0811|223344556677885f5f5f5f5f5f5f	64	plan9	ORL DL, 0(CX)
0911|223344556677885f5f5f5f5f5f5f	32	intel	or dword ptr [ecx], edx
0911|223344556677885f5f5f5f5f5f5f	32	plan9	ORL DX, 0(CX)
0911|223344556677885f5f5f5f5f5f5f	64	gnu	or %edx,(%rcx)
0911|223344556677885f5f5f5f5f5f5f	64	intel	or dword ptr [rcx], edx
0911|223344556677885f5f5f5f5f5f5f	64	plan9	ORL DX, 0(CX)
0a11|223344556677885f5f5f5f5f5f5f	32	intel	or dl, byte ptr [ecx]
0a11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL 0(CX), DL
0a11|223344556677885f5f5f5f5f5f5f	64	gnu	or (%rcx),%dl
0a11|223344556677885f5f5f5f5f5f5f	64	intel	or dl, byte ptr [rcx]
0a11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL 0(CX), DL
0b11|223344556677885f5f5f5f5f5f5f	32	intel	or edx, dword ptr [ecx]
0b11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL 0(CX), DX
0b11|223344556677885f5f5f5f5f5f5f	64	gnu	or (%rcx),%edx
0b11|223344556677885f5f5f5f5f5f5f	64	intel	or edx, dword ptr [rcx]
0b11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL 0(CX), DX
0c11|223344556677885f5f5f5f5f5f5f	32	intel	or al, 0x11
0c11|223344556677885f5f5f5f5f5f5f	32	plan9	ORL $0x11, AL
0c11|223344556677885f5f5f5f5f5f5f	64	gnu	or $0x11,%al
0c11|223344556677885f5f5f5f5f5f5f	64	intel	or al, 0x11
0c11|223344556677885f5f5f5f5f5f5f	64	plan9	ORL $0x11, AL
0d11223344|556677885f5f5f5f5f5f5f	32	intel	or eax, 0x44332211
0d11223344|556677885f5f5f5f5f5f5f	32	plan9	ORL $0x44332211, AX
0d11223344|556677885f5f5f5f5f5f5f	64	gnu	or $0x44332211,%eax
0d11223344|556677885f5f5f5f5f5f5f	64	intel	or eax, 0x44332211
0d11223344|556677885f5f5f5f5f5f5f	64	plan9	ORL $0x44332211, AX
0e|11223344556677885f5f5f5f5f5f5f	32	intel	push cs
0e|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL CS
0e|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0e|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
0e|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f0000|11223344556677885f5f5f5f5f	32	intel	sldt word ptr [eax]
0f0000|11223344556677885f5f5f5f5f	32	plan9	SLDT 0(AX)
0f0000|11223344556677885f5f5f5f5f	64	gnu	sldt (%rax)
0f0000|11223344556677885f5f5f5f5f	64	intel	sldt word ptr [rax]
0f0000|11223344556677885f5f5f5f5f	64	plan9	SLDT 0(AX)
0f0008|11223344556677885f5f5f5f5f	32	intel	str word ptr [eax]
0f0008|11223344556677885f5f5f5f5f	32	plan9	STR 0(AX)
0f0008|11223344556677885f5f5f5f5f	64	gnu	str (%rax)
0f0008|11223344556677885f5f5f5f5f	64	intel	str word ptr [rax]
0f0008|11223344556677885f5f5f5f5f	64	plan9	STR 0(AX)
0f0011|223344556677885f5f5f5f5f5f	32	intel	lldt word ptr [ecx]
0f0011|223344556677885f5f5f5f5f5f	32	plan9	LLDT 0(CX)
0f0011|223344556677885f5f5f5f5f5f	64	gnu	lldt (%rcx)
0f0011|223344556677885f5f5f5f5f5f	64	intel	lldt word ptr [rcx]
0f0011|223344556677885f5f5f5f5f5f	64	plan9	LLDT 0(CX)
0f0018|11223344556677885f5f5f5f5f	32	intel	ltr word ptr [eax]
0f0018|11223344556677885f5f5f5f5f	32	plan9	LTR 0(AX)
0f0018|11223344556677885f5f5f5f5f	64	gnu	ltr (%rax)
0f0018|11223344556677885f5f5f5f5f	64	intel	ltr word ptr [rax]
0f0018|11223344556677885f5f5f5f5f	64	plan9	LTR 0(AX)
0f0020|11223344556677885f5f5f5f5f	32	intel	verr word ptr [eax]
0f0020|11223344556677885f5f5f5f5f	32	plan9	VERR 0(AX)
0f0020|11223344556677885f5f5f5f5f	64	gnu	verr (%rax)
0f0020|11223344556677885f5f5f5f5f	64	intel	verr word ptr [rax]
0f0020|11223344556677885f5f5f5f5f	64	plan9	VERR 0(AX)
0f0028|11223344556677885f5f5f5f5f	32	intel	verw word ptr [eax]
0f0028|11223344556677885f5f5f5f5f	32	plan9	VERW 0(AX)
0f0028|11223344556677885f5f5f5f5f	64	gnu	verw (%rax)
0f0028|11223344556677885f5f5f5f5f	64	intel	verw word ptr [rax]
0f0028|11223344556677885f5f5f5f5f	64	plan9	VERW 0(AX)
0f0030|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f0030|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f0100|11223344556677885f5f5f5f5f	32	intel	sgdt ptr [eax]
0f0100|11223344556677885f5f5f5f5f	32	plan9	SGDT 0(AX)
0f0100|11223344556677885f5f5f5f5f	64	gnu	sgdtl (%rax)
0f0100|11223344556677885f5f5f5f5f	64	intel	sgdt ptr [rax]
0f0100|11223344556677885f5f5f5f5f	64	plan9	SGDT 0(AX)
0f0108|11223344556677885f5f5f5f5f	32	intel	sidt ptr [eax]
0f0108|11223344556677885f5f5f5f5f	32	plan9	SIDT 0(AX)
0f0108|11223344556677885f5f5f5f5f	64	gnu	sidtl (%rax)
0f0108|11223344556677885f5f5f5f5f	64	intel	sidt ptr [rax]
0f0108|11223344556677885f5f5f5f5f	64	plan9	SIDT 0(AX)
0f0111|223344556677885f5f5f5f5f5f	32	intel	lgdt ptr [ecx]
0f0111|223344556677885f5f5f5f5f5f	32	plan9	LGDT 0(CX)
0f0111|223344556677885f5f5f5f5f5f	64	gnu	lgdtl (%rcx)
0f0111|223344556677885f5f5f5f5f5f	64	intel	lgdt ptr [rcx]
0f0111|223344556677885f5f5f5f5f5f	64	plan9	LGDT 0(CX)
0f0118|11223344556677885f5f5f5f5f	32	intel	lidt ptr [eax]
0f0118|11223344556677885f5f5f5f5f	32	plan9	LIDT 0(AX)
0f0118|11223344556677885f5f5f5f5f	64	gnu	lidtl (%rax)
0f0118|11223344556677885f5f5f5f5f	64	intel	lidt ptr [rax]
0f0118|11223344556677885f5f5f5f5f	64	plan9	LIDT 0(AX)
0f0120|11223344556677885f5f5f5f5f	32	intel	smsw word ptr [eax]
0f0120|11223344556677885f5f5f5f5f	32	plan9	SMSW 0(AX)
0f0120|11223344556677885f5f5f5f5f	64	gnu	smsw (%rax)
0f0120|11223344556677885f5f5f5f5f	64	intel	smsw word ptr [rax]
0f0120|11223344556677885f5f5f5f5f	64	plan9	SMSW 0(AX)
0f0130|11223344556677885f5f5f5f5f	32	intel	lmsw word ptr [eax]
0f0130|11223344556677885f5f5f5f5f	32	plan9	LMSW 0(AX)
0f0130|11223344556677885f5f5f5f5f	64	gnu	lmsw (%rax)
0f0130|11223344556677885f5f5f5f5f	64	intel	lmsw word ptr [rax]
0f0130|11223344556677885f5f5f5f5f	64	plan9	LMSW 0(AX)
0f0138|11223344556677885f5f5f5f5f	32	intel	invlpg byte ptr [eax]
0f0138|11223344556677885f5f5f5f5f	32	plan9	INVLPG 0(AX)
0f0138|11223344556677885f5f5f5f5f	64	gnu	invlpg (%rax)
0f0138|11223344556677885f5f5f5f5f	64	intel	invlpg byte ptr [rax]
0f0138|11223344556677885f5f5f5f5f	64	plan9	INVLPG 0(AX)
0f01c8|11223344556677885f5f5f5f5f	32	intel	monitor
0f01c8|11223344556677885f5f5f5f5f	32	plan9	MONITOR
0f01c8|11223344556677885f5f5f5f5f	64	gnu	monitor %eax,%ecx,%edx
0f01c8|11223344556677885f5f5f5f5f	64	intel	monitor
0f01c8|11223344556677885f5f5f5f5f	64	plan9	MONITOR
0f01c9|11223344556677885f5f5f5f5f	32	intel	mwait
0f01c9|11223344556677885f5f5f5f5f	32	plan9	MWAIT
0f01c9|11223344556677885f5f5f5f5f	64	gnu	mwait %rax,%rcx
0f01c9|11223344556677885f5f5f5f5f	64	intel	mwait
0f01c9|11223344556677885f5f5f5f5f	64	plan9	MWAIT
0f01d0|11223344556677885f5f5f5f5f	32	intel	xgetbv
0f01d0|11223344556677885f5f5f5f5f	32	plan9	XGETBV
0f01d0|11223344556677885f5f5f5f5f	64	gnu	xgetbv
0f01d0|11223344556677885f5f5f5f5f	64	intel	xgetbv
0f01d0|11223344556677885f5f5f5f5f	64	plan9	XGETBV
0f01d1|11223344556677885f5f5f5f5f	32	intel	xsetbv
0f01d1|11223344556677885f5f5f5f5f	32	plan9	XSETBV
0f01d1|11223344556677885f5f5f5f5f	64	gnu	xsetbv
0f01d1|11223344556677885f5f5f5f5f	64	intel	xsetbv
0f01d1|11223344556677885f5f5f5f5f	64	plan9	XSETBV
0f01d5|11223344556677885f5f5f5f5f	32	intel	xend
0f01d5|11223344556677885f5f5f5f5f	32	plan9	XEND
0f01d5|11223344556677885f5f5f5f5f	64	gnu	xend
0f01d5|11223344556677885f5f5f5f5f	64	intel	xend
0f01d5|11223344556677885f5f5f5f5f	64	plan9	XEND
0f01d6|11223344556677885f5f5f5f5f	32	intel	xtest
0f01d6|11223344556677885f5f5f5f5f	32	plan9	XTEST
0f01d6|11223344556677885f5f5f5f5f	64	gnu	xtest
0f01d6|11223344556677885f5f5f5f5f	64	intel	xtest
0f01d6|11223344556677885f5f5f5f5f	64	plan9	XTEST
0f01f8|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f01f8|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f01f8|11223344556677885f5f5f5f5f	64	gnu	swapgs
0f01f8|11223344556677885f5f5f5f5f	64	intel	swapgs
0f01f8|11223344556677885f5f5f5f5f	64	plan9	SWAPGS
0f01f9|11223344556677885f5f5f5f5f	32	intel	rdtscp
0f01f9|11223344556677885f5f5f5f5f	32	plan9	RDTSCP
0f01f9|11223344556677885f5f5f5f5f	64	gnu	rdtscp
0f01f9|11223344556677885f5f5f5f5f	64	intel	rdtscp
0f01f9|11223344556677885f5f5f5f5f	64	plan9	RDTSCP
0f0211|223344556677885f5f5f5f5f5f	32	intel	lar edx, word ptr [ecx]
0f0211|223344556677885f5f5f5f5f5f	32	plan9	LAR 0(CX), DX
0f0211|223344556677885f5f5f5f5f5f	64	gnu	lar (%rcx),%edx
0f0211|223344556677885f5f5f5f5f5f	64	intel	lar edx, word ptr [rcx]
0f0211|223344556677885f5f5f5f5f5f	64	plan9	LAR 0(CX), DX
0f0311|223344556677885f5f5f5f5f5f	32	intel	lsl edx, word ptr [ecx]
0f0311|223344556677885f5f5f5f5f5f	32	plan9	LSL 0(CX), DX
0f0311|223344556677885f5f5f5f5f5f	64	gnu	lsl (%rcx),%edx
0f0311|223344556677885f5f5f5f5f5f	64	intel	lsl edx, word ptr [rcx]
0f0311|223344556677885f5f5f5f5f5f	64	plan9	LSL 0(CX), DX
0f04|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f04|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f05|11223344556677885f5f5f5f5f5f	64	gnu	syscall
0f05|11223344556677885f5f5f5f5f5f	64	intel	syscall
0f05|11223344556677885f5f5f5f5f5f	64	plan9	SYSCALL
0f06|11223344556677885f5f5f5f5f5f	32	intel	clts
0f06|11223344556677885f5f5f5f5f5f	32	plan9	CLTS
0f06|11223344556677885f5f5f5f5f5f	64	gnu	clts
0f06|11223344556677885f5f5f5f5f5f	64	intel	clts
0f06|11223344556677885f5f5f5f5f5f	64	plan9	CLTS
0f07|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f07|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f07|11223344556677885f5f5f5f5f5f	64	gnu	sysretq
0f07|11223344556677885f5f5f5f5f5f	64	intel	sysret
0f07|11223344556677885f5f5f5f5f5f	64	plan9	SYSRET
0f08|11223344556677885f5f5f5f5f5f	32	intel	invd
0f08|11223344556677885f5f5f5f5f5f	32	plan9	INVD
0f08|11223344556677885f5f5f5f5f5f	64	gnu	invd
0f08|11223344556677885f5f5f5f5f5f	64	intel	invd
0f08|11223344556677885f5f5f5f5f5f	64	plan9	INVD
0f09|11223344556677885f5f5f5f5f5f	32	intel	wbinvd
0f09|11223344556677885f5f5f5f5f5f	32	plan9	WBINVD
0f09|11223344556677885f5f5f5f5f5f	64	gnu	wbinvd
0f09|11223344556677885f5f5f5f5f5f	64	intel	wbinvd
0f09|11223344556677885f5f5f5f5f5f	64	plan9	WBINVD
0f0b|11223344556677885f5f5f5f5f5f	32	intel	ud2
0f0b|11223344556677885f5f5f5f5f5f	32	plan9	UD2
0f0b|11223344556677885f5f5f5f5f5f	64	gnu	ud2
0f0b|11223344556677885f5f5f5f5f5f	64	intel	ud2
0f0b|11223344556677885f5f5f5f5f5f	64	plan9	UD2
0f0d08|11223344556677885f5f5f5f5f	32	intel	prefetchw zmmword ptr [eax]
0f0d08|11223344556677885f5f5f5f5f	32	plan9	PREFETCHW 0(AX)
0f0d08|11223344556677885f5f5f5f5f	64	gnu	prefetchw (%rax)
0f0d08|11223344556677885f5f5f5f5f	64	intel	prefetchw zmmword ptr [rax]
0f0d08|11223344556677885f5f5f5f5f	64	plan9	PREFETCHW 0(AX)
0f1011|223344556677885f5f5f5f5f5f	32	intel	movups xmm2, xmmword ptr [ecx]
0f1011|223344556677885f5f5f5f5f5f	32	plan9	MOVUPS 0(CX), X2
0f1011|223344556677885f5f5f5f5f5f	64	gnu	movups (%rcx),%xmm2
0f1011|223344556677885f5f5f5f5f5f	64	intel	movups xmm2, xmmword ptr [rcx]
0f1011|223344556677885f5f5f5f5f5f	64	plan9	MOVUPS 0(CX), X2
0f1122|3344556677885f5f5f5f5f5f5f	32	intel	movups xmmword ptr [edx], xmm4
0f1122|3344556677885f5f5f5f5f5f5f	32	plan9	MOVUPS X4, 0(DX)
0f1122|3344556677885f5f5f5f5f5f5f	64	gnu	movups %xmm4,(%rdx)
0f1122|3344556677885f5f5f5f5f5f5f	64	intel	movups xmmword ptr [rdx], xmm4
0f1122|3344556677885f5f5f5f5f5f5f	64	plan9	MOVUPS X4, 0(DX)
0f1211|223344556677885f5f5f5f5f5f	32	intel	movlps xmm2, qword ptr [ecx]
0f1211|223344556677885f5f5f5f5f5f	32	plan9	MOVLPS 0(CX), X2
0f1211|223344556677885f5f5f5f5f5f	64	gnu	movlps (%rcx),%xmm2
0f1211|223344556677885f5f5f5f5f5f	64	intel	movlps xmm2, qword ptr [rcx]
0f1211|223344556677885f5f5f5f5f5f	64	plan9	MOVLPS 0(CX), X2
0f12c0|11223344556677885f5f5f5f5f	32	intel	movhlps xmm0, xmm0
0f12c0|11223344556677885f5f5f5f5f	32	plan9	MOVHLPS X0, X0
0f12c0|11223344556677885f5f5f5f5f	64	gnu	movhlps %xmm0,%xmm0
0f12c0|11223344556677885f5f5f5f5f	64	intel	movhlps xmm0, xmm0
0f12c0|11223344556677885f5f5f5f5f	64	plan9	MOVHLPS X0, X0
0f1311|223344556677885f5f5f5f5f5f	32	intel	movlps qword ptr [ecx], xmm2
0f1311|223344556677885f5f5f5f5f5f	32	plan9	MOVLPS X2, 0(CX)
0f1311|223344556677885f5f5f5f5f5f	64	gnu	movlps %xmm2,(%rcx)
0f1311|223344556677885f5f5f5f5f5f	64	intel	movlps qword ptr [rcx], xmm2
0f1311|223344556677885f5f5f5f5f5f	64	plan9	MOVLPS X2, 0(CX)
0f1411|223344556677885f5f5f5f5f5f	32	intel	unpcklps xmm2, xmmword ptr [ecx]
0f1411|223344556677885f5f5f5f5f5f	32	plan9	UNPCKLPS 0(CX), X2
0f1411|223344556677885f5f5f5f5f5f	64	gnu	unpcklps (%rcx),%xmm2
0f1411|223344556677885f5f5f5f5f5f	64	intel	unpcklps xmm2, xmmword ptr [rcx]
0f1411|223344556677885f5f5f5f5f5f	64	plan9	UNPCKLPS 0(CX), X2
0f1511|223344556677885f5f5f5f5f5f	32	intel	unpckhps xmm2, xmmword ptr [ecx]
0f1511|223344556677885f5f5f5f5f5f	32	plan9	UNPCKHPS 0(CX), X2
0f1511|223344556677885f5f5f5f5f5f	64	gnu	unpckhps (%rcx),%xmm2
0f1511|223344556677885f5f5f5f5f5f	64	intel	unpckhps xmm2, xmmword ptr [rcx]
0f1511|223344556677885f5f5f5f5f5f	64	plan9	UNPCKHPS 0(CX), X2
0f1611|223344556677885f5f5f5f5f5f	32	intel	movhps xmm2, qword ptr [ecx]
0f1611|223344556677885f5f5f5f5f5f	32	plan9	MOVHPS 0(CX), X2
0f1611|223344556677885f5f5f5f5f5f	64	gnu	movhps (%rcx),%xmm2
0f1611|223344556677885f5f5f5f5f5f	64	intel	movhps xmm2, qword ptr [rcx]
0f1611|223344556677885f5f5f5f5f5f	64	plan9	MOVHPS 0(CX), X2
0f16c0|11223344556677885f5f5f5f5f	32	intel	movlhps xmm0, xmm0
0f16c0|11223344556677885f5f5f5f5f	32	plan9	MOVLHPS X0, X0
0f16c0|11223344556677885f5f5f5f5f	64	gnu	movlhps %xmm0,%xmm0
0f16c0|11223344556677885f5f5f5f5f	64	intel	movlhps xmm0, xmm0
0f16c0|11223344556677885f5f5f5f5f	64	plan9	MOVLHPS X0, X0
0f1711|223344556677885f5f5f5f5f5f	32	intel	movhps qword ptr [ecx], xmm2
0f1711|223344556677885f5f5f5f5f5f	32	plan9	MOVHPS X2, 0(CX)
0f1711|223344556677885f5f5f5f5f5f	64	gnu	movhps %xmm2,(%rcx)
0f1711|223344556677885f5f5f5f5f5f	64	intel	movhps qword ptr [rcx], xmm2
0f1711|223344556677885f5f5f5f5f5f	64	plan9	MOVHPS X2, 0(CX)
0f1800|11223344556677885f5f5f5f5f	32	intel	prefetchnta zmmword ptr [eax]
0f1800|11223344556677885f5f5f5f5f	32	plan9	PREFETCHNTA 0(AX)
0f1800|11223344556677885f5f5f5f5f	64	gnu	prefetchnta (%rax)
0f1800|11223344556677885f5f5f5f5f	64	intel	prefetchnta zmmword ptr [rax]
0f1800|11223344556677885f5f5f5f5f	64	plan9	PREFETCHNTA 0(AX)
0f1808|11223344556677885f5f5f5f5f	32	intel	prefetcht0 zmmword ptr [eax]
0f1808|11223344556677885f5f5f5f5f	32	plan9	PREFETCHT0 0(AX)
0f1808|11223344556677885f5f5f5f5f	64	gnu	prefetcht0 (%rax)
0f1808|11223344556677885f5f5f5f5f	64	intel	prefetcht0 zmmword ptr [rax]
0f1808|11223344556677885f5f5f5f5f	64	plan9	PREFETCHT0 0(AX)
0f1811|223344556677885f5f5f5f5f5f	32	intel	prefetcht1 zmmword ptr [ecx]
0f1811|223344556677885f5f5f5f5f5f	32	plan9	PREFETCHT1 0(CX)
0f1811|223344556677885f5f5f5f5f5f	64	gnu	prefetcht1 (%rcx)
0f1811|223344556677885f5f5f5f5f5f	64	intel	prefetcht1 zmmword ptr [rcx]
0f1811|223344556677885f5f5f5f5f5f	64	plan9	PREFETCHT1 0(CX)
0f1818|11223344556677885f5f5f5f5f	32	intel	prefetcht2 zmmword ptr [eax]
0f1818|11223344556677885f5f5f5f5f	32	plan9	PREFETCHT2 0(AX)
0f1818|11223344556677885f5f5f5f5f	64	gnu	prefetcht2 (%rax)
0f1818|11223344556677885f5f5f5f5f	64	intel	prefetcht2 zmmword ptr [rax]
0f1818|11223344556677885f5f5f5f5f	64	plan9	PREFETCHT2 0(AX)
0f1f00|11223344556677885f5f5f5f5f	32	intel	nop dword ptr [eax], eax
0f1f00|11223344556677885f5f5f5f5f	32	plan9	NOPL 0(AX)
0f1f00|11223344556677885f5f5f5f5f	64	gnu	nopl (%rax)
0f1f00|11223344556677885f5f5f5f5f	64	intel	nop dword ptr [rax], eax
0f1f00|11223344556677885f5f5f5f5f	64	plan9	NOPL 0(AX)
0f2011|223344556677885f5f5f5f5f5f	32	intel	mov ecx, cr2
0f2011|223344556677885f5f5f5f5f5f	32	plan9	MOVL CR2, CX
0f2011|223344556677885f5f5f5f5f5f	64	gnu	mov %cr2,%rcx
0f2011|223344556677885f5f5f5f5f5f	64	intel	mov rcx, cr2
0f2011|223344556677885f5f5f5f5f5f	64	plan9	MOVL CR2, CX
0f2111|223344556677885f5f5f5f5f5f	32	intel	mov ecx, dr2
0f2111|223344556677885f5f5f5f5f5f	32	plan9	MOVL DR2, CX
0f2111|223344556677885f5f5f5f5f5f	64	gnu	mov %db2,%rcx
0f2111|223344556677885f5f5f5f5f5f	64	intel	mov rcx, dr2
0f2111|223344556677885f5f5f5f5f5f	64	plan9	MOVL DR2, CX
0f2211|223344556677885f5f5f5f5f5f	32	intel	mov cr2, ecx
0f2211|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, CR2
0f2211|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%cr2
0f2211|223344556677885f5f5f5f5f5f	64	intel	mov cr2, rcx
0f2211|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, CR2
0f2311|223344556677885f5f5f5f5f5f	32	intel	mov dr2, ecx
0f2311|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, DR2
0f2311|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%db2
0f2311|223344556677885f5f5f5f5f5f	64	intel	mov dr2, rcx
0f2311|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, DR2
0f2411|223344556677885f5f5f5f5f5f	32	intel	mov ecx, tr2
0f2411|223344556677885f5f5f5f5f5f	32	plan9	MOVL TR2, CX
0f2411|223344556677885f5f5f5f5f5f	64	gnu	mov %tr2,%rcx
0f2411|223344556677885f5f5f5f5f5f	64	intel	mov rcx, tr2
0f2411|223344556677885f5f5f5f5f5f	64	plan9	MOVL TR2, CX
0f2611|223344556677885f5f5f5f5f5f	32	intel	mov tr2, ecx
0f2611|223344556677885f5f5f5f5f5f	32	plan9	MOVL CX, TR2
0f2611|223344556677885f5f5f5f5f5f	64	gnu	mov %rcx,%tr2
0f2611|223344556677885f5f5f5f5f5f	64	intel	mov tr2, rcx
0f2611|223344556677885f5f5f5f5f5f	64	plan9	MOVL CX, TR2
0f2811|223344556677885f5f5f5f5f5f	32	intel	movaps xmm2, xmmword ptr [ecx]
0f2811|223344556677885f5f5f5f5f5f	32	plan9	MOVAPS 0(CX), X2
0f2811|223344556677885f5f5f5f5f5f	64	gnu	movaps (%rcx),%xmm2
0f2811|223344556677885f5f5f5f5f5f	64	intel	movaps xmm2, xmmword ptr [rcx]
0f2811|223344556677885f5f5f5f5f5f	64	plan9	MOVAPS 0(CX), X2
0f2911|223344556677885f5f5f5f5f5f	32	intel	movaps xmmword ptr [ecx], xmm2
0f2911|223344556677885f5f5f5f5f5f	32	plan9	MOVAPS X2, 0(CX)
0f2911|223344556677885f5f5f5f5f5f	64	gnu	movaps %xmm2,(%rcx)
0f2911|223344556677885f5f5f5f5f5f	64	intel	movaps xmmword ptr [rcx], xmm2
0f2911|223344556677885f5f5f5f5f5f	64	plan9	MOVAPS X2, 0(CX)
0f2a11|223344556677885f5f5f5f5f5f	32	intel	cvtpi2ps xmm2, qword ptr [ecx]
0f2a11|223344556677885f5f5f5f5f5f	32	plan9	CVTPI2PS 0(CX), X2
0f2a11|223344556677885f5f5f5f5f5f	64	gnu	cvtpi2ps (%rcx),%xmm2
0f2a11|223344556677885f5f5f5f5f5f	64	intel	cvtpi2ps xmm2, qword ptr [rcx]
0f2a11|223344556677885f5f5f5f5f5f	64	plan9	CVTPI2PS 0(CX), X2
0f2b11|223344556677885f5f5f5f5f5f	32	intel	movntps xmmword ptr [ecx], xmm2
0f2b11|223344556677885f5f5f5f5f5f	32	plan9	MOVNTPS X2, 0(CX)
0f2b11|223344556677885f5f5f5f5f5f	64	gnu	movntps %xmm2,(%rcx)
0f2b11|223344556677885f5f5f5f5f5f	64	intel	movntps xmmword ptr [rcx], xmm2
0f2b11|223344556677885f5f5f5f5f5f	64	plan9	MOVNTPS X2, 0(CX)
0f2c11|223344556677885f5f5f5f5f5f	32	intel	cvttps2pi mmx2, qword ptr [ecx]
0f2c11|223344556677885f5f5f5f5f5f	32	plan9	CVTTPS2PI 0(CX), M2
0f2c11|223344556677885f5f5f5f5f5f	64	gnu	cvttps2pi (%rcx),%mm2
0f2c11|223344556677885f5f5f5f5f5f	64	intel	cvttps2pi mmx2, qword ptr [rcx]
0f2c11|223344556677885f5f5f5f5f5f	64	plan9	CVTTPS2PI 0(CX), M2
0f2d11|223344556677885f5f5f5f5f5f	32	intel	cvtps2pi mmx2, qword ptr [ecx]
0f2d11|223344556677885f5f5f5f5f5f	32	plan9	CVTPS2PI 0(CX), M2
0f2d11|223344556677885f5f5f5f5f5f	64	gnu	cvtps2pi (%rcx),%mm2
0f2d11|223344556677885f5f5f5f5f5f	64	intel	cvtps2pi mmx2, qword ptr [rcx]
0f2d11|223344556677885f5f5f5f5f5f	64	plan9	CVTPS2PI 0(CX), M2
0f2e11|223344556677885f5f5f5f5f5f	32	intel	ucomiss xmm2, dword ptr [ecx]
0f2e11|223344556677885f5f5f5f5f5f	32	plan9	UCOMISS 0(CX), X2
0f2e11|223344556677885f5f5f5f5f5f	64	gnu	ucomiss (%rcx),%xmm2
0f2e11|223344556677885f5f5f5f5f5f	64	intel	ucomiss xmm2, dword ptr [rcx]
0f2e11|223344556677885f5f5f5f5f5f	64	plan9	UCOMISS 0(CX), X2
0f2f11|223344556677885f5f5f5f5f5f	32	intel	comiss xmm2, dword ptr [ecx]
0f2f11|223344556677885f5f5f5f5f5f	32	plan9	COMISS 0(CX), X2
0f2f11|223344556677885f5f5f5f5f5f	64	gnu	comiss (%rcx),%xmm2
0f2f11|223344556677885f5f5f5f5f5f	64	intel	comiss xmm2, dword ptr [rcx]
0f2f11|223344556677885f5f5f5f5f5f	64	plan9	COMISS 0(CX), X2
0f30|11223344556677885f5f5f5f5f5f	32	intel	wrmsr
0f30|11223344556677885f5f5f5f5f5f	32	plan9	WRMSR
0f30|11223344556677885f5f5f5f5f5f	64	gnu	wrmsr
0f30|11223344556677885f5f5f5f5f5f	64	intel	wrmsr
0f30|11223344556677885f5f5f5f5f5f	64	plan9	WRMSR
0f31|11223344556677885f5f5f5f5f5f	32	intel	rdtsc
0f31|11223344556677885f5f5f5f5f5f	32	plan9	RDTSC
0f31|11223344556677885f5f5f5f5f5f	64	gnu	rdtsc
0f31|11223344556677885f5f5f5f5f5f	64	intel	rdtsc
0f31|11223344556677885f5f5f5f5f5f	64	plan9	RDTSC
0f32|11223344556677885f5f5f5f5f5f	32	intel	rdmsr
0f32|11223344556677885f5f5f5f5f5f	32	plan9	RDMSR
0f32|11223344556677885f5f5f5f5f5f	64	gnu	rdmsr
0f32|11223344556677885f5f5f5f5f5f	64	intel	rdmsr
0f32|11223344556677885f5f5f5f5f5f	64	plan9	RDMSR
0f33|11223344556677885f5f5f5f5f5f	32	intel	rdpmc
0f33|11223344556677885f5f5f5f5f5f	32	plan9	RDPMC
0f33|11223344556677885f5f5f5f5f5f	64	gnu	rdpmc
0f33|11223344556677885f5f5f5f5f5f	64	intel	rdpmc
0f33|11223344556677885f5f5f5f5f5f	64	plan9	RDPMC
0f34|11223344556677885f5f5f5f5f5f	32	intel	sysenter
0f34|11223344556677885f5f5f5f5f5f	32	plan9	SYSENTER
0f34|11223344556677885f5f5f5f5f5f	64	gnu	sysenter
0f34|11223344556677885f5f5f5f5f5f	64	intel	sysenter
0f34|11223344556677885f5f5f5f5f5f	64	plan9	SYSENTER
0f35|11223344556677885f5f5f5f5f5f	32	intel	sysexit
0f35|11223344556677885f5f5f5f5f5f	32	plan9	SYSEXIT
0f35|11223344556677885f5f5f5f5f5f	64	gnu	sysexit
0f35|11223344556677885f5f5f5f5f5f	64	intel	sysexit
0f35|11223344556677885f5f5f5f5f5f	64	plan9	SYSEXIT
0f380011|223344556677885f5f5f5f5f	32	intel	pshufb mmx2, qword ptr [ecx]
0f380011|223344556677885f5f5f5f5f	32	plan9	PSHUFB 0(CX), M2
0f380011|223344556677885f5f5f5f5f	64	gnu	pshufb (%rcx),%mm2
0f380011|223344556677885f5f5f5f5f	64	intel	pshufb mmx2, qword ptr [rcx]
0f380011|223344556677885f5f5f5f5f	64	plan9	PSHUFB 0(CX), M2
0f380111|223344556677885f5f5f5f5f	32	intel	phaddw mmx2, qword ptr [ecx]
0f380111|223344556677885f5f5f5f5f	32	plan9	PHADDW 0(CX), M2
0f380111|223344556677885f5f5f5f5f	64	gnu	phaddw (%rcx),%mm2
0f380111|223344556677885f5f5f5f5f	64	intel	phaddw mmx2, qword ptr [rcx]
0f380111|223344556677885f5f5f5f5f	64	plan9	PHADDW 0(CX), M2
0f380211|223344556677885f5f5f5f5f	32	intel	phaddd mmx2, qword ptr [ecx]
0f380211|223344556677885f5f5f5f5f	32	plan9	PHADDD 0(CX), M2
0f380211|223344556677885f5f5f5f5f	64	gnu	phaddd (%rcx),%mm2
0f380211|223344556677885f5f5f5f5f	64	intel	phaddd mmx2, qword ptr [rcx]
0f380211|223344556677885f5f5f5f5f	64	plan9	PHADDD 0(CX), M2
0f380311|223344556677885f5f5f5f5f	32	intel	phaddsw mmx2, qword ptr [ecx]
0f380311|223344556677885f5f5f5f5f	32	plan9	PHADDSW 0(CX), M2
0f380311|223344556677885f5f5f5f5f	64	gnu	phaddsw (%rcx),%mm2
0f380311|223344556677885f5f5f5f5f	64	intel	phaddsw mmx2, qword ptr [rcx]
0f380311|223344556677885f5f5f5f5f	64	plan9	PHADDSW 0(CX), M2
0f380411|223344556677885f5f5f5f5f	32	intel	pmaddubsw mmx2, qword ptr [ecx]
0f380411|223344556677885f5f5f5f5f	32	plan9	PMADDUBSW 0(CX), M2
0f380411|223344556677885f5f5f5f5f	64	gnu	pmaddubsw (%rcx),%mm2
0f380411|223344556677885f5f5f5f5f	64	intel	pmaddubsw mmx2, qword ptr [rcx]
0f380411|223344556677885f5f5f5f5f	64	plan9	PMADDUBSW 0(CX), M2
0f380511|223344556677885f5f5f5f5f	32	intel	phsubw mmx2, qword ptr [ecx]
0f380511|223344556677885f5f5f5f5f	32	plan9	PHSUBW 0(CX), M2
0f380511|223344556677885f5f5f5f5f	64	gnu	phsubw (%rcx),%mm2
0f380511|223344556677885f5f5f5f5f	64	intel	phsubw mmx2, qword ptr [rcx]
0f380511|223344556677885f5f5f5f5f	64	plan9	PHSUBW 0(CX), M2
0f380611|223344556677885f5f5f5f5f	32	intel	phsubd mmx2, qword ptr [ecx]
0f380611|223344556677885f5f5f5f5f	32	plan9	PHSUBD 0(CX), M2
0f380611|223344556677885f5f5f5f5f	64	gnu	phsubd (%rcx),%mm2
0f380611|223344556677885f5f5f5f5f	64	intel	phsubd mmx2, qword ptr [rcx]
0f380611|223344556677885f5f5f5f5f	64	plan9	PHSUBD 0(CX), M2
0f380711|223344556677885f5f5f5f5f	32	intel	phsubsw mmx2, qword ptr [ecx]
0f380711|223344556677885f5f5f5f5f	32	plan9	PHSUBSW 0(CX), M2
0f380711|223344556677885f5f5f5f5f	64	gnu	phsubsw (%rcx),%mm2
0f380711|223344556677885f5f5f5f5f	64	intel	phsubsw mmx2, qword ptr [rcx]
0f380711|223344556677885f5f5f5f5f	64	plan9	PHSUBSW 0(CX), M2
0f380811|223344556677885f5f5f5f5f	32	intel	psignb mmx2, qword ptr [ecx]
0f380811|223344556677885f5f5f5f5f	32	plan9	PSIGNB 0(CX), M2
0f380811|223344556677885f5f5f5f5f	64	gnu	psignb (%rcx),%mm2
0f380811|223344556677885f5f5f5f5f	64	intel	psignb mmx2, qword ptr [rcx]
0f380811|223344556677885f5f5f5f5f	64	plan9	PSIGNB 0(CX), M2
0f380911|223344556677885f5f5f5f5f	32	intel	psignw mmx2, qword ptr [ecx]
0f380911|223344556677885f5f5f5f5f	32	plan9	PSIGNW 0(CX), M2
0f380911|223344556677885f5f5f5f5f	64	gnu	psignw (%rcx),%mm2
0f380911|223344556677885f5f5f5f5f	64	intel	psignw mmx2, qword ptr [rcx]
0f380911|223344556677885f5f5f5f5f	64	plan9	PSIGNW 0(CX), M2
0f380a11|223344556677885f5f5f5f5f	32	intel	psignd mmx2, qword ptr [ecx]
0f380a11|223344556677885f5f5f5f5f	32	plan9	PSIGND 0(CX), M2
0f380a11|223344556677885f5f5f5f5f	64	gnu	psignd (%rcx),%mm2
0f380a11|223344556677885f5f5f5f5f	64	intel	psignd mmx2, qword ptr [rcx]
0f380a11|223344556677885f5f5f5f5f	64	plan9	PSIGND 0(CX), M2
0f380b11|223344556677885f5f5f5f5f	32	intel	pmulhrsw mmx2, qword ptr [ecx]
0f380b11|223344556677885f5f5f5f5f	32	plan9	PMULHRSW 0(CX), M2
0f380b11|223344556677885f5f5f5f5f	64	gnu	pmulhrsw (%rcx),%mm2
0f380b11|223344556677885f5f5f5f5f	64	intel	pmulhrsw mmx2, qword ptr [rcx]
0f380b11|223344556677885f5f5f5f5f	64	plan9	PMULHRSW 0(CX), M2
0f3810|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3810|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f3811|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3814|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3815|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3817|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f381c11|223344556677885f5f5f5f5f	32	intel	pabsb mmx2, qword ptr [ecx]
0f381c11|223344556677885f5f5f5f5f	32	plan9	PABSB 0(CX), M2
0f381c11|223344556677885f5f5f5f5f	64	gnu	pabsb (%rcx),%mm2
0f381c11|223344556677885f5f5f5f5f	64	intel	pabsb mmx2, qword ptr [rcx]
0f381c11|223344556677885f5f5f5f5f	64	plan9	PABSB 0(CX), M2
0f381d11|223344556677885f5f5f5f5f	32	intel	pabsw mmx2, qword ptr [ecx]
0f381d11|223344556677885f5f5f5f5f	32	plan9	PABSW 0(CX), M2
0f381d11|223344556677885f5f5f5f5f	64	gnu	pabsw (%rcx),%mm2
0f381d11|223344556677885f5f5f5f5f	64	intel	pabsw mmx2, qword ptr [rcx]
0f381d11|223344556677885f5f5f5f5f	64	plan9	PABSW 0(CX), M2
0f381e11|223344556677885f5f5f5f5f	32	intel	pabsd mmx2, qword ptr [ecx]
0f381e11|223344556677885f5f5f5f5f	32	plan9	PABSD 0(CX), M2
0f381e11|223344556677885f5f5f5f5f	64	gnu	pabsd (%rcx),%mm2
0f381e11|223344556677885f5f5f5f5f	64	intel	pabsd mmx2, qword ptr [rcx]
0f381e11|223344556677885f5f5f5f5f	64	plan9	PABSD 0(CX), M2
0f3820|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3820|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3821|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3822|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3823|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3824|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3825|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3828|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3829|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f382a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f382b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3830|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3831|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3832|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3833|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3834|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3835|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3837|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3838|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3839|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383c|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383d|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383e|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f383f|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3840|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3841|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3882|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38db|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38dc|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38dd|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38de|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f38df|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f38f011|223344556677885f5f5f5f5f	32	intel	movbe edx, dword ptr [ecx]
0f38f011|223344556677885f5f5f5f5f	32	plan9	MOVBE 0(CX), DX
0f38f011|223344556677885f5f5f5f5f	64	gnu	movbe (%rcx),%edx
0f38f011|223344556677885f5f5f5f5f	64	intel	movbe edx, dword ptr [rcx]
0f38f011|223344556677885f5f5f5f5f	64	plan9	MOVBE 0(CX), DX
0f38f111|223344556677885f5f5f5f5f	32	intel	movbe dword ptr [ecx], edx
0f38f111|223344556677885f5f5f5f5f	32	plan9	MOVBE DX, 0(CX)
0f38f111|223344556677885f5f5f5f5f	64	gnu	movbe %edx,(%rcx)
0f38f111|223344556677885f5f5f5f5f	64	intel	movbe dword ptr [rcx], edx
0f38f111|223344556677885f5f5f5f5f	64	plan9	MOVBE DX, 0(CX)
0f3a08|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a08|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a09|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0a|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0b|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0c|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0d|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a0e|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a0f1122|3344556677885f5f5f5f5f	32	intel	palignr mmx2, qword ptr [ecx], 0x22
0f3a0f1122|3344556677885f5f5f5f5f	32	plan9	PALIGNR $0x22, 0(CX), M2
0f3a0f1122|3344556677885f5f5f5f5f	64	gnu	palignr $0x22,(%rcx),%mm2
0f3a0f1122|3344556677885f5f5f5f5f	64	intel	palignr mmx2, qword ptr [rcx], 0x22
0f3a0f1122|3344556677885f5f5f5f5f	64	plan9	PALIGNR $0x22, 0(CX), M2
0f3a11|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a11|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a14|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a15|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a16|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a17|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a20|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a21|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a22|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a40|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a41|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a42|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a44|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a60|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a61|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a62|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3a63|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f3adf|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f4011|223344556677885f5f5f5f5f5f	32	intel	cmovo edx, dword ptr [ecx]
0f4011|223344556677885f5f5f5f5f5f	32	plan9	CMOVO 0(CX), DX
0f4011|223344556677885f5f5f5f5f5f	64	gnu	cmovo (%rcx),%edx
0f4011|223344556677885f5f5f5f5f5f	64	intel	cmovo edx, dword ptr [rcx]
0f4011|223344556677885f5f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
0f4111|223344556677885f5f5f5f5f5f	32	intel	cmovno edx, dword ptr [ecx]
0f4111|223344556677885f5f5f5f5f5f	32	plan9	CMOVNO 0(CX), DX
0f4111|223344556677885f5f5f5f5f5f	64	gnu	cmovno (%rcx),%edx
0f4111|223344556677885f5f5f5f5f5f	64	intel	cmovno edx, dword ptr [rcx]
0f4111|223344556677885f5f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
0f4211|223344556677885f5f5f5f5f5f	32	intel	cmovb edx, dword ptr [ecx]
0f4211|223344556677885f5f5f5f5f5f	32	plan9	CMOVB 0(CX), DX
0f4211|223344556677885f5f5f5f5f5f	64	gnu	cmovb (%rcx),%edx
0f4211|223344556677885f5f5f5f5f5f	64	intel	cmovb edx, dword ptr [rcx]
0f4211|223344556677885f5f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
0f4311|223344556677885f5f5f5f5f5f	32	intel	cmovnb edx, dword ptr [ecx]
0f4311|223344556677885f5f5f5f5f5f	32	plan9	CMOVAE 0(CX), DX
0f4311|223344556677885f5f5f5f5f5f	64	gnu	cmovae (%rcx),%edx
0f4311|223344556677885f5f5f5f5f5f	64	intel	cmovnb edx, dword ptr [rcx]
0f4311|223344556677885f5f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
0f4411|223344556677885f5f5f5f5f5f	32	intel	cmovz edx, dword ptr [ecx]
0f4411|223344556677885f5f5f5f5f5f	32	plan9	CMOVE 0(CX), DX
0f4411|223344556677885f5f5f5f5f5f	64	gnu	cmove (%rcx),%edx
0f4411|223344556677885f5f5f5f5f5f	64	intel	cmovz edx, dword ptr [rcx]
0f4411|223344556677885f5f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
0f4511|223344556677885f5f5f5f5f5f	32	intel	cmovnz edx, dword ptr [ecx]
0f4511|223344556677885f5f5f5f5f5f	32	plan9	CMOVNE 0(CX), DX
0f4511|223344556677885f5f5f5f5f5f	64	gnu	cmovne (%rcx),%edx
0f4511|223344556677885f5f5f5f5f5f	64	intel	cmovnz edx, dword ptr [rcx]
0f4511|223344556677885f5f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
0f4611|223344556677885f5f5f5f5f5f	32	intel	cmovbe edx, dword ptr [ecx]
0f4611|223344556677885f5f5f5f5f5f	32	plan9	CMOVBE 0(CX), DX
0f4611|223344556677885f5f5f5f5f5f	64	gnu	cmovbe (%rcx),%edx
0f4611|223344556677885f5f5f5f5f5f	64	intel	cmovbe edx, dword ptr [rcx]
0f4611|223344556677885f5f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
0f4711|223344556677885f5f5f5f5f5f	32	intel	cmovnbe edx, dword ptr [ecx]
0f4711|223344556677885f5f5f5f5f5f	32	plan9	CMOVA 0(CX), DX
0f4711|223344556677885f5f5f5f5f5f	64	gnu	cmova (%rcx),%edx
0f4711|223344556677885f5f5f5f5f5f	64	intel	cmovnbe edx, dword ptr [rcx]
0f4711|223344556677885f5f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
0f4811|223344556677885f5f5f5f5f5f	32	intel	cmovs edx, dword ptr [ecx]
0f4811|223344556677885f5f5f5f5f5f	32	plan9	CMOVS 0(CX), DX
0f4811|223344556677885f5f5f5f5f5f	64	gnu	cmovs (%rcx),%edx
0f4811|223344556677885f5f5f5f5f5f	64	intel	cmovs edx, dword ptr [rcx]
0f4811|223344556677885f5f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
0f4911|223344556677885f5f5f5f5f5f	32	intel	cmovns edx, dword ptr [ecx]
0f4911|223344556677885f5f5f5f5f5f	32	plan9	CMOVNS 0(CX), DX
0f4911|223344556677885f5f5f5f5f5f	64	gnu	cmovns (%rcx),%edx
0f4911|223344556677885f5f5f5f5f5f	64	intel	cmovns edx, dword ptr [rcx]
0f4911|223344556677885f5f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
0f4a11|223344556677885f5f5f5f5f5f	32	intel	cmovp edx, dword ptr [ecx]
0f4a11|223344556677885f5f5f5f5f5f	32	plan9	CMOVP 0(CX), DX
0f4a11|223344556677885f5f5f5f5f5f	64	gnu	cmovp (%rcx),%edx
0f4a11|223344556677885f5f5f5f5f5f	64	intel	cmovp edx, dword ptr [rcx]
0f4a11|223344556677885f5f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
0f4b11|223344556677885f5f5f5f5f5f	32	intel	cmovnp edx, dword ptr [ecx]
0f4b11|223344556677885f5f5f5f5f5f	32	plan9	CMOVNP 0(CX), DX
0f4b11|223344556677885f5f5f5f5f5f	64	gnu	cmovnp (%rcx),%edx
0f4b11|223344556677885f5f5f5f5f5f	64	intel	cmovnp edx, dword ptr [rcx]
0f4b11|223344556677885f5f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
0f4c11|223344556677885f5f5f5f5f5f	32	intel	cmovl edx, dword ptr [ecx]
0f4c11|223344556677885f5f5f5f5f5f	32	plan9	CMOVL 0(CX), DX
0f4c11|223344556677885f5f5f5f5f5f	64	gnu	cmovl (%rcx),%edx
0f4c11|223344556677885f5f5f5f5f5f	64	intel	cmovl edx, dword ptr [rcx]
0f4c11|223344556677885f5f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
0f4d11|223344556677885f5f5f5f5f5f	32	intel	cmovnl edx, dword ptr [ecx]
0f4d11|223344556677885f5f5f5f5f5f	32	plan9	CMOVGE 0(CX), DX
0f4d11|223344556677885f5f5f5f5f5f	64	gnu	cmovge (%rcx),%edx
0f4d11|223344556677885f5f5f5f5f5f	64	intel	cmovnl edx, dword ptr [rcx]
0f4d11|223344556677885f5f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
0f4e11|223344556677885f5f5f5f5f5f	32	intel	cmovle edx, dword ptr [ecx]
0f4e11|223344556677885f5f5f5f5f5f	32	plan9	CMOVLE 0(CX), DX
0f4e11|223344556677885f5f5f5f5f5f	64	gnu	cmovle (%rcx),%edx
0f4e11|223344556677885f5f5f5f5f5f	64	intel	cmovle edx, dword ptr [rcx]
0f4e11|223344556677885f5f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
0f4f11|223344556677885f5f5f5f5f5f	32	intel	cmovnle edx, dword ptr [ecx]
0f4f11|223344556677885f5f5f5f5f5f	32	plan9	CMOVG 0(CX), DX
0f4f11|223344556677885f5f5f5f5f5f	64	gnu	cmovg (%rcx),%edx
0f4f11|223344556677885f5f5f5f5f5f	64	intel	cmovnle edx, dword ptr [rcx]
0f4f11|223344556677885f5f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
0f5011|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f5011|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f50c0|11223344556677885f5f5f5f5f	32	intel	movmskps eax, xmm0
0f50c0|11223344556677885f5f5f5f5f	32	plan9	MOVMSKPS X0, AX
0f50c0|11223344556677885f5f5f5f5f	64	gnu	movmskps %xmm0,%eax
0f50c0|11223344556677885f5f5f5f5f	64	intel	movmskps eax, xmm0
0f50c0|11223344556677885f5f5f5f5f	64	plan9	MOVMSKPS X0, AX
0f5111|223344556677885f5f5f5f5f5f	32	intel	sqrtps xmm2, xmmword ptr [ecx]
0f5111|223344556677885f5f5f5f5f5f	32	plan9	SQRTPS 0(CX), X2
0f5111|223344556677885f5f5f5f5f5f	64	gnu	sqrtps (%rcx),%xmm2
0f5111|223344556677885f5f5f5f5f5f	64	intel	sqrtps xmm2, xmmword ptr [rcx]
0f5111|223344556677885f5f5f5f5f5f	64	plan9	SQRTPS 0(CX), X2
0f5211|223344556677885f5f5f5f5f5f	32	intel	rsqrtps xmm2, xmmword ptr [ecx]
0f5211|223344556677885f5f5f5f5f5f	32	plan9	RSQRTPS 0(CX), X2
0f5211|223344556677885f5f5f5f5f5f	64	gnu	rsqrtps (%rcx),%xmm2
0f5211|223344556677885f5f5f5f5f5f	64	intel	rsqrtps xmm2, xmmword ptr [rcx]
0f5211|223344556677885f5f5f5f5f5f	64	plan9	RSQRTPS 0(CX), X2
0f5311|223344556677885f5f5f5f5f5f	32	intel	rcpps xmm2, xmmword ptr [ecx]
0f5311|223344556677885f5f5f5f5f5f	32	plan9	RCPPS 0(CX), X2
0f5311|223344556677885f5f5f5f5f5f	64	gnu	rcpps (%rcx),%xmm2
0f5311|223344556677885f5f5f5f5f5f	64	intel	rcpps xmm2, xmmword ptr [rcx]
0f5311|223344556677885f5f5f5f5f5f	64	plan9	RCPPS 0(CX), X2
0f5411|223344556677885f5f5f5f5f5f	32	intel	andps xmm2, xmmword ptr [ecx]
0f5411|223344556677885f5f5f5f5f5f	32	plan9	ANDPS 0(CX), X2
0f5411|223344556677885f5f5f5f5f5f	64	gnu	andps (%rcx),%xmm2
0f5411|223344556677885f5f5f5f5f5f	64	intel	andps xmm2, xmmword ptr [rcx]
0f5411|223344556677885f5f5f5f5f5f	64	plan9	ANDPS 0(CX), X2
0f5511|223344556677885f5f5f5f5f5f	32	intel	andnps xmm2, xmmword ptr [ecx]
0f5511|223344556677885f5f5f5f5f5f	32	plan9	ANDNPS 0(CX), X2
0f5511|223344556677885f5f5f5f5f5f	64	gnu	andnps (%rcx),%xmm2
0f5511|223344556677885f5f5f5f5f5f	64	intel	andnps xmm2, xmmword ptr [rcx]
0f5511|223344556677885f5f5f5f5f5f	64	plan9	ANDNPS 0(CX), X2
0f5611|223344556677885f5f5f5f5f5f	32	intel	orps xmm2, xmmword ptr [ecx]
0f5611|223344556677885f5f5f5f5f5f	32	plan9	ORPS 0(CX), X2
0f5611|223344556677885f5f5f5f5f5f	64	gnu	orps (%rcx),%xmm2
0f5611|223344556677885f5f5f5f5f5f	64	intel	orps xmm2, xmmword ptr [rcx]
0f5611|223344556677885f5f5f5f5f5f	64	plan9	ORPS 0(CX), X2
0f5711|223344556677885f5f5f5f5f5f	32	intel	xorps xmm2, xmmword ptr [ecx]
0f5711|223344556677885f5f5f5f5f5f	32	plan9	XORPS 0(CX), X2
0f5711|223344556677885f5f5f5f5f5f	64	gnu	xorps (%rcx),%xmm2
0f5711|223344556677885f5f5f5f5f5f	64	intel	xorps xmm2, xmmword ptr [rcx]
0f5711|223344556677885f5f5f5f5f5f	64	plan9	XORPS 0(CX), X2
0f5811|223344556677885f5f5f5f5f5f	32	intel	addps xmm2, xmmword ptr [ecx]
0f5811|223344556677885f5f5f5f5f5f	32	plan9	ADDPS 0(CX), X2
0f5811|223344556677885f5f5f5f5f5f	64	gnu	addps (%rcx),%xmm2
0f5811|223344556677885f5f5f5f5f5f	64	intel	addps xmm2, xmmword ptr [rcx]
0f5811|223344556677885f5f5f5f5f5f	64	plan9	ADDPS 0(CX), X2
0f5911|223344556677885f5f5f5f5f5f	32	intel	mulps xmm2, xmmword ptr [ecx]
0f5911|223344556677885f5f5f5f5f5f	32	plan9	MULPS 0(CX), X2
0f5911|223344556677885f5f5f5f5f5f	64	gnu	mulps (%rcx),%xmm2
0f5911|223344556677885f5f5f5f5f5f	64	intel	mulps xmm2, xmmword ptr [rcx]
0f5911|223344556677885f5f5f5f5f5f	64	plan9	MULPS 0(CX), X2
0f5a11|223344556677885f5f5f5f5f5f	32	intel	cvtps2pd xmm2, qword ptr [ecx]
0f5a11|223344556677885f5f5f5f5f5f	32	plan9	CVTPS2PD 0(CX), X2
0f5a11|223344556677885f5f5f5f5f5f	64	gnu	cvtps2pd (%rcx),%xmm2
0f5a11|223344556677885f5f5f5f5f5f	64	intel	cvtps2pd xmm2, qword ptr [rcx]
0f5a11|223344556677885f5f5f5f5f5f	64	plan9	CVTPS2PD 0(CX), X2
0f5b11|223344556677885f5f5f5f5f5f	32	intel	cvtdq2ps xmm2, xmmword ptr [ecx]
0f5b11|223344556677885f5f5f5f5f5f	32	plan9	CVTDQ2PS 0(CX), X2
0f5b11|223344556677885f5f5f5f5f5f	64	gnu	cvtdq2ps (%rcx),%xmm2
0f5b11|223344556677885f5f5f5f5f5f	64	intel	cvtdq2ps xmm2, xmmword ptr [rcx]
0f5b11|223344556677885f5f5f5f5f5f	64	plan9	CVTDQ2PS 0(CX), X2
0f5c11|223344556677885f5f5f5f5f5f	32	intel	subps xmm2, xmmword ptr [ecx]
0f5c11|223344556677885f5f5f5f5f5f	32	plan9	SUBPS 0(CX), X2
0f5c11|223344556677885f5f5f5f5f5f	64	gnu	subps (%rcx),%xmm2
0f5c11|223344556677885f5f5f5f5f5f	64	intel	subps xmm2, xmmword ptr [rcx]
0f5c11|223344556677885f5f5f5f5f5f	64	plan9	SUBPS 0(CX), X2
0f5d11|223344556677885f5f5f5f5f5f	32	intel	minps xmm2, xmmword ptr [ecx]
0f5d11|223344556677885f5f5f5f5f5f	32	plan9	MINPS 0(CX), X2
0f5d11|223344556677885f5f5f5f5f5f	64	gnu	minps (%rcx),%xmm2
0f5d11|223344556677885f5f5f5f5f5f	64	intel	minps xmm2, xmmword ptr [rcx]
0f5d11|223344556677885f5f5f5f5f5f	64	plan9	MINPS 0(CX), X2
0f5e11|223344556677885f5f5f5f5f5f	32	intel	divps xmm2, xmmword ptr [ecx]
0f5e11|223344556677885f5f5f5f5f5f	32	plan9	DIVPS 0(CX), X2
0f5e11|223344556677885f5f5f5f5f5f	64	gnu	divps (%rcx),%xmm2
0f5e11|223344556677885f5f5f5f5f5f	64	intel	divps xmm2, xmmword ptr [rcx]
0f5e11|223344556677885f5f5f5f5f5f	64	plan9	DIVPS 0(CX), X2
0f5f11|223344556677885f5f5f5f5f5f	32	intel	maxps xmm2, xmmword ptr [ecx]
0f5f11|223344556677885f5f5f5f5f5f	32	plan9	MAXPS 0(CX), X2
0f5f11|223344556677885f5f5f5f5f5f	64	gnu	maxps (%rcx),%xmm2
0f5f11|223344556677885f5f5f5f5f5f	64	intel	maxps xmm2, xmmword ptr [rcx]
0f5f11|223344556677885f5f5f5f5f5f	64	plan9	MAXPS 0(CX), X2
0f6011|223344556677885f5f5f5f5f5f	32	intel	punpcklbw mmx2, dword ptr [ecx]
0f6011|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLBW 0(CX), M2
0f6011|223344556677885f5f5f5f5f5f	64	gnu	punpcklbw (%rcx),%mm2
0f6011|223344556677885f5f5f5f5f5f	64	intel	punpcklbw mmx2, dword ptr [rcx]
0f6011|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLBW 0(CX), M2
0f6111|223344556677885f5f5f5f5f5f	32	intel	punpcklwd mmx2, dword ptr [ecx]
0f6111|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLWD 0(CX), M2
0f6111|223344556677885f5f5f5f5f5f	64	gnu	punpcklwd (%rcx),%mm2
0f6111|223344556677885f5f5f5f5f5f	64	intel	punpcklwd mmx2, dword ptr [rcx]
0f6111|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLWD 0(CX), M2
0f6211|223344556677885f5f5f5f5f5f	32	intel	punpckldq mmx2, dword ptr [ecx]
0f6211|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKLDQ 0(CX), M2
0f6211|223344556677885f5f5f5f5f5f	64	gnu	punpckldq (%rcx),%mm2
0f6211|223344556677885f5f5f5f5f5f	64	intel	punpckldq mmx2, dword ptr [rcx]
0f6211|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKLDQ 0(CX), M2
0f6311|223344556677885f5f5f5f5f5f	32	intel	packsswb mmx2, qword ptr [ecx]
0f6311|223344556677885f5f5f5f5f5f	32	plan9	PACKSSWB 0(CX), M2
0f6311|223344556677885f5f5f5f5f5f	64	gnu	packsswb (%rcx),%mm2
0f6311|223344556677885f5f5f5f5f5f	64	intel	packsswb mmx2, qword ptr [rcx]
0f6311|223344556677885f5f5f5f5f5f	64	plan9	PACKSSWB 0(CX), M2
0f6411|223344556677885f5f5f5f5f5f	32	intel	pcmpgtb mmx2, qword ptr [ecx]
0f6411|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTB 0(CX), M2
0f6411|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtb (%rcx),%mm2
0f6411|223344556677885f5f5f5f5f5f	64	intel	pcmpgtb mmx2, qword ptr [rcx]
0f6411|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTB 0(CX), M2
0f6511|223344556677885f5f5f5f5f5f	32	intel	pcmpgtw mmx2, qword ptr [ecx]
0f6511|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTW 0(CX), M2
0f6511|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtw (%rcx),%mm2
0f6511|223344556677885f5f5f5f5f5f	64	intel	pcmpgtw mmx2, qword ptr [rcx]
0f6511|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTW 0(CX), M2
0f6611|223344556677885f5f5f5f5f5f	32	intel	pcmpgtd mmx2, qword ptr [ecx]
0f6611|223344556677885f5f5f5f5f5f	32	plan9	PCMPGTD 0(CX), M2
0f6611|223344556677885f5f5f5f5f5f	64	gnu	pcmpgtd (%rcx),%mm2
0f6611|223344556677885f5f5f5f5f5f	64	intel	pcmpgtd mmx2, qword ptr [rcx]
0f6611|223344556677885f5f5f5f5f5f	64	plan9	PCMPGTD 0(CX), M2
0f6711|223344556677885f5f5f5f5f5f	32	intel	packuswb mmx2, qword ptr [ecx]
0f6711|223344556677885f5f5f5f5f5f	32	plan9	PACKUSWB 0(CX), M2
0f6711|223344556677885f5f5f5f5f5f	64	gnu	packuswb (%rcx),%mm2
0f6711|223344556677885f5f5f5f5f5f	64	intel	packuswb mmx2, qword ptr [rcx]
0f6711|223344556677885f5f5f5f5f5f	64	plan9	PACKUSWB 0(CX), M2
0f6811|223344556677885f5f5f5f5f5f	32	intel	punpckhbw mmx2, qword ptr [ecx]
0f6811|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHBW 0(CX), M2
0f6811|223344556677885f5f5f5f5f5f	64	gnu	punpckhbw (%rcx),%mm2
0f6811|223344556677885f5f5f5f5f5f	64	intel	punpckhbw mmx2, qword ptr [rcx]
0f6811|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHBW 0(CX), M2
0f6911|223344556677885f5f5f5f5f5f	32	intel	punpckhwd mmx2, qword ptr [ecx]
0f6911|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHWD 0(CX), M2
0f6911|223344556677885f5f5f5f5f5f	64	gnu	punpckhwd (%rcx),%mm2
0f6911|223344556677885f5f5f5f5f5f	64	intel	punpckhwd mmx2, qword ptr [rcx]
0f6911|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHWD 0(CX), M2
0f6a11|223344556677885f5f5f5f5f5f	32	intel	punpckhdq mmx2, qword ptr [ecx]
0f6a11|223344556677885f5f5f5f5f5f	32	plan9	PUNPCKHDQ 0(CX), M2
0f6a11|223344556677885f5f5f5f5f5f	64	gnu	punpckhdq (%rcx),%mm2
0f6a11|223344556677885f5f5f5f5f5f	64	intel	punpckhdq mmx2, qword ptr [rcx]
0f6a11|223344556677885f5f5f5f5f5f	64	plan9	PUNPCKHDQ 0(CX), M2
0f6b11|223344556677885f5f5f5f5f5f	32	intel	packssdw mmx2, qword ptr [ecx]
0f6b11|223344556677885f5f5f5f5f5f	32	plan9	PACKSSDW 0(CX), M2
0f6b11|223344556677885f5f5f5f5f5f	64	gnu	packssdw (%rcx),%mm2
0f6b11|223344556677885f5f5f5f5f5f	64	intel	packssdw mmx2, qword ptr [rcx]
0f6b11|223344556677885f5f5f5f5f5f	64	plan9	PACKSSDW 0(CX), M2
0f6c|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f6c|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f6d|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f6e11|223344556677885f5f5f5f5f5f	32	intel	movd mmx2, dword ptr [ecx]
0f6e11|223344556677885f5f5f5f5f5f	32	plan9	MOVD 0(CX), M2
0f6e11|223344556677885f5f5f5f5f5f	64	gnu	movd (%rcx),%mm2
0f6e11|223344556677885f5f5f5f5f5f	64	intel	movd mmx2, dword ptr [rcx]
0f6e11|223344556677885f5f5f5f5f5f	64	plan9	MOVD 0(CX), M2
0f6f11|223344556677885f5f5f5f5f5f	32	intel	movq mmx2, qword ptr [ecx]
0f6f11|223344556677885f5f5f5f5f5f	32	plan9	MOVQ 0(CX), M2
0f6f11|223344556677885f5f5f5f5f5f	64	gnu	movq (%rcx),%mm2
0f6f11|223344556677885f5f5f5f5f5f	64	intel	movq mmx2, qword ptr [rcx]
0f6f11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), M2
0f701122|3344556677885f5f5f5f5f5f	32	intel	pshufw mmx2, qword ptr [ecx], 0x22
0f701122|3344556677885f5f5f5f5f5f	32	plan9	PSHUFW $0x22, 0(CX), M2
0f701122|3344556677885f5f5f5f5f5f	64	gnu	pshufw $0x22,(%rcx),%mm2
0f701122|3344556677885f5f5f5f5f5f	64	intel	pshufw mmx2, qword ptr [rcx], 0x22
0f701122|3344556677885f5f5f5f5f5f	64	plan9	PSHUFW $0x22, 0(CX), M2
0f7100|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7100|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f711122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f712011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f713011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f71d011|223344556677885f5f5f5f5f	32	intel	psrlw mmx0, 0x11
0f71d011|223344556677885f5f5f5f5f	32	plan9	PSRLW $0x11, M0
0f71d011|223344556677885f5f5f5f5f	64	gnu	psrlw $0x11,%mm0
0f71d011|223344556677885f5f5f5f5f	64	intel	psrlw mmx0, 0x11
0f71d011|223344556677885f5f5f5f5f	64	plan9	PSRLW $0x11, M0
0f71e011|223344556677885f5f5f5f5f	32	intel	psraw mmx0, 0x11
0f71e011|223344556677885f5f5f5f5f	32	plan9	PSRAW $0x11, M0
0f71e011|223344556677885f5f5f5f5f	64	gnu	psraw $0x11,%mm0
0f71e011|223344556677885f5f5f5f5f	64	intel	psraw mmx0, 0x11
0f71e011|223344556677885f5f5f5f5f	64	plan9	PSRAW $0x11, M0
0f71f011|223344556677885f5f5f5f5f	32	intel	psllw mmx0, 0x11
0f71f011|223344556677885f5f5f5f5f	32	plan9	PSLLW $0x11, M0
0f71f011|223344556677885f5f5f5f5f	64	gnu	psllw $0x11,%mm0
0f71f011|223344556677885f5f5f5f5f	64	intel	psllw mmx0, 0x11
0f71f011|223344556677885f5f5f5f5f	64	plan9	PSLLW $0x11, M0
0f7200|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7200|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f721122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f722011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f723011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f72d011|223344556677885f5f5f5f5f	32	intel	psrld mmx0, 0x11
0f72d011|223344556677885f5f5f5f5f	32	plan9	PSRLD $0x11, M0
0f72d011|223344556677885f5f5f5f5f	64	gnu	psrld $0x11,%mm0
0f72d011|223344556677885f5f5f5f5f	64	intel	psrld mmx0, 0x11
0f72d011|223344556677885f5f5f5f5f	64	plan9	PSRLD $0x11, M0
0f72e011|223344556677885f5f5f5f5f	32	intel	psrad mmx0, 0x11
0f72e011|223344556677885f5f5f5f5f	32	plan9	PSRAD $0x11, M0
0f72e011|223344556677885f5f5f5f5f	64	gnu	psrad $0x11,%mm0
0f72e011|223344556677885f5f5f5f5f	64	intel	psrad mmx0, 0x11
0f72e011|223344556677885f5f5f5f5f	64	plan9	PSRAD $0x11, M0
0f72f011|223344556677885f5f5f5f5f	32	intel	pslld mmx0, 0x11
0f72f011|223344556677885f5f5f5f5f	32	plan9	PSLLD $0x11, M0
0f72f011|223344556677885f5f5f5f5f	64	gnu	pslld $0x11,%mm0
0f72f011|223344556677885f5f5f5f5f	64	intel	pslld mmx0, 0x11
0f72f011|223344556677885f5f5f5f5f	64	plan9	PSLLD $0x11, M0
0f7300|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7300|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f731122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7318|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f733011|223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0f7338|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0f73d011|223344556677885f5f5f5f5f	32	intel	psrlq mmx0, 0x11
0f73d011|223344556677885f5f5f5f5f	32	plan9	PSRLQ $0x11, M0
0f73d011|223344556677885f5f5f5f5f	64	gnu	psrlq $0x11,%mm0
0f73d011|223344556677885f5f5f5f5f	64	intel	psrlq mmx0, 0x11
0f73d011|223344556677885f5f5f5f5f	64	plan9	PSRLQ $0x11, M0
0f73f011|223344556677885f5f5f5f5f	32	intel	psllq mmx0, 0x11
0f73f011|223344556677885f5f5f5f5f	32	plan9	PSLLQ $0x11, M0
0f73f011|223344556677885f5f5f5f5f	64	gnu	psllq $0x11,%mm0
0f73f011|223344556677885f5f5f5f5f	64	intel	psllq mmx0, 0x11
0f73f011|223344556677885f5f5f5f5f	64	plan9	PSLLQ $0x11, M0
0f7411|223344556677885f5f5f5f5f5f	32	intel	pcmpeqb mmx2, qword ptr [ecx]
0f7411|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQB 0(CX), M2
0f7411|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqb (%rcx),%mm2
0f7411|223344556677885f5f5f5f5f5f	64	intel	pcmpeqb mmx2, qword ptr [rcx]
0f7411|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQB 0(CX), M2
0f7511|223344556677885f5f5f5f5f5f	32	intel	pcmpeqw mmx2, qword ptr [ecx]
0f7511|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQW 0(CX), M2
0f7511|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqw (%rcx),%mm2
0f7511|223344556677885f5f5f5f5f5f	64	intel	pcmpeqw mmx2, qword ptr [rcx]
0f7511|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQW 0(CX), M2
0f7611|223344556677885f5f5f5f5f5f	32	intel	pcmpeqd mmx2, qword ptr [ecx]
0f7611|223344556677885f5f5f5f5f5f	32	plan9	PCMPEQD 0(CX), M2
0f7611|223344556677885f5f5f5f5f5f	64	gnu	pcmpeqd (%rcx),%mm2
0f7611|223344556677885f5f5f5f5f5f	64	intel	pcmpeqd mmx2, qword ptr [rcx]
0f7611|223344556677885f5f5f5f5f5f	64	plan9	PCMPEQD 0(CX), M2
0f77|11223344556677885f5f5f5f5f5f	32	intel	emms
0f77|11223344556677885f5f5f5f5f5f	32	plan9	EMMS
0f77|11223344556677885f5f5f5f5f5f	64	gnu	emms
0f77|11223344556677885f5f5f5f5f5f	64	intel	emms
0f77|11223344556677885f5f5f5f5f5f	64	plan9	EMMS
0f7c|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f7c|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0f7d|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0f7e11|223344556677885f5f5f5f5f5f	32	intel	movd dword ptr [ecx], mmx2
0f7e11|223344556677885f5f5f5f5f5f	32	plan9	MOVD M2, 0(CX)
0f7e11|223344556677885f5f5f5f5f5f	64	gnu	movd %mm2,(%rcx)
0f7e11|223344556677885f5f5f5f5f5f	64	intel	movd dword ptr [rcx], mmx2
0f7e11|223344556677885f5f5f5f5f5f	64	plan9	MOVD M2, 0(CX)
0f7f11|223344556677885f5f5f5f5f5f	32	intel	movq qword ptr [ecx], mmx2
0f7f11|223344556677885f5f5f5f5f5f	32	plan9	MOVQ M2, 0(CX)
0f7f11|223344556677885f5f5f5f5f5f	64	gnu	movq %mm2,(%rcx)
0f7f11|223344556677885f5f5f5f5f5f	64	intel	movq qword ptr [rcx], mmx2
0f7f11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ M2, 0(CX)
0f8011223344|556677885f5f5f5f5f5f	32	intel	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	32	plan9	JO .+1144201745
0f8011223344|556677885f5f5f5f5f5f	64	gnu	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	64	intel	jo .+0x44332211
0f8011223344|556677885f5f5f5f5f5f	64	plan9	JO .+1144201745
0f8111223344|556677885f5f5f5f5f5f	32	intel	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	32	plan9	JNO .+1144201745
0f8111223344|556677885f5f5f5f5f5f	64	gnu	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	64	intel	jno .+0x44332211
0f8111223344|556677885f5f5f5f5f5f	64	plan9	JNO .+1144201745
0f8211223344|556677885f5f5f5f5f5f	32	intel	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	32	plan9	JB .+1144201745
0f8211223344|556677885f5f5f5f5f5f	64	gnu	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	64	intel	jb .+0x44332211
0f8211223344|556677885f5f5f5f5f5f	64	plan9	JB .+1144201745
0f8311223344|556677885f5f5f5f5f5f	32	intel	jnb .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	32	plan9	JAE .+1144201745
0f8311223344|556677885f5f5f5f5f5f	64	gnu	jae .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	64	intel	jnb .+0x44332211
0f8311223344|556677885f5f5f5f5f5f	64	plan9	JAE .+1144201745
0f8411223344|556677885f5f5f5f5f5f	32	intel	jz .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	32	plan9	JE .+1144201745
0f8411223344|556677885f5f5f5f5f5f	64	gnu	je .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	64	intel	jz .+0x44332211
0f8411223344|556677885f5f5f5f5f5f	64	plan9	JE .+1144201745
0f8511223344|556677885f5f5f5f5f5f	32	intel	jnz .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	32	plan9	JNE .+1144201745
0f8511223344|556677885f5f5f5f5f5f	64	gnu	jne .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	64	intel	jnz .+0x44332211
0f8511223344|556677885f5f5f5f5f5f	64	plan9	JNE .+1144201745
0f8611223344|556677885f5f5f5f5f5f	32	intel	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	32	plan9	JBE .+1144201745
0f8611223344|556677885f5f5f5f5f5f	64	gnu	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	64	intel	jbe .+0x44332211
0f8611223344|556677885f5f5f5f5f5f	64	plan9	JBE .+1144201745
0f8711223344|556677885f5f5f5f5f5f	32	intel	jnbe .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	32	plan9	JA .+1144201745
0f8711223344|556677885f5f5f5f5f5f	64	gnu	ja .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	64	intel	jnbe .+0x44332211
0f8711223344|556677885f5f5f5f5f5f	64	plan9	JA .+1144201745
0f8811223344|556677885f5f5f5f5f5f	32	intel	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	32	plan9	JS .+1144201745
0f8811223344|556677885f5f5f5f5f5f	64	gnu	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	64	intel	js .+0x44332211
0f8811223344|556677885f5f5f5f5f5f	64	plan9	JS .+1144201745
0f8911223344|556677885f5f5f5f5f5f	32	intel	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	32	plan9	JNS .+1144201745
0f8911223344|556677885f5f5f5f5f5f	64	gnu	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	64	intel	jns .+0x44332211
0f8911223344|556677885f5f5f5f5f5f	64	plan9	JNS .+1144201745
0f8a11223344|556677885f5f5f5f5f5f	32	intel	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	32	plan9	JP .+1144201745
0f8a11223344|556677885f5f5f5f5f5f	64	gnu	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	64	intel	jp .+0x44332211
0f8a11223344|556677885f5f5f5f5f5f	64	plan9	JP .+1144201745
0f8b11223344|556677885f5f5f5f5f5f	32	intel	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	32	plan9	JNP .+1144201745
0f8b11223344|556677885f5f5f5f5f5f	64	gnu	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	64	intel	jnp .+0x44332211
0f8b11223344|556677885f5f5f5f5f5f	64	plan9	JNP .+1144201745
0f8c11223344|556677885f5f5f5f5f5f	32	intel	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	32	plan9	JL .+1144201745
0f8c11223344|556677885f5f5f5f5f5f	64	gnu	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	64	intel	jl .+0x44332211
0f8c11223344|556677885f5f5f5f5f5f	64	plan9	JL .+1144201745
0f8d11223344|556677885f5f5f5f5f5f	32	intel	jnl .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	32	plan9	JGE .+1144201745
0f8d11223344|556677885f5f5f5f5f5f	64	gnu	jge .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	64	intel	jnl .+0x44332211
0f8d11223344|556677885f5f5f5f5f5f	64	plan9	JGE .+1144201745
0f8e11223344|556677885f5f5f5f5f5f	32	intel	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	32	plan9	JLE .+1144201745
0f8e11223344|556677885f5f5f5f5f5f	64	gnu	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	64	intel	jle .+0x44332211
0f8e11223344|556677885f5f5f5f5f5f	64	plan9	JLE .+1144201745
0f8f11223344|556677885f5f5f5f5f5f	32	intel	jnle .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	32	plan9	JG .+1144201745
0f8f11223344|556677885f5f5f5f5f5f	64	gnu	jg .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	64	intel	jnle .+0x44332211
0f8f11223344|556677885f5f5f5f5f5f	64	plan9	JG .+1144201745
0f9011|223344556677885f5f5f5f5f5f	32	intel	seto byte ptr [ecx]
0f9011|223344556677885f5f5f5f5f5f	32	plan9	SETO 0(CX)
0f9011|223344556677885f5f5f5f5f5f	64	gnu	seto (%rcx)
0f9011|223344556677885f5f5f5f5f5f	64	intel	seto byte ptr [rcx]
0f9011|223344556677885f5f5f5f5f5f	64	plan9	SETO 0(CX)
0f9111|223344556677885f5f5f5f5f5f	32	intel	setno byte ptr [ecx]
0f9111|223344556677885f5f5f5f5f5f	32	plan9	SETNO 0(CX)
0f9111|223344556677885f5f5f5f5f5f	64	gnu	setno (%rcx)
0f9111|223344556677885f5f5f5f5f5f	64	intel	setno byte ptr [rcx]
0f9111|223344556677885f5f5f5f5f5f	64	plan9	SETNO 0(CX)
0f9211|223344556677885f5f5f5f5f5f	32	intel	setb byte ptr [ecx]
0f9211|223344556677885f5f5f5f5f5f	32	plan9	SETB 0(CX)
0f9211|223344556677885f5f5f5f5f5f	64	gnu	setb (%rcx)
0f9211|223344556677885f5f5f5f5f5f	64	intel	setb byte ptr [rcx]
0f9211|223344556677885f5f5f5f5f5f	64	plan9	SETB 0(CX)
0f9311|223344556677885f5f5f5f5f5f	32	intel	setnb byte ptr [ecx]
0f9311|223344556677885f5f5f5f5f5f	32	plan9	SETAE 0(CX)
0f9311|223344556677885f5f5f5f5f5f	64	gnu	setae (%rcx)
0f9311|223344556677885f5f5f5f5f5f	64	intel	setnb byte ptr [rcx]
0f9311|223344556677885f5f5f5f5f5f	64	plan9	SETAE 0(CX)
0f9411|223344556677885f5f5f5f5f5f	32	intel	setz byte ptr [ecx]
0f9411|223344556677885f5f5f5f5f5f	32	plan9	SETE 0(CX)
0f9411|223344556677885f5f5f5f5f5f	64	gnu	sete (%rcx)
0f9411|223344556677885f5f5f5f5f5f	64	intel	setz byte ptr [rcx]
0f9411|223344556677885f5f5f5f5f5f	64	plan9	SETE 0(CX)
0f9511|223344556677885f5f5f5f5f5f	32	intel	setnz byte ptr [ecx]
0f9511|223344556677885f5f5f5f5f5f	32	plan9	SETNE 0(CX)
0f9511|223344556677885f5f5f5f5f5f	64	gnu	setne (%rcx)
0f9511|223344556677885f5f5f5f5f5f	64	intel	setnz byte ptr [rcx]
0f9511|223344556677885f5f5f5f5f5f	64	plan9	SETNE 0(CX)
0f9611|223344556677885f5f5f5f5f5f	32	intel	setbe byte ptr [ecx]
0f9611|223344556677885f5f5f5f5f5f	32	plan9	SETBE 0(CX)
0f9611|223344556677885f5f5f5f5f5f	64	gnu	setbe (%rcx)
0f9611|223344556677885f5f5f5f5f5f	64	intel	setbe byte ptr [rcx]
0f9611|223344556677885f5f5f5f5f5f	64	plan9	SETBE 0(CX)
0f9711|223344556677885f5f5f5f5f5f	32	intel	setnbe byte ptr [ecx]
0f9711|223344556677885f5f5f5f5f5f	32	plan9	SETA 0(CX)
0f9711|223344556677885f5f5f5f5f5f	64	gnu	seta (%rcx)
0f9711|223344556677885f5f5f5f5f5f	64	intel	setnbe byte ptr [rcx]
0f9711|223344556677885f5f5f5f5f5f	64	plan9	SETA 0(CX)
0f9811|223344556677885f5f5f5f5f5f	32	intel	sets byte ptr [ecx]
0f9811|223344556677885f5f5f5f5f5f	32	plan9	SETS 0(CX)
0f9811|223344556677885f5f5f5f5f5f	64	gnu	sets (%rcx)
0f9811|223344556677885f5f5f5f5f5f	64	intel	sets byte ptr [rcx]
0f9811|223344556677885f5f5f5f5f5f	64	plan9	SETS 0(CX)
0f9911|223344556677885f5f5f5f5f5f	32	intel	setns byte ptr [ecx]
0f9911|223344556677885f5f5f5f5f5f	32	plan9	SETNS 0(CX)
0f9911|223344556677885f5f5f5f5f5f	64	gnu	setns (%rcx)
0f9911|223344556677885f5f5f5f5f5f	64	intel	setns byte ptr [rcx]
0f9911|223344556677885f5f5f5f5f5f	64	plan9	SETNS 0(CX)
0f9a11|223344556677885f5f5f5f5f5f	32	intel	setp byte ptr [ecx]
0f9a11|223344556677885f5f5f5f5f5f	32	plan9	SETP 0(CX)
0f9a11|223344556677885f5f5f5f5f5f	64	gnu	setp (%rcx)
0f9a11|223344556677885f5f5f5f5f5f	64	intel	setp byte ptr [rcx]
0f9a11|223344556677885f5f5f5f5f5f	64	plan9	SETP 0(CX)
0f9b11|223344556677885f5f5f5f5f5f	32	intel	setnp byte ptr [ecx]
0f9b11|223344556677885f5f5f5f5f5f	32	plan9	SETNP 0(CX)
0f9b11|223344556677885f5f5f5f5f5f	64	gnu	setnp (%rcx)
0f9b11|223344556677885f5f5f5f5f5f	64	intel	setnp byte ptr [rcx]
0f9b11|223344556677885f5f5f5f5f5f	64	plan9	SETNP 0(CX)
0f9c11|223344556677885f5f5f5f5f5f	32	intel	setl byte ptr [ecx]
0f9c11|223344556677885f5f5f5f5f5f	32	plan9	SETL 0(CX)
0f9c11|223344556677885f5f5f5f5f5f	64	gnu	setl (%rcx)
0f9c11|223344556677885f5f5f5f5f5f	64	intel	setl byte ptr [rcx]
0f9c11|223344556677885f5f5f5f5f5f	64	plan9	SETL 0(CX)
0f9d11|223344556677885f5f5f5f5f5f	32	intel	setnl byte ptr [ecx]
0f9d11|223344556677885f5f5f5f5f5f	32	plan9	SETGE 0(CX)
0f9d11|223344556677885f5f5f5f5f5f	64	gnu	setge (%rcx)
0f9d11|223344556677885f5f5f5f5f5f	64	intel	setnl byte ptr [rcx]
0f9d11|223344556677885f5f5f5f5f5f	64	plan9	SETGE 0(CX)
0f9e11|223344556677885f5f5f5f5f5f	32	intel	setle byte ptr [ecx]
0f9e11|223344556677885f5f5f5f5f5f	32	plan9	SETLE 0(CX)
0f9e11|223344556677885f5f5f5f5f5f	64	gnu	setle (%rcx)
0f9e11|223344556677885f5f5f5f5f5f	64	intel	setle byte ptr [rcx]
0f9e11|223344556677885f5f5f5f5f5f	64	plan9	SETLE 0(CX)
0f9f11|223344556677885f5f5f5f5f5f	32	intel	setnle byte ptr [ecx]
0f9f11|223344556677885f5f5f5f5f5f	32	plan9	SETG 0(CX)
0f9f11|223344556677885f5f5f5f5f5f	64	gnu	setg (%rcx)
0f9f11|223344556677885f5f5f5f5f5f	64	intel	setnle byte ptr [rcx]
0f9f11|223344556677885f5f5f5f5f5f	64	plan9	SETG 0(CX)
0fa0|11223344556677885f5f5f5f5f5f	32	intel	push fs
0fa0|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL FS
0fa0|11223344556677885f5f5f5f5f5f	64	gnu	pushq %fs
0fa0|11223344556677885f5f5f5f5f5f	64	intel	push fs
0fa0|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL FS
0fa1|11223344556677885f5f5f5f5f5f	32	intel	pop fs
0fa1|11223344556677885f5f5f5f5f5f	32	plan9	POPL FS
0fa1|11223344556677885f5f5f5f5f5f	64	gnu	popq %fs
0fa1|11223344556677885f5f5f5f5f5f	64	intel	pop fs
0fa1|11223344556677885f5f5f5f5f5f	64	plan9	POPL FS
0fa2|11223344556677885f5f5f5f5f5f	32	intel	cpuid
0fa2|11223344556677885f5f5f5f5f5f	32	plan9	CPUID
0fa2|11223344556677885f5f5f5f5f5f	64	gnu	cpuid
0fa2|11223344556677885f5f5f5f5f5f	64	intel	cpuid
0fa2|11223344556677885f5f5f5f5f5f	64	plan9	CPUID
0fa311|223344556677885f5f5f5f5f5f	32	intel	bt dword ptr [ecx], edx
0fa311|223344556677885f5f5f5f5f5f	32	plan9	BTL DX, 0(CX)
0fa311|223344556677885f5f5f5f5f5f	64	gnu	bt %edx,(%rcx)
0fa311|223344556677885f5f5f5f5f5f	64	intel	bt dword ptr [rcx], edx
0fa311|223344556677885f5f5f5f5f5f	64	plan9	BTL DX, 0(CX)
0fa41122|3344556677885f5f5f5f5f5f	32	intel	shld dword ptr [ecx], edx, 0x22
0fa41122|3344556677885f5f5f5f5f5f	32	plan9	SHLDL $0x22, DX, 0(CX)
0fa41122|3344556677885f5f5f5f5f5f	64	gnu	shld $0x22,%edx,(%rcx)
0fa41122|3344556677885f5f5f5f5f5f	64	intel	shld dword ptr [rcx], edx, 0x22
0fa41122|3344556677885f5f5f5f5f5f	64	plan9	SHLDL $0x22, DX, 0(CX)
0fa511|223344556677885f5f5f5f5f5f	32	intel	shld dword ptr [ecx], edx, cl
0fa511|223344556677885f5f5f5f5f5f	32	plan9	SHLDL CL, DX, 0(CX)
0fa511|223344556677885f5f5f5f5f5f	64	gnu	shld %cl,%edx,(%rcx)
0fa511|223344556677885f5f5f5f5f5f	64	intel	shld dword ptr [rcx], edx, cl
0fa511|223344556677885f5f5f5f5f5f	64	plan9	SHLDL CL, DX, 0(CX)
0fa8|11223344556677885f5f5f5f5f5f	32	intel	push gs
0fa8|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL GS
0fa8|11223344556677885f5f5f5f5f5f	64	gnu	pushq %gs
0fa8|11223344556677885f5f5f5f5f5f	64	intel	push gs
0fa8|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL GS
0fa9|11223344556677885f5f5f5f5f5f	32	intel	pop gs
0fa9|11223344556677885f5f5f5f5f5f	32	plan9	POPL GS
0fa9|11223344556677885f5f5f5f5f5f	64	gnu	popq %gs
0fa9|11223344556677885f5f5f5f5f5f	64	intel	pop gs
0fa9|11223344556677885f5f5f5f5f5f	64	plan9	POPL GS
0faa|11223344556677885f5f5f5f5f5f	32	intel	rsm
0faa|11223344556677885f5f5f5f5f5f	32	plan9	RSM
0faa|11223344556677885f5f5f5f5f5f	64	gnu	rsm
0faa|11223344556677885f5f5f5f5f5f	64	intel	rsm
0faa|11223344556677885f5f5f5f5f5f	64	plan9	RSM
0fab11|223344556677885f5f5f5f5f5f	32	intel	bts dword ptr [ecx], edx
0fab11|223344556677885f5f5f5f5f5f	32	plan9	BTSL DX, 0(CX)
0fab11|223344556677885f5f5f5f5f5f	64	gnu	bts %edx,(%rcx)
0fab11|223344556677885f5f5f5f5f5f	64	intel	bts dword ptr [rcx], edx
0fab11|223344556677885f5f5f5f5f5f	64	plan9	BTSL DX, 0(CX)
0fac1122|3344556677885f5f5f5f5f5f	32	intel	shrd dword ptr [ecx], edx, 0x22
0fac1122|3344556677885f5f5f5f5f5f	32	plan9	SHRDL $0x22, DX, 0(CX)
0fac1122|3344556677885f5f5f5f5f5f	64	gnu	shrd $0x22,%edx,(%rcx)
0fac1122|3344556677885f5f5f5f5f5f	64	intel	shrd dword ptr [rcx], edx, 0x22
0fac1122|3344556677885f5f5f5f5f5f	64	plan9	SHRDL $0x22, DX, 0(CX)
0fad11|223344556677885f5f5f5f5f5f	32	intel	shrd dword ptr [ecx], edx, cl
0fad11|223344556677885f5f5f5f5f5f	32	plan9	SHRDL CL, DX, 0(CX)
0fad11|223344556677885f5f5f5f5f5f	64	gnu	shrd %cl,%edx,(%rcx)
0fad11|223344556677885f5f5f5f5f5f	64	intel	shrd dword ptr [rcx], edx, cl
0fad11|223344556677885f5f5f5f5f5f	64	plan9	SHRDL CL, DX, 0(CX)
0fae00|11223344556677885f5f5f5f5f	32	intel	fxsave ptr [eax]
0fae00|11223344556677885f5f5f5f5f	32	plan9	FXSAVE 0(AX)
0fae00|11223344556677885f5f5f5f5f	64	gnu	fxsave (%rax)
0fae00|11223344556677885f5f5f5f5f	64	intel	fxsave ptr [rax]
0fae00|11223344556677885f5f5f5f5f	64	plan9	FXSAVE 0(AX)
0fae08|11223344556677885f5f5f5f5f	32	intel	fxrstor ptr [eax]
0fae08|11223344556677885f5f5f5f5f	32	plan9	FXRSTOR 0(AX)
0fae08|11223344556677885f5f5f5f5f	64	gnu	fxrstor (%rax)
0fae08|11223344556677885f5f5f5f5f	64	intel	fxrstor ptr [rax]
0fae08|11223344556677885f5f5f5f5f	64	plan9	FXRSTOR 0(AX)
0fae11|223344556677885f5f5f5f5f5f	32	intel	ldmxcsr dword ptr [ecx]
0fae11|223344556677885f5f5f5f5f5f	32	plan9	LDMXCSR 0(CX)
0fae11|223344556677885f5f5f5f5f5f	64	gnu	ldmxcsr (%rcx)
0fae11|223344556677885f5f5f5f5f5f	64	intel	ldmxcsr dword ptr [rcx]
0fae11|223344556677885f5f5f5f5f5f	64	plan9	LDMXCSR 0(CX)
0fae18|11223344556677885f5f5f5f5f	32	intel	stmxcsr dword ptr [eax]
0fae18|11223344556677885f5f5f5f5f	32	plan9	STMXCSR 0(AX)
0fae18|11223344556677885f5f5f5f5f	64	gnu	stmxcsr (%rax)
0fae18|11223344556677885f5f5f5f5f	64	intel	stmxcsr dword ptr [rax]
0fae18|11223344556677885f5f5f5f5f	64	plan9	STMXCSR 0(AX)
0fae20|11223344556677885f5f5f5f5f	32	intel	xsave ptr [eax]
0fae20|11223344556677885f5f5f5f5f	32	plan9	XSAVE 0(AX)
0fae20|11223344556677885f5f5f5f5f	64	gnu	xsave (%rax)
0fae20|11223344556677885f5f5f5f5f	64	intel	xsave ptr [rax]
0fae20|11223344556677885f5f5f5f5f	64	plan9	XSAVE 0(AX)
0fae28|11223344556677885f5f5f5f5f	32	intel	xrstor ptr [eax]
0fae28|11223344556677885f5f5f5f5f	32	plan9	XRSTOR 0(AX)
0fae28|11223344556677885f5f5f5f5f	64	gnu	xrstor (%rax)
0fae28|11223344556677885f5f5f5f5f	64	intel	xrstor ptr [rax]
0fae28|11223344556677885f5f5f5f5f	64	plan9	XRSTOR 0(AX)
0fae30|11223344556677885f5f5f5f5f	32	intel	xsaveopt ptr [eax]
0fae30|11223344556677885f5f5f5f5f	32	plan9	XSAVEOPT 0(AX)
0fae30|11223344556677885f5f5f5f5f	64	gnu	xsaveopt (%rax)
0fae30|11223344556677885f5f5f5f5f	64	intel	xsaveopt ptr [rax]
0fae30|11223344556677885f5f5f5f5f	64	plan9	XSAVEOPT 0(AX)
0fae38|11223344556677885f5f5f5f5f	32	intel	clflush zmmword ptr [eax]
0fae38|11223344556677885f5f5f5f5f	32	plan9	CLFLUSH 0(AX)
0fae38|11223344556677885f5f5f5f5f	64	gnu	clflush (%rax)
0fae38|11223344556677885f5f5f5f5f	64	intel	clflush zmmword ptr [rax]
0fae38|11223344556677885f5f5f5f5f	64	plan9	CLFLUSH 0(AX)
0faee8|11223344556677885f5f5f5f5f	32	intel	lfence
0faee8|11223344556677885f5f5f5f5f	32	plan9	LFENCE
0faee8|11223344556677885f5f5f5f5f	64	gnu	lfence
0faee8|11223344556677885f5f5f5f5f	64	intel	lfence
0faee8|11223344556677885f5f5f5f5f	64	plan9	LFENCE
0faef0|11223344556677885f5f5f5f5f	32	intel	mfence
0faef0|11223344556677885f5f5f5f5f	32	plan9	MFENCE
0faef0|11223344556677885f5f5f5f5f	64	gnu	mfence
0faef0|11223344556677885f5f5f5f5f	64	intel	mfence
0faef0|11223344556677885f5f5f5f5f	64	plan9	MFENCE
0faef8|11223344556677885f5f5f5f5f	32	intel	sfence
0faef8|11223344556677885f5f5f5f5f	32	plan9	SFENCE
0faef8|11223344556677885f5f5f5f5f	64	gnu	sfence
0faef8|11223344556677885f5f5f5f5f	64	intel	sfence
0faef8|11223344556677885f5f5f5f5f	64	plan9	SFENCE
0faf11|223344556677885f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx]
0faf11|223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(CX), DX
0faf11|223344556677885f5f5f5f5f5f	64	gnu	imul (%rcx),%edx
0faf11|223344556677885f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx]
0faf11|223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(CX), DX
0fb011|223344556677885f5f5f5f5f5f	32	intel	cmpxchg byte ptr [ecx], dl
0fb011|223344556677885f5f5f5f5f5f	32	plan9	CMPXCHGL DL, 0(CX)
0fb011|223344556677885f5f5f5f5f5f	64	gnu	cmpxchg %dl,(%rcx)
0fb011|223344556677885f5f5f5f5f5f	64	intel	cmpxchg byte ptr [rcx], dl
0fb011|223344556677885f5f5f5f5f5f	64	plan9	CMPXCHGL DL, 0(CX)
0fb111|223344556677885f5f5f5f5f5f	32	intel	cmpxchg dword ptr [ecx], edx
0fb111|223344556677885f5f5f5f5f5f	32	plan9	CMPXCHGL DX, 0(CX)
0fb111|223344556677885f5f5f5f5f5f	64	gnu	cmpxchg %edx,(%rcx)
0fb111|223344556677885f5f5f5f5f5f	64	intel	cmpxchg dword ptr [rcx], edx
0fb111|223344556677885f5f5f5f5f5f	64	plan9	CMPXCHGL DX, 0(CX)
0fb211|223344556677885f5f5f5f5f5f	32	intel	lss edx, ptr [ecx]
0fb211|223344556677885f5f5f5f5f5f	32	plan9	LSS 0(CX), DX
0fb211|223344556677885f5f5f5f5f5f	64	gnu	lss (%rcx),%edx
0fb211|223344556677885f5f5f5f5f5f	64	intel	lss edx, ptr [rcx]
0fb211|223344556677885f5f5f5f5f5f	64	plan9	LSS 0(CX), DX
0fb311|223344556677885f5f5f5f5f5f	32	intel	btr dword ptr [ecx], edx
0fb311|223344556677885f5f5f5f5f5f	32	plan9	BTRL DX, 0(CX)
0fb311|223344556677885f5f5f5f5f5f	64	gnu	btr %edx,(%rcx)
0fb311|223344556677885f5f5f5f5f5f	64	intel	btr dword ptr [rcx], edx
0fb311|223344556677885f5f5f5f5f5f	64	plan9	BTRL DX, 0(CX)
0fb411|223344556677885f5f5f5f5f5f	32	intel	lfs edx, ptr [ecx]
0fb411|223344556677885f5f5f5f5f5f	32	plan9	LFS 0(CX), DX
0fb411|223344556677885f5f5f5f5f5f	64	gnu	lfs (%rcx),%edx
0fb411|223344556677885f5f5f5f5f5f	64	intel	lfs edx, ptr [rcx]
0fb411|223344556677885f5f5f5f5f5f	64	plan9	LFS 0(CX), DX
0fb511|223344556677885f5f5f5f5f5f	32	intel	lgs edx, ptr [ecx]
0fb511|223344556677885f5f5f5f5f5f	32	plan9	LGS 0(CX), DX
0fb511|223344556677885f5f5f5f5f5f	64	gnu	lgs (%rcx),%edx
0fb511|223344556677885f5f5f5f5f5f	64	intel	lgs edx, ptr [rcx]
0fb511|223344556677885f5f5f5f5f5f	64	plan9	LGS 0(CX), DX
0fb611|223344556677885f5f5f5f5f5f	32	intel	movzx edx, byte ptr [ecx]
0fb611|223344556677885f5f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
0fb611|223344556677885f5f5f5f5f5f	64	gnu	movzbl (%rcx),%edx
0fb611|223344556677885f5f5f5f5f5f	64	intel	movzx edx, byte ptr [rcx]
0fb611|223344556677885f5f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
0fb711|223344556677885f5f5f5f5f5f	32	intel	movzx edx, word ptr [ecx]
0fb711|223344556677885f5f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
0fb711|223344556677885f5f5f5f5f5f	64	gnu	movzwl (%rcx),%edx
0fb711|223344556677885f5f5f5f5f5f	64	intel	movzx edx, word ptr [rcx]
0fb711|223344556677885f5f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
0fb8|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fb8|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fb9|11223344556677885f5f5f5f5f5f	32	intel	ud1
0fb9|11223344556677885f5f5f5f5f5f	32	plan9	UD1
0fb9|11223344556677885f5f5f5f5f5f	64	gnu	ud1
0fb9|11223344556677885f5f5f5f5f5f	64	intel	ud1
0fb9|11223344556677885f5f5f5f5f5f	64	plan9	UD1
0fba11|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fba11|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fba2011|223344556677885f5f5f5f5f	32	intel	bt dword ptr [eax], 0x11
0fba2011|223344556677885f5f5f5f5f	32	plan9	BTL $0x11, 0(AX)
0fba2011|223344556677885f5f5f5f5f	64	gnu	btl $0x11,(%rax)
0fba2011|223344556677885f5f5f5f5f	64	intel	bt dword ptr [rax], 0x11
0fba2011|223344556677885f5f5f5f5f	64	plan9	BTL $0x11, 0(AX)
0fba2811|223344556677885f5f5f5f5f	32	intel	bts dword ptr [eax], 0x11
0fba2811|223344556677885f5f5f5f5f	32	plan9	BTSL $0x11, 0(AX)
0fba2811|223344556677885f5f5f5f5f	64	gnu	btsl $0x11,(%rax)
0fba2811|223344556677885f5f5f5f5f	64	intel	bts dword ptr [rax], 0x11
0fba2811|223344556677885f5f5f5f5f	64	plan9	BTSL $0x11, 0(AX)
0fba3011|223344556677885f5f5f5f5f	32	intel	btr dword ptr [eax], 0x11
0fba3011|223344556677885f5f5f5f5f	32	plan9	BTRL $0x11, 0(AX)
0fba3011|223344556677885f5f5f5f5f	64	gnu	btrl $0x11,(%rax)
0fba3011|223344556677885f5f5f5f5f	64	intel	btr dword ptr [rax], 0x11
0fba3011|223344556677885f5f5f5f5f	64	plan9	BTRL $0x11, 0(AX)
0fba3811|223344556677885f5f5f5f5f	32	intel	btc dword ptr [eax], 0x11
0fba3811|223344556677885f5f5f5f5f	32	plan9	BTCL $0x11, 0(AX)
0fba3811|223344556677885f5f5f5f5f	64	gnu	btcl $0x11,(%rax)
0fba3811|223344556677885f5f5f5f5f	64	intel	btc dword ptr [rax], 0x11
0fba3811|223344556677885f5f5f5f5f	64	plan9	BTCL $0x11, 0(AX)
0fbb11|223344556677885f5f5f5f5f5f	32	intel	btc dword ptr [ecx], edx
0fbb11|223344556677885f5f5f5f5f5f	32	plan9	BTCL DX, 0(CX)
0fbb11|223344556677885f5f5f5f5f5f	64	gnu	btc %edx,(%rcx)
0fbb11|223344556677885f5f5f5f5f5f	64	intel	btc dword ptr [rcx], edx
0fbb11|223344556677885f5f5f5f5f5f	64	plan9	BTCL DX, 0(CX)
0fbc11|223344556677885f5f5f5f5f5f	32	intel	bsf edx, dword ptr [ecx]
0fbc11|223344556677885f5f5f5f5f5f	32	plan9	BSFL 0(CX), DX
0fbc11|223344556677885f5f5f5f5f5f	64	gnu	bsf (%rcx),%edx
0fbc11|223344556677885f5f5f5f5f5f	64	intel	bsf edx, dword ptr [rcx]
0fbc11|223344556677885f5f5f5f5f5f	64	plan9	BSFL 0(CX), DX
0fbd11|223344556677885f5f5f5f5f5f	32	intel	bsr edx, dword ptr [ecx]
0fbd11|223344556677885f5f5f5f5f5f	32	plan9	BSRL 0(CX), DX
0fbd11|223344556677885f5f5f5f5f5f	64	gnu	bsr (%rcx),%edx
0fbd11|223344556677885f5f5f5f5f5f	64	intel	bsr edx, dword ptr [rcx]
0fbd11|223344556677885f5f5f5f5f5f	64	plan9	BSRL 0(CX), DX
0fbe11|223344556677885f5f5f5f5f5f	32	intel	movsx edx, byte ptr [ecx]
0fbe11|223344556677885f5f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
0fbe11|223344556677885f5f5f5f5f5f	64	gnu	movsbl (%rcx),%edx
0fbe11|223344556677885f5f5f5f5f5f	64	intel	movsx edx, byte ptr [rcx]
0fbe11|223344556677885f5f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
0fbf11|223344556677885f5f5f5f5f5f	32	intel	movsx edx, word ptr [ecx]
0fbf11|223344556677885f5f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
0fbf11|223344556677885f5f5f5f5f5f	64	gnu	movswl (%rcx),%edx
0fbf11|223344556677885f5f5f5f5f5f	64	intel	movsx edx, word ptr [rcx]
0fbf11|223344556677885f5f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
0fc011|223344556677885f5f5f5f5f5f	32	intel	xadd byte ptr [ecx], dl
0fc011|223344556677885f5f5f5f5f5f	32	plan9	XADDL DL, 0(CX)
0fc011|223344556677885f5f5f5f5f5f	64	gnu	xadd %dl,(%rcx)
0fc011|223344556677885f5f5f5f5f5f	64	intel	xadd byte ptr [rcx], dl
0fc011|223344556677885f5f5f5f5f5f	64	plan9	XADDL DL, 0(CX)
0fc111|223344556677885f5f5f5f5f5f	32	intel	xadd dword ptr [ecx], edx
0fc111|223344556677885f5f5f5f5f5f	32	plan9	XADDL DX, 0(CX)
0fc111|223344556677885f5f5f5f5f5f	64	gnu	xadd %edx,(%rcx)
0fc111|223344556677885f5f5f5f5f5f	64	intel	xadd dword ptr [rcx], edx
0fc111|223344556677885f5f5f5f5f5f	64	plan9	XADDL DX, 0(CX)
0fc20000|11223344556677885f5f5f5f	32	intel	cmpps xmm0, xmmword ptr [eax], 0x0
0fc20000|11223344556677885f5f5f5f	32	plan9	CMPPS $0x0, 0(AX), X0
0fc20000|11223344556677885f5f5f5f	64	gnu	cmpeqps (%rax),%xmm0
0fc20000|11223344556677885f5f5f5f	64	intel	cmpps xmm0, xmmword ptr [rax], 0x0
0fc20000|11223344556677885f5f5f5f	64	plan9	CMPPS $0x0, 0(AX), X0
0fc311|223344556677885f5f5f5f5f5f	32	intel	movnti dword ptr [ecx], edx
0fc311|223344556677885f5f5f5f5f5f	32	plan9	MOVNTIL DX, 0(CX)
0fc311|223344556677885f5f5f5f5f5f	64	gnu	movnti %edx,(%rcx)
0fc311|223344556677885f5f5f5f5f5f	64	intel	movnti dword ptr [rcx], edx
0fc311|223344556677885f5f5f5f5f5f	64	plan9	MOVNTIL DX, 0(CX)
0fc41122|3344556677885f5f5f5f5f5f	32	intel	pinsrw mmx2, word ptr [ecx], 0x22
0fc41122|3344556677885f5f5f5f5f5f	32	plan9	PINSRW $0x22, 0(CX), M2
0fc41122|3344556677885f5f5f5f5f5f	64	gnu	pinsrw $0x22,(%rcx),%mm2
0fc41122|3344556677885f5f5f5f5f5f	64	intel	pinsrw mmx2, word ptr [rcx], 0x22
0fc41122|3344556677885f5f5f5f5f5f	64	plan9	PINSRW $0x22, 0(CX), M2
0fc51122|3344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fc51122|3344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fc5c011|223344556677885f5f5f5f5f	32	intel	pextrw eax, mmx0, 0x11
0fc5c011|223344556677885f5f5f5f5f	32	plan9	PEXTRW $0x11, M0, AX
0fc5c011|223344556677885f5f5f5f5f	64	gnu	pextrw $0x11,%mm0,%eax
0fc5c011|223344556677885f5f5f5f5f	64	intel	pextrw eax, mmx0, 0x11
0fc5c011|223344556677885f5f5f5f5f	64	plan9	PEXTRW $0x11, M0, AX
0fc61122|3344556677885f5f5f5f5f5f	32	intel	shufps xmm2, xmmword ptr [ecx], 0x22
0fc61122|3344556677885f5f5f5f5f5f	32	plan9	SHUFPS $0x22, 0(CX), X2
0fc61122|3344556677885f5f5f5f5f5f	64	gnu	shufps $0x22,(%rcx),%xmm2
0fc61122|3344556677885f5f5f5f5f5f	64	intel	shufps xmm2, xmmword ptr [rcx], 0x22
0fc61122|3344556677885f5f5f5f5f5f	64	plan9	SHUFPS $0x22, 0(CX), X2
0fc708|11223344556677885f5f5f5f5f	32	intel	cmpxchg8b qword ptr [eax]
0fc708|11223344556677885f5f5f5f5f	32	plan9	CMPXCHG8B 0(AX)
0fc708|11223344556677885f5f5f5f5f	64	gnu	cmpxchg8b (%rax)
0fc708|11223344556677885f5f5f5f5f	64	intel	cmpxchg8b qword ptr [rax]
0fc708|11223344556677885f5f5f5f5f	64	plan9	CMPXCHG8B 0(AX)
0fc718|11223344556677885f5f5f5f5f	32	intel	xrstors ptr [eax]
0fc718|11223344556677885f5f5f5f5f	32	plan9	XRSTORS 0(AX)
0fc718|11223344556677885f5f5f5f5f	64	gnu	xrstors (%rax)
0fc718|11223344556677885f5f5f5f5f	64	intel	xrstors ptr [rax]
0fc718|11223344556677885f5f5f5f5f	64	plan9	XRSTORS 0(AX)
0fc720|11223344556677885f5f5f5f5f	32	intel	xsavec ptr [eax]
0fc720|11223344556677885f5f5f5f5f	32	plan9	XSAVEC 0(AX)
0fc720|11223344556677885f5f5f5f5f	64	gnu	xsavec (%rax)
0fc720|11223344556677885f5f5f5f5f	64	intel	xsavec ptr [rax]
0fc720|11223344556677885f5f5f5f5f	64	plan9	XSAVEC 0(AX)
0fc728|11223344556677885f5f5f5f5f	32	intel	xsaves ptr [eax]
0fc728|11223344556677885f5f5f5f5f	32	plan9	XSAVES 0(AX)
0fc728|11223344556677885f5f5f5f5f	64	gnu	xsaves (%rax)
0fc728|11223344556677885f5f5f5f5f	64	intel	xsaves ptr [rax]
0fc728|11223344556677885f5f5f5f5f	64	plan9	XSAVES 0(AX)
0fc730|11223344556677885f5f5f5f5f	32	intel	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	32	plan9	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	gnu	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	intel	error: unrecognized instruction
0fc730|11223344556677885f5f5f5f5f	64	plan9	error: unrecognized instruction
0fc7f0|11223344556677885f5f5f5f5f	32	intel	rdrand eax
0fc7f0|11223344556677885f5f5f5f5f	32	plan9	RDRAND AX
0fc7f0|11223344556677885f5f5f5f5f	64	gnu	rdrand %eax
0fc7f0|11223344556677885f5f5f5f5f	64	intel	rdrand eax
0fc7f0|11223344556677885f5f5f5f5f	64	plan9	RDRAND AX
0fc8|11223344556677885f5f5f5f5f5f	32	intel	bswap eax
0fc8|11223344556677885f5f5f5f5f5f	32	plan9	BSWAP AX
0fc8|11223344556677885f5f5f5f5f5f	64	gnu	bswap %eax
0fc8|11223344556677885f5f5f5f5f5f	64	intel	bswap eax
0fc8|11223344556677885f5f5f5f5f5f	64	plan9	BSWAP AX
0fd0|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd0|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd111|223344556677885f5f5f5f5f5f	32	intel	psrlw mmx2, qword ptr [ecx]
0fd111|223344556677885f5f5f5f5f5f	32	plan9	PSRLW 0(CX), M2
0fd111|223344556677885f5f5f5f5f5f	64	gnu	psrlw (%rcx),%mm2
0fd111|223344556677885f5f5f5f5f5f	64	intel	psrlw mmx2, qword ptr [rcx]
0fd111|223344556677885f5f5f5f5f5f	64	plan9	PSRLW 0(CX), M2
0fd211|223344556677885f5f5f5f5f5f	32	intel	psrld mmx2, qword ptr [ecx]
0fd211|223344556677885f5f5f5f5f5f	32	plan9	PSRLD 0(CX), M2
0fd211|223344556677885f5f5f5f5f5f	64	gnu	psrld (%rcx),%mm2
0fd211|223344556677885f5f5f5f5f5f	64	intel	psrld mmx2, qword ptr [rcx]
0fd211|223344556677885f5f5f5f5f5f	64	plan9	PSRLD 0(CX), M2
0fd311|223344556677885f5f5f5f5f5f	32	intel	psrlq mmx2, qword ptr [ecx]
0fd311|223344556677885f5f5f5f5f5f	32	plan9	PSRLQ 0(CX), M2
0fd311|223344556677885f5f5f5f5f5f	64	gnu	psrlq (%rcx),%mm2
0fd311|223344556677885f5f5f5f5f5f	64	intel	psrlq mmx2, qword ptr [rcx]
0fd311|223344556677885f5f5f5f5f5f	64	plan9	PSRLQ 0(CX), M2
0fd411|223344556677885f5f5f5f5f5f	32	intel	paddq mmx2, qword ptr [ecx]
0fd411|223344556677885f5f5f5f5f5f	32	plan9	PADDQ 0(CX), M2
0fd411|223344556677885f5f5f5f5f5f	64	gnu	paddq (%rcx),%mm2
0fd411|223344556677885f5f5f5f5f5f	64	intel	paddq mmx2, qword ptr [rcx]
0fd411|223344556677885f5f5f5f5f5f	64	plan9	PADDQ 0(CX), M2
0fd511|223344556677885f5f5f5f5f5f	32	intel	pmullw mmx2, qword ptr [ecx]
0fd511|223344556677885f5f5f5f5f5f	32	plan9	PMULLW 0(CX), M2
0fd511|223344556677885f5f5f5f5f5f	64	gnu	pmullw (%rcx),%mm2
0fd511|223344556677885f5f5f5f5f5f	64	intel	pmullw mmx2, qword ptr [rcx]
0fd511|223344556677885f5f5f5f5f5f	64	plan9	PMULLW 0(CX), M2
0fd6|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd6|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fd711|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fd7c0|11223344556677885f5f5f5f5f	32	intel	pmovmskb eax, mmx0
0fd7c0|11223344556677885f5f5f5f5f	32	plan9	PMOVMSKB M0, AX
0fd7c0|11223344556677885f5f5f5f5f	64	gnu	pmovmskb %mm0,%eax
0fd7c0|11223344556677885f5f5f5f5f	64	intel	pmovmskb eax, mmx0
0fd7c0|11223344556677885f5f5f5f5f	64	plan9	PMOVMSKB M0, AX
0fd811|223344556677885f5f5f5f5f5f	32	intel	psubusb mmx2, qword ptr [ecx]
0fd811|223344556677885f5f5f5f5f5f	32	plan9	PSUBUSB 0(CX), M2
0fd811|223344556677885f5f5f5f5f5f	64	gnu	psubusb (%rcx),%mm2
0fd811|223344556677885f5f5f5f5f5f	64	intel	psubusb mmx2, qword ptr [rcx]
0fd811|223344556677885f5f5f5f5f5f	64	plan9	PSUBUSB 0(CX), M2
0fd911|223344556677885f5f5f5f5f5f	32	intel	psubusw mmx2, qword ptr [ecx]
0fd911|223344556677885f5f5f5f5f5f	32	plan9	PSUBUSW 0(CX), M2
0fd911|223344556677885f5f5f5f5f5f	64	gnu	psubusw (%rcx),%mm2
0fd911|223344556677885f5f5f5f5f5f	64	intel	psubusw mmx2, qword ptr [rcx]
0fd911|223344556677885f5f5f5f5f5f	64	plan9	PSUBUSW 0(CX), M2
0fda11|223344556677885f5f5f5f5f5f	32	intel	pminub mmx2, qword ptr [ecx]
0fda11|223344556677885f5f5f5f5f5f	32	plan9	PMINUB 0(CX), M2
0fda11|223344556677885f5f5f5f5f5f	64	gnu	pminub (%rcx),%mm2
0fda11|223344556677885f5f5f5f5f5f	64	intel	pminub mmx2, qword ptr [rcx]
0fda11|223344556677885f5f5f5f5f5f	64	plan9	PMINUB 0(CX), M2
0fdb11|223344556677885f5f5f5f5f5f	32	intel	pand mmx2, qword ptr [ecx]
0fdb11|223344556677885f5f5f5f5f5f	32	plan9	PAND 0(CX), M2
0fdb11|223344556677885f5f5f5f5f5f	64	gnu	pand (%rcx),%mm2
0fdb11|223344556677885f5f5f5f5f5f	64	intel	pand mmx2, qword ptr [rcx]
0fdb11|223344556677885f5f5f5f5f5f	64	plan9	PAND 0(CX), M2
0fdc11|223344556677885f5f5f5f5f5f	32	intel	paddusb mmx2, qword ptr [ecx]
0fdc11|223344556677885f5f5f5f5f5f	32	plan9	PADDUSB 0(CX), M2
0fdc11|223344556677885f5f5f5f5f5f	64	gnu	paddusb (%rcx),%mm2
0fdc11|223344556677885f5f5f5f5f5f	64	intel	paddusb mmx2, qword ptr [rcx]
0fdc11|223344556677885f5f5f5f5f5f	64	plan9	PADDUSB 0(CX), M2
0fdd11|223344556677885f5f5f5f5f5f	32	intel	paddusw mmx2, qword ptr [ecx]
0fdd11|223344556677885f5f5f5f5f5f	32	plan9	PADDUSW 0(CX), M2
0fdd11|223344556677885f5f5f5f5f5f	64	gnu	paddusw (%rcx),%mm2
0fdd11|223344556677885f5f5f5f5f5f	64	intel	paddusw mmx2, qword ptr [rcx]
0fdd11|223344556677885f5f5f5f5f5f	64	plan9	PADDUSW 0(CX), M2
0fde11|223344556677885f5f5f5f5f5f	32	intel	pmaxub mmx2, qword ptr [ecx]
0fde11|223344556677885f5f5f5f5f5f	32	plan9	PMAXUB 0(CX), M2
0fde11|223344556677885f5f5f5f5f5f	64	gnu	pmaxub (%rcx),%mm2
0fde11|223344556677885f5f5f5f5f5f	64	intel	pmaxub mmx2, qword ptr [rcx]
0fde11|223344556677885f5f5f5f5f5f	64	plan9	PMAXUB 0(CX), M2
0fdf11|223344556677885f5f5f5f5f5f	32	intel	pandn mmx2, qword ptr [ecx]
0fdf11|223344556677885f5f5f5f5f5f	32	plan9	PANDN 0(CX), M2
0fdf11|223344556677885f5f5f5f5f5f	64	gnu	pandn (%rcx),%mm2
0fdf11|223344556677885f5f5f5f5f5f	64	intel	pandn mmx2, qword ptr [rcx]
0fdf11|223344556677885f5f5f5f5f5f	64	plan9	PANDN 0(CX), M2
0fe011|223344556677885f5f5f5f5f5f	32	intel	pavgb mmx2, qword ptr [ecx]
0fe011|223344556677885f5f5f5f5f5f	32	plan9	PAVGB 0(CX), M2
0fe011|223344556677885f5f5f5f5f5f	64	gnu	pavgb (%rcx),%mm2
0fe011|223344556677885f5f5f5f5f5f	64	intel	pavgb mmx2, qword ptr [rcx]
0fe011|223344556677885f5f5f5f5f5f	64	plan9	PAVGB 0(CX), M2
0fe111|223344556677885f5f5f5f5f5f	32	intel	psraw mmx2, qword ptr [ecx]
0fe111|223344556677885f5f5f5f5f5f	32	plan9	PSRAW 0(CX), M2
0fe111|223344556677885f5f5f5f5f5f	64	gnu	psraw (%rcx),%mm2
0fe111|223344556677885f5f5f5f5f5f	64	intel	psraw mmx2, qword ptr [rcx]
0fe111|223344556677885f5f5f5f5f5f	64	plan9	PSRAW 0(CX), M2
0fe211|223344556677885f5f5f5f5f5f	32	intel	psrad mmx2, qword ptr [ecx]
0fe211|223344556677885f5f5f5f5f5f	32	plan9	PSRAD 0(CX), M2
0fe211|223344556677885f5f5f5f5f5f	64	gnu	psrad (%rcx),%mm2
0fe211|223344556677885f5f5f5f5f5f	64	intel	psrad mmx2, qword ptr [rcx]
0fe211|223344556677885f5f5f5f5f5f	64	plan9	PSRAD 0(CX), M2
0fe311|223344556677885f5f5f5f5f5f	32	intel	pavgw mmx2, qword ptr [ecx]
0fe311|223344556677885f5f5f5f5f5f	32	plan9	PAVGW 0(CX), M2
0fe311|223344556677885f5f5f5f5f5f	64	gnu	pavgw (%rcx),%mm2
0fe311|223344556677885f5f5f5f5f5f	64	intel	pavgw mmx2, qword ptr [rcx]
0fe311|223344556677885f5f5f5f5f5f	64	plan9	PAVGW 0(CX), M2
0fe411|223344556677885f5f5f5f5f5f	32	intel	pmulhuw mmx2, qword ptr [ecx]
0fe411|223344556677885f5f5f5f5f5f	32	plan9	PMULHUW 0(CX), M2
0fe411|223344556677885f5f5f5f5f5f	64	gnu	pmulhuw (%rcx),%mm2
0fe411|223344556677885f5f5f5f5f5f	64	intel	pmulhuw mmx2, qword ptr [rcx]
0fe411|223344556677885f5f5f5f5f5f	64	plan9	PMULHUW 0(CX), M2
0fe511|223344556677885f5f5f5f5f5f	32	intel	pmulhw mmx2, qword ptr [ecx]
0fe511|223344556677885f5f5f5f5f5f	32	plan9	PMULHW 0(CX), M2
0fe511|223344556677885f5f5f5f5f5f	64	gnu	pmulhw (%rcx),%mm2
0fe511|223344556677885f5f5f5f5f5f	64	intel	pmulhw mmx2, qword ptr [rcx]
0fe511|223344556677885f5f5f5f5f5f	64	plan9	PMULHW 0(CX), M2
0fe6|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0fe6|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0fe711|223344556677885f5f5f5f5f5f	32	intel	movntq qword ptr [ecx], mmx2
0fe711|223344556677885f5f5f5f5f5f	32	plan9	MOVNTQ M2, 0(CX)
0fe711|223344556677885f5f5f5f5f5f	64	gnu	movntq %mm2,(%rcx)
0fe711|223344556677885f5f5f5f5f5f	64	intel	movntq qword ptr [rcx], mmx2
0fe711|223344556677885f5f5f5f5f5f	64	plan9	MOVNTQ M2, 0(CX)
0fe811|223344556677885f5f5f5f5f5f	32	intel	psubsb mmx2, qword ptr [ecx]
0fe811|223344556677885f5f5f5f5f5f	32	plan9	PSUBSB 0(CX), M2
0fe811|223344556677885f5f5f5f5f5f	64	gnu	psubsb (%rcx),%mm2
0fe811|223344556677885f5f5f5f5f5f	64	intel	psubsb mmx2, qword ptr [rcx]
0fe811|223344556677885f5f5f5f5f5f	64	plan9	PSUBSB 0(CX), M2
0fe911|223344556677885f5f5f5f5f5f	32	intel	psubsw mmx2, qword ptr [ecx]
0fe911|223344556677885f5f5f5f5f5f	32	plan9	PSUBSW 0(CX), M2
0fe911|223344556677885f5f5f5f5f5f	64	gnu	psubsw (%rcx),%mm2
0fe911|223344556677885f5f5f5f5f5f	64	intel	psubsw mmx2, qword ptr [rcx]
0fe911|223344556677885f5f5f5f5f5f	64	plan9	PSUBSW 0(CX), M2
0fea11|223344556677885f5f5f5f5f5f	32	intel	pminsw mmx2, qword ptr [ecx]
0fea11|223344556677885f5f5f5f5f5f	32	plan9	PMINSW 0(CX), M2
0fea11|223344556677885f5f5f5f5f5f	64	gnu	pminsw (%rcx),%mm2
0fea11|223344556677885f5f5f5f5f5f	64	intel	pminsw mmx2, qword ptr [rcx]
0fea11|223344556677885f5f5f5f5f5f	64	plan9	PMINSW 0(CX), M2
0feb11|223344556677885f5f5f5f5f5f	32	intel	por mmx2, qword ptr [ecx]
0feb11|223344556677885f5f5f5f5f5f	32	plan9	POR 0(CX), M2
0feb11|223344556677885f5f5f5f5f5f	64	gnu	por (%rcx),%mm2
0feb11|223344556677885f5f5f5f5f5f	64	intel	por mmx2, qword ptr [rcx]
0feb11|223344556677885f5f5f5f5f5f	64	plan9	POR 0(CX), M2
0fec11|223344556677885f5f5f5f5f5f	32	intel	paddsb mmx2, qword ptr [ecx]
0fec11|223344556677885f5f5f5f5f5f	32	plan9	PADDSB 0(CX), M2
0fec11|223344556677885f5f5f5f5f5f	64	gnu	paddsb (%rcx),%mm2
0fec11|223344556677885f5f5f5f5f5f	64	intel	paddsb mmx2, qword ptr [rcx]
0fec11|223344556677885f5f5f5f5f5f	64	plan9	PADDSB 0(CX), M2
0fed11|223344556677885f5f5f5f5f5f	32	intel	paddsw mmx2, qword ptr [ecx]
0fed11|223344556677885f5f5f5f5f5f	32	plan9	PADDSW 0(CX), M2
0fed11|223344556677885f5f5f5f5f5f	64	gnu	paddsw (%rcx),%mm2
0fed11|223344556677885f5f5f5f5f5f	64	intel	paddsw mmx2, qword ptr [rcx]
0fed11|223344556677885f5f5f5f5f5f	64	plan9	PADDSW 0(CX), M2
0fee11|223344556677885f5f5f5f5f5f	32	intel	pmaxsw mmx2, qword ptr [ecx]
0fee11|223344556677885f5f5f5f5f5f	32	plan9	PMAXSW 0(CX), M2
0fee11|223344556677885f5f5f5f5f5f	64	gnu	pmaxsw (%rcx),%mm2
0fee11|223344556677885f5f5f5f5f5f	64	intel	pmaxsw mmx2, qword ptr [rcx]
0fee11|223344556677885f5f5f5f5f5f	64	plan9	PMAXSW 0(CX), M2
0fef11|223344556677885f5f5f5f5f5f	32	intel	pxor mmx2, qword ptr [ecx]
0fef11|223344556677885f5f5f5f5f5f	32	plan9	PXOR 0(CX), M2
0fef11|223344556677885f5f5f5f5f5f	64	gnu	pxor (%rcx),%mm2
0fef11|223344556677885f5f5f5f5f5f	64	intel	pxor mmx2, qword ptr [rcx]
0fef11|223344556677885f5f5f5f5f5f	64	plan9	PXOR 0(CX), M2
0ff0|11223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0ff0|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0ff111|223344556677885f5f5f5f5f5f	32	intel	psllw mmx2, qword ptr [ecx]
0ff111|223344556677885f5f5f5f5f5f	32	plan9	PSLLW 0(CX), M2
0ff111|223344556677885f5f5f5f5f5f	64	gnu	psllw (%rcx),%mm2
0ff111|223344556677885f5f5f5f5f5f	64	intel	psllw mmx2, qword ptr [rcx]
0ff111|223344556677885f5f5f5f5f5f	64	plan9	PSLLW 0(CX), M2
0ff211|223344556677885f5f5f5f5f5f	32	intel	pslld mmx2, qword ptr [ecx]
0ff211|223344556677885f5f5f5f5f5f	32	plan9	PSLLD 0(CX), M2
0ff211|223344556677885f5f5f5f5f5f	64	gnu	pslld (%rcx),%mm2
0ff211|223344556677885f5f5f5f5f5f	64	intel	pslld mmx2, qword ptr [rcx]
0ff211|223344556677885f5f5f5f5f5f	64	plan9	PSLLD 0(CX), M2
0ff311|223344556677885f5f5f5f5f5f	32	intel	psllq mmx2, qword ptr [ecx]
0ff311|223344556677885f5f5f5f5f5f	32	plan9	PSLLQ 0(CX), M2
0ff311|223344556677885f5f5f5f5f5f	64	gnu	psllq (%rcx),%mm2
0ff311|223344556677885f5f5f5f5f5f	64	intel	psllq mmx2, qword ptr [rcx]
0ff311|223344556677885f5f5f5f5f5f	64	plan9	PSLLQ 0(CX), M2
0ff411|223344556677885f5f5f5f5f5f	32	intel	pmuludq mmx2, qword ptr [ecx]
0ff411|223344556677885f5f5f5f5f5f	32	plan9	PMULUDQ 0(CX), M2
0ff411|223344556677885f5f5f5f5f5f	64	gnu	pmuludq (%rcx),%mm2
0ff411|223344556677885f5f5f5f5f5f	64	intel	pmuludq mmx2, qword ptr [rcx]
0ff411|223344556677885f5f5f5f5f5f	64	plan9	PMULUDQ 0(CX), M2
0ff511|223344556677885f5f5f5f5f5f	32	intel	pmaddwd mmx2, qword ptr [ecx]
0ff511|223344556677885f5f5f5f5f5f	32	plan9	PMADDWD 0(CX), M2
0ff511|223344556677885f5f5f5f5f5f	64	gnu	pmaddwd (%rcx),%mm2
0ff511|223344556677885f5f5f5f5f5f	64	intel	pmaddwd mmx2, qword ptr [rcx]
0ff511|223344556677885f5f5f5f5f5f	64	plan9	PMADDWD 0(CX), M2
0ff611|223344556677885f5f5f5f5f5f	32	intel	psadbw mmx2, qword ptr [ecx]
0ff611|223344556677885f5f5f5f5f5f	32	plan9	PSADBW 0(CX), M2
0ff611|223344556677885f5f5f5f5f5f	64	gnu	psadbw (%rcx),%mm2
0ff611|223344556677885f5f5f5f5f5f	64	intel	psadbw mmx2, qword ptr [rcx]
0ff611|223344556677885f5f5f5f5f5f	64	plan9	PSADBW 0(CX), M2
0ff711|223344556677885f5f5f5f5f5f	32	intel	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	32	plan9	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
0ff711|223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
0ff7c0|11223344556677885f5f5f5f5f	32	intel	maskmovq mmx0, mmx0
0ff7c0|11223344556677885f5f5f5f5f	32	plan9	MASKMOVQ M0, M0
0ff7c0|11223344556677885f5f5f5f5f	64	gnu	maskmovq %mm0,%mm0
0ff7c0|11223344556677885f5f5f5f5f	64	intel	maskmovq mmx0, mmx0
0ff7c0|11223344556677885f5f5f5f5f	64	plan9	MASKMOVQ M0, M0
0ff811|223344556677885f5f5f5f5f5f	32	intel	psubb mmx2, qword ptr [ecx]
0ff811|223344556677885f5f5f5f5f5f	32	plan9	PSUBB 0(CX), M2
0ff811|223344556677885f5f5f5f5f5f	64	gnu	psubb (%rcx),%mm2
0ff811|223344556677885f5f5f5f5f5f	64	intel	psubb mmx2, qword ptr [rcx]
0ff811|223344556677885f5f5f5f5f5f	64	plan9	PSUBB 0(CX), M2
0ff911|223344556677885f5f5f5f5f5f	32	intel	psubw mmx2, qword ptr [ecx]
0ff911|223344556677885f5f5f5f5f5f	32	plan9	PSUBW 0(CX), M2
0ff911|223344556677885f5f5f5f5f5f	64	gnu	psubw (%rcx),%mm2
0ff911|223344556677885f5f5f5f5f5f	64	intel	psubw mmx2, qword ptr [rcx]
0ff911|223344556677885f5f5f5f5f5f	64	plan9	PSUBW 0(CX), M2
0ffa11|223344556677885f5f5f5f5f5f	32	intel	psubd mmx2, qword ptr [ecx]
0ffa11|223344556677885f5f5f5f5f5f	32	plan9	PSUBD 0(CX), M2
0ffa11|223344556677885f5f5f5f5f5f	64	gnu	psubd (%rcx),%mm2
0ffa11|223344556677885f5f5f5f5f5f	64	intel	psubd mmx2, qword ptr [rcx]
0ffa11|223344556677885f5f5f5f5f5f	64	plan9	PSUBD 0(CX), M2
0ffb11|223344556677885f5f5f5f5f5f	32	intel	psubq mmx2, qword ptr [ecx]
0ffb11|223344556677885f5f5f5f5f5f	32	plan9	PSUBQ 0(CX), M2
0ffb11|223344556677885f5f5f5f5f5f	64	gnu	psubq (%rcx),%mm2
0ffb11|223344556677885f5f5f5f5f5f	64	intel	psubq mmx2, qword ptr [rcx]
0ffb11|223344556677885f5f5f5f5f5f	64	plan9	PSUBQ 0(CX), M2
0ffc11|223344556677885f5f5f5f5f5f	32	intel	paddb mmx2, qword ptr [ecx]
0ffc11|223344556677885f5f5f5f5f5f	32	plan9	PADDB 0(CX), M2
0ffc11|223344556677885f5f5f5f5f5f	64	gnu	paddb (%rcx),%mm2
0ffc11|223344556677885f5f5f5f5f5f	64	intel	paddb mmx2, qword ptr [rcx]
0ffc11|223344556677885f5f5f5f5f5f	64	plan9	PADDB 0(CX), M2
0ffd11|223344556677885f5f5f5f5f5f	32	intel	paddw mmx2, qword ptr [ecx]
0ffd11|223344556677885f5f5f5f5f5f	32	plan9	PADDW 0(CX), M2
0ffd11|223344556677885f5f5f5f5f5f	64	gnu	paddw (%rcx),%mm2
0ffd11|223344556677885f5f5f5f5f5f	64	intel	paddw mmx2, qword ptr [rcx]
0ffd11|223344556677885f5f5f5f5f5f	64	plan9	PADDW 0(CX), M2
0ffe11|223344556677885f5f5f5f5f5f	32	intel	paddd mmx2, qword ptr [ecx]
0ffe11|223344556677885f5f5f5f5f5f	32	plan9	PADDD 0(CX), M2
0ffe11|223344556677885f5f5f5f5f5f	64	gnu	paddd (%rcx),%mm2
0ffe11|223344556677885f5f5f5f5f5f	64	intel	paddd mmx2, qword ptr [rcx]
0ffe11|223344556677885f5f5f5f5f5f	64	plan9	PADDD 0(CX), M2
1011|223344556677885f5f5f5f5f5f5f	32	intel	adc byte ptr [ecx], dl
1011|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL DL, 0(CX)
1011|223344556677885f5f5f5f5f5f5f	64	gnu	adc %dl,(%rcx)
1011|223344556677885f5f5f5f5f5f5f	64	intel	adc byte ptr [rcx], dl
1011|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL DL, 0(CX)
1111|223344556677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], edx
1111|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL DX, 0(CX)
1111|223344556677885f5f5f5f5f5f5f	64	gnu	adc %edx,(%rcx)
1111|223344556677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], edx
1111|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL DX, 0(CX)
1211|223344556677885f5f5f5f5f5f5f	32	intel	adc dl, byte ptr [ecx]
1211|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL 0(CX), DL
1211|223344556677885f5f5f5f5f5f5f	64	gnu	adc (%rcx),%dl
1211|223344556677885f5f5f5f5f5f5f	64	intel	adc dl, byte ptr [rcx]
1211|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL 0(CX), DL
1311|223344556677885f5f5f5f5f5f5f	32	intel	adc edx, dword ptr [ecx]
1311|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL 0(CX), DX
1311|223344556677885f5f5f5f5f5f5f	64	gnu	adc (%rcx),%edx
1311|223344556677885f5f5f5f5f5f5f	64	intel	adc edx, dword ptr [rcx]
1311|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL 0(CX), DX
1411|223344556677885f5f5f5f5f5f5f	32	intel	adc al, 0x11
1411|223344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x11, AL
1411|223344556677885f5f5f5f5f5f5f	64	gnu	adc $0x11,%al
1411|223344556677885f5f5f5f5f5f5f	64	intel	adc al, 0x11
1411|223344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x11, AL
1511223344|556677885f5f5f5f5f5f5f	32	intel	adc eax, 0x44332211
1511223344|556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x44332211, AX
1511223344|556677885f5f5f5f5f5f5f	64	gnu	adc $0x44332211,%eax
1511223344|556677885f5f5f5f5f5f5f	64	intel	adc eax, 0x44332211
1511223344|556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x44332211, AX
16|11223344556677885f5f5f5f5f5f5f	32	intel	push ss
16|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL SS
16|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
16|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
16|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	32	intel	pop ss
17|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL SS
17|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
17|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
1811|223344556677885f5f5f5f5f5f5f	32	intel	sbb byte ptr [ecx], dl
1811|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL DL, 0(CX)
1811|223344556677885f5f5f5f5f5f5f	64	gnu	sbb %dl,(%rcx)
1811|223344556677885f5f5f5f5f5f5f	64	intel	sbb byte ptr [rcx], dl
1811|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL DL, 0(CX)
1911|223344556677885f5f5f5f5f5f5f	32	intel	sbb dword ptr [ecx], edx
1911|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL DX, 0(CX)
1911|223344556677885f5f5f5f5f5f5f	64	gnu	sbb %edx,(%rcx)
1911|223344556677885f5f5f5f5f5f5f	64	intel	sbb dword ptr [rcx], edx
1911|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL DX, 0(CX)
1a11|223344556677885f5f5f5f5f5f5f	32	intel	sbb dl, byte ptr [ecx]
1a11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL 0(CX), DL
1a11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb (%rcx),%dl
1a11|223344556677885f5f5f5f5f5f5f	64	intel	sbb dl, byte ptr [rcx]
1a11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL 0(CX), DL
1b11|223344556677885f5f5f5f5f5f5f	32	intel	sbb edx, dword ptr [ecx]
1b11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL 0(CX), DX
1b11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb (%rcx),%edx
1b11|223344556677885f5f5f5f5f5f5f	64	intel	sbb edx, dword ptr [rcx]
1b11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL 0(CX), DX
1c11|223344556677885f5f5f5f5f5f5f	32	intel	sbb al, 0x11
1c11|223344556677885f5f5f5f5f5f5f	32	plan9	SBBL $0x11, AL
1c11|223344556677885f5f5f5f5f5f5f	64	gnu	sbb $0x11,%al
1c11|223344556677885f5f5f5f5f5f5f	64	intel	sbb al, 0x11
1c11|223344556677885f5f5f5f5f5f5f	64	plan9	SBBL $0x11, AL
1d11223344|556677885f5f5f5f5f5f5f	32	intel	sbb eax, 0x44332211
1d11223344|556677885f5f5f5f5f5f5f	32	plan9	SBBL $0x44332211, AX
1d11223344|556677885f5f5f5f5f5f5f	64	gnu	sbb $0x44332211,%eax
1d11223344|556677885f5f5f5f5f5f5f	64	intel	sbb eax, 0x44332211
1d11223344|556677885f5f5f5f5f5f5f	64	plan9	SBBL $0x44332211, AX
1e|11223344556677885f5f5f5f5f5f5f	32	intel	push ds
1e|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL DS
1e|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
1e|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
1e|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	32	intel	pop ds
1f|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL DS
1f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
1f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
2011|223344556677885f5f5f5f5f5f5f	32	intel	and byte ptr [ecx], dl
2011|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL DL, 0(CX)
2011|223344556677885f5f5f5f5f5f5f	64	gnu	and %dl,(%rcx)
2011|223344556677885f5f5f5f5f5f5f	64	intel	and byte ptr [rcx], dl
2011|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL DL, 0(CX)
2111|223344556677885f5f5f5f5f5f5f	32	intel	and dword ptr [ecx], edx
2111|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL DX, 0(CX)
2111|223344556677885f5f5f5f5f5f5f	64	gnu	and %edx,(%rcx)
2111|223344556677885f5f5f5f5f5f5f	64	intel	and dword ptr [rcx], edx
2111|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL DX, 0(CX)
2211|223344556677885f5f5f5f5f5f5f	32	intel	and dl, byte ptr [ecx]
2211|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL 0(CX), DL
2211|223344556677885f5f5f5f5f5f5f	64	gnu	and (%rcx),%dl
2211|223344556677885f5f5f5f5f5f5f	64	intel	and dl, byte ptr [rcx]
2211|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL 0(CX), DL
2311|223344556677885f5f5f5f5f5f5f	32	intel	and edx, dword ptr [ecx]
2311|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL 0(CX), DX
2311|223344556677885f5f5f5f5f5f5f	64	gnu	and (%rcx),%edx
2311|223344556677885f5f5f5f5f5f5f	64	intel	and edx, dword ptr [rcx]
2311|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL 0(CX), DX
2411|223344556677885f5f5f5f5f5f5f	32	intel	and al, 0x11
2411|223344556677885f5f5f5f5f5f5f	32	plan9	ANDL $0x11, AL
2411|223344556677885f5f5f5f5f5f5f	64	gnu	and $0x11,%al
2411|223344556677885f5f5f5f5f5f5f	64	intel	and al, 0x11
2411|223344556677885f5f5f5f5f5f5f	64	plan9	ANDL $0x11, AL
2511223344|556677885f5f5f5f5f5f5f	32	intel	and eax, 0x44332211
2511223344|556677885f5f5f5f5f5f5f	32	plan9	ANDL $0x44332211, AX
2511223344|556677885f5f5f5f5f5f5f	64	gnu	and $0x44332211,%eax
2511223344|556677885f5f5f5f5f5f5f	64	intel	and eax, 0x44332211
2511223344|556677885f5f5f5f5f5f5f	64	plan9	ANDL $0x44332211, AX
266e|11223344556677885f5f5f5f5f5f	32	intel	outsb es
266e|11223344556677885f5f5f5f5f5f	32	plan9	ES OUTSB ES:0(SI), DX
266e|11223344556677885f5f5f5f5f5f	64	gnu	outsb %ds:%es:(%rsi),(%dx)
266e|11223344556677885f5f5f5f5f5f	64	intel	outsb
266e|11223344556677885f5f5f5f5f5f	64	plan9	ES OUTSB DS:0(SI), DX
267011|223344556677885f5f5f5f5f5f	32	intel	jo .+0x11
267011|223344556677885f5f5f5f5f5f	32	plan9	ES JO .+17
267011|223344556677885f5f5f5f5f5f	64	gnu	es jo .+0x11
267011|223344556677885f5f5f5f5f5f	64	intel	jo .+0x11
267011|223344556677885f5f5f5f5f5f	64	plan9	ES JO .+17
26a01122334455667788|5f5f5f5f5f5f	64	gnu	mov %es:-0x778899aabbccddef,%al
26a01122334455667788|5f5f5f5f5f5f	64	intel	mov al, byte ptr [0x8877665544332211]
26a01122334455667788|5f5f5f5f5f5f	64	plan9	ES MOVL -0x778899aabbccddef, AL
26a011223344|556677885f5f5f5f5f5f	32	intel	mov al, byte ptr es:[0x44332211]
26a011223344|556677885f5f5f5f5f5f	32	plan9	ES MOVL ES:0x44332211, AL
26|8211223344556677885f5f5f5f5f5f	32	intel	es
26|8211223344556677885f5f5f5f5f5f	32	plan9	ES Op(0)
26|8211223344556677885f5f5f5f5f5f	64	gnu	es
26|8211223344556677885f5f5f5f5f5f	64	intel	es
26|8211223344556677885f5f5f5f5f5f	64	plan9	ES Op(0)
27|11223344556677885f5f5f5f5f5f5f	32	intel	daa
27|11223344556677885f5f5f5f5f5f5f	32	plan9	DAA
27|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
27|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
27|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
2811|223344556677885f5f5f5f5f5f5f	32	intel	sub byte ptr [ecx], dl
2811|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL DL, 0(CX)
2811|223344556677885f5f5f5f5f5f5f	64	gnu	sub %dl,(%rcx)
2811|223344556677885f5f5f5f5f5f5f	64	intel	sub byte ptr [rcx], dl
2811|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL DL, 0(CX)
2911|223344556677885f5f5f5f5f5f5f	32	intel	sub dword ptr [ecx], edx
2911|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL DX, 0(CX)
2911|223344556677885f5f5f5f5f5f5f	64	gnu	sub %edx,(%rcx)
2911|223344556677885f5f5f5f5f5f5f	64	intel	sub dword ptr [rcx], edx
2911|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL DX, 0(CX)
2a11|223344556677885f5f5f5f5f5f5f	32	intel	sub dl, byte ptr [ecx]
2a11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL 0(CX), DL
2a11|223344556677885f5f5f5f5f5f5f	64	gnu	sub (%rcx),%dl
2a11|223344556677885f5f5f5f5f5f5f	64	intel	sub dl, byte ptr [rcx]
2a11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL 0(CX), DL
2b11|223344556677885f5f5f5f5f5f5f	32	intel	sub edx, dword ptr [ecx]
2b11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL 0(CX), DX
2b11|223344556677885f5f5f5f5f5f5f	64	gnu	sub (%rcx),%edx
2b11|223344556677885f5f5f5f5f5f5f	64	intel	sub edx, dword ptr [rcx]
2b11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL 0(CX), DX
2c11|223344556677885f5f5f5f5f5f5f	32	intel	sub al, 0x11
2c11|223344556677885f5f5f5f5f5f5f	32	plan9	SUBL $0x11, AL
2c11|223344556677885f5f5f5f5f5f5f	64	gnu	sub $0x11,%al
2c11|223344556677885f5f5f5f5f5f5f	64	intel	sub al, 0x11
2c11|223344556677885f5f5f5f5f5f5f	64	plan9	SUBL $0x11, AL
2d11223344|556677885f5f5f5f5f5f5f	32	intel	sub eax, 0x44332211
2d11223344|556677885f5f5f5f5f5f5f	32	plan9	SUBL $0x44332211, AX
2d11223344|556677885f5f5f5f5f5f5f	64	gnu	sub $0x44332211,%eax
2d11223344|556677885f5f5f5f5f5f5f	64	intel	sub eax, 0x44332211
2d11223344|556677885f5f5f5f5f5f5f	64	plan9	SUBL $0x44332211, AX
2f|11223344556677885f5f5f5f5f5f5f	32	intel	das
2f|11223344556677885f5f5f5f5f5f5f	32	plan9	DAS
2f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
2f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
2f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
3011|223344556677885f5f5f5f5f5f5f	32	intel	xor byte ptr [ecx], dl
3011|223344556677885f5f5f5f5f5f5f	32	plan9	XORL DL, 0(CX)
3011|223344556677885f5f5f5f5f5f5f	64	gnu	xor %dl,(%rcx)
3011|223344556677885f5f5f5f5f5f5f	64	intel	xor byte ptr [rcx], dl
3011|223344556677885f5f5f5f5f5f5f	64	plan9	XORL DL, 0(CX)
3111|223344556677885f5f5f5f5f5f5f	32	intel	xor dword ptr [ecx], edx
3111|223344556677885f5f5f5f5f5f5f	32	plan9	XORL DX, 0(CX)
3111|223344556677885f5f5f5f5f5f5f	64	gnu	xor %edx,(%rcx)
3111|223344556677885f5f5f5f5f5f5f	64	intel	xor dword ptr [rcx], edx
3111|223344556677885f5f5f5f5f5f5f	64	plan9	XORL DX, 0(CX)
3211|223344556677885f5f5f5f5f5f5f	32	intel	xor dl, byte ptr [ecx]
3211|223344556677885f5f5f5f5f5f5f	32	plan9	XORL 0(CX), DL
3211|223344556677885f5f5f5f5f5f5f	64	gnu	xor (%rcx),%dl
3211|223344556677885f5f5f5f5f5f5f	64	intel	xor dl, byte ptr [rcx]
3211|223344556677885f5f5f5f5f5f5f	64	plan9	XORL 0(CX), DL
3311|223344556677885f5f5f5f5f5f5f	32	intel	xor edx, dword ptr [ecx]
3311|223344556677885f5f5f5f5f5f5f	32	plan9	XORL 0(CX), DX
3311|223344556677885f5f5f5f5f5f5f	64	gnu	xor (%rcx),%edx
3311|223344556677885f5f5f5f5f5f5f	64	intel	xor edx, dword ptr [rcx]
3311|223344556677885f5f5f5f5f5f5f	64	plan9	XORL 0(CX), DX
3411|223344556677885f5f5f5f5f5f5f	32	intel	xor al, 0x11
3411|223344556677885f5f5f5f5f5f5f	32	plan9	XORL $0x11, AL
3411|223344556677885f5f5f5f5f5f5f	64	gnu	xor $0x11,%al
3411|223344556677885f5f5f5f5f5f5f	64	intel	xor al, 0x11
3411|223344556677885f5f5f5f5f5f5f	64	plan9	XORL $0x11, AL
3511223344|556677885f5f5f5f5f5f5f	32	intel	xor eax, 0x44332211
3511223344|556677885f5f5f5f5f5f5f	32	plan9	XORL $0x44332211, AX
3511223344|556677885f5f5f5f5f5f5f	64	gnu	xor $0x44332211,%eax
3511223344|556677885f5f5f5f5f5f5f	64	intel	xor eax, 0x44332211
3511223344|556677885f5f5f5f5f5f5f	64	plan9	XORL $0x44332211, AX
3667f3660f2ac0|11223344556677885f	32	intel	addr16 cvtsi2ss xmm0, eax
3667f3660f2ac0|11223344556677885f	32	plan9	CVTSI2SSW AX, X0
3667f3660f2ac0|11223344556677885f	64	gnu	ss addr32 cvtsi2ss %ax,%xmm0
3667f3660f2ac0|11223344556677885f	64	intel	addr32 cvtsi2ss xmm0, eax
3667f3660f2ac0|11223344556677885f	64	plan9	CVTSI2SSW AX, X0
36|67f3660ff7c011223344556677885f	64	gnu	ss
36|f0f2f33e66f066f2f33e3666818411	32	intel	ss
36|f0f2f33e66f066f2f33e3666818411	32	plan9	SS Op(0)
36|f0f2f33e66f066f2f33e3666818411	64	gnu	ss
36|f0f2f33e66f066f2f33e3666818411	64	intel	ss
36|f0f2f33e66f066f2f33e3666818411	64	plan9	SS Op(0)
36|f2f33ef0f78411223344556677885f	32	intel	ss
36|f2f33ef0f78411223344556677885f	32	plan9	SS Op(0)
36|f2f33ef0f78411223344556677885f	64	gnu	ss
36|f2f33ef0f78411223344556677885f	64	intel	ss
36|f2f33ef0f78411223344556677885f	64	plan9	SS Op(0)
37|11223344556677885f5f5f5f5f5f5f	32	intel	aaa
37|11223344556677885f5f5f5f5f5f5f	32	plan9	AAA
37|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
37|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
37|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
3811|223344556677885f5f5f5f5f5f5f	32	intel	cmp byte ptr [ecx], dl
3811|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL DL, 0(CX)
3811|223344556677885f5f5f5f5f5f5f	64	gnu	cmp %dl,(%rcx)
3811|223344556677885f5f5f5f5f5f5f	64	intel	cmp byte ptr [rcx], dl
3811|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL DL, 0(CX)
3911|223344556677885f5f5f5f5f5f5f	32	intel	cmp dword ptr [ecx], edx
3911|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL DX, 0(CX)
3911|223344556677885f5f5f5f5f5f5f	64	gnu	cmp %edx,(%rcx)
3911|223344556677885f5f5f5f5f5f5f	64	intel	cmp dword ptr [rcx], edx
3911|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL DX, 0(CX)
3a11|223344556677885f5f5f5f5f5f5f	32	intel	cmp dl, byte ptr [ecx]
3a11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL 0(CX), DL
3a11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp (%rcx),%dl
3a11|223344556677885f5f5f5f5f5f5f	64	intel	cmp dl, byte ptr [rcx]
3a11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL 0(CX), DL
3b11|223344556677885f5f5f5f5f5f5f	32	intel	cmp edx, dword ptr [ecx]
3b11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL 0(CX), DX
3b11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp (%rcx),%edx
3b11|223344556677885f5f5f5f5f5f5f	64	intel	cmp edx, dword ptr [rcx]
3b11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL 0(CX), DX
3c11|223344556677885f5f5f5f5f5f5f	32	intel	cmp al, 0x11
3c11|223344556677885f5f5f5f5f5f5f	32	plan9	CMPL $0x11, AL
3c11|223344556677885f5f5f5f5f5f5f	64	gnu	cmp $0x11,%al
3c11|223344556677885f5f5f5f5f5f5f	64	intel	cmp al, 0x11
3c11|223344556677885f5f5f5f5f5f5f	64	plan9	CMPL $0x11, AL
3d11223344|556677885f5f5f5f5f5f5f	32	intel	cmp eax, 0x44332211
3d11223344|556677885f5f5f5f5f5f5f	32	plan9	CMPL $0x44332211, AX
3d11223344|556677885f5f5f5f5f5f5f	64	gnu	cmp $0x44332211,%eax
3d11223344|556677885f5f5f5f5f5f5f	64	intel	cmp eax, 0x44332211
3d11223344|556677885f5f5f5f5f5f5f	64	plan9	CMPL $0x44332211, AX
3e67e011|223344556677885f5f5f5f5f	32	intel	addr16 loopne .+0x11
3e67e011|223344556677885f5f5f5f5f	32	plan9	LOOPNE .+17
3e67e011|223344556677885f5f5f5f5f	64	gnu	loopne,pt .+0x11
3e67e011|223344556677885f5f5f5f5f	64	intel	addr32 loopne .+0x11
3e67e011|223344556677885f5f5f5f5f	64	plan9	LOOPNE .+17
3ef367660f38f011|223344556677885f	32	intel	movbe dx, word ptr [bx+di*1]
3ef367660f38f011|223344556677885f	32	plan9	MOVBE DS:0(BX)(DI*1), DX
3ef367660f38f011|223344556677885f	64	gnu	rep movbe %ds:(%ecx),%dx
3ef367660f38f011|223344556677885f	64	intel	movbe dx, word ptr [ecx]
3ef367660f38f011|223344556677885f	64	plan9	MOVBE 0(CX), DX
3f|11223344556677885f5f5f5f5f5f5f	32	intel	aas
3f|11223344556677885f5f5f5f5f5f5f	32	plan9	AAS
3f|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
3f|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
3f|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
4040|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	gnu	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	intel	error: unrecognized instruction
4048|11223344556677885f5f5f5f5f5f	64	plan9	error: unrecognized instruction
40|11223344556677885f5f5f5f5f5f5f	32	intel	inc eax
40|11223344556677885f5f5f5f5f5f5f	32	plan9	INCL AX
480100|11223344556677885f5f5f5f5f	64	gnu	add %rax,(%rax)
480100|11223344556677885f5f5f5f5f	64	intel	add qword ptr [rax], rax
480100|11223344556677885f5f5f5f5f	64	plan9	ADDQ AX, 0(AX)
480311|223344556677885f5f5f5f5f5f	64	gnu	add (%rcx),%rdx
480311|223344556677885f5f5f5f5f5f	64	intel	add rdx, qword ptr [rcx]
480311|223344556677885f5f5f5f5f5f	64	plan9	ADDQ 0(CX), DX
480511223344|556677885f5f5f5f5f5f	64	gnu	add $0x44332211,%rax
480511223344|556677885f5f5f5f5f5f	64	intel	add rax, 0x44332211
480511223344|556677885f5f5f5f5f5f	64	plan9	ADDQ $0x44332211, AX
480911|223344556677885f5f5f5f5f5f	64	gnu	or %rdx,(%rcx)
480911|223344556677885f5f5f5f5f5f	64	intel	or qword ptr [rcx], rdx
480911|223344556677885f5f5f5f5f5f	64	plan9	ORQ DX, 0(CX)
480b11|223344556677885f5f5f5f5f5f	64	gnu	or (%rcx),%rdx
480b11|223344556677885f5f5f5f5f5f	64	intel	or rdx, qword ptr [rcx]
480b11|223344556677885f5f5f5f5f5f	64	plan9	ORQ 0(CX), DX
480d11223344|556677885f5f5f5f5f5f	64	gnu	or $0x44332211,%rax
480d11223344|556677885f5f5f5f5f5f	64	intel	or rax, 0x44332211
480d11223344|556677885f5f5f5f5f5f	64	plan9	ORQ $0x44332211, AX
480f0000|11223344556677885f5f5f5f	64	gnu	sldt (%rax)
480f0000|11223344556677885f5f5f5f	64	intel	sldt word ptr [rax]
480f0000|11223344556677885f5f5f5f	64	plan9	SLDT 0(AX)
480f0008|11223344556677885f5f5f5f	64	gnu	str (%rax)
480f0008|11223344556677885f5f5f5f	64	intel	str word ptr [rax]
480f0008|11223344556677885f5f5f5f	64	plan9	STR 0(AX)
480f0120|11223344556677885f5f5f5f	64	gnu	smsw (%rax)
480f0120|11223344556677885f5f5f5f	64	intel	smsw word ptr [rax]
480f0120|11223344556677885f5f5f5f	64	plan9	SMSW 0(AX)
480f0211|223344556677885f5f5f5f5f	64	gnu	lar (%rcx),%rdx
480f0211|223344556677885f5f5f5f5f	64	intel	lar rdx, word ptr [rcx]
480f0211|223344556677885f5f5f5f5f	64	plan9	LAR 0(CX), DX
480f0311|223344556677885f5f5f5f5f	64	gnu	lsl (%rcx),%rdx
480f0311|223344556677885f5f5f5f5f	64	intel	lsl rdx, word ptr [rcx]
480f0311|223344556677885f5f5f5f5f	64	plan9	LSL 0(CX), DX
480f35|11223344556677885f5f5f5f5f	64	gnu	sysexit
480f35|11223344556677885f5f5f5f5f	64	intel	sysexit
480f35|11223344556677885f5f5f5f5f	64	plan9	SYSEXIT
480f38f011|223344556677885f5f5f5f	64	gnu	movbe (%rcx),%rdx
480f38f011|223344556677885f5f5f5f	64	intel	movbe rdx, qword ptr [rcx]
480f38f011|223344556677885f5f5f5f	64	plan9	MOVBE 0(CX), DX
480f38f111|223344556677885f5f5f5f	64	gnu	movbe %rdx,(%rcx)
480f38f111|223344556677885f5f5f5f	64	intel	movbe qword ptr [rcx], rdx
480f38f111|223344556677885f5f5f5f	64	plan9	MOVBE DX, 0(CX)
480f4011|223344556677885f5f5f5f5f	64	gnu	cmovo (%rcx),%rdx
480f4011|223344556677885f5f5f5f5f	64	intel	cmovo rdx, qword ptr [rcx]
480f4011|223344556677885f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
480f4111|223344556677885f5f5f5f5f	64	gnu	cmovno (%rcx),%rdx
480f4111|223344556677885f5f5f5f5f	64	intel	cmovno rdx, qword ptr [rcx]
480f4111|223344556677885f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
480f4211|223344556677885f5f5f5f5f	64	gnu	cmovb (%rcx),%rdx
480f4211|223344556677885f5f5f5f5f	64	intel	cmovb rdx, qword ptr [rcx]
480f4211|223344556677885f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
480f4311|223344556677885f5f5f5f5f	64	gnu	cmovae (%rcx),%rdx
480f4311|223344556677885f5f5f5f5f	64	intel	cmovnb rdx, qword ptr [rcx]
480f4311|223344556677885f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
480f4411|223344556677885f5f5f5f5f	64	gnu	cmove (%rcx),%rdx
480f4411|223344556677885f5f5f5f5f	64	intel	cmovz rdx, qword ptr [rcx]
480f4411|223344556677885f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
480f4511|223344556677885f5f5f5f5f	64	gnu	cmovne (%rcx),%rdx
480f4511|223344556677885f5f5f5f5f	64	intel	cmovnz rdx, qword ptr [rcx]
480f4511|223344556677885f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
480f4611|223344556677885f5f5f5f5f	64	gnu	cmovbe (%rcx),%rdx
480f4611|223344556677885f5f5f5f5f	64	intel	cmovbe rdx, qword ptr [rcx]
480f4611|223344556677885f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
480f4711|223344556677885f5f5f5f5f	64	gnu	cmova (%rcx),%rdx
480f4711|223344556677885f5f5f5f5f	64	intel	cmovnbe rdx, qword ptr [rcx]
480f4711|223344556677885f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
480f4811|223344556677885f5f5f5f5f	64	gnu	cmovs (%rcx),%rdx
480f4811|223344556677885f5f5f5f5f	64	intel	cmovs rdx, qword ptr [rcx]
480f4811|223344556677885f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
480f4911|223344556677885f5f5f5f5f	64	gnu	cmovns (%rcx),%rdx
480f4911|223344556677885f5f5f5f5f	64	intel	cmovns rdx, qword ptr [rcx]
480f4911|223344556677885f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
480f4a11|223344556677885f5f5f5f5f	64	gnu	cmovp (%rcx),%rdx
480f4a11|223344556677885f5f5f5f5f	64	intel	cmovp rdx, qword ptr [rcx]
480f4a11|223344556677885f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
480f4b11|223344556677885f5f5f5f5f	64	gnu	cmovnp (%rcx),%rdx
480f4b11|223344556677885f5f5f5f5f	64	intel	cmovnp rdx, qword ptr [rcx]
480f4b11|223344556677885f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
480f4c11|223344556677885f5f5f5f5f	64	gnu	cmovl (%rcx),%rdx
480f4c11|223344556677885f5f5f5f5f	64	intel	cmovl rdx, qword ptr [rcx]
480f4c11|223344556677885f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
480f4d11|223344556677885f5f5f5f5f	64	gnu	cmovge (%rcx),%rdx
480f4d11|223344556677885f5f5f5f5f	64	intel	cmovnl rdx, qword ptr [rcx]
480f4d11|223344556677885f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
480f4e11|223344556677885f5f5f5f5f	64	gnu	cmovle (%rcx),%rdx
480f4e11|223344556677885f5f5f5f5f	64	intel	cmovle rdx, qword ptr [rcx]
480f4e11|223344556677885f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
480f4f11|223344556677885f5f5f5f5f	64	gnu	cmovg (%rcx),%rdx
480f4f11|223344556677885f5f5f5f5f	64	intel	cmovnle rdx, qword ptr [rcx]
480f4f11|223344556677885f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
480f6e11|223344556677885f5f5f5f5f	64	gnu	movq (%rcx),%mm2
480f6e11|223344556677885f5f5f5f5f	64	intel	movq mmx2, qword ptr [rcx]
480f6e11|223344556677885f5f5f5f5f	64	plan9	MOVQ 0(CX), M2
480f7e11|223344556677885f5f5f5f5f	64	gnu	movq %mm2,(%rcx)
480f7e11|223344556677885f5f5f5f5f	64	intel	movq qword ptr [rcx], mmx2
480f7e11|223344556677885f5f5f5f5f	64	plan9	MOVQ M2, 0(CX)
480f8011223344|556677885f5f5f5f5f	64	gnu	jo .+0x44332211
480f8011223344|556677885f5f5f5f5f	64	intel	jo .+0x44332211
480f8011223344|556677885f5f5f5f5f	64	plan9	JO .+1144201745
480f8111223344|556677885f5f5f5f5f	64	gnu	jno .+0x44332211
480f8111223344|556677885f5f5f5f5f	64	intel	jno .+0x44332211
480f8111223344|556677885f5f5f5f5f	64	plan9	JNO .+1144201745
480f8211223344|556677885f5f5f5f5f	64	gnu	jb .+0x44332211
480f8211223344|556677885f5f5f5f5f	64	intel	jb .+0x44332211
480f8211223344|556677885f5f5f5f5f	64	plan9	JB .+1144201745
480f8311223344|556677885f5f5f5f5f	64	gnu	jae .+0x44332211
480f8311223344|556677885f5f5f5f5f	64	intel	jnb .+0x44332211
480f8311223344|556677885f5f5f5f5f	64	plan9	JAE .+1144201745
480f8411223344|556677885f5f5f5f5f	64	gnu	je .+0x44332211
480f8411223344|556677885f5f5f5f5f	64	intel	jz .+0x44332211
480f8411223344|556677885f5f5f5f5f	64	plan9	JE .+1144201745
480f8511223344|556677885f5f5f5f5f	64	gnu	jne .+0x44332211
480f8511223344|556677885f5f5f5f5f	64	intel	jnz .+0x44332211
480f8511223344|556677885f5f5f5f5f	64	plan9	JNE .+1144201745
480f8611223344|556677885f5f5f5f5f	64	gnu	jbe .+0x44332211
480f8611223344|556677885f5f5f5f5f	64	intel	jbe .+0x44332211
480f8611223344|556677885f5f5f5f5f	64	plan9	JBE .+1144201745
480f8711223344|556677885f5f5f5f5f	64	gnu	ja .+0x44332211
480f8711223344|556677885f5f5f5f5f	64	intel	jnbe .+0x44332211
480f8711223344|556677885f5f5f5f5f	64	plan9	JA .+1144201745
480f8811223344|556677885f5f5f5f5f	64	gnu	js .+0x44332211
480f8811223344|556677885f5f5f5f5f	64	intel	js .+0x44332211
480f8811223344|556677885f5f5f5f5f	64	plan9	JS .+1144201745
480f8911223344|556677885f5f5f5f5f	64	gnu	jns .+0x44332211
480f8911223344|556677885f5f5f5f5f	64	intel	jns .+0x44332211
480f8911223344|556677885f5f5f5f5f	64	plan9	JNS .+1144201745
480f8a11223344|556677885f5f5f5f5f	64	gnu	jp .+0x44332211
480f8a11223344|556677885f5f5f5f5f	64	intel	jp .+0x44332211
480f8a11223344|556677885f5f5f5f5f	64	plan9	JP .+1144201745
480f8b11223344|556677885f5f5f5f5f	64	gnu	jnp .+0x44332211
480f8b11223344|556677885f5f5f5f5f	64	intel	jnp .+0x44332211
480f8b11223344|556677885f5f5f5f5f	64	plan9	JNP .+1144201745
480f8c11223344|556677885f5f5f5f5f	64	gnu	jl .+0x44332211
480f8c11223344|556677885f5f5f5f5f	64	intel	jl .+0x44332211
480f8c11223344|556677885f5f5f5f5f	64	plan9	JL .+1144201745
480f8d11223344|556677885f5f5f5f5f	64	gnu	jge .+0x44332211
480f8d11223344|556677885f5f5f5f5f	64	intel	jnl .+0x44332211
480f8d11223344|556677885f5f5f5f5f	64	plan9	JGE .+1144201745
480f8e11223344|556677885f5f5f5f5f	64	gnu	jle .+0x44332211
480f8e11223344|556677885f5f5f5f5f	64	intel	jle .+0x44332211
480f8e11223344|556677885f5f5f5f5f	64	plan9	JLE .+1144201745
480f8f11223344|556677885f5f5f5f5f	64	gnu	jg .+0x44332211
480f8f11223344|556677885f5f5f5f5f	64	intel	jnle .+0x44332211
480f8f11223344|556677885f5f5f5f5f	64	plan9	JG .+1144201745
480fa1|11223344556677885f5f5f5f5f	64	gnu	popq %fs
480fa1|11223344556677885f5f5f5f5f	64	intel	pop fs
480fa1|11223344556677885f5f5f5f5f	64	plan9	POPQ FS
480fa311|223344556677885f5f5f5f5f	64	gnu	bt %rdx,(%rcx)
480fa311|223344556677885f5f5f5f5f	64	intel	bt qword ptr [rcx], rdx
480fa311|223344556677885f5f5f5f5f	64	plan9	BTQ DX, 0(CX)
480fa41122|3344556677885f5f5f5f5f	64	gnu	shld $0x22,%rdx,(%rcx)
480fa41122|3344556677885f5f5f5f5f	64	intel	shld qword ptr [rcx], rdx, 0x22
480fa41122|3344556677885f5f5f5f5f	64	plan9	SHLDQ $0x22, DX, 0(CX)
480fa511|223344556677885f5f5f5f5f	64	gnu	shld %cl,%rdx,(%rcx)
480fa511|223344556677885f5f5f5f5f	64	intel	shld qword ptr [rcx], rdx, cl
480fa511|223344556677885f5f5f5f5f	64	plan9	SHLDQ CL, DX, 0(CX)
480fa9|11223344556677885f5f5f5f5f	64	gnu	popq %gs
480fa9|11223344556677885f5f5f5f5f	64	intel	pop gs
480fa9|11223344556677885f5f5f5f5f	64	plan9	POPQ GS
480fab11|223344556677885f5f5f5f5f	64	gnu	bts %rdx,(%rcx)
480fab11|223344556677885f5f5f5f5f	64	intel	bts qword ptr [rcx], rdx
480fab11|223344556677885f5f5f5f5f	64	plan9	BTSQ DX, 0(CX)
480fac1122|3344556677885f5f5f5f5f	64	gnu	shrd $0x22,%rdx,(%rcx)
480fac1122|3344556677885f5f5f5f5f	64	intel	shrd qword ptr [rcx], rdx, 0x22
480fac1122|3344556677885f5f5f5f5f	64	plan9	SHRDQ $0x22, DX, 0(CX)
480fad11|223344556677885f5f5f5f5f	64	gnu	shrd %cl,%rdx,(%rcx)
480fad11|223344556677885f5f5f5f5f	64	intel	shrd qword ptr [rcx], rdx, cl
480fad11|223344556677885f5f5f5f5f	64	plan9	SHRDQ CL, DX, 0(CX)
480fae00|11223344556677885f5f5f5f	64	gnu	fxsave64 (%rax)
480fae00|11223344556677885f5f5f5f	64	intel	fxsave64 ptr [rax]
480fae00|11223344556677885f5f5f5f	64	plan9	FXSAVE64 0(AX)
480fae08|11223344556677885f5f5f5f	64	gnu	fxrstor64 (%rax)
480fae08|11223344556677885f5f5f5f	64	intel	fxrstor64 ptr [rax]
480fae08|11223344556677885f5f5f5f	64	plan9	FXRSTOR64 0(AX)
480fae20|11223344556677885f5f5f5f	64	gnu	xsave64 (%rax)
480fae20|11223344556677885f5f5f5f	64	intel	xsave64 ptr [rax]
480fae20|11223344556677885f5f5f5f	64	plan9	XSAVE64 0(AX)
480fae28|11223344556677885f5f5f5f	64	gnu	xrstor64 (%rax)
480fae28|11223344556677885f5f5f5f	64	intel	xrstor64 ptr [rax]
480fae28|11223344556677885f5f5f5f	64	plan9	XRSTOR64 0(AX)
480fae30|11223344556677885f5f5f5f	64	gnu	xsaveopt64 (%rax)
480fae30|11223344556677885f5f5f5f	64	intel	xsaveopt64 ptr [rax]
480fae30|11223344556677885f5f5f5f	64	plan9	XSAVEOPT64 0(AX)
480faf11|223344556677885f5f5f5f5f	64	gnu	imul (%rcx),%rdx
480faf11|223344556677885f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx]
480faf11|223344556677885f5f5f5f5f	64	plan9	IMULQ 0(CX), DX
480fb111|223344556677885f5f5f5f5f	64	gnu	cmpxchg %rdx,(%rcx)
480fb111|223344556677885f5f5f5f5f	64	intel	cmpxchg qword ptr [rcx], rdx
480fb111|223344556677885f5f5f5f5f	64	plan9	CMPXCHGQ DX, 0(CX)
480fb211|223344556677885f5f5f5f5f	64	gnu	lss (%rcx),%rdx
480fb211|223344556677885f5f5f5f5f	64	intel	lss rdx, ptr [rcx]
480fb211|223344556677885f5f5f5f5f	64	plan9	LSS 0(CX), DX
480fb311|223344556677885f5f5f5f5f	64	gnu	btr %rdx,(%rcx)
480fb311|223344556677885f5f5f5f5f	64	intel	btr qword ptr [rcx], rdx
480fb311|223344556677885f5f5f5f5f	64	plan9	BTRQ DX, 0(CX)
480fb411|223344556677885f5f5f5f5f	64	gnu	lfs (%rcx),%rdx
480fb411|223344556677885f5f5f5f5f	64	intel	lfs rdx, ptr [rcx]
480fb411|223344556677885f5f5f5f5f	64	plan9	LFS 0(CX), DX
480fb511|223344556677885f5f5f5f5f	64	gnu	lgs (%rcx),%rdx
480fb511|223344556677885f5f5f5f5f	64	intel	lgs rdx, ptr [rcx]
480fb511|223344556677885f5f5f5f5f	64	plan9	LGS 0(CX), DX
480fb611|223344556677885f5f5f5f5f	64	gnu	movzbq (%rcx),%rdx
480fb611|223344556677885f5f5f5f5f	64	intel	movzx rdx, byte ptr [rcx]
480fb611|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
480fb711|223344556677885f5f5f5f5f	64	gnu	movzwq (%rcx),%rdx
480fb711|223344556677885f5f5f5f5f	64	intel	movzx rdx, word ptr [rcx]
480fb711|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
480fba2011|223344556677885f5f5f5f	64	gnu	btq $0x11,(%rax)
480fba2011|223344556677885f5f5f5f	64	intel	bt qword ptr [rax], 0x11
480fba2011|223344556677885f5f5f5f	64	plan9	BTQ $0x11, 0(AX)
480fba2811|223344556677885f5f5f5f	64	gnu	btsq $0x11,(%rax)
480fba2811|223344556677885f5f5f5f	64	intel	bts qword ptr [rax], 0x11
480fba2811|223344556677885f5f5f5f	64	plan9	BTSQ $0x11, 0(AX)
480fba3011|223344556677885f5f5f5f	64	gnu	btrq $0x11,(%rax)
480fba3011|223344556677885f5f5f5f	64	intel	btr qword ptr [rax], 0x11
480fba3011|223344556677885f5f5f5f	64	plan9	BTRQ $0x11, 0(AX)
480fba3811|223344556677885f5f5f5f	64	gnu	btcq $0x11,(%rax)
480fba3811|223344556677885f5f5f5f	64	intel	btc qword ptr [rax], 0x11
480fba3811|223344556677885f5f5f5f	64	plan9	BTCQ $0x11, 0(AX)
480fbb11|223344556677885f5f5f5f5f	64	gnu	btc %rdx,(%rcx)
480fbb11|223344556677885f5f5f5f5f	64	intel	btc qword ptr [rcx], rdx
480fbb11|223344556677885f5f5f5f5f	64	plan9	BTCQ DX, 0(CX)
480fbc11|223344556677885f5f5f5f5f	64	gnu	bsf (%rcx),%rdx
480fbc11|223344556677885f5f5f5f5f	64	intel	bsf rdx, qword ptr [rcx]
480fbc11|223344556677885f5f5f5f5f	64	plan9	BSFQ 0(CX), DX
480fbd11|223344556677885f5f5f5f5f	64	gnu	bsr (%rcx),%rdx
480fbd11|223344556677885f5f5f5f5f	64	intel	bsr rdx, qword ptr [rcx]
480fbd11|223344556677885f5f5f5f5f	64	plan9	BSRQ 0(CX), DX
480fbe11|223344556677885f5f5f5f5f	64	gnu	movsbq (%rcx),%rdx
480fbe11|223344556677885f5f5f5f5f	64	intel	movsx rdx, byte ptr [rcx]
480fbe11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
480fbf11|223344556677885f5f5f5f5f	64	gnu	movswq (%rcx),%rdx
480fbf11|223344556677885f5f5f5f5f	64	intel	movsx rdx, word ptr [rcx]
480fbf11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
480fc111|223344556677885f5f5f5f5f	64	gnu	xadd %rdx,(%rcx)
480fc111|223344556677885f5f5f5f5f	64	intel	xadd qword ptr [rcx], rdx
480fc111|223344556677885f5f5f5f5f	64	plan9	XADDQ DX, 0(CX)
480fc311|223344556677885f5f5f5f5f	64	gnu	movnti %rdx,(%rcx)
480fc311|223344556677885f5f5f5f5f	64	intel	movnti qword ptr [rcx], rdx
480fc311|223344556677885f5f5f5f5f	64	plan9	MOVNTIQ DX, 0(CX)
480fc708|11223344556677885f5f5f5f	64	gnu	cmpxchg16b (%rax)
480fc708|11223344556677885f5f5f5f	64	intel	cmpxchg16b xmmword ptr [rax]
480fc708|11223344556677885f5f5f5f	64	plan9	CMPXCHG16B 0(AX)
480fc718|11223344556677885f5f5f5f	64	gnu	xrstors64 (%rax)
480fc718|11223344556677885f5f5f5f	64	intel	xrstors64 ptr [rax]
480fc718|11223344556677885f5f5f5f	64	plan9	XRSTORS64 0(AX)
480fc720|11223344556677885f5f5f5f	64	gnu	xsavec64 (%rax)
480fc720|11223344556677885f5f5f5f	64	intel	xsavec64 ptr [rax]
480fc720|11223344556677885f5f5f5f	64	plan9	XSAVEC64 0(AX)
480fc728|11223344556677885f5f5f5f	64	gnu	xsaves64 (%rax)
480fc728|11223344556677885f5f5f5f	64	intel	xsaves64 ptr [rax]
480fc728|11223344556677885f5f5f5f	64	plan9	XSAVES64 0(AX)
480fc730|11223344556677885f5f5f5f	64	gnu	rdrand
480fc730|11223344556677885f5f5f5f	64	intel	rdrand
480fc730|11223344556677885f5f5f5f	64	plan9	RDRAND
480fc8|11223344556677885f5f5f5f5f	64	gnu	bswap %rax
480fc8|11223344556677885f5f5f5f5f	64	intel	bswap rax
480fc8|11223344556677885f5f5f5f5f	64	plan9	BSWAP AX
481122|3344556677885f5f5f5f5f5f5f	64	gnu	adc %rsp,(%rdx)
481122|3344556677885f5f5f5f5f5f5f	64	intel	adc qword ptr [rdx], rsp
481122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCQ SP, 0(DX)
481311|223344556677885f5f5f5f5f5f	64	gnu	adc (%rcx),%rdx
481311|223344556677885f5f5f5f5f5f	64	intel	adc rdx, qword ptr [rcx]
481311|223344556677885f5f5f5f5f5f	64	plan9	ADCQ 0(CX), DX
481511223344|556677885f5f5f5f5f5f	64	gnu	adc $0x44332211,%rax
481511223344|556677885f5f5f5f5f5f	64	intel	adc rax, 0x44332211
481511223344|556677885f5f5f5f5f5f	64	plan9	ADCQ $0x44332211, AX
481911|223344556677885f5f5f5f5f5f	64	gnu	sbb %rdx,(%rcx)
481911|223344556677885f5f5f5f5f5f	64	intel	sbb qword ptr [rcx], rdx
481911|223344556677885f5f5f5f5f5f	64	plan9	SBBQ DX, 0(CX)
481b11|223344556677885f5f5f5f5f5f	64	gnu	sbb (%rcx),%rdx
481b11|223344556677885f5f5f5f5f5f	64	intel	sbb rdx, qword ptr [rcx]
481b11|223344556677885f5f5f5f5f5f	64	plan9	SBBQ 0(CX), DX
481d11223344|556677885f5f5f5f5f5f	64	gnu	sbb $0x44332211,%rax
481d11223344|556677885f5f5f5f5f5f	64	intel	sbb rax, 0x44332211
481d11223344|556677885f5f5f5f5f5f	64	plan9	SBBQ $0x44332211, AX
482111|223344556677885f5f5f5f5f5f	64	gnu	and %rdx,(%rcx)
482111|223344556677885f5f5f5f5f5f	64	intel	and qword ptr [rcx], rdx
482111|223344556677885f5f5f5f5f5f	64	plan9	ANDQ DX, 0(CX)
482311|223344556677885f5f5f5f5f5f	64	gnu	and (%rcx),%rdx
482311|223344556677885f5f5f5f5f5f	64	intel	and rdx, qword ptr [rcx]
482311|223344556677885f5f5f5f5f5f	64	plan9	ANDQ 0(CX), DX
482511223344|556677885f5f5f5f5f5f	64	gnu	and $0x44332211,%rax
482511223344|556677885f5f5f5f5f5f	64	intel	and rax, 0x44332211
482511223344|556677885f5f5f5f5f5f	64	plan9	ANDQ $0x44332211, AX
482911|223344556677885f5f5f5f5f5f	64	gnu	sub %rdx,(%rcx)
482911|223344556677885f5f5f5f5f5f	64	intel	sub qword ptr [rcx], rdx
482911|223344556677885f5f5f5f5f5f	64	plan9	SUBQ DX, 0(CX)
482b11|223344556677885f5f5f5f5f5f	64	gnu	sub (%rcx),%rdx
482b11|223344556677885f5f5f5f5f5f	64	intel	sub rdx, qword ptr [rcx]
482b11|223344556677885f5f5f5f5f5f	64	plan9	SUBQ 0(CX), DX
482d11223344|556677885f5f5f5f5f5f	64	gnu	sub $0x44332211,%rax
482d11223344|556677885f5f5f5f5f5f	64	intel	sub rax, 0x44332211
482d11223344|556677885f5f5f5f5f5f	64	plan9	SUBQ $0x44332211, AX
483111|223344556677885f5f5f5f5f5f	64	gnu	xor %rdx,(%rcx)
483111|223344556677885f5f5f5f5f5f	64	intel	xor qword ptr [rcx], rdx
483111|223344556677885f5f5f5f5f5f	64	plan9	XORQ DX, 0(CX)
483311|223344556677885f5f5f5f5f5f	64	gnu	xor (%rcx),%rdx
483311|223344556677885f5f5f5f5f5f	64	intel	xor rdx, qword ptr [rcx]
483311|223344556677885f5f5f5f5f5f	64	plan9	XORQ 0(CX), DX
483511223344|556677885f5f5f5f5f5f	64	gnu	xor $0x44332211,%rax
483511223344|556677885f5f5f5f5f5f	64	intel	xor rax, 0x44332211
483511223344|556677885f5f5f5f5f5f	64	plan9	XORQ $0x44332211, AX
483911|223344556677885f5f5f5f5f5f	64	gnu	cmp %rdx,(%rcx)
483911|223344556677885f5f5f5f5f5f	64	intel	cmp qword ptr [rcx], rdx
483911|223344556677885f5f5f5f5f5f	64	plan9	CMPQ DX, 0(CX)
483b11|223344556677885f5f5f5f5f5f	64	gnu	cmp (%rcx),%rdx
483b11|223344556677885f5f5f5f5f5f	64	intel	cmp rdx, qword ptr [rcx]
483b11|223344556677885f5f5f5f5f5f	64	plan9	CMPQ 0(CX), DX
483d11223344|556677885f5f5f5f5f5f	64	gnu	cmp $0x44332211,%rax
483d11223344|556677885f5f5f5f5f5f	64	intel	cmp rax, 0x44332211
483d11223344|556677885f5f5f5f5f5f	64	plan9	CMPQ $0x44332211, AX
4850|11223344556677885f5f5f5f5f5f	64	gnu	push %rax
4850|11223344556677885f5f5f5f5f5f	64	intel	push rax
4850|11223344556677885f5f5f5f5f5f	64	plan9	PUSHQ AX
4858|11223344556677885f5f5f5f5f5f	64	gnu	pop %rax
4858|11223344556677885f5f5f5f5f5f	64	intel	pop rax
4858|11223344556677885f5f5f5f5f5f	64	plan9	POPQ AX
486311|223344556677885f5f5f5f5f5f	64	gnu	movsxd (%rcx),%rdx
486311|223344556677885f5f5f5f5f5f	64	intel	movsxd rdx, dword ptr [rcx]
486311|223344556677885f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
486811223344|556677885f5f5f5f5f5f	64	gnu	pushq $0x44332211
486811223344|556677885f5f5f5f5f5f	64	intel	push 0x44332211
486811223344|556677885f5f5f5f5f5f	64	plan9	PUSHQ $0x44332211
48691122334455|6677885f5f5f5f5f5f	64	gnu	imul $0x55443322,(%rcx),%rdx
48691122334455|6677885f5f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx], 0x55443322
48691122334455|6677885f5f5f5f5f5f	64	plan9	IMULQ $0x55443322, 0(CX), DX
486b1122|3344556677885f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%rdx
486b1122|3344556677885f5f5f5f5f5f	64	intel	imul rdx, qword ptr [rcx], 0x22
486b1122|3344556677885f5f5f5f5f5f	64	plan9	IMULQ $0x22, 0(CX), DX
486d|11223344556677885f5f5f5f5f5f	64	gnu	insl (%dx),%es:(%rdi)
486d|11223344556677885f5f5f5f5f5f	64	intel	insd
486d|11223344556677885f5f5f5f5f5f	64	plan9	INSD DX, ES:0(DI)
486f|11223344556677885f5f5f5f5f5f	64	gnu	outsl %ds:(%rsi),(%dx)
486f|11223344556677885f5f5f5f5f5f	64	intel	outsd
486f|11223344556677885f5f5f5f5f5f	64	plan9	OUTSD DS:0(SI), DX
48810011223344|556677885f5f5f5f5f	64	gnu	addq $0x44332211,(%rax)
48810011223344|556677885f5f5f5f5f	64	intel	add qword ptr [rax], 0x44332211
48810011223344|556677885f5f5f5f5f	64	plan9	ADDQ $0x44332211, 0(AX)
48810811223344|556677885f5f5f5f5f	64	gnu	orq $0x44332211,(%rax)
48810811223344|556677885f5f5f5f5f	64	intel	or qword ptr [rax], 0x44332211
48810811223344|556677885f5f5f5f5f	64	plan9	ORQ $0x44332211, 0(AX)
48811122334455|6677885f5f5f5f5f5f	64	gnu	adcq $0x55443322,(%rcx)
48811122334455|6677885f5f5f5f5f5f	64	intel	adc qword ptr [rcx], 0x55443322
48811122334455|6677885f5f5f5f5f5f	64	plan9	ADCQ $0x55443322, 0(CX)
48811811223344|556677885f5f5f5f5f	64	gnu	sbbq $0x44332211,(%rax)
48811811223344|556677885f5f5f5f5f	64	intel	sbb qword ptr [rax], 0x44332211
48811811223344|556677885f5f5f5f5f	64	plan9	SBBQ $0x44332211, 0(AX)
48812011223344|556677885f5f5f5f5f	64	gnu	andq $0x44332211,(%rax)
48812011223344|556677885f5f5f5f5f	64	intel	and qword ptr [rax], 0x44332211
48812011223344|556677885f5f5f5f5f	64	plan9	ANDQ $0x44332211, 0(AX)
48812811223344|556677885f5f5f5f5f	64	gnu	subq $0x44332211,(%rax)
48812811223344|556677885f5f5f5f5f	64	intel	sub qword ptr [rax], 0x44332211
48812811223344|556677885f5f5f5f5f	64	plan9	SUBQ $0x44332211, 0(AX)
48813011223344|556677885f5f5f5f5f	64	gnu	xorq $0x44332211,(%rax)
48813011223344|556677885f5f5f5f5f	64	intel	xor qword ptr [rax], 0x44332211
48813011223344|556677885f5f5f5f5f	64	plan9	XORQ $0x44332211, 0(AX)
48813811223344|556677885f5f5f5f5f	64	gnu	cmpq $0x44332211,(%rax)
48813811223344|556677885f5f5f5f5f	64	intel	cmp qword ptr [rax], 0x44332211
48813811223344|556677885f5f5f5f5f	64	plan9	CMPQ $0x44332211, 0(AX)
48830011|223344556677885f5f5f5f5f	64	gnu	addq $0x11,(%rax)
48830011|223344556677885f5f5f5f5f	64	intel	add qword ptr [rax], 0x11
48830011|223344556677885f5f5f5f5f	64	plan9	ADDQ $0x11, 0(AX)
48830811|223344556677885f5f5f5f5f	64	gnu	orq $0x11,(%rax)
48830811|223344556677885f5f5f5f5f	64	intel	or qword ptr [rax], 0x11
48830811|223344556677885f5f5f5f5f	64	plan9	ORQ $0x11, 0(AX)
48831122|3344556677885f5f5f5f5f5f	64	gnu	adcq $0x22,(%rcx)
48831122|3344556677885f5f5f5f5f5f	64	intel	adc qword ptr [rcx], 0x22
48831122|3344556677885f5f5f5f5f5f	64	plan9	ADCQ $0x22, 0(CX)
48831811|223344556677885f5f5f5f5f	64	gnu	sbbq $0x11,(%rax)
48831811|223344556677885f5f5f5f5f	64	intel	sbb qword ptr [rax], 0x11
48831811|223344556677885f5f5f5f5f	64	plan9	SBBQ $0x11, 0(AX)
48832011|223344556677885f5f5f5f5f	64	gnu	andq $0x11,(%rax)
48832011|223344556677885f5f5f5f5f	64	intel	and qword ptr [rax], 0x11
48832011|223344556677885f5f5f5f5f	64	plan9	ANDQ $0x11, 0(AX)
48832811|223344556677885f5f5f5f5f	64	gnu	subq $0x11,(%rax)
48832811|223344556677885f5f5f5f5f	64	intel	sub qword ptr [rax], 0x11
48832811|223344556677885f5f5f5f5f	64	plan9	SUBQ $0x11, 0(AX)
48833011|223344556677885f5f5f5f5f	64	gnu	xorq $0x11,(%rax)
48833011|223344556677885f5f5f5f5f	64	intel	xor qword ptr [rax], 0x11
48833011|223344556677885f5f5f5f5f	64	plan9	XORQ $0x11, 0(AX)
48833811|223344556677885f5f5f5f5f	64	gnu	cmpq $0x11,(%rax)
48833811|223344556677885f5f5f5f5f	64	intel	cmp qword ptr [rax], 0x11
48833811|223344556677885f5f5f5f5f	64	plan9	CMPQ $0x11, 0(AX)
488511|223344556677885f5f5f5f5f5f	64	gnu	test %rdx,(%rcx)
488511|223344556677885f5f5f5f5f5f	64	intel	test qword ptr [rcx], rdx
488511|223344556677885f5f5f5f5f5f	64	plan9	TESTQ DX, 0(CX)
488711|223344556677885f5f5f5f5f5f	64	gnu	xchg %rdx,(%rcx)
488711|223344556677885f5f5f5f5f5f	64	intel	xchg qword ptr [rcx], rdx
488711|223344556677885f5f5f5f5f5f	64	plan9	XCHGQ DX, 0(CX)
488911|223344556677885f5f5f5f5f5f	64	gnu	mov %rdx,(%rcx)
488911|223344556677885f5f5f5f5f5f	64	intel	mov qword ptr [rcx], rdx
488911|223344556677885f5f5f5f5f5f	64	plan9	MOVQ DX, 0(CX)
488b11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%rdx
488b11|223344556677885f5f5f5f5f5f	64	intel	mov rdx, qword ptr [rcx]
488b11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), DX
488c11|223344556677885f5f5f5f5f5f	64	gnu	mov %ss,(%rcx)
488c11|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
488c11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ SS, 0(CX)
488d11|223344556677885f5f5f5f5f5f	64	gnu	lea (%rcx),%rdx
488d11|223344556677885f5f5f5f5f5f	64	intel	lea rdx, ptr [rcx]
488d11|223344556677885f5f5f5f5f5f	64	plan9	LEAQ 0(CX), DX
488e11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%ss
488e11|223344556677885f5f5f5f5f5f	64	intel	mov ss, word ptr [rcx]
488e11|223344556677885f5f5f5f5f5f	64	plan9	MOVQ 0(CX), SS
488f00|11223344556677885f5f5f5f5f	64	gnu	popq (%rax)
488f00|11223344556677885f5f5f5f5f	64	intel	pop qword ptr [rax]
488f00|11223344556677885f5f5f5f5f	64	plan9	POPQ 0(AX)
4891|11223344556677885f5f5f5f5f5f	64	gnu	xchg %rax,%rcx
4891|11223344556677885f5f5f5f5f5f	64	intel	xchg rcx, rax
4891|11223344556677885f5f5f5f5f5f	64	plan9	XCHGQ AX, CX
4898|11223344556677885f5f5f5f5f5f	64	gnu	cdqe
4898|11223344556677885f5f5f5f5f5f	64	intel	cdqe
4898|11223344556677885f5f5f5f5f5f	64	plan9	CDQE
4899|11223344556677885f5f5f5f5f5f	64	gnu	cqto
4899|11223344556677885f5f5f5f5f5f	64	intel	cqo
4899|11223344556677885f5f5f5f5f5f	64	plan9	CQO
489c|11223344556677885f5f5f5f5f5f	64	gnu	pushfq
489c|11223344556677885f5f5f5f5f5f	64	intel	pushfq
489c|11223344556677885f5f5f5f5f5f	64	plan9	PUSHFQ
489d|11223344556677885f5f5f5f5f5f	64	gnu	popfq
489d|11223344556677885f5f5f5f5f5f	64	intel	popfq
489d|11223344556677885f5f5f5f5f5f	64	plan9	POPFQ
48a01122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%al
48a01122334455667788|5f5f5f5f5f5f	64	intel	mov al, byte ptr [0x8877665544332211]
48a01122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ -0x778899aabbccddef, AL
48a11122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%rax
48a11122334455667788|5f5f5f5f5f5f	64	intel	mov rax, qword ptr [0x8877665544332211]
48a11122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ -0x778899aabbccddef, AX
48a21122334455667788|5f5f5f5f5f5f	64	gnu	mov %al,-0x778899aabbccddef
48a21122334455667788|5f5f5f5f5f5f	64	intel	mov byte ptr [0x8877665544332211], al
48a21122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ AL, -0x778899aabbccddef
48a31122334455667788|5f5f5f5f5f5f	64	gnu	mov %rax,-0x778899aabbccddef
48a31122334455667788|5f5f5f5f5f5f	64	intel	mov qword ptr [0x8877665544332211], rax
48a31122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ AX, -0x778899aabbccddef
48a5|11223344556677885f5f5f5f5f5f	64	gnu	movsq %ds:(%rsi),%es:(%rdi)
48a5|11223344556677885f5f5f5f5f5f	64	intel	movsq qword ptr [rdi], qword ptr [rsi]
48a5|11223344556677885f5f5f5f5f5f	64	plan9	MOVSQ DS:0(SI), ES:0(DI)
48a7|11223344556677885f5f5f5f5f5f	64	gnu	cmpsq %es:(%rdi),%ds:(%rsi)
48a7|11223344556677885f5f5f5f5f5f	64	intel	cmpsq qword ptr [rsi], qword ptr [rdi]
48a7|11223344556677885f5f5f5f5f5f	64	plan9	CMPSQ ES:0(DI), DS:0(SI)
48a911223344|556677885f5f5f5f5f5f	64	gnu	test $0x44332211,%rax
48a911223344|556677885f5f5f5f5f5f	64	intel	test rax, 0x44332211
48a911223344|556677885f5f5f5f5f5f	64	plan9	TESTQ $0x44332211, AX
48ab|11223344556677885f5f5f5f5f5f	64	gnu	stos %rax,%es:(%rdi)
48ab|11223344556677885f5f5f5f5f5f	64	intel	stosq qword ptr [rdi]
48ab|11223344556677885f5f5f5f5f5f	64	plan9	STOSQ AX, ES:0(DI)
48ad|11223344556677885f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%rax
48ad|11223344556677885f5f5f5f5f5f	64	intel	lodsq qword ptr [rsi]
48ad|11223344556677885f5f5f5f5f5f	64	plan9	LODSQ DS:0(SI), AX
48af|11223344556677885f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%rax
48af|11223344556677885f5f5f5f5f5f	64	intel	scasq qword ptr [rdi]
48af|11223344556677885f5f5f5f5f5f	64	plan9	SCASQ ES:0(DI), AX
48b81122334455667788|5f5f5f5f5f5f	64	gnu	mov $-0x778899aabbccddef,%rax
48b81122334455667788|5f5f5f5f5f5f	64	intel	mov rax, 0x8877665544332211
48b81122334455667788|5f5f5f5f5f5f	64	plan9	MOVQ $0x8877665544332211, AX
48c10011|223344556677885f5f5f5f5f	64	gnu	rolq $0x11,(%rax)
48c10011|223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], 0x11
48c10011|223344556677885f5f5f5f5f	64	plan9	ROLQ $0x11, 0(AX)
48c10811|223344556677885f5f5f5f5f	64	gnu	rorq $0x11,(%rax)
48c10811|223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], 0x11
48c10811|223344556677885f5f5f5f5f	64	plan9	RORQ $0x11, 0(AX)
48c11122|3344556677885f5f5f5f5f5f	64	gnu	rclq $0x22,(%rcx)
48c11122|3344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], 0x22
48c11122|3344556677885f5f5f5f5f5f	64	plan9	RCLQ $0x22, 0(CX)
48c11811|223344556677885f5f5f5f5f	64	gnu	rcrq $0x11,(%rax)
48c11811|223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], 0x11
48c11811|223344556677885f5f5f5f5f	64	plan9	RCRQ $0x11, 0(AX)
48c12011|223344556677885f5f5f5f5f	64	gnu	shlq $0x11,(%rax)
48c12011|223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], 0x11
48c12011|223344556677885f5f5f5f5f	64	plan9	SHLQ $0x11, 0(AX)
48c12811|223344556677885f5f5f5f5f	64	gnu	shrq $0x11,(%rax)
48c12811|223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], 0x11
48c12811|223344556677885f5f5f5f5f	64	plan9	SHRQ $0x11, 0(AX)
48c13811|223344556677885f5f5f5f5f	64	gnu	sarq $0x11,(%rax)
48c13811|223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], 0x11
48c13811|223344556677885f5f5f5f5f	64	plan9	SARQ $0x11, 0(AX)
48c70011223344|556677885f5f5f5f5f	64	gnu	movq $0x44332211,(%rax)
48c70011223344|556677885f5f5f5f5f	64	intel	mov qword ptr [rax], 0x44332211
48c70011223344|556677885f5f5f5f5f	64	plan9	MOVQ $0x44332211, 0(AX)
48c7f811223344|556677885f5f5f5f5f	64	gnu	xbeginq .+0x44332211
48c7f811223344|556677885f5f5f5f5f	64	intel	xbegin .+0x44332211
48c7f811223344|556677885f5f5f5f5f	64	plan9	XBEGIN .+1144201745
48c9|11223344556677885f5f5f5f5f5f	64	gnu	leaveq
48c9|11223344556677885f5f5f5f5f5f	64	intel	leave
48c9|11223344556677885f5f5f5f5f5f	64	plan9	LEAVE
48cf|11223344556677885f5f5f5f5f5f	64	gnu	iretq
48cf|11223344556677885f5f5f5f5f5f	64	intel	iretq
48cf|11223344556677885f5f5f5f5f5f	64	plan9	IRETQ
48d100|11223344556677885f5f5f5f5f	64	gnu	rolq (%rax)
48d100|11223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], 0x1
48d100|11223344556677885f5f5f5f5f	64	plan9	ROLQ $0x1, 0(AX)
48d108|11223344556677885f5f5f5f5f	64	gnu	rorq (%rax)
48d108|11223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], 0x1
48d108|11223344556677885f5f5f5f5f	64	plan9	RORQ $0x1, 0(AX)
48d111|223344556677885f5f5f5f5f5f	64	gnu	rclq (%rcx)
48d111|223344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], 0x1
48d111|223344556677885f5f5f5f5f5f	64	plan9	RCLQ $0x1, 0(CX)
48d118|11223344556677885f5f5f5f5f	64	gnu	rcrq (%rax)
48d118|11223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], 0x1
48d118|11223344556677885f5f5f5f5f	64	plan9	RCRQ $0x1, 0(AX)
48d120|11223344556677885f5f5f5f5f	64	gnu	shlq (%rax)
48d120|11223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], 0x1
48d120|11223344556677885f5f5f5f5f	64	plan9	SHLQ $0x1, 0(AX)
48d128|11223344556677885f5f5f5f5f	64	gnu	shrq (%rax)
48d128|11223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], 0x1
48d128|11223344556677885f5f5f5f5f	64	plan9	SHRQ $0x1, 0(AX)
48d138|11223344556677885f5f5f5f5f	64	gnu	sarq (%rax)
48d138|11223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], 0x1
48d138|11223344556677885f5f5f5f5f	64	plan9	SARQ $0x1, 0(AX)
48d300|11223344556677885f5f5f5f5f	64	gnu	rolq %cl,(%rax)
48d300|11223344556677885f5f5f5f5f	64	intel	rol qword ptr [rax], cl
48d300|11223344556677885f5f5f5f5f	64	plan9	ROLQ CL, 0(AX)
48d308|11223344556677885f5f5f5f5f	64	gnu	rorq %cl,(%rax)
48d308|11223344556677885f5f5f5f5f	64	intel	ror qword ptr [rax], cl
48d308|11223344556677885f5f5f5f5f	64	plan9	RORQ CL, 0(AX)
48d311|223344556677885f5f5f5f5f5f	64	gnu	rclq %cl,(%rcx)
48d311|223344556677885f5f5f5f5f5f	64	intel	rcl qword ptr [rcx], cl
48d311|223344556677885f5f5f5f5f5f	64	plan9	RCLQ CL, 0(CX)
48d318|11223344556677885f5f5f5f5f	64	gnu	rcrq %cl,(%rax)
48d318|11223344556677885f5f5f5f5f	64	intel	rcr qword ptr [rax], cl
48d318|11223344556677885f5f5f5f5f	64	plan9	RCRQ CL, 0(AX)
48d320|11223344556677885f5f5f5f5f	64	gnu	shlq %cl,(%rax)
48d320|11223344556677885f5f5f5f5f	64	intel	shl qword ptr [rax], cl
48d320|11223344556677885f5f5f5f5f	64	plan9	SHLQ CL, 0(AX)
48d328|11223344556677885f5f5f5f5f	64	gnu	shrq %cl,(%rax)
48d328|11223344556677885f5f5f5f5f	64	intel	shr qword ptr [rax], cl
48d328|11223344556677885f5f5f5f5f	64	plan9	SHRQ CL, 0(AX)
48d338|11223344556677885f5f5f5f5f	64	gnu	sarq %cl,(%rax)
48d338|11223344556677885f5f5f5f5f	64	intel	sar qword ptr [rax], cl
48d338|11223344556677885f5f5f5f5f	64	plan9	SARQ CL, 0(AX)
48d7|11223344556677885f5f5f5f5f5f	64	gnu	xlat %ds:(%rbx)
48d7|11223344556677885f5f5f5f5f5f	64	intel	xlat
48d7|11223344556677885f5f5f5f5f5f	64	plan9	XLATB DS:0(BX)
48e511|223344556677885f5f5f5f5f5f	64	gnu	in $0x11,%eax
48e511|223344556677885f5f5f5f5f5f	64	intel	in eax, 0x11
48e511|223344556677885f5f5f5f5f5f	64	plan9	INQ $0x11, AX
48e711|223344556677885f5f5f5f5f5f	64	gnu	out %eax,$0x11
48e711|223344556677885f5f5f5f5f5f	64	intel	out 0x11, eax
48e711|223344556677885f5f5f5f5f5f	64	plan9	OUTQ AX, $0x11
48e811223344|556677885f5f5f5f5f5f	64	gnu	callq .+0x44332211
48e811223344|556677885f5f5f5f5f5f	64	intel	call .+0x44332211
48e811223344|556677885f5f5f5f5f5f	64	plan9	CALL .+1144201745
48e911223344|556677885f5f5f5f5f5f	64	gnu	jmpq .+0x44332211
48e911223344|556677885f5f5f5f5f5f	64	intel	jmp .+0x44332211
48e911223344|556677885f5f5f5f5f5f	64	plan9	JMP .+1144201745
48ed|11223344556677885f5f5f5f5f5f	64	gnu	in (%dx),%eax
48ed|11223344556677885f5f5f5f5f5f	64	intel	in eax, dx
48ed|11223344556677885f5f5f5f5f5f	64	plan9	INQ DX, AX
48ef|11223344556677885f5f5f5f5f5f	64	gnu	out %eax,(%dx)
48ef|11223344556677885f5f5f5f5f5f	64	intel	out dx, eax
48ef|11223344556677885f5f5f5f5f5f	64	plan9	OUTQ AX, DX
48f70011223344|556677885f5f5f5f5f	64	gnu	testq $0x44332211,(%rax)
48f70011223344|556677885f5f5f5f5f	64	intel	test qword ptr [rax], 0x44332211
48f70011223344|556677885f5f5f5f5f	64	plan9	TESTQ $0x44332211, 0(AX)
48f711|223344556677885f5f5f5f5f5f	64	gnu	notq (%rcx)
48f711|223344556677885f5f5f5f5f5f	64	intel	not qword ptr [rcx]
48f711|223344556677885f5f5f5f5f5f	64	plan9	NOTQ 0(CX)
48f718|11223344556677885f5f5f5f5f	64	gnu	negq (%rax)
48f718|11223344556677885f5f5f5f5f	64	intel	neg qword ptr [rax]
48f718|11223344556677885f5f5f5f5f	64	plan9	NEGQ 0(AX)
48f720|11223344556677885f5f5f5f5f	64	gnu	mulq (%rax)
48f720|11223344556677885f5f5f5f5f	64	intel	mul qword ptr [rax]
48f720|11223344556677885f5f5f5f5f	64	plan9	MULQ 0(AX)
48f728|11223344556677885f5f5f5f5f	64	gnu	imulq (%rax)
48f728|11223344556677885f5f5f5f5f	64	intel	imul qword ptr [rax]
48f728|11223344556677885f5f5f5f5f	64	plan9	IMULQ 0(AX)
48f730|11223344556677885f5f5f5f5f	64	gnu	divq (%rax)
48f730|11223344556677885f5f5f5f5f	64	intel	div qword ptr [rax]
48f730|11223344556677885f5f5f5f5f	64	plan9	DIVQ 0(AX)
48f738|11223344556677885f5f5f5f5f	64	gnu	idivq (%rax)
48f738|11223344556677885f5f5f5f5f	64	intel	idiv qword ptr [rax]
48f738|11223344556677885f5f5f5f5f	64	plan9	IDIVQ 0(AX)
48ff00|11223344556677885f5f5f5f5f	64	gnu	incq (%rax)
48ff00|11223344556677885f5f5f5f5f	64	intel	inc qword ptr [rax]
48ff00|11223344556677885f5f5f5f5f	64	plan9	INCQ 0(AX)
48ff08|11223344556677885f5f5f5f5f	64	gnu	decq (%rax)
48ff08|11223344556677885f5f5f5f5f	64	intel	dec qword ptr [rax]
48ff08|11223344556677885f5f5f5f5f	64	plan9	DECQ 0(AX)
48ff18|11223344556677885f5f5f5f5f	64	gnu	lcallq *(%rax)
48ff18|11223344556677885f5f5f5f5f	64	intel	call far ptr [rax]
48ff18|11223344556677885f5f5f5f5f	64	plan9	LCALL 0(AX)
48ff28|11223344556677885f5f5f5f5f	64	gnu	ljmpq *(%rax)
48ff28|11223344556677885f5f5f5f5f	64	intel	jmp far ptr [rax]
48ff28|11223344556677885f5f5f5f5f	64	plan9	LJMP 0(AX)
48ff30|11223344556677885f5f5f5f5f	64	gnu	pushq (%rax)
48ff30|11223344556677885f5f5f5f5f	64	intel	push qword ptr [rax]
48ff30|11223344556677885f5f5f5f5f	64	plan9	PUSHQ 0(AX)
48|010011223344556677885f5f5f5f5f	32	intel	dec eax
48|010011223344556677885f5f5f5f5f	32	plan9	DECL AX
50|11223344556677885f5f5f5f5f5f5f	32	intel	push eax
50|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL AX
50|11223344556677885f5f5f5f5f5f5f	64	gnu	push %rax
50|11223344556677885f5f5f5f5f5f5f	64	intel	push rax
50|11223344556677885f5f5f5f5f5f5f	64	plan9	PUSHL AX
58|11223344556677885f5f5f5f5f5f5f	32	intel	pop eax
58|11223344556677885f5f5f5f5f5f5f	32	plan9	POPL AX
58|11223344556677885f5f5f5f5f5f5f	64	gnu	pop %rax
58|11223344556677885f5f5f5f5f5f5f	64	intel	pop rax
58|11223344556677885f5f5f5f5f5f5f	64	plan9	POPL AX
60|11223344556677885f5f5f5f5f5f5f	32	intel	pushad
60|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHAD
60|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
60|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
60|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	32	intel	popad
61|11223344556677885f5f5f5f5f5f5f	32	plan9	POPAD
61|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
61|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
6211|223344556677885f5f5f5f5f5f5f	32	intel	bound edx, qword ptr [ecx]
6211|223344556677885f5f5f5f5f5f5f	32	plan9	BOUND 0(CX), DX
62|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
62|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
62|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
6311|223344556677885f5f5f5f5f5f5f	32	intel	arpl word ptr [ecx], dx
6311|223344556677885f5f5f5f5f5f5f	32	plan9	ARPL DX, 0(CX)
6311|223344556677885f5f5f5f5f5f5f	64	gnu	movsxd (%rcx),%edx
6311|223344556677885f5f5f5f5f5f5f	64	intel	movsxd edx, dword ptr [rcx]
6311|223344556677885f5f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
660111|223344556677885f5f5f5f5f5f	32	intel	add word ptr [ecx], dx
660111|223344556677885f5f5f5f5f5f	32	plan9	ADDW DX, 0(CX)
660111|223344556677885f5f5f5f5f5f	64	gnu	add %dx,(%rcx)
660111|223344556677885f5f5f5f5f5f	64	intel	add word ptr [rcx], dx
660111|223344556677885f5f5f5f5f5f	64	plan9	ADDW DX, 0(CX)
660311|223344556677885f5f5f5f5f5f	32	intel	add dx, word ptr [ecx]
660311|223344556677885f5f5f5f5f5f	32	plan9	ADDW 0(CX), DX
660311|223344556677885f5f5f5f5f5f	64	gnu	add (%rcx),%dx
660311|223344556677885f5f5f5f5f5f	64	intel	add dx, word ptr [rcx]
660311|223344556677885f5f5f5f5f5f	64	plan9	ADDW 0(CX), DX
66051122|3344556677885f5f5f5f5f5f	32	intel	add ax, 0x2211
66051122|3344556677885f5f5f5f5f5f	32	plan9	ADDW $0x2211, AX
66051122|3344556677885f5f5f5f5f5f	64	gnu	add $0x2211,%ax
66051122|3344556677885f5f5f5f5f5f	64	intel	add ax, 0x2211
66051122|3344556677885f5f5f5f5f5f	64	plan9	ADDW $0x2211, AX
660911|223344556677885f5f5f5f5f5f	32	intel	or word ptr [ecx], dx
660911|223344556677885f5f5f5f5f5f	32	plan9	ORW DX, 0(CX)
660911|223344556677885f5f5f5f5f5f	64	gnu	or %dx,(%rcx)
660911|223344556677885f5f5f5f5f5f	64	intel	or word ptr [rcx], dx
660911|223344556677885f5f5f5f5f5f	64	plan9	ORW DX, 0(CX)
660b11|223344556677885f5f5f5f5f5f	32	intel	or dx, word ptr [ecx]
660b11|223344556677885f5f5f5f5f5f	32	plan9	ORW 0(CX), DX
660b11|223344556677885f5f5f5f5f5f	64	gnu	or (%rcx),%dx
660b11|223344556677885f5f5f5f5f5f	64	intel	or dx, word ptr [rcx]
660b11|223344556677885f5f5f5f5f5f	64	plan9	ORW 0(CX), DX
660d1122|3344556677885f5f5f5f5f5f	32	intel	or ax, 0x2211
660d1122|3344556677885f5f5f5f5f5f	32	plan9	ORW $0x2211, AX
660d1122|3344556677885f5f5f5f5f5f	64	gnu	or $0x2211,%ax
660d1122|3344556677885f5f5f5f5f5f	64	intel	or ax, 0x2211
660d1122|3344556677885f5f5f5f5f5f	64	plan9	ORW $0x2211, AX
660f0000|11223344556677885f5f5f5f	32	intel	sldt word ptr [eax]
660f0000|11223344556677885f5f5f5f	32	plan9	SLDT 0(AX)
660f0000|11223344556677885f5f5f5f	64	gnu	data16 sldt (%rax)
660f0000|11223344556677885f5f5f5f	64	intel	sldt word ptr [rax]
660f0000|11223344556677885f5f5f5f	64	plan9	SLDT 0(AX)
660f0008|11223344556677885f5f5f5f	32	intel	str word ptr [eax]
660f0008|11223344556677885f5f5f5f	32	plan9	STR 0(AX)
660f0008|11223344556677885f5f5f5f	64	gnu	data16 str (%rax)
660f0008|11223344556677885f5f5f5f	64	intel	str word ptr [rax]
660f0008|11223344556677885f5f5f5f	64	plan9	STR 0(AX)
660f01a611223344|556677885f5f5f5f	32	intel	smsw word ptr [esi+0x44332211]
660f01a611223344|556677885f5f5f5f	32	plan9	SMSW 0x44332211(SI)
660f01a611223344|556677885f5f5f5f	64	gnu	data16 smsw 0x44332211(%rsi)
660f01a611223344|556677885f5f5f5f	64	intel	smsw word ptr [rsi+0x44332211]
660f01a611223344|556677885f5f5f5f	64	plan9	SMSW 0x44332211(SI)
660f0211|223344556677885f5f5f5f5f	32	intel	lar dx, word ptr [ecx]
660f0211|223344556677885f5f5f5f5f	32	plan9	LAR 0(CX), DX
660f0211|223344556677885f5f5f5f5f	64	gnu	lar (%rcx),%dx
660f0211|223344556677885f5f5f5f5f	64	intel	lar dx, word ptr [rcx]
660f0211|223344556677885f5f5f5f5f	64	plan9	LAR 0(CX), DX
660f0311|223344556677885f5f5f5f5f	32	intel	lsl dx, word ptr [ecx]
660f0311|223344556677885f5f5f5f5f	32	plan9	LSL 0(CX), DX
660f0311|223344556677885f5f5f5f5f	64	gnu	lsl (%rcx),%dx
660f0311|223344556677885f5f5f5f5f	64	intel	lsl dx, word ptr [rcx]
660f0311|223344556677885f5f5f5f5f	64	plan9	LSL 0(CX), DX
660f1011|223344556677885f5f5f5f5f	32	intel	movupd xmm2, xmmword ptr [ecx]
660f1011|223344556677885f5f5f5f5f	32	plan9	MOVUPD 0(CX), X2
660f1011|223344556677885f5f5f5f5f	64	gnu	movupd (%rcx),%xmm2
660f1011|223344556677885f5f5f5f5f	64	intel	movupd xmm2, xmmword ptr [rcx]
660f1011|223344556677885f5f5f5f5f	64	plan9	MOVUPD 0(CX), X2
660f1122|3344556677885f5f5f5f5f5f	32	intel	movupd xmmword ptr [edx], xmm4
660f1122|3344556677885f5f5f5f5f5f	32	plan9	MOVUPD X4, 0(DX)
660f1122|3344556677885f5f5f5f5f5f	64	gnu	movupd %xmm4,(%rdx)
660f1122|3344556677885f5f5f5f5f5f	64	intel	movupd xmmword ptr [rdx], xmm4
660f1122|3344556677885f5f5f5f5f5f	64	plan9	MOVUPD X4, 0(DX)
660f1211|223344556677885f5f5f5f5f	32	intel	movlpd xmm2, qword ptr [ecx]
660f1211|223344556677885f5f5f5f5f	32	plan9	MOVLPD 0(CX), X2
660f1211|223344556677885f5f5f5f5f	64	gnu	movlpd (%rcx),%xmm2
660f1211|223344556677885f5f5f5f5f	64	intel	movlpd xmm2, qword ptr [rcx]
660f1211|223344556677885f5f5f5f5f	64	plan9	MOVLPD 0(CX), X2
660f1311|223344556677885f5f5f5f5f	32	intel	movlpd qword ptr [ecx], xmm2
660f1311|223344556677885f5f5f5f5f	32	plan9	MOVLPD X2, 0(CX)
660f1311|223344556677885f5f5f5f5f	64	gnu	movlpd %xmm2,(%rcx)
660f1311|223344556677885f5f5f5f5f	64	intel	movlpd qword ptr [rcx], xmm2
660f1311|223344556677885f5f5f5f5f	64	plan9	MOVLPD X2, 0(CX)
660f1411|223344556677885f5f5f5f5f	32	intel	unpcklpd xmm2, xmmword ptr [ecx]
660f1411|223344556677885f5f5f5f5f	32	plan9	UNPCKLPD 0(CX), X2
660f1411|223344556677885f5f5f5f5f	64	gnu	unpcklpd (%rcx),%xmm2
660f1411|223344556677885f5f5f5f5f	64	intel	unpcklpd xmm2, xmmword ptr [rcx]
660f1411|223344556677885f5f5f5f5f	64	plan9	UNPCKLPD 0(CX), X2
660f1511|223344556677885f5f5f5f5f	32	intel	unpckhpd xmm2, xmmword ptr [ecx]
660f1511|223344556677885f5f5f5f5f	32	plan9	UNPCKHPD 0(CX), X2
660f1511|223344556677885f5f5f5f5f	64	gnu	unpckhpd (%rcx),%xmm2
660f1511|223344556677885f5f5f5f5f	64	intel	unpckhpd xmm2, xmmword ptr [rcx]
660f1511|223344556677885f5f5f5f5f	64	plan9	UNPCKHPD 0(CX), X2
660f1611|223344556677885f5f5f5f5f	32	intel	movhpd xmm2, qword ptr [ecx]
660f1611|223344556677885f5f5f5f5f	32	plan9	MOVHPD 0(CX), X2
660f1611|223344556677885f5f5f5f5f	64	gnu	movhpd (%rcx),%xmm2
660f1611|223344556677885f5f5f5f5f	64	intel	movhpd xmm2, qword ptr [rcx]
660f1611|223344556677885f5f5f5f5f	64	plan9	MOVHPD 0(CX), X2
660f1711|223344556677885f5f5f5f5f	32	intel	movhpd qword ptr [ecx], xmm2
660f1711|223344556677885f5f5f5f5f	32	plan9	MOVHPD X2, 0(CX)
660f1711|223344556677885f5f5f5f5f	64	gnu	movhpd %xmm2,(%rcx)
660f1711|223344556677885f5f5f5f5f	64	intel	movhpd qword ptr [rcx], xmm2
660f1711|223344556677885f5f5f5f5f	64	plan9	MOVHPD X2, 0(CX)
660f1f00|11223344556677885f5f5f5f	32	intel	nop word ptr [eax], ax
660f1f00|11223344556677885f5f5f5f	32	plan9	NOPW 0(AX)
660f1f00|11223344556677885f5f5f5f	64	gnu	nopw (%rax)
660f1f00|11223344556677885f5f5f5f	64	intel	nop word ptr [rax], ax
660f1f00|11223344556677885f5f5f5f	64	plan9	NOPW 0(AX)
660f2811|223344556677885f5f5f5f5f	32	intel	movapd xmm2, xmmword ptr [ecx]
660f2811|223344556677885f5f5f5f5f	32	plan9	MOVAPD 0(CX), X2
660f2811|223344556677885f5f5f5f5f	64	gnu	movapd (%rcx),%xmm2
660f2811|223344556677885f5f5f5f5f	64	intel	movapd xmm2, xmmword ptr [rcx]
660f2811|223344556677885f5f5f5f5f	64	plan9	MOVAPD 0(CX), X2
660f2911|223344556677885f5f5f5f5f	32	intel	movapd xmmword ptr [ecx], xmm2
660f2911|223344556677885f5f5f5f5f	32	plan9	MOVAPD X2, 0(CX)
660f2911|223344556677885f5f5f5f5f	64	gnu	movapd %xmm2,(%rcx)
660f2911|223344556677885f5f5f5f5f	64	intel	movapd xmmword ptr [rcx], xmm2
660f2911|223344556677885f5f5f5f5f	64	plan9	MOVAPD X2, 0(CX)
660f2a11|223344556677885f5f5f5f5f	32	intel	cvtpi2pd xmm2, qword ptr [ecx]
660f2a11|223344556677885f5f5f5f5f	32	plan9	CVTPI2PD 0(CX), X2
660f2a11|223344556677885f5f5f5f5f	64	gnu	cvtpi2pd (%rcx),%xmm2
660f2a11|223344556677885f5f5f5f5f	64	intel	cvtpi2pd xmm2, qword ptr [rcx]
660f2a11|223344556677885f5f5f5f5f	64	plan9	CVTPI2PD 0(CX), X2
660f2b11|223344556677885f5f5f5f5f	32	intel	movntpd xmmword ptr [ecx], xmm2
660f2b11|223344556677885f5f5f5f5f	32	plan9	MOVNTPD X2, 0(CX)
660f2b11|223344556677885f5f5f5f5f	64	gnu	movntpd %xmm2,(%rcx)
660f2b11|223344556677885f5f5f5f5f	64	intel	movntpd xmmword ptr [rcx], xmm2
660f2b11|223344556677885f5f5f5f5f	64	plan9	MOVNTPD X2, 0(CX)
660f2c11|223344556677885f5f5f5f5f	32	intel	cvttpd2pi mmx2, xmmword ptr [ecx]
660f2c11|223344556677885f5f5f5f5f	32	plan9	CVTTPD2PI 0(CX), M2
660f2c11|223344556677885f5f5f5f5f	64	gnu	cvttpd2pi (%rcx),%mm2
660f2c11|223344556677885f5f5f5f5f	64	intel	cvttpd2pi mmx2, xmmword ptr [rcx]
660f2c11|223344556677885f5f5f5f5f	64	plan9	CVTTPD2PI 0(CX), M2
660f2d11|223344556677885f5f5f5f5f	32	intel	cvtpd2pi mmx2, xmmword ptr [ecx]
660f2d11|223344556677885f5f5f5f5f	32	plan9	CVTPD2PI 0(CX), M2
660f2d11|223344556677885f5f5f5f5f	64	gnu	cvtpd2pi (%rcx),%mm2
660f2d11|223344556677885f5f5f5f5f	64	intel	cvtpd2pi mmx2, xmmword ptr [rcx]
660f2d11|223344556677885f5f5f5f5f	64	plan9	CVTPD2PI 0(CX), M2
660f2e11|223344556677885f5f5f5f5f	32	intel	ucomisd xmm2, qword ptr [ecx]
660f2e11|223344556677885f5f5f5f5f	32	plan9	UCOMISD 0(CX), X2
660f2e11|223344556677885f5f5f5f5f	64	gnu	ucomisd (%rcx),%xmm2
660f2e11|223344556677885f5f5f5f5f	64	intel	ucomisd xmm2, qword ptr [rcx]
660f2e11|223344556677885f5f5f5f5f	64	plan9	UCOMISD 0(CX), X2
660f2f11|223344556677885f5f5f5f5f	32	intel	comisd xmm2, qword ptr [ecx]
660f2f11|223344556677885f5f5f5f5f	32	plan9	COMISD 0(CX), X2
660f2f11|223344556677885f5f5f5f5f	64	gnu	comisd (%rcx),%xmm2
660f2f11|223344556677885f5f5f5f5f	64	intel	comisd xmm2, qword ptr [rcx]
660f2f11|223344556677885f5f5f5f5f	64	plan9	COMISD 0(CX), X2
660f380011|223344556677885f5f5f5f	32	intel	pshufb xmm2, xmmword ptr [ecx]
660f380011|223344556677885f5f5f5f	32	plan9	PSHUFB 0(CX), X2
660f380011|223344556677885f5f5f5f	64	gnu	pshufb (%rcx),%xmm2
660f380011|223344556677885f5f5f5f	64	intel	pshufb xmm2, xmmword ptr [rcx]
660f380011|223344556677885f5f5f5f	64	plan9	PSHUFB 0(CX), X2
660f380111|223344556677885f5f5f5f	32	intel	phaddw xmm2, xmmword ptr [ecx]
660f380111|223344556677885f5f5f5f	32	plan9	PHADDW 0(CX), X2
660f380111|223344556677885f5f5f5f	64	gnu	phaddw (%rcx),%xmm2
660f380111|223344556677885f5f5f5f	64	intel	phaddw xmm2, xmmword ptr [rcx]
660f380111|223344556677885f5f5f5f	64	plan9	PHADDW 0(CX), X2
660f380211|223344556677885f5f5f5f	32	intel	phaddd xmm2, xmmword ptr [ecx]
660f380211|223344556677885f5f5f5f	32	plan9	PHADDD 0(CX), X2
660f380211|223344556677885f5f5f5f	64	gnu	phaddd (%rcx),%xmm2
660f380211|223344556677885f5f5f5f	64	intel	phaddd xmm2, xmmword ptr [rcx]
660f380211|223344556677885f5f5f5f	64	plan9	PHADDD 0(CX), X2
660f380311|223344556677885f5f5f5f	32	intel	phaddsw xmm2, xmmword ptr [ecx]
660f380311|223344556677885f5f5f5f	32	plan9	PHADDSW 0(CX), X2
660f380311|223344556677885f5f5f5f	64	gnu	phaddsw (%rcx),%xmm2
660f380311|223344556677885f5f5f5f	64	intel	phaddsw xmm2, xmmword ptr [rcx]
660f380311|223344556677885f5f5f5f	64	plan9	PHADDSW 0(CX), X2
660f380411|223344556677885f5f5f5f	32	intel	pmaddubsw xmm2, xmmword ptr [ecx]
660f380411|223344556677885f5f5f5f	32	plan9	PMADDUBSW 0(CX), X2
660f380411|223344556677885f5f5f5f	64	gnu	pmaddubsw (%rcx),%xmm2
660f380411|223344556677885f5f5f5f	64	intel	pmaddubsw xmm2, xmmword ptr [rcx]
660f380411|223344556677885f5f5f5f	64	plan9	PMADDUBSW 0(CX), X2
660f380511|223344556677885f5f5f5f	32	intel	phsubw xmm2, xmmword ptr [ecx]
660f380511|223344556677885f5f5f5f	32	plan9	PHSUBW 0(CX), X2
660f380511|223344556677885f5f5f5f	64	gnu	phsubw (%rcx),%xmm2
660f380511|223344556677885f5f5f5f	64	intel	phsubw xmm2, xmmword ptr [rcx]
660f380511|223344556677885f5f5f5f	64	plan9	PHSUBW 0(CX), X2
660f380611|223344556677885f5f5f5f	32	intel	phsubd xmm2, xmmword ptr [ecx]
660f380611|223344556677885f5f5f5f	32	plan9	PHSUBD 0(CX), X2
660f380611|223344556677885f5f5f5f	64	gnu	phsubd (%rcx),%xmm2
660f380611|223344556677885f5f5f5f	64	intel	phsubd xmm2, xmmword ptr [rcx]
660f380611|223344556677885f5f5f5f	64	plan9	PHSUBD 0(CX), X2
660f380711|223344556677885f5f5f5f	32	intel	phsubsw xmm2, xmmword ptr [ecx]
660f380711|223344556677885f5f5f5f	32	plan9	PHSUBSW 0(CX), X2
660f380711|223344556677885f5f5f5f	64	gnu	phsubsw (%rcx),%xmm2
660f380711|223344556677885f5f5f5f	64	intel	phsubsw xmm2, xmmword ptr [rcx]
660f380711|223344556677885f5f5f5f	64	plan9	PHSUBSW 0(CX), X2
660f380811|223344556677885f5f5f5f	32	intel	psignb xmm2, xmmword ptr [ecx]
660f380811|223344556677885f5f5f5f	32	plan9	PSIGNB 0(CX), X2
660f380811|223344556677885f5f5f5f	64	gnu	psignb (%rcx),%xmm2
660f380811|223344556677885f5f5f5f	64	intel	psignb xmm2, xmmword ptr [rcx]
660f380811|223344556677885f5f5f5f	64	plan9	PSIGNB 0(CX), X2
660f380911|223344556677885f5f5f5f	32	intel	psignw xmm2, xmmword ptr [ecx]
660f380911|223344556677885f5f5f5f	32	plan9	PSIGNW 0(CX), X2
660f380911|223344556677885f5f5f5f	64	gnu	psignw (%rcx),%xmm2
660f380911|223344556677885f5f5f5f	64	intel	psignw xmm2, xmmword ptr [rcx]
660f380911|223344556677885f5f5f5f	64	plan9	PSIGNW 0(CX), X2
660f380a11|223344556677885f5f5f5f	32	intel	psignd xmm2, xmmword ptr [ecx]
660f380a11|223344556677885f5f5f5f	32	plan9	PSIGND 0(CX), X2
660f380a11|223344556677885f5f5f5f	64	gnu	psignd (%rcx),%xmm2
660f380a11|223344556677885f5f5f5f	64	intel	psignd xmm2, xmmword ptr [rcx]
660f380a11|223344556677885f5f5f5f	64	plan9	PSIGND 0(CX), X2
660f380b11|223344556677885f5f5f5f	32	intel	pmulhrsw xmm2, xmmword ptr [ecx]
660f380b11|223344556677885f5f5f5f	32	plan9	PMULHRSW 0(CX), X2
660f380b11|223344556677885f5f5f5f	64	gnu	pmulhrsw (%rcx),%xmm2
660f380b11|223344556677885f5f5f5f	64	intel	pmulhrsw xmm2, xmmword ptr [rcx]
660f380b11|223344556677885f5f5f5f	64	plan9	PMULHRSW 0(CX), X2
660f381011|223344556677885f5f5f5f	32	intel	pblendvb xmm2, xmmword ptr [ecx]
660f381011|223344556677885f5f5f5f	32	plan9	PBLENDVB X0, 0(CX), X2
660f381011|223344556677885f5f5f5f	64	gnu	pblendvb %xmm0,(%rcx),%xmm2
660f381011|223344556677885f5f5f5f	64	intel	pblendvb xmm2, xmmword ptr [rcx]
660f381011|223344556677885f5f5f5f	64	plan9	PBLENDVB X0, 0(CX), X2
660f381411|223344556677885f5f5f5f	32	intel	blendvps xmm2, xmmword ptr [ecx]
660f381411|223344556677885f5f5f5f	32	plan9	BLENDVPS X0, 0(CX), X2
660f381411|223344556677885f5f5f5f	64	gnu	blendvps %xmm0,(%rcx),%xmm2
660f381411|223344556677885f5f5f5f	64	intel	blendvps xmm2, xmmword ptr [rcx]
660f381411|223344556677885f5f5f5f	64	plan9	BLENDVPS X0, 0(CX), X2
660f381511|223344556677885f5f5f5f	32	intel	blendvpd xmm2, xmmword ptr [ecx]
660f381511|223344556677885f5f5f5f	32	plan9	BLENDVPD X0, 0(CX), X2
660f381511|223344556677885f5f5f5f	64	gnu	blendvpd %xmm0,(%rcx),%xmm2
660f381511|223344556677885f5f5f5f	64	intel	blendvpd xmm2, xmmword ptr [rcx]
660f381511|223344556677885f5f5f5f	64	plan9	BLENDVPD X0, 0(CX), X2
660f381711|223344556677885f5f5f5f	32	intel	ptest xmm2, xmmword ptr [ecx]
660f381711|223344556677885f5f5f5f	32	plan9	PTEST 0(CX), X2
660f381711|223344556677885f5f5f5f	64	gnu	ptest (%rcx),%xmm2
660f381711|223344556677885f5f5f5f	64	intel	ptest xmm2, xmmword ptr [rcx]
660f381711|223344556677885f5f5f5f	64	plan9	PTEST 0(CX), X2
660f381c11|223344556677885f5f5f5f	32	intel	pabsb xmm2, xmmword ptr [ecx]
660f381c11|223344556677885f5f5f5f	32	plan9	PABSB 0(CX), X2
660f381c11|223344556677885f5f5f5f	64	gnu	pabsb (%rcx),%xmm2
660f381c11|223344556677885f5f5f5f	64	intel	pabsb xmm2, xmmword ptr [rcx]
660f381c11|223344556677885f5f5f5f	64	plan9	PABSB 0(CX), X2
660f381d11|223344556677885f5f5f5f	32	intel	pabsw xmm2, xmmword ptr [ecx]
660f381d11|223344556677885f5f5f5f	32	plan9	PABSW 0(CX), X2
660f381d11|223344556677885f5f5f5f	64	gnu	pabsw (%rcx),%xmm2
660f381d11|223344556677885f5f5f5f	64	intel	pabsw xmm2, xmmword ptr [rcx]
660f381d11|223344556677885f5f5f5f	64	plan9	PABSW 0(CX), X2
660f381e11|223344556677885f5f5f5f	32	intel	pabsd xmm2, xmmword ptr [ecx]
660f381e11|223344556677885f5f5f5f	32	plan9	PABSD 0(CX), X2
660f381e11|223344556677885f5f5f5f	64	gnu	pabsd (%rcx),%xmm2
660f381e11|223344556677885f5f5f5f	64	intel	pabsd xmm2, xmmword ptr [rcx]
660f381e11|223344556677885f5f5f5f	64	plan9	PABSD 0(CX), X2
660f382011|223344556677885f5f5f5f	32	intel	pmovsxbw xmm2, qword ptr [ecx]
660f382011|223344556677885f5f5f5f	32	plan9	PMOVSXBW 0(CX), X2
660f382011|223344556677885f5f5f5f	64	gnu	pmovsxbw (%rcx),%xmm2
660f382011|223344556677885f5f5f5f	64	intel	pmovsxbw xmm2, qword ptr [rcx]
660f382011|223344556677885f5f5f5f	64	plan9	PMOVSXBW 0(CX), X2
660f382111|223344556677885f5f5f5f	32	intel	pmovsxbd xmm2, dword ptr [ecx]
660f382111|223344556677885f5f5f5f	32	plan9	PMOVSXBD 0(CX), X2
660f382111|223344556677885f5f5f5f	64	gnu	pmovsxbd (%rcx),%xmm2
660f382111|223344556677885f5f5f5f	64	intel	pmovsxbd xmm2, dword ptr [rcx]
660f382111|223344556677885f5f5f5f	64	plan9	PMOVSXBD 0(CX), X2
660f382211|223344556677885f5f5f5f	32	intel	pmovsxbq xmm2, word ptr [ecx]
660f382211|223344556677885f5f5f5f	32	plan9	PMOVSXBQ 0(CX), X2
660f382211|223344556677885f5f5f5f	64	gnu	pmovsxbq (%rcx),%xmm2
660f382211|223344556677885f5f5f5f	64	intel	pmovsxbq xmm2, word ptr [rcx]
660f382211|223344556677885f5f5f5f	64	plan9	PMOVSXBQ 0(CX), X2
660f382311|223344556677885f5f5f5f	32	intel	pmovsxwd xmm2, qword ptr [ecx]
660f382311|223344556677885f5f5f5f	32	plan9	PMOVSXWD 0(CX), X2
660f382311|223344556677885f5f5f5f	64	gnu	pmovsxwd (%rcx),%xmm2
660f382311|223344556677885f5f5f5f	64	intel	pmovsxwd xmm2, qword ptr [rcx]
660f382311|223344556677885f5f5f5f	64	plan9	PMOVSXWD 0(CX), X2
660f382411|223344556677885f5f5f5f	32	intel	pmovsxwq xmm2, dword ptr [ecx]
660f382411|223344556677885f5f5f5f	32	plan9	PMOVSXWQ 0(CX), X2
660f382411|223344556677885f5f5f5f	64	gnu	pmovsxwq (%rcx),%xmm2
660f382411|223344556677885f5f5f5f	64	intel	pmovsxwq xmm2, dword ptr [rcx]
660f382411|223344556677885f5f5f5f	64	plan9	PMOVSXWQ 0(CX), X2
660f382511|223344556677885f5f5f5f	32	intel	pmovsxdq xmm2, qword ptr [ecx]
660f382511|223344556677885f5f5f5f	32	plan9	PMOVSXDQ 0(CX), X2
660f382511|223344556677885f5f5f5f	64	gnu	pmovsxdq (%rcx),%xmm2
660f382511|223344556677885f5f5f5f	64	intel	pmovsxdq xmm2, qword ptr [rcx]
660f382511|223344556677885f5f5f5f	64	plan9	PMOVSXDQ 0(CX), X2
660f382811|223344556677885f5f5f5f	32	intel	pmuldq xmm2, xmmword ptr [ecx]
660f382811|223344556677885f5f5f5f	32	plan9	PMULDQ 0(CX), X2
660f382811|223344556677885f5f5f5f	64	gnu	pmuldq (%rcx),%xmm2
660f382811|223344556677885f5f5f5f	64	intel	pmuldq xmm2, xmmword ptr [rcx]
660f382811|223344556677885f5f5f5f	64	plan9	PMULDQ 0(CX), X2
660f382911|223344556677885f5f5f5f	32	intel	pcmpeqq xmm2, xmmword ptr [ecx]
660f382911|223344556677885f5f5f5f	32	plan9	PCMPEQQ 0(CX), X2
660f382911|223344556677885f5f5f5f	64	gnu	pcmpeqq (%rcx),%xmm2
660f382911|223344556677885f5f5f5f	64	intel	pcmpeqq xmm2, xmmword ptr [rcx]
660f382911|223344556677885f5f5f5f	64	plan9	PCMPEQQ 0(CX), X2
660f382a11|223344556677885f5f5f5f	32	intel	movntdqa xmm2, xmmword ptr [ecx]
660f382a11|223344556677885f5f5f5f	32	plan9	MOVNTDQA 0(CX), X2
660f382a11|223344556677885f5f5f5f	64	gnu	movntdqa (%rcx),%xmm2
660f382a11|223344556677885f5f5f5f	64	intel	movntdqa xmm2, xmmword ptr [rcx]
660f382a11|223344556677885f5f5f5f	64	plan9	MOVNTDQA 0(CX), X2
660f382b11|223344556677885f5f5f5f	32	intel	packusdw xmm2, xmmword ptr [ecx]
660f382b11|223344556677885f5f5f5f	32	plan9	PACKUSDW 0(CX), X2
660f382b11|223344556677885f5f5f5f	64	gnu	packusdw (%rcx),%xmm2
660f382b11|223344556677885f5f5f5f	64	intel	packusdw xmm2, xmmword ptr [rcx]
660f382b11|223344556677885f5f5f5f	64	plan9	PACKUSDW 0(CX), X2
660f383011|223344556677885f5f5f5f	32	intel	pmovzxbw xmm2, qword ptr [ecx]
660f383011|223344556677885f5f5f5f	32	plan9	PMOVZXBW 0(CX), X2
660f383011|223344556677885f5f5f5f	64	gnu	pmovzxbw (%rcx),%xmm2
660f383011|223344556677885f5f5f5f	64	intel	pmovzxbw xmm2, qword ptr [rcx]
660f383011|223344556677885f5f5f5f	64	plan9	PMOVZXBW 0(CX), X2
660f383111|223344556677885f5f5f5f	32	intel	pmovzxbd xmm2, dword ptr [ecx]
660f383111|223344556677885f5f5f5f	32	plan9	PMOVZXBD 0(CX), X2
660f383111|223344556677885f5f5f5f	64	gnu	pmovzxbd (%rcx),%xmm2
660f383111|223344556677885f5f5f5f	64	intel	pmovzxbd xmm2, dword ptr [rcx]
660f383111|223344556677885f5f5f5f	64	plan9	PMOVZXBD 0(CX), X2
660f383211|223344556677885f5f5f5f	32	intel	pmovzxbq xmm2, word ptr [ecx]
660f383211|223344556677885f5f5f5f	32	plan9	PMOVZXBQ 0(CX), X2
660f383211|223344556677885f5f5f5f	64	gnu	pmovzxbq (%rcx),%xmm2
660f383211|223344556677885f5f5f5f	64	intel	pmovzxbq xmm2, word ptr [rcx]
660f383211|223344556677885f5f5f5f	64	plan9	PMOVZXBQ 0(CX), X2
660f383311|223344556677885f5f5f5f	32	intel	pmovzxwd xmm2, qword ptr [ecx]
660f383311|223344556677885f5f5f5f	32	plan9	PMOVZXWD 0(CX), X2
660f383311|223344556677885f5f5f5f	64	gnu	pmovzxwd (%rcx),%xmm2
660f383311|223344556677885f5f5f5f	64	intel	pmovzxwd xmm2, qword ptr [rcx]
660f383311|223344556677885f5f5f5f	64	plan9	PMOVZXWD 0(CX), X2
660f383411|223344556677885f5f5f5f	32	intel	pmovzxwq xmm2, dword ptr [ecx]
660f383411|223344556677885f5f5f5f	32	plan9	PMOVZXWQ 0(CX), X2
660f383411|223344556677885f5f5f5f	64	gnu	pmovzxwq (%rcx),%xmm2
660f383411|223344556677885f5f5f5f	64	intel	pmovzxwq xmm2, dword ptr [rcx]
660f383411|223344556677885f5f5f5f	64	plan9	PMOVZXWQ 0(CX), X2
660f383511|223344556677885f5f5f5f	32	intel	pmovzxdq xmm2, qword ptr [ecx]
660f383511|223344556677885f5f5f5f	32	plan9	PMOVZXDQ 0(CX), X2
660f383511|223344556677885f5f5f5f	64	gnu	pmovzxdq (%rcx),%xmm2
660f383511|223344556677885f5f5f5f	64	intel	pmovzxdq xmm2, qword ptr [rcx]
660f383511|223344556677885f5f5f5f	64	plan9	PMOVZXDQ 0(CX), X2
660f383711|223344556677885f5f5f5f	32	intel	pcmpgtq xmm2, xmmword ptr [ecx]
660f383711|223344556677885f5f5f5f	32	plan9	PCMPGTQ 0(CX), X2
660f383711|223344556677885f5f5f5f	64	gnu	pcmpgtq (%rcx),%xmm2
660f383711|223344556677885f5f5f5f	64	intel	pcmpgtq xmm2, xmmword ptr [rcx]
660f383711|223344556677885f5f5f5f	64	plan9	PCMPGTQ 0(CX), X2
660f383811|223344556677885f5f5f5f	32	intel	pminsb xmm2, xmmword ptr [ecx]
660f383811|223344556677885f5f5f5f	32	plan9	PMINSB 0(CX), X2
660f383811|223344556677885f5f5f5f	64	gnu	pminsb (%rcx),%xmm2
660f383811|223344556677885f5f5f5f	64	intel	pminsb xmm2, xmmword ptr [rcx]
660f383811|223344556677885f5f5f5f	64	plan9	PMINSB 0(CX), X2
660f383911|223344556677885f5f5f5f	32	intel	pminsd xmm2, xmmword ptr [ecx]
660f383911|223344556677885f5f5f5f	32	plan9	PMINSD 0(CX), X2
660f383911|223344556677885f5f5f5f	64	gnu	pminsd (%rcx),%xmm2
660f383911|223344556677885f5f5f5f	64	intel	pminsd xmm2, xmmword ptr [rcx]
660f383911|223344556677885f5f5f5f	64	plan9	PMINSD 0(CX), X2
660f383a11|223344556677885f5f5f5f	32	intel	pminuw xmm2, xmmword ptr [ecx]
660f383a11|223344556677885f5f5f5f	32	plan9	PMINUW 0(CX), X2
660f383a11|223344556677885f5f5f5f	64	gnu	pminuw (%rcx),%xmm2
660f383a11|223344556677885f5f5f5f	64	intel	pminuw xmm2, xmmword ptr [rcx]
660f383a11|223344556677885f5f5f5f	64	plan9	PMINUW 0(CX), X2
660f383b11|223344556677885f5f5f5f	32	intel	pminud xmm2, xmmword ptr [ecx]
660f383b11|223344556677885f5f5f5f	32	plan9	PMINUD 0(CX), X2
660f383b11|223344556677885f5f5f5f	64	gnu	pminud (%rcx),%xmm2
660f383b11|223344556677885f5f5f5f	64	intel	pminud xmm2, xmmword ptr [rcx]
660f383b11|223344556677885f5f5f5f	64	plan9	PMINUD 0(CX), X2
660f383c11|223344556677885f5f5f5f	32	intel	pmaxsb xmm2, xmmword ptr [ecx]
660f383c11|223344556677885f5f5f5f	32	plan9	PMAXSB 0(CX), X2
660f383c11|223344556677885f5f5f5f	64	gnu	pmaxsb (%rcx),%xmm2
660f383c11|223344556677885f5f5f5f	64	intel	pmaxsb xmm2, xmmword ptr [rcx]
660f383c11|223344556677885f5f5f5f	64	plan9	PMAXSB 0(CX), X2
660f383d11|223344556677885f5f5f5f	32	intel	pmaxsd xmm2, xmmword ptr [ecx]
660f383d11|223344556677885f5f5f5f	32	plan9	PMAXSD 0(CX), X2
660f383d11|223344556677885f5f5f5f	64	gnu	pmaxsd (%rcx),%xmm2
660f383d11|223344556677885f5f5f5f	64	intel	pmaxsd xmm2, xmmword ptr [rcx]
660f383d11|223344556677885f5f5f5f	64	plan9	PMAXSD 0(CX), X2
660f383e11|223344556677885f5f5f5f	32	intel	pmaxuw xmm2, xmmword ptr [ecx]
660f383e11|223344556677885f5f5f5f	32	plan9	PMAXUW 0(CX), X2
660f383e11|223344556677885f5f5f5f	64	gnu	pmaxuw (%rcx),%xmm2
660f383e11|223344556677885f5f5f5f	64	intel	pmaxuw xmm2, xmmword ptr [rcx]
660f383e11|223344556677885f5f5f5f	64	plan9	PMAXUW 0(CX), X2
660f383f11|223344556677885f5f5f5f	32	intel	pmaxud xmm2, xmmword ptr [ecx]
660f383f11|223344556677885f5f5f5f	32	plan9	PMAXUD 0(CX), X2
660f383f11|223344556677885f5f5f5f	64	gnu	pmaxud (%rcx),%xmm2
660f383f11|223344556677885f5f5f5f	64	intel	pmaxud xmm2, xmmword ptr [rcx]
660f383f11|223344556677885f5f5f5f	64	plan9	PMAXUD 0(CX), X2
660f384011|223344556677885f5f5f5f	32	intel	pmulld xmm2, xmmword ptr [ecx]
660f384011|223344556677885f5f5f5f	32	plan9	PMULLD 0(CX), X2
660f384011|223344556677885f5f5f5f	64	gnu	pmulld (%rcx),%xmm2
660f384011|223344556677885f5f5f5f	64	intel	pmulld xmm2, xmmword ptr [rcx]
660f384011|223344556677885f5f5f5f	64	plan9	PMULLD 0(CX), X2
660f384111|223344556677885f5f5f5f	32	intel	phminposuw xmm2, xmmword ptr [ecx]
660f384111|223344556677885f5f5f5f	32	plan9	PHMINPOSUW 0(CX), X2
660f384111|223344556677885f5f5f5f	64	gnu	phminposuw (%rcx),%xmm2
660f384111|223344556677885f5f5f5f	64	intel	phminposuw xmm2, xmmword ptr [rcx]
660f384111|223344556677885f5f5f5f	64	plan9	PHMINPOSUW 0(CX), X2
660f388211|223344556677885f5f5f5f	32	intel	invpcid edx, xmmword ptr [ecx]
660f388211|223344556677885f5f5f5f	32	plan9	INVPCID 0(CX), DX
660f388211|223344556677885f5f5f5f	64	gnu	invpcid (%rcx),%rdx
660f388211|223344556677885f5f5f5f	64	intel	invpcid rdx, xmmword ptr [rcx]
660f388211|223344556677885f5f5f5f	64	plan9	INVPCID 0(CX), DX
660f38db11|223344556677885f5f5f5f	32	intel	aesimc xmm2, xmmword ptr [ecx]
660f38db11|223344556677885f5f5f5f	32	plan9	AESIMC 0(CX), X2
660f38db11|223344556677885f5f5f5f	64	gnu	aesimc (%rcx),%xmm2
660f38db11|223344556677885f5f5f5f	64	intel	aesimc xmm2, xmmword ptr [rcx]
660f38db11|223344556677885f5f5f5f	64	plan9	AESIMC 0(CX), X2
660f38dc11|223344556677885f5f5f5f	32	intel	aesenc xmm2, xmmword ptr [ecx]
660f38dc11|223344556677885f5f5f5f	32	plan9	AESENC 0(CX), X2
660f38dc11|223344556677885f5f5f5f	64	gnu	aesenc (%rcx),%xmm2
660f38dc11|223344556677885f5f5f5f	64	intel	aesenc xmm2, xmmword ptr [rcx]
660f38dc11|223344556677885f5f5f5f	64	plan9	AESENC 0(CX), X2
660f38dd11|223344556677885f5f5f5f	32	intel	aesenclast xmm2, xmmword ptr [ecx]
660f38dd11|223344556677885f5f5f5f	32	plan9	AESENCLAST 0(CX), X2
660f38dd11|223344556677885f5f5f5f	64	gnu	aesenclast (%rcx),%xmm2
660f38dd11|223344556677885f5f5f5f	64	intel	aesenclast xmm2, xmmword ptr [rcx]
660f38dd11|223344556677885f5f5f5f	64	plan9	AESENCLAST 0(CX), X2
660f38de11|223344556677885f5f5f5f	32	intel	aesdec xmm2, xmmword ptr [ecx]
660f38de11|223344556677885f5f5f5f	32	plan9	AESDEC 0(CX), X2
660f38de11|223344556677885f5f5f5f	64	gnu	aesdec (%rcx),%xmm2
660f38de11|223344556677885f5f5f5f	64	intel	aesdec xmm2, xmmword ptr [rcx]
660f38de11|223344556677885f5f5f5f	64	plan9	AESDEC 0(CX), X2
660f38df11|223344556677885f5f5f5f	32	intel	aesdeclast xmm2, xmmword ptr [ecx]
660f38df11|223344556677885f5f5f5f	32	plan9	AESDECLAST 0(CX), X2
660f38df11|223344556677885f5f5f5f	64	gnu	aesdeclast (%rcx),%xmm2
660f38df11|223344556677885f5f5f5f	64	intel	aesdeclast xmm2, xmmword ptr [rcx]
660f38df11|223344556677885f5f5f5f	64	plan9	AESDECLAST 0(CX), X2
660f3a081122|3344556677885f5f5f5f	32	intel	roundps xmm2, xmmword ptr [ecx], 0x22
660f3a081122|3344556677885f5f5f5f	32	plan9	ROUNDPS $0x22, 0(CX), X2
660f3a081122|3344556677885f5f5f5f	64	gnu	roundps $0x22,(%rcx),%xmm2
660f3a081122|3344556677885f5f5f5f	64	intel	roundps xmm2, xmmword ptr [rcx], 0x22
660f3a081122|3344556677885f5f5f5f	64	plan9	ROUNDPS $0x22, 0(CX), X2
660f3a091122|3344556677885f5f5f5f	32	intel	roundpd xmm2, xmmword ptr [ecx], 0x22
660f3a091122|3344556677885f5f5f5f	32	plan9	ROUNDPD $0x22, 0(CX), X2
660f3a091122|3344556677885f5f5f5f	64	gnu	roundpd $0x22,(%rcx),%xmm2
660f3a091122|3344556677885f5f5f5f	64	intel	roundpd xmm2, xmmword ptr [rcx], 0x22
660f3a091122|3344556677885f5f5f5f	64	plan9	ROUNDPD $0x22, 0(CX), X2
660f3a0a1122|3344556677885f5f5f5f	32	intel	roundss xmm2, dword ptr [ecx], 0x22
660f3a0a1122|3344556677885f5f5f5f	32	plan9	ROUNDSS $0x22, 0(CX), X2
660f3a0a1122|3344556677885f5f5f5f	64	gnu	roundss $0x22,(%rcx),%xmm2
660f3a0a1122|3344556677885f5f5f5f	64	intel	roundss xmm2, dword ptr [rcx], 0x22
660f3a0a1122|3344556677885f5f5f5f	64	plan9	ROUNDSS $0x22, 0(CX), X2
660f3a0b1122|3344556677885f5f5f5f	32	intel	roundsd xmm2, qword ptr [ecx], 0x22
660f3a0b1122|3344556677885f5f5f5f	32	plan9	ROUNDSD $0x22, 0(CX), X2
660f3a0b1122|3344556677885f5f5f5f	64	gnu	roundsd $0x22,(%rcx),%xmm2
660f3a0b1122|3344556677885f5f5f5f	64	intel	roundsd xmm2, qword ptr [rcx], 0x22
660f3a0b1122|3344556677885f5f5f5f	64	plan9	ROUNDSD $0x22, 0(CX), X2
660f3a0c1122|3344556677885f5f5f5f	32	intel	blendps xmm2, xmmword ptr [ecx], 0x22
660f3a0c1122|3344556677885f5f5f5f	32	plan9	BLENDPS $0x22, 0(CX), X2
660f3a0c1122|3344556677885f5f5f5f	64	gnu	blendps $0x22,(%rcx),%xmm2
660f3a0c1122|3344556677885f5f5f5f	64	intel	blendps xmm2, xmmword ptr [rcx], 0x22
660f3a0c1122|3344556677885f5f5f5f	64	plan9	BLENDPS $0x22, 0(CX), X2
660f3a0d1122|3344556677885f5f5f5f	32	intel	blendpd xmm2, xmmword ptr [ecx], 0x22
660f3a0d1122|3344556677885f5f5f5f	32	plan9	BLENDPD $0x22, 0(CX), X2
660f3a0d1122|3344556677885f5f5f5f	64	gnu	blendpd $0x22,(%rcx),%xmm2
660f3a0d1122|3344556677885f5f5f5f	64	intel	blendpd xmm2, xmmword ptr [rcx], 0x22
660f3a0d1122|3344556677885f5f5f5f	64	plan9	BLENDPD $0x22, 0(CX), X2
660f3a0e1122|3344556677885f5f5f5f	32	intel	pblendw xmm2, xmmword ptr [ecx], 0x22
660f3a0e1122|3344556677885f5f5f5f	32	plan9	PBLENDW $0x22, 0(CX), X2
660f3a0e1122|3344556677885f5f5f5f	64	gnu	pblendw $0x22,(%rcx),%xmm2
660f3a0e1122|3344556677885f5f5f5f	64	intel	pblendw xmm2, xmmword ptr [rcx], 0x22
660f3a0e1122|3344556677885f5f5f5f	64	plan9	PBLENDW $0x22, 0(CX), X2
660f3a0f1122|3344556677885f5f5f5f	32	intel	palignr xmm2, xmmword ptr [ecx], 0x22
660f3a0f1122|3344556677885f5f5f5f	32	plan9	PALIGNR $0x22, 0(CX), X2
660f3a0f1122|3344556677885f5f5f5f	64	gnu	palignr $0x22,(%rcx),%xmm2
660f3a0f1122|3344556677885f5f5f5f	64	intel	palignr xmm2, xmmword ptr [rcx], 0x22
660f3a0f1122|3344556677885f5f5f5f	64	plan9	PALIGNR $0x22, 0(CX), X2
660f3a141122|3344556677885f5f5f5f	32	intel	pextrb byte ptr [ecx], xmm2, 0x22
660f3a141122|3344556677885f5f5f5f	32	plan9	PEXTRB $0x22, X2, 0(CX)
660f3a141122|3344556677885f5f5f5f	64	gnu	pextrb $0x22,%xmm2,(%rcx)
660f3a141122|3344556677885f5f5f5f	64	intel	pextrb byte ptr [rcx], xmm2, 0x22
660f3a141122|3344556677885f5f5f5f	64	plan9	PEXTRB $0x22, X2, 0(CX)
660f3a151122|3344556677885f5f5f5f	32	intel	pextrw word ptr [ecx], xmm2, 0x22
660f3a151122|3344556677885f5f5f5f	32	plan9	PEXTRW $0x22, X2, 0(CX)
660f3a151122|3344556677885f5f5f5f	64	gnu	pextrw $0x22,%xmm2,(%rcx)
660f3a151122|3344556677885f5f5f5f	64	intel	pextrw word ptr [rcx], xmm2, 0x22
660f3a151122|3344556677885f5f5f5f	64	plan9	PEXTRW $0x22, X2, 0(CX)
660f3a161122|3344556677885f5f5f5f	32	intel	pextrd dword ptr [ecx], xmm2, 0x22
660f3a161122|3344556677885f5f5f5f	32	plan9	PEXTRD $0x22, X2, 0(CX)
660f3a161122|3344556677885f5f5f5f	64	gnu	pextrd $0x22,%xmm2,(%rcx)
660f3a161122|3344556677885f5f5f5f	64	intel	pextrd dword ptr [rcx], xmm2, 0x22
660f3a161122|3344556677885f5f5f5f	64	plan9	PEXTRD $0x22, X2, 0(CX)
660f3a171122|3344556677885f5f5f5f	32	intel	extractps dword ptr [ecx], xmm2, 0x22
660f3a171122|3344556677885f5f5f5f	32	plan9	EXTRACTPS $0x22, X2, 0(CX)
660f3a171122|3344556677885f5f5f5f	64	gnu	extractps $0x22,%xmm2,(%rcx)
660f3a171122|3344556677885f5f5f5f	64	intel	extractps dword ptr [rcx], xmm2, 0x22
660f3a171122|3344556677885f5f5f5f	64	plan9	EXTRACTPS $0x22, X2, 0(CX)
660f3a201122|3344556677885f5f5f5f	32	intel	pinsrb xmm2, byte ptr [ecx], 0x22
660f3a201122|3344556677885f5f5f5f	32	plan9	PINSRB $0x22, 0(CX), X2
660f3a201122|3344556677885f5f5f5f	64	gnu	pinsrb $0x22,(%rcx),%xmm2
660f3a201122|3344556677885f5f5f5f	64	intel	pinsrb xmm2, byte ptr [rcx], 0x22
660f3a201122|3344556677885f5f5f5f	64	plan9	PINSRB $0x22, 0(CX), X2
660f3a211122|3344556677885f5f5f5f	32	intel	insertps xmm2, dword ptr [ecx], 0x22
660f3a211122|3344556677885f5f5f5f	32	plan9	INSERTPS $0x22, 0(CX), X2
660f3a211122|3344556677885f5f5f5f	64	gnu	insertps $0x22,(%rcx),%xmm2
660f3a211122|3344556677885f5f5f5f	64	intel	insertps xmm2, dword ptr [rcx], 0x22
660f3a211122|3344556677885f5f5f5f	64	plan9	INSERTPS $0x22, 0(CX), X2
660f3a221122|3344556677885f5f5f5f	32	intel	pinsrd xmm2, dword ptr [ecx], 0x22
660f3a221122|3344556677885f5f5f5f	32	plan9	PINSRD $0x22, 0(CX), X2
660f3a221122|3344556677885f5f5f5f	64	gnu	pinsrd $0x22,(%rcx),%xmm2
660f3a221122|3344556677885f5f5f5f	64	intel	pinsrd xmm2, dword ptr [rcx], 0x22
660f3a221122|3344556677885f5f5f5f	64	plan9	PINSRD $0x22, 0(CX), X2
660f3a401122|3344556677885f5f5f5f	32	intel	dpps xmm2, xmmword ptr [ecx], 0x22
660f3a401122|3344556677885f5f5f5f	32	plan9	DPPS $0x22, 0(CX), X2
660f3a401122|3344556677885f5f5f5f	64	gnu	dpps $0x22,(%rcx),%xmm2
660f3a401122|3344556677885f5f5f5f	64	intel	dpps xmm2, xmmword ptr [rcx], 0x22
660f3a401122|3344556677885f5f5f5f	64	plan9	DPPS $0x22, 0(CX), X2
660f3a411122|3344556677885f5f5f5f	32	intel	dppd xmm2, xmmword ptr [ecx], 0x22
660f3a411122|3344556677885f5f5f5f	32	plan9	DPPD $0x22, 0(CX), X2
660f3a411122|3344556677885f5f5f5f	64	gnu	dppd $0x22,(%rcx),%xmm2
660f3a411122|3344556677885f5f5f5f	64	intel	dppd xmm2, xmmword ptr [rcx], 0x22
660f3a411122|3344556677885f5f5f5f	64	plan9	DPPD $0x22, 0(CX), X2
660f3a421122|3344556677885f5f5f5f	32	intel	mpsadbw xmm2, xmmword ptr [ecx], 0x22
660f3a421122|3344556677885f5f5f5f	32	plan9	MPSADBW $0x22, 0(CX), X2
660f3a421122|3344556677885f5f5f5f	64	gnu	mpsadbw $0x22,(%rcx),%xmm2
660f3a421122|3344556677885f5f5f5f	64	intel	mpsadbw xmm2, xmmword ptr [rcx], 0x22
660f3a421122|3344556677885f5f5f5f	64	plan9	MPSADBW $0x22, 0(CX), X2
660f3a441122|3344556677885f5f5f5f	32	intel	pclmulqdq xmm2, xmmword ptr [ecx], 0x22
660f3a441122|3344556677885f5f5f5f	32	plan9	PCLMULQDQ $0x22, 0(CX), X2
660f3a441122|3344556677885f5f5f5f	64	gnu	pclmulqdq $0x22,(%rcx),%xmm2
660f3a441122|3344556677885f5f5f5f	64	intel	pclmulqdq xmm2, xmmword ptr [rcx], 0x22
660f3a441122|3344556677885f5f5f5f	64	plan9	PCLMULQDQ $0x22, 0(CX), X2
660f3a601122|3344556677885f5f5f5f	32	intel	pcmpestrm xmm2, xmmword ptr [ecx], 0x22
660f3a601122|3344556677885f5f5f5f	32	plan9	PCMPESTRM $0x22, 0(CX), X2
660f3a601122|3344556677885f5f5f5f	64	gnu	pcmpestrm $0x22,(%rcx),%xmm2
660f3a601122|3344556677885f5f5f5f	64	intel	pcmpestrm xmm2, xmmword ptr [rcx], 0x22
660f3a601122|3344556677885f5f5f5f	64	plan9	PCMPESTRM $0x22, 0(CX), X2
660f3a611122|3344556677885f5f5f5f	32	intel	pcmpestri xmm2, xmmword ptr [ecx], 0x22
660f3a611122|3344556677885f5f5f5f	32	plan9	PCMPESTRI $0x22, 0(CX), X2
660f3a611122|3344556677885f5f5f5f	64	gnu	pcmpestri $0x22,(%rcx),%xmm2
660f3a611122|3344556677885f5f5f5f	64	intel	pcmpestri xmm2, xmmword ptr [rcx], 0x22
660f3a611122|3344556677885f5f5f5f	64	plan9	PCMPESTRI $0x22, 0(CX), X2
660f3a621122|3344556677885f5f5f5f	32	intel	pcmpistrm xmm2, xmmword ptr [ecx], 0x22
660f3a621122|3344556677885f5f5f5f	32	plan9	PCMPISTRM $0x22, 0(CX), X2
660f3a621122|3344556677885f5f5f5f	64	gnu	pcmpistrm $0x22,(%rcx),%xmm2
660f3a621122|3344556677885f5f5f5f	64	intel	pcmpistrm xmm2, xmmword ptr [rcx], 0x22
660f3a621122|3344556677885f5f5f5f	64	plan9	PCMPISTRM $0x22, 0(CX), X2
660f3a631122|3344556677885f5f5f5f	32	intel	pcmpistri xmm2, xmmword ptr [ecx], 0x22
660f3a631122|3344556677885f5f5f5f	32	plan9	PCMPISTRI $0x22, 0(CX), X2
660f3a631122|3344556677885f5f5f5f	64	gnu	pcmpistri $0x22,(%rcx),%xmm2
660f3a631122|3344556677885f5f5f5f	64	intel	pcmpistri xmm2, xmmword ptr [rcx], 0x22
660f3a631122|3344556677885f5f5f5f	64	plan9	PCMPISTRI $0x22, 0(CX), X2
660f3adf1122|3344556677885f5f5f5f	32	intel	aeskeygenassist xmm2, xmmword ptr [ecx], 0x22
660f3adf1122|3344556677885f5f5f5f	32	plan9	AESKEYGENASSIST $0x22, 0(CX), X2
660f3adf1122|3344556677885f5f5f5f	64	gnu	aeskeygenassist $0x22,(%rcx),%xmm2
660f3adf1122|3344556677885f5f5f5f	64	intel	aeskeygenassist xmm2, xmmword ptr [rcx], 0x22
660f3adf1122|3344556677885f5f5f5f	64	plan9	AESKEYGENASSIST $0x22, 0(CX), X2
660f4011|223344556677885f5f5f5f5f	32	intel	cmovo dx, word ptr [ecx]
660f4011|223344556677885f5f5f5f5f	32	plan9	CMOVO 0(CX), DX
660f4011|223344556677885f5f5f5f5f	64	gnu	cmovo (%rcx),%dx
660f4011|223344556677885f5f5f5f5f	64	intel	cmovo dx, word ptr [rcx]
660f4011|223344556677885f5f5f5f5f	64	plan9	CMOVO 0(CX), DX
660f4111|223344556677885f5f5f5f5f	32	intel	cmovno dx, word ptr [ecx]
660f4111|223344556677885f5f5f5f5f	32	plan9	CMOVNO 0(CX), DX
660f4111|223344556677885f5f5f5f5f	64	gnu	cmovno (%rcx),%dx
660f4111|223344556677885f5f5f5f5f	64	intel	cmovno dx, word ptr [rcx]
660f4111|223344556677885f5f5f5f5f	64	plan9	CMOVNO 0(CX), DX
660f4211|223344556677885f5f5f5f5f	32	intel	cmovb dx, word ptr [ecx]
660f4211|223344556677885f5f5f5f5f	32	plan9	CMOVB 0(CX), DX
660f4211|223344556677885f5f5f5f5f	64	gnu	cmovb (%rcx),%dx
660f4211|223344556677885f5f5f5f5f	64	intel	cmovb dx, word ptr [rcx]
660f4211|223344556677885f5f5f5f5f	64	plan9	CMOVB 0(CX), DX
660f4311|223344556677885f5f5f5f5f	32	intel	cmovnb dx, word ptr [ecx]
660f4311|223344556677885f5f5f5f5f	32	plan9	CMOVAE 0(CX), DX
660f4311|223344556677885f5f5f5f5f	64	gnu	cmovae (%rcx),%dx
660f4311|223344556677885f5f5f5f5f	64	intel	cmovnb dx, word ptr [rcx]
660f4311|223344556677885f5f5f5f5f	64	plan9	CMOVAE 0(CX), DX
660f4411|223344556677885f5f5f5f5f	32	intel	cmovz dx, word ptr [ecx]
660f4411|223344556677885f5f5f5f5f	32	plan9	CMOVE 0(CX), DX
660f4411|223344556677885f5f5f5f5f	64	gnu	cmove (%rcx),%dx
660f4411|223344556677885f5f5f5f5f	64	intel	cmovz dx, word ptr [rcx]
660f4411|223344556677885f5f5f5f5f	64	plan9	CMOVE 0(CX), DX
660f4511|223344556677885f5f5f5f5f	32	intel	cmovnz dx, word ptr [ecx]
660f4511|223344556677885f5f5f5f5f	32	plan9	CMOVNE 0(CX), DX
660f4511|223344556677885f5f5f5f5f	64	gnu	cmovne (%rcx),%dx
660f4511|223344556677885f5f5f5f5f	64	intel	cmovnz dx, word ptr [rcx]
660f4511|223344556677885f5f5f5f5f	64	plan9	CMOVNE 0(CX), DX
660f4611|223344556677885f5f5f5f5f	32	intel	cmovbe dx, word ptr [ecx]
660f4611|223344556677885f5f5f5f5f	32	plan9	CMOVBE 0(CX), DX
660f4611|223344556677885f5f5f5f5f	64	gnu	cmovbe (%rcx),%dx
660f4611|223344556677885f5f5f5f5f	64	intel	cmovbe dx, word ptr [rcx]
660f4611|223344556677885f5f5f5f5f	64	plan9	CMOVBE 0(CX), DX
660f4711|223344556677885f5f5f5f5f	32	intel	cmovnbe dx, word ptr [ecx]
660f4711|223344556677885f5f5f5f5f	32	plan9	CMOVA 0(CX), DX
660f4711|223344556677885f5f5f5f5f	64	gnu	cmova (%rcx),%dx
660f4711|223344556677885f5f5f5f5f	64	intel	cmovnbe dx, word ptr [rcx]
660f4711|223344556677885f5f5f5f5f	64	plan9	CMOVA 0(CX), DX
660f4811|223344556677885f5f5f5f5f	32	intel	cmovs dx, word ptr [ecx]
660f4811|223344556677885f5f5f5f5f	32	plan9	CMOVS 0(CX), DX
660f4811|223344556677885f5f5f5f5f	64	gnu	cmovs (%rcx),%dx
660f4811|223344556677885f5f5f5f5f	64	intel	cmovs dx, word ptr [rcx]
660f4811|223344556677885f5f5f5f5f	64	plan9	CMOVS 0(CX), DX
660f4911|223344556677885f5f5f5f5f	32	intel	cmovns dx, word ptr [ecx]
660f4911|223344556677885f5f5f5f5f	32	plan9	CMOVNS 0(CX), DX
660f4911|223344556677885f5f5f5f5f	64	gnu	cmovns (%rcx),%dx
660f4911|223344556677885f5f5f5f5f	64	intel	cmovns dx, word ptr [rcx]
660f4911|223344556677885f5f5f5f5f	64	plan9	CMOVNS 0(CX), DX
660f4a11|223344556677885f5f5f5f5f	32	intel	cmovp dx, word ptr [ecx]
660f4a11|223344556677885f5f5f5f5f	32	plan9	CMOVP 0(CX), DX
660f4a11|223344556677885f5f5f5f5f	64	gnu	cmovp (%rcx),%dx
660f4a11|223344556677885f5f5f5f5f	64	intel	cmovp dx, word ptr [rcx]
660f4a11|223344556677885f5f5f5f5f	64	plan9	CMOVP 0(CX), DX
660f4b11|223344556677885f5f5f5f5f	32	intel	cmovnp dx, word ptr [ecx]
660f4b11|223344556677885f5f5f5f5f	32	plan9	CMOVNP 0(CX), DX
660f4b11|223344556677885f5f5f5f5f	64	gnu	cmovnp (%rcx),%dx
660f4b11|223344556677885f5f5f5f5f	64	intel	cmovnp dx, word ptr [rcx]
660f4b11|223344556677885f5f5f5f5f	64	plan9	CMOVNP 0(CX), DX
660f4c11|223344556677885f5f5f5f5f	32	intel	cmovl dx, word ptr [ecx]
660f4c11|223344556677885f5f5f5f5f	32	plan9	CMOVL 0(CX), DX
660f4c11|223344556677885f5f5f5f5f	64	gnu	cmovl (%rcx),%dx
660f4c11|223344556677885f5f5f5f5f	64	intel	cmovl dx, word ptr [rcx]
660f4c11|223344556677885f5f5f5f5f	64	plan9	CMOVL 0(CX), DX
660f4d11|223344556677885f5f5f5f5f	32	intel	cmovnl dx, word ptr [ecx]
660f4d11|223344556677885f5f5f5f5f	32	plan9	CMOVGE 0(CX), DX
660f4d11|223344556677885f5f5f5f5f	64	gnu	cmovge (%rcx),%dx
660f4d11|223344556677885f5f5f5f5f	64	intel	cmovnl dx, word ptr [rcx]
660f4d11|223344556677885f5f5f5f5f	64	plan9	CMOVGE 0(CX), DX
660f4e11|223344556677885f5f5f5f5f	32	intel	cmovle dx, word ptr [ecx]
660f4e11|223344556677885f5f5f5f5f	32	plan9	CMOVLE 0(CX), DX
660f4e11|223344556677885f5f5f5f5f	64	gnu	cmovle (%rcx),%dx
660f4e11|223344556677885f5f5f5f5f	64	intel	cmovle dx, word ptr [rcx]
660f4e11|223344556677885f5f5f5f5f	64	plan9	CMOVLE 0(CX), DX
660f4f11|223344556677885f5f5f5f5f	32	intel	cmovnle dx, word ptr [ecx]
660f4f11|223344556677885f5f5f5f5f	32	plan9	CMOVG 0(CX), DX
660f4f11|223344556677885f5f5f5f5f	64	gnu	cmovg (%rcx),%dx
660f4f11|223344556677885f5f5f5f5f	64	intel	cmovnle dx, word ptr [rcx]
660f4f11|223344556677885f5f5f5f5f	64	plan9	CMOVG 0(CX), DX
660f50c0|11223344556677885f5f5f5f	32	intel	movmskpd eax, xmm0
660f50c0|11223344556677885f5f5f5f	32	plan9	MOVMSKPD X0, AX
660f50c0|11223344556677885f5f5f5f	64	gnu	movmskpd %xmm0,%eax
660f50c0|11223344556677885f5f5f5f	64	intel	movmskpd eax, xmm0
660f50c0|11223344556677885f5f5f5f	64	plan9	MOVMSKPD X0, AX
660f5111|223344556677885f5f5f5f5f	32	intel	sqrtpd xmm2, xmmword ptr [ecx]
660f5111|223344556677885f5f5f5f5f	32	plan9	SQRTPD 0(CX), X2
660f5111|223344556677885f5f5f5f5f	64	gnu	sqrtpd (%rcx),%xmm2
660f5111|223344556677885f5f5f5f5f	64	intel	sqrtpd xmm2, xmmword ptr [rcx]
660f5111|223344556677885f5f5f5f5f	64	plan9	SQRTPD 0(CX), X2
660f5411|223344556677885f5f5f5f5f	32	intel	andpd xmm2, xmmword ptr [ecx]
660f5411|223344556677885f5f5f5f5f	32	plan9	ANDPD 0(CX), X2
660f5411|223344556677885f5f5f5f5f	64	gnu	andpd (%rcx),%xmm2
660f5411|223344556677885f5f5f5f5f	64	intel	andpd xmm2, xmmword ptr [rcx]
660f5411|223344556677885f5f5f5f5f	64	plan9	ANDPD 0(CX), X2
660f5511|223344556677885f5f5f5f5f	32	intel	andnpd xmm2, xmmword ptr [ecx]
660f5511|223344556677885f5f5f5f5f	32	plan9	ANDNPD 0(CX), X2
660f5511|223344556677885f5f5f5f5f	64	gnu	andnpd (%rcx),%xmm2
660f5511|223344556677885f5f5f5f5f	64	intel	andnpd xmm2, xmmword ptr [rcx]
660f5511|223344556677885f5f5f5f5f	64	plan9	ANDNPD 0(CX), X2
660f5611|223344556677885f5f5f5f5f	32	intel	orpd xmm2, xmmword ptr [ecx]
660f5611|223344556677885f5f5f5f5f	32	plan9	ORPD 0(CX), X2
660f5611|223344556677885f5f5f5f5f	64	gnu	orpd (%rcx),%xmm2
660f5611|223344556677885f5f5f5f5f	64	intel	orpd xmm2, xmmword ptr [rcx]
660f5611|223344556677885f5f5f5f5f	64	plan9	ORPD 0(CX), X2
660f5711|223344556677885f5f5f5f5f	32	intel	xorpd xmm2, xmmword ptr [ecx]
660f5711|223344556677885f5f5f5f5f	32	plan9	XORPD 0(CX), X2
660f5711|223344556677885f5f5f5f5f	64	gnu	xorpd (%rcx),%xmm2
660f5711|223344556677885f5f5f5f5f	64	intel	xorpd xmm2, xmmword ptr [rcx]
660f5711|223344556677885f5f5f5f5f	64	plan9	XORPD 0(CX), X2
660f5811|223344556677885f5f5f5f5f	32	intel	addpd xmm2, xmmword ptr [ecx]
660f5811|223344556677885f5f5f5f5f	32	plan9	ADDPD 0(CX), X2
660f5811|223344556677885f5f5f5f5f	64	gnu	addpd (%rcx),%xmm2
660f5811|223344556677885f5f5f5f5f	64	intel	addpd xmm2, xmmword ptr [rcx]
660f5811|223344556677885f5f5f5f5f	64	plan9	ADDPD 0(CX), X2
660f5911|223344556677885f5f5f5f5f	32	intel	mulpd xmm2, xmmword ptr [ecx]
660f5911|223344556677885f5f5f5f5f	32	plan9	MULPD 0(CX), X2
660f5911|223344556677885f5f5f5f5f	64	gnu	mulpd (%rcx),%xmm2
660f5911|223344556677885f5f5f5f5f	64	intel	mulpd xmm2, xmmword ptr [rcx]
660f5911|223344556677885f5f5f5f5f	64	plan9	MULPD 0(CX), X2
660f5a11|223344556677885f5f5f5f5f	32	intel	cvtpd2ps xmm2, xmmword ptr [ecx]
660f5a11|223344556677885f5f5f5f5f	32	plan9	CVTPD2PS 0(CX), X2
660f5a11|223344556677885f5f5f5f5f	64	gnu	cvtpd2ps (%rcx),%xmm2
660f5a11|223344556677885f5f5f5f5f	64	intel	cvtpd2ps xmm2, xmmword ptr [rcx]
660f5a11|223344556677885f5f5f5f5f	64	plan9	CVTPD2PS 0(CX), X2
660f5b11|223344556677885f5f5f5f5f	32	intel	cvtps2dq xmm2, xmmword ptr [ecx]
660f5b11|223344556677885f5f5f5f5f	32	plan9	CVTPS2DQ 0(CX), X2
660f5b11|223344556677885f5f5f5f5f	64	gnu	cvtps2dq (%rcx),%xmm2
660f5b11|223344556677885f5f5f5f5f	64	intel	cvtps2dq xmm2, xmmword ptr [rcx]
660f5b11|223344556677885f5f5f5f5f	64	plan9	CVTPS2DQ 0(CX), X2
660f5c11|223344556677885f5f5f5f5f	32	intel	subpd xmm2, xmmword ptr [ecx]
660f5c11|223344556677885f5f5f5f5f	32	plan9	SUBPD 0(CX), X2
660f5c11|223344556677885f5f5f5f5f	64	gnu	subpd (%rcx),%xmm2
660f5c11|223344556677885f5f5f5f5f	64	intel	subpd xmm2, xmmword ptr [rcx]
660f5c11|223344556677885f5f5f5f5f	64	plan9	SUBPD 0(CX), X2
660f5d11|223344556677885f5f5f5f5f	32	intel	minpd xmm2, xmmword ptr [ecx]
660f5d11|223344556677885f5f5f5f5f	32	plan9	MINPD 0(CX), X2
660f5d11|223344556677885f5f5f5f5f	64	gnu	minpd (%rcx),%xmm2
660f5d11|223344556677885f5f5f5f5f	64	intel	minpd xmm2, xmmword ptr [rcx]
660f5d11|223344556677885f5f5f5f5f	64	plan9	MINPD 0(CX), X2
660f5e11|223344556677885f5f5f5f5f	32	intel	divpd xmm2, xmmword ptr [ecx]
660f5e11|223344556677885f5f5f5f5f	32	plan9	DIVPD 0(CX), X2
660f5e11|223344556677885f5f5f5f5f	64	gnu	divpd (%rcx),%xmm2
660f5e11|223344556677885f5f5f5f5f	64	intel	divpd xmm2, xmmword ptr [rcx]
660f5e11|223344556677885f5f5f5f5f	64	plan9	DIVPD 0(CX), X2
660f5f11|223344556677885f5f5f5f5f	32	intel	maxpd xmm2, xmmword ptr [ecx]
660f5f11|223344556677885f5f5f5f5f	32	plan9	MAXPD 0(CX), X2
660f5f11|223344556677885f5f5f5f5f	64	gnu	maxpd (%rcx),%xmm2
660f5f11|223344556677885f5f5f5f5f	64	intel	maxpd xmm2, xmmword ptr [rcx]
660f5f11|223344556677885f5f5f5f5f	64	plan9	MAXPD 0(CX), X2
660f6011|223344556677885f5f5f5f5f	32	intel	punpcklbw xmm2, xmmword ptr [ecx]
660f6011|223344556677885f5f5f5f5f	32	plan9	PUNPCKLBW 0(CX), X2
660f6011|223344556677885f5f5f5f5f	64	gnu	punpcklbw (%rcx),%xmm2
660f6011|223344556677885f5f5f5f5f	64	intel	punpcklbw xmm2, xmmword ptr [rcx]
660f6011|223344556677885f5f5f5f5f	64	plan9	PUNPCKLBW 0(CX), X2
660f6111|223344556677885f5f5f5f5f	32	intel	punpcklwd xmm2, xmmword ptr [ecx]
660f6111|223344556677885f5f5f5f5f	32	plan9	PUNPCKLWD 0(CX), X2
660f6111|223344556677885f5f5f5f5f	64	gnu	punpcklwd (%rcx),%xmm2
660f6111|223344556677885f5f5f5f5f	64	intel	punpcklwd xmm2, xmmword ptr [rcx]
660f6111|223344556677885f5f5f5f5f	64	plan9	PUNPCKLWD 0(CX), X2
660f6211|223344556677885f5f5f5f5f	32	intel	punpckldq xmm2, xmmword ptr [ecx]
660f6211|223344556677885f5f5f5f5f	32	plan9	PUNPCKLDQ 0(CX), X2
660f6211|223344556677885f5f5f5f5f	64	gnu	punpckldq (%rcx),%xmm2
660f6211|223344556677885f5f5f5f5f	64	intel	punpckldq xmm2, xmmword ptr [rcx]
660f6211|223344556677885f5f5f5f5f	64	plan9	PUNPCKLDQ 0(CX), X2
660f6311|223344556677885f5f5f5f5f	32	intel	packsswb xmm2, xmmword ptr [ecx]
660f6311|223344556677885f5f5f5f5f	32	plan9	PACKSSWB 0(CX), X2
660f6311|223344556677885f5f5f5f5f	64	gnu	packsswb (%rcx),%xmm2
660f6311|223344556677885f5f5f5f5f	64	intel	packsswb xmm2, xmmword ptr [rcx]
660f6311|223344556677885f5f5f5f5f	64	plan9	PACKSSWB 0(CX), X2
660f6411|223344556677885f5f5f5f5f	32	intel	pcmpgtb xmm2, xmmword ptr [ecx]
660f6411|223344556677885f5f5f5f5f	32	plan9	PCMPGTB 0(CX), X2
660f6411|223344556677885f5f5f5f5f	64	gnu	pcmpgtb (%rcx),%xmm2
660f6411|223344556677885f5f5f5f5f	64	intel	pcmpgtb xmm2, xmmword ptr [rcx]
660f6411|223344556677885f5f5f5f5f	64	plan9	PCMPGTB 0(CX), X2
660f6511|223344556677885f5f5f5f5f	32	intel	pcmpgtw xmm2, xmmword ptr [ecx]
660f6511|223344556677885f5f5f5f5f	32	plan9	PCMPGTW 0(CX), X2
660f6511|223344556677885f5f5f5f5f	64	gnu	pcmpgtw (%rcx),%xmm2
660f6511|223344556677885f5f5f5f5f	64	intel	pcmpgtw xmm2, xmmword ptr [rcx]
660f6511|223344556677885f5f5f5f5f	64	plan9	PCMPGTW 0(CX), X2
660f6611|223344556677885f5f5f5f5f	32	intel	pcmpgtd xmm2, xmmword ptr [ecx]
660f6611|223344556677885f5f5f5f5f	32	plan9	PCMPGTD 0(CX), X2
660f6611|223344556677885f5f5f5f5f	64	gnu	pcmpgtd (%rcx),%xmm2
660f6611|223344556677885f5f5f5f5f	64	intel	pcmpgtd xmm2, xmmword ptr [rcx]
660f6611|223344556677885f5f5f5f5f	64	plan9	PCMPGTD 0(CX), X2
660f6711|223344556677885f5f5f5f5f	32	intel	packuswb xmm2, xmmword ptr [ecx]
660f6711|223344556677885f5f5f5f5f	32	plan9	PACKUSWB 0(CX), X2
660f6711|223344556677885f5f5f5f5f	64	gnu	packuswb (%rcx),%xmm2
660f6711|223344556677885f5f5f5f5f	64	intel	packuswb xmm2, xmmword ptr [rcx]
660f6711|223344556677885f5f5f5f5f	64	plan9	PACKUSWB 0(CX), X2
660f6811|223344556677885f5f5f5f5f	32	intel	punpckhbw xmm2, xmmword ptr [ecx]
660f6811|223344556677885f5f5f5f5f	32	plan9	PUNPCKHBW 0(CX), X2
660f6811|223344556677885f5f5f5f5f	64	gnu	punpckhbw (%rcx),%xmm2
660f6811|223344556677885f5f5f5f5f	64	intel	punpckhbw xmm2, xmmword ptr [rcx]
660f6811|223344556677885f5f5f5f5f	64	plan9	PUNPCKHBW 0(CX), X2
660f6911|223344556677885f5f5f5f5f	32	intel	punpckhwd xmm2, xmmword ptr [ecx]
660f6911|223344556677885f5f5f5f5f	32	plan9	PUNPCKHWD 0(CX), X2
660f6911|223344556677885f5f5f5f5f	64	gnu	punpckhwd (%rcx),%xmm2
660f6911|223344556677885f5f5f5f5f	64	intel	punpckhwd xmm2, xmmword ptr [rcx]
660f6911|223344556677885f5f5f5f5f	64	plan9	PUNPCKHWD 0(CX), X2
660f6a11|223344556677885f5f5f5f5f	32	intel	punpckhdq xmm2, xmmword ptr [ecx]
660f6a11|223344556677885f5f5f5f5f	32	plan9	PUNPCKHDQ 0(CX), X2
660f6a11|223344556677885f5f5f5f5f	64	gnu	punpckhdq (%rcx),%xmm2
660f6a11|223344556677885f5f5f5f5f	64	intel	punpckhdq xmm2, xmmword ptr [rcx]
660f6a11|223344556677885f5f5f5f5f	64	plan9	PUNPCKHDQ 0(CX), X2
660f6b11|223344556677885f5f5f5f5f	32	intel	packssdw xmm2, xmmword ptr [ecx]
660f6b11|223344556677885f5f5f5f5f	32	plan9	PACKSSDW 0(CX), X2
660f6b11|223344556677885f5f5f5f5f	64	gnu	packssdw (%rcx),%xmm2
660f6b11|223344556677885f5f5f5f5f	64	intel	packssdw xmm2, xmmword ptr [rcx]
660f6b11|223344556677885f5f5f5f5f	64	plan9	PACKSSDW 0(CX), X2
660f6c11|223344556677885f5f5f5f5f	32	intel	punpcklqdq xmm2, xmmword ptr [ecx]
660f6c11|223344556677885f5f5f5f5f	32	plan9	PUNPCKLQDQ 0(CX), X2
660f6c11|223344556677885f5f5f5f5f	64	gnu	punpcklqdq (%rcx),%xmm2
660f6c11|223344556677885f5f5f5f5f	64	intel	punpcklqdq xmm2, xmmword ptr [rcx]
660f6c11|223344556677885f5f5f5f5f	64	plan9	PUNPCKLQDQ 0(CX), X2
660f6d11|223344556677885f5f5f5f5f	32	intel	punpckhqdq xmm2, xmmword ptr [ecx]
660f6d11|223344556677885f5f5f5f5f	32	plan9	PUNPCKHQDQ 0(CX), X2
660f6d11|223344556677885f5f5f5f5f	64	gnu	punpckhqdq (%rcx),%xmm2
660f6d11|223344556677885f5f5f5f5f	64	intel	punpckhqdq xmm2, xmmword ptr [rcx]
660f6d11|223344556677885f5f5f5f5f	64	plan9	PUNPCKHQDQ 0(CX), X2
660f6e11|223344556677885f5f5f5f5f	32	intel	movd xmm2, dword ptr [ecx]
660f6e11|223344556677885f5f5f5f5f	32	plan9	MOVD 0(CX), X2
660f6e11|223344556677885f5f5f5f5f	64	gnu	movd (%rcx),%xmm2
660f6e11|223344556677885f5f5f5f5f	64	intel	movd xmm2, dword ptr [rcx]
660f6e11|223344556677885f5f5f5f5f	64	plan9	MOVD 0(CX), X2
660f6f11|223344556677885f5f5f5f5f	32	intel	movdqa xmm2, xmmword ptr [ecx]
660f6f11|223344556677885f5f5f5f5f	32	plan9	MOVDQA 0(CX), X2
660f6f11|223344556677885f5f5f5f5f	64	gnu	movdqa (%rcx),%xmm2
660f6f11|223344556677885f5f5f5f5f	64	intel	movdqa xmm2, xmmword ptr [rcx]
660f6f11|223344556677885f5f5f5f5f	64	plan9	MOVDQA 0(CX), X2
660f701122|3344556677885f5f5f5f5f	32	intel	pshufd xmm2, xmmword ptr [ecx], 0x22
660f701122|3344556677885f5f5f5f5f	32	plan9	PSHUFD $0x22, 0(CX), X2
660f701122|3344556677885f5f5f5f5f	64	gnu	pshufd $0x22,(%rcx),%xmm2
660f701122|3344556677885f5f5f5f5f	64	intel	pshufd xmm2, xmmword ptr [rcx], 0x22
660f701122|3344556677885f5f5f5f5f	64	plan9	PSHUFD $0x22, 0(CX), X2
660f71d011|223344556677885f5f5f5f	32	intel	psrlw xmm0, 0x11
660f71d011|223344556677885f5f5f5f	32	plan9	PSRLW $0x11, X0
660f71d011|223344556677885f5f5f5f	64	gnu	psrlw $0x11,%xmm0
660f71d011|223344556677885f5f5f5f	64	intel	psrlw xmm0, 0x11
660f71d011|223344556677885f5f5f5f	64	plan9	PSRLW $0x11, X0
660f71e011|223344556677885f5f5f5f	32	intel	psraw xmm0, 0x11
660f71e011|223344556677885f5f5f5f	32	plan9	PSRAW $0x11, X0
660f71e011|223344556677885f5f5f5f	64	gnu	psraw $0x11,%xmm0
660f71e011|223344556677885f5f5f5f	64	intel	psraw xmm0, 0x11
660f71e011|223344556677885f5f5f5f	64	plan9	PSRAW $0x11, X0
660f71f011|223344556677885f5f5f5f	32	intel	psllw xmm0, 0x11
660f71f011|223344556677885f5f5f5f	32	plan9	PSLLW $0x11, X0
660f71f011|223344556677885f5f5f5f	64	gnu	psllw $0x11,%xmm0
660f71f011|223344556677885f5f5f5f	64	intel	psllw xmm0, 0x11
660f71f011|223344556677885f5f5f5f	64	plan9	PSLLW $0x11, X0
660f72d011|223344556677885f5f5f5f	32	intel	psrld xmm0, 0x11
660f72d011|223344556677885f5f5f5f	32	plan9	PSRLD $0x11, X0
660f72d011|223344556677885f5f5f5f	64	gnu	psrld $0x11,%xmm0
660f72d011|223344556677885f5f5f5f	64	intel	psrld xmm0, 0x11
660f72d011|223344556677885f5f5f5f	64	plan9	PSRLD $0x11, X0
660f72e011|223344556677885f5f5f5f	32	intel	psrad xmm0, 0x11
660f72e011|223344556677885f5f5f5f	32	plan9	PSRAD $0x11, X0
660f72e011|223344556677885f5f5f5f	64	gnu	psrad $0x11,%xmm0
660f72e011|223344556677885f5f5f5f	64	intel	psrad xmm0, 0x11
660f72e011|223344556677885f5f5f5f	64	plan9	PSRAD $0x11, X0
660f72f011|223344556677885f5f5f5f	32	intel	pslld xmm0, 0x11
660f72f011|223344556677885f5f5f5f	32	plan9	PSLLD $0x11, X0
660f72f011|223344556677885f5f5f5f	64	gnu	pslld $0x11,%xmm0
660f72f011|223344556677885f5f5f5f	64	intel	pslld xmm0, 0x11
660f72f011|223344556677885f5f5f5f	64	plan9	PSLLD $0x11, X0
660f73d011|223344556677885f5f5f5f	32	intel	psrlq xmm0, 0x11
660f73d011|223344556677885f5f5f5f	32	plan9	PSRLQ $0x11, X0
660f73d011|223344556677885f5f5f5f	64	gnu	psrlq $0x11,%xmm0
660f73d011|223344556677885f5f5f5f	64	intel	psrlq xmm0, 0x11
660f73d011|223344556677885f5f5f5f	64	plan9	PSRLQ $0x11, X0
660f73d811|223344556677885f5f5f5f	32	intel	psrldq xmm0, 0x11
660f73d811|223344556677885f5f5f5f	32	plan9	PSRLDQ $0x11, X0
660f73d811|223344556677885f5f5f5f	64	gnu	psrldq $0x11,%xmm0
660f73d811|223344556677885f5f5f5f	64	intel	psrldq xmm0, 0x11
660f73d811|223344556677885f5f5f5f	64	plan9	PSRLDQ $0x11, X0
660f73f011|223344556677885f5f5f5f	32	intel	psllq xmm0, 0x11
660f73f011|223344556677885f5f5f5f	32	plan9	PSLLQ $0x11, X0
660f73f011|223344556677885f5f5f5f	64	gnu	psllq $0x11,%xmm0
660f73f011|223344556677885f5f5f5f	64	intel	psllq xmm0, 0x11
660f73f011|223344556677885f5f5f5f	64	plan9	PSLLQ $0x11, X0
660f73f811|223344556677885f5f5f5f	32	intel	pslldq xmm0, 0x11
660f73f811|223344556677885f5f5f5f	32	plan9	PSLLDQ $0x11, X0
660f73f811|223344556677885f5f5f5f	64	gnu	pslldq $0x11,%xmm0
660f73f811|223344556677885f5f5f5f	64	intel	pslldq xmm0, 0x11
660f73f811|223344556677885f5f5f5f	64	plan9	PSLLDQ $0x11, X0
660f7411|223344556677885f5f5f5f5f	32	intel	pcmpeqb xmm2, xmmword ptr [ecx]
660f7411|223344556677885f5f5f5f5f	32	plan9	PCMPEQB 0(CX), X2
660f7411|223344556677885f5f5f5f5f	64	gnu	pcmpeqb (%rcx),%xmm2
660f7411|223344556677885f5f5f5f5f	64	intel	pcmpeqb xmm2, xmmword ptr [rcx]
660f7411|223344556677885f5f5f5f5f	64	plan9	PCMPEQB 0(CX), X2
660f7511|223344556677885f5f5f5f5f	32	intel	pcmpeqw xmm2, xmmword ptr [ecx]
660f7511|223344556677885f5f5f5f5f	32	plan9	PCMPEQW 0(CX), X2
660f7511|223344556677885f5f5f5f5f	64	gnu	pcmpeqw (%rcx),%xmm2
660f7511|223344556677885f5f5f5f5f	64	intel	pcmpeqw xmm2, xmmword ptr [rcx]
660f7511|223344556677885f5f5f5f5f	64	plan9	PCMPEQW 0(CX), X2
660f7611|223344556677885f5f5f5f5f	32	intel	pcmpeqd xmm2, xmmword ptr [ecx]
660f7611|223344556677885f5f5f5f5f	32	plan9	PCMPEQD 0(CX), X2
660f7611|223344556677885f5f5f5f5f	64	gnu	pcmpeqd (%rcx),%xmm2
660f7611|223344556677885f5f5f5f5f	64	intel	pcmpeqd xmm2, xmmword ptr [rcx]
660f7611|223344556677885f5f5f5f5f	64	plan9	PCMPEQD 0(CX), X2
660f7c11|223344556677885f5f5f5f5f	32	intel	haddpd xmm2, xmmword ptr [ecx]
660f7c11|223344556677885f5f5f5f5f	32	plan9	HADDPD 0(CX), X2
660f7c11|223344556677885f5f5f5f5f	64	gnu	haddpd (%rcx),%xmm2
660f7c11|223344556677885f5f5f5f5f	64	intel	haddpd xmm2, xmmword ptr [rcx]
660f7c11|223344556677885f5f5f5f5f	64	plan9	HADDPD 0(CX), X2
660f7d11|223344556677885f5f5f5f5f	32	intel	hsubpd xmm2, xmmword ptr [ecx]
660f7d11|223344556677885f5f5f5f5f	32	plan9	HSUBPD 0(CX), X2
660f7d11|223344556677885f5f5f5f5f	64	gnu	hsubpd (%rcx),%xmm2
660f7d11|223344556677885f5f5f5f5f	64	intel	hsubpd xmm2, xmmword ptr [rcx]
660f7d11|223344556677885f5f5f5f5f	64	plan9	HSUBPD 0(CX), X2
660f7e11|223344556677885f5f5f5f5f	32	intel	movd dword ptr [ecx], xmm2
660f7e11|223344556677885f5f5f5f5f	32	plan9	MOVD X2, 0(CX)
660f7e11|223344556677885f5f5f5f5f	64	gnu	movd %xmm2,(%rcx)
660f7e11|223344556677885f5f5f5f5f	64	intel	movd dword ptr [rcx], xmm2
660f7e11|223344556677885f5f5f5f5f	64	plan9	MOVD X2, 0(CX)
660f7f11|223344556677885f5f5f5f5f	32	intel	movdqa xmmword ptr [ecx], xmm2
660f7f11|223344556677885f5f5f5f5f	32	plan9	MOVDQA X2, 0(CX)
660f7f11|223344556677885f5f5f5f5f	64	gnu	movdqa %xmm2,(%rcx)
660f7f11|223344556677885f5f5f5f5f	64	intel	movdqa xmmword ptr [rcx], xmm2
660f7f11|223344556677885f5f5f5f5f	64	plan9	MOVDQA X2, 0(CX)
660f8011223344|556677885f5f5f5f5f	64	gnu	jo .+0x44332211
660f8011223344|556677885f5f5f5f5f	64	intel	jo .+0x44332211
660f8011223344|556677885f5f5f5f5f	64	plan9	JO .+1144201745
660f801122|3344556677885f5f5f5f5f	32	intel	jo .+0x2211
660f801122|3344556677885f5f5f5f5f	32	plan9	JO .+8721
660f8111223344|556677885f5f5f5f5f	64	gnu	jno .+0x44332211
660f8111223344|556677885f5f5f5f5f	64	intel	jno .+0x44332211
660f8111223344|556677885f5f5f5f5f	64	plan9	JNO .+1144201745
660f811122|3344556677885f5f5f5f5f	32	intel	jno .+0x2211
660f811122|3344556677885f5f5f5f5f	32	plan9	JNO .+8721
660f8211223344|556677885f5f5f5f5f	64	gnu	jb .+0x44332211
660f8211223344|556677885f5f5f5f5f	64	intel	jb .+0x44332211
660f8211223344|556677885f5f5f5f5f	64	plan9	JB .+1144201745
660f821122|3344556677885f5f5f5f5f	32	intel	jb .+0x2211
660f821122|3344556677885f5f5f5f5f	32	plan9	JB .+8721
660f8311223344|556677885f5f5f5f5f	64	gnu	jae .+0x44332211
660f8311223344|556677885f5f5f5f5f	64	intel	jnb .+0x44332211
660f8311223344|556677885f5f5f5f5f	64	plan9	JAE .+1144201745
660f831122|3344556677885f5f5f5f5f	32	intel	jnb .+0x2211
660f831122|3344556677885f5f5f5f5f	32	plan9	JAE .+8721
660f8411223344|556677885f5f5f5f5f	64	gnu	je .+0x44332211
660f8411223344|556677885f5f5f5f5f	64	intel	jz .+0x44332211
660f8411223344|556677885f5f5f5f5f	64	plan9	JE .+1144201745
660f841122|3344556677885f5f5f5f5f	32	intel	jz .+0x2211
660f841122|3344556677885f5f5f5f5f	32	plan9	JE .+8721
660f8511223344|556677885f5f5f5f5f	64	gnu	jne .+0x44332211
660f8511223344|556677885f5f5f5f5f	64	intel	jnz .+0x44332211
660f8511223344|556677885f5f5f5f5f	64	plan9	JNE .+1144201745
660f851122|3344556677885f5f5f5f5f	32	intel	jnz .+0x2211
660f851122|3344556677885f5f5f5f5f	32	plan9	JNE .+8721
660f8611223344|556677885f5f5f5f5f	64	gnu	jbe .+0x44332211
660f8611223344|556677885f5f5f5f5f	64	intel	jbe .+0x44332211
660f8611223344|556677885f5f5f5f5f	64	plan9	JBE .+1144201745
660f861122|3344556677885f5f5f5f5f	32	intel	jbe .+0x2211
660f861122|3344556677885f5f5f5f5f	32	plan9	JBE .+8721
660f8711223344|556677885f5f5f5f5f	64	gnu	ja .+0x44332211
660f8711223344|556677885f5f5f5f5f	64	intel	jnbe .+0x44332211
660f8711223344|556677885f5f5f5f5f	64	plan9	JA .+1144201745
660f871122|3344556677885f5f5f5f5f	32	intel	jnbe .+0x2211
660f871122|3344556677885f5f5f5f5f	32	plan9	JA .+8721
660f8811223344|556677885f5f5f5f5f	64	gnu	js .+0x44332211
660f8811223344|556677885f5f5f5f5f	64	intel	js .+0x44332211
660f8811223344|556677885f5f5f5f5f	64	plan9	JS .+1144201745
660f881122|3344556677885f5f5f5f5f	32	intel	js .+0x2211
660f881122|3344556677885f5f5f5f5f	32	plan9	JS .+8721
660f8911223344|556677885f5f5f5f5f	64	gnu	jns .+0x44332211
660f8911223344|556677885f5f5f5f5f	64	intel	jns .+0x44332211
660f8911223344|556677885f5f5f5f5f	64	plan9	JNS .+1144201745
660f891122|3344556677885f5f5f5f5f	32	intel	jns .+0x2211
660f891122|3344556677885f5f5f5f5f	32	plan9	JNS .+8721
660f8a11223344|556677885f5f5f5f5f	64	gnu	jp .+0x44332211
660f8a11223344|556677885f5f5f5f5f	64	intel	jp .+0x44332211
660f8a11223344|556677885f5f5f5f5f	64	plan9	JP .+1144201745
660f8a1122|3344556677885f5f5f5f5f	32	intel	jp .+0x2211
660f8a1122|3344556677885f5f5f5f5f	32	plan9	JP .+8721
660f8b11223344|556677885f5f5f5f5f	64	gnu	jnp .+0x44332211
660f8b11223344|556677885f5f5f5f5f	64	intel	jnp .+0x44332211
660f8b11223344|556677885f5f5f5f5f	64	plan9	JNP .+1144201745
660f8b1122|3344556677885f5f5f5f5f	32	intel	jnp .+0x2211
660f8b1122|3344556677885f5f5f5f5f	32	plan9	JNP .+8721
660f8c11223344|556677885f5f5f5f5f	64	gnu	jl .+0x44332211
660f8c11223344|556677885f5f5f5f5f	64	intel	jl .+0x44332211
660f8c11223344|556677885f5f5f5f5f	64	plan9	JL .+1144201745
660f8c1122|3344556677885f5f5f5f5f	32	intel	jl .+0x2211
660f8c1122|3344556677885f5f5f5f5f	32	plan9	JL .+8721
660f8d11223344|556677885f5f5f5f5f	64	gnu	jge .+0x44332211
660f8d11223344|556677885f5f5f5f5f	64	intel	jnl .+0x44332211
660f8d11223344|556677885f5f5f5f5f	64	plan9	JGE .+1144201745
660f8d1122|3344556677885f5f5f5f5f	32	intel	jnl .+0x2211
660f8d1122|3344556677885f5f5f5f5f	32	plan9	JGE .+8721
660f8e11223344|556677885f5f5f5f5f	64	gnu	jle .+0x44332211
660f8e11223344|556677885f5f5f5f5f	64	intel	jle .+0x44332211
660f8e11223344|556677885f5f5f5f5f	64	plan9	JLE .+1144201745
660f8e1122|3344556677885f5f5f5f5f	32	intel	jle .+0x2211
660f8e1122|3344556677885f5f5f5f5f	32	plan9	JLE .+8721
660f8f11223344|556677885f5f5f5f5f	64	gnu	jg .+0x44332211
660f8f11223344|556677885f5f5f5f5f	64	intel	jnle .+0x44332211
660f8f11223344|556677885f5f5f5f5f	64	plan9	JG .+1144201745
660f8f1122|3344556677885f5f5f5f5f	32	intel	jnle .+0x2211
660f8f1122|3344556677885f5f5f5f5f	32	plan9	JG .+8721
660fa1|11223344556677885f5f5f5f5f	32	intel	pop fs
660fa1|11223344556677885f5f5f5f5f	32	plan9	POPW FS
660fa1|11223344556677885f5f5f5f5f	64	gnu	popw %fs
660fa1|11223344556677885f5f5f5f5f	64	intel	pop fs
660fa1|11223344556677885f5f5f5f5f	64	plan9	POPW FS
660fa311|223344556677885f5f5f5f5f	32	intel	bt word ptr [ecx], dx
660fa311|223344556677885f5f5f5f5f	32	plan9	BTW DX, 0(CX)
660fa311|223344556677885f5f5f5f5f	64	gnu	bt %dx,(%rcx)
660fa311|223344556677885f5f5f5f5f	64	intel	bt word ptr [rcx], dx
660fa311|223344556677885f5f5f5f5f	64	plan9	BTW DX, 0(CX)
660fa41122|3344556677885f5f5f5f5f	32	intel	shld word ptr [ecx], dx, 0x22
660fa41122|3344556677885f5f5f5f5f	32	plan9	SHLDW $0x22, DX, 0(CX)
660fa41122|3344556677885f5f5f5f5f	64	gnu	shld $0x22,%dx,(%rcx)
660fa41122|3344556677885f5f5f5f5f	64	intel	shld word ptr [rcx], dx, 0x22
660fa41122|3344556677885f5f5f5f5f	64	plan9	SHLDW $0x22, DX, 0(CX)
660fa511|223344556677885f5f5f5f5f	32	intel	shld word ptr [ecx], dx, cl
660fa511|223344556677885f5f5f5f5f	32	plan9	SHLDW CL, DX, 0(CX)
660fa511|223344556677885f5f5f5f5f	64	gnu	shld %cl,%dx,(%rcx)
660fa511|223344556677885f5f5f5f5f	64	intel	shld word ptr [rcx], dx, cl
660fa511|223344556677885f5f5f5f5f	64	plan9	SHLDW CL, DX, 0(CX)
660fa9|11223344556677885f5f5f5f5f	32	intel	pop gs
660fa9|11223344556677885f5f5f5f5f	32	plan9	POPW GS
660fa9|11223344556677885f5f5f5f5f	64	gnu	popw %gs
660fa9|11223344556677885f5f5f5f5f	64	intel	pop gs
660fa9|11223344556677885f5f5f5f5f	64	plan9	POPW GS
660fab11|223344556677885f5f5f5f5f	32	intel	bts word ptr [ecx], dx
660fab11|223344556677885f5f5f5f5f	32	plan9	BTSW DX, 0(CX)
660fab11|223344556677885f5f5f5f5f	64	gnu	bts %dx,(%rcx)
660fab11|223344556677885f5f5f5f5f	64	intel	bts word ptr [rcx], dx
660fab11|223344556677885f5f5f5f5f	64	plan9	BTSW DX, 0(CX)
660fac1122|3344556677885f5f5f5f5f	32	intel	shrd word ptr [ecx], dx, 0x22
660fac1122|3344556677885f5f5f5f5f	32	plan9	SHRDW $0x22, DX, 0(CX)
660fac1122|3344556677885f5f5f5f5f	64	gnu	shrd $0x22,%dx,(%rcx)
660fac1122|3344556677885f5f5f5f5f	64	intel	shrd word ptr [rcx], dx, 0x22
660fac1122|3344556677885f5f5f5f5f	64	plan9	SHRDW $0x22, DX, 0(CX)
660fad11|223344556677885f5f5f5f5f	32	intel	shrd word ptr [ecx], dx, cl
660fad11|223344556677885f5f5f5f5f	32	plan9	SHRDW CL, DX, 0(CX)
660fad11|223344556677885f5f5f5f5f	64	gnu	shrd %cl,%dx,(%rcx)
660fad11|223344556677885f5f5f5f5f	64	intel	shrd word ptr [rcx], dx, cl
660fad11|223344556677885f5f5f5f5f	64	plan9	SHRDW CL, DX, 0(CX)
660fae00|11223344556677885f5f5f5f	32	intel	fxsave ptr [eax]
660fae00|11223344556677885f5f5f5f	32	plan9	FXSAVE 0(AX)
660fae00|11223344556677885f5f5f5f	64	gnu	fxsave (%rax)
660fae00|11223344556677885f5f5f5f	64	intel	fxsave ptr [rax]
660fae00|11223344556677885f5f5f5f	64	plan9	FXSAVE 0(AX)
660fae08|11223344556677885f5f5f5f	32	intel	fxrstor ptr [eax]
660fae08|11223344556677885f5f5f5f	32	plan9	FXRSTOR 0(AX)
660fae08|11223344556677885f5f5f5f	64	gnu	data16 fxrstor (%rax)
660fae08|11223344556677885f5f5f5f	64	intel	fxrstor ptr [rax]
660fae08|11223344556677885f5f5f5f	64	plan9	FXRSTOR 0(AX)
660fae20|11223344556677885f5f5f5f	32	intel	xsave ptr [eax]
660fae20|11223344556677885f5f5f5f	32	plan9	XSAVE 0(AX)
660fae20|11223344556677885f5f5f5f	64	gnu	data16 xsave (%rax)
660fae20|11223344556677885f5f5f5f	64	intel	xsave ptr [rax]
660fae20|11223344556677885f5f5f5f	64	plan9	XSAVE 0(AX)
660fae28|11223344556677885f5f5f5f	32	intel	xrstor ptr [eax]
660fae28|11223344556677885f5f5f5f	32	plan9	XRSTOR 0(AX)
660fae28|11223344556677885f5f5f5f	64	gnu	data16 xrstor (%rax)
660fae28|11223344556677885f5f5f5f	64	intel	xrstor ptr [rax]
660fae28|11223344556677885f5f5f5f	64	plan9	XRSTOR 0(AX)
660fae30|11223344556677885f5f5f5f	32	intel	xsaveopt ptr [eax]
660fae30|11223344556677885f5f5f5f	32	plan9	XSAVEOPT 0(AX)
660fae30|11223344556677885f5f5f5f	64	gnu	data16 xsaveopt (%rax)
660fae30|11223344556677885f5f5f5f	64	intel	xsaveopt ptr [rax]
660fae30|11223344556677885f5f5f5f	64	plan9	XSAVEOPT 0(AX)
660faf11|223344556677885f5f5f5f5f	32	intel	imul dx, word ptr [ecx]
660faf11|223344556677885f5f5f5f5f	32	plan9	IMULW 0(CX), DX
660faf11|223344556677885f5f5f5f5f	64	gnu	imul (%rcx),%dx
660faf11|223344556677885f5f5f5f5f	64	intel	imul dx, word ptr [rcx]
660faf11|223344556677885f5f5f5f5f	64	plan9	IMULW 0(CX), DX
660fb111|223344556677885f5f5f5f5f	32	intel	cmpxchg word ptr [ecx], dx
660fb111|223344556677885f5f5f5f5f	32	plan9	CMPXCHGW DX, 0(CX)
660fb111|223344556677885f5f5f5f5f	64	gnu	cmpxchg %dx,(%rcx)
660fb111|223344556677885f5f5f5f5f	64	intel	cmpxchg word ptr [rcx], dx
660fb111|223344556677885f5f5f5f5f	64	plan9	CMPXCHGW DX, 0(CX)
660fb211|223344556677885f5f5f5f5f	32	intel	lss dx, dword ptr [ecx]
660fb211|223344556677885f5f5f5f5f	32	plan9	LSS 0(CX), DX
660fb211|223344556677885f5f5f5f5f	64	gnu	lss (%rcx),%dx
660fb211|223344556677885f5f5f5f5f	64	intel	lss dx, dword ptr [rcx]
660fb211|223344556677885f5f5f5f5f	64	plan9	LSS 0(CX), DX
660fb311|223344556677885f5f5f5f5f	32	intel	btr word ptr [ecx], dx
660fb311|223344556677885f5f5f5f5f	32	plan9	BTRW DX, 0(CX)
660fb311|223344556677885f5f5f5f5f	64	gnu	btr %dx,(%rcx)
660fb311|223344556677885f5f5f5f5f	64	intel	btr word ptr [rcx], dx
660fb311|223344556677885f5f5f5f5f	64	plan9	BTRW DX, 0(CX)
660fb411|223344556677885f5f5f5f5f	32	intel	lfs dx, dword ptr [ecx]
660fb411|223344556677885f5f5f5f5f	32	plan9	LFS 0(CX), DX
660fb411|223344556677885f5f5f5f5f	64	gnu	lfs (%rcx),%dx
660fb411|223344556677885f5f5f5f5f	64	intel	lfs dx, dword ptr [rcx]
660fb411|223344556677885f5f5f5f5f	64	plan9	LFS 0(CX), DX
660fb511|223344556677885f5f5f5f5f	32	intel	lgs dx, dword ptr [ecx]
660fb511|223344556677885f5f5f5f5f	32	plan9	LGS 0(CX), DX
660fb511|223344556677885f5f5f5f5f	64	gnu	lgs (%rcx),%dx
660fb511|223344556677885f5f5f5f5f	64	intel	lgs dx, dword ptr [rcx]
660fb511|223344556677885f5f5f5f5f	64	plan9	LGS 0(CX), DX
660fb611|223344556677885f5f5f5f5f	32	intel	movzx dx, byte ptr [ecx]
660fb611|223344556677885f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
660fb611|223344556677885f5f5f5f5f	64	gnu	movzbw (%rcx),%dx
660fb611|223344556677885f5f5f5f5f	64	intel	movzx dx, byte ptr [rcx]
660fb611|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
660fb711|223344556677885f5f5f5f5f	32	intel	movzx dx, word ptr [ecx]
660fb711|223344556677885f5f5f5f5f	32	plan9	MOVZX 0(CX), DX
660fb711|223344556677885f5f5f5f5f	64	gnu	movzww (%rcx),%dx
660fb711|223344556677885f5f5f5f5f	64	intel	movzx dx, word ptr [rcx]
660fb711|223344556677885f5f5f5f5f	64	plan9	MOVZX 0(CX), DX
660fba2011|223344556677885f5f5f5f	32	intel	bt word ptr [eax], 0x11
660fba2011|223344556677885f5f5f5f	32	plan9	BTW $0x11, 0(AX)
660fba2011|223344556677885f5f5f5f	64	gnu	btw $0x11,(%rax)
660fba2011|223344556677885f5f5f5f	64	intel	bt word ptr [rax], 0x11
660fba2011|223344556677885f5f5f5f	64	plan9	BTW $0x11, 0(AX)
660fba2811|223344556677885f5f5f5f	32	intel	bts word ptr [eax], 0x11
660fba2811|223344556677885f5f5f5f	32	plan9	BTSW $0x11, 0(AX)
660fba2811|223344556677885f5f5f5f	64	gnu	btsw $0x11,(%rax)
660fba2811|223344556677885f5f5f5f	64	intel	bts word ptr [rax], 0x11
660fba2811|223344556677885f5f5f5f	64	plan9	BTSW $0x11, 0(AX)
660fba3011|223344556677885f5f5f5f	32	intel	btr word ptr [eax], 0x11
660fba3011|223344556677885f5f5f5f	32	plan9	BTRW $0x11, 0(AX)
660fba3011|223344556677885f5f5f5f	64	gnu	btrw $0x11,(%rax)
660fba3011|223344556677885f5f5f5f	64	intel	btr word ptr [rax], 0x11
660fba3011|223344556677885f5f5f5f	64	plan9	BTRW $0x11, 0(AX)
660fba3811|223344556677885f5f5f5f	32	intel	btc word ptr [eax], 0x11
660fba3811|223344556677885f5f5f5f	32	plan9	BTCW $0x11, 0(AX)
660fba3811|223344556677885f5f5f5f	64	gnu	btcw $0x11,(%rax)
660fba3811|223344556677885f5f5f5f	64	intel	btc word ptr [rax], 0x11
660fba3811|223344556677885f5f5f5f	64	plan9	BTCW $0x11, 0(AX)
660fbb11|223344556677885f5f5f5f5f	32	intel	btc word ptr [ecx], dx
660fbb11|223344556677885f5f5f5f5f	32	plan9	BTCW DX, 0(CX)
660fbb11|223344556677885f5f5f5f5f	64	gnu	btc %dx,(%rcx)
660fbb11|223344556677885f5f5f5f5f	64	intel	btc word ptr [rcx], dx
660fbb11|223344556677885f5f5f5f5f	64	plan9	BTCW DX, 0(CX)
660fbc11|223344556677885f5f5f5f5f	32	intel	bsf dx, word ptr [ecx]
660fbc11|223344556677885f5f5f5f5f	32	plan9	BSFW 0(CX), DX
660fbc11|223344556677885f5f5f5f5f	64	gnu	bsf (%rcx),%dx
660fbc11|223344556677885f5f5f5f5f	64	intel	bsf dx, word ptr [rcx]
660fbc11|223344556677885f5f5f5f5f	64	plan9	BSFW 0(CX), DX
660fbd11|223344556677885f5f5f5f5f	32	intel	bsr dx, word ptr [ecx]
660fbd11|223344556677885f5f5f5f5f	32	plan9	BSRW 0(CX), DX
660fbd11|223344556677885f5f5f5f5f	64	gnu	bsr (%rcx),%dx
660fbd11|223344556677885f5f5f5f5f	64	intel	bsr dx, word ptr [rcx]
660fbd11|223344556677885f5f5f5f5f	64	plan9	BSRW 0(CX), DX
660fbe11|223344556677885f5f5f5f5f	32	intel	movsx dx, byte ptr [ecx]
660fbe11|223344556677885f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
660fbe11|223344556677885f5f5f5f5f	64	gnu	movsbw (%rcx),%dx
660fbe11|223344556677885f5f5f5f5f	64	intel	movsx dx, byte ptr [rcx]
660fbe11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
660fbf11|223344556677885f5f5f5f5f	32	intel	movsx dx, word ptr [ecx]
660fbf11|223344556677885f5f5f5f5f	32	plan9	MOVSX 0(CX), DX
660fbf11|223344556677885f5f5f5f5f	64	gnu	movsww (%rcx),%dx
660fbf11|223344556677885f5f5f5f5f	64	intel	movsx dx, word ptr [rcx]
660fbf11|223344556677885f5f5f5f5f	64	plan9	MOVSX 0(CX), DX
660fc111|223344556677885f5f5f5f5f	32	intel	xadd word ptr [ecx], dx
660fc111|223344556677885f5f5f5f5f	32	plan9	XADDW DX, 0(CX)
660fc111|223344556677885f5f5f5f5f	64	gnu	xadd %dx,(%rcx)
660fc111|223344556677885f5f5f5f5f	64	intel	xadd word ptr [rcx], dx
660fc111|223344556677885f5f5f5f5f	64	plan9	XADDW DX, 0(CX)
660fc21122|3344556677885f5f5f5f5f	32	intel	cmppd xmm2, xmmword ptr [ecx], 0x22
660fc21122|3344556677885f5f5f5f5f	32	plan9	CMPPD $0x22, 0(CX), X2
660fc21122|3344556677885f5f5f5f5f	64	gnu	cmppd $0x22,(%rcx),%xmm2
660fc21122|3344556677885f5f5f5f5f	64	intel	cmppd xmm2, xmmword ptr [rcx], 0x22
660fc21122|3344556677885f5f5f5f5f	64	plan9	CMPPD $0x22, 0(CX), X2
660fc311|223344556677885f5f5f5f5f	32	intel	movnti dword ptr [ecx], edx
660fc311|223344556677885f5f5f5f5f	32	plan9	MOVNTIW DX, 0(CX)
660fc311|223344556677885f5f5f5f5f	64	gnu	movnti %edx,(%rcx)
660fc311|223344556677885f5f5f5f5f	64	intel	movnti dword ptr [rcx], edx
660fc311|223344556677885f5f5f5f5f	64	plan9	MOVNTIW DX, 0(CX)
660fc41122|3344556677885f5f5f5f5f	32	intel	pinsrw xmm2, word ptr [ecx], 0x22
660fc41122|3344556677885f5f5f5f5f	32	plan9	PINSRW $0x22, 0(CX), X2
660fc41122|3344556677885f5f5f5f5f	64	gnu	pinsrw $0x22,(%rcx),%xmm2
660fc41122|3344556677885f5f5f5f5f	64	intel	pinsrw xmm2, word ptr [rcx], 0x22
660fc41122|3344556677885f5f5f5f5f	64	plan9	PINSRW $0x22, 0(CX), X2
660fc5c011|223344556677885f5f5f5f	32	intel	pextrw eax, xmm0, 0x11
660fc5c011|223344556677885f5f5f5f	32	plan9	PEXTRW $0x11, X0, AX
660fc5c011|223344556677885f5f5f5f	64	gnu	pextrw $0x11,%xmm0,%eax
660fc5c011|223344556677885f5f5f5f	64	intel	pextrw eax, xmm0, 0x11
660fc5c011|223344556677885f5f5f5f	64	plan9	PEXTRW $0x11, X0, AX
660fc61122|3344556677885f5f5f5f5f	32	intel	shufpd xmm2, xmmword ptr [ecx], 0x22
660fc61122|3344556677885f5f5f5f5f	32	plan9	SHUFPD $0x22, 0(CX), X2
660fc61122|3344556677885f5f5f5f5f	64	gnu	shufpd $0x22,(%rcx),%xmm2
660fc61122|3344556677885f5f5f5f5f	64	intel	shufpd xmm2, xmmword ptr [rcx], 0x22
660fc61122|3344556677885f5f5f5f5f	64	plan9	SHUFPD $0x22, 0(CX), X2
660fc708|11223344556677885f5f5f5f	32	intel	cmpxchg8b qword ptr [eax]
660fc708|11223344556677885f5f5f5f	32	plan9	CMPXCHG8B 0(AX)
660fc708|11223344556677885f5f5f5f	64	gnu	data16 cmpxchg8b (%rax)
660fc708|11223344556677885f5f5f5f	64	intel	cmpxchg8b qword ptr [rax]
660fc708|11223344556677885f5f5f5f	64	plan9	CMPXCHG8B 0(AX)
660fc718|11223344556677885f5f5f5f	32	intel	xrstors ptr [eax]
660fc718|11223344556677885f5f5f5f	32	plan9	XRSTORS 0(AX)
660fc718|11223344556677885f5f5f5f	64	gnu	xrstors (%rax)
660fc718|11223344556677885f5f5f5f	64	intel	xrstors ptr [rax]
660fc718|11223344556677885f5f5f5f	64	plan9	XRSTORS 0(AX)
660fc720|11223344556677885f5f5f5f	32	intel	xsavec ptr [eax]
660fc720|11223344556677885f5f5f5f	32	plan9	XSAVEC 0(AX)
660fc720|11223344556677885f5f5f5f	64	gnu	xsavec (%rax)
660fc720|11223344556677885f5f5f5f	64	intel	xsavec ptr [rax]
660fc720|11223344556677885f5f5f5f	64	plan9	XSAVEC 0(AX)
660fc728|11223344556677885f5f5f5f	32	intel	xsaves ptr [eax]
660fc728|11223344556677885f5f5f5f	32	plan9	XSAVES 0(AX)
660fc728|11223344556677885f5f5f5f	64	gnu	xsaves (%rax)
660fc728|11223344556677885f5f5f5f	64	intel	xsaves ptr [rax]
660fc728|11223344556677885f5f5f5f	64	plan9	XSAVES 0(AX)
660fc7f2|11223344556677885f5f5f5f	32	intel	rdrand dx
660fc7f2|11223344556677885f5f5f5f	32	plan9	RDRAND DX
660fc7f2|11223344556677885f5f5f5f	64	gnu	rdrand %dx
660fc7f2|11223344556677885f5f5f5f	64	intel	rdrand dx
660fc7f2|11223344556677885f5f5f5f	64	plan9	RDRAND DX
660fc8|11223344556677885f5f5f5f5f	32	intel	bswap ax
660fc8|11223344556677885f5f5f5f5f	32	plan9	BSWAP AX
660fc8|11223344556677885f5f5f5f5f	64	gnu	bswap %ax
660fc8|11223344556677885f5f5f5f5f	64	intel	bswap ax
660fc8|11223344556677885f5f5f5f5f	64	plan9	BSWAP AX
660fd011|223344556677885f5f5f5f5f	32	intel	addsubpd xmm2, xmmword ptr [ecx]
660fd011|223344556677885f5f5f5f5f	32	plan9	ADDSUBPD 0(CX), X2
660fd011|223344556677885f5f5f5f5f	64	gnu	addsubpd (%rcx),%xmm2
660fd011|223344556677885f5f5f5f5f	64	intel	addsubpd xmm2, xmmword ptr [rcx]
660fd011|223344556677885f5f5f5f5f	64	plan9	ADDSUBPD 0(CX), X2
660fd111|223344556677885f5f5f5f5f	32	intel	psrlw xmm2, xmmword ptr [ecx]
660fd111|223344556677885f5f5f5f5f	32	plan9	PSRLW 0(CX), X2
660fd111|223344556677885f5f5f5f5f	64	gnu	psrlw (%rcx),%xmm2
660fd111|223344556677885f5f5f5f5f	64	intel	psrlw xmm2, xmmword ptr [rcx]
660fd111|223344556677885f5f5f5f5f	64	plan9	PSRLW 0(CX), X2
660fd211|223344556677885f5f5f5f5f	32	intel	psrld xmm2, xmmword ptr [ecx]
660fd211|223344556677885f5f5f5f5f	32	plan9	PSRLD 0(CX), X2
660fd211|223344556677885f5f5f5f5f	64	gnu	psrld (%rcx),%xmm2
660fd211|223344556677885f5f5f5f5f	64	intel	psrld xmm2, xmmword ptr [rcx]
660fd211|223344556677885f5f5f5f5f	64	plan9	PSRLD 0(CX), X2
660fd311|223344556677885f5f5f5f5f	32	intel	psrlq xmm2, xmmword ptr [ecx]
660fd311|223344556677885f5f5f5f5f	32	plan9	PSRLQ 0(CX), X2
660fd311|223344556677885f5f5f5f5f	64	gnu	psrlq (%rcx),%xmm2
660fd311|223344556677885f5f5f5f5f	64	intel	psrlq xmm2, xmmword ptr [rcx]
660fd311|223344556677885f5f5f5f5f	64	plan9	PSRLQ 0(CX), X2
660fd411|223344556677885f5f5f5f5f	32	intel	paddq xmm2, xmmword ptr [ecx]
660fd411|223344556677885f5f5f5f5f	32	plan9	PADDQ 0(CX), X2
660fd411|223344556677885f5f5f5f5f	64	gnu	paddq (%rcx),%xmm2
660fd411|223344556677885f5f5f5f5f	64	intel	paddq xmm2, xmmword ptr [rcx]
660fd411|223344556677885f5f5f5f5f	64	plan9	PADDQ 0(CX), X2
660fd511|223344556677885f5f5f5f5f	32	intel	pmullw xmm2, xmmword ptr [ecx]
660fd511|223344556677885f5f5f5f5f	32	plan9	PMULLW 0(CX), X2
660fd511|223344556677885f5f5f5f5f	64	gnu	pmullw (%rcx),%xmm2
660fd511|223344556677885f5f5f5f5f	64	intel	pmullw xmm2, xmmword ptr [rcx]
660fd511|223344556677885f5f5f5f5f	64	plan9	PMULLW 0(CX), X2
660fd611|223344556677885f5f5f5f5f	32	intel	movq qword ptr [ecx], xmm2
660fd611|223344556677885f5f5f5f5f	32	plan9	MOVQ X2, 0(CX)
660fd611|223344556677885f5f5f5f5f	64	gnu	movq %xmm2,(%rcx)
660fd611|223344556677885f5f5f5f5f	64	intel	movq qword ptr [rcx], xmm2
660fd611|223344556677885f5f5f5f5f	64	plan9	MOVQ X2, 0(CX)
660fd7c0|11223344556677885f5f5f5f	32	intel	pmovmskb eax, xmm0
660fd7c0|11223344556677885f5f5f5f	32	plan9	PMOVMSKB X0, AX
660fd7c0|11223344556677885f5f5f5f	64	gnu	pmovmskb %xmm0,%eax
660fd7c0|11223344556677885f5f5f5f	64	intel	pmovmskb eax, xmm0
660fd7c0|11223344556677885f5f5f5f	64	plan9	PMOVMSKB X0, AX
660fd811|223344556677885f5f5f5f5f	32	intel	psubusb xmm2, xmmword ptr [ecx]
660fd811|223344556677885f5f5f5f5f	32	plan9	PSUBUSB 0(CX), X2
660fd811|223344556677885f5f5f5f5f	64	gnu	psubusb (%rcx),%xmm2
660fd811|223344556677885f5f5f5f5f	64	intel	psubusb xmm2, xmmword ptr [rcx]
660fd811|223344556677885f5f5f5f5f	64	plan9	PSUBUSB 0(CX), X2
660fd911|223344556677885f5f5f5f5f	32	intel	psubusw xmm2, xmmword ptr [ecx]
660fd911|223344556677885f5f5f5f5f	32	plan9	PSUBUSW 0(CX), X2
660fd911|223344556677885f5f5f5f5f	64	gnu	psubusw (%rcx),%xmm2
660fd911|223344556677885f5f5f5f5f	64	intel	psubusw xmm2, xmmword ptr [rcx]
660fd911|223344556677885f5f5f5f5f	64	plan9	PSUBUSW 0(CX), X2
660fda11|223344556677885f5f5f5f5f	32	intel	pminub xmm2, xmmword ptr [ecx]
660fda11|223344556677885f5f5f5f5f	32	plan9	PMINUB 0(CX), X2
660fda11|223344556677885f5f5f5f5f	64	gnu	pminub (%rcx),%xmm2
660fda11|223344556677885f5f5f5f5f	64	intel	pminub xmm2, xmmword ptr [rcx]
660fda11|223344556677885f5f5f5f5f	64	plan9	PMINUB 0(CX), X2
660fdb11|223344556677885f5f5f5f5f	32	intel	pand xmm2, xmmword ptr [ecx]
660fdb11|223344556677885f5f5f5f5f	32	plan9	PAND 0(CX), X2
660fdb11|223344556677885f5f5f5f5f	64	gnu	pand (%rcx),%xmm2
660fdb11|223344556677885f5f5f5f5f	64	intel	pand xmm2, xmmword ptr [rcx]
660fdb11|223344556677885f5f5f5f5f	64	plan9	PAND 0(CX), X2
660fdc11|223344556677885f5f5f5f5f	32	intel	paddusb xmm2, xmmword ptr [ecx]
660fdc11|223344556677885f5f5f5f5f	32	plan9	PADDUSB 0(CX), X2
660fdc11|223344556677885f5f5f5f5f	64	gnu	paddusb (%rcx),%xmm2
660fdc11|223344556677885f5f5f5f5f	64	intel	paddusb xmm2, xmmword ptr [rcx]
660fdc11|223344556677885f5f5f5f5f	64	plan9	PADDUSB 0(CX), X2
660fdd11|223344556677885f5f5f5f5f	32	intel	paddusw xmm2, xmmword ptr [ecx]
660fdd11|223344556677885f5f5f5f5f	32	plan9	PADDUSW 0(CX), X2
660fdd11|223344556677885f5f5f5f5f	64	gnu	paddusw (%rcx),%xmm2
660fdd11|223344556677885f5f5f5f5f	64	intel	paddusw xmm2, xmmword ptr [rcx]
660fdd11|223344556677885f5f5f5f5f	64	plan9	PADDUSW 0(CX), X2
660fde11|223344556677885f5f5f5f5f	32	intel	pmaxub xmm2, xmmword ptr [ecx]
660fde11|223344556677885f5f5f5f5f	32	plan9	PMAXUB 0(CX), X2
660fde11|223344556677885f5f5f5f5f	64	gnu	pmaxub (%rcx),%xmm2
660fde11|223344556677885f5f5f5f5f	64	intel	pmaxub xmm2, xmmword ptr [rcx]
660fde11|223344556677885f5f5f5f5f	64	plan9	PMAXUB 0(CX), X2
660fdf11|223344556677885f5f5f5f5f	32	intel	pandn xmm2, xmmword ptr [ecx]
660fdf11|223344556677885f5f5f5f5f	32	plan9	PANDN 0(CX), X2
660fdf11|223344556677885f5f5f5f5f	64	gnu	pandn (%rcx),%xmm2
660fdf11|223344556677885f5f5f5f5f	64	intel	pandn xmm2, xmmword ptr [rcx]
660fdf11|223344556677885f5f5f5f5f	64	plan9	PANDN 0(CX), X2
660fe011|223344556677885f5f5f5f5f	32	intel	pavgb xmm2, xmmword ptr [ecx]
660fe011|223344556677885f5f5f5f5f	32	plan9	PAVGB 0(CX), X2
660fe011|223344556677885f5f5f5f5f	64	gnu	pavgb (%rcx),%xmm2
660fe011|223344556677885f5f5f5f5f	64	intel	pavgb xmm2, xmmword ptr [rcx]
660fe011|223344556677885f5f5f5f5f	64	plan9	PAVGB 0(CX), X2
660fe111|223344556677885f5f5f5f5f	32	intel	psraw xmm2, xmmword ptr [ecx]
660fe111|223344556677885f5f5f5f5f	32	plan9	PSRAW 0(CX), X2
660fe111|223344556677885f5f5f5f5f	64	gnu	psraw (%rcx),%xmm2
660fe111|223344556677885f5f5f5f5f	64	intel	psraw xmm2, xmmword ptr [rcx]
660fe111|223344556677885f5f5f5f5f	64	plan9	PSRAW 0(CX), X2
660fe211|223344556677885f5f5f5f5f	32	intel	psrad xmm2, xmmword ptr [ecx]
660fe211|223344556677885f5f5f5f5f	32	plan9	PSRAD 0(CX), X2
660fe211|223344556677885f5f5f5f5f	64	gnu	psrad (%rcx),%xmm2
660fe211|223344556677885f5f5f5f5f	64	intel	psrad xmm2, xmmword ptr [rcx]
660fe211|223344556677885f5f5f5f5f	64	plan9	PSRAD 0(CX), X2
660fe311|223344556677885f5f5f5f5f	32	intel	pavgw xmm2, xmmword ptr [ecx]
660fe311|223344556677885f5f5f5f5f	32	plan9	PAVGW 0(CX), X2
660fe311|223344556677885f5f5f5f5f	64	gnu	pavgw (%rcx),%xmm2
660fe311|223344556677885f5f5f5f5f	64	intel	pavgw xmm2, xmmword ptr [rcx]
660fe311|223344556677885f5f5f5f5f	64	plan9	PAVGW 0(CX), X2
660fe411|223344556677885f5f5f5f5f	32	intel	pmulhuw xmm2, xmmword ptr [ecx]
660fe411|223344556677885f5f5f5f5f	32	plan9	PMULHUW 0(CX), X2
660fe411|223344556677885f5f5f5f5f	64	gnu	pmulhuw (%rcx),%xmm2
660fe411|223344556677885f5f5f5f5f	64	intel	pmulhuw xmm2, xmmword ptr [rcx]
660fe411|223344556677885f5f5f5f5f	64	plan9	PMULHUW 0(CX), X2
660fe511|223344556677885f5f5f5f5f	32	intel	pmulhw xmm2, xmmword ptr [ecx]
660fe511|223344556677885f5f5f5f5f	32	plan9	PMULHW 0(CX), X2
660fe511|223344556677885f5f5f5f5f	64	gnu	pmulhw (%rcx),%xmm2
660fe511|223344556677885f5f5f5f5f	64	intel	pmulhw xmm2, xmmword ptr [rcx]
660fe511|223344556677885f5f5f5f5f	64	plan9	PMULHW 0(CX), X2
660fe611|223344556677885f5f5f5f5f	32	intel	cvttpd2dq xmm2, xmmword ptr [ecx]
660fe611|223344556677885f5f5f5f5f	32	plan9	CVTTPD2DQ 0(CX), X2
660fe611|223344556677885f5f5f5f5f	64	gnu	cvttpd2dq (%rcx),%xmm2
660fe611|223344556677885f5f5f5f5f	64	intel	cvttpd2dq xmm2, xmmword ptr [rcx]
660fe611|223344556677885f5f5f5f5f	64	plan9	CVTTPD2DQ 0(CX), X2
660fe711|223344556677885f5f5f5f5f	32	intel	movntdq xmmword ptr [ecx], xmm2
660fe711|223344556677885f5f5f5f5f	32	plan9	MOVNTDQ X2, 0(CX)
660fe711|223344556677885f5f5f5f5f	64	gnu	movntdq %xmm2,(%rcx)
660fe711|223344556677885f5f5f5f5f	64	intel	movntdq xmmword ptr [rcx], xmm2
660fe711|223344556677885f5f5f5f5f	64	plan9	MOVNTDQ X2, 0(CX)
660fe811|223344556677885f5f5f5f5f	32	intel	psubsb xmm2, xmmword ptr [ecx]
660fe811|223344556677885f5f5f5f5f	32	plan9	PSUBSB 0(CX), X2
660fe811|223344556677885f5f5f5f5f	64	gnu	psubsb (%rcx),%xmm2
660fe811|223344556677885f5f5f5f5f	64	intel	psubsb xmm2, xmmword ptr [rcx]
660fe811|223344556677885f5f5f5f5f	64	plan9	PSUBSB 0(CX), X2
660fe911|223344556677885f5f5f5f5f	32	intel	psubsw xmm2, xmmword ptr [ecx]
660fe911|223344556677885f5f5f5f5f	32	plan9	PSUBSW 0(CX), X2
660fe911|223344556677885f5f5f5f5f	64	gnu	psubsw (%rcx),%xmm2
660fe911|223344556677885f5f5f5f5f	64	intel	psubsw xmm2, xmmword ptr [rcx]
660fe911|223344556677885f5f5f5f5f	64	plan9	PSUBSW 0(CX), X2
660fea11|223344556677885f5f5f5f5f	32	intel	pminsw xmm2, xmmword ptr [ecx]
660fea11|223344556677885f5f5f5f5f	32	plan9	PMINSW 0(CX), X2
660fea11|223344556677885f5f5f5f5f	64	gnu	pminsw (%rcx),%xmm2
660fea11|223344556677885f5f5f5f5f	64	intel	pminsw xmm2, xmmword ptr [rcx]
660fea11|223344556677885f5f5f5f5f	64	plan9	PMINSW 0(CX), X2
660feb11|223344556677885f5f5f5f5f	32	intel	por xmm2, xmmword ptr [ecx]
660feb11|223344556677885f5f5f5f5f	32	plan9	POR 0(CX), X2
660feb11|223344556677885f5f5f5f5f	64	gnu	por (%rcx),%xmm2
660feb11|223344556677885f5f5f5f5f	64	intel	por xmm2, xmmword ptr [rcx]
660feb11|223344556677885f5f5f5f5f	64	plan9	POR 0(CX), X2
660fec11|223344556677885f5f5f5f5f	32	intel	paddsb xmm2, xmmword ptr [ecx]
660fec11|223344556677885f5f5f5f5f	32	plan9	PADDSB 0(CX), X2
660fec11|223344556677885f5f5f5f5f	64	gnu	paddsb (%rcx),%xmm2
660fec11|223344556677885f5f5f5f5f	64	intel	paddsb xmm2, xmmword ptr [rcx]
660fec11|223344556677885f5f5f5f5f	64	plan9	PADDSB 0(CX), X2
660fed11|223344556677885f5f5f5f5f	32	intel	paddsw xmm2, xmmword ptr [ecx]
660fed11|223344556677885f5f5f5f5f	32	plan9	PADDSW 0(CX), X2
660fed11|223344556677885f5f5f5f5f	64	gnu	paddsw (%rcx),%xmm2
660fed11|223344556677885f5f5f5f5f	64	intel	paddsw xmm2, xmmword ptr [rcx]
660fed11|223344556677885f5f5f5f5f	64	plan9	PADDSW 0(CX), X2
660fee11|223344556677885f5f5f5f5f	32	intel	pmaxsw xmm2, xmmword ptr [ecx]
660fee11|223344556677885f5f5f5f5f	32	plan9	PMAXSW 0(CX), X2
660fee11|223344556677885f5f5f5f5f	64	gnu	pmaxsw (%rcx),%xmm2
660fee11|223344556677885f5f5f5f5f	64	intel	pmaxsw xmm2, xmmword ptr [rcx]
660fee11|223344556677885f5f5f5f5f	64	plan9	PMAXSW 0(CX), X2
660fef11|223344556677885f5f5f5f5f	32	intel	pxor xmm2, xmmword ptr [ecx]
660fef11|223344556677885f5f5f5f5f	32	plan9	PXOR 0(CX), X2
660fef11|223344556677885f5f5f5f5f	64	gnu	pxor (%rcx),%xmm2
660fef11|223344556677885f5f5f5f5f	64	intel	pxor xmm2, xmmword ptr [rcx]
660fef11|223344556677885f5f5f5f5f	64	plan9	PXOR 0(CX), X2
660ff111|223344556677885f5f5f5f5f	32	intel	psllw xmm2, xmmword ptr [ecx]
660ff111|223344556677885f5f5f5f5f	32	plan9	PSLLW 0(CX), X2
660ff111|223344556677885f5f5f5f5f	64	gnu	psllw (%rcx),%xmm2
660ff111|223344556677885f5f5f5f5f	64	intel	psllw xmm2, xmmword ptr [rcx]
660ff111|223344556677885f5f5f5f5f	64	plan9	PSLLW 0(CX), X2
660ff211|223344556677885f5f5f5f5f	32	intel	pslld xmm2, xmmword ptr [ecx]
660ff211|223344556677885f5f5f5f5f	32	plan9	PSLLD 0(CX), X2
660ff211|223344556677885f5f5f5f5f	64	gnu	pslld (%rcx),%xmm2
660ff211|223344556677885f5f5f5f5f	64	intel	pslld xmm2, xmmword ptr [rcx]
660ff211|223344556677885f5f5f5f5f	64	plan9	PSLLD 0(CX), X2
660ff311|223344556677885f5f5f5f5f	32	intel	psllq xmm2, xmmword ptr [ecx]
660ff311|223344556677885f5f5f5f5f	32	plan9	PSLLQ 0(CX), X2
660ff311|223344556677885f5f5f5f5f	64	gnu	psllq (%rcx),%xmm2
660ff311|223344556677885f5f5f5f5f	64	intel	psllq xmm2, xmmword ptr [rcx]
660ff311|223344556677885f5f5f5f5f	64	plan9	PSLLQ 0(CX), X2
660ff411|223344556677885f5f5f5f5f	32	intel	pmuludq xmm2, xmmword ptr [ecx]
660ff411|223344556677885f5f5f5f5f	32	plan9	PMULUDQ 0(CX), X2
660ff411|223344556677885f5f5f5f5f	64	gnu	pmuludq (%rcx),%xmm2
660ff411|223344556677885f5f5f5f5f	64	intel	pmuludq xmm2, xmmword ptr [rcx]
660ff411|223344556677885f5f5f5f5f	64	plan9	PMULUDQ 0(CX), X2
660ff511|223344556677885f5f5f5f5f	32	intel	pmaddwd xmm2, xmmword ptr [ecx]
660ff511|223344556677885f5f5f5f5f	32	plan9	PMADDWD 0(CX), X2
660ff511|223344556677885f5f5f5f5f	64	gnu	pmaddwd (%rcx),%xmm2
660ff511|223344556677885f5f5f5f5f	64	intel	pmaddwd xmm2, xmmword ptr [rcx]
660ff511|223344556677885f5f5f5f5f	64	plan9	PMADDWD 0(CX), X2
660ff611|223344556677885f5f5f5f5f	32	intel	psadbw xmm2, xmmword ptr [ecx]
660ff611|223344556677885f5f5f5f5f	32	plan9	PSADBW 0(CX), X2
660ff611|223344556677885f5f5f5f5f	64	gnu	psadbw (%rcx),%xmm2
660ff611|223344556677885f5f5f5f5f	64	intel	psadbw xmm2, xmmword ptr [rcx]
660ff611|223344556677885f5f5f5f5f	64	plan9	PSADBW 0(CX), X2
660ff7c0|11223344556677885f5f5f5f	32	intel	maskmovdqu xmm0, xmm0
660ff7c0|11223344556677885f5f5f5f	32	plan9	MASKMOVDQU X0, X0
660ff7c0|11223344556677885f5f5f5f	64	intel	maskmovdqu xmm0, xmm0
660ff7c0|11223344556677885f5f5f5f	64	plan9	MASKMOVDQU X0, X0
660ff811|223344556677885f5f5f5f5f	32	intel	psubb xmm2, xmmword ptr [ecx]
660ff811|223344556677885f5f5f5f5f	32	plan9	PSUBB 0(CX), X2
660ff811|223344556677885f5f5f5f5f	64	gnu	psubb (%rcx),%xmm2
660ff811|223344556677885f5f5f5f5f	64	intel	psubb xmm2, xmmword ptr [rcx]
660ff811|223344556677885f5f5f5f5f	64	plan9	PSUBB 0(CX), X2
660ff911|223344556677885f5f5f5f5f	32	intel	psubw xmm2, xmmword ptr [ecx]
660ff911|223344556677885f5f5f5f5f	32	plan9	PSUBW 0(CX), X2
660ff911|223344556677885f5f5f5f5f	64	gnu	psubw (%rcx),%xmm2
660ff911|223344556677885f5f5f5f5f	64	intel	psubw xmm2, xmmword ptr [rcx]
660ff911|223344556677885f5f5f5f5f	64	plan9	PSUBW 0(CX), X2
660ffa11|223344556677885f5f5f5f5f	32	intel	psubd xmm2, xmmword ptr [ecx]
660ffa11|223344556677885f5f5f5f5f	32	plan9	PSUBD 0(CX), X2
660ffa11|223344556677885f5f5f5f5f	64	gnu	psubd (%rcx),%xmm2
660ffa11|223344556677885f5f5f5f5f	64	intel	psubd xmm2, xmmword ptr [rcx]
660ffa11|223344556677885f5f5f5f5f	64	plan9	PSUBD 0(CX), X2
660ffb11|223344556677885f5f5f5f5f	32	intel	psubq xmm2, xmmword ptr [ecx]
660ffb11|223344556677885f5f5f5f5f	32	plan9	PSUBQ 0(CX), X2
660ffb11|223344556677885f5f5f5f5f	64	gnu	psubq (%rcx),%xmm2
660ffb11|223344556677885f5f5f5f5f	64	intel	psubq xmm2, xmmword ptr [rcx]
660ffb11|223344556677885f5f5f5f5f	64	plan9	PSUBQ 0(CX), X2
660ffc11|223344556677885f5f5f5f5f	32	intel	paddb xmm2, xmmword ptr [ecx]
660ffc11|223344556677885f5f5f5f5f	32	plan9	PADDB 0(CX), X2
660ffc11|223344556677885f5f5f5f5f	64	gnu	paddb (%rcx),%xmm2
660ffc11|223344556677885f5f5f5f5f	64	intel	paddb xmm2, xmmword ptr [rcx]
660ffc11|223344556677885f5f5f5f5f	64	plan9	PADDB 0(CX), X2
660ffd11|223344556677885f5f5f5f5f	32	intel	paddw xmm2, xmmword ptr [ecx]
660ffd11|223344556677885f5f5f5f5f	32	plan9	PADDW 0(CX), X2
660ffd11|223344556677885f5f5f5f5f	64	gnu	paddw (%rcx),%xmm2
660ffd11|223344556677885f5f5f5f5f	64	intel	paddw xmm2, xmmword ptr [rcx]
660ffd11|223344556677885f5f5f5f5f	64	plan9	PADDW 0(CX), X2
660ffe11|223344556677885f5f5f5f5f	32	intel	paddd xmm2, xmmword ptr [ecx]
660ffe11|223344556677885f5f5f5f5f	32	plan9	PADDD 0(CX), X2
660ffe11|223344556677885f5f5f5f5f	64	gnu	paddd (%rcx),%xmm2
660ffe11|223344556677885f5f5f5f5f	64	intel	paddd xmm2, xmmword ptr [rcx]
660ffe11|223344556677885f5f5f5f5f	64	plan9	PADDD 0(CX), X2
661122|3344556677885f5f5f5f5f5f5f	32	intel	adc word ptr [edx], sp
661122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCW SP, 0(DX)
661122|3344556677885f5f5f5f5f5f5f	64	gnu	adc %sp,(%rdx)
661122|3344556677885f5f5f5f5f5f5f	64	intel	adc word ptr [rdx], sp
661122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCW SP, 0(DX)
661311|223344556677885f5f5f5f5f5f	32	intel	adc dx, word ptr [ecx]
661311|223344556677885f5f5f5f5f5f	32	plan9	ADCW 0(CX), DX
661311|223344556677885f5f5f5f5f5f	64	gnu	adc (%rcx),%dx
661311|223344556677885f5f5f5f5f5f	64	intel	adc dx, word ptr [rcx]
661311|223344556677885f5f5f5f5f5f	64	plan9	ADCW 0(CX), DX
66151122|3344556677885f5f5f5f5f5f	32	intel	adc ax, 0x2211
66151122|3344556677885f5f5f5f5f5f	32	plan9	ADCW $0x2211, AX
66151122|3344556677885f5f5f5f5f5f	64	gnu	adc $0x2211,%ax
66151122|3344556677885f5f5f5f5f5f	64	intel	adc ax, 0x2211
66151122|3344556677885f5f5f5f5f5f	64	plan9	ADCW $0x2211, AX
661911|223344556677885f5f5f5f5f5f	32	intel	sbb word ptr [ecx], dx
661911|223344556677885f5f5f5f5f5f	32	plan9	SBBW DX, 0(CX)
661911|223344556677885f5f5f5f5f5f	64	gnu	sbb %dx,(%rcx)
661911|223344556677885f5f5f5f5f5f	64	intel	sbb word ptr [rcx], dx
661911|223344556677885f5f5f5f5f5f	64	plan9	SBBW DX, 0(CX)
661b11|223344556677885f5f5f5f5f5f	32	intel	sbb dx, word ptr [ecx]
661b11|223344556677885f5f5f5f5f5f	32	plan9	SBBW 0(CX), DX
661b11|223344556677885f5f5f5f5f5f	64	gnu	sbb (%rcx),%dx
661b11|223344556677885f5f5f5f5f5f	64	intel	sbb dx, word ptr [rcx]
661b11|223344556677885f5f5f5f5f5f	64	plan9	SBBW 0(CX), DX
661d1122|3344556677885f5f5f5f5f5f	32	intel	sbb ax, 0x2211
661d1122|3344556677885f5f5f5f5f5f	32	plan9	SBBW $0x2211, AX
661d1122|3344556677885f5f5f5f5f5f	64	gnu	sbb $0x2211,%ax
661d1122|3344556677885f5f5f5f5f5f	64	intel	sbb ax, 0x2211
661d1122|3344556677885f5f5f5f5f5f	64	plan9	SBBW $0x2211, AX
662111|223344556677885f5f5f5f5f5f	32	intel	and word ptr [ecx], dx
662111|223344556677885f5f5f5f5f5f	32	plan9	ANDW DX, 0(CX)
662111|223344556677885f5f5f5f5f5f	64	gnu	and %dx,(%rcx)
662111|223344556677885f5f5f5f5f5f	64	intel	and word ptr [rcx], dx
662111|223344556677885f5f5f5f5f5f	64	plan9	ANDW DX, 0(CX)
662311|223344556677885f5f5f5f5f5f	32	intel	and dx, word ptr [ecx]
662311|223344556677885f5f5f5f5f5f	32	plan9	ANDW 0(CX), DX
662311|223344556677885f5f5f5f5f5f	64	gnu	and (%rcx),%dx
662311|223344556677885f5f5f5f5f5f	64	intel	and dx, word ptr [rcx]
662311|223344556677885f5f5f5f5f5f	64	plan9	ANDW 0(CX), DX
66251122|3344556677885f5f5f5f5f5f	32	intel	and ax, 0x2211
66251122|3344556677885f5f5f5f5f5f	32	plan9	ANDW $0x2211, AX
66251122|3344556677885f5f5f5f5f5f	64	gnu	and $0x2211,%ax
66251122|3344556677885f5f5f5f5f5f	64	intel	and ax, 0x2211
66251122|3344556677885f5f5f5f5f5f	64	plan9	ANDW $0x2211, AX
662911|223344556677885f5f5f5f5f5f	32	intel	sub word ptr [ecx], dx
662911|223344556677885f5f5f5f5f5f	32	plan9	SUBW DX, 0(CX)
662911|223344556677885f5f5f5f5f5f	64	gnu	sub %dx,(%rcx)
662911|223344556677885f5f5f5f5f5f	64	intel	sub word ptr [rcx], dx
662911|223344556677885f5f5f5f5f5f	64	plan9	SUBW DX, 0(CX)
662b11|223344556677885f5f5f5f5f5f	32	intel	sub dx, word ptr [ecx]
662b11|223344556677885f5f5f5f5f5f	32	plan9	SUBW 0(CX), DX
662b11|223344556677885f5f5f5f5f5f	64	gnu	sub (%rcx),%dx
662b11|223344556677885f5f5f5f5f5f	64	intel	sub dx, word ptr [rcx]
662b11|223344556677885f5f5f5f5f5f	64	plan9	SUBW 0(CX), DX
662d1122|3344556677885f5f5f5f5f5f	32	intel	sub ax, 0x2211
662d1122|3344556677885f5f5f5f5f5f	32	plan9	SUBW $0x2211, AX
662d1122|3344556677885f5f5f5f5f5f	64	gnu	sub $0x2211,%ax
662d1122|3344556677885f5f5f5f5f5f	64	intel	sub ax, 0x2211
662d1122|3344556677885f5f5f5f5f5f	64	plan9	SUBW $0x2211, AX
663111|223344556677885f5f5f5f5f5f	32	intel	xor word ptr [ecx], dx
663111|223344556677885f5f5f5f5f5f	32	plan9	XORW DX, 0(CX)
663111|223344556677885f5f5f5f5f5f	64	gnu	xor %dx,(%rcx)
663111|223344556677885f5f5f5f5f5f	64	intel	xor word ptr [rcx], dx
663111|223344556677885f5f5f5f5f5f	64	plan9	XORW DX, 0(CX)
663311|223344556677885f5f5f5f5f5f	32	intel	xor dx, word ptr [ecx]
663311|223344556677885f5f5f5f5f5f	32	plan9	XORW 0(CX), DX
663311|223344556677885f5f5f5f5f5f	64	gnu	xor (%rcx),%dx
663311|223344556677885f5f5f5f5f5f	64	intel	xor dx, word ptr [rcx]
663311|223344556677885f5f5f5f5f5f	64	plan9	XORW 0(CX), DX
66351122|3344556677885f5f5f5f5f5f	32	intel	xor ax, 0x2211
66351122|3344556677885f5f5f5f5f5f	32	plan9	XORW $0x2211, AX
66351122|3344556677885f5f5f5f5f5f	64	gnu	xor $0x2211,%ax
66351122|3344556677885f5f5f5f5f5f	64	intel	xor ax, 0x2211
66351122|3344556677885f5f5f5f5f5f	64	plan9	XORW $0x2211, AX
663911|223344556677885f5f5f5f5f5f	32	intel	cmp word ptr [ecx], dx
663911|223344556677885f5f5f5f5f5f	32	plan9	CMPW DX, 0(CX)
663911|223344556677885f5f5f5f5f5f	64	gnu	cmp %dx,(%rcx)
663911|223344556677885f5f5f5f5f5f	64	intel	cmp word ptr [rcx], dx
663911|223344556677885f5f5f5f5f5f	64	plan9	CMPW DX, 0(CX)
663b11|223344556677885f5f5f5f5f5f	32	intel	cmp dx, word ptr [ecx]
663b11|223344556677885f5f5f5f5f5f	32	plan9	CMPW 0(CX), DX
663b11|223344556677885f5f5f5f5f5f	64	gnu	cmp (%rcx),%dx
663b11|223344556677885f5f5f5f5f5f	64	intel	cmp dx, word ptr [rcx]
663b11|223344556677885f5f5f5f5f5f	64	plan9	CMPW 0(CX), DX
663d1122|3344556677885f5f5f5f5f5f	32	intel	cmp ax, 0x2211
663d1122|3344556677885f5f5f5f5f5f	32	plan9	CMPW $0x2211, AX
663d1122|3344556677885f5f5f5f5f5f	64	gnu	cmp $0x2211,%ax
663d1122|3344556677885f5f5f5f5f5f	64	intel	cmp ax, 0x2211
663d1122|3344556677885f5f5f5f5f5f	64	plan9	CMPW $0x2211, AX
6640|11223344556677885f5f5f5f5f5f	32	intel	inc ax
6640|11223344556677885f5f5f5f5f5f	32	plan9	INCW AX
66480f3a161122|3344556677885f5f5f	64	gnu	pextrq $0x22,%xmm2,(%rcx)
66480f3a161122|3344556677885f5f5f	64	intel	pextrq qword ptr [rcx], xmm2, 0x22
66480f3a161122|3344556677885f5f5f	64	plan9	PEXTRQ $0x22, X2, 0(CX)
66480f3a221122|3344556677885f5f5f	64	gnu	pinsrq $0x22,(%rcx),%xmm2
66480f3a221122|3344556677885f5f5f	64	intel	pinsrq xmm2, qword ptr [rcx], 0x22
66480f3a221122|3344556677885f5f5f	64	plan9	PINSRQ $0x22, 0(CX), X2
66480f6e11|223344556677885f5f5f5f	64	gnu	movq (%rcx),%xmm2
66480f6e11|223344556677885f5f5f5f	64	intel	movq xmm2, qword ptr [rcx]
66480f6e11|223344556677885f5f5f5f	64	plan9	MOVQ 0(CX), X2
66480f7e11|223344556677885f5f5f5f	64	gnu	movq %xmm2,(%rcx)
66480f7e11|223344556677885f5f5f5f	64	intel	movq qword ptr [rcx], xmm2
66480f7e11|223344556677885f5f5f5f	64	plan9	MOVQ X2, 0(CX)
6648|0f3a1611223344556677885f5f5f	32	intel	dec ax
6648|0f3a1611223344556677885f5f5f	32	plan9	DECW AX
6650|11223344556677885f5f5f5f5f5f	32	intel	push ax
6650|11223344556677885f5f5f5f5f5f	32	plan9	PUSHW AX
6650|11223344556677885f5f5f5f5f5f	64	gnu	push %ax
6650|11223344556677885f5f5f5f5f5f	64	intel	push ax
6650|11223344556677885f5f5f5f5f5f	64	plan9	PUSHW AX
6658|11223344556677885f5f5f5f5f5f	32	intel	pop ax
6658|11223344556677885f5f5f5f5f5f	32	plan9	POPW AX
6658|11223344556677885f5f5f5f5f5f	64	gnu	pop %ax
6658|11223344556677885f5f5f5f5f5f	64	intel	pop ax
6658|11223344556677885f5f5f5f5f5f	64	plan9	POPW AX
6660|11223344556677885f5f5f5f5f5f	32	intel	data16 pusha
6660|11223344556677885f5f5f5f5f5f	32	plan9	PUSHAW
6661|11223344556677885f5f5f5f5f5f	32	intel	data16 popa
6661|11223344556677885f5f5f5f5f5f	32	plan9	POPAW
666211|223344556677885f5f5f5f5f5f	32	intel	bound dx, qword ptr [ecx]
666211|223344556677885f5f5f5f5f5f	32	plan9	BOUND 0(CX), DX
666311|223344556677885f5f5f5f5f5f	64	gnu	movsxd (%rcx),%dx
666311|223344556677885f5f5f5f5f5f	64	intel	movsxd dx, dword ptr [rcx]
666311|223344556677885f5f5f5f5f5f	64	plan9	MOVSXD 0(CX), DX
66681122|3344556677885f5f5f5f5f5f	32	intel	push 0x2211
66681122|3344556677885f5f5f5f5f5f	32	plan9	PUSHW $0x2211
66681122|3344556677885f5f5f5f5f5f	64	gnu	pushw $0x2211
66681122|3344556677885f5f5f5f5f5f	64	intel	push 0x2211
66681122|3344556677885f5f5f5f5f5f	64	plan9	PUSHW $0x2211
6669112233|44556677885f5f5f5f5f5f	32	intel	imul dx, word ptr [ecx], 0x3322
6669112233|44556677885f5f5f5f5f5f	32	plan9	IMULW $0x3322, 0(CX), DX
6669112233|44556677885f5f5f5f5f5f	64	gnu	imul $0x3322,(%rcx),%dx
6669112233|44556677885f5f5f5f5f5f	64	intel	imul dx, word ptr [rcx], 0x3322
6669112233|44556677885f5f5f5f5f5f	64	plan9	IMULW $0x3322, 0(CX), DX
666b1122|3344556677885f5f5f5f5f5f	32	intel	imul dx, word ptr [ecx], 0x22
666b1122|3344556677885f5f5f5f5f5f	32	plan9	IMULW $0x22, 0(CX), DX
666b1122|3344556677885f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%dx
666b1122|3344556677885f5f5f5f5f5f	64	intel	imul dx, word ptr [rcx], 0x22
666b1122|3344556677885f5f5f5f5f5f	64	plan9	IMULW $0x22, 0(CX), DX
666d|11223344556677885f5f5f5f5f5f	32	intel	data16 insw
666d|11223344556677885f5f5f5f5f5f	32	plan9	INSW DX, ES:0(DI)
666d|11223344556677885f5f5f5f5f5f	64	gnu	insw (%dx),%es:(%rdi)
666d|11223344556677885f5f5f5f5f5f	64	intel	data16 insw
666d|11223344556677885f5f5f5f5f5f	64	plan9	INSW DX, ES:0(DI)
666f|11223344556677885f5f5f5f5f5f	32	intel	data16 outsw
666f|11223344556677885f5f5f5f5f5f	32	plan9	OUTSW DS:0(SI), DX
666f|11223344556677885f5f5f5f5f5f	64	gnu	outsw %ds:(%rsi),(%dx)
666f|11223344556677885f5f5f5f5f5f	64	intel	data16 outsw
666f|11223344556677885f5f5f5f5f5f	64	plan9	OUTSW DS:0(SI), DX
6681001122|3344556677885f5f5f5f5f	32	intel	add word ptr [eax], 0x2211
6681001122|3344556677885f5f5f5f5f	32	plan9	ADDW $0x2211, 0(AX)
6681001122|3344556677885f5f5f5f5f	64	gnu	addw $0x2211,(%rax)
6681001122|3344556677885f5f5f5f5f	64	intel	add word ptr [rax], 0x2211
6681001122|3344556677885f5f5f5f5f	64	plan9	ADDW $0x2211, 0(AX)
6681081122|3344556677885f5f5f5f5f	32	intel	or word ptr [eax], 0x2211
6681081122|3344556677885f5f5f5f5f	32	plan9	ORW $0x2211, 0(AX)
6681081122|3344556677885f5f5f5f5f	64	gnu	orw $0x2211,(%rax)
6681081122|3344556677885f5f5f5f5f	64	intel	or word ptr [rax], 0x2211
6681081122|3344556677885f5f5f5f5f	64	plan9	ORW $0x2211, 0(AX)
6681112233|44556677885f5f5f5f5f5f	32	intel	adc word ptr [ecx], 0x3322
6681112233|44556677885f5f5f5f5f5f	32	plan9	ADCW $0x3322, 0(CX)
6681112233|44556677885f5f5f5f5f5f	64	gnu	adcw $0x3322,(%rcx)
6681112233|44556677885f5f5f5f5f5f	64	intel	adc word ptr [rcx], 0x3322
6681112233|44556677885f5f5f5f5f5f	64	plan9	ADCW $0x3322, 0(CX)
6681181122|3344556677885f5f5f5f5f	32	intel	sbb word ptr [eax], 0x2211
6681181122|3344556677885f5f5f5f5f	32	plan9	SBBW $0x2211, 0(AX)
6681181122|3344556677885f5f5f5f5f	64	gnu	sbbw $0x2211,(%rax)
6681181122|3344556677885f5f5f5f5f	64	intel	sbb word ptr [rax], 0x2211
6681181122|3344556677885f5f5f5f5f	64	plan9	SBBW $0x2211, 0(AX)
6681201122|3344556677885f5f5f5f5f	32	intel	and word ptr [eax], 0x2211
6681201122|3344556677885f5f5f5f5f	32	plan9	ANDW $0x2211, 0(AX)
6681201122|3344556677885f5f5f5f5f	64	gnu	andw $0x2211,(%rax)
6681201122|3344556677885f5f5f5f5f	64	intel	and word ptr [rax], 0x2211
6681201122|3344556677885f5f5f5f5f	64	plan9	ANDW $0x2211, 0(AX)
6681281122|3344556677885f5f5f5f5f	32	intel	sub word ptr [eax], 0x2211
6681281122|3344556677885f5f5f5f5f	32	plan9	SUBW $0x2211, 0(AX)
6681281122|3344556677885f5f5f5f5f	64	gnu	subw $0x2211,(%rax)
6681281122|3344556677885f5f5f5f5f	64	intel	sub word ptr [rax], 0x2211
6681281122|3344556677885f5f5f5f5f	64	plan9	SUBW $0x2211, 0(AX)
6681301122|3344556677885f5f5f5f5f	32	intel	xor word ptr [eax], 0x2211
6681301122|3344556677885f5f5f5f5f	32	plan9	XORW $0x2211, 0(AX)
6681301122|3344556677885f5f5f5f5f	64	gnu	xorw $0x2211,(%rax)
6681301122|3344556677885f5f5f5f5f	64	intel	xor word ptr [rax], 0x2211
6681301122|3344556677885f5f5f5f5f	64	plan9	XORW $0x2211, 0(AX)
6681381122|3344556677885f5f5f5f5f	32	intel	cmp word ptr [eax], 0x2211
6681381122|3344556677885f5f5f5f5f	32	plan9	CMPW $0x2211, 0(AX)
6681381122|3344556677885f5f5f5f5f	64	gnu	cmpw $0x2211,(%rax)
6681381122|3344556677885f5f5f5f5f	64	intel	cmp word ptr [rax], 0x2211
6681381122|3344556677885f5f5f5f5f	64	plan9	CMPW $0x2211, 0(AX)
66830011|223344556677885f5f5f5f5f	32	intel	add word ptr [eax], 0x11
66830011|223344556677885f5f5f5f5f	32	plan9	ADDW $0x11, 0(AX)
66830011|223344556677885f5f5f5f5f	64	gnu	addw $0x11,(%rax)
66830011|223344556677885f5f5f5f5f	64	intel	add word ptr [rax], 0x11
66830011|223344556677885f5f5f5f5f	64	plan9	ADDW $0x11, 0(AX)
66830811|223344556677885f5f5f5f5f	32	intel	or word ptr [eax], 0x11
66830811|223344556677885f5f5f5f5f	32	plan9	ORW $0x11, 0(AX)
66830811|223344556677885f5f5f5f5f	64	gnu	orw $0x11,(%rax)
66830811|223344556677885f5f5f5f5f	64	intel	or word ptr [rax], 0x11
66830811|223344556677885f5f5f5f5f	64	plan9	ORW $0x11, 0(AX)
66831122|3344556677885f5f5f5f5f5f	32	intel	adc word ptr [ecx], 0x22
66831122|3344556677885f5f5f5f5f5f	32	plan9	ADCW $0x22, 0(CX)
66831122|3344556677885f5f5f5f5f5f	64	gnu	adcw $0x22,(%rcx)
66831122|3344556677885f5f5f5f5f5f	64	intel	adc word ptr [rcx], 0x22
66831122|3344556677885f5f5f5f5f5f	64	plan9	ADCW $0x22, 0(CX)
66831811|223344556677885f5f5f5f5f	32	intel	sbb word ptr [eax], 0x11
66831811|223344556677885f5f5f5f5f	32	plan9	SBBW $0x11, 0(AX)
66831811|223344556677885f5f5f5f5f	64	gnu	sbbw $0x11,(%rax)
66831811|223344556677885f5f5f5f5f	64	intel	sbb word ptr [rax], 0x11
66831811|223344556677885f5f5f5f5f	64	plan9	SBBW $0x11, 0(AX)
66832011|223344556677885f5f5f5f5f	32	intel	and word ptr [eax], 0x11
66832011|223344556677885f5f5f5f5f	32	plan9	ANDW $0x11, 0(AX)
66832011|223344556677885f5f5f5f5f	64	gnu	andw $0x11,(%rax)
66832011|223344556677885f5f5f5f5f	64	intel	and word ptr [rax], 0x11
66832011|223344556677885f5f5f5f5f	64	plan9	ANDW $0x11, 0(AX)
66832811|223344556677885f5f5f5f5f	32	intel	sub word ptr [eax], 0x11
66832811|223344556677885f5f5f5f5f	32	plan9	SUBW $0x11, 0(AX)
66832811|223344556677885f5f5f5f5f	64	gnu	subw $0x11,(%rax)
66832811|223344556677885f5f5f5f5f	64	intel	sub word ptr [rax], 0x11
66832811|223344556677885f5f5f5f5f	64	plan9	SUBW $0x11, 0(AX)
66833011|223344556677885f5f5f5f5f	32	intel	xor word ptr [eax], 0x11
66833011|223344556677885f5f5f5f5f	32	plan9	XORW $0x11, 0(AX)
66833011|223344556677885f5f5f5f5f	64	gnu	xorw $0x11,(%rax)
66833011|223344556677885f5f5f5f5f	64	intel	xor word ptr [rax], 0x11
66833011|223344556677885f5f5f5f5f	64	plan9	XORW $0x11, 0(AX)
66833811|223344556677885f5f5f5f5f	32	intel	cmp word ptr [eax], 0x11
66833811|223344556677885f5f5f5f5f	32	plan9	CMPW $0x11, 0(AX)
66833811|223344556677885f5f5f5f5f	64	gnu	cmpw $0x11,(%rax)
66833811|223344556677885f5f5f5f5f	64	intel	cmp word ptr [rax], 0x11
66833811|223344556677885f5f5f5f5f	64	plan9	CMPW $0x11, 0(AX)
668511|223344556677885f5f5f5f5f5f	32	intel	test word ptr [ecx], dx
668511|223344556677885f5f5f5f5f5f	32	plan9	TESTW DX, 0(CX)
668511|223344556677885f5f5f5f5f5f	64	gnu	test %dx,(%rcx)
668511|223344556677885f5f5f5f5f5f	64	intel	test word ptr [rcx], dx
668511|223344556677885f5f5f5f5f5f	64	plan9	TESTW DX, 0(CX)
668711|223344556677885f5f5f5f5f5f	32	intel	xchg word ptr [ecx], dx
668711|223344556677885f5f5f5f5f5f	32	plan9	XCHGW DX, 0(CX)
668711|223344556677885f5f5f5f5f5f	64	gnu	xchg %dx,(%rcx)
668711|223344556677885f5f5f5f5f5f	64	intel	xchg word ptr [rcx], dx
668711|223344556677885f5f5f5f5f5f	64	plan9	XCHGW DX, 0(CX)
668911|223344556677885f5f5f5f5f5f	32	intel	mov word ptr [ecx], dx
668911|223344556677885f5f5f5f5f5f	32	plan9	MOVW DX, 0(CX)
668911|223344556677885f5f5f5f5f5f	64	gnu	mov %dx,(%rcx)
668911|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], dx
668911|223344556677885f5f5f5f5f5f	64	plan9	MOVW DX, 0(CX)
668b11|223344556677885f5f5f5f5f5f	32	intel	mov dx, word ptr [ecx]
668b11|223344556677885f5f5f5f5f5f	32	plan9	MOVW 0(CX), DX
668b11|223344556677885f5f5f5f5f5f	64	gnu	mov (%rcx),%dx
668b11|223344556677885f5f5f5f5f5f	64	intel	mov dx, word ptr [rcx]
668b11|223344556677885f5f5f5f5f5f	64	plan9	MOVW 0(CX), DX
668c11|223344556677885f5f5f5f5f5f	32	intel	mov word ptr [ecx], ss
668c11|223344556677885f5f5f5f5f5f	32	plan9	MOVW SS, 0(CX)
668c11|223344556677885f5f5f5f5f5f	64	gnu	data16 mov %ss,(%rcx)
668c11|223344556677885f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
668c11|223344556677885f5f5f5f5f5f	64	plan9	MOVW SS, 0(CX)
668d11|223344556677885f5f5f5f5f5f	32	intel	lea dx, ptr [ecx]
668d11|223344556677885f5f5f5f5f5f	32	plan9	LEAW 0(CX), DX
668d11|223344556677885f5f5f5f5f5f	64	gnu	lea (%rcx),%dx
668d11|223344556677885f5f5f5f5f5f	64	intel	lea dx, ptr [rcx]
668d11|223344556677885f5f5f5f5f5f	64	plan9	LEAW 0(CX), DX
668ec0|11223344556677885f5f5f5f5f	32	intel	mov es, ax
668ec0|11223344556677885f5f5f5f5f	32	plan9	MOVW AX, ES
668ec0|11223344556677885f5f5f5f5f	64	gnu	mov %ax,%es
668ec0|11223344556677885f5f5f5f5f	64	intel	mov es, ax
668ec0|11223344556677885f5f5f5f5f	64	plan9	MOVW AX, ES
668f00|11223344556677885f5f5f5f5f	32	intel	pop word ptr [eax]
668f00|11223344556677885f5f5f5f5f	32	plan9	POPW 0(AX)
668f00|11223344556677885f5f5f5f5f	64	gnu	popw (%rax)
668f00|11223344556677885f5f5f5f5f	64	intel	pop word ptr [rax]
668f00|11223344556677885f5f5f5f5f	64	plan9	POPW 0(AX)
6690|11223344556677885f5f5f5f5f5f	32	plan9	NOPW
6690|11223344556677885f5f5f5f5f5f	64	gnu	data16 nop
6690|11223344556677885f5f5f5f5f5f	64	plan9	NOPW
6698|11223344556677885f5f5f5f5f5f	32	intel	data16 cbw
6698|11223344556677885f5f5f5f5f5f	32	plan9	CBW
6698|11223344556677885f5f5f5f5f5f	64	gnu	cbtw
6698|11223344556677885f5f5f5f5f5f	64	intel	data16 cbw
6698|11223344556677885f5f5f5f5f5f	64	plan9	CBW
6699|11223344556677885f5f5f5f5f5f	32	intel	data16 cwd
6699|11223344556677885f5f5f5f5f5f	32	plan9	CWD
6699|11223344556677885f5f5f5f5f5f	64	gnu	cwtd
6699|11223344556677885f5f5f5f5f5f	64	intel	data16 cwd
6699|11223344556677885f5f5f5f5f5f	64	plan9	CWD
669a11223344|556677885f5f5f5f5f5f	32	intel	call far 0x2211, 0x4433
669a11223344|556677885f5f5f5f5f5f	32	plan9	LCALL $0x2211, $0x4433
669c|11223344556677885f5f5f5f5f5f	32	intel	data16 pushf
669c|11223344556677885f5f5f5f5f5f	32	plan9	PUSHF
669c|11223344556677885f5f5f5f5f5f	64	gnu	pushfw
669c|11223344556677885f5f5f5f5f5f	64	intel	data16 pushf
669c|11223344556677885f5f5f5f5f5f	64	plan9	PUSHF
669d|11223344556677885f5f5f5f5f5f	32	intel	data16 popf
669d|11223344556677885f5f5f5f5f5f	32	plan9	POPF
669d|11223344556677885f5f5f5f5f5f	64	gnu	popfw
669d|11223344556677885f5f5f5f5f5f	64	intel	data16 popf
669d|11223344556677885f5f5f5f5f5f	64	plan9	POPF
66a11122334455667788|5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%ax
66a11122334455667788|5f5f5f5f5f5f	64	intel	mov ax, word ptr [0x8877665544332211]
66a11122334455667788|5f5f5f5f5f5f	64	plan9	MOVW -0x778899aabbccddef, AX
66a111223344|556677885f5f5f5f5f5f	32	intel	mov ax, word ptr [0x44332211]
66a111223344|556677885f5f5f5f5f5f	32	plan9	MOVW 0x44332211, AX
66a31122334455667788|5f5f5f5f5f5f	64	gnu	mov %ax,-0x778899aabbccddef
66a31122334455667788|5f5f5f5f5f5f	64	intel	mov word ptr [0x8877665544332211], ax
66a31122334455667788|5f5f5f5f5f5f	64	plan9	MOVW AX, -0x778899aabbccddef
66a311223344|556677885f5f5f5f5f5f	32	intel	mov word ptr [0x44332211], ax
66a311223344|556677885f5f5f5f5f5f	32	plan9	MOVW AX, 0x44332211
66a5|11223344556677885f5f5f5f5f5f	32	intel	movsw word ptr [edi], word ptr [esi]
66a5|11223344556677885f5f5f5f5f5f	32	plan9	MOVSW DS:0(SI), ES:0(DI)
66a5|11223344556677885f5f5f5f5f5f	64	gnu	movsw %ds:(%rsi),%es:(%rdi)
66a5|11223344556677885f5f5f5f5f5f	64	intel	movsw word ptr [rdi], word ptr [rsi]
66a5|11223344556677885f5f5f5f5f5f	64	plan9	MOVSW DS:0(SI), ES:0(DI)
66a7|11223344556677885f5f5f5f5f5f	32	intel	cmpsw word ptr [esi], word ptr [edi]
66a7|11223344556677885f5f5f5f5f5f	32	plan9	CMPSW ES:0(DI), DS:0(SI)
66a7|11223344556677885f5f5f5f5f5f	64	gnu	cmpsw %es:(%rdi),%ds:(%rsi)
66a7|11223344556677885f5f5f5f5f5f	64	intel	cmpsw word ptr [rsi], word ptr [rdi]
66a7|11223344556677885f5f5f5f5f5f	64	plan9	CMPSW ES:0(DI), DS:0(SI)
66a91122|3344556677885f5f5f5f5f5f	32	intel	test ax, 0x2211
66a91122|3344556677885f5f5f5f5f5f	32	plan9	TESTW $0x2211, AX
66a91122|3344556677885f5f5f5f5f5f	64	gnu	test $0x2211,%ax
66a91122|3344556677885f5f5f5f5f5f	64	intel	test ax, 0x2211
66a91122|3344556677885f5f5f5f5f5f	64	plan9	TESTW $0x2211, AX
66ab|11223344556677885f5f5f5f5f5f	32	intel	stosw word ptr [edi]
66ab|11223344556677885f5f5f5f5f5f	32	plan9	STOSW AX, ES:0(DI)
66ab|11223344556677885f5f5f5f5f5f	64	gnu	stos %ax,%es:(%rdi)
66ab|11223344556677885f5f5f5f5f5f	64	intel	stosw word ptr [rdi]
66ab|11223344556677885f5f5f5f5f5f	64	plan9	STOSW AX, ES:0(DI)
66ad|11223344556677885f5f5f5f5f5f	32	intel	lodsw word ptr [esi]
66ad|11223344556677885f5f5f5f5f5f	32	plan9	LODSW DS:0(SI), AX
66ad|11223344556677885f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%ax
66ad|11223344556677885f5f5f5f5f5f	64	intel	lodsw word ptr [rsi]
66ad|11223344556677885f5f5f5f5f5f	64	plan9	LODSW DS:0(SI), AX
66af|11223344556677885f5f5f5f5f5f	32	intel	scasw word ptr [edi]
66af|11223344556677885f5f5f5f5f5f	32	plan9	SCASW ES:0(DI), AX
66af|11223344556677885f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%ax
66af|11223344556677885f5f5f5f5f5f	64	intel	scasw word ptr [rdi]
66af|11223344556677885f5f5f5f5f5f	64	plan9	SCASW ES:0(DI), AX
66b81122|3344556677885f5f5f5f5f5f	32	intel	mov ax, 0x2211
66b81122|3344556677885f5f5f5f5f5f	32	plan9	MOVW $0x2211, AX
66b81122|3344556677885f5f5f5f5f5f	64	gnu	mov $0x2211,%ax
66b81122|3344556677885f5f5f5f5f5f	64	intel	mov ax, 0x2211
66b81122|3344556677885f5f5f5f5f5f	64	plan9	MOVW $0x2211, AX
66c10011|223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], 0x11
66c10011|223344556677885f5f5f5f5f	32	plan9	ROLW $0x11, 0(AX)
66c10011|223344556677885f5f5f5f5f	64	gnu	rolw $0x11,(%rax)
66c10011|223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], 0x11
66c10011|223344556677885f5f5f5f5f	64	plan9	ROLW $0x11, 0(AX)
66c10811|223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], 0x11
66c10811|223344556677885f5f5f5f5f	32	plan9	RORW $0x11, 0(AX)
66c10811|223344556677885f5f5f5f5f	64	gnu	rorw $0x11,(%rax)
66c10811|223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], 0x11
66c10811|223344556677885f5f5f5f5f	64	plan9	RORW $0x11, 0(AX)
66c11122|3344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], 0x22
66c11122|3344556677885f5f5f5f5f5f	32	plan9	RCLW $0x22, 0(CX)
66c11122|3344556677885f5f5f5f5f5f	64	gnu	rclw $0x22,(%rcx)
66c11122|3344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], 0x22
66c11122|3344556677885f5f5f5f5f5f	64	plan9	RCLW $0x22, 0(CX)
66c11811|223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], 0x11
66c11811|223344556677885f5f5f5f5f	32	plan9	RCRW $0x11, 0(AX)
66c11811|223344556677885f5f5f5f5f	64	gnu	rcrw $0x11,(%rax)
66c11811|223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], 0x11
66c11811|223344556677885f5f5f5f5f	64	plan9	RCRW $0x11, 0(AX)
66c12011|223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], 0x11
66c12011|223344556677885f5f5f5f5f	32	plan9	SHLW $0x11, 0(AX)
66c12011|223344556677885f5f5f5f5f	64	gnu	shlw $0x11,(%rax)
66c12011|223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], 0x11
66c12011|223344556677885f5f5f5f5f	64	plan9	SHLW $0x11, 0(AX)
66c12811|223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], 0x11
66c12811|223344556677885f5f5f5f5f	32	plan9	SHRW $0x11, 0(AX)
66c12811|223344556677885f5f5f5f5f	64	gnu	shrw $0x11,(%rax)
66c12811|223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], 0x11
66c12811|223344556677885f5f5f5f5f	64	plan9	SHRW $0x11, 0(AX)
66c13811|223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], 0x11
66c13811|223344556677885f5f5f5f5f	32	plan9	SARW $0x11, 0(AX)
66c13811|223344556677885f5f5f5f5f	64	gnu	sarw $0x11,(%rax)
66c13811|223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], 0x11
66c13811|223344556677885f5f5f5f5f	64	plan9	SARW $0x11, 0(AX)
66c21122|3344556677885f5f5f5f5f5f	32	intel	ret 0x2211
66c21122|3344556677885f5f5f5f5f5f	32	plan9	RET $0x2211
66c21122|3344556677885f5f5f5f5f5f	64	gnu	retw $0x2211
66c21122|3344556677885f5f5f5f5f5f	64	intel	ret 0x2211
66c21122|3344556677885f5f5f5f5f5f	64	plan9	RET $0x2211
66c411|223344556677885f5f5f5f5f5f	32	intel	les dx, dword ptr [ecx]
66c411|223344556677885f5f5f5f5f5f	32	plan9	LES 0(CX), DX
66c511|223344556677885f5f5f5f5f5f	32	intel	lds dx, dword ptr [ecx]
66c511|223344556677885f5f5f5f5f5f	32	plan9	LDS 0(CX), DX
66c7001122|3344556677885f5f5f5f5f	32	intel	mov word ptr [eax], 0x2211
66c7001122|3344556677885f5f5f5f5f	32	plan9	MOVW $0x2211, 0(AX)
66c7001122|3344556677885f5f5f5f5f	64	gnu	movw $0x2211,(%rax)
66c7001122|3344556677885f5f5f5f5f	64	intel	mov word ptr [rax], 0x2211
66c7001122|3344556677885f5f5f5f5f	64	plan9	MOVW $0x2211, 0(AX)
66c7f81122|3344556677885f5f5f5f5f	32	intel	xbegin .+0x2211
66c7f81122|3344556677885f5f5f5f5f	32	plan9	XBEGIN .+8721
66c7f81122|3344556677885f5f5f5f5f	64	gnu	xbeginw .+0x2211
66c7f81122|3344556677885f5f5f5f5f	64	intel	xbegin .+0x2211
66c7f81122|3344556677885f5f5f5f5f	64	plan9	XBEGIN .+8721
66c9|11223344556677885f5f5f5f5f5f	32	intel	data16 leave
66c9|11223344556677885f5f5f5f5f5f	32	plan9	LEAVE
66c9|11223344556677885f5f5f5f5f5f	64	gnu	leavew
66c9|11223344556677885f5f5f5f5f5f	64	intel	data16 leave
66c9|11223344556677885f5f5f5f5f5f	64	plan9	LEAVE
66cf|11223344556677885f5f5f5f5f5f	32	intel	data16 iret
66cf|11223344556677885f5f5f5f5f5f	32	plan9	IRET
66cf|11223344556677885f5f5f5f5f5f	64	gnu	iretw
66cf|11223344556677885f5f5f5f5f5f	64	intel	data16 iret
66cf|11223344556677885f5f5f5f5f5f	64	plan9	IRET
66d100|11223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], 0x1
66d100|11223344556677885f5f5f5f5f	32	plan9	ROLW $0x1, 0(AX)
66d100|11223344556677885f5f5f5f5f	64	gnu	rolw (%rax)
66d100|11223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], 0x1
66d100|11223344556677885f5f5f5f5f	64	plan9	ROLW $0x1, 0(AX)
66d108|11223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], 0x1
66d108|11223344556677885f5f5f5f5f	32	plan9	RORW $0x1, 0(AX)
66d108|11223344556677885f5f5f5f5f	64	gnu	rorw (%rax)
66d108|11223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], 0x1
66d108|11223344556677885f5f5f5f5f	64	plan9	RORW $0x1, 0(AX)
66d111|223344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], 0x1
66d111|223344556677885f5f5f5f5f5f	32	plan9	RCLW $0x1, 0(CX)
66d111|223344556677885f5f5f5f5f5f	64	gnu	rclw (%rcx)
66d111|223344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], 0x1
66d111|223344556677885f5f5f5f5f5f	64	plan9	RCLW $0x1, 0(CX)
66d118|11223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], 0x1
66d118|11223344556677885f5f5f5f5f	32	plan9	RCRW $0x1, 0(AX)
66d118|11223344556677885f5f5f5f5f	64	gnu	rcrw (%rax)
66d118|11223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], 0x1
66d118|11223344556677885f5f5f5f5f	64	plan9	RCRW $0x1, 0(AX)
66d120|11223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], 0x1
66d120|11223344556677885f5f5f5f5f	32	plan9	SHLW $0x1, 0(AX)
66d120|11223344556677885f5f5f5f5f	64	gnu	shlw (%rax)
66d120|11223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], 0x1
66d120|11223344556677885f5f5f5f5f	64	plan9	SHLW $0x1, 0(AX)
66d128|11223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], 0x1
66d128|11223344556677885f5f5f5f5f	32	plan9	SHRW $0x1, 0(AX)
66d128|11223344556677885f5f5f5f5f	64	gnu	shrw (%rax)
66d128|11223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], 0x1
66d128|11223344556677885f5f5f5f5f	64	plan9	SHRW $0x1, 0(AX)
66d138|11223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], 0x1
66d138|11223344556677885f5f5f5f5f	32	plan9	SARW $0x1, 0(AX)
66d138|11223344556677885f5f5f5f5f	64	gnu	sarw (%rax)
66d138|11223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], 0x1
66d138|11223344556677885f5f5f5f5f	64	plan9	SARW $0x1, 0(AX)
66d300|11223344556677885f5f5f5f5f	32	intel	rol word ptr [eax], cl
66d300|11223344556677885f5f5f5f5f	32	plan9	ROLW CL, 0(AX)
66d300|11223344556677885f5f5f5f5f	64	gnu	rolw %cl,(%rax)
66d300|11223344556677885f5f5f5f5f	64	intel	rol word ptr [rax], cl
66d300|11223344556677885f5f5f5f5f	64	plan9	ROLW CL, 0(AX)
66d308|11223344556677885f5f5f5f5f	32	intel	ror word ptr [eax], cl
66d308|11223344556677885f5f5f5f5f	32	plan9	RORW CL, 0(AX)
66d308|11223344556677885f5f5f5f5f	64	gnu	rorw %cl,(%rax)
66d308|11223344556677885f5f5f5f5f	64	intel	ror word ptr [rax], cl
66d308|11223344556677885f5f5f5f5f	64	plan9	RORW CL, 0(AX)
66d311|223344556677885f5f5f5f5f5f	32	intel	rcl word ptr [ecx], cl
66d311|223344556677885f5f5f5f5f5f	32	plan9	RCLW CL, 0(CX)
66d311|223344556677885f5f5f5f5f5f	64	gnu	rclw %cl,(%rcx)
66d311|223344556677885f5f5f5f5f5f	64	intel	rcl word ptr [rcx], cl
66d311|223344556677885f5f5f5f5f5f	64	plan9	RCLW CL, 0(CX)
66d318|11223344556677885f5f5f5f5f	32	intel	rcr word ptr [eax], cl
66d318|11223344556677885f5f5f5f5f	32	plan9	RCRW CL, 0(AX)
66d318|11223344556677885f5f5f5f5f	64	gnu	rcrw %cl,(%rax)
66d318|11223344556677885f5f5f5f5f	64	intel	rcr word ptr [rax], cl
66d318|11223344556677885f5f5f5f5f	64	plan9	RCRW CL, 0(AX)
66d320|11223344556677885f5f5f5f5f	32	intel	shl word ptr [eax], cl
66d320|11223344556677885f5f5f5f5f	32	plan9	SHLW CL, 0(AX)
66d320|11223344556677885f5f5f5f5f	64	gnu	shlw %cl,(%rax)
66d320|11223344556677885f5f5f5f5f	64	intel	shl word ptr [rax], cl
66d320|11223344556677885f5f5f5f5f	64	plan9	SHLW CL, 0(AX)
66d328|11223344556677885f5f5f5f5f	32	intel	shr word ptr [eax], cl
66d328|11223344556677885f5f5f5f5f	32	plan9	SHRW CL, 0(AX)
66d328|11223344556677885f5f5f5f5f	64	gnu	shrw %cl,(%rax)
66d328|11223344556677885f5f5f5f5f	64	intel	shr word ptr [rax], cl
66d328|11223344556677885f5f5f5f5f	64	plan9	SHRW CL, 0(AX)
66d338|11223344556677885f5f5f5f5f	32	intel	sar word ptr [eax], cl
66d338|11223344556677885f5f5f5f5f	32	plan9	SARW CL, 0(AX)
66d338|11223344556677885f5f5f5f5f	64	gnu	sarw %cl,(%rax)
66d338|11223344556677885f5f5f5f5f	64	intel	sar word ptr [rax], cl
66d338|11223344556677885f5f5f5f5f	64	plan9	SARW CL, 0(AX)
66d411|223344556677885f5f5f5f5f5f	32	intel	aam 0x11
66d411|223344556677885f5f5f5f5f5f	32	plan9	AAM $0x11
66d920|11223344556677885f5f5f5f5f	32	intel	fldenv ptr [eax]
66d920|11223344556677885f5f5f5f5f	32	plan9	FLDENVW 0(AX)
66d920|11223344556677885f5f5f5f5f	64	gnu	fldenvs (%rax)
66d920|11223344556677885f5f5f5f5f	64	intel	fldenv ptr [rax]
66d920|11223344556677885f5f5f5f5f	64	plan9	FLDENVW 0(AX)
66e511|223344556677885f5f5f5f5f5f	32	intel	in ax, 0x11
66e511|223344556677885f5f5f5f5f5f	32	plan9	INW $0x11, AX
66e511|223344556677885f5f5f5f5f5f	64	gnu	in $0x11,%ax
66e511|223344556677885f5f5f5f5f5f	64	intel	in ax, 0x11
66e511|223344556677885f5f5f5f5f5f	64	plan9	INW $0x11, AX
66e711|223344556677885f5f5f5f5f5f	32	intel	out 0x11, ax
66e711|223344556677885f5f5f5f5f5f	32	plan9	OUTW AX, $0x11
66e711|223344556677885f5f5f5f5f5f	64	gnu	out %ax,$0x11
66e711|223344556677885f5f5f5f5f5f	64	intel	out 0x11, ax
66e711|223344556677885f5f5f5f5f5f	64	plan9	OUTW AX, $0x11
66e811223344|556677885f5f5f5f5f5f	64	gnu	callw .+0x44332211
66e811223344|556677885f5f5f5f5f5f	64	intel	call .+0x44332211
66e811223344|556677885f5f5f5f5f5f	64	plan9	CALL .+1144201745
66e81122|3344556677885f5f5f5f5f5f	32	intel	call .+0x2211
66e81122|3344556677885f5f5f5f5f5f	32	plan9	CALL .+8721
66e911223344|556677885f5f5f5f5f5f	64	gnu	jmpw .+0x44332211
66e911223344|556677885f5f5f5f5f5f	64	intel	jmp .+0x44332211
66e911223344|556677885f5f5f5f5f5f	64	plan9	JMP .+1144201745
66e91122|3344556677885f5f5f5f5f5f	32	intel	jmp .+0x2211
66e91122|3344556677885f5f5f5f5f5f	32	plan9	JMP .+8721
66ea11223344|556677885f5f5f5f5f5f	32	intel	jmp far 0x2211, 0x4433
66ea11223344|556677885f5f5f5f5f5f	32	plan9	LJMP $0x2211, $0x4433
66ed|11223344556677885f5f5f5f5f5f	32	intel	in ax, dx
66ed|11223344556677885f5f5f5f5f5f	32	plan9	INW DX, AX
66ed|11223344556677885f5f5f5f5f5f	64	gnu	in (%dx),%ax
66ed|11223344556677885f5f5f5f5f5f	64	intel	in ax, dx
66ed|11223344556677885f5f5f5f5f5f	64	plan9	INW DX, AX
66ef|11223344556677885f5f5f5f5f5f	32	intel	out dx, ax
66ef|11223344556677885f5f5f5f5f5f	32	plan9	OUTW AX, DX
66ef|11223344556677885f5f5f5f5f5f	64	gnu	out %ax,(%dx)
66ef|11223344556677885f5f5f5f5f5f	64	intel	out dx, ax
66ef|11223344556677885f5f5f5f5f5f	64	plan9	OUTW AX, DX
66f20f2a11|223344556677885f5f5f5f	32	intel	cvtsi2sd xmm2, dword ptr [ecx]
66f20f2a11|223344556677885f5f5f5f	32	plan9	REPNE CVTSI2SDW 0(CX), X2
66f20f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2sdl (%rcx),%xmm2
66f20f2a11|223344556677885f5f5f5f	64	intel	cvtsi2sd xmm2, dword ptr [rcx]
66f20f2a11|223344556677885f5f5f5f	64	plan9	REPNE CVTSI2SDW 0(CX), X2
66f20f2c11|223344556677885f5f5f5f	32	intel	cvttsd2si edx, qword ptr [ecx]
66f20f2c11|223344556677885f5f5f5f	32	plan9	REPNE CVTTSD2SIW 0(CX), DX
66f20f2c11|223344556677885f5f5f5f	64	gnu	cvttsd2si (%rcx),%dx
66f20f2c11|223344556677885f5f5f5f	64	intel	cvttsd2si edx, qword ptr [rcx]
66f20f2c11|223344556677885f5f5f5f	64	plan9	REPNE CVTTSD2SIW 0(CX), DX
66f20f2d11|223344556677885f5f5f5f	32	intel	cvtsd2si edx, qword ptr [ecx]
66f20f2d11|223344556677885f5f5f5f	32	plan9	REPNE CVTSD2SIW 0(CX), DX
66f20f2d11|223344556677885f5f5f5f	64	gnu	cvtsd2si (%rcx),%dx
66f20f2d11|223344556677885f5f5f5f	64	intel	cvtsd2si edx, qword ptr [rcx]
66f20f2d11|223344556677885f5f5f5f	64	plan9	REPNE CVTSD2SIW 0(CX), DX
66f20f38f011|223344556677885f5f5f	32	intel	crc32 edx, byte ptr [ecx]
66f20f38f011|223344556677885f5f5f	32	plan9	REPNE CRC32 0(CX), DX
66f20f38f011|223344556677885f5f5f	64	gnu	crc32b (%rcx),%edx
66f20f38f011|223344556677885f5f5f	64	intel	crc32 edx, byte ptr [rcx]
66f20f38f011|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
66f30f2c11|223344556677885f5f5f5f	32	intel	cvttss2si edx, dword ptr [ecx]
66f30f2c11|223344556677885f5f5f5f	32	plan9	REP CVTTSS2SIW 0(CX), DX
66f30f2c11|223344556677885f5f5f5f	64	gnu	cvttss2si (%rcx),%dx
66f30f2c11|223344556677885f5f5f5f	64	intel	cvttss2si edx, dword ptr [rcx]
66f30f2c11|223344556677885f5f5f5f	64	plan9	REP CVTTSS2SIW 0(CX), DX
66f30f2d11|223344556677885f5f5f5f	32	intel	cvtss2si edx, dword ptr [ecx]
66f30f2d11|223344556677885f5f5f5f	32	plan9	REP CVTSS2SIW 0(CX), DX
66f30f2d11|223344556677885f5f5f5f	64	gnu	cvtss2si (%rcx),%dx
66f30f2d11|223344556677885f5f5f5f	64	intel	cvtss2si edx, dword ptr [rcx]
66f30f2d11|223344556677885f5f5f5f	64	plan9	REP CVTSS2SIW 0(CX), DX
66f30fae11|223344556677885f5f5f5f	64	gnu	wrfsbasel (%rcx)
66f30fae11|223344556677885f5f5f5f	64	intel	wrfsbase dword ptr [rcx]
66f30fae11|223344556677885f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
66f30fae18|11223344556677885f5f5f	64	gnu	wrgsbasel (%rax)
66f30fae18|11223344556677885f5f5f	64	intel	wrgsbase dword ptr [rax]
66f30fae18|11223344556677885f5f5f	64	plan9	REP WRGSBASE 0(AX)
66f30faec0|11223344556677885f5f5f	64	gnu	rdfsbase %eax
66f30faec0|11223344556677885f5f5f	64	intel	rdfsbase eax
66f30faec0|11223344556677885f5f5f	64	plan9	REP RDFSBASE AX
66f30faec8|11223344556677885f5f5f	64	gnu	rdgsbase %eax
66f30faec8|11223344556677885f5f5f	64	intel	rdgsbase eax
66f30faec8|11223344556677885f5f5f	64	plan9	REP RDGSBASE AX
66f30fd6c5|11223344556677885f5f5f	32	intel	movq2dq xmm0, mmx5
66f30fd6c5|11223344556677885f5f5f	32	plan9	REP MOVQ2DQ M5, X0
66f30fd6c5|11223344556677885f5f5f	64	gnu	movq2dq %mm5,%xmm0
66f30fd6c5|11223344556677885f5f5f	64	intel	movq2dq xmm0, mmx5
66f30fd6c5|11223344556677885f5f5f	64	plan9	REP MOVQ2DQ M5, X0
66f7001122|3344556677885f5f5f5f5f	32	intel	test word ptr [eax], 0x2211
66f7001122|3344556677885f5f5f5f5f	32	plan9	TESTW $0x2211, 0(AX)
66f7001122|3344556677885f5f5f5f5f	64	gnu	testw $0x2211,(%rax)
66f7001122|3344556677885f5f5f5f5f	64	intel	test word ptr [rax], 0x2211
66f7001122|3344556677885f5f5f5f5f	64	plan9	TESTW $0x2211, 0(AX)
66f711|223344556677885f5f5f5f5f5f	32	intel	not word ptr [ecx]
66f711|223344556677885f5f5f5f5f5f	32	plan9	NOTW 0(CX)
66f711|223344556677885f5f5f5f5f5f	64	gnu	notw (%rcx)
66f711|223344556677885f5f5f5f5f5f	64	intel	not word ptr [rcx]
66f711|223344556677885f5f5f5f5f5f	64	plan9	NOTW 0(CX)
66f718|11223344556677885f5f5f5f5f	32	intel	neg word ptr [eax]
66f718|11223344556677885f5f5f5f5f	32	plan9	NEGW 0(AX)
66f718|11223344556677885f5f5f5f5f	64	gnu	negw (%rax)
66f718|11223344556677885f5f5f5f5f	64	intel	neg word ptr [rax]
66f718|11223344556677885f5f5f5f5f	64	plan9	NEGW 0(AX)
66f720|11223344556677885f5f5f5f5f	32	intel	mul word ptr [eax]
66f720|11223344556677885f5f5f5f5f	32	plan9	MULW 0(AX)
66f720|11223344556677885f5f5f5f5f	64	gnu	mulw (%rax)
66f720|11223344556677885f5f5f5f5f	64	intel	mul word ptr [rax]
66f720|11223344556677885f5f5f5f5f	64	plan9	MULW 0(AX)
66f728|11223344556677885f5f5f5f5f	32	intel	imul word ptr [eax]
66f728|11223344556677885f5f5f5f5f	32	plan9	IMULW 0(AX)
66f728|11223344556677885f5f5f5f5f	64	gnu	imulw (%rax)
66f728|11223344556677885f5f5f5f5f	64	intel	imul word ptr [rax]
66f728|11223344556677885f5f5f5f5f	64	plan9	IMULW 0(AX)
66f730|11223344556677885f5f5f5f5f	32	intel	div word ptr [eax]
66f730|11223344556677885f5f5f5f5f	32	plan9	DIVW 0(AX)
66f730|11223344556677885f5f5f5f5f	64	gnu	divw (%rax)
66f730|11223344556677885f5f5f5f5f	64	intel	div word ptr [rax]
66f730|11223344556677885f5f5f5f5f	64	plan9	DIVW 0(AX)
66f738|11223344556677885f5f5f5f5f	32	intel	idiv word ptr [eax]
66f738|11223344556677885f5f5f5f5f	32	plan9	IDIVW 0(AX)
66f738|11223344556677885f5f5f5f5f	64	gnu	idivw (%rax)
66f738|11223344556677885f5f5f5f5f	64	intel	idiv word ptr [rax]
66f738|11223344556677885f5f5f5f5f	64	plan9	IDIVW 0(AX)
66ff00|11223344556677885f5f5f5f5f	32	intel	inc word ptr [eax]
66ff00|11223344556677885f5f5f5f5f	32	plan9	INCW 0(AX)
66ff00|11223344556677885f5f5f5f5f	64	gnu	incw (%rax)
66ff00|11223344556677885f5f5f5f5f	64	intel	inc word ptr [rax]
66ff00|11223344556677885f5f5f5f5f	64	plan9	INCW 0(AX)
66ff08|11223344556677885f5f5f5f5f	32	intel	dec word ptr [eax]
66ff08|11223344556677885f5f5f5f5f	32	plan9	DECW 0(AX)
66ff08|11223344556677885f5f5f5f5f	64	gnu	decw (%rax)
66ff08|11223344556677885f5f5f5f5f	64	intel	dec word ptr [rax]
66ff08|11223344556677885f5f5f5f5f	64	plan9	DECW 0(AX)
66ff11|223344556677885f5f5f5f5f5f	32	intel	call word ptr [ecx]
66ff11|223344556677885f5f5f5f5f5f	32	plan9	CALL 0(CX)
66ff11|223344556677885f5f5f5f5f5f	64	gnu	callw *(%rcx)
66ff11|223344556677885f5f5f5f5f5f	64	intel	call qword ptr [rcx]
66ff11|223344556677885f5f5f5f5f5f	64	plan9	CALL 0(CX)
66ff18|11223344556677885f5f5f5f5f	32	intel	call far dword ptr [eax]
66ff18|11223344556677885f5f5f5f5f	32	plan9	LCALL 0(AX)
66ff18|11223344556677885f5f5f5f5f	64	gnu	lcallw *(%rax)
66ff18|11223344556677885f5f5f5f5f	64	intel	call far dword ptr [rax]
66ff18|11223344556677885f5f5f5f5f	64	plan9	LCALL 0(AX)
66ff20|11223344556677885f5f5f5f5f	32	intel	jmp word ptr [eax]
66ff20|11223344556677885f5f5f5f5f	32	plan9	JMP 0(AX)
66ff20|11223344556677885f5f5f5f5f	64	gnu	jmpw *(%rax)
66ff20|11223344556677885f5f5f5f5f	64	intel	jmp qword ptr [rax]
66ff20|11223344556677885f5f5f5f5f	64	plan9	JMP 0(AX)
66ff28|11223344556677885f5f5f5f5f	32	intel	jmp far dword ptr [eax]
66ff28|11223344556677885f5f5f5f5f	32	plan9	LJMP 0(AX)
66ff28|11223344556677885f5f5f5f5f	64	gnu	ljmpw *(%rax)
66ff28|11223344556677885f5f5f5f5f	64	intel	jmp far dword ptr [rax]
66ff28|11223344556677885f5f5f5f5f	64	plan9	LJMP 0(AX)
66ff30|11223344556677885f5f5f5f5f	32	intel	push word ptr [eax]
66ff30|11223344556677885f5f5f5f5f	32	plan9	PUSHW 0(AX)
66ff30|11223344556677885f5f5f5f5f	64	gnu	pushw (%rax)
66ff30|11223344556677885f5f5f5f5f	64	intel	push word ptr [rax]
66ff30|11223344556677885f5f5f5f5f	64	plan9	PUSHW 0(AX)
66|9a11223344556677885f5f5f5f5f5f	64	gnu	data16
66|9a11223344556677885f5f5f5f5f5f	64	intel	data16
66|9a11223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|c411223344556677885f5f5f5f5f5f	64	gnu	data16
66|c411223344556677885f5f5f5f5f5f	64	intel	data16
66|c411223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|c511223344556677885f5f5f5f5f5f	64	gnu	data16
66|c511223344556677885f5f5f5f5f5f	64	intel	data16
66|c511223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|d411223344556677885f5f5f5f5f5f	64	gnu	data16
66|d411223344556677885f5f5f5f5f5f	64	intel	data16
66|d411223344556677885f5f5f5f5f5f	64	plan9	Op(0)
66|ea11223344556677885f5f5f5f5f5f	64	gnu	data16
66|ea11223344556677885f5f5f5f5f5f	64	intel	data16
66|ea11223344556677885f5f5f5f5f5f	64	plan9	Op(0)
676c|11223344556677885f5f5f5f5f5f	32	intel	addr16 insb
676c|11223344556677885f5f5f5f5f5f	32	plan9	INSB DX, ES:0(DI)
676c|11223344556677885f5f5f5f5f5f	64	gnu	insb (%dx),%es:(%edi)
676c|11223344556677885f5f5f5f5f5f	64	intel	addr32 insb
676c|11223344556677885f5f5f5f5f5f	64	plan9	INSB DX, ES:0(DI)
67d7|11223344556677885f5f5f5f5f5f	32	intel	addr16 xlat
67d7|11223344556677885f5f5f5f5f5f	32	plan9	XLATB DS:0(BX)
67d7|11223344556677885f5f5f5f5f5f	64	gnu	xlat %ds:(%ebx)
67d7|11223344556677885f5f5f5f5f5f	64	intel	addr32 xlat
67d7|11223344556677885f5f5f5f5f5f	64	plan9	XLATB DS:0(BX)
67e311|223344556677885f5f5f5f5f5f	32	intel	addr16 jcxz .+0x11
67e311|223344556677885f5f5f5f5f5f	32	plan9	JCXZ .+17
67e311|223344556677885f5f5f5f5f5f	64	gnu	jecxz .+0x11
67e311|223344556677885f5f5f5f5f5f	64	intel	addr32 jecxz .+0x11
67e311|223344556677885f5f5f5f5f5f	64	plan9	JECXZ .+17
6811223344|556677885f5f5f5f5f5f5f	32	intel	push 0x44332211
6811223344|556677885f5f5f5f5f5f5f	32	plan9	PUSHL $0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	gnu	pushq $0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	intel	push 0x44332211
6811223344|556677885f5f5f5f5f5f5f	64	plan9	PUSHL $0x44332211
691122334455|6677885f5f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx], 0x55443322
691122334455|6677885f5f5f5f5f5f5f	32	plan9	IMULL $0x55443322, 0(CX), DX
691122334455|6677885f5f5f5f5f5f5f	64	gnu	imul $0x55443322,(%rcx),%edx
691122334455|6677885f5f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx], 0x55443322
691122334455|6677885f5f5f5f5f5f5f	64	plan9	IMULL $0x55443322, 0(CX), DX
6a11|223344556677885f5f5f5f5f5f5f	32	intel	push 0x11
6a11|223344556677885f5f5f5f5f5f5f	32	plan9	PUSHL $0x11
6a11|223344556677885f5f5f5f5f5f5f	64	gnu	pushq $0x11
6a11|223344556677885f5f5f5f5f5f5f	64	intel	push 0x11
6a11|223344556677885f5f5f5f5f5f5f	64	plan9	PUSHL $0x11
6b1122|3344556677885f5f5f5f5f5f5f	32	intel	imul edx, dword ptr [ecx], 0x22
6b1122|3344556677885f5f5f5f5f5f5f	32	plan9	IMULL $0x22, 0(CX), DX
6b1122|3344556677885f5f5f5f5f5f5f	64	gnu	imul $0x22,(%rcx),%edx
6b1122|3344556677885f5f5f5f5f5f5f	64	intel	imul edx, dword ptr [rcx], 0x22
6b1122|3344556677885f5f5f5f5f5f5f	64	plan9	IMULL $0x22, 0(CX), DX
6d|11223344556677885f5f5f5f5f5f5f	32	intel	insd
6d|11223344556677885f5f5f5f5f5f5f	32	plan9	INSD DX, ES:0(DI)
6d|11223344556677885f5f5f5f5f5f5f	64	gnu	insl (%dx),%es:(%rdi)
6d|11223344556677885f5f5f5f5f5f5f	64	intel	insd
6d|11223344556677885f5f5f5f5f5f5f	64	plan9	INSD DX, ES:0(DI)
6f|11223344556677885f5f5f5f5f5f5f	32	intel	outsd
6f|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTSD DS:0(SI), DX
6f|11223344556677885f5f5f5f5f5f5f	64	gnu	outsl %ds:(%rsi),(%dx)
6f|11223344556677885f5f5f5f5f5f5f	64	intel	outsd
6f|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTSD DS:0(SI), DX
7111|223344556677885f5f5f5f5f5f5f	32	intel	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	32	plan9	JNO .+17
7111|223344556677885f5f5f5f5f5f5f	64	gnu	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	64	intel	jno .+0x11
7111|223344556677885f5f5f5f5f5f5f	64	plan9	JNO .+17
7211|223344556677885f5f5f5f5f5f5f	32	intel	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	32	plan9	JB .+17
7211|223344556677885f5f5f5f5f5f5f	64	gnu	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	64	intel	jb .+0x11
7211|223344556677885f5f5f5f5f5f5f	64	plan9	JB .+17
7311|223344556677885f5f5f5f5f5f5f	32	intel	jnb .+0x11
7311|223344556677885f5f5f5f5f5f5f	32	plan9	JAE .+17
7311|223344556677885f5f5f5f5f5f5f	64	gnu	jae .+0x11
7311|223344556677885f5f5f5f5f5f5f	64	intel	jnb .+0x11
7311|223344556677885f5f5f5f5f5f5f	64	plan9	JAE .+17
7411|223344556677885f5f5f5f5f5f5f	32	intel	jz .+0x11
7411|223344556677885f5f5f5f5f5f5f	32	plan9	JE .+17
7411|223344556677885f5f5f5f5f5f5f	64	gnu	je .+0x11
7411|223344556677885f5f5f5f5f5f5f	64	intel	jz .+0x11
7411|223344556677885f5f5f5f5f5f5f	64	plan9	JE .+17
7511|223344556677885f5f5f5f5f5f5f	32	intel	jnz .+0x11
7511|223344556677885f5f5f5f5f5f5f	32	plan9	JNE .+17
7511|223344556677885f5f5f5f5f5f5f	64	gnu	jne .+0x11
7511|223344556677885f5f5f5f5f5f5f	64	intel	jnz .+0x11
7511|223344556677885f5f5f5f5f5f5f	64	plan9	JNE .+17
7611|223344556677885f5f5f5f5f5f5f	32	intel	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	32	plan9	JBE .+17
7611|223344556677885f5f5f5f5f5f5f	64	gnu	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	64	intel	jbe .+0x11
7611|223344556677885f5f5f5f5f5f5f	64	plan9	JBE .+17
7711|223344556677885f5f5f5f5f5f5f	32	intel	jnbe .+0x11
7711|223344556677885f5f5f5f5f5f5f	32	plan9	JA .+17
7711|223344556677885f5f5f5f5f5f5f	64	gnu	ja .+0x11
7711|223344556677885f5f5f5f5f5f5f	64	intel	jnbe .+0x11
7711|223344556677885f5f5f5f5f5f5f	64	plan9	JA .+17
7811|223344556677885f5f5f5f5f5f5f	32	intel	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	32	plan9	JS .+17
7811|223344556677885f5f5f5f5f5f5f	64	gnu	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	64	intel	js .+0x11
7811|223344556677885f5f5f5f5f5f5f	64	plan9	JS .+17
7911|223344556677885f5f5f5f5f5f5f	32	intel	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	32	plan9	JNS .+17
7911|223344556677885f5f5f5f5f5f5f	64	gnu	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	64	intel	jns .+0x11
7911|223344556677885f5f5f5f5f5f5f	64	plan9	JNS .+17
7a11|223344556677885f5f5f5f5f5f5f	32	intel	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	32	plan9	JP .+17
7a11|223344556677885f5f5f5f5f5f5f	64	gnu	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	64	intel	jp .+0x11
7a11|223344556677885f5f5f5f5f5f5f	64	plan9	JP .+17
7b11|223344556677885f5f5f5f5f5f5f	32	intel	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	32	plan9	JNP .+17
7b11|223344556677885f5f5f5f5f5f5f	64	gnu	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	64	intel	jnp .+0x11
7b11|223344556677885f5f5f5f5f5f5f	64	plan9	JNP .+17
7c11|223344556677885f5f5f5f5f5f5f	32	intel	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	32	plan9	JL .+17
7c11|223344556677885f5f5f5f5f5f5f	64	gnu	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	64	intel	jl .+0x11
7c11|223344556677885f5f5f5f5f5f5f	64	plan9	JL .+17
7d11|223344556677885f5f5f5f5f5f5f	32	intel	jnl .+0x11
7d11|223344556677885f5f5f5f5f5f5f	32	plan9	JGE .+17
7d11|223344556677885f5f5f5f5f5f5f	64	gnu	jge .+0x11
7d11|223344556677885f5f5f5f5f5f5f	64	intel	jnl .+0x11
7d11|223344556677885f5f5f5f5f5f5f	64	plan9	JGE .+17
7e11|223344556677885f5f5f5f5f5f5f	32	intel	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	32	plan9	JLE .+17
7e11|223344556677885f5f5f5f5f5f5f	64	gnu	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	64	intel	jle .+0x11
7e11|223344556677885f5f5f5f5f5f5f	64	plan9	JLE .+17
7f11|223344556677885f5f5f5f5f5f5f	32	intel	jnle .+0x11
7f11|223344556677885f5f5f5f5f5f5f	32	plan9	JG .+17
7f11|223344556677885f5f5f5f5f5f5f	64	gnu	jg .+0x11
7f11|223344556677885f5f5f5f5f5f5f	64	intel	jnle .+0x11
7f11|223344556677885f5f5f5f5f5f5f	64	plan9	JG .+17
800011|223344556677885f5f5f5f5f5f	32	intel	add byte ptr [eax], 0x11
800011|223344556677885f5f5f5f5f5f	32	plan9	ADDL $0x11, 0(AX)
800011|223344556677885f5f5f5f5f5f	64	gnu	addb $0x11,(%rax)
800011|223344556677885f5f5f5f5f5f	64	intel	add byte ptr [rax], 0x11
800011|223344556677885f5f5f5f5f5f	64	plan9	ADDL $0x11, 0(AX)
800811|223344556677885f5f5f5f5f5f	32	intel	or byte ptr [eax], 0x11
800811|223344556677885f5f5f5f5f5f	32	plan9	ORL $0x11, 0(AX)
800811|223344556677885f5f5f5f5f5f	64	gnu	orb $0x11,(%rax)
800811|223344556677885f5f5f5f5f5f	64	intel	or byte ptr [rax], 0x11
800811|223344556677885f5f5f5f5f5f	64	plan9	ORL $0x11, 0(AX)
801122|3344556677885f5f5f5f5f5f5f	32	intel	adc byte ptr [ecx], 0x22
801122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x22, 0(CX)
801122|3344556677885f5f5f5f5f5f5f	64	gnu	adcb $0x22,(%rcx)
801122|3344556677885f5f5f5f5f5f5f	64	intel	adc byte ptr [rcx], 0x22
801122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x22, 0(CX)
801811|223344556677885f5f5f5f5f5f	32	intel	sbb byte ptr [eax], 0x11
801811|223344556677885f5f5f5f5f5f	32	plan9	SBBL $0x11, 0(AX)
801811|223344556677885f5f5f5f5f5f	64	gnu	sbbb $0x11,(%rax)
801811|223344556677885f5f5f5f5f5f	64	intel	sbb byte ptr [rax], 0x11
801811|223344556677885f5f5f5f5f5f	64	plan9	SBBL $0x11, 0(AX)
802011|223344556677885f5f5f5f5f5f	32	intel	and byte ptr [eax], 0x11
802011|223344556677885f5f5f5f5f5f	32	plan9	ANDL $0x11, 0(AX)
802011|223344556677885f5f5f5f5f5f	64	gnu	andb $0x11,(%rax)
802011|223344556677885f5f5f5f5f5f	64	intel	and byte ptr [rax], 0x11
802011|223344556677885f5f5f5f5f5f	64	plan9	ANDL $0x11, 0(AX)
802811|223344556677885f5f5f5f5f5f	32	intel	sub byte ptr [eax], 0x11
802811|223344556677885f5f5f5f5f5f	32	plan9	SUBL $0x11, 0(AX)
802811|223344556677885f5f5f5f5f5f	64	gnu	subb $0x11,(%rax)
802811|223344556677885f5f5f5f5f5f	64	intel	sub byte ptr [rax], 0x11
802811|223344556677885f5f5f5f5f5f	64	plan9	SUBL $0x11, 0(AX)
803011|223344556677885f5f5f5f5f5f	32	intel	xor byte ptr [eax], 0x11
803011|223344556677885f5f5f5f5f5f	32	plan9	XORL $0x11, 0(AX)
803011|223344556677885f5f5f5f5f5f	64	gnu	xorb $0x11,(%rax)
803011|223344556677885f5f5f5f5f5f	64	intel	xor byte ptr [rax], 0x11
803011|223344556677885f5f5f5f5f5f	64	plan9	XORL $0x11, 0(AX)
803811|223344556677885f5f5f5f5f5f	32	intel	cmp byte ptr [eax], 0x11
803811|223344556677885f5f5f5f5f5f	32	plan9	CMPL $0x11, 0(AX)
803811|223344556677885f5f5f5f5f5f	64	gnu	cmpb $0x11,(%rax)
803811|223344556677885f5f5f5f5f5f	64	intel	cmp byte ptr [rax], 0x11
803811|223344556677885f5f5f5f5f5f	64	plan9	CMPL $0x11, 0(AX)
810011223344|556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], 0x44332211
810011223344|556677885f5f5f5f5f5f	32	plan9	ADDL $0x44332211, 0(AX)
810011223344|556677885f5f5f5f5f5f	64	gnu	addl $0x44332211,(%rax)
810011223344|556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], 0x44332211
810011223344|556677885f5f5f5f5f5f	64	plan9	ADDL $0x44332211, 0(AX)
810811223344|556677885f5f5f5f5f5f	32	intel	or dword ptr [eax], 0x44332211
810811223344|556677885f5f5f5f5f5f	32	plan9	ORL $0x44332211, 0(AX)
810811223344|556677885f5f5f5f5f5f	64	gnu	orl $0x44332211,(%rax)
810811223344|556677885f5f5f5f5f5f	64	intel	or dword ptr [rax], 0x44332211
810811223344|556677885f5f5f5f5f5f	64	plan9	ORL $0x44332211, 0(AX)
811122334455|6677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], 0x55443322
811122334455|6677885f5f5f5f5f5f5f	32	plan9	ADCL $0x55443322, 0(CX)
811122334455|6677885f5f5f5f5f5f5f	64	gnu	adcl $0x55443322,(%rcx)
811122334455|6677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], 0x55443322
811122334455|6677885f5f5f5f5f5f5f	64	plan9	ADCL $0x55443322, 0(CX)
811811223344|556677885f5f5f5f5f5f	32	intel	sbb dword ptr [eax], 0x44332211
811811223344|556677885f5f5f5f5f5f	32	plan9	SBBL $0x44332211, 0(AX)
811811223344|556677885f5f5f5f5f5f	64	gnu	sbbl $0x44332211,(%rax)
811811223344|556677885f5f5f5f5f5f	64	intel	sbb dword ptr [rax], 0x44332211
811811223344|556677885f5f5f5f5f5f	64	plan9	SBBL $0x44332211, 0(AX)
812011223344|556677885f5f5f5f5f5f	32	intel	and dword ptr [eax], 0x44332211
812011223344|556677885f5f5f5f5f5f	32	plan9	ANDL $0x44332211, 0(AX)
812011223344|556677885f5f5f5f5f5f	64	gnu	andl $0x44332211,(%rax)
812011223344|556677885f5f5f5f5f5f	64	intel	and dword ptr [rax], 0x44332211
812011223344|556677885f5f5f5f5f5f	64	plan9	ANDL $0x44332211, 0(AX)
812811223344|556677885f5f5f5f5f5f	32	intel	sub dword ptr [eax], 0x44332211
812811223344|556677885f5f5f5f5f5f	32	plan9	SUBL $0x44332211, 0(AX)
812811223344|556677885f5f5f5f5f5f	64	gnu	subl $0x44332211,(%rax)
812811223344|556677885f5f5f5f5f5f	64	intel	sub dword ptr [rax], 0x44332211
812811223344|556677885f5f5f5f5f5f	64	plan9	SUBL $0x44332211, 0(AX)
813011223344|556677885f5f5f5f5f5f	32	intel	xor dword ptr [eax], 0x44332211
813011223344|556677885f5f5f5f5f5f	32	plan9	XORL $0x44332211, 0(AX)
813011223344|556677885f5f5f5f5f5f	64	gnu	xorl $0x44332211,(%rax)
813011223344|556677885f5f5f5f5f5f	64	intel	xor dword ptr [rax], 0x44332211
813011223344|556677885f5f5f5f5f5f	64	plan9	XORL $0x44332211, 0(AX)
813811223344|556677885f5f5f5f5f5f	32	intel	cmp dword ptr [eax], 0x44332211
813811223344|556677885f5f5f5f5f5f	32	plan9	CMPL $0x44332211, 0(AX)
813811223344|556677885f5f5f5f5f5f	64	gnu	cmpl $0x44332211,(%rax)
813811223344|556677885f5f5f5f5f5f	64	intel	cmp dword ptr [rax], 0x44332211
813811223344|556677885f5f5f5f5f5f	64	plan9	CMPL $0x44332211, 0(AX)
830011|223344556677885f5f5f5f5f5f	32	intel	add dword ptr [eax], 0x11
830011|223344556677885f5f5f5f5f5f	32	plan9	ADDL $0x11, 0(AX)
830011|223344556677885f5f5f5f5f5f	64	gnu	addl $0x11,(%rax)
830011|223344556677885f5f5f5f5f5f	64	intel	add dword ptr [rax], 0x11
830011|223344556677885f5f5f5f5f5f	64	plan9	ADDL $0x11, 0(AX)
830811|223344556677885f5f5f5f5f5f	32	intel	or dword ptr [eax], 0x11
830811|223344556677885f5f5f5f5f5f	32	plan9	ORL $0x11, 0(AX)
830811|223344556677885f5f5f5f5f5f	64	gnu	orl $0x11,(%rax)
830811|223344556677885f5f5f5f5f5f	64	intel	or dword ptr [rax], 0x11
830811|223344556677885f5f5f5f5f5f	64	plan9	ORL $0x11, 0(AX)
831122|3344556677885f5f5f5f5f5f5f	32	intel	adc dword ptr [ecx], 0x22
831122|3344556677885f5f5f5f5f5f5f	32	plan9	ADCL $0x22, 0(CX)
831122|3344556677885f5f5f5f5f5f5f	64	gnu	adcl $0x22,(%rcx)
831122|3344556677885f5f5f5f5f5f5f	64	intel	adc dword ptr [rcx], 0x22
831122|3344556677885f5f5f5f5f5f5f	64	plan9	ADCL $0x22, 0(CX)
831811|223344556677885f5f5f5f5f5f	32	intel	sbb dword ptr [eax], 0x11
831811|223344556677885f5f5f5f5f5f	32	plan9	SBBL $0x11, 0(AX)
831811|223344556677885f5f5f5f5f5f	64	gnu	sbbl $0x11,(%rax)
831811|223344556677885f5f5f5f5f5f	64	intel	sbb dword ptr [rax], 0x11
831811|223344556677885f5f5f5f5f5f	64	plan9	SBBL $0x11, 0(AX)
832011|223344556677885f5f5f5f5f5f	32	intel	and dword ptr [eax], 0x11
832011|223344556677885f5f5f5f5f5f	32	plan9	ANDL $0x11, 0(AX)
832011|223344556677885f5f5f5f5f5f	64	gnu	andl $0x11,(%rax)
832011|223344556677885f5f5f5f5f5f	64	intel	and dword ptr [rax], 0x11
832011|223344556677885f5f5f5f5f5f	64	plan9	ANDL $0x11, 0(AX)
832811|223344556677885f5f5f5f5f5f	32	intel	sub dword ptr [eax], 0x11
832811|223344556677885f5f5f5f5f5f	32	plan9	SUBL $0x11, 0(AX)
832811|223344556677885f5f5f5f5f5f	64	gnu	subl $0x11,(%rax)
832811|223344556677885f5f5f5f5f5f	64	intel	sub dword ptr [rax], 0x11
832811|223344556677885f5f5f5f5f5f	64	plan9	SUBL $0x11, 0(AX)
833011|223344556677885f5f5f5f5f5f	32	intel	xor dword ptr [eax], 0x11
833011|223344556677885f5f5f5f5f5f	32	plan9	XORL $0x11, 0(AX)
833011|223344556677885f5f5f5f5f5f	64	gnu	xorl $0x11,(%rax)
833011|223344556677885f5f5f5f5f5f	64	intel	xor dword ptr [rax], 0x11
833011|223344556677885f5f5f5f5f5f	64	plan9	XORL $0x11, 0(AX)
833811|223344556677885f5f5f5f5f5f	32	intel	cmp dword ptr [eax], 0x11
833811|223344556677885f5f5f5f5f5f	32	plan9	CMPL $0x11, 0(AX)
833811|223344556677885f5f5f5f5f5f	64	gnu	cmpl $0x11,(%rax)
833811|223344556677885f5f5f5f5f5f	64	intel	cmp dword ptr [rax], 0x11
833811|223344556677885f5f5f5f5f5f	64	plan9	CMPL $0x11, 0(AX)
8411|223344556677885f5f5f5f5f5f5f	32	intel	test byte ptr [ecx], dl
8411|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL DL, 0(CX)
8411|223344556677885f5f5f5f5f5f5f	64	gnu	test %dl,(%rcx)
8411|223344556677885f5f5f5f5f5f5f	64	intel	test byte ptr [rcx], dl
8411|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL DL, 0(CX)
8511|223344556677885f5f5f5f5f5f5f	32	intel	test dword ptr [ecx], edx
8511|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL DX, 0(CX)
8511|223344556677885f5f5f5f5f5f5f	64	gnu	test %edx,(%rcx)
8511|223344556677885f5f5f5f5f5f5f	64	intel	test dword ptr [rcx], edx
8511|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL DX, 0(CX)
8611|223344556677885f5f5f5f5f5f5f	32	intel	xchg byte ptr [ecx], dl
8611|223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL DL, 0(CX)
8611|223344556677885f5f5f5f5f5f5f	64	gnu	xchg %dl,(%rcx)
8611|223344556677885f5f5f5f5f5f5f	64	intel	xchg byte ptr [rcx], dl
8611|223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL DL, 0(CX)
8711|223344556677885f5f5f5f5f5f5f	32	intel	xchg dword ptr [ecx], edx
8711|223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL DX, 0(CX)
8711|223344556677885f5f5f5f5f5f5f	64	gnu	xchg %edx,(%rcx)
8711|223344556677885f5f5f5f5f5f5f	64	intel	xchg dword ptr [rcx], edx
8711|223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL DX, 0(CX)
8811|223344556677885f5f5f5f5f5f5f	32	intel	mov byte ptr [ecx], dl
8811|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL DL, 0(CX)
8811|223344556677885f5f5f5f5f5f5f	64	gnu	mov %dl,(%rcx)
8811|223344556677885f5f5f5f5f5f5f	64	intel	mov byte ptr [rcx], dl
8811|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL DL, 0(CX)
8911|223344556677885f5f5f5f5f5f5f	32	intel	mov dword ptr [ecx], edx
8911|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL DX, 0(CX)
8911|223344556677885f5f5f5f5f5f5f	64	gnu	mov %edx,(%rcx)
8911|223344556677885f5f5f5f5f5f5f	64	intel	mov dword ptr [rcx], edx
8911|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL DX, 0(CX)
8a11|223344556677885f5f5f5f5f5f5f	32	intel	mov dl, byte ptr [ecx]
8a11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), DL
8a11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%dl
8a11|223344556677885f5f5f5f5f5f5f	64	intel	mov dl, byte ptr [rcx]
8a11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), DL
8b11|223344556677885f5f5f5f5f5f5f	32	intel	mov edx, dword ptr [ecx]
8b11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), DX
8b11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%edx
8b11|223344556677885f5f5f5f5f5f5f	64	intel	mov edx, dword ptr [rcx]
8b11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), DX
8c11|223344556677885f5f5f5f5f5f5f	32	intel	mov word ptr [ecx], ss
8c11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL SS, 0(CX)
8c11|223344556677885f5f5f5f5f5f5f	64	gnu	mov %ss,(%rcx)
8c11|223344556677885f5f5f5f5f5f5f	64	intel	mov word ptr [rcx], ss
8c11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL SS, 0(CX)
8d11|223344556677885f5f5f5f5f5f5f	32	intel	lea edx, ptr [ecx]
8d11|223344556677885f5f5f5f5f5f5f	32	plan9	LEAL 0(CX), DX
8d11|223344556677885f5f5f5f5f5f5f	64	gnu	lea (%rcx),%edx
8d11|223344556677885f5f5f5f5f5f5f	64	intel	lea edx, ptr [rcx]
8d11|223344556677885f5f5f5f5f5f5f	64	plan9	LEAL 0(CX), DX
8e11|223344556677885f5f5f5f5f5f5f	32	intel	mov ss, word ptr [ecx]
8e11|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL 0(CX), SS
8e11|223344556677885f5f5f5f5f5f5f	64	gnu	mov (%rcx),%ss
8e11|223344556677885f5f5f5f5f5f5f	64	intel	mov ss, word ptr [rcx]
8e11|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL 0(CX), SS
8f00|11223344556677885f5f5f5f5f5f	32	intel	pop dword ptr [eax]
8f00|11223344556677885f5f5f5f5f5f	32	plan9	POPL 0(AX)
8f00|11223344556677885f5f5f5f5f5f	64	gnu	popq (%rax)
8f00|11223344556677885f5f5f5f5f5f	64	intel	pop qword ptr [rax]
8f00|11223344556677885f5f5f5f5f5f	64	plan9	POPL 0(AX)
91|11223344556677885f5f5f5f5f5f5f	32	intel	xchg ecx, eax
91|11223344556677885f5f5f5f5f5f5f	32	plan9	XCHGL AX, CX
91|11223344556677885f5f5f5f5f5f5f	64	intel	xchg ecx, eax
91|11223344556677885f5f5f5f5f5f5f	64	plan9	XCHGL AX, CX
98|11223344556677885f5f5f5f5f5f5f	32	intel	cwde
98|11223344556677885f5f5f5f5f5f5f	32	plan9	CWDE
98|11223344556677885f5f5f5f5f5f5f	64	gnu	cwtl
98|11223344556677885f5f5f5f5f5f5f	64	intel	cwde
98|11223344556677885f5f5f5f5f5f5f	64	plan9	CWDE
99|11223344556677885f5f5f5f5f5f5f	32	intel	cdq
99|11223344556677885f5f5f5f5f5f5f	32	plan9	CDQ
99|11223344556677885f5f5f5f5f5f5f	64	gnu	cltd
99|11223344556677885f5f5f5f5f5f5f	64	intel	cdq
99|11223344556677885f5f5f5f5f5f5f	64	plan9	CDQ
9a112233445566|77885f5f5f5f5f5f5f	32	intel	call far 0x44332211, 0x6655
9a112233445566|77885f5f5f5f5f5f5f	32	plan9	LCALL $0x44332211, $0x6655
9b|11223344556677885f5f5f5f5f5f5f	32	intel	fwait
9b|11223344556677885f5f5f5f5f5f5f	32	plan9	FWAIT
9b|11223344556677885f5f5f5f5f5f5f	64	gnu	fwait
9b|11223344556677885f5f5f5f5f5f5f	64	intel	fwait
9b|11223344556677885f5f5f5f5f5f5f	64	plan9	FWAIT
9c|11223344556677885f5f5f5f5f5f5f	32	intel	pushfd
9c|11223344556677885f5f5f5f5f5f5f	32	plan9	PUSHFD
9c|11223344556677885f5f5f5f5f5f5f	64	gnu	pushfq
9c|11223344556677885f5f5f5f5f5f5f	64	intel	pushfq
9c|11223344556677885f5f5f5f5f5f5f	64	plan9	PUSHFQ
9d|11223344556677885f5f5f5f5f5f5f	32	intel	popfd
9d|11223344556677885f5f5f5f5f5f5f	32	plan9	POPFD
9d|11223344556677885f5f5f5f5f5f5f	64	gnu	popfq
9d|11223344556677885f5f5f5f5f5f5f	64	intel	popfq
9d|11223344556677885f5f5f5f5f5f5f	64	plan9	POPFQ
9e|11223344556677885f5f5f5f5f5f5f	32	intel	sahf
9e|11223344556677885f5f5f5f5f5f5f	32	plan9	SAHF
9e|11223344556677885f5f5f5f5f5f5f	64	gnu	sahf
9e|11223344556677885f5f5f5f5f5f5f	64	intel	sahf
9e|11223344556677885f5f5f5f5f5f5f	64	plan9	SAHF
9f|11223344556677885f5f5f5f5f5f5f	32	intel	lahf
9f|11223344556677885f5f5f5f5f5f5f	32	plan9	LAHF
9f|11223344556677885f5f5f5f5f5f5f	64	gnu	lahf
9f|11223344556677885f5f5f5f5f5f5f	64	intel	lahf
9f|11223344556677885f5f5f5f5f5f5f	64	plan9	LAHF
a11122334455667788|5f5f5f5f5f5f5f	64	gnu	mov -0x778899aabbccddef,%eax
a11122334455667788|5f5f5f5f5f5f5f	64	intel	mov eax, dword ptr [0x8877665544332211]
a11122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL -0x778899aabbccddef, AX
a111223344|556677885f5f5f5f5f5f5f	32	intel	mov eax, dword ptr [0x44332211]
a111223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL 0x44332211, AX
a21122334455667788|5f5f5f5f5f5f5f	64	gnu	mov %al,-0x778899aabbccddef
a21122334455667788|5f5f5f5f5f5f5f	64	intel	mov byte ptr [0x8877665544332211], al
a21122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL AL, -0x778899aabbccddef
a211223344|556677885f5f5f5f5f5f5f	32	intel	mov byte ptr [0x44332211], al
a211223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL AL, 0x44332211
a31122334455667788|5f5f5f5f5f5f5f	64	gnu	mov %eax,-0x778899aabbccddef
a31122334455667788|5f5f5f5f5f5f5f	64	intel	mov dword ptr [0x8877665544332211], eax
a31122334455667788|5f5f5f5f5f5f5f	64	plan9	MOVL AX, -0x778899aabbccddef
a311223344|556677885f5f5f5f5f5f5f	32	intel	mov dword ptr [0x44332211], eax
a311223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL AX, 0x44332211
a4|11223344556677885f5f5f5f5f5f5f	32	intel	movsb byte ptr [edi], byte ptr [esi]
a4|11223344556677885f5f5f5f5f5f5f	32	plan9	MOVSB DS:0(SI), ES:0(DI)
a4|11223344556677885f5f5f5f5f5f5f	64	gnu	movsb %ds:(%rsi),%es:(%rdi)
a4|11223344556677885f5f5f5f5f5f5f	64	intel	movsb byte ptr [rdi], byte ptr [rsi]
a4|11223344556677885f5f5f5f5f5f5f	64	plan9	MOVSB DS:0(SI), ES:0(DI)
a5|11223344556677885f5f5f5f5f5f5f	32	intel	movsd dword ptr [edi], dword ptr [esi]
a5|11223344556677885f5f5f5f5f5f5f	32	plan9	MOVSD DS:0(SI), ES:0(DI)
a5|11223344556677885f5f5f5f5f5f5f	64	gnu	movsl %ds:(%rsi),%es:(%rdi)
a5|11223344556677885f5f5f5f5f5f5f	64	intel	movsd dword ptr [rdi], dword ptr [rsi]
a5|11223344556677885f5f5f5f5f5f5f	64	plan9	MOVSD DS:0(SI), ES:0(DI)
a6|11223344556677885f5f5f5f5f5f5f	32	intel	cmpsb byte ptr [esi], byte ptr [edi]
a6|11223344556677885f5f5f5f5f5f5f	32	plan9	CMPSB ES:0(DI), DS:0(SI)
a6|11223344556677885f5f5f5f5f5f5f	64	gnu	cmpsb %es:(%rdi),%ds:(%rsi)
a6|11223344556677885f5f5f5f5f5f5f	64	intel	cmpsb byte ptr [rsi], byte ptr [rdi]
a6|11223344556677885f5f5f5f5f5f5f	64	plan9	CMPSB ES:0(DI), DS:0(SI)
a7|11223344556677885f5f5f5f5f5f5f	32	intel	cmpsd dword ptr [esi], dword ptr [edi]
a7|11223344556677885f5f5f5f5f5f5f	32	plan9	CMPSD ES:0(DI), DS:0(SI)
a7|11223344556677885f5f5f5f5f5f5f	64	gnu	cmpsl %es:(%rdi),%ds:(%rsi)
a7|11223344556677885f5f5f5f5f5f5f	64	intel	cmpsd dword ptr [rsi], dword ptr [rdi]
a7|11223344556677885f5f5f5f5f5f5f	64	plan9	CMPSD ES:0(DI), DS:0(SI)
a811|223344556677885f5f5f5f5f5f5f	32	intel	test al, 0x11
a811|223344556677885f5f5f5f5f5f5f	32	plan9	TESTL $0x11, AL
a811|223344556677885f5f5f5f5f5f5f	64	gnu	test $0x11,%al
a811|223344556677885f5f5f5f5f5f5f	64	intel	test al, 0x11
a811|223344556677885f5f5f5f5f5f5f	64	plan9	TESTL $0x11, AL
a911223344|556677885f5f5f5f5f5f5f	32	intel	test eax, 0x44332211
a911223344|556677885f5f5f5f5f5f5f	32	plan9	TESTL $0x44332211, AX
a911223344|556677885f5f5f5f5f5f5f	64	gnu	test $0x44332211,%eax
a911223344|556677885f5f5f5f5f5f5f	64	intel	test eax, 0x44332211
a911223344|556677885f5f5f5f5f5f5f	64	plan9	TESTL $0x44332211, AX
aa|11223344556677885f5f5f5f5f5f5f	32	intel	stosb byte ptr [edi]
aa|11223344556677885f5f5f5f5f5f5f	32	plan9	STOSB AL, ES:0(DI)
aa|11223344556677885f5f5f5f5f5f5f	64	gnu	stos %al,%es:(%rdi)
aa|11223344556677885f5f5f5f5f5f5f	64	intel	stosb byte ptr [rdi]
aa|11223344556677885f5f5f5f5f5f5f	64	plan9	STOSB AL, ES:0(DI)
ab|11223344556677885f5f5f5f5f5f5f	32	intel	stosd dword ptr [edi]
ab|11223344556677885f5f5f5f5f5f5f	32	plan9	STOSD AX, ES:0(DI)
ab|11223344556677885f5f5f5f5f5f5f	64	gnu	stos %eax,%es:(%rdi)
ab|11223344556677885f5f5f5f5f5f5f	64	intel	stosd dword ptr [rdi]
ab|11223344556677885f5f5f5f5f5f5f	64	plan9	STOSD AX, ES:0(DI)
ac|11223344556677885f5f5f5f5f5f5f	32	intel	lodsb byte ptr [esi]
ac|11223344556677885f5f5f5f5f5f5f	32	plan9	LODSB DS:0(SI), AL
ac|11223344556677885f5f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%al
ac|11223344556677885f5f5f5f5f5f5f	64	intel	lodsb byte ptr [rsi]
ac|11223344556677885f5f5f5f5f5f5f	64	plan9	LODSB DS:0(SI), AL
ad|11223344556677885f5f5f5f5f5f5f	32	intel	lodsd dword ptr [esi]
ad|11223344556677885f5f5f5f5f5f5f	32	plan9	LODSD DS:0(SI), AX
ad|11223344556677885f5f5f5f5f5f5f	64	gnu	lods %ds:(%rsi),%eax
ad|11223344556677885f5f5f5f5f5f5f	64	intel	lodsd dword ptr [rsi]
ad|11223344556677885f5f5f5f5f5f5f	64	plan9	LODSD DS:0(SI), AX
ae|11223344556677885f5f5f5f5f5f5f	32	intel	scasb byte ptr [edi]
ae|11223344556677885f5f5f5f5f5f5f	32	plan9	SCASB ES:0(DI), AL
ae|11223344556677885f5f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%al
ae|11223344556677885f5f5f5f5f5f5f	64	intel	scasb byte ptr [rdi]
ae|11223344556677885f5f5f5f5f5f5f	64	plan9	SCASB ES:0(DI), AL
af|11223344556677885f5f5f5f5f5f5f	32	intel	scasd dword ptr [edi]
af|11223344556677885f5f5f5f5f5f5f	32	plan9	SCASD ES:0(DI), AX
af|11223344556677885f5f5f5f5f5f5f	64	gnu	scas %es:(%rdi),%eax
af|11223344556677885f5f5f5f5f5f5f	64	intel	scasd dword ptr [rdi]
af|11223344556677885f5f5f5f5f5f5f	64	plan9	SCASD ES:0(DI), AX
b011|223344556677885f5f5f5f5f5f5f	32	intel	mov al, 0x11
b011|223344556677885f5f5f5f5f5f5f	32	plan9	MOVL $0x11, AL
b011|223344556677885f5f5f5f5f5f5f	64	gnu	mov $0x11,%al
b011|223344556677885f5f5f5f5f5f5f	64	intel	mov al, 0x11
b011|223344556677885f5f5f5f5f5f5f	64	plan9	MOVL $0x11, AL
b811223344|556677885f5f5f5f5f5f5f	32	intel	mov eax, 0x44332211
b811223344|556677885f5f5f5f5f5f5f	32	plan9	MOVL $0x44332211, AX
b811223344|556677885f5f5f5f5f5f5f	64	gnu	mov $0x44332211,%eax
b811223344|556677885f5f5f5f5f5f5f	64	intel	mov eax, 0x44332211
b811223344|556677885f5f5f5f5f5f5f	64	plan9	MOVL $0x44332211, AX
c00011|223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], 0x11
c00011|223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x11, 0(AX)
c00011|223344556677885f5f5f5f5f5f	64	gnu	rolb $0x11,(%rax)
c00011|223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], 0x11
c00011|223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x11, 0(AX)
c00811|223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], 0x11
c00811|223344556677885f5f5f5f5f5f	32	plan9	RORL $0x11, 0(AX)
c00811|223344556677885f5f5f5f5f5f	64	gnu	rorb $0x11,(%rax)
c00811|223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], 0x11
c00811|223344556677885f5f5f5f5f5f	64	plan9	RORL $0x11, 0(AX)
c01122|3344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], 0x22
c01122|3344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x22, 0(CX)
c01122|3344556677885f5f5f5f5f5f5f	64	gnu	rclb $0x22,(%rcx)
c01122|3344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], 0x22
c01122|3344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x22, 0(CX)
c01811|223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], 0x11
c01811|223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x11, 0(AX)
c01811|223344556677885f5f5f5f5f5f	64	gnu	rcrb $0x11,(%rax)
c01811|223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], 0x11
c01811|223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x11, 0(AX)
c02011|223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], 0x11
c02011|223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x11, 0(AX)
c02011|223344556677885f5f5f5f5f5f	64	gnu	shlb $0x11,(%rax)
c02011|223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], 0x11
c02011|223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x11, 0(AX)
c02811|223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], 0x11
c02811|223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x11, 0(AX)
c02811|223344556677885f5f5f5f5f5f	64	gnu	shrb $0x11,(%rax)
c02811|223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], 0x11
c02811|223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x11, 0(AX)
c03811|223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], 0x11
c03811|223344556677885f5f5f5f5f5f	32	plan9	SARL $0x11, 0(AX)
c03811|223344556677885f5f5f5f5f5f	64	gnu	sarb $0x11,(%rax)
c03811|223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], 0x11
c03811|223344556677885f5f5f5f5f5f	64	plan9	SARL $0x11, 0(AX)
c10011|223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], 0x11
c10011|223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x11, 0(AX)
c10011|223344556677885f5f5f5f5f5f	64	gnu	roll $0x11,(%rax)
c10011|223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], 0x11
c10011|223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x11, 0(AX)
c10811|223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], 0x11
c10811|223344556677885f5f5f5f5f5f	32	plan9	RORL $0x11, 0(AX)
c10811|223344556677885f5f5f5f5f5f	64	gnu	rorl $0x11,(%rax)
c10811|223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], 0x11
c10811|223344556677885f5f5f5f5f5f	64	plan9	RORL $0x11, 0(AX)
c11122|3344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], 0x22
c11122|3344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x22, 0(CX)
c11122|3344556677885f5f5f5f5f5f5f	64	gnu	rcll $0x22,(%rcx)
c11122|3344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], 0x22
c11122|3344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x22, 0(CX)
c11811|223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], 0x11
c11811|223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x11, 0(AX)
c11811|223344556677885f5f5f5f5f5f	64	gnu	rcrl $0x11,(%rax)
c11811|223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], 0x11
c11811|223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x11, 0(AX)
c12011|223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], 0x11
c12011|223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x11, 0(AX)
c12011|223344556677885f5f5f5f5f5f	64	gnu	shll $0x11,(%rax)
c12011|223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], 0x11
c12011|223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x11, 0(AX)
c12811|223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], 0x11
c12811|223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x11, 0(AX)
c12811|223344556677885f5f5f5f5f5f	64	gnu	shrl $0x11,(%rax)
c12811|223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], 0x11
c12811|223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x11, 0(AX)
c13811|223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], 0x11
c13811|223344556677885f5f5f5f5f5f	32	plan9	SARL $0x11, 0(AX)
c13811|223344556677885f5f5f5f5f5f	64	gnu	sarl $0x11,(%rax)
c13811|223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], 0x11
c13811|223344556677885f5f5f5f5f5f	64	plan9	SARL $0x11, 0(AX)
c3|11223344556677885f5f5f5f5f5f5f	32	intel	ret
c3|11223344556677885f5f5f5f5f5f5f	32	plan9	RET
c3|11223344556677885f5f5f5f5f5f5f	64	gnu	retq
c3|11223344556677885f5f5f5f5f5f5f	64	intel	ret
c3|11223344556677885f5f5f5f5f5f5f	64	plan9	RET
c411|223344556677885f5f5f5f5f5f5f	32	intel	les edx, ptr [ecx]
c411|223344556677885f5f5f5f5f5f5f	32	plan9	LES 0(CX), DX
c511|223344556677885f5f5f5f5f5f5f	32	intel	lds edx, ptr [ecx]
c511|223344556677885f5f5f5f5f5f5f	32	plan9	LDS 0(CX), DX
c60011|223344556677885f5f5f5f5f5f	32	intel	mov byte ptr [eax], 0x11
c60011|223344556677885f5f5f5f5f5f	32	plan9	MOVL $0x11, 0(AX)
c60011|223344556677885f5f5f5f5f5f	64	gnu	movb $0x11,(%rax)
c60011|223344556677885f5f5f5f5f5f	64	intel	mov byte ptr [rax], 0x11
c60011|223344556677885f5f5f5f5f5f	64	plan9	MOVL $0x11, 0(AX)
c6f811|223344556677885f5f5f5f5f5f	32	intel	xabort 0x11
c6f811|223344556677885f5f5f5f5f5f	32	plan9	XABORT $0x11
c6f811|223344556677885f5f5f5f5f5f	64	gnu	xabort $0x11
c6f811|223344556677885f5f5f5f5f5f	64	intel	xabort 0x11
c6f811|223344556677885f5f5f5f5f5f	64	plan9	XABORT $0x11
c70011223344|556677885f5f5f5f5f5f	32	intel	mov dword ptr [eax], 0x44332211
c70011223344|556677885f5f5f5f5f5f	32	plan9	MOVL $0x44332211, 0(AX)
c70011223344|556677885f5f5f5f5f5f	64	gnu	movl $0x44332211,(%rax)
c70011223344|556677885f5f5f5f5f5f	64	intel	mov dword ptr [rax], 0x44332211
c70011223344|556677885f5f5f5f5f5f	64	plan9	MOVL $0x44332211, 0(AX)
c7f811223344|556677885f5f5f5f5f5f	32	intel	xbegin .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	32	plan9	XBEGIN .+1144201745
c7f811223344|556677885f5f5f5f5f5f	64	gnu	xbeginq .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	64	intel	xbegin .+0x44332211
c7f811223344|556677885f5f5f5f5f5f	64	plan9	XBEGIN .+1144201745
c8112233|44556677885f5f5f5f5f5f5f	32	intel	enter 0x2211, 0x33
c8112233|44556677885f5f5f5f5f5f5f	32	plan9	ENTER $0x33, $0x2211
c8112233|44556677885f5f5f5f5f5f5f	64	gnu	enterq $0x2211,$0x33
c8112233|44556677885f5f5f5f5f5f5f	64	intel	enter 0x2211, 0x33
c8112233|44556677885f5f5f5f5f5f5f	64	plan9	ENTER $0x33, $0x2211
c9|11223344556677885f5f5f5f5f5f5f	32	intel	leave
c9|11223344556677885f5f5f5f5f5f5f	32	plan9	LEAVE
c9|11223344556677885f5f5f5f5f5f5f	64	gnu	leaveq
c9|11223344556677885f5f5f5f5f5f5f	64	intel	leave
c9|11223344556677885f5f5f5f5f5f5f	64	plan9	LEAVE
ca1122|3344556677885f5f5f5f5f5f5f	32	intel	ret far 0x2211
ca1122|3344556677885f5f5f5f5f5f5f	32	plan9	LRET $0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	gnu	lretq $0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	intel	ret far 0x2211
ca1122|3344556677885f5f5f5f5f5f5f	64	plan9	LRET $0x2211
cb|11223344556677885f5f5f5f5f5f5f	32	intel	ret far
cb|11223344556677885f5f5f5f5f5f5f	32	plan9	LRET
cb|11223344556677885f5f5f5f5f5f5f	64	gnu	lretq
cb|11223344556677885f5f5f5f5f5f5f	64	intel	ret far
cb|11223344556677885f5f5f5f5f5f5f	64	plan9	LRET
cc|11223344556677885f5f5f5f5f5f5f	32	intel	int3
cc|11223344556677885f5f5f5f5f5f5f	32	plan9	INT $0x3
cc|11223344556677885f5f5f5f5f5f5f	64	gnu	int3
cc|11223344556677885f5f5f5f5f5f5f	64	intel	int3
cc|11223344556677885f5f5f5f5f5f5f	64	plan9	INT $0x3
cd11|223344556677885f5f5f5f5f5f5f	32	intel	int 0x11
cd11|223344556677885f5f5f5f5f5f5f	32	plan9	INT $0x11
cd11|223344556677885f5f5f5f5f5f5f	64	gnu	int $0x11
cd11|223344556677885f5f5f5f5f5f5f	64	intel	int 0x11
cd11|223344556677885f5f5f5f5f5f5f	64	plan9	INT $0x11
ce|11223344556677885f5f5f5f5f5f5f	32	intel	into
ce|11223344556677885f5f5f5f5f5f5f	32	plan9	INTO
ce|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
ce|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
ce|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
cf|11223344556677885f5f5f5f5f5f5f	32	intel	iretd
cf|11223344556677885f5f5f5f5f5f5f	32	plan9	IRETD
cf|11223344556677885f5f5f5f5f5f5f	64	gnu	iret
cf|11223344556677885f5f5f5f5f5f5f	64	intel	iretd
cf|11223344556677885f5f5f5f5f5f5f	64	plan9	IRETD
d000|11223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], 0x1
d000|11223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x1, 0(AX)
d000|11223344556677885f5f5f5f5f5f	64	gnu	rolb (%rax)
d000|11223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], 0x1
d000|11223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x1, 0(AX)
d008|11223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], 0x1
d008|11223344556677885f5f5f5f5f5f	32	plan9	RORL $0x1, 0(AX)
d008|11223344556677885f5f5f5f5f5f	64	gnu	rorb (%rax)
d008|11223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], 0x1
d008|11223344556677885f5f5f5f5f5f	64	plan9	RORL $0x1, 0(AX)
d011|223344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], 0x1
d011|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x1, 0(CX)
d011|223344556677885f5f5f5f5f5f5f	64	gnu	rclb (%rcx)
d011|223344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], 0x1
d011|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x1, 0(CX)
d018|11223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], 0x1
d018|11223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x1, 0(AX)
d018|11223344556677885f5f5f5f5f5f	64	gnu	rcrb (%rax)
d018|11223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], 0x1
d018|11223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x1, 0(AX)
d020|11223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], 0x1
d020|11223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x1, 0(AX)
d020|11223344556677885f5f5f5f5f5f	64	gnu	shlb (%rax)
d020|11223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], 0x1
d020|11223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x1, 0(AX)
d028|11223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], 0x1
d028|11223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x1, 0(AX)
d028|11223344556677885f5f5f5f5f5f	64	gnu	shrb (%rax)
d028|11223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], 0x1
d028|11223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x1, 0(AX)
d038|11223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], 0x1
d038|11223344556677885f5f5f5f5f5f	32	plan9	SARL $0x1, 0(AX)
d038|11223344556677885f5f5f5f5f5f	64	gnu	sarb (%rax)
d038|11223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], 0x1
d038|11223344556677885f5f5f5f5f5f	64	plan9	SARL $0x1, 0(AX)
d100|11223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], 0x1
d100|11223344556677885f5f5f5f5f5f	32	plan9	ROLL $0x1, 0(AX)
d100|11223344556677885f5f5f5f5f5f	64	gnu	roll (%rax)
d100|11223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], 0x1
d100|11223344556677885f5f5f5f5f5f	64	plan9	ROLL $0x1, 0(AX)
d108|11223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], 0x1
d108|11223344556677885f5f5f5f5f5f	32	plan9	RORL $0x1, 0(AX)
d108|11223344556677885f5f5f5f5f5f	64	gnu	rorl (%rax)
d108|11223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], 0x1
d108|11223344556677885f5f5f5f5f5f	64	plan9	RORL $0x1, 0(AX)
d111|223344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], 0x1
d111|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL $0x1, 0(CX)
d111|223344556677885f5f5f5f5f5f5f	64	gnu	rcll (%rcx)
d111|223344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], 0x1
d111|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL $0x1, 0(CX)
d118|11223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], 0x1
d118|11223344556677885f5f5f5f5f5f	32	plan9	RCRL $0x1, 0(AX)
d118|11223344556677885f5f5f5f5f5f	64	gnu	rcrl (%rax)
d118|11223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], 0x1
d118|11223344556677885f5f5f5f5f5f	64	plan9	RCRL $0x1, 0(AX)
d120|11223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], 0x1
d120|11223344556677885f5f5f5f5f5f	32	plan9	SHLL $0x1, 0(AX)
d120|11223344556677885f5f5f5f5f5f	64	gnu	shll (%rax)
d120|11223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], 0x1
d120|11223344556677885f5f5f5f5f5f	64	plan9	SHLL $0x1, 0(AX)
d128|11223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], 0x1
d128|11223344556677885f5f5f5f5f5f	32	plan9	SHRL $0x1, 0(AX)
d128|11223344556677885f5f5f5f5f5f	64	gnu	shrl (%rax)
d128|11223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], 0x1
d128|11223344556677885f5f5f5f5f5f	64	plan9	SHRL $0x1, 0(AX)
d138|11223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], 0x1
d138|11223344556677885f5f5f5f5f5f	32	plan9	SARL $0x1, 0(AX)
d138|11223344556677885f5f5f5f5f5f	64	gnu	sarl (%rax)
d138|11223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], 0x1
d138|11223344556677885f5f5f5f5f5f	64	plan9	SARL $0x1, 0(AX)
d200|11223344556677885f5f5f5f5f5f	32	intel	rol byte ptr [eax], cl
d200|11223344556677885f5f5f5f5f5f	32	plan9	ROLL CL, 0(AX)
d200|11223344556677885f5f5f5f5f5f	64	gnu	rolb %cl,(%rax)
d200|11223344556677885f5f5f5f5f5f	64	intel	rol byte ptr [rax], cl
d200|11223344556677885f5f5f5f5f5f	64	plan9	ROLL CL, 0(AX)
d208|11223344556677885f5f5f5f5f5f	32	intel	ror byte ptr [eax], cl
d208|11223344556677885f5f5f5f5f5f	32	plan9	RORL CL, 0(AX)
d208|11223344556677885f5f5f5f5f5f	64	gnu	rorb %cl,(%rax)
d208|11223344556677885f5f5f5f5f5f	64	intel	ror byte ptr [rax], cl
d208|11223344556677885f5f5f5f5f5f	64	plan9	RORL CL, 0(AX)
d211|223344556677885f5f5f5f5f5f5f	32	intel	rcl byte ptr [ecx], cl
d211|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL CL, 0(CX)
d211|223344556677885f5f5f5f5f5f5f	64	gnu	rclb %cl,(%rcx)
d211|223344556677885f5f5f5f5f5f5f	64	intel	rcl byte ptr [rcx], cl
d211|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL CL, 0(CX)
d218|11223344556677885f5f5f5f5f5f	32	intel	rcr byte ptr [eax], cl
d218|11223344556677885f5f5f5f5f5f	32	plan9	RCRL CL, 0(AX)
d218|11223344556677885f5f5f5f5f5f	64	gnu	rcrb %cl,(%rax)
d218|11223344556677885f5f5f5f5f5f	64	intel	rcr byte ptr [rax], cl
d218|11223344556677885f5f5f5f5f5f	64	plan9	RCRL CL, 0(AX)
d220|11223344556677885f5f5f5f5f5f	32	intel	shl byte ptr [eax], cl
d220|11223344556677885f5f5f5f5f5f	32	plan9	SHLL CL, 0(AX)
d220|11223344556677885f5f5f5f5f5f	64	gnu	shlb %cl,(%rax)
d220|11223344556677885f5f5f5f5f5f	64	intel	shl byte ptr [rax], cl
d220|11223344556677885f5f5f5f5f5f	64	plan9	SHLL CL, 0(AX)
d228|11223344556677885f5f5f5f5f5f	32	intel	shr byte ptr [eax], cl
d228|11223344556677885f5f5f5f5f5f	32	plan9	SHRL CL, 0(AX)
d228|11223344556677885f5f5f5f5f5f	64	gnu	shrb %cl,(%rax)
d228|11223344556677885f5f5f5f5f5f	64	intel	shr byte ptr [rax], cl
d228|11223344556677885f5f5f5f5f5f	64	plan9	SHRL CL, 0(AX)
d238|11223344556677885f5f5f5f5f5f	32	intel	sar byte ptr [eax], cl
d238|11223344556677885f5f5f5f5f5f	32	plan9	SARL CL, 0(AX)
d238|11223344556677885f5f5f5f5f5f	64	gnu	sarb %cl,(%rax)
d238|11223344556677885f5f5f5f5f5f	64	intel	sar byte ptr [rax], cl
d238|11223344556677885f5f5f5f5f5f	64	plan9	SARL CL, 0(AX)
d300|11223344556677885f5f5f5f5f5f	32	intel	rol dword ptr [eax], cl
d300|11223344556677885f5f5f5f5f5f	32	plan9	ROLL CL, 0(AX)
d300|11223344556677885f5f5f5f5f5f	64	gnu	roll %cl,(%rax)
d300|11223344556677885f5f5f5f5f5f	64	intel	rol dword ptr [rax], cl
d300|11223344556677885f5f5f5f5f5f	64	plan9	ROLL CL, 0(AX)
d308|11223344556677885f5f5f5f5f5f	32	intel	ror dword ptr [eax], cl
d308|11223344556677885f5f5f5f5f5f	32	plan9	RORL CL, 0(AX)
d308|11223344556677885f5f5f5f5f5f	64	gnu	rorl %cl,(%rax)
d308|11223344556677885f5f5f5f5f5f	64	intel	ror dword ptr [rax], cl
d308|11223344556677885f5f5f5f5f5f	64	plan9	RORL CL, 0(AX)
d311|223344556677885f5f5f5f5f5f5f	32	intel	rcl dword ptr [ecx], cl
d311|223344556677885f5f5f5f5f5f5f	32	plan9	RCLL CL, 0(CX)
d311|223344556677885f5f5f5f5f5f5f	64	gnu	rcll %cl,(%rcx)
d311|223344556677885f5f5f5f5f5f5f	64	intel	rcl dword ptr [rcx], cl
d311|223344556677885f5f5f5f5f5f5f	64	plan9	RCLL CL, 0(CX)
d318|11223344556677885f5f5f5f5f5f	32	intel	rcr dword ptr [eax], cl
d318|11223344556677885f5f5f5f5f5f	32	plan9	RCRL CL, 0(AX)
d318|11223344556677885f5f5f5f5f5f	64	gnu	rcrl %cl,(%rax)
d318|11223344556677885f5f5f5f5f5f	64	intel	rcr dword ptr [rax], cl
d318|11223344556677885f5f5f5f5f5f	64	plan9	RCRL CL, 0(AX)
d320|11223344556677885f5f5f5f5f5f	32	intel	shl dword ptr [eax], cl
d320|11223344556677885f5f5f5f5f5f	32	plan9	SHLL CL, 0(AX)
d320|11223344556677885f5f5f5f5f5f	64	gnu	shll %cl,(%rax)
d320|11223344556677885f5f5f5f5f5f	64	intel	shl dword ptr [rax], cl
d320|11223344556677885f5f5f5f5f5f	64	plan9	SHLL CL, 0(AX)
d328|11223344556677885f5f5f5f5f5f	32	intel	shr dword ptr [eax], cl
d328|11223344556677885f5f5f5f5f5f	32	plan9	SHRL CL, 0(AX)
d328|11223344556677885f5f5f5f5f5f	64	gnu	shrl %cl,(%rax)
d328|11223344556677885f5f5f5f5f5f	64	intel	shr dword ptr [rax], cl
d328|11223344556677885f5f5f5f5f5f	64	plan9	SHRL CL, 0(AX)
d338|11223344556677885f5f5f5f5f5f	32	intel	sar dword ptr [eax], cl
d338|11223344556677885f5f5f5f5f5f	32	plan9	SARL CL, 0(AX)
d338|11223344556677885f5f5f5f5f5f	64	gnu	sarl %cl,(%rax)
d338|11223344556677885f5f5f5f5f5f	64	intel	sar dword ptr [rax], cl
d338|11223344556677885f5f5f5f5f5f	64	plan9	SARL CL, 0(AX)
d511|223344556677885f5f5f5f5f5f5f	32	intel	aad 0x11
d511|223344556677885f5f5f5f5f5f5f	32	plan9	AAD $0x11
d5|11223344556677885f5f5f5f5f5f5f	64	gnu	error: unrecognized instruction
d5|11223344556677885f5f5f5f5f5f5f	64	intel	error: unrecognized instruction
d5|11223344556677885f5f5f5f5f5f5f	64	plan9	error: unrecognized instruction
d800|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, dword ptr [eax]
d800|11223344556677885f5f5f5f5f5f	32	plan9	FADD 0(AX)
d800|11223344556677885f5f5f5f5f5f	64	gnu	fadds (%rax)
d800|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, dword ptr [rax]
d800|11223344556677885f5f5f5f5f5f	64	plan9	FADD 0(AX)
d808|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, dword ptr [eax]
d808|11223344556677885f5f5f5f5f5f	32	plan9	FMUL 0(AX)
d808|11223344556677885f5f5f5f5f5f	64	gnu	fmuls (%rax)
d808|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, dword ptr [rax]
d808|11223344556677885f5f5f5f5f5f	64	plan9	FMUL 0(AX)
d811|223344556677885f5f5f5f5f5f5f	32	intel	fcom st0, dword ptr [ecx]
d811|223344556677885f5f5f5f5f5f5f	32	plan9	FCOM 0(CX)
d811|223344556677885f5f5f5f5f5f5f	64	gnu	fcoms (%rcx)
d811|223344556677885f5f5f5f5f5f5f	64	intel	fcom st0, dword ptr [rcx]
d811|223344556677885f5f5f5f5f5f5f	64	plan9	FCOM 0(CX)
d818|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, dword ptr [eax]
d818|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP 0(AX)
d818|11223344556677885f5f5f5f5f5f	64	gnu	fcomps (%rax)
d818|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, dword ptr [rax]
d818|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP 0(AX)
d820|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, dword ptr [eax]
d820|11223344556677885f5f5f5f5f5f	32	plan9	FSUB 0(AX)
d820|11223344556677885f5f5f5f5f5f	64	gnu	fsubs (%rax)
d820|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, dword ptr [rax]
d820|11223344556677885f5f5f5f5f5f	64	plan9	FSUB 0(AX)
d828|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, dword ptr [eax]
d828|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR 0(AX)
d828|11223344556677885f5f5f5f5f5f	64	gnu	fsubrs (%rax)
d828|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, dword ptr [rax]
d828|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR 0(AX)
d830|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, dword ptr [eax]
d830|11223344556677885f5f5f5f5f5f	32	plan9	FDIV 0(AX)
d830|11223344556677885f5f5f5f5f5f	64	gnu	fdivs (%rax)
d830|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, dword ptr [rax]
d830|11223344556677885f5f5f5f5f5f	64	plan9	FDIV 0(AX)
d838|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, dword ptr [eax]
d838|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR 0(AX)
d838|11223344556677885f5f5f5f5f5f	64	gnu	fdivrs (%rax)
d838|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, dword ptr [rax]
d838|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR 0(AX)
d8c0|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, st0
d8c0|11223344556677885f5f5f5f5f5f	32	plan9	FADD F0, F0
d8c0|11223344556677885f5f5f5f5f5f	64	gnu	fadd %st,%st
d8c0|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, st0
d8c0|11223344556677885f5f5f5f5f5f	64	plan9	FADD F0, F0
d8c8|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, st0
d8c8|11223344556677885f5f5f5f5f5f	32	plan9	FMUL F0, F0
d8c8|11223344556677885f5f5f5f5f5f	64	gnu	fmul %st,%st
d8c8|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, st0
d8c8|11223344556677885f5f5f5f5f5f	64	plan9	FMUL F0, F0
d8d0|11223344556677885f5f5f5f5f5f	32	intel	fcom st0, st0
d8d0|11223344556677885f5f5f5f5f5f	32	plan9	FCOM F0
d8d0|11223344556677885f5f5f5f5f5f	64	gnu	fcom %st
d8d0|11223344556677885f5f5f5f5f5f	64	intel	fcom st0, st0
d8d0|11223344556677885f5f5f5f5f5f	64	plan9	FCOM F0
d8d8|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, st0
d8d8|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP F0
d8d8|11223344556677885f5f5f5f5f5f	64	gnu	fcomp %st
d8d8|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, st0
d8d8|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP F0
d8e0|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, st0
d8e0|11223344556677885f5f5f5f5f5f	32	plan9	FSUB F0, F0
d8e0|11223344556677885f5f5f5f5f5f	64	gnu	fsub %st,%st
d8e0|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, st0
d8e0|11223344556677885f5f5f5f5f5f	64	plan9	FSUB F0, F0
d8e8|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, st0
d8e8|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR F0, F0
d8e8|11223344556677885f5f5f5f5f5f	64	gnu	fsubr %st,%st
d8e8|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, st0
d8e8|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR F0, F0
d8f0|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, st0
d8f0|11223344556677885f5f5f5f5f5f	32	plan9	FDIV F0, F0
d8f0|11223344556677885f5f5f5f5f5f	64	gnu	fdiv %st,%st
d8f0|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, st0
d8f0|11223344556677885f5f5f5f5f5f	64	plan9	FDIV F0, F0
d8f8|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, st0
d8f8|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR F0, F0
d8f8|11223344556677885f5f5f5f5f5f	64	gnu	fdivr %st,%st
d8f8|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, st0
d8f8|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR F0, F0
d900|11223344556677885f5f5f5f5f5f	32	intel	fld st0, dword ptr [eax]
d900|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
d900|11223344556677885f5f5f5f5f5f	64	gnu	flds (%rax)
d900|11223344556677885f5f5f5f5f5f	64	intel	fld st0, dword ptr [rax]
d900|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
d911|223344556677885f5f5f5f5f5f5f	32	intel	fst dword ptr [ecx], st0
d911|223344556677885f5f5f5f5f5f5f	32	plan9	FST 0(CX)
d911|223344556677885f5f5f5f5f5f5f	64	gnu	fsts (%rcx)
d911|223344556677885f5f5f5f5f5f5f	64	intel	fst dword ptr [rcx], st0
d911|223344556677885f5f5f5f5f5f5f	64	plan9	FST 0(CX)
d918|11223344556677885f5f5f5f5f5f	32	intel	fstp dword ptr [eax], st0
d918|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
d918|11223344556677885f5f5f5f5f5f	64	gnu	fstps (%rax)
d918|11223344556677885f5f5f5f5f5f	64	intel	fstp dword ptr [rax], st0
d918|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
d928|11223344556677885f5f5f5f5f5f	32	intel	fldcw word ptr [eax]
d928|11223344556677885f5f5f5f5f5f	32	plan9	FLDCW 0(AX)
d928|11223344556677885f5f5f5f5f5f	64	gnu	fldcw (%rax)
d928|11223344556677885f5f5f5f5f5f	64	intel	fldcw word ptr [rax]
d928|11223344556677885f5f5f5f5f5f	64	plan9	FLDCW 0(AX)
d930|11223344556677885f5f5f5f5f5f	32	intel	fnstenv ptr [eax]
d930|11223344556677885f5f5f5f5f5f	32	plan9	FNSTENV 0(AX)
d930|11223344556677885f5f5f5f5f5f	64	gnu	fnstenv (%rax)
d930|11223344556677885f5f5f5f5f5f	64	intel	fnstenv ptr [rax]
d930|11223344556677885f5f5f5f5f5f	64	plan9	FNSTENV 0(AX)
d938|11223344556677885f5f5f5f5f5f	32	intel	fnstcw word ptr [eax]
d938|11223344556677885f5f5f5f5f5f	32	plan9	FNSTCW 0(AX)
d938|11223344556677885f5f5f5f5f5f	64	gnu	fnstcw (%rax)
d938|11223344556677885f5f5f5f5f5f	64	intel	fnstcw word ptr [rax]
d938|11223344556677885f5f5f5f5f5f	64	plan9	FNSTCW 0(AX)
d9c0|11223344556677885f5f5f5f5f5f	32	intel	fld st0, st0
d9c0|11223344556677885f5f5f5f5f5f	32	plan9	FLD F0
d9c0|11223344556677885f5f5f5f5f5f	64	gnu	fld %st
d9c0|11223344556677885f5f5f5f5f5f	64	intel	fld st0, st0
d9c0|11223344556677885f5f5f5f5f5f	64	plan9	FLD F0
d9c8|11223344556677885f5f5f5f5f5f	32	intel	fxch st0, st0
d9c8|11223344556677885f5f5f5f5f5f	32	plan9	FXCH F0
d9c8|11223344556677885f5f5f5f5f5f	64	gnu	fxch %st
d9c8|11223344556677885f5f5f5f5f5f	64	intel	fxch st0, st0
d9c8|11223344556677885f5f5f5f5f5f	64	plan9	FXCH F0
d9d0|11223344556677885f5f5f5f5f5f	32	intel	fnop
d9d0|11223344556677885f5f5f5f5f5f	32	plan9	FNOP
d9d0|11223344556677885f5f5f5f5f5f	64	gnu	fnop
d9d0|11223344556677885f5f5f5f5f5f	64	intel	fnop
d9d0|11223344556677885f5f5f5f5f5f	64	plan9	FNOP
d9e0|11223344556677885f5f5f5f5f5f	32	intel	fchs st0
d9e0|11223344556677885f5f5f5f5f5f	32	plan9	FCHS
d9e0|11223344556677885f5f5f5f5f5f	64	gnu	fchs
d9e0|11223344556677885f5f5f5f5f5f	64	intel	fchs st0
d9e0|11223344556677885f5f5f5f5f5f	64	plan9	FCHS
d9e1|11223344556677885f5f5f5f5f5f	32	intel	fabs st0
d9e1|11223344556677885f5f5f5f5f5f	32	plan9	FABS
d9e1|11223344556677885f5f5f5f5f5f	64	gnu	fabs
d9e1|11223344556677885f5f5f5f5f5f	64	intel	fabs st0
d9e1|11223344556677885f5f5f5f5f5f	64	plan9	FABS
d9e4|11223344556677885f5f5f5f5f5f	32	intel	ftst st0
d9e4|11223344556677885f5f5f5f5f5f	32	plan9	FTST
d9e4|11223344556677885f5f5f5f5f5f	64	gnu	ftst
d9e4|11223344556677885f5f5f5f5f5f	64	intel	ftst st0
d9e4|11223344556677885f5f5f5f5f5f	64	plan9	FTST
d9e5|11223344556677885f5f5f5f5f5f	32	intel	fxam st0
d9e5|11223344556677885f5f5f5f5f5f	32	plan9	FXAM
d9e5|11223344556677885f5f5f5f5f5f	64	gnu	fxam
d9e5|11223344556677885f5f5f5f5f5f	64	intel	fxam st0
d9e5|11223344556677885f5f5f5f5f5f	64	plan9	FXAM
d9e8|11223344556677885f5f5f5f5f5f	32	intel	fld1 st0
d9e8|11223344556677885f5f5f5f5f5f	32	plan9	FLD1
d9e8|11223344556677885f5f5f5f5f5f	64	gnu	fld1
d9e8|11223344556677885f5f5f5f5f5f	64	intel	fld1 st0
d9e8|11223344556677885f5f5f5f5f5f	64	plan9	FLD1
d9e9|11223344556677885f5f5f5f5f5f	32	intel	fldl2t st0
d9e9|11223344556677885f5f5f5f5f5f	32	plan9	FLDL2T
d9e9|11223344556677885f5f5f5f5f5f	64	gnu	fldl2t
d9e9|11223344556677885f5f5f5f5f5f	64	intel	fldl2t st0
d9e9|11223344556677885f5f5f5f5f5f	64	plan9	FLDL2T
d9ea|11223344556677885f5f5f5f5f5f	32	intel	fldl2e st0
d9ea|11223344556677885f5f5f5f5f5f	32	plan9	FLDL2E
d9ea|11223344556677885f5f5f5f5f5f	64	gnu	fldl2e
d9ea|11223344556677885f5f5f5f5f5f	64	intel	fldl2e st0
d9ea|11223344556677885f5f5f5f5f5f	64	plan9	FLDL2E
d9eb|11223344556677885f5f5f5f5f5f	32	intel	fldpi st0
d9eb|11223344556677885f5f5f5f5f5f	32	plan9	FLDPI
d9eb|11223344556677885f5f5f5f5f5f	64	gnu	fldpi
d9eb|11223344556677885f5f5f5f5f5f	64	intel	fldpi st0
d9eb|11223344556677885f5f5f5f5f5f	64	plan9	FLDPI
d9ec|11223344556677885f5f5f5f5f5f	32	intel	fldlg2 st0
d9ec|11223344556677885f5f5f5f5f5f	32	plan9	FLDLG2
d9ec|11223344556677885f5f5f5f5f5f	64	gnu	fldlg2
d9ec|11223344556677885f5f5f5f5f5f	64	intel	fldlg2 st0
d9ec|11223344556677885f5f5f5f5f5f	64	plan9	FLDLG2
d9f0|11223344556677885f5f5f5f5f5f	32	intel	f2xm1 st0
d9f0|11223344556677885f5f5f5f5f5f	32	plan9	F2XM1
d9f0|11223344556677885f5f5f5f5f5f	64	gnu	f2xm1
d9f0|11223344556677885f5f5f5f5f5f	64	intel	f2xm1 st0
d9f0|11223344556677885f5f5f5f5f5f	64	plan9	F2XM1
d9f1|11223344556677885f5f5f5f5f5f	32	intel	fyl2x st0, st1
d9f1|11223344556677885f5f5f5f5f5f	32	plan9	FYL2X
d9f1|11223344556677885f5f5f5f5f5f	64	gnu	fyl2x
d9f1|11223344556677885f5f5f5f5f5f	64	intel	fyl2x st0, st1
d9f1|11223344556677885f5f5f5f5f5f	64	plan9	FYL2X
d9f2|11223344556677885f5f5f5f5f5f	32	intel	fptan st0, st1
d9f2|11223344556677885f5f5f5f5f5f	32	plan9	FPTAN
d9f2|11223344556677885f5f5f5f5f5f	64	gnu	fptan
d9f2|11223344556677885f5f5f5f5f5f	64	intel	fptan st0, st1
d9f2|11223344556677885f5f5f5f5f5f	64	plan9	FPTAN
d9f3|11223344556677885f5f5f5f5f5f	32	intel	fpatan st0, st1
d9f3|11223344556677885f5f5f5f5f5f	32	plan9	FPATAN
d9f3|11223344556677885f5f5f5f5f5f	64	gnu	fpatan
d9f3|11223344556677885f5f5f5f5f5f	64	intel	fpatan st0, st1
d9f3|11223344556677885f5f5f5f5f5f	64	plan9	FPATAN
d9f4|11223344556677885f5f5f5f5f5f	32	intel	fxtract st0, st1
d9f4|11223344556677885f5f5f5f5f5f	32	plan9	FXTRACT
d9f4|11223344556677885f5f5f5f5f5f	64	gnu	fxtract
d9f4|11223344556677885f5f5f5f5f5f	64	intel	fxtract st0, st1
d9f4|11223344556677885f5f5f5f5f5f	64	plan9	FXTRACT
d9f5|11223344556677885f5f5f5f5f5f	32	intel	fprem1 st0, st1
d9f5|11223344556677885f5f5f5f5f5f	32	plan9	FPREM1
d9f5|11223344556677885f5f5f5f5f5f	64	gnu	fprem1
d9f5|11223344556677885f5f5f5f5f5f	64	intel	fprem1 st0, st1
d9f5|11223344556677885f5f5f5f5f5f	64	plan9	FPREM1
d9f6|11223344556677885f5f5f5f5f5f	32	intel	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	32	plan9	FDECSTP
d9f6|11223344556677885f5f5f5f5f5f	64	gnu	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	64	intel	fdecstp
d9f6|11223344556677885f5f5f5f5f5f	64	plan9	FDECSTP
d9f7|11223344556677885f5f5f5f5f5f	32	intel	fincstp
d9f7|11223344556677885f5f5f5f5f5f	32	plan9	FINCSTP
d9f7|11223344556677885f5f5f5f5f5f	64	gnu	fincstp
d9f7|11223344556677885f5f5f5f5f5f	64	intel	fincstp
d9f7|11223344556677885f5f5f5f5f5f	64	plan9	FINCSTP
d9f8|11223344556677885f5f5f5f5f5f	32	intel	fprem st0, st1
d9f8|11223344556677885f5f5f5f5f5f	32	plan9	FPREM
d9f8|11223344556677885f5f5f5f5f5f	64	gnu	fprem
d9f8|11223344556677885f5f5f5f5f5f	64	intel	fprem st0, st1
d9f8|11223344556677885f5f5f5f5f5f	64	plan9	FPREM
d9f9|11223344556677885f5f5f5f5f5f	32	intel	fyl2xp1 st0, st1
d9f9|11223344556677885f5f5f5f5f5f	32	plan9	FYL2XP1
d9f9|11223344556677885f5f5f5f5f5f	64	gnu	fyl2xp1
d9f9|11223344556677885f5f5f5f5f5f	64	intel	fyl2xp1 st0, st1
d9f9|11223344556677885f5f5f5f5f5f	64	plan9	FYL2XP1
d9fa|11223344556677885f5f5f5f5f5f	32	intel	fsqrt st0
d9fa|11223344556677885f5f5f5f5f5f	32	plan9	FSQRT
d9fa|11223344556677885f5f5f5f5f5f	64	gnu	fsqrt
d9fa|11223344556677885f5f5f5f5f5f	64	intel	fsqrt st0
d9fa|11223344556677885f5f5f5f5f5f	64	plan9	FSQRT
d9fb|11223344556677885f5f5f5f5f5f	32	intel	fsincos st0, st1
d9fb|11223344556677885f5f5f5f5f5f	32	plan9	FSINCOS
d9fb|11223344556677885f5f5f5f5f5f	64	gnu	fsincos
d9fb|11223344556677885f5f5f5f5f5f	64	intel	fsincos st0, st1
d9fb|11223344556677885f5f5f5f5f5f	64	plan9	FSINCOS
d9fc|11223344556677885f5f5f5f5f5f	32	intel	frndint st0
d9fc|11223344556677885f5f5f5f5f5f	32	plan9	FRNDINT
d9fc|11223344556677885f5f5f5f5f5f	64	gnu	frndint
d9fc|11223344556677885f5f5f5f5f5f	64	intel	frndint st0
d9fc|11223344556677885f5f5f5f5f5f	64	plan9	FRNDINT
d9fd|11223344556677885f5f5f5f5f5f	32	intel	fscale st0, st1
d9fd|11223344556677885f5f5f5f5f5f	32	plan9	FSCALE
d9fd|11223344556677885f5f5f5f5f5f	64	gnu	fscale
d9fd|11223344556677885f5f5f5f5f5f	64	intel	fscale st0, st1
d9fd|11223344556677885f5f5f5f5f5f	64	plan9	FSCALE
d9fe|11223344556677885f5f5f5f5f5f	32	intel	fsin st0
d9fe|11223344556677885f5f5f5f5f5f	32	plan9	FSIN
d9fe|11223344556677885f5f5f5f5f5f	64	gnu	fsin
d9fe|11223344556677885f5f5f5f5f5f	64	intel	fsin st0
d9fe|11223344556677885f5f5f5f5f5f	64	plan9	FSIN
d9ff|11223344556677885f5f5f5f5f5f	32	intel	fcos st0
d9ff|11223344556677885f5f5f5f5f5f	32	plan9	FCOS
d9ff|11223344556677885f5f5f5f5f5f	64	gnu	fcos
d9ff|11223344556677885f5f5f5f5f5f	64	intel	fcos st0
d9ff|11223344556677885f5f5f5f5f5f	64	plan9	FCOS
da00|11223344556677885f5f5f5f5f5f	32	intel	fiadd st0, dword ptr [eax]
da00|11223344556677885f5f5f5f5f5f	32	plan9	FIADD 0(AX)
da00|11223344556677885f5f5f5f5f5f	64	gnu	fiaddl (%rax)
da00|11223344556677885f5f5f5f5f5f	64	intel	fiadd st0, dword ptr [rax]
da00|11223344556677885f5f5f5f5f5f	64	plan9	FIADD 0(AX)
da08|11223344556677885f5f5f5f5f5f	32	intel	fimul st0, dword ptr [eax]
da08|11223344556677885f5f5f5f5f5f	32	plan9	FIMUL 0(AX)
da08|11223344556677885f5f5f5f5f5f	64	gnu	fimull (%rax)
da08|11223344556677885f5f5f5f5f5f	64	intel	fimul st0, dword ptr [rax]
da08|11223344556677885f5f5f5f5f5f	64	plan9	FIMUL 0(AX)
da11|223344556677885f5f5f5f5f5f5f	32	intel	ficom st0, dword ptr [ecx]
da11|223344556677885f5f5f5f5f5f5f	32	plan9	FICOM 0(CX)
da11|223344556677885f5f5f5f5f5f5f	64	gnu	ficoml (%rcx)
da11|223344556677885f5f5f5f5f5f5f	64	intel	ficom st0, dword ptr [rcx]
da11|223344556677885f5f5f5f5f5f5f	64	plan9	FICOM 0(CX)
da18|11223344556677885f5f5f5f5f5f	32	intel	ficomp st0, dword ptr [eax]
da18|11223344556677885f5f5f5f5f5f	32	plan9	FICOMP 0(AX)
da18|11223344556677885f5f5f5f5f5f	64	gnu	ficompl (%rax)
da18|11223344556677885f5f5f5f5f5f	64	intel	ficomp st0, dword ptr [rax]
da18|11223344556677885f5f5f5f5f5f	64	plan9	FICOMP 0(AX)
da20|11223344556677885f5f5f5f5f5f	32	intel	fisub st0, dword ptr [eax]
da20|11223344556677885f5f5f5f5f5f	32	plan9	FISUB 0(AX)
da20|11223344556677885f5f5f5f5f5f	64	gnu	fisubl (%rax)
da20|11223344556677885f5f5f5f5f5f	64	intel	fisub st0, dword ptr [rax]
da20|11223344556677885f5f5f5f5f5f	64	plan9	FISUB 0(AX)
da28|11223344556677885f5f5f5f5f5f	32	intel	fisubr st0, dword ptr [eax]
da28|11223344556677885f5f5f5f5f5f	32	plan9	FISUBR 0(AX)
da28|11223344556677885f5f5f5f5f5f	64	gnu	fisubrl (%rax)
da28|11223344556677885f5f5f5f5f5f	64	intel	fisubr st0, dword ptr [rax]
da28|11223344556677885f5f5f5f5f5f	64	plan9	FISUBR 0(AX)
da30|11223344556677885f5f5f5f5f5f	32	intel	fidiv st0, dword ptr [eax]
da30|11223344556677885f5f5f5f5f5f	32	plan9	FIDIV 0(AX)
da30|11223344556677885f5f5f5f5f5f	64	gnu	fidivl (%rax)
da30|11223344556677885f5f5f5f5f5f	64	intel	fidiv st0, dword ptr [rax]
da30|11223344556677885f5f5f5f5f5f	64	plan9	FIDIV 0(AX)
da38|11223344556677885f5f5f5f5f5f	32	intel	fidivr st0, dword ptr [eax]
da38|11223344556677885f5f5f5f5f5f	32	plan9	FIDIVR 0(AX)
da38|11223344556677885f5f5f5f5f5f	64	gnu	fidivrl (%rax)
da38|11223344556677885f5f5f5f5f5f	64	intel	fidivr st0, dword ptr [rax]
da38|11223344556677885f5f5f5f5f5f	64	plan9	FIDIVR 0(AX)
dac0|11223344556677885f5f5f5f5f5f	32	intel	fcmovb st0, st0
dac0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVB F0, F0
dac0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovb %st,%st
dac0|11223344556677885f5f5f5f5f5f	64	intel	fcmovb st0, st0
dac0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVB F0, F0
dac8|11223344556677885f5f5f5f5f5f	32	intel	fcmove st0, st0
dac8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVE F0, F0
dac8|11223344556677885f5f5f5f5f5f	64	gnu	fcmove %st,%st
dac8|11223344556677885f5f5f5f5f5f	64	intel	fcmove st0, st0
dac8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVE F0, F0
dad0|11223344556677885f5f5f5f5f5f	32	intel	fcmovbe st0, st0
dad0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVBE F0, F0
dad0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovbe %st,%st
dad0|11223344556677885f5f5f5f5f5f	64	intel	fcmovbe st0, st0
dad0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVBE F0, F0
dad8|11223344556677885f5f5f5f5f5f	32	intel	fcmovu st0, st0
dad8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVU F0, F0
dad8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovu %st,%st
dad8|11223344556677885f5f5f5f5f5f	64	intel	fcmovu st0, st0
dad8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVU F0, F0
dae9|11223344556677885f5f5f5f5f5f	32	intel	fucompp st0, st1
dae9|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMPP
dae9|11223344556677885f5f5f5f5f5f	64	gnu	fucompp
dae9|11223344556677885f5f5f5f5f5f	64	intel	fucompp st0, st1
dae9|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMPP
db00|11223344556677885f5f5f5f5f5f	32	intel	fild st0, dword ptr [eax]
db00|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
db00|11223344556677885f5f5f5f5f5f	64	gnu	fildl (%rax)
db00|11223344556677885f5f5f5f5f5f	64	intel	fild st0, dword ptr [rax]
db00|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
db08|11223344556677885f5f5f5f5f5f	32	intel	fisttp dword ptr [eax], st0
db08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
db08|11223344556677885f5f5f5f5f5f	64	gnu	fisttpl (%rax)
db08|11223344556677885f5f5f5f5f5f	64	intel	fisttp dword ptr [rax], st0
db08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
db11|223344556677885f5f5f5f5f5f5f	32	intel	fist dword ptr [ecx], st0
db11|223344556677885f5f5f5f5f5f5f	32	plan9	FIST 0(CX)
db11|223344556677885f5f5f5f5f5f5f	64	gnu	fistl (%rcx)
db11|223344556677885f5f5f5f5f5f5f	64	intel	fist dword ptr [rcx], st0
db11|223344556677885f5f5f5f5f5f5f	64	plan9	FIST 0(CX)
db18|11223344556677885f5f5f5f5f5f	32	intel	fistp dword ptr [eax], st0
db18|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
db18|11223344556677885f5f5f5f5f5f	64	gnu	fistpl (%rax)
db18|11223344556677885f5f5f5f5f5f	64	intel	fistp dword ptr [rax], st0
db18|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
db28|11223344556677885f5f5f5f5f5f	32	intel	fld st0, ptr [eax]
db28|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
db28|11223344556677885f5f5f5f5f5f	64	gnu	fldt (%rax)
db28|11223344556677885f5f5f5f5f5f	64	intel	fld st0, ptr [rax]
db28|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
db38|11223344556677885f5f5f5f5f5f	32	intel	fstp ptr [eax], st0
db38|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
db38|11223344556677885f5f5f5f5f5f	64	gnu	fstpt (%rax)
db38|11223344556677885f5f5f5f5f5f	64	intel	fstp ptr [rax], st0
db38|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
dbc0|11223344556677885f5f5f5f5f5f	32	intel	fcmovnb st0, st0
dbc0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNB F0, F0
dbc0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnb %st,%st
dbc0|11223344556677885f5f5f5f5f5f	64	intel	fcmovnb st0, st0
dbc0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNB F0, F0
dbc8|11223344556677885f5f5f5f5f5f	32	intel	fcmovne st0, st0
dbc8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNE F0, F0
dbc8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovne %st,%st
dbc8|11223344556677885f5f5f5f5f5f	64	intel	fcmovne st0, st0
dbc8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNE F0, F0
dbd0|11223344556677885f5f5f5f5f5f	32	intel	fcmovnbe st0, st0
dbd0|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNBE F0, F0
dbd0|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnbe %st,%st
dbd0|11223344556677885f5f5f5f5f5f	64	intel	fcmovnbe st0, st0
dbd0|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNBE F0, F0
dbd8|11223344556677885f5f5f5f5f5f	32	intel	fcmovnu st0, st0
dbd8|11223344556677885f5f5f5f5f5f	32	plan9	FCMOVNU F0, F0
dbd8|11223344556677885f5f5f5f5f5f	64	gnu	fcmovnu %st,%st
dbd8|11223344556677885f5f5f5f5f5f	64	intel	fcmovnu st0, st0
dbd8|11223344556677885f5f5f5f5f5f	64	plan9	FCMOVNU F0, F0
dbe2|11223344556677885f5f5f5f5f5f	32	intel	fnclex
dbe2|11223344556677885f5f5f5f5f5f	32	plan9	FNCLEX
dbe2|11223344556677885f5f5f5f5f5f	64	gnu	fnclex
dbe2|11223344556677885f5f5f5f5f5f	64	intel	fnclex
dbe2|11223344556677885f5f5f5f5f5f	64	plan9	FNCLEX
dbe3|11223344556677885f5f5f5f5f5f	32	intel	fninit
dbe3|11223344556677885f5f5f5f5f5f	32	plan9	FNINIT
dbe3|11223344556677885f5f5f5f5f5f	64	gnu	fninit
dbe3|11223344556677885f5f5f5f5f5f	64	intel	fninit
dbe3|11223344556677885f5f5f5f5f5f	64	plan9	FNINIT
dbe8|11223344556677885f5f5f5f5f5f	32	intel	fucomi st0, st0
dbe8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMI F0, F0
dbe8|11223344556677885f5f5f5f5f5f	64	gnu	fucomi %st,%st
dbe8|11223344556677885f5f5f5f5f5f	64	intel	fucomi st0, st0
dbe8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMI F0, F0
dbf0|11223344556677885f5f5f5f5f5f	32	intel	fcomi st0, st0
dbf0|11223344556677885f5f5f5f5f5f	32	plan9	FCOMI F0, F0
dbf0|11223344556677885f5f5f5f5f5f	64	gnu	fcomi %st,%st
dbf0|11223344556677885f5f5f5f5f5f	64	intel	fcomi st0, st0
dbf0|11223344556677885f5f5f5f5f5f	64	plan9	FCOMI F0, F0
dc00|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, qword ptr [eax]
dc00|11223344556677885f5f5f5f5f5f	32	plan9	FADD 0(AX)
dc00|11223344556677885f5f5f5f5f5f	64	gnu	faddl (%rax)
dc00|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, qword ptr [rax]
dc00|11223344556677885f5f5f5f5f5f	64	plan9	FADD 0(AX)
dc08|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, qword ptr [eax]
dc08|11223344556677885f5f5f5f5f5f	32	plan9	FMUL 0(AX)
dc08|11223344556677885f5f5f5f5f5f	64	gnu	fmull (%rax)
dc08|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, qword ptr [rax]
dc08|11223344556677885f5f5f5f5f5f	64	plan9	FMUL 0(AX)
dc11|223344556677885f5f5f5f5f5f5f	32	intel	fcom st0, qword ptr [ecx]
dc11|223344556677885f5f5f5f5f5f5f	32	plan9	FCOM 0(CX)
dc11|223344556677885f5f5f5f5f5f5f	64	gnu	fcoml (%rcx)
dc11|223344556677885f5f5f5f5f5f5f	64	intel	fcom st0, qword ptr [rcx]
dc11|223344556677885f5f5f5f5f5f5f	64	plan9	FCOM 0(CX)
dc18|11223344556677885f5f5f5f5f5f	32	intel	fcomp st0, qword ptr [eax]
dc18|11223344556677885f5f5f5f5f5f	32	plan9	FCOMP 0(AX)
dc18|11223344556677885f5f5f5f5f5f	64	gnu	fcompl (%rax)
dc18|11223344556677885f5f5f5f5f5f	64	intel	fcomp st0, qword ptr [rax]
dc18|11223344556677885f5f5f5f5f5f	64	plan9	FCOMP 0(AX)
dc20|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, qword ptr [eax]
dc20|11223344556677885f5f5f5f5f5f	32	plan9	FSUB 0(AX)
dc20|11223344556677885f5f5f5f5f5f	64	gnu	fsubl (%rax)
dc20|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, qword ptr [rax]
dc20|11223344556677885f5f5f5f5f5f	64	plan9	FSUB 0(AX)
dc28|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, qword ptr [eax]
dc28|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR 0(AX)
dc28|11223344556677885f5f5f5f5f5f	64	gnu	fsubrl (%rax)
dc28|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, qword ptr [rax]
dc28|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR 0(AX)
dc30|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, qword ptr [eax]
dc30|11223344556677885f5f5f5f5f5f	32	plan9	FDIV 0(AX)
dc30|11223344556677885f5f5f5f5f5f	64	gnu	fdivl (%rax)
dc30|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, qword ptr [rax]
dc30|11223344556677885f5f5f5f5f5f	64	plan9	FDIV 0(AX)
dc38|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, qword ptr [eax]
dc38|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR 0(AX)
dc38|11223344556677885f5f5f5f5f5f	64	gnu	fdivrl (%rax)
dc38|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, qword ptr [rax]
dc38|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR 0(AX)
dcc0|11223344556677885f5f5f5f5f5f	32	intel	fadd st0, st0
dcc0|11223344556677885f5f5f5f5f5f	32	plan9	FADD F0, F0
dcc0|11223344556677885f5f5f5f5f5f	64	gnu	fadd %st,%st
dcc0|11223344556677885f5f5f5f5f5f	64	intel	fadd st0, st0
dcc0|11223344556677885f5f5f5f5f5f	64	plan9	FADD F0, F0
dcc8|11223344556677885f5f5f5f5f5f	32	intel	fmul st0, st0
dcc8|11223344556677885f5f5f5f5f5f	32	plan9	FMUL F0, F0
dcc8|11223344556677885f5f5f5f5f5f	64	gnu	fmul %st,%st
dcc8|11223344556677885f5f5f5f5f5f	64	intel	fmul st0, st0
dcc8|11223344556677885f5f5f5f5f5f	64	plan9	FMUL F0, F0
dce0|11223344556677885f5f5f5f5f5f	32	intel	fsubr st0, st0
dce0|11223344556677885f5f5f5f5f5f	32	plan9	FSUBR F0, F0
dce0|11223344556677885f5f5f5f5f5f	64	gnu	fsub %st,%st
dce0|11223344556677885f5f5f5f5f5f	64	intel	fsubr st0, st0
dce0|11223344556677885f5f5f5f5f5f	64	plan9	FSUBR F0, F0
dce8|11223344556677885f5f5f5f5f5f	32	intel	fsub st0, st0
dce8|11223344556677885f5f5f5f5f5f	32	plan9	FSUB F0, F0
dce8|11223344556677885f5f5f5f5f5f	64	gnu	fsubr %st,%st
dce8|11223344556677885f5f5f5f5f5f	64	intel	fsub st0, st0
dce8|11223344556677885f5f5f5f5f5f	64	plan9	FSUB F0, F0
dcf0|11223344556677885f5f5f5f5f5f	32	intel	fdivr st0, st0
dcf0|11223344556677885f5f5f5f5f5f	32	plan9	FDIVR F0, F0
dcf0|11223344556677885f5f5f5f5f5f	64	gnu	fdiv %st,%st
dcf0|11223344556677885f5f5f5f5f5f	64	intel	fdivr st0, st0
dcf0|11223344556677885f5f5f5f5f5f	64	plan9	FDIVR F0, F0
dcf8|11223344556677885f5f5f5f5f5f	32	intel	fdiv st0, st0
dcf8|11223344556677885f5f5f5f5f5f	32	plan9	FDIV F0, F0
dcf8|11223344556677885f5f5f5f5f5f	64	gnu	fdivr %st,%st
dcf8|11223344556677885f5f5f5f5f5f	64	intel	fdiv st0, st0
dcf8|11223344556677885f5f5f5f5f5f	64	plan9	FDIV F0, F0
dd00|11223344556677885f5f5f5f5f5f	32	intel	fld st0, qword ptr [eax]
dd00|11223344556677885f5f5f5f5f5f	32	plan9	FLD 0(AX)
dd00|11223344556677885f5f5f5f5f5f	64	gnu	fldl (%rax)
dd00|11223344556677885f5f5f5f5f5f	64	intel	fld st0, qword ptr [rax]
dd00|11223344556677885f5f5f5f5f5f	64	plan9	FLD 0(AX)
dd08|11223344556677885f5f5f5f5f5f	32	intel	fisttp qword ptr [eax], st0
dd08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
dd08|11223344556677885f5f5f5f5f5f	64	gnu	fisttpll (%rax)
dd08|11223344556677885f5f5f5f5f5f	64	intel	fisttp qword ptr [rax], st0
dd08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
dd11|223344556677885f5f5f5f5f5f5f	32	intel	fst qword ptr [ecx], st0
dd11|223344556677885f5f5f5f5f5f5f	32	plan9	FST 0(CX)
dd11|223344556677885f5f5f5f5f5f5f	64	gnu	fstl (%rcx)
dd11|223344556677885f5f5f5f5f5f5f	64	intel	fst qword ptr [rcx], st0
dd11|223344556677885f5f5f5f5f5f5f	64	plan9	FST 0(CX)
dd18|11223344556677885f5f5f5f5f5f	32	intel	fstp qword ptr [eax], st0
dd18|11223344556677885f5f5f5f5f5f	32	plan9	FSTP 0(AX)
dd18|11223344556677885f5f5f5f5f5f	64	gnu	fstpl (%rax)
dd18|11223344556677885f5f5f5f5f5f	64	intel	fstp qword ptr [rax], st0
dd18|11223344556677885f5f5f5f5f5f	64	plan9	FSTP 0(AX)
dd20|11223344556677885f5f5f5f5f5f	32	intel	frstor ptr [eax]
dd20|11223344556677885f5f5f5f5f5f	32	plan9	FRSTORL 0(AX)
dd20|11223344556677885f5f5f5f5f5f	64	gnu	frstor (%rax)
dd20|11223344556677885f5f5f5f5f5f	64	intel	frstor ptr [rax]
dd20|11223344556677885f5f5f5f5f5f	64	plan9	FRSTORL 0(AX)
dd30|11223344556677885f5f5f5f5f5f	32	intel	fnsave ptr [eax]
dd30|11223344556677885f5f5f5f5f5f	32	plan9	FNSAVE 0(AX)
dd30|11223344556677885f5f5f5f5f5f	64	gnu	fnsave (%rax)
dd30|11223344556677885f5f5f5f5f5f	64	intel	fnsave ptr [rax]
dd30|11223344556677885f5f5f5f5f5f	64	plan9	FNSAVE 0(AX)
dd38|11223344556677885f5f5f5f5f5f	32	intel	fnstsw word ptr [eax]
dd38|11223344556677885f5f5f5f5f5f	32	plan9	FNSTSW 0(AX)
dd38|11223344556677885f5f5f5f5f5f	64	gnu	fnstsw (%rax)
dd38|11223344556677885f5f5f5f5f5f	64	intel	fnstsw word ptr [rax]
dd38|11223344556677885f5f5f5f5f5f	64	plan9	FNSTSW 0(AX)
ddc0|11223344556677885f5f5f5f5f5f	32	intel	ffree st0
ddc0|11223344556677885f5f5f5f5f5f	32	plan9	FFREE F0
ddc0|11223344556677885f5f5f5f5f5f	64	gnu	ffree %st
ddc0|11223344556677885f5f5f5f5f5f	64	intel	ffree st0
ddc0|11223344556677885f5f5f5f5f5f	64	plan9	FFREE F0
ddd0|11223344556677885f5f5f5f5f5f	32	intel	fst st0, st0
ddd0|11223344556677885f5f5f5f5f5f	32	plan9	FST F0
ddd0|11223344556677885f5f5f5f5f5f	64	gnu	fst %st
ddd0|11223344556677885f5f5f5f5f5f	64	intel	fst st0, st0
ddd0|11223344556677885f5f5f5f5f5f	64	plan9	FST F0
ddd8|11223344556677885f5f5f5f5f5f	32	intel	fstp st0, st0
ddd8|11223344556677885f5f5f5f5f5f	32	plan9	FSTP F0
ddd8|11223344556677885f5f5f5f5f5f	64	gnu	fstp %st
ddd8|11223344556677885f5f5f5f5f5f	64	intel	fstp st0, st0
ddd8|11223344556677885f5f5f5f5f5f	64	plan9	FSTP F0
dde0|11223344556677885f5f5f5f5f5f	32	intel	fucom st0, st0
dde0|11223344556677885f5f5f5f5f5f	32	plan9	FUCOM F0
dde0|11223344556677885f5f5f5f5f5f	64	gnu	fucom %st
dde0|11223344556677885f5f5f5f5f5f	64	intel	fucom st0, st0
dde0|11223344556677885f5f5f5f5f5f	64	plan9	FUCOM F0
dde8|11223344556677885f5f5f5f5f5f	32	intel	fucomp st0, st0
dde8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMP F0
dde8|11223344556677885f5f5f5f5f5f	64	gnu	fucomp %st
dde8|11223344556677885f5f5f5f5f5f	64	intel	fucomp st0, st0
dde8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMP F0
de00|11223344556677885f5f5f5f5f5f	32	intel	fiadd st0, word ptr [eax]
de00|11223344556677885f5f5f5f5f5f	32	plan9	FIADD 0(AX)
de00|11223344556677885f5f5f5f5f5f	64	gnu	fiadd (%rax)
de00|11223344556677885f5f5f5f5f5f	64	intel	fiadd st0, word ptr [rax]
de00|11223344556677885f5f5f5f5f5f	64	plan9	FIADD 0(AX)
de08|11223344556677885f5f5f5f5f5f	32	intel	fimul st0, word ptr [eax]
de08|11223344556677885f5f5f5f5f5f	32	plan9	FIMUL 0(AX)
de08|11223344556677885f5f5f5f5f5f	64	gnu	fimul (%rax)
de08|11223344556677885f5f5f5f5f5f	64	intel	fimul st0, word ptr [rax]
de08|11223344556677885f5f5f5f5f5f	64	plan9	FIMUL 0(AX)
de11|223344556677885f5f5f5f5f5f5f	32	intel	ficom st0, word ptr [ecx]
de11|223344556677885f5f5f5f5f5f5f	32	plan9	FICOM 0(CX)
de11|223344556677885f5f5f5f5f5f5f	64	gnu	ficom (%rcx)
de11|223344556677885f5f5f5f5f5f5f	64	intel	ficom st0, word ptr [rcx]
de11|223344556677885f5f5f5f5f5f5f	64	plan9	FICOM 0(CX)
de18|11223344556677885f5f5f5f5f5f	32	intel	ficomp st0, word ptr [eax]
de18|11223344556677885f5f5f5f5f5f	32	plan9	FICOMP 0(AX)
de18|11223344556677885f5f5f5f5f5f	64	gnu	ficomp (%rax)
de18|11223344556677885f5f5f5f5f5f	64	intel	ficomp st0, word ptr [rax]
de18|11223344556677885f5f5f5f5f5f	64	plan9	FICOMP 0(AX)
de20|11223344556677885f5f5f5f5f5f	32	intel	fisub st0, word ptr [eax]
de20|11223344556677885f5f5f5f5f5f	32	plan9	FISUB 0(AX)
de20|11223344556677885f5f5f5f5f5f	64	gnu	fisub (%rax)
de20|11223344556677885f5f5f5f5f5f	64	intel	fisub st0, word ptr [rax]
de20|11223344556677885f5f5f5f5f5f	64	plan9	FISUB 0(AX)
de28|11223344556677885f5f5f5f5f5f	32	intel	fisubr st0, word ptr [eax]
de28|11223344556677885f5f5f5f5f5f	32	plan9	FISUBR 0(AX)
de28|11223344556677885f5f5f5f5f5f	64	gnu	fisubr (%rax)
de28|11223344556677885f5f5f5f5f5f	64	intel	fisubr st0, word ptr [rax]
de28|11223344556677885f5f5f5f5f5f	64	plan9	FISUBR 0(AX)
de30|11223344556677885f5f5f5f5f5f	32	intel	fidiv st0, word ptr [eax]
de30|11223344556677885f5f5f5f5f5f	32	plan9	FIDIV 0(AX)
de30|11223344556677885f5f5f5f5f5f	64	gnu	fidiv (%rax)
de30|11223344556677885f5f5f5f5f5f	64	intel	fidiv st0, word ptr [rax]
de30|11223344556677885f5f5f5f5f5f	64	plan9	FIDIV 0(AX)
de38|11223344556677885f5f5f5f5f5f	32	intel	fidivr st0, word ptr [eax]
de38|11223344556677885f5f5f5f5f5f	32	plan9	FIDIVR 0(AX)
de38|11223344556677885f5f5f5f5f5f	64	gnu	fidivr (%rax)
de38|11223344556677885f5f5f5f5f5f	64	intel	fidivr st0, word ptr [rax]
de38|11223344556677885f5f5f5f5f5f	64	plan9	FIDIVR 0(AX)
dec0|11223344556677885f5f5f5f5f5f	32	intel	faddp st0, st0
dec0|11223344556677885f5f5f5f5f5f	32	plan9	FADDP F0, F0
dec0|11223344556677885f5f5f5f5f5f	64	gnu	faddp %st,%st
dec0|11223344556677885f5f5f5f5f5f	64	intel	faddp st0, st0
dec0|11223344556677885f5f5f5f5f5f	64	plan9	FADDP F0, F0
dec8|11223344556677885f5f5f5f5f5f	32	intel	fmulp st0, st0
dec8|11223344556677885f5f5f5f5f5f	32	plan9	FMULP F0, F0
dec8|11223344556677885f5f5f5f5f5f	64	gnu	fmulp %st,%st
dec8|11223344556677885f5f5f5f5f5f	64	intel	fmulp st0, st0
dec8|11223344556677885f5f5f5f5f5f	64	plan9	FMULP F0, F0
ded9|11223344556677885f5f5f5f5f5f	32	intel	fcompp st0, st1
ded9|11223344556677885f5f5f5f5f5f	32	plan9	FCOMPP
ded9|11223344556677885f5f5f5f5f5f	64	gnu	fcompp
ded9|11223344556677885f5f5f5f5f5f	64	intel	fcompp st0, st1
ded9|11223344556677885f5f5f5f5f5f	64	plan9	FCOMPP
dee0|11223344556677885f5f5f5f5f5f	32	intel	fsubrp st0, st0
dee0|11223344556677885f5f5f5f5f5f	32	plan9	FSUBRP F0, F0
dee0|11223344556677885f5f5f5f5f5f	64	gnu	fsubp %st,%st
dee0|11223344556677885f5f5f5f5f5f	64	intel	fsubrp st0, st0
dee0|11223344556677885f5f5f5f5f5f	64	plan9	FSUBRP F0, F0
dee8|11223344556677885f5f5f5f5f5f	32	intel	fsubp st0, st0
dee8|11223344556677885f5f5f5f5f5f	32	plan9	FSUBP F0, F0
dee8|11223344556677885f5f5f5f5f5f	64	gnu	fsubrp %st,%st
dee8|11223344556677885f5f5f5f5f5f	64	intel	fsubp st0, st0
dee8|11223344556677885f5f5f5f5f5f	64	plan9	FSUBP F0, F0
def0|11223344556677885f5f5f5f5f5f	32	intel	fdivrp st0, st0
def0|11223344556677885f5f5f5f5f5f	32	plan9	FDIVRP F0, F0
def0|11223344556677885f5f5f5f5f5f	64	gnu	fdivp %st,%st
def0|11223344556677885f5f5f5f5f5f	64	intel	fdivrp st0, st0
def0|11223344556677885f5f5f5f5f5f	64	plan9	FDIVRP F0, F0
def8|11223344556677885f5f5f5f5f5f	32	intel	fdivp st0, st0
def8|11223344556677885f5f5f5f5f5f	32	plan9	FDIVP F0, F0
def8|11223344556677885f5f5f5f5f5f	64	gnu	fdivrp %st,%st
def8|11223344556677885f5f5f5f5f5f	64	intel	fdivp st0, st0
def8|11223344556677885f5f5f5f5f5f	64	plan9	FDIVP F0, F0
df00|11223344556677885f5f5f5f5f5f	32	intel	fild st0, word ptr [eax]
df00|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
df00|11223344556677885f5f5f5f5f5f	64	gnu	fild (%rax)
df00|11223344556677885f5f5f5f5f5f	64	intel	fild st0, word ptr [rax]
df00|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
df08|11223344556677885f5f5f5f5f5f	32	intel	fisttp word ptr [eax], st0
df08|11223344556677885f5f5f5f5f5f	32	plan9	FISTTP 0(AX)
df08|11223344556677885f5f5f5f5f5f	64	gnu	fisttp (%rax)
df08|11223344556677885f5f5f5f5f5f	64	intel	fisttp word ptr [rax], st0
df08|11223344556677885f5f5f5f5f5f	64	plan9	FISTTP 0(AX)
df11|223344556677885f5f5f5f5f5f5f	32	intel	fist word ptr [ecx], st0
df11|223344556677885f5f5f5f5f5f5f	32	plan9	FIST 0(CX)
df11|223344556677885f5f5f5f5f5f5f	64	gnu	fist (%rcx)
df11|223344556677885f5f5f5f5f5f5f	64	intel	fist word ptr [rcx], st0
df11|223344556677885f5f5f5f5f5f5f	64	plan9	FIST 0(CX)
df18|11223344556677885f5f5f5f5f5f	32	intel	fistp word ptr [eax], st0
df18|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
df18|11223344556677885f5f5f5f5f5f	64	gnu	fistp (%rax)
df18|11223344556677885f5f5f5f5f5f	64	intel	fistp word ptr [rax], st0
df18|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
df20|11223344556677885f5f5f5f5f5f	32	intel	fbld st0, ptr [eax]
df20|11223344556677885f5f5f5f5f5f	32	plan9	FBLD 0(AX)
df20|11223344556677885f5f5f5f5f5f	64	gnu	fbld (%rax)
df20|11223344556677885f5f5f5f5f5f	64	intel	fbld st0, ptr [rax]
df20|11223344556677885f5f5f5f5f5f	64	plan9	FBLD 0(AX)
df28|11223344556677885f5f5f5f5f5f	32	intel	fild st0, qword ptr [eax]
df28|11223344556677885f5f5f5f5f5f	32	plan9	FILD 0(AX)
df28|11223344556677885f5f5f5f5f5f	64	gnu	fildll (%rax)
df28|11223344556677885f5f5f5f5f5f	64	intel	fild st0, qword ptr [rax]
df28|11223344556677885f5f5f5f5f5f	64	plan9	FILD 0(AX)
df30|11223344556677885f5f5f5f5f5f	32	intel	fbstp ptr [eax], st0
df30|11223344556677885f5f5f5f5f5f	32	plan9	FBSTP 0(AX)
df30|11223344556677885f5f5f5f5f5f	64	gnu	fbstp (%rax)
df30|11223344556677885f5f5f5f5f5f	64	intel	fbstp ptr [rax], st0
df30|11223344556677885f5f5f5f5f5f	64	plan9	FBSTP 0(AX)
df38|11223344556677885f5f5f5f5f5f	32	intel	fistp qword ptr [eax], st0
df38|11223344556677885f5f5f5f5f5f	32	plan9	FISTP 0(AX)
df38|11223344556677885f5f5f5f5f5f	64	gnu	fistpll (%rax)
df38|11223344556677885f5f5f5f5f5f	64	intel	fistp qword ptr [rax], st0
df38|11223344556677885f5f5f5f5f5f	64	plan9	FISTP 0(AX)
dfc0|11223344556677885f5f5f5f5f5f	32	intel	ffreep st0
dfc0|11223344556677885f5f5f5f5f5f	32	plan9	FFREEP F0
dfc0|11223344556677885f5f5f5f5f5f	64	gnu	ffreep %st
dfc0|11223344556677885f5f5f5f5f5f	64	intel	ffreep st0
dfc0|11223344556677885f5f5f5f5f5f	64	plan9	FFREEP F0
dfe0|11223344556677885f5f5f5f5f5f	32	intel	fnstsw ax
dfe0|11223344556677885f5f5f5f5f5f	32	plan9	FNSTSW AX
dfe0|11223344556677885f5f5f5f5f5f	64	gnu	fnstsw %ax
dfe0|11223344556677885f5f5f5f5f5f	64	intel	fnstsw ax
dfe0|11223344556677885f5f5f5f5f5f	64	plan9	FNSTSW AX
dfe8|11223344556677885f5f5f5f5f5f	32	intel	fucomip st0, st0
dfe8|11223344556677885f5f5f5f5f5f	32	plan9	FUCOMIP F0, F0
dfe8|11223344556677885f5f5f5f5f5f	64	gnu	fucomip %st,%st
dfe8|11223344556677885f5f5f5f5f5f	64	intel	fucomip st0, st0
dfe8|11223344556677885f5f5f5f5f5f	64	plan9	FUCOMIP F0, F0
dff0|11223344556677885f5f5f5f5f5f	32	intel	fcomip st0, st0
dff0|11223344556677885f5f5f5f5f5f	32	plan9	FCOMIP F0, F0
dff0|11223344556677885f5f5f5f5f5f	64	gnu	fcomip %st,%st
dff0|11223344556677885f5f5f5f5f5f	64	intel	fcomip st0, st0
dff0|11223344556677885f5f5f5f5f5f	64	plan9	FCOMIP F0, F0
e111|223344556677885f5f5f5f5f5f5f	32	intel	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	32	plan9	LOOPE .+17
e111|223344556677885f5f5f5f5f5f5f	64	gnu	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	64	intel	loope .+0x11
e111|223344556677885f5f5f5f5f5f5f	64	plan9	LOOPE .+17
e211|223344556677885f5f5f5f5f5f5f	32	intel	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	32	plan9	LOOP .+17
e211|223344556677885f5f5f5f5f5f5f	64	gnu	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	64	intel	loop .+0x11
e211|223344556677885f5f5f5f5f5f5f	64	plan9	LOOP .+17
e311|223344556677885f5f5f5f5f5f5f	32	intel	jecxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	32	plan9	JECXZ .+17
e311|223344556677885f5f5f5f5f5f5f	64	gnu	jrcxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	64	intel	jrcxz .+0x11
e311|223344556677885f5f5f5f5f5f5f	64	plan9	JRCXZ .+17
e411|223344556677885f5f5f5f5f5f5f	32	intel	in al, 0x11
e411|223344556677885f5f5f5f5f5f5f	32	plan9	INL $0x11, AL
e411|223344556677885f5f5f5f5f5f5f	64	gnu	in $0x11,%al
e411|223344556677885f5f5f5f5f5f5f	64	intel	in al, 0x11
e411|223344556677885f5f5f5f5f5f5f	64	plan9	INL $0x11, AL
e511|223344556677885f5f5f5f5f5f5f	32	intel	in eax, 0x11
e511|223344556677885f5f5f5f5f5f5f	32	plan9	INL $0x11, AX
e511|223344556677885f5f5f5f5f5f5f	64	gnu	in $0x11,%eax
e511|223344556677885f5f5f5f5f5f5f	64	intel	in eax, 0x11
e511|223344556677885f5f5f5f5f5f5f	64	plan9	INL $0x11, AX
e611|223344556677885f5f5f5f5f5f5f	32	intel	out 0x11, al
e611|223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AL, $0x11
e611|223344556677885f5f5f5f5f5f5f	64	gnu	out %al,$0x11
e611|223344556677885f5f5f5f5f5f5f	64	intel	out 0x11, al
e611|223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AL, $0x11
e711|223344556677885f5f5f5f5f5f5f	32	intel	out 0x11, eax
e711|223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AX, $0x11
e711|223344556677885f5f5f5f5f5f5f	64	gnu	out %eax,$0x11
e711|223344556677885f5f5f5f5f5f5f	64	intel	out 0x11, eax
e711|223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AX, $0x11
e811223344|556677885f5f5f5f5f5f5f	32	intel	call .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	32	plan9	CALL .+1144201745
e811223344|556677885f5f5f5f5f5f5f	64	gnu	callq .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	64	intel	call .+0x44332211
e811223344|556677885f5f5f5f5f5f5f	64	plan9	CALL .+1144201745
e911223344|556677885f5f5f5f5f5f5f	32	intel	jmp .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	32	plan9	JMP .+1144201745
e911223344|556677885f5f5f5f5f5f5f	64	gnu	jmpq .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	64	intel	jmp .+0x44332211
e911223344|556677885f5f5f5f5f5f5f	64	plan9	JMP .+1144201745
ea112233445566|77885f5f5f5f5f5f5f	32	intel	jmp far 0x44332211, 0x6655
ea112233445566|77885f5f5f5f5f5f5f	32	plan9	LJMP $0x44332211, $0x6655
eb11|223344556677885f5f5f5f5f5f5f	32	intel	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	32	plan9	JMP .+17
eb11|223344556677885f5f5f5f5f5f5f	64	gnu	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	64	intel	jmp .+0x11
eb11|223344556677885f5f5f5f5f5f5f	64	plan9	JMP .+17
ec|11223344556677885f5f5f5f5f5f5f	32	intel	in al, dx
ec|11223344556677885f5f5f5f5f5f5f	32	plan9	INL DX, AL
ec|11223344556677885f5f5f5f5f5f5f	64	gnu	in (%dx),%al
ec|11223344556677885f5f5f5f5f5f5f	64	intel	in al, dx
ec|11223344556677885f5f5f5f5f5f5f	64	plan9	INL DX, AL
ed|11223344556677885f5f5f5f5f5f5f	32	intel	in eax, dx
ed|11223344556677885f5f5f5f5f5f5f	32	plan9	INL DX, AX
ed|11223344556677885f5f5f5f5f5f5f	64	gnu	in (%dx),%eax
ed|11223344556677885f5f5f5f5f5f5f	64	intel	in eax, dx
ed|11223344556677885f5f5f5f5f5f5f	64	plan9	INL DX, AX
ee|11223344556677885f5f5f5f5f5f5f	32	intel	out dx, al
ee|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AL, DX
ee|11223344556677885f5f5f5f5f5f5f	64	gnu	out %al,(%dx)
ee|11223344556677885f5f5f5f5f5f5f	64	intel	out dx, al
ee|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AL, DX
ef|11223344556677885f5f5f5f5f5f5f	32	intel	out dx, eax
ef|11223344556677885f5f5f5f5f5f5f	32	plan9	OUTL AX, DX
ef|11223344556677885f5f5f5f5f5f5f	64	gnu	out %eax,(%dx)
ef|11223344556677885f5f5f5f5f5f5f	64	intel	out dx, eax
ef|11223344556677885f5f5f5f5f5f5f	64	plan9	OUTL AX, DX
f1|11223344556677885f5f5f5f5f5f5f	32	intel	int1
f1|11223344556677885f5f5f5f5f5f5f	32	plan9	ICEBP
f1|11223344556677885f5f5f5f5f5f5f	64	gnu	icebp
f1|11223344556677885f5f5f5f5f5f5f	64	intel	int1
f1|11223344556677885f5f5f5f5f5f5f	64	plan9	ICEBP
f20f1011|223344556677885f5f5f5f5f	32	intel	movsd xmm2, qword ptr [ecx]
f20f1011|223344556677885f5f5f5f5f	32	plan9	REPNE MOVSD_XMM 0(CX), X2
f20f1011|223344556677885f5f5f5f5f	64	gnu	movsd (%rcx),%xmm2
f20f1011|223344556677885f5f5f5f5f	64	intel	movsd xmm2, qword ptr [rcx]
f20f1011|223344556677885f5f5f5f5f	64	plan9	REPNE MOVSD_XMM 0(CX), X2
f20f1122|3344556677885f5f5f5f5f5f	32	intel	movsd qword ptr [edx], xmm4
f20f1122|3344556677885f5f5f5f5f5f	32	plan9	REPNE MOVSD_XMM X4, 0(DX)
f20f1122|3344556677885f5f5f5f5f5f	64	gnu	movsd %xmm4,(%rdx)
f20f1122|3344556677885f5f5f5f5f5f	64	intel	movsd qword ptr [rdx], xmm4
f20f1122|3344556677885f5f5f5f5f5f	64	plan9	REPNE MOVSD_XMM X4, 0(DX)
f20f1211|223344556677885f5f5f5f5f	32	intel	movddup xmm2, qword ptr [ecx]
f20f1211|223344556677885f5f5f5f5f	32	plan9	REPNE MOVDDUP 0(CX), X2
f20f1211|223344556677885f5f5f5f5f	64	gnu	movddup (%rcx),%xmm2
f20f1211|223344556677885f5f5f5f5f	64	intel	movddup xmm2, qword ptr [rcx]
f20f1211|223344556677885f5f5f5f5f	64	plan9	REPNE MOVDDUP 0(CX), X2
f20f2a11|223344556677885f5f5f5f5f	32	intel	cvtsi2sd xmm2, dword ptr [ecx]
f20f2a11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSI2SDL 0(CX), X2
f20f2a11|223344556677885f5f5f5f5f	64	gnu	cvtsi2sdl (%rcx),%xmm2
f20f2a11|223344556677885f5f5f5f5f	64	intel	cvtsi2sd xmm2, dword ptr [rcx]
f20f2a11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSI2SDL 0(CX), X2
f20f2c11|223344556677885f5f5f5f5f	32	intel	cvttsd2si edx, qword ptr [ecx]
f20f2c11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTTSD2SIL 0(CX), DX
f20f2c11|223344556677885f5f5f5f5f	64	gnu	cvttsd2si (%rcx),%edx
f20f2c11|223344556677885f5f5f5f5f	64	intel	cvttsd2si edx, qword ptr [rcx]
f20f2c11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTTSD2SIL 0(CX), DX
f20f2d11|223344556677885f5f5f5f5f	32	intel	cvtsd2si edx, qword ptr [ecx]
f20f2d11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSD2SIL 0(CX), DX
f20f2d11|223344556677885f5f5f5f5f	64	gnu	cvtsd2si (%rcx),%edx
f20f2d11|223344556677885f5f5f5f5f	64	intel	cvtsd2si edx, qword ptr [rcx]
f20f2d11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSD2SIL 0(CX), DX
f20f38f011|223344556677885f5f5f5f	32	intel	crc32 edx, byte ptr [ecx]
f20f38f011|223344556677885f5f5f5f	32	plan9	REPNE CRC32 0(CX), DX
f20f38f011|223344556677885f5f5f5f	64	gnu	crc32b (%rcx),%edx
f20f38f011|223344556677885f5f5f5f	64	intel	crc32 edx, byte ptr [rcx]
f20f38f011|223344556677885f5f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f20f38f111|223344556677885f5f5f5f	32	intel	crc32 edx, dword ptr [ecx]
f20f38f111|223344556677885f5f5f5f	32	plan9	REPNE CRC32 0(CX), DX
f20f38f111|223344556677885f5f5f5f	64	gnu	crc32l (%rcx),%edx
f20f38f111|223344556677885f5f5f5f	64	intel	crc32 edx, dword ptr [rcx]
f20f38f111|223344556677885f5f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f20f5111|223344556677885f5f5f5f5f	32	intel	sqrtsd xmm2, qword ptr [ecx]
f20f5111|223344556677885f5f5f5f5f	32	plan9	REPNE SQRTSD 0(CX), X2
f20f5111|223344556677885f5f5f5f5f	64	gnu	sqrtsd (%rcx),%xmm2
f20f5111|223344556677885f5f5f5f5f	64	intel	sqrtsd xmm2, qword ptr [rcx]
f20f5111|223344556677885f5f5f5f5f	64	plan9	REPNE SQRTSD 0(CX), X2
f20f5811|223344556677885f5f5f5f5f	32	intel	addsd xmm2, qword ptr [ecx]
f20f5811|223344556677885f5f5f5f5f	32	plan9	REPNE ADDSD 0(CX), X2
f20f5811|223344556677885f5f5f5f5f	64	gnu	addsd (%rcx),%xmm2
f20f5811|223344556677885f5f5f5f5f	64	intel	addsd xmm2, qword ptr [rcx]
f20f5811|223344556677885f5f5f5f5f	64	plan9	REPNE ADDSD 0(CX), X2
f20f5911|223344556677885f5f5f5f5f	32	intel	mulsd xmm2, qword ptr [ecx]
f20f5911|223344556677885f5f5f5f5f	32	plan9	REPNE MULSD 0(CX), X2
f20f5911|223344556677885f5f5f5f5f	64	gnu	mulsd (%rcx),%xmm2
f20f5911|223344556677885f5f5f5f5f	64	intel	mulsd xmm2, qword ptr [rcx]
f20f5911|223344556677885f5f5f5f5f	64	plan9	REPNE MULSD 0(CX), X2
f20f5a11|223344556677885f5f5f5f5f	32	intel	cvtsd2ss xmm2, qword ptr [ecx]
f20f5a11|223344556677885f5f5f5f5f	32	plan9	REPNE CVTSD2SS 0(CX), X2
f20f5a11|223344556677885f5f5f5f5f	64	gnu	cvtsd2ss (%rcx),%xmm2
f20f5a11|223344556677885f5f5f5f5f	64	intel	cvtsd2ss xmm2, qword ptr [rcx]
f20f5a11|223344556677885f5f5f5f5f	64	plan9	REPNE CVTSD2SS 0(CX), X2
f20f5c11|223344556677885f5f5f5f5f	32	intel	subsd xmm2, qword ptr [ecx]
f20f5c11|223344556677885f5f5f5f5f	32	plan9	REPNE SUBSD 0(CX), X2
f20f5c11|223344556677885f5f5f5f5f	64	gnu	subsd (%rcx),%xmm2
f20f5c11|223344556677885f5f5f5f5f	64	intel	subsd xmm2, qword ptr [rcx]
f20f5c11|223344556677885f5f5f5f5f	64	plan9	REPNE SUBSD 0(CX), X2
f20f5d11|223344556677885f5f5f5f5f	32	intel	minsd xmm2, qword ptr [ecx]
f20f5d11|223344556677885f5f5f5f5f	32	plan9	REPNE MINSD 0(CX), X2
f20f5d11|223344556677885f5f5f5f5f	64	gnu	minsd (%rcx),%xmm2
f20f5d11|223344556677885f5f5f5f5f	64	intel	minsd xmm2, qword ptr [rcx]
f20f5d11|223344556677885f5f5f5f5f	64	plan9	REPNE MINSD 0(CX), X2
f20f5e11|223344556677885f5f5f5f5f	32	intel	divsd xmm2, qword ptr [ecx]
f20f5e11|223344556677885f5f5f5f5f	32	plan9	REPNE DIVSD 0(CX), X2
f20f5e11|223344556677885f5f5f5f5f	64	gnu	divsd (%rcx),%xmm2
f20f5e11|223344556677885f5f5f5f5f	64	intel	divsd xmm2, qword ptr [rcx]
f20f5e11|223344556677885f5f5f5f5f	64	plan9	REPNE DIVSD 0(CX), X2
f20f5f11|223344556677885f5f5f5f5f	32	intel	maxsd xmm2, qword ptr [ecx]
f20f5f11|223344556677885f5f5f5f5f	32	plan9	REPNE MAXSD 0(CX), X2
f20f5f11|223344556677885f5f5f5f5f	64	gnu	maxsd (%rcx),%xmm2
f20f5f11|223344556677885f5f5f5f5f	64	intel	maxsd xmm2, qword ptr [rcx]
f20f5f11|223344556677885f5f5f5f5f	64	plan9	REPNE MAXSD 0(CX), X2
f20f701122|3344556677885f5f5f5f5f	32	intel	pshuflw xmm2, xmmword ptr [ecx], 0x22
f20f701122|3344556677885f5f5f5f5f	32	plan9	REPNE PSHUFLW $0x22, 0(CX), X2
f20f701122|3344556677885f5f5f5f5f	64	gnu	pshuflw $0x22,(%rcx),%xmm2
f20f701122|3344556677885f5f5f5f5f	64	intel	pshuflw xmm2, xmmword ptr [rcx], 0x22
f20f701122|3344556677885f5f5f5f5f	64	plan9	REPNE PSHUFLW $0x22, 0(CX), X2
f20f7c11|223344556677885f5f5f5f5f	32	intel	haddps xmm2, xmmword ptr [ecx]
f20f7c11|223344556677885f5f5f5f5f	32	plan9	REPNE HADDPS 0(CX), X2
f20f7c11|223344556677885f5f5f5f5f	64	gnu	haddps (%rcx),%xmm2
f20f7c11|223344556677885f5f5f5f5f	64	intel	haddps xmm2, xmmword ptr [rcx]
f20f7c11|223344556677885f5f5f5f5f	64	plan9	REPNE HADDPS 0(CX), X2
f20f7d11|223344556677885f5f5f5f5f	32	intel	hsubps xmm2, xmmword ptr [ecx]
f20f7d11|223344556677885f5f5f5f5f	32	plan9	REPNE HSUBPS 0(CX), X2
f20f7d11|223344556677885f5f5f5f5f	64	gnu	hsubps (%rcx),%xmm2
f20f7d11|223344556677885f5f5f5f5f	64	intel	hsubps xmm2, xmmword ptr [rcx]
f20f7d11|223344556677885f5f5f5f5f	64	plan9	REPNE HSUBPS 0(CX), X2
f20fc21122|3344556677885f5f5f5f5f	32	intel	cmpsd_xmm xmm2, qword ptr [ecx], 0x22
f20fc21122|3344556677885f5f5f5f5f	32	plan9	REPNE CMPSD_XMM $0x22, 0(CX), X2
f20fc21122|3344556677885f5f5f5f5f	64	gnu	cmpsd $0x22,(%rcx),%xmm2
f20fc21122|3344556677885f5f5f5f5f	64	intel	cmpsd_xmm xmm2, qword ptr [rcx], 0x22
f20fc21122|3344556677885f5f5f5f5f	64	plan9	REPNE CMPSD_XMM $0x22, 0(CX), X2
f20fd011|223344556677885f5f5f5f5f	32	intel	addsubps xmm2, xmmword ptr [ecx]
f20fd011|223344556677885f5f5f5f5f	32	plan9	REPNE ADDSUBPS 0(CX), X2
f20fd011|223344556677885f5f5f5f5f	64	gnu	addsubps (%rcx),%xmm2
f20fd011|223344556677885f5f5f5f5f	64	intel	addsubps xmm2, xmmword ptr [rcx]
f20fd011|223344556677885f5f5f5f5f	64	plan9	REPNE ADDSUBPS 0(CX), X2
f20fd6c0|11223344556677885f5f5f5f	32	intel	movdq2q mmx0, xmm0
f20fd6c0|11223344556677885f5f5f5f	32	plan9	REPNE MOVDQ2Q X0, M0
f20fd6c0|11223344556677885f5f5f5f	64	gnu	movdq2q %xmm0,%mm0
f20fd6c0|11223344556677885f5f5f5f	64	intel	movdq2q mmx0, xmm0
f20fd6c0|11223344556677885f5f5f5f	64	plan9	REPNE MOVDQ2Q X0, M0
f20fe611|223344556677885f5f5f5f5f	32	intel	cvtpd2dq xmm2, xmmword ptr [ecx]
f20fe611|223344556677885f5f5f5f5f	32	plan9	REPNE CVTPD2DQ 0(CX), X2
f20fe611|223344556677885f5f5f5f5f	64	gnu	cvtpd2dq (%rcx),%xmm2
f20fe611|223344556677885f5f5f5f5f	64	intel	cvtpd2dq xmm2, xmmword ptr [rcx]
f20fe611|223344556677885f5f5f5f5f	64	plan9	REPNE CVTPD2DQ 0(CX), X2
f20ff011|223344556677885f5f5f5f5f	32	intel	lddqu xmm2, xmmword ptr [ecx]
f20ff011|223344556677885f5f5f5f5f	32	plan9	REPNE LDDQU 0(CX), X2
f20ff011|223344556677885f5f5f5f5f	64	gnu	lddqu (%rcx),%xmm2
f20ff011|223344556677885f5f5f5f5f	64	intel	lddqu xmm2, xmmword ptr [rcx]
f20ff011|223344556677885f5f5f5f5f	64	plan9	REPNE LDDQU 0(CX), X2
f2480f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2sdq (%rcx),%xmm2
f2480f2a11|223344556677885f5f5f5f	64	intel	cvtsi2sd xmm2, qword ptr [rcx]
f2480f2a11|223344556677885f5f5f5f	64	plan9	REPNE CVTSI2SDQ 0(CX), X2
f2480f2c11|223344556677885f5f5f5f	64	gnu	cvttsd2si (%rcx),%rdx
f2480f2c11|223344556677885f5f5f5f	64	intel	cvttsd2si rdx, qword ptr [rcx]
f2480f2c11|223344556677885f5f5f5f	64	plan9	REPNE CVTTSD2SIQ 0(CX), DX
f2480f2d11|223344556677885f5f5f5f	64	gnu	cvtsd2si (%rcx),%rdx
f2480f2d11|223344556677885f5f5f5f	64	intel	cvtsd2si rdx, qword ptr [rcx]
f2480f2d11|223344556677885f5f5f5f	64	plan9	REPNE CVTSD2SIQ 0(CX), DX
f2480f38f011|223344556677885f5f5f	64	gnu	crc32b (%rcx),%rdx
f2480f38f011|223344556677885f5f5f	64	intel	crc32 rdx, byte ptr [rcx]
f2480f38f011|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f2480f38f111|223344556677885f5f5f	64	gnu	crc32q (%rcx),%rdx
f2480f38f111|223344556677885f5f5f	64	intel	crc32 rdx, qword ptr [rcx]
f2480f38f111|223344556677885f5f5f	64	plan9	REPNE CRC32 0(CX), DX
f267f0663e360f38f111|223344556677	32	intel	lock crc32 edx, word ptr ss:[bx+di*1]
f267f0663e360f38f111|223344556677	32	plan9	SS CRC32 SS:0(BX)(DI*1), DX
f267f0663e360f38f111|223344556677	64	gnu	lock crc32w %ds:%ss:(%ecx),%edx
f267f0663e360f38f111|223344556677	64	intel	lock crc32 edx, word ptr [ecx]
f267f0663e360f38f111|223344556677	64	plan9	SS CRC32 0(CX), DX
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	intel	movntss dword ptr [ecx], xmm2
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	plan9	REP MOVNTSS X2, 0(CX)
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	gnu	repn movntss %xmm2,(%rcx)
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	intel	movntss dword ptr [rcx], xmm2
f2f30f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	plan9	REP MOVNTSS X2, 0(CX)
f30f1011|223344556677885f5f5f5f5f	32	intel	movss xmm2, dword ptr [ecx]
f30f1011|223344556677885f5f5f5f5f	32	plan9	REP MOVSS 0(CX), X2
f30f1011|223344556677885f5f5f5f5f	64	gnu	movss (%rcx),%xmm2
f30f1011|223344556677885f5f5f5f5f	64	intel	movss xmm2, dword ptr [rcx]
f30f1011|223344556677885f5f5f5f5f	64	plan9	REP MOVSS 0(CX), X2
f30f1122|3344556677885f5f5f5f5f5f	32	intel	movss dword ptr [edx], xmm4
f30f1122|3344556677885f5f5f5f5f5f	32	plan9	REP MOVSS X4, 0(DX)
f30f1122|3344556677885f5f5f5f5f5f	64	gnu	movss %xmm4,(%rdx)
f30f1122|3344556677885f5f5f5f5f5f	64	intel	movss dword ptr [rdx], xmm4
f30f1122|3344556677885f5f5f5f5f5f	64	plan9	REP MOVSS X4, 0(DX)
f30f1211|223344556677885f5f5f5f5f	32	intel	movsldup xmm2, xmmword ptr [ecx]
f30f1211|223344556677885f5f5f5f5f	32	plan9	REP MOVSLDUP 0(CX), X2
f30f1211|223344556677885f5f5f5f5f	64	gnu	movsldup (%rcx),%xmm2
f30f1211|223344556677885f5f5f5f5f	64	intel	movsldup xmm2, xmmword ptr [rcx]
f30f1211|223344556677885f5f5f5f5f	64	plan9	REP MOVSLDUP 0(CX), X2
f30f1611|223344556677885f5f5f5f5f	32	intel	movshdup xmm2, xmmword ptr [ecx]
f30f1611|223344556677885f5f5f5f5f	32	plan9	REP MOVSHDUP 0(CX), X2
f30f1611|223344556677885f5f5f5f5f	64	gnu	movshdup (%rcx),%xmm2
f30f1611|223344556677885f5f5f5f5f	64	intel	movshdup xmm2, xmmword ptr [rcx]
f30f1611|223344556677885f5f5f5f5f	64	plan9	REP MOVSHDUP 0(CX), X2
f30f2a11|223344556677885f5f5f5f5f	32	intel	cvtsi2ss xmm2, dword ptr [ecx]
f30f2a11|223344556677885f5f5f5f5f	32	plan9	REP CVTSI2SSL 0(CX), X2
f30f2a11|223344556677885f5f5f5f5f	64	gnu	cvtsi2ssl (%rcx),%xmm2
f30f2a11|223344556677885f5f5f5f5f	64	intel	cvtsi2ss xmm2, dword ptr [rcx]
f30f2a11|223344556677885f5f5f5f5f	64	plan9	REP CVTSI2SSL 0(CX), X2
f30f2c11|223344556677885f5f5f5f5f	32	intel	cvttss2si edx, dword ptr [ecx]
f30f2c11|223344556677885f5f5f5f5f	32	plan9	REP CVTTSS2SIL 0(CX), DX
f30f2c11|223344556677885f5f5f5f5f	64	gnu	cvttss2si (%rcx),%edx
f30f2c11|223344556677885f5f5f5f5f	64	intel	cvttss2si edx, dword ptr [rcx]
f30f2c11|223344556677885f5f5f5f5f	64	plan9	REP CVTTSS2SIL 0(CX), DX
f30f2d11|223344556677885f5f5f5f5f	32	intel	cvtss2si edx, dword ptr [ecx]
f30f2d11|223344556677885f5f5f5f5f	32	plan9	REP CVTSS2SIL 0(CX), DX
f30f2d11|223344556677885f5f5f5f5f	64	gnu	cvtss2si (%rcx),%edx
f30f2d11|223344556677885f5f5f5f5f	64	intel	cvtss2si edx, dword ptr [rcx]
f30f2d11|223344556677885f5f5f5f5f	64	plan9	REP CVTSS2SIL 0(CX), DX
f30f5111|223344556677885f5f5f5f5f	32	intel	sqrtss xmm2, dword ptr [ecx]
f30f5111|223344556677885f5f5f5f5f	32	plan9	REP SQRTSS 0(CX), X2
f30f5111|223344556677885f5f5f5f5f	64	gnu	sqrtss (%rcx),%xmm2
f30f5111|223344556677885f5f5f5f5f	64	intel	sqrtss xmm2, dword ptr [rcx]
f30f5111|223344556677885f5f5f5f5f	64	plan9	REP SQRTSS 0(CX), X2
f30f5211|223344556677885f5f5f5f5f	32	intel	rsqrtss xmm2, dword ptr [ecx]
f30f5211|223344556677885f5f5f5f5f	32	plan9	REP RSQRTSS 0(CX), X2
f30f5211|223344556677885f5f5f5f5f	64	gnu	rsqrtss (%rcx),%xmm2
f30f5211|223344556677885f5f5f5f5f	64	intel	rsqrtss xmm2, dword ptr [rcx]
f30f5211|223344556677885f5f5f5f5f	64	plan9	REP RSQRTSS 0(CX), X2
f30f5311|223344556677885f5f5f5f5f	32	intel	rcpss xmm2, dword ptr [ecx]
f30f5311|223344556677885f5f5f5f5f	32	plan9	REP RCPSS 0(CX), X2
f30f5311|223344556677885f5f5f5f5f	64	gnu	rcpss (%rcx),%xmm2
f30f5311|223344556677885f5f5f5f5f	64	intel	rcpss xmm2, dword ptr [rcx]
f30f5311|223344556677885f5f5f5f5f	64	plan9	REP RCPSS 0(CX), X2
f30f5811|223344556677885f5f5f5f5f	32	intel	addss xmm2, dword ptr [ecx]
f30f5811|223344556677885f5f5f5f5f	32	plan9	REP ADDSS 0(CX), X2
f30f5811|223344556677885f5f5f5f5f	64	gnu	addss (%rcx),%xmm2
f30f5811|223344556677885f5f5f5f5f	64	intel	addss xmm2, dword ptr [rcx]
f30f5811|223344556677885f5f5f5f5f	64	plan9	REP ADDSS 0(CX), X2
f30f5911|223344556677885f5f5f5f5f	32	intel	mulss xmm2, dword ptr [ecx]
f30f5911|223344556677885f5f5f5f5f	32	plan9	REP MULSS 0(CX), X2
f30f5911|223344556677885f5f5f5f5f	64	gnu	mulss (%rcx),%xmm2
f30f5911|223344556677885f5f5f5f5f	64	intel	mulss xmm2, dword ptr [rcx]
f30f5911|223344556677885f5f5f5f5f	64	plan9	REP MULSS 0(CX), X2
f30f5a11|223344556677885f5f5f5f5f	32	intel	cvtss2sd xmm2, dword ptr [ecx]
f30f5a11|223344556677885f5f5f5f5f	32	plan9	REP CVTSS2SD 0(CX), X2
f30f5a11|223344556677885f5f5f5f5f	64	gnu	cvtss2sd (%rcx),%xmm2
f30f5a11|223344556677885f5f5f5f5f	64	intel	cvtss2sd xmm2, dword ptr [rcx]
f30f5a11|223344556677885f5f5f5f5f	64	plan9	REP CVTSS2SD 0(CX), X2
f30f5b11|223344556677885f5f5f5f5f	32	intel	cvttps2dq xmm2, xmmword ptr [ecx]
f30f5b11|223344556677885f5f5f5f5f	32	plan9	REP CVTTPS2DQ 0(CX), X2
f30f5b11|223344556677885f5f5f5f5f	64	gnu	cvttps2dq (%rcx),%xmm2
f30f5b11|223344556677885f5f5f5f5f	64	intel	cvttps2dq xmm2, xmmword ptr [rcx]
f30f5b11|223344556677885f5f5f5f5f	64	plan9	REP CVTTPS2DQ 0(CX), X2
f30f5c11|223344556677885f5f5f5f5f	32	intel	subss xmm2, dword ptr [ecx]
f30f5c11|223344556677885f5f5f5f5f	32	plan9	REP SUBSS 0(CX), X2
f30f5c11|223344556677885f5f5f5f5f	64	gnu	subss (%rcx),%xmm2
f30f5c11|223344556677885f5f5f5f5f	64	intel	subss xmm2, dword ptr [rcx]
f30f5c11|223344556677885f5f5f5f5f	64	plan9	REP SUBSS 0(CX), X2
f30f5d11|223344556677885f5f5f5f5f	32	intel	minss xmm2, dword ptr [ecx]
f30f5d11|223344556677885f5f5f5f5f	32	plan9	REP MINSS 0(CX), X2
f30f5d11|223344556677885f5f5f5f5f	64	gnu	minss (%rcx),%xmm2
f30f5d11|223344556677885f5f5f5f5f	64	intel	minss xmm2, dword ptr [rcx]
f30f5d11|223344556677885f5f5f5f5f	64	plan9	REP MINSS 0(CX), X2
f30f5e11|223344556677885f5f5f5f5f	32	intel	divss xmm2, dword ptr [ecx]
f30f5e11|223344556677885f5f5f5f5f	32	plan9	REP DIVSS 0(CX), X2
f30f5e11|223344556677885f5f5f5f5f	64	gnu	divss (%rcx),%xmm2
f30f5e11|223344556677885f5f5f5f5f	64	intel	divss xmm2, dword ptr [rcx]
f30f5e11|223344556677885f5f5f5f5f	64	plan9	REP DIVSS 0(CX), X2
f30f5f11|223344556677885f5f5f5f5f	32	intel	maxss xmm2, dword ptr [ecx]
f30f5f11|223344556677885f5f5f5f5f	32	plan9	REP MAXSS 0(CX), X2
f30f5f11|223344556677885f5f5f5f5f	64	gnu	maxss (%rcx),%xmm2
f30f5f11|223344556677885f5f5f5f5f	64	intel	maxss xmm2, dword ptr [rcx]
f30f5f11|223344556677885f5f5f5f5f	64	plan9	REP MAXSS 0(CX), X2
f30f6f11|223344556677885f5f5f5f5f	32	intel	movdqu xmm2, xmmword ptr [ecx]
f30f6f11|223344556677885f5f5f5f5f	32	plan9	REP MOVDQU 0(CX), X2
f30f6f11|223344556677885f5f5f5f5f	64	gnu	movdqu (%rcx),%xmm2
f30f6f11|223344556677885f5f5f5f5f	64	intel	movdqu xmm2, xmmword ptr [rcx]
f30f6f11|223344556677885f5f5f5f5f	64	plan9	REP MOVDQU 0(CX), X2
f30f701122|3344556677885f5f5f5f5f	32	intel	pshufhw xmm2, xmmword ptr [ecx], 0x22
f30f701122|3344556677885f5f5f5f5f	32	plan9	REP PSHUFHW $0x22, 0(CX), X2
f30f701122|3344556677885f5f5f5f5f	64	gnu	pshufhw $0x22,(%rcx),%xmm2
f30f701122|3344556677885f5f5f5f5f	64	intel	pshufhw xmm2, xmmword ptr [rcx], 0x22
f30f701122|3344556677885f5f5f5f5f	64	plan9	REP PSHUFHW $0x22, 0(CX), X2
f30f7e11|223344556677885f5f5f5f5f	32	intel	movq xmm2, qword ptr [ecx]
f30f7e11|223344556677885f5f5f5f5f	32	plan9	REP MOVQ 0(CX), X2
f30f7e11|223344556677885f5f5f5f5f	64	gnu	movq (%rcx),%xmm2
f30f7e11|223344556677885f5f5f5f5f	64	intel	movq xmm2, qword ptr [rcx]
f30f7e11|223344556677885f5f5f5f5f	64	plan9	REP MOVQ 0(CX), X2
f30f7f11|223344556677885f5f5f5f5f	32	intel	movdqu xmmword ptr [ecx], xmm2
f30f7f11|223344556677885f5f5f5f5f	32	plan9	REP MOVDQU X2, 0(CX)
f30f7f11|223344556677885f5f5f5f5f	64	gnu	movdqu %xmm2,(%rcx)
f30f7f11|223344556677885f5f5f5f5f	64	intel	movdqu xmmword ptr [rcx], xmm2
f30f7f11|223344556677885f5f5f5f5f	64	plan9	REP MOVDQU X2, 0(CX)
f30fae11|223344556677885f5f5f5f5f	64	gnu	wrfsbasel (%rcx)
f30fae11|223344556677885f5f5f5f5f	64	intel	wrfsbase dword ptr [rcx]
f30fae11|223344556677885f5f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
f30fae18|11223344556677885f5f5f5f	64	gnu	wrgsbasel (%rax)
f30fae18|11223344556677885f5f5f5f	64	intel	wrgsbase dword ptr [rax]
f30fae18|11223344556677885f5f5f5f	64	plan9	REP WRGSBASE 0(AX)
f30faec0|11223344556677885f5f5f5f	64	gnu	rdfsbase %eax
f30faec0|11223344556677885f5f5f5f	64	intel	rdfsbase eax
f30faec0|11223344556677885f5f5f5f	64	plan9	REP RDFSBASE AX
f30faec8|11223344556677885f5f5f5f	64	gnu	rdgsbase %eax
f30faec8|11223344556677885f5f5f5f	64	intel	rdgsbase eax
f30faec8|11223344556677885f5f5f5f	64	plan9	REP RDGSBASE AX
f30fb811|223344556677885f5f5f5f5f	32	intel	popcnt edx, dword ptr [ecx]
f30fb811|223344556677885f5f5f5f5f	32	plan9	REP POPCNT 0(CX), DX
f30fb811|223344556677885f5f5f5f5f	64	gnu	popcnt (%rcx),%edx
f30fb811|223344556677885f5f5f5f5f	64	intel	popcnt edx, dword ptr [rcx]
f30fb811|223344556677885f5f5f5f5f	64	plan9	REP POPCNT 0(CX), DX
f30fbc11|223344556677885f5f5f5f5f	32	intel	tzcnt edx, dword ptr [ecx]
f30fbc11|223344556677885f5f5f5f5f	32	plan9	REP TZCNT 0(CX), DX
f30fbc11|223344556677885f5f5f5f5f	64	gnu	tzcnt (%rcx),%edx
f30fbc11|223344556677885f5f5f5f5f	64	intel	tzcnt edx, dword ptr [rcx]
f30fbc11|223344556677885f5f5f5f5f	64	plan9	REP TZCNT 0(CX), DX
f30fbd11|223344556677885f5f5f5f5f	32	intel	lzcnt edx, dword ptr [ecx]
f30fbd11|223344556677885f5f5f5f5f	32	plan9	REP LZCNT 0(CX), DX
f30fbd11|223344556677885f5f5f5f5f	64	gnu	lzcnt (%rcx),%edx
f30fbd11|223344556677885f5f5f5f5f	64	intel	lzcnt edx, dword ptr [rcx]
f30fbd11|223344556677885f5f5f5f5f	64	plan9	REP LZCNT 0(CX), DX
f30fc21122|3344556677885f5f5f5f5f	32	intel	cmpss xmm2, dword ptr [ecx], 0x22
f30fc21122|3344556677885f5f5f5f5f	32	plan9	REP CMPSS $0x22, 0(CX), X2
f30fc21122|3344556677885f5f5f5f5f	64	gnu	cmpss $0x22,(%rcx),%xmm2
f30fc21122|3344556677885f5f5f5f5f	64	intel	cmpss xmm2, dword ptr [rcx], 0x22
f30fc21122|3344556677885f5f5f5f5f	64	plan9	REP CMPSS $0x22, 0(CX), X2
f30fe611|223344556677885f5f5f5f5f	32	intel	cvtdq2pd xmm2, qword ptr [ecx]
f30fe611|223344556677885f5f5f5f5f	32	plan9	REP CVTDQ2PD 0(CX), X2
f30fe611|223344556677885f5f5f5f5f	64	gnu	cvtdq2pd (%rcx),%xmm2
f30fe611|223344556677885f5f5f5f5f	64	intel	cvtdq2pd xmm2, qword ptr [rcx]
f30fe611|223344556677885f5f5f5f5f	64	plan9	REP CVTDQ2PD 0(CX), X2
f3480f2a11|223344556677885f5f5f5f	64	gnu	cvtsi2ssq (%rcx),%xmm2
f3480f2a11|223344556677885f5f5f5f	64	intel	cvtsi2ss xmm2, qword ptr [rcx]
f3480f2a11|223344556677885f5f5f5f	64	plan9	REP CVTSI2SSQ 0(CX), X2
f3480f2c11|223344556677885f5f5f5f	64	gnu	cvttss2si (%rcx),%rdx
f3480f2c11|223344556677885f5f5f5f	64	intel	cvttss2si rdx, dword ptr [rcx]
f3480f2c11|223344556677885f5f5f5f	64	plan9	REP CVTTSS2SIQ 0(CX), DX
f3480f2d11|223344556677885f5f5f5f	64	gnu	cvtss2si (%rcx),%rdx
f3480f2d11|223344556677885f5f5f5f	64	intel	cvtss2si rdx, dword ptr [rcx]
f3480f2d11|223344556677885f5f5f5f	64	plan9	REP CVTSS2SIQ 0(CX), DX
f3480fae11|223344556677885f5f5f5f	64	gnu	wrfsbaseq (%rcx)
f3480fae11|223344556677885f5f5f5f	64	intel	wrfsbase qword ptr [rcx]
f3480fae11|223344556677885f5f5f5f	64	plan9	REP WRFSBASE 0(CX)
f3480fae18|11223344556677885f5f5f	64	gnu	wrgsbaseq (%rax)
f3480fae18|11223344556677885f5f5f	64	intel	wrgsbase qword ptr [rax]
f3480fae18|11223344556677885f5f5f	64	plan9	REP WRGSBASE 0(AX)
f3480faec0|11223344556677885f5f5f	64	gnu	rdfsbase %rax
f3480faec0|11223344556677885f5f5f	64	intel	rdfsbase rax
f3480faec0|11223344556677885f5f5f	64	plan9	REP RDFSBASE AX
f3480faec8|11223344556677885f5f5f	64	gnu	rdgsbase %rax
f3480faec8|11223344556677885f5f5f	64	intel	rdgsbase rax
f3480faec8|11223344556677885f5f5f	64	plan9	REP RDGSBASE AX
f3480fb811|223344556677885f5f5f5f	64	gnu	popcnt (%rcx),%rdx
f3480fb811|223344556677885f5f5f5f	64	intel	popcnt rdx, qword ptr [rcx]
f3480fb811|223344556677885f5f5f5f	64	plan9	REP POPCNT 0(CX), DX
f3480fbc11|223344556677885f5f5f5f	64	gnu	tzcnt (%rcx),%rdx
f3480fbc11|223344556677885f5f5f5f	64	intel	tzcnt rdx, qword ptr [rcx]
f3480fbc11|223344556677885f5f5f5f	64	plan9	REP TZCNT 0(CX), DX
f3480fbd11|223344556677885f5f5f5f	64	gnu	lzcnt (%rcx),%rdx
f3480fbd11|223344556677885f5f5f5f	64	intel	lzcnt rdx, qword ptr [rcx]
f3480fbd11|223344556677885f5f5f5f	64	plan9	REP LZCNT 0(CX), DX
f3660fb811|223344556677885f5f5f5f	32	intel	popcnt dx, word ptr [ecx]
f3660fb811|223344556677885f5f5f5f	32	plan9	POPCNT 0(CX), DX
f3660fb811|223344556677885f5f5f5f	64	gnu	popcnt (%rcx),%dx
f3660fb811|223344556677885f5f5f5f	64	intel	popcnt dx, word ptr [rcx]
f3660fb811|223344556677885f5f5f5f	64	plan9	POPCNT 0(CX), DX
f3660fbc11|223344556677885f5f5f5f	32	intel	tzcnt dx, word ptr [ecx]
f3660fbc11|223344556677885f5f5f5f	32	plan9	TZCNT 0(CX), DX
f3660fbc11|223344556677885f5f5f5f	64	gnu	tzcnt (%rcx),%dx
f3660fbc11|223344556677885f5f5f5f	64	intel	tzcnt dx, word ptr [rcx]
f3660fbc11|223344556677885f5f5f5f	64	plan9	TZCNT 0(CX), DX
f3660fbd11|223344556677885f5f5f5f	32	intel	lzcnt dx, word ptr [ecx]
f3660fbd11|223344556677885f5f5f5f	32	plan9	LZCNT 0(CX), DX
f3660fbd11|223344556677885f5f5f5f	64	gnu	lzcnt (%rcx),%dx
f3660fbd11|223344556677885f5f5f5f	64	intel	lzcnt dx, word ptr [rcx]
f3660fbd11|223344556677885f5f5f5f	64	plan9	LZCNT 0(CX), DX
f3f0673e660f38f111|22334455667788	32	intel	lock movbe word ptr [bx+di*1], dx
f3f0673e660f38f111|22334455667788	32	plan9	MOVBE DX, DS:0(BX)(DI*1)
f3f0673e660f38f111|22334455667788	64	gnu	rep lock movbe %dx,%ds:(%ecx)
f3f0673e660f38f111|22334455667788	64	intel	lock movbe word ptr [ecx], dx
f3f0673e660f38f111|22334455667788	64	plan9	MOVBE DX, 0(CX)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	intel	movntsd qword ptr [ecx], xmm2
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	32	plan9	REPNE MOVNTSD X2, 0(CX)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	gnu	repn movntss %xmm2,(%rcx)
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	intel	movntsd qword ptr [rcx], xmm2
f3f20f2b11|5f5f5f5f5f5f5f5f5f5f5f	64	plan9	REPNE MOVNTSD X2, 0(CX)
f4|11223344556677885f5f5f5f5f5f5f	32	intel	hlt
f4|11223344556677885f5f5f5f5f5f5f	32	plan9	HLT
f4|11223344556677885f5f5f5f5f5f5f	64	gnu	hlt
f4|11223344556677885f5f5f5f5f5f5f	64	intel	hlt
f4|11223344556677885f5f5f5f5f5f5f	64	plan9	HLT
f5|11223344556677885f5f5f5f5f5f5f	32	intel	cmc
f5|11223344556677885f5f5f5f5f5f5f	32	plan9	CMC
f5|11223344556677885f5f5f5f5f5f5f	64	gnu	cmc
f5|11223344556677885f5f5f5f5f5f5f	64	intel	cmc
f5|11223344556677885f5f5f5f5f5f5f	64	plan9	CMC
f60011|223344556677885f5f5f5f5f5f	32	intel	test byte ptr [eax], 0x11
f60011|223344556677885f5f5f5f5f5f	32	plan9	TESTL $0x11, 0(AX)
f60011|223344556677885f5f5f5f5f5f	64	gnu	testb $0x11,(%rax)
f60011|223344556677885f5f5f5f5f5f	64	intel	test byte ptr [rax], 0x11
f60011|223344556677885f5f5f5f5f5f	64	plan9	TESTL $0x11, 0(AX)
f611|223344556677885f5f5f5f5f5f5f	32	intel	not byte ptr [ecx]
f611|223344556677885f5f5f5f5f5f5f	32	plan9	NOTL 0(CX)
f611|223344556677885f5f5f5f5f5f5f	64	gnu	notb (%rcx)
f611|223344556677885f5f5f5f5f5f5f	64	intel	not byte ptr [rcx]
f611|223344556677885f5f5f5f5f5f5f	64	plan9	NOTL 0(CX)
f618|11223344556677885f5f5f5f5f5f	32	intel	neg byte ptr [eax]
f618|11223344556677885f5f5f5f5f5f	32	plan9	NEGL 0(AX)
f618|11223344556677885f5f5f5f5f5f	64	gnu	negb (%rax)
f618|11223344556677885f5f5f5f5f5f	64	intel	neg byte ptr [rax]
f618|11223344556677885f5f5f5f5f5f	64	plan9	NEGL 0(AX)
f620|11223344556677885f5f5f5f5f5f	32	intel	mul byte ptr [eax]
f620|11223344556677885f5f5f5f5f5f	32	plan9	MULL 0(AX)
f620|11223344556677885f5f5f5f5f5f	64	gnu	mulb (%rax)
f620|11223344556677885f5f5f5f5f5f	64	intel	mul byte ptr [rax]
f620|11223344556677885f5f5f5f5f5f	64	plan9	MULL 0(AX)
f628|11223344556677885f5f5f5f5f5f	32	intel	imul byte ptr [eax]
f628|11223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(AX)
f628|11223344556677885f5f5f5f5f5f	64	gnu	imulb (%rax)
f628|11223344556677885f5f5f5f5f5f	64	intel	imul byte ptr [rax]
f628|11223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(AX)
f630|11223344556677885f5f5f5f5f5f	32	intel	div byte ptr [eax]
f630|11223344556677885f5f5f5f5f5f	32	plan9	DIVL 0(AX)
f630|11223344556677885f5f5f5f5f5f	64	gnu	divb (%rax)
f630|11223344556677885f5f5f5f5f5f	64	intel	div byte ptr [rax]
f630|11223344556677885f5f5f5f5f5f	64	plan9	DIVL 0(AX)
f638|11223344556677885f5f5f5f5f5f	32	intel	idiv byte ptr [eax]
f638|11223344556677885f5f5f5f5f5f	32	plan9	IDIVL 0(AX)
f638|11223344556677885f5f5f5f5f5f	64	gnu	idivb (%rax)
f638|11223344556677885f5f5f5f5f5f	64	intel	idiv byte ptr [rax]
f638|11223344556677885f5f5f5f5f5f	64	plan9	IDIVL 0(AX)
f70011223344|556677885f5f5f5f5f5f	32	intel	test dword ptr [eax], 0x44332211
f70011223344|556677885f5f5f5f5f5f	32	plan9	TESTL $0x44332211, 0(AX)
f70011223344|556677885f5f5f5f5f5f	64	gnu	testl $0x44332211,(%rax)
f70011223344|556677885f5f5f5f5f5f	64	intel	test dword ptr [rax], 0x44332211
f70011223344|556677885f5f5f5f5f5f	64	plan9	TESTL $0x44332211, 0(AX)
f711|223344556677885f5f5f5f5f5f5f	32	intel	not dword ptr [ecx]
f711|223344556677885f5f5f5f5f5f5f	32	plan9	NOTL 0(CX)
f711|223344556677885f5f5f5f5f5f5f	64	gnu	notl (%rcx)
f711|223344556677885f5f5f5f5f5f5f	64	intel	not dword ptr [rcx]
f711|223344556677885f5f5f5f5f5f5f	64	plan9	NOTL 0(CX)
f718|11223344556677885f5f5f5f5f5f	32	intel	neg dword ptr [eax]
f718|11223344556677885f5f5f5f5f5f	32	plan9	NEGL 0(AX)
f718|11223344556677885f5f5f5f5f5f	64	gnu	negl (%rax)
f718|11223344556677885f5f5f5f5f5f	64	intel	neg dword ptr [rax]
f718|11223344556677885f5f5f5f5f5f	64	plan9	NEGL 0(AX)
f720|11223344556677885f5f5f5f5f5f	32	intel	mul dword ptr [eax]
f720|11223344556677885f5f5f5f5f5f	32	plan9	MULL 0(AX)
f720|11223344556677885f5f5f5f5f5f	64	gnu	mull (%rax)
f720|11223344556677885f5f5f5f5f5f	64	intel	mul dword ptr [rax]
f720|11223344556677885f5f5f5f5f5f	64	plan9	MULL 0(AX)
f728|11223344556677885f5f5f5f5f5f	32	intel	imul dword ptr [eax]
f728|11223344556677885f5f5f5f5f5f	32	plan9	IMULL 0(AX)
f728|11223344556677885f5f5f5f5f5f	64	gnu	imull (%rax)
f728|11223344556677885f5f5f5f5f5f	64	intel	imul dword ptr [rax]
f728|11223344556677885f5f5f5f5f5f	64	plan9	IMULL 0(AX)
f730|11223344556677885f5f5f5f5f5f	32	intel	div dword ptr [eax]
f730|11223344556677885f5f5f5f5f5f	32	plan9	DIVL 0(AX)
f730|11223344556677885f5f5f5f5f5f	64	gnu	divl (%rax)
f730|11223344556677885f5f5f5f5f5f	64	intel	div dword ptr [rax]
f730|11223344556677885f5f5f5f5f5f	64	plan9	DIVL 0(AX)
f738|11223344556677885f5f5f5f5f5f	32	intel	idiv dword ptr [eax]
f738|11223344556677885f5f5f5f5f5f	32	plan9	IDIVL 0(AX)
f738|11223344556677885f5f5f5f5f5f	64	gnu	idivl (%rax)
f738|11223344556677885f5f5f5f5f5f	64	intel	idiv dword ptr [rax]
f738|11223344556677885f5f5f5f5f5f	64	plan9	IDIVL 0(AX)
f8|11223344556677885f5f5f5f5f5f5f	32	intel	clc
f8|11223344556677885f5f5f5f5f5f5f	32	plan9	CLC
f8|11223344556677885f5f5f5f5f5f5f	64	gnu	clc
f8|11223344556677885f5f5f5f5f5f5f	64	intel	clc
f8|11223344556677885f5f5f5f5f5f5f	64	plan9	CLC
f9|11223344556677885f5f5f5f5f5f5f	32	intel	stc
f9|11223344556677885f5f5f5f5f5f5f	32	plan9	STC
f9|11223344556677885f5f5f5f5f5f5f	64	gnu	stc
f9|11223344556677885f5f5f5f5f5f5f	64	intel	stc
f9|11223344556677885f5f5f5f5f5f5f	64	plan9	STC
fa|11223344556677885f5f5f5f5f5f5f	32	intel	cli
fa|11223344556677885f5f5f5f5f5f5f	32	plan9	CLI
fa|11223344556677885f5f5f5f5f5f5f	64	gnu	cli
fa|11223344556677885f5f5f5f5f5f5f	64	intel	cli
fa|11223344556677885f5f5f5f5f5f5f	64	plan9	CLI
fb|11223344556677885f5f5f5f5f5f5f	32	intel	sti
fb|11223344556677885f5f5f5f5f5f5f	32	plan9	STI
fb|11223344556677885f5f5f5f5f5f5f	64	gnu	sti
fb|11223344556677885f5f5f5f5f5f5f	64	intel	sti
fb|11223344556677885f5f5f5f5f5f5f	64	plan9	STI
fc|11223344556677885f5f5f5f5f5f5f	32	intel	cld
fc|11223344556677885f5f5f5f5f5f5f	32	plan9	CLD
fc|11223344556677885f5f5f5f5f5f5f	64	gnu	cld
fc|11223344556677885f5f5f5f5f5f5f	64	intel	cld
fc|11223344556677885f5f5f5f5f5f5f	64	plan9	CLD
fd|11223344556677885f5f5f5f5f5f5f	32	intel	std
fd|11223344556677885f5f5f5f5f5f5f	32	plan9	STD
fd|11223344556677885f5f5f5f5f5f5f	64	gnu	std
fd|11223344556677885f5f5f5f5f5f5f	64	intel	std
fd|11223344556677885f5f5f5f5f5f5f	64	plan9	STD
fe00|11223344556677885f5f5f5f5f5f	32	intel	inc byte ptr [eax]
fe00|11223344556677885f5f5f5f5f5f	32	plan9	INCL 0(AX)
fe00|11223344556677885f5f5f5f5f5f	64	gnu	incb (%rax)
fe00|11223344556677885f5f5f5f5f5f	64	intel	inc byte ptr [rax]
fe00|11223344556677885f5f5f5f5f5f	64	plan9	INCL 0(AX)
fe08|11223344556677885f5f5f5f5f5f	32	intel	dec byte ptr [eax]
fe08|11223344556677885f5f5f5f5f5f	32	plan9	DECL 0(AX)
fe08|11223344556677885f5f5f5f5f5f	64	gnu	decb (%rax)
fe08|11223344556677885f5f5f5f5f5f	64	intel	dec byte ptr [rax]
fe08|11223344556677885f5f5f5f5f5f	64	plan9	DECL 0(AX)
ff00|11223344556677885f5f5f5f5f5f	32	intel	inc dword ptr [eax]
ff00|11223344556677885f5f5f5f5f5f	32	plan9	INCL 0(AX)
ff00|11223344556677885f5f5f5f5f5f	64	gnu	incl (%rax)
ff00|11223344556677885f5f5f5f5f5f	64	intel	inc dword ptr [rax]
ff00|11223344556677885f5f5f5f5f5f	64	plan9	INCL 0(AX)
ff08|11223344556677885f5f5f5f5f5f	32	intel	dec dword ptr [eax]
ff08|11223344556677885f5f5f5f5f5f	32	plan9	DECL 0(AX)
ff08|11223344556677885f5f5f5f5f5f	64	gnu	decl (%rax)
ff08|11223344556677885f5f5f5f5f5f	64	intel	dec dword ptr [rax]
ff08|11223344556677885f5f5f5f5f5f	64	plan9	DECL 0(AX)
ff11|223344556677885f5f5f5f5f5f5f	32	intel	call dword ptr [ecx]
ff11|223344556677885f5f5f5f5f5f5f	32	plan9	CALL 0(CX)
ff18|11223344556677885f5f5f5f5f5f	32	intel	call far ptr [eax]
ff18|11223344556677885f5f5f5f5f5f	32	plan9	LCALL 0(AX)
ff18|11223344556677885f5f5f5f5f5f	64	gnu	lcallq *(%rax)
ff18|11223344556677885f5f5f5f5f5f	64	intel	call far ptr [rax]
ff18|11223344556677885f5f5f5f5f5f	64	plan9	LCALL 0(AX)
ff20|11223344556677885f5f5f5f5f5f	32	intel	jmp dword ptr [eax]
ff20|11223344556677885f5f5f5f5f5f	32	plan9	JMP 0(AX)
ff28|11223344556677885f5f5f5f5f5f	32	intel	jmp far ptr [eax]
ff28|11223344556677885f5f5f5f5f5f	32	plan9	LJMP 0(AX)
ff28|11223344556677885f5f5f5f5f5f	64	gnu	ljmpq *(%rax)
ff28|11223344556677885f5f5f5f5f5f	64	intel	jmp far ptr [rax]
ff28|11223344556677885f5f5f5f5f5f	64	plan9	LJMP 0(AX)
ff30|11223344556677885f5f5f5f5f5f	32	intel	push dword ptr [eax]
ff30|11223344556677885f5f5f5f5f5f	32	plan9	PUSHL 0(AX)
ff30|11223344556677885f5f5f5f5f5f	64	gnu	pushq (%rax)
ff30|11223344556677885f5f5f5f5f5f	64	intel	push qword ptr [rax]
ff30|11223344556677885f5f5f5f5f5f	64	plan9	PUSHL 0(AX)
                                                                                                                                                                                       root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/xed_test.go                                           0100644 0000000 0000000 00000017255 12600426226 021356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2014 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package x86asm

import (
	"bytes"
	"strings"
	"testing"
)

func TestXed32Manual(t *testing.T)   { testXed32(t, hexCases(t, xedManualTests)) }
func TestXed32Testdata(t *testing.T) { testXed32(t, concat(basicPrefixes, testdataCases(t))) }
func TestXed32ModRM(t *testing.T)    { testXed32(t, concat(basicPrefixes, enumModRM)) }
func TestXed32OneByte(t *testing.T)  { testBasic(t, testXed32) }
func TestXed320F(t *testing.T)       { testBasic(t, testXed32, 0x0F) }
func TestXed320F38(t *testing.T)     { testBasic(t, testXed32, 0x0F, 0x38) }
func TestXed320F3A(t *testing.T)     { testBasic(t, testXed32, 0x0F, 0x3A) }
func TestXed32Prefix(t *testing.T)   { testPrefix(t, testXed32) }

func TestXed64Manual(t *testing.T)   { testXed64(t, hexCases(t, xedManualTests)) }
func TestXed64Testdata(t *testing.T) { testXed64(t, concat(basicPrefixes, testdataCases(t))) }
func TestXed64ModRM(t *testing.T)    { testXed64(t, concat(basicPrefixes, enumModRM)) }
func TestXed64OneByte(t *testing.T)  { testBasic(t, testXed64) }
func TestXed640F(t *testing.T)       { testBasic(t, testXed64, 0x0F) }
func TestXed640F38(t *testing.T)     { testBasic(t, testXed64, 0x0F, 0x38) }
func TestXed640F3A(t *testing.T)     { testBasic(t, testXed64, 0x0F, 0x3A) }
func TestXed64Prefix(t *testing.T)   { testPrefix(t, testXed64) }

func TestXed64REXTestdata(t *testing.T) {
	testXed64(t, filter(concat3(basicPrefixes, rexPrefixes, testdataCases(t)), isValidREX))
}
func TestXed64REXModRM(t *testing.T)   { testXed64(t, concat3(basicPrefixes, rexPrefixes, enumModRM)) }
func TestXed64REXOneByte(t *testing.T) { testBasicREX(t, testXed64) }
func TestXed64REX0F(t *testing.T)      { testBasicREX(t, testXed64, 0x0F) }
func TestXed64REX0F38(t *testing.T)    { testBasicREX(t, testXed64, 0x0F, 0x38) }
func TestXed64REX0F3A(t *testing.T)    { testBasicREX(t, testXed64, 0x0F, 0x3A) }
func TestXed64REXPrefix(t *testing.T)  { testPrefixREX(t, testXed64) }

// xedManualTests holds test cases that will be run by TestXedManual32 and TestXedManual64.
// If you are debugging a few cases that turned up in a longer run, it can be useful
// to list them here and then use -run=XedManual, particularly with tracing enabled.
var xedManualTests = `
6690
`

// allowedMismatchXed reports whether the mismatch between text and dec
// should be allowed by the test.
func allowedMismatchXed(text string, size int, inst *Inst, dec ExtInst) bool {
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "GENERAL_ERROR", "INSTR_TOO_LONG", "BAD_LOCK_PREFIX") {
		return true
	}

	if contains(dec.text, "BAD_LOCK_PREFIX") && countExactPrefix(inst, PrefixLOCK|PrefixInvalid) > 0 {
		return true
	}

	if contains(dec.text, "BAD_LOCK_PREFIX", "GENERAL_ERROR") && countExactPrefix(inst, PrefixLOCK|PrefixImplicit) > 0 {
		return true
	}

	if text == "lock" && size == 1 && contains(dec.text, "BAD_LOCK_PREFIX") {
		return true
	}

	// Instructions not known to us.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, unsupported...) {
		return true
	}

	// Instructions not known to xed.
	if contains(text, xedUnsupported...) && contains(dec.text, "ERROR") {
		return true
	}

	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "shl ") && (inst.Opcode>>16)&0xEC38 == 0xC030 {
		return true
	}

	// 82 11 22: xed says 'adc byte ptr [ecx], 0x22' but there is no justification in the manuals for that.
	// C0 30 11: xed says 'shl byte ptr [eax], 0x11' but there is no justification in the manuals for that.
	// F6 08 11: xed says 'test byte ptr [eax], 0x11' but there is no justification in the manuals for that.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && hasByte(dec.enc[:dec.nenc], 0x82, 0xC0, 0xC1, 0xD0, 0xD1, 0xD2, 0xD3, 0xF6, 0xF7) {
		return true
	}

	// F3 11 22 and many others: xed allows and drops misused rep/repn prefix.
	if (text == "rep" && dec.enc[0] == 0xF3 || (text == "repn" || text == "repne") && dec.enc[0] == 0xF2) && (!contains(dec.text, "ins", "outs", "movs", "lods", "cmps", "scas") || contains(dec.text, "xmm")) {
		return true
	}

	// 0F C7 30: xed says vmptrld qword ptr [eax]; we say rdrand eax.
	// TODO(rsc): Fix, since we are probably wrong, but we don't have vmptrld in the manual.
	if contains(text, "rdrand") && contains(dec.text, "vmptrld", "vmxon", "vmclear") {
		return true
	}

	// F3 0F AE 00: we say 'rdfsbase dword ptr [eax]' but RDFSBASE needs a register.
	// Also, this is a 64-bit only instruction.
	// TODO(rsc): Fix to reject this encoding.
	if contains(text, "rdfsbase", "rdgsbase", "wrfsbase", "wrgsbase") && contains(dec.text, "ERROR") {
		return true
	}

	// 0F 01 F8: we say swapgs but that's only valid in 64-bit mode.
	// TODO(rsc): Fix.
	if contains(text, "swapgs") {
		return true
	}

	// 0F 24 11: 'mov ecx, tr2' except there is no TR2.
	// Or maybe the MOV to TR registers doesn't use RMF.
	if contains(text, "cr1", "cr5", "cr6", "cr7", "tr0", "tr1", "tr2", "tr3", "tr4", "tr5", "tr6", "tr7") && contains(dec.text, "ERROR") {
		return true
	}

	// 0F 19 11, 0F 1C 11, 0F 1D 11, 0F 1E 11, 0F 1F 11: xed says nop,
	// but the Intel manuals say that the only NOP there is 0F 1F /0.
	// Perhaps xed is reporting an older encoding.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "nop ") && (inst.Opcode>>8)&0xFFFF38 != 0x0F1F00 {
		return true
	}

	// 66 0F AE 38: clflushopt but we only know clflush
	if contains(text, "clflush") && contains(dec.text, "clflushopt") {
		return true
	}

	// 0F 20 04 11: MOV SP, CR0 but has mod!=3 despite register argument.
	// (This encoding ignores the mod bits.) The decoder sees the non-register
	// mod and reads farther ahead to decode the memory reference that
	// isn't really there, causing the size to be too large.
	// TODO(rsc): Fix.
	if text == dec.text && size > dec.nenc && contains(text, " cr", " dr", " tr") {
		return true
	}

	// 0F AE E9: xed says lfence, which is wrong (only 0F AE E8 is lfence). And so on.
	if contains(dec.text, "fence") && hasByte(dec.enc[:dec.nenc], 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF) {
		return true
	}

	// DD C9, DF C9: xed says 'fxch st0, st1' but that instruction is D9 C9.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fxch ") && hasByte(dec.enc[:dec.nenc], 0xDD, 0xDF) {
		return true
	}

	// DC D4: xed says 'fcom st0, st4' but that instruction is D8 D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fcom ") && hasByte(dec.enc[:dec.nenc], 0xD8, 0xDC) {
		return true
	}

	// DE D4: xed says 'fcomp st0, st4' but that instruction is D8 D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fcomp ") && hasByte(dec.enc[:dec.nenc], 0xDC, 0xDE) {
		return true
	}

	// DF D4: xed says 'fstp st4, st0' but that instruction is DD D4.
	if (contains(text, "error:") || isPrefix(text) && size == 1) && contains(dec.text, "fstp ") && hasByte(dec.enc[:dec.nenc], 0xDF) {
		return true
	}

	return false
}

func countExactPrefix(inst *Inst, target Prefix) int {
	n := 0
	for _, p := range inst.Prefix {
		if p == target {
			n++
		}
	}
	return n
}

func hasByte(src []byte, target ...byte) bool {
	for _, b := range target {
		if bytes.IndexByte(src, b) >= 0 {
			return true
		}
	}
	return false
}

// Instructions known to us but not to xed.
var xedUnsupported = strings.Fields(`
	xrstor
	xsave
	xsave
	ud1
	xgetbv
	xsetbv
	fxsave
	fxrstor
	clflush
	lfence
	mfence
	sfence
	rsqrtps
	rcpps
	emms
	ldmxcsr
	stmxcsr
	movhpd
	movnti
	rdrand
	movbe
	movlpd
	sysret
`)
                                                                                                                                                                                                                                                                                                                                                   root/go1.4/src/cmd/internal/rsc.io/x86/x86asm/xedext_test.go                                        0100644 0000000 0000000 00000010665 12600426226 022075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        package x86asm

import (
	"bytes"
	"fmt"
	"io"
	"log"
	"os"
	"strconv"
	"strings"
	"testing"
)

// xed binary from Intel sde-external-6.22.0-2014-03-06.
const xedPath = "/Users/rsc/bin/xed"

func testXedArch(t *testing.T, arch int, generate func(func([]byte))) {
	if testing.Short() {
		t.Skip("skipping libmach test in short mode")
	}

	if _, err := os.Stat(xedPath); err != nil {
		t.Fatal(err)
	}

	testExtDis(t, "intel", arch, xed, generate, allowedMismatchXed)
}

func testXed32(t *testing.T, generate func(func([]byte))) {
	testXedArch(t, 32, generate)
}

func testXed64(t *testing.T, generate func(func([]byte))) {
	testXedArch(t, 64, generate)
}

func xed(ext *ExtDis) error {
	b, err := ext.Run(xedPath, fmt.Sprintf("-%d", ext.Arch), "-n", "1G", "-ir", ext.File.Name())
	if err != nil {
		return err
	}

	nmatch := 0
	next := uint32(start)
	var (
		addr   uint32
		encbuf [32]byte
		enc    []byte
		text   string
	)

	var xedEnd = []byte("# end of text section")
	var xedEnd1 = []byte("# Errors")

	eof := false
	for {
		line, err := b.ReadSlice('\n')
		if err != nil {
			if err == io.EOF {
				break
			}
			return fmt.Errorf("reading objdump output: %v", err)
		}
		if debug {
			os.Stdout.Write(line)
		}
		if bytes.HasPrefix(line, xedEnd) || bytes.HasPrefix(line, xedEnd1) {
			eof = true
		}
		if eof {
			continue
		}
		nmatch++
		addr, enc, text = parseLineXed(line, encbuf[:0])
		if addr > next {
			return fmt.Errorf("address out of sync expected <= %#x at %q in:\n%s", next, line, line)
		}
		if addr < next {
			continue
		}
		switch text {
		case "repz":
			text = "rep"
		case "repnz":
			text = "repn"
		default:
			text = strings.Replace(text, "repz ", "rep ", -1)
			text = strings.Replace(text, "repnz ", "repn ", -1)
		}
		if m := pcrelw.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int16(uint32(targ)-uint32(uint16(addr))-uint32(len(enc))))
		}
		if m := pcrel.FindStringSubmatch(text); m != nil {
			targ, _ := strconv.ParseUint(m[2], 16, 64)
			text = fmt.Sprintf("%s .%+#x", m[1], int32(uint32(targ)-addr-uint32(len(enc))))
		}
		ext.Dec <- ExtInst{addr, encbuf, len(enc), text}
		encbuf = [32]byte{}
		enc = nil
		next += 32
	}
	if next != start+uint32(ext.Size) {
		return fmt.Errorf("not enough results found [%d %d]", next, start+ext.Size)
	}
	if err := ext.Wait(); err != nil {
		return fmt.Errorf("exec: %v", err)
	}

	return nil
}

var (
	xedInRaw    = []byte("In raw...")
	xedDots     = []byte("...")
	xdis        = []byte("XDIS ")
	xedError    = []byte("ERROR: ")
	xedNoDecode = []byte("Could not decode at offset: 0x")
)

func parseLineXed(line []byte, encstart []byte) (addr uint32, enc []byte, text string) {
	oline := line
	if bytes.HasPrefix(line, xedInRaw) || bytes.HasPrefix(line, xedDots) {
		return 0, nil, ""
	}
	if bytes.HasPrefix(line, xedError) {
		i := bytes.IndexByte(line[len(xedError):], ' ')
		if i < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		errstr := string(line[len(xedError):])
		i = bytes.Index(line, xedNoDecode)
		if i < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		i += len(xedNoDecode)
		j := bytes.IndexByte(line[i:], ' ')
		if j < 0 {
			log.Fatalf("cannot parse error: %q", oline)
		}
		x, err := strconv.ParseUint(string(trimSpace(line[i:i+j])), 16, 32)
		if err != nil {
			log.Fatalf("cannot parse disassembly: %q", oline)
		}
		addr = uint32(x)
		return addr, nil, errstr
	}

	if !bytes.HasPrefix(line, xdis) {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}

	i := bytes.IndexByte(line, ':')
	if i < 0 {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	x, err := strconv.ParseUint(string(trimSpace(line[len(xdis):i])), 16, 32)
	if err != nil {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}
	addr = uint32(x)

	// spaces
	i++
	for i < len(line) && line[i] == ' ' {
		i++
	}
	// instruction class, spaces
	for i < len(line) && line[i] != ' ' {
		i++
	}
	for i < len(line) && line[i] == ' ' {
		i++
	}
	// instruction set, spaces
	for i < len(line) && line[i] != ' ' {
		i++
	}
	for i < len(line) && line[i] == ' ' {
		i++
	}

	// hex
	hexStart := i
	for i < len(line) && line[i] != ' ' {
		i++
	}
	hexEnd := i
	for i < len(line) && line[i] == ' ' {
		i++
	}

	// text
	textStart := i
	for i < len(line) && line[i] != '\n' {
		i++
	}
	textEnd := i

	enc, ok := parseHex(line[hexStart:hexEnd], encstart)
	if !ok {
		log.Fatalf("cannot parse disassembly: %q", oline)
	}

	return addr, enc, string(fixSpace(line[textStart:textEnd]))
}
                                                                           root/go1.4/src/cmd/ld/                                                                              0040755 0000000 0000000 00000000000 12600426233 013012  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        root/go1.4/src/cmd/ld/data.c                                                                        0100644 0000000 0000000 00000105527 12600426226 014100  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Inferno utils/8l/asm.c
// http://code.google.com/p/inferno-os/source/browse/utils/8l/asm.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Data layout and relocation.

#include	"l.h"
#include	"../ld/lib.h"
#include	"../ld/elf.h"
#include	"../ld/macho.h"
#include	"../ld/pe.h"
#include	"../../runtime/mgc0.h"

void	dynreloc(void);

/*
 * divide-and-conquer list-link
 * sort of LSym* structures.
 * Used for the data block.
 */
int
datcmp(LSym *s1, LSym *s2)
{
	if(s1->type != s2->type)
		return (int)s1->type - (int)s2->type;
	if(s1->size != s2->size) {
		if(s1->size < s2->size)
			return -1;
		return +1;
	}
	return strcmp(s1->name, s2->name);
}

LSym*
listsort(LSym *l, int (*cmp)(LSym*, LSym*), int off)
{
	LSym *l1, *l2, *le;
	#define NEXT(l) (*(LSym**)((char*)(l)+off))

	if(l == 0 || NEXT(l) == 0)
		return l;

	l1 = l;
	l2 = l;
	for(;;) {
		l2 = NEXT(l2);
		if(l2 == 0)
			break;
		l2 = NEXT(l2);
		if(l2 == 0)
			break;
		l1 = NEXT(l1);
	}

	l2 = NEXT(l1);
	NEXT(l1) = 0;
	l1 = listsort(l, cmp, off);
	l2 = listsort(l2, cmp, off);

	/* set up lead element */
	if(cmp(l1, l2) < 0) {
		l = l1;
		l1 = NEXT(l1);
	} else {
		l = l2;
		l2 = NEXT(l2);
	}
	le = l;

	for(;;) {
		if(l1 == 0) {
			while(l2) {
				NEXT(le) = l2;
				le = l2;
				l2 = NEXT(l2);
			}
			NEXT(le) = 0;
			break;
		}
		if(l2 == 0) {
			while(l1) {
				NEXT(le) = l1;
				le = l1;
				l1 = NEXT(l1);
			}
			break;
		}
		if(cmp(l1, l2) < 0) {
			NEXT(le) = l1;
			le = l1;
			l1 = NEXT(l1);
		} else {
			NEXT(le) = l2;
			le = l2;
			l2 = NEXT(l2);
		}
	}
	NEXT(le) = 0;
	return l;
	
	#undef NEXT
}

void
relocsym(LSym *s)
{
	Reloc *r;
	LSym *rs;
	int32 i, off, siz, fl;
	vlong o;
	uchar *cast;

	ctxt->cursym = s;
	for(r=s->r; r<s->r+s->nr; r++) {
		r->done = 1;
		off = r->off;
		siz = r->siz;
		if(off < 0 || off+siz > s->np) {
			diag("%s: invalid relocation %d+%d not in [%d,%d)", s->name, off, siz, 0, s->np);
			continue;
		}
		if(r->sym != S && ((r->sym->type & (SMASK | SHIDDEN)) == 0 || (r->sym->type & SMASK) == SXREF)) {
			diag("%s: not defined", r->sym->name);
			continue;
		}
		if(r->type >= 256)
			continue;
		if(r->siz == 0) // informational relocation - no work to do
			continue;

		// Solaris needs the ability to reference dynimport symbols.
		if(HEADTYPE != Hsolaris && r->sym != S && r->sym->type == SDYNIMPORT)
			diag("unhandled relocation for %s (type %d rtype %d)", r->sym->name, r->sym->type, r->type);
		if(r->sym != S && r->sym->type != STLSBSS && !r->sym->reachable)
			diag("unreachable sym in relocation: %s %s", s->name, r->sym->name);

		// Android emulates runtime.tlsg as a regular variable.
		if (r->type == R_TLS && strcmp(goos, "android") == 0)
			r->type = R_ADDR;

		switch(r->type) {
		default:
			o = 0;
			if(archreloc(r, s, &o) < 0)
				diag("unknown reloc %d", r->type);
			break;
		case R_TLS:
			if(linkmode == LinkInternal && iself && thechar == '5') {
				// On ELF ARM, the thread pointer is 8 bytes before
				// the start of the thread-local data block, so add 8
				// to the actual TLS offset (r->sym->value).
				// This 8 seems to be a fundamental constant of
				// ELF on ARM (or maybe Glibc on ARM); it is not
				// related to the fact that our own TLS storage happens
				// to take up 8 bytes.
				o = 8 + r->sym->value;
				break;
			}
			r->done = 0;
			o = 0;
			if(thechar != '6')
				o = r->add;
			break;
		case R_TLS_LE:
			if(linkmode == LinkExternal && iself && HEADTYPE != Hopenbsd) {
				r->done = 0;
				r->sym = ctxt->tlsg;
				r->xsym = ctxt->tlsg;
				r->xadd = r->add;
				o = 0;
				if(thechar != '6')
					o = r->add;
				break;
			}
			o = ctxt->tlsoffset + r->add;
			break;

		case R_TLS_IE:
			if(linkmode == LinkExternal && iself && HEADTYPE != Hopenbsd) {
				r->done = 0;
				r->sym = ctxt->tlsg;
				r->xsym = ctxt->tlsg;
				r->xadd = r->add;
				o = 0;
				if(thechar != '6')
					o = r->add;
				break;
			}
			if(iself || ctxt->headtype == Hplan9)
				o = ctxt->tlsoffset + r->add;
			else if(ctxt->headtype == Hwindows)
				o = r->add;
			else
				sysfatal("unexpected R_TLS_IE relocation for %s", headstr(ctxt->headtype));
			break;
		case R_ADDR:
			if(linkmode == LinkExternal && r->sym->type != SCONST) {
				r->done = 0;

				// set up addend for eventual relocation via outer symbol.
				rs = r->sym;
				r->xadd = r->add;
				while(rs->outer != nil) {
					r->xadd += symaddr(rs) - symaddr(rs->outer);
					rs = rs->outer;
				}
				if(rs->type != SHOSTOBJ && rs->type != SDYNIMPORT && rs->sect == nil)
					diag("missing section for %s", rs->name);
				r->xsym = rs;

				o = r->xadd;
				if(iself) {
					if(thechar == '6')
						o = 0;
				} else if(HEADTYPE == Hdarwin) {
					if(rs->type != SHOSTOBJ)
						o += symaddr(rs);
				} else {
					diag("unhandled pcrel relocation for %s", headstring);
				}
				break;
			}
			o = symaddr(r->sym) + r->add;

			// On amd64, 4-byte offsets will be sign-extended, so it is impossible to
			// access more than 2GB of static data; fail at link time is better than
			// fail at runtime. See http://golang.org/issue/7980.
			// Instead of special casing only amd64, we treat this as an error on all
			// 64-bit architectures so as to be future-proof.
			if((int32)o < 0 && PtrSize > 4 && siz == 4) {
				diag("non-pc-relative relocation address is too big: %#llux", o);
				errorexit();
			}
			break;
		case R_CALL:
		case R_PCREL:
			// r->sym can be null when CALL $(constant) is transformed from absolute PC to relative PC call.
			if(linkmode == LinkExternal && r->sym && r->sym->type != SCONST && r->sym->sect != ctxt->cursym->sect) {
				r->done = 0;

				// set up addend for eventual relocation via outer symbol.
				rs = r->sym;
				r->xadd = r->add;
				while(rs->outer != nil) {
					r->xadd += symaddr(rs) - symaddr(rs->outer);
					rs = rs->outer;
				}
				r->xadd -= r->siz; // relative to address after the relocated chunk
				if(rs->type != SHOSTOBJ && rs->type != SDYNIMPORT && rs->sect == nil)
					diag("missing section for %s", rs->name);
				r->xsym = rs;

				o = r->xadd;
				if(iself) {
					if(thechar == '6')
						o = 0;
				} else if(HEADTYPE == Hdarwin) {
					if(r->type == R_CALL) {
						if(rs->type != SHOSTOBJ)
							o += symaddr(rs) - rs->sect->vaddr;
						o -= r->off; // relative to section offset, not symbol
					} else {
						o += r->siz;
					}
				} else {
					diag("unhandled pcrel relocation for %s", headstring);
				}
				break;
			}
			o = 0;
			if(r->sym)
				o += symaddr(r->sym);
			// NOTE: The (int32) cast on the next line works around a bug in Plan 9's 8c
			// compiler. The expression s->value + r->off + r->siz is int32 + int32 +
			// uchar, and Plan 9 8c incorrectly treats the expression as type uint32
			// instead of int32, causing incorrect values when sign extended for adding
			// to o. The bug only occurs on Plan 9, because this C program is compiled by
			// the standard host compiler (gcc on most other systems).
			o += r->add - (s->value + r->off + (int32)r->siz);
			break;
		case R_SIZE:
			o = r->sym->size + r->add;
			break;
		}
//print("relocate %s %#llux (%#llux+%#llux, size %d) => %s %#llux +%#llx [%llx]\n", s->name, (uvlong)(s->value+off), (uvlong)s->value, (uvlong)r->off, r->siz, r->sym ? r->sym->name : "<nil>", (uvlong)symaddr(r->sym), (vlong)r->add, (vlong)o);
		switch(siz) {
		default:
			ctxt->cursym = s;
			diag("bad reloc size %#ux for %s", siz, r->sym->name);
		case 1:
			// TODO(rsc): Remove.
			s->p[off] = (int8)o;
			break;
		case 4:
			if(r->type == R_PCREL || r->type == R_CALL) {
				if(o != (int32)o)
					diag("pc-relative relocation address is too big: %#llx", o);
			} else {
				if(o != (int32)o && o != (uint32)o)
					diag("non-pc-relative relocation address is too big: %#llux", o);
			}
			fl = o;
			cast = (uchar*)&fl;
			for(i=0; i<4; i++)
				s->p[off+i] = cast[inuxi4[i]];
			break;
		case 8:
			cast = (uchar*)&o;
			for(i=0; i<8; i++)
				s->p[off+i] = cast[inuxi8[i]];
			break;
		}
	}
}

void
reloc(void)
{
	LSym *s;

	if(debug['v'])
		Bprint(&bso, "%5.2f reloc\n", cputime());
	Bflush(&bso);

	for(s=ctxt->textp; s!=S; s=s->next)
		relocsym(s);
	for(s=datap; s!=S; s=s->next)
		relocsym(s);
}

void
dynrelocsym(LSym *s)
{
	Reloc *r;

	if(HEADTYPE == Hwindows) {
		LSym *rel, *targ;

		rel = linklookup(ctxt, ".rel", 0);
		if(s == rel)
			return;
		for(r=s->r; r<s->r+s->nr; r++) {
			targ = r->sym;
			if(targ == nil)
				continue;
			if(!targ->reachable)
				diag("internal inconsistency: dynamic symbol %s is not reachable.", targ->name);
			if(r->sym->plt == -2 && r->sym->got != -2) { // make dynimport JMP table for PE object files.
				targ->plt = rel->size;
				r->sym = rel;
				r->add = targ->plt;

				// jmp *addr
				if(thechar == '8') {
					adduint8(ctxt, rel, 0xff);
					adduint8(ctxt, rel, 0x25);
					addaddr(ctxt, rel, targ);
					adduint8(ctxt, rel, 0x90);
					adduint8(ctxt, rel, 0x90);
				} else {
					adduint8(ctxt, rel, 0xff);
					adduint8(ctxt, rel, 0x24);
					adduint8(ctxt, rel, 0x25);
					addaddrplus4(ctxt, rel, targ, 0);
					adduint8(ctxt, rel, 0x90);
				}
			} else if(r->sym->plt >= 0) {
				r->sym = rel;
				r->add = targ->plt;
			}
		}
		return;
	}

	for(r=s->r; r<s->r+s->nr; r++) {
		if(r->sym != S && r->sym->type == SDYNIMPORT || r->type >= 256) {
			if(r->sym != S && !r->sym->reachable)
				diag("internal inconsistency: dynamic symbol %s is not reachable.", r->sym->name);
			adddynrel(s, r);
		}
	}
}

void
dynreloc(void)
{
	LSym *s;

	// -d suppresses dynamic loader format, so we may as well not
	// compute these sections or mark their symbols as reachable.
	if(debug['d'] && HEADTYPE != Hwindows)
		return;
	if(debug['v'])
		Bprint(&bso, "%5.2f reloc\n", cputime());
	Bflush(&bso);

	for(s=ctxt->textp; s!=S; s=s->next)
		dynrelocsym(s);
	for(s=datap; s!=S; s=s->next)
		dynrelocsym(s);
	if(iself)
		elfdynhash();
}

static void
blk(LSym *start, int64 addr, int64 size)
{
	LSym *sym;
	int64 eaddr;
	uchar *p, *ep;

	for(sym = start; sym != nil; sym = sym->next)
		if(!(sym->type&SSUB) && sym->value >= addr)
			break;

	eaddr = addr+size;
	for(; sym != nil; sym = sym->next) {
		if(sym->type&SSUB)
			continue;
		if(sym->value >= eaddr)
			break;
		if(sym->value < addr) {
			diag("phase error: addr=%#llx but sym=%#llx type=%d", (vlong)addr, (vlong)sym->value, sym->type);
			errorexit();
		}
		ctxt->cursym = sym;
		for(; addr < sym->value; addr++)
			cput(0);
		p = sym->p;
		ep = p + sym->np;
		while(p < ep)
			cput(*p++);
		addr += sym->np;
		for(; addr < sym->value+sym->size; addr++)
			cput(0);
		if(addr != sym->value+sym->size) {
			diag("phase error: addr=%#llx value+size=%#llx", (vlong)addr, (vlong)sym->value+sym->size);
			errorexit();
		}
	}

	for(; addr < eaddr; addr++)
		cput(0);
	cflush();
}

void
codeblk(int64 addr, int64 size)
{
	LSym *sym;
	int64 eaddr, n;
	uchar *q;

	if(debug['a'])
		Bprint(&bso, "codeblk [%#x,%#x) at offset %#llx\n", addr, addr+size, cpos());

	blk(ctxt->textp, addr, size);

	/* again for printing */
	if(!debug['a'])
		return;

	for(sym = ctxt->textp; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= addr)
			break;
	}

	eaddr = addr + size;
	for(; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= eaddr)
			break;

		if(addr < sym->value) {
			Bprint(&bso, "%-20s %.8llux|", "_", (vlong)addr);
			for(; addr < sym->value; addr++)
				Bprint(&bso, " %.2ux", 0);
			Bprint(&bso, "\n");
		}

		Bprint(&bso, "%.6llux\t%-20s\n", (vlong)addr, sym->name);
		n = sym->size;
		q = sym->p;

		while(n >= 16) {
			Bprint(&bso, "%.6ux\t%-20.16I\n", addr, q);
			addr += 16;
			q += 16;
			n -= 16;
		}
		if(n > 0)
			Bprint(&bso, "%.6ux\t%-20.*I\n", addr, (int)n, q);
		addr += n;
	}

	if(addr < eaddr) {
		Bprint(&bso, "%-20s %.8llux|", "_", (vlong)addr);
		for(; addr < eaddr; addr++)
			Bprint(&bso, " %.2ux", 0);
	}
	Bflush(&bso);
}

void
datblk(int64 addr, int64 size)
{
	LSym *sym;
	int64 i, eaddr;
	uchar *p, *ep;
	char *typ, *rsname;
	Reloc *r;

	if(debug['a'])
		Bprint(&bso, "datblk [%#x,%#x) at offset %#llx\n", addr, addr+size, cpos());

	blk(datap, addr, size);

	/* again for printing */
	if(!debug['a'])
		return;

	for(sym = datap; sym != nil; sym = sym->next)
		if(sym->value >= addr)
			break;

	eaddr = addr + size;
	for(; sym != nil; sym = sym->next) {
		if(sym->value >= eaddr)
			break;
		if(addr < sym->value) {
			Bprint(&bso, "\t%.8ux| 00 ...\n", addr);
			addr = sym->value;
		}
		Bprint(&bso, "%s\n\t%.8ux|", sym->name, (uint)addr);
		p = sym->p;
		ep = p + sym->np;
		while(p < ep) {
			if(p > sym->p && (int)(p-sym->p)%16 == 0)
				Bprint(&bso, "\n\t%.8ux|", (uint)(addr+(p-sym->p)));
			Bprint(&bso, " %.2ux", *p++);
		}
		addr += sym->np;
		for(; addr < sym->value+sym->size; addr++)
			Bprint(&bso, " %.2ux", 0);
		Bprint(&bso, "\n");
		
		if(linkmode == LinkExternal) {
			for(i=0; i<sym->nr; i++) {
				r = &sym->r[i];
				rsname = "";
				if(r->sym)
					rsname = r->sym->name;
				typ = "?";
				switch(r->type) {
				case R_ADDR:
					typ = "addr";
					break;
				case R_PCREL:
					typ = "pcrel";
					break;
				case R_CALL:
					typ = "call";
					break;
				}
				Bprint(&bso, "\treloc %.8ux/%d %s %s+%#llx [%#llx]\n",
					(uint)(sym->value+r->off), r->siz, typ, rsname, (vlong)r->add, (vlong)(r->sym->value+r->add));
			}
		}				
	}

	if(addr < eaddr)
		Bprint(&bso, "\t%.8ux| 00 ...\n", (uint)addr);
	Bprint(&bso, "\t%.8ux|\n", (uint)eaddr);
}

void
strnput(char *s, int n)
{
	for(; n > 0 && *s; s++) {
		cput(*s);
		n--;
	}
	while(n > 0) {
		cput(0);
		n--;
	}
}

void
addstrdata(char *name, char *value)
{
	LSym *s, *sp;
	char *p;
	uchar reachable;

	p = smprint("%s.str", name);
	sp = linklookup(ctxt, p, 0);
	free(p);
	addstring(sp, value);
	sp->type = SRODATA;

	s = linklookup(ctxt, name, 0);
	s->size = 0;
	s->dupok = 1;
	reachable = s->reachable;
	addaddr(ctxt, s, sp);
	adduintxx(ctxt, s, strlen(value), PtrSize);

	// addstring, addaddr, etc., mark the symbols as reachable.
	// In this case that is not necessarily true, so stick to what
	// we know before entering this function.
	s->reachable = reachable;
	sp->reachable = reachable;
}

vlong
addstring(LSym *s, char *str)
{
	int n;
	int32 r;

	if(s->type == 0)
		s->type = SNOPTRDATA;
	s->reachable = 1;
	r = s->size;
	n = strlen(str)+1;
	if(strcmp(s->name, ".shstrtab") == 0)
		elfsetstring(str, r);
	symgrow(ctxt, s, r+n);
	memmove(s->p+r, str, n);
	s->size += n;
	return r;
}

void
dosymtype(void)
{
	LSym *s;

	for(s = ctxt->allsym; s != nil; s = s->allsym) {
		if(s->np > 0) {
			if(s->type == SBSS)
				s->type = SDATA;
			if(s->type == SNOPTRBSS)
				s->type = SNOPTRDATA;
		}
	}
}

static int32
symalign(LSym *s)
{
	int32 align;

	if(s->align != 0)
		return s->align;

	align = MaxAlign;
	while(align > s->size && align > 1)
		align >>= 1;
	if(align < s->align)
		align = s->align;
	return align;
}
	
static vlong
aligndatsize(vlong datsize, LSym *s)
{
	return rnd(datsize, symalign(s));
}

// maxalign returns the maximum required alignment for
// the list of symbols s; the list stops when s->type exceeds type.
static int32
maxalign(LSym *s, int type)
{
	int32 align, max;
	
	max = 0;
	for(; s != S && s->type <= type; s = s->next) {
		align = symalign(s);
		if(max < align)
			max = align;
	}
	return max;
}

// Helper object for building GC type programs.
typedef struct ProgGen ProgGen;
struct ProgGen
{
	LSym*	s;
	int32	datasize;
	uint8	data[256/PointersPerByte];
	vlong	pos;
};

static void
proggeninit(ProgGen *g, LSym *s)
{
	g->s = s;
	g->datasize = 0;
	g->pos = 0;
	memset(g->data, 0, sizeof(g->data));
}

static void
proggenemit(ProgGen *g, uint8 v)
{
	adduint8(ctxt, g->s, v);
}

// Writes insData block from g->data.
static void
proggendataflush(ProgGen *g)
{
	int32 i, s;

	if(g->datasize == 0)
		return;
	proggenemit(g, insData);
	proggenemit(g, g->datasize);
	s = (g->datasize + PointersPerByte - 1)/PointersPerByte;
	for(i = 0; i < s; i++)
		proggenemit(g, g->data[i]);
	g->datasize = 0;
	memset(g->data, 0, sizeof(g->data));
}

static void
proggendata(ProgGen *g, uint8 d)
{
	g->data[g->datasize/PointersPerByte] |= d << ((g->datasize%PointersPerByte)*BitsPerPointer);
	g->datasize++;
	if(g->datasize == 255)
		proggendataflush(g);
}

// Skip v bytes due to alignment, etc.
static void
proggenskip(ProgGen *g, vlong off, vlong v)
{
	vlong i;

	for(i = off; i < off+v; i++) {
		if((i%PtrSize) == 0)
			proggendata(g, BitsScalar);
	}
}

// Emit insArray instruction.
static void
proggenarray(ProgGen *g, vlong len)
{
	int32 i;

	proggendataflush(g);
	proggenemit(g, insArray);
	for(i = 0; i < PtrSize; i++, len >>= 8)
		proggenemit(g, len);
}

static void
proggenarrayend(ProgGen *g)
{
	proggendataflush(g);
	proggenemit(g, insArrayEnd);
}

static void
proggenfini(ProgGen *g, vlong size)
{
	proggenskip(g, g->pos, size - g->pos);
	proggendataflush(g);
	proggenemit(g, insEnd);
}


// This function generates GC pointer info for global variables.
static void
proggenaddsym(ProgGen *g, LSym *s)
{
	LSym *gcprog;
	uint8 *mask;
	vlong i, size;

	if(s->size == 0)
		return;

	// Skip alignment hole from the previous symbol.
	proggenskip(g, g->pos, s->value - g->pos);
	g->pos += s->value - g->pos;

	// The test for names beginning with . here is meant
	// to keep .dynamic and .dynsym from turning up as
	// conservative symbols. They should be marked SELFSECT
	// and not SDATA, but sometimes that doesn't happen.
	// Leave debugging the SDATA issue for the Go rewrite.

	if(s->gotype == nil && s->size >= PtrSize && s->name[0] != '.') {
		// conservative scan
		diag("missing Go type information for global symbol: %s size %d", s->name, (int)s->size);
		if((s->size%PtrSize) || (g->pos%PtrSize))
			diag("proggenaddsym: unaligned conservative symbol %s: size=%lld pos=%lld",
				s->name, s->size, g->pos);
		size = (s->size+PtrSize-1)/PtrSize*PtrSize;
		if(size < 32*PtrSize) {
			// Emit small symbols as data.
			for(i = 0; i < size/PtrSize; i++)
				proggendata(g, BitsPointer);
		} else {
			// Emit large symbols as array.
			proggenarray(g, size/PtrSize);
			proggendata(g, BitsPointer);
			proggenarrayend(g);
		}
		g->pos = s->value + size;
	} else if(s->gotype == nil || decodetype_noptr(s->gotype) || s->size < PtrSize || s->name[0] == '.') {
		// no scan
		if(s->size < 32*PtrSize) {
			// Emit small symbols as data.
			// This case also handles unaligned and tiny symbols, so tread carefully.
			for(i = s->value; i < s->value+s->size; i++) {
				if((i%PtrSize) == 0)
					proggendata(g, BitsScalar);
			}
		} else {
			// Emit large symbols as array.
			if((s->size%PtrSize) || (g->pos%PtrSize))
				diag("proggenaddsym: unaligned noscan symbol %s: size=%lld pos=%lld",
					s->name, s->size, g->pos);
			proggenarray(g, s->size/PtrSize);
			proggendata(g, BitsScalar);
			proggenarrayend(g);
		}
		g->pos = s->value + s->size;
	} else if(decodetype_usegcprog(s->gotype)) {
		// gc program, copy directly
		proggendataflush(g);
		gcprog = decodetype_gcprog(s->gotype);
		size = decodetype_size(s->gotype);
		if((size%PtrSize) || (g->pos%PtrSize))
			diag("proggenaddsym: unaligned gcprog symbol %s: size=%lld pos=%lld",
				s->name, s->size, g->pos);
		for(i = 0; i < gcprog->np-1; i++)
			proggenemit(g, gcprog->p[i]);
		g->pos = s->value + size;
	} else {
		// gc mask, it's small so emit as data
		mask = decodetype_gcmask(s->gotype);
		size = decodetype_size(s->gotype);
		if((size%PtrSize) || (g->pos%PtrSize))
			diag("proggenaddsym: unaligned gcmask symbol %s: size=%lld pos=%lld",
				s->name, s->size, g->pos);
		for(i = 0; i < size; i += PtrSize)
			proggendata(g, (mask[i/PtrSize/2]>>((i/PtrSize%2)*4+2))&BitsMask);
		g->pos = s->value + size;
	}
}

void
growdatsize(vlong *datsizep, LSym *s)
{
	vlong datsize;
	
	datsize = *datsizep;
	if(s->size < 0)
		diag("negative size (datsize = %lld, s->size = %lld)", datsize, s->size);
	if(datsize + s->size < datsize)
		diag("symbol too large (datsize = %lld, s->size = %lld)", datsize, s->size);
	*datsizep = datsize + s->size;
}

void
dodata(void)
{
	int32 n;
	vlong datsize;
	Section *sect;
	Segment *segro;
	LSym *s, *last, **l;
	LSym *gcdata, *gcbss;
	ProgGen gen;

	if(debug['v'])
		Bprint(&bso, "%5.2f dodata\n", cputime());
	Bflush(&bso);

	last = nil;
	datap = nil;

	for(s=ctxt->allsym; s!=S; s=s->allsym) {
		if(!s->reachable || s->special)
			continue;
		if(STEXT < s->type && s->type < SXREF) {
			if(s->onlist)
				sysfatal("symbol %s listed multiple times", s->name);
			s->onlist = 1;
			if(last == nil)
				datap = s;
			else
				last->next = s;
			s->next = nil;
			last = s;
		}
	}

	for(s = datap; s != nil; s = s->next) {
		if(s->np > s->size)
			diag("%s: initialize bounds (%lld < %d)",
				s->name, (vlong)s->size, s->np);
	}


	/*
	 * now that we have the datap list, but before we start
	 * to assign addresses, record all the necessary
	 * dynamic relocations.  these will grow the relocation
	 * symbol, which is itself data.
	 *
	 * on darwin, we need the symbol table numbers for dynreloc.
	 */
	if(HEADTYPE == Hdarwin)
		machosymorder();
	dynreloc();

	/* some symbols may no longer belong in datap (Mach-O) */
	for(l=&datap; (s=*l) != nil; ) {
		if(s->type <= STEXT || SXREF <= s->type)
			*l = s->next;
		else
			l = &s->next;
	}
	*l = nil;

	datap = listsort(datap, datcmp, offsetof(LSym, next));

	/*
	 * allocate sections.  list is sorted by type,
	 * so we can just walk it for each piece we want to emit.
	 * segdata is processed before segtext, because we need
	 * to see all symbols in the .data and .bss sections in order
	 * to generate garbage collection information.
	 */

	/* begin segdata */

	/* skip symbols belonging to segtext */
	s = datap;
	for(; s != nil && s->type < SELFSECT; s = s->next)
		;

	/* writable ELF sections */
	datsize = 0;
	for(; s != nil && s->type < SNOPTRDATA; s = s->next) {
		sect = addsection(&segdata, s->name, 06);
		sect->align = symalign(s);
		datsize = rnd(datsize, sect->align);
		sect->vaddr = datsize;
		s->sect = sect;
		s->type = SDATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
		sect->len = datsize - sect->vaddr;
	}

	/* pointer-free data */
	sect = addsection(&segdata, ".noptrdata", 06);
	sect->align = maxalign(s, SINITARR-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.noptrdata", 0)->sect = sect;
	linklookup(ctxt, "runtime.enoptrdata", 0)->sect = sect;
	for(; s != nil && s->type < SINITARR; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->type = SDATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;

	/* shared library initializer */
	if(flag_shared) {
		sect = addsection(&segdata, ".init_array", 06);
		sect->align = maxalign(s, SINITARR);
		datsize = rnd(datsize, sect->align);
		sect->vaddr = datsize;
		for(; s != nil && s->type == SINITARR; s = s->next) {
			datsize = aligndatsize(datsize, s);
			s->sect = sect;
			s->value = datsize - sect->vaddr;
			growdatsize(&datsize, s);
		}
		sect->len = datsize - sect->vaddr;
	}

	/* data */
	sect = addsection(&segdata, ".data", 06);
	sect->align = maxalign(s, SBSS-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.data", 0)->sect = sect;
	linklookup(ctxt, "runtime.edata", 0)->sect = sect;
	gcdata = linklookup(ctxt, "runtime.gcdata", 0);
	proggeninit(&gen, gcdata);
	for(; s != nil && s->type < SBSS; s = s->next) {
		if(s->type == SINITARR) {
			ctxt->cursym = s;
			diag("unexpected symbol type %d", s->type);
		}
		s->sect = sect;
		s->type = SDATA;
		datsize = aligndatsize(datsize, s);
		s->value = datsize - sect->vaddr;
		proggenaddsym(&gen, s);  // gc
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;
	proggenfini(&gen, sect->len);  // gc

	/* bss */
	sect = addsection(&segdata, ".bss", 06);
	sect->align = maxalign(s, SNOPTRBSS-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.bss", 0)->sect = sect;
	linklookup(ctxt, "runtime.ebss", 0)->sect = sect;
	gcbss = linklookup(ctxt, "runtime.gcbss", 0);
	proggeninit(&gen, gcbss);
	for(; s != nil && s->type < SNOPTRBSS; s = s->next) {
		s->sect = sect;
		datsize = aligndatsize(datsize, s);
		s->value = datsize - sect->vaddr;
		proggenaddsym(&gen, s);  // gc
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;
	proggenfini(&gen, sect->len);  // gc

	/* pointer-free bss */
	sect = addsection(&segdata, ".noptrbss", 06);
	sect->align = maxalign(s, SNOPTRBSS);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.noptrbss", 0)->sect = sect;
	linklookup(ctxt, "runtime.enoptrbss", 0)->sect = sect;
	for(; s != nil && s->type == SNOPTRBSS; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;
	linklookup(ctxt, "runtime.end", 0)->sect = sect;

	// 6g uses 4-byte relocation offsets, so the entire segment must fit in 32 bits.
	if(datsize != (uint32)datsize) {
		diag("data or bss segment too large");
	}
	
	if(iself && linkmode == LinkExternal && s != nil && s->type == STLSBSS && HEADTYPE != Hopenbsd) {
		sect = addsection(&segdata, ".tbss", 06);
		sect->align = PtrSize;
		sect->vaddr = 0;
		datsize = 0;
		for(; s != nil && s->type == STLSBSS; s = s->next) {
			datsize = aligndatsize(datsize, s);
			s->sect = sect;
			s->value = datsize - sect->vaddr;
			growdatsize(&datsize, s);
		}
		sect->len = datsize;
	} else {
		// Might be internal linking but still using cgo.
		// In that case, the only possible STLSBSS symbol is runtime.tlsg.
		// Give it offset 0, because it's the only thing here.
		if(s != nil && s->type == STLSBSS && strcmp(s->name, "runtime.tlsg") == 0) {
			s->value = 0;
			s = s->next;
		}
	}
	
	if(s != nil) {
		ctxt->cursym = nil;
		diag("unexpected symbol type %d for %s", s->type, s->name);
	}

	/*
	 * We finished data, begin read-only data.
	 * Not all systems support a separate read-only non-executable data section.
	 * ELF systems do.
	 * OS X and Plan 9 do not.
	 * Windows PE may, but if so we have not implemented it.
	 * And if we're using external linking mode, the point is moot,
	 * since it's not our decision; that code expects the sections in
	 * segtext.
	 */
	if(iself && linkmode == LinkInternal)
		segro = &segrodata;
	else
		segro = &segtext;

	s = datap;
	
	datsize = 0;
	
	/* read-only executable ELF, Mach-O sections */
	for(; s != nil && s->type < STYPE; s = s->next) {
		sect = addsection(&segtext, s->name, 04);
		sect->align = symalign(s);
		datsize = rnd(datsize, sect->align);
		sect->vaddr = datsize;
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
		sect->len = datsize - sect->vaddr;
	}

	/* read-only data */
	sect = addsection(segro, ".rodata", 04);
	sect->align = maxalign(s, STYPELINK-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = 0;
	linklookup(ctxt, "runtime.rodata", 0)->sect = sect;
	linklookup(ctxt, "runtime.erodata", 0)->sect = sect;
	for(; s != nil && s->type < STYPELINK; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;

	/* typelink */
	sect = addsection(segro, ".typelink", 04);
	sect->align = maxalign(s, STYPELINK);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.typelink", 0)->sect = sect;
	linklookup(ctxt, "runtime.etypelink", 0)->sect = sect;
	for(; s != nil && s->type == STYPELINK; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;

	/* gosymtab */
	sect = addsection(segro, ".gosymtab", 04);
	sect->align = maxalign(s, SPCLNTAB-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.symtab", 0)->sect = sect;
	linklookup(ctxt, "runtime.esymtab", 0)->sect = sect;
	for(; s != nil && s->type < SPCLNTAB; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;

	/* gopclntab */
	sect = addsection(segro, ".gopclntab", 04);
	sect->align = maxalign(s, SELFROSECT-1);
	datsize = rnd(datsize, sect->align);
	sect->vaddr = datsize;
	linklookup(ctxt, "runtime.pclntab", 0)->sect = sect;
	linklookup(ctxt, "runtime.epclntab", 0)->sect = sect;
	for(; s != nil && s->type < SELFROSECT; s = s->next) {
		datsize = aligndatsize(datsize, s);
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
	}
	sect->len = datsize - sect->vaddr;

	/* read-only ELF, Mach-O sections */
	for(; s != nil && s->type < SELFSECT; s = s->next) {
		sect = addsection(segro, s->name, 04);
		sect->align = symalign(s);
		datsize = rnd(datsize, sect->align);
		sect->vaddr = datsize;
		s->sect = sect;
		s->type = SRODATA;
		s->value = datsize - sect->vaddr;
		growdatsize(&datsize, s);
		sect->len = datsize - sect->vaddr;
	}

	// 6g uses 4-byte relocation offsets, so the entire segment must fit in 32 bits.
	if(datsize != (uint32)datsize) {
		diag("read-only data segment too large");
	}
	
	/* number the sections */
	n = 1;
	for(sect = segtext.sect; sect != nil; sect = sect->next)
		sect->extnum = n++;
	for(sect = segrodata.sect; sect != nil; sect = sect->next)
		sect->extnum = n++;
	for(sect = segdata.sect; sect != nil; sect = sect->next)
		sect->extnum = n++;
}

// assign addresses to text
void
textaddress(void)
{
	uvlong va;
	Section *sect;
	LSym *sym, *sub;

	addsection(&segtext, ".text", 05);

	// Assign PCs in text segment.
	// Could parallelize, by assigning to text
	// and then letting threads copy down, but probably not worth it.
	sect = segtext.sect;
	sect->align = funcalign;
	linklookup(ctxt, "runtime.text", 0)->sect = sect;
	linklookup(ctxt, "runtime.etext", 0)->sect = sect;
	va = INITTEXT;
	sect->vaddr = va;
	for(sym = ctxt->textp; sym != nil; sym = sym->next) {
		sym->sect = sect;
		if(sym->type & SSUB)
			continue;
		if(sym->align != 0)
			va = rnd(va, sym->align);
		else
			va = rnd(va, funcalign);
		sym->value = 0;
		for(sub = sym; sub != S; sub = sub->sub)
			sub->value += va;
		if(sym->size == 0 && sym->sub != S)
			ctxt->cursym = sym;
		va += sym->size;
	}
	sect->len = va - sect->vaddr;
}

// assign addresses
void
address(void)
{
	Section *s, *text, *data, *rodata, *symtab, *pclntab, *noptr, *bss, *noptrbss;
	Section *typelink;
	LSym *sym, *sub;
	uvlong va;
	vlong vlen;

	va = INITTEXT;
	segtext.rwx = 05;
	segtext.vaddr = va;
	segtext.fileoff = HEADR;
	for(s=segtext.sect; s != nil; s=s->next) {
		va = rnd(va, s->align);
		s->vaddr = va;
		va += s->len;
	}
	segtext.len = va - INITTEXT;
	segtext.filelen = segtext.len;
	if(HEADTYPE == Hnacl)
		va += 32; // room for the "halt sled"

	if(segrodata.sect != nil) {
		// align to page boundary so as not to mix
		// rodata and executable text.
		va = rnd(va, INITRND);

		segrodata.rwx = 04;
		segrodata.vaddr = va;
		segrodata.fileoff = va - segtext.vaddr + segtext.fileoff;
		segrodata.filelen = 0;
		for(s=segrodata.sect; s != nil; s=s->next) {
			va = rnd(va, s->align);
			s->vaddr = va;
			va += s->len;
		}
		segrodata.len = va - segrodata.vaddr;
		segrodata.filelen = segrodata.len;
	}

	va = rnd(va, INITRND);
	segdata.rwx = 06;
	segdata.vaddr = va;
	segdata.fileoff = va - segtext.vaddr + segtext.fileoff;
	segdata.filelen = 0;
	if(HEADTYPE == Hwindows)
		segdata.fileoff = segtext.fileoff + rnd(segtext.len, PEFILEALIGN);
	if(HEADTYPE == Hplan9)
		segdata.fileoff = segtext.fileoff + segtext.filelen;
	data = nil;
	noptr = nil;
	bss = nil;
	noptrbss = nil;
	for(s=segdata.sect; s != nil; s=s->next) {
		vlen = s->len;
		if(s->next)
			vlen = s->next->vaddr - s->vaddr;
		s->vaddr = va;
		va += vlen;
		segdata.len = va - segdata.vaddr;
		if(strcmp(s->name, ".data") == 0)
			data = s;
		if(strcmp(s->name, ".noptrdata") == 0)
			noptr = s;
		if(strcmp(s->name, ".bss") == 0)
			bss = s;
		if(strcmp(s->name, ".noptrbss") == 0)
			noptrbss = s;
	}
	segdata.filelen = bss->vaddr - segdata.vaddr;

	text = segtext.sect;
	if(segrodata.sect)
		rodata = segrodata.sect;
	else
		rodata = text->next;
	typelink = rodata->next;
	symtab = typelink->next;
	pclntab = symtab->next;

	for(sym = datap; sym != nil; sym = sym->next) {
		ctxt->cursym = sym;
		if(sym->sect != nil)
			sym->value += sym->sect->vaddr;
		for(sub = sym->sub; sub != nil; sub = sub->sub)
			sub->value += sym->value;
	}

	xdefine("runtime.text", STEXT, text->vaddr);
	xdefine("runtime.etext", STEXT, text->vaddr + text->len);
	xdefine("runtime.rodata", SRODATA, rodata->vaddr);
	xdefine("runtime.erodata", SRODATA, rodata->vaddr + rodata->len);
	xdefine("runtime.typelink", SRODATA, typelink->vaddr);
	xdefine("runtime.etypelink", SRODATA, typelink->vaddr + typelink->len);

	sym = linklookup(ctxt, "runtime.gcdata", 0);
	xdefine("runtime.egcdata", SRODATA, symaddr(sym) + sym->size);
	linklookup(ctxt, "runtime.egcdata", 0)->sect = sym->sect;

	sym = linklookup(ctxt, "runtime.gcbss", 0);
	xdefine("runtime.egcbss", SRODATA, symaddr(sym) + sym->size);
	linklookup(ctxt, "runtime.egcbss", 0)->sect = sym->sect;

	xdefine("runtime.symtab", SRODATA, symtab->vaddr);
	xdefine("runtime.esymtab", SRODATA, symtab->vaddr + symtab->len);
	xdefine("runtime.pclntab", SRODATA, pclntab->vaddr);
	xdefine("runtime.epclntab", SRODATA, pclntab->vaddr + pclntab->len);
	xdefine("runtime.noptrdata", SNOPTRDATA, noptr->vaddr);
	xdefine("runtime.enoptrdata", SNOPTRDATA, noptr->vaddr + noptr->len);
	xdefine("runtime.bss", SBSS, bss->vaddr);
	xdefine("runtime.ebss", SBSS, bss->vaddr + bss->len);
	xdefine("runtime.data", SDATA, data->vaddr);
	xdefine("runtime.edata", SDATA, data->vaddr + data->len);
	xdefine("runtime.noptrbss", SNOPTRBSS, noptrbss->vaddr);
	xdefine("runtime.enoptrbss", SNOPTRBSS, noptrbss->vaddr + noptrbss->len);
	xdefine("runtime.end", SBSS, segdata.vaddr + segdata.len);
}
                                                                                                                                                                         root/go1.4/src/cmd/ld/decodesym.c                                                                   0100644 0000000 0000000 00000010646 12600426226 015140  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2012 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include	"l.h"
#include	"lib.h"
#include	"../../runtime/typekind.h"

// Decoding the type.* symbols.	 This has to be in sync with
// ../../runtime/type.go, or more specificaly, with what
// ../gc/reflect.c stuffs in these.

static Reloc*
decode_reloc(LSym *s, int32 off)
{
	int i;

	for (i = 0; i < s->nr; i++)
		if (s->r[i].off == off)
			return s->r + i;
	return nil;
}

static LSym*
decode_reloc_sym(LSym *s, int32 off)
{
	Reloc *r;

	r = decode_reloc(s,off);
	if (r == nil)
		return nil;
	return r->sym;
}

static uvlong
decode_inuxi(uchar* p, int sz)
{
	uint64 v;
	uint32 l;
	uchar *cast, *inuxi;
	int i;

	v = l = 0;
	cast = nil;
	inuxi = nil;
	switch (sz) {
	case 2:
		cast = (uchar*)&l;
		inuxi = inuxi2;
		break;
	case 4:
		cast = (uchar*)&l;
		inuxi = inuxi4;
		break;
	case 8:
		cast = (uchar*)&v;
		inuxi = inuxi8;
		break;
	default:
		diag("dwarf: decode inuxi %d", sz);
		errorexit();
	}
	for (i = 0; i < sz; i++)
		cast[inuxi[i]] = p[i];
	if (sz == 8)
		return v;
	return l;
}

static int
commonsize(void)
{
	return 8*PtrSize + 8;
}

// Type.commonType.kind
uint8
decodetype_kind(LSym *s)
{
	return s->p[1*PtrSize + 7] & KindMask;	//  0x13 / 0x1f
}

// Type.commonType.kind
uint8
decodetype_noptr(LSym *s)
{
	return s->p[1*PtrSize + 7] & KindNoPointers;	//  0x13 / 0x1f
}

// Type.commonType.kind
uint8
decodetype_usegcprog(LSym *s)
{
	return s->p[1*PtrSize + 7] & KindGCProg;	//  0x13 / 0x1f
}

// Type.commonType.size
vlong
decodetype_size(LSym *s)
{
	return decode_inuxi(s->p, PtrSize);	 // 0x8 / 0x10
}

// Type.commonType.gc
LSym*
decodetype_gcprog(LSym *s)
{
	return decode_reloc_sym(s, 1*PtrSize + 8 + 2*PtrSize);
}

uint8*
decodetype_gcmask(LSym *s)
{
	LSym *mask;
	
	mask = decode_reloc_sym(s, 1*PtrSize + 8 + 1*PtrSize);
	return mask->p;
}

// Type.ArrayType.elem and Type.SliceType.Elem
LSym*
decodetype_arrayelem(LSym *s)
{
	return decode_reloc_sym(s, commonsize());	// 0x1c / 0x30
}

vlong
decodetype_arraylen(LSym *s)
{
	return decode_inuxi(s->p + commonsize()+2*PtrSize, PtrSize);
}

// Type.PtrType.elem
LSym*
decodetype_ptrelem(LSym *s)
{
	return decode_reloc_sym(s, commonsize());	// 0x1c / 0x30
}

// Type.MapType.key, elem
LSym*
decodetype_mapkey(LSym *s)
{
	return decode_reloc_sym(s, commonsize());	// 0x1c / 0x30
}

LSym*
decodetype_mapvalue(LSym *s)
{
	return decode_reloc_sym(s, commonsize()+PtrSize);	// 0x20 / 0x38
}

// Type.ChanType.elem
LSym*
decodetype_chanelem(LSym *s)
{
	return decode_reloc_sym(s, commonsize());	// 0x1c / 0x30
}

// Type.FuncType.dotdotdot
int
decodetype_funcdotdotdot(LSym *s)
{
	return s->p[commonsize()];
}

// Type.FuncType.in.len
int
decodetype_funcincount(LSym *s)
{
	return decode_inuxi(s->p + commonsize()+2*PtrSize, IntSize);
}

int
decodetype_funcoutcount(LSym *s)
{
	return decode_inuxi(s->p + commonsize()+3*PtrSize + 2*IntSize, IntSize);
}

LSym*
decodetype_funcintype(LSym *s, int i)
{
	Reloc *r;

	r = decode_reloc(s, commonsize() + PtrSize);
	if (r == nil)
		return nil;
	return decode_reloc_sym(r->sym, r->add + i * PtrSize);
}

LSym*
decodetype_funcouttype(LSym *s, int i)
{
	Reloc *r;

	r = decode_reloc(s, commonsize() + 2*PtrSize + 2*IntSize);
	if (r == nil)
		return nil;
	return decode_reloc_sym(r->sym, r->add + i * PtrSize);
}

// Type.StructType.fields.Slice::len
int
decodetype_structfieldcount(LSym *s)
{
	return decode_inuxi(s->p + commonsize() + PtrSize, IntSize);
}

static int
structfieldsize(void)
{
	return 5*PtrSize;
}

// Type.StructType.fields[]-> name, typ and offset.
char*
decodetype_structfieldname(LSym *s, int i)
{
	Reloc *r;

	// go.string."foo"  0x28 / 0x40
	s = decode_reloc_sym(s, commonsize() + PtrSize + 2*IntSize + i*structfieldsize());
	if (s == nil)			// embedded structs have a nil name.
		return nil;
	r = decode_reloc(s, 0);		// s has a pointer to the string data at offset 0
	if (r == nil)			// shouldn't happen.
		return nil;
	return (char*) r->sym->p + r->add;	// the c-string
}

LSym*
decodetype_structfieldtype(LSym *s, int i)
{
	return decode_reloc_sym(s, commonsize() + PtrSize + 2*IntSize + i*structfieldsize() + 2*PtrSize);
}

vlong
decodetype_structfieldoffs(LSym *s, int i)
{
	return decode_inuxi(s->p + commonsize() + PtrSize + 2*IntSize + i*structfieldsize() + 4*PtrSize, IntSize);
}

// InterfaceTYpe.methods.len
vlong
decodetype_ifacemethodcount(LSym *s)
{
	return decode_inuxi(s->p + commonsize() + PtrSize, IntSize);
}
                                                                                          root/go1.4/src/cmd/ld/doc.go                                                                        0100644 0000000 0000000 00000007204 12600426226 014110  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

/*

Ld is the portable code for a modified version of the Plan 9 linker.  The original is documented at

	http://plan9.bell-labs.com/magic/man2html/1/8l

It reads object files (.5, .6, or .8 files) and writes a binary named for the
architecture (5.out, 6.out, 8.out) by default (if $GOOS is windows, a .exe suffix
will be appended).

Major changes include:
	- support for ELF, Mach-O and PE binary files
	- support for segmented stacks (this feature is implemented here, not in the compilers).

Original options are listed on the manual page linked above.

Usage:
	go tool 6l [flags] mainObj
Substitute 6l with 8l or 5l as appropriate.

Options new in this version:

	-d
		Elide the dynamic linking header.  With this option, the binary
		is statically linked and does not refer to a dynamic linker.  Without this option
		(the default), the binary's contents are identical but it is loaded with a dynamic
		linker. This flag cannot be used when $GOOS is windows.
	-H darwin     (only in 6l/8l)
		Write Apple Mach-O binaries (default when $GOOS is darwin)
	-H dragonfly  (only in 6l/8l)
		Write DragonFly ELF binaries (default when $GOOS is dragonfly)
	-H linux
		Write Linux ELF binaries (default when $GOOS is linux)
	-H freebsd
		Write FreeBSD ELF binaries (default when $GOOS is freebsd)
	-H netbsd
		Write NetBSD ELF binaries (default when $GOOS is netbsd)
	-H openbsd    (only in 6l/8l)
		Write OpenBSD ELF binaries (default when $GOOS is openbsd)
	-H solaris    (only in 6l)
		Write Solaris ELF binaries (default when $GOOS is solaris)
	-H windows    (only in 6l/8l)
		Write Windows PE32+ Console binaries (default when $GOOS is windows)
	-H windowsgui (only in 6l/8l)
		Write Windows PE32+ GUI binaries
	-I interpreter
		Set the ELF dynamic linker to use.
	-L dir1 -L dir2
		Search for libraries (package files) in dir1, dir2, etc.
		The default is the single location $GOROOT/pkg/$GOOS_$GOARCH.
	-r dir1:dir2:...
		Set the dynamic linker search path when using ELF.
	-s
		Omit the symbol table and debug information.
	-V
		Print the linker version.
	-w
		Omit the DWARF symbol table.
	-X symbol value
		Set the value of a string variable. The symbol name
		should be of the form importpath.name, as displayed
		in the symbol table printed by "go tool nm".
	-race
		Link with race detection libraries.
	-B value
		Add a NT_GNU_BUILD_ID note when using ELF.  The value
		should start with 0x and be an even number of hex digits.
	-Z
		Zero stack on function entry. This is expensive but it might
		be useful in cases where you are suffering from false positives
		during garbage collection and are willing to trade the CPU time
		for getting rid of the false positives.
		NOTE: it only eliminates false positives caused by other function
		calls, not false positives caused by dead temporaries stored in
		the current function call.
	-linkmode argument
		Set the linkmode.  The argument must be one of
		internal, external, or auto.  The default is auto.
		This sets the linking mode as described in
		../cgo/doc.go.
	-tmpdir dir
		Set the location to use for any temporary files.  The
		default is a newly created directory that is removed
		after the linker completes.  Temporary files are only
		used in external linking mode.
	-extld name
		Set the name of the external linker to use in external
		linking mode.  The default is "gcc".
	-extldflags flags
		Set space-separated trailing flags to pass to the
		external linker in external linking mode.  The default
		is to not pass any additional trailing flags.
*/
package main
                                                                                                                                                                                                                                                                                                                                                                                            root/go1.4/src/cmd/ld/dwarf.c                                                                       0100644 0000000 0000000 00000161703 12600426226 014270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// TODO/NICETOHAVE:
//   - eliminate DW_CLS_ if not used
//   - package info in compilation units
//   - assign global variables and types to their packages
//   - gdb uses c syntax, meaning clumsy quoting is needed for go identifiers. eg
//     ptype struct '[]uint8' and qualifiers need to be quoted away
//   - lexical scoping is lost, so gdb gets confused as to which 'main.i' you mean.
//   - file:line info for variables
//   - make strings a typedef so prettyprinters can see the underlying string type
//
#include	"l.h"
#include	"lib.h"
#include	"../ld/dwarf.h"
#include	"../ld/dwarf_defs.h"
#include	"../ld/elf.h"
#include	"../ld/macho.h"
#include	"../ld/pe.h"
#include	"../../runtime/typekind.h"

/*
 * Offsets and sizes of the debug_* sections in the cout file.
 */

static vlong abbrevo;
static vlong abbrevsize;
static LSym*  abbrevsym;
static vlong abbrevsympos;
static vlong lineo;
static vlong linesize;
static LSym*  linesym;
static vlong linesympos;
static vlong infoo;	// also the base for DWDie->offs and reference attributes.
static vlong infosize;
static LSym*  infosym;
static vlong infosympos;
static vlong frameo;
static vlong framesize;
static LSym*  framesym;
static vlong framesympos;
static vlong pubnameso;
static vlong pubnamessize;
static vlong pubtypeso;
static vlong pubtypessize;
static vlong arangeso;
static vlong arangessize;
static vlong gdbscripto;
static vlong gdbscriptsize;

static LSym *infosec;
static vlong inforeloco;
static vlong inforelocsize;

static LSym *arangessec;
static vlong arangesreloco;
static vlong arangesrelocsize;

static LSym *linesec;
static vlong linereloco;
static vlong linerelocsize;

static LSym *framesec;
static vlong framereloco;
static vlong framerelocsize;

static char  gdbscript[1024];

/*
 *  Basic I/O
 */

static void
addrput(vlong addr)
{
	switch(PtrSize) {
	case 4:
		LPUT(addr);
		break;
	case 8:
		VPUT(addr);
		break;
	}
}

static int
uleb128enc(uvlong v, char* dst)
{
	uint8 c, len;

	len = 0;
	do {
		c = v & 0x7f;
		v >>= 7;
		if (v)
			c |= 0x80;
		if (dst)
			*dst++ = c;
		len++;
	} while (c & 0x80);
	return len;
};

static int
sleb128enc(vlong v, char *dst)
{
	uint8 c, s, len;

	len = 0;
	do {
		c = v & 0x7f;
		s = v & 0x40;
		v >>= 7;
		if ((v != -1 || !s) && (v != 0 || s))
			c |= 0x80;
		if (dst)
			*dst++ = c;
		len++;
	} while(c & 0x80);
	return len;
}

static void
uleb128put(vlong v)
{
	char buf[10];
	strnput(buf, uleb128enc(v, buf));
}

static void
sleb128put(vlong v)
{
	char buf[10];
	strnput(buf, sleb128enc(v, buf));
}

/*
 * Defining Abbrevs.  This is hardcoded, and there will be
 * only a handful of them.  The DWARF spec places no restriction on
 * the ordering of attributes in the Abbrevs and DIEs, and we will
 * always write them out in the order of declaration in the abbrev.
 */
typedef struct DWAttrForm DWAttrForm;
struct DWAttrForm {
	uint16 attr;
	uint8 form;
};

// Go-specific type attributes.
enum {
	DW_AT_go_kind = 0x2900,
	DW_AT_go_key = 0x2901,
	DW_AT_go_elem = 0x2902,

	DW_AT_internal_location = 253,	 // params and locals; not emitted
};

// Index into the abbrevs table below.
// Keep in sync with ispubname() and ispubtype() below.
// ispubtype considers >= NULLTYPE public
enum
{
	DW_ABRV_NULL,
	DW_ABRV_COMPUNIT,
	DW_ABRV_FUNCTION,
	DW_ABRV_VARIABLE,
	DW_ABRV_AUTO,
	DW_ABRV_PARAM,
	DW_ABRV_STRUCTFIELD,
	DW_ABRV_FUNCTYPEPARAM,
	DW_ABRV_DOTDOTDOT,
	DW_ABRV_ARRAYRANGE,
	DW_ABRV_NULLTYPE,
	DW_ABRV_BASETYPE,
	DW_ABRV_ARRAYTYPE,
	DW_ABRV_CHANTYPE,
	DW_ABRV_FUNCTYPE,
	DW_ABRV_IFACETYPE,
	DW_ABRV_MAPTYPE,
	DW_ABRV_PTRTYPE,
	DW_ABRV_BARE_PTRTYPE, // only for void*, no DW_AT_type attr to please gdb 6.
	DW_ABRV_SLICETYPE,
	DW_ABRV_STRINGTYPE,
	DW_ABRV_STRUCTTYPE,
	DW_ABRV_TYPEDECL,
	DW_NABRV
};

typedef struct DWAbbrev DWAbbrev;
static struct DWAbbrev {
	uint8 tag;
	uint8 children;
	DWAttrForm attr[30];
} abbrevs[DW_NABRV] = {
	/* The mandatory DW_ABRV_NULL entry. */
	{ 0 },
	/* COMPUNIT */
	{
		DW_TAG_compile_unit, DW_CHILDREN_yes,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_language,	 DW_FORM_data1,
		DW_AT_low_pc,	 DW_FORM_addr,
		DW_AT_high_pc,	 DW_FORM_addr,
		DW_AT_stmt_list, DW_FORM_data4,
		0, 0
	},
	/* FUNCTION */
	{
		DW_TAG_subprogram, DW_CHILDREN_yes,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_low_pc,	 DW_FORM_addr,
		DW_AT_high_pc,	 DW_FORM_addr,
		DW_AT_external,	 DW_FORM_flag,
		0, 0
	},
	/* VARIABLE */
	{
		DW_TAG_variable, DW_CHILDREN_no,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_location,	 DW_FORM_block1,
		DW_AT_type,	 DW_FORM_ref_addr,
		DW_AT_external,	 DW_FORM_flag,
		0, 0
	},
	/* AUTO */
	{
		DW_TAG_variable, DW_CHILDREN_no,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_location,	 DW_FORM_block1,
		DW_AT_type,	 DW_FORM_ref_addr,
		0, 0
	},
	/* PARAM */
	{
		DW_TAG_formal_parameter, DW_CHILDREN_no,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_location,	 DW_FORM_block1,
		DW_AT_type,	 DW_FORM_ref_addr,
		0, 0
	},
	/* STRUCTFIELD */
	{
		DW_TAG_member,	DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		DW_AT_data_member_location, DW_FORM_block1,
		DW_AT_type,	 DW_FORM_ref_addr,
		0, 0
	},
	/* FUNCTYPEPARAM */
	{
		DW_TAG_formal_parameter, DW_CHILDREN_no,
		// No name!
		DW_AT_type,	 DW_FORM_ref_addr,
		0, 0
	},

	/* DOTDOTDOT */
	{
		DW_TAG_unspecified_parameters, DW_CHILDREN_no,
		0, 0
	},
	/* ARRAYRANGE */
	{
		DW_TAG_subrange_type, DW_CHILDREN_no,
		// No name!
		DW_AT_type,	 DW_FORM_ref_addr,
		DW_AT_count, DW_FORM_udata,
		0, 0
	},

	// Below here are the types considered public by ispubtype
	/* NULLTYPE */
	{
		DW_TAG_unspecified_type, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		0, 0
	},
	/* BASETYPE */
	{
		DW_TAG_base_type, DW_CHILDREN_no,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_encoding,	 DW_FORM_data1,
		DW_AT_byte_size, DW_FORM_data1,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},
	/* ARRAYTYPE */
	// child is subrange with upper bound
	{
		DW_TAG_array_type, DW_CHILDREN_yes,
		DW_AT_name,	DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_byte_size, DW_FORM_udata,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},

	/* CHANTYPE */
	{
		DW_TAG_typedef, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_go_kind, DW_FORM_data1,
		DW_AT_go_elem, DW_FORM_ref_addr,
		0, 0
	},

	/* FUNCTYPE */
	{
		DW_TAG_subroutine_type, DW_CHILDREN_yes,
		DW_AT_name,	DW_FORM_string,
//		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},

	/* IFACETYPE */
	{
		DW_TAG_typedef, DW_CHILDREN_yes,
		DW_AT_name,	 DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},

	/* MAPTYPE */
	{
		DW_TAG_typedef, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_go_kind, DW_FORM_data1,
		DW_AT_go_key, DW_FORM_ref_addr,
		DW_AT_go_elem, DW_FORM_ref_addr,
		0, 0
	},

	/* PTRTYPE */
	{
		DW_TAG_pointer_type, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},
	/* BARE_PTRTYPE */
	{
		DW_TAG_pointer_type, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		0, 0
	},

	/* SLICETYPE */
	{
		DW_TAG_structure_type, DW_CHILDREN_yes,
		DW_AT_name,	DW_FORM_string,
		DW_AT_byte_size, DW_FORM_udata,
		DW_AT_go_kind, DW_FORM_data1,
		DW_AT_go_elem, DW_FORM_ref_addr,
		0, 0
	},

	/* STRINGTYPE */
	{
		DW_TAG_structure_type, DW_CHILDREN_yes,
		DW_AT_name,	DW_FORM_string,
		DW_AT_byte_size, DW_FORM_udata,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},

	/* STRUCTTYPE */
	{
		DW_TAG_structure_type, DW_CHILDREN_yes,
		DW_AT_name,	DW_FORM_string,
		DW_AT_byte_size, DW_FORM_udata,
		DW_AT_go_kind, DW_FORM_data1,
		0, 0
	},

	/* TYPEDECL */
	{
		DW_TAG_typedef, DW_CHILDREN_no,
		DW_AT_name,	DW_FORM_string,
		DW_AT_type,	DW_FORM_ref_addr,
		0, 0
	},
};

static void
writeabbrev(void)
{
	int i, j;
	DWAttrForm *f;

	abbrevo = cpos();
	for (i = 1; i < DW_NABRV; i++) {
		// See section 7.5.3
		uleb128put(i);
		uleb128put(abbrevs[i].tag);
		cput(abbrevs[i].children);
		for(j=0; j<nelem(abbrevs[i].attr); j++) {
			f = &abbrevs[i].attr[j];
			uleb128put(f->attr);
			uleb128put(f->form);
			if(f->attr == 0)
				break;
		}
	}
	cput(0);
	abbrevsize = cpos() - abbrevo;
}

/*
 * Debugging Information Entries and their attributes.
 */

enum
{
	HASHSIZE = 107
};

static uint32
hashstr(char* s)
{
	uint32 h;

	h = 0;
	while (*s)
		h = h+h+h + *s++;
	return h % HASHSIZE;
}

// For DW_CLS_string and _block, value should contain the length, and
// data the data, for _reference, value is 0 and data is a DWDie* to
// the referenced instance, for all others, value is the whole thing
// and data is null.

typedef struct DWAttr DWAttr;
struct DWAttr {
	DWAttr *link;
	uint16 atr;  // DW_AT_
	uint8 cls;  // DW_CLS_
	vlong value;
	char *data;
};

typedef struct DWDie DWDie;
struct DWDie {
	int abbrev;
	DWDie *link;
	DWDie *child;
	DWAttr *attr;
	// offset into .debug_info section, i.e relative to
	// infoo. only valid after call to putdie()
	vlong offs;
	DWDie **hash;  // optional index of children by name, enabled by mkindex()
	DWDie *hlink;  // bucket chain in parent's index
};

/*
 * Root DIEs for compilation units, types and global variables.
 */

static DWDie dwroot;
static DWDie dwtypes;
static DWDie dwglobals;

static DWAttr*
newattr(DWDie *die, uint16 attr, int cls, vlong value, char *data)
{
	DWAttr *a;

	a = mal(sizeof *a);
	a->link = die->attr;
	die->attr = a;
	a->atr = attr;
	a->cls = cls;
	a->value = value;
	a->data = data;
	return a;
}

// Each DIE (except the root ones) has at least 1 attribute: its
// name. getattr moves the desired one to the front so
// frequently searched ones are found faster.
static DWAttr*
getattr(DWDie *die, uint16 attr)
{
	DWAttr *a, *b;

	if (die->attr->atr == attr)
		return die->attr;

	a = die->attr;
	b = a->link;
	while (b != nil) {
		if (b->atr == attr) {
			a->link = b->link;
			b->link = die->attr;
			die->attr = b;
			return b;
		}
		a = b;
		b = b->link;
	}
	return nil;
}

// Every DIE has at least a DW_AT_name attribute (but it will only be
// written out if it is listed in the abbrev).	If its parent is
// keeping an index, the new DIE will be inserted there.
static DWDie*
newdie(DWDie *parent, int abbrev, char *name)
{
	DWDie *die;
	int h;

	die = mal(sizeof *die);
	die->abbrev = abbrev;
	die->link = parent->child;
	parent->child = die;

	newattr(die, DW_AT_name, DW_CLS_STRING, strlen(name), name);

	if (parent->hash) {
		h = hashstr(name);
		die->hlink = parent->hash[h];
		parent->hash[h] = die;
	}

	return die;
}

static void
mkindex(DWDie *die)
{
	die->hash = mal(HASHSIZE * sizeof(DWDie*));
}

static DWDie*
walktypedef(DWDie *die)
{
	DWAttr *attr;

	// Resolve typedef if present.
	if (die->abbrev == DW_ABRV_TYPEDECL) {
		for (attr = die->attr; attr; attr = attr->link) {
			if (attr->atr == DW_AT_type && attr->cls == DW_CLS_REFERENCE && attr->data != nil) {
				return (DWDie*)attr->data;
			}
		}
	}
	return die;
}

// Find child by AT_name using hashtable if available or linear scan
// if not.
static DWDie*
find(DWDie *die, char* name)
{
	DWDie *a, *b, *die2;
	int h;

top:
	if (die->hash == nil) {
		for (a = die->child; a != nil; a = a->link)
			if (strcmp(name, getattr(a, DW_AT_name)->data) == 0)
				return a;
		goto notfound;
	}

	h = hashstr(name);
	a = die->hash[h];

	if (a == nil)
		goto notfound;


	if (strcmp(name, getattr(a, DW_AT_name)->data) == 0)
		return a;

	// Move found ones to head of the list.
	b = a->hlink;
	while (b != nil) {
		if (strcmp(name, getattr(b, DW_AT_name)->data) == 0) {
			a->hlink = b->hlink;
			b->hlink = die->hash[h];
			die->hash[h] = b;
			return b;
		}
		a = b;
		b = b->hlink;
	}

notfound:
	die2 = walktypedef(die);
	if(die2 != die) {
		die = die2;
		goto top;
	}

	return nil;
}

static DWDie*
find_or_diag(DWDie *die, char* name)
{
	DWDie *r;
	r = find(die, name);
	if (r == nil) {
		diag("dwarf find: %s %p has no %s", getattr(die, DW_AT_name)->data, die, name);
		errorexit();
	}
	return r;
}

static void
adddwarfrel(LSym* sec, LSym* sym, vlong offsetbase, int siz, vlong addend)
{
	Reloc *r;

	r = addrel(sec);
	r->sym = sym;
	r->xsym = sym;
	r->off = cpos() - offsetbase;
	r->siz = siz;
	r->type = R_ADDR;
	r->add = addend;
	r->xadd = addend;
	if(iself && thechar == '6')
		addend = 0;
	switch(siz) {
	case 4:
		LPUT(addend);
		break;
	case 8:
		VPUT(addend);
		break;
	default:
		diag("bad size in adddwarfrel");
		break;
	}
}

static DWAttr*
newrefattr(DWDie *die, uint16 attr, DWDie* ref)
{
	if (ref == nil)
		return nil;
	return newattr(die, attr, DW_CLS_REFERENCE, 0, (char*)ref);
}

static int fwdcount;

static void
putattr(int abbrev, int form, int cls, vlong value, char *data)
{
	vlong off;

	switch(form) {
	case DW_FORM_addr:	// address
		if(linkmode == LinkExternal) {
			value -= ((LSym*)data)->value;
			adddwarfrel(infosec, (LSym*)data, infoo, PtrSize, value);
			break;
		}
		addrput(value);
		break;

	case DW_FORM_block1:	// block
		if(cls == DW_CLS_ADDRESS) {
			cput(1+PtrSize);
			cput(DW_OP_addr);
			if(linkmode == LinkExternal) {
				value -= ((LSym*)data)->value;
				adddwarfrel(infosec, (LSym*)data, infoo, PtrSize, value);
				break;
			}
			addrput(value);
			break;
		}
		value &= 0xff;
		cput(value);
		while(value--)
			cput(*data++);
		break;

	case DW_FORM_block2:	// block
		value &= 0xffff;
		WPUT(value);
		while(value--)
			cput(*data++);
		break;

	case DW_FORM_block4:	// block
		value &= 0xffffffff;
		LPUT(value);
		while(value--)
			cput(*data++);
		break;

	case DW_FORM_block:	// block
		uleb128put(value);
		while(value--)
			cput(*data++);
		break;

	case DW_FORM_data1:	// constant
		cput(value);
		break;

	case DW_FORM_data2:	// constant
		WPUT(value);
		break;

	case DW_FORM_data4:	// constant, {line,loclist,mac,rangelist}ptr
		if(linkmode == LinkExternal && cls == DW_CLS_PTR) {
			adddwarfrel(infosec, linesym, infoo, 4, value);
			break;
		}
		LPUT(value);
		break;

	case DW_FORM_data8:	// constant, {line,loclist,mac,rangelist}ptr
		VPUT(value);
		break;

	case DW_FORM_sdata:	// constant
		sleb128put(value);
		break;

	case DW_FORM_udata:	// constant
		uleb128put(value);
		break;

	case DW_FORM_string:	// string
		strnput(data, value+1);
		break;

	case DW_FORM_flag:	// flag
		cput(value?1:0);
		break;

	case DW_FORM_ref_addr:	// reference to a DIE in the .info section
		// In DWARF 2 (which is what we claim to generate),
		// the ref_addr is the same size as a normal address.
		// In DWARF 3 it is always 32 bits, unless emitting a large
		// (> 4 GB of debug info aka "64-bit") unit, which we don't implement.
		if (data == nil) {
			diag("dwarf: null reference in %d", abbrev);
			if(PtrSize == 8)
				VPUT(0); // invalid dwarf, gdb will complain.
			else
				LPUT(0); // invalid dwarf, gdb will complain.
		} else {
			off = ((DWDie*)data)->offs;
			if (off == 0)
				fwdcount++;
			if(linkmode == LinkExternal) {
				adddwarfrel(infosec, infosym, infoo, PtrSize, off);
				break;
			}
			addrput(off);
		}
		break;

	case DW_FORM_ref1:	// reference within the compilation unit
	case DW_FORM_ref2:	// reference
	case DW_FORM_ref4:	// reference
	case DW_FORM_ref8:	// reference
	case DW_FORM_ref_udata:	// reference

	case DW_FORM_strp:	// string
	case DW_FORM_indirect:	// (see Section 7.5.3)
	default:
		diag("dwarf: unsupported attribute form %d / class %d", form, cls);
		errorexit();
	}
}

// Note that we can (and do) add arbitrary attributes to a DIE, but
// only the ones actually listed in the Abbrev will be written out.
static void
putattrs(int abbrev, DWAttr* attr)
{
	DWAttrForm* af;
	DWAttr *ap;

	for(af = abbrevs[abbrev].attr; af->attr; af++) {
		for(ap=attr; ap; ap=ap->link) {
			if(ap->atr == af->attr) {
				putattr(abbrev, af->form,
					ap->cls,
					ap->value,
					ap->data);
				goto done;
			}
		}
		putattr(abbrev, af->form, 0, 0, nil);
	done:;
	}
}

static void putdie(DWDie* die);

static void
putdies(DWDie* die)
{
	for(; die; die = die->link)
		putdie(die);
}

static void
putdie(DWDie* die)
{
	die->offs = cpos() - infoo;
	uleb128put(die->abbrev);
	putattrs(die->abbrev, die->attr);
	if (abbrevs[die->abbrev].children) {
		putdies(die->child);
		cput(0);
	}
}

static void
reverselist(DWDie** list)
{
	DWDie *curr, *prev;

	curr = *list;
	prev = nil;
	while(curr != nil) {
		DWDie* next = curr->link;
		curr->link = prev;
		prev = curr;
		curr = next;
	}
	*list = prev;
}

static void
reversetree(DWDie** list)
{
	 DWDie *die;

	 reverselist(list);
	 for (die = *list; die != nil; die = die->link)
		 if (abbrevs[die->abbrev].children)
			 reversetree(&die->child);
}

static void
newmemberoffsetattr(DWDie *die, int32 offs)
{
	char block[10];
	int i;

	i = 0;
	block[i++] = DW_OP_plus_uconst;
	i += uleb128enc(offs, block+i);
	newattr(die, DW_AT_data_member_location, DW_CLS_BLOCK, i, mal(i));
	memmove(die->attr->data, block, i);
}

// GDB doesn't like DW_FORM_addr for DW_AT_location, so emit a
// location expression that evals to a const.
static void
newabslocexprattr(DWDie *die, vlong addr, LSym *sym)
{
	newattr(die, DW_AT_location, DW_CLS_ADDRESS, addr, (char*)sym);
}

static DWDie* defptrto(DWDie *dwtype);	// below

// Lookup predefined types
static LSym*
lookup_or_diag(char *n)
{
	LSym *s;

	s = linkrlookup(ctxt, n, 0);
	if (s == nil || s->size == 0) {
		diag("dwarf: missing type: %s", n);
		errorexit();
	}
	return s;
}

static void
dotypedef(DWDie *parent, char *name, DWDie *def)
{
	DWDie *die;

	// Only emit typedefs for real names.
	if(strncmp(name, "map[", 4) == 0)
		return;
	if(strncmp(name, "struct {", 8) == 0)
		return;
	if(strncmp(name, "chan ", 5) == 0)
		return;
	if(*name == '[' || *name == '*')
		return;
	if(def == nil)
		diag("dwarf: bad def in dotypedef");

	// The typedef entry must be created after the def,
	// so that future lookups will find the typedef instead
	// of the real definition. This hooks the typedef into any
	// circular definition loops, so that gdb can understand them.
	die = newdie(parent, DW_ABRV_TYPEDECL, name);
	newrefattr(die, DW_AT_type, def);
}

// Define gotype, for composite ones recurse into constituents.
static DWDie*
defgotype(LSym *gotype)
{
	DWDie *die, *fld;
	LSym *s;
	char *name, *f;
	uint8 kind;
	vlong bytesize;
	int i, nfields;

	if (gotype == nil)
		return find_or_diag(&dwtypes, "<unspecified>");

	if (strncmp("type.", gotype->name, 5) != 0) {
		diag("dwarf: type name doesn't start with \".type\": %s", gotype->name);
		return find_or_diag(&dwtypes, "<unspecified>");
	}
	name = gotype->name + 5;  // could also decode from Type.string

	die = find(&dwtypes, name);
	if (die != nil)
		return die;

	if (0 && debug['v'] > 2)
		print("new type: %Y\n", gotype);

	kind = decodetype_kind(gotype);
	bytesize = decodetype_size(gotype);

	switch (kind) {
	case KindBool:
		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name);
		newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_boolean, 0);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindInt:
	case KindInt8:
	case KindInt16:
	case KindInt32:
	case KindInt64:
		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name);
		newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_signed, 0);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindUint:
	case KindUint8:
	case KindUint16:
	case KindUint32:
	case KindUint64:
	case KindUintptr:
		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name);
		newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_unsigned, 0);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindFloat32:
	case KindFloat64:
		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name);
		newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_float, 0);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindComplex64:
	case KindComplex128:
		die = newdie(&dwtypes, DW_ABRV_BASETYPE, name);
		newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_complex_float, 0);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindArray:
		die = newdie(&dwtypes, DW_ABRV_ARRAYTYPE, name);
		dotypedef(&dwtypes, name, die);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		s = decodetype_arrayelem(gotype);
		newrefattr(die, DW_AT_type, defgotype(s));
		fld = newdie(die, DW_ABRV_ARRAYRANGE, "range");
		// use actual length not upper bound; correct for 0-length arrays.
		newattr(fld, DW_AT_count, DW_CLS_CONSTANT, decodetype_arraylen(gotype), 0);
		newrefattr(fld, DW_AT_type, find_or_diag(&dwtypes, "uintptr"));
		break;

	case KindChan:
		die = newdie(&dwtypes, DW_ABRV_CHANTYPE, name);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		s = decodetype_chanelem(gotype);
		newrefattr(die, DW_AT_go_elem, defgotype(s));
		break;

	case KindFunc:
		die = newdie(&dwtypes, DW_ABRV_FUNCTYPE, name);
		dotypedef(&dwtypes, name, die);
		newrefattr(die, DW_AT_type, find_or_diag(&dwtypes, "void"));
		nfields = decodetype_funcincount(gotype);
		for (i = 0; i < nfields; i++) {
			s = decodetype_funcintype(gotype, i);
			fld = newdie(die, DW_ABRV_FUNCTYPEPARAM, s->name+5);
			newrefattr(fld, DW_AT_type, defgotype(s));
		}
		if (decodetype_funcdotdotdot(gotype))
			newdie(die, DW_ABRV_DOTDOTDOT, "...");
		nfields = decodetype_funcoutcount(gotype);
		for (i = 0; i < nfields; i++) {
			s = decodetype_funcouttype(gotype, i);
			fld = newdie(die, DW_ABRV_FUNCTYPEPARAM, s->name+5);
			newrefattr(fld, DW_AT_type, defptrto(defgotype(s)));
		}
		break;

	case KindInterface:
		die = newdie(&dwtypes, DW_ABRV_IFACETYPE, name);
		dotypedef(&dwtypes, name, die);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		nfields = decodetype_ifacemethodcount(gotype);
		if (nfields == 0)
			s = lookup_or_diag("type.runtime.eface");
		else
			s = lookup_or_diag("type.runtime.iface");
		newrefattr(die, DW_AT_type, defgotype(s));
		break;

	case KindMap:
		die = newdie(&dwtypes, DW_ABRV_MAPTYPE, name);
		s = decodetype_mapkey(gotype);
		newrefattr(die, DW_AT_go_key, defgotype(s));
		s = decodetype_mapvalue(gotype);
		newrefattr(die, DW_AT_go_elem, defgotype(s));
		break;

	case KindPtr:
		die = newdie(&dwtypes, DW_ABRV_PTRTYPE, name);
		dotypedef(&dwtypes, name, die);
		s = decodetype_ptrelem(gotype);
		newrefattr(die, DW_AT_type, defgotype(s));
		break;

	case KindSlice:
		die = newdie(&dwtypes, DW_ABRV_SLICETYPE, name);
		dotypedef(&dwtypes, name, die);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		s = decodetype_arrayelem(gotype);
		newrefattr(die, DW_AT_go_elem, defgotype(s));
		break;

	case KindString:
		die = newdie(&dwtypes, DW_ABRV_STRINGTYPE, name);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		break;

	case KindStruct:
		die = newdie(&dwtypes, DW_ABRV_STRUCTTYPE, name);
		dotypedef(&dwtypes, name, die);
		newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, bytesize, 0);
		nfields = decodetype_structfieldcount(gotype);
		for (i = 0; i < nfields; i++) {
			f = decodetype_structfieldname(gotype, i);
			s = decodetype_structfieldtype(gotype, i);
			if (f == nil)
				f = s->name + 5;	 // skip "type."
			fld = newdie(die, DW_ABRV_STRUCTFIELD, f);
			newrefattr(fld, DW_AT_type, defgotype(s));
			newmemberoffsetattr(fld, decodetype_structfieldoffs(gotype, i));
		}
		break;

	case KindUnsafePointer:
		die = newdie(&dwtypes, DW_ABRV_BARE_PTRTYPE, name);
		break;

	default:
		diag("dwarf: definition of unknown kind %d: %s", kind, gotype->name);
		die = newdie(&dwtypes, DW_ABRV_TYPEDECL, name);
		newrefattr(die, DW_AT_type, find_or_diag(&dwtypes, "<unspecified>"));
	}

	newattr(die, DW_AT_go_kind, DW_CLS_CONSTANT, kind, 0);

	return die;
}

// Find or construct *T given T.
static DWDie*
defptrto(DWDie *dwtype)
{
	char ptrname[1024];
	DWDie *die;

	snprint(ptrname, sizeof ptrname, "*%s", getattr(dwtype, DW_AT_name)->data);
	die = find(&dwtypes, ptrname);
	if (die == nil) {
		die = newdie(&dwtypes, DW_ABRV_PTRTYPE,
			     strcpy(mal(strlen(ptrname)+1), ptrname));
		newrefattr(die, DW_AT_type, dwtype);
	}
	return die;
}

// Copies src's children into dst. Copies attributes by value.
// DWAttr.data is copied as pointer only.  If except is one of
// the top-level children, it will not be copied.
static void
copychildrenexcept(DWDie *dst, DWDie *src, DWDie *except)
{
	DWDie *c;
	DWAttr *a;

	for (src = src->child; src != nil; src = src->link) {
		if(src == except)
			continue;
		c = newdie(dst, src->abbrev, getattr(src, DW_AT_name)->data);
		for (a = src->attr; a != nil; a = a->link)
			newattr(c, a->atr, a->cls, a->value, a->data);
		copychildrenexcept(c, src, nil);
	}
	reverselist(&dst->child);
}
static void
copychildren(DWDie *dst, DWDie *src)
{
	copychildrenexcept(dst, src, nil);
}

// Search children (assumed to have DW_TAG_member) for the one named
// field and set its DW_AT_type to dwtype
static void
substitutetype(DWDie *structdie, char *field, DWDie* dwtype)
{
	DWDie *child;
	DWAttr *a;

	child = find_or_diag(structdie, field);
	if (child == nil)
		return;

	a = getattr(child, DW_AT_type);
	if (a != nil)
		a->data = (char*) dwtype;
	else
		newrefattr(child, DW_AT_type, dwtype);
}

static void
synthesizestringtypes(DWDie* die)
{
	DWDie *prototype;

	prototype = walktypedef(defgotype(lookup_or_diag("type.runtime._string")));
	if (prototype == nil)
		return;

	for (; die != nil; die = die->link) {
		if (die->abbrev != DW_ABRV_STRINGTYPE)
			continue;
		copychildren(die, prototype);
	}
}

static void
synthesizeslicetypes(DWDie *die)
{
	DWDie *prototype, *elem;

	prototype = walktypedef(defgotype(lookup_or_diag("type.runtime.slice")));
	if (prototype == nil)
		return;

	for (; die != nil; die = die->link) {
		if (die->abbrev != DW_ABRV_SLICETYPE)
			continue;
		copychildren(die, prototype);
		elem = (DWDie*) getattr(die, DW_AT_go_elem)->data;
		substitutetype(die, "array", defptrto(elem));
	}
}

static char*
mkinternaltypename(char *base, char *arg1, char *arg2)
{
	char buf[1024];
	char *n;

	if (arg2 == nil)
		snprint(buf, sizeof buf, "%s<%s>", base, arg1);
	else
		snprint(buf, sizeof buf, "%s<%s,%s>", base, arg1, arg2);
	n = mal(strlen(buf) + 1);
	memmove(n, buf, strlen(buf));
	return n;
}

// synthesizemaptypes is way too closely married to runtime/hashmap.c
enum {
	MaxKeySize = 128,
	MaxValSize = 128,
	BucketSize = 8,
};

static void
synthesizemaptypes(DWDie *die)
{

	DWDie *hash, *bucket, *dwh, *dwhk, *dwhv, *dwhb, *keytype, *valtype, *fld;
	int indirect_key, indirect_val;
	int keysize, valsize;
	DWAttr *a;

	hash		= walktypedef(defgotype(lookup_or_diag("type.runtime.hmap")));
	bucket		= walktypedef(defgotype(lookup_or_diag("type.runtime.bmap")));

	if (hash == nil)
		return;

	for (; die != nil; die = die->link) {
		if (die->abbrev != DW_ABRV_MAPTYPE)
			continue;

		keytype = walktypedef((DWDie*) getattr(die, DW_AT_go_key)->data);
		valtype = walktypedef((DWDie*) getattr(die, DW_AT_go_elem)->data);

		// compute size info like hashmap.c does.
		a = getattr(keytype, DW_AT_byte_size);
		keysize = a ? a->value : PtrSize;  // We don't store size with Pointers
		a = getattr(valtype, DW_AT_byte_size);
		valsize = a ? a->value : PtrSize;
		indirect_key = 0;
		indirect_val = 0;
		if(keysize > MaxKeySize) {
			keysize = PtrSize;
			indirect_key = 1;
		}
		if(valsize > MaxValSize) {
			valsize = PtrSize;
			indirect_val = 1;
		}

		// Construct type to represent an array of BucketSize keys
		dwhk = newdie(&dwtypes, DW_ABRV_ARRAYTYPE,
			      mkinternaltypename("[]key",
						 getattr(keytype, DW_AT_name)->data, nil));
		newattr(dwhk, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize * keysize, 0);
		newrefattr(dwhk, DW_AT_type, indirect_key ? defptrto(keytype) : keytype);
		fld = newdie(dwhk, DW_ABRV_ARRAYRANGE, "size");
		newattr(fld, DW_AT_count, DW_CLS_CONSTANT, BucketSize, 0);
		newrefattr(fld, DW_AT_type, find_or_diag(&dwtypes, "uintptr"));
		
		// Construct type to represent an array of BucketSize values
		dwhv = newdie(&dwtypes, DW_ABRV_ARRAYTYPE, 
			      mkinternaltypename("[]val",
						 getattr(valtype, DW_AT_name)->data, nil));
		newattr(dwhv, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize * valsize, 0);
		newrefattr(dwhv, DW_AT_type, indirect_val ? defptrto(valtype) : valtype);
		fld = newdie(dwhv, DW_ABRV_ARRAYRANGE, "size");
		newattr(fld, DW_AT_count, DW_CLS_CONSTANT, BucketSize, 0);
		newrefattr(fld, DW_AT_type, find_or_diag(&dwtypes, "uintptr"));

		// Construct bucket<K,V>
		dwhb = newdie(&dwtypes, DW_ABRV_STRUCTTYPE,
			      mkinternaltypename("bucket",
						 getattr(keytype, DW_AT_name)->data,
						 getattr(valtype, DW_AT_name)->data));
		// Copy over all fields except the field "data" from the generic bucket.
		// "data" will be replaced with keys/values below.
		copychildrenexcept(dwhb, bucket, find(bucket, "data"));
		
		fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "keys");
		newrefattr(fld, DW_AT_type, dwhk);
		newmemberoffsetattr(fld, BucketSize);
		fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "values");
		newrefattr(fld, DW_AT_type, dwhv);
		newmemberoffsetattr(fld, BucketSize + BucketSize * keysize);
		fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "overflow");
		newrefattr(fld, DW_AT_type, defptrto(dwhb));
		newmemberoffsetattr(fld, BucketSize + BucketSize * (keysize + valsize));
		if(RegSize > PtrSize) {
			fld = newdie(dwhb, DW_ABRV_STRUCTFIELD, "pad");
			newrefattr(fld, DW_AT_type, find_or_diag(&dwtypes, "uintptr"));
			newmemberoffsetattr(fld, BucketSize + BucketSize * (keysize + valsize) + PtrSize);
		}
		newattr(dwhb, DW_AT_byte_size, DW_CLS_CONSTANT, BucketSize + BucketSize * keysize + BucketSize * valsize + RegSize, 0);

		// Construct hash<K,V>
		dwh = newdie(&dwtypes, DW_ABRV_STRUCTTYPE,
			mkinternaltypename("hash",
				getattr(keytype, DW_AT_name)->data,
				getattr(valtype, DW_AT_name)->data));
		copychildren(dwh, hash);
		substitutetype(dwh, "buckets", defptrto(dwhb));
		substitutetype(dwh, "oldbuckets", defptrto(dwhb));
		newattr(dwh, DW_AT_byte_size, DW_CLS_CONSTANT,
			getattr(hash, DW_AT_byte_size)->value, nil);

		// make map type a pointer to hash<K,V>
		newrefattr(die, DW_AT_type, defptrto(dwh));
	}
}

static void
synthesizechantypes(DWDie *die)
{
	DWDie *sudog, *waitq, *hchan,
		*dws, *dww, *dwh, *elemtype;
	DWAttr *a;
	int elemsize, sudogsize;

	sudog = walktypedef(defgotype(lookup_or_diag("type.runtime.sudog")));
	waitq = walktypedef(defgotype(lookup_or_diag("type.runtime.waitq")));
	hchan = walktypedef(defgotype(lookup_or_diag("type.runtime.hchan")));
	if (sudog == nil || waitq == nil || hchan == nil)
		return;

	sudogsize = getattr(sudog, DW_AT_byte_size)->value;

	for (; die != nil; die = die->link) {
		if (die->abbrev != DW_ABRV_CHANTYPE)
			continue;
		elemtype = (DWDie*) getattr(die, DW_AT_go_elem)->data;
		a = getattr(elemtype, DW_AT_byte_size);
		elemsize = a ? a->value : PtrSize;

		// sudog<T>
		dws = newdie(&dwtypes, DW_ABRV_STRUCTTYPE,
			mkinternaltypename("sudog",
				getattr(elemtype, DW_AT_name)->data, nil));
		copychildren(dws, sudog);
		substitutetype(dws, "elem", elemtype);
		newattr(dws, DW_AT_byte_size, DW_CLS_CONSTANT,
			sudogsize + (elemsize > 8 ? elemsize - 8 : 0), nil);

		// waitq<T>
		dww = newdie(&dwtypes, DW_ABRV_STRUCTTYPE,
			mkinternaltypename("waitq", getattr(elemtype, DW_AT_name)->data, nil));
		copychildren(dww, waitq);
		substitutetype(dww, "first", defptrto(dws));
		substitutetype(dww, "last",  defptrto(dws));
		newattr(dww, DW_AT_byte_size, DW_CLS_CONSTANT,
			getattr(waitq, DW_AT_byte_size)->value, nil);

		// hchan<T>
		dwh = newdie(&dwtypes, DW_ABRV_STRUCTTYPE,
			mkinternaltypename("hchan", getattr(elemtype, DW_AT_name)->data, nil));
		copychildren(dwh, hchan);
		substitutetype(dwh, "recvq", dww);
		substitutetype(dwh, "sendq", dww);
		newattr(dwh, DW_AT_byte_size, DW_CLS_CONSTANT,
			getattr(hchan, DW_AT_byte_size)->value, nil);

		newrefattr(die, DW_AT_type, defptrto(dwh));
	}
}

// For use with pass.c::genasmsym
static void
defdwsymb(LSym* sym, char *s, int t, vlong v, vlong size, int ver, LSym *gotype)
{
	DWDie *dv, *dt;

	USED(size);
	if (strncmp(s, "go.string.", 10) == 0)
		return;

	if (strncmp(s, "type.", 5) == 0 && strcmp(s, "type.*") != 0 && strncmp(s, "type..", 6) != 0) {
		defgotype(sym);
		return;
	}

	dv = nil;

	switch (t) {
	default:
		return;
	case 'd':
	case 'b':
	case 'D':
	case 'B':
		dv = newdie(&dwglobals, DW_ABRV_VARIABLE, s);
		newabslocexprattr(dv, v, sym);
		if (ver == 0)
			newattr(dv, DW_AT_external, DW_CLS_FLAG, 1, 0);
		// fallthrough
	case 'a':
	case 'p':
		dt = defgotype(gotype);
	}

	if (dv != nil)
		newrefattr(dv, DW_AT_type, dt);
}

static void
movetomodule(DWDie *parent)
{
	DWDie *die;

	die = dwroot.child->child;
	while(die->link != nil)
		die = die->link;
	die->link = parent->child;
}

// If the pcln table contains runtime/string.goc, use that to set gdbscript path.
static void
finddebugruntimepath(LSym *s)
{
	int i;
	char *p;
	LSym *f;
	
	if(gdbscript[0] != '\0')
		return;

	for(i=0; i<s->pcln->nfile; i++) {
		f = s->pcln->file[i];
		if((p = strstr(f->name, "runtime/string.goc")) != nil) {
			*p = '\0';
			snprint(gdbscript, sizeof gdbscript, "%sruntime/runtime-gdb.py", f->name);
			*p = 'r';
			break;
		}
	}
}

/*
 * Generate short opcodes when possible, long ones when necessary.
 * See section 6.2.5
 */

enum {
	LINE_BASE = -1,
	LINE_RANGE = 4,
	OPCODE_BASE = 10
};

static void
putpclcdelta(vlong delta_pc, vlong delta_lc)
{
	if (LINE_BASE <= delta_lc && delta_lc < LINE_BASE+LINE_RANGE) {
		vlong opcode = OPCODE_BASE + (delta_lc - LINE_BASE) + (LINE_RANGE * delta_pc);
		if (OPCODE_BASE <= opcode && opcode < 256) {
			cput(opcode);
			return;
		}
	}

	if (delta_pc) {
		cput(DW_LNS_advance_pc);
		sleb128put(delta_pc);
	}

	cput(DW_LNS_advance_line);
	sleb128put(delta_lc);
	cput(DW_LNS_copy);
}

static void
newcfaoffsetattr(DWDie *die, int32 offs)
{
	char block[10];
	int i;

	i = 0;

	block[i++] = DW_OP_call_frame_cfa;
	if (offs != 0) {
		block[i++] = DW_OP_consts;
		i += sleb128enc(offs, block+i);
		block[i++] = DW_OP_plus;
	}
	newattr(die, DW_AT_location, DW_CLS_BLOCK, i, mal(i));
	memmove(die->attr->data, block, i);
}

static char*
mkvarname(char* name, int da)
{
	char buf[1024];
	char *n;

	snprint(buf, sizeof buf, "%s#%d", name, da);
	n = mal(strlen(buf) + 1);
	memmove(n, buf, strlen(buf));
	return n;
}

/*
 * Walk prog table, emit line program and build DIE tree.
 */

// flush previous compilation unit.
static void
flushunit(DWDie *dwinfo, vlong pc, LSym *pcsym, vlong unitstart, int32 header_length)
{
	vlong here;

	if (dwinfo != nil && pc != 0) {
		newattr(dwinfo, DW_AT_high_pc, DW_CLS_ADDRESS, pc+1, (char*)pcsym);
	}

	if (unitstart >= 0) {
		cput(0);  // start extended opcode
		uleb128put(1);
		cput(DW_LNE_end_sequence);

		here = cpos();
		cseek(unitstart);
		LPUT(here - unitstart - sizeof(int32));	 // unit_length
		WPUT(2);  // dwarf version
		LPUT(header_length); // header length starting here
		cseek(here);
	}
}

static void
writelines(void)
{
	LSym *s, *epcs;
	Auto *a;
	vlong unitstart, headerend, offs;
	vlong pc, epc;
	int i, lang, da, dt, line, file;
	DWDie *dwinfo, *dwfunc, *dwvar, **dws;
	DWDie *varhash[HASHSIZE];
	char *n, *nn;
	Pciter pcfile, pcline;
	LSym **files, *f;

	if(linesec == S)
		linesec = linklookup(ctxt, ".dwarfline", 0);
	linesec->nr = 0;

	unitstart = -1;
	headerend = -1;
	epc = 0;
	epcs = S;
	lineo = cpos();
	dwinfo = nil;
	
	flushunit(dwinfo, epc, epcs, unitstart, headerend - unitstart - 10);
	unitstart = cpos();
	
	lang = DW_LANG_Go;
	
	s = ctxt->textp;

	dwinfo = newdie(&dwroot, DW_ABRV_COMPUNIT, estrdup("go"));
	newattr(dwinfo, DW_AT_language, DW_CLS_CONSTANT,lang, 0);
	newattr(dwinfo, DW_AT_stmt_list, DW_CLS_PTR, unitstart - lineo, 0);
	newattr(dwinfo, DW_AT_low_pc, DW_CLS_ADDRESS, s->value, (char*)s);

	// Write .debug_line Line Number Program Header (sec 6.2.4)
	// Fields marked with (*) must be changed for 64-bit dwarf
	LPUT(0);   // unit_length (*), will be filled in by flushunit.
	WPUT(2);   // dwarf version (appendix F)
	LPUT(0);   // header_length (*), filled in by flushunit.
	// cpos == unitstart + 4 + 2 + 4
	cput(1);   // minimum_instruction_length
	cput(1);   // default_is_stmt
	cput(LINE_BASE);     // line_base
	cput(LINE_RANGE);    // line_range
	cput(OPCODE_BASE);   // opcode_base
	cput(0);   // standard_opcode_lengths[1]
	cput(1);   // standard_opcode_lengths[2]
	cput(1);   // standard_opcode_lengths[3]
	cput(1);   // standard_opcode_lengths[4]
	cput(1);   // standard_opcode_lengths[5]
	cput(0);   // standard_opcode_lengths[6]
	cput(0);   // standard_opcode_lengths[7]
	cput(0);   // standard_opcode_lengths[8]
	cput(1);   // standard_opcode_lengths[9]
	cput(0);   // include_directories  (empty)

	files = emallocz(ctxt->nhistfile*sizeof files[0]);
	for(f = ctxt->filesyms; f != nil; f = f->next)
		files[f->value-1] = f;

	for(i=0; i<ctxt->nhistfile; i++) {
		strnput(files[i]->name, strlen(files[i]->name) + 4);
		// 4 zeros: the string termination + 3 fields.
	}

	cput(0);   // terminate file_names.
	headerend = cpos();

	cput(0);  // start extended opcode
	uleb128put(1 + PtrSize);
	cput(DW_LNE_set_address);

	pc = s->value;
	line = 1;
	file = 1;
	if(linkmode == LinkExternal)
		adddwarfrel(linesec, s, lineo, PtrSize, 0);
	else
		addrput(pc);

	for(ctxt->cursym = ctxt->textp; ctxt->cursym != nil; ctxt->cursym = ctxt->cursym->next) {
		s = ctxt->cursym;

		dwfunc = newdie(dwinfo, DW_ABRV_FUNCTION, s->name);
		newattr(dwfunc, DW_AT_low_pc, DW_CLS_ADDRESS, s->value, (char*)s);
		epc = s->value + s->size;
		epcs = s;
		newattr(dwfunc, DW_AT_high_pc, DW_CLS_ADDRESS, epc, (char*)s);
		if (s->version == 0)
			newattr(dwfunc, DW_AT_external, DW_CLS_FLAG, 1, 0);

		if(s->pcln == nil)
			continue;

		finddebugruntimepath(s);

		pciterinit(ctxt, &pcfile, &s->pcln->pcfile);
		pciterinit(ctxt, &pcline, &s->pcln->pcline);
		epc = pc;
		while(!pcfile.done && !pcline.done) {
			if(epc - s->value >= pcfile.nextpc) {
				pciternext(&pcfile);
				continue;
			}
			if(epc - s->value >= pcline.nextpc) {
				pciternext(&pcline);
				continue;
			}

			if(file != pcfile.value) {
				cput(DW_LNS_set_file);
				uleb128put(pcfile.value);
				file = pcfile.value;
			}
			putpclcdelta(s->value + pcline.pc - pc, pcline.value - line);

			pc = s->value + pcline.pc;
			line = pcline.value;
			if(pcfile.nextpc < pcline.nextpc)
				epc = pcfile.nextpc;
			else
				epc = pcline.nextpc;
			epc += s->value;
		}

		da = 0;
		dwfunc->hash = varhash;	 // enable indexing of children by name
		memset(varhash, 0, sizeof varhash);
		for(a = s->autom; a; a = a->link) {
			switch (a->type) {
			case A_AUTO:
				dt = DW_ABRV_AUTO;
				offs = a->aoffset - PtrSize;
				break;
			case A_PARAM:
				dt = DW_ABRV_PARAM;
				offs = a->aoffset;
				break;
			default:
				continue;
			}
			if (strstr(a->asym->name, ".autotmp_"))
				continue;
			if (find(dwfunc, a->asym->name) != nil)
				n = mkvarname(a->asym->name, da);
			else
				n = a->asym->name;
			// Drop the package prefix from locals and arguments.
			nn = strrchr(n, '.');
			if (nn)
				n = nn + 1;

			dwvar = newdie(dwfunc, dt, n);
			newcfaoffsetattr(dwvar, offs);
			newrefattr(dwvar, DW_AT_type, defgotype(a->gotype));

			// push dwvar down dwfunc->child to preserve order
			newattr(dwvar, DW_AT_internal_location, DW_CLS_CONSTANT, offs, nil);
			dwfunc->child = dwvar->link;  // take dwvar out from the top of the list
			for (dws = &dwfunc->child; *dws != nil; dws = &(*dws)->link)
				if (offs > getattr(*dws, DW_AT_internal_location)->value)
					break;
			dwvar->link = *dws;
			*dws = dwvar;

			da++;
		}

		dwfunc->hash = nil;
	}

	flushunit(dwinfo, epc, epcs, unitstart, headerend - unitstart - 10);
	linesize = cpos() - lineo;
}

/*
 *  Emit .debug_frame
 */
enum
{
	CIERESERVE = 16,
	DATAALIGNMENTFACTOR = -4,	// TODO -PtrSize?
	FAKERETURNCOLUMN = 16		// TODO gdb6 doesn't like > 15?
};

static void
putpccfadelta(vlong deltapc, vlong cfa)
{
	cput(DW_CFA_def_cfa_offset_sf);
	sleb128put(cfa / DATAALIGNMENTFACTOR);

	if (deltapc < 0x40) {
		cput(DW_CFA_advance_loc + deltapc);
	} else if (deltapc < 0x100) {
		cput(DW_CFA_advance_loc1);
		cput(deltapc);
	} else if (deltapc < 0x10000) {
		cput(DW_CFA_advance_loc2);
		WPUT(deltapc);
	} else {
		cput(DW_CFA_advance_loc4);
		LPUT(deltapc);
	}
}

static void
writeframes(void)
{
	LSym *s;
	vlong fdeo, fdesize, pad;
	Pciter pcsp;
	uint32 nextpc;

	if(framesec == S)
		framesec = linklookup(ctxt, ".dwarfframe", 0);
	framesec->nr = 0;
	frameo = cpos();

	// Emit the CIE, Section 6.4.1
	LPUT(CIERESERVE);	// initial length, must be multiple of PtrSize
	LPUT(0xffffffff);	// cid.
	cput(3);		// dwarf version (appendix F)
	cput(0);		// augmentation ""
	uleb128put(1);		// code_alignment_factor
	sleb128put(DATAALIGNMENTFACTOR); // guess
	uleb128put(FAKERETURNCOLUMN);	// return_address_register

	cput(DW_CFA_def_cfa);
	uleb128put(DWARFREGSP);	// register SP (**ABI-dependent, defined in l.h)
	uleb128put(PtrSize);	// offset

	cput(DW_CFA_offset + FAKERETURNCOLUMN);	 // return address
	uleb128put(-PtrSize / DATAALIGNMENTFACTOR);  // at cfa - x*4

	// 4 is to exclude the length field.
	pad = CIERESERVE + frameo + 4 - cpos();
	if (pad < 0) {
		diag("dwarf: CIERESERVE too small by %lld bytes.", -pad);
		errorexit();
	}
	strnput("", pad);

	for(ctxt->cursym = ctxt->textp; ctxt->cursym != nil; ctxt->cursym = ctxt->cursym->next) {
		s = ctxt->cursym;
		if(s->pcln == nil)
			continue;

		fdeo = cpos();
		// Emit a FDE, Section 6.4.1, starting wit a placeholder.
		LPUT(0);	// length, must be multiple of PtrSize
		LPUT(0);	// Pointer to the CIE above, at offset 0
		addrput(0);	// initial location
		addrput(0);	// address range

		for(pciterinit(ctxt, &pcsp, &s->pcln->pcsp); !pcsp.done; pciternext(&pcsp)) {
			nextpc = pcsp.nextpc;
			// pciterinit goes up to the end of the function,
			// but DWARF expects us to stop just before the end.
			if(nextpc == s->size) {
				nextpc--;
				if(nextpc < pcsp.pc)
					continue;
			}
			putpccfadelta(nextpc - pcsp.pc, PtrSize + pcsp.value);
		}

		fdesize = cpos() - fdeo - 4;	// exclude the length field.
		pad = rnd(fdesize, PtrSize) - fdesize;
		strnput("", pad);
		fdesize += pad;

		// Emit the FDE header for real, Section 6.4.1.
		cseek(fdeo);
		LPUT(fdesize);
		if(linkmode == LinkExternal) {
			adddwarfrel(framesec, framesym, frameo, 4, 0);
			adddwarfrel(framesec, s, frameo, PtrSize, 0);
		}
		else {
			LPUT(0);
			addrput(s->value);
		}
		addrput(s->size);
		cseek(fdeo + 4 + fdesize);
	}

	cflush();
	framesize = cpos() - frameo;
}

/*
 *  Walk DWarfDebugInfoEntries, and emit .debug_info
 */
enum
{
	COMPUNITHEADERSIZE = 4+2+4+1
};

static void
writeinfo(void)
{
	DWDie *compunit;
	vlong unitstart, here;

	fwdcount = 0;
	if (infosec == S)
		infosec = linklookup(ctxt, ".dwarfinfo", 0);
	infosec->nr = 0;

	if(arangessec == S)
		arangessec = linklookup(ctxt, ".dwarfaranges", 0);
	arangessec->nr = 0;

	for (compunit = dwroot.child; compunit; compunit = compunit->link) {
		unitstart = cpos();

		// Write .debug_info Compilation Unit Header (sec 7.5.1)
		// Fields marked with (*) must be changed for 64-bit dwarf
		// This must match COMPUNITHEADERSIZE above.
		LPUT(0);	// unit_length (*), will be filled in later.
		WPUT(2);	// dwarf version (appendix F)

		// debug_abbrev_offset (*)
		if(linkmode == LinkExternal)
			adddwarfrel(infosec, abbrevsym, infoo, 4, 0);
		else
			LPUT(0);

		cput(PtrSize);	// address_size

		putdie(compunit);

		here = cpos();
		cseek(unitstart);
		LPUT(here - unitstart - 4);	// exclude the length field.
		cseek(here);
	}
	cflush();
}

/*
 *  Emit .debug_pubnames/_types.  _info must have been written before,
 *  because we need die->offs and infoo/infosize;
 */
static int
ispubname(DWDie *die)
{
	DWAttr *a;

	switch(die->abbrev) {
	case DW_ABRV_FUNCTION:
	case DW_ABRV_VARIABLE:
		a = getattr(die, DW_AT_external);
		return a && a->value;
	}
	return 0;
}

static int
ispubtype(DWDie *die)
{
	return die->abbrev >= DW_ABRV_NULLTYPE;
}

static vlong
writepub(int (*ispub)(DWDie*))
{
	DWDie *compunit, *die;
	DWAttr *dwa;
	vlong unitstart, unitend, sectionstart, here;

	sectionstart = cpos();

	for (compunit = dwroot.child; compunit != nil; compunit = compunit->link) {
		unitstart = compunit->offs - COMPUNITHEADERSIZE;
		if (compunit->link != nil)
			unitend = compunit->link->offs - COMPUNITHEADERSIZE;
		else
			unitend = infoo + infosize;

		// Write .debug_pubnames/types	Header (sec 6.1.1)
		LPUT(0);			// unit_length (*), will be filled in later.
		WPUT(2);			// dwarf version (appendix F)
		LPUT(unitstart);		// debug_info_offset (of the Comp unit Header)
		LPUT(unitend - unitstart);	// debug_info_length

		for (die = compunit->child; die != nil; die = die->link) {
			if (!ispub(die)) continue;
			LPUT(die->offs - unitstart);
			dwa = getattr(die, DW_AT_name);
			strnput(dwa->data, dwa->value + 1);
		}
		LPUT(0);

		here = cpos();
		cseek(sectionstart);
		LPUT(here - sectionstart - 4);	// exclude the length field.
		cseek(here);

	}

	return sectionstart;
}

/*
 *  emit .debug_aranges.  _info must have been written before,
 *  because we need die->offs of dw_globals.
 */
static vlong
writearanges(void)
{
	DWDie *compunit;
	DWAttr *b, *e;
	int headersize;
	vlong sectionstart;
	vlong value;

	sectionstart = cpos();
	headersize = rnd(4+2+4+1+1, PtrSize);  // don't count unit_length field itself

	for (compunit = dwroot.child; compunit != nil; compunit = compunit->link) {
		b = getattr(compunit,  DW_AT_low_pc);
		if (b == nil)
			continue;
		e = getattr(compunit,  DW_AT_high_pc);
		if (e == nil)
			continue;

		// Write .debug_aranges	 Header + entry	 (sec 6.1.2)
		LPUT(headersize + 4*PtrSize - 4);	// unit_length (*)
		WPUT(2);	// dwarf version (appendix F)

		value = compunit->offs - COMPUNITHEADERSIZE;	// debug_info_offset
		if(linkmode == LinkExternal)
			adddwarfrel(arangessec, infosym, sectionstart, 4, value);
		else
			LPUT(value);

		cput(PtrSize);	// address_size
		cput(0);	// segment_size
		strnput("", headersize - (4+2+4+1+1));	// align to PtrSize

		if(linkmode == LinkExternal)
			adddwarfrel(arangessec, (LSym*)b->data, sectionstart, PtrSize, b->value-((LSym*)b->data)->value);
		else
			addrput(b->value);

		addrput(e->value - b->value);
		addrput(0);
		addrput(0);
	}
	cflush();
	return sectionstart;
}

static vlong
writegdbscript(void)
{
	vlong sectionstart;

	sectionstart = cpos();

	if (gdbscript[0]) {
		cput(1);  // magic 1 byte?
		strnput(gdbscript, strlen(gdbscript)+1);
		cflush();
	}
	return sectionstart;
}

static void
align(vlong size)
{
	if(HEADTYPE == Hwindows) // Only Windows PE need section align.
		strnput("", rnd(size, PEFILEALIGN) - size);
}

static vlong
writedwarfreloc(LSym* s)
{
	int i;
	vlong start;
	Reloc *r;
	
	start = cpos();
	for(r = s->r; r < s->r+s->nr; r++) {
		if(iself)
			i = elfreloc1(r, r->off);
		else if(HEADTYPE == Hdarwin)
			i = machoreloc1(r, r->off);
		else
			i = -1;
		if(i < 0)
			diag("unsupported obj reloc %d/%d to %s", r->type, r->siz, r->sym->name);
	}
	return start;
}

/*
 * This is the main entry point for generating dwarf.  After emitting
 * the mandatory debug_abbrev section, it calls writelines() to set up
 * the per-compilation unit part of the DIE tree, while simultaneously
 * emitting the debug_line section.  When the final tree contains
 * forward references, it will write the debug_info section in 2
 * passes.
 *
 */
void
dwarfemitdebugsections(void)
{
	vlong infoe;
	DWDie* die;

	if(debug['w'])  // disable dwarf
		return;

	if(linkmode == LinkExternal && !iself)
		return;

	// For diagnostic messages.
	newattr(&dwtypes, DW_AT_name, DW_CLS_STRING, strlen("dwtypes"), "dwtypes");

	mkindex(&dwroot);
	mkindex(&dwtypes);
	mkindex(&dwglobals);

	// Some types that must exist to define other ones.
	newdie(&dwtypes, DW_ABRV_NULLTYPE, "<unspecified>");
	newdie(&dwtypes, DW_ABRV_NULLTYPE, "void");
	newdie(&dwtypes, DW_ABRV_BARE_PTRTYPE, "unsafe.Pointer");

	die = newdie(&dwtypes, DW_ABRV_BASETYPE, "uintptr");  // needed for array size
	newattr(die, DW_AT_encoding,  DW_CLS_CONSTANT, DW_ATE_unsigned, 0);
	newattr(die, DW_AT_byte_size, DW_CLS_CONSTANT, PtrSize, 0);
	newattr(die, DW_AT_go_kind, DW_CLS_CONSTANT, KindUintptr, 0);

	// Needed by the prettyprinter code for interface inspection.
	defgotype(lookup_or_diag("type.runtime._type"));
	defgotype(lookup_or_diag("type.runtime.interfacetype"));
	defgotype(lookup_or_diag("type.runtime.itab"));

	genasmsym(defdwsymb);

	writeabbrev();
	align(abbrevsize);
	writelines();
	align(linesize);
	writeframes();
	align(framesize);

	synthesizestringtypes(dwtypes.child);
	synthesizeslicetypes(dwtypes.child);
	synthesizemaptypes(dwtypes.child);
	synthesizechantypes(dwtypes.child);

	reversetree(&dwroot.child);
	reversetree(&dwtypes.child);
	reversetree(&dwglobals.child);

	movetomodule(&dwtypes);
	movetomodule(&dwglobals);

	infoo = cpos();
	writeinfo();
	infoe = cpos();
	pubnameso = infoe;
	pubtypeso = infoe;
	arangeso = infoe;
	gdbscripto = infoe;

	if (fwdcount > 0) {
		if (debug['v'])
			Bprint(&bso, "%5.2f dwarf pass 2.\n", cputime());
		cseek(infoo);
		writeinfo();
		if (fwdcount > 0) {
			diag("dwarf: unresolved references after first dwarf info pass");
			errorexit();
		}
		if (infoe != cpos()) {
			diag("dwarf: inconsistent second dwarf info pass");
			errorexit();
		}
	}
	infosize = infoe - infoo;
	align(infosize);

	pubnameso  = writepub(ispubname);
	pubnamessize  = cpos() - pubnameso;
	align(pubnamessize);

	pubtypeso  = writepub(ispubtype);
	pubtypessize  = cpos() - pubtypeso;
	align(pubtypessize);

	arangeso   = writearanges();
	arangessize   = cpos() - arangeso;
	align(arangessize);

	gdbscripto = writegdbscript();
	gdbscriptsize = cpos() - gdbscripto;
	align(gdbscriptsize);

	while(cpos()&7)
		cput(0);
	inforeloco = writedwarfreloc(infosec);
	inforelocsize = cpos() - inforeloco;
	align(inforelocsize);

	arangesreloco = writedwarfreloc(arangessec);
	arangesrelocsize = cpos() - arangesreloco;
	align(arangesrelocsize);

	linereloco = writedwarfreloc(linesec);
	linerelocsize = cpos() - linereloco;
	align(linerelocsize);

	framereloco = writedwarfreloc(framesec);
	framerelocsize = cpos() - framereloco;
	align(framerelocsize);
}

/*
 *  Elf.
 */
enum
{
	ElfStrDebugAbbrev,
	ElfStrDebugAranges,
	ElfStrDebugFrame,
	ElfStrDebugInfo,
	ElfStrDebugLine,
	ElfStrDebugLoc,
	ElfStrDebugMacinfo,
	ElfStrDebugPubNames,
	ElfStrDebugPubTypes,
	ElfStrDebugRanges,
	ElfStrDebugStr,
	ElfStrGDBScripts,
	ElfStrRelDebugInfo,
	ElfStrRelDebugAranges,
	ElfStrRelDebugLine,
	ElfStrRelDebugFrame,
	NElfStrDbg
};

vlong elfstrdbg[NElfStrDbg];

void
dwarfaddshstrings(LSym *shstrtab)
{
	if(debug['w'])  // disable dwarf
		return;

	elfstrdbg[ElfStrDebugAbbrev]   = addstring(shstrtab, ".debug_abbrev");
	elfstrdbg[ElfStrDebugAranges]  = addstring(shstrtab, ".debug_aranges");
	elfstrdbg[ElfStrDebugFrame]    = addstring(shstrtab, ".debug_frame");
	elfstrdbg[ElfStrDebugInfo]     = addstring(shstrtab, ".debug_info");
	elfstrdbg[ElfStrDebugLine]     = addstring(shstrtab, ".debug_line");
	elfstrdbg[ElfStrDebugLoc]      = addstring(shstrtab, ".debug_loc");
	elfstrdbg[ElfStrDebugMacinfo]  = addstring(shstrtab, ".debug_macinfo");
	elfstrdbg[ElfStrDebugPubNames] = addstring(shstrtab, ".debug_pubnames");
	elfstrdbg[ElfStrDebugPubTypes] = addstring(shstrtab, ".debug_pubtypes");
	elfstrdbg[ElfStrDebugRanges]   = addstring(shstrtab, ".debug_ranges");
	elfstrdbg[ElfStrDebugStr]      = addstring(shstrtab, ".debug_str");
	elfstrdbg[ElfStrGDBScripts]    = addstring(shstrtab, ".debug_gdb_scripts");
	if(linkmode == LinkExternal) {
		if(thechar == '6') {
			elfstrdbg[ElfStrRelDebugInfo] = addstring(shstrtab, ".rela.debug_info");
			elfstrdbg[ElfStrRelDebugAranges] = addstring(shstrtab, ".rela.debug_aranges");
			elfstrdbg[ElfStrRelDebugLine] = addstring(shstrtab, ".rela.debug_line");
			elfstrdbg[ElfStrRelDebugFrame] = addstring(shstrtab, ".rela.debug_frame");
		} else {
			elfstrdbg[ElfStrRelDebugInfo] = addstring(shstrtab, ".rel.debug_info");
			elfstrdbg[ElfStrRelDebugAranges] = addstring(shstrtab, ".rel.debug_aranges");
			elfstrdbg[ElfStrRelDebugLine] = addstring(shstrtab, ".rel.debug_line");
			elfstrdbg[ElfStrRelDebugFrame] = addstring(shstrtab, ".rel.debug_frame");
		}

		infosym = linklookup(ctxt, ".debug_info", 0);
		infosym->hide = 1;

		abbrevsym = linklookup(ctxt, ".debug_abbrev", 0);
		abbrevsym->hide = 1;

		linesym = linklookup(ctxt, ".debug_line", 0);
		linesym->hide = 1;

		framesym = linklookup(ctxt, ".debug_frame", 0);
		framesym->hide = 1;
	}
}

// Add section symbols for DWARF debug info.  This is called before
// dwarfaddelfheaders.
void
dwarfaddelfsectionsyms()
{
	if(infosym != nil) {
		infosympos = cpos();
		putelfsectionsym(infosym, 0);
	}
	if(abbrevsym != nil) {
		abbrevsympos = cpos();
		putelfsectionsym(abbrevsym, 0);
	}
	if(linesym != nil) {
		linesympos = cpos();
		putelfsectionsym(linesym, 0);
	}
	if(framesym != nil) {
		framesympos = cpos();
		putelfsectionsym(framesym, 0);
	}
}

static void
dwarfaddelfrelocheader(int elfstr, ElfShdr *shdata, vlong off, vlong size)
{
	ElfShdr *sh;

	sh = newElfShdr(elfstrdbg[elfstr]);
	if(thechar == '6') {
		sh->type = SHT_RELA;
	} else {
		sh->type = SHT_REL;
	}
	sh->entsize = PtrSize*(2+(sh->type==SHT_RELA));
	sh->link = elfshname(".symtab")->shnum;
	sh->info = shdata->shnum;
	sh->off = off;
	sh->size = size;
	sh->addralign = PtrSize;
	
}

void
dwarfaddelfheaders(void)
{
	ElfShdr *sh, *shinfo, *sharanges, *shline, *shframe;

	if(debug['w'])  // disable dwarf
		return;

	sh = newElfShdr(elfstrdbg[ElfStrDebugAbbrev]);
	sh->type = SHT_PROGBITS;
	sh->off = abbrevo;
	sh->size = abbrevsize;
	sh->addralign = 1;
	if(abbrevsympos > 0)
		putelfsymshndx(abbrevsympos, sh->shnum);

	sh = newElfShdr(elfstrdbg[ElfStrDebugLine]);
	sh->type = SHT_PROGBITS;
	sh->off = lineo;
	sh->size = linesize;
	sh->addralign = 1;
	if(linesympos > 0)
		putelfsymshndx(linesympos, sh->shnum);
	shline = sh;

	sh = newElfShdr(elfstrdbg[ElfStrDebugFrame]);
	sh->type = SHT_PROGBITS;
	sh->off = frameo;
	sh->size = framesize;
	sh->addralign = 1;
	if(framesympos > 0)
		putelfsymshndx(framesympos, sh->shnum);
	shframe = sh;

	sh = newElfShdr(elfstrdbg[ElfStrDebugInfo]);
	sh->type = SHT_PROGBITS;
	sh->off = infoo;
	sh->size = infosize;
	sh->addralign = 1;
	if(infosympos > 0)
		putelfsymshndx(infosympos, sh->shnum);
	shinfo = sh;

	if (pubnamessize > 0) {
		sh = newElfShdr(elfstrdbg[ElfStrDebugPubNames]);
		sh->type = SHT_PROGBITS;
		sh->off = pubnameso;
		sh->size = pubnamessize;
		sh->addralign = 1;
	}

	if (pubtypessize > 0) {
		sh = newElfShdr(elfstrdbg[ElfStrDebugPubTypes]);
		sh->type = SHT_PROGBITS;
		sh->off = pubtypeso;
		sh->size = pubtypessize;
		sh->addralign = 1;
	}

	sharanges = nil;
	if (arangessize) {
		sh = newElfShdr(elfstrdbg[ElfStrDebugAranges]);
		sh->type = SHT_PROGBITS;
		sh->off = arangeso;
		sh->size = arangessize;
		sh->addralign = 1;
		sharanges = sh;
	}

	if (gdbscriptsize) {
		sh = newElfShdr(elfstrdbg[ElfStrGDBScripts]);
		sh->type = SHT_PROGBITS;
		sh->off = gdbscripto;
		sh->size = gdbscriptsize;
		sh->addralign = 1;
	}

	if(inforelocsize)
		dwarfaddelfrelocheader(ElfStrRelDebugInfo, shinfo, inforeloco, inforelocsize);

	if(arangesrelocsize)
		dwarfaddelfrelocheader(ElfStrRelDebugAranges, sharanges, arangesreloco, arangesrelocsize);

	if(linerelocsize)
		dwarfaddelfrelocheader(ElfStrRelDebugLine, shline, linereloco, linerelocsize);

	if(framerelocsize)
		dwarfaddelfrelocheader(ElfStrRelDebugFrame, shframe, framereloco, framerelocsize);
}

/*
 * Macho
 */
void
dwarfaddmachoheaders(void)
{
	MachoSect *msect;
	MachoSeg *ms;
	vlong fakestart;
	int nsect;

	if(debug['w'])  // disable dwarf
		return;

	// Zero vsize segments won't be loaded in memory, even so they
	// have to be page aligned in the file.
	fakestart = abbrevo & ~0xfff;

	nsect = 4;
	if (pubnamessize  > 0)
		nsect++;
	if (pubtypessize  > 0)
		nsect++;
	if (arangessize	  > 0)
		nsect++;
	if (gdbscriptsize > 0)
		nsect++;

	ms = newMachoSeg("__DWARF", nsect);
	ms->fileoffset = fakestart;
	ms->filesize = abbrevo-fakestart;
	ms->vaddr = ms->fileoffset + segdata.vaddr - segdata.fileoff;

	msect = newMachoSect(ms, "__debug_abbrev", "__DWARF");
	msect->off = abbrevo;
	msect->size = abbrevsize;
	msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
	ms->filesize += msect->size;

	msect = newMachoSect(ms, "__debug_line", "__DWARF");
	msect->off = lineo;
	msect->size = linesize;
	msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
	ms->filesize += msect->size;

	msect = newMachoSect(ms, "__debug_frame", "__DWARF");
	msect->off = frameo;
	msect->size = framesize;
	msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
	ms->filesize += msect->size;

	msect = newMachoSect(ms, "__debug_info", "__DWARF");
	msect->off = infoo;
	msect->size = infosize;
	msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
	ms->filesize += msect->size;

	if (pubnamessize > 0) {
		msect = newMachoSect(ms, "__debug_pubnames", "__DWARF");
		msect->off = pubnameso;
		msect->size = pubnamessize;
		msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
		ms->filesize += msect->size;
	}

	if (pubtypessize > 0) {
		msect = newMachoSect(ms, "__debug_pubtypes", "__DWARF");
		msect->off = pubtypeso;
		msect->size = pubtypessize;
		msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
		ms->filesize += msect->size;
	}

	if (arangessize > 0) {
		msect = newMachoSect(ms, "__debug_aranges", "__DWARF");
		msect->off = arangeso;
		msect->size = arangessize;
		msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
		ms->filesize += msect->size;
	}

	// TODO(lvd) fix gdb/python to load MachO (16 char section name limit)
	if (gdbscriptsize > 0) {
		msect = newMachoSect(ms, "__debug_gdb_scripts", "__DWARF");
		msect->off = gdbscripto;
		msect->size = gdbscriptsize;
		msect->addr = msect->off + segdata.vaddr - segdata.fileoff;
		ms->filesize += msect->size;
	}
}

/*
 * Windows PE
 */
void
dwarfaddpeheaders(void)
{
	if(debug['w'])  // disable dwarf
		return;

	newPEDWARFSection(".debug_abbrev", abbrevsize);
	newPEDWARFSection(".debug_line", linesize);
	newPEDWARFSection(".debug_frame", framesize);
	newPEDWARFSection(".debug_info", infosize);
	newPEDWARFSection(".debug_pubnames", pubnamessize);
	newPEDWARFSection(".debug_pubtypes", pubtypessize);
	newPEDWARFSection(".debug_aranges", arangessize);
	newPEDWARFSection(".debug_gdb_scripts", gdbscriptsize);
}
                                                             root/go1.4/src/cmd/ld/dwarf.h                                                                       0100644 0000000 0000000 00000001204 12600426226 014262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

/*
 * Emit debug_abbrevs, debug_info and debug_line sections to current
 * offset in cout.
 */
void dwarfemitdebugsections(void);

/*
 * Add the dwarf section names to the ELF
 * s[ection]h[eader]str[ing]tab.  Prerequisite for
 * dwarfaddelfheaders().
 */
void dwarfaddshstrings(LSym *shstrtab);

/*
 * Add section headers pointing to the sections emitted in
 * dwarfemitdebugsections.
 */
void dwarfaddelfheaders(void);
void dwarfaddmachoheaders(void);
void dwarfaddpeheaders(void);
                                                                                                                                                                                                                                                                                                                                                                                            root/go1.4/src/cmd/ld/dwarf_defs.h                                                                  0100644 0000000 0000000 00000032603 12600426226 015272  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Cut, pasted, tr-and-awk'ed from tables in
// http://dwarfstd.org/doc/Dwarf3.pdf

// Table 18
enum
{
	DW_TAG_array_type = 0x01,
	DW_TAG_class_type = 0x02,
	DW_TAG_entry_point = 0x03,
	DW_TAG_enumeration_type = 0x04,
	DW_TAG_formal_parameter = 0x05,
	DW_TAG_imported_declaration = 0x08,
	DW_TAG_label = 0x0a,
	DW_TAG_lexical_block = 0x0b,
	DW_TAG_member = 0x0d,
	DW_TAG_pointer_type = 0x0f,
	DW_TAG_reference_type = 0x10,
	DW_TAG_compile_unit = 0x11,
	DW_TAG_string_type = 0x12,
	DW_TAG_structure_type = 0x13,
	DW_TAG_subroutine_type = 0x15,
	DW_TAG_typedef = 0x16,
	DW_TAG_union_type = 0x17,
	DW_TAG_unspecified_parameters = 0x18,
	DW_TAG_variant = 0x19,
	DW_TAG_common_block = 0x1a,
	DW_TAG_common_inclusion = 0x1b,
	DW_TAG_inheritance = 0x1c,
	DW_TAG_inlined_subroutine = 0x1d,
	DW_TAG_module = 0x1e,
	DW_TAG_ptr_to_member_type = 0x1f,
	DW_TAG_set_type = 0x20,
	DW_TAG_subrange_type = 0x21,
	DW_TAG_with_stmt = 0x22,
	DW_TAG_access_declaration = 0x23,
	DW_TAG_base_type = 0x24,
	DW_TAG_catch_block = 0x25,
	DW_TAG_const_type = 0x26,
	DW_TAG_constant = 0x27,
	DW_TAG_enumerator = 0x28,
	DW_TAG_file_type = 0x29,
	DW_TAG_friend = 0x2a,
	DW_TAG_namelist = 0x2b,
	DW_TAG_namelist_item = 0x2c,
	DW_TAG_packed_type = 0x2d,
	DW_TAG_subprogram = 0x2e,
	DW_TAG_template_type_parameter = 0x2f,
	DW_TAG_template_value_parameter = 0x30,
	DW_TAG_thrown_type = 0x31,
	DW_TAG_try_block = 0x32,
	DW_TAG_variant_part = 0x33,
	DW_TAG_variable = 0x34,
	DW_TAG_volatile_type = 0x35,
	// Dwarf3
	DW_TAG_dwarf_procedure = 0x36,
	DW_TAG_restrict_type = 0x37,
	DW_TAG_interface_type = 0x38,
	DW_TAG_namespace = 0x39,
	DW_TAG_imported_module = 0x3a,
	DW_TAG_unspecified_type = 0x3b,
	DW_TAG_partial_unit = 0x3c,
	DW_TAG_imported_unit = 0x3d,
	DW_TAG_condition = 0x3f,
	DW_TAG_shared_type = 0x40,
	// Dwarf4
	DW_TAG_type_unit = 0x41,
	DW_TAG_rvalue_reference_type = 0x42,
	DW_TAG_template_alias = 0x43,

	// User defined
	DW_TAG_lo_user = 0x4080,
	DW_TAG_hi_user = 0xffff,

};

// Table 19
enum
{
	DW_CHILDREN_no = 0x00,
	DW_CHILDREN_yes = 0x01,
};

// Not from the spec, but logicaly belongs here
enum
{
	DW_CLS_ADDRESS = 0x01,
	DW_CLS_BLOCK,
	DW_CLS_CONSTANT,
	DW_CLS_FLAG,
	DW_CLS_PTR,	// lineptr, loclistptr, macptr, rangelistptr
	DW_CLS_REFERENCE,
	DW_CLS_ADDRLOC,
	DW_CLS_STRING
};

// Table 20
enum
{
	DW_AT_sibling = 0x01,	// reference
	DW_AT_location = 0x02,	// block, loclistptr
	DW_AT_name = 0x03,	// string
	DW_AT_ordering = 0x09,	// constant
	DW_AT_byte_size = 0x0b,	// block, constant, reference
	DW_AT_bit_offset = 0x0c,	// block, constant, reference
	DW_AT_bit_size = 0x0d,	// block, constant, reference
	DW_AT_stmt_list = 0x10,	// lineptr
	DW_AT_low_pc = 0x11,	// address
	DW_AT_high_pc = 0x12,	// address
	DW_AT_language = 0x13,	// constant
	DW_AT_discr = 0x15,	// reference
	DW_AT_discr_value = 0x16,	// constant
	DW_AT_visibility = 0x17,	// constant
	DW_AT_import = 0x18,	// reference
	DW_AT_string_length = 0x19,	// block, loclistptr
	DW_AT_common_reference = 0x1a,	// reference
	DW_AT_comp_dir = 0x1b,	// string
	DW_AT_const_value = 0x1c,	// block, constant, string
	DW_AT_containing_type = 0x1d,	// reference
	DW_AT_default_value = 0x1e,	// reference
	DW_AT_inline = 0x20,	// constant
	DW_AT_is_optional = 0x21,	// flag
	DW_AT_lower_bound = 0x22,	// block, constant, reference
	DW_AT_producer = 0x25,	// string
	DW_AT_prototyped = 0x27,	// flag
	DW_AT_return_addr = 0x2a,	// block, loclistptr
	DW_AT_start_scope = 0x2c,	// constant
	DW_AT_bit_stride = 0x2e,	// constant
	DW_AT_upper_bound = 0x2f,	// block, constant, reference
	DW_AT_abstract_origin = 0x31,	// reference
	DW_AT_accessibility = 0x32,	// constant
	DW_AT_address_class = 0x33,	// constant
	DW_AT_artificial = 0x34,	// flag
	DW_AT_base_types = 0x35,	// reference
	DW_AT_calling_convention = 0x36,	// constant
	DW_AT_count = 0x37,	// block, constant, reference
	DW_AT_data_member_location = 0x38,	// block, constant, loclistptr
	DW_AT_decl_column = 0x39,	// constant
	DW_AT_decl_file = 0x3a,	// constant
	DW_AT_decl_line = 0x3b,	// constant
	DW_AT_declaration = 0x3c,	// flag
	DW_AT_discr_list = 0x3d,	// block
	DW_AT_encoding = 0x3e,	// constant
	DW_AT_external = 0x3f,	// flag
	DW_AT_frame_base = 0x40,	// block, loclistptr
	DW_AT_friend = 0x41,	// reference
	DW_AT_identifier_case = 0x42,	// constant
	DW_AT_macro_info = 0x43,	// macptr
	DW_AT_namelist_item = 0x44,	// block
	DW_AT_priority = 0x45,	// reference
	DW_AT_segment = 0x46,	// block, loclistptr
	DW_AT_specification = 0x47,	// reference
	DW_AT_static_link = 0x48,	// block, loclistptr
	DW_AT_type = 0x49,	// reference
	DW_AT_use_location = 0x4a,	// block, loclistptr
	DW_AT_variable_parameter = 0x4b,	// flag
	DW_AT_virtuality = 0x4c,	// constant
	DW_AT_vtable_elem_location = 0x4d,	// block, loclistptr
	// Dwarf3
	DW_AT_allocated = 0x4e,	// block, constant, reference
	DW_AT_associated = 0x4f,	// block, constant, reference
	DW_AT_data_location = 0x50,	// block
	DW_AT_byte_stride = 0x51,	// block, constant, reference
	DW_AT_entry_pc = 0x52,	// address
	DW_AT_use_UTF8 = 0x53,	// flag
	DW_AT_extension = 0x54,	// reference
	DW_AT_ranges = 0x55,	// rangelistptr
	DW_AT_trampoline = 0x56,	// address, flag, reference, string
	DW_AT_call_column = 0x57,	// constant
	DW_AT_call_file = 0x58,	// constant
	DW_AT_call_line = 0x59,	// constant
	DW_AT_description = 0x5a,	// string
	DW_AT_binary_scale = 0x5b,	// constant
	DW_AT_decimal_scale = 0x5c,	// constant
	DW_AT_small = 0x5d,	// reference
	DW_AT_decimal_sign = 0x5e,	// constant
	DW_AT_digit_count = 0x5f,	// constant
	DW_AT_picture_string = 0x60,	// string
	DW_AT_mutable = 0x61,	// flag
	DW_AT_threads_scaled = 0x62,	// flag
	DW_AT_explicit = 0x63,	// flag
	DW_AT_object_pointer = 0x64,	// reference
	DW_AT_endianity = 0x65,	// constant
	DW_AT_elemental = 0x66,	// flag
	DW_AT_pure = 0x67,	// flag
	DW_AT_recursive = 0x68,	// flag

	DW_AT_lo_user = 0x2000,	// ---
	DW_AT_hi_user = 0x3fff,	// ---

};

// Table 21
enum
{
	DW_FORM_addr = 0x01,	// address
	DW_FORM_block2 = 0x03,	// block
	DW_FORM_block4 = 0x04,	// block
	DW_FORM_data2 = 0x05,	// constant
	DW_FORM_data4 = 0x06,	// constant, lineptr, loclistptr, macptr, rangelistptr
	DW_FORM_data8 = 0x07,	// constant, lineptr, loclistptr, macptr, rangelistptr
	DW_FORM_string = 0x08,	// string
	DW_FORM_block = 0x09,	// block
	DW_FORM_block1 = 0x0a,	// block
	DW_FORM_data1 = 0x0b,	// constant
	DW_FORM_flag = 0x0c,	// flag
	DW_FORM_sdata = 0x0d,	// constant
	DW_FORM_strp = 0x0e,	// string
	DW_FORM_udata = 0x0f,	// constant
	DW_FORM_ref_addr = 0x10,	// reference
	DW_FORM_ref1 = 0x11,	// reference
	DW_FORM_ref2 = 0x12,	// reference
	DW_FORM_ref4 = 0x13,	// reference
	DW_FORM_ref8 = 0x14,	// reference
	DW_FORM_ref_udata = 0x15,	// reference
	DW_FORM_indirect = 0x16,	// (see Section 7.5.3)
};

// Table 24 (#operands, notes)
enum
{
	DW_OP_addr = 0x03,	// 1 constant address (size target specific)
	DW_OP_deref = 0x06,	// 0
	DW_OP_const1u = 0x08,	// 1 1-byte constant
	DW_OP_const1s = 0x09,	// 1 1-byte constant
	DW_OP_const2u = 0x0a,	// 1 2-byte constant
	DW_OP_const2s = 0x0b,	// 1 2-byte constant
	DW_OP_const4u = 0x0c,	// 1 4-byte constant
	DW_OP_const4s = 0x0d,	// 1 4-byte constant
	DW_OP_const8u = 0x0e,	// 1 8-byte constant
	DW_OP_const8s = 0x0f,	// 1 8-byte constant
	DW_OP_constu = 0x10,	// 1 ULEB128 constant
	DW_OP_consts = 0x11,	// 1 SLEB128 constant
	DW_OP_dup = 0x12,	// 0
	DW_OP_drop = 0x13,	// 0
	DW_OP_over = 0x14,	// 0
	DW_OP_pick = 0x15,	// 1 1-byte stack index
	DW_OP_swap = 0x16,	// 0
	DW_OP_rot = 0x17,	// 0
	DW_OP_xderef = 0x18,	// 0
	DW_OP_abs = 0x19,	// 0
	DW_OP_and = 0x1a,	// 0
	DW_OP_div = 0x1b,	// 0
	DW_OP_minus = 0x1c,	// 0
	DW_OP_mod = 0x1d,	// 0
	DW_OP_mul = 0x1e,	// 0
	DW_OP_neg = 0x1f,	// 0
	DW_OP_not = 0x20,	// 0
	DW_OP_or = 0x21,	// 0
	DW_OP_plus = 0x22,	// 0
	DW_OP_plus_uconst = 0x23,	// 1 ULEB128 addend
	DW_OP_shl = 0x24,	// 0
	DW_OP_shr = 0x25,	// 0
	DW_OP_shra = 0x26,	// 0
	DW_OP_xor = 0x27,	// 0
	DW_OP_skip = 0x2f,	// 1 signed 2-byte constant
	DW_OP_bra = 0x28,	// 1 signed 2-byte constant
	DW_OP_eq = 0x29,	// 0
	DW_OP_ge = 0x2a,	// 0
	DW_OP_gt = 0x2b,	// 0
	DW_OP_le = 0x2c,	// 0
	DW_OP_lt = 0x2d,	// 0
	DW_OP_ne = 0x2e,	// 0
	DW_OP_lit0 = 0x30,	// 0 ...
	DW_OP_lit31 = 0x4f,	// 0 literals 0..31 = (DW_OP_lit0 +
	// literal)
	DW_OP_reg0 = 0x50,	// 0 ..
	DW_OP_reg31 = 0x6f,	// 0 reg 0..31 = (DW_OP_reg0 + regnum)
	DW_OP_breg0 = 0x70,	// 1 ...
	DW_OP_breg31 = 0x8f,	// 1 SLEB128 offset base register 0..31 = (DW_OP_breg0 + regnum)
	DW_OP_regx = 0x90,	// 1 ULEB128 register
	DW_OP_fbreg = 0x91,	// 1 SLEB128 offset
	DW_OP_bregx = 0x92,	// 2 ULEB128 register followed by SLEB128 offset
	DW_OP_piece = 0x93,	// 1 ULEB128 size of piece addressed
	DW_OP_deref_size = 0x94,	// 1 1-byte size of data retrieved
	DW_OP_xderef_size = 0x95,	// 1 1-byte size of data retrieved
	DW_OP_nop = 0x96,	// 0
	DW_OP_push_object_address = 0x97,	// 0
	DW_OP_call2 = 0x98,	// 1 2-byte offset of DIE
	DW_OP_call4 = 0x99,	// 1 4-byte offset of DIE
	DW_OP_call_ref = 0x9a,	// 1 4- or 8-byte offset of DIE
	DW_OP_form_tls_address = 0x9b,	// 0
	DW_OP_call_frame_cfa = 0x9c,	// 0
	DW_OP_bit_piece = 0x9d,	// 2
	DW_OP_lo_user = 0xe0,
	DW_OP_hi_user = 0xff,
};

// Table 25
enum
{
	DW_ATE_address = 0x01,
	DW_ATE_boolean = 0x02,
	DW_ATE_complex_float = 0x03,
	DW_ATE_float = 0x04,
	DW_ATE_signed = 0x05,
	DW_ATE_signed_char = 0x06,
	DW_ATE_unsigned = 0x07,
	DW_ATE_unsigned_char = 0x08,
	DW_ATE_imaginary_float = 0x09,
	DW_ATE_packed_decimal = 0x0a,
	DW_ATE_numeric_string = 0x0b,
	DW_ATE_edited = 0x0c,
	DW_ATE_signed_fixed = 0x0d,
	DW_ATE_unsigned_fixed = 0x0e,
	DW_ATE_decimal_float = 0x0f,
	DW_ATE_lo_user = 0x80,
	DW_ATE_hi_user = 0xff,
};

// Table 26
enum
{
	DW_DS_unsigned = 0x01,
	DW_DS_leading_overpunch = 0x02,
	DW_DS_trailing_overpunch = 0x03,
	DW_DS_leading_separate = 0x04,
	DW_DS_trailing_separate = 0x05,
};

// Table 27
enum
{
	DW_END_default = 0x00,
	DW_END_big = 0x01,
	DW_END_little = 0x02,
	DW_END_lo_user = 0x40,
	DW_END_hi_user = 0xff,
};

// Table 28
enum
{
	DW_ACCESS_public = 0x01,
	DW_ACCESS_protected = 0x02,
	DW_ACCESS_private = 0x03,
};

// Table 29
enum
{
	DW_VIS_local = 0x01,
	DW_VIS_exported = 0x02,
	DW_VIS_qualified = 0x03,
};

// Table 30
enum
{
	DW_VIRTUALITY_none = 0x00,
	DW_VIRTUALITY_virtual = 0x01,
	DW_VIRTUALITY_pure_virtual = 0x02,
};

// Table 31
enum
{
	DW_LANG_C89 = 0x0001,
	DW_LANG_C = 0x0002,
	DW_LANG_Ada83 = 0x0003,
	DW_LANG_C_plus_plus = 0x0004,
	DW_LANG_Cobol74 = 0x0005,
	DW_LANG_Cobol85 = 0x0006,
	DW_LANG_Fortran77 = 0x0007,
	DW_LANG_Fortran90 = 0x0008,
	DW_LANG_Pascal83 = 0x0009,
	DW_LANG_Modula2 = 0x000a,
	// Dwarf3
	DW_LANG_Java = 0x000b,
	DW_LANG_C99 = 0x000c,
	DW_LANG_Ada95 = 0x000d,
	DW_LANG_Fortran95 = 0x000e,
	DW_LANG_PLI = 0x000f,
	DW_LANG_ObjC = 0x0010,
	DW_LANG_ObjC_plus_plus = 0x0011,
	DW_LANG_UPC = 0x0012,
	DW_LANG_D = 0x0013,
	// Dwarf4
	DW_LANG_Python = 0x0014,
	// Dwarf5
	DW_LANG_Go = 0x0016,

	DW_LANG_lo_user = 0x8000,
	DW_LANG_hi_user = 0xffff,
};

// Table 32
enum
{
	DW_ID_case_sensitive = 0x00,
	DW_ID_up_case = 0x01,
	DW_ID_down_case = 0x02,
	DW_ID_case_insensitive = 0x03,
};

// Table 33
enum
{
	DW_CC_normal = 0x01,
	DW_CC_program = 0x02,
	DW_CC_nocall = 0x03,
	DW_CC_lo_user = 0x40,
	DW_CC_hi_user = 0xff,
};

// Table 34
enum
{
	DW_INL_not_inlined = 0x00,
	DW_INL_inlined = 0x01,
	DW_INL_declared_not_inlined = 0x02,
	DW_INL_declared_inlined = 0x03,
};

// Table 35
enum
{
	DW_ORD_row_major = 0x00,
	DW_ORD_col_major = 0x01,
};

// Table 36
enum
{
	DW_DSC_label = 0x00,
	DW_DSC_range = 0x01,
};

// Table 37
enum
{
	DW_LNS_copy = 0x01,
	DW_LNS_advance_pc = 0x02,
	DW_LNS_advance_line = 0x03,
	DW_LNS_set_file = 0x04,
	DW_LNS_set_column = 0x05,
	DW_LNS_negate_stmt = 0x06,
	DW_LNS_set_basic_block = 0x07,
	DW_LNS_const_add_pc = 0x08,
	DW_LNS_fixed_advance_pc = 0x09,
	// Dwarf3
	DW_LNS_set_prologue_end = 0x0a,
	DW_LNS_set_epilogue_begin = 0x0b,
	DW_LNS_set_isa = 0x0c,
};

// Table 38
enum
{
	DW_LNE_end_sequence = 0x01,
	DW_LNE_set_address = 0x02,
	DW_LNE_define_file = 0x03,
	DW_LNE_lo_user = 0x80,
	DW_LNE_hi_user = 0xff,
};

// Table 39
enum
{
	DW_MACINFO_define = 0x01,
	DW_MACINFO_undef = 0x02,
	DW_MACINFO_start_file = 0x03,
	DW_MACINFO_end_file = 0x04,
	DW_MACINFO_vendor_ext = 0xff,
};

// Table 40.
enum
{					// operand,...
	DW_CFA_nop = 0x00,
	DW_CFA_set_loc = 0x01,		// address
	DW_CFA_advance_loc1 = 0x02,	// 1-byte delta
	DW_CFA_advance_loc2 = 0x03,	// 2-byte delta
	DW_CFA_advance_loc4 = 0x04,	// 4-byte delta
	DW_CFA_offset_extended = 0x05,	// ULEB128 register, ULEB128 offset
	DW_CFA_restore_extended = 0x06, // ULEB128 register
	DW_CFA_undefined = 0x07,	// ULEB128 register
	DW_CFA_same_value = 0x08,	// ULEB128 register
	DW_CFA_register = 0x09,		// ULEB128 register, ULEB128 register
	DW_CFA_remember_state = 0x0a,
	DW_CFA_restore_state = 0x0b,
	DW_CFA_def_cfa = 0x0c,		// ULEB128 register, ULEB128 offset
	DW_CFA_def_cfa_register = 0x0d,	// ULEB128 register
	DW_CFA_def_cfa_offset = 0x0e,	// ULEB128 offset
	DW_CFA_def_cfa_expression = 0x0f, // BLOCK
	DW_CFA_expression = 0x10,	// ULEB128 register, BLOCK
	DW_CFA_offset_extended_sf = 0x11, // ULEB128 register, SLEB128 offset
	DW_CFA_def_cfa_sf = 0x12,	// ULEB128 register, SLEB128 offset
	DW_CFA_def_cfa_offset_sf = 0x13, // SLEB128 offset
	DW_CFA_val_offset = 0x14,	// ULEB128, ULEB128
	DW_CFA_val_offset_sf = 0x15,	// ULEB128, SLEB128
	DW_CFA_val_expression = 0x16,	// ULEB128, BLOCK

	DW_CFA_lo_user = 0x1c,
	DW_CFA_hi_user = 0x3f,

	// Opcodes that take an addend operand.
	DW_CFA_advance_loc = 0x1<<6, // +delta
	DW_CFA_offset	   = 0x2<<6, // +register (ULEB128 offset)
	DW_CFA_restore	   = 0x3<<6, // +register
};
                                                                                                                             root/go1.4/src/cmd/ld/elf.c                                                                         0100644 0000000 0000000 00000100577 12600426226 013735  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include	"l.h"
#include	"lib.h"
#include	"../ld/elf.h"

/*
 * We use the 64-bit data structures on both 32- and 64-bit machines
 * in order to write the code just once.  The 64-bit data structure is
 * written in the 32-bit format on the 32-bit machines.
 */
#define	NSECT	48

int	iself;

static	int	elf64;
static	ElfEhdr	hdr;
static	ElfPhdr	*phdr[NSECT];
static	ElfShdr	*shdr[NSECT];
static	char	*interp;

typedef struct Elfstring Elfstring;
struct Elfstring
{
	char *s;
	int off;
};

static Elfstring elfstr[100];
static int nelfstr;

static char buildinfo[32];

/*
 Initialize the global variable that describes the ELF header. It will be updated as
 we write section and prog headers.
 */
void
elfinit(void)
{
	iself = 1;

	switch(thechar) {
	// 64-bit architectures
	case '6':
		elf64 = 1;
		hdr.phoff = ELF64HDRSIZE;	/* Must be be ELF64HDRSIZE: first PHdr must follow ELF header */
		hdr.shoff = ELF64HDRSIZE;	/* Will move as we add PHeaders */
		hdr.ehsize = ELF64HDRSIZE;	/* Must be ELF64HDRSIZE */
		hdr.phentsize = ELF64PHDRSIZE;	/* Must be ELF64PHDRSIZE */
		hdr.shentsize = ELF64SHDRSIZE;	/* Must be ELF64SHDRSIZE */
		break;

	// 32-bit architectures
	case '5':
		// we use EABI on both linux/arm and freebsd/arm.
		if(HEADTYPE == Hlinux || HEADTYPE == Hfreebsd)
			hdr.flags = 0x5000002; // has entry point, Version5 EABI
		// fallthrough
	default:
		hdr.phoff = ELF32HDRSIZE;	/* Must be be ELF32HDRSIZE: first PHdr must follow ELF header */
		hdr.shoff = ELF32HDRSIZE;	/* Will move as we add PHeaders */
		hdr.ehsize = ELF32HDRSIZE;	/* Must be ELF32HDRSIZE */
		hdr.phentsize = ELF32PHDRSIZE;	/* Must be ELF32PHDRSIZE */
		hdr.shentsize = ELF32SHDRSIZE;	/* Must be ELF32SHDRSIZE */
	}
}

void
elf64phdr(ElfPhdr *e)
{
	LPUT(e->type);
	LPUT(e->flags);
	VPUT(e->off);
	VPUT(e->vaddr);
	VPUT(e->paddr);
	VPUT(e->filesz);
	VPUT(e->memsz);
	VPUT(e->align);
}

void
elf32phdr(ElfPhdr *e)
{
	int frag;
	
	if(e->type == PT_LOAD) {
		// Correct ELF loaders will do this implicitly,
		// but buggy ELF loaders like the one in some
		// versions of QEMU won't.
		frag = e->vaddr&(e->align-1);
		e->off -= frag;
		e->vaddr -= frag;
		e->paddr -= frag;
		e->filesz += frag;
		e->memsz += frag;
	}
	LPUT(e->type);
	LPUT(e->off);
	LPUT(e->vaddr);
	LPUT(e->paddr);
	LPUT(e->filesz);
	LPUT(e->memsz);
	LPUT(e->flags);
	LPUT(e->align);
}

void
elf64shdr(ElfShdr *e)
{
	LPUT(e->name);
	LPUT(e->type);
	VPUT(e->flags);
	VPUT(e->addr);
	VPUT(e->off);
	VPUT(e->size);
	LPUT(e->link);
	LPUT(e->info);
	VPUT(e->addralign);
	VPUT(e->entsize);
}

void
elf32shdr(ElfShdr *e)
{
	LPUT(e->name);
	LPUT(e->type);
	LPUT(e->flags);
	LPUT(e->addr);
	LPUT(e->off);
	LPUT(e->size);
	LPUT(e->link);
	LPUT(e->info);
	LPUT(e->addralign);
	LPUT(e->entsize);
}

uint32
elfwriteshdrs(void)
{
	int i;

	if (elf64) {
		for (i = 0; i < hdr.shnum; i++)
			elf64shdr(shdr[i]);
		return hdr.shnum * ELF64SHDRSIZE;
	}
	for (i = 0; i < hdr.shnum; i++)
		elf32shdr(shdr[i]);
	return hdr.shnum * ELF32SHDRSIZE;
}

void
elfsetstring(char *s, int off)
{
	if(nelfstr >= nelem(elfstr)) {
		diag("too many elf strings");
		errorexit();
	}
	elfstr[nelfstr].s = s;
	elfstr[nelfstr].off = off;
	nelfstr++;
}

uint32
elfwritephdrs(void)
{
	int i;

	if (elf64) {
		for (i = 0; i < hdr.phnum; i++)
			elf64phdr(phdr[i]);
		return hdr.phnum * ELF64PHDRSIZE;
	}
	for (i = 0; i < hdr.phnum; i++)
		elf32phdr(phdr[i]);
	return hdr.phnum * ELF32PHDRSIZE;
}

ElfPhdr*
newElfPhdr(void)
{
	ElfPhdr *e;

	e = mal(sizeof *e);
	if (hdr.phnum >= NSECT)
		diag("too many phdrs");
	else
		phdr[hdr.phnum++] = e;
	if (elf64)
		hdr.shoff += ELF64PHDRSIZE;
	else
		hdr.shoff += ELF32PHDRSIZE;
	return e;
}

ElfShdr*
newElfShdr(vlong name)
{
	ElfShdr *e;

	e = mal(sizeof *e);
	e->name = name;
	e->shnum = hdr.shnum;
	if (hdr.shnum >= NSECT) {
		diag("too many shdrs");
	} else {
		shdr[hdr.shnum++] = e;
	}
	return e;
}

ElfEhdr*
getElfEhdr(void)
{
	return &hdr;
}

uint32
elf64writehdr(void)
{
	int i;

	for (i = 0; i < EI_NIDENT; i++)
		cput(hdr.ident[i]);
	WPUT(hdr.type);
	WPUT(hdr.machine);
	LPUT(hdr.version);
	VPUT(hdr.entry);
	VPUT(hdr.phoff);
	VPUT(hdr.shoff);
	LPUT(hdr.flags);
	WPUT(hdr.ehsize);
	WPUT(hdr.phentsize);
	WPUT(hdr.phnum);
	WPUT(hdr.shentsize);
	WPUT(hdr.shnum);
	WPUT(hdr.shstrndx);
	return ELF64HDRSIZE;
}

uint32
elf32writehdr(void)
{
	int i;

	for (i = 0; i < EI_NIDENT; i++)
		cput(hdr.ident[i]);
	WPUT(hdr.type);
	WPUT(hdr.machine);
	LPUT(hdr.version);
	LPUT(hdr.entry);
	LPUT(hdr.phoff);
	LPUT(hdr.shoff);
	LPUT(hdr.flags);
	WPUT(hdr.ehsize);
	WPUT(hdr.phentsize);
	WPUT(hdr.phnum);
	WPUT(hdr.shentsize);
	WPUT(hdr.shnum);
	WPUT(hdr.shstrndx);
	return ELF32HDRSIZE;
}

uint32
elfwritehdr(void)
{
	if(elf64)
		return elf64writehdr();
	return elf32writehdr();
}

/* Taken directly from the definition document for ELF64 */
uint32
elfhash(uchar *name)
{
	uint32 h = 0, g;
	while (*name) {
		h = (h << 4) + *name++;
		if (g = h & 0xf0000000)
			h ^= g >> 24;
		h &= 0x0fffffff;
	}
	return h;
}

void
elfwritedynent(LSym *s, int tag, uint64 val)
{
	if(elf64) {
		adduint64(ctxt, s, tag);
		adduint64(ctxt, s, val);
	} else {
		adduint32(ctxt, s, tag);
		adduint32(ctxt, s, val);
	}
}

void
elfwritedynentsym(LSym *s, int tag, LSym *t)
{
	if(elf64)
		adduint64(ctxt, s, tag);
	else
		adduint32(ctxt, s, tag);
	addaddr(ctxt, s, t);
}

void
elfwritedynentsymsize(LSym *s, int tag, LSym *t)
{
	if(elf64)
		adduint64(ctxt, s, tag);
	else
		adduint32(ctxt, s, tag);
	addsize(ctxt, s, t);
}

int
elfinterp(ElfShdr *sh, uint64 startva, uint64 resoff, char *p)
{
	int n;

	interp = p;
	n = strlen(interp)+1;
	sh->addr = startva + resoff - n;
	sh->off = resoff - n;
	sh->size = n;

	return n;
}

int
elfwriteinterp(void)
{
	ElfShdr *sh;
	
	sh = elfshname(".interp");
	cseek(sh->off);
	cwrite(interp, sh->size);
	return sh->size;
}

int
elfnote(ElfShdr *sh, uint64 startva, uint64 resoff, int sz)
{
	uint64 n;

	n = sizeof(Elf_Note) + sz + resoff % 4;

	sh->type = SHT_NOTE;
	sh->flags = SHF_ALLOC;
	sh->addralign = 4;
	sh->addr = startva + resoff - n;
	sh->off = resoff - n;
	sh->size = n - resoff % 4;

	return n;
}

ElfShdr *
elfwritenotehdr(char *str, uint32 namesz, uint32 descsz, uint32 tag)
{
	ElfShdr *sh;
	
	sh = elfshname(str);

	// Write Elf_Note header.
	cseek(sh->off);
	LPUT(namesz);
	LPUT(descsz);
	LPUT(tag);

	return sh;
}

// NetBSD Signature (as per sys/exec_elf.h)
#define ELF_NOTE_NETBSD_NAMESZ		7
#define ELF_NOTE_NETBSD_DESCSZ		4
#define ELF_NOTE_NETBSD_TAG		1
#define ELF_NOTE_NETBSD_NAME		"NetBSD\0\0"
#define ELF_NOTE_NETBSD_VERSION		599000000	/* NetBSD 5.99 */

int
elfnetbsdsig(ElfShdr *sh, uint64 startva, uint64 resoff)
{
	int n;

	n = rnd(ELF_NOTE_NETBSD_NAMESZ, 4) + rnd(ELF_NOTE_NETBSD_DESCSZ, 4);
	return elfnote(sh, startva, resoff, n);
}

int
elfwritenetbsdsig(void)
{
	ElfShdr *sh;

	// Write Elf_Note header.
	sh = elfwritenotehdr(".note.netbsd.ident", ELF_NOTE_NETBSD_NAMESZ, ELF_NOTE_NETBSD_DESCSZ, ELF_NOTE_NETBSD_TAG);
	if(sh == nil)
		return 0;

	// Followed by NetBSD string and version.
	cwrite(ELF_NOTE_NETBSD_NAME, ELF_NOTE_NETBSD_NAMESZ + 1);
	LPUT(ELF_NOTE_NETBSD_VERSION);

	return sh->size;
}

// OpenBSD Signature
#define ELF_NOTE_OPENBSD_NAMESZ		8
#define ELF_NOTE_OPENBSD_DESCSZ		4
#define ELF_NOTE_OPENBSD_TAG		1
#define ELF_NOTE_OPENBSD_NAME		"OpenBSD\0"
#define ELF_NOTE_OPENBSD_VERSION	0

int
elfopenbsdsig(ElfShdr *sh, uint64 startva, uint64 resoff)
{
	int n;

	n = ELF_NOTE_OPENBSD_NAMESZ + ELF_NOTE_OPENBSD_DESCSZ;
	return elfnote(sh, startva, resoff, n);
}

int
elfwriteopenbsdsig(void)
{
	ElfShdr *sh;

	// Write Elf_Note header.
	sh = elfwritenotehdr(".note.openbsd.ident", ELF_NOTE_OPENBSD_NAMESZ, ELF_NOTE_OPENBSD_DESCSZ, ELF_NOTE_OPENBSD_TAG);
	if(sh == nil)
		return 0;

	// Followed by OpenBSD string and version.
	cwrite(ELF_NOTE_OPENBSD_NAME, ELF_NOTE_OPENBSD_NAMESZ);
	LPUT(ELF_NOTE_OPENBSD_VERSION);

	return sh->size;
}

void
addbuildinfo(char *val)
{
	char *ov;
	int i, b, j;

	if(val[0] != '0' || val[1] != 'x') {
		fprint(2, "%s: -B argument must start with 0x: %s\n", argv0, val);
		exits("usage");
	}
	ov = val;
	val += 2;
	i = 0;
	while(*val != '\0') {
		if(val[1] == '\0') {
			fprint(2, "%s: -B argument must have even number of digits: %s\n", argv0, ov);
			exits("usage");
		}
		b = 0;
		for(j = 0; j < 2; j++, val++) {
			b *= 16;
		  	if(*val >= '0' && *val <= '9')
				b += *val - '0';
			else if(*val >= 'a' && *val <= 'f')
				b += *val - 'a' + 10;
			else if(*val >= 'A' && *val <= 'F')
				b += *val - 'A' + 10;
			else {
				fprint(2, "%s: -B argument contains invalid hex digit %c: %s\n", argv0, *val, ov);
				exits("usage");
			}
		}
		if(i >= nelem(buildinfo)) {
			fprint(2, "%s: -B option too long (max %d digits): %s\n", argv0, (int)nelem(buildinfo), ov);
			exits("usage");
		}
		buildinfo[i++] = b;
	}
	buildinfolen = i;
}

// Build info note
#define ELF_NOTE_BUILDINFO_NAMESZ	4
#define ELF_NOTE_BUILDINFO_TAG		3
#define ELF_NOTE_BUILDINFO_NAME		"GNU\0"

int
elfbuildinfo(ElfShdr *sh, uint64 startva, uint64 resoff)
{
	int n;

	n = ELF_NOTE_BUILDINFO_NAMESZ + rnd(buildinfolen, 4);
	return elfnote(sh, startva, resoff, n);
}

int
elfwritebuildinfo(void)
{
	ElfShdr *sh;

	sh = elfwritenotehdr(".note.gnu.build-id", ELF_NOTE_BUILDINFO_NAMESZ, buildinfolen, ELF_NOTE_BUILDINFO_TAG);
	if(sh == nil)
		return 0;

	cwrite(ELF_NOTE_BUILDINFO_NAME, ELF_NOTE_BUILDINFO_NAMESZ);
	cwrite(buildinfo, buildinfolen);
	cwrite("\0\0\0", rnd(buildinfolen, 4) - buildinfolen);

	return sh->size;
}

extern int nelfsym;
int elfverneed;

typedef struct Elfaux Elfaux;
typedef struct Elflib Elflib;

struct Elflib
{
	Elflib *next;
	Elfaux *aux;
	char *file;
};

struct Elfaux
{
	Elfaux *next;
	int num;
	char *vers;
};

Elfaux*
addelflib(Elflib **list, char *file, char *vers)
{
	Elflib *lib;
	Elfaux *aux;
	
	for(lib=*list; lib; lib=lib->next)
		if(strcmp(lib->file, file) == 0)
			goto havelib;
	lib = mal(sizeof *lib);
	lib->next = *list;
	lib->file = file;
	*list = lib;
havelib:
	for(aux=lib->aux; aux; aux=aux->next)
		if(strcmp(aux->vers, vers) == 0)
			goto haveaux;
	aux = mal(sizeof *aux);
	aux->next = lib->aux;
	aux->vers = vers;
	lib->aux = aux;
haveaux:
	return aux;
}

void
elfdynhash(void)
{
	LSym *s, *sy, *dynstr;
	int i, j, nbucket, b, nfile;
	uint32 hc, *chain, *buckets;
	int nsym;
	char *name;
	Elfaux **need;
	Elflib *needlib;
	Elflib *l;
	Elfaux *x;
	
	if(!iself)
		return;

	nsym = nelfsym;
	s = linklookup(ctxt, ".hash", 0);
	s->type = SELFROSECT;
	s->reachable = 1;

	i = nsym;
	nbucket = 1;
	while(i > 0) {
		++nbucket;
		i >>= 1;
	}

	needlib = nil;
	need = malloc(nsym * sizeof need[0]);
	chain = malloc(nsym * sizeof chain[0]);
	buckets = malloc(nbucket * sizeof buckets[0]);
	if(need == nil || chain == nil || buckets == nil) {
		ctxt->cursym = nil;
		diag("out of memory");
		errorexit();
	}
	memset(need, 0, nsym * sizeof need[0]);
	memset(chain, 0, nsym * sizeof chain[0]);
	memset(buckets, 0, nbucket * sizeof buckets[0]);
	for(sy=ctxt->allsym; sy!=S; sy=sy->allsym) {
		if (sy->dynid <= 0)
			continue;

		if(sy->dynimpvers)
			need[sy->dynid] = addelflib(&needlib, sy->dynimplib, sy->dynimpvers);

		name = sy->extname;
		hc = elfhash((uchar*)name);

		b = hc % nbucket;
		chain[sy->dynid] = buckets[b];
		buckets[b] = sy->dynid;
	}

	adduint32(ctxt, s, nbucket);
	adduint32(ctxt, s, nsym);
	for(i = 0; i<nbucket; i++)
		adduint32(ctxt, s, buckets[i]);
	for(i = 0; i<nsym; i++)
		adduint32(ctxt, s, chain[i]);

	free(chain);
	free(buckets);
	
	// version symbols
	dynstr = linklookup(ctxt, ".dynstr", 0);
	s = linklookup(ctxt, ".gnu.version_r", 0);
	i = 2;
	nfile = 0;
	for(l=needlib; l; l=l->next) {
		nfile++;
		// header
		adduint16(ctxt, s, 1);  // table version
		j = 0;
		for(x=l->aux; x; x=x->next)
			j++;
		adduint16(ctxt, s, j);	// aux count
		adduint32(ctxt, s, addstring(dynstr, l->file));  // file string offset
		adduint32(ctxt, s, 16);  // offset from header to first aux
		if(l->next)
			adduint32(ctxt, s, 16+j*16);  // offset from this header to next
		else
			adduint32(ctxt, s, 0);
		
		for(x=l->aux; x; x=x->next) {
			x->num = i++;
			// aux struct
			adduint32(ctxt, s, elfhash((uchar*)x->vers));  // hash
			adduint16(ctxt, s, 0);  // flags
			adduint16(ctxt, s, x->num);  // other - index we refer to this by
			adduint32(ctxt, s, addstring(dynstr, x->vers));  // version string offset
			if(x->next)
				adduint32(ctxt, s, 16);  // offset from this aux to next
			else
				adduint32(ctxt, s, 0);
		}
	}

	// version references
	s = linklookup(ctxt, ".gnu.version", 0);
	for(i=0; i<nsym; i++) {
		if(i == 0)
			adduint16(ctxt, s, 0); // first entry - no symbol
		else if(need[i] == nil)
			adduint16(ctxt, s, 1); // global
		else
			adduint16(ctxt, s, need[i]->num);
	}

	free(need);

	s = linklookup(ctxt, ".dynamic", 0);
	elfverneed = nfile;
	if(elfverneed) {
		elfwritedynentsym(s, DT_VERNEED, linklookup(ctxt, ".gnu.version_r", 0));
		elfwritedynent(s, DT_VERNEEDNUM, nfile);
		elfwritedynentsym(s, DT_VERSYM, linklookup(ctxt, ".gnu.version", 0));
	}

	if(thechar == '6') {
		sy = linklookup(ctxt, ".rela.plt", 0);
		if(sy->size > 0) {
			elfwritedynent(s, DT_PLTREL, DT_RELA);
			elfwritedynentsymsize(s, DT_PLTRELSZ, sy);
			elfwritedynentsym(s, DT_JMPREL, sy);
		}
	} else {
		sy = linklookup(ctxt, ".rel.plt", 0);
		if(sy->size > 0) {
			elfwritedynent(s, DT_PLTREL, DT_REL);
			elfwritedynentsymsize(s, DT_PLTRELSZ, sy);
			elfwritedynentsym(s, DT_JMPREL, sy);
		}
	}

	elfwritedynent(s, DT_NULL, 0);
}

ElfPhdr*
elfphload(Segment *seg)
{
	ElfPhdr *ph;
	
	ph = newElfPhdr();
	ph->type = PT_LOAD;
	if(seg->rwx & 4)
		ph->flags |= PF_R;
	if(seg->rwx & 2)
		ph->flags |= PF_W;
	if(seg->rwx & 1)
		ph->flags |= PF_X;
	ph->vaddr = seg->vaddr;
	ph->paddr = seg->vaddr;
	ph->memsz = seg->len;
	ph->off = seg->fileoff;
	ph->filesz = seg->filelen;
	ph->align = INITRND;
	
	return ph;
}

ElfShdr*
elfshname(char *name)
{
	int i, off;
	ElfShdr *sh;
	
	for(i=0; i<nelfstr; i++) {
		if(strcmp(name, elfstr[i].s) == 0) {
			off = elfstr[i].off;
			goto found;
		}
	}
	diag("cannot find elf name %s", name);
	errorexit();
	return nil;

found:
	for(i=0; i<hdr.shnum; i++) {
		sh = shdr[i];
		if(sh->name == off)
			return sh;
	}
	
	sh = newElfShdr(off);
	return sh;
}

ElfShdr*
elfshalloc(Section *sect)
{
	ElfShdr *sh;
	
	sh = elfshname(sect->name);
	sect->elfsect = sh;
	return sh;
}

ElfShdr*
elfshbits(Section *sect)
{
	ElfShdr *sh;
	
	sh = elfshalloc(sect);
	if(sh->type > 0)
		return sh;

	if(sect->vaddr < sect->seg->vaddr + sect->seg->filelen)
		sh->type = SHT_PROGBITS;
	else
		sh->type = SHT_NOBITS;
	sh->flags = SHF_ALLOC;
	if(sect->rwx & 1)
		sh->flags |= SHF_EXECINSTR;
	if(sect->rwx & 2)
		sh->flags |= SHF_WRITE;
	if(strcmp(sect->name, ".tbss") == 0) {
		if(strcmp(goos, "android") != 0)
			sh->flags |= SHF_TLS; // no TLS on android
		sh->type = SHT_NOBITS;
	}
	if(linkmode != LinkExternal)
		sh->addr = sect->vaddr;
	sh->addralign = sect->align;
	sh->size = sect->len;
	sh->off = sect->seg->fileoff + sect->vaddr - sect->seg->vaddr;

	return sh;
}

ElfShdr*
elfshreloc(Section *sect)
{
	int typ;
	ElfShdr *sh;
	char *prefix;
	char buf[100];
	
	// If main section is SHT_NOBITS, nothing to relocate.
	// Also nothing to relocate in .shstrtab.
	if(sect->vaddr >= sect->seg->vaddr + sect->seg->filelen)
		return nil;
	if(strcmp(sect->name, ".shstrtab") == 0 || strcmp(sect->name, ".tbss") == 0)
		return nil;

	if(thechar == '6') {
		prefix = ".rela";
		typ = SHT_RELA;
	} else {
		prefix = ".rel";
		typ = SHT_REL;
	}

	snprint(buf, sizeof buf, "%s%s", prefix, sect->name);
	sh = elfshname(buf);
	sh->type = typ;
	sh->entsize = RegSize*(2+(typ==SHT_RELA));
	sh->link = elfshname(".symtab")->shnum;
	sh->info = sect->elfsect->shnum;
	sh->off = sect->reloff;
	sh->size = sect->rellen;
	sh->addralign = RegSize;
	return sh;
}

void
elfrelocsect(Section *sect, LSym *first)
{
	LSym *sym;
	int32 eaddr;
	Reloc *r;

	// If main section is SHT_NOBITS, nothing to relocate.
	// Also nothing to relocate in .shstrtab.
	if(sect->vaddr >= sect->seg->vaddr + sect->seg->filelen)
		return;
	if(strcmp(sect->name, ".shstrtab") == 0)
		return;

	sect->reloff = cpos();
	for(sym = first; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= sect->vaddr)
			break;
	}
	
	eaddr = sect->vaddr + sect->len;
	for(; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= eaddr)
			break;
		ctxt->cursym = sym;
		
		for(r = sym->r; r < sym->r+sym->nr; r++) {
			if(r->done)
				continue;
			if(r->xsym == nil) {
				diag("missing xsym in relocation");
				continue;
			}
			if(r->xsym->elfsym == 0)
				diag("reloc %d to non-elf symbol %s (outer=%s) %d", r->type, r->sym->name, r->xsym->name, r->sym->type);
			if(elfreloc1(r, sym->value+r->off - sect->vaddr) < 0)
				diag("unsupported obj reloc %d/%d to %s", r->type, r->siz, r->sym->name);
		}
	}
		
	sect->rellen = cpos() - sect->reloff;
}	
	
void
elfemitreloc(void)
{
	Section *sect;

	while(cpos()&7)
		cput(0);

	elfrelocsect(segtext.sect, ctxt->textp);
	for(sect=segtext.sect->next; sect!=nil; sect=sect->next)
		elfrelocsect(sect, datap);	
	for(sect=segrodata.sect; sect!=nil; sect=sect->next)
		elfrelocsect(sect, datap);	
	for(sect=segdata.sect; sect!=nil; sect=sect->next)
		elfrelocsect(sect, datap);	
}

void
doelf(void)
{
	LSym *s, *shstrtab, *dynstr;

	if(!iself)
		return;

	/* predefine strings we need for section headers */
	shstrtab = linklookup(ctxt, ".shstrtab", 0);
	shstrtab->type = SELFROSECT;
	shstrtab->reachable = 1;

	addstring(shstrtab, "");
	addstring(shstrtab, ".text");
	addstring(shstrtab, ".noptrdata");
	addstring(shstrtab, ".data");
	addstring(shstrtab, ".bss");
	addstring(shstrtab, ".noptrbss");
	// generate .tbss section (except for OpenBSD where it's not supported)
	// for dynamic internal linker or external linking, so that various
	// binutils could correctly calculate PT_TLS size.
	// see http://golang.org/issue/5200.
	if(HEADTYPE != Hopenbsd)
	if(!debug['d'] || linkmode == LinkExternal)
		addstring(shstrtab, ".tbss");
	if(HEADTYPE == Hnetbsd)
		addstring(shstrtab, ".note.netbsd.ident");
	if(HEADTYPE == Hopenbsd)
		addstring(shstrtab, ".note.openbsd.ident");
	if(buildinfolen > 0)
		addstring(shstrtab, ".note.gnu.build-id");
	addstring(shstrtab, ".elfdata");
	addstring(shstrtab, ".rodata");
	addstring(shstrtab, ".typelink");
	addstring(shstrtab, ".gosymtab");
	addstring(shstrtab, ".gopclntab");
	
	if(linkmode == LinkExternal) {
		debug_s = debug['s'];
		debug['s'] = 0;
		debug['d'] = 1;

		if(thechar == '6') {
			addstring(shstrtab, ".rela.text");
			addstring(shstrtab, ".rela.rodata");
			addstring(shstrtab, ".rela.typelink");
			addstring(shstrtab, ".rela.gosymtab");
			addstring(shstrtab, ".rela.gopclntab");
			addstring(shstrtab, ".rela.noptrdata");
			addstring(shstrtab, ".rela.data");
		} else {
			addstring(shstrtab, ".rel.text");
			addstring(shstrtab, ".rel.rodata");
			addstring(shstrtab, ".rel.typelink");
			addstring(shstrtab, ".rel.gosymtab");
			addstring(shstrtab, ".rel.gopclntab");
			addstring(shstrtab, ".rel.noptrdata");
			addstring(shstrtab, ".rel.data");
		}
		// add a .note.GNU-stack section to mark the stack as non-executable
		addstring(shstrtab, ".note.GNU-stack");
	}

	if(flag_shared) {
		addstring(shstrtab, ".init_array");
		if(thechar == '6')
			addstring(shstrtab, ".rela.init_array");
		else
			addstring(shstrtab, ".rel.init_array");
	}

	if(!debug['s']) {
		addstring(shstrtab, ".symtab");
		addstring(shstrtab, ".strtab");
		dwarfaddshstrings(shstrtab);
	}
	addstring(shstrtab, ".shstrtab");

	if(!debug['d']) {	/* -d suppresses dynamic loader format */
		addstring(shstrtab, ".interp");
		addstring(shstrtab, ".hash");
		addstring(shstrtab, ".got");
		addstring(shstrtab, ".got.plt");
		addstring(shstrtab, ".dynamic");
		addstring(shstrtab, ".dynsym");
		addstring(shstrtab, ".dynstr");
		if(thechar == '6') {
			addstring(shstrtab, ".rela");
			addstring(shstrtab, ".rela.plt");
		} else {
			addstring(shstrtab, ".rel");
			addstring(shstrtab, ".rel.plt");
		}
		addstring(shstrtab, ".plt");
		addstring(shstrtab, ".gnu.version");
		addstring(shstrtab, ".gnu.version_r");

		/* dynamic symbol table - first entry all zeros */
		s = linklookup(ctxt, ".dynsym", 0);
		s->type = SELFROSECT;
		s->reachable = 1;
		if(thechar == '6')
			s->size += ELF64SYMSIZE;
		else
			s->size += ELF32SYMSIZE;

		/* dynamic string table */
		s = linklookup(ctxt, ".dynstr", 0);
		s->type = SELFROSECT;
		s->reachable = 1;
		if(s->size == 0)
			addstring(s, "");
		dynstr = s;

		/* relocation table */
		if(thechar == '6')
			s = linklookup(ctxt, ".rela", 0);
		else
			s = linklookup(ctxt, ".rel", 0);
		s->reachable = 1;
		s->type = SELFROSECT;

		/* global offset table */
		s = linklookup(ctxt, ".got", 0);
		s->reachable = 1;
		s->type = SELFSECT; // writable

		/* hash */
		s = linklookup(ctxt, ".hash", 0);
		s->reachable = 1;
		s->type = SELFROSECT;

		s = linklookup(ctxt, ".got.plt", 0);
		s->reachable = 1;
		s->type = SELFSECT; // writable

		s = linklookup(ctxt, ".plt", 0);
		s->reachable = 1;
		s->type = SELFRXSECT;
		
		elfsetupplt();
		
		if(thechar == '6')
			s = linklookup(ctxt, ".rela.plt", 0);
		else
			s = linklookup(ctxt, ".rel.plt", 0);
		s->reachable = 1;
		s->type = SELFROSECT;
		
		s = linklookup(ctxt, ".gnu.version", 0);
		s->reachable = 1;
		s->type = SELFROSECT;
		
		s = linklookup(ctxt, ".gnu.version_r", 0);
		s->reachable = 1;
		s->type = SELFROSECT;

		/* define dynamic elf table */
		s = linklookup(ctxt, ".dynamic", 0);
		s->reachable = 1;
		s->type = SELFSECT; // writable

		/*
		 * .dynamic table
		 */
		elfwritedynentsym(s, DT_HASH, linklookup(ctxt, ".hash", 0));
		elfwritedynentsym(s, DT_SYMTAB, linklookup(ctxt, ".dynsym", 0));
		if(thechar == '6')
			elfwritedynent(s, DT_SYMENT, ELF64SYMSIZE);
		else
			elfwritedynent(s, DT_SYMENT, ELF32SYMSIZE);
		elfwritedynentsym(s, DT_STRTAB, linklookup(ctxt, ".dynstr", 0));
		elfwritedynentsymsize(s, DT_STRSZ, linklookup(ctxt, ".dynstr", 0));
		if(thechar == '6') {
			elfwritedynentsym(s, DT_RELA, linklookup(ctxt, ".rela", 0));
			elfwritedynentsymsize(s, DT_RELASZ, linklookup(ctxt, ".rela", 0));
			elfwritedynent(s, DT_RELAENT, ELF64RELASIZE);
		} else {
			elfwritedynentsym(s, DT_REL, linklookup(ctxt, ".rel", 0));
			elfwritedynentsymsize(s, DT_RELSZ, linklookup(ctxt, ".rel", 0));
			elfwritedynent(s, DT_RELENT, ELF32RELSIZE);
		}
		if(rpath)
			elfwritedynent(s, DT_RUNPATH, addstring(dynstr, rpath));
		
		elfwritedynentsym(s, DT_PLTGOT, linklookup(ctxt, ".got.plt", 0));

		// Solaris dynamic linker can't handle an empty .rela.plt if
		// DT_JMPREL is emitted so we have to defer generation of DT_PLTREL,
		// DT_PLTRELSZ, and DT_JMPREL dynamic entries until after we know the
		// size of .rel(a).plt section.
		elfwritedynent(s, DT_DEBUG, 0);

		// Do not write DT_NULL.  elfdynhash will finish it.
	}
}

void
shsym(ElfShdr *sh, LSym *s)
{
	vlong addr;
	addr = symaddr(s);
	if(sh->flags&SHF_ALLOC)
		sh->addr = addr;
	sh->off = datoff(addr);
	sh->size = s->size;
}

void
phsh(ElfPhdr *ph, ElfShdr *sh)
{
	ph->vaddr = sh->addr;
	ph->paddr = ph->vaddr;
	ph->off = sh->off;
	ph->filesz = sh->size;
	ph->memsz = sh->size;
	ph->align = sh->addralign;
}

void
asmbelfsetup(void)
{
	Section *sect;

	/* This null SHdr must appear before all others */
	elfshname("");
	
	for(sect=segtext.sect; sect!=nil; sect=sect->next)
		elfshalloc(sect);
	for(sect=segrodata.sect; sect!=nil; sect=sect->next)
		elfshalloc(sect);
	for(sect=segdata.sect; sect!=nil; sect=sect->next)
		elfshalloc(sect);
}

void
asmbelf(vlong symo)
{
	vlong a, o;
	vlong startva, resoff;
	ElfEhdr *eh;
	ElfPhdr *ph, *pph, *pnote;
	ElfShdr *sh;
	Section *sect;

	eh = getElfEhdr();
	switch(thechar) {
	default:
		diag("unknown architecture in asmbelf");
		errorexit();
	case '5':
		eh->machine = EM_ARM;
		break;
	case '6':
		eh->machine = EM_X86_64;
		break;
	case '8':
		eh->machine = EM_386;
		break;
	}

	startva = INITTEXT - HEADR;
	resoff = ELFRESERVE;
	
	pph = nil;
	if(linkmode == LinkExternal) {
		/* skip program headers */
		eh->phoff = 0;
		eh->phentsize = 0;
		goto elfobj;
	}

	/* program header info */
	pph = newElfPhdr();
	pph->type = PT_PHDR;
	pph->flags = PF_R;
	pph->off = eh->ehsize;
	pph->vaddr = INITTEXT - HEADR + pph->off;
	pph->paddr = INITTEXT - HEADR + pph->off;
	pph->align = INITRND;

	/*
	 * PHDR must be in a loaded segment. Adjust the text
	 * segment boundaries downwards to include it.
	 * Except on NaCl where it must not be loaded.
	 */
	if(HEADTYPE != Hnacl) {
		o = segtext.vaddr - pph->vaddr;
		segtext.vaddr -= o;
		segtext.len += o;
		o = segtext.fileoff - pph->off;
		segtext.fileoff -= o;
		segtext.filelen += o;
	}

	if(!debug['d']) {
		/* interpreter */
		sh = elfshname(".interp");
		sh->type = SHT_PROGBITS;
		sh->flags = SHF_ALLOC;
		sh->addralign = 1;
		if(interpreter == nil) {
			switch(HEADTYPE) {
			case Hlinux:
				interpreter = linuxdynld;
				break;
			case Hfreebsd:
				interpreter = freebsddynld;
				break;
			case Hnetbsd:
				interpreter = netbsddynld;
				break;
			case Hopenbsd:
				interpreter = openbsddynld;
				break;
			case Hdragonfly:
				interpreter = dragonflydynld;
				break;
			case Hsolaris:
				interpreter = solarisdynld;
				break;
			}
		}
		resoff -= elfinterp(sh, startva, resoff, interpreter);

		ph = newElfPhdr();
		ph->type = PT_INTERP;
		ph->flags = PF_R;
		phsh(ph, sh);
	}

	pnote = nil;
	if(HEADTYPE == Hnetbsd || HEADTYPE == Hopenbsd) {
		sh = nil;
		switch(HEADTYPE) {
		case Hnetbsd:
			sh = elfshname(".note.netbsd.ident");
			resoff -= elfnetbsdsig(sh, startva, resoff);
			break;
		case Hopenbsd:
			sh = elfshname(".note.openbsd.ident");
			resoff -= elfopenbsdsig(sh, startva, resoff);
			break;
		}

		pnote = newElfPhdr();
		pnote->type = PT_NOTE;
		pnote->flags = PF_R;
		phsh(pnote, sh);
	}

	if(buildinfolen > 0) {
		sh = elfshname(".note.gnu.build-id");
		resoff -= elfbuildinfo(sh, startva, resoff);

		if(pnote == nil) {
			pnote = newElfPhdr();
			pnote->type = PT_NOTE;
			pnote->flags = PF_R;
		}
		phsh(pnote, sh);
	}

	// Additions to the reserved area must be above this line.
	USED(resoff);

	elfphload(&segtext);
	if(segrodata.sect != nil)
		elfphload(&segrodata);
	elfphload(&segdata);

	/* Dynamic linking sections */
	if(!debug['d']) {	/* -d suppresses dynamic loader format */
		sh = elfshname(".dynsym");
		sh->type = SHT_DYNSYM;
		sh->flags = SHF_ALLOC;
		if(elf64)
			sh->entsize = ELF64SYMSIZE;
		else
			sh->entsize = ELF32SYMSIZE;
		sh->addralign = RegSize;
		sh->link = elfshname(".dynstr")->shnum;
		// sh->info = index of first non-local symbol (number of local symbols)
		shsym(sh, linklookup(ctxt, ".dynsym", 0));

		sh = elfshname(".dynstr");
		sh->type = SHT_STRTAB;
		sh->flags = SHF_ALLOC;
		sh->addralign = 1;
		shsym(sh, linklookup(ctxt, ".dynstr", 0));

		if(elfverneed) {
			sh = elfshname(".gnu.version");
			sh->type = SHT_GNU_VERSYM;
			sh->flags = SHF_ALLOC;
			sh->addralign = 2;
			sh->link = elfshname(".dynsym")->shnum;
			sh->entsize = 2;
			shsym(sh, linklookup(ctxt, ".gnu.version", 0));
			
			sh = elfshname(".gnu.version_r");
			sh->type = SHT_GNU_VERNEED;
			sh->flags = SHF_ALLOC;
			sh->addralign = RegSize;
			sh->info = elfverneed;
			sh->link = elfshname(".dynstr")->shnum;
			shsym(sh, linklookup(ctxt, ".gnu.version_r", 0));
		}

		switch(eh->machine) {
		case EM_X86_64:
			sh = elfshname(".rela.plt");
			sh->type = SHT_RELA;
			sh->flags = SHF_ALLOC;
			sh->entsize = ELF64RELASIZE;
			sh->addralign = RegSize;
			sh->link = elfshname(".dynsym")->shnum;
			sh->info = elfshname(".plt")->shnum;
			shsym(sh, linklookup(ctxt, ".rela.plt", 0));

			sh = elfshname(".rela");
			sh->type = SHT_RELA;
			sh->flags = SHF_ALLOC;
			sh->entsize = ELF64RELASIZE;
			sh->addralign = 8;
			sh->link = elfshname(".dynsym")->shnum;
			shsym(sh, linklookup(ctxt, ".rela", 0));
			break;
		
		default:
			sh = elfshname(".rel.plt");
			sh->type = SHT_REL;
			sh->flags = SHF_ALLOC;
			sh->entsize = ELF32RELSIZE;
			sh->link = elfshname(".dynsym")->shnum;
			shsym(sh, linklookup(ctxt, ".rel.plt", 0));

			sh = elfshname(".rel");
			sh->type = SHT_REL;
			sh->flags = SHF_ALLOC;
			sh->entsize = ELF32RELSIZE;
			sh->addralign = 4;
			sh->link = elfshname(".dynsym")->shnum;
			shsym(sh, linklookup(ctxt, ".rel", 0));
			break;
		}

		sh = elfshname(".plt");
		sh->type = SHT_PROGBITS;
		sh->flags = SHF_ALLOC+SHF_EXECINSTR;
		if(eh->machine == EM_X86_64)
			sh->entsize = 16;
		else
			sh->entsize = 4;
		sh->addralign = 4;
		shsym(sh, linklookup(ctxt, ".plt", 0));

		sh = elfshname(".got");
		sh->type = SHT_PROGBITS;
		sh->flags = SHF_ALLOC+SHF_WRITE;
		sh->entsize = RegSize;
		sh->addralign = RegSize;
		shsym(sh, linklookup(ctxt, ".got", 0));

		sh = elfshname(".got.plt");
		sh->type = SHT_PROGBITS;
		sh->flags = SHF_ALLOC+SHF_WRITE;
		sh->entsize = RegSize;
		sh->addralign = RegSize;
		shsym(sh, linklookup(ctxt, ".got.plt", 0));
		
		sh = elfshname(".hash");
		sh->type = SHT_HASH;
		sh->flags = SHF_ALLOC;
		sh->entsize = 4;
		sh->addralign = RegSize;
		sh->link = elfshname(".dynsym")->shnum;
		shsym(sh, linklookup(ctxt, ".hash", 0));

		/* sh and PT_DYNAMIC for .dynamic section */
		sh = elfshname(".dynamic");
		sh->type = SHT_DYNAMIC;
		sh->flags = SHF_ALLOC+SHF_WRITE;
		sh->entsize = 2*RegSize;
		sh->addralign = RegSize;
		sh->link = elfshname(".dynstr")->shnum;
		shsym(sh, linklookup(ctxt, ".dynamic", 0));
		ph = newElfPhdr();
		ph->type = PT_DYNAMIC;
		ph->flags = PF_R + PF_W;
		phsh(ph, sh);
		
		/*
		 * Thread-local storage segment (really just size).
		 */
		// Do not emit PT_TLS for OpenBSD since ld.so(1) does
		// not currently support it. This is handled
		// appropriately in runtime/cgo.
		if(ctxt->tlsoffset != 0 && HEADTYPE != Hopenbsd) {
			ph = newElfPhdr();
			ph->type = PT_TLS;
			ph->flags = PF_R;
			ph->memsz = -ctxt->tlsoffset;
			ph->align = RegSize;
		}
	}

	if(HEADTYPE == Hlinux) {
		ph = newElfPhdr();
		ph->type = PT_GNU_STACK;
		ph->flags = PF_W+PF_R;
		ph->align = RegSize;
		
		ph = newElfPhdr();
		ph->type = PT_PAX_FLAGS;
		ph->flags = 0x2a00; // mprotect, randexec, emutramp disabled
		ph->align = RegSize;
	}

elfobj:
	sh = elfshname(".shstrtab");
	sh->type = SHT_STRTAB;
	sh->addralign = 1;
	shsym(sh, linklookup(ctxt, ".shstrtab", 0));
	eh->shstrndx = sh->shnum;

	// put these sections early in the list
	if(!debug['s']) {
		elfshname(".symtab");
		elfshname(".strtab");
	}

	for(sect=segtext.sect; sect!=nil; sect=sect->next)
		elfshbits(sect);
	for(sect=segrodata.sect; sect!=nil; sect=sect->next)
		elfshbits(sect);
	for(sect=segdata.sect; sect!=nil; sect=sect->next)
		elfshbits(sect);

	if(linkmode == LinkExternal) {
		for(sect=segtext.sect; sect!=nil; sect=sect->next)
			elfshreloc(sect);
		for(sect=segrodata.sect; sect!=nil; sect=sect->next)
			elfshreloc(sect);
		for(sect=segdata.sect; sect!=nil; sect=sect->next)
			elfshreloc(sect);
		// add a .note.GNU-stack section to mark the stack as non-executable
		sh = elfshname(".note.GNU-stack");
		sh->type = SHT_PROGBITS;
		sh->addralign = 1;
		sh->flags = 0;
	}

	// generate .tbss section for dynamic internal linking (except for OpenBSD)
	// external linking generates .tbss in data.c
	if(linkmode == LinkInternal && !debug['d'] && HEADTYPE != Hopenbsd) {
		sh = elfshname(".tbss");
		sh->type = SHT_NOBITS;
		sh->addralign = RegSize;
		sh->size = -ctxt->tlsoffset;
		sh->flags = SHF_ALLOC | SHF_TLS | SHF_WRITE;
	}

	if(!debug['s']) {
		sh = elfshname(".symtab");
		sh->type = SHT_SYMTAB;
		sh->off = symo;
		sh->size = symsize;
		sh->addralign = RegSize;
		sh->entsize = 8+2*RegSize;
		sh->link = elfshname(".strtab")->shnum;
		sh->info = elfglobalsymndx;

		sh = elfshname(".strtab");
		sh->type = SHT_STRTAB;
		sh->off = symo+symsize;
		sh->size = elfstrsize;
		sh->addralign = 1;

		dwarfaddelfheaders();
	}

	/* Main header */
	eh->ident[EI_MAG0] = '\177';
	eh->ident[EI_MAG1] = 'E';
	eh->ident[EI_MAG2] = 'L';
	eh->ident[EI_MAG3] = 'F';
	if(HEADTYPE == Hfreebsd)
		eh->ident[EI_OSABI] = ELFOSABI_FREEBSD;
	else if(HEADTYPE == Hnetbsd)
		eh->ident[EI_OSABI] = ELFOSABI_NETBSD;
	else if(HEADTYPE == Hopenbsd)
		eh->ident[EI_OSABI] = ELFOSABI_OPENBSD;
	else if(HEADTYPE == Hdragonfly)
		eh->ident[EI_OSABI] = ELFOSABI_NONE;
	if(elf64)
		eh->ident[EI_CLASS] = ELFCLASS64;
	else
		eh->ident[EI_CLASS] = ELFCLASS32;
	eh->ident[EI_DATA] = ELFDATA2LSB;
	eh->ident[EI_VERSION] = EV_CURRENT;

	if(linkmode == LinkExternal)
		eh->type = ET_REL;
	else
		eh->type = ET_EXEC;

	if(linkmode != LinkExternal)
		eh->entry = entryvalue();

	eh->version = EV_CURRENT;

	if(pph != nil) {
		pph->filesz = eh->phnum * eh->phentsize;
		pph->memsz = pph->filesz;
	}

	cseek(0);
	a = 0;
	a += elfwritehdr();
	a += elfwritephdrs();
	a += elfwriteshdrs();
	if(!debug['d'])
		a += elfwriteinterp();
	if(linkmode != LinkExternal) {
		if(HEADTYPE == Hnetbsd)
			a += elfwritenetbsdsig();
		if(HEADTYPE == Hopenbsd)
			a += elfwriteopenbsdsig();
		if(buildinfolen > 0)
			a += elfwritebuildinfo();
	}
	if(a > ELFRESERVE)	
		diag("ELFRESERVE too small: %lld > %d", a, ELFRESERVE);
}
                                                                                                                                 root/go1.4/src/cmd/ld/elf.h                                                                         0100644 0000000 0000000 00000111662 12600426226 013737  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
 * Derived from:
 * $FreeBSD: src/sys/sys/elf32.h,v 1.8.14.1 2005/12/30 22:13:58 marcel Exp $
 * $FreeBSD: src/sys/sys/elf64.h,v 1.10.14.1 2005/12/30 22:13:58 marcel Exp $
 * $FreeBSD: src/sys/sys/elf_common.h,v 1.15.8.1 2005/12/30 22:13:58 marcel Exp $
 * $FreeBSD: src/sys/alpha/include/elf.h,v 1.14 2003/09/25 01:10:22 peter Exp $
 * $FreeBSD: src/sys/amd64/include/elf.h,v 1.18 2004/08/03 08:21:48 dfr Exp $
 * $FreeBSD: src/sys/arm/include/elf.h,v 1.5.2.1 2006/06/30 21:42:52 cognet Exp $
 * $FreeBSD: src/sys/i386/include/elf.h,v 1.16 2004/08/02 19:12:17 dfr Exp $
 * $FreeBSD: src/sys/powerpc/include/elf.h,v 1.7 2004/11/02 09:47:01 ssouhlal Exp $
 * $FreeBSD: src/sys/sparc64/include/elf.h,v 1.12 2003/09/25 01:10:26 peter Exp $
 *
 * Copyright (c) 1996-1998 John D. Polstra.  All rights reserved.
 * Copyright (c) 2001 David E. O'Brien
 * Portions Copyright 2009 The Go Authors.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * ELF definitions that are independent of architecture or word size.
 */

/*
 * Note header.  The ".note" section contains an array of notes.  Each
 * begins with this header, aligned to a word boundary.  Immediately
 * following the note header is n_namesz bytes of name, padded to the
 * next word boundary.  Then comes n_descsz bytes of descriptor, again
 * padded to a word boundary.  The values of n_namesz and n_descsz do
 * not include the padding.
 */

typedef struct {
	uint32	n_namesz;	/* Length of name. */
	uint32	n_descsz;	/* Length of descriptor. */
	uint32	n_type;		/* Type of this note. */
} Elf_Note;

/* Indexes into the e_ident array.  Keep synced with
   http://www.sco.com/developer/gabi/ch4.eheader.html */
#define EI_MAG0		0	/* Magic number, byte 0. */
#define EI_MAG1		1	/* Magic number, byte 1. */
#define EI_MAG2		2	/* Magic number, byte 2. */
#define EI_MAG3		3	/* Magic number, byte 3. */
#define EI_CLASS	4	/* Class of machine. */
#define EI_DATA		5	/* Data format. */
#define EI_VERSION	6	/* ELF format version. */
#define EI_OSABI	7	/* Operating system / ABI identification */
#define EI_ABIVERSION	8	/* ABI version */
#define OLD_EI_BRAND	8	/* Start of architecture identification. */
#define EI_PAD		9	/* Start of padding (per SVR4 ABI). */
#define EI_NIDENT	16	/* Size of e_ident array. */

/* Values for the magic number bytes. */
#define ELFMAG0		0x7f
#define ELFMAG1		'E'
#define ELFMAG2		'L'
#define ELFMAG3		'F'
#define ELFMAG		"\177ELF"	/* magic string */
#define SELFMAG		4		/* magic string size */

/* Values for e_ident[EI_VERSION] and e_version. */
#define EV_NONE		0
#define EV_CURRENT	1

/* Values for e_ident[EI_CLASS]. */
#define ELFCLASSNONE	0	/* Unknown class. */
#define ELFCLASS32	1	/* 32-bit architecture. */
#define ELFCLASS64	2	/* 64-bit architecture. */

/* Values for e_ident[EI_DATA]. */
#define ELFDATANONE	0	/* Unknown data format. */
#define ELFDATA2LSB	1	/* 2's complement little-endian. */
#define ELFDATA2MSB	2	/* 2's complement big-endian. */

/* Values for e_ident[EI_OSABI]. */
#define ELFOSABI_NONE		0	/* UNIX System V ABI */
#define ELFOSABI_HPUX		1	/* HP-UX operating system */
#define ELFOSABI_NETBSD		2	/* NetBSD */
#define ELFOSABI_LINUX		3	/* GNU/Linux */
#define ELFOSABI_HURD		4	/* GNU/Hurd */
#define ELFOSABI_86OPEN		5	/* 86Open common IA32 ABI */
#define ELFOSABI_SOLARIS	6	/* Solaris */
#define ELFOSABI_AIX		7	/* AIX */
#define ELFOSABI_IRIX		8	/* IRIX */
#define ELFOSABI_FREEBSD	9	/* FreeBSD */
#define ELFOSABI_TRU64		10	/* TRU64 UNIX */
#define ELFOSABI_MODESTO	11	/* Novell Modesto */
#define ELFOSABI_OPENBSD	12	/* OpenBSD */
#define ELFOSABI_OPENVMS	13	/* Open VMS */
#define ELFOSABI_NSK		14	/* HP Non-Stop Kernel */
#define ELFOSABI_ARM		97	/* ARM */
#define ELFOSABI_STANDALONE	255	/* Standalone (embedded) application */

#define ELFOSABI_SYSV		ELFOSABI_NONE	/* symbol used in old spec */
#define ELFOSABI_MONTEREY	ELFOSABI_AIX	/* Monterey */

/* e_ident */
#define IS_ELF(ehdr)	((ehdr).e_ident[EI_MAG0] == ELFMAG0 && \
			 (ehdr).e_ident[EI_MAG1] == ELFMAG1 && \
			 (ehdr).e_ident[EI_MAG2] == ELFMAG2 && \
			 (ehdr).e_ident[EI_MAG3] == ELFMAG3)

/* Values for e_type. */
#define ET_NONE		0	/* Unknown type. */
#define ET_REL		1	/* Relocatable. */
#define ET_EXEC		2	/* Executable. */
#define ET_DYN		3	/* Shared object. */
#define ET_CORE		4	/* Core file. */
#define ET_LOOS		0xfe00	/* First operating system specific. */
#define ET_HIOS		0xfeff	/* Last operating system-specific. */
#define ET_LOPROC	0xff00	/* First processor-specific. */
#define ET_HIPROC	0xffff	/* Last processor-specific. */

/* Values for e_machine. */
#define EM_NONE		0	/* Unknown machine. */
#define EM_M32		1	/* AT&T WE32100. */
#define EM_SPARC	2	/* Sun SPARC. */
#define EM_386		3	/* Intel i386. */
#define EM_68K		4	/* Motorola 68000. */
#define EM_88K		5	/* Motorola 88000. */
#define EM_860		7	/* Intel i860. */
#define EM_MIPS		8	/* MIPS R3000 Big-Endian only. */
#define EM_S370		9	/* IBM System/370. */
#define EM_MIPS_RS3_LE	10	/* MIPS R3000 Little-Endian. */
#define EM_PARISC	15	/* HP PA-RISC. */
#define EM_VPP500	17	/* Fujitsu VPP500. */
#define EM_SPARC32PLUS	18	/* SPARC v8plus. */
#define EM_960		19	/* Intel 80960. */
#define EM_PPC		20	/* PowerPC 32-bit. */
#define EM_PPC64	21	/* PowerPC 64-bit. */
#define EM_S390		22	/* IBM System/390. */
#define EM_V800		36	/* NEC V800. */
#define EM_FR20		37	/* Fujitsu FR20. */
#define EM_RH32		38	/* TRW RH-32. */
#define EM_RCE		39	/* Motorola RCE. */
#define EM_ARM		40	/* ARM. */
#define EM_SH		42	/* Hitachi SH. */
#define EM_SPARCV9	43	/* SPARC v9 64-bit. */
#define EM_TRICORE	44	/* Siemens TriCore embedded processor. */
#define EM_ARC		45	/* Argonaut RISC Core. */
#define EM_H8_300	46	/* Hitachi H8/300. */
#define EM_H8_300H	47	/* Hitachi H8/300H. */
#define EM_H8S		48	/* Hitachi H8S. */
#define EM_H8_500	49	/* Hitachi H8/500. */
#define EM_IA_64	50	/* Intel IA-64 Processor. */
#define EM_MIPS_X	51	/* Stanford MIPS-X. */
#define EM_COLDFIRE	52	/* Motorola ColdFire. */
#define EM_68HC12	53	/* Motorola M68HC12. */
#define EM_MMA		54	/* Fujitsu MMA. */
#define EM_PCP		55	/* Siemens PCP. */
#define EM_NCPU		56	/* Sony nCPU. */
#define EM_NDR1		57	/* Denso NDR1 microprocessor. */
#define EM_STARCORE	58	/* Motorola Star*Core processor. */
#define EM_ME16		59	/* Toyota ME16 processor. */
#define EM_ST100	60	/* STMicroelectronics ST100 processor. */
#define EM_TINYJ	61	/* Advanced Logic Corp. TinyJ processor. */
#define EM_X86_64	62	/* Advanced Micro Devices x86-64 */

/* Non-standard or deprecated. */
#define EM_486		6	/* Intel i486. */
#define EM_MIPS_RS4_BE	10	/* MIPS R4000 Big-Endian */
#define EM_ALPHA_STD	41	/* Digital Alpha (standard value). */
#define EM_ALPHA	0x9026	/* Alpha (written in the absence of an ABI) */

/* Special section indexes. */
#define SHN_UNDEF	     0		/* Undefined, missing, irrelevant. */
#define SHN_LORESERVE	0xff00		/* First of reserved range. */
#define SHN_LOPROC	0xff00		/* First processor-specific. */
#define SHN_HIPROC	0xff1f		/* Last processor-specific. */
#define SHN_LOOS	0xff20		/* First operating system-specific. */
#define SHN_HIOS	0xff3f		/* Last operating system-specific. */
#define SHN_ABS		0xfff1		/* Absolute values. */
#define SHN_COMMON	0xfff2		/* Common data. */
#define SHN_XINDEX	0xffff		/* Escape -- index stored elsewhere. */
#define SHN_HIRESERVE	0xffff		/* Last of reserved range. */

/* sh_type */
#define SHT_NULL		0	/* inactive */
#define SHT_PROGBITS		1	/* program defined information */
#define SHT_SYMTAB		2	/* symbol table section */
#define SHT_STRTAB		3	/* string table section */
#define SHT_RELA		4	/* relocation section with addends */
#define SHT_HASH		5	/* symbol hash table section */
#define SHT_DYNAMIC		6	/* dynamic section */
#define SHT_NOTE		7	/* note section */
#define SHT_NOBITS		8	/* no space section */
#define SHT_REL			9	/* relocation section - no addends */
#define SHT_SHLIB		10	/* reserved - purpose unknown */
#define SHT_DYNSYM		11	/* dynamic symbol table section */
#define SHT_INIT_ARRAY		14	/* Initialization function pointers. */
#define SHT_FINI_ARRAY		15	/* Termination function pointers. */
#define SHT_PREINIT_ARRAY	16	/* Pre-initialization function ptrs. */
#define SHT_GROUP		17	/* Section group. */
#define SHT_SYMTAB_SHNDX	18	/* Section indexes (see SHN_XINDEX). */
#define SHT_LOOS	0x60000000	/* First of OS specific semantics */
#define SHT_HIOS	0x6fffffff	/* Last of OS specific semantics */
#define SHT_GNU_VERDEF	0x6ffffffd
#define SHT_GNU_VERNEED	0x6ffffffe
#define SHT_GNU_VERSYM	0x6fffffff
#define SHT_LOPROC	0x70000000	/* reserved range for processor */
#define SHT_HIPROC	0x7fffffff	/* specific section header types */
#define SHT_LOUSER	0x80000000	/* reserved range for application */
#define SHT_HIUSER	0xffffffff	/* specific indexes */

/* Flags for sh_flags. */
#define SHF_WRITE		0x1	/* Section contains writable data. */
#define SHF_ALLOC		0x2	/* Section occupies memory. */
#define SHF_EXECINSTR		0x4	/* Section contains instructions. */
#define SHF_MERGE		0x10	/* Section may be merged. */
#define SHF_STRINGS		0x20	/* Section contains strings. */
#define SHF_INFO_LINK		0x40	/* sh_info holds section index. */
#define SHF_LINK_ORDER		0x80	/* Special ordering requirements. */
#define SHF_OS_NONCONFORMING	0x100	/* OS-specific processing required. */
#define SHF_GROUP		0x200	/* Member of section group. */
#define SHF_TLS			0x400	/* Section contains TLS data. */
#define SHF_MASKOS	0x0ff00000	/* OS-specific semantics. */
#define SHF_MASKPROC	0xf0000000	/* Processor-specific semantics. */

/* Values for p_type. */
#define PT_NULL		0	/* Unused entry. */
#define PT_LOAD		1	/* Loadable segment. */
#define PT_DYNAMIC	2	/* Dynamic linking information segment. */
#define PT_INTERP	3	/* Pathname of interpreter. */
#define PT_NOTE		4	/* Auxiliary information. */
#define PT_SHLIB	5	/* Reserved (not used). */
#define PT_PHDR		6	/* Location of program header itself. */
#define PT_TLS		7	/* Thread local storage segment */
#define PT_LOOS		0x60000000	/* First OS-specific. */
#define PT_HIOS		0x6fffffff	/* Last OS-specific. */
#define PT_LOPROC	0x70000000	/* First processor-specific type. */
#define PT_HIPROC	0x7fffffff	/* Last processor-specific type. */
#define PT_GNU_STACK	0x6474e551
#define PT_PAX_FLAGS	0x65041580

/* Values for p_flags. */
#define PF_X		0x1		/* Executable. */
#define PF_W		0x2		/* Writable. */
#define PF_R		0x4		/* Readable. */
#define PF_MASKOS	0x0ff00000	/* Operating system-specific. */
#define PF_MASKPROC	0xf0000000	/* Processor-specific. */

/* Values for d_tag. */
#define DT_NULL		0	/* Terminating entry. */
/* String table offset of a needed shared library. */
#define DT_NEEDED	1
#define DT_PLTRELSZ	2	/* Total size in bytes of PLT relocations. */
#define DT_PLTGOT	3	/* Processor-dependent address. */
#define DT_HASH		4	/* Address of symbol hash table. */
#define DT_STRTAB	5	/* Address of string table. */
#define DT_SYMTAB	6	/* Address of symbol table. */
#define DT_RELA		7	/* Address of ElfNN_Rela relocations. */
#define DT_RELASZ	8	/* Total size of ElfNN_Rela relocations. */
#define DT_RELAENT	9	/* Size of each ElfNN_Rela relocation entry. */
#define DT_STRSZ	10	/* Size of string table. */
#define DT_SYMENT	11	/* Size of each symbol table entry. */
#define DT_INIT		12	/* Address of initialization function. */
#define DT_FINI		13	/* Address of finalization function. */
/* String table offset of shared object name. */
#define DT_SONAME	14
#define DT_RPATH	15	/* String table offset of library path. [sup] */
#define DT_SYMBOLIC	16	/* Indicates "symbolic" linking. [sup] */
#define DT_REL		17	/* Address of ElfNN_Rel relocations. */
#define DT_RELSZ	18	/* Total size of ElfNN_Rel relocations. */
#define DT_RELENT	19	/* Size of each ElfNN_Rel relocation. */
#define DT_PLTREL	20	/* Type of relocation used for PLT. */
#define DT_DEBUG	21	/* Reserved (not used). */
/* Indicates there may be relocations in non-writable segments. [sup] */
#define DT_TEXTREL	22
#define DT_JMPREL	23	/* Address of PLT relocations. */
#define	DT_BIND_NOW	24	/* [sup] */
/* Address of the array of pointers to initialization functions */
#define	DT_INIT_ARRAY	25
/* Address of the array of pointers to termination functions */
#define	DT_FINI_ARRAY	26
/* Size in bytes of the array of initialization functions. */
#define	DT_INIT_ARRAYSZ	27
/* Size in bytes of the array of terminationfunctions. */
#define	DT_FINI_ARRAYSZ	28
/* String table offset of a null-terminated library search path string. */
#define	DT_RUNPATH	29
#define	DT_FLAGS	30	/* Object specific flag values. */
/*	Values greater than or equal to DT_ENCODING and less than
	DT_LOOS follow the rules for the interpretation of the d_un
	union as follows: even == 'd_ptr', even == 'd_val' or none */
#define	DT_ENCODING	32
/* Address of the array of pointers to pre-initialization functions. */
#define	DT_PREINIT_ARRAY 32
/* Size in bytes of the array of pre-initialization functions. */
#define	DT_PREINIT_ARRAYSZ 33
#define	DT_LOOS		0x6000000d	/* First OS-specific */
#define	DT_HIOS		0x6ffff000	/* Last OS-specific */
#define	DT_LOPROC	0x70000000	/* First processor-specific type. */
#define	DT_HIPROC	0x7fffffff	/* Last processor-specific type. */

#define	DT_VERNEED	0x6ffffffe
#define	DT_VERNEEDNUM	0x6fffffff
#define	DT_VERSYM	0x6ffffff0

/* Values for DT_FLAGS */
/*	Indicates that the object being loaded may make reference to
	the $ORIGIN substitution string */
#define	DF_ORIGIN	0x0001
#define	DF_SYMBOLIC	0x0002	/* Indicates "symbolic" linking. */
/* Indicates there may be relocations in non-writable segments. */
#define	DF_TEXTREL	0x0004
/*	Indicates that the dynamic linker should process all
	relocations for the object containing this entry before
	transferring control to the program.  */
#define	DF_BIND_NOW	0x0008
/*	Indicates that the shared object or executable contains code
	using a static thread-local storage scheme.  */
#define	DF_STATIC_TLS	0x0010

/* Values for n_type.  Used in core files. */
#define NT_PRSTATUS	1	/* Process status. */
#define NT_FPREGSET	2	/* Floating point registers. */
#define NT_PRPSINFO	3	/* Process state info. */

/* Symbol Binding - ELFNN_ST_BIND - st_info */
#define STB_LOCAL	0	/* Local symbol */
#define STB_GLOBAL	1	/* Global symbol */
#define STB_WEAK	2	/* like global - lower precedence */
#define STB_LOOS	10	/* Reserved range for operating system */
#define STB_HIOS	12	/*   specific semantics. */
#define STB_LOPROC	13	/* reserved range for processor */
#define STB_HIPROC	15	/*   specific semantics. */

/* Symbol type - ELFNN_ST_TYPE - st_info */
#define STT_NOTYPE	0	/* Unspecified type. */
#define STT_OBJECT	1	/* Data object. */
#define STT_FUNC	2	/* Function. */
#define STT_SECTION	3	/* Section. */
#define STT_FILE	4	/* Source file. */
#define STT_COMMON	5	/* Uninitialized common block. */
#define STT_TLS		6	/* TLS object. */
#define STT_LOOS	10	/* Reserved range for operating system */
#define STT_HIOS	12	/*   specific semantics. */
#define STT_LOPROC	13	/* reserved range for processor */
#define STT_HIPROC	15	/*   specific semantics. */

/* Symbol visibility - ELFNN_ST_VISIBILITY - st_other */
#define STV_DEFAULT	0x0	/* Default visibility (see binding). */
#define STV_INTERNAL	0x1	/* Special meaning in relocatable objects. */
#define STV_HIDDEN	0x2	/* Not visible. */
#define STV_PROTECTED	0x3	/* Visible but not preemptible. */

/* Special symbol table indexes. */
#define STN_UNDEF	0	/* Undefined symbol index. */

/*
 * ELF definitions common to all 32-bit architectures.
 */

typedef uint32	Elf32_Addr;
typedef uint16	Elf32_Half;
typedef uint32	Elf32_Off;
typedef int32		Elf32_Sword;
typedef uint32	Elf32_Word;

typedef Elf32_Word	Elf32_Hashelt;

/* Non-standard class-dependent datatype used for abstraction. */
typedef Elf32_Word	Elf32_Size;
typedef Elf32_Sword	Elf32_Ssize;

/*
 * ELF header.
 */

typedef struct {
	unsigned char	ident[EI_NIDENT];	/* File identification. */
	Elf32_Half	type;		/* File type. */
	Elf32_Half	machine;	/* Machine architecture. */
	Elf32_Word	version;	/* ELF format version. */
	Elf32_Addr	entry;	/* Entry point. */
	Elf32_Off	phoff;	/* Program header file offset. */
	Elf32_Off	shoff;	/* Section header file offset. */
	Elf32_Word	flags;	/* Architecture-specific flags. */
	Elf32_Half	ehsize;	/* Size of ELF header in bytes. */
	Elf32_Half	phentsize;	/* Size of program header entry. */
	Elf32_Half	phnum;	/* Number of program header entries. */
	Elf32_Half	shentsize;	/* Size of section header entry. */
	Elf32_Half	shnum;	/* Number of section header entries. */
	Elf32_Half	shstrndx;	/* Section name strings section. */
} Elf32_Ehdr;

/*
 * Section header.
 */

typedef struct {
	Elf32_Word	name;	/* Section name (index into the
					   section header string table). */
	Elf32_Word	type;	/* Section type. */
	Elf32_Word	flags;	/* Section flags. */
	Elf32_Addr	vaddr;	/* Address in memory image. */
	Elf32_Off	off;	/* Offset in file. */
	Elf32_Word	size;	/* Size in bytes. */
	Elf32_Word	link;	/* Index of a related section. */
	Elf32_Word	info;	/* Depends on section type. */
	Elf32_Word	addralign;	/* Alignment in bytes. */
	Elf32_Word	entsize;	/* Size of each entry in section. */
} Elf32_Shdr;

/*
 * Program header.
 */

typedef struct {
	Elf32_Word	type;		/* Entry type. */
	Elf32_Off	off;	/* File offset of contents. */
	Elf32_Addr	vaddr;	/* Virtual address in memory image. */
	Elf32_Addr	paddr;	/* Physical address (not used). */
	Elf32_Word	filesz;	/* Size of contents in file. */
	Elf32_Word	memsz;	/* Size of contents in memory. */
	Elf32_Word	flags;	/* Access permission flags. */
	Elf32_Word	align;	/* Alignment in memory and file. */
} Elf32_Phdr;

/*
 * Dynamic structure.  The ".dynamic" section contains an array of them.
 */

typedef struct {
	Elf32_Sword	d_tag;		/* Entry type. */
	union {
		Elf32_Word	d_val;	/* Integer value. */
		Elf32_Addr	d_ptr;	/* Address value. */
	} d_un;
} Elf32_Dyn;

/*
 * Relocation entries.
 */

/* Relocations that don't need an addend field. */
typedef struct {
	Elf32_Addr	off;	/* Location to be relocated. */
	Elf32_Word	info;		/* Relocation type and symbol index. */
} Elf32_Rel;

/* Relocations that need an addend field. */
typedef struct {
	Elf32_Addr	off;	/* Location to be relocated. */
	Elf32_Word	info;		/* Relocation type and symbol index. */
	Elf32_Sword	addend;	/* Addend. */
} Elf32_Rela;

/* Macros for accessing the fields of r_info. */
#define ELF32_R_SYM(info)	((info) >> 8)
#define ELF32_R_TYPE(info)	((unsigned char)(info))

/* Macro for constructing r_info from field values. */
#define ELF32_R_INFO(sym, type)	(((sym) << 8) + (unsigned char)(type))

/*
 * Relocation types.
 */

#define	R_X86_64_NONE	0	/* No relocation. */
#define	R_X86_64_64	1	/* Add 64 bit symbol value. */
#define	R_X86_64_PC32	2	/* PC-relative 32 bit signed sym value. */
#define	R_X86_64_GOT32	3	/* PC-relative 32 bit GOT offset. */
#define	R_X86_64_PLT32	4	/* PC-relative 32 bit PLT offset. */
#define	R_X86_64_COPY	5	/* Copy data from shared object. */
#define	R_X86_64_GLOB_DAT 6	/* Set GOT entry to data address. */
#define	R_X86_64_JMP_SLOT 7	/* Set GOT entry to code address. */
#define	R_X86_64_RELATIVE 8	/* Add load address of shared object. */
#define	R_X86_64_GOTPCREL 9	/* Add 32 bit signed pcrel offset to GOT. */
#define	R_X86_64_32	10	/* Add 32 bit zero extended symbol value */
#define	R_X86_64_32S	11	/* Add 32 bit sign extended symbol value */
#define	R_X86_64_16	12	/* Add 16 bit zero extended symbol value */
#define	R_X86_64_PC16	13	/* Add 16 bit signed extended pc relative symbol value */
#define	R_X86_64_8	14	/* Add 8 bit zero extended symbol value */
#define	R_X86_64_PC8	15	/* Add 8 bit signed extended pc relative symbol value */
#define	R_X86_64_DTPMOD64 16	/* ID of module containing symbol */
#define	R_X86_64_DTPOFF64 17	/* Offset in TLS block */
#define	R_X86_64_TPOFF64 18	/* Offset in static TLS block */
#define	R_X86_64_TLSGD	19	/* PC relative offset to GD GOT entry */
#define	R_X86_64_TLSLD	20	/* PC relative offset to LD GOT entry */
#define	R_X86_64_DTPOFF32 21	/* Offset in TLS block */
#define	R_X86_64_GOTTPOFF 22	/* PC relative offset to IE GOT entry */
#define	R_X86_64_TPOFF32 23	/* Offset in static TLS block */

#define	R_X86_64_COUNT	24	/* Count of defined relocation types. */


#define	R_ALPHA_NONE		0	/* No reloc */
#define	R_ALPHA_REFLONG		1	/* Direct 32 bit */
#define	R_ALPHA_REFQUAD		2	/* Direct 64 bit */
#define	R_ALPHA_GPREL32		3	/* GP relative 32 bit */
#define	R_ALPHA_LITERAL		4	/* GP relative 16 bit w/optimization */
#define	R_ALPHA_LITUSE		5	/* Optimization hint for LITERAL */
#define	R_ALPHA_GPDISP		6	/* Add displacement to GP */
#define	R_ALPHA_BRADDR		7	/* PC+4 relative 23 bit shifted */
#define	R_ALPHA_HINT		8	/* PC+4 relative 16 bit shifted */
#define	R_ALPHA_SREL16		9	/* PC relative 16 bit */
#define	R_ALPHA_SREL32		10	/* PC relative 32 bit */
#define	R_ALPHA_SREL64		11	/* PC relative 64 bit */
#define	R_ALPHA_OP_PUSH		12	/* OP stack push */
#define	R_ALPHA_OP_STORE	13	/* OP stack pop and store */
#define	R_ALPHA_OP_PSUB		14	/* OP stack subtract */
#define	R_ALPHA_OP_PRSHIFT	15	/* OP stack right shift */
#define	R_ALPHA_GPVALUE		16
#define	R_ALPHA_GPRELHIGH	17
#define	R_ALPHA_GPRELLOW	18
#define	R_ALPHA_IMMED_GP_16	19
#define	R_ALPHA_IMMED_GP_HI32	20
#define	R_ALPHA_IMMED_SCN_HI32	21
#define	R_ALPHA_IMMED_BR_HI32	22
#define	R_ALPHA_IMMED_LO32	23
#define	R_ALPHA_COPY		24	/* Copy symbol at runtime */
#define	R_ALPHA_GLOB_DAT	25	/* Create GOT entry */
#define	R_ALPHA_JMP_SLOT	26	/* Create PLT entry */
#define	R_ALPHA_RELATIVE	27	/* Adjust by program base */

#define	R_ALPHA_COUNT		28


#define	R_ARM_NONE		0	/* No relocation. */
#define	R_ARM_PC24		1
#define	R_ARM_ABS32		2
#define	R_ARM_REL32		3
#define	R_ARM_PC13		4
#define	R_ARM_ABS16		5
#define	R_ARM_ABS12		6
#define	R_ARM_THM_ABS5		7
#define	R_ARM_ABS8		8
#define	R_ARM_SBREL32		9
#define	R_ARM_THM_PC22		10
#define	R_ARM_THM_PC8		11
#define	R_ARM_AMP_VCALL9	12
#define	R_ARM_SWI24		13
#define	R_ARM_THM_SWI8		14
#define	R_ARM_XPC25		15
#define	R_ARM_THM_XPC22		16
#define	R_ARM_COPY		20	/* Copy data from shared object. */
#define	R_ARM_GLOB_DAT		21	/* Set GOT entry to data address. */
#define	R_ARM_JUMP_SLOT		22	/* Set GOT entry to code address. */
#define	R_ARM_RELATIVE		23	/* Add load address of shared object. */
#define	R_ARM_GOTOFF		24	/* Add GOT-relative symbol address. */
#define	R_ARM_GOTPC		25	/* Add PC-relative GOT table address. */
#define	R_ARM_GOT32		26	/* Add PC-relative GOT offset. */
#define	R_ARM_PLT32		27	/* Add PC-relative PLT offset. */
#define	R_ARM_CALL		28
#define	R_ARM_JUMP24	29
#define	R_ARM_V4BX		40
#define	R_ARM_GOT_PREL		96
#define	R_ARM_GNU_VTENTRY	100
#define	R_ARM_GNU_VTINHERIT	101
#define	R_ARM_TLS_IE32		107
#define	R_ARM_TLS_LE32		108
#define	R_ARM_RSBREL32		250
#define	R_ARM_THM_RPC22		251
#define	R_ARM_RREL32		252
#define	R_ARM_RABS32		253
#define	R_ARM_RPC24		254
#define	R_ARM_RBASE		255

#define	R_ARM_COUNT		38	/* Count of defined relocation types. */


#define	R_386_NONE	0	/* No relocation. */
#define	R_386_32	1	/* Add symbol value. */
#define	R_386_PC32	2	/* Add PC-relative symbol value. */
#define	R_386_GOT32	3	/* Add PC-relative GOT offset. */
#define	R_386_PLT32	4	/* Add PC-relative PLT offset. */
#define	R_386_COPY	5	/* Copy data from shared object. */
#define	R_386_GLOB_DAT	6	/* Set GOT entry to data address. */
#define	R_386_JMP_SLOT	7	/* Set GOT entry to code address. */
#define	R_386_RELATIVE	8	/* Add load address of shared object. */
#define	R_386_GOTOFF	9	/* Add GOT-relative symbol address. */
#define	R_386_GOTPC	10	/* Add PC-relative GOT table address. */
#define	R_386_TLS_TPOFF	14	/* Negative offset in static TLS block */
#define	R_386_TLS_IE	15	/* Absolute address of GOT for -ve static TLS */
#define	R_386_TLS_GOTIE	16	/* GOT entry for negative static TLS block */
#define	R_386_TLS_LE	17	/* Negative offset relative to static TLS */
#define	R_386_TLS_GD	18	/* 32 bit offset to GOT (index,off) pair */
#define	R_386_TLS_LDM	19	/* 32 bit offset to GOT (index,zero) pair */
#define	R_386_TLS_GD_32	24	/* 32 bit offset to GOT (index,off) pair */
#define	R_386_TLS_GD_PUSH 25	/* pushl instruction for Sun ABI GD sequence */
#define	R_386_TLS_GD_CALL 26	/* call instruction for Sun ABI GD sequence */
#define	R_386_TLS_GD_POP 27	/* popl instruction for Sun ABI GD sequence */
#define	R_386_TLS_LDM_32 28	/* 32 bit offset to GOT (index,zero) pair */
#define	R_386_TLS_LDM_PUSH 29	/* pushl instruction for Sun ABI LD sequence */
#define	R_386_TLS_LDM_CALL 30	/* call instruction for Sun ABI LD sequence */
#define	R_386_TLS_LDM_POP 31	/* popl instruction for Sun ABI LD sequence */
#define	R_386_TLS_LDO_32 32	/* 32 bit offset from start of TLS block */
#define	R_386_TLS_IE_32	33	/* 32 bit offset to GOT static TLS offset entry */
#define	R_386_TLS_LE_32	34	/* 32 bit offset within static TLS block */
#define	R_386_TLS_DTPMOD32 35	/* GOT entry containing TLS index */
#define	R_386_TLS_DTPOFF32 36	/* GOT entry containing TLS offset */
#define	R_386_TLS_TPOFF32 37	/* GOT entry of -ve static TLS offset */

#define	R_386_COUNT	38	/* Count of defined relocation types. */

#define	R_PPC_NONE		0	/* No relocation. */
#define	R_PPC_ADDR32		1
#define	R_PPC_ADDR24		2
#define	R_PPC_ADDR16		3
#define	R_PPC_ADDR16_LO		4
#define	R_PPC_ADDR16_HI		5
#define	R_PPC_ADDR16_HA		6
#define	R_PPC_ADDR14		7
#define	R_PPC_ADDR14_BRTAKEN	8
#define	R_PPC_ADDR14_BRNTAKEN	9
#define	R_PPC_REL24		10
#define	R_PPC_REL14		11
#define	R_PPC_REL14_BRTAKEN	12
#define	R_PPC_REL14_BRNTAKEN	13
#define	R_PPC_GOT16		14
#define	R_PPC_GOT16_LO		15
#define	R_PPC_GOT16_HI		16
#define	R_PPC_GOT16_HA		17
#define	R_PPC_PLTREL24		18
#define	R_PPC_COPY		19
#define	R_PPC_GLOB_DAT		20
#define	R_PPC_JMP_SLOT		21
#define	R_PPC_RELATIVE		22
#define	R_PPC_LOCAL24PC		23
#define	R_PPC_UADDR32		24
#define	R_PPC_UADDR16		25
#define	R_PPC_REL32		26
#define	R_PPC_PLT32		27
#define	R_PPC_PLTREL32		28
#define	R_PPC_PLT16_LO		29
#define	R_PPC_PLT16_HI		30
#define	R_PPC_PLT16_HA		31
#define	R_PPC_SDAREL16		32
#define	R_PPC_SECTOFF		33
#define	R_PPC_SECTOFF_LO	34
#define	R_PPC_SECTOFF_HI	35
#define	R_PPC_SECTOFF_HA	36

#define	R_PPC_COUNT		37	/* Count of defined relocation types. */

#define R_PPC_TLS		67
#define R_PPC_DTPMOD32		68
#define R_PPC_TPREL16		69
#define R_PPC_TPREL16_LO	70
#define R_PPC_TPREL16_HI	71
#define R_PPC_TPREL16_HA	72
#define R_PPC_TPREL32		73
#define R_PPC_DTPREL16		74
#define R_PPC_DTPREL16_LO	75
#define R_PPC_DTPREL16_HI	76
#define R_PPC_DTPREL16_HA	77
#define R_PPC_DTPREL32		78
#define R_PPC_GOT_TLSGD16	79
#define R_PPC_GOT_TLSGD16_LO	80
#define R_PPC_GOT_TLSGD16_HI	81
#define R_PPC_GOT_TLSGD16_HA	82
#define R_PPC_GOT_TLSLD16	83
#define R_PPC_GOT_TLSLD16_LO	84
#define R_PPC_GOT_TLSLD16_HI	85
#define R_PPC_GOT_TLSLD16_HA	86
#define R_PPC_GOT_TPREL16	87
#define R_PPC_GOT_TPREL16_LO	88
#define R_PPC_GOT_TPREL16_HI	89
#define R_PPC_GOT_TPREL16_HA	90

#define	R_PPC_EMB_NADDR32	101
#define	R_PPC_EMB_NADDR16	102
#define	R_PPC_EMB_NADDR16_LO	103
#define	R_PPC_EMB_NADDR16_HI	104
#define	R_PPC_EMB_NADDR16_HA	105
#define	R_PPC_EMB_SDAI16	106
#define	R_PPC_EMB_SDA2I16	107
#define	R_PPC_EMB_SDA2REL	108
#define	R_PPC_EMB_SDA21		109
#define	R_PPC_EMB_MRKREF	110
#define	R_PPC_EMB_RELSEC16	111
#define	R_PPC_EMB_RELST_LO	112
#define	R_PPC_EMB_RELST_HI	113
#define	R_PPC_EMB_RELST_HA	114
#define	R_PPC_EMB_BIT_FLD	115
#define	R_PPC_EMB_RELSDA	116

					/* Count of defined relocation types. */
#define	R_PPC_EMB_COUNT		(R_PPC_EMB_RELSDA - R_PPC_EMB_NADDR32 + 1)


#define R_SPARC_NONE		0
#define R_SPARC_8		1
#define R_SPARC_16		2
#define R_SPARC_32		3
#define R_SPARC_DISP8		4
#define R_SPARC_DISP16		5
#define R_SPARC_DISP32		6
#define R_SPARC_WDISP30		7
#define R_SPARC_WDISP22		8
#define R_SPARC_HI22		9
#define R_SPARC_22		10
#define R_SPARC_13		11
#define R_SPARC_LO10		12
#define R_SPARC_GOT10		13
#define R_SPARC_GOT13		14
#define R_SPARC_GOT22		15
#define R_SPARC_PC10		16
#define R_SPARC_PC22		17
#define R_SPARC_WPLT30		18
#define R_SPARC_COPY		19
#define R_SPARC_GLOB_DAT	20
#define R_SPARC_JMP_SLOT	21
#define R_SPARC_RELATIVE	22
#define R_SPARC_UA32		23
#define R_SPARC_PLT32		24
#define R_SPARC_HIPLT22		25
#define R_SPARC_LOPLT10		26
#define R_SPARC_PCPLT32		27
#define R_SPARC_PCPLT22		28
#define R_SPARC_PCPLT10		29
#define R_SPARC_10		30
#define R_SPARC_11		31
#define R_SPARC_64		32
#define R_SPARC_OLO10		33
#define R_SPARC_HH22		34
#define R_SPARC_HM10		35
#define R_SPARC_LM22		36
#define R_SPARC_PC_HH22		37
#define R_SPARC_PC_HM10		38
#define R_SPARC_PC_LM22		39
#define R_SPARC_WDISP16		40
#define R_SPARC_WDISP19		41
#define R_SPARC_GLOB_JMP	42
#define R_SPARC_7		43
#define R_SPARC_5		44
#define R_SPARC_6		45
#define	R_SPARC_DISP64		46
#define	R_SPARC_PLT64		47
#define	R_SPARC_HIX22		48
#define	R_SPARC_LOX10		49
#define	R_SPARC_H44		50
#define	R_SPARC_M44		51
#define	R_SPARC_L44		52
#define	R_SPARC_REGISTER	53
#define	R_SPARC_UA64		54
#define	R_SPARC_UA16		55


/*
 * Magic number for the elf trampoline, chosen wisely to be an immediate
 * value.
 */
#define ARM_MAGIC_TRAMP_NUMBER	0x5c000003


/*
 * Symbol table entries.
 */

typedef struct {
	Elf32_Word	name;	/* String table index of name. */
	Elf32_Addr	value;	/* Symbol value. */
	Elf32_Word	size;	/* Size of associated object. */
	unsigned char	info;	/* Type and binding information. */
	unsigned char	other;	/* Reserved (not used). */
	Elf32_Half	shndx;	/* Section index of symbol. */
} Elf32_Sym;

/* Macros for accessing the fields of st_info. */
#define ELF32_ST_BIND(info)		((info) >> 4)
#define ELF32_ST_TYPE(info)		((info) & 0xf)

/* Macro for constructing st_info from field values. */
#define ELF32_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))

/* Macro for accessing the fields of st_other. */
#define ELF32_ST_VISIBILITY(oth)	((oth) & 0x3)

/*
 * ELF definitions common to all 64-bit architectures.
 */

typedef uint64	Elf64_Addr;
typedef uint16	Elf64_Half;
typedef uint64	Elf64_Off;
typedef int32		Elf64_Sword;
typedef int64		Elf64_Sxword;
typedef uint32	Elf64_Word;
typedef uint64	Elf64_Xword;

/*
 * Types of dynamic symbol hash table bucket and chain elements.
 *
 * This is inconsistent among 64 bit architectures, so a machine dependent
 * typedef is required.
 */

#ifdef __alpha__
typedef Elf64_Off	Elf64_Hashelt;
#else
typedef Elf64_Word	Elf64_Hashelt;
#endif

/* Non-standard class-dependent datatype used for abstraction. */
typedef Elf64_Xword	Elf64_Size;
typedef Elf64_Sxword	Elf64_Ssize;

/*
 * ELF header.
 */

typedef struct {
	unsigned char	ident[EI_NIDENT];	/* File identification. */
	Elf64_Half	type;		/* File type. */
	Elf64_Half	machine;	/* Machine architecture. */
	Elf64_Word	version;	/* ELF format version. */
	Elf64_Addr	entry;	/* Entry point. */
	Elf64_Off	phoff;	/* Program header file offset. */
	Elf64_Off	shoff;	/* Section header file offset. */
	Elf64_Word	flags;	/* Architecture-specific flags. */
	Elf64_Half	ehsize;	/* Size of ELF header in bytes. */
	Elf64_Half	phentsize;	/* Size of program header entry. */
	Elf64_Half	phnum;	/* Number of program header entries. */
	Elf64_Half	shentsize;	/* Size of section header entry. */
	Elf64_Half	shnum;	/* Number of section header entries. */
	Elf64_Half	shstrndx;	/* Section name strings section. */
} Elf64_Ehdr;

/*
 * Section header.
 */

typedef struct Elf64_Shdr Elf64_Shdr;
struct Elf64_Shdr {
	Elf64_Word	name;	/* Section name (index into the
					   section header string table). */
	Elf64_Word	type;	/* Section type. */
	Elf64_Xword	flags;	/* Section flags. */
	Elf64_Addr	addr;	/* Address in memory image. */
	Elf64_Off	off;	/* Offset in file. */
	Elf64_Xword	size;	/* Size in bytes. */
	Elf64_Word	link;	/* Index of a related section. */
	Elf64_Word	info;	/* Depends on section type. */
	Elf64_Xword	addralign;	/* Alignment in bytes. */
	Elf64_Xword	entsize;	/* Size of each entry in section. */
	
	int	shnum;  /* section number, not stored on disk */
	LSym*	secsym; /* section symbol, if needed; not on disk */
};

/*
 * Program header.
 */

typedef struct {
	Elf64_Word	type;		/* Entry type. */
	Elf64_Word	flags;	/* Access permission flags. */
	Elf64_Off	off;	/* File offset of contents. */
	Elf64_Addr	vaddr;	/* Virtual address in memory image. */
	Elf64_Addr	paddr;	/* Physical address (not used). */
	Elf64_Xword	filesz;	/* Size of contents in file. */
	Elf64_Xword	memsz;	/* Size of contents in memory. */
	Elf64_Xword	align;	/* Alignment in memory and file. */
} Elf64_Phdr;

/*
 * Dynamic structure.  The ".dynamic" section contains an array of them.
 */

typedef struct {
	Elf64_Sxword	d_tag;		/* Entry type. */
	union {
		Elf64_Xword	d_val;	/* Integer value. */
		Elf64_Addr	d_ptr;	/* Address value. */
	} d_un;
} Elf64_Dyn;

/*
 * Relocation entries.
 */

/* Relocations that don't need an addend field. */
typedef struct {
	Elf64_Addr	off;	/* Location to be relocated. */
	Elf64_Xword	info;		/* Relocation type and symbol index. */
} Elf64_Rel;

/* Relocations that need an addend field. */
typedef struct {
	Elf64_Addr	off;	/* Location to be relocated. */
	Elf64_Xword	info;		/* Relocation type and symbol index. */
	Elf64_Sxword	addend;	/* Addend. */
} Elf64_Rela;

/* Macros for accessing the fields of r_info. */
#define ELF64_R_SYM(info)	((info) >> 32)
#define ELF64_R_TYPE(info)	((info) & 0xffffffffL)

/* Macro for constructing r_info from field values. */
#define ELF64_R_INFO(sym, type)	((((uint64)(sym)) << 32) + (((uint64)(type)) & 0xffffffffULL))

/*
 * Symbol table entries.
 */

typedef struct {
	Elf64_Word	name;	/* String table index of name. */
	unsigned char	info;	/* Type and binding information. */
	unsigned char	other;	/* Reserved (not used). */
	Elf64_Half	shndx;	/* Section index of symbol. */
	Elf64_Addr	value;	/* Symbol value. */
	Elf64_Xword	size;	/* Size of associated object. */
} Elf64_Sym;

/* Macros for accessing the fields of st_info. */
#define ELF64_ST_BIND(info)		((info) >> 4)
#define ELF64_ST_TYPE(info)		((info) & 0xf)

/* Macro for constructing st_info from field values. */
#define ELF64_ST_INFO(bind, type)	(((bind) << 4) + ((type) & 0xf))

/* Macro for accessing the fields of st_other. */
#define ELF64_ST_VISIBILITY(oth)	((oth) & 0x3)

/*
 * Go linker interface
 */

#define	ELF64HDRSIZE	64
#define	ELF64PHDRSIZE	56
#define	ELF64SHDRSIZE	64
#define	ELF64RELSIZE	16
#define	ELF64RELASIZE	24
#define	ELF64SYMSIZE	sizeof(Elf64_Sym)

#define	ELF32HDRSIZE	sizeof(Elf32_Ehdr)
#define	ELF32PHDRSIZE	sizeof(Elf32_Phdr)
#define	ELF32SHDRSIZE	sizeof(Elf32_Shdr)
#define	ELF32SYMSIZE	sizeof(Elf32_Sym)
#define	ELF32RELSIZE	8

/*
 * The interface uses the 64-bit structures always,
 * to avoid code duplication.  The writers know how to
 * marshal a 32-bit representation from the 64-bit structure.
 */
typedef Elf64_Ehdr ElfEhdr;
typedef Elf64_Shdr ElfShdr;
typedef Elf64_Phdr ElfPhdr;

void	elfinit(void);
ElfEhdr	*getElfEhdr(void);
ElfShdr	*newElfShdr(vlong);
ElfPhdr	*newElfPhdr(void);
uint32	elfwritehdr(void);
uint32	elfwritephdrs(void);
uint32	elfwriteshdrs(void);
void	elfwritedynent(LSym*, int, uint64);
void	elfwritedynentsym(LSym*, int, LSym*);
void	elfwritedynentsymsize(LSym*, int, LSym*);
uint32	elfhash(uchar*);
uint64	startelf(void);
uint64	endelf(void);
extern	int	numelfphdr;
extern	int	numelfshdr;
extern	int	iself;
extern	int	elfverneed;
int	elfinterp(ElfShdr*, uint64, uint64, char*);
int	elfwriteinterp(void);
int	elfnetbsdsig(ElfShdr*, uint64, uint64);
int	elfwritenetbsdsig(void);
int	elfopenbsdsig(ElfShdr*, uint64, uint64);
int	elfwriteopenbsdsig(void);
void	addbuildinfo(char*);
int	elfbuildinfo(ElfShdr*, uint64, uint64);
int	elfwritebuildinfo(void);
void	elfdynhash(void);
ElfPhdr* elfphload(Segment*);
ElfShdr* elfshbits(Section*);
ElfShdr* elfshalloc(Section*);
ElfShdr* elfshname(char*);
ElfShdr* elfshreloc(Section*);
void	elfsetstring(char*, int);
void	elfaddverneed(LSym*);
void	elfemitreloc(void);
void	shsym(ElfShdr*, LSym*);
void	phsh(ElfPhdr*, ElfShdr*);
void	doelf(void);
void	elfsetupplt(void);
void	dwarfaddshstrings(LSym*);
void	dwarfaddelfsectionsyms(void);
void	dwarfaddelfheaders(void);
void	asmbelf(vlong symo);
void	asmbelfsetup(void);
extern char linuxdynld[];
extern char freebsddynld[];
extern char netbsddynld[];
extern char openbsddynld[];
extern char dragonflydynld[];
extern char solarisdynld[];
int	elfreloc1(Reloc*, vlong sectoff);
void	putelfsectionsyms(void);

EXTERN	int	elfstrsize;
EXTERN	char*	elfstrdat;
EXTERN	int	buildinfolen;

/*
 * Total amount of space to reserve at the start of the file
 * for Header, PHeaders, SHeaders, and interp.
 * May waste some.
 * On FreeBSD, cannot be larger than a page.
 */
#define	ELFRESERVE	3072
                                                                              root/go1.4/src/cmd/ld/go.c                                                                          0100644 0000000 0000000 00000041672 12600426226 013574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// go-specific code shared across loaders (5l, 6l, 8l).

#include	"l.h"
#include	"../ld/lib.h"

// accumulate all type information from .6 files.
// check for inconsistencies.

// TODO:
//	generate debugging section in binary.
//	once the dust settles, try to move some code to
//		libmach, so that other linkers and ar can share.

/*
 *	package import data
 */
typedef struct Import Import;
struct Import
{
	Import *hash;	// next in hash table
	char *prefix;	// "type", "var", "func", "const"
	char *name;
	char *def;
	char *file;
};
enum {
	NIHASH = 1024
};
static Import *ihash[NIHASH];
static int nimport;
static void imported(char *pkg, char *import);

static int
hashstr(char *name)
{
	uint32 h;
	char *cp;

	h = 0;
	for(cp = name; *cp; h += *cp++)
		h *= 1119;
	h &= 0xffffff;
	return h;
}

static Import *
ilookup(char *name)
{
	int h;
	Import *x;

	h = hashstr(name) % NIHASH;
	for(x=ihash[h]; x; x=x->hash)
		if(x->name[0] == name[0] && strcmp(x->name, name) == 0)
			return x;
	x = mal(sizeof *x);
	x->name = estrdup(name);
	x->hash = ihash[h];
	ihash[h] = x;
	nimport++;
	return x;
}

static void loadpkgdata(char*, char*, char*, int);
static void loadcgo(char*, char*, char*, int);
static int parsemethod(char**, char*, char**);
static int parsepkgdata(char*, char*, char**, char*, char**, char**, char**);

void
ldpkg(Biobuf *f, char *pkg, int64 len, char *filename, int whence)
{
	char *data, *p0, *p1, *name;

	if(debug['g'])
		return;

	if((int)len != len) {
		fprint(2, "%s: too much pkg data in %s\n", argv0, filename);
		if(debug['u'])
			errorexit();
		return;
	}
	data = mal(len+1);
	if(Bread(f, data, len) != len) {
		fprint(2, "%s: short pkg read %s\n", argv0, filename);
		if(debug['u'])
			errorexit();
		return;
	}
	data[len] = '\0';

	// first \n$$ marks beginning of exports - skip rest of line
	p0 = strstr(data, "\n$$");
	if(p0 == nil) {
		if(debug['u'] && whence != ArchiveObj) {
			fprint(2, "%s: cannot find export data in %s\n", argv0, filename);
			errorexit();
		}
		return;
	}
	p0 += 3;
	while(*p0 != '\n' && *p0 != '\0')
		p0++;

	// second marks end of exports / beginning of local data
	p1 = strstr(p0, "\n$$");
	if(p1 == nil) {
		fprint(2, "%s: cannot find end of exports in %s\n", argv0, filename);
		if(debug['u'])
			errorexit();
		return;
	}
	while(p0 < p1 && (*p0 == ' ' || *p0 == '\t' || *p0 == '\n'))
		p0++;
	if(p0 < p1) {
		if(strncmp(p0, "package ", 8) != 0) {
			fprint(2, "%s: bad package section in %s - %s\n", argv0, filename, p0);
			if(debug['u'])
				errorexit();
			return;
		}
		p0 += 8;
		while(p0 < p1 && (*p0 == ' ' || *p0 == '\t' || *p0 == '\n'))
			p0++;
		name = p0;
		while(p0 < p1 && *p0 != ' ' && *p0 != '\t' && *p0 != '\n')
			p0++;
		if(debug['u'] && whence != ArchiveObj &&
		   (p0+6 > p1 || memcmp(p0, " safe\n", 6) != 0)) {
			fprint(2, "%s: load of unsafe package %s\n", argv0, filename);
			nerrors++;
			errorexit();
		}
		if(p0 < p1) {
			if(*p0 == '\n')
				*p0++ = '\0';
			else {
				*p0++ = '\0';
				while(p0 < p1 && *p0++ != '\n')
					;
			}
		}
		if(strcmp(pkg, "main") == 0 && strcmp(name, "main") != 0) {
			fprint(2, "%s: %s: not package main (package %s)\n", argv0, filename, name);
			nerrors++;
			errorexit();
		}
		loadpkgdata(filename, pkg, p0, p1 - p0);
	}
	
	// __.PKGDEF has no cgo section - those are in the C compiler-generated object files.
	if(whence == Pkgdef)
		return;

	// look for cgo section
	p0 = strstr(p1, "\n$$  // cgo");
	if(p0 != nil) {
		p0 = strchr(p0+1, '\n');
		if(p0 == nil) {
			fprint(2, "%s: found $$ // cgo but no newline in %s\n", argv0, filename);
			if(debug['u'])
				errorexit();
			return;
		}
		p1 = strstr(p0, "\n$$");
		if(p1 == nil)
			p1 = strstr(p0, "\n!\n");
		if(p1 == nil) {
			fprint(2, "%s: cannot find end of // cgo section in %s\n", argv0, filename);
			if(debug['u'])
				errorexit();
			return;
		}
		loadcgo(filename, pkg, p0 + 1, p1 - (p0+1));
	}
}

static void
loadpkgdata(char *file, char *pkg, char *data, int len)
{
	char *p, *ep, *prefix, *name, *def;
	Import *x;

	file = estrdup(file);
	p = data;
	ep = data + len;
	while(parsepkgdata(file, pkg, &p, ep, &prefix, &name, &def) > 0) {
		x = ilookup(name);
		if(x->prefix == nil) {
			x->prefix = prefix;
			x->def = estrdup(def);
			x->file = file;
		} else if(strcmp(x->prefix, prefix) != 0) {
			fprint(2, "%s: conflicting definitions for %s\n", argv0, name);
			fprint(2, "%s:\t%s %s ...\n", x->file, x->prefix, name);
			fprint(2, "%s:\t%s %s ...\n", file, prefix, name);
			nerrors++;
		} else if(strcmp(x->def, def) != 0) {
			fprint(2, "%s: conflicting definitions for %s\n", argv0, name);
			fprint(2, "%s:\t%s %s %s\n", x->file, x->prefix, name, x->def);
			fprint(2, "%s:\t%s %s %s\n", file, prefix, name, def);
			nerrors++;
		}
		free(name);
		free(def);
	}
	free(file);
}

static int
parsepkgdata(char *file, char *pkg, char **pp, char *ep, char **prefixp, char **namep, char **defp)
{
	char *p, *prefix, *name, *def, *edef, *meth;
	int n, inquote;

	// skip white space
	p = *pp;
loop:
	while(p < ep && (*p == ' ' || *p == '\t' || *p == '\n'))
		p++;
	if(p == ep || strncmp(p, "$$\n", 3) == 0)
		return 0;

	// prefix: (var|type|func|const)
	prefix = p;
	if(p + 7 > ep)
		return -1;
	if(strncmp(p, "var ", 4) == 0)
		p += 4;
	else if(strncmp(p, "type ", 5) == 0)
		p += 5;
	else if(strncmp(p, "func ", 5) == 0)
		p += 5;
	else if(strncmp(p, "const ", 6) == 0)
		p += 6;
	else if(strncmp(p, "import ", 7) == 0) {
		p += 7;
		while(p < ep && *p != ' ')
			p++;
		p++;
		name = p;
		while(p < ep && *p != '\n')
			p++;
		if(p >= ep) {
			fprint(2, "%s: %s: confused in import line\n", argv0, file);
			nerrors++;
			return -1;
		}
		*p++ = '\0';
		imported(pkg, name);
		goto loop;
	}
	else {
		fprint(2, "%s: %s: confused in pkg data near <<%.40s>>\n", argv0, file, prefix);
		nerrors++;
		return -1;
	}
	p[-1] = '\0';

	// name: a.b followed by space
	name = p;
	inquote = 0;
	while(p < ep) {
		if (*p == ' ' && !inquote)
			break;

		if(*p == '\\')
			p++;
		else if(*p == '"')
			inquote = !inquote;

		p++;
	}

	if(p >= ep)
		return -1;
	*p++ = '\0';

	// def: free form to new line
	def = p;
	while(p < ep && *p != '\n')
		p++;
	if(p >= ep)
		return -1;
	edef = p;
	*p++ = '\0';

	// include methods on successive lines in def of named type
	while(parsemethod(&p, ep, &meth) > 0) {
		*edef++ = '\n';	// overwrites '\0'
		if(edef+1 > meth) {
			// We want to indent methods with a single \t.
			// 6g puts at least one char of indent before all method defs,
			// so there will be room for the \t.  If the method def wasn't
			// indented we could do something more complicated,
			// but for now just diagnose the problem and assume
			// 6g will keep indenting for us.
			fprint(2, "%s: %s: expected methods to be indented %p %p %.10s\n", argv0,
				file, edef, meth, meth);
			nerrors++;
			return -1;
		}
		*edef++ = '\t';
		n = strlen(meth);
		memmove(edef, meth, n);
		edef += n;
	}

	name = expandpkg(name, pkg);
	def = expandpkg(def, pkg);

	// done
	*pp = p;
	*prefixp = prefix;
	*namep = name;
	*defp = def;
	return 1;
}

static int
parsemethod(char **pp, char *ep, char **methp)
{
	char *p;

	// skip white space
	p = *pp;
	while(p < ep && (*p == ' ' || *p == '\t'))
		p++;
	if(p == ep)
		return 0;

	// might be a comment about the method
	if(p + 2 < ep && strncmp(p, "//", 2) == 0)
		goto useline;
	
	// if it says "func (", it's a method
	if(p + 6 < ep && strncmp(p, "func (", 6) == 0)
		goto useline;
	return 0;

useline:
	// definition to end of line
	*methp = p;
	while(p < ep && *p != '\n')
		p++;
	if(p >= ep) {
		fprint(2, "%s: lost end of line in method definition\n", argv0);
		*pp = ep;
		return -1;
	}
	*p++ = '\0';
	*pp = p;
	return 1;
}

static void
loadcgo(char *file, char *pkg, char *p, int n)
{
	char *pend, *next, *p0, *q;
	char *f[10], *local, *remote, *lib;
	int nf;
	LSym *s;

	USED(file);
	pend = p + n;
	p0 = nil;
	for(; p<pend; p=next) {
		next = strchr(p, '\n');
		if(next == nil)
			next = "";
		else
			*next++ = '\0';

		free(p0);
		p0 = estrdup(p); // save for error message
		nf = tokenize(p, f, nelem(f));
		
		if(strcmp(f[0], "cgo_import_dynamic") == 0) {
			if(nf < 2 || nf > 4)
				goto err;
			
			local = f[1];
			remote = local;
			if(nf > 2)
				remote = f[2];
			lib = "";
			if(nf > 3)
				lib = f[3];
			
			if(debug['d']) {
				fprint(2, "%s: %s: cannot use dynamic imports with -d flag\n", argv0, file);
				nerrors++;
				return;
			}
		
			if(strcmp(local, "_") == 0 && strcmp(remote, "_") == 0) {
				// allow #pragma dynimport _ _ "foo.so"
				// to force a link of foo.so.
				havedynamic = 1;
				adddynlib(lib);
				continue;
			}

			local = expandpkg(local, pkg);
			q = strchr(remote, '#');
			if(q)
				*q++ = '\0';
			s = linklookup(ctxt, local, 0);
			if(local != f[1])
				free(local);
			if(s->type == 0 || s->type == SXREF || s->type == SHOSTOBJ) {
				s->dynimplib = lib;
				s->extname = remote;
				s->dynimpvers = q;
				if(s->type != SHOSTOBJ)
					s->type = SDYNIMPORT;
				havedynamic = 1;
			}
			continue;
		}
		
		if(strcmp(f[0], "cgo_import_static") == 0) {
			if(nf != 2)
				goto err;
			local = f[1];
			s = linklookup(ctxt, local, 0);
			s->type = SHOSTOBJ;
			s->size = 0;
			continue;
		}

		if(strcmp(f[0], "cgo_export_static") == 0 || strcmp(f[0], "cgo_export_dynamic") == 0) {
			// TODO: Remove once we know Windows is okay.
			if(strcmp(f[0], "cgo_export_static") == 0 && HEADTYPE == Hwindows)
				continue;

			if(nf < 2 || nf > 3)
				goto err;
			local = f[1];
			if(nf > 2)
				remote = f[2];
			else
				remote = local;
			local = expandpkg(local, pkg);
			s = linklookup(ctxt, local, 0);

			if(flag_shared && s == linklookup(ctxt, "main", 0))
				continue;

			// export overrides import, for openbsd/cgo.
			// see issue 4878.
			if(s->dynimplib != nil) {
				s->dynimplib = nil;
				s->extname = nil;
				s->dynimpvers = nil;
				s->type = 0;
			}

			if(s->cgoexport == 0) {
				s->extname = remote;
				if(ndynexp%32 == 0)
					dynexp = erealloc(dynexp, (ndynexp+32)*sizeof dynexp[0]);
				dynexp[ndynexp++] = s;
			} else if(strcmp(s->extname, remote) != 0) {
				fprint(2, "%s: conflicting cgo_export directives: %s as %s and %s\n", argv0, s->name, s->extname, remote);
				nerrors++;
				return;
			}
			if(strcmp(f[0], "cgo_export_static") == 0)
				s->cgoexport |= CgoExportStatic;
			else
				s->cgoexport |= CgoExportDynamic;
			if(local != f[1])
				free(local);
			continue;
		}
		
		if(strcmp(f[0], "cgo_dynamic_linker") == 0) {
			if(nf != 2)
				goto err;
			
			if(!debug['I']) { // not overridden by command line
				if(interpreter != nil && strcmp(interpreter, f[1]) != 0) {
					fprint(2, "%s: conflict dynlinker: %s and %s\n", argv0, interpreter, f[1]);
					nerrors++;
					return;
				}
				free(interpreter);
				interpreter = estrdup(f[1]);
			}
			continue;
		}
		
		if(strcmp(f[0], "cgo_ldflag") == 0) {
			if(nf != 2)
				goto err;
			if(nldflag%32 == 0)
				ldflag = erealloc(ldflag, (nldflag+32)*sizeof ldflag[0]);
			ldflag[nldflag++] = estrdup(f[1]);
			continue;
		}
	}
	free(p0);
	return;

err:
	fprint(2, "%s: %s: invalid dynimport line: %s\n", argv0, file, p0);
	nerrors++;
}

static LSym *markq;
static LSym *emarkq;

static void
mark1(LSym *s, LSym *parent)
{
	if(s == S || s->reachable)
		return;
	if(strncmp(s->name, "go.weak.", 8) == 0)
		return;
	s->reachable = 1;
	s->reachparent = parent;
	if(markq == nil)
		markq = s;
	else
		emarkq->queue = s;
	emarkq = s;
}

void
mark(LSym *s)
{
	mark1(s, nil);
}

static void
markflood(void)
{
	Auto *a;
	LSym *s;
	int i;
	
	for(s=markq; s!=S; s=s->queue) {
		if(s->type == STEXT) {
			if(debug['v'] > 1)
				Bprint(&bso, "marktext %s\n", s->name);
			for(a=s->autom; a; a=a->link)
				mark1(a->gotype, s);
		}
		for(i=0; i<s->nr; i++)
			mark1(s->r[i].sym, s);
		if(s->pcln) {
			for(i=0; i<s->pcln->nfuncdata; i++)
				mark1(s->pcln->funcdata[i], s);
		}
		mark1(s->gotype, s);
		mark1(s->sub, s);
		mark1(s->outer, s);
	}
}

static char*
markextra[] =
{
	"runtime.morestack",
	"runtime.morestackx",

	"runtime.morestack00",
	"runtime.morestack10",
	"runtime.morestack01",
	"runtime.morestack11",

	"runtime.morestack8",
	"runtime.morestack16",
	"runtime.morestack24",
	"runtime.morestack32",
	"runtime.morestack40",
	"runtime.morestack48",
	
	// on arm, lock in the div/mod helpers too
	"_div",
	"_divu",
	"_mod",
	"_modu",
};

void
deadcode(void)
{
	int i;
	LSym *s, *last, *p;
	Fmt fmt;

	if(debug['v'])
		Bprint(&bso, "%5.2f deadcode\n", cputime());

	mark(linklookup(ctxt, INITENTRY, 0));
	for(i=0; i<nelem(markextra); i++)
		mark(linklookup(ctxt, markextra[i], 0));

	for(i=0; i<ndynexp; i++)
		mark(dynexp[i]);

	markflood();
	
	// keep each beginning with 'typelink.' if the symbol it points at is being kept.
	for(s = ctxt->allsym; s != S; s = s->allsym) {
		if(strncmp(s->name, "go.typelink.", 12) == 0)
			s->reachable = s->nr==1 && s->r[0].sym->reachable;
	}

	// remove dead text but keep file information (z symbols).
	last = nil;
	for(s = ctxt->textp; s != nil; s = s->next) {
		if(!s->reachable)
			continue;
		// NOTE: Removing s from old textp and adding to new, shorter textp.
		if(last == nil)
			ctxt->textp = s;
		else
			last->next = s;
		last = s;
	}
	if(last == nil)
		ctxt->textp = nil;
	else
		last->next = nil;
	
	for(s = ctxt->allsym; s != S; s = s->allsym)
		if(strncmp(s->name, "go.weak.", 8) == 0) {
			s->special = 1;  // do not lay out in data segment
			s->reachable = 1;
			s->hide = 1;
		}
	
	// record field tracking references
	fmtstrinit(&fmt);
	for(s = ctxt->allsym; s != S; s = s->allsym) {
		if(strncmp(s->name, "go.track.", 9) == 0) {
			s->special = 1;  // do not lay out in data segment
			s->hide = 1;
			if(s->reachable) {
				fmtprint(&fmt, "%s", s->name+9);
				for(p=s->reachparent; p; p=p->reachparent)
					fmtprint(&fmt, "\t%s", p->name);
				fmtprint(&fmt, "\n");
			}
			s->type = SCONST;
			s->value = 0;
		}
	}
	if(tracksym == nil)
		return;
	s = linklookup(ctxt, tracksym, 0);
	if(!s->reachable)
		return;
	addstrdata(tracksym, fmtstrflush(&fmt));
}

void
doweak(void)
{
	LSym *s, *t;

	// resolve weak references only if
	// target symbol will be in binary anyway.
	for(s = ctxt->allsym; s != S; s = s->allsym) {
		if(strncmp(s->name, "go.weak.", 8) == 0) {
			t = linkrlookup(ctxt, s->name+8, s->version);
			if(t && t->type != 0 && t->reachable) {
				s->value = t->value;
				s->type = t->type;
				s->outer = t;
			} else {
				s->type = SCONST;
				s->value = 0;
			}
			continue;
		}
	}
}

void
addexport(void)
{
	int i;
	
	if(HEADTYPE == Hdarwin)
		return;

	for(i=0; i<ndynexp; i++)
		adddynsym(ctxt, dynexp[i]);
}

/* %Z from gc, for quoting import paths */
int
Zconv(Fmt *fp)
{
	Rune r;
	char *s, *se;
	int n;

	s = va_arg(fp->args, char*);
	if(s == nil)
		return fmtstrcpy(fp, "<nil>");

	se = s + strlen(s);

	// NOTE: Keep in sync with ../gc/go.c:/^Zconv.
	while(s < se) {
		n = chartorune(&r, s);
		s += n;
		switch(r) {
		case Runeerror:
			if(n == 1) {
				fmtprint(fp, "\\x%02x", (uchar)*(s-1));
				break;
			}
			// fall through
		default:
			if(r < ' ') {
				fmtprint(fp, "\\x%02x", r);
				break;
			}
			fmtrune(fp, r);
			break;
		case '\t':
			fmtstrcpy(fp, "\\t");
			break;
		case '\n':
			fmtstrcpy(fp, "\\n");
			break;
		case '\"':
		case '\\':
			fmtrune(fp, '\\');
			fmtrune(fp, r);
			break;
		case 0xFEFF: // BOM, basically disallowed in source code
			fmtstrcpy(fp, "\\uFEFF");
			break;
		}
	}
	return 0;
}


typedef struct Pkg Pkg;
struct Pkg
{
	uchar mark;
	uchar checked;
	Pkg *next;
	char *path;
	Pkg **impby;
	int nimpby;
	int mimpby;
	Pkg *all;
};

static Pkg *phash[1024];
static Pkg *pkgall;

static Pkg*
getpkg(char *path)
{
	Pkg *p;
	int h;
	
	h = hashstr(path) % nelem(phash);
	for(p=phash[h]; p; p=p->next)
		if(strcmp(p->path, path) == 0)
			return p;
	p = mal(sizeof *p);
	p->path = estrdup(path);
	p->next = phash[h];
	phash[h] = p;
	p->all = pkgall;
	pkgall = p;
	return p;
}

static void
imported(char *pkg, char *import)
{
	Pkg *p, *i;
	
	// everyone imports runtime, even runtime.
	if(strcmp(import, "\"runtime\"") == 0)
		return;

	pkg = smprint("\"%Z\"", pkg);  // turn pkg path into quoted form, freed below
	p = getpkg(pkg);
	i = getpkg(import);
	if(i->nimpby >= i->mimpby) {
		i->mimpby *= 2;
		if(i->mimpby == 0)
			i->mimpby = 16;
		i->impby = erealloc(i->impby, i->mimpby*sizeof i->impby[0]);
	}
	i->impby[i->nimpby++] = p;
	free(pkg);
}

static Pkg*
cycle(Pkg *p)
{
	int i;
	Pkg *bad;

	if(p->checked)
		return 0;

	if(p->mark) {
		nerrors++;
		print("import cycle:\n");
		print("\t%s\n", p->path);
		return p;
	}
	p->mark = 1;
	for(i=0; i<p->nimpby; i++) {
		if((bad = cycle(p->impby[i])) != nil) {
			p->mark = 0;
			p->checked = 1;
			print("\timports %s\n", p->path);
			if(bad == p)
				return nil;
			return bad;
		}
	}
	p->checked = 1;
	p->mark = 0;
	return 0;
}

void
importcycles(void)
{
	Pkg *p;
	
	for(p=pkgall; p; p=p->all)
		cycle(p);
}

void
setlinkmode(char *arg)
{
	if(strcmp(arg, "internal") == 0)
		linkmode = LinkInternal;
	else if(strcmp(arg, "external") == 0)
		linkmode = LinkExternal;
	else if(strcmp(arg, "auto") == 0)
		linkmode = LinkAuto;
	else {
		fprint(2, "unknown link mode -linkmode %s\n", arg);
		errorexit();
	}
}
                                                                      root/go1.4/src/cmd/ld/ldelf.c                                                                       0100644 0000000 0000000 00000051337 12600426226 014254  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
Derived from Plan 9 from User Space's src/libmach/elf.h, elf.c
http://code.swtch.com/plan9port/src/tip/src/libmach/

	Copyright © 2004 Russ Cox.
	Portions Copyright © 2008-2010 Google Inc.
	Portions Copyright © 2010 The Go Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include	"l.h"
#include	"lib.h"
#include	"../ld/elf.h"

enum
{
	ElfClassNone = 0,
	ElfClass32,
	ElfClass64,

	ElfDataNone = 0,
	ElfDataLsb,
	ElfDataMsb,

	ElfTypeNone = 0,
	ElfTypeRelocatable,
	ElfTypeExecutable,
	ElfTypeSharedObject,
	ElfTypeCore,
	/* 0xFF00 - 0xFFFF reserved for processor-specific types */

	ElfMachNone = 0,
	ElfMach32100,		/* AT&T WE 32100 */
	ElfMachSparc,		/* SPARC */
	ElfMach386,		/* Intel 80386 */
	ElfMach68000,		/* Motorola 68000 */
	ElfMach88000,		/* Motorola 88000 */
	ElfMach486,		/* Intel 80486, no longer used */
	ElfMach860,		/* Intel 80860 */
	ElfMachMips,		/* MIPS RS3000 */
	ElfMachS370,		/* IBM System/370 */
	ElfMachMipsLe,	/* MIPS RS3000 LE */
	ElfMachParisc = 15,		/* HP PA RISC */
	ElfMachVpp500 = 17,	/* Fujitsu VPP500 */
	ElfMachSparc32Plus,	/* SPARC V8+ */
	ElfMach960,		/* Intel 80960 */
	ElfMachPower,		/* PowerPC */
	ElfMachPower64,	/* PowerPC 64 */
	ElfMachS390,		/* IBM System/390 */
	ElfMachV800 = 36,	/* NEC V800 */
	ElfMachFr20,		/* Fujitsu FR20 */
	ElfMachRh32,		/* TRW RH-32 */
	ElfMachRce,		/* Motorola RCE */
	ElfMachArm,		/* ARM */
	ElfMachAlpha,		/* Digital Alpha */
	ElfMachSH,		/* Hitachi SH */
	ElfMachSparc9,		/* SPARC V9 */
	ElfMachAmd64 = 62,
	/* and the list goes on... */

	ElfAbiNone = 0,
	ElfAbiSystemV = 0,	/* [sic] */
	ElfAbiHPUX,
	ElfAbiNetBSD,
	ElfAbiLinux,
	ElfAbiSolaris = 6,
	ElfAbiAix,
	ElfAbiIrix,
	ElfAbiFreeBSD,
	ElfAbiTru64,
	ElfAbiModesto,
	ElfAbiOpenBSD,
	ElfAbiARM = 97,
	ElfAbiEmbedded = 255,

	/* some of sections 0xFF00 - 0xFFFF reserved for various things */
	ElfSectNone = 0,
	ElfSectProgbits,
	ElfSectSymtab,
	ElfSectStrtab,
	ElfSectRela,
	ElfSectHash,
	ElfSectDynamic,
	ElfSectNote,
	ElfSectNobits,
	ElfSectRel,
	ElfSectShlib,
	ElfSectDynsym,

	ElfSectFlagWrite = 0x1,
	ElfSectFlagAlloc = 0x2,
	ElfSectFlagExec = 0x4,
	/* 0xF0000000 are reserved for processor specific */

	ElfSymBindLocal = 0,
	ElfSymBindGlobal,
	ElfSymBindWeak,
	/* 13-15 reserved */

	ElfSymTypeNone = 0,
	ElfSymTypeObject,
	ElfSymTypeFunc,
	ElfSymTypeSection,
	ElfSymTypeFile,
	/* 13-15 reserved */

	ElfSymShnNone = 0,
	ElfSymShnAbs = 0xFFF1,
	ElfSymShnCommon = 0xFFF2,
	/* 0xFF00-0xFF1F reserved for processors */
	/* 0xFF20-0xFF3F reserved for operating systems */

	ElfProgNone = 0,
	ElfProgLoad,
	ElfProgDynamic,
	ElfProgInterp,
	ElfProgNote,
	ElfProgShlib,
	ElfProgPhdr,

	ElfProgFlagExec = 0x1,
	ElfProgFlagWrite = 0x2,
	ElfProgFlagRead = 0x4,

	ElfNotePrStatus = 1,
	ElfNotePrFpreg = 2,
	ElfNotePrPsinfo = 3,
	ElfNotePrTaskstruct = 4,
	ElfNotePrAuxv = 6,
	ElfNotePrXfpreg = 0x46e62b7f	/* for gdb/386 */
};

typedef struct ElfHdrBytes ElfHdrBytes;
typedef struct ElfSectBytes ElfSectBytes;
typedef struct ElfProgBytes ElfProgBytes;
typedef struct ElfSymBytes ElfSymBytes;

typedef struct ElfHdrBytes64 ElfHdrBytes64;
typedef struct ElfSectBytes64 ElfSectBytes64;
typedef struct ElfProgBytes64 ElfProgBytes64;
typedef struct ElfSymBytes64 ElfSymBytes64;

struct ElfHdrBytes
{
	uchar	ident[16];
	uchar	type[2];
	uchar	machine[2];
	uchar	version[4];
	uchar	entry[4];
	uchar	phoff[4];
	uchar	shoff[4];
	uchar	flags[4];
	uchar	ehsize[2];
	uchar	phentsize[2];
	uchar	phnum[2];
	uchar	shentsize[2];
	uchar	shnum[2];
	uchar	shstrndx[2];
};

struct ElfHdrBytes64
{
	uchar	ident[16];
	uchar	type[2];
	uchar	machine[2];
	uchar	version[4];
	uchar	entry[8];
	uchar	phoff[8];
	uchar	shoff[8];
	uchar	flags[4];
	uchar	ehsize[2];
	uchar	phentsize[2];
	uchar	phnum[2];
	uchar	shentsize[2];
	uchar	shnum[2];
	uchar	shstrndx[2];
};

struct ElfSectBytes
{
	uchar	name[4];
	uchar	type[4];
	uchar	flags[4];
	uchar	addr[4];
	uchar	off[4];
	uchar	size[4];
	uchar	link[4];
	uchar	info[4];
	uchar	align[4];
	uchar	entsize[4];
};

struct ElfSectBytes64
{
	uchar	name[4];
	uchar	type[4];
	uchar	flags[8];
	uchar	addr[8];
	uchar	off[8];
	uchar	size[8];
	uchar	link[4];
	uchar	info[4];
	uchar	align[8];
	uchar	entsize[8];
};

struct ElfSymBytes
{
	uchar	name[4];
	uchar	value[4];
	uchar	size[4];
	uchar	info;	/* top4: bind, bottom4: type */
	uchar	other;
	uchar	shndx[2];
};

struct ElfSymBytes64
{
	uchar	name[4];
	uchar	info;	/* top4: bind, bottom4: type */
	uchar	other;
	uchar	shndx[2];
	uchar	value[8];
	uchar	size[8];
};

typedef struct ElfSect ElfSect;
typedef struct ElfObj ElfObj;
typedef struct ElfSym ElfSym;

struct ElfSect
{
	char		*name;
	uint32	type;
	uint64	flags;
	uint64	addr;
	uint64	off;
	uint64	size;
	uint32	link;
	uint32	info;
	uint64	align;
	uint64	entsize;
	uchar	*base;
	LSym	*sym;
};

struct ElfObj
{
	Biobuf	*f;
	int64	base;	// offset in f where ELF begins
	int64	len;		// length of ELF
	int	is64;
	char	*name;

	Endian	*e;
	ElfSect	*sect;
	uint		nsect;
	char		*shstrtab;
	int		nsymtab;
	ElfSect	*symtab;
	ElfSect	*symstr;

	uint32	type;
	uint32	machine;
	uint32	version;
	uint64	entry;
	uint64	phoff;
	uint64	shoff;
	uint32	flags;
	uint32	ehsize;
	uint32	phentsize;
	uint32	phnum;
	uint32	shentsize;
	uint32	shnum;
	uint32	shstrndx;
};

struct ElfSym
{
	char*	name;
	uint64	value;
	uint64	size;
	uchar	bind;
	uchar	type;
	uchar	other;
	uint16	shndx;
	LSym*	sym;
};

uchar ElfMagic[4] = { 0x7F, 'E', 'L', 'F' };

static ElfSect*	section(ElfObj*, char*);
static int	map(ElfObj*, ElfSect*);
static int	readsym(ElfObj*, int i, ElfSym*, int);
static int	reltype(char*, int, uchar*);

int
valuecmp(LSym *a, LSym *b)
{
	if(a->value < b->value)
		return -1;
	if(a->value > b->value)
		return +1;
	return 0;
}

void
ldelf(Biobuf *f, char *pkg, int64 len, char *pn)
{
	int32 base;
	uint64 add, info;
	char *name;
	int i, j, rela, is64, n;
	uchar hdrbuf[64];
	uchar *p;
	ElfHdrBytes *hdr;
	ElfObj *obj;
	ElfSect *sect, *rsect;
	ElfSym sym;
	Endian *e;
	Reloc *r, *rp;
	LSym *s;
	LSym **symbols;

	symbols = nil;

	if(debug['v'])
		Bprint(&bso, "%5.2f ldelf %s\n", cputime(), pn);

	ctxt->version++;
	base = Boffset(f);

	if(Bread(f, hdrbuf, sizeof hdrbuf) != sizeof hdrbuf)
		goto bad;
	hdr = (ElfHdrBytes*)hdrbuf;
	if(memcmp(hdr->ident, ElfMagic, 4) != 0)
		goto bad;
	switch(hdr->ident[5]) {
	case ElfDataLsb:
		e = &le;
		break;
	case ElfDataMsb:
		e = &be;
		break;
	default:
		goto bad;
	}

	// read header
	obj = mal(sizeof *obj);
	obj->e = e;
	obj->f = f;
	obj->base = base;
	obj->len = len;
	obj->name = pn;
	
	is64 = 0;
	if(hdr->ident[4] == ElfClass64) {
		ElfHdrBytes64* hdr;

		is64 = 1;
		hdr = (ElfHdrBytes64*)hdrbuf;
		obj->type = e->e16(hdr->type);
		obj->machine = e->e16(hdr->machine);
		obj->version = e->e32(hdr->version);
		obj->phoff = e->e64(hdr->phoff);
		obj->shoff = e->e64(hdr->shoff);
		obj->flags = e->e32(hdr->flags);
		obj->ehsize = e->e16(hdr->ehsize);
		obj->phentsize = e->e16(hdr->phentsize);
		obj->phnum = e->e16(hdr->phnum);
		obj->shentsize = e->e16(hdr->shentsize);
		obj->shnum = e->e16(hdr->shnum);
		obj->shstrndx = e->e16(hdr->shstrndx);
	} else {
		obj->type = e->e16(hdr->type);
		obj->machine = e->e16(hdr->machine);
		obj->version = e->e32(hdr->version);
		obj->entry = e->e32(hdr->entry);
		obj->phoff = e->e32(hdr->phoff);
		obj->shoff = e->e32(hdr->shoff);
		obj->flags = e->e32(hdr->flags);
		obj->ehsize = e->e16(hdr->ehsize);
		obj->phentsize = e->e16(hdr->phentsize);
		obj->phnum = e->e16(hdr->phnum);
		obj->shentsize = e->e16(hdr->shentsize);
		obj->shnum = e->e16(hdr->shnum);
		obj->shstrndx = e->e16(hdr->shstrndx);
	}
	obj->is64 = is64;
	
	if(hdr->ident[6] != obj->version)
		goto bad;

	if(e->e16(hdr->type) != ElfTypeRelocatable) {
		diag("%s: elf but not elf relocatable object", pn);
		return;
	}

	switch(thechar) {
	default:
		diag("%s: elf %s unimplemented", pn, thestring);
		return;
	case '5':
		if(e != &le || obj->machine != ElfMachArm || hdr->ident[4] != ElfClass32) {
			diag("%s: elf object but not arm", pn);
			return;
		}
		break;
	case '6':
		if(e != &le || obj->machine != ElfMachAmd64 || hdr->ident[4] != ElfClass64) {
			diag("%s: elf object but not amd64", pn);
			return;
		}
		break;
	case '8':
		if(e != &le || obj->machine != ElfMach386 || hdr->ident[4] != ElfClass32) {
			diag("%s: elf object but not 386", pn);
			return;
		}
		break;
	}

	// load section list into memory.
	obj->sect = mal(obj->shnum*sizeof obj->sect[0]);
	obj->nsect = obj->shnum;
	for(i=0; i<obj->nsect; i++) {
		if(Bseek(f, base+obj->shoff+i*obj->shentsize, 0) < 0)
			goto bad;
		sect = &obj->sect[i];
		if(is64) {
			ElfSectBytes64 b;

			werrstr("short read");
			if(Bread(f, &b, sizeof b) != sizeof b)
				goto bad;

			sect->name = (char*)(uintptr)e->e32(b.name);
			sect->type = e->e32(b.type);
			sect->flags = e->e64(b.flags);
			sect->addr = e->e64(b.addr);
			sect->off = e->e64(b.off);
			sect->size = e->e64(b.size);
			sect->link = e->e32(b.link);
			sect->info = e->e32(b.info);
			sect->align = e->e64(b.align);
			sect->entsize = e->e64(b.entsize);
		} else {
			ElfSectBytes b;

			werrstr("short read");
			if(Bread(f, &b, sizeof b) != sizeof b)
				goto bad;
		
			sect->name = (char*)(uintptr)e->e32(b.name);
			sect->type = e->e32(b.type);
			sect->flags = e->e32(b.flags);
			sect->addr = e->e32(b.addr);
			sect->off = e->e32(b.off);
			sect->size = e->e32(b.size);
			sect->link = e->e32(b.link);
			sect->info = e->e32(b.info);
			sect->align = e->e32(b.align);
			sect->entsize = e->e32(b.entsize);
		}
	}

	// read section string table and translate names
	if(obj->shstrndx >= obj->nsect) {
		werrstr("shstrndx out of range %d >= %d", obj->shstrndx, obj->nsect);
		goto bad;
	}
	sect = &obj->sect[obj->shstrndx];
	if(map(obj, sect) < 0)
		goto bad;
	for(i=0; i<obj->nsect; i++)
		if(obj->sect[i].name != nil)
			obj->sect[i].name = (char*)sect->base + (uintptr)obj->sect[i].name;
	
	// load string table for symbols into memory.
	obj->symtab = section(obj, ".symtab");
	if(obj->symtab == nil) {
		// our work is done here - no symbols means nothing can refer to this file
		return;
	}
	if(obj->symtab->link <= 0 || obj->symtab->link >= obj->nsect) {
		diag("%s: elf object has symbol table with invalid string table link", pn);
		return;
	}
	obj->symstr = &obj->sect[obj->symtab->link];
	if(is64)
		obj->nsymtab = obj->symtab->size / sizeof(ElfSymBytes64);
	else
		obj->nsymtab = obj->symtab->size / sizeof(ElfSymBytes);
	
	if(map(obj, obj->symtab) < 0)
		goto bad;
	if(map(obj, obj->symstr) < 0)
		goto bad;

	// load text and data segments into memory.
	// they are not as small as the section lists, but we'll need
	// the memory anyway for the symbol images, so we might
	// as well use one large chunk.
	
	// create symbols for mapped sections
	for(i=0; i<obj->nsect; i++) {
		sect = &obj->sect[i];
		if((sect->type != ElfSectProgbits && sect->type != ElfSectNobits) || !(sect->flags&ElfSectFlagAlloc))
			continue;
		if(sect->type != ElfSectNobits && map(obj, sect) < 0)
			goto bad;
		
		name = smprint("%s(%s)", pkg, sect->name);
		s = linklookup(ctxt, name, ctxt->version);
		free(name);
		switch((int)sect->flags&(ElfSectFlagAlloc|ElfSectFlagWrite|ElfSectFlagExec)) {
		default:
			werrstr("unexpected flags for ELF section %s", sect->name);
			goto bad;
		case ElfSectFlagAlloc:
			s->type = SRODATA;
			break;
		case ElfSectFlagAlloc + ElfSectFlagWrite:
			if(sect->type == ElfSectNobits)
				s->type = SNOPTRBSS;
			else
				s->type = SNOPTRDATA;
			break;
		case ElfSectFlagAlloc + ElfSectFlagExec:
			s->type = STEXT;
			break;
		}
		if(sect->type == ElfSectProgbits) {
			s->p = sect->base;
			s->np = sect->size;
		}
		s->size = sect->size;
		s->align = sect->align;
		sect->sym = s;
	}

	// enter sub-symbols into symbol table.
	// symbol 0 is the null symbol.
	symbols = malloc(obj->nsymtab * sizeof(symbols[0]));
	if(symbols == nil) {
		diag("out of memory");
		errorexit();
	}
	for(i=1; i<obj->nsymtab; i++) {
		if(readsym(obj, i, &sym, 1) < 0)
			goto bad;
		symbols[i] = sym.sym;
		if(sym.type != ElfSymTypeFunc && sym.type != ElfSymTypeObject && sym.type != ElfSymTypeNone)
			continue;
		if(sym.shndx == ElfSymShnCommon) {
			s = sym.sym;
			if(s->size < sym.size)
				s->size = sym.size;
			if(s->type == 0 || s->type == SXREF)
				s->type = SNOPTRBSS;
			continue;
		}
		if(sym.shndx >= obj->nsect || sym.shndx == 0)
			continue;
		// even when we pass needSym == 1 to readsym, it might still return nil to skip some unwanted symbols
		if(sym.sym == S)
			continue;
		sect = obj->sect+sym.shndx;
		if(sect->sym == nil) {
			if(strncmp(sym.name, ".Linfo_string", 13) == 0) // clang does this
				continue;
			diag("%s: sym#%d: ignoring %s in section %d (type %d)", pn, i, sym.name, sym.shndx, sym.type);
			continue;
		}
		s = sym.sym;
		if(s->outer != S) {
			if(s->dupok)
				continue;
			diag("%s: duplicate symbol reference: %s in both %s and %s", pn, s->name, s->outer->name, sect->sym->name);
			errorexit();
		}
		s->sub = sect->sym->sub;
		sect->sym->sub = s;
		s->type = sect->sym->type | (s->type&~SMASK) | SSUB;
		if(!(s->cgoexport & CgoExportDynamic))
			s->dynimplib = nil;  // satisfy dynimport
		s->value = sym.value;
		s->size = sym.size;
		s->outer = sect->sym;
		if(sect->sym->type == STEXT) {
			if(s->external && !s->dupok)
					diag("%s: duplicate definition of %s", pn, s->name);
			s->external = 1;
		}
	}
	
	// Sort outer lists by address, adding to textp.
	// This keeps textp in increasing address order.
	for(i=0; i<obj->nsect; i++) {
		s = obj->sect[i].sym;
		if(s == S)
			continue;
		if(s->sub)
			s->sub = listsort(s->sub, valuecmp, offsetof(LSym, sub));
		if(s->type == STEXT) {
			if(s->onlist)
				sysfatal("symbol %s listed multiple times", s->name);
			s->onlist = 1;
			if(ctxt->etextp)
				ctxt->etextp->next = s;
			else
				ctxt->textp = s;
			ctxt->etextp = s;
			for(s = s->sub; s != S; s = s->sub) {
				if(s->onlist)
					sysfatal("symbol %s listed multiple times", s->name);
				s->onlist = 1;
				ctxt->etextp->next = s;
				ctxt->etextp = s;
			}
		}
	}

	// load relocations
	for(i=0; i<obj->nsect; i++) {
		rsect = &obj->sect[i];
		if(rsect->type != ElfSectRela && rsect->type != ElfSectRel)
			continue;
		if(rsect->info >= obj->nsect || obj->sect[rsect->info].base == nil)
			continue;
		sect = &obj->sect[rsect->info];
		if(map(obj, rsect) < 0)
			goto bad;
		rela = rsect->type == ElfSectRela;
		n = rsect->size/(4+4*is64)/(2+rela);
		r = mal(n*sizeof r[0]);
		p = rsect->base;
		for(j=0; j<n; j++) {
			add = 0;
			rp = &r[j];
			if(is64) {
				// 64-bit rel/rela
				rp->off = e->e64(p);
				p += 8;
				info = e->e64(p);
				p += 8;
				if(rela) {
					add = e->e64(p);
					p += 8;
				}
			} else {
				// 32-bit rel/rela
				rp->off = e->e32(p);
				p += 4;
				info = e->e32(p);
				info = info>>8<<32 | (info&0xff);	// convert to 64-bit info
				p += 4;
				if(rela) {
					add = e->e32(p);
					p += 4;
				}
			}
			if((info & 0xffffffff) == 0) { // skip R_*_NONE relocation
				j--;
				n--;
				continue;
			}
			if((info >> 32) == 0) { // absolute relocation, don't bother reading the null symbol
				rp->sym = S;
			} else {
				if(readsym(obj, info>>32, &sym, 0) < 0)
					goto bad;
				sym.sym = symbols[info>>32];
				if(sym.sym == nil) {
					werrstr("%s#%d: reloc of invalid sym #%d %s shndx=%d type=%d",
						sect->sym->name, j, (int)(info>>32), sym.name, sym.shndx, sym.type);
					goto bad;
				}
				rp->sym = sym.sym;
			}
			rp->type = reltype(pn, (uint32)info, &rp->siz);
			if(rela)
				rp->add = add;
			else {
				// load addend from image
				if(rp->siz == 4)
					rp->add = e->e32(sect->base+rp->off);
				else if(rp->siz == 8)
					rp->add = e->e64(sect->base+rp->off);
				else
					diag("invalid rela size %d", rp->siz);
			}
			if(rp->siz == 4)
				rp->add = (int32)rp->add;
			//print("rel %s %d %d %s %#llx\n", sect->sym->name, rp->type, rp->siz, rp->sym->name, rp->add);
		}
		qsort(r, n, sizeof r[0], rbyoff);	// just in case
		
		s = sect->sym;
		s->r = r;
		s->nr = n;
	}
	free(symbols);

	return;

bad:
	diag("%s: malformed elf file: %r", pn);
	free(symbols);
}

static ElfSect*
section(ElfObj *obj, char *name)
{
	int i;
	
	for(i=0; i<obj->nsect; i++)
		if(obj->sect[i].name && name && strcmp(obj->sect[i].name, name) == 0)
			return &obj->sect[i];
	return nil;
}

static int
map(ElfObj *obj, ElfSect *sect)
{
	if(sect->base != nil)
		return 0;

	if(sect->off+sect->size > obj->len) {
		werrstr("elf section past end of file");
		return -1;
	}

	sect->base = mal(sect->size);
	werrstr("short read");
	if(Bseek(obj->f, obj->base+sect->off, 0) < 0 || Bread(obj->f, sect->base, sect->size) != sect->size)
		return -1;
	
	return 0;
}

static int
readsym(ElfObj *obj, int i, ElfSym *sym, int needSym)
{
	LSym *s;

	if(i >= obj->nsymtab || i < 0) {
		werrstr("invalid elf symbol index");
		return -1;
	}
	if(i == 0) {
		diag("readym: read null symbol!");
	}

	if(obj->is64) {
		ElfSymBytes64 *b;
		
		b = (ElfSymBytes64*)(obj->symtab->base + i*sizeof *b);
		sym->name = (char*)obj->symstr->base + obj->e->e32(b->name);
		sym->value = obj->e->e64(b->value);
		sym->size = obj->e->e64(b->size);
		sym->shndx = obj->e->e16(b->shndx);
		sym->bind = b->info>>4;
		sym->type = b->info&0xf;
		sym->other = b->other;
	} else {
		ElfSymBytes *b;
		
		b = (ElfSymBytes*)(obj->symtab->base + i*sizeof *b);
		sym->name = (char*)obj->symstr->base + obj->e->e32(b->name);
		sym->value = obj->e->e32(b->value);
		sym->size = obj->e->e32(b->size);
		sym->shndx = obj->e->e16(b->shndx);
		sym->bind = b->info>>4;
		sym->type = b->info&0xf;
		sym->other = b->other;
	}

	s = nil;
	if(strcmp(sym->name, "_GLOBAL_OFFSET_TABLE_") == 0)
		sym->name = ".got";
	switch(sym->type) {
	case ElfSymTypeSection:
		s = obj->sect[sym->shndx].sym;
		break;
	case ElfSymTypeObject:
	case ElfSymTypeFunc:
	case ElfSymTypeNone:
		switch(sym->bind) {
		case ElfSymBindGlobal:
			if(needSym) {
				s = linklookup(ctxt, sym->name, 0);
				// for global scoped hidden symbols we should insert it into
				// symbol hash table, but mark them as hidden.
				// __i686.get_pc_thunk.bx is allowed to be duplicated, to
				// workaround that we set dupok.
				// TODO(minux): correctly handle __i686.get_pc_thunk.bx without
				// set dupok generally. See http://codereview.appspot.com/5823055/
				// comment #5 for details.
				if(s && sym->other == 2) {
					s->type |= SHIDDEN;
					s->dupok = 1;
				}
			}
			break;
		case ElfSymBindLocal:
			if(!(thechar == '5' && (strncmp(sym->name, "$a", 2) == 0 || strncmp(sym->name, "$d", 2) == 0))) // binutils for arm generate these mapping symbols, ignore these
				if(needSym) {
					// local names and hidden visiblity global names are unique
					// and should only reference by its index, not name, so we
					// don't bother to add them into hash table
					s = linknewsym(ctxt, sym->name, ctxt->version);
					s->type |= SHIDDEN;
				}
			break;
		case ElfSymBindWeak:
			if(needSym) {
				s = linknewsym(ctxt, sym->name, 0);
				if(sym->other == 2)
					s->type |= SHIDDEN;
			}
			break;
		default:
			werrstr("%s: invalid symbol binding %d", sym->name, sym->bind);
			return -1;
		}
		break;
	}
	if(s != nil && s->type == 0 && sym->type != ElfSymTypeSection)
		s->type = SXREF;
	sym->sym = s;

	return 0;
}

int
rbyoff(const void *va, const void *vb)
{
	Reloc *a, *b;
	
	a = (Reloc*)va;
	b = (Reloc*)vb;
	if(a->off < b->off)
		return -1;
	if(a->off > b->off)
		return +1;
	return 0;
}

#define R(x, y) ((x)|((y)<<24))

static int
reltype(char *pn, int elftype, uchar *siz)
{
	switch(R(thechar, elftype)) {
	default:
		diag("%s: unknown relocation type %d; compiled without -fpic?", pn, elftype);
	case R('5', R_ARM_ABS32):
	case R('5', R_ARM_GOT32):
	case R('5', R_ARM_PLT32):
	case R('5', R_ARM_GOTOFF):
	case R('5', R_ARM_GOTPC):
	case R('5', R_ARM_THM_PC22):
	case R('5', R_ARM_REL32):
	case R('5', R_ARM_CALL):
	case R('5', R_ARM_V4BX):
	case R('5', R_ARM_GOT_PREL):
	case R('5', R_ARM_PC24):
	case R('5', R_ARM_JUMP24):
	case R('6', R_X86_64_PC32):
	case R('6', R_X86_64_PLT32):
	case R('6', R_X86_64_GOTPCREL):
	case R('8', R_386_32):
	case R('8', R_386_PC32):
	case R('8', R_386_GOT32):
	case R('8', R_386_PLT32):
	case R('8', R_386_GOTOFF):
	case R('8', R_386_GOTPC):
		*siz = 4;
		break;
	case R('6', R_X86_64_64):
		*siz = 8;
		break;
	}

	return 256+elftype;
}
                                                                                                                                                                                                                                                                                                 root/go1.4/src/cmd/ld/ldmacho.c                                                                     0100644 0000000 0000000 00000050471 12600426226 014573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        /*
Derived from Plan 9 from User Space's src/libmach/elf.h, elf.c
http://code.swtch.com/plan9port/src/tip/src/libmach/

	Copyright © 2004 Russ Cox.
	Portions Copyright © 2008-2010 Google Inc.
	Portions Copyright © 2010 The Go Authors.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

#include	"l.h"
#include	"lib.h"

enum {
	MACHO_FAKE_GOTPCREL = 100,	// from macho.h
	
	N_EXT = 0x01,
	N_TYPE = 0x1e,
	N_STAB = 0xe0,
};

typedef struct MachoObj MachoObj;
typedef struct MachoCmd MachoCmd;
typedef struct MachoSeg MachoSeg;
typedef struct MachoSect MachoSect;
typedef struct MachoRel MachoRel;
typedef struct MachoSymtab MachoSymtab;
typedef struct MachoSym MachoSym;
typedef struct MachoDysymtab MachoDysymtab;

enum
{
	MachoCpuVax = 1,
	MachoCpu68000 = 6,
	MachoCpu386 = 7,
	MachoCpuAmd64 = 0x1000007,
	MachoCpuMips = 8,
	MachoCpu98000 = 10,
	MachoCpuHppa = 11,
	MachoCpuArm = 12,
	MachoCpu88000 = 13,
	MachoCpuSparc = 14,
	MachoCpu860 = 15,
	MachoCpuAlpha = 16,
	MachoCpuPower = 18,

	MachoCmdSegment = 1,
	MachoCmdSymtab = 2,
	MachoCmdSymseg = 3,
	MachoCmdThread = 4,
	MachoCmdDysymtab = 11,
	MachoCmdSegment64 = 25,

	MachoFileObject = 1,
	MachoFileExecutable = 2,
	MachoFileFvmlib = 3,
	MachoFileCore = 4,
	MachoFilePreload = 5,
};

struct MachoSeg
{
	char name[16+1];
	uint64 vmaddr;
	uint64 vmsize;
	uint32 fileoff;
	uint32 filesz;
	uint32 maxprot;
	uint32 initprot;
	uint32 nsect;
	uint32 flags;
	MachoSect *sect;
};

struct MachoSect
{
	char	name[16+1];
	char	segname[16+1];
	uint64 addr;
	uint64 size;
	uint32 off;
	uint32 align;
	uint32 reloff;
	uint32 nreloc;
	uint32 flags;
	uint32 res1;
	uint32 res2;
	LSym *sym;
	
	MachoRel *rel;
};

struct MachoRel
{
	uint32 addr;
	uint32 symnum;
	uint8 pcrel;
	uint8 length;
	uint8 extrn;
	uint8 type;
	uint8 scattered;
	uint32 value;
};

struct MachoSymtab
{
	uint32 symoff;
	uint32 nsym;
	uint32 stroff;
	uint32 strsize;
	
	char *str;
	MachoSym *sym;
};

struct MachoSym
{
	char *name;
	uint8 type;
	uint8 sectnum;
	uint16 desc;
	char kind;
	uint64 value;
	LSym *sym;
};

struct MachoDysymtab
{
	uint32 ilocalsym;
	uint32 nlocalsym;
	uint32 iextdefsym;
	uint32 nextdefsym;
	uint32 iundefsym;
	uint32 nundefsym;
	uint32 tocoff;
	uint32 ntoc;
	uint32 modtaboff;
	uint32 nmodtab;
	uint32 extrefsymoff;
	uint32 nextrefsyms;
	uint32 indirectsymoff;
	uint32 nindirectsyms;
	uint32 extreloff;
	uint32 nextrel;
	uint32 locreloff;
	uint32 nlocrel;
	uint32 *indir;
};

struct MachoCmd
{
	int type;
	uint32 off;
	uint32 size;
	MachoSeg seg;
	MachoSymtab sym;
	MachoDysymtab dsym;
};

struct MachoObj
{
	Biobuf	*f;
	int64	base;	// off in f where Mach-O begins
	int64	len;		// length of Mach-O
	int is64;
	char	*name;

	Endian	*e;
	uint cputype;
	uint subcputype;
	uint32 filetype;
	uint32 flags;
	MachoCmd *cmd;
	uint ncmd;
};

static int
unpackcmd(uchar *p, MachoObj *m, MachoCmd *c, uint type, uint sz)
{
	uint32 (*e4)(uchar*);
	uint64 (*e8)(uchar*);
	MachoSect *s;
	int i;

	e4 = m->e->e32;
	e8 = m->e->e64;

	c->type = type;
	c->size = sz;
	switch(type){
	default:
		return -1;
	case MachoCmdSegment:
		if(sz < 56)
			return -1;
		strecpy(c->seg.name, c->seg.name+sizeof c->seg.name, (char*)p+8);
		c->seg.vmaddr = e4(p+24);
		c->seg.vmsize = e4(p+28);
		c->seg.fileoff = e4(p+32);
		c->seg.filesz = e4(p+36);
		c->seg.maxprot = e4(p+40);
		c->seg.initprot = e4(p+44);
		c->seg.nsect = e4(p+48);
		c->seg.flags = e4(p+52);
		c->seg.sect = mal(c->seg.nsect * sizeof c->seg.sect[0]);
		if(sz < 56+c->seg.nsect*68)
			return -1;
		p += 56;
		for(i=0; i<c->seg.nsect; i++) {
			s = &c->seg.sect[i];
			strecpy(s->name, s->name+sizeof s->name, (char*)p+0);
			strecpy(s->segname, s->segname+sizeof s->segname, (char*)p+16);
			s->addr = e4(p+32);
			s->size = e4(p+36);
			s->off = e4(p+40);
			s->align = e4(p+44);
			s->reloff = e4(p+48);
			s->nreloc = e4(p+52);
			s->flags = e4(p+56);
			s->res1 = e4(p+60);
			s->res2 = e4(p+64);
			p += 68;
		}
		break;
	case MachoCmdSegment64:
		if(sz < 72)
			return -1;
		strecpy(c->seg.name, c->seg.name+sizeof c->seg.name, (char*)p+8);
		c->seg.vmaddr = e8(p+24);
		c->seg.vmsize = e8(p+32);
		c->seg.fileoff = e8(p+40);
		c->seg.filesz = e8(p+48);
		c->seg.maxprot = e4(p+56);
		c->seg.initprot = e4(p+60);
		c->seg.nsect = e4(p+64);
		c->seg.flags = e4(p+68);
		c->seg.sect = mal(c->seg.nsect * sizeof c->seg.sect[0]);
		if(sz < 72+c->seg.nsect*80)
			return -1;
		p += 72;
		for(i=0; i<c->seg.nsect; i++) {
			s = &c->seg.sect[i];
			strecpy(s->name, s->name+sizeof s->name, (char*)p+0);
			strecpy(s->segname, s->segname+sizeof s->segname, (char*)p+16);
			s->addr = e8(p+32);
			s->size = e8(p+40);
			s->off = e4(p+48);
			s->align = e4(p+52);
			s->reloff = e4(p+56);
			s->nreloc = e4(p+60);
			s->flags = e4(p+64);
			s->res1 = e4(p+68);
			s->res2 = e4(p+72);
			// p+76 is reserved
			p += 80;
		}
		break;
	case MachoCmdSymtab:
		if(sz < 24)
			return -1;
		c->sym.symoff = e4(p+8);
		c->sym.nsym = e4(p+12);
		c->sym.stroff = e4(p+16);
		c->sym.strsize = e4(p+20);
		break;
	case MachoCmdDysymtab:
		if(sz < 80)
			return -1;
		c->dsym.ilocalsym = e4(p+8);
		c->dsym.nlocalsym = e4(p+12);
		c->dsym.iextdefsym = e4(p+16);
		c->dsym.nextdefsym = e4(p+20);
		c->dsym.iundefsym = e4(p+24);
		c->dsym.nundefsym = e4(p+28);
		c->dsym.tocoff = e4(p+32);
		c->dsym.ntoc = e4(p+36);
		c->dsym.modtaboff = e4(p+40);
		c->dsym.nmodtab = e4(p+44);
		c->dsym.extrefsymoff = e4(p+48);
		c->dsym.nextrefsyms = e4(p+52);
		c->dsym.indirectsymoff = e4(p+56);
		c->dsym.nindirectsyms = e4(p+60);
		c->dsym.extreloff = e4(p+64);
		c->dsym.nextrel = e4(p+68);
		c->dsym.locreloff = e4(p+72);
		c->dsym.nlocrel = e4(p+76);
		break;
	}
	return 0;
}

static int
macholoadrel(MachoObj *m, MachoSect *sect)
{
	MachoRel *rel, *r;
	uchar *buf, *p;
	int i, n;
	uint32 v;
	
	if(sect->rel != nil || sect->nreloc == 0)
		return 0;
	rel = mal(sect->nreloc * sizeof r[0]);
	n = sect->nreloc * 8;
	buf = mal(n);
	if(Bseek(m->f, m->base + sect->reloff, 0) < 0 || Bread(m->f, buf, n) != n)
		return -1;
	for(i=0; i<sect->nreloc; i++) {
		r = &rel[i];
		p = buf+i*8;
		r->addr = m->e->e32(p);
		
		// TODO(rsc): Wrong interpretation for big-endian bitfields?
		if(r->addr & 0x80000000) {
			// scatterbrained relocation
			r->scattered = 1;
			v = r->addr >> 24;
			r->addr &= 0xFFFFFF;
			r->type = v & 0xF;
			v >>= 4;
			r->length = 1<<(v&3);
			v >>= 2;
			r->pcrel = v & 1;
			r->value = m->e->e32(p+4);
		} else {
			v = m->e->e32(p+4);
			r->symnum = v & 0xFFFFFF;
			v >>= 24;
			r->pcrel = v&1;
			v >>= 1;
			r->length = 1<<(v&3);
			v >>= 2;
			r->extrn = v&1;
			v >>= 1;
			r->type = v;
		}
	}
	sect->rel = rel;
	return 0;
}

static int
macholoaddsym(MachoObj *m, MachoDysymtab *d)
{
	uchar *p;
	int i, n;
	
	n = d->nindirectsyms;
	
	p = mal(n*4);
	if(Bseek(m->f, m->base + d->indirectsymoff, 0) < 0 || Bread(m->f, p, n*4) != n*4)
		return -1;
	
	d->indir = (uint32*)p;
	for(i=0; i<n; i++)
		d->indir[i] = m->e->e32(p+4*i);
	return 0;
}

static int 
macholoadsym(MachoObj *m, MachoSymtab *symtab)
{
	char *strbuf;
	uchar *symbuf, *p;
	int i, n, symsize;
	MachoSym *sym, *s;
	uint32 v;

	if(symtab->sym != nil)
		return 0;

	strbuf = mal(symtab->strsize);
	if(Bseek(m->f, m->base + symtab->stroff, 0) < 0 || Bread(m->f, strbuf, symtab->strsize) != symtab->strsize)
		return -1;
	
	symsize = 12;
	if(m->is64)
		symsize = 16;
	n = symtab->nsym * symsize;
	symbuf = mal(n);
	if(Bseek(m->f, m->base + symtab->symoff, 0) < 0 || Bread(m->f, symbuf, n) != n)
		return -1;
	sym = mal(symtab->nsym * sizeof sym[0]);
	p = symbuf;
	for(i=0; i<symtab->nsym; i++) {
		s = &sym[i];
		v = m->e->e32(p);
		if(v >= symtab->strsize)
			return -1;
		s->name = strbuf + v;
		s->type = p[4];
		s->sectnum = p[5];
		s->desc = m->e->e16(p+6);
		if(m->is64)
			s->value = m->e->e64(p+8);
		else
			s->value = m->e->e32(p+8);
		p += symsize;
	}
	symtab->str = strbuf;
	symtab->sym = sym;
	return 0;
}

void
ldmacho(Biobuf *f, char *pkg, int64 len, char *pn)
{
	int i, j, is64;
	uint64 secaddr;
	uchar hdr[7*4], *cmdp;
	uchar tmp[4];
	uchar *dat;
	ulong ncmd, cmdsz, ty, sz, off;
	MachoObj *m;
	Endian *e;
	int64 base;
	MachoSect *sect;
	MachoRel *rel;
	LSym *s, *s1, *outer;
	MachoCmd *c;
	MachoSymtab *symtab;
	MachoDysymtab *dsymtab;
	MachoSym *sym;
	Reloc *r, *rp;
	char *name;

	ctxt->version++;
	base = Boffset(f);
	if(Bread(f, hdr, sizeof hdr) != sizeof hdr)
		goto bad;

	if((be.e32(hdr)&~1) == 0xFEEDFACE){
		e = &be;
	}else if((le.e32(hdr)&~1) == 0xFEEDFACE){
		e = &le;
	}else{
		werrstr("bad magic - not mach-o file");
		goto bad;
	}

	is64 = e->e32(hdr) == 0xFEEDFACF;
	ncmd = e->e32(hdr+4*4);
	cmdsz = e->e32(hdr+5*4);
	if(ncmd > 0x10000 || cmdsz >= 0x01000000){
		werrstr("implausible mach-o header ncmd=%lud cmdsz=%lud", ncmd, cmdsz);
		goto bad;
	}
	if(is64)
		Bread(f, tmp, 4);	// skip reserved word in header

	m = mal(sizeof(*m)+ncmd*sizeof(MachoCmd)+cmdsz);
	m->f = f;
	m->e = e;
	m->cputype = e->e32(hdr+1*4);
	m->subcputype = e->e32(hdr+2*4);
	m->filetype = e->e32(hdr+3*4);
	m->ncmd = ncmd;
	m->flags = e->e32(hdr+6*4);
	m->is64 = is64;
	m->base = base;
	m->len = len;
	m->name = pn;
	
	switch(thechar) {
	default:
		diag("%s: mach-o %s unimplemented", pn, thestring);
		return;
	case '6':
		if(e != &le || m->cputype != MachoCpuAmd64) {
			diag("%s: mach-o object but not amd64", pn);
			return;
		}
		break;
	case '8':
		if(e != &le || m->cputype != MachoCpu386) {
			diag("%s: mach-o object but not 386", pn);
			return;
		}
		break;
	}

	m->cmd = (MachoCmd*)(m+1);
	off = sizeof hdr;
	cmdp = (uchar*)(m->cmd+ncmd);
	if(Bread(f, cmdp, cmdsz) != cmdsz){
		werrstr("reading cmds: %r");
		goto bad;
	}

	// read and parse load commands
	c = nil;
	symtab = nil;
	dsymtab = nil;
	USED(dsymtab);
	for(i=0; i<ncmd; i++){
		ty = e->e32(cmdp);
		sz = e->e32(cmdp+4);
		m->cmd[i].off = off;
		unpackcmd(cmdp, m, &m->cmd[i], ty, sz);
		cmdp += sz;
		off += sz;
		if(ty == MachoCmdSymtab) {
			if(symtab != nil) {
				werrstr("multiple symbol tables");
				goto bad;
			}
			symtab = &m->cmd[i].sym;
			macholoadsym(m, symtab);
		}
		if(ty == MachoCmdDysymtab) {
			dsymtab = &m->cmd[i].dsym;
			macholoaddsym(m, dsymtab);
		}
		if((is64 && ty == MachoCmdSegment64) || (!is64 && ty == MachoCmdSegment)) {
			if(c != nil) {
				werrstr("multiple load commands");
				goto bad;
			}
			c = &m->cmd[i];
		}
	}

	// load text and data segments into memory.
	// they are not as small as the load commands, but we'll need
	// the memory anyway for the symbol images, so we might
	// as well use one large chunk.
	if(c == nil) {
		werrstr("no load command");
		goto bad;
	}
	if(symtab == nil) {
		// our work is done here - no symbols means nothing can refer to this file
		return;
	}

	if(c->seg.fileoff+c->seg.filesz >= len) {
		werrstr("load segment out of range");
		goto bad;
	}

	dat = mal(c->seg.filesz);
	if(Bseek(f, m->base + c->seg.fileoff, 0) < 0 || Bread(f, dat, c->seg.filesz) != c->seg.filesz) {
		werrstr("cannot load object data: %r");
		goto bad;
	}
	
	for(i=0; i<c->seg.nsect; i++) {
		sect = &c->seg.sect[i];
		if(strcmp(sect->segname, "__TEXT") != 0 && strcmp(sect->segname, "__DATA") != 0)
			continue;
		if(strcmp(sect->name, "__eh_frame") == 0)
			continue;
		name = smprint("%s(%s/%s)", pkg, sect->segname, sect->name);
		s = linklookup(ctxt, name, ctxt->version);
		if(s->type != 0) {
			werrstr("duplicate %s/%s", sect->segname, sect->name);
			goto bad;
		}
		free(name);

		s->np = sect->size;
		s->size = s->np;
		if((sect->flags & 0xff) == 1) // S_ZEROFILL
			s->p = mal(s->size);
		else {
			s->p = dat + sect->addr - c->seg.vmaddr;
		}
		
		if(strcmp(sect->segname, "__TEXT") == 0) {
			if(strcmp(sect->name, "__text") == 0)
				s->type = STEXT;
			else
				s->type = SRODATA;
		} else {
			if (strcmp(sect->name, "__bss") == 0) {
				s->type = SNOPTRBSS;
				s->np = 0;
			} else
				s->type = SNOPTRDATA;
		}
		sect->sym = s;
	}
	
	// enter sub-symbols into symbol table.
	// have to guess sizes from next symbol.
	for(i=0; i<symtab->nsym; i++) {
		int v;
		sym = &symtab->sym[i];
		if(sym->type&N_STAB)
			continue;
		// TODO: check sym->type against outer->type.
		name = sym->name;
		if(name[0] == '_' && name[1] != '\0')
			name++;
		v = 0;
		if(!(sym->type&N_EXT))
			v = ctxt->version;
		s = linklookup(ctxt, name, v);
		if(!(sym->type&N_EXT))
			s->dupok = 1;
		sym->sym = s;
		if(sym->sectnum == 0)	// undefined
			continue;
		if(sym->sectnum > c->seg.nsect) {
			werrstr("reference to invalid section %d", sym->sectnum);
			goto bad;
		}
		sect = &c->seg.sect[sym->sectnum-1];
		outer = sect->sym;
		if(outer == nil) {
			werrstr("reference to invalid section %s/%s", sect->segname, sect->name);
			continue;
		}
		if(s->outer != S) {
			if(s->dupok)
				continue;
			diag("%s: duplicate symbol reference: %s in both %s and %s", pn, s->name, s->outer->name, sect->sym->name);
			errorexit();
		}
		s->type = outer->type | SSUB;
		s->sub = outer->sub;
		outer->sub = s;
		s->outer = outer;
		s->value = sym->value - sect->addr;
		if(!(s->cgoexport & CgoExportDynamic))
			s->dynimplib = nil;	// satisfy dynimport
		if(outer->type == STEXT) {
			if(s->external && !s->dupok)
				diag("%s: duplicate definition of %s", pn, s->name);
			s->external = 1;
		}
		sym->sym = s;
	}

	// Sort outer lists by address, adding to textp.
	// This keeps textp in increasing address order.
	for(i=0; i<c->seg.nsect; i++) {
		sect = &c->seg.sect[i];
		if((s = sect->sym) == S)
			continue;
		if(s->sub) {
			s->sub = listsort(s->sub, valuecmp, offsetof(LSym, sub));
			
			// assign sizes, now that we know symbols in sorted order.
			for(s1 = s->sub; s1 != S; s1 = s1->sub) {
				if(s1->sub)
					s1->size = s1->sub->value - s1->value;
				else
					s1->size = s->value + s->size - s1->value;
			}
		}
		if(s->type == STEXT) {
			if(s->onlist)
				sysfatal("symbol %s listed multiple times", s->name);
			s->onlist = 1;
			if(ctxt->etextp)
				ctxt->etextp->next = s;
			else
				ctxt->textp = s;
			ctxt->etextp = s;
			for(s1 = s->sub; s1 != S; s1 = s1->sub) {
				if(s1->onlist)
					sysfatal("symbol %s listed multiple times", s1->name);
				s1->onlist = 1;
				ctxt->etextp->next = s1;
				ctxt->etextp = s1;
			}
		}
	}

	// load relocations
	for(i=0; i<c->seg.nsect; i++) {
		sect = &c->seg.sect[i];
		if((s = sect->sym) == S)
			continue;
		macholoadrel(m, sect);
		if(sect->rel == nil)
			continue;
		r = mal(sect->nreloc*sizeof r[0]);
		rp = r;
		rel = sect->rel;
		for(j=0; j<sect->nreloc; j++, rel++) {
			if(rel->scattered) {
				int k;
				MachoSect *ks;

				if(thechar != '8') {
					// mach-o only uses scattered relocation on 32-bit platforms
					diag("unexpected scattered relocation");
					continue;
				}

				// on 386, rewrite scattered 4/1 relocation and some
				// scattered 2/1 relocation into the pseudo-pc-relative
				// reference that it is.
				// assume that the second in the pair is in this section
				// and use that as the pc-relative base.
				if(j+1 >= sect->nreloc) {
					werrstr("unsupported scattered relocation %d", (int)rel->type);
					goto bad;
				}
				if(!(rel+1)->scattered || (rel+1)->type != 1 ||
				   (rel->type != 4 && rel->type != 2) ||
				   (rel+1)->value < sect->addr || (rel+1)->value >= sect->addr+sect->size) {
					werrstr("unsupported scattered relocation %d/%d", (int)rel->type, (int)(rel+1)->type);
					goto bad;
				}

				rp->siz = rel->length;
				rp->off = rel->addr;
				
				// NOTE(rsc): I haven't worked out why (really when)
				// we should ignore the addend on a
				// scattered relocation, but it seems that the
				// common case is we ignore it.
				// It's likely that this is not strictly correct
				// and that the math should look something
				// like the non-scattered case below.
				rp->add = 0;
				
				// want to make it pc-relative aka relative to rp->off+4
				// but the scatter asks for relative to off = (rel+1)->value - sect->addr.
				// adjust rp->add accordingly.
				rp->type = R_PCREL;
				rp->add += (rp->off+4) - ((rel+1)->value - sect->addr);
				
				// now consider the desired symbol.
				// find the section where it lives.
				for(k=0; k<c->seg.nsect; k++) {
					ks = &c->seg.sect[k];
					if(ks->addr <= rel->value && rel->value < ks->addr+ks->size)
						goto foundk;
				}
				werrstr("unsupported scattered relocation: invalid address %#ux", rel->addr);
				goto bad;
			foundk:
				if(ks->sym != S) {
					rp->sym = ks->sym;
					rp->add += rel->value - ks->addr;
				} else if(strcmp(ks->segname, "__IMPORT") == 0 && strcmp(ks->name, "__pointers") == 0) {
					// handle reference to __IMPORT/__pointers.
					// how much worse can this get?
					// why are we supporting 386 on the mac anyway?
					rp->type = 512 + MACHO_FAKE_GOTPCREL;
					// figure out which pointer this is a reference to.
					k = ks->res1 + (rel->value - ks->addr) / 4;
					// load indirect table for __pointers
					// fetch symbol number
					if(dsymtab == nil || k < 0 || k >= dsymtab->nindirectsyms || dsymtab->indir == nil) {
						werrstr("invalid scattered relocation: indirect symbol reference out of range");
						goto bad;
					}
					k = dsymtab->indir[k];
					if(k < 0 || k >= symtab->nsym) {
						werrstr("invalid scattered relocation: symbol reference out of range");
						goto bad;
					}
					rp->sym = symtab->sym[k].sym;
				} else {
					werrstr("unsupported scattered relocation: reference to %s/%s", ks->segname, ks->name);
					goto bad;
				}
				rp++;
				// skip #1 of 2 rel; continue skips #2 of 2.
				rel++;
				j++;
				continue;
			}

			rp->siz = rel->length;
			rp->type = 512 + (rel->type<<1) + rel->pcrel;
			rp->off = rel->addr;

			// Handle X86_64_RELOC_SIGNED referencing a section (rel->extrn == 0).
			if (thechar == '6' && rel->extrn == 0 && rel->type == 1) {
				// Calculate the addend as the offset into the section.
				//
				// The rip-relative offset stored in the object file is encoded
				// as follows:
				//    
				//    movsd	0x00000360(%rip),%xmm0
				//
				// To get the absolute address of the value this rip-relative address is pointing
				// to, we must add the address of the next instruction to it. This is done by
				// taking the address of the relocation and adding 4 to it (since the rip-relative
				// offset can at most be 32 bits long).  To calculate the offset into the section the
				// relocation is referencing, we subtract the vaddr of the start of the referenced
				// section found in the original object file.
				//
				// [For future reference, see Darwin's /usr/include/mach-o/x86_64/reloc.h]
				secaddr = c->seg.sect[rel->symnum-1].addr;
				rp->add = (int32)e->e32(s->p+rp->off) + rp->off + 4 - secaddr;
			} else
				rp->add = (int32)e->e32(s->p+rp->off);

			// For i386 Mach-O PC-relative, the addend is written such that
			// it *is* the PC being subtracted.  Use that to make
			// it match our version of PC-relative.
			if(rel->pcrel && thechar == '8')
				rp->add += rp->off+rp->siz;
			if(!rel->extrn) {
				if(rel->symnum < 1 || rel->symnum > c->seg.nsect) {
					werrstr("invalid relocation: section reference out of range %d vs %d", rel->symnum, c->seg.nsect);
					goto bad;
				}
				rp->sym = c->seg.sect[rel->symnum-1].sym;
				if(rp->sym == nil) {
					werrstr("invalid relocation: %s", c->seg.sect[rel->symnum-1].name);
					goto bad;
				}
				// References to symbols in other sections
				// include that information in the addend.
				// We only care about the delta from the 
				// section base.
				if(thechar == '8')
					rp->add -= c->seg.sect[rel->symnum-1].addr;
			} else {
				if(rel->symnum >= symtab->nsym) {
					werrstr("invalid relocation: symbol reference out of range");
					goto bad;
				}
				rp->sym = symtab->sym[rel->symnum].sym;
			}
			rp++;
		}			
		qsort(r, rp - r, sizeof r[0], rbyoff);
		s->r = r;
		s->nr = rp - r;
	}
	return;

bad:
	diag("%s: malformed mach-o file: %r", pn);
}
                                                                                                                                                                                                       root/go1.4/src/cmd/ld/ldpe.c                                                                        0100644 0000000 0000000 00000032616 12600426226 014111  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2010 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include	"l.h"
#include	"lib.h"
#include	"../ld/pe.h"

#define IMAGE_SCN_MEM_DISCARDABLE 0x2000000

#define IMAGE_SYM_UNDEFINED	0
#define IMAGE_SYM_ABSOLUTE (-1)
#define IMAGE_SYM_DEBUG	(-2)
#define IMAGE_SYM_TYPE_NULL 0
#define IMAGE_SYM_TYPE_VOID 1
#define IMAGE_SYM_TYPE_CHAR 2
#define IMAGE_SYM_TYPE_SHORT 3
#define IMAGE_SYM_TYPE_INT 4
#define IMAGE_SYM_TYPE_LONG 5
#define IMAGE_SYM_TYPE_FLOAT 6
#define IMAGE_SYM_TYPE_DOUBLE 7
#define IMAGE_SYM_TYPE_STRUCT 8
#define IMAGE_SYM_TYPE_UNION 9
#define IMAGE_SYM_TYPE_ENUM 10
#define IMAGE_SYM_TYPE_MOE 11
#define IMAGE_SYM_TYPE_BYTE 12
#define IMAGE_SYM_TYPE_WORD 13
#define IMAGE_SYM_TYPE_UINT 14
#define IMAGE_SYM_TYPE_DWORD 15
#define IMAGE_SYM_TYPE_PCODE 32768
#define IMAGE_SYM_DTYPE_NULL 0
#define IMAGE_SYM_DTYPE_POINTER 0x10
#define IMAGE_SYM_DTYPE_FUNCTION 0x20
#define IMAGE_SYM_DTYPE_ARRAY 0x30
#define IMAGE_SYM_CLASS_END_OF_FUNCTION	(-1)
#define IMAGE_SYM_CLASS_NULL 0
#define IMAGE_SYM_CLASS_AUTOMATIC 1
#define IMAGE_SYM_CLASS_EXTERNAL 2
#define IMAGE_SYM_CLASS_STATIC 3
#define IMAGE_SYM_CLASS_REGISTER 4
#define IMAGE_SYM_CLASS_EXTERNAL_DEF 5
#define IMAGE_SYM_CLASS_LABEL 6
#define IMAGE_SYM_CLASS_UNDEFINED_LABEL 7
#define IMAGE_SYM_CLASS_MEMBER_OF_STRUCT 8
#define IMAGE_SYM_CLASS_ARGUMENT 9
#define IMAGE_SYM_CLASS_STRUCT_TAG 10
#define IMAGE_SYM_CLASS_MEMBER_OF_UNION 11
#define IMAGE_SYM_CLASS_UNION_TAG 12
#define IMAGE_SYM_CLASS_TYPE_DEFINITION 13
#define IMAGE_SYM_CLASS_UNDEFINED_STATIC 14
#define IMAGE_SYM_CLASS_ENUM_TAG 15
#define IMAGE_SYM_CLASS_MEMBER_OF_ENUM 16
#define IMAGE_SYM_CLASS_REGISTER_PARAM 17
#define IMAGE_SYM_CLASS_BIT_FIELD 18
#define IMAGE_SYM_CLASS_FAR_EXTERNAL 68 /* Not in PECOFF v8 spec */
#define IMAGE_SYM_CLASS_BLOCK 100
#define IMAGE_SYM_CLASS_FUNCTION 101
#define IMAGE_SYM_CLASS_END_OF_STRUCT 102
#define IMAGE_SYM_CLASS_FILE 103
#define IMAGE_SYM_CLASS_SECTION 104
#define IMAGE_SYM_CLASS_WEAK_EXTERNAL 105
#define IMAGE_SYM_CLASS_CLR_TOKEN 107

#define IMAGE_REL_I386_ABSOLUTE	0x0000
#define IMAGE_REL_I386_DIR16	0x0001
#define IMAGE_REL_I386_REL16	0x0002
#define IMAGE_REL_I386_DIR32	0x0006
#define IMAGE_REL_I386_DIR32NB	0x0007
#define IMAGE_REL_I386_SEG12	0x0009
#define IMAGE_REL_I386_SECTION	0x000A
#define IMAGE_REL_I386_SECREL	0x000B
#define IMAGE_REL_I386_TOKEN	0x000C
#define IMAGE_REL_I386_SECREL7	0x000D
#define IMAGE_REL_I386_REL32	0x0014

#define IMAGE_REL_AMD64_ABSOLUTE 0x0000
#define IMAGE_REL_AMD64_ADDR64 0x0001 // R_X86_64_64
#define IMAGE_REL_AMD64_ADDR32 0x0002 // R_X86_64_PC32
#define IMAGE_REL_AMD64_ADDR32NB 0x0003
#define IMAGE_REL_AMD64_REL32 0x0004 
#define IMAGE_REL_AMD64_REL32_1 0x0005
#define IMAGE_REL_AMD64_REL32_2 0x0006
#define IMAGE_REL_AMD64_REL32_3 0x0007
#define IMAGE_REL_AMD64_REL32_4 0x0008
#define IMAGE_REL_AMD64_REL32_5 0x0009
#define IMAGE_REL_AMD64_SECTION 0x000A
#define IMAGE_REL_AMD64_SECREL 0x000B
#define IMAGE_REL_AMD64_SECREL7 0x000C
#define IMAGE_REL_AMD64_TOKEN 0x000D
#define IMAGE_REL_AMD64_SREL32 0x000E
#define IMAGE_REL_AMD64_PAIR 0x000F
#define IMAGE_REL_AMD64_SSPAN32 0x0010

typedef struct PeSym PeSym;
typedef struct PeSect PeSect;
typedef struct PeObj PeObj;

struct PeSym {
	char* name;
	uint32 value;
	uint16 sectnum;
	uint16 type;
	uint8 sclass;
	uint8 aux;
	LSym* sym;
};

struct PeSect {
	char* name;
	uchar* base;
	uint64 size;
	LSym* sym;
	IMAGE_SECTION_HEADER sh;
};

struct PeObj {
	Biobuf	*f;
	char	*name;
	uint32 base;
	
	PeSect	*sect;
	uint	nsect;
	PeSym	*pesym;
	uint npesym;
	
	IMAGE_FILE_HEADER fh;
	char* snames;
};

static int map(PeObj *obj, PeSect *sect);
static int issect(PeSym *s);
static int readsym(PeObj *obj, int i, PeSym **sym);

void
ldpe(Biobuf *f, char *pkg, int64 len, char *pn)
{
	char *name;
	int32 base;
	uint32 l;
	int i, j, numaux;
	PeObj *obj;
	PeSect *sect, *rsect;
	IMAGE_SECTION_HEADER sh;
	uchar symbuf[18];
	LSym *s;
	Reloc *r, *rp;
	PeSym *sym;

	USED(len);
	if(debug['v'])
		Bprint(&bso, "%5.2f ldpe %s\n", cputime(), pn);
	
	sect = nil;
	ctxt->version++;
	base = Boffset(f);
	
	obj = mal(sizeof *obj);
	obj->f = f;
	obj->base = base;
	obj->name = pn;
	// read header
	if(Bread(f, &obj->fh, sizeof obj->fh) != sizeof obj->fh)
		goto bad;
	// load section list
	obj->sect = mal(obj->fh.NumberOfSections*sizeof obj->sect[0]);
	obj->nsect = obj->fh.NumberOfSections;
	for(i=0; i < obj->fh.NumberOfSections; i++) {
		if(Bread(f, &obj->sect[i].sh, sizeof sh) != sizeof sh)
			goto bad;
		obj->sect[i].size = obj->sect[i].sh.SizeOfRawData;
		obj->sect[i].name = (char*)obj->sect[i].sh.Name;
		// TODO return error if found .cormeta
	}
	// load string table
	Bseek(f, base+obj->fh.PointerToSymbolTable+sizeof(symbuf)*obj->fh.NumberOfSymbols, 0);
	if(Bread(f, symbuf, 4) != 4) 
		goto bad;
	l = le32(symbuf);
	obj->snames = mal(l);
	Bseek(f, base+obj->fh.PointerToSymbolTable+sizeof(symbuf)*obj->fh.NumberOfSymbols, 0);
	if(Bread(f, obj->snames, l) != l)
		goto bad;
	// rewrite section names if they start with /
	for(i=0; i < obj->fh.NumberOfSections; i++) {
		if(obj->sect[i].name == nil)
			continue;
		if(obj->sect[i].name[0] != '/')
			continue;
		l = atoi(obj->sect[i].name + 1);
		obj->sect[i].name = (char*)&obj->snames[l];
	}
	// read symbols
	obj->pesym = mal(obj->fh.NumberOfSymbols*sizeof obj->pesym[0]);
	obj->npesym = obj->fh.NumberOfSymbols;
	Bseek(f, base+obj->fh.PointerToSymbolTable, 0);
	for(i=0; i<obj->fh.NumberOfSymbols; i+=numaux+1) {
		Bseek(f, base+obj->fh.PointerToSymbolTable+sizeof(symbuf)*i, 0);
		if(Bread(f, symbuf, sizeof symbuf) != sizeof symbuf)
			goto bad;
		
		if((symbuf[0] == 0) && (symbuf[1] == 0) &&
			 (symbuf[2] == 0) && (symbuf[3] == 0)) {
			l = le32(&symbuf[4]);
			obj->pesym[i].name = (char*)&obj->snames[l];
		} else { // sym name length <= 8
			obj->pesym[i].name = mal(9);
			strncpy(obj->pesym[i].name, (char*)symbuf, 8);
			obj->pesym[i].name[8] = 0;
		}
		obj->pesym[i].value = le32(&symbuf[8]);
		obj->pesym[i].sectnum = le16(&symbuf[12]);
		obj->pesym[i].sclass = symbuf[16];
		obj->pesym[i].aux = symbuf[17];
		obj->pesym[i].type = le16(&symbuf[14]);
		numaux = obj->pesym[i].aux; 
		if (numaux < 0) 
			numaux = 0;
	}
	// create symbols for mapped sections
	for(i=0; i<obj->nsect; i++) {
		sect = &obj->sect[i];
		if(sect->sh.Characteristics&IMAGE_SCN_MEM_DISCARDABLE)
			continue;

		if((sect->sh.Characteristics&(IMAGE_SCN_CNT_CODE|IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_CNT_UNINITIALIZED_DATA)) == 0) {
			// This has been seen for .idata sections, which we
			// want to ignore.  See issues 5106 and 5273.
			continue;
		}

		if(map(obj, sect) < 0)
			goto bad;
		
		name = smprint("%s(%s)", pkg, sect->name);
		s = linklookup(ctxt, name, ctxt->version);
		free(name);
		switch(sect->sh.Characteristics&(IMAGE_SCN_CNT_UNINITIALIZED_DATA|IMAGE_SCN_CNT_INITIALIZED_DATA|
			IMAGE_SCN_MEM_READ|IMAGE_SCN_MEM_WRITE|IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE)) {
			case IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_MEM_READ: //.rdata
				s->type = SRODATA;
				break;
			case IMAGE_SCN_CNT_UNINITIALIZED_DATA|IMAGE_SCN_MEM_READ|IMAGE_SCN_MEM_WRITE: //.bss
				s->type = SNOPTRBSS;
				break;
			case IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_MEM_READ|IMAGE_SCN_MEM_WRITE: //.data
				s->type = SNOPTRDATA;
				break;
			case IMAGE_SCN_CNT_CODE|IMAGE_SCN_MEM_EXECUTE|IMAGE_SCN_MEM_READ: //.text
				s->type = STEXT;
				break;
			default:
				werrstr("unexpected flags %#08ux for PE section %s", sect->sh.Characteristics, sect->name);
				goto bad;
		}
		s->p = sect->base;
		s->np = sect->size;
		s->size = sect->size;
		sect->sym = s;
		if(strcmp(sect->name, ".rsrc") == 0)
			setpersrc(sect->sym);
	}
	
	// load relocations
	for(i=0; i<obj->nsect; i++) {
		rsect = &obj->sect[i];
		if(rsect->sym == 0 || rsect->sh.NumberOfRelocations == 0)
			continue;
		if(rsect->sh.Characteristics&IMAGE_SCN_MEM_DISCARDABLE)
			continue;
		if((sect->sh.Characteristics&(IMAGE_SCN_CNT_CODE|IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_CNT_UNINITIALIZED_DATA)) == 0) {
			// This has been seen for .idata sections, which we
			// want to ignore.  See issues 5106 and 5273.
			continue;
		}
		r = mal(rsect->sh.NumberOfRelocations*sizeof r[0]);
		Bseek(f, obj->base+rsect->sh.PointerToRelocations, 0);
		for(j=0; j<rsect->sh.NumberOfRelocations; j++) {
			rp = &r[j];
			if(Bread(f, symbuf, 10) != 10)
				goto bad;
			
			uint32 rva, symindex;
			uint16 type;
			rva = le32(&symbuf[0]);
			symindex = le32(&symbuf[4]);
			type = le16(&symbuf[8]);
			if(readsym(obj, symindex, &sym) < 0)
				goto bad;
			if(sym->sym == nil) {
				werrstr("reloc of invalid sym %s idx=%d type=%d", sym->name, symindex, sym->type);
				goto bad;
			}
			rp->sym = sym->sym;
			rp->siz = 4;
			rp->off = rva;
			switch(type) {
				default:
					diag("%s: unknown relocation type %d;", pn, type);
				case IMAGE_REL_I386_REL32:
				case IMAGE_REL_AMD64_REL32:
				case IMAGE_REL_AMD64_ADDR32: // R_X86_64_PC32
				case IMAGE_REL_AMD64_ADDR32NB:
					rp->type = R_PCREL;
					rp->add = (int32)le32(rsect->base+rp->off);
					break;
				case IMAGE_REL_I386_DIR32NB:
				case IMAGE_REL_I386_DIR32:
					rp->type = R_ADDR;
					// load addend from image
					rp->add = (int32)le32(rsect->base+rp->off);
					break;
				case IMAGE_REL_AMD64_ADDR64: // R_X86_64_64
					rp->siz = 8;
					rp->type = R_ADDR;
					// load addend from image
					rp->add = le64(rsect->base+rp->off);
					break;
			}
			// ld -r could generate multiple section symbols for the
			// same section but with different values, we have to take
			// that into account
			if(issect(&obj->pesym[symindex]))
				rp->add += obj->pesym[symindex].value;
		}
		qsort(r, rsect->sh.NumberOfRelocations, sizeof r[0], rbyoff);
		
		s = rsect->sym;
		s->r = r;
		s->nr = rsect->sh.NumberOfRelocations;
	}

	// enter sub-symbols into symbol table.
	for(i=0; i<obj->npesym; i++) {
		if(obj->pesym[i].name == 0)
			continue;
		if(issect(&obj->pesym[i]))
			continue;
		if(obj->pesym[i].sectnum > 0) {
			sect = &obj->sect[obj->pesym[i].sectnum-1];
			if(sect->sym == 0)
				continue;
		}
		if(readsym(obj, i, &sym) < 0)
			goto bad;
	
		s = sym->sym;
		if(sym->sectnum == 0) {// extern
			if(s->type == SDYNIMPORT)
				s->plt = -2; // flag for dynimport in PE object files.
			if (s->type == SXREF && sym->value > 0) {// global data
				s->type = SNOPTRDATA;
				s->size = sym->value;
			}
			continue;
		} else if (sym->sectnum > 0) {
			sect = &obj->sect[sym->sectnum-1];
			if(sect->sym == 0)
				diag("%s: %s sym == 0!", pn, s->name);
		} else {
			diag("%s: %s sectnum < 0!", pn, s->name);
		}

		if(sect == nil) 
			return;

		if(s->outer != S) {
			if(s->dupok)
				continue;
			diag("%s: duplicate symbol reference: %s in both %s and %s", pn, s->name, s->outer->name, sect->sym->name);
			errorexit();
		}
		s->sub = sect->sym->sub;
		sect->sym->sub = s;
		s->type = sect->sym->type | SSUB;
		s->value = sym->value;
		s->size = 4;
		s->outer = sect->sym;
		if(sect->sym->type == STEXT) {
			if(s->external && !s->dupok)
				diag("%s: duplicate definition of %s", pn, s->name);
			s->external = 1;
		}
	}

	// Sort outer lists by address, adding to textp.
	// This keeps textp in increasing address order.
	for(i=0; i<obj->nsect; i++) {
		s = obj->sect[i].sym;
		if(s == S)
			continue;
		if(s->sub)
			s->sub = listsort(s->sub, valuecmp, offsetof(LSym, sub));
		if(s->type == STEXT) {
			if(s->onlist)
				sysfatal("symbol %s listed multiple times", s->name);
			s->onlist = 1;
			if(ctxt->etextp)
				ctxt->etextp->next = s;
			else
				ctxt->textp = s;
			ctxt->etextp = s;
			for(s = s->sub; s != S; s = s->sub) {
				if(s->onlist)
					sysfatal("symbol %s listed multiple times", s->name);
				s->onlist = 1;
				ctxt->etextp->next = s;
				ctxt->etextp = s;
			}
		}
	}

	return;
bad:
	diag("%s: malformed pe file: %r", pn);
}

static int
map(PeObj *obj, PeSect *sect)
{
	if(sect->base != nil)
		return 0;

	sect->base = mal(sect->sh.SizeOfRawData);
	if(sect->sh.PointerToRawData == 0) // .bss doesn't have data in object file
		return 0;
	werrstr("short read");
	if(Bseek(obj->f, obj->base+sect->sh.PointerToRawData, 0) < 0 || 
			Bread(obj->f, sect->base, sect->sh.SizeOfRawData) != sect->sh.SizeOfRawData)
		return -1;
	
	return 0;
}

static int
issect(PeSym *s)
{
	return s->sclass == IMAGE_SYM_CLASS_STATIC && s->type == 0 && s->name[0] == '.';
}

static int
readsym(PeObj *obj, int i, PeSym **y)
{
	LSym *s;
	PeSym *sym;
	char *name, *p;

	if(i >= obj->npesym || i < 0) {
		werrstr("invalid pe symbol index");
		return -1;
	}

	sym = &obj->pesym[i];
	*y = sym;
	
	if(issect(sym))
		name = obj->sect[sym->sectnum-1].sym->name;
	else {
		name = sym->name;
		if(strncmp(name, "__imp_", 6) == 0)
			name = &name[6]; // __imp_Name => Name
		if(thechar == '8' && name[0] == '_')
			name = &name[1]; // _Name => Name
	}
	// remove last @XXX
	p = strchr(name, '@');
	if(p)
		*p = 0;
	
	switch(sym->type) {
	default:
		werrstr("%s: invalid symbol type %d", sym->name, sym->type);
		return -1;
	case IMAGE_SYM_DTYPE_FUNCTION:
	case IMAGE_SYM_DTYPE_NULL:
		switch(sym->sclass) {
		case IMAGE_SYM_CLASS_EXTERNAL: //global
			s = linklookup(ctxt, name, 0);
			break;
		case IMAGE_SYM_CLASS_NULL:
		case IMAGE_SYM_CLASS_STATIC:
		case IMAGE_SYM_CLASS_LABEL:
			s = linklookup(ctxt, name, ctxt->version);
			s->dupok = 1;
			break;
		default:
			werrstr("%s: invalid symbol binding %d", sym->name, sym->sclass);
			return -1;
		}
		break;
	}

	if(s != nil && s->type == 0 && !(sym->sclass == IMAGE_SYM_CLASS_STATIC && sym->value == 0))
		s->type = SXREF;
	if(strncmp(sym->name, "__imp_", 6) == 0)
		s->got = -2; // flag for __imp_
	sym->sym = s;

	return 0;
}
                                                                                                                  root/go1.4/src/cmd/ld/lib.c                                                                         0100644 0000000 0000000 00000103471 12600426226 013731  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6l/obj.c and utils/6l/span.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/obj.c
// http://code.google.com/p/inferno-os/source/browse/utils/6l/span.c
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

#include	"l.h"
#include	"lib.h"
#include	"../ld/elf.h"
#include	"../ld/dwarf.h"
#include	"../../runtime/stack.h"
#include	"../../runtime/funcdata.h"

#include	<ar.h>
#if !(defined(_WIN32) || defined(PLAN9))
#include	<sys/stat.h>
#endif

enum
{
	// Whether to assume that the external linker is "gold"
	// (http://sourceware.org/ml/binutils/2008-03/msg00162.html).
	AssumeGoldLinker = 0,
};

int iconv(Fmt*);

char	symname[]	= SYMDEF;
char	pkgname[]	= "__.PKGDEF";
static int	cout = -1;

extern int	version;

// Set if we see an object compiled by the host compiler that is not
// from a package that is known to support internal linking mode.
static int	externalobj = 0;

static	void	hostlinksetup(void);

char*	goroot;
char*	goarch;
char*	goos;
char*	theline;

void
Lflag(char *arg)
{
	char **p;

	if(ctxt->nlibdir >= ctxt->maxlibdir) {
		if (ctxt->maxlibdir == 0)
			ctxt->maxlibdir = 8;
		else
			ctxt->maxlibdir *= 2;
		p = erealloc(ctxt->libdir, ctxt->maxlibdir * sizeof(*p));
		ctxt->libdir = p;
	}
	ctxt->libdir[ctxt->nlibdir++] = arg;
}

/*
 * Unix doesn't like it when we write to a running (or, sometimes,
 * recently run) binary, so remove the output file before writing it.
 * On Windows 7, remove() can force a subsequent create() to fail.
 * S_ISREG() does not exist on Plan 9.
 */
static void
mayberemoveoutfile(void) 
{
#if !(defined(_WIN32) || defined(PLAN9))
	struct stat st;
	if(lstat(outfile, &st) == 0 && !S_ISREG(st.st_mode))
		return;
#endif
	remove(outfile);
}

void
libinit(void)
{
	char *suffix, *suffixsep;

	funcalign = FuncAlign;
	fmtinstall('i', iconv);
	fmtinstall('Y', Yconv);
	fmtinstall('Z', Zconv);
	mywhatsys();	// get goroot, goarch, goos

	// add goroot to the end of the libdir list.
	suffix = "";
	suffixsep = "";
	if(flag_installsuffix != nil) {
		suffixsep = "_";
		suffix = flag_installsuffix;
	} else if(flag_race) {
		suffixsep = "_";
		suffix = "race";
	}
	Lflag(smprint("%s/pkg/%s_%s%s%s", goroot, goos, goarch, suffixsep, suffix));

	mayberemoveoutfile();
	cout = create(outfile, 1, 0775);
	if(cout < 0) {
		diag("cannot create %s: %r", outfile);
		errorexit();
	}

	if(INITENTRY == nil) {
		INITENTRY = mal(strlen(goarch)+strlen(goos)+20);
		if(!flag_shared) {
			sprint(INITENTRY, "_rt0_%s_%s", goarch, goos);
		} else {
			sprint(INITENTRY, "_rt0_%s_%s_lib", goarch, goos);
		}
	}
	linklookup(ctxt, INITENTRY, 0)->type = SXREF;
}

void
errorexit(void)
{
	if(cout >= 0) {
		// For rmtemp run at atexit time on Windows.
		close(cout);
	}
	if(nerrors) {
		if(cout >= 0)
			mayberemoveoutfile();
		exits("error");
	}
	exits(0);
}

void
loadinternal(char *name)
{
	char pname[1024];
	int i, found;

	found = 0;
	for(i=0; i<ctxt->nlibdir; i++) {
		snprint(pname, sizeof pname, "%s/%s.a", ctxt->libdir[i], name);
		if(debug['v'])
			Bprint(&bso, "searching for %s.a in %s\n", name, pname);
		if(access(pname, AEXIST) >= 0) {
			addlibpath(ctxt, "internal", "internal", pname, name);
			found = 1;
			break;
		}
	}
	if(!found)
		Bprint(&bso, "warning: unable to find %s.a\n", name);
}

void
loadlib(void)
{
	int i, w, x;
	LSym *s, *tlsg;
	char* cgostrsym;

	if(flag_shared) {
		s = linklookup(ctxt, "runtime.islibrary", 0);
		s->dupok = 1;
		adduint8(ctxt, s, 1);
	}

	loadinternal("runtime");
	if(thechar == '5')
		loadinternal("math");
	if(flag_race)
		loadinternal("runtime/race");

	for(i=0; i<ctxt->libraryp; i++) {
		if(debug['v'] > 1)
			Bprint(&bso, "%5.2f autolib: %s (from %s)\n", cputime(), ctxt->library[i].file, ctxt->library[i].objref);
		iscgo |= strcmp(ctxt->library[i].pkg, "runtime/cgo") == 0;
		objfile(ctxt->library[i].file, ctxt->library[i].pkg);
	}
	
	if(linkmode == LinkExternal && !iscgo) {
		// This indicates a user requested -linkmode=external.
		// The startup code uses an import of runtime/cgo to decide
		// whether to initialize the TLS.  So give it one.  This could
		// be handled differently but it's an unusual case.
		loadinternal("runtime/cgo");
		if(i < ctxt->libraryp)
			objfile(ctxt->library[i].file, ctxt->library[i].pkg);

		// Pretend that we really imported the package.
		s = linklookup(ctxt, "go.importpath.runtime/cgo.", 0);
		s->type = SDATA;
		s->dupok = 1;
		s->reachable = 1;

		// Provided by the code that imports the package.
		// Since we are simulating the import, we have to provide this string.
		cgostrsym = "go.string.\"runtime/cgo\"";
		if(linkrlookup(ctxt, cgostrsym, 0) == nil) {
			s = linklookup(ctxt, cgostrsym, 0);
			s->type = SRODATA;
			s->reachable = 1;
			addstrdata(cgostrsym, "runtime/cgo");
		}
	}

	if(linkmode == LinkAuto) {
		if(iscgo && externalobj)
			linkmode = LinkExternal;
		else
			linkmode = LinkInternal;

		// Force external linking for android.
		if(strcmp(goos, "android") == 0)
			linkmode = LinkExternal;
	}

	if(linkmode == LinkInternal) {
		// Drop all the cgo_import_static declarations.
		// Turns out we won't be needing them.
		for(s = ctxt->allsym; s != S; s = s->allsym)
			if(s->type == SHOSTOBJ) {
				// If a symbol was marked both
				// cgo_import_static and cgo_import_dynamic,
				// then we want to make it cgo_import_dynamic
				// now.
				if(s->extname != nil && s->dynimplib != nil && s->cgoexport == 0) {
					s->type = SDYNIMPORT;
				} else
					s->type = 0;
			}
	}
	
	tlsg = linklookup(ctxt, "runtime.tlsg", 0);
	tlsg->type = STLSBSS;
	tlsg->size = PtrSize;
	tlsg->hide = 1;
	tlsg->reachable = 1;
	ctxt->tlsg = tlsg;

	// Now that we know the link mode, trim the dynexp list.
	x = CgoExportDynamic;
	if(linkmode == LinkExternal)
		x = CgoExportStatic;
	w = 0;
	for(i=0; i<ndynexp; i++)
		if(dynexp[i]->cgoexport & x)
			dynexp[w++] = dynexp[i];
	ndynexp = w;
	
	// In internal link mode, read the host object files.
	if(linkmode == LinkInternal)
		hostobjs();
	else
		hostlinksetup();

	// We've loaded all the code now.
	// If there are no dynamic libraries needed, gcc disables dynamic linking.
	// Because of this, glibc's dynamic ELF loader occasionally (like in version 2.13)
	// assumes that a dynamic binary always refers to at least one dynamic library.
	// Rather than be a source of test cases for glibc, disable dynamic linking
	// the same way that gcc would.
	//
	// Exception: on OS X, programs such as Shark only work with dynamic
	// binaries, so leave it enabled on OS X (Mach-O) binaries.
	// Also leave it enabled on Solaris which doesn't support
	// statically linked binaries.
	if(!flag_shared && !havedynamic && HEADTYPE != Hdarwin && HEADTYPE != Hsolaris)
		debug['d'] = 1;
	
	importcycles();
}

/*
 * look for the next file in an archive.
 * adapted from libmach.
 */
static vlong
nextar(Biobuf *bp, vlong off, struct ar_hdr *a)
{
	int r;
	int32 arsize;
	char *buf;

	if (off&01)
		off++;
	Bseek(bp, off, 0);
	buf = Brdline(bp, '\n');
	r = Blinelen(bp);
	if(buf == nil) {
		if(r == 0)
			return 0;
		return -1;
	}
	if(r != SAR_HDR)
		return -1;
	memmove(a, buf, SAR_HDR);
	if(strncmp(a->fmag, ARFMAG, sizeof a->fmag))
		return -1;
	arsize = strtol(a->size, 0, 0);
	if (arsize&1)
		arsize++;
	return arsize + r;
}

void
objfile(char *file, char *pkg)
{
	vlong off, l;
	Biobuf *f;
	char magbuf[SARMAG];
	char pname[150];
	struct ar_hdr arhdr;

	pkg = smprint("%i", pkg);

	if(debug['v'] > 1)
		Bprint(&bso, "%5.2f ldobj: %s (%s)\n", cputime(), file, pkg);
	Bflush(&bso);
	f = Bopen(file, 0);
	if(f == nil) {
		diag("cannot open file: %s", file);
		errorexit();
	}
	l = Bread(f, magbuf, SARMAG);
	if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
		/* load it as a regular file */
		l = Bseek(f, 0L, 2);
		Bseek(f, 0L, 0);
		ldobj(f, pkg, l, file, file, FileObj);
		Bterm(f);
		free(pkg);
		return;
	}
	
	/* skip over optional __.GOSYMDEF and process __.PKGDEF */
	off = Boffset(f);
	l = nextar(f, off, &arhdr);
	if(l <= 0) {
		diag("%s: short read on archive file symbol header", file);
		goto out;
	}
	if(strncmp(arhdr.name, symname, strlen(symname)) == 0) {
		off += l;
		l = nextar(f, off, &arhdr);
		if(l <= 0) {
			diag("%s: short read on archive file symbol header", file);
			goto out;
		}
	}

	if(strncmp(arhdr.name, pkgname, strlen(pkgname))) {
		diag("%s: cannot find package header", file);
		goto out;
	}
	off += l;

	if(debug['u'])
		ldpkg(f, pkg, atolwhex(arhdr.size), file, Pkgdef);

	/*
	 * load all the object files from the archive now.
	 * this gives us sequential file access and keeps us
	 * from needing to come back later to pick up more
	 * objects.  it breaks the usual C archive model, but
	 * this is Go, not C.  the common case in Go is that
	 * we need to load all the objects, and then we throw away
	 * the individual symbols that are unused.
	 *
	 * loading every object will also make it possible to
	 * load foreign objects not referenced by __.GOSYMDEF.
	 */
	for(;;) {
		l = nextar(f, off, &arhdr);
		if(l == 0)
			break;
		if(l < 0) {
			diag("%s: malformed archive", file);
			goto out;
		}
		off += l;

		l = SARNAME;
		while(l > 0 && arhdr.name[l-1] == ' ')
			l--;
		snprint(pname, sizeof pname, "%s(%.*s)", file, utfnlen(arhdr.name, l), arhdr.name);
		l = atolwhex(arhdr.size);
		ldobj(f, pkg, l, pname, file, ArchiveObj);
	}

out:
	Bterm(f);
	free(pkg);
}

static void
dowrite(int fd, char *p, int n)
{
	int m;
	
	while(n > 0) {
		m = write(fd, p, n);
		if(m <= 0) {
			ctxt->cursym = S;
			diag("write error: %r");
			errorexit();
		}
		n -= m;
		p += m;
	}
}

typedef struct Hostobj Hostobj;

struct Hostobj
{
	void (*ld)(Biobuf*, char*, int64, char*);
	char *pkg;
	char *pn;
	char *file;
	int64 off;
	int64 len;
};

Hostobj *hostobj;
int nhostobj;
int mhostobj;

// These packages can use internal linking mode.
// Others trigger external mode.
const char *internalpkg[] = {
	"crypto/x509",
	"net",
	"os/user",
	"runtime/cgo",
	"runtime/race"
};

void
ldhostobj(void (*ld)(Biobuf*, char*, int64, char*), Biobuf *f, char *pkg, int64 len, char *pn, char *file)
{
	int i, isinternal;
	Hostobj *h;

	isinternal = 0;
	for(i=0; i<nelem(internalpkg); i++) {
		if(strcmp(pkg, internalpkg[i]) == 0) {
			isinternal = 1;
			break;
		}
	}

	// DragonFly declares errno with __thread, which results in a symbol
	// type of R_386_TLS_GD or R_X86_64_TLSGD. The Go linker does not
	// currently know how to handle TLS relocations, hence we have to
	// force external linking for any libraries that link in code that
	// uses errno. This can be removed if the Go linker ever supports
	// these relocation types.
	if(HEADTYPE == Hdragonfly)
	if(strcmp(pkg, "net") == 0 || strcmp(pkg, "os/user") == 0)
		isinternal = 0;

	if(!isinternal)
		externalobj = 1;

	if(nhostobj >= mhostobj) {
		if(mhostobj == 0)
			mhostobj = 16;
		else
			mhostobj *= 2;
		hostobj = erealloc(hostobj, mhostobj*sizeof hostobj[0]);
	}
	h = &hostobj[nhostobj++];
	h->ld = ld;
	h->pkg = estrdup(pkg);
	h->pn = estrdup(pn);
	h->file = estrdup(file);
	h->off = Boffset(f);
	h->len = len;
}

void
hostobjs(void)
{
	int i;
	Biobuf *f;
	Hostobj *h;
	
	for(i=0; i<nhostobj; i++) {
		h = &hostobj[i];
		f = Bopen(h->file, OREAD);
		if(f == nil) {
			ctxt->cursym = S;
			diag("cannot reopen %s: %r", h->pn);
			errorexit();
		}
		Bseek(f, h->off, 0);
		h->ld(f, h->pkg, h->len, h->pn);
		Bterm(f);
	}
}

// provided by lib9
int runcmd(char**);
char* mktempdir(void);
void removeall(char*);

static void
rmtemp(void)
{
	removeall(tmpdir);
}

static void
hostlinksetup(void)
{
	char *p;

	if(linkmode != LinkExternal)
		return;

	// create temporary directory and arrange cleanup
	if(tmpdir == nil) {
		tmpdir = mktempdir();
		atexit(rmtemp);
	}

	// change our output to temporary object file
	close(cout);
	p = smprint("%s/go.o", tmpdir);
	cout = create(p, 1, 0775);
	if(cout < 0) {
		diag("cannot create %s: %r", p);
		errorexit();
	}
	free(p);
}

void
hostlink(void)
{
	char *p, **argv;
	int c, i, w, n, argc, len;
	Hostobj *h;
	Biobuf *f;
	static char buf[64<<10];

	if(linkmode != LinkExternal || nerrors > 0)
		return;

	c = 0;
	p = extldflags;
	while(p != nil) {
		while(*p == ' ')
			p++;
		if(*p == '\0')
			break;
		c++;
		p = strchr(p + 1, ' ');
	}

	argv = malloc((14+nhostobj+nldflag+c)*sizeof argv[0]);
	argc = 0;
	if(extld == nil)
		extld = "gcc";
	argv[argc++] = extld;
	switch(thechar){
	case '8':
		argv[argc++] = "-m32";
		break;
	case '6':
		argv[argc++] = "-m64";
		break;
	case '5':
		argv[argc++] = "-marm";
		break;
	}
	if(!debug['s'] && !debug_s) {
		argv[argc++] = "-gdwarf-2"; 
	} else {
		argv[argc++] = "-s";
	}
	if(HEADTYPE == Hdarwin)
		argv[argc++] = "-Wl,-no_pie,-pagezero_size,4000000";
	if(HEADTYPE == Hopenbsd)
		argv[argc++] = "-Wl,-nopie";
	
	if(iself && AssumeGoldLinker)
		argv[argc++] = "-Wl,--rosegment";

	if(flag_shared) {
		argv[argc++] = "-Wl,-Bsymbolic";
		argv[argc++] = "-shared";
	}
	argv[argc++] = "-o";
	argv[argc++] = outfile;
	
	if(rpath)
		argv[argc++] = smprint("-Wl,-rpath,%s", rpath);

	// Force global symbols to be exported for dlopen, etc.
	if(iself)
		argv[argc++] = "-rdynamic";

	if(strstr(argv[0], "clang") != nil)
		argv[argc++] = "-Qunused-arguments";

	// already wrote main object file
	// copy host objects to temporary directory
	for(i=0; i<nhostobj; i++) {
		h = &hostobj[i];
		f = Bopen(h->file, OREAD);
		if(f == nil) {
			ctxt->cursym = S;
			diag("cannot reopen %s: %r", h->pn);
			errorexit();
		}
		Bseek(f, h->off, 0);
		p = smprint("%s/%06d.o", tmpdir, i);
		argv[argc++] = p;
		w = create(p, 1, 0775);
		if(w < 0) {
			ctxt->cursym = S;
			diag("cannot create %s: %r", p);
			errorexit();
		}
		len = h->len;
		while(len > 0 && (n = Bread(f, buf, sizeof buf)) > 0){
			if(n > len)
				n = len;
			dowrite(w, buf, n);
			len -= n;
		}
		if(close(w) < 0) {
			ctxt->cursym = S;
			diag("cannot write %s: %r", p);
			errorexit();
		}
		Bterm(f);
	}
	
	argv[argc++] = smprint("%s/go.o", tmpdir);
	for(i=0; i<nldflag; i++)
		argv[argc++] = ldflag[i];

	p = extldflags;
	while(p != nil) {
		while(*p == ' ')
			*p++ = '\0';
		if(*p == '\0')
			break;
		argv[argc++] = p;

		// clang, unlike GCC, passes -rdynamic to the linker
		// even when linking with -static, causing a linker
		// error when using GNU ld.  So take out -rdynamic if
		// we added it.  We do it in this order, rather than
		// only adding -rdynamic later, so that -extldflags
		// can override -rdynamic without using -static.
		if(iself && strncmp(p, "-static", 7) == 0 && (p[7]==' ' || p[7]=='\0')) {
			for(i=0; i<argc; i++) {
				if(strcmp(argv[i], "-rdynamic") == 0)
					argv[i] = "-static";
			}
		}

		p = strchr(p + 1, ' ');
	}

	argv[argc] = nil;

	quotefmtinstall();
	if(debug['v']) {
		Bprint(&bso, "host link:");
		for(i=0; i<argc; i++)
			Bprint(&bso, " %q", argv[i]);
		Bprint(&bso, "\n");
		Bflush(&bso);
	}

	if(runcmd(argv) < 0) {
		ctxt->cursym = S;
		diag("%s: running %s failed: %r", argv0, argv[0]);
		errorexit();
	}
}

void
ldobj(Biobuf *f, char *pkg, int64 len, char *pn, char *file, int whence)
{
	char *line;
	int n, c1, c2, c3, c4;
	uint32 magic;
	vlong import0, import1, eof;
	char *t;

	eof = Boffset(f) + len;

	pn = estrdup(pn);

	c1 = BGETC(f);
	c2 = BGETC(f);
	c3 = BGETC(f);
	c4 = BGETC(f);
	Bungetc(f);
	Bungetc(f);
	Bungetc(f);
	Bungetc(f);

	magic = c1<<24 | c2<<16 | c3<<8 | c4;
	if(magic == 0x7f454c46) {	// \x7F E L F
		ldhostobj(ldelf, f, pkg, len, pn, file);
		return;
	}
	if((magic&~1) == 0xfeedface || (magic&~0x01000000) == 0xcefaedfe) {
		ldhostobj(ldmacho, f, pkg, len, pn, file);
		return;
	}
	if(c1 == 0x4c && c2 == 0x01 || c1 == 0x64 && c2 == 0x86) {
		ldhostobj(ldpe, f, pkg, len, pn, file);
		return;
	}

	/* check the header */
	line = Brdline(f, '\n');
	if(line == nil) {
		if(Blinelen(f) > 0) {
			diag("%s: not an object file", pn);
			return;
		}
		goto eof;
	}
	n = Blinelen(f) - 1;
	line[n] = '\0';
	if(strncmp(line, "go object ", 10) != 0) {
		if(strlen(pn) > 3 && strcmp(pn+strlen(pn)-3, ".go") == 0) {
			print("%cl: input %s is not .%c file (use %cg to compile .go files)\n", thechar, pn, thechar, thechar);
			errorexit();
		}
		if(strcmp(line, thestring) == 0) {
			// old header format: just $GOOS
			diag("%s: stale object file", pn);
			return;
		}
		diag("%s: not an object file", pn);
		free(pn);
		return;
	}
	
	// First, check that the basic goos, goarch, and version match.
	t = smprint("%s %s %s ", goos, getgoarch(), getgoversion());
	line[n] = ' ';
	if(strncmp(line+10, t, strlen(t)) != 0 && !debug['f']) {
		line[n] = '\0';
		diag("%s: object is [%s] expected [%s]", pn, line+10, t);
		free(t);
		free(pn);
		return;
	}
	
	// Second, check that longer lines match each other exactly,
	// so that the Go compiler and write additional information
	// that must be the same from run to run.
	line[n] = '\0';
	if(n-10 > strlen(t)) {
		if(theline == nil)
			theline = estrdup(line+10);
		else if(strcmp(theline, line+10) != 0) {
			line[n] = '\0';
			diag("%s: object is [%s] expected [%s]", pn, line+10, theline);
			free(t);
			free(pn);
			return;
		}
	}
	free(t);
	line[n] = '\n';

	/* skip over exports and other info -- ends with \n!\n */
	import0 = Boffset(f);
	c1 = '\n';	// the last line ended in \n
	c2 = BGETC(f);
	c3 = BGETC(f);
	while(c1 != '\n' || c2 != '!' || c3 != '\n') {
		c1 = c2;
		c2 = c3;
		c3 = BGETC(f);
		if(c3 == Beof)
			goto eof;
	}
	import1 = Boffset(f);

	Bseek(f, import0, 0);
	ldpkg(f, pkg, import1 - import0 - 2, pn, whence);	// -2 for !\n
	Bseek(f, import1, 0);

	ldobjfile(ctxt, f, pkg, eof - Boffset(f), pn);
	free(pn);
	return;

eof:
	diag("truncated object file: %s", pn);
	free(pn);
}

void
zerosig(char *sp)
{
	LSym *s;

	s = linklookup(ctxt, sp, 0);
	s->sig = 0;
}

void
mywhatsys(void)
{
	goroot = getgoroot();
	goos = getgoos();
	goarch = getgoarch();

	if(strncmp(goarch, thestring, strlen(thestring)) != 0)
		sysfatal("cannot use %cc with GOARCH=%s", thechar, goarch);
}

int
pathchar(void)
{
	return '/';
}

static	uchar*	hunk;
static	uint32	nhunk;
#define	NHUNK	(10UL<<20)

void*
mal(uint32 n)
{
	void *v;

	n = (n+7)&~7;
	if(n > NHUNK) {
		v = malloc(n);
		if(v == nil) {
			diag("out of memory");
			errorexit();
		}
		memset(v, 0, n);
		return v;
	}
	if(n > nhunk) {
		hunk = malloc(NHUNK);
		if(hunk == nil) {
			diag("out of memory");
			errorexit();
		}
		nhunk = NHUNK;
	}

	v = hunk;
	nhunk -= n;
	hunk += n;

	memset(v, 0, n);
	return v;
}

void
unmal(void *v, uint32 n)
{
	n = (n+7)&~7;
	if(hunk - n == v) {
		hunk -= n;
		nhunk += n;
	}
}

// Copied from ../gc/subr.c:/^pathtoprefix; must stay in sync.
/*
 * Convert raw string to the prefix that will be used in the symbol table.
 * Invalid bytes turn into %xx.	 Right now the only bytes that need
 * escaping are %, ., and ", but we escape all control characters too.
 *
 * If you edit this, edit ../gc/subr.c:/^pathtoprefix too.
 * If you edit this, edit ../../debug/goobj/read.go:/importPathToPrefix too.
 */
static char*
pathtoprefix(char *s)
{
	static char hex[] = "0123456789abcdef";
	char *p, *r, *w, *l;
	int n;

	// find first character past the last slash, if any.
	l = s;
	for(r=s; *r; r++)
		if(*r == '/')
			l = r+1;

	// check for chars that need escaping
	n = 0;
	for(r=s; *r; r++)
		if(*r <= ' ' || (*r == '.' && r >= l) || *r == '%' || *r == '"' || *r >= 0x7f)
			n++;

	// quick exit
	if(n == 0)
		return s;

	// escape
	p = mal((r-s)+1+2*n);
	for(r=s, w=p; *r; r++) {
		if(*r <= ' ' || (*r == '.' && r >= l) || *r == '%' || *r == '"' || *r >= 0x7f) {
			*w++ = '%';
			*w++ = hex[(*r>>4)&0xF];
			*w++ = hex[*r&0xF];
		} else
			*w++ = *r;
	}
	*w = '\0';
	return p;
}

int
iconv(Fmt *fp)
{
	char *p;

	p = va_arg(fp->args, char*);
	if(p == nil) {
		fmtstrcpy(fp, "<nil>");
		return 0;
	}
	p = pathtoprefix(p);
	fmtstrcpy(fp, p);
	return 0;
}

Section*
addsection(Segment *seg, char *name, int rwx)
{
	Section **l;
	Section *sect;
	
	for(l=&seg->sect; *l; l=&(*l)->next)
		;
	sect = mal(sizeof *sect);
	sect->rwx = rwx;
	sect->name = name;
	sect->seg = seg;
	sect->align = PtrSize; // everything is at least pointer-aligned
	*l = sect;
	return sect;
}

uint16
le16(uchar *b)
{
	return b[0] | b[1]<<8;
}

uint32
le32(uchar *b)
{
	return b[0] | b[1]<<8 | b[2]<<16 | (uint32)b[3]<<24;
}

uint64
le64(uchar *b)
{
	return le32(b) | (uint64)le32(b+4)<<32;
}

uint16
be16(uchar *b)
{
	return b[0]<<8 | b[1];
}

uint32
be32(uchar *b)
{
	return (uint32)b[0]<<24 | b[1]<<16 | b[2]<<8 | b[3];
}

uint64
be64(uchar *b)
{
	return (uvlong)be32(b)<<32 | be32(b+4);
}

Endian be = { be16, be32, be64 };
Endian le = { le16, le32, le64 };

typedef struct Chain Chain;
struct Chain
{
	LSym *sym;
	Chain *up;
	int limit;  // limit on entry to sym
};

static int stkcheck(Chain*, int);
static void stkprint(Chain*, int);
static void stkbroke(Chain*, int);
static LSym *morestack;
static LSym *newstack;

enum
{
	HasLinkRegister = (thechar == '5'),
};

// TODO: Record enough information in new object files to
// allow stack checks here.

static int
callsize(void)
{
	if(thechar == '5')
		return 0;
	return RegSize;
}

void
dostkcheck(void)
{
	Chain ch;
	LSym *s;
	
	morestack = linklookup(ctxt, "runtime.morestack", 0);
	newstack = linklookup(ctxt, "runtime.newstack", 0);

	// Every splitting function ensures that there are at least StackLimit
	// bytes available below SP when the splitting prologue finishes.
	// If the splitting function calls F, then F begins execution with
	// at least StackLimit - callsize() bytes available.
	// Check that every function behaves correctly with this amount
	// of stack, following direct calls in order to piece together chains
	// of non-splitting functions.
	ch.up = nil;
	ch.limit = StackLimit - callsize();

	// Check every function, but do the nosplit functions in a first pass,
	// to make the printed failure chains as short as possible.
	for(s = ctxt->textp; s != nil; s = s->next) {
		// runtime.racesymbolizethunk is called from gcc-compiled C
		// code running on the operating system thread stack.
		// It uses more than the usual amount of stack but that's okay.
		if(strcmp(s->name, "runtime.racesymbolizethunk") == 0)
			continue;

		if(s->nosplit) {
		ctxt->cursym = s;
		ch.sym = s;
		stkcheck(&ch, 0);
	}
	}
	for(s = ctxt->textp; s != nil; s = s->next) {
		if(!s->nosplit) {
		ctxt->cursym = s;
		ch.sym = s;
		stkcheck(&ch, 0);
	}
}
}

static int
stkcheck(Chain *up, int depth)
{
	Chain ch, ch1;
	LSym *s;
	int limit;
	Reloc *r, *endr;
	Pciter pcsp;
	
	limit = up->limit;
	s = up->sym;
	
	// Don't duplicate work: only need to consider each
	// function at top of safe zone once.
	if(limit == StackLimit-callsize()) {
		if(s->stkcheck)
		return 0;
		s->stkcheck = 1;
	}
	
	if(depth > 100) {
		diag("nosplit stack check too deep");
		stkbroke(up, 0);
		return -1;
	}

	if(s->external || s->pcln == nil) {
		// external function.
		// should never be called directly.
		// only diagnose the direct caller.
		if(depth == 1 && s->type != SXREF)
			diag("call to external function %s", s->name);
		return -1;
	}

	if(limit < 0) {
		stkbroke(up, limit);
		return -1;
	}

	// morestack looks like it calls functions,
	// but it switches the stack pointer first.
	if(s == morestack)
		return 0;

	ch.up = up;
	
	// Walk through sp adjustments in function, consuming relocs.
	r = s->r;
	endr = r + s->nr;
	for(pciterinit(ctxt, &pcsp, &s->pcln->pcsp); !pcsp.done; pciternext(&pcsp)) {
		// pcsp.value is in effect for [pcsp.pc, pcsp.nextpc).

		// Check stack size in effect for this span.
		if(limit - pcsp.value < 0) {
			stkbroke(up, limit - pcsp.value);
			return -1;
		}

		// Process calls in this span.
		for(; r < endr && r->off < pcsp.nextpc; r++) {
			switch(r->type) {
			case R_CALL:
			case R_CALLARM:
				// Direct call.
				ch.limit = limit - pcsp.value - callsize();
				ch.sym = r->sym;
				if(stkcheck(&ch, depth+1) < 0)
					return -1;

				// If this is a call to morestack, we've just raised our limit back
				// to StackLimit beyond the frame size.
				if(strncmp(r->sym->name, "runtime.morestack", 17) == 0) {
					limit = StackLimit + s->locals;
					if(thechar == '5')
						limit += 4; // saved LR
				}
				break;

			case R_CALLIND:
				// Indirect call.  Assume it is a call to a splitting function,
				// so we have to make sure it can call morestack.
				// Arrange the data structures to report both calls, so that
				// if there is an error, stkprint shows all the steps involved.
				ch.limit = limit - pcsp.value - callsize();
				ch.sym = nil;
				ch1.limit = ch.limit - callsize(); // for morestack in called prologue
				ch1.up = &ch;
				ch1.sym = morestack;
				if(stkcheck(&ch1, depth+2) < 0)
					return -1;
				break;
			}
		}
		}
		
	return 0;
}

static void
stkbroke(Chain *ch, int limit)
{
	diag("nosplit stack overflow");
	stkprint(ch, limit);
}

static void
stkprint(Chain *ch, int limit)
{
	char *name;

	if(ch->sym)
		name = ch->sym->name;
	else
		name = "function pointer";

	if(ch->up == nil) {
		// top of chain.  ch->sym != nil.
		if(ch->sym->nosplit)
			print("\t%d\tassumed on entry to %s\n", ch->limit, name);
		else
			print("\t%d\tguaranteed after split check in %s\n", ch->limit, name);
	} else {
		stkprint(ch->up, ch->limit + (!HasLinkRegister)*PtrSize);
		if(!HasLinkRegister)
			print("\t%d\ton entry to %s\n", ch->limit, name);
	}
	if(ch->limit != limit)
		print("\t%d\tafter %s uses %d\n", limit, name, ch->limit - limit);
}

int
Yconv(Fmt *fp)
{
	LSym *s;
	Fmt fmt;
	int i;
	char *str;

	s = va_arg(fp->args, LSym*);
	if (s == S) {
		fmtprint(fp, "<nil>");
	} else {
		fmtstrinit(&fmt);
		fmtprint(&fmt, "%s @0x%08llx [%lld]", s->name, (vlong)s->value, (vlong)s->size);
		for (i = 0; i < s->size; i++) {
			if (!(i%8)) fmtprint(&fmt,  "\n\t0x%04x ", i);
			fmtprint(&fmt, "%02x ", s->p[i]);
		}
		fmtprint(&fmt, "\n");
		for (i = 0; i < s->nr; i++) {
			fmtprint(&fmt, "\t0x%04x[%x] %d %s[%llx]\n",
			      s->r[i].off,
			      s->r[i].siz,
			      s->r[i].type,
			      s->r[i].sym->name,
			      (vlong)s->r[i].add);
		}
		str = fmtstrflush(&fmt);
		fmtstrcpy(fp, str);
		free(str);
	}

	return 0;
}

vlong coutpos;

void
cflush(void)
{
	int n;

	if(cbpmax < cbp)
		cbpmax = cbp;
	n = cbpmax - buf.cbuf;
	dowrite(cout, buf.cbuf, n);
	coutpos += n;
	cbp = buf.cbuf;
	cbc = sizeof(buf.cbuf);
	cbpmax = cbp;
}

vlong
cpos(void)
{
	return coutpos + cbp - buf.cbuf;
}

void
cseek(vlong p)
{
	vlong start;
	int delta;

	if(cbpmax < cbp)
		cbpmax = cbp;
	start = coutpos;
	if(start <= p && p <= start+(cbpmax - buf.cbuf)) {
//print("cseek %lld in [%lld,%lld] (%lld)\n", p, start, start+sizeof(buf.cbuf), cpos());
		delta = p - (start + cbp - buf.cbuf);
		cbp += delta;
		cbc -= delta;
//print("now at %lld\n", cpos());
		return;
	}

	cflush();
	seek(cout, p, 0);
	coutpos = p;
}

void
cwrite(void *buf, int n)
{
	cflush();
	if(n <= 0)
		return;
	dowrite(cout, buf, n);
	coutpos += n;
}

void
usage(void)
{
	fprint(2, "usage: %cl [options] main.%c\n", thechar, thechar);
	flagprint(2);
	exits("usage");
}

void
setheadtype(char *s)
{
	int h;
	
	h = headtype(s);
	if(h < 0) {
		fprint(2, "unknown header type -H %s\n", s);
		errorexit();
	}
	headstring = s;
	HEADTYPE = headtype(s);
}

void
setinterp(char *s)
{
	debug['I'] = 1; // denote cmdline interpreter override
	interpreter = s;
}

void
doversion(void)
{
	print("%cl version %s\n", thechar, getgoversion());
	errorexit();
}

void
genasmsym(void (*put)(LSym*, char*, int, vlong, vlong, int, LSym*))
{
	Auto *a;
	LSym *s;
	int32 off;

	// These symbols won't show up in the first loop below because we
	// skip STEXT symbols. Normal STEXT symbols are emitted by walking textp.
	s = linklookup(ctxt, "runtime.text", 0);
	if(s->type == STEXT)
		put(s, s->name, 'T', s->value, s->size, s->version, 0);
	s = linklookup(ctxt, "runtime.etext", 0);
	if(s->type == STEXT)
		put(s, s->name, 'T', s->value, s->size, s->version, 0);

	for(s=ctxt->allsym; s!=S; s=s->allsym) {
		if(s->hide || (s->name[0] == '.' && s->version == 0 && strcmp(s->name, ".rathole") != 0))
			continue;
		switch(s->type&SMASK) {
		case SCONST:
		case SRODATA:
		case SSYMTAB:
		case SPCLNTAB:
		case SDATA:
		case SNOPTRDATA:
		case SELFROSECT:
		case SMACHOGOT:
		case STYPE:
		case SSTRING:
		case SGOSTRING:
		case SWINDOWS:
			if(!s->reachable)
				continue;
			put(s, s->name, 'D', symaddr(s), s->size, s->version, s->gotype);
			continue;

		case SBSS:
		case SNOPTRBSS:
			if(!s->reachable)
				continue;
			if(s->np > 0)
				diag("%s should not be bss (size=%d type=%d special=%d)", s->name, (int)s->np, s->type, s->special);
			put(s, s->name, 'B', symaddr(s), s->size, s->version, s->gotype);
			continue;

		case SFILE:
			put(nil, s->name, 'f', s->value, 0, s->version, 0);
			continue;
		}
	}

	for(s = ctxt->textp; s != nil; s = s->next) {
		put(s, s->name, 'T', s->value, s->size, s->version, s->gotype);

		// NOTE(ality): acid can't produce a stack trace without .frame symbols
		put(nil, ".frame", 'm', s->locals+PtrSize, 0, 0, 0);

		for(a=s->autom; a; a=a->link) {
			// Emit a or p according to actual offset, even if label is wrong.
			// This avoids negative offsets, which cannot be encoded.
			if(a->type != A_AUTO && a->type != A_PARAM)
				continue;
			
			// compute offset relative to FP
			if(a->type == A_PARAM)
				off = a->aoffset;
			else
				off = a->aoffset - PtrSize;
			
			// FP
			if(off >= 0) {
				put(nil, a->asym->name, 'p', off, 0, 0, a->gotype);
				continue;
			}
			
			// SP
			if(off <= -PtrSize) {
				put(nil, a->asym->name, 'a', -(off+PtrSize), 0, 0, a->gotype);
				continue;
			}
			
			// Otherwise, off is addressing the saved program counter.
			// Something underhanded is going on. Say nothing.
		}
	}
	if(debug['v'] || debug['n'])
		Bprint(&bso, "%5.2f symsize = %ud\n", cputime(), symsize);
	Bflush(&bso);
}

vlong
symaddr(LSym *s)
{
	if(!s->reachable)
		diag("unreachable symbol in symaddr - %s", s->name);
	return s->value;
}

void
xdefine(char *p, int t, vlong v)
{
	LSym *s;

	s = linklookup(ctxt, p, 0);
	s->type = t;
	s->value = v;
	s->reachable = 1;
	s->special = 1;
}

vlong
datoff(vlong addr)
{
	if(addr >= segdata.vaddr)
		return addr - segdata.vaddr + segdata.fileoff;
	if(addr >= segtext.vaddr)
		return addr - segtext.vaddr + segtext.fileoff;
	diag("datoff %#llx", addr);
	return 0;
}

vlong
entryvalue(void)
{
	char *a;
	LSym *s;

	a = INITENTRY;
	if(*a >= '0' && *a <= '9')
		return atolwhex(a);
	s = linklookup(ctxt, a, 0);
	if(s->type == 0)
		return INITTEXT;
	if(s->type != STEXT)
		diag("entry not text: %s", s->name);
	return s->value;
}

static void
undefsym(LSym *s)
{
	int i;
	Reloc *r;

	ctxt->cursym = s;
	for(i=0; i<s->nr; i++) {
		r = &s->r[i];
		if(r->sym == nil) // happens for some external ARM relocs
			continue;
		if(r->sym->type == Sxxx || r->sym->type == SXREF)
			diag("undefined: %s", r->sym->name);
		if(!r->sym->reachable)
			diag("use of unreachable symbol: %s", r->sym->name);
	}
}

void
undef(void)
{
	LSym *s;
	
	for(s = ctxt->textp; s != nil; s = s->next)
		undefsym(s);
	for(s = datap; s != nil; s = s->next)
		undefsym(s);
	if(nerrors > 0)
		errorexit();
}

void
callgraph(void)
{
	LSym *s;
	Reloc *r;
	int i;

	if(!debug['c'])
		return;

	for(s = ctxt->textp; s != nil; s = s->next) {
		for(i=0; i<s->nr; i++) {
			r = &s->r[i];
			if(r->sym == nil)
				continue;
			if((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT)
				Bprint(&bso, "%s calls %s\n", s->name, r->sym->name);
		}
	}
}

void
diag(char *fmt, ...)
{
	char buf[1024], *tn, *sep;
	va_list arg;

	tn = "";
	sep = "";
	if(ctxt->cursym != S) {
		tn = ctxt->cursym->name;
		sep = ": ";
	}
	va_start(arg, fmt);
	vseprint(buf, buf+sizeof(buf), fmt, arg);
	va_end(arg);
	print("%s%s%s\n", tn, sep, buf);

	nerrors++;
	if(nerrors > 20) {
		print("too many errors\n");
		errorexit();
	}
}

void
checkgo(void)
{
	LSym *s;
	Reloc *r;
	int i;
	int changed;
	
	if(!debug['C'])
		return;
	
	// TODO(rsc,khr): Eventually we want to get to no Go-called C functions at all,
	// which would simplify this logic quite a bit.

	// Mark every Go-called C function with cfunc=2, recursively.
	do {
		changed = 0;
		for(s = ctxt->textp; s != nil; s = s->next) {
			if(s->cfunc == 0 || (s->cfunc == 2 && s->nosplit)) {
				for(i=0; i<s->nr; i++) {
					r = &s->r[i];
					if(r->sym == nil)
						continue;
					if((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT) {
						if(r->sym->cfunc == 1) {
							changed = 1;
							r->sym->cfunc = 2;
						}
					}
				}
			}
		}
	}while(changed);

	// Complain about Go-called C functions that can split the stack
	// (that can be preempted for garbage collection or trigger a stack copy).
	for(s = ctxt->textp; s != nil; s = s->next) {
		if(s->cfunc == 0 || (s->cfunc == 2 && s->nosplit)) {
			for(i=0; i<s->nr; i++) {
				r = &s->r[i];
				if(r->sym == nil)
					continue;
				if((r->type == R_CALL || r->type == R_CALLARM) && r->sym->type == STEXT) {
					if(s->cfunc == 0 && r->sym->cfunc == 2 && !r->sym->nosplit)
						print("Go %s calls C %s\n", s->name, r->sym->name);
					else if(s->cfunc == 2 && s->nosplit && !r->sym->nosplit)
						print("Go calls C %s calls %s\n", s->name, r->sym->name);
				}
			}
		}
	}
}
                                                                                                                                                                                                       root/go1.4/src/cmd/ld/lib.h                                                                         0100644 0000000 0000000 00000017366 12600426226 013745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Derived from Inferno utils/6l/l.h
// http://code.google.com/p/inferno-os/source/browse/utils/6l/l.h
//
//	Copyright © 1994-1999 Lucent Technologies Inc.  All rights reserved.
//	Portions Copyright © 1995-1997 C H Forsyth (forsyth@terzarima.net)
//	Portions Copyright © 1997-1999 Vita Nuova Limited
//	Portions Copyright © 2000-2007 Vita Nuova Holdings Limited (www.vitanuova.com)
//	Portions Copyright © 2004,2006 Bruce Ellis
//	Portions Copyright © 2005-2007 C H Forsyth (forsyth@terzarima.net)
//	Revisions Copyright © 2000-2007 Lucent Technologies Inc. and others
//	Portions Copyright © 2009 The Go Authors.  All rights reserved.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

// Terrible but standard terminology.
// A segment describes a block of file to load into memory.
// A section further describes the pieces of that block for
// use in debuggers and such.

enum {
	MAXIO		= 8192,
};

typedef struct Segment Segment;
typedef struct Section Section;

struct Segment
{
	uchar	rwx;		// permission as usual unix bits (5 = r-x etc)
	uvlong	vaddr;	// virtual address
	uvlong	len;		// length in memory
	uvlong	fileoff;	// file offset
	uvlong	filelen;	// length on disk
	Section*	sect;
};

#pragma incomplete struct Elf64_Shdr

struct Section
{
	uchar	rwx;
	int16	extnum;
	int32	align;
	char	*name;
	uvlong	vaddr;
	uvlong	len;
	Section	*next;	// in segment list
	Segment	*seg;
	struct Elf64_Shdr *elfsect;
	uvlong	reloff;
	uvlong	rellen;
};

extern	char	symname[];

EXTERN	char*	INITENTRY;
extern	char*	thestring;
extern	LinkArch*	thelinkarch;
EXTERN	char*	outfile;
EXTERN	int	ndynexp;
EXTERN	LSym**	dynexp;
EXTERN	int	nldflag;
EXTERN	char**	ldflag;
EXTERN	int	havedynamic;
EXTERN	int	funcalign;
EXTERN	int	iscgo;
EXTERN	int	elfglobalsymndx;
EXTERN	char*	flag_installsuffix;
EXTERN	int	flag_race;
EXTERN	int flag_shared;
EXTERN	char*	tracksym;
EXTERN	char*	interpreter;
EXTERN	char*	tmpdir;
EXTERN	char*	extld;
EXTERN	char*	extldflags;
EXTERN	int	debug_s; // backup old value of debug['s']
EXTERN	Link*	ctxt;
EXTERN	int32	HEADR;
EXTERN	int32	HEADTYPE;
EXTERN	int32	INITRND;
EXTERN	int64	INITTEXT;
EXTERN	int64	INITDAT;
EXTERN	char*	INITENTRY;		/* entry point */
EXTERN	char*	noname;
EXTERN	char*	paramspace;
EXTERN	int	nerrors;

EXTERN	int	linkmode;
EXTERN	int64	liveness;

// for dynexport field of LSym
enum
{
	CgoExportDynamic = 1<<0,
	CgoExportStatic = 1<<1,
};

EXTERN	Segment	segtext;
EXTERN	Segment	segrodata;
EXTERN	Segment	segdata;
EXTERN	Segment	segdwarf;

typedef struct Endian Endian;
struct Endian
{
	uint16	(*e16)(uchar*);
	uint32	(*e32)(uchar*);
	uint64	(*e64)(uchar*);
};

extern Endian be, le;

/* set by call to mywhatsys() */
extern	char*	goroot;
extern	char*	goarch;
extern	char*	goos;

/* whence for ldpkg */
enum {
	FileObj = 0,
	ArchiveObj,
	Pkgdef
};

typedef struct Header Header;
struct Header {
	char *name;
	int val;
};

EXTERN	char*	headstring;
extern	Header	headers[];

#pragma	varargck	type	"Y"	LSym*
#pragma	varargck	type	"Z"	char*
#pragma	varargck	type	"i"	char*

// buffered output

EXTERN	Biobuf	bso;

EXTERN struct
{
	char	cbuf[MAXIO];	/* output buffer */
} buf;

EXTERN	int	cbc;
EXTERN	char*	cbp;
EXTERN	char*	cbpmax;

#define	cput(c)\
	{ *cbp++ = c;\
	if(--cbc <= 0)\
		cflush(); }

void	Lflag(char *arg);
int	Yconv(Fmt *fp);
int	Zconv(Fmt *fp);
void	addexport(void);
void	address(void);
Section*addsection(Segment *seg, char *name, int rwx);
void	addstrdata(char *name, char *value);
vlong	addstring(LSym *s, char *str);
void	asmelfsym(void);
void	asmplan9sym(void);
uint16	be16(uchar *b);
uint32	be32(uchar *b);
uint64	be64(uchar *b);
void	callgraph(void);
void	checkgo(void);
void	cflush(void);
void	codeblk(int64 addr, int64 size);
vlong	cpos(void);
void	cseek(vlong p);
void	cwrite(void *buf, int n);
void	datblk(int64 addr, int64 size);
int	datcmp(LSym *s1, LSym *s2);
vlong	datoff(vlong addr);
void	deadcode(void);
LSym*	decodetype_arrayelem(LSym *s);
vlong	decodetype_arraylen(LSym *s);
LSym*	decodetype_chanelem(LSym *s);
int	decodetype_funcdotdotdot(LSym *s);
int	decodetype_funcincount(LSym *s);
LSym*	decodetype_funcintype(LSym *s, int i);
int	decodetype_funcoutcount(LSym *s);
LSym*	decodetype_funcouttype(LSym *s, int i);
LSym*	decodetype_gcprog(LSym *s);
uint8*	decodetype_gcmask(LSym *s);
vlong	decodetype_ifacemethodcount(LSym *s);
uint8	decodetype_kind(LSym *s);
uint8	decodetype_noptr(LSym *s);
uint8	decodetype_usegcprog(LSym *s);
LSym*	decodetype_mapkey(LSym *s);
LSym*	decodetype_mapvalue(LSym *s);
LSym*	decodetype_ptrelem(LSym *s);
vlong	decodetype_size(LSym *s);
int	decodetype_structfieldcount(LSym *s);
char*	decodetype_structfieldname(LSym *s, int i);
vlong	decodetype_structfieldoffs(LSym *s, int i);
LSym*	decodetype_structfieldtype(LSym *s, int i);
void	dodata(void);
void	dostkcheck(void);
void	dostkoff(void);
void	dosymtype(void);
void	doversion(void);
void	doweak(void);
void	dynreloc(void);
void	dynrelocsym(LSym *s);
vlong	entryvalue(void);
void	errorexit(void);
void	follow(void);
void	genasmsym(void (*put)(LSym*, char*, int, vlong, vlong, int, LSym*));
void	growdatsize(vlong *datsizep, LSym *s);
char*	headstr(int v);
int	headtype(char *name);
void	hostlink(void);
void	hostobjs(void);
int	iconv(Fmt *fp);
void	importcycles(void);
void	linkarchinit(void);
void	ldelf(Biobuf *f, char *pkg, int64 len, char *pn);
void	ldhostobj(void (*ld)(Biobuf*, char*, int64, char*), Biobuf *f, char *pkg, int64 len, char *pn, char *file);
void	ldmacho(Biobuf *f, char *pkg, int64 len, char *pn);
void	ldobj(Biobuf *f, char *pkg, int64 len, char *pn, char *file, int whence);
void	ldpe(Biobuf *f, char *pkg, int64 len, char *pn);
void	ldpkg(Biobuf *f, char *pkg, int64 len, char *filename, int whence);
uint16	le16(uchar *b);
uint32	le32(uchar *b);
uint64	le64(uchar *b);
void	libinit(void);
LSym*	listsort(LSym *l, int (*cmp)(LSym*, LSym*), int off);
void	loadinternal(char *name);
void	loadlib(void);
void	lputb(int32 l);
void	lputl(int32 l);
void*	mal(uint32 n);
void	mark(LSym *s);
void	mywhatsys(void);
struct ar_hdr;
void	objfile(char *file, char *pkg);
void	patch(void);
int	pathchar(void);
void	pcln(void);
void	pclntab(void);
void	putelfsectionsym(LSym* s, int shndx);
void	putelfsymshndx(vlong sympos, int shndx);
void	putsymb(LSym *s, char *name, int t, vlong v, vlong size, int ver, LSym *typ);
int	rbyoff(const void *va, const void *vb);
void	reloc(void);
void	relocsym(LSym *s);
void	setheadtype(char *s);
void	setinterp(char *s);
void	setlinkmode(char *arg);
void	span(void);
void	strnput(char *s, int n);
vlong	symaddr(LSym *s);
void	symtab(void);
void	textaddress(void);
void	undef(void);
void	unmal(void *v, uint32 n);
void	usage(void);
void	vputb(uint64 v);
int	valuecmp(LSym *a, LSym *b);
void	vputl(uint64 v);
void	wputb(ushort w);
void	wputl(ushort w);
void	xdefine(char *p, int t, vlong v);
void	zerosig(char *sp);
void	archinit(void);
void	diag(char *fmt, ...);

#pragma	varargck	argpos	diag	1
                                                                                                                                                                                                                                                                          root/go1.4/src/cmd/ld/macho.c                                                                       0100644 0000000 0000000 00000041016 12600426226 014246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Mach-O file writing
// http://developer.apple.com/mac/library/DOCUMENTATION/DeveloperTools/Conceptual/MachORuntime/Reference/reference.html

#include "l.h"
#include "../ld/dwarf.h"
#include "../ld/lib.h"
#include "../ld/macho.h"

static	int	macho64;
static	MachoHdr	hdr;
static	MachoLoad	*load;
static	MachoSeg	seg[16];
static	int	nload, mload, nseg, ndebug, nsect;

enum
{
	SymKindLocal = 0,
	SymKindExtdef,
	SymKindUndef,
	NumSymKind
};

static	int nkind[NumSymKind];
static	LSym** sortsym;
static	int	nsortsym;

// Amount of space left for adding load commands
// that refer to dynamic libraries.  Because these have
// to go in the Mach-O header, we can't just pick a
// "big enough" header size.  The initial header is 
// one page, the non-dynamic library stuff takes
// up about 1300 bytes; we overestimate that as 2k.
static	int	load_budget = INITIAL_MACHO_HEADR - 2*1024;

static	void	machodysymtab(void);

void
machoinit(void)
{
	switch(thechar) {
	// 64-bit architectures
	case '6':
		macho64 = 1;
		break;

	// 32-bit architectures
	default:
		break;
	}
}

MachoHdr*
getMachoHdr(void)
{
	return &hdr;
}

MachoLoad*
newMachoLoad(uint32 type, uint32 ndata)
{
	MachoLoad *l;

	if(nload >= mload) {
		if(mload == 0)
			mload = 1;
		else
			mload *= 2;
		load = erealloc(load, mload*sizeof load[0]);
	}

	if(macho64 && (ndata & 1))
		ndata++;
	
	l = &load[nload++];
	l->type = type;
	l->ndata = ndata;
	l->data = mal(ndata*4);
	return l;
}

MachoSeg*
newMachoSeg(char *name, int msect)
{
	MachoSeg *s;

	if(nseg >= nelem(seg)) {
		diag("too many segs");
		errorexit();
	}
	s = &seg[nseg++];
	s->name = name;
	s->msect = msect;
	s->sect = mal(msect*sizeof s->sect[0]);
	return s;
}

MachoSect*
newMachoSect(MachoSeg *seg, char *name, char *segname)
{
	MachoSect *s;

	if(seg->nsect >= seg->msect) {
		diag("too many sects in segment %s", seg->name);
		errorexit();
	}
	s = &seg->sect[seg->nsect++];
	s->name = name;
	s->segname = segname;
	nsect++;
	return s;
}

// Generic linking code.

static char **dylib;
static int ndylib;

static vlong linkoff;

int
machowrite(void)
{
	vlong o1;
	int loadsize;
	int i, j;
	MachoSeg *s;
	MachoSect *t;
	MachoLoad *l;

	o1 = cpos();

	loadsize = 4*4*ndebug;
	for(i=0; i<nload; i++)
		loadsize += 4*(load[i].ndata+2);
	if(macho64) {
		loadsize += 18*4*nseg;
		loadsize += 20*4*nsect;
	} else {
		loadsize += 14*4*nseg;
		loadsize += 17*4*nsect;
	}

	if(macho64)
		LPUT(0xfeedfacf);
	else
		LPUT(0xfeedface);
	LPUT(hdr.cpu);
	LPUT(hdr.subcpu);
	if(linkmode == LinkExternal)
		LPUT(1);	/* file type - mach object */
	else
		LPUT(2);	/* file type - mach executable */
	LPUT(nload+nseg+ndebug);
	LPUT(loadsize);
	LPUT(1);	/* flags - no undefines */
	if(macho64)
		LPUT(0);	/* reserved */

	for(i=0; i<nseg; i++) {
		s = &seg[i];
		if(macho64) {
			LPUT(25);	/* segment 64 */
			LPUT(72+80*s->nsect);
			strnput(s->name, 16);
			VPUT(s->vaddr);
			VPUT(s->vsize);
			VPUT(s->fileoffset);
			VPUT(s->filesize);
			LPUT(s->prot1);
			LPUT(s->prot2);
			LPUT(s->nsect);
			LPUT(s->flag);
		} else {
			LPUT(1);	/* segment 32 */
			LPUT(56+68*s->nsect);
			strnput(s->name, 16);
			LPUT(s->vaddr);
			LPUT(s->vsize);
			LPUT(s->fileoffset);
			LPUT(s->filesize);
			LPUT(s->prot1);
			LPUT(s->prot2);
			LPUT(s->nsect);
			LPUT(s->flag);
		}
		for(j=0; j<s->nsect; j++) {
			t = &s->sect[j];
			if(macho64) {
				strnput(t->name, 16);
				strnput(t->segname, 16);
				VPUT(t->addr);
				VPUT(t->size);
				LPUT(t->off);
				LPUT(t->align);
				LPUT(t->reloc);
				LPUT(t->nreloc);
				LPUT(t->flag);
				LPUT(t->res1);	/* reserved */
				LPUT(t->res2);	/* reserved */
				LPUT(0);	/* reserved */
			} else {
				strnput(t->name, 16);
				strnput(t->segname, 16);
				LPUT(t->addr);
				LPUT(t->size);
				LPUT(t->off);
				LPUT(t->align);
				LPUT(t->reloc);
				LPUT(t->nreloc);
				LPUT(t->flag);
				LPUT(t->res1);	/* reserved */
				LPUT(t->res2);	/* reserved */
			}
		}
	}

	for(i=0; i<nload; i++) {
		l = &load[i];
		LPUT(l->type);
		LPUT(4*(l->ndata+2));
		for(j=0; j<l->ndata; j++)
			LPUT(l->data[j]);
	}

	return cpos() - o1;
}

void
domacho(void)
{
	LSym *s;

	if(debug['d'])
		return;

	// empirically, string table must begin with " \x00".
	s = linklookup(ctxt, ".machosymstr", 0);
	s->type = SMACHOSYMSTR;
	s->reachable = 1;
	adduint8(ctxt, s, ' ');
	adduint8(ctxt, s, '\0');
	
	s = linklookup(ctxt, ".machosymtab", 0);
	s->type = SMACHOSYMTAB;
	s->reachable = 1;
	
	if(linkmode != LinkExternal) {
		s = linklookup(ctxt, ".plt", 0);	// will be __symbol_stub
		s->type = SMACHOPLT;
		s->reachable = 1;
	
		s = linklookup(ctxt, ".got", 0);	// will be __nl_symbol_ptr
		s->type = SMACHOGOT;
		s->reachable = 1;
		s->align = 4;
	
		s = linklookup(ctxt, ".linkedit.plt", 0);	// indirect table for .plt
		s->type = SMACHOINDIRECTPLT;
		s->reachable = 1;
	
		s = linklookup(ctxt, ".linkedit.got", 0);	// indirect table for .got
		s->type = SMACHOINDIRECTGOT;
		s->reachable = 1;
	}
}

void
machoadddynlib(char *lib)
{
	// Will need to store the library name rounded up
	// and 24 bytes of header metadata.  If not enough
	// space, grab another page of initial space at the
	// beginning of the output file.
	load_budget -= (strlen(lib)+7)/8*8 + 24;
	if(load_budget < 0) {
		HEADR += 4096;
		INITTEXT += 4096;
		load_budget += 4096;
	}

	if(ndylib%32 == 0)
		dylib = erealloc(dylib, (ndylib+32)*sizeof dylib[0]);
	dylib[ndylib++] = lib;
}

static void
machoshbits(MachoSeg *mseg, Section *sect, char *segname)
{
	MachoSect *msect;
	char buf[40];
	char *p;
	
	snprint(buf, sizeof buf, "__%s", sect->name+1);
	for(p=buf; *p; p++)
		if(*p == '.')
			*p = '_';

	msect = newMachoSect(mseg, estrdup(buf), segname);
	if(sect->rellen > 0) {
		msect->reloc = sect->reloff;
		msect->nreloc = sect->rellen / 8;
	}

	while(1<<msect->align < sect->align)
		msect->align++;
	msect->addr = sect->vaddr;
	msect->size = sect->len;
	
	if(sect->vaddr < sect->seg->vaddr + sect->seg->filelen) {
		// data in file
		if(sect->len > sect->seg->vaddr + sect->seg->filelen - sect->vaddr)
			diag("macho cannot represent section %s crossing data and bss", sect->name);
		msect->off = sect->seg->fileoff + sect->vaddr - sect->seg->vaddr;
	} else {
		// zero fill
		msect->off = 0;
		msect->flag |= 1;
	}

	if(sect->rwx & 1)
		msect->flag |= 0x400; /* has instructions */
	
	if(strcmp(sect->name, ".plt") == 0) {
		msect->name = "__symbol_stub1";
		msect->flag = 0x80000408; /* only instructions, code, symbol stubs */
		msect->res1 = 0;//nkind[SymKindLocal];
		msect->res2 = 6;
	}

	if(strcmp(sect->name, ".got") == 0) {
		msect->name = "__nl_symbol_ptr";
		msect->flag = 6;	/* section with nonlazy symbol pointers */
		msect->res1 = linklookup(ctxt, ".linkedit.plt", 0)->size / 4;	/* offset into indirect symbol table */
	}
}

void
asmbmacho(void)
{
	vlong v, w;
	vlong va;
	int a, i;
	MachoHdr *mh;
	MachoSeg *ms;
	MachoLoad *ml;
	Section *sect;

	/* apple MACH */
	va = INITTEXT - HEADR;
	mh = getMachoHdr();
	switch(thechar){
	default:
		diag("unknown mach architecture");
		errorexit();
	case '6':
		mh->cpu = MACHO_CPU_AMD64;
		mh->subcpu = MACHO_SUBCPU_X86;
		break;
	case '8':
		mh->cpu = MACHO_CPU_386;
		mh->subcpu = MACHO_SUBCPU_X86;
		break;
	}
	
	ms = nil;
	if(linkmode == LinkExternal) {
		/* segment for entire file */
		ms = newMachoSeg("", 40);
		ms->fileoffset = segtext.fileoff;
		ms->filesize = segdata.fileoff + segdata.filelen - segtext.fileoff;
	}

	/* segment for zero page */
	if(linkmode != LinkExternal) {
		ms = newMachoSeg("__PAGEZERO", 0);
		ms->vsize = va;
	}

	/* text */
	v = rnd(HEADR+segtext.len, INITRND);
	if(linkmode != LinkExternal) {
		ms = newMachoSeg("__TEXT", 20);
		ms->vaddr = va;
		ms->vsize = v;
		ms->fileoffset = 0;
		ms->filesize = v;
		ms->prot1 = 7;
		ms->prot2 = 5;
	}

	for(sect=segtext.sect; sect!=nil; sect=sect->next)
		machoshbits(ms, sect, "__TEXT");

	/* data */
	if(linkmode != LinkExternal) {
		w = segdata.len;
		ms = newMachoSeg("__DATA", 20);
		ms->vaddr = va+v;
		ms->vsize = w;
		ms->fileoffset = v;
		ms->filesize = segdata.filelen;
		ms->prot1 = 3;
		ms->prot2 = 3;
	}

	for(sect=segdata.sect; sect!=nil; sect=sect->next)
		machoshbits(ms, sect, "__DATA");

	if(linkmode != LinkExternal) {
		switch(thechar) {
		default:
			diag("unknown macho architecture");
			errorexit();
		case '6':
			ml = newMachoLoad(5, 42+2);	/* unix thread */
			ml->data[0] = 4;	/* thread type */
			ml->data[1] = 42;	/* word count */
			ml->data[2+32] = entryvalue();	/* start pc */
			ml->data[2+32+1] = entryvalue()>>16>>16;	// hide >>32 for 8l
			break;
		case '8':
			ml = newMachoLoad(5, 16+2);	/* unix thread */
			ml->data[0] = 1;	/* thread type */
			ml->data[1] = 16;	/* word count */
			ml->data[2+10] = entryvalue();	/* start pc */
			break;
		}
	}
	
	if(!debug['d']) {
		LSym *s1, *s2, *s3, *s4;

		// must match domacholink below
		s1 = linklookup(ctxt, ".machosymtab", 0);
		s2 = linklookup(ctxt, ".linkedit.plt", 0);
		s3 = linklookup(ctxt, ".linkedit.got", 0);
		s4 = linklookup(ctxt, ".machosymstr", 0);

		if(linkmode != LinkExternal) {
			ms = newMachoSeg("__LINKEDIT", 0);
			ms->vaddr = va+v+rnd(segdata.len, INITRND);
			ms->vsize = s1->size + s2->size + s3->size + s4->size;
			ms->fileoffset = linkoff;
			ms->filesize = ms->vsize;
			ms->prot1 = 7;
			ms->prot2 = 3;
		}

		ml = newMachoLoad(2, 4);	/* LC_SYMTAB */
		ml->data[0] = linkoff;	/* symoff */
		ml->data[1] = nsortsym;	/* nsyms */
		ml->data[2] = linkoff + s1->size + s2->size + s3->size;	/* stroff */
		ml->data[3] = s4->size;	/* strsize */

		machodysymtab();

		if(linkmode != LinkExternal) {
			ml = newMachoLoad(14, 6);	/* LC_LOAD_DYLINKER */
			ml->data[0] = 12;	/* offset to string */
			strcpy((char*)&ml->data[1], "/usr/lib/dyld");
	
			for(i=0; i<ndylib; i++) {
				ml = newMachoLoad(12, 4+(strlen(dylib[i])+1+7)/8*2);	/* LC_LOAD_DYLIB */
				ml->data[0] = 24;	/* offset of string from beginning of load */
				ml->data[1] = 0;	/* time stamp */
				ml->data[2] = 0;	/* version */
				ml->data[3] = 0;	/* compatibility version */
				strcpy((char*)&ml->data[4], dylib[i]);
			}
		}
	}

	// TODO: dwarf headers go in ms too
	if(!debug['s'] && linkmode != LinkExternal)
		dwarfaddmachoheaders();

	a = machowrite();
	if(a > HEADR)
		diag("HEADR too small: %d > %d", a, HEADR);
}

static int
symkind(LSym *s)
{
	if(s->type == SDYNIMPORT)
		return SymKindUndef;
	if(s->cgoexport)
		return SymKindExtdef;
	return SymKindLocal;
}

static void
addsym(LSym *s, char *name, int type, vlong addr, vlong size, int ver, LSym *gotype)
{
	USED(name);
	USED(addr);
	USED(size);
	USED(ver);
	USED(gotype);

	if(s == nil)
		return;

	switch(type) {
	default:
		return;
	case 'D':
	case 'B':
	case 'T':
		break;
	}
	
	if(sortsym) {
		sortsym[nsortsym] = s;
		nkind[symkind(s)]++;
	}
	nsortsym++;
}
	
static int
scmp(const void *p1, const void *p2)
{
	LSym *s1, *s2;
	int k1, k2;

	s1 = *(LSym**)p1;
	s2 = *(LSym**)p2;
	
	k1 = symkind(s1);
	k2 = symkind(s2);
	if(k1 != k2)
		return k1 - k2;

	return strcmp(s1->extname, s2->extname);
}

static void
machogenasmsym(void (*put)(LSym*, char*, int, vlong, vlong, int, LSym*))
{
	LSym *s;

	genasmsym(put);
	for(s=ctxt->allsym; s; s=s->allsym)
		if(s->type == SDYNIMPORT || s->type == SHOSTOBJ)
		if(s->reachable)
			put(s, nil, 'D', 0, 0, 0, nil);
}
			
void
machosymorder(void)
{
	int i;

	// On Mac OS X Mountain Lion, we must sort exported symbols
	// So we sort them here and pre-allocate dynid for them
	// See http://golang.org/issue/4029
	for(i=0; i<ndynexp; i++)
		dynexp[i]->reachable = 1;
	machogenasmsym(addsym);
	sortsym = mal(nsortsym * sizeof sortsym[0]);
	nsortsym = 0;
	machogenasmsym(addsym);
	qsort(sortsym, nsortsym, sizeof sortsym[0], scmp);
	for(i=0; i<nsortsym; i++)
		sortsym[i]->dynid = i;
}

static void
machosymtab(void)
{
	int i;
	LSym *symtab, *symstr, *s, *o;
	char *p;

	symtab = linklookup(ctxt, ".machosymtab", 0);
	symstr = linklookup(ctxt, ".machosymstr", 0);

	for(i=0; i<nsortsym; i++) {
		s = sortsym[i];
		adduint32(ctxt, symtab, symstr->size);
		
		// Only add _ to C symbols. Go symbols have dot in the name.
		if(strstr(s->extname, ".") == nil)
			adduint8(ctxt, symstr, '_');
		// replace "·" as ".", because DTrace cannot handle it.
		if(strstr(s->extname, "·") == nil) {
			addstring(symstr, s->extname);
		} else {
			for(p = s->extname; *p; p++) {
				if((uchar)*p == 0xc2 && (uchar)*(p+1) == 0xb7) {
					adduint8(ctxt, symstr, '.');
					p++;
				} else {
					adduint8(ctxt, symstr, *p);
				}
			}
			adduint8(ctxt, symstr, '\0');
		}
		if(s->type == SDYNIMPORT || s->type == SHOSTOBJ) {
			adduint8(ctxt, symtab, 0x01); // type N_EXT, external symbol
			adduint8(ctxt, symtab, 0); // no section
			adduint16(ctxt, symtab, 0); // desc
			adduintxx(ctxt, symtab, 0, PtrSize); // no value
		} else {
			if(s->cgoexport)
				adduint8(ctxt, symtab, 0x0f);
			else
				adduint8(ctxt, symtab, 0x0e);
			o = s;
			while(o->outer != nil)
				o = o->outer;
			if(o->sect == nil) {
				diag("missing section for %s", s->name);
				adduint8(ctxt, symtab, 0);
			} else
				adduint8(ctxt, symtab, o->sect->extnum);
			adduint16(ctxt, symtab, 0); // desc
			adduintxx(ctxt, symtab, symaddr(s), PtrSize);
		}
	}
}

static void
machodysymtab(void)
{
	int n;
	MachoLoad *ml;
	LSym *s1, *s2, *s3;

	ml = newMachoLoad(11, 18);	/* LC_DYSYMTAB */

	n = 0;
	ml->data[0] = n;	/* ilocalsym */
	ml->data[1] = nkind[SymKindLocal];	/* nlocalsym */
	n += nkind[SymKindLocal];

	ml->data[2] = n;	/* iextdefsym */
	ml->data[3] = nkind[SymKindExtdef];	/* nextdefsym */
	n += nkind[SymKindExtdef];

	ml->data[4] = n;	/* iundefsym */
	ml->data[5] = nkind[SymKindUndef];	/* nundefsym */

	ml->data[6] = 0;	/* tocoffset */
	ml->data[7] = 0;	/* ntoc */
	ml->data[8] = 0;	/* modtaboff */
	ml->data[9] = 0;	/* nmodtab */
	ml->data[10] = 0;	/* extrefsymoff */
	ml->data[11] = 0;	/* nextrefsyms */

	// must match domacholink below
	s1 = linklookup(ctxt, ".machosymtab", 0);
	s2 = linklookup(ctxt, ".linkedit.plt", 0);
	s3 = linklookup(ctxt, ".linkedit.got", 0);
	ml->data[12] = linkoff + s1->size;	/* indirectsymoff */
	ml->data[13] = (s2->size + s3->size) / 4;	/* nindirectsyms */

	ml->data[14] = 0;	/* extreloff */
	ml->data[15] = 0;	/* nextrel */
	ml->data[16] = 0;	/* locreloff */
	ml->data[17] = 0;	/* nlocrel */
}

vlong
domacholink(void)
{
	int size;
	LSym *s1, *s2, *s3, *s4;

	machosymtab();

	// write data that will be linkedit section
	s1 = linklookup(ctxt, ".machosymtab", 0);
	s2 = linklookup(ctxt, ".linkedit.plt", 0);
	s3 = linklookup(ctxt, ".linkedit.got", 0);
	s4 = linklookup(ctxt, ".machosymstr", 0);

	// Force the linkedit section to end on a 16-byte
	// boundary.  This allows pure (non-cgo) Go binaries
	// to be code signed correctly.
	//
	// Apple's codesign_allocate (a helper utility for
	// the codesign utility) can do this fine itself if
	// it is run on a dynamic Mach-O binary.  However,
	// when it is run on a pure (non-cgo) Go binary, where
	// the linkedit section is mostly empty, it fails to
	// account for the extra padding that it itself adds
	// when adding the LC_CODE_SIGNATURE load command
	// (which must be aligned on a 16-byte boundary).
	//
	// By forcing the linkedit section to end on a 16-byte
	// boundary, codesign_allocate will not need to apply
	// any alignment padding itself, working around the
	// issue.
	while(s4->size%16)
		adduint8(ctxt, s4, 0);
	
	size = s1->size + s2->size + s3->size + s4->size;

	if(size > 0) {
		linkoff = rnd(HEADR+segtext.len, INITRND) + rnd(segdata.filelen, INITRND) + rnd(segdwarf.filelen, INITRND);
		cseek(linkoff);

		cwrite(s1->p, s1->size);
		cwrite(s2->p, s2->size);
		cwrite(s3->p, s3->size);
		cwrite(s4->p, s4->size);
	}

	return rnd(size, INITRND);
}


void
machorelocsect(Section *sect, LSym *first)
{
	LSym *sym;
	int32 eaddr;
	Reloc *r;

	// If main section has no bits, nothing to relocate.
	if(sect->vaddr >= sect->seg->vaddr + sect->seg->filelen)
		return;
	
	sect->reloff = cpos();
	for(sym = first; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= sect->vaddr)
			break;
	}
	
	eaddr = sect->vaddr + sect->len;
	for(; sym != nil; sym = sym->next) {
		if(!sym->reachable)
			continue;
		if(sym->value >= eaddr)
			break;
		ctxt->cursym = sym;
		
		for(r = sym->r; r < sym->r+sym->nr; r++) {
			if(r->done)
				continue;
			if(machoreloc1(r, sym->value+r->off - sect->vaddr) < 0)
				diag("unsupported obj reloc %d/%d to %s", r->type, r->siz, r->sym->name);
		}
	}
		
	sect->rellen = cpos() - sect->reloff;
}

void
machoemitreloc(void)
{
	Section *sect;

	while(cpos()&7)
		cput(0);

	machorelocsect(segtext.sect, ctxt->textp);
	for(sect=segtext.sect->next; sect!=nil; sect=sect->next)
		machorelocsect(sect, datap);	
	for(sect=segdata.sect; sect!=nil; sect=sect->next)
		machorelocsect(sect, datap);	
}
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  root/go1.4/src/cmd/ld/macho.h                                                                       0100644 0000000 0000000 00000003450 12600426226 014253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

typedef struct MachoHdr MachoHdr;
struct MachoHdr {
	uint32	cpu;
	uint32	subcpu;
};

typedef struct MachoSect MachoSect;
struct MachoSect {
	char*	name;
	char*	segname;
	uint64	addr;
	uint64	size;
	uint32	off;
	uint32	align;
	uint32	reloc;
	uint32	nreloc;
	uint32	flag;
	uint32	res1;
	uint32	res2;
};

typedef struct MachoSeg MachoSeg;
struct MachoSeg {
	char*	name;
	uint64	vsize;
	uint64	vaddr;
	uint64	fileoffset;
	uint64	filesize;
	uint32	prot1;
	uint32	prot2;
	uint32	nsect;
	uint32	msect;
	MachoSect	*sect;
	uint32	flag;
};

typedef struct MachoLoad MachoLoad;
struct MachoLoad {
	uint32	type;
	uint32	ndata;
	uint32	*data;
};

MachoHdr*	getMachoHdr(void);
MachoSeg*	newMachoSeg(char*, int);
MachoSect*	newMachoSect(MachoSeg*, char*, char*);
MachoLoad*	newMachoLoad(uint32, uint32);
int	machowrite(void);
void	machoinit(void);
void	machosymorder(void);
void	machoemitreloc(void);
int	machoreloc1(Reloc*, vlong);

/*
 * Total amount of space to reserve at the start of the file
 * for Header, PHeaders, and SHeaders.
 * May waste some.
 */
#define	INITIAL_MACHO_HEADR	4*1024

enum {
	MACHO_CPU_AMD64 = (1<<24)|7,
	MACHO_CPU_386 = 7,
	MACHO_SUBCPU_X86 = 3,

	MACHO32SYMSIZE = 12,
	MACHO64SYMSIZE = 16,
	
	MACHO_X86_64_RELOC_UNSIGNED = 0,
	MACHO_X86_64_RELOC_SIGNED = 1,
	MACHO_X86_64_RELOC_BRANCH = 2,
	MACHO_X86_64_RELOC_GOT_LOAD = 3,
	MACHO_X86_64_RELOC_GOT = 4,
	MACHO_X86_64_RELOC_SUBTRACTOR = 5,
	MACHO_X86_64_RELOC_SIGNED_1 = 6,
	MACHO_X86_64_RELOC_SIGNED_2 = 7,
	MACHO_X86_64_RELOC_SIGNED_4 = 8,
	
	MACHO_GENERIC_RELOC_VANILLA = 0,
	
	MACHO_FAKE_GOTPCREL = 100,
};

void	domacho(void);
vlong	domacholink(void);
void	asmbmacho(void);
void	machoadddynlib(char*);
                                                                                                                                                                                                                        root/go1.4/src/cmd/ld/pcln.c                                                                        0100644 0000000 0000000 00000014327 12600426226 014120  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2013 The Go Authors.  All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

#include	"l.h"
#include	"lib.h"
#include	"../../runtime/funcdata.h"

static void
addvarint(Pcdata *d, uint32 val)
{
	int32 n;
	uint32 v;
	uchar *p;

	n = 0;
	for(v = val; v >= 0x80; v >>= 7)
		n++;
	n++;

	if(d->n + n > d->m) {
		d->m = (d->n + n)*2;
		d->p = erealloc(d->p, d->m);
	}

	p = d->p + d->n;
	for(v = val; v >= 0x80; v >>= 7)
		*p++ = v | 0x80;
	*p = v;
	d->n += n;
}

static int32
addpctab(LSym *ftab, int32 off, Pcdata *d)
{
	int32 start;
	
	start = ftab->np;
	symgrow(ctxt, ftab, start + d->n);
	memmove(ftab->p + start, d->p, d->n);
	
	return setuint32(ctxt, ftab, off, start);
}

static int32
ftabaddstring(LSym *ftab, char *s)
{
	int32 n, start;
	
	n = strlen(s)+1;
	start = ftab->np;
	symgrow(ctxt, ftab, start+n+1);
	strcpy((char*)ftab->p + start, s);
	return start;
}

static void
renumberfiles(Link *ctxt, LSym **files, int nfiles, Pcdata *d)
{
	int i;
	LSym *f;
	Pcdata out;
	Pciter it;
	uint32 v;
	int32 oldval, newval, val, dv;
	
	// Give files numbers.
	for(i=0; i<nfiles; i++) {
		f = files[i];
		if(f->type != SFILEPATH) {
			f->value = ++ctxt->nhistfile;
			f->type = SFILEPATH;
			f->next = ctxt->filesyms;
			ctxt->filesyms = f;
		}
	}

	newval = -1;
	memset(&out, 0, sizeof out);

	for(pciterinit(ctxt, &it, d); !it.done; pciternext(&it)) {
		// value delta
		oldval = it.value;
		if(oldval == -1)
			val = -1;
		else {	
			if(oldval < 0 || oldval >= nfiles)
				sysfatal("bad pcdata %d", oldval);
			val = files[oldval]->value;
		}
		dv = val - newval;
		newval = val;
		v = ((uint32)dv<<1) ^ (uint32)(int32)(dv>>31);
		addvarint(&out, v);

		// pc delta
		addvarint(&out, (it.nextpc - it.pc) / it.pcscale);
	}
	
	// terminating value delta
	addvarint(&out, 0);

	free(d->p);
	*d = out;	
}


// pclntab initializes the pclntab symbol with
// runtime function and file name information.
void
pclntab(void)
{
	int32 i, nfunc, start, funcstart;
	LSym *ftab, *s;
	int32 off, end, frameptrsize;
	int64 funcdata_bytes;
	Pcln *pcln;
	Pciter it;
	static Pcln zpcln;
	
	funcdata_bytes = 0;
	ftab = linklookup(ctxt, "runtime.pclntab", 0);
	ftab->type = SPCLNTAB;
	ftab->reachable = 1;

	// See golang.org/s/go12symtab for the format. Briefly:
	//	8-byte header
	//	nfunc [PtrSize bytes]
	//	function table, alternating PC and offset to func struct [each entry PtrSize bytes]
	//	end PC [PtrSize bytes]
	//	offset to file table [4 bytes]
	nfunc = 0;
	for(ctxt->cursym = ctxt->textp; ctxt->cursym != nil; ctxt->cursym = ctxt->cursym->next)
		nfunc++;
	symgrow(ctxt, ftab, 8+PtrSize+nfunc*2*PtrSize+PtrSize+4);
	setuint32(ctxt, ftab, 0, 0xfffffffb);
	setuint8(ctxt, ftab, 6, MINLC);
	setuint8(ctxt, ftab, 7, PtrSize);
	setuintxx(ctxt, ftab, 8, nfunc, PtrSize);

	nfunc = 0;
	for(ctxt->cursym = ctxt->textp; ctxt->cursym != nil; ctxt->cursym = ctxt->cursym->next, nfunc++) {
		pcln = ctxt->cursym->pcln;
		if(pcln == nil)
			pcln = &zpcln;
	
		funcstart = ftab->np;
		funcstart += -ftab->np & (PtrSize-1);

		setaddr(ctxt, ftab, 8+PtrSize+nfunc*2*PtrSize, ctxt->cursym);
		setuintxx(ctxt, ftab, 8+PtrSize+nfunc*2*PtrSize+PtrSize, funcstart, PtrSize);

		// fixed size of struct, checked below
		off = funcstart;
		end = funcstart + PtrSize + 3*4 + 5*4 + pcln->npcdata*4 + pcln->nfuncdata*PtrSize;
		if(pcln->nfuncdata > 0 && (end&(PtrSize-1)))
			end += 4;
		symgrow(ctxt, ftab, end);

		// entry uintptr
		off = setaddr(ctxt, ftab, off, ctxt->cursym);

		// name int32
		off = setuint32(ctxt, ftab, off, ftabaddstring(ftab, ctxt->cursym->name));
		
		// args int32
		// TODO: Move into funcinfo.
		off = setuint32(ctxt, ftab, off, ctxt->cursym->args);
	
		// frame int32
		// TODO: Remove entirely. The pcsp table is more precise.
		// This is only used by a fallback case during stack walking
		// when a called function doesn't have argument information.
		// We need to make sure everything has argument information
		// and then remove this.
		frameptrsize = PtrSize;
		if(ctxt->cursym->leaf)
			frameptrsize = 0;
		off = setuint32(ctxt, ftab, off, ctxt->cursym->locals + frameptrsize);
		
		if(pcln != &zpcln) {
			renumberfiles(ctxt, pcln->file, pcln->nfile, &pcln->pcfile);
			if(0) {
				// Sanity check the new numbering
				for(pciterinit(ctxt, &it, &pcln->pcfile); !it.done; pciternext(&it)) {
					if(it.value < 1 || it.value > ctxt->nhistfile) {
						diag("bad file number in pcfile: %d not in range [1, %d]\n", it.value, ctxt->nhistfile);
						errorexit();
					}
				}
			}
		}

		// pcdata
		off = addpctab(ftab, off, &pcln->pcsp);
		off = addpctab(ftab, off, &pcln->pcfile);
		off = addpctab(ftab, off, &pcln->pcline);
		off = setuint32(ctxt, ftab, off, pcln->npcdata);
		off = setuint32(ctxt, ftab, off, pcln->nfuncdata);
		for(i=0; i<pcln->npcdata; i++)
			off = addpctab(ftab, off, &pcln->pcdata[i]);

		// funcdata, must be pointer-aligned and we're only int32-aligned.
		// Missing funcdata will be 0 (nil pointer).
		if(pcln->nfuncdata > 0) {
			if(off&(PtrSize-1))
				off += 4;
			for(i=0; i<pcln->nfuncdata; i++) {
				if(pcln->funcdata[i] == nil)
					setuintxx(ctxt, ftab, off+PtrSize*i, pcln->funcdataoff[i], PtrSize);
				else {
					// TODO: Dedup.
					funcdata_bytes += pcln->funcdata[i]->size;
					setaddrplus(ctxt, ftab, off+PtrSize*i, pcln->funcdata[i], pcln->funcdataoff[i]);
				}
			}
			off += pcln->nfuncdata*PtrSize;
		}

		if(off != end) {
			diag("bad math in functab: funcstart=%d off=%d but end=%d (npcdata=%d nfuncdata=%d ptrsize=%d)", funcstart, off, end, pcln->npcdata, pcln->nfuncdata, PtrSize);
			errorexit();
		}
	
		// Final entry of table is just end pc.
		if(ctxt->cursym->next == nil)
			setaddrplus(ctxt, ftab, 8+PtrSize+(nfunc+1)*2*PtrSize, ctxt->cursym, ctxt->cursym->size);
	}
	
	// Start file table.
	start = ftab->np;
	start += -ftab->np & (PtrSize-1);
	setuint32(ctxt, ftab, 8+PtrSize+nfunc*2*PtrSize+PtrSize, start);

	symgrow(ctxt, ftab, start+(ctxt->nhistfile+1)*4);
	setuint32(ctxt, ftab, start, ctxt->nhistfile);
	for(s = ctxt->filesyms; s != S; s = s->next)
		setuint32(ctxt, ftab, start + s->value*4, ftabaddstring(ftab, s->name));

	ftab->size = ftab->np;
	
	if(debug['v'])
		Bprint(&bso, "%5.2f pclntab=%lld bytes, funcdata total %lld bytes\n", cputime(), (vlong)ftab->size, (vlong)funcdata_bytes);
}	
                                                                                                                                                                                                                                                                                                         root/go1.4/src/cmd/ld/pe.c                                                                          0100644 0000000 0000000 00000040174 12600426226 013567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        // Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// PE (Portable Executable) file writing
// http://www.microsoft.com/whdc/system/platform/firmware/PECOFF.mspx

#include "l.h"
#include "../ld/lib.h"
#include "../ld/pe.h"
#include "../ld/dwarf.h"

// DOS stub that prints out
// "This program cannot be run in DOS mode."
static char dosstub[] =
{
	0x4d, 0x5a, 0x90, 0x00, 0x03, 0x00, 0x04, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00,
	0x8b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00,
	0x0e, 0x1f, 0xba, 0x0e, 0x00, 0xb4, 0x09, 0xcd,
	0x21, 0xb8, 0x01, 0x4c, 0xcd, 0x21, 0x54, 0x68,
	0x69, 0x73, 0x20, 0x70, 0x72, 0x6f, 0x67, 0x72,
	0x61, 0x6d, 0x20, 0x63, 0x61, 0x6e, 0x6e, 0x6f,
	0x74, 0x20, 0x62, 0x65, 0x20, 0x72, 0x75, 0x6e,
	0x20, 0x69, 0x6e, 0x20, 0x44, 0x4f, 0x53, 0x20,
	0x6d, 0x6f, 0x64, 0x65, 0x2e, 0x0d, 0x0d, 0x0a,
	0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static LSym *rsrcsym;

static char* strtbl;
static int strtblnextoff;
static int strtblsize;

int32 PESECTHEADR;
int32 PEFILEHEADR;

static int pe64;
static int nsect;
static int nextsectoff;
static int nextfileoff;
static int textsect;
static int datasect;

static IMAGE_FILE_HEADER fh;
static IMAGE_OPTIONAL_HEADER oh;
static PE64_IMAGE_OPTIONAL_HEADER oh64;
static IMAGE_SECTION_HEADER sh[16];
static IMAGE_DATA_DIRECTORY* dd;

#define	set(n, v)	(pe64 ? (oh64.n = v) : (oh.n = v))
#define	put(v)		(pe64 ? vputl(v) : lputl(v))

typedef struct Imp Imp;
struct Imp {
	LSym* s;
	uvlong off;
	Imp* next;
};

typedef struct Dll Dll;
struct Dll {
	char* name;
	uvlong nameoff;
	uvlong thunkoff;
	Imp* ms;
	Dll* next;
};

static Dll* dr;

static LSym *dexport[1024];
static int nexport;

typedef struct COFFSym COFFSym;
struct COFFSym
{
	LSym* sym;
	int strtbloff;
	int sect;
	vlong value;
};

static COFFSym* coffsym;
static int ncoffsym;

static IMAGE_SECTION_HEADER*
addpesection(char *name, int sectsize, int filesize)
{
	IMAGE_SECTION_HEADER *h;

	if(nsect == 16) {
		diag("too many sections");
		errorexit();
	}
	h = &sh[nsect++];
	strncpy((char*)h->Name, name, sizeof(h->Name));
	h->VirtualSize = sectsize;
	h->VirtualAddress = nextsectoff;
	nextsectoff = rnd(nextsectoff+sectsize, PESECTALIGN);
	h->PointerToRawData = nextfileoff;
	if(filesize > 0) {
		h->SizeOfRawData = rnd(filesize, PEFILEALIGN);
		nextfileoff += h->SizeOfRawData;
	}
	return h;
}

static void
chksectoff(IMAGE_SECTION_HEADER *h, vlong off)
{
	if(off != h->PointerToRawData) {
		diag("%s.PointerToRawData = %#llux, want %#llux", (char *)h->Name, (vlong)h->PointerToRawData, off);
		errorexit();
	}
}

static void
chksectseg(IMAGE_SECTION_HEADER *h, Segment *s)
{
	if(s->vaddr-PEBASE != h->VirtualAddress) {
		diag("%s.VirtualAddress = %#llux, want %#llux", (char *)h->Name, (vlong)h->VirtualAddress, (vlong)(s->vaddr-PEBASE));
		errorexit();
	}
	if(s->fileoff != h->PointerToRawData) {
		diag("%s.PointerToRawData = %#llux, want %#llux", (char *)h->Name, (vlong)h->PointerToRawData, (vlong)(s->fileoff));
		errorexit();
	}
}

void
peinit(void)
{
	int32 l;

	switch(thechar) {
	// 64-bit architectures
	case '6':
		pe64 = 1;
		l = sizeof(oh64);
		dd = oh64.DataDirectory;
		break;
	// 32-bit architectures
	default:
		l = sizeof(oh);
		dd = oh.DataDirectory;
		break;
	}
	
	PEFILEHEADR = rnd(sizeof(dosstub)+sizeof(fh)+l+sizeof(sh), PEFILEALIGN);
	PESECTHEADR = rnd(PEFILEHEADR, PESECTALIGN);
	nextsectoff = PESECTHEADR;
	nextfileoff = PEFILEHEADR;

	// some mingw libs depend on this symbol, for example, FindPESectionByName
	xdefine("__image_base__", SDATA, PEBASE);
	xdefine("_image_base__", SDATA, PEBASE);
}

static void
pewrite(void)
{
	cseek(0);
	cwrite(dosstub, sizeof dosstub);
	strnput("PE", 4);
	// TODO: This code should not assume that the
	// memory representation is little-endian or
	// that the structs are packed identically to
	// their file representation.
	cwrite(&fh, sizeof fh);
	if(pe64)
		cwrite(&oh64, sizeof oh64);
	else
		cwrite(&oh, sizeof oh);
	cwrite(sh, nsect * sizeof sh[0]);
}

static void
strput(char *s)
{
	int n;

	for(n=0; *s; n++)
		cput(*s++);
	cput('\0');
	n++;
	// string must be padded to even size
	if(n%2)
		cput('\0');
}

static Dll* 
initdynimport(void)
{
	Imp *m;
	Dll *d;
	LSym *s, *dynamic;

	dr = nil;
	m = nil;
	for(s = ctxt->allsym; s != S; s = s->allsym) {
		if(!s->reachable || s->type != SDYNIMPORT)
			continue;
		for(d = dr; d != nil; d = d->next) {
			if(strcmp(d->name,s->dynimplib) == 0) {
				m = mal(sizeof *m);
				break;
			}
		}
		if(d == nil) {
			d = mal(sizeof *d);
			d->name = s->dynimplib;
			d->next = dr;
			dr = d;
			m = mal(sizeof *m);
		}
		m->s = s;
		m->next = d->ms;
		d->ms = m;
	}
	
	dynamic = linklookup(ctxt, ".windynamic", 0);
	dynamic->reachable = 1;
	dynamic->type = SWINDOWS;
	for(d = dr; d != nil; d = d->next) {
		for(m = d->ms; m != nil; m = m->next) {
			m->s->type = SWINDOWS | SSUB;
			m->s->sub = dynamic->sub;
			dynamic->sub = m->s;
			m->s->value = dynamic->size;
			dynamic->size += PtrSize;
		}
		dynamic->size += PtrSize;
	}
		
	return dr;
}

static void
addimports(IMAGE_SECTION_HEADER *datsect)
{
	IMAGE_SECTION_HEADER *isect;
	uvlong n, oftbase, ftbase;
	vlong startoff, endoff;
	Imp *m;
	Dll *d;
	LSym* dynamic;
	
	startoff = cpos();
	dynamic = linklookup(ctxt, ".windynamic", 0);

	// skip import descriptor table (will write it later)
	n = 0;
	for(d = dr; d != nil; d = d->next)
		n++;
	cseek(startoff + sizeof(IMAGE_IMPORT_DESCRIPTOR) * (n + 1));

	// write dll names
	for(d = dr; d != nil; d = d->next) {
		d->nameoff = cpos() - startoff;
		strput(d->name);
	}

	// write function names
	for(d = dr; d != nil; d = d->next) {
		for(m = d->ms; m != nil; m = m->next) {
			m->off = nextsectoff + cpos() - startoff;
			wputl(0); // hint
			strput(m->s->extname);
		}
	}
	
	// write OriginalFirstThunks
	oftbase = cpos() - startoff;
	n = cpos();
	for(d = dr; d != nil; d = d->next) {
		d->thunkoff = cpos() - n;
		for(m = d->ms; m != nil; m = m->next)
			put(m->off);
		put(0);
	}

	// add pe section and pad it at the end
	n = cpos() - startoff;
	isect = addpesection(".idata", n, n);
	isect->Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA|
		IMAGE_SCN_MEM_READ|IMAGE_SCN_MEM_WRITE;
	chksectoff(isect, startoff);
	strnput("", isect->SizeOfRawData - n);
	endoff = cpos();

	// write FirstThunks (allocated in .data section)
	ftbase = dynamic->value - datsect->VirtualAddress - PEBASE;
	cseek(datsect->PointerToRawData + ftbase);
	for(d = dr; d != nil; d = d->next) {
		for(m = d->ms; m != nil; m = m->next)
			put(m->off);
		put(0);
	}
	
	// finally write import descriptor table
	cseek(startoff);
	for(d = dr; d != nil; d = d->next) {
		lputl(isect->VirtualAddress + oftbase + d->thunkoff);
		lputl(0);
		lputl(0);
		lputl(isect->VirtualAddress + d->nameoff);
		lputl(datsect->VirtualAddress + ftbase + d->thunkoff);
	}
	lputl(0); //end
	lputl(0);
	lputl(0);
	lputl(0);
	lputl(0);
	
	// update data directory
	dd[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = isect->VirtualAddress;
	dd[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = isect->VirtualSize;
	dd[IMAGE_DIRECTORY_ENTRY_IAT].VirtualAddress = dynamic->value - PEBASE;
	dd[IMAGE_DIRECTORY_ENTRY_IAT].Size = dynamic->size;

	cseek(endoff);
}

static int
scmp(const void *p1, const void *p2)
{
	LSym *s1, *s2;

	s1 = *(LSym**)p1;
	s2 = *(LSym**)p2;
	return strcmp(s1->extname, s2->extname);
}

static void
initdynexport(void)
{
	LSym *s;
	
	nexport = 0;
	for(s = ctxt->allsym; s != S; s = s->allsym) {
		if(!s->reachable || !(s->cgoexport & CgoExportDynamic))
			continue;
		if(nexport+1 > sizeof(dexport)/sizeof(dexport[0])) {
			diag("pe dynexport table is full");
			errorexit();
		}
		
		dexport[nexport] = s;
		nexport++;
	}
	
	qsort(dexport, nexport, sizeof dexport[0], scmp);
}

void
addexports(void)
{
	IMAGE_SECTION_HEADER *sect;
	IMAGE_EXPORT_DIRECTORY e;
	int size, i, va, va_name, va_addr, va_na, v;

	size = sizeof e + 10*nexport + strlen(outfile) + 1;
	for(i=0; i<nexport; i++)
		size += strlen(dexport[i]->extname) + 1;
	
	if (nexport == 0)
		return;
		
	sect = addpesection(".edata", size, size);
	sect->Characteristics = IMAGE_SCN_CNT_INITIALIZED_DATA|IMAGE_SCN_MEM_READ;
	chksectoff(sect, cpos());
	va = sect->VirtualAddress;
	dd[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = va;
	dd[IMAGE_DIRECTORY_ENTRY_EXPORT].Size = sect->VirtualSize;

	va_name = va + sizeof e + nexport*4;
	va_addr = va + sizeof e;
	va_na = va + sizeof e + nexport*8;

	e.Characteristics = 0;
	e.MajorVersion = 0;
	e.MinorVersion = 0;
	e.NumberOfFunctions = nexport;
	e.NumberOfNames = nexport;
	e.Name = va + sizeof e + nexport*10; // Program names.
	e.Base = 1;
	e.AddressOfFunctions = va_addr;
	e.AddressOfNames = va_name;
	e.AddressOfNameOrdinals = va_na;
	// put IMAGE_EXPORT_DIRECTORY
	for (i=0; i<sizeof(e); i++)
		cput(((char*)&e)[i]);
	// put EXPORT Address Table
	for(i=0; i<nexport; i++)
		lputl(dexport[i]->value - PEBASE);		
	// put EXPORT Name Pointer Table
	v = e.Name + strlen(outfile)+1;
	for(i=0; i<nexport; i++) {
		lputl(v);
		v += strlen(dexport[i]->extname)+1;
	}
	// put EXPORT Ordinal Table
	for(i=0; i<nexport; i++)
		wputl(i);
	// put Names
	strnput(outfile, strlen(outfile)+1);
	for(i=0; i<nexport; i++)
		strnput(dexport[i]->extname, strlen(dexport[i]->extname)+1);
	strnput("", sect->SizeOfRawData - size);
}

void
dope(void)
{
	LSym *rel;

	/* relocation table */
	rel = linklookup(ctxt, ".rel", 0);
	rel->reachable = 1;
	rel->type = SELFROSECT;

	initdynimport();
	initdynexport();
}

static int
strtbladd(char *name)
{
	int newsize, thisoff;

	newsize = strtblnextoff + strlen(name) + 1;
	if(newsize > strtblsize) {
		strtblsize = 2 * (newsize + (1<<18));
		strtbl = realloc(strtbl, strtblsize);
	}
	thisoff = strtblnextoff+4; // first string starts at offset=4
	strcpy(&strtbl[strtblnextoff], name);
	strtblnextoff += strlen(name);
	strtbl[strtblnextoff] = 0;
	strtblnextoff++;
	return thisoff;
}

/*
 * For more than 8 characters section names, name contains a slash (/) that is 
 * followed by an ASCII representation of a decimal number that is an offset into 
 * the string table. 
 * reference: pecoff_v8.docx Page 24.
 * <http://www.microsoft.com/whdc/system/platform/firmware/PECOFFdwn.mspx>
 */
IMAGE_SECTION_HEADER*
newPEDWARFSection(char *name, vlong size)
{
	IMAGE_SECTION_HEADER *h;
	char s[8];
	int off;

	if(size == 0)
		return nil;

	off = strtbladd(name);
	sprint(s, "/%d\0", off);
	h = addpesection(s, size, size);
	h->Characteristics = IMAGE_SCN_MEM_READ|
		IMAGE_SCN_MEM_DISCARDABLE;

	return h;
}

static void
addsym(LSym *s, char *name, int type, vlong addr, vlong size, int ver, LSym *gotype)
{
	COFFSym *cs;
	USED(name);
	USED(addr);
	USED(size);
	USED(ver);
	USED(gotype);

	if(s == nil)
		return;

	if(s->sect == nil)
		return;

	switch(type) {
	default:
		return;
	case 'D':
	case 'B':
	case 'T':
		break;
	}

	if(coffsym) {
		cs = &coffsym[ncoffsym];
		cs->sym = s;
		if(strlen(s->name) > 8)
			cs->strtbloff = strtbladd(s->name);
		if(s->value >= segdata.vaddr) {
			cs->value = s->value - segdata.vaddr;
			cs->sect = datasect;
		} else if(s->value >= segtext.vaddr) {
			cs->value = s->value - segtext.vaddr;
			cs->sect = textsect;
		} else {
			cs->value = 0;
			cs->sect = 0;
			diag("addsym %#llx", addr);
		}
	}
	ncoffsym++;
}

static void
addsymtable(void)
{
	IMAGE_SECTION_HEADER *h;
	int i, size;
	COFFSym *s;

	if(!debug['s']) {
		genasmsym(addsym);
		coffsym = mal(ncoffsym * sizeof coffsym[0]);
		ncoffsym = 0;
		genasmsym(addsym);
	}

	siz