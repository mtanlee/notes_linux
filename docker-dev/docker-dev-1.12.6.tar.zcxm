  keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
    keepj call netrw#RestorePosn(svpos)
   elseif !exists("g:netrw_quiet")
    keepj call netrw#ErrorMsg(s:ERROR,"unable to make directory<".newdirname.">",27)
   endif
"   redraw!

  elseif b:netrw_method == 2
   " Remote mkdir:  using ftp+.netrc
   let svpos= netrw#SavePosn()
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">")
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
   keepj call netrw#RestorePosn(svpos)

  elseif b:netrw_method == 3
   " Remote mkdir: using ftp + machine, id, passwd, and fname (ie. no .netrc)
   let svpos= netrw#SavePosn()
"   call Decho("b:netrw_curdir<".b:netrw_curdir.">")
   if exists("b:netrw_fname")
"    call Decho("b:netrw_fname<".b:netrw_fname.">")
    let remotepath= b:netrw_fname
   else
    let remotepath= ""
   endif
   call s:NetrwRemoteFtpCmd(remotepath,g:netrw_remote_mkdir.' "'.newdirname.'"')
   keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif

  let @@= ykeep
"  call Dret("s:NetrwMakeDir")
endfun

" ---------------------------------------------------------------------
" s:TreeSqueezeDir: allows a shift-cr (gvim only) to squeeze the current tree-listing directory {{{2
fun! s:TreeSqueezeDir(islocal)
"  call Dfunc("s:TreeSqueezeDir(islocal=".a:islocal.")")
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " its a tree-listing style
   let curdepth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
   let iline    = line(".") - 1
   let stopline = (exists("w:netrw_bannercnt")? (w:netrw_bannercnt + 1) : 1)
"   call Decho("curdepth=".curdepth)
"   call Decho("stopline#".stopline)
"   call Decho("starting with line#".line(".").": ".getline('.'))
   while iline > stopline
    " find a line that has less depth
    let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"    call Decho("considering  line#".line(".").": ".getline('.'))
    if depth < curdepth
     break
    endif
    norm! k
   endwhile
"   call Decho("squeezing at line#".line(".").": ".getline('.'))
   call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,s:NetrwGetWord()))
  endif
"  call Dret("s:TreeSqueezeDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwMaps: {{{2
fun! s:NetrwMaps(islocal)
"  call Dfunc("s:NetrwMaps(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")

  if g:netrw_mousemaps && g:netrw_retmap
"   call Decho("set up Rexplore 2-leftmouse")
   if !hasmapto("<Plug>NetrwReturn")
    if maparg("<2-leftmouse>","n") == "" || maparg("<2-leftmouse>","n") =~ '^-$'
"     call Decho("making map for 2-leftmouse")
     nmap <unique> <silent> <2-leftmouse>	<Plug>NetrwReturn
    elseif maparg("<c-leftmouse>","n") == ""
"     call Decho("making map for c-leftmouse")
     nmap <unique> <silent> <c-leftmouse>	<Plug>NetrwReturn
    endif
   endif
   nno <silent> <Plug>NetrwReturn	:Rexplore<cr>
"   call Decho("made <Plug>NetrwReturn map")
  endif

  if a:islocal
"   call Decho("make local maps")
   " local normal-mode maps
   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(1)<cr>
   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(1)<cr>
   nnoremap <buffer> <silent> c		:call <SID>NetrwLcd(b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> <cr>	:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(1)<cr>
   nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>
   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(1)<cr>
   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(1)<cr>
   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(1)<cr>
   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(1)<cr>
   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(3)<cr>
   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(1)<cr>
   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(1)<cr>
   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(1)<cr>
   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(4)<cr>
   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(5)<cr>
   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   nnoremap <buffer> <silent> X		:call <SID>NetrwLocalExecute(expand("<cword>"))"<cr>
   " local insert-mode maps
   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(1)<cr>
   inoremap <buffer> <silent> c		<c-o>:exe "keepjumps lcd ".fnameescape(b:netrw_curdir)<cr>
   inoremap <buffer> <silent> c		<c-o>:call <SID>NetrwLcd(b:netrw_curdir)<cr>
   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(1)<cr>
   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(1)<cr>
   inoremap <buffer> <silent> <cr>	<c-o>:call netrw#LocalBrowseCheck(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord()))<cr>
   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(1)<cr>
   inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>
   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(1)<cr>
   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(1)<cr>
   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(1)<cr>
   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(1)<cr>
   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(1)<cr>
   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(1)<cr>
   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(1)<cr>
   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(1)<cr>
   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(1)<cr>
   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(1)<cr>
   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(1)<cr>
   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(1)<cr>
   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(1)<cr>
   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(1)<cr>
   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(1)<cr>
   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(1)<cr>
   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(1)<cr>
   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(1)<cr>
   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(3)<cr>
   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(1,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(1,getqflist())<cr>
   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(1)<cr>
   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(1)<cr>
   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(4)<cr>
   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,expand("%"))<cr>
   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,expand("%"))<cr>
   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(5)<cr>
   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),0),0)"<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
    imap <buffer> <unique> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(1)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <unique> <c-l> <Plug>NetrwRefresh
    imap <buffer> <unique> <c-l> <Plug>NetrwRefresh
   endif
   nnoremap <buffer> <silent> <Plug>NetrwRefresh		:call <SID>NetrwRefresh(1,<SID>NetrwBrowseChgDir(1,'./'))<cr>
   if s:didstarstar || !mapcheck("<s-down>","n")
    nnoremap <buffer> <silent> <s-down>	:Nexplore<cr>
    inoremap <buffer> <silent> <s-down>	:Nexplore<cr>
   endif
   if s:didstarstar || !mapcheck("<s-up>","n")
    nnoremap <buffer> <silent> <s-up>	:Pexplore<cr>
    inoremap <buffer> <silent> <s-up>	:Pexplore<cr>
   endif
   let mapsafecurdir = escape(b:netrw_curdir, s:netrw_map_escape)
   if g:netrw_mousemaps == 1
    nmap <buffer> <leftmouse>   	<Plug>NetrwLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwLeftmouse		<leftmouse>:call <SID>NetrwLeftmouse(1)<cr>
    nmap <buffer> <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>		<Plug>NetrwMiddlemouse		<leftmouse>:call <SID>NetrwPrevWinOpen(1)<cr>
    nmap <buffer> <s-leftmouse>		<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>		<Plug>NetrwSLeftmouse 		<leftmouse>:call <SID>NetrwSLeftmouse(1)<cr>
    nmap <buffer> <s-leftdrag>		<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>		<Plug>NetrwSLeftdrag		<leftmouse>:call <SID>NetrwSLeftdrag(1)<cr>
    nmap <buffer> <2-leftmouse>		<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>		<Plug>Netrw2Leftmouse		-
    imap <buffer> <leftmouse>		<Plug>ILeftmouse
    ino  <buffer> <silent>		<Plug>ILeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(1)<cr>
    imap <buffer> <middlemouse>		<Plug>IMiddlemouse
    ino  <buffer> <silent>		<Plug>IMiddlemouse		<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(1)<cr>
    imap <buffer> <s-leftmouse>		<Plug>ISLeftmouse
    ino  <buffer> <silent>		<Plug>ISLeftmouse		<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(1,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse>  <leftmouse>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
    exe 'inoremap <buffer> <silent> <rightmouse>  <c-o><leftmouse><c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("")<cr>'
   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwLocalRm("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwLocalRename("'.mapsafecurdir.'")<cr>'
   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>

  else " remote
"   call Decho("make remote maps")
   call s:RemotePathAnalysis(b:netrw_curdir)
   " remote normal-mode maps
   nnoremap <buffer> <silent> <cr>	:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   nnoremap <buffer> <silent> <s-cr>	:call <SID>TreeSqueezeDir(0)<cr>
   nnoremap <buffer> <silent> <c-l>	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> -		:call <SID>NetrwBrowseUpDir(0)<cr>
   nnoremap <buffer> <silent> a		:call <SID>NetrwHide(0)<cr>
   nnoremap <buffer> <silent> mb	:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mc	:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   nnoremap <buffer> <silent> md	:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   nnoremap <buffer> <silent> me	:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   nnoremap <buffer> <silent> mf	:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> mF	:<c-u>call <SID>NetrwUnmarkList(bufnr("%"),b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mg	:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   nnoremap <buffer> <silent> mh	:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   nnoremap <buffer> <silent> mm	:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   nnoremap <buffer> <silent> mp	:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   nnoremap <buffer> <silent> mr	:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   nnoremap <buffer> <silent> ms	:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   nnoremap <buffer> <silent> mt	:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   nnoremap <buffer> <silent> mT	:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   nnoremap <buffer> <silent> mu	:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   nnoremap <buffer> <silent> mx	:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
   nnoremap <buffer> <silent> mX	:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   nnoremap <buffer> <silent> mz	:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   nnoremap <buffer> <silent> gb	:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> gd	:<c-u>call <SID>NetrwForceChgDir(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gf	:<c-u>call <SID>NetrwForceFile(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> gh	:<c-u>call <SID>NetrwHidden(0)<cr>
   nnoremap <buffer> <silent> gp	:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> C		:<c-u>call <SID>NetrwSetChgwin()<cr>
   nnoremap <buffer> <silent> i		:call <SID>NetrwListStyle(0)<cr>
   nnoremap <buffer> <silent> I		:call <SID>NetrwBannerCtrl(1)<cr>
   nnoremap <buffer> <silent> o		:call <SID>NetrwSplit(0)<cr>
   nnoremap <buffer> <silent> O		:call <SID>NetrwObtain(0)<cr>
   nnoremap <buffer> <silent> p		:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   nnoremap <buffer> <silent> P		:call <SID>NetrwPrevWinOpen(0)<cr>
   nnoremap <buffer> <silent> qb	:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> mB	:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> qf	:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   nnoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   nnoremap <buffer> <silent> r		:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   nnoremap <buffer> <silent> s		:call <SID>NetrwSortStyle(0)<cr>
   nnoremap <buffer> <silent> S		:call <SID>NetSortSequence(0)<cr>
   nnoremap <buffer> <silent> t		:call <SID>NetrwSplit(1)<cr>
   nnoremap <buffer> <silent> Tb	:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   nnoremap <buffer> <silent> Th	:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   nnoremap <buffer> <silent> u		:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> U		:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   nnoremap <buffer> <silent> v		:call <SID>NetrwSplit(2)<cr>
   nnoremap <buffer> <silent> x		:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
   nnoremap <buffer> <silent> %		:call <SID>NetrwOpenFile(0)<cr>
   " remote insert-mode maps
   inoremap <buffer> <silent> <cr>	<c-o>:call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()))<cr>
   inoremap <buffer> <silent> <c-l>	<c-o>:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   inoremap <buffer> <silent> <s-cr>	<c-o>:call <SID>TreeSqueezeDir(0)<cr>
   inoremap <buffer> <silent> -		<c-o>:call <SID>NetrwBrowseUpDir(0)<cr>
   inoremap <buffer> <silent> a		<c-o>:call <SID>NetrwHide(0)<cr>
   inoremap <buffer> <silent> mb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mc	<c-o>:<c-u>call <SID>NetrwMarkFileCopy(0)<cr>
   inoremap <buffer> <silent> md	<c-o>:<c-u>call <SID>NetrwMarkFileDiff(0)<cr>
   inoremap <buffer> <silent> me	<c-o>:<c-u>call <SID>NetrwMarkFileEdit(0)<cr>
   inoremap <buffer> <silent> mf	<c-o>:<c-u>call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> mg	<c-o>:<c-u>call <SID>NetrwMarkFileGrep(0)<cr>
   inoremap <buffer> <silent> mh	<c-o>:<c-u>call <SID>NetrwMarkHideSfx(0)<cr>
   inoremap <buffer> <silent> mm	<c-o>:<c-u>call <SID>NetrwMarkFileMove(0)<cr>
   inoremap <buffer> <silent> mp	<c-o>:<c-u>call <SID>NetrwMarkFilePrint(0)<cr>
   inoremap <buffer> <silent> mr	<c-o>:<c-u>call <SID>NetrwMarkFileRegexp(0)<cr>
   inoremap <buffer> <silent> ms	<c-o>:<c-u>call <SID>NetrwMarkFileSource(0)<cr>
   inoremap <buffer> <silent> mt	<c-o>:<c-u>call <SID>NetrwMarkFileTgt(0)<cr>
   inoremap <buffer> <silent> mT	<c-o>:<c-u>call <SID>NetrwMarkFileTag(0)<cr>
   inoremap <buffer> <silent> mu	<c-o>:<c-u>call <SID>NetrwUnMarkFile(0)<cr>
   inoremap <buffer> <silent> mx	<c-o>:<c-u>call <SID>NetrwMarkFileExe(0)<cr>
   inoremap <buffer> <silent> mX	<c-o>:<c-u>call <SID>NetrwMarkFileVimCmd(0)<cr>
   inoremap <buffer> <silent> mz	<c-o>:<c-u>call <SID>NetrwMarkFileCompress(0)<cr>
   inoremap <buffer> <silent> gb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(1,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> gh	<c-o>:<c-u>call <SID>NetrwHidden(0)<cr>
   inoremap <buffer> <silent> gp	<c-o>:<c-u>call <SID>NetrwChgPerm(0,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> C		<c-o>:call <SID>NetrwSetChgwin()<cr>
   inoremap <buffer> <silent> i		<c-o>:call <SID>NetrwListStyle(0)<cr>
   inoremap <buffer> <silent> I		<c-o>:call <SID>NetrwBannerCtrl(1)<cr>
   inoremap <buffer> <silent> o		<c-o>:call <SID>NetrwSplit(0)<cr>
   inoremap <buffer> <silent> O		<c-o>:call <SID>NetrwObtain(0)<cr>
   inoremap <buffer> <silent> p		<c-o>:call <SID>NetrwPreview(<SID>NetrwBrowseChgDir(1,<SID>NetrwGetWord(),1))<cr>
   inoremap <buffer> <silent> P		<c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
   inoremap <buffer> <silent> qb	<c-o>:<c-u>call <SID>NetrwBookHistHandler(2,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> mB	<c-o>:<c-u>call <SID>NetrwBookHistHandler(6,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> qf	<c-o>:<c-u>call <SID>NetrwFileInfo(0,<SID>NetrwGetWord())<cr>
   inoremap <buffer> <silent> qF	:<c-u>call <SID>NetrwMarkFileQFEL(0,getqflist())<cr>
   inoremap <buffer> <silent> r		<c-o>:let g:netrw_sort_direction= (g:netrw_sort_direction =~ 'n')? 'r' : 'n'<bar>exe "norm! 0"<bar>call <SID>NetrwBrowse(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   inoremap <buffer> <silent> s		<c-o>:call <SID>NetrwSortStyle(0)<cr>
   inoremap <buffer> <silent> S		<c-o>:call <SID>NetSortSequence(0)<cr>
   inoremap <buffer> <silent> t		<c-o>:call <SID>NetrwSplit(1)<cr>
   inoremap <buffer> <silent> Tb	<c-o>:<c-u>call <SID>NetrwSetTgt('b',v:count1)<cr>
   inoremap <buffer> <silent> Th	<c-o>:<c-u>call <SID>NetrwSetTgt('h',v:count)<cr>
   inoremap <buffer> <silent> u		<c-o>:<c-u>call <SID>NetrwBookHistHandler(4,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> U		<c-o>:<c-u>call <SID>NetrwBookHistHandler(5,b:netrw_curdir)<cr>
   inoremap <buffer> <silent> v		<c-o>:call <SID>NetrwSplit(2)<cr>
   inoremap <buffer> <silent> x		<c-o>:call netrw#NetrwBrowseX(<SID>NetrwBrowseChgDir(0,<SID>NetrwGetWord()),1)<cr>
   inoremap <buffer> <silent> %		<c-o>:call <SID>NetrwOpenFile(0)<cr>
   if !hasmapto('<Plug>NetrwHideEdit')
    nmap <buffer> <c-h> <Plug>NetrwHideEdit
    imap <buffer> <c-h> <Plug>NetrwHideEdit
   endif
   nnoremap <buffer> <silent> <Plug>NetrwHideEdit	:call <SID>NetrwHideEdit(0)<cr>
   if !hasmapto('<Plug>NetrwRefresh')
    nmap <buffer> <c-l> <Plug>NetrwRefresh
    imap <buffer> <c-l> <Plug>NetrwRefresh
   endif

   let mapsafepath     = escape(s:path, s:netrw_map_escape)
   let mapsafeusermach = escape(s:user.s:machine, s:netrw_map_escape)

   nnoremap <buffer> <silent> <Plug>NetrwRefresh	:call <SID>NetrwRefresh(0,<SID>NetrwBrowseChgDir(0,'./'))<cr>
   if g:netrw_mousemaps == 1
    nmap <leftmouse>		<Plug>NetrwLeftmouse
    nno <buffer> <silent>	<Plug>NetrwLeftmouse	<leftmouse>:call <SID>NetrwLeftmouse(0)<cr>
    nmap <buffer> <leftdrag>	<Plug>NetrwLeftdrag
    nno  <buffer> <silent>	<Plug>NetrwLeftdrag	:call <SID>NetrwLeftdrag(0)<cr>
    nmap <buffer> <s-leftmouse>	<Plug>NetrwSLeftmouse
    nno  <buffer> <silent>	<Plug>NetrwSLeftmouse 	<leftmouse>:call <SID>NetrwSLeftmouse(0)<cr>
    nmap <buffer> <s-leftdrag>	<Plug>NetrwSLeftdrag
    nno  <buffer> <silent>	<Plug>NetrwSLeftdrag	<leftmouse>:call <SID>NetrwSLeftdrag(0)<cr>
    nmap <middlemouse>		<Plug>NetrwMiddlemouse
    nno  <buffer> <silent>	<middlemouse>		<Plug>NetrwMiddlemouse <leftmouse>:call <SID>NetrwPrevWinOpen(0)<cr>
    nmap <buffer> <2-leftmouse>	<Plug>Netrw2Leftmouse
    nmap <buffer> <silent>	<Plug>Netrw2Leftmouse	-
    imap <buffer> <leftmouse>	<Plug>ILeftmouse
    ino  <buffer> <silent>	<Plug>ILeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwLeftmouse(0)<cr>
    imap <buffer> <middlemouse>	<Plug>IMiddlemouse
    ino  <buffer> <silent>	<Plug>IMiddlemouse	<c-o><leftmouse><c-o>:call <SID>NetrwPrevWinOpen(0)<cr>
    imap <buffer> <s-leftmouse>	<Plug>ISLeftmouse
    ino  <buffer> <silent>	<Plug>ISLeftmouse	<c-o><leftmouse><c-o>:call <SID>NetrwMarkFile(0,<SID>NetrwGetWord())<cr>
    exe 'nnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'vnoremap <buffer> <silent> <rightmouse> <leftmouse>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
    exe 'inoremap <buffer> <silent> <rightmouse> <c-o><leftmouse><c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   endif
   exe 'nnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> d		:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'nnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'nnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> <del>	:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> D		:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'vnoremap <buffer> <silent> R		:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> <del>	<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> d		<c-o>:call <SID>NetrwMakeDir("'.mapsafeusermach.'")<cr>'
   exe 'inoremap <buffer> <silent> D		<c-o>:call <SID>NetrwRemoteRm("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   exe 'inoremap <buffer> <silent> R		<c-o>:call <SID>NetrwRemoteRename("'.mapsafeusermach.'","'.mapsafepath.'")<cr>'
   nnoremap <buffer> <F1>			:he netrw-quickhelp<cr>
   inoremap <buffer> <F1>			<c-o>:he netrw-quickhelp<cr>
  endif

  keepj call s:SetRexDir(a:islocal,b:netrw_curdir)

"  call Dret("s:NetrwMaps")
endfun

" ---------------------------------------------------------------------
" s:NetrwCommands: sets up commands available only in the netrw buffer windows {{{2
fun! s:NetrwCommands(islocal)
"  call Dfunc("s:NetrwCommands(islocal=".a:islocal.")")

  com! Rexplore if exists("w:netrw_rexlocal")|call s:NetrwRexplore(w:netrw_rexlocal,exists("w:netrw_rexdir")? w:netrw_rexdir : ".")|else|call netrw#ErrorMsg(s:WARNING,"not a former netrw window",79)|endif
  if a:islocal
   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(1,<f-args>)
  else
   com! -buffer -nargs=+ -complete=file MF	call s:NetrwMarkFiles(0,<f-args>)
  endif
  com! -buffer -nargs=? -complete=file MT	call s:NetrwMarkTarget(<q-args>)

"  call Dret("s:NetrwCommands")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFiles: apply s:NetrwMarkFile() to named file(s) {{{2
"                   glob()ing only works with local files
fun! s:NetrwMarkFiles(islocal,...)
"  call Dfunc("s:NetrwMarkFiles(islocal=".a:islocal."...) a:0=".a:0)
  let i = 1
  while i <= a:0
   if a:islocal
    let mffiles= glob(a:{i},0,1)
   else
    let mffiles= [a:{i}]
   endif
"   call Decho("mffiles".string(mffiles))
   for mffile in mffiles
"    call Decho("mffile<".mffile.">")
    call s:NetrwMarkFile(a:islocal,mffile)
   endfor
   let i= i + 1
  endwhile
"  call Dret("s:NetrwMarkFiles")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkTarget: {{{2
fun! s:NetrwMarkTarget(...)
"  call Dfunc("s:NetrwMarkTarget() a:0=".a:0)
  if a:0 == 0 || (a:0 == 1 && a:1 == "")
   let tgt= b:netrw_curdir
  else
   let tgt= a:1
  endif
"  call Decho("tgt<".tgt.">")
  let s:netrwmftgt         = tgt
  let s:netrwmftgt_islocal = tgt !~ '^\a\+://'
  let curislocal           = b:netrw_curdir !~ '^\a\+://'
  let svpos                = netrw#SavePosn()
  call s:NetrwRefresh(curislocal,s:NetrwBrowseChgDir(curislocal,'./'))
  call netrw#RestorePosn(svpos)
"  call Dret("s:NetrwMarkTarget")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFile: (invoked by mf) This function is used to both {{{2
"                  mark and unmark files.  If a markfile list exists,
"                  then the rename and delete functions will use it instead
"                  of whatever may happen to be under the cursor at that
"                  moment.  When the mouse and gui are available,
"                  shift-leftmouse may also be used to mark files.
"
"  Creates two lists
"    s:netrwmarkfilelist    -- holds complete paths to all marked files
"    s:netrwmarkfilelist_#  -- holds list of marked files in current-buffer's directory (#==bufnr())
"
"  Creates a marked file match string
"    s:netrwmarfilemtch_#   -- used with 2match to display marked files
"
"  Creates a buffer version of islocal
"    b:netrw_islocal
fun! s:NetrwMarkFile(islocal,fname)
"  call Dfunc("s:NetrwMarkFile(islocal=".a:islocal." fname<".a:fname.">)")

  " sanity check
  if empty(a:fname)
"   call Dret("s:NetrwMarkFile : emtpy fname")
   return
  endif

  let ykeep   = @@
  let curbufnr= bufnr("%")
  let curdir  = b:netrw_curdir
  if a:fname =~ '^\a'
   let leader= '\<'
  else
   let leader= ''
  endif
  if a:fname =~ '\a$'
   let trailer = '\>[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  else
   let trailer = '[@=|\/\*]\=\ze\%(  \|\t\|$\)'
  endif

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " markfile list pre-exists
"   call Decho("starting s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")
"   call Decho("starting s:netrwmarkfilemtch_{curbufnr}<".s:netrwmarkfilemtch_{curbufnr}.">")
   let b:netrw_islocal= a:islocal

   if index(s:netrwmarkfilelist_{curbufnr},a:fname) == -1
    " append filename to buffer's markfilelist
"    call Decho("append filename<".a:fname."> to local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    call add(s:netrwmarkfilelist_{curbufnr},a:fname)
    let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(a:fname,g:netrw_markfileesc).trailer

   else
    " remove filename from buffer's markfilelist
"    call Decho("remove filename<".a:fname."> from local markfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    call filter(s:netrwmarkfilelist_{curbufnr},'v:val != a:fname')
    if s:netrwmarkfilelist_{curbufnr} == []
     " local markfilelist is empty; remove it entirely
"     call Decho("markfile list now empty")
     call s:NetrwUnmarkList(curbufnr,curdir)
    else
     " rebuild match list to display markings correctly
"     call Decho("rebuild s:netrwmarkfilemtch_".curbufnr)
     let s:netrwmarkfilemtch_{curbufnr}= ""
     let first                         = 1
     for fname in s:netrwmarkfilelist_{curbufnr}
      if first
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.leader.escape(fname,g:netrw_markfileesc).trailer
      else
       let s:netrwmarkfilemtch_{curbufnr}= s:netrwmarkfilemtch_{curbufnr}.'\|'.leader.escape(fname,g:netrw_markfileesc).trailer
      endif
      let first= 0
     endfor
"     call Decho("ending s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}).">")
    endif
   endif

  else
   " initialize new markfilelist

"   call Decho("add fname<".a:fname."> to new markfilelist_".curbufnr)
   let s:netrwmarkfilelist_{curbufnr}= []
   call add(s:netrwmarkfilelist_{curbufnr},a:fname)
"   call Decho("ending s:netrwmarkfilelist_{curbufnr}<".string(s:netrwmarkfilelist_{curbufnr}).">")

   " build initial markfile matching pattern
   if a:fname =~ '/$'
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc)
   else
    let s:netrwmarkfilemtch_{curbufnr}= leader.escape(a:fname,g:netrw_markfileesc).trailer
   endif
"   call Decho("ending s:netrwmarkfilemtch_".curbufnr."<".s:netrwmarkfilemtch_{curbufnr}.">")
  endif

  " handle global markfilelist
  if exists("s:netrwmarkfilelist")
   let dname= s:ComposePath(b:netrw_curdir,a:fname)
   if index(s:netrwmarkfilelist,dname) == -1
    " append new filename to global markfilelist
    call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"    call Decho("append filename<".a:fname."> to global markfilelist<".string(s:netrwmarkfilelist).">")
   else
    " remove new filename from global markfilelist
"    call Decho("filter(".string(s:netrwmarkfilelist).",'v:val != '.".dname.")")
    call filter(s:netrwmarkfilelist,'v:val != "'.dname.'"')
"    call Decho("ending s:netrwmarkfilelist  <".string(s:netrwmarkfilelist).">")
    if s:netrwmarkfilelist == []
     unlet s:netrwmarkfilelist
    endif
   endif
  else
   " initialize new global-directory markfilelist
   let s:netrwmarkfilelist= []
   call add(s:netrwmarkfilelist,s:ComposePath(b:netrw_curdir,a:fname))
"   call Decho("init s:netrwmarkfilelist<".string(s:netrwmarkfilelist).">")
  endif

  " set up 2match'ing to netrwmarkfilemtch list
  if exists("s:netrwmarkfilemtch_{curbufnr}") && s:netrwmarkfilemtch_{curbufnr} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/")
   if exists("g:did_drchip_netrwlist_syntax")
    exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{curbufnr}."/"
   endif
  else
"   call Decho("2match none")
   2match none
  endif
  let @@= ykeep
"  call Dret("s:NetrwMarkFile : s:netrwmarkfilelist_".curbufnr."<".(exists("s:netrwmarkfilelist_{curbufnr}")? string(s:netrwmarkfilelist_{curbufnr}) : " doesn't exist").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCompress: (invoked by mz) This function is used to {{{2
"                          compress/decompress files using the programs
"                          in g:netrw_compress and g:netrw_uncompress,
"                          using g:netrw_compress_suffix to know which to
"                          do.  By default:
"                            g:netrw_compress        = "gzip"
"                            g:netrw_decompress      = { ".gz" : "gunzip" , ".bz2" : "bunzip2" , ".zip" : "unzip" , ".tar" : "tar -xf", ".xz" : "unxz"}
fun! s:NetrwMarkFileCompress(islocal)
"  call Dfunc("s:NetrwMarkFileCompress(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCompress")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}") && exists("g:netrw_compress") && exists("g:netrw_decompress")

   " for every filename in the marked list
   for fname in s:netrwmarkfilelist_{curbufnr}
    let sfx= substitute(fname,'^.\{-}\(\.\a\+\)$','\1','')
"    call Decho("extracted sfx<".sfx.">")
    if exists("g:netrw_decompress['".sfx."']")
     " fname has a suffix indicating that its compressed; apply associated decompression routine
     let exe= g:netrw_decompress[sfx]
"     call Decho("fname<".fname."> is compressed so decompress with <".exe.">")
     let exe= netrw#WinPath(exe)
     if a:islocal
      if g:netrw_keepdir
       let fname= shellescape(s:ComposePath(curdir,fname))
      endif
     else
      let fname= shellescape(b:netrw_curdir.fname,1)
     endif
     if executable(exe)
      if a:islocal
       call system(exe." ".fname)
      else
       keepj call s:RemoteSystem(exe." ".fname)
      endif
     else
      keepj call netrw#ErrorMsg(s:WARNING,"unable to apply<".exe."> to file<".fname.">",50)
     endif
    endif
    unlet sfx

    if exists("exe")
     unlet exe
    elseif a:islocal
     " fname not a compressed file, so compress it
     call system(netrw#WinPath(g:netrw_compress)." ".shellescape(s:ComposePath(b:netrw_curdir,fname)))
    else
     " fname not a compressed file, so compress it
     keepj call s:RemoteSystem(netrw#WinPath(g:netrw_compress)." ".shellescape(fname))
    endif
   endfor	" for every file in the marked list

   call s:NetrwUnmarkList(curbufnr,curdir)
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif
"  call Dret("s:NetrwMarkFileCompress")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileCopy: (invoked by mc) copy marked files to target {{{2
"                      If no marked files, then set up directory as the
"                      target.  Currently does not support copying entire
"                      directories.  Uses the local-buffer marked file list.
"                      Returns 1=success  (used by NetrwMarkFileMove())
"                              0=failure
fun! s:NetrwMarkFileCopy(islocal,...)
"  call Dfunc("s:NetrwMarkFileCopy(islocal=".a:islocal.") target<".(exists("s:netrwmftgt")? s:netrwmftgt : '---')."> a:0=".a:0)

  if !exists("b:netrw_curdir")
   let b:netrw_curdir= getcwd()
"   call Decho("set b:netrw_curdir<".b:netrw_curdir."> (used getcwd)")
  endif
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileCopy")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if !exists("s:netrwmftgt")
   keepj call netrw#ErrorMsg(s:ERROR,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")

  if      a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, local directory to local directory
"   call Decho("copy from local to local")
   if !executable(g:netrw_localcopycmd) && g:netrw_localcopycmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localcopycmd<".g:netrw_localcopycmd."> not executable on your system, aborting",91)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localcopycmd<".g:netrw_localcopycmd."> n/a!")
    return
   endif

   " copy marked files while within the same directory (ie. allow renaming)
   if simplify(s:netrwmftgt) == simplify(b:netrw_curdir)
    if len(s:netrwmarkfilelist_{bufnr('%')}) == 1
     " only one marked file
     let args    = shellescape(b:netrw_curdir."/".s:netrwmarkfilelist_{bufnr('%')}[0])
     let oldname = s:netrwmarkfilelist_{bufnr('%')}[0]
    elseif a:0 == 1
     " this happens when the next case was used to recursively call s:NetrwMarkFileCopy()
     let args    = shellescape(b:netrw_curdir."/".a:1)
     let oldname = a:1
    else
     " copy multiple marked files inside the same directory
     let s:recursive= 1
     for oldname in s:netrwmarkfilelist_{bufnr("%")}
      let ret= s:NetrwMarkFileCopy(a:islocal,oldname)
      if ret == 0
       break
      endif
     endfor
     unlet s:recursive
     call s:NetrwUnmarkList(curbufnr,curdir)
"     call Dret("s:NetrwMarkFileCopy ".ret)
     return ret
    endif

    call inputsave()
    let newname= input("Copy ".oldname." to : ",oldname,"file")
    call inputrestore()
    if newname == ""
"     call Dret("s:NetrwMarkFileCopy 0")
     return 0
    endif
    let args= shellescape(oldname)
    let tgt = shellescape(s:netrwmftgt.'/'.newname)
   else
    let args= join(map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),"shellescape(b:netrw_curdir.\"/\".v:val)"))
    let tgt = shellescape(s:netrwmftgt)
   endif
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let args= substitute(args,'/','\\','g')
    let tgt = substitute(tgt, '/','\\','g')
   endif
   if g:netrw_localcopycmd =~ '\s'
    let copycmd     = substitute(g:netrw_localcopycmd,'\s.*$','','')
    let copycmdargs = substitute(g:netrw_localcopycmd,'^.\{-}\(\s.*\)$','\1','')
    let copycmd     = netrw#WinPath(copycmd).copycmdargs
   else
    let copycmd = netrw#WinPath(g:netrw_localcopycmd)
   endif
"   call Decho("args   <".args.">")
"   call Decho("tgt    <".tgt.">")
"   call Decho("copycmd<".copycmd.">")
"   call Decho("system(".copycmd." ".args." ".tgt.")")
   call system(copycmd." ".args." ".tgt)
   if v:shell_error != 0
    call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localcopycmd<".g:netrw_localcopycmd.">; it doesn't work!",80)
"    call Dret("s:NetrwMarkFileCopy 0 : failed: system(".g:netrw_localcopycmd." ".args." ".shellescape(s:netrwmftgt))
    return 0
   endif

  elseif  a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, local directory to remote directory
"   call Decho("copy from local to remote")
   keepj call s:NetrwUpload(s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " Copy marked files, remote directory to local directory
"   call Decho("copy from remote to local")
   keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},s:netrwmftgt)

  elseif !a:islocal && !s:netrwmftgt_islocal
   " Copy marked files, remote directory to remote directory
"   call Decho("copy from remote to remote")
   let curdir = getcwd()
   let tmpdir = s:GetTempfile("")
   if tmpdir !~ '/'
    let tmpdir= curdir."/".tmpdir
   endif
   if exists("*mkdir")
    call mkdir(tmpdir)
   else
    exe "sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1)
    if v:shell_error != 0
     call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localmkdir<".g:netrw_localmkdir."> to something that works",80)
"     call Dret("s:NetrwMarkFileCopy : failed: sil! !".g:netrw_localmkdir.' '.shellescape(tmpdir,1) )
     return
    endif
   endif
   if isdirectory(tmpdir)
    call s:NetrwLcd(tmpdir)
    keepj call netrw#Obtain(a:islocal,s:netrwmarkfilelist_{bufnr('%')},tmpdir)
    let localfiles= map(deepcopy(s:netrwmarkfilelist_{bufnr('%')}),'substitute(v:val,"^.*/","","")')
    keepj call s:NetrwUpload(localfiles,s:netrwmftgt)
    if getcwd() == tmpdir
     for fname in s:netrwmarkfilelist_{bufnr('%')}
      keepj call s:NetrwDelete(fname)
     endfor
     call s:NetrwLcd(curdir)
     exe "sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1)
     if v:shell_error != 0
      call netrw#ErrorMsg(s:WARNING,"consider setting g:netrw_localrmdir<".g:netrw_localrmdir."> to something that works",80)
"      call Dret("s:NetrwMarkFileCopy : failed: sil !".g:netrw_localrmdir." ".shellescape(tmpdir,1) )
      return
     endif
    else
     call s:NetrwLcd(curdir)
    endif
   endif
  endif

  " -------
  " cleanup
  " -------
"   call Decho("cleanup")
  if !exists("s:recursive")
   " remove markings from local buffer
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

  " refresh buffers
  if !s:netrwmftgt_islocal
   call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
   keepj call s:NetrwRefreshDir(a:islocal,curdir)
  endif
  if g:netrw_fastbrowse <= 1
   keepj call s:LocalBrowseRefresh()
  endif
  
"  call Dret("s:NetrwMarkFileCopy 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileDiff: (invoked by md) This function is used to {{{2
"                      invoke vim's diff mode on the marked files.
"                      Either two or three files can be so handled.
"                      Uses the global marked file list.
fun! s:NetrwMarkFileDiff(islocal)
"  call Dfunc("s:NetrwMarkFileDiff(islocal=".a:islocal.") b:netrw_curdir<".b:netrw_curdir.">")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileDiff")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{".curbufnr."}")
   let cnt    = 0
   let curdir = b:netrw_curdir
   for fname in s:netrwmarkfilelist
    let cnt= cnt + 1
    if cnt == 1
"     call Decho("diffthis: fname<".fname.">")
     exe "e ".fnameescape(fname)
     diffthis
    elseif cnt == 2 || cnt == 3
     vsplit
     wincmd l
"     call Decho("diffthis: ".fname)
     exe "e ".fnameescape(fname)
     diffthis
    else
     break
    endif
   endfor
   call s:NetrwUnmarkList(curbufnr,curdir)
  endif

"  call Dret("s:NetrwMarkFileDiff")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileEdit: (invoked by me) put marked files on arg list and start editing them {{{2
"                       Uses global markfilelist
fun! s:NetrwMarkFileEdit(islocal)
"  call Dfunc("s:NetrwMarkFileEdit(islocal=".a:islocal.")")

  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileEdit")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   call s:SetRexDir(a:islocal,curdir)
   let flist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   " unmark markedfile list
"   call s:NetrwUnmarkList(curbufnr,curdir)
   call s:NetrwUnmarkAll()
"   call Decho("exe sil args ".flist)
   exe "sil args ".flist
  endif
  echo "(use :bn, :bp to navigate files; :Rex to return)"
  
"  call Dret("s:NetrwMarkFileEdit")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileQFEL: convert a quickfix-error list into a marked file list {{{2
fun! s:NetrwMarkFileQFEL(islocal,qfel)
"  call Dfunc("s:NetrwMarkFileQFEL(islocal=".a:islocal.",qfel)")
  call s:NetrwUnmarkAll()
  let curbufnr= bufnr("%")

  if !empty(a:qfel)
   for entry in a:qfel
    let bufnmbr= entry["bufnr"]
"    call Decho("bufname(".bufnmbr.")<".bufname(bufnmbr)."> line#".entry["lnum"]." text=".entry["text"])
    if !exists("s:netrwmarkfilelist_{curbufnr}")
"     call Decho("case: no marked file list")
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    elseif index(s:netrwmarkfilelist_{curbufnr},bufname(bufnmbr)) == -1
     " s:NetrwMarkFile will remove duplicate entries from the marked file list.
     " So, this test lets two or more hits on the same pattern to be ignored.
"     call Decho("case: ".bufname(bufnmbr)." not currently in marked file list")
     call s:NetrwMarkFile(a:islocal,bufname(bufnmbr))
    else
"     call Decho("case: ".bufname(bufnmbr)." already in marked file list")
    endif
   endfor
   echo "(use me to edit marked files)"
  else
   call netrw#ErrorMsg(s:WARNING,"can't convert quickfix error list; its empty!",92)
  endif

"  call Dret("s:NetrwMarkFileQFEL")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileExe: (invoked by mx) execute arbitrary system command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileExe(islocal)
"  call Dfunc("s:NetrwMarkFileExe(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileExe")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">")
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileExe : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
    if a:islocal
     if g:netrw_keepdir
      let fname= shellescape(netrw#WinPath(s:ComposePath(curdir,fname)))
     endif
    else
     let fname= shellescape(netrw#WinPath(b:netrw_curdir.fname))
    endif
    if cmd =~ '%'
     let xcmd= substitute(cmd,'%',fname,'g')
    else
     let xcmd= cmd.' '.fname
    endif
    if a:islocal
"     call Decho("local: xcmd<".xcmd.">")
     let ret= system(xcmd)
    else
"     call Decho("remote: xcmd<".xcmd.">")
     let ret= s:RemoteSystem(xcmd)
    endif
    if v:shell_error < 0
     keepj call netrw#ErrorMsg(s:ERROR,"command<".xcmd."> failed, aborting",54)
     break
    else
     echo ret
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif
  
"  call Dret("s:NetrwMarkFileExe")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileVimCmd: (invoked by mX) execute arbitrary vim command on marked files, one at a time {{{2
"                     Uses the local marked-file list.
fun! s:NetrwMarkFileVimCmd(islocal)
"  call Dfunc("s:NetrwMarkFileVimCmd(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileVimCmd")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist_{curbufnr}")
   " get the command
   call inputsave()
   let cmd= input("Enter vim command: ","","file")
   call inputrestore()
"   call Decho("cmd<".cmd.">")
   if cmd == ""
"    "   call Dret("s:NetrwMarkFileVimCmd : early exit, empty command")
    return
   endif

   " apply command to marked files.  Substitute: filename -> %
   " If no %, then append a space and the filename to the command
   for fname in s:netrwmarkfilelist_{curbufnr}
"    call Decho("fname<".fname.">")
    if a:islocal
     1split
     exe "sil! keepalt e ".fnameescape(fname)
"     call Decho("local<".fname.">: exe ".cmd)
     exe cmd
     exe "sil! keepalt wq!"
    else
"     call Decho("remote<".fname.">: exe ".cmd." : NOT SUPPORTED YET")
     echo "sorry, \"mX\" not supported yet for remote files"
    endif
   endfor

   " unmark marked file list
   call s:NetrwUnmarkList(curbufnr,curdir)

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif
  
"  call Dret("s:NetrwMarkFileVimCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkHideSfx: (invoked by mh) (un)hide files having same suffix
"                  as the marked file(s) (toggles suffix presence)
"                  Uses the local marked file list.
fun! s:NetrwMarkHideSfx(islocal)
"  call Dfunc("s:NetrwMarkHideSfx(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " s:netrwmarkfilelist_{curbufnr}: the List of marked files
  if exists("s:netrwmarkfilelist_{curbufnr}")

   for fname in s:netrwmarkfilelist_{curbufnr}
"     call Decho("s:NetrwMarkFileCopy: fname<".fname.">")
     " construct suffix pattern
     if fname =~ '\.'
      let sfxpat= "^.*".substitute(fname,'^.*\(\.[^. ]\+\)$','\1','')
     else
      let sfxpat= '^\%(\%(\.\)\@!.\)*$'
     endif
     " determine if its in the hiding list or not
     let inhidelist= 0
     if g:netrw_list_hide != ""
      let itemnum = 0
      let hidelist= split(g:netrw_list_hide,',')
      for hidepat in hidelist
       if sfxpat == hidepat
        let inhidelist= 1
        break
       endif
       let itemnum= itemnum + 1
      endfor
     endif
"     call Decho("fname<".fname."> inhidelist=".inhidelist." sfxpat<".sfxpat.">")
     if inhidelist
      " remove sfxpat from list
      call remove(hidelist,itemnum)
      let g:netrw_list_hide= join(hidelist,",")
     elseif g:netrw_list_hide != ""
      " append sfxpat to non-empty list
      let g:netrw_list_hide= g:netrw_list_hide.",".sfxpat
     else
      " set hiding list to sfxpat
      let g:netrw_list_hide= sfxpat
     endif
    endfor

   " refresh the listing
   keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   keepj call netrw#RestorePosn(svpos)
  else
   keepj call netrw#ErrorMsg(s:ERROR,"no files marked!",59)
  endif

"  call Dret("s:NetrwMarkHideSfx")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileGrep: (invoked by mg) This function applies vimgrep to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileGrep(islocal)
"  call Dfunc("s:NetrwMarkFileGrep(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  if exists("s:netrwmarkfilelist")
"  call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "fnameescape(v:val)"))
   call s:NetrwUnmarkAll()
  else
"   call Decho('no marked files, using "*"')
   let netrwmarkfilelist= "*"
  endif

  " ask user for pattern
  call inputsave()
  let pat= input("Enter pattern: ","")
  call inputrestore()
  let patbang = ""
  if pat =~ '^!'
   let patbang = "!"
   let pat= strpart(pat,2)
  endif
  if pat =~ '^\i'
   let pat    = escape(pat,'/')
   let pat    = '/'.pat.'/'
  else
   let nonisi = pat[0]
  endif

  " use vimgrep for both local and remote
"  call Decho("exe vimgrep".patbang." ".pat." ".netrwmarkfilelist)
  try
   exe "keepj noautocmd vimgrep".patbang." ".pat." ".netrwmarkfilelist
  catch /^Vim\%((\a\+)\)\=:E480/
   keepj call netrw#ErrorMsg(s:WARNING,"no match with pattern<".pat.">",76)
"   call Dret("s:NetrwMarkFileGrep : unable to find pattern<".pat.">")
   return
  endtry
  echo "(use :cn, :cp to navigate, :Rex to return)"

  2match none
  keepj call netrw#RestorePosn(svpos)

  if exists("nonisi")
   " original, user-supplied pattern did not begin with a character from isident
"   call Decho("looking for trailing nonisi<".nonisi."> followed by a j, gj, or jg")
   if pat =~ nonisi.'j$\|'.nonisi.'gj$\|'.nonisi.'jg$'
    call s:NetrwMarkFileQFEL(a:islocal,getqflist())
   endif
  endif

"  call Dret("s:NetrwMarkFileGrep")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileMove: (invoked by mm) execute arbitrary command on marked files, one at a time {{{2
"                      uses the global marked file list
"                      s:netrwmfloc= 0: target directory is remote
"                                  = 1: target directory is local
fun! s:NetrwMarkFileMove(islocal)
"  call Dfunc("s:NetrwMarkFileMove(islocal=".a:islocal.")")
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileMove")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if !exists("s:netrwmftgt")
   keepj call netrw#ErrorMsg(2,"your marked file target is empty! (:help netrw-mt)",67)
"   call Dret("s:NetrwMarkFileCopy 0")
   return 0
  endif
"  call Decho("sanity chk passed: s:netrwmftgt<".s:netrwmftgt.">")

  if      a:islocal &&  s:netrwmftgt_islocal
   " move: local -> local
"   call Decho("move from local to local")
"   call Decho("local to local move")
   if !executable(g:netrw_localmovecmd) && g:netrw_localmovecmd !~ '^'.expand("$COMSPEC").'\s'
    call netrw#ErrorMsg(s:ERROR,"g:netrw_localmovecmd<".g:netrw_localmovecmd."> not executable on your system, aborting",90)
"    call Dfunc("s:NetrwMarkFileMove : g:netrw_localmovecmd<".g:netrw_localmovecmd."> n/a!")
    return
   endif
   let tgt         = shellescape(s:netrwmftgt)
"   call Decho("tgt<".tgt.">")
   if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
    let tgt         = substitute(tgt, '/','\\','g')
"    call Decho("windows exception: tgt<".tgt.">")
    if g:netrw_localmovecmd =~ '\s'
     let movecmd     = substitute(g:netrw_localmovecmd,'\s.*$','','')
     let movecmdargs = substitute(g:netrw_localmovecmd,'^.\{-}\(\s.*\)$','\1','')
     let movecmd     = netrw#WinPath(movecmd).movecmdargs
"     call Decho("windows exception: movecmd<".movecmd."> (#1: had a space)")
    else
     let movecmd = netrw#WinPath(movecmd)
"     call Decho("windows exception: movecmd<".movecmd."> (#2: no space)")
    endif
   else
    let movecmd = netrw#WinPath(g:netrw_localmovecmd)
"    call Decho("movecmd<".movecmd."> (#3 linux or cygwin)")
   endif
   for fname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("system(".movecmd." ".shellescape(fname)." ".tgt.")")
    if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
     let fname= substitute(fname,'/','\\','g')
    endif
    let ret= system(g:netrw_localmovecmd." ".shellescape(fname)." ".tgt)
    if v:shell_error != 0
     call netrw#ErrorMsg(s:ERROR,"tried using g:netrw_localmovecmd<".g:netrw_localmovecmd.">; it doesn't work!",54)
     break
    endif
   endfor

  elseif  a:islocal && !s:netrwmftgt_islocal
   " move: local -> remote
"   call Decho("move from local to remote")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwLocalRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal &&  s:netrwmftgt_islocal
   " move: remote -> local
"   call Decho("move from remote to local")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist

  elseif !a:islocal && !s:netrwmftgt_islocal
   " move: remote -> remote
"   call Decho("move from remote to remote")
"   call Decho("copy")
   let mflist= s:netrwmarkfilelist_{bufnr("%")}
   keepj call s:NetrwMarkFileCopy(a:islocal)
"   call Decho("remove")
   for fname in mflist
    let barefname = substitute(fname,'^\(.*/\)\(.\{-}\)$','\2','')
    let ok        = s:NetrwRemoteRmFile(b:netrw_curdir,barefname,1)
   endfor
   unlet mflist
  endif

  " -------
  " cleanup
  " -------
"  call Decho("cleanup")

  " remove markings from local buffer
  call s:NetrwUnmarkList(curbufnr,curdir)                   " remove markings from local buffer

  " refresh buffers
  if !s:netrwmftgt_islocal
"   call Decho("refresh netrwmftgt<".s:netrwmftgt.">")
   keepj call s:NetrwRefreshDir(s:netrwmftgt_islocal,s:netrwmftgt)
  endif
  if a:islocal
"   call Decho("refresh b:netrw_curdir<".b:netrw_curdir.">")
   keepj call s:NetrwRefreshDir(a:islocal,b:netrw_curdir)
  endif
  if g:netrw_fastbrowse <= 1
"   call Decho("since g:netrw_fastbrowse=".g:netrw_fastbrowse.", perform shell cmd refresh")
   keepj call s:LocalBrowseRefresh()
  endif
  
"  call Dret("s:NetrwMarkFileMove")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFilePrint: (invoked by mp) This function prints marked files {{{2
"                       using the hardcopy command.  Local marked-file list only.
fun! s:NetrwMarkFilePrint(islocal)
"  call Dfunc("s:NetrwMarkFilePrint(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFilePrint")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{curbufnr}
   let curdir            = b:netrw_curdir
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    1split
    " the autocmds will handle both local and remote files
"    call Decho("exe sil e ".escape(fname,' '))
    exe "sil e ".fnameescape(fname)
"    call Decho("hardcopy")
    hardcopy
    q
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFilePrint")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileRegexp: (invoked by mr) This function is used to mark {{{2
"                        files when given a regexp (for which a prompt is
"                        issued) (matches to name of files).
fun! s:NetrwMarkFileRegexp(islocal)
"  call Dfunc("s:NetrwMarkFileRegexp(islocal=".a:islocal.")")

  " get the regular expression
  call inputsave()
  let regexp= input("Enter regexp: ","","file")
  call inputrestore()

  if a:islocal
   " get the matching list of files using local glob()
"   call Decho("handle local regexp")
   let dirname = escape(b:netrw_curdir,g:netrw_glob_escape)
   let files   = glob(s:ComposePath(dirname,regexp))
"   call Decho("files<".files.">")
   let filelist= split(files,"\n")

  " mark the list of files
  for fname in filelist
"   call Decho("fname<".fname.">")
   keepj call s:NetrwMarkFile(a:islocal,substitute(fname,'^.*/','',''))
  endfor

  else
"   call Decho("handle remote regexp")

   " convert displayed listing into a filelist
   let eikeep = &ei
   let areg   = @a
   sil keepj %y a
   setl ei=all ma
"   call Decho("setl ei=all ma")
   1split
   keepj call s:NetrwEnew()
   keepj call s:NetrwSafeOptions()
   sil keepj norm! "ap
   keepj 2
   let bannercnt= search('^" =====','W')
   exe "sil keepj 1,".bannercnt."d"
   setl bt=nofile
   if     g:netrw_liststyle == s:LONGLIST
    sil keepj %s/\s\{2,}\S.*$//e
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:WIDELIST
    sil keepj %s/\s\{2,}/\r/ge
    call histdel("/",-1)
   elseif g:netrw_liststyle == s:TREELIST
    exe 'sil keepj %s/^'.s:treedepthstring.' //e'
    sil! keepj g/^ .*$/d
    call histdel("/",-1)
    call histdel("/",-1)
   endif
   " convert regexp into the more usual glob-style format
   let regexp= substitute(regexp,'\*','.*','g')
"   call Decho("regexp<".regexp.">")
   exe "sil! keepj v/".escape(regexp,'/')."/d"
   call histdel("/",-1)
   let filelist= getline(1,line("$"))
   q!
   for filename in filelist
    keepj call s:NetrwMarkFile(a:islocal,substitute(filename,'^.*/','',''))
   endfor
   unlet filelist
   let @a  = areg
   let &ei = eikeep
  endif
  echo "  (use me to edit marked files)"

"  call Dret("s:NetrwMarkFileRegexp")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileSource: (invoked by ms) This function sources marked files {{{2
"                        Uses the local marked file list.
fun! s:NetrwMarkFileSource(islocal)
"  call Dfunc("s:NetrwMarkFileSource(islocal=".a:islocal.")")
  let curbufnr= bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileSource")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))
  if exists("s:netrwmarkfilelist_{curbufnr}")
   let netrwmarkfilelist = s:netrwmarkfilelist_{bufnr("%")}
   let curdir            = b:netrw_curdir
   call s:NetrwUnmarkList(curbufnr,curdir)
   for fname in netrwmarkfilelist
    if a:islocal
     if g:netrw_keepdir
      let fname= s:ComposePath(curdir,fname)
     endif
    else
     let fname= curdir.fname
    endif
    " the autocmds will handle sourcing both local and remote files
"    call Decho("exe so ".fnameescape(fname))
    exe "so ".fnameescape(fname)
   endfor
   2match none
  endif
"  call Dret("s:NetrwMarkFileSource")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTag: (invoked by mT) This function applies g:netrw_ctags to marked files {{{2
"                     Uses the global markfilelist
fun! s:NetrwMarkFileTag(islocal)
"  call Dfunc("s:NetrwMarkFileTag(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curdir   = b:netrw_curdir
  let curbufnr = bufnr("%")

  " sanity check
  if !exists("s:netrwmarkfilelist_{curbufnr}") || empty(s:netrwmarkfilelist_{curbufnr})
   keepj call netrw#ErrorMsg(2,"there are no marked files in this window (:help netrw-mf)",66)
"   call Dret("s:NetrwMarkFileTag")
   return
  endif
"  call Decho("sanity chk passed: s:netrwmarkfilelist_".curbufnr."<".string(s:netrwmarkfilelist_{curbufnr}))

  if exists("s:netrwmarkfilelist")
"   call Decho("s:netrwmarkfilelist".string(s:netrwmarkfilelist).">")
   let netrwmarkfilelist= join(map(deepcopy(s:netrwmarkfilelist), "shellescape(v:val,".!a:islocal.")"))
   call s:NetrwUnmarkAll()

   if a:islocal
    if executable(g:netrw_ctags)
"     call Decho("call system(".g:netrw_ctags." ".netrwmarkfilelist.")")
     call system(g:netrw_ctags." ".netrwmarkfilelist)
    else
     call netrw#ErrorMsg(s:ERROR,"g:netrw_ctags<".g:netrw_ctags."> is not executable!",51)
    endif
   else
    let cmd   = s:RemoteSystem(g:netrw_ctags." ".netrwmarkfilelist)
    call netrw#Obtain(a:islocal,"tags")
    let curdir= b:netrw_curdir
    1split
    e tags
    let path= substitute(curdir,'^\(.*\)/[^/]*$','\1/','')
"    call Decho("curdir<".curdir."> path<".path.">")
    exe 'keepj %s/\t\(\S\+\)\t/\t'.escape(path,"/\n\r\\").'\1\t/e'
    call histdel("/",-1)
    wq!
   endif
   2match none
   call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
   call netrw#RestorePosn(svpos)
  endif

"  call Dret("s:NetrwMarkFileTag")
endfun

" ---------------------------------------------------------------------
" s:NetrwMarkFileTgt:  (invoked by mt) This function sets up a marked file target {{{2
"   Sets up two variables, 
"     s:netrwmftgt         : holds the target directory
"     s:netrwmftgt_islocal : 0=target directory is remote
"                            1=target directory is local
fun! s:NetrwMarkFileTgt(islocal)
"  call Dfunc("s:NetrwMarkFileTgt(islocal=".a:islocal.")")
  let svpos  = netrw#SavePosn()
  let curdir = b:netrw_curdir
  let hadtgt = exists("s:netrwmftgt")
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= b:netrw_bannercnt
  endif

  " set up target
  if line(".") < w:netrw_bannercnt
   " if cursor in banner region, use b:netrw_curdir for the target unless its already the target
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal") && s:netrwmftgt == b:netrw_curdir
"    call Decho("cursor in banner region, and target already is <".b:netrw_curdir.">: removing target")
    unlet s:netrwmftgt s:netrwmftgt_islocal
    if g:netrw_fastbrowse <= 1
     call s:LocalBrowseRefresh()
    endif
    call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
    call netrw#RestorePosn(svpos)
"    call Dret("s:NetrwMarkFileTgt : removed target")
    return
   else
    let s:netrwmftgt= b:netrw_curdir
"    call Decho("inbanner: s:netrwmftgt<".s:netrwmftgt.">")
   endif

  else
   " get word under cursor.
   "  * If directory, use it for the target.
   "  * If file, use b:netrw_curdir for the target
   let curword= s:NetrwGetWord()
   let tgtdir = s:ComposePath(curdir,curword)
   if a:islocal && isdirectory(tgtdir)
    let s:netrwmftgt = tgtdir
"    call Decho("local isdir: s:netrwmftgt<".s:netrwmftgt.">")
   elseif !a:islocal && tgtdir =~ '/$'
    let s:netrwmftgt = tgtdir
"    call Decho("remote isdir: s:netrwmftgt<".s:netrwmftgt.">")
   else
    let s:netrwmftgt = curdir
"    call Decho("isfile: s:netrwmftgt<".s:netrwmftgt.">")
   endif
  endif
  if a:islocal
   " simplify the target (eg. /abc/def/../ghi -> /abc/ghi)
   let s:netrwmftgt= simplify(s:netrwmftgt)
"   call Decho("simplify: s:netrwmftgt<".s:netrwmftgt.">")
  endif
  if g:netrw_cygwin
   let s:netrwmftgt= substitute(system("cygpath ".shellescape(s:netrwmftgt)),'\n$','','')
   let s:netrwmftgt= substitute(s:netrwmftgt,'\n$','','')
  endif
  let s:netrwmftgt_islocal= a:islocal

  if g:netrw_fastbrowse <= 1
   call s:LocalBrowseRefresh()
  endif
  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  call netrw#RestorePosn(svpos)
  if !hadtgt
   sil! keepj norm! j
  endif

"  call Dret("s:NetrwMarkFileTgt : netrwmftgt<".(exists("s:netrwmftgt")? s:netrwmftgt : "").">")
endfun

" ---------------------------------------------------------------------
" s:NetrwOpenFile: query user for a filename and open it {{{2
fun! s:NetrwOpenFile(islocal)
"  call Dfunc("s:NetrwOpenFile(islocal=".a:islocal.")")
  let ykeep= @@
  call inputsave()
  let fname= input("Enter filename: ")
  call inputrestore()
  if fname !~ '[/\\]'
   if exists("b:netrw_curdir")
    if exists("g:netrw_quiet")
     let netrw_quiet_keep = g:netrw_quiet
    endif
    let g:netrw_quiet    = 1
    if b:netrw_curdir =~ '/$'
     exe "e ".fnameescape(b:netrw_curdir.fname)
    else
     exe "e ".fnameescape(b:netrw_curdir."/".fname)
    endif
    if exists("netrw_quiet_keep")
     let g:netrw_quiet= netrw_quiet_keep
    else
     unlet g:netrw_quiet
    endif
   endif
  else
   exe "e ".fnameescape(fname)
  endif
  let @@= ykeep
"  call Dret("s:NetrwOpenFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkList: delete local marked file lists and remove their contents from the global marked-file list {{{2
"   User access provided by the <mu> mapping. (see :help netrw-mu)
"   Used by many MarkFile functions.
fun! s:NetrwUnmarkList(curbufnr,curdir)
"  call Dfunc("s:NetrwUnmarkList(curbufnr=".a:curbufnr." curdir<".a:curdir.">)")

  "  remove all files in local marked-file list from global list
  if exists("s:netrwmarkfilelist_{a:curbufnr}")
   for mfile in s:netrwmarkfilelist_{a:curbufnr}
    let dfile = s:ComposePath(a:curdir,mfile)       " prepend directory to mfile
    let idx   = index(s:netrwmarkfilelist,dfile)    " get index in list of dfile
    call remove(s:netrwmarkfilelist,idx)            " remove from global list
   endfor
   if s:netrwmarkfilelist == []
    unlet s:netrwmarkfilelist
   endif
 
   " getting rid of the local marked-file lists is easy
   unlet s:netrwmarkfilelist_{a:curbufnr}
  endif
  if exists("s:netrwmarkfilemtch_{a:curbufnr}")
   unlet s:netrwmarkfilemtch_{a:curbufnr}
  endif
  2match none
"  call Dret("s:NetrwUnmarkList")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll: remove the global marked file list and all local ones {{{2
fun! s:NetrwUnmarkAll()
"  call Dfunc("s:NetrwUnmarkAll()")
  if exists("s:netrwmarkfilelist")
   unlet s:netrwmarkfilelist
  endif
  sil call s:NetrwUnmarkAll2()
  2match none
"  call Dret("s:NetrwUnmarkAll")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnmarkAll2: unmark all files from all buffers {{{2
fun! s:NetrwUnmarkAll2()
"  call Dfunc("s:NetrwUnmarkAll2()")
  redir => netrwmarkfilelist_let
  let
  redir END
  let netrwmarkfilelist_list= split(netrwmarkfilelist_let,'\n')          " convert let string into a let list
  call filter(netrwmarkfilelist_list,"v:val =~ '^s:netrwmarkfilelist_'") " retain only those vars that start as s:netrwmarkfilelist_ 
  call map(netrwmarkfilelist_list,"substitute(v:val,'\\s.*$','','')")    " remove what the entries are equal to
  for flist in netrwmarkfilelist_list
   let curbufnr= substitute(flist,'s:netrwmarkfilelist_','','')
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
  endfor
"  call Dret("s:NetrwUnmarkAll2")
endfun

" ---------------------------------------------------------------------
" s:NetrwUnMarkFile: {{{2
fun! s:NetrwUnMarkFile(islocal)
"  call Dfunc("s:NetrwUnMarkFile(islocal=".a:islocal.")")
  let svpos    = netrw#SavePosn()
  let curbufnr = bufnr("%")

  " unmark marked file list (although I expect s:NetrwUpload()
  " to do it, I'm just making sure)
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
"   call Decho("unlet'ing: s:netrwmarkfile[list|mtch]_".bufnr("%"))
   unlet s:netrwmarkfilelist
   unlet s:netrwmarkfilelist_{curbufnr}
   unlet s:netrwmarkfilemtch_{curbufnr}
   2match none
  endif

"  call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  call netrw#RestorePosn(svpos)
"  call Dret("s:NetrwUnMarkFile")
endfun

" ---------------------------------------------------------------------
" s:NetrwMenu: generates the menu for gvim and netrw {{{2
fun! s:NetrwMenu(domenu)

  if !exists("g:NetrwMenuPriority")
   let g:NetrwMenuPriority= 80
  endif

  if has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
"   call Dfunc("NetrwMenu(domenu=".a:domenu.")")

   if !exists("s:netrw_menu_enabled") && a:domenu
"    call Decho("initialize menu")
    let s:netrw_menu_enabled= 1
    exe 'sil! menu '.g:NetrwMenuPriority.'.1      '.g:NetrwTopLvlMenu.'Help<tab><F1>	<F1>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.5      '.g:NetrwTopLvlMenu.'-Sep1-	:'
    exe 'sil! menu '.g:NetrwMenuPriority.'.6      '.g:NetrwTopLvlMenu.'Go\ Up\ Directory<tab>-	-'
    exe 'sil! menu '.g:NetrwMenuPriority.'.7      '.g:NetrwTopLvlMenu.'Apply\ Special\ Viewer<tab>x	x'
    if g:netrw_dirhistmax > 0
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.1   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Bookmark\ Current\ Directory<tab>mb	mb'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.4   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Prev\ Dir\ (History)<tab>u	u'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.5   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.Goto\ Next\ Dir\ (History)<tab>U	U'
     exe 'sil! menu '.g:NetrwMenuPriority.'.8.6   '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History.List<tab>qb	qb'
    else
     exe 'sil! menu '.g:NetrwMenuPriority.'.8     '.g:NetrwTopLvlMenu.'Bookmarks\ and\ History	:echo "(disabled)"'."\<cr>"
    endif
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.1    '.g:NetrwTopLvlMenu.'Browsing\ Control.Horizontal\ Split<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.2    '.g:NetrwTopLvlMenu.'Browsing\ Control.Vertical\ Split<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.3    '.g:NetrwTopLvlMenu.'Browsing\ Control.New\ Tab<tab>t	t'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.4    '.g:NetrwTopLvlMenu.'Browsing\ Control.Preview<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.5    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ File\ Hiding\ List<tab><ctrl-h>'."	\<c-h>'"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.6    '.g:NetrwTopLvlMenu.'Browsing\ Control.Edit\ Sorting\ Sequence<tab>S	S'
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.7    '.g:NetrwTopLvlMenu.'Browsing\ Control.Quick\ Hide/Unhide\ Dot\ Files<tab>'."gh	gh"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.8    '.g:NetrwTopLvlMenu.'Browsing\ Control.Refresh\ Listing<tab>'."<ctrl-l>	\<c-l>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.9.9    '.g:NetrwTopLvlMenu.'Browsing\ Control.Settings/Options<tab>:NetrwSettings	'.":NetrwSettings\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.10     '.g:NetrwTopLvlMenu.'Delete\ File/Directory<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Create\ New\ File<tab>%	%'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.1   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Current\ Window<tab><cr>	'."\<cr>"
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.2   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.Preview\ File/Directory<tab>p	p'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.3   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ Previous\ Window<tab>P	P'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.4   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Window<tab>o	o'
    exe 'sil! menu '.g:NetrwMenuPriority.'.11.5   '.g:NetrwTopLvlMenu.'Edit\ File/Dir.In\ New\ Vertical\ Window<tab>v	v'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.1   '.g:NetrwTopLvlMenu.'Explore.Directory\ Name	:Explore '
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (curdir\ only)<tab>:Explore\ */	:Explore */'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.2   '.g:NetrwTopLvlMenu.'Explore.Filenames\ Matching\ Pattern\ (+subdirs)<tab>:Explore\ **/	:Explore **/'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.3   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (curdir\ only)<tab>:Explore\ *//	:Explore *//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Files\ Containing\ String\ Pattern\ (+subdirs)<tab>:Explore\ **//	:Explore **//'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Next\ Match<tab>:Nexplore	:Nexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.12.4   '.g:NetrwTopLvlMenu.'Explore.Prev\ Match<tab>:Pexplore	:Pexplore<cr>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.13     '.g:NetrwTopLvlMenu.'Make\ Subdirectory<tab>d	d'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.1   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ File<tab>mf	mf'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.2   '.g:NetrwTopLvlMenu.'Marked\ Files.Mark\ Files\ by\ Regexp<tab>mr	mr'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.3   '.g:NetrwTopLvlMenu.'Marked\ Files.Hide-Show-List\ Control<tab>a	a'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.4   '.g:NetrwTopLvlMenu.'Marked\ Files.Copy\ To\ Target<tab>mc	mc'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.5   '.g:NetrwTopLvlMenu.'Marked\ Files.Delete<tab>D	D'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.6   '.g:NetrwTopLvlMenu.'Marked\ Files.Diff<tab>md	md'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.7   '.g:NetrwTopLvlMenu.'Marked\ Files.Edit<tab>me	me'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.8   '.g:NetrwTopLvlMenu.'Marked\ Files.Exe\ Cmd<tab>mx	mx'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.9   '.g:NetrwTopLvlMenu.'Marked\ Files.Move\ To\ Target<tab>mm	mm'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.10  '.g:NetrwTopLvlMenu.'Marked\ Files.Obtain<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.11  '.g:NetrwTopLvlMenu.'Marked\ Files.Print<tab>mp	mp'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.12  '.g:NetrwTopLvlMenu.'Marked\ Files.Replace<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.13  '.g:NetrwTopLvlMenu.'Marked\ Files.Set\ Target<tab>mt	mt'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.14  '.g:NetrwTopLvlMenu.'Marked\ Files.Tag<tab>mT	mT'
    exe 'sil! menu '.g:NetrwMenuPriority.'.14.15  '.g:NetrwTopLvlMenu.'Marked\ Files.Zip/Unzip/Compress/Uncompress<tab>mz	mz'
    exe 'sil! menu '.g:NetrwMenuPriority.'.15     '.g:NetrwTopLvlMenu.'Obtain\ File<tab>O	O'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.thin<tab>i	:let w:netrw_liststyle=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.long<tab>i	:let w:netrw_liststyle=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.wide<tab>i	:let w:netrw_liststyle=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.1.1 '.g:NetrwTopLvlMenu.'Style.Listing.tree<tab>i	:let w:netrw_liststyle=3<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.1 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Show\ All<tab>a	:let g:netrw_hide=0<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.3 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Normal<tab>a	:let g:netrw_hide=1<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.2.2 '.g:NetrwTopLvlMenu.'Style.Normal-Hide-Show.Hidden\ Only<tab>a	:let g:netrw_hide=2<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.3   '.g:NetrwTopLvlMenu.'Style.Reverse\ Sorting\ Order<tab>'."r	r"
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.1 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Name<tab>s       :let g:netrw_sort_by="name"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.2 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Time<tab>s       :let g:netrw_sort_by="time"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.16.4.3 '.g:NetrwTopLvlMenu.'Style.Sorting\ Method.Size<tab>s       :let g:netrw_sort_by="size"<cr><c-L>'
    exe 'sil! menu '.g:NetrwMenuPriority.'.17     '.g:NetrwTopLvlMenu.'Rename\ File/Directory<tab>R	R'
    exe 'sil! menu '.g:NetrwMenuPriority.'.18     '.g:NetrwTopLvlMenu.'Set\ Current\ Directory<tab>c	c'
    let s:netrw_menucnt= 28
    call s:NetrwBookmarkMenu() " provide some history!  uses priorities 2,3, reserves 4, 8.2.x
    call s:NetrwTgtMenu()      " let bookmarks and history be easy targets

   elseif !a:domenu
    let s:netrwcnt = 0
    let curwin     = winnr()
    windo if getline(2) =~ "Netrw" | let s:netrwcnt= s:netrwcnt + 1 | endif
    exe curwin."wincmd w"

    if s:netrwcnt <= 1
"     call Decho("clear menus")
     exe 'sil! unmenu '.g:NetrwTopLvlMenu
"     call Decho('exe sil! unmenu '.g:NetrwTopLvlMenu.'*')
     sil! unlet s:netrw_menu_enabled
    endif
   endif
"   call Dret("NetrwMenu")
   return
  endif

endfun

" ---------------------------------------------------------------------
" s:NetrwObtain: obtain file under cursor or from markfile list {{{2
"                Used by the O maps (as <SID>NetrwObtain())
fun! s:NetrwObtain(islocal)
"  call Dfunc("NetrwObtain(islocal=".a:islocal.")")

  let ykeep= @@
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   let islocal= s:netrwmarkfilelist_{bufnr('%')}[1] !~ '^\a\+://'
   call netrw#Obtain(islocal,s:netrwmarkfilelist_{bufnr('%')})
   call s:NetrwUnmarkList(bufnr('%'),b:netrw_curdir)
  else
   call netrw#Obtain(a:islocal,expand("<cWORD>"))
  endif
  let @@= ykeep

"  call Dret("NetrwObtain")
endfun

" ---------------------------------------------------------------------
" s:NetrwPrevWinOpen: open file/directory in previous window.  {{{2
"   If there's only one window, then the window will first be split.
"   Returns:
"     choice = 0 : didn't have to choose
"     choice = 1 : saved modified file in window first
"     choice = 2 : didn't save modified file, opened window
"     choice = 3 : cancel open
fun! s:NetrwPrevWinOpen(islocal)
"  call Dfunc("s:NetrwPrevWinOpen(islocal=".a:islocal.")")

  let ykeep= @@
  " grab a copy of the b:netrw_curdir to pass it along to newly split windows
  let curdir = b:netrw_curdir

  " get last window number and the word currently under the cursor
  let origwin   = winnr()
  let lastwinnr = winnr("$")
  let curword   = s:NetrwGetWord()
  let choice    = 0
  let s:treedir = s:NetrwTreeDir()
  let curdir    = s:treedir
"  call Decho("winnr($)#".lastwinnr." curword<".curword.">")

  let didsplit = 0
  if lastwinnr == 1
   " if only one window, open a new one first
"   call Decho("only one window, so open a new one (g:netrw_alto=".g:netrw_alto.")")
   if g:netrw_preview
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s")
    exe (g:netrw_alto? "top " : "bot ")."vert ".winsz."wincmd s"
   else
    let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
"    call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
    exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   endif
   let didsplit = 1
"   call Decho("did split")

  else
   keepj call s:SaveBufVars()
   let eikeep= &ei
   setl ei=all
   wincmd p
"   call Decho("wincmd p  (now in win#".winnr().") curdir<".curdir.">")

   " prevwinnr: the window number of the "prev" window
   " prevbufnr: the buffer number of the buffer in the "prev" window
   " bnrcnt   : the qty of windows open on the "prev" buffer
   let prevwinnr   = winnr()
   let prevbufnr   = bufnr("%")
   let prevbufname = bufname("%")
   let prevmod     = &mod
   let bnrcnt      = 0
   keepj call s:RestoreBufVars()
"   call Decho("after wincmd p: win#".winnr()." win($)#".winnr("$")." origwin#".origwin." &mod=".&mod." bufname(%)<".bufname("%")."> prevbufnr=".prevbufnr)

   " if the previous window's buffer has been changed (ie. its modified flag is set),
   " and it doesn't appear in any other extant window, then ask the
   " user if s/he wants to abandon modifications therein.
   if prevmod
"    call Decho("detected that prev window's buffer has been modified: prevbufnr=".prevbufnr." winnr()#".winnr())
    windo if winbufnr(0) == prevbufnr | let bnrcnt=bnrcnt+1 | endif
"    call Decho("prevbufnr=".prevbufnr." bnrcnt=".bnrcnt." buftype=".&bt." winnr()=".winnr()." prevwinnr#".prevwinnr)
    exe prevwinnr."wincmd w"

    if bnrcnt == 1 && &hidden == 0
     " only one copy of the modified buffer in a window, and
     " hidden not set, so overwriting will lose the modified file.  Ask first...
     let choice = confirm("Save modified buffer<".prevbufname."> first?","&Yes\n&No\n&Cancel")
"     call Decho("(NetrwPrevWinOpen) prevbufname<".prevbufname."> choice=".choice." current-winnr#".winnr())
     let &ei= eikeep

     if choice == 1
      " Yes -- write file & then browse
      let v:errmsg= ""
      sil w
      if v:errmsg != ""
       call netrw#ErrorMsg(s:ERROR,"unable to write <".prevbufname.">!",30)
       exe origwin."wincmd w"
       let &ei = eikeep
       let @@  = ykeep
"       call Dret("s:NetrwPrevWinOpen ".choice." : unable to write <".prevbufname.">")
       return choice
      endif

     elseif choice == 2
      " No -- don't worry about changed file, just browse anyway
"      call Decho("don't worry about chgd file, just browse anyway (winnr($)#".winnr("$").")")
      echomsg "**note** changes to ".prevbufname." abandoned"

     else
      " Cancel -- don't do this
"      call Decho("cancel, don't browse, switch to win#".origwin)
      exe origwin."wincmd w"
      let &ei= eikeep
      let @@ = ykeep
"      call Dret("s:NetrwPrevWinOpen ".choice." : cancelled")
      return choice
     endif
    endif
   endif
   let &ei= eikeep
  endif

  " restore b:netrw_curdir (window split/enew may have lost it)
  let b:netrw_curdir= curdir
  if a:islocal < 2
   if a:islocal
    call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(a:islocal,curword))
   else
    call s:NetrwBrowse(a:islocal,s:NetrwBrowseChgDir(a:islocal,curword))
   endif
  endif
  let @@= ykeep
"  call Dret("s:NetrwPrevWinOpen ".choice)
  return choice
endfun

" ---------------------------------------------------------------------
" s:NetrwUpload: load fname to tgt (used by NetrwMarkFileCopy()) {{{2
"                Always assumed to be local -> remote
"                call s:NetrwUpload(filename, target)
"                call s:NetrwUpload(filename, target, fromdirectory)
fun! s:NetrwUpload(fname,tgt,...)
"  call Dfunc("s:NetrwUpload(fname<".((type(a:fname) == 1)? a:fname : string(a:fname))."> tgt<".a:tgt.">) a:0=".a:0)

  if a:tgt =~ '^\a\+://'
   let tgtdir= substitute(a:tgt,'^\a\+://[^/]\+/\(.\{-}\)$','\1','')
  else
   let tgtdir= substitute(a:tgt,'^\(.*\)/[^/]*$','\1','')
  endif
"  call Decho("tgtdir<".tgtdir.">")

  if a:0 > 0
   let fromdir= a:1
  else
   let fromdir= getcwd()
  endif
"  call Decho("fromdir<".fromdir.">")

  if type(a:fname) == 1
   " handle uploading a single file using NetWrite
"   call Decho("handle uploading a single file via NetWrite")
   1split
"   call Decho("exe e ".fnameescape(a:fname))
   exe "e ".fnameescape(a:fname)
"   call Decho("now locally editing<".expand("%").">, has ".line("$")." lines")
   if a:tgt =~ '/$'
    let wfname= substitute(a:fname,'^.*/','','')
"    call Decho("exe w! ".fnameescape(wfname))
    exe "w! ".fnameescape(a:tgt.wfname)
   else
"    call Decho("writing local->remote: exe w ".fnameescape(a:tgt))
    exe "w ".fnameescape(a:tgt)
"    call Decho("done writing local->remote")
   endif
   q!

  elseif type(a:fname) == 3
   " handle uploading a list of files via scp
"   call Decho("handle uploading a list of files via scp")
   let curdir= getcwd()
   if a:tgt =~ '^scp:'
    call s:NetrwLcd(fromdir)
    let filelist= deepcopy(s:netrwmarkfilelist_{bufnr('%')})
    let args    = join(map(filelist,"shellescape(v:val, 1)"))
    if exists("g:netrw_port") && g:netrw_port != ""
     let useport= " ".g:netrw_scpport." ".g:netrw_port
    else
     let useport= ""
    endif
    let machine = substitute(a:tgt,'^scp://\([^/:]\+\).*$','\1','')
    let tgt     = substitute(a:tgt,'^scp://[^/]\+/\(.*\)$','\1','')
"    call Decho("exe ".s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1))
    exe s:netrw_silentxfer."!".g:netrw_scp_cmd.shellescape(useport,1)." ".args." ".shellescape(machine.":".tgt,1)
    call s:NetrwLcd(curdir)

   elseif a:tgt =~ '^ftp:'
    call s:NetrwMethod(a:tgt)

    if b:netrw_method == 2
     " handle uploading a list of files via ftp+.netrc
     let netrw_fname = b:netrw_fname
     sil keepj new
"     call Decho("filter input window#".winnr())

     keepj put =g:netrw_ftpmode
"     call Decho("filter input: ".getline('$'))

     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'))
     endif

     keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'))

     if tgtdir == ""
      let tgtdir= '/'
     endif
     keepj call setline(line("$")+1,'cd "'.tgtdir.'"')
"     call Decho("filter input: ".getline('$'))

     for fname in a:fname
      keepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'))
     endfor

     if exists("g:netrw_port") && g:netrw_port != ""
"      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
     else
"      call Decho("filter input window#".winnr())
"      call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
      exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
     endif
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil keepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      call netrw#ErrorMsg(s:ERROR,getline(1),14)
     else
      bw!|q
     endif

    elseif b:netrw_method == 3
     " upload with ftp + machine, id, passwd, and fname (ie. no .netrc)
     let netrw_fname= b:netrw_fname
     keepj call s:SaveBufVars()|sil keepj new|keepj call s:RestoreBufVars()
     let tmpbufnr= bufnr("%")
     setl ff=unix

     if exists("g:netrw_port") && g:netrw_port != ""
      keepj put ='open '.g:netrw_machine.' '.g:netrw_port
"      call Decho("filter input: ".getline('$'))
     else
      keepj put ='open '.g:netrw_machine
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("g:netrw_uid") && g:netrw_uid != ""
      if exists("g:netrw_ftp") && g:netrw_ftp == 1
       keepj put =g:netrw_uid
"       call Decho("filter input: ".getline('$'))
       if exists("s:netrw_passwd")
        keepj call setline(line("$")+1,'"'.s:netrw_passwd.'"')
       endif
"       call Decho("filter input: ".getline('$'))
      elseif exists("s:netrw_passwd")
       keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
"       call Decho("filter input: ".getline('$'))
      endif
     endif

     keepj call setline(line("$")+1,'lcd "'.fromdir.'"')
"     call Decho("filter input: ".getline('$'))

     if exists("b:netrw_fname") && b:netrw_fname != ""
      keepj call setline(line("$")+1,'cd "'.b:netrw_fname.'"')
"      call Decho("filter input: ".getline('$'))
     endif

     if exists("g:netrw_ftpextracmd")
      keepj put =g:netrw_ftpextracmd
"      call Decho("filter input: ".getline('$'))
     endif

     for fname in a:fname
      keepj call setline(line("$")+1,'put "'.fname.'"')
"      call Decho("filter input: ".getline('$'))
     endfor

     " perform ftp:
     " -i       : turns off interactive prompting from ftp
     " -n  unix : DON'T use <.netrc>, even though it exists
     " -n  win32: quit being obnoxious about password
     keepj norm! 1Gdd
"     call Decho("executing: ".s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
     exe s:netrw_silentxfer."%!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
     " If the result of the ftp operation isn't blank, show an error message (tnx to Doug Claar)
     sil keepj g/Local directory now/d
     call histdel("/",-1)
     if getline(1) !~ "^$" && !exists("g:netrw_quiet") && getline(1) !~ '^Trying '
      let debugkeep= &debug
      setl debug=msg
      call netrw#ErrorMsg(s:ERROR,getline(1),15)
      let &debug = debugkeep
      let mod    = 1
     else
      bw!|q
     endif
    elseif !exists("b:netrw_method") || b:netrw_method < 0
"     call Dfunc("netrw#NetrwUpload : unsupported method")
     return
    endif
   else
    call netrw#ErrorMsg(s:ERROR,"can't obtain files with protocol from<".a:tgt.">",63)
   endif
  endif

"  call Dret("s:NetrwUpload")
endfun

" ---------------------------------------------------------------------
" s:NetrwPreview: {{{2
fun! s:NetrwPreview(path) range
"  call Dfunc("NetrwPreview(path<".a:path.">)")
  let ykeep= @@
  keepj call s:NetrwOptionSave("s:")
  keepj call s:NetrwSafeOptions()
  if has("quickfix")
   if !isdirectory(a:path)
    if g:netrw_preview && !g:netrw_alto
     let pvhkeep = &pvh
     let winsz   = (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
     let &pvh    = winwidth(0) - winsz
    endif
    exe (g:netrw_alto? "top " : "bot ").(g:netrw_preview? "vert " : "")."pedit ".fnameescape(a:path)
    if exists("pvhkeep")
     let &pvh= pvhkeep
    endif
   elseif !exists("g:netrw_quiet")
    keepj call netrw#ErrorMsg(s:WARNING,"sorry, cannot preview a directory such as <".a:path.">",38)
   endif
  elseif !exists("g:netrw_quiet")
   keepj call netrw#ErrorMsg(s:WARNING,"sorry, to preview your vim needs the quickfix feature compiled in",39)
  endif
  keepj call s:NetrwOptionRestore("s:")
  let @@= ykeep
"  call Dret("NetrwPreview")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefresh: {{{2
fun! s:NetrwRefresh(islocal,dirname)
"  call Dfunc("NetrwRefresh(islocal<".a:islocal.">,dirname=".a:dirname.") hide=".g:netrw_hide." sortdir=".g:netrw_sort_direction)
  " at the current time (Mar 19, 2007) all calls to NetrwRefresh() call NetrwBrowseChgDir() first.
  setl ma noro
"  call Decho("setl ma noro")
"  call Decho("clear buffer<".expand("%")."> with :%d")
  let ykeep      = @@

  " save the cursor position before refresh.
  let screenposn = netrw#SavePosn()
"  call Decho("win#".winnr().": ".winheight(0)."x".winwidth(0)." curfile<".expand("%").">")
"  call Decho("clearing buffer prior to refresh")
  sil! keepj %d
  if a:islocal
   keepj call netrw#LocalBrowseCheck(a:dirname)
  else
   keepj call s:NetrwBrowse(a:islocal,a:dirname)
  endif

  " restore position
  keepj call netrw#RestorePosn(screenposn)

  " restore file marks
  if exists("s:netrwmarkfilemtch_{bufnr('%')}") && s:netrwmarkfilemtch_{bufnr("%")} != ""
"   call Decho("exe 2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/")
   exe "2match netrwMarkFile /".s:netrwmarkfilemtch_{bufnr("%")}."/"
  else
"   call Decho("2match none")
   2match none
  endif

"  restore
  let @@= ykeep
"  call Dret("NetrwRefresh")
endfun

" ---------------------------------------------------------------------
" s:NetrwRefreshDir: refreshes a directory by name {{{2
"                    Called by NetrwMarkFileCopy()
"                    Interfaces to s:NetrwRefresh() and s:LocalBrowseRefresh()
fun! s:NetrwRefreshDir(islocal,dirname)
"  call Dfunc("s:NetrwRefreshDir(islocal=".a:islocal." dirname<".a:dirname.">) g:netrw_fastbrowse=".g:netrw_fastbrowse)
  if g:netrw_fastbrowse == 0
   " slowest mode (keep buffers refreshed, local or remote)
"   call Decho("slowest mode: keep buffers refreshed, local or remote")
   let tgtwin= bufwinnr(a:dirname)
"   call Decho("tgtwin= bufwinnr(".a:dirname.")=".tgtwin)

   if tgtwin > 0
    " tgtwin is being displayed, so refresh it
    let curwin= winnr()
"    call Decho("refresh tgtwin#".tgtwin." (curwin#".curwin.")")
    exe tgtwin."wincmd w"
    keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./')) 
    exe curwin."wincmd w"

   elseif bufnr(a:dirname) > 0
    let bn= bufnr(a:dirname)
"    call Decho("bd bufnr(".a:dirname.")=".bn)
    exe "sil bd ".bn
   endif

  elseif g:netrw_fastbrowse <= 1
"   call Decho("medium-speed mode: refresh local buffers only")
   keepj call s:LocalBrowseRefresh()
  endif
"  call Dret("s:NetrwRefreshDir")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetChgwin: set g:netrw_chgwin; a <cr> will use the specified
" window number to do its editing in.
" Supports   [count]C  where the count, if present, is used to specify
" a window to use for editing via the <cr> mapping.
fun! s:NetrwSetChgwin()
"  call Dfunc("s:NetrwSetChgwin() v:count=".v:count)
  if v:count > 0
   let g:netrw_chgwin= v:count
  else
   let g:netrw_chgwin= winnr()
  endif
"  call Dret("s:NetrwSetChgwin")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetSort: sets up the sort based on the g:netrw_sort_sequence {{{2
"          What this function does is to compute a priority for the patterns
"          in the g:netrw_sort_sequence.  It applies a substitute to any
"          "files" that satisfy each pattern, putting the priority / in
"          front.  An "*" pattern handles the default priority.
fun! s:NetrwSetSort()
"  call Dfunc("SetSort() bannercnt=".w:netrw_bannercnt)
  let ykeep= @@
  if w:netrw_liststyle == s:LONGLIST
   let seqlist  = substitute(g:netrw_sort_sequence,'\$','\\%(\t\\|\$\\)','ge')
  else
   let seqlist  = g:netrw_sort_sequence
  endif
  " sanity check -- insure that * appears somewhere
  if seqlist == ""
   let seqlist= '*'
  elseif seqlist !~ '\*'
   let seqlist= seqlist.',*'
  endif
  let priority = 1
  while seqlist != ""
   if seqlist =~ ','
    let seq     = substitute(seqlist,',.*$','','e')
    let seqlist = substitute(seqlist,'^.\{-},\(.*\)$','\1','e')
   else
    let seq     = seqlist
    let seqlist = ""
   endif
   if priority < 10
    let spriority= "00".priority.g:netrw_sepchr
   elseif priority < 100
    let spriority= "0".priority.g:netrw_sepchr
   else
    let spriority= priority.g:netrw_sepchr
   endif
"   call Decho("priority=".priority." spriority<".spriority."> seq<".seq."> seqlist<".seqlist.">")

   " sanity check
   if w:netrw_bannercnt > line("$")
    " apparently no files were left after a Hiding pattern was used
"    call Dret("SetSort : no files left after hiding")
    return
   endif
   if seq == '*'
    let starpriority= spriority
   else
    exe 'sil keepj '.w:netrw_bannercnt.',$g/'.seq.'/s/^/'.spriority.'/'
    call histdel("/",-1)
    " sometimes multiple sorting patterns will match the same file or directory.
    " The following substitute is intended to remove the excess matches.
    exe 'sil keepj '.w:netrw_bannercnt.',$g/^\d\{3}'.g:netrw_sepchr.'\d\{3}\//s/^\d\{3}'.g:netrw_sepchr.'\(\d\{3}\/\).\@=/\1/e'
    keepj call histdel("/",-1)
   endif
   let priority = priority + 1
  endwhile
  if exists("starpriority")
   exe 'sil keepj '.w:netrw_bannercnt.',$v/^\d\{3}'.g:netrw_sepchr.'/s/^/'.starpriority.'/e'
   keepj call histdel("/",-1)
  endif

  " Following line associated with priority -- items that satisfy a priority
  " pattern get prefixed by ###/ which permits easy sorting by priority.
  " Sometimes files can satisfy multiple priority patterns -- only the latest
  " priority pattern needs to be retained.  So, at this point, these excess
  " priority prefixes need to be removed, but not directories that happen to
  " be just digits themselves.
  exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\d\{3}'.g:netrw_sepchr.'\)\%(\d\{3}'.g:netrw_sepchr.'\)\+\ze./\1/e'
  keepj call histdel("/",-1)
  let @@= ykeep

"  call Dret("SetSort")
endfun

" ---------------------------------------------------------------------
" s:NetrwSetTgt: sets the target to the specified choice index {{{2
"    Implements [count]Tb  (bookhist<b>)
"               [count]Th  (bookhist<h>)
"               See :help netrw-qb for how to make the choice.
fun! s:NetrwSetTgt(bookhist,choice)
"  call Dfunc("s:NetrwSetTgt(bookhist<".a:bookhist."> choice#".a:choice.")")

  if     a:bookhist == 'b'
   " supports choosing a bookmark as a target using a qb-generated list
   let choice= a:choice - 1
   if exists("g:netrw_bookmarklist[".choice."]")
    call netrw#MakeTgt(g:netrw_bookmarklist[choice])
   else
    echomsg "Sorry, bookmark#".a:choice." doesn't exist!"
   endif

  elseif a:bookhist == 'h'
   " supports choosing a history stack entry as a target using a qb-generated list
   let choice= (a:choice % g:netrw_dirhistmax) + 1
   if exists("g:netrw_dirhist_".choice)
    let histentry = g:netrw_dirhist_{choice}
    call netrw#MakeTgt(histentry)
   else
    echomsg "Sorry, history#".a:choice." not available!"
   endif
  endif

"  call Dret("s:NetrwSetTgt")
endfun

" =====================================================================
" s:NetrwSortStyle: change sorting style (name - time - size) and refresh display {{{2
fun! s:NetrwSortStyle(islocal)
"  call Dfunc("s:NetrwSortStyle(islocal=".a:islocal.") netrw_sort_by<".g:netrw_sort_by.">")
  keepj call s:NetrwSaveWordPosn()
  let svpos= netrw#SavePosn()

  let g:netrw_sort_by= (g:netrw_sort_by =~ 'n')? 'time' : (g:netrw_sort_by =~ 't')? 'size' : 'name'
  keepj norm! 0
  keepj call s:NetrwRefresh(a:islocal,s:NetrwBrowseChgDir(a:islocal,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("s:NetrwSortStyle : netrw_sort_by<".g:netrw_sort_by.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwSplit: mode {{{2
"           =0 : net   and o
"           =1 : net   and t
"           =2 : net   and v
"           =3 : local and o
"           =4 : local and t
"           =5 : local and v
fun! s:NetrwSplit(mode)
"  call Dfunc("s:NetrwSplit(mode=".a:mode.") alto=".g:netrw_alto." altv=".g:netrw_altv)

  let ykeep= @@
  call s:SaveWinVars()

  if a:mode == 0
   " remote and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 1
   " remote and t
   let newdir  = s:NetrwBrowseChgDir(0,s:NetrwGetWord())
"   call Decho("tabnew")
   tabnew
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,newdir)
   unlet s:didsplit

  elseif a:mode == 2
   " remote and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call s:NetrwBrowse(0,s:NetrwBrowseChgDir(0,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 3
   " local and o
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winheight(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_alto? "bel " : "abo ").winsz."wincmd s")
   exe (g:netrw_alto? "bel " : "abo ").winsz."wincmd s"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  elseif a:mode == 4
   " local and t
   let cursorword  = s:NetrwGetWord()
   let eikeep      = &ei
   let netrw_winnr = winnr()
   let netrw_line  = line(".")
   let netrw_col   = virtcol(".")
   keepj norm! H0
   let netrw_hline = line(".")
   setl ei=all
   exe "keepj norm! ".netrw_hline."G0z\<CR>"
   exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
   let &ei= eikeep
   let netrw_curdir= s:NetrwTreeDir()
"   call Decho("tabnew")
   tabnew
   let b:netrw_curdir = netrw_curdir
   let s:didsplit     = 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,cursorword))
   if &ft == "netrw"
    setl ei=all
    exe "keepj norm! ".netrw_hline."G0z\<CR>"
    exe "keepj norm! ".netrw_line."G0".netrw_col."\<bar>"
    let &ei= eikeep
   endif
   unlet s:didsplit

  elseif a:mode == 5
   " local and v
   let winsz= (g:netrw_winsize > 0)? (g:netrw_winsize*winwidth(0))/100 : -g:netrw_winsize
   if winsz == 0|let winsz= ""|endif
"   call Decho("exe ".(g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v")
   exe (g:netrw_altv? "rightb " : "lefta ").winsz."wincmd v"
   let s:didsplit= 1
   keepj call s:RestoreWinVars()
   keepj call netrw#LocalBrowseCheck(s:NetrwBrowseChgDir(1,s:NetrwGetWord()))
   unlet s:didsplit

  else
   keepj call netrw#ErrorMsg(s:ERROR,"(NetrwSplit) unsupported mode=".a:mode,45)
  endif

  let @@= ykeep
"  call Dret("s:NetrwSplit")
endfun

" ---------------------------------------------------------------------
" s:NetrwTgtMenu: {{{2
fun! s:NetrwTgtMenu()
  if !exists("s:netrw_menucnt")
   return
  endif
"  call Dfunc("s:NetrwTgtMenu()")

  " the following test assures that gvim is running, has menus available, and has menus enabled.
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   if exists("g:NetrwTopLvlMenu")
"    call Decho("removing ".g:NetrwTopLvlMenu."Bookmarks menu item(s)")
    exe 'sil! unmenu '.g:NetrwTopLvlMenu.'Targets'
   endif
   if !exists("s:netrw_initbookhist")
    call s:NetrwBookHistRead()
   endif

   " target bookmarked places
   if exists("g:netrw_bookmarklist") && g:netrw_bookmarklist != [] && g:netrw_dirhistmax > 0
"    call Decho("installing bookmarks as easy targets")
    let cnt= 1
    for bmd in g:netrw_bookmarklist
     let ebmd= escape(bmd,g:netrw_menu_escape)
     " show bookmarks for goto menu
"     call Decho("menu: Targets: ".bmd)
     exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.1.".cnt." ".g:NetrwTopLvlMenu.'Targets.'.ebmd."	:call netrw#MakeTgt('".bmd."')\<cr>"
     let cnt= cnt + 1
    endfor
   endif

   " target directory browsing history
   if exists("g:netrw_dirhistmax") && g:netrw_dirhistmax > 0
"    call Decho("installing history as easy targets (histmax=".g:netrw_dirhistmax.")")
    let histcnt = 1
    while histcnt <= g:netrw_dirhistmax
     let priority = g:netrw_dirhist_cnt + histcnt
     if exists("g:netrw_dirhist_{histcnt}")
      let histentry  = g:netrw_dirhist_{histcnt}
      let ehistentry = escape(histentry,g:netrw_menu_escape)
"      call Decho("menu: Targets: ".histentry)
      exe 'sil! menu <silent> '.g:NetrwMenuPriority.".19.2.".priority." ".g:NetrwTopLvlMenu.'Targets.'.ehistentry."	:call netrw#MakeTgt('".histentry."')\<cr>"
     endif
     let histcnt = histcnt + 1
    endwhile
   endif
  endif
"  call Dret("s:NetrwTgtMenu")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDir: determine tree directory given current cursor position {{{2
" (full path directory with trailing slash returned)
fun! s:NetrwTreeDir()
"  call Dfunc("s:NetrwTreeDir() getline(".line(".").")"."<".getline('.')."> b:netrw_curdir<".b:netrw_curdir."> tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> ft=".&ft)

  if exists("s:treedir")
   " s:NetrwPrevWinOpen opens a "previous" window -- and thus needs to and does call s:NetrwTreeDir early
   let treedir= s:treedir
   unlet s:treedir
"   call Dret("s:NetrwTreeDir ".treedir)
   return treedir
  endif
  if !exists("b:netrw_curdir") || b:netrw_curdir == ""
   let b:netrw_curdir= getcwd()
  endif
  let treedir = b:netrw_curdir
"  call Decho("set initial treedir<".treedir.">")
  let s:treecurpos= netrw#SavePosn()

  if w:netrw_liststyle == s:TREELIST
"   call Decho("w:netrw_liststyle is TREELIST:")
"   call Decho("line#".line(".")." getline(.)<".getline('.')."> treecurpos<".string(s:treecurpos).">")

   " extract tree directory if on a line specifying a subdirectory (ie. ends with "/")
   if getline('.') =~ '/$'
"    call Decho("extract tree subdirectory from current line")
    let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"    call Decho("treedir<".treedir.">")
   else
"    call Decho("do not extract tree subdirectory from current line and set treedir to empty")
    let treedir= ""
   endif

   " detect user attempting to close treeroot
"   call Decho("win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
"   call Decho("getline(".line(".").")<".getline('.').'> '.((getline('.') =~ '^'.s:treedepthstring)? '=~' : '!~').' ^'.s:treedepthstring)
   if getline('.') !~ '^'.s:treedepthstring && getline('.') != '..'
"    call Decho("user may have attempted to close treeroot")
    " now force a refresh
"    call Decho("clear buffer<".expand("%")."> with :%d")
    sil! keepj %d
"    call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
    return b:netrw_curdir
"   else " Decho
"    call Decho("user did not attempt to close treeroot")
   endif

   let treedir = s:NetrwTreePath(w:netrw_treetop)
  endif

  " sanity maintenance: keep those //s away...
  let treedir= substitute(treedir,'//$','/','')

"  call Dret("s:NetrwTreeDir <".treedir."> : (side effect) s:treecurpos<".string(s:treecurpos).">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeDisplay: recursive tree display {{{2
fun! s:NetrwTreeDisplay(dir,depth)
"  call Dfunc("NetrwTreeDisplay(dir<".a:dir."> depth<".a:depth.">)")

  " insure that there are no folds
  setl nofen

  " install ../ and shortdir
  if a:depth == ""
   call setline(line("$")+1,'../')
"   call Decho("setline#".line("$")." ../ (depth is zero)")
  endif
  if a:dir =~ '^\a\+://'
   if a:dir == w:netrw_treetop
    let shortdir= a:dir
   else
    let shortdir= substitute(a:dir,'^.*/\([^/]\+\)/$','\1/','e')
   endif
   call setline(line("$")+1,a:depth.shortdir)
  else
   let shortdir= substitute(a:dir,'^.*/','','e')
   call setline(line("$")+1,a:depth.shortdir.'/')
  endif
"  call Decho("setline#".line("$")." shortdir<".a:depth.shortdir.">")

  " append a / to dir if its missing one
  let dir= a:dir
  if dir !~ '/$'
   let dir= dir.'/'
  endif

  " display subtrees (if any)
  let depth= s:treedepthstring.a:depth

"  call Decho("display subtrees with depth<".depth."> and current leaves")
  for entry in w:netrw_treedict[a:dir]
   let direntry= substitute(dir.entry,'/$','','e')
"   call Decho("dir<".dir."> entry<".entry."> direntry<".direntry.">")
   if entry =~ '/$' && has_key(w:netrw_treedict,direntry)
"    call Decho("<".direntry."> is a key in treedict - display subtree for it")
    keepj call s:NetrwTreeDisplay(direntry,depth)
   elseif entry =~ '/$' && has_key(w:netrw_treedict,direntry.'/')
"    call Decho("<".direntry."/> is a key in treedict - display subtree for it")
    keepj call s:NetrwTreeDisplay(direntry.'/',depth)
   else
"    call Decho("<".entry."> is not a key in treedict (no subtree)")
    sil! keepj call setline(line("$")+1,depth.entry)
   endif
  endfor

"  call Dret("NetrwTreeDisplay")
endfun

" ---------------------------------------------------------------------
" s:NetrwTreeListing: displays tree listing from treetop on down, using NetrwTreeDisplay() {{{2
fun! s:NetrwTreeListing(dirname)
  if w:netrw_liststyle == s:TREELIST
"   call Dfunc("NetrwTreeListing() bufname<".expand("%").">")
"   call Decho("curdir<".a:dirname.">")
"   call Decho("win#".winnr().": w:netrw_treetop ".(exists("w:netrw_treetop")? "exists" : "doesn't exist")." w:netrw_treedict ".(exists("w:netrw_treedict")? "exists" : "doesn't exit"))
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

   " update the treetop
"   call Decho("update the treetop")
   if !exists("w:netrw_treetop")
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (reusing)")
   elseif (w:netrw_treetop =~ ('^'.a:dirname) && s:Strlen(a:dirname) < s:Strlen(w:netrw_treetop)) || a:dirname !~ ('^'.w:netrw_treetop)
    let w:netrw_treetop= a:dirname
"    call Decho("w:netrw_treetop<".w:netrw_treetop."> (went up)")
   endif

   " insure that we have at least an empty treedict
   if !exists("w:netrw_treedict")
    let w:netrw_treedict= {}
   endif

   " update the directory listing for the current directory
"   call Decho("updating dictionary with ".a:dirname.":[..directory listing..]")
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
   exe "sil! keepj ".w:netrw_bannercnt.',$g@^\.\.\=/$@d'
   let w:netrw_treedict[a:dirname]= getline(w:netrw_bannercnt,line("$"))
"   call Decho("w:treedict[".a:dirname."]= ".string(w:netrw_treedict[a:dirname]))
   exe "sil! keepj ".w:netrw_bannercnt.",$d"

   " if past banner, record word
   if exists("w:netrw_bannercnt") && line(".") > w:netrw_bannercnt
    let fname= expand("<cword>")
   else
    let fname= ""
   endif
"   call Decho("fname<".fname.">")
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

   " display from treetop on down
   keepj call s:NetrwTreeDisplay(w:netrw_treetop,"")
"   call Decho("s:NetrwTreeDisplay) setl noma nomod ro")

   " remove any blank line remaining as line#1 (happens in treelisting mode with banner suppressed)
   while getline(1) =~ '^\s*$' && byte2line(1) > 0
"    call Decho("deleting blank line")
    1d
   endwhile

   exe "setl ".g:netrw_bufsettings

"   call Dret("NetrwTreeListing : bufname<".expand("%").">")
   return
  endif
endfun

" ---------------------------------------------------------------------
" s:NetrwTreePath: returns path to current file in tree listing {{{2
"                  Normally, treetop is w:netrw_treetop, but a
"                  user of the function ( netrw#SetTreetop() )
"                  wipes that out prior to calling this function
fun! s:NetrwTreePath(treetop)
"  call Dfunc("s:NetrwTreePath() line#".line(".")."<".getline(".").">")
  let depth = substitute(getline('.'),'^\(\%('.s:treedepthstring.'\)*\)[^'.s:treedepthstring.'].\{-}$','\1','e')
"  call Decho("(s:NetrwTreePath) depth<".depth."> 1st subst")
  let depth = substitute(depth,'^'.s:treedepthstring,'','')
"  call Decho("(s:NetrwTreePath) depth<".depth."> 2nd subst (first depth removed)")
  if getline('.') =~ '/$'
"   call Decho("extract tree directory from current line")
   let treedir= substitute(getline('.'),'^\%('.s:treedepthstring.'\)*\([^'.s:treedepthstring.'].\{-}\)$','\1','e')
"   call Decho("(s:NetrwTreePath) treedir<".treedir.">")
  else
"   call Decho("(s:NetrwTreePath) do not extract tree directory from current line and set treedir to empty")
   let treedir= ""
  endif
  " construct treedir by searching backwards at correct depth
"  call Decho("(s:NetrwTreePath) construct treedir by searching backwards for correct depth")
"  call Decho("(s:NetrwTreePath) initial      treedir<".treedir."> depth<".depth.">")
  while depth != "" && search('^'.depth.'[^'.s:treedepthstring.'].\{-}/$','bW')
   let dirname= substitute(getline('.'),'^\('.s:treedepthstring.'\)*','','e')
   let treedir= dirname.treedir
   let depth  = substitute(depth,'^'.s:treedepthstring,'','')
"   call Decho("(s:NetrwTreePath) constructing treedir<".treedir.">: dirname<".dirname."> while depth<".depth.">")
  endwhile
  if a:treetop =~ '/$'
   let treedir= a:treetop.treedir
  else
   let treedir= a:treetop.'/'.treedir
  endif
  let treedir= substitute(treedir,'//$','/','')
"  call Dret("s:NetrwTreePath <".treedir.">")
  return treedir
endfun

" ---------------------------------------------------------------------
" s:NetrwWideListing: {{{2
fun! s:NetrwWideListing()

  if w:netrw_liststyle == s:WIDELIST
"   call Dfunc("NetrwWideListing() w:netrw_liststyle=".w:netrw_liststyle.' fo='.&fo.' l:fo='.&l:fo)
   " look for longest filename (cpf=characters per filename)
   " cpf: characters per filename
   " fpl: filenames per line
   " fpc: filenames per column
   setl ma noro
"   call Decho("setl ma noro")
   let b:netrw_cpf= 0
   if line("$") >= w:netrw_bannercnt
    exe 'sil keepj '.w:netrw_bannercnt.',$g/^./if virtcol("$") > b:netrw_cpf|let b:netrw_cpf= virtcol("$")|endif'
    keepj call histdel("/",-1)
   else
"    call Dret("NetrwWideListing")
    return
   endif
   let b:netrw_cpf= b:netrw_cpf + 2
"   call Decho("b:netrw_cpf=max_filename_length+2=".b:netrw_cpf)

   " determine qty files per line (fpl)
   let w:netrw_fpl= winwidth(0)/b:netrw_cpf
   if w:netrw_fpl <= 0
    let w:netrw_fpl= 1
   endif
"   call Decho("fpl= [winwidth=".winwidth(0)."]/[b:netrw_cpf=".b:netrw_cpf.']='.w:netrw_fpl)

   " make wide display
   exe 'sil keepj '.w:netrw_bannercnt.',$s/^.*$/\=escape(printf("%-'.b:netrw_cpf.'s",submatch(0)),"\\")/'
   keepj call histdel("/",-1)
   let fpc         = (line("$") - w:netrw_bannercnt + w:netrw_fpl)/w:netrw_fpl
   let newcolstart = w:netrw_bannercnt + fpc
   let newcolend   = newcolstart + fpc - 1
"   call Decho("bannercnt=".w:netrw_bannercnt." fpl=".w:netrw_fpl." fpc=".fpc." newcol[".newcolstart.",".newcolend."]")
   if has("clipboard")
    sil! let keepregstar = @*
   endif
   while line("$") >= newcolstart
    if newcolend > line("$") | let newcolend= line("$") | endif
    let newcolqty= newcolend - newcolstart
    exe newcolstart
    if newcolqty == 0
     exe "sil! keepj norm! 0\<c-v>$hx".w:netrw_bannercnt."G$p"
    else
     exe "sil! keepj norm! 0\<c-v>".newcolqty.'j$hx'.w:netrw_bannercnt.'G$p'
    endif
    exe "sil! keepj ".newcolstart.','.newcolend.'d'
    exe 'sil! keepj '.w:netrw_bannercnt
   endwhile
   if has("clipboard")
    sil! let @*= keepregstar
   endif
   exe "sil! keepj ".w:netrw_bannercnt.',$s/\s\+$//e'
   keepj call histdel("/",-1)
   exe "nmap <buffer> <silent> w	/^\\\\|\\s\\s\\zs\\S/\<cr>"
   exe "nmap <buffer> <silent> b	?^\\\\|\\s\\s\\zs\\S?\<cr>"
"   call Decho("NetrwWideListing) setl noma nomod ro")
   exe "setl ".g:netrw_bufsettings
"   call Decho("(NetrwWideListing) ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"   call Dret("NetrwWideListing")
   return
  else
   if hasmapto("w","n")
    sil! nunmap <buffer> w
   endif
   if hasmapto("b","n")
    sil! nunmap <buffer> b
   endif
  endif

endfun

" ---------------------------------------------------------------------
" s:PerformListing: {{{2
fun! s:PerformListing(islocal)
"  call Dfunc("s:PerformListing(islocal=".a:islocal.") bufnr(%)=".bufnr("%")."<".bufname("%").">")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (enter)")

  " set up syntax highlighting {{{3
"  call Decho("set up syntax highlighting")
  if has("syntax")
   if !exists("g:syntax_on") || !g:syntax_on
"    call Decho("but g:syntax_on".(exists("g:syntax_on")? "=".g:syntax_on : "<doesn't exist>"))
    setl ft=
   elseif &ft != "netrw"
"    call Decho("setl ft=netrw")
    setl ft=netrw
   endif
  endif

  keepj call s:NetrwSafeOptions()
  setl noro ma
"  call Decho("setl noro ma bh=".&bh)

"  if exists("g:netrw_silent") && g:netrw_silent == 0 && &ch >= 1	" Decho
"   call Decho("(netrw) Processing your browsing request...")
"  endif								" Decho

"  call Decho('w:netrw_liststyle='.(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
  if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST && exists("w:netrw_treedict")
   " force a refresh for tree listings
"   call Decho("force refresh for treelisting: clear buffer<".expand("%")."> with :%d")
   sil! keepj %d
  endif

  " save current directory on directory history list
  keepj call s:NetrwBookHistHandler(3,b:netrw_curdir)

  " Set up the banner {{{3
  if g:netrw_banner
"   call Decho("set up banner")
   keepj call setline(1,'" ============================================================================')
   keepj call setline(2,'" Netrw Directory Listing                                        (netrw '.g:loaded_netrw.')')
   if exists("g:netrw_bannerbackslash") && g:netrw_bannerbackslash
    keepj call setline(3,'"   '.substitute(b:netrw_curdir,'/','\\','g'))
   else
    keepj call setline(3,'"   '.b:netrw_curdir)
   endif
   let w:netrw_bannercnt= 3
   keepj exe "sil! keepj ".w:netrw_bannercnt
  else
   keepj 1
   let w:netrw_bannercnt= 1
  endif
"  call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." win#".winnr())

  let sortby= g:netrw_sort_by
  if g:netrw_sort_direction =~ "^r"
   let sortby= sortby." reversed"
  endif

  " Sorted by... {{{3
  if g:netrw_banner
"   call Decho("handle specified sorting: g:netrw_sort_by<".g:netrw_sort_by.">")
   if g:netrw_sort_by =~ "^n"
"   call Decho("directories will be sorted by name")
    " sorted by name
    keepj put ='\"   Sorted by      '.sortby
    keepj put ='\"   Sort sequence: '.g:netrw_sort_sequence
    let w:netrw_bannercnt= w:netrw_bannercnt + 2
   else
"   call Decho("directories will be sorted by size or time")
    " sorted by size or date
    keepj put ='\"   Sorted by '.sortby
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "sil! keepj ".w:netrw_bannercnt
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " show copy/move target, if any
  if g:netrw_banner
   if exists("s:netrwmftgt") && exists("s:netrwmftgt_islocal")
"    call Decho("show copy/move target<".s:netrwmftgt.">")
    keepj put =''
    if s:netrwmftgt_islocal
     sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (local)')
    else
     sil! keepj call setline(line("."),'"   Copy/Move Tgt: '.s:netrwmftgt.' (remote)')
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   else
"    call Decho("s:netrwmftgt does not exist, don't make Copy/Move Tgt")
   endif
   exe "sil! keepj ".w:netrw_bannercnt
  endif

  " Hiding...  -or-  Showing... {{{3
  if g:netrw_banner
"   call Decho("handle hiding/showing (g:netrw_hide=".g:netrw_list_hide." g:netrw_list_hide<".g:netrw_list_hide.">)")
   if g:netrw_list_hide != "" && g:netrw_hide
    if g:netrw_hide == 1
     keepj put ='\"   Hiding:        '.g:netrw_list_hide
    else
     keepj put ='\"   Showing:       '.g:netrw_list_hide
    endif
    let w:netrw_bannercnt= w:netrw_bannercnt + 1
   endif
   exe "keepjumps ".w:netrw_bannercnt

"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   let quickhelp   = g:netrw_quickhelp%len(s:QuickHelp)
"   call Decho("quickhelp   =".quickhelp)
   keepj put ='\"   Quick Help: <F1>:help  '.s:QuickHelp[quickhelp]
"   call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
   keepj put ='\" =============================================================================='
   let w:netrw_bannercnt= w:netrw_bannercnt + 2
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " bannercnt should index the line just after the banner
  if g:netrw_banner
   let w:netrw_bannercnt= w:netrw_bannercnt + 1
   exe "sil! keepj ".w:netrw_bannercnt
"   call Decho("w:netrw_bannercnt=".w:netrw_bannercnt." (should index line just after banner) line($)=".line("$"))
"  else " Decho
"   call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")
  endif

  " get list of files
"  call Decho("Get list of files - islocal=".a:islocal)
  if a:islocal
   keepj call s:LocalListing()
  else " remote
   keepj let badresult= s:NetrwRemoteListing()
   if badresult
"    call Decho("w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a')." win#".winnr()." buf#".bufnr("%")."<".bufname("%").">")
"    call Dret("s:PerformListing : error detected by NetrwRemoteListing")
    return
   endif
  endif

  " manipulate the directory listing (hide, sort) {{{3
  if !exists("w:netrw_bannercnt")
   let w:netrw_bannercnt= 0
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner." w:netrw_bannercnt=".w:netrw_bannercnt." (banner complete)")
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"   call Decho("manipulate directory listing (hide)")
"   call Decho("g:netrw_hide=".g:netrw_hide." g:netrw_list_hide<".g:netrw_list_hide.">")
   if g:netrw_hide && g:netrw_list_hide != ""
    keepj call s:NetrwListHide()
   endif
   if !g:netrw_banner || line("$") >= w:netrw_bannercnt
"    call Decho("manipulate directory listing (sort) : g:netrw_sort_by<".g:netrw_sort_by.">")

    if g:netrw_sort_by =~ "^n"
     " sort by name
     keepj call s:NetrwSetSort()

     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction." (bannercnt=".w:netrw_bannercnt.")")
      if g:netrw_sort_direction =~ 'n'
       " normal direction sorting
       exe 'sil keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
       " reverse direction sorting
       exe 'sil keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     endif
     " remove priority pattern prefix
"     call Decho("remove priority pattern prefix")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{3}'.g:netrw_sepchr.'//e'
     keepj call histdel("/",-1)

    elseif a:islocal
     if !g:netrw_banner || w:netrw_bannercnt < line("$")
"      call Decho("g:netrw_sort_direction=".g:netrw_sort_direction)
      if g:netrw_sort_direction =~ 'n'
"       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort')
       exe 'sil! keepj '.w:netrw_bannercnt.',$sort'.' '.g:netrw_sort_options
      else
"       call Decho('exe sil keepjumps '.w:netrw_bannercnt.',$sort!')
       exe 'sil! keepj '.w:netrw_bannercnt.',$sort!'.' '.g:netrw_sort_options
      endif
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{-}\///e'
     keepj call histdel("/",-1)
     endif
    endif

   elseif g:netrw_sort_direction =~ 'r'
"    call Decho('(s:PerformListing) reverse the sorted listing')
    if !g:netrw_banner || w:netrw_bannercnt < line('$')
     exe 'sil! keepj '.w:netrw_bannercnt.',$g/^/m '.w:netrw_bannercnt
     call histdel("/",-1)
    endif
   endif
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  " convert to wide/tree listing {{{3
"  call Decho("modify display if wide/tree listing style")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#1)")
  keepj call s:NetrwWideListing()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#2)")
  keepj call s:NetrwTreeListing(b:netrw_curdir)
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#3)")

  if exists("w:netrw_bannercnt") && (line("$") > w:netrw_bannercnt || !g:netrw_banner)
   " place cursor on the top-left corner of the file listing
"   call Decho("place cursor on top-left corner of file listing")
   exe 'sil! keepj '.w:netrw_bannercnt
   sil! keepj norm! 0
  endif

  " record previous current directory
  let w:netrw_prvdir= b:netrw_curdir
"  call Decho("record netrw_prvdir<".w:netrw_prvdir.">")

  " save certain window-oriented variables into buffer-oriented variables {{{3
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#4)")
  keepj call s:SetBufWinVars()
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#5)")
  keepj call s:NetrwOptionRestore("w:")
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#6)")

  " set display to netrw display settings
"  call Decho("set display to netrw display settings (".g:netrw_bufsettings.")")
  exe "setl ".g:netrw_bufsettings
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#7)")
  if g:netrw_liststyle == s:LONGLIST
"   call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
   exe "setl ts=".(g:netrw_maxfilenamelen+1)
  endif

  if exists("s:treecurpos")
"   call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (internal#8)")
   keepj call netrw#RestorePosn(s:treecurpos)
   unlet s:treecurpos
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo. " (return)")
"  call Dret("s:PerformListing : curpos<".string(getpos(".")).">")
endfun

" ---------------------------------------------------------------------
" s:SetupNetrwStatusLine: {{{2
fun! s:SetupNetrwStatusLine(statline)
"  call Dfunc("SetupNetrwStatusLine(statline<".a:statline.">)")

  if !exists("s:netrw_setup_statline")
   let s:netrw_setup_statline= 1
"   call Decho("do first-time status line setup")

   if !exists("s:netrw_users_stl")
    let s:netrw_users_stl= &stl
   endif
   if !exists("s:netrw_users_ls")
    let s:netrw_users_ls= &laststatus
   endif

   " set up User9 highlighting as needed
   let keepa= @a
   redir @a
   try
    hi User9
   catch /^Vim\%((\a\+)\)\=:E411/
    if &bg == "dark"
     hi User9 ctermfg=yellow ctermbg=blue guifg=yellow guibg=blue
    else
     hi User9 ctermbg=yellow ctermfg=blue guibg=yellow guifg=blue
    endif
   endtry
   redir END
   let @a= keepa
  endif

  " set up status line (may use User9 highlighting)
  " insure that windows have a statusline
  " make sure statusline is displayed
  let &stl=a:statline
  setl laststatus=2
"  call Decho("stl=".&stl)
  redraw

"  call Dret("SetupNetrwStatusLine : stl=".&stl)
endfun

" ---------------------------------------------------------------------
"  Remote Directory Browsing Support:    {{{1
" ===========================================

" ---------------------------------------------------------------------
" s:NetrwRemoteFtpCmd: unfortunately, not all ftp servers honor options for ls {{{2
"  This function assumes that a long listing will be received.  Size, time,
"  and reverse sorts will be requested of the server but not otherwise
"  enforced here.
fun! s:NetrwRemoteFtpCmd(path,listcmd)
"  call Dfunc("NetrwRemoteFtpCmd(path<".a:path."> listcmd<".a:listcmd.">) w:netrw_method=".(exists("w:netrw_method")? w:netrw_method : (exists("b:netrw_method")? b:netrw_method : "???")))
"  call Decho("line($)=".line("$")." w:netrw_bannercnt=".w:netrw_bannercnt)
  " sanity check: {{{3
  if !exists("w:netrw_method")
   if exists("b:netrw_method")
    let w:netrw_method= b:netrw_method
   else
    call netrw#ErrorMsg(2,"(s:NetrwRemoteFtpCmd) internal netrw error",93)
"    call Dret("NetrwRemoteFtpCmd")
    return
   endif
  endif

  " WinXX ftp uses unix style input, so set ff to unix	" {{{3
  let ffkeep= &ff
  setl ma ff=unix noro
"  call Decho("setl ma ff=unix noro")

  " clear off any older non-banner lines	" {{{3
  " note that w:netrw_bannercnt indexes the line after the banner
"  call Decho('exe sil! keepjumps '.w:netrw_bannercnt.",$d  (clear off old non-banner lines)")
  exe "sil! keepjumps ".w:netrw_bannercnt.",$d"

  ".........................................
  if w:netrw_method == 2 || w:netrw_method == 5	" {{{3
   " ftp + <.netrc>:  Method #2
   if a:path != ""
    keepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    keepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'))
   endif
   keepj call setline(line("$")+1,a:listcmd)
"   exe "keepjumps ".w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
   if exists("g:netrw_port") && g:netrw_port != ""
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1))
    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)." ".shellescape(g:netrw_port,1)
   else
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1))
    exe s:netrw_silentxfer." keepj ".w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." -i ".shellescape(g:netrw_machine,1)
   endif

  ".........................................
  elseif w:netrw_method == 3	" {{{3
   " ftp + machine,id,passwd,filename:  Method #3
    setl ff=unix
    if exists("g:netrw_port") && g:netrw_port != ""
     keepj put ='open '.g:netrw_machine.' '.g:netrw_port
    else
     keepj put ='open '.g:netrw_machine
    endif

    " handle userid and password
    let host= substitute(g:netrw_machine,'\..*$','','')
"    call Decho("host<".host.">")
    if exists("s:netrw_hup") && exists("s:netrw_hup[host]")
     call NetUserPass("ftp:".host)
    endif
    if exists("g:netrw_uid") && g:netrw_uid != ""
     if exists("g:netrw_ftp") && g:netrw_ftp == 1
      keepj put =g:netrw_uid
      if exists("s:netrw_passwd") && s:netrw_passwd != ""
       keepj put ='\"'.s:netrw_passwd.'\"'
      endif
     elseif exists("s:netrw_passwd")
      keepj put ='user \"'.g:netrw_uid.'\" \"'.s:netrw_passwd.'\"'
     endif
    endif

   if a:path != ""
    keepj put ='cd \"'.a:path.'\"'
   endif
   if exists("g:netrw_ftpextracmd")
    keepj put =g:netrw_ftpextracmd
"    call Decho("filter input: ".getline('.'))
   endif
   keepj call setline(line("$")+1,a:listcmd)

   " perform ftp:
   " -i       : turns off interactive prompting from ftp
   " -n  unix : DON'T use <.netrc>, even though it exists
   " -n  win32: quit being obnoxious about password
   if exists("w:netrw_bannercnt")
"    exe w:netrw_bannercnt.',$g/^./call Decho("ftp#".line(".").": ".getline("."))'
"    call Decho("exe ".s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options)
    exe s:netrw_silentxfer.w:netrw_bannercnt.",$!".s:netrw_ftp_cmd." ".g:netrw_ftp_options
"   else " Decho
"    call Decho("WARNING: w:netrw_bannercnt doesn't exist!")
"    g/^./call Decho("SKIPPING ftp#".line(".").": ".getline(".")) " COMBAK
   endif

  ".........................................
  elseif w:netrw_method == 9	" {{{3
   " sftp username@machine: Method #9
   " s:netrw_sftp_cmd
   setl ff=unix

   " restore settings
   let &ff= ffkeep
"   call Dret("NetrwRemoteFtpCmd")
   return

  ".........................................
  else	" {{{3
   keepj call netrw#ErrorMsg(s:WARNING,"unable to comply with your request<" . bufname("%") . ">",23)
  endif

  " cleanup for Windows " {{{3
  if has("win32") || has("win95") || has("win64") || has("win16")
   sil! keepj %s/\r$//e
   keepj call histdel("/",-1)
  endif
  if a:listcmd == "dir"
   " infer directory/link based on the file permission string
   sil! keepj g/d\%([-r][-w][-x]\)\{3}/keepj s@$@/@e
   sil! keepj g/l\%([-r][-w][-x]\)\{3}/keepj s/$/@/e
   keepj call histdel("/",-1)
   keepj call histdel("/",-1)
   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
    exe "sil! keepj ".w:netrw_bannercnt.',$s/^\%(\S\+\s\+\)\{8}//e'
    keepj call histdel("/",-1)
   endif
  endif

  " ftp's listing doesn't seem to include ./ or ../ " {{{3
  if !search('^\.\/$\|\s\.\/$','wn')
   exe 'keepj '.w:netrw_bannercnt
   keepj put ='./'
  endif
  if !search('^\.\.\/$\|\s\.\.\/$','wn')
   exe 'keepj '.w:netrw_bannercnt
   keepj put ='../'
  endif

  " restore settings " {{{3
  let &ff= ffkeep
"  call Dret("NetrwRemoteFtpCmd")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteListing: {{{2
fun! s:NetrwRemoteListing()
"  call Dfunc("s:NetrwRemoteListing() b:netrw_curdir<".b:netrw_curdir.">)")

  if !exists("w:netrw_bannercnt") && exists("s:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif
  if !exists("w:netrw_bannercnt") && exists("b:bannercnt")
   let w:netrw_bannercnt= s:bannercnt
  endif

  call s:RemotePathAnalysis(b:netrw_curdir)

  " sanity check:
  if exists("b:netrw_method") && b:netrw_method =~ '[235]'
"   call Decho("b:netrw_method=".b:netrw_method)
   if !executable("ftp")
"    call Decho("ftp is not executable")
    if !exists("g:netrw_quiet")
     call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ftp",18)
    endif
    call s:NetrwOptionRestore("w:")
"    call Dret("s:NetrwRemoteListing -1")
    return -1
   endif

  elseif !exists("g:netrw_list_cmd") || g:netrw_list_cmd == ''
"   call Decho("g:netrw_list_cmd<",(exists("g:netrw_list_cmd")? 'n/a' : "-empty-").">")
   if !exists("g:netrw_quiet")
    if g:netrw_list_cmd == ""
     keepj call netrw#ErrorMsg(s:ERROR,"your g:netrw_list_cmd is empty; perhaps ".g:netrw_ssh_cmd." is not executable on your system",47)
    else
     keepj call netrw#ErrorMsg(s:ERROR,"this system doesn't support remote directory listing via ".g:netrw_list_cmd,19)
    endif
   endif

   keepj call s:NetrwOptionRestore("w:")
"   call Dret("s:NetrwRemoteListing -1")
   return -1
  endif  " (remote handling sanity check)
"  call Decho("passed remote listing sanity checks")

  if exists("b:netrw_method")
"   call Decho("setting w:netrw_method to b:netrw_method<".b:netrw_method.">")
   let w:netrw_method= b:netrw_method
  endif

  if s:method == "ftp"
   " use ftp to get remote file listing {{{3
"   call Decho("use ftp to get remote file listing")
   let s:method  = "ftp"
   let listcmd = g:netrw_ftp_list_cmd
   if g:netrw_sort_by =~ '^t'
    let listcmd= g:netrw_ftp_timelist_cmd
   elseif g:netrw_sort_by =~ '^s'
    let listcmd= g:netrw_ftp_sizelist_cmd
   endif
"   call Decho("listcmd<".listcmd."> (using g:netrw_ftp_list_cmd)")
   call s:NetrwRemoteFtpCmd(s:path,listcmd)
"   exe "sil! keepalt keepj ".w:netrw_bannercnt.',$g/^./call Decho("raw listing: ".getline("."))'

   " report on missing file or directory messages
   if search('[Nn]o such file or directory\|Failed to change directory')
    let mesg= getline(".")
    if exists("w:netrw_bannercnt")
     setl ma
     exe w:netrw_bannercnt.",$d"
     setl noma
    endif
    keepj call s:NetrwOptionRestore("w:")
    call netrw#ErrorMsg(s:WARNING,mesg,96)
"    call Dret("s:NetrwRemoteListing : -1")
    return -1
   endif

   if w:netrw_liststyle == s:THINLIST || w:netrw_liststyle == s:WIDELIST || w:netrw_liststyle == s:TREELIST
    " shorten the listing
"    call Decho("generate short listing")
    exe "sil! keepalt keepj ".w:netrw_bannercnt

    " cleanup
    if g:netrw_ftp_browse_reject != ""
     exe "sil! keepalt keepj g/".g:netrw_ftp_browse_reject."/keepj d"
     keepj call histdel("/",-1)
    endif
    sil! keepj %s/\r$//e
    keepj call histdel("/",-1)

    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    exe "sil! keepj ".w:netrw_bannercnt
    let line2= search('\.\.\/\%(\s\|$\)','cnW')
"    call Decho("search(".'\.\.\/\%(\s\|$\)'."','cnW')=".line2."  w:netrw_bannercnt=".w:netrw_bannercnt)
    if line2 == 0
"     call Decho("netrw is putting ../ into listing")
     sil! keepj put='../'
    endif
    exe "sil! keepj ".line1
    sil! keepj norm! 0

"    call Decho("line1=".line1." line2=".line2." line(.)=".line("."))
    if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"     call Decho("M$ ftp cleanup")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+//'
     keepj call histdel("/",-1)
    else " normal ftp cleanup
"     call Decho("normal ftp cleanup")
     exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2/e'
     exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*/$#/#e'
     exe "sil! keepj ".w:netrw_bannercnt.',$g/ -> /s# -> .*$#/#e'
     keepj call histdel("/",-1)
     keepj call histdel("/",-1)
     keepj call histdel("/",-1)
    endif
   endif

   else
   " use ssh to get remote file listing {{{3
"   call Decho("use ssh to get remote file listing: s:path<".s:path.">")
   let listcmd= s:MakeSshCmd(g:netrw_list_cmd)
"   call Decho("listcmd<".listcmd."> (using g:netrw_list_cmd)")
   if g:netrw_scp_cmd =~ '^pscp'
"    call Decho("1: exe sil r! ".shellescape(listcmd.s:path, 1))
    exe "sil! keepj r! ".listcmd.shellescape(s:path, 1)
    " remove rubbish and adjust listing format of 'pscp' to 'ssh ls -FLa' like
    sil! keepj g/^Listing directory/keepj d
    sil! keepj g/^d[-rwx][-rwx][-rwx]/keepj s+$+/+e
    sil! keepj g/^l[-rwx][-rwx][-rwx]/keepj s+$+@+e
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    if g:netrw_liststyle != s:LONGLIST
     sil! keepj g/^[dlsp-][-rwx][-rwx][-rwx]/keepj s/^.*\s\(\S\+\)$/\1/e
     keepj call histdel("/",-1)
    endif
   else
    if s:path == ""
"     call Decho("2: exe sil r! ".listcmd)
     exe "sil! keepj keepalt r! ".listcmd
    else
"     call Decho("3: exe sil r! ".listcmd.' '.shellescape(fnameescape(s:path),1))
     exe "sil! keepj keepalt r! ".listcmd.' '.shellescape(fnameescape(s:path),1)
"     call Decho("listcmd<".listcmd."> path<".s:path.">")
    endif
   endif

   " cleanup
   if g:netrw_ssh_browse_reject != ""
"    call Decho("cleanup: exe sil! g/".g:netrw_ssh_browse_reject."/keepjumps d")
    exe "sil! g/".g:netrw_ssh_browse_reject."/keepj d"
    keepj call histdel("/",-1)
   endif
  endif

  if w:netrw_liststyle == s:LONGLIST
   " do a long listing; these substitutions need to be done prior to sorting {{{3
"   call Decho("fix long listing:")

   if s:method == "ftp"
    " cleanup
    exe "sil! keepj ".w:netrw_bannercnt
    while getline('.') =~ g:netrw_ftp_browse_reject
     sil! keepj d
    endwhile
    " if there's no ../ listed, then put ../ in
    let line1= line(".")
    sil! keepj 1
    sil! keepj call search('^\.\.\/\%(\s\|$\)','W')
    let line2= line(".")
    if line2 == 0
     if b:netrw_curdir != '/'
      exe 'sil! keepj '.w:netrw_bannercnt."put='../'"
     endif
    endif
    exe "sil! keepj ".line1
    sil! keepj norm! 0
   endif

   if search('^\d\{2}-\d\{2}-\d\{2}\s','n') " M$ ftp site cleanup
"    call Decho("M$ ftp site listing cleanup")
    exe 'sil! keepj '.w:netrw_bannercnt.',$s/^\(\d\{2}-\d\{2}-\d\{2}\s\+\d\+:\d\+[AaPp][Mm]\s\+\%(<DIR>\|\d\+\)\s\+\)\(\w.*\)$/\2\t\1/'
   elseif exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$")
"    call Decho("normal ftp site listing cleanup: bannercnt=".w:netrw_bannercnt." line($)=".line("$"))
    exe 'sil keepj '.w:netrw_bannercnt.',$s/ -> .*$//e'
    exe 'sil keepj '.w:netrw_bannercnt.',$s/^\(\%(\S\+\s\+\)\{7}\S\+\)\s\+\(\S.*\)$/\2\t\1/e'
    exe 'sil keepj '.w:netrw_bannercnt
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
    keepj call histdel("/",-1)
   endif
  endif

"  if exists("w:netrw_bannercnt") && w:netrw_bannercnt <= line("$") " Decho
"   exe "keepj ".w:netrw_bannercnt.',$g/^./call Decho("listing: ".getline("."))'
"  endif " Decho

"  call Dret("s:NetrwRemoteListing 0")
  return 0
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRm: remove/delete a remote file or directory {{{2
fun! s:NetrwRemoteRm(usrhost,path) range
"  call Dfunc("s:NetrwRemoteRm(usrhost<".a:usrhost."> path<".a:path.">) virtcol=".virtcol("."))
"  call Decho("firstline=".a:firstline." lastline=".a:lastline)
  let svpos= netrw#SavePosn()

  let all= 0
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files with bufnr#".bufnr("%"))
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwRemoteRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)

  else
   " remove files specified by range
"   call Decho("remove files specified by range")

   " preparation for removing multiple files/directories
   let ctr= a:firstline

   " remove multiple files and directories
   while ctr <= a:lastline
    exe "keepj ".ctr
    let ok= s:NetrwRemoteRmFile(a:path,s:NetrwGetWord(),all)
    if ok =~ 'q\%[uit]'
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
  endif

  " refresh the (remote) directory listing
"  call Decho("refresh remote directory listing")
  keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("s:NetrwRemoteRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRmFile: {{{2
fun! s:NetrwRemoteRmFile(path,rmfile,all)
"  call Dfunc("s:NetrwRemoteRmFile(path<".a:path."> rmfile<".a:rmfile.">) all=".a:all)

  let all= a:all
  let ok = ""

  if a:rmfile !~ '^"' && (a:rmfile =~ '@$' || a:rmfile !~ '[\/]$')
   " attempt to remove file
"    call Decho("attempt to remove file (all=".all.")")
   if !all
    echohl Statement
"    call Decho("case all=0:")
    call inputsave()
    let ok= input("Confirm deletion of file<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
"    call Decho("case all=".all." or ok<".ok.">".(exists("w:netrw_method")? ': netrw_method='.w:netrw_method : ""))
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
"     call Decho("case ftp:")
     let path= a:path
     if path =~ '^\a\+://'
      let path= substitute(path,'^\a\+://[^/]\+/','','')
     endif
     sil! keepj .,$d
     call s:NetrwRemoteFtpCmd(path,"delete ".'"'.a:rmfile.'"')
    else
"     call Decho("case ssh: g:netrw_rm_cmd<".g:netrw_rm_cmd.">")
     let netrw_rm_cmd= s:MakeSshCmd(g:netrw_rm_cmd)
"     call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
     if !exists("b:netrw_curdir")
      keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
      let ok="q"
     else
      let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
"      call Decho("netrw_rm_cmd<".netrw_rm_cmd.">")
"      call Decho("remotedir<".remotedir.">")
"      call Decho("rmfile<".a:rmfile.">")
      if remotedir != ""
       let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(remotedir.a:rmfile))
      else
       let netrw_rm_cmd= netrw_rm_cmd." ".shellescape(fnameescape(a:rmfile))
      endif
"      call Decho("call system(".netrw_rm_cmd.")")
      let ret= system(netrw_rm_cmd)
      if ret != 0
       keepj call netrw#ErrorMsg(s:WARNING,"cmd<".netrw_rm_cmd."> failed",60)
      endif
"      call Decho("returned=".ret." errcode=".v:shell_error)
     endif
    endif
   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok)
   endif

  else
   " attempt to remove directory
"    call Decho("attempt to remove directory")
   if !all
    call inputsave()
    let ok= input("Confirm deletion of directory<".a:rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    if ok == ""
     let ok="no"
    endif
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     keepj call s:NetrwRemoteFtpCmd(a:path,"rmdir ".a:rmfile)
    else
     let rmfile          = substitute(a:path.a:rmfile,'/$','','')
     let netrw_rmdir_cmd = s:MakeSshCmd(netrw#WinPath(g:netrw_rmdir_cmd)).' '.shellescape(netrw#WinPath(rmfile))
"      call Decho("attempt to remove dir: system(".netrw_rmdir_cmd.")")
     let ret= system(netrw_rmdir_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error)

     if v:shell_error != 0
"      call Decho("v:shell_error not 0")
      let netrw_rmf_cmd= s:MakeSshCmd(netrw#WinPath(g:netrw_rmf_cmd)).' '.shellescape(netrw#WinPath(substitute(rmfile,'[\/]$','','e')))
"      call Decho("2nd attempt to remove dir: system(".netrw_rmf_cmd.")")
      let ret= system(netrw_rmf_cmd)
"      call Decho("returned=".ret." errcode=".v:shell_error)

      if v:shell_error != 0 && !exists("g:netrw_quiet")
      	keepj call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",22)
      endif
     endif
    endif

   elseif ok =~ 'q\%[uit]'
"    call Decho("ok==".ok)
   endif
  endif

"  call Dret("s:NetrwRemoteRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" s:NetrwRemoteRename: rename a remote file or directory {{{2
fun! s:NetrwRemoteRename(usrhost,path) range
"  call Dfunc("NetrwRemoteRename(usrhost<".a:usrhost."> path<".a:path.">)")

  " preparation for removing multiple files/directories
  let svpos      = netrw#SavePosn()
  let ctr        = a:firstline
  let rename_cmd = s:MakeSshCmd(g:netrw_rename_cmd)

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">")
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
      let newname = substitute(oldname,subfrom,subto,'')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
     endif
    endif
   
    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     keepj call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= shellescape(a:path.oldname)
     let newname= shellescape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

   endfor
   call s:NetrwUnMarkFile(1)

  else

  " attempt to rename files/directories
   while ctr <= a:lastline
    exe "keepj ".ctr

    let oldname= s:NetrwGetWord()
"   call Decho("oldname<".oldname.">")

    call inputsave()
    let newname= input("Moving ".oldname." to : ",oldname)
    call inputrestore()

    if exists("w:netrw_method") && (w:netrw_method == 2 || w:netrw_method == 3)
     call s:NetrwRemoteFtpCmd(a:path,"rename ".oldname." ".newname)
    else
     let oldname= shellescape(a:path.oldname)
     let newname= shellescape(a:path.newname)
"     call Decho("system(netrw#WinPath(".rename_cmd.") ".oldname.' '.newname.")")
     let ret    = system(netrw#WinPath(rename_cmd).' '.oldname.' '.newname)
    endif

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
  keepj call s:NetrwRefresh(0,s:NetrwBrowseChgDir(0,'./'))
  keepj call netrw#RestorePosn(svpos)

"  call Dret("NetrwRemoteRename")
endfun

" ---------------------------------------------------------------------
"  Local Directory Browsing Support:    {{{1
" ==========================================

" ---------------------------------------------------------------------
" netrw#FileUrlRead: handles reading file://* files {{{2
"   Should accept:   file://localhost/etc/fstab
"                    file:///etc/fstab
"                    file:///c:/WINDOWS/clock.avi
"                    file:///c|/WINDOWS/clock.avi
"                    file://localhost/c:/WINDOWS/clock.avi
"                    file://localhost/c|/WINDOWS/clock.avi
"                    file://c:/foo.txt
"                    file:///c:/foo.txt
" and %XX (where X is [0-9a-fA-F] is converted into a character with the given hexadecimal value
fun! netrw#FileUrlRead(fname)
"  call Dfunc("netrw#FileUrlRead(fname<".a:fname.">)")
  let fname = a:fname
  if fname =~ '^file://localhost/'
"   call Decho('converting file://localhost/   -to-  file:///')
   let fname= substitute(fname,'^file://localhost/','file:///','')
"   call Decho("fname<".fname.">")
  endif
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   if fname  =~ '^file:///\=\a[|:]/'
"    call Decho('converting file:///\a|/   -to-  file://\a:/')
    let fname = substitute(fname,'^file:///\=\(\a\)[|:]/','file://\1:/','')
"    call Decho("fname<".fname.">")
   endif
  endif
  let fname2396 = netrw#RFC2396(fname)
  let fname2396e= fnameescape(fname2396)
  let plainfname= substitute(fname2396,'file://\(.*\)','\1',"")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows exception for plainfname")
   if plainfname =~ '^/\+\a:'
"    call Decho('removing leading "/"s')
    let plainfname= substitute(plainfname,'^/\+\(\a:\)','\1','')
   endif
  endif
"  call Decho("fname2396<".fname2396.">")
"  call Decho("plainfname<".plainfname.">")
  exe "sil doau BufReadPre ".fname2396e
  exe 'keepj r '.plainfname
  exe 'sil! bdelete '.plainfname
  exe 'keepalt file! '.plainfname
  keepj 1d
"  call Decho("setl nomod")
  setl nomod
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("netrw#FileUrlRead")
  exe "sil doau BufReadPost ".fname2396e
endfun

" ---------------------------------------------------------------------
" netrw#LocalBrowseCheck: {{{2
fun! netrw#LocalBrowseCheck(dirname)
  " unfortunate interaction -- split window debugging can't be
  " used here, must use D-echoRemOn or D-echoTabOn -- the BufEnter
  " event triggers another call to LocalBrowseCheck() when attempts
  " to write to the DBG buffer are made.
  " The &ft == "netrw" test was installed because the BufEnter event
  " would hit when re-entering netrw windows, creating unexpected
  " refreshes (and would do so in the middle of NetrwSaveOptions(), too)
"  call Dfunc("netrw#LocalBrowseCheck(dirname<".a:dirname.">")
"  call Decho("isdir<".a:dirname.">=".isdirectory(a:dirname).((exists("s:treeforceredraw")? " treeforceredraw" : "")))
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dredir("ls!","ls!")

  let ykeep= @@
  if isdirectory(a:dirname)
"   call Decho("is-directory ft<".&ft."> b:netrw_curdir<".(exists("b:netrw_curdir")? b:netrw_curdir : " doesn't exist")."> dirname<".a:dirname.">"." line($)=".line("$")." ft<".&ft."> g:netrw_fastbrowse=".g:netrw_fastbrowse)
   let svposn= netrw#SavePosn()
   if &ft != "netrw" || (exists("b:netrw_curdir") && b:netrw_curdir != a:dirname) || g:netrw_fastbrowse <= 1
"    call Decho("case 1 : ft=".&ft)
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)

   elseif &ft == "netrw" && line("$") == 1
"    call Decho("case 2 (ft≡netrw && line($)≡1)")
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)

   elseif exists("s:treeforceredraw")
"    call Decho("case 3 (treeforceredraw)")
    unlet s:treeforceredraw
    sil! keepj keepalt call s:NetrwBrowse(1,a:dirname)
    keepalt call netrw#RestorePosn(svposn)
   endif

"   call Dret("netrw#LocalBrowseCheck")
   return
  endif

  " following code wipes out currently unused netrw buffers
  "       IF g:netrw_fastbrowse is zero (ie. slow browsing selected)
  "   AND IF the listing style is not a tree listing
  if exists("g:netrw_fastbrowse") && g:netrw_fastbrowse == 0 && g:netrw_liststyle != s:TREELIST
"   call Decho("wiping out currently unused netrw buffers")
   let ibuf    = 1
   let buflast = bufnr("$")
   while ibuf <= buflast
    if bufwinnr(ibuf) == -1 && isdirectory(bufname(ibuf))
     exe "sil! keepalt ".ibuf."bw!"
    endif
    let ibuf= ibuf + 1
   endwhile
  endif
  let @@= ykeep
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  " not a directory, ignore it
"  call Dret("netrw#LocalBrowseCheck : not a directory, ignoring it; dirname<".a:dirname.">")
endfun

" ---------------------------------------------------------------------
" s:LocalBrowseRefresh: this function is called after a user has {{{2
" performed any shell command.  The idea is to cause all local-browsing
" buffers to be refreshed after a user has executed some shell command,
" on the chance that s/he removed/created a file/directory with it.
fun! s:LocalBrowseRefresh()
"  call Dfunc("s:LocalBrowseRefresh() tabpagenr($)=".tabpagenr("$"))
"  call Decho("s:netrw_browselist =".(exists("s:netrw_browselist")?  string(s:netrw_browselist)  : '<n/a>'))
"  call Decho("w:netrw_bannercnt  =".(exists("w:netrw_bannercnt")?   string(w:netrw_bannercnt)   : '<n/a>'))

  " determine which buffers currently reside in a tab
  if !exists("s:netrw_browselist")
"   call Dret("s:LocalBrowseRefresh : browselist is empty")
   return
  endif
  if !exists("w:netrw_bannercnt")
"   call Dret("s:LocalBrowseRefresh : don't refresh when focus not on netrw window")
   return
  endif
  if exists("s:netrw_events") && s:netrw_events == 1
   " s:LocalFastBrowser gets called (indirectly) from a
   let s:netrw_events= 2
"   call Dret("s:LocalBrowseRefresh : avoid initial double refresh")
   return
  endif
  let itab       = 1
  let buftablist = []
  let ykeep      = @@
  while itab <= tabpagenr("$")
   let buftablist = buftablist + tabpagebuflist()
   let itab       = itab + 1
   tabn
  endwhile
"  call Decho("buftablist".string(buftablist))
"  call Decho("s:netrw_browselist<".(exists("s:netrw_browselist")? string(s:netrw_browselist) : "").">")
  "  GO through all buffers on netrw_browselist (ie. just local-netrw buffers):
  "   | refresh any netrw window
  "   | wipe out any non-displaying netrw buffer
  let curwin = winnr()
  let ibl    = 0
  for ibuf in s:netrw_browselist
"   call Decho("bufwinnr(".ibuf.") index(buftablist,".ibuf.")=".index(buftablist,ibuf))
   if bufwinnr(ibuf) == -1 && index(buftablist,ibuf) == -1
    " wipe out any non-displaying netrw buffer
"    call Decho("wiping  buf#".ibuf,"<".bufname(ibuf).">")
    exe "sil! bd ".fnameescape(ibuf)
    call remove(s:netrw_browselist,ibl)
"    call Decho("browselist=".string(s:netrw_browselist))
    continue
   elseif index(tabpagebuflist(),ibuf) != -1
    " refresh any netrw buffer
"    call Decho("refresh buf#".ibuf.'-> win#'.bufwinnr(ibuf))
    exe bufwinnr(ibuf)."wincmd w"
    if getline(".") =~ 'Quick Help'
     " decrement g:netrw_quickhelp to prevent refresh from changing g:netrw_quickhelp
     " (counteracts s:NetrwBrowseChgDir()'s incrementing)
     let g:netrw_quickhelp= g:netrw_quickhelp - 1
    endif
"    call Decho("#3: quickhelp=".g:netrw_quickhelp)
    keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   endif
   let ibl= ibl + 1
  endfor
  exe curwin."wincmd w"
  let @@= ykeep

"  call Dret("s:LocalBrowseRefresh")
endfun

" ---------------------------------------------------------------------
" s:LocalFastBrowser: handles setting up/taking down fast browsing for the local browser {{{2
"
"     g:netrw_    Directory Is
"     fastbrowse  Local  Remote   
"  slow   0         D      D      D=Deleting a buffer implies it will not be re-used (slow)
"  med    1         D      H      H=Hiding a buffer implies it may be re-used        (fast)
"  fast   2         H      H      
"
"  Deleting a buffer means that it will be re-loaded when examined, hence "slow".
"  Hiding   a buffer means that it will be re-used   when examined, hence "fast".
"                       (re-using a buffer may not be as accurate)
"
"  s:netrw_events : doesn't exist, s:LocalFastBrowser() will install autocmds whena med or fast browsing
"                   =1: autocmds installed, but ignore next FocusGained event to avoid initial double-refresh of listing.
"                       BufEnter may be first event, then a FocusGained event.  Ignore the first FocusGained event.
"                       If :Explore used: it sets s:netrw_events to 2, so no FocusGained events are ignored.
"                   =2: autocmds installed (doesn't ignore any FocusGained events)
fun! s:LocalFastBrowser()
"  call Dfunc("LocalFastBrowser() g:netrw_fastbrowse=".g:netrw_fastbrowse)
"  call Decho("s:netrw_events        ".(exists("s:netrw_events")? "exists"    : 'n/a'))
"  call Decho("autocmd: ShellCmdPost ".(exists("#ShellCmdPost")?  "installed" : "not installed"))
"  call Decho("autocmd: FocusGained  ".(exists("#FocusGained")?   "installed" : "not installed"))

  " initialize browselist, a list of buffer numbers that the local browser has used
  if !exists("s:netrw_browselist")
"   call Decho("initialize s:netrw_browselist")
   let s:netrw_browselist= []
  endif

  " append current buffer to fastbrowse list
  if empty(s:netrw_browselist) || bufnr("%") > s:netrw_browselist[-1]
"   call Decho("appendng current buffer to browselist")
   call add(s:netrw_browselist,bufnr("%"))
"   call Decho("browselist=".string(s:netrw_browselist))
  endif

  " enable autocmd events to handle refreshing/removing local browser buffers
  "    If local browse buffer is currently showing: refresh it
  "    If local browse buffer is currently hidden : wipe it
  "    g:netrw_fastbrowse=0 : slow   speed, never re-use directory listing
  "                      =1 : medium speed, re-use directory listing for remote only
  "                      =2 : fast   speed, always re-use directory listing when possible
  if g:netrw_fastbrowse <= 1 && !exists("#ShellCmdPost") && !exists("s:netrw_events")
   let s:netrw_events= 1
   augroup AuNetrwEvent
    au!
    if (has("win32") || has("win95") || has("win64") || has("win16"))
"     call Decho("installing autocmd: ShellCmdPost")
     au ShellCmdPost			*	call s:LocalBrowseRefresh()
    else
"     call Decho("installing autocmds: ShellCmdPost FocusGained")
     au ShellCmdPost,FocusGained	*	call s:LocalBrowseRefresh()
    endif
   augroup END

  " user must have changed fastbrowse to its fast setting, so remove
  " the associated autocmd events
  elseif g:netrw_fastbrowse > 1 && exists("#ShellCmdPost") && exists("s:netrw_events")
"   call Decho("remove AuNetrwEvent autcmd group")
   unlet s:netrw_events
   augroup AuNetrwEvent
    au!
   augroup END
   augroup! AuNetrwEvent
  endif

"  call Dret("LocalFastBrowser : browselist<".string(s:netrw_browselist).">")
endfun

" ---------------------------------------------------------------------
"  s:LocalListing: does the job of "ls" for local directories {{{2
fun! s:LocalListing()
"  call Dfunc("s:LocalListing()")
"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Decho("tab#".tabpagenr()." win#".winnr()." buf#".bufnr("%")."<".bufname("%")."> modified=".&modified." modifiable=".&modifiable." readonly=".&readonly)

"  if exists("b:netrw_curdir") |call Decho('b:netrw_curdir<'.b:netrw_curdir.">")  |else|call Decho("b:netrw_curdir doesn't exist") |endif
"  if exists("g:netrw_sort_by")|call Decho('g:netrw_sort_by<'.g:netrw_sort_by.">")|else|call Decho("g:netrw_sort_by doesn't exist")|endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  " get the list of files contained in the current directory
  let dirname    = b:netrw_curdir
  let dirnamelen = strlen(b:netrw_curdir)
  let filelist   = glob(s:ComposePath(dirname,"*"),0,1)
  let filelist   = filelist + glob(s:ComposePath(dirname,".*"),0,1)
"  call Decho("filelist=".filelist)

  if g:netrw_cygwin == 0 && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("filelist=".string(filelist))
  elseif index(filelist,'..') == -1 && b:netrw_curdir !~ '/'
    " include ../ in the glob() entry if its missing
"   call Decho("forcibly including on \"..\"")
   let filelist= filelist+[s:ComposePath(b:netrw_curdir,"../")]
"   call Decho("filelist=".string(filelist))
  endif

"  call Decho("before while: dirname<".dirname.">")
"  call Decho("before while: dirnamelen<".dirnamelen.">")
"  call Decho("before while: filelist=".string(filelist))

  if get(g:, 'netrw_dynamic_maxfilenamelen', 0)
   let filelistcopy           = map(deepcopy(filelist),'fnamemodify(v:val, ":t")')
   let g:netrw_maxfilenamelen = max(map(filelistcopy,'len(v:val)')) + 1
"   call Decho("dynamic_maxfilenamelen: filenames             =".string(filelistcopy))
"   call Decho("dynamic_maxfilenamelen: g:netrw_maxfilenamelen=".g:netrw_maxfilenamelen)
  endif
"  call Decho("g:netrw_banner=".g:netrw_banner.": banner ".(g:netrw_banner? "enabled" : "suppressed").": (line($)=".line("$")." byte2line(1)=".byte2line(1)." bannercnt=".w:netrw_bannercnt.")")

  for filename in filelist
"   call Decho(" ")
"   call Decho("for filename in filelist: filename<".filename.">")

   if getftype(filename) == "link"
    " indicate a symbolic link
"    call Decho("indicate <".filename."> is a symbolic link with trailing @")
    let pfile= filename."@"

   elseif getftype(filename) == "socket"
    " indicate a socket
"    call Decho("indicate <".filename."> is a socket with trailing =")
    let pfile= filename."="

   elseif getftype(filename) == "fifo"
    " indicate a fifo
"    call Decho("indicate <".filename."> is a fifo with trailing |")
    let pfile= filename."|"

   elseif isdirectory(filename)
    " indicate a directory
"    call Decho("indicate <".filename."> is a directory with trailing /")
    let pfile= filename."/"

   elseif exists("b:netrw_curdir") && b:netrw_curdir !~ '^.*://' && !isdirectory(filename)
    if (has("win32") || has("win95") || has("win64") || has("win16"))
     if filename =~ '\.[eE][xX][eE]$' || filename =~ '\.[cC][oO][mM]$' || filename =~ '\.[bB][aA][tT]$'
      " indicate an executable
"      call Decho("indicate <".filename."> is executable with trailing *")
      let pfile= filename."*"
     else
      " normal file
      let pfile= filename
     endif
    elseif executable(filename)
     " indicate an executable
"     call Decho("indicate <".filename."> is executable with trailing *")
     let pfile= filename."*"
    else
     " normal file
     let pfile= filename
    endif

   else
    " normal file
    let pfile= filename
   endif
"   call Decho("pfile<".pfile."> (after *@/ appending)")

   if pfile =~ '//$'
    let pfile= substitute(pfile,'//$','/','e')
"    call Decho("change // to /: pfile<".pfile.">")
   endif
   let pfile= strpart(pfile,dirnamelen)
   let pfile= substitute(pfile,'^[/\\]','','e')
"   call Decho("filename<".filename.">")
"   call Decho("pfile   <".pfile.">")

   if w:netrw_liststyle == s:LONGLIST
    let sz   = getfsize(filename)
    let fsz  = strpart("               ",1,15-strlen(sz)).sz
    let pfile= pfile."\t".fsz." ".strftime(g:netrw_timefmt,getftime(filename))
"    call Decho("sz=".sz." fsz=".fsz)
   endif

   if     g:netrw_sort_by =~ "^t"
    " sort by time (handles time up to 1 quintillion seconds, US)
"    call Decho("getftime(".filename.")=".getftime(filename))
    let t  = getftime(filename)
    let ft = strpart("000000000000000000",1,18-strlen(t)).t
"    call Decho("exe keepjumps put ='".ft.'/'.filename."'")
    let ftpfile= ft.'/'.pfile
    sil! keepj put=ftpfile

   elseif g:netrw_sort_by =~ "^s"
    " sort by size (handles file sizes up to 1 quintillion bytes, US)
"    call Decho("getfsize(".filename.")=".getfsize(filename))
    let sz   = getfsize(filename)
    let fsz  = strpart("000000000000000000",1,18-strlen(sz)).sz
"    call Decho("exe keepj put ='".fsz.'/'.filename."'")
    let fszpfile= fsz.'/'.pfile
    sil! keepj put =fszpfile

   else
    " sort by name
"    call Decho("exe keepjumps put ='".pfile."'")
    sil! keepj put=pfile
   endif
  endfor

  " cleanup any windows mess at end-of-line
  sil! keepj g/^$/d
  sil! keepj %s/\r$//e
  call histdel("/",-1)
"  call Decho("exe setl ts=".(g:netrw_maxfilenamelen+1))
  exe "setl ts=".(g:netrw_maxfilenamelen+1)

"  call Dret("s:LocalListing")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalExecute: uses system() to execute command under cursor ("X" command support) {{{2
fun! s:NetrwLocalExecute(cmd)
"  call Dfunc("s:NetrwLocalExecute(cmd<".a:cmd.">)")
  let ykeep= @@
  " sanity check
  if !executable(a:cmd)
   call netrw#ErrorMsg(s:ERROR,"the file<".a:cmd."> is not executable!",89)
   let @@= ykeep
"   call Dret("s:NetrwLocalExecute")
   return
  endif

  let optargs= input(":!".a:cmd,"","file")
"  call Decho("optargs<".optargs.">")
  let result= system(a:cmd.optargs)
"  call Decho("result)

  " strip any ansi escape sequences off
  let result = substitute(result,"\e\\[[0-9;]*m","","g")

  " show user the result(s)
  echomsg result
  let @@= ykeep

"  call Dret("s:NetrwLocalExecute")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRename: rename a remote file or directory {{{2
fun! s:NetrwLocalRename(path) range
"  call Dfunc("NetrwLocalRename(path<".a:path.">)")

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ctr   = a:firstline
  let svpos = netrw#SavePosn()

  " rename files given by the markfilelist
  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   for oldname in s:netrwmarkfilelist_{bufnr("%")}
"    call Decho("oldname<".oldname.">")
    if exists("subfrom")
     let newname= substitute(oldname,subfrom,subto,'')
"     call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
    else
     call inputsave()
     let newname= input("Moving ".oldname." to : ",oldname)
     call inputrestore()
     if newname =~ '^s/'
      let subfrom = substitute(newname,'^s/\([^/]*\)/.*/$','\1','')
      let subto   = substitute(newname,'^s/[^/]*/\(.*\)/$','\1','')
"      call Decho("subfrom<".subfrom."> subto<".subto."> newname<".newname.">")
      let newname = substitute(oldname,subfrom,subto,'')
     endif
    endif
    call rename(oldname,newname)
   endfor
   call s:NetrwUnmarkList(bufnr("%"),b:netrw_curdir)
  
  else

   " attempt to rename files/directories
   while ctr <= a:lastline
    exe "keepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif

    keepj norm! 0
    let oldname= s:ComposePath(a:path,curword)
"   call Decho("oldname<".oldname.">")

    call inputsave()
    let newname= input("Moving ".oldname." to : ",substitute(oldname,'/*$','','e'))
    call inputrestore()

    call rename(oldname,newname)
"   call Decho("renaming <".oldname."> to <".newname.">")

    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("refresh the directory listing")
  keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
  keepj call netrw#RestorePosn(svpos)
  let @@= ykeep

"  call Dret("NetrwLocalRename")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRm: {{{2
fun! s:NetrwLocalRm(path) range
"  call Dfunc("s:NetrwLocalRm(path<".a:path.">)")
"  call Decho("firstline=".a:firstline." lastline=".a:lastline)

  " preparation for removing multiple files/directories
  let ykeep = @@
  let ret   = 0
  let all   = 0
  let svpos = netrw#SavePosn()

  if exists("s:netrwmarkfilelist_{bufnr('%')}")
   " remove all marked files
"   call Decho("remove all marked files")
   for fname in s:netrwmarkfilelist_{bufnr("%")}
    let ok= s:NetrwLocalRmFile(a:path,fname,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
   endfor
   call s:NetrwUnMarkFile(1)

  else
  " remove (multiple) files and directories
"   call Decho("remove files in range [".a:firstline.",".a:lastline."]")

   let ctr = a:firstline
   while ctr <= a:lastline
    exe "keepj ".ctr

    " sanity checks
    if line(".") < w:netrw_bannercnt
     let ctr= ctr + 1
     continue
    endif
    let curword= s:NetrwGetWord()
    if curword == "./" || curword == "../"
     let ctr= ctr + 1
     continue
    endif
    let ok= s:NetrwLocalRmFile(a:path,curword,all)
    if ok =~ 'q\%[uit]' || ok == "no"
     break
    elseif ok =~ 'a\%[ll]'
     let all= 1
    endif
    let ctr= ctr + 1
   endwhile
  endif

  " refresh the directory
"  call Decho("bufname<".bufname("%").">")
  if bufname("%") != "NetrwMessage"
   keepj call s:NetrwRefresh(1,s:NetrwBrowseChgDir(1,'./'))
   keepj call netrw#RestorePosn(svpos)
  endif
  let @@= ykeep

"  call Dret("s:NetrwLocalRm")
endfun

" ---------------------------------------------------------------------
" s:NetrwLocalRmFile: remove file fname given the path {{{2
"                     Give confirmation prompt unless all==1
fun! s:NetrwLocalRmFile(path,fname,all)
"  call Dfunc("s:NetrwLocalRmFile(path<".a:path."> fname<".a:fname."> all=".a:all)
  
  let all= a:all
  let ok = ""
  keepj norm! 0
  let rmfile= s:ComposePath(a:path,a:fname)
"  call Decho("rmfile<".rmfile.">")

  if rmfile !~ '^"' && (rmfile =~ '@$' || rmfile !~ '[\/]$')
   " attempt to remove file
"   call Decho("attempt to remove file<".rmfile.">")
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of file<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    echohl NONE
    if ok == ""
     let ok="no"
    endif
"    call Decho("response: ok<".ok.">")
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
"    call Decho("response: ok<".ok."> (after sub)")
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif

   if all || ok =~ 'y\%[es]' || ok == ""
    let ret= s:NetrwDelete(rmfile)
"    call Decho("errcode=".v:shell_error." ret=".ret)
   endif

  else
   " attempt to remove directory
   if !all
    echohl Statement
    call inputsave()
    let ok= input("Confirm deletion of directory<".rmfile."> ","[{y(es)},n(o),a(ll),q(uit)] ")
    call inputrestore()
    let ok= substitute(ok,'\[{y(es)},n(o),a(ll),q(uit)]\s*','','e')
    if ok == ""
     let ok="no"
    endif
    if ok =~ 'a\%[ll]'
     let all= 1
    endif
   endif
   let rmfile= substitute(rmfile,'[\/]$','','e')

   if all || ok =~ 'y\%[es]' || ok == ""
"    call Decho("1st attempt: system(netrw#WinPath(".g:netrw_localrmdir.') '.shellescape(rmfile).')')
    call system(netrw#WinPath(g:netrw_localrmdir).' '.shellescape(rmfile))
"    call Decho("v:shell_error=".v:shell_error)

    if v:shell_error != 0
"     call Decho("2nd attempt to remove directory<".rmfile.">")
     let errcode= s:NetrwDelete(rmfile)
"     call Decho("errcode=".errcode)

     if errcode != 0
      if has("unix")
"       call Decho("3rd attempt to remove directory<".rmfile.">")
       call system("rm ".shellescape(rmfile))
       if v:shell_error != 0 && !exists("g:netrw_quiet")
        call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",34)
	let ok="no"
       endif
      elseif !exists("g:netrw_quiet")
       call netrw#ErrorMsg(s:ERROR,"unable to remove directory<".rmfile."> -- is it empty?",35)
       let ok="no"
      endif
     endif
    endif
   endif
  endif

"  call Dret("s:NetrwLocalRmFile ".ok)
  return ok
endfun

" ---------------------------------------------------------------------
" Support Functions: {{{1

" ---------------------------------------------------------------------
" netrw#Access: intended to provide access to variable values for netrw's test suite {{{2
"   0: marked file list of current buffer
"   1: marked file target
fun! netrw#Access(ilist)
  if     a:ilist == 0
   if exists("s:netrwmarkfilelist_".bufnr('%'))
    return s:netrwmarkfilelist_{bufnr('%')}
   else
    return "no-list-buf#".bufnr('%')
   endif
  elseif a:ilist == 1
   return s:netrwmftgt
endfun

" ------------------------------------------------------------------------
" netrw#RestorePosn: restores the cursor and file position as saved by NetrwSavePosn() {{{2
fun! netrw#RestorePosn(...)
"  call Dfunc("netrw#RestorePosn() a:0=".a:0." winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : -1)." line=".(exists("w:netrw_line")? w:netrw_line : -1)." col=".(exists("w:netrw_col")? w:netrw_col : -1)." hline=".(exists("w:netrw_hline")? w:netrw_hline : -1))
  let eikeep= &ei
  setl ei=all
  if expand("%") == "NetrwMessage"
   if exists("s:winBeforeErr")
    exe s:winBeforeErr."wincmd w"
   endif
  endif

  if a:0 > 0
   exe "keepj ".a:1
  endif
"  call Decho("a:1             = ".((a:0 > 0)?              a:1       : 'n/a'))
"  call Decho("liststyle       = ".(exists("liststyle")?    liststyle : 'n/a'). " w:netrw_liststyle=".(exists("w:netrw_liststyle")? w:netrw_liststyle : 'n/a'))
  if exists("liststyle") && exists("w:netrw_liststyle") && liststyle != w:netrw_liststyle
   let usesrch= 1
  else
   let usesrch= 0
  endif

"  call Decho("winh            = ".(exists("w:netrw_winh")?    w:netrw_winh    : -1))
"  call Decho("winw            = ".(exists("w:netrw_winw")?    w:netrw_winw    : -1))
"  call Decho("cur    winheight=".winheight(0)." winwidth=".winwidth(0))
"  call Decho("w:netrw_winfile = ".(exists("w:netrw_winfile")? w:netrw_winfile : 'n/a'))

  " restore window
  if exists("w:netrw_winnr")
"   call Decho("restore window: exe sil! ".w:netrw_winnr."wincmd w")
   exe "sil! ".w:netrw_winnr."wincmd w"
  endif
  if v:shell_error == 0
   " as suggested by Bram M: redraw on no error
   " allows protocol error messages to remain visible
"   redraw!
  endif

  " restore top-of-screen line
  if exists("w:netrw_hline")
"   call Decho("restore topofscreen: exe keepj norm! ".w:netrw_hline."G0z")
   exe "keepj norm! ".w:netrw_hline."G0z\<CR>"
  endif

  " restore position
  " when the window's height x width has changed, the line,col is no longer useful
  if w:netrw_winh == winheight(0) && w:netrw_winw == winwidth(0) && exists("w:netrw_line") && exists("w:netrw_col") && !usesrch
"   call Decho("using posn: exe keepj norm! ".w:netrw_line."G0".w:netrw_col."|")
   exe "keepj norm! ".w:netrw_line."G0".w:netrw_col."\<bar>"

  elseif exists("w:netrw_winfile")
   if !search('\<'.escape(w:netrw_winfile,g:netrw_fname_escape),'cw')
    if exists("w:netrw_bannercnt")
"     call Decho("using bannercnt: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
     exe "keepj ".w:netrw_bannercnt
     norm! 0
    else
     " go to upper left corner
"     call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0)." w:netrw_winfile<".w:netrw_winfile.">")
     keepj 1
     norm! 0
    endif
   else
"    call Decho("used search: w:netrw_winfile<".w:netrw_winfile.">")
   endif

  else
"   call Decho("goto ulc: win#".winnr()." ".winheight(0)."x".winwidth(0))
   keepj 1
   norm! 0
  endif

  let &ei= eikeep
"  call Dret("netrw#RestorePosn : line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
endfun

" ---------------------------------------------------------------------
"  netrw#RFC2396: converts %xx into characters {{{2
fun! netrw#RFC2396(fname)
"  call Dfunc("netrw#RFC2396(fname<".a:fname.">)")
  let fname = escape(substitute(a:fname,'%\(\x\x\)','\=nr2char("0x".submatch(1))','ge')," \t")
"  call Dret("netrw#RFC2396 ".fname)
  return fname
endfun

" ---------------------------------------------------------------------
" netrw#SavePosn: saves position of cursor on screen {{{2
fun! netrw#SavePosn()
"  call Dfunc("netrw#SavePosn() line#".line(".")." col#".col(".")." winline#".winline()." wincol#".wincol())
  " Save current line and column
  let w:netrw_winnr= winnr()
  let w:netrw_line = line(".")
  let w:netrw_col  = virtcol(".")
"  call Decho("currently, win#".w:netrw_winnr." line#".w:netrw_line." col#".w:netrw_col)

  " save filename under cursor
"  call Decho("line#".line(".")." w:netrw_bannercnt=".(exists("w:netrw_bannercnt")? w:netrw_bannercnt : 'n/a'))
  if exists("w:netrw_bannercnt") && line(".") >= w:netrw_bannercnt && &ft == "netrw"
   let winfile = "|let w:netrw_winfile='".s:NetrwGetWord()."'"
  else
   let winfile= ""
  endif
"  call Decho("winfile<".winfile.">")
  if exists("w:netrw_liststyle")
   let liststyle = "|let liststyle=".w:netrw_liststyle
  else
   let liststyle= ""
  endif
"  call Decho("liststyle=".liststyle)

  " Save top-of-screen line
  keepj norm! H0
  let w:netrw_hline= line(".")

  " save up alternate position information
  " use this when window height x width has changed
  let w:netrw_winh = winheight(0)
  let w:netrw_winw = winwidth(0)

  " set up string holding position parameters
  let ret          = "let w:netrw_winnr=".w:netrw_winnr."|let w:netrw_line=".w:netrw_line."|let w:netrw_col=".w:netrw_col."|let w:netrw_hline=".w:netrw_hline."|let w:netrw_winh=".w:netrw_winh."|let w:netrw_winw=".w:netrw_winw.liststyle.winfile

  keepj call netrw#RestorePosn()
"  call Dret("netrw#SavePosn : winnr=".(exists("w:netrw_winnr")? w:netrw_winnr : "n/a")." line=".(exists("w:netrw_line")? w:netrw_line : "n/a")." col=".(exists("w:netrw_col")? w:netrw_col : "n/a")." hline=".(exists("w:netrw_hline")? w:netrw_hline : "n/a"))
  return ret
endfun

" ---------------------------------------------------------------------
" netrw#WinPath: tries to insure that the path is windows-acceptable, whether cygwin is used or not {{{2
fun! netrw#WinPath(path)
"  call Dfunc("netrw#WinPath(path<".a:path.">)")
  if (!g:netrw_cygwin || &shell !~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$') && (has("win32") || has("win95") || has("win64") || has("win16"))
   " remove cygdrive prefix, if present
   let path = substitute(a:path,g:netrw_cygdrive.'/\(.\)','\1:','')
   " remove trailing slash (Win95)
   let path = substitute(path, '\(\\\|/\)$', '', 'g')
   " remove escaped spaces
   let path = substitute(path, '\ ', ' ', 'g')
   " convert slashes to backslashes
   let path = substitute(path, '/', '\', 'g')
  else
   let path= a:path
  endif
"  call Dret("netrw#WinPath <".path.">")
  return path
endfun

" ---------------------------------------------------------------------
"  s:ComposePath: Appends a new part to a path taking different systems into consideration {{{2
fun! s:ComposePath(base,subdir)
"  call Dfunc("s:ComposePath(base<".a:base."> subdir<".a:subdir.">)")

  if has("amiga")
"   call Decho("amiga")
   let ec = a:base[s:Strlen(a:base)-1]
   if ec != '/' && ec != ':'
    let ret = a:base . "/" . a:subdir
   else
    let ret = a:base . a:subdir
   endif

  elseif a:subdir =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows")
   let ret= a:subdir

  elseif a:base =~ '^\a:[/\\][^/\\]' && (has("win32") || has("win95") || has("win64") || has("win16"))
"   call Decho("windows")
   if a:base =~ '[/\\]$'
    let ret= a:base.a:subdir
   else
    let ret= a:base."/".a:subdir
   endif

  elseif a:base =~ '^\a\+://'
"   call Decho("remote linux/macos")
   let urlbase = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\1','')
   let curpath = substitute(a:base,'^\(\a\+://.\{-}/\)\(.*\)$','\2','')
   if a:subdir == '../'
    if curpath =~ '[^/]/[^/]\+/$'
     let curpath= substitute(curpath,'[^/]\+/$','','')
    else
     let curpath=""
    endif
    let ret= urlbase.curpath
   else
    let ret= urlbase.curpath.a:subdir
   endif
"   call Decho("urlbase<".urlbase.">")
"   call Decho("curpath<".curpath.">")
"   call Decho("ret<".ret.">")

  else
"   call Decho("local linux/macos")
   let ret = substitute(a:base."/".a:subdir,"//","/","g")
   if a:base =~ '^//'
    " keeping initial '//' for the benefit of network share listing support
    let ret= '/'.ret
   endif
   let ret= simplify(ret)
  endif

"  call Dret("s:ComposePath ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:FileReadable: o/s independent filereadable {{{2
fun! s:FileReadable(fname)
"  call Dfunc("s:FileReadable(fname<".a:fname.">)")

  if g:netrw_cygwin
   let ret= filereadable(substitute(a:fname,g:netrw_cygdrive.'/\(.\)','\1:/',''))
  else
   let ret= filereadable(a:fname)
  endif

"  call Dret("s:FileReadable ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
"  s:GetTempfile: gets a tempname that'll work for various o/s's {{{2
"                 Places correct suffix on end of temporary filename,
"                 using the suffix provided with fname
fun! s:GetTempfile(fname)
"  call Dfunc("s:GetTempfile(fname<".a:fname.">)")

  if !exists("b:netrw_tmpfile")
   " get a brand new temporary filename
   let tmpfile= tempname()
"   call Decho("tmpfile<".tmpfile."> : from tempname()")

   let tmpfile= substitute(tmpfile,'\','/','ge')
"   call Decho("tmpfile<".tmpfile."> : chgd any \\ -> /")

   " sanity check -- does the temporary file's directory exist?
   if !isdirectory(substitute(tmpfile,'[^/]\+$','','e'))
"    call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    keepj call netrw#ErrorMsg(s:ERROR,"your <".substitute(tmpfile,'[^/]\+$','','e')."> directory is missing!",2)
"    call Dret("s:GetTempfile getcwd<".getcwd().">")
    return ""
   endif

   " let netrw#NetSource() know about the tmpfile
   let s:netrw_tmpfile= tmpfile " used by netrw#NetSource() and netrw#NetrwBrowseX()
"   call Decho("tmpfile<".tmpfile."> s:netrw_tmpfile<".s:netrw_tmpfile.">")

   " o/s dependencies
   if g:netrw_cygwin != 0
    let tmpfile = substitute(tmpfile,'^\(\a\):',g:netrw_cygdrive.'/\1','e')
   elseif has("win32") || has("win95") || has("win64") || has("win16")
    if !exists("+shellslash") || !&ssl
     let tmpfile = substitute(tmpfile,'/','\','g')
    endif
   else
    let tmpfile = tmpfile
   endif
   let b:netrw_tmpfile= tmpfile
"   call Decho("o/s dependent fixed tempname<".tmpfile.">")
  else
   " re-use temporary filename
   let tmpfile= b:netrw_tmpfile
"   call Decho("tmpfile<".tmpfile."> re-using")
  endif

  " use fname's suffix for the temporary file
  if a:fname != ""
   if a:fname =~ '\.[^./]\+$'
"    call Decho("using fname<".a:fname.">'s suffix")
    if a:fname =~ '\.tar\.gz$' || a:fname =~ '\.tar\.bz2$' || a:fname =~ '\.tar\.xz$'
     let suffix = ".tar".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    elseif a:fname =~ '.txz$'
     let suffix = ".txz".substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    else
     let suffix = substitute(a:fname,'^.*\(\.[^./]\+\)$','\1','e')
    endif
"    call Decho("suffix<".suffix.">")
    let tmpfile= substitute(tmpfile,'\.tmp$','','e')
"    call Decho("chgd tmpfile<".tmpfile."> (removed any .tmp suffix)")
    let tmpfile .= suffix
"    call Decho("chgd tmpfile<".tmpfile."> (added ".suffix." suffix) netrw_fname<".b:netrw_fname.">")
    let s:netrw_tmpfile= tmpfile " supports netrw#NetSource()
   endif
  endif

"  call Decho("ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
"  call Dret("s:GetTempfile <".tmpfile.">")
  return tmpfile
endfun

" ---------------------------------------------------------------------
" s:MakeSshCmd: transforms input command using USEPORT HOSTNAME into {{{2
"               a correct command for use with a system() call
fun! s:MakeSshCmd(sshcmd)
"  call Dfunc("s:MakeSshCmd(sshcmd<".a:sshcmd.">) user<".s:user."> machine<".s:machine.">")
  if s:user == ""
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:machine,'')
  else
   let sshcmd = substitute(a:sshcmd,'\<HOSTNAME\>',s:user."@".s:machine,'')
  endif
  if exists("g:netrw_port") && g:netrw_port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.g:netrw_port,'')
  elseif exists("s:port") && s:port != ""
   let sshcmd= substitute(sshcmd,"USEPORT",g:netrw_sshport.' '.s:port,'')
  else
   let sshcmd= substitute(sshcmd,"USEPORT ",'','')
  endif
"  call Dret("s:MakeSshCmd <".sshcmd.">")
  return sshcmd
endfun

" ---------------------------------------------------------------------
" s:NetrwBMShow: {{{2
fun! s:NetrwBMShow()
"  call Dfunc("s:NetrwBMShow()")
  redir => bmshowraw
   menu
  redir END
  let bmshowlist = split(bmshowraw,'\n')
  if bmshowlist != []
   let bmshowfuncs= filter(bmshowlist,'v:val =~ "<SNR>\\d\\+_BMShow()"')
   if bmshowfuncs != []
    let bmshowfunc = substitute(bmshowfuncs[0],'^.*:\(call.*BMShow()\).*$','\1','')
    if bmshowfunc =~ '^call.*BMShow()'
     exe "sil! keepj ".bmshowfunc
    endif
   endif
  endif
"  call Dret("s:NetrwBMShow : bmshowfunc<".(exists("bmshowfunc")? bmshowfunc : 'n/a').">")
endfun

" ---------------------------------------------------------------------
" s:NetrwCursor: responsible for setting cursorline/cursorcolumn based upon g:netrw_cursor {{{2
fun! s:NetrwCursor()
  if !exists("w:netrw_liststyle")
   let w:netrw_liststyle= g:netrw_liststyle
  endif
"  call Dfunc("s:NetrwCursor() ft<".&ft."> liststyle=".w:netrw_liststyle." g:netrw_cursor=".g:netrw_cursor." s:netrw_usercuc=".s:netrw_usercuc." s:netrw_usercul=".s:netrw_usercul)

  if &ft != "netrw"
   " if the current window isn't a netrw directory listing window, then use user cursorline/column
   " settings.  Affects when netrw is used to read/write a file using scp/ftp/etc.
"   call Decho("case ft!=netrw: use user cul,cuc")
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc

  elseif g:netrw_cursor == 4
   " all styles: cursorline, cursorcolumn
"   call Decho("case g:netrw_cursor==4: setl cul cuc")
   setl cursorline
   setl cursorcolumn

  elseif g:netrw_cursor == 3
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, cursorcolumn
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==3 and wide: setl cul cuc")
    setl cursorline
    setl cursorcolumn
   else
"    call Decho("case g:netrw_cursor==3 and not wide: setl cul (use user's cuc)")
    setl cursorline
    let &l:cursorcolumn   = s:netrw_usercuc
   endif

  elseif g:netrw_cursor == 2
   " thin-long-tree: cursorline, user's cursorcolumn
   " wide          : cursorline, user's cursorcolumn
"   call Decho("case g:netrw_cursor==2: setl cuc (use user's cul)")
   let &l:cursorcolumn = s:netrw_usercuc
   setl cursorline

  elseif g:netrw_cursor == 1
   " thin-long-tree: user's cursorline, user's cursorcolumn
   " wide          : cursorline,        user's cursorcolumn
   let &l:cursorcolumn = s:netrw_usercuc
   if w:netrw_liststyle == s:WIDELIST
"    call Decho("case g:netrw_cursor==2 and wide: setl cul (use user's cuc)")
    setl cursorline
   else
"    call Decho("case g:netrw_cursor==2 and not wide: (use user's cul,cuc)")
    let &l:cursorline   = s:netrw_usercul
   endif

  else
   " all styles: user's cursorline, user's cursorcolumn
"   call Decho("default: (use user's cul,cuc)")
   let &l:cursorline   = s:netrw_usercul
   let &l:cursorcolumn = s:netrw_usercuc
  endif

"  call Dret("s:NetrwCursor : l:cursorline=".&l:cursorline." l:cursorcolumn=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:RestoreCursorline: restores cursorline/cursorcolumn to original user settings {{{2
fun! s:RestoreCursorline()
"  call Dfunc("s:RestoreCursorline() currently, cul=".&l:cursorline." cuc=".&l:cursorcolumn." win#".winnr()." buf#".bufnr("%"))
  if exists("s:netrw_usercul")
   let &l:cursorline   = s:netrw_usercul
  endif
  if exists("s:netrw_usercuc")
   let &l:cursorcolumn = s:netrw_usercuc
  endif
"  call Dret("s:RestoreCursorline : restored cul=".&l:cursorline." cuc=".&l:cursorcolumn)
endfun

" ---------------------------------------------------------------------
" s:NetrwDelete: Deletes a file. {{{2
"           Uses Steve Hall's idea to insure that Windows paths stay
"           acceptable.  No effect on Unix paths.
"  Examples of use:  let result= s:NetrwDelete(path)
fun! s:NetrwDelete(path)
"  call Dfunc("s:NetrwDelete(path<".a:path.">)")

  let path = netrw#WinPath(a:path)
  if !g:netrw_cygwin && (has("win32") || has("win95") || has("win64") || has("win16"))
   if exists("+shellslash")
    let sskeep= &shellslash
    setl noshellslash
    let result      = delete(path)
    let &shellslash = sskeep
   else
"    call Decho("exe let result= ".a:cmd."('".path."')")
    let result= delete(path)
   endif
  else
"   call Decho("let result= delete(".path.")")
   let result= delete(path)
  endif
  if result < 0
   keepj call netrw#ErrorMsg(s:WARNING,"delete(".path.") failed!",71)
  endif

"  call Dret("s:NetrwDelete ".result)
  return result
endfun

" ---------------------------------------------------------------------
" s:NetrwEnew: opens a new buffer, passes netrw buffer variables through {{{2
fun! s:NetrwEnew(...)
"  call Dfunc("s:NetrwEnew() a:0=".a:0." bufnr($)=".bufnr("$"))
"  call Decho("curdir<".((a:0>0)? a:1 : "")."> buf#".bufnr("%")."<".bufname("%").">")

  " grab a function-local-variable copy of buffer variables
"  call Decho("make function-local copy of netrw variables")
  if exists("b:netrw_bannercnt")      |let netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_browser_active") |let netrw_browser_active  = b:netrw_browser_active |endif
  if exists("b:netrw_cpf")            |let netrw_cpf             = b:netrw_cpf            |endif
  if exists("b:netrw_curdir")         |let netrw_curdir          = b:netrw_curdir         |endif
  if exists("b:netrw_explore_bufnr")  |let netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_indx")   |let netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_line")   |let netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")   |let netrw_explore_list    = b:netrw_explore_list   |endif
  if exists("b:netrw_explore_listlen")|let netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt")|let netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_fname")          |let netrw_fname           = b:netrw_fname          |endif
  if exists("b:netrw_lastfile")       |let netrw_lastfile        = b:netrw_lastfile       |endif
  if exists("b:netrw_liststyle")      |let netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_method")         |let netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_option")         |let netrw_option          = b:netrw_option         |endif
  if exists("b:netrw_prvdir")         |let netrw_prvdir          = b:netrw_prvdir         |endif

  keepj call s:NetrwOptionRestore("w:")
"  call Decho("generate a buffer with keepjumps keepalt enew!")
  let netrw_keepdiff= &l:diff
  noswapfile keepj keepalt enew!
  let &l:diff= netrw_keepdiff
"  call Decho("bufnr($)=".bufnr("$")." winnr($)=".winnr("$"))
  keepj call s:NetrwOptionSave("w:")

  " copy function-local-variables to buffer variable equivalents
"  call Decho("copy function-local variables back to buffer netrw variables")
  if exists("netrw_bannercnt")      |let b:netrw_bannercnt       = netrw_bannercnt      |endif
  if exists("netrw_browser_active") |let b:netrw_browser_active  = netrw_browser_active |endif
  if exists("netrw_cpf")            |let b:netrw_cpf             = netrw_cpf            |endif
  if exists("netrw_curdir")         |let b:netrw_curdir          = netrw_curdir         |endif
  if exists("netrw_explore_bufnr")  |let b:netrw_explore_bufnr   = netrw_explore_bufnr  |endif
  if exists("netrw_explore_indx")   |let b:netrw_explore_indx    = netrw_explore_indx   |endif
  if exists("netrw_explore_line")   |let b:netrw_explore_line    = netrw_explore_line   |endif
  if exists("netrw_explore_list")   |let b:netrw_explore_list    = netrw_explore_list   |endif
  if exists("netrw_explore_listlen")|let b:netrw_explore_listlen = netrw_explore_listlen|endif
  if exists("netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt = netrw_explore_mtchcnt|endif
  if exists("netrw_fname")          |let b:netrw_fname           = netrw_fname          |endif
  if exists("netrw_lastfile")       |let b:netrw_lastfile        = netrw_lastfile       |endif
  if exists("netrw_liststyle")      |let b:netrw_liststyle       = netrw_liststyle      |endif
  if exists("netrw_method")         |let b:netrw_method          = netrw_method         |endif
  if exists("netrw_option")         |let b:netrw_option          = netrw_option         |endif
  if exists("netrw_prvdir")         |let b:netrw_prvdir          = netrw_prvdir         |endif

  if a:0 > 0
   let b:netrw_curdir= a:1
   if b:netrw_curdir =~ '/$'
    if exists("w:netrw_liststyle") && w:netrw_liststyle == s:TREELIST
     file NetrwTreeListing
     setl bt=nowrite noswf bh=hide
     nno <silent> <buffer> [	:sil call <SID>TreeListMove('[')<cr>
     nno <silent> <buffer> ]	:sil call <SID>TreeListMove(']')<cr>
    else
     exe "sil! keepalt file ".fnameescape(b:netrw_curdir)
    endif
   endif
  endif

"  call Dret("s:NetrwEnew : buf#".bufnr("%")."<".bufname("%")."> expand(%)<".expand("%")."> expand(#)<".expand("#")."> bh=".&bh." win#".winnr()." winnr($)#".winnr("$"))
endfun

" ---------------------------------------------------------------------
" s:NetrwInsureWinVars: insure that a netrw buffer has its w: variables in spite of a wincmd v or s {{{2
fun! s:NetrwInsureWinVars()
"  call Dfunc("s:NetrwInsureWinVars() win#".winnr())
  if !exists("w:netrw_liststyle")
   let curbuf = bufnr("%")
   let curwin = winnr()
   let iwin   = 1
   while iwin <= winnr("$")
    exe iwin."wincmd w"
    if winnr() != curwin && bufnr("%") == curbuf && exists("w:netrw_liststyle")
     " looks like ctrl-w_s or ctrl-w_v was used to split a netrw buffer
     let winvars= w:
     break
    endif
    let iwin= iwin + 1
   endwhile
   exe "keepalt ".curwin."wincmd w"
   if exists("winvars")
"    call Decho("copying w#".iwin." window variables to w#".curwin)
    for k in keys(winvars)
     let w:{k}= winvars[k]
    endfor
   endif
  endif
"  call Dret("s:NetrwInsureWinVars win#".winnr())
endfun

" ---------------------------------------------------------------------
" s:NetrwLcd: handles changing the (local) directory {{{2
fun! s:NetrwLcd(newdir)
"  call Dfunc("s:NetrwLcd(newdir<".a:newdir.">)")

  try
   exe 'keepj sil lcd '.fnameescape(a:newdir)
  catch /^Vim\%((\a\+)\)\=:E344/
     " Vim's lcd fails with E344 when attempting to go above the 'root' of a Windows share.
     " Therefore, detect if a Windows share is present, and if E344 occurs, just settle at
     " 'root' (ie. '\').  The share name may start with either backslashes ('\\Foo') or 
     " forward slashes ('//Foo'), depending on whether backslashes have been converted to
     " forward slashes by earlier code; so check for both.
     if (has("win32") || has("win95") || has("win64") || has("win16")) && !g:netrw_cygwin
       if a:newdir =~ '^\\\\\w\+' || a:newdir =~ '^//\w\+'
         let dirname = '\'
	 exe 'keepj sil lcd '.fnameescape(dirname)
       endif
     endif
  catch /^Vim\%((\a\+)\)\=:E472/
   call netrw#ErrorMsg(s:ERROR,"unable to change directory to <".a:newdir."> (permissions?)",61)
   if exists("w:netrw_prvdir")
    let a:newdir= w:netrw_prvdir
   else
    call s:NetrwOptionRestore("w:")
"    call Decho("setl noma nomod nowrap")
    exe "setl ".g:netrw_bufsettings
"    call Decho(" ro=".&l:ro." ma=".&l:ma." mod=".&l:mod." wrap=".&l:wrap." (filename<".expand("%")."> win#".winnr()." ft<".&ft.">)")
    let a:newdir= dirname
"    call Dret("s:NetrwBrowse : reusing buffer#".(exists("bufnum")? bufnum : 'N/A')."<".dirname."> getcwd<".getcwd().">")
    return
   endif
  endtry

"  call Dret("s:NetrwLcd")
endfun

" ------------------------------------------------------------------------
" s:NetrwSaveWordPosn: used to keep cursor on same word after refresh, {{{2
" changed sorting, etc.  Also see s:NetrwRestoreWordPosn().
fun! s:NetrwSaveWordPosn()
"  call Dfunc("NetrwSaveWordPosn()")
  let s:netrw_saveword= '^'.fnameescape(getline('.')).'$'
"  call Dret("NetrwSaveWordPosn : saveword<".s:netrw_saveword.">")
endfun

" ---------------------------------------------------------------------
" s:NetrwRestoreWordPosn: used to keep cursor on same word after refresh, {{{2
"  changed sorting, etc.  Also see s:NetrwSaveWordPosn().
fun! s:NetrwRestoreWordPosn()
"  call Dfunc("NetrwRestoreWordPosn()")
  sil! call search(s:netrw_saveword,'w')
"  call Dret("NetrwRestoreWordPosn")
endfun

" ---------------------------------------------------------------------
" s:RestoreBufVars: {{{2
fun! s:RestoreBufVars()
"  call Dfunc("s:RestoreBufVars()")

  if exists("s:netrw_curdir")        |let b:netrw_curdir         = s:netrw_curdir        |endif
  if exists("s:netrw_lastfile")      |let b:netrw_lastfile       = s:netrw_lastfile      |endif
  if exists("s:netrw_method")        |let b:netrw_method         = s:netrw_method        |endif
  if exists("s:netrw_fname")         |let b:netrw_fname          = s:netrw_fname         |endif
  if exists("s:netrw_machine")       |let b:netrw_machine        = s:netrw_machine       |endif
  if exists("s:netrw_browser_active")|let b:netrw_browser_active = s:netrw_browser_active|endif

"  call Dret("s:RestoreBufVars")
endfun

" ---------------------------------------------------------------------
" s:RemotePathAnalysis: {{{2
fun! s:RemotePathAnalysis(dirname)
"  call Dfunc("s:RemotePathAnalysis(a:dirname<".a:dirname.">)")

  "                method   ://    user  @      machine      :port            /path
  let dirpat  = '^\(\w\{-}\)://\(\(\w\+\)@\)\=\([^/:#]\+\)\%([:#]\(\d\+\)\)\=/\(.*\)$'
  let s:method  = substitute(a:dirname,dirpat,'\1','')
  let s:user    = substitute(a:dirname,dirpat,'\3','')
  let s:machine = substitute(a:dirname,dirpat,'\4','')
  let s:port    = substitute(a:dirname,dirpat,'\5','')
  let s:path    = substitute(a:dirname,dirpat,'\6','')
  let s:fname   = substitute(s:path,'^.*/\ze.','','')
  if s:machine =~ '@'
   let dirpat    = '^\(.*\)@\(.\{-}\)$'
   let s:user    = s:user.'@'.substitute(s:machine,dirpat,'\1','')
   let s:machine = substitute(s:machine,dirpat,'\2','')
  endif

"  call Decho("set up s:method <".s:method .">")
"  call Decho("set up s:user   <".s:user   .">")
"  call Decho("set up s:machine<".s:machine.">")
"  call Decho("set up s:port   <".s:port.">")
"  call Decho("set up s:path   <".s:path   .">")
"  call Decho("set up s:fname  <".s:fname  .">")

"  call Dret("s:RemotePathAnalysis")
endfun

" ---------------------------------------------------------------------
" s:RemoteSystem: runs a command on a remote host using ssh {{{2
"                 Returns status
" Runs system() on
"    [cd REMOTEDIRPATH;] a:cmd
" Note that it doesn't do shellescape(a:cmd)!
fun! s:RemoteSystem(cmd)
"  call Dfunc("s:RemoteSystem(cmd<".a:cmd.">)")
  if !executable(g:netrw_ssh_cmd)
   keepj call netrw#ErrorMsg(s:ERROR,"g:netrw_ssh_cmd<".g:netrw_ssh_cmd."> is not executable!",52)
  elseif !exists("b:netrw_curdir")
   keepj call netrw#ErrorMsg(s:ERROR,"for some reason b:netrw_curdir doesn't exist!",53)
  else
   let cmd      = s:MakeSshCmd(g:netrw_ssh_cmd." USEPORT HOSTNAME")
   let remotedir= substitute(b:netrw_curdir,'^.*//[^/]\+/\(.*\)$','\1','')
   if remotedir != ""
    let cmd= cmd.' cd '.shellescape(remotedir).";"
   else
    let cmd= cmd.' '
   endif
   let cmd= cmd.a:cmd
"   call Decho("call system(".cmd.")")
   let ret= system(cmd)
  endif
"  call Dret("s:RemoteSystem ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:RestoreWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:RestoreWinVars()
"  call Dfunc("s:RestoreWinVars()")
  if exists("s:bannercnt")      |let w:netrw_bannercnt       = s:bannercnt      |unlet s:bannercnt      |endif
  if exists("s:col")            |let w:netrw_col             = s:col            |unlet s:col            |endif
  if exists("s:curdir")         |let w:netrw_curdir          = s:curdir         |unlet s:curdir         |endif
  if exists("s:explore_bufnr")  |let w:netrw_explore_bufnr   = s:explore_bufnr  |unlet s:explore_bufnr  |endif
  if exists("s:explore_indx")   |let w:netrw_explore_indx    = s:explore_indx   |unlet s:explore_indx   |endif
  if exists("s:explore_line")   |let w:netrw_explore_line    = s:explore_line   |unlet s:explore_line   |endif
  if exists("s:explore_listlen")|let w:netrw_explore_listlen = s:explore_listlen|unlet s:explore_listlen|endif
  if exists("s:explore_list")   |let w:netrw_explore_list    = s:explore_list   |unlet s:explore_list   |endif
  if exists("s:explore_mtchcnt")|let w:netrw_explore_mtchcnt = s:explore_mtchcnt|unlet s:explore_mtchcnt|endif
  if exists("s:fpl")            |let w:netrw_fpl             = s:fpl            |unlet s:fpl            |endif
  if exists("s:hline")          |let w:netrw_hline           = s:hline          |unlet s:hline          |endif
  if exists("s:line")           |let w:netrw_line            = s:line           |unlet s:line           |endif
  if exists("s:liststyle")      |let w:netrw_liststyle       = s:liststyle      |unlet s:liststyle      |endif
  if exists("s:method")         |let w:netrw_method          = s:method         |unlet s:method         |endif
  if exists("s:prvdir")         |let w:netrw_prvdir          = s:prvdir         |unlet s:prvdir         |endif
  if exists("s:treedict")       |let w:netrw_treedict        = s:treedict       |unlet s:treedict       |endif
  if exists("s:treetop")        |let w:netrw_treetop         = s:treetop        |unlet s:treetop        |endif
  if exists("s:winnr")          |let w:netrw_winnr           = s:winnr          |unlet s:winnr          |endif
"  call Dret("s:RestoreWinVars")
endfun

" ---------------------------------------------------------------------
" s:Rexplore: implements returning from a buffer to a netrw directory {{{2
"
"             s:SetRexDir() sets up <2-leftmouse> maps (if g:netrw_retmap
"             is true) and a command, :Rexplore, which call this function.
"
"             s:nbcd_curpos_{bufnr('%')} is set up by s:NetrwBrowseChgDir()
fun! s:NetrwRexplore(islocal,dirname)
  if exists("s:netrwdrag")
   return
  endif
"  call Dfunc("s:NetrwRexplore() w:netrw_rexlocal=".w:netrw_rexlocal." w:netrw_rexdir<".w:netrw_rexdir.">")
"  call Decho("ft=".&ft." win#".winnr()." w:netrw_rexfile<".(exists("w:netrw_rexfile")? w:netrw_rexfile : 'n/a').">")

  if &ft == "netrw" && exists("w:netrw_rexfile") && w:netrw_rexfile != ""
"   call Decho("in netrw buffer, will edit file<".w:netrw_rexfile.">")
   exe "e ".w:netrw_rexfile
   unlet w:netrw_rexfile
"   call Dret("s:NetrwRexplore returning from netrw to buf#".bufnr("%")."<".bufname("%").">  (ft=".&ft.")")
   return
  endif

  " record current file so :Rex can return to it from netrw
  let w:netrw_rexfile= expand("%")

  if !exists("w:netrw_rexlocal")
"   call Dret("s:NetrwRexplore w:netrw_rexlocal doesn't exist (".&ft.")")
   return
  endif
"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
  if w:netrw_rexlocal
   keepj call netrw#LocalBrowseCheck(w:netrw_rexdir)
  else
   keepj call s:NetrwBrowse(0,w:netrw_rexdir)
  endif
  if exists("s:initbeval")
   setl beval
  endif
  if exists("s:rexposn_".bufnr("%"))
"   call Decho("restore posn, then unlet s:rexposn_".bufnr('%'))
   keepj call netrw#RestorePosn(s:rexposn_{bufnr('%')})
   unlet s:rexposn_{bufnr('%')}
  else
"   call Decho("s:rexposn_".bufnr('%')." doesn't exist")
  endif

  if exists("s:explore_match")
   exe "2match netrwMarkFile /".s:explore_match."/"
  endif

"  call Decho("settings buf#".bufnr("%")."<".bufname("%").">: ".((&l:ma == 0)? "no" : "")."ma ".((&l:mod == 0)? "no" : "")."mod ".((&l:bl == 0)? "no" : "")."bl ".((&l:ro == 0)? "no" : "")."ro fo=".&l:fo)
"  call Dret("s:NetrwRexplore : ft=".&ft)
endfun

" ---------------------------------------------------------------------
" s:SaveBufVars: save selected b: variables to s: variables {{{2
"                use s:RestoreBufVars() to restore b: variables from s: variables
fun! s:SaveBufVars()
"  call Dfunc("s:SaveBufVars() buf#".bufnr("%"))

  if exists("b:netrw_curdir")        |let s:netrw_curdir         = b:netrw_curdir        |endif
  if exists("b:netrw_lastfile")      |let s:netrw_lastfile       = b:netrw_lastfile      |endif
  if exists("b:netrw_method")        |let s:netrw_method         = b:netrw_method        |endif
  if exists("b:netrw_fname")         |let s:netrw_fname          = b:netrw_fname         |endif
  if exists("b:netrw_machine")       |let s:netrw_machine        = b:netrw_machine       |endif
  if exists("b:netrw_browser_active")|let s:netrw_browser_active = b:netrw_browser_active|endif

"  call Dret("s:SaveBufVars")
endfun

" ---------------------------------------------------------------------
" s:SaveWinVars: (used by Explore() and NetrwSplit()) {{{2
fun! s:SaveWinVars()
"  call Dfunc("s:SaveWinVars() win#".winnr())
  if exists("w:netrw_bannercnt")      |let s:bannercnt       = w:netrw_bannercnt      |endif
  if exists("w:netrw_col")            |let s:col             = w:netrw_col            |endif
  if exists("w:netrw_curdir")         |let s:curdir          = w:netrw_curdir         |endif
  if exists("w:netrw_explore_bufnr")  |let s:explore_bufnr   = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_indx")   |let s:explore_indx    = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_line")   |let s:explore_line    = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_listlen")|let s:explore_listlen = w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_list")   |let s:explore_list    = w:netrw_explore_list   |endif
  if exists("w:netrw_explore_mtchcnt")|let s:explore_mtchcnt = w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_fpl")            |let s:fpl             = w:netrw_fpl            |endif
  if exists("w:netrw_hline")          |let s:hline           = w:netrw_hline          |endif
  if exists("w:netrw_line")           |let s:line            = w:netrw_line           |endif
  if exists("w:netrw_liststyle")      |let s:liststyle       = w:netrw_liststyle      |endif
  if exists("w:netrw_method")         |let s:method          = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let s:prvdir          = w:netrw_prvdir         |endif
  if exists("w:netrw_treedict")       |let s:treedict        = w:netrw_treedict       |endif
  if exists("w:netrw_treetop")        |let s:treetop         = w:netrw_treetop        |endif
  if exists("w:netrw_winnr")          |let s:winnr           = w:netrw_winnr          |endif
"  call Dret("s:SaveWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck()) {{{2
"   To allow separate windows to have their own activities, such as
"   Explore **/pattern, several variables have been made window-oriented.
"   However, when the user splits a browser window (ex: ctrl-w s), these
"   variables are not inherited by the new window.  SetBufWinVars() and
"   UseBufWinVars() get around that.
fun! s:SetBufWinVars()
"  call Dfunc("s:SetBufWinVars() win#".winnr())
  if exists("w:netrw_liststyle")      |let b:netrw_liststyle      = w:netrw_liststyle      |endif
  if exists("w:netrw_bannercnt")      |let b:netrw_bannercnt      = w:netrw_bannercnt      |endif
  if exists("w:netrw_method")         |let b:netrw_method         = w:netrw_method         |endif
  if exists("w:netrw_prvdir")         |let b:netrw_prvdir         = w:netrw_prvdir         |endif
  if exists("w:netrw_explore_indx")   |let b:netrw_explore_indx   = w:netrw_explore_indx   |endif
  if exists("w:netrw_explore_listlen")|let b:netrw_explore_listlen= w:netrw_explore_listlen|endif
  if exists("w:netrw_explore_mtchcnt")|let b:netrw_explore_mtchcnt= w:netrw_explore_mtchcnt|endif
  if exists("w:netrw_explore_bufnr")  |let b:netrw_explore_bufnr  = w:netrw_explore_bufnr  |endif
  if exists("w:netrw_explore_line")   |let b:netrw_explore_line   = w:netrw_explore_line   |endif
  if exists("w:netrw_explore_list")   |let b:netrw_explore_list   = w:netrw_explore_list   |endif
"  call Dret("s:SetBufWinVars")
endfun

" ---------------------------------------------------------------------
" s:SetRexDir: set directory for :Rexplore {{{2
fun! s:SetRexDir(islocal,dirname)
"  call Dfunc("s:SetRexDir(islocal=".a:islocal." dirname<".a:dirname.">)")
  let w:netrw_rexdir   = a:dirname
  let w:netrw_rexlocal = a:islocal
"  call Dret("s:SetRexDir : win#".winnr()." ".(a:islocal? "local" : "remote")." dir: ".a:dirname)
endfun

" ---------------------------------------------------------------------
" s:Strlen: this function returns the length of a string, even if its using multi-byte characters. {{{2
"           Solution from Nicolai Weibull, vim docs (:help strlen()),
"           Tony Mechelynck, and my own invention.
fun! s:Strlen(x)
"  "" call Dfunc("s:Strlen(x<".a:x."> g:Align_xstrlen=".g:Align_xstrlen.")")

  if v:version >= 703 && exists("*strdisplaywidth")
   let ret= strdisplaywidth(a:x)
 
  elseif type(g:Align_xstrlen) == 1
   " allow user to specify a function to compute the string length  (ie. let g:Align_xstrlen="mystrlenfunc")
   exe "let ret= ".g:Align_xstrlen."('".substitute(a:x,"'","''","g")."')"
 
  elseif g:Align_xstrlen == 1
   " number of codepoints (Latin a + combining circumflex is two codepoints)
   " (comment from TM, solution from NW)
   let ret= strlen(substitute(a:x,'.','c','g'))
 
  elseif g:Align_xstrlen == 2
   " number of spacing codepoints (Latin a + combining circumflex is one spacing
   " codepoint; a hard tab is one; wide and narrow CJK are one each; etc.)
   " (comment from TM, solution from TM)
   let ret=strlen(substitute(a:x, '.\Z', 'x', 'g'))
 
  elseif g:Align_xstrlen == 3
   " virtual length (counting, for instance, tabs as anything between 1 and
   " 'tabstop', wide CJK as 2 rather than 1, Arabic alif as zero when immediately
   " preceded by lam, one otherwise, etc.)
   " (comment from TM, solution from me)
   let modkeep= &l:mod
   exe "norm! o\<esc>"
   call setline(line("."),a:x)
   let ret= virtcol("$") - 1
   d
   keepj norm! k
   let &l:mod= modkeep
 
  else
   " at least give a decent default
    let ret= strlen(a:x)
  endif
"  "" call Dret("s:Strlen ".ret)
  return ret
endfun

" ---------------------------------------------------------------------
" s:TreeListMove: {{{2
fun! s:TreeListMove(dir)
"  call Dfunc("s:TreeListMove(dir<".a:dir.">)")
  let curline  = getline('.')
  let prvline  = (line(".") > 1)?         getline(line(".")-1) : ''
  let nxtline  = (line(".") < line("$"))? getline(line(".")+1) : ''
  let curindent= substitute(curline,'^\([| ]*\).\{-}$','\1','')
  let indentm1 = substitute(curindent,'^'.s:treedepthstring.' ','','')
"  call Decho("prvline  <".prvline."> #".line(".")-1)
"  call Decho("curline  <".curline."> #".line("."))
"  call Decho("nxtline  <".nxtline."> #".line(".")+1)
"  call Decho("curindent<".curindent.">")
"  call Decho("indentm1 <".indentm1.">")

  if curline !~ '/$'
"   call Decho('regfile')
   if     a:dir == '[' && prvline != ''
    keepj norm! 0
    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')    " search backwards from regular file
"    call Decho("regfile srch back: ".nl)
   elseif a:dir == ']' && nxtline != ''
    keepj norm! $
    let nl = search('^'.indentm1.'[^'.s:treedepthstring.']','We')     " search forwards from regular file
"    call Decho("regfile srch fwd: ".nl)
   endif

  elseif a:dir == '[' && prvline != ''
   keepj norm! 0
   let curline= line(".")
   let nl     = search('^'.curindent.'[^'.s:treedepthstring.']','bWe') " search backwards From directory, same indentation
"   call Decho("dir srch back ind: ".nl)
   if nl != 0
    if line(".") == curline-1
     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','bWe')     " search backwards from directory, indentation - 1
"     call Decho("dir srch back ind-1: ".nl)
    endif
   endif

  elseif a:dir == ']' && nxtline != ''
   keepj norm! $
   let curline = line(".")
   let nl      = search('^'.curindent.'[^'.s:treedepthstring.']','We') " search forwards from directory, same indentation
"   call Decho("dir srch fwd ind: ".nl)
   if nl != 0
    if line(".") == curline+1
     let nl= search('^'.indentm1.'[^'.s:treedepthstring.']','We')         " search forwards from directory, indentation - 1
"     call Decho("dir srch fwd ind-1: ".nl)
    endif
   endif

  endif

"  call Dret("s:TreeListMove")
endfun

" ---------------------------------------------------------------------
" s:UpdateBuffersMenu: does emenu Buffers.Refresh (but due to locale, the menu item may not be called that) {{{2
"                      The Buffers.Refresh menu calls s:BMShow(); unfortunately, that means that that function
"                      can't be called except via emenu.  But due to locale, that menu line may not be called
"                      Buffers.Refresh; hence, s:NetrwBMShow() utilizes a "cheat" to call that function anyway.
fun! s:UpdateBuffersMenu()
"  call Dfunc("s:UpdateBuffersMenu()")
  if has("gui") && has("menu") && has("gui_running") && &go =~# 'm' && g:netrw_menu
   try
    sil emenu Buffers.Refresh\ menu
   catch /^Vim\%((\a\+)\)\=:E/
    let v:errmsg= ""
    sil keepj call s:NetrwBMShow()
   endtry
  endif
"  call Dret("s:UpdateBuffersMenu")
endfun

" ---------------------------------------------------------------------
" s:UseBufWinVars: (used by NetrwBrowse() and LocalBrowseCheck() {{{2
"              Matching function to s:SetBufWinVars()
fun! s:UseBufWinVars()
"  call Dfunc("s:UseBufWinVars()")
  if exists("b:netrw_liststyle")       && !exists("w:netrw_liststyle")      |let w:netrw_liststyle       = b:netrw_liststyle      |endif
  if exists("b:netrw_bannercnt")       && !exists("w:netrw_bannercnt")      |let w:netrw_bannercnt       = b:netrw_bannercnt      |endif
  if exists("b:netrw_method")          && !exists("w:netrw_method")         |let w:netrw_method          = b:netrw_method         |endif
  if exists("b:netrw_prvdir")          && !exists("w:netrw_prvdir")         |let w:netrw_prvdir          = b:netrw_prvdir         |endif
  if exists("b:netrw_explore_indx")    && !exists("w:netrw_explore_indx")   |let w:netrw_explore_indx    = b:netrw_explore_indx   |endif
  if exists("b:netrw_explore_listlen") && !exists("w:netrw_explore_listlen")|let w:netrw_explore_listlen = b:netrw_explore_listlen|endif
  if exists("b:netrw_explore_mtchcnt") && !exists("w:netrw_explore_mtchcnt")|let w:netrw_explore_mtchcnt = b:netrw_explore_mtchcnt|endif
  if exists("b:netrw_explore_bufnr")   && !exists("w:netrw_explore_bufnr")  |let w:netrw_explore_bufnr   = b:netrw_explore_bufnr  |endif
  if exists("b:netrw_explore_line")    && !exists("w:netrw_explore_line")   |let w:netrw_explore_line    = b:netrw_explore_line   |endif
  if exists("b:netrw_explore_list")    && !exists("w:netrw_explore_list")   |let w:netrw_explore_list    = b:netrw_explore_list   |endif
"  call Dret("s:UseBufWinVars")
endfun

" ---------------------------------------------------------------------
" Settings Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo

" ------------------------------------------------------------------------
" Modelines: {{{1
" vim:ts=8 fdm=marker
                                                           usr/share/vim/vim74/autoload/netrwFileHandlers.vim                                                  0100644 0000000 0000000 00000023637 13050207306 020675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " netrwFileHandlers: contains various extension-based file handlers for
"                    netrw's browsers' x command ("eXecute launcher")
" Author:	Charles E. Campbell
" Date:		May 03, 2013
" Version:	11b	ASTRO-ONLY
" Copyright:    Copyright (C) 1999-2012 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrwFileHandlers.vim is provided *as is* and comes with no
"               warranty of any kind, either expressed or implied. In no
"               event will the copyright holder be liable for any damages
"               resulting from the use of this software.
"
" Rom 6:23 (WEB) For the wages of sin is death, but the free gift of God {{{1
"                is eternal life in Christ Jesus our Lord.

" ---------------------------------------------------------------------
" Load Once: {{{1
if exists("g:loaded_netrwFileHandlers") || &cp
 finish
endif
let g:loaded_netrwFileHandlers= "v11b"
if v:version < 702
 echohl WarningMsg
 echo "***warning*** this version of netrwFileHandlers needs vim 7.2"
 echohl Normal
 finish
endif
let s:keepcpo= &cpo
set cpo&vim

" ---------------------------------------------------------------------
" netrwFileHandlers#Invoke: {{{1
fun! netrwFileHandlers#Invoke(exten,fname)
"  call Dfunc("netrwFileHandlers#Invoke(exten<".a:exten."> fname<".a:fname.">)")
  let exten= a:exten
  " list of supported special characters.  Consider rcs,v --- that can be
  " supported with a NFH_rcsCOMMAv() handler
  if exten =~ '[@:,$!=\-+%?;~]'
   let specials= {
\   '@' : 'AT',
\   ':' : 'COLON',
\   ',' : 'COMMA',
\   '$' : 'DOLLAR',
\   '!' : 'EXCLAMATION',
\   '=' : 'EQUAL',
\   '-' : 'MINUS',
\   '+' : 'PLUS',
\   '%' : 'PERCENT',
\   '?' : 'QUESTION',
\   ';' : 'SEMICOLON',
\   '~' : 'TILDE'}
   let exten= substitute(a:exten,'[@:,$!=\-+%?;~]','\=specials[submatch(0)]','ge')
"   call Decho('fname<'.fname.'> done with dictionary')
  endif

  if a:exten != "" && exists("*NFH_".exten)
   " support user NFH_*() functions
"   call Decho("let ret= netrwFileHandlers#NFH_".a:exten.'("'.fname.'")')
   exe "let ret= NFH_".exten.'("'.a:fname.'")'
  elseif a:exten != "" && exists("*s:NFH_".exten)
   " use builtin-NFH_*() functions
"   call Decho("let ret= netrwFileHandlers#NFH_".a:exten.'("'.fname.'")')
   exe "let ret= s:NFH_".a:exten.'("'.a:fname.'")'
  endif

"  call Dret("netrwFileHandlers#Invoke 0 : ret=".ret)
  return 0
endfun

" ---------------------------------------------------------------------
" s:NFH_html: handles html when the user hits "x" when the {{{1
"                        cursor is atop a *.html file
fun! s:NFH_html(pagefile)
"  call Dfunc("s:NFH_html(".a:pagefile.")")

  let page= substitute(a:pagefile,'^','file://','')

  if executable("mozilla")
"   call Decho("executing !mozilla ".page)
   exe "!mozilla ".shellescape(page,1)
  elseif executable("netscape")
"   call Decho("executing !netscape ".page)
   exe "!netscape ".shellescape(page,1)
  else
"   call Dret("s:NFH_html 0")
   return 0
  endif

"  call Dret("s:NFH_html 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_htm: handles html when the user hits "x" when the {{{1
"                        cursor is atop a *.htm file
fun! s:NFH_htm(pagefile)
"  call Dfunc("s:NFH_htm(".a:pagefile.")")

  let page= substitute(a:pagefile,'^','file://','')

  if executable("mozilla")
"   call Decho("executing !mozilla ".page)
   exe "!mozilla ".shellescape(page,1)
  elseif executable("netscape")
"   call Decho("executing !netscape ".page)
   exe "!netscape ".shellescape(page,1)
  else
"   call Dret("s:NFH_htm 0")
   return 0
  endif

"  call Dret("s:NFH_htm 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_jpg: {{{1
fun! s:NFH_jpg(jpgfile)
"  call Dfunc("s:NFH_jpg(jpgfile<".a:jpgfile.">)")

  if executable("gimp")
   exe "silent! !gimp -s ".shellescape(a:jpgfile,1)
  elseif executable(expand("$SystemRoot")."/SYSTEM32/MSPAINT.EXE")
"   call Decho("silent! !".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".escape(a:jpgfile," []|'"))
   exe "!".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".shellescape(a:jpgfile,1)
  else
"   call Dret("s:NFH_jpg 0")
   return 0
  endif

"  call Dret("s:NFH_jpg 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_gif: {{{1
fun! s:NFH_gif(giffile)
"  call Dfunc("s:NFH_gif(giffile<".a:giffile.">)")

  if executable("gimp")
   exe "silent! !gimp -s ".shellescape(a:giffile,1)
  elseif executable(expand("$SystemRoot")."/SYSTEM32/MSPAINT.EXE")
   exe "silent! !".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".shellescape(a:giffile,1)
  else
"   call Dret("s:NFH_gif 0")
   return 0
  endif

"  call Dret("s:NFH_gif 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_png: {{{1
fun! s:NFH_png(pngfile)
"  call Dfunc("s:NFH_png(pngfile<".a:pngfile.">)")

  if executable("gimp")
   exe "silent! !gimp -s ".shellescape(a:pngfile,1)
  elseif executable(expand("$SystemRoot")."/SYSTEM32/MSPAINT.EXE")
   exe "silent! !".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".shellescape(a:pngfile,1)
  else
"   call Dret("s:NFH_png 0")
   return 0
  endif

"  call Dret("s:NFH_png 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_pnm: {{{1
fun! s:NFH_pnm(pnmfile)
"  call Dfunc("s:NFH_pnm(pnmfile<".a:pnmfile.">)")

  if executable("gimp")
   exe "silent! !gimp -s ".shellescape(a:pnmfile,1)
  elseif executable(expand("$SystemRoot")."/SYSTEM32/MSPAINT.EXE")
   exe "silent! !".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".shellescape(a:pnmfile,1)
  else
"   call Dret("s:NFH_pnm 0")
   return 0
  endif

"  call Dret("s:NFH_pnm 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_bmp: visualize bmp files {{{1
fun! s:NFH_bmp(bmpfile)
"  call Dfunc("s:NFH_bmp(bmpfile<".a:bmpfile.">)")

  if executable("gimp")
   exe "silent! !gimp -s ".a:bmpfile
  elseif executable(expand("$SystemRoot")."/SYSTEM32/MSPAINT.EXE")
   exe "silent! !".expand("$SystemRoot")."/SYSTEM32/MSPAINT ".shellescape(a:bmpfile,1)
  else
"   call Dret("s:NFH_bmp 0")
   return 0
  endif

"  call Dret("s:NFH_bmp 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_pdf: visualize pdf files {{{1
fun! s:NFH_pdf(pdf)
"  call Dfunc("s:NFH_pdf(pdf<".a:pdf.">)")
  if executable("gs")
   exe 'silent! !gs '.shellescape(a:pdf,1)
  elseif executable("pdftotext")
   exe 'silent! pdftotext -nopgbrk '.shellescape(a:pdf,1)
  else
"  call Dret("s:NFH_pdf 0")
   return 0
  endif

"  call Dret("s:NFH_pdf 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_doc: visualize doc files {{{1
fun! s:NFH_doc(doc)
"  call Dfunc("s:NFH_doc(doc<".a:doc.">)")

  if executable("oowriter")
   exe 'silent! !oowriter '.shellescape(a:doc,1)
   redraw!
  else
"  call Dret("s:NFH_doc 0")
   return 0
  endif

"  call Dret("s:NFH_doc 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_sxw: visualize sxw files {{{1
fun! s:NFH_sxw(sxw)
"  call Dfunc("s:NFH_sxw(sxw<".a:sxw.">)")

  if executable("oowriter")
   exe 'silent! !oowriter '.shellescape(a:sxw,1)
   redraw!
  else
"   call Dret("s:NFH_sxw 0")
   return 0
  endif

"  call Dret("s:NFH_sxw 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_xls: visualize xls files {{{1
fun! s:NFH_xls(xls)
"  call Dfunc("s:NFH_xls(xls<".a:xls.">)")

  if executable("oocalc")
   exe 'silent! !oocalc '.shellescape(a:xls,1)
   redraw!
  else
"  call Dret("s:NFH_xls 0")
   return 0
  endif

"  call Dret("s:NFH_xls 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_ps: handles PostScript files {{{1
fun! s:NFH_ps(ps)
"  call Dfunc("s:NFH_ps(ps<".a:ps.">)")
  if executable("gs")
"   call Decho("exe silent! !gs ".a:ps)
   exe "silent! !gs ".shellescape(a:ps,1)
   redraw!
  elseif executable("ghostscript")
"   call Decho("exe silent! !ghostscript ".a:ps)
   exe "silent! !ghostscript ".shellescape(a:ps,1)
   redraw!
  elseif executable("gswin32")
"   call Decho("exe silent! !gswin32 ".shellescape(a:ps,1))
   exe "silent! !gswin32 ".shellescape(a:ps,1)
   redraw!
  else
"   call Dret("s:NFH_ps 0")
   return 0
  endif

"  call Dret("s:NFH_ps 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_eps: handles encapsulated PostScript files {{{1
fun! s:NFH_eps(eps)
"  call Dfunc("s:NFH_eps()")
  if executable("gs")
   exe "silent! !gs ".shellescape(a:eps,1)
   redraw!
  elseif executable("ghostscript")
   exe "silent! !ghostscript ".shellescape(a:eps,1)
   redraw!
  elseif executable("ghostscript")
   exe "silent! !ghostscript ".shellescape(a:eps,1)
   redraw!
  elseif executable("gswin32")
   exe "silent! !gswin32 ".shellescape(a:eps,1)
   redraw!
  else
"   call Dret("s:NFH_eps 0")
   return 0
  endif
"  call Dret("s:NFH_eps 0")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_fig: handles xfig files {{{1
fun! s:NFH_fig(fig)
"  call Dfunc("s:NFH_fig()")
  if executable("xfig")
   exe "silent! !xfig ".a:fig
   redraw!
  else
"   call Dret("s:NFH_fig 0")
   return 0
  endif

"  call Dret("s:NFH_fig 1")
  return 1
endfun

" ---------------------------------------------------------------------
" s:NFH_obj: handles tgif's obj files {{{1
fun! s:NFH_obj(obj)
"  call Dfunc("s:NFH_obj()")
  if has("unix") && executable("tgif")
   exe "silent! !tgif ".a:obj
   redraw!
  else
"   call Dret("s:NFH_obj 0")
   return 0
  endif

"  call Dret("s:NFH_obj 1")
  return 1
endfun

let &cpo= s:keepcpo
unlet s:keepcpo
" ---------------------------------------------------------------------
"  Modelines: {{{1
"  vim: fdm=marker
                                                                                                 usr/share/vim/vim74/autoload/netrwSettings.vim                                                      0100644 0000000 0000000 00000023635 13050207306 020133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " netrwSettings.vim: makes netrw settings simpler
" Date:		Aug 27, 2013
" Maintainer:	Charles E Campbell <drchipNOSPAM at campbellfamily dot biz>
" Version:	14
" Copyright:    Copyright (C) 1999-2007 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrwSettings.vim is provided *as is* and comes with no
"               warranty of any kind, either expressed or implied. By using
"               this plugin, you agree that in no event will the copyright
"               holder be liable for any damages resulting from the use
"               of this software.
"
" Mat 4:23 (WEB) Jesus went about in all Galilee, teaching in their {{{1
"                synagogues, preaching the gospel of the kingdom, and healing
"                every disease and every sickness among the people.
" Load Once: {{{1
if exists("g:loaded_netrwSettings") || &cp
  finish
endif
let g:loaded_netrwSettings = "v14"
if v:version < 700
 echohl WarningMsg
 echo "***warning*** this version of netrwSettings needs vim 7.0"
 echohl Normal
 finish
endif

" ---------------------------------------------------------------------
" NetrwSettings: {{{1
fun! netrwSettings#NetrwSettings()
  " this call is here largely just to insure that netrw has been loaded
  call netrw#SavePosn()
  if !exists("g:loaded_netrw")
   echohl WarningMsg | echomsg "***sorry*** netrw needs to be loaded prior to using NetrwSettings" | echohl None
   return
  endif

  above wincmd s
  enew
  setlocal noswapfile bh=wipe
  set ft=vim
  file Netrw\ Settings

  " these variables have the following default effects when they don't
  " exist (ie. have not been set by the user in his/her .vimrc)
  if !exists("g:netrw_liststyle")
   let g:netrw_liststyle= 0
   let g:netrw_list_cmd= "ssh HOSTNAME ls -FLa"
  endif
  if !exists("g:netrw_silent")
   let g:netrw_silent= 0
  endif
  if !exists("g:netrw_use_nt_rcp")
   let g:netrw_use_nt_rcp= 0
  endif
  if !exists("g:netrw_ftp")
   let g:netrw_ftp= 0
  endif
  if !exists("g:netrw_ignorenetrc")
   let g:netrw_ignorenetrc= 0
  endif

  put ='+ ---------------------------------------------'
  put ='+  NetrwSettings:  by Charles E. Campbell'
  put ='+ Press <F1> with cursor atop any line for help'
  put ='+ ---------------------------------------------'
  let s:netrw_settings_stop= line(".")

  put =''
  put ='+ Netrw Protocol Commands'
  put = 'let g:netrw_dav_cmd           = '.g:netrw_dav_cmd
  put = 'let g:netrw_fetch_cmd         = '.g:netrw_fetch_cmd
  put = 'let g:netrw_ftp_cmd           = '.g:netrw_ftp_cmd
  put = 'let g:netrw_http_cmd          = '.g:netrw_http_cmd
  put = 'let g:netrw_rcp_cmd           = '.g:netrw_rcp_cmd
  put = 'let g:netrw_rsync_cmd         = '.g:netrw_rsync_cmd
  put = 'let g:netrw_scp_cmd           = '.g:netrw_scp_cmd
  put = 'let g:netrw_sftp_cmd          = '.g:netrw_sftp_cmd
  put = 'let g:netrw_ssh_cmd           = '.g:netrw_ssh_cmd
  let s:netrw_protocol_stop= line(".")
  put = ''

  put ='+Netrw Transfer Control'
  put = 'let g:netrw_cygwin            = '.g:netrw_cygwin
  put = 'let g:netrw_ftp               = '.g:netrw_ftp
  put = 'let g:netrw_ftpmode           = '.g:netrw_ftpmode
  put = 'let g:netrw_ignorenetrc       = '.g:netrw_ignorenetrc
  put = 'let g:netrw_sshport           = '.g:netrw_sshport
  put = 'let g:netrw_silent            = '.g:netrw_silent
  put = 'let g:netrw_use_nt_rcp        = '.g:netrw_use_nt_rcp
  put = 'let g:netrw_win95ftp          = '.g:netrw_win95ftp
  let s:netrw_xfer_stop= line(".")
  put =''
  put ='+ Netrw Messages'
  put ='let g:netrw_use_errorwindow    = '.g:netrw_use_errorwindow

  put = ''
  put ='+ Netrw Browser Control'
  if exists("g:netrw_altfile")
   put = 'let g:netrw_altfile   = '.g:netrw_altfile
  else
   put = 'let g:netrw_altfile   = 0'
  endif
  put = 'let g:netrw_alto              = '.g:netrw_alto
  put = 'let g:netrw_altv              = '.g:netrw_altv
  put = 'let g:netrw_banner            = '.g:netrw_banner
  if exists("g:netrw_bannerbackslash")
   put = 'let g:netrw_bannerbackslash   = '.g:netrw_bannerbackslash
  else
   put = '\" let g:netrw_bannerbackslash   = (not defined)'
  endif
  put = 'let g:netrw_browse_split      = '.g:netrw_browse_split
  if exists("g:netrw_browsex_viewer")
   put = 'let g:netrw_browsex_viewer   = '.g:netrw_browsex_viewer
  else
   put = '\" let g:netrw_browsex_viewer   = (not defined)'
  endif
  put = 'let g:netrw_compress          = '.g:netrw_compress
  if exists("g:Netrw_corehandler")
   put = 'let g:Netrw_corehandler      = '.g:Netrw_corehandler
  else
   put = '\" let g:Netrw_corehandler      = (not defined)'
  endif
  put = 'let g:netrw_ctags             = '.g:netrw_ctags
  put = 'let g:netrw_cursor            = '.g:netrw_cursor
  let decompressline= line("$")
  put = 'let g:netrw_decompress        = '.string(g:netrw_decompress)
  if exists("g:netrw_dynamic_maxfilenamelen")
   put = 'let g:netrw_dynamic_maxfilenamelen='.g:netrw_dynamic_maxfilenamelen
  else
   put = '\" let g:netrw_dynamic_maxfilenamelen= (not defined)'
  endif
  put = 'let g:netrw_dirhistmax        = '.g:netrw_dirhistmax
  put = 'let g:netrw_errorlvl          = '.g:netrw_errorlvl
  put = 'let g:netrw_fastbrowse        = '.g:netrw_fastbrowse
  let fnameescline= line("$")
  put = 'let g:netrw_fname_escape      = '.string(g:netrw_fname_escape)
  put = 'let g:netrw_ftp_browse_reject = '.g:netrw_ftp_browse_reject
  put = 'let g:netrw_ftp_list_cmd      = '.g:netrw_ftp_list_cmd
  put = 'let g:netrw_ftp_sizelist_cmd  = '.g:netrw_ftp_sizelist_cmd
  put = 'let g:netrw_ftp_timelist_cmd  = '.g:netrw_ftp_timelist_cmd
  let globescline= line("$")
  put = 'let g:netrw_glob_escape       = '.string(g:netrw_glob_escape)
  put = 'let g:netrw_hide              = '.g:netrw_hide
  if exists("g:netrw_home")
   put = 'let g:netrw_home              = '.g:netrw_home
  else
   put = '\" let g:netrw_home              = (not defined)'
  endif
  put = 'let g:netrw_keepdir           = '.g:netrw_keepdir
  put = 'let g:netrw_list_cmd          = '.g:netrw_list_cmd
  put = 'let g:netrw_list_hide         = '.g:netrw_list_hide
  put = 'let g:netrw_liststyle         = '.g:netrw_liststyle
  put = 'let g:netrw_localcopycmd      = '.g:netrw_localcopycmd
  put = 'let g:netrw_localmkdir        = '.g:netrw_localmkdir
  put = 'let g:netrw_localmovecmd      = '.g:netrw_localmovecmd
  put = 'let g:netrw_localrmdir        = '.g:netrw_localrmdir
  put = 'let g:netrw_maxfilenamelen    = '.g:netrw_maxfilenamelen
  put = 'let g:netrw_menu              = '.g:netrw_menu
  put = 'let g:netrw_mousemaps         = '.g:netrw_mousemaps
  put = 'let g:netrw_mkdir_cmd         = '.g:netrw_mkdir_cmd
  if exists("g:netrw_nobeval")
   put = 'let g:netrw_nobeval           = '.g:netrw_nobeval
  else
   put = '\" let g:netrw_nobeval           = (not defined)'
  endif
  put = 'let g:netrw_remote_mkdir      = '.g:netrw_remote_mkdir
  put = 'let g:netrw_preview           = '.g:netrw_preview
  put = 'let g:netrw_rename_cmd        = '.g:netrw_rename_cmd
  put = 'let g:netrw_retmap            = '.g:netrw_retmap
  put = 'let g:netrw_rm_cmd            = '.g:netrw_rm_cmd
  put = 'let g:netrw_rmdir_cmd         = '.g:netrw_rmdir_cmd
  put = 'let g:netrw_rmf_cmd           = '.g:netrw_rmf_cmd
  put = 'let g:netrw_sort_by           = '.g:netrw_sort_by
  put = 'let g:netrw_sort_direction    = '.g:netrw_sort_direction
  put = 'let g:netrw_sort_options      = '.g:netrw_sort_options
  put = 'let g:netrw_sort_sequence     = '.g:netrw_sort_sequence
  put = 'let g:netrw_special_syntax    = '.g:netrw_special_syntax
  put = 'let g:netrw_ssh_browse_reject = '.g:netrw_ssh_browse_reject
  put = 'let g:netrw_ssh_cmd           = '.g:netrw_ssh_cmd
  put = 'let g:netrw_scpport           = '.g:netrw_scpport
  put = 'let g:netrw_sepchr            = '.g:netrw_sepchr
  put = 'let g:netrw_sshport           = '.g:netrw_sshport
  put = 'let g:netrw_timefmt           = '.g:netrw_timefmt
  let tmpfileescline= line("$")
  put ='let g:netrw_tmpfile_escape...'
  put = 'let g:netrw_use_noswf         = '.g:netrw_use_noswf
  put = 'let g:netrw_xstrlen           = '.g:netrw_xstrlen
  put = 'let g:netrw_winsize           = '.g:netrw_winsize

  put =''
  put ='+ For help, place cursor on line and press <F1>'

  1d
  silent %s/^+/"/e
  res 99
  silent %s/= \([^0-9].*\)$/= '\1'/e
  silent %s/= $/= ''/e
  1

  call setline(decompressline,"let g:netrw_decompress        = ".substitute(string(g:netrw_decompress),"^'\\(.*\\)'$",'\1',''))
  call setline(fnameescline,  "let g:netrw_fname_escape      = '".escape(g:netrw_fname_escape,"'")."'")
  call setline(globescline,   "let g:netrw_glob_escape       = '".escape(g:netrw_glob_escape,"'")."'")
  call setline(tmpfileescline,"let g:netrw_tmpfile_escape    = '".escape(g:netrw_tmpfile_escape,"'")."'")

  set nomod

  nmap <buffer> <silent> <F1>                       :call NetrwSettingHelp()<cr>
  nnoremap <buffer> <silent> <leftmouse> <leftmouse>:call NetrwSettingHelp()<cr>
  let tmpfile= tempname()
  exe 'au BufWriteCmd	Netrw\ Settings	silent w! '.tmpfile.'|so '.tmpfile.'|call delete("'.tmpfile.'")|set nomod'
endfun

" ---------------------------------------------------------------------
" NetrwSettingHelp: {{{2
fun! NetrwSettingHelp()
"  call Dfunc("NetrwSettingHelp()")
  let curline = getline(".")
  if curline =~ '='
   let varhelp = substitute(curline,'^\s*let ','','e')
   let varhelp = substitute(varhelp,'\s*=.*$','','e')
"   call Decho("trying help ".varhelp)
   try
    exe "he ".varhelp
   catch /^Vim\%((\a\+)\)\=:E149/
   	echo "***sorry*** no help available for <".varhelp.">"
   endtry
  elseif line(".") < s:netrw_settings_stop
   he netrw-settings
  elseif line(".") < s:netrw_protocol_stop
   he netrw-externapp
  elseif line(".") < s:netrw_xfer_stop
   he netrw-variables
  else
   he netrw-browse-var
  endif
"  call Dret("NetrwSettingHelp")
endfun

" ---------------------------------------------------------------------
" Modelines: {{{1
" vim:ts=8 fdm=marker
                                                                                                   usr/share/vim/vim74/autoload/netrw_gitignore.vim                                                    0100644 0000000 0000000 00000005215 13050207306 020453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " netrw_gitignore#Hide: gitignore-based hiding
"  Function returns a string of comma separated patterns convenient for
"  assignment to `g:netrw_list_hide` option.
"  Function can take additional filenames as arguments, example:
"  netrw_gitignore#Hide('custom_gitignore1', 'custom_gitignore2')
"
" Usage examples:
"  let g:netrw_list_hide = netrw_gitignore#Hide()
"  let g:netrw_list_hide = netrw_gitignore#Hide() . 'more,hide,patterns'
"
" Copyright:    Copyright (C) 2013 Bruno Sutic {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               netrw_gitignore.vim is provided *as is* and comes with no
"               warranty of any kind, either expressed or implied. By using
"               this plugin, you agree that in no event will the copyright
"               holder be liable for any damages resulting from the use
"               of this software.
function! netrw_gitignore#Hide(...)
  let additional_files = a:000

  let default_files = ['.gitignore', '.git/info/exclude']

  " get existing global/system gitignore files
  let global_gitignore = expand(substitute(system("git config --global core.excludesfile"), '\n', '', 'g'))
  if global_gitignore !=# ''
    let default_files = add(default_files, global_gitignore)
  endif
  let system_gitignore = expand(substitute(system("git config --system core.excludesfile"), '\n', '', 'g'))
  if system_gitignore !=# ''
    let default_files = add(default_files, system_gitignore)
  endif

  " append additional files if given as function arguments
  if additional_files !=# []
    let files = extend(default_files, additional_files)
  else
    let files = default_files
  endif

  " keep only existing/readable files
  let gitignore_files = []
  for file in files
    if filereadable(file)
      let gitignore_files = add(gitignore_files, file)
    endif
  endfor

  " get contents of gitignore patterns from those files
  let gitignore_lines = []
  for file in gitignore_files
    for line in readfile(file)
      " filter empty lines and comments
      if line !~# '^#' && line !~# '^$'
        let gitignore_lines = add(gitignore_lines, line)
      endif
    endfor
  endfor

  " convert gitignore patterns to Netrw/Vim regex patterns
  let escaped_lines = []
  for line in gitignore_lines
    let escaped       = line
    let escaped       = substitute(escaped, '\.', '\\.', 'g')
    let escaped       = substitute(escaped, '*', '.*', 'g')
    let escaped_lines = add(escaped_lines, escaped)
  endfor

  return join(escaped_lines, ',')
endfunction
                                                                                                                                                                                                                                                                                                                                                                                   usr/share/vim/vim74/autoload/paste.vim                                                              0100644 0000000 0000000 00000002320 13050207306 016353  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim support file to help with paste mappings and menus
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2006 Jun 23

" Define the string to use for items that are present both in Edit, Popup and
" Toolbar menu.  Also used in mswin.vim and macmap.vim.

" Pasting blockwise and linewise selections is not possible in Insert and
" Visual mode without the +virtualedit feature.  They are pasted as if they
" were characterwise instead.  Add to that some tricks to leave the cursor in
" the right position, also for "gi".
if has("virtualedit")
  let paste#paste_cmd = {'n': ":call paste#Paste()<CR>"}
  let paste#paste_cmd['v'] = '"-c<Esc>' . paste#paste_cmd['n']
  let paste#paste_cmd['i'] = 'x<BS><Esc>' . paste#paste_cmd['n'] . 'gi'

  func! paste#Paste()
    let ove = &ve
    set ve=all
    normal! `^
    if @+ != ''
      normal! "+gP
    endif
    let c = col(".")
    normal! i
    if col(".") < c	" compensate for i<ESC> moving the cursor left
      normal! l
    endif
    let &ve = ove
  endfunc
else
  let paste#paste_cmd = {'n': "\"=@+.'xy'<CR>gPFx\"_2x"}
  let paste#paste_cmd['v'] = '"-c<Esc>gix<Esc>' . paste#paste_cmd['n'] . '"_x'
  let paste#paste_cmd['i'] = 'x<Esc>' . paste#paste_cmd['n'] . '"_s'
endif
                                                                                                                                                                                                                                                                                                                usr/share/vim/vim74/autoload/phpcomplete.vim                                                        0100644 0000000 0000000 00001233673 13050207306 017601  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim completion script
" Language:	PHP
" Maintainer:	Dávid Szabó ( complex857 AT gmail DOT com )
" Previous Maintainer:	Mikolaj Machowski ( mikmach AT wp DOT pl )
" URL: https://github.com/shawncplus/phpcomplete.vim
" Last Change:  2014 Oct 02
"
"	OPTIONS:
"
"		let g:phpcomplete_relax_static_constraint = 1/0  [default 0]
"			Enables completion for non-static methods when completing for static context (::).
"			This generates E_STRICT level warning, but php calls these methods nontheless.
"
"		let g:phpcomplete_complete_for_unknown_classes = 1/0 [default 0]
"			Enables completion of variables and functions in "everything under the sun" fashion
"			when completing for an instance or static class context but the code can't tell the class
"			or locate the file that it lives in.
"			The completion list generated this way is only filtered by the completion base
"			and generally not much more accurate then simple keyword completion.
"
"		let g:phpcomplete_search_tags_for_variables = 1/0 [default 0]
"			Enables use of tags when the plugin tries to find variables.
"			When enabled the plugin will search for the variables in the tag files with kind 'v',
"			lines like $some_var = new Foo; but these usually yield highly inaccurate results and
"			can	be fairly slow.
"
"		let g:phpcomplete_min_num_of_chars_for_namespace_completion = n [default 1]
"			This option controls the number of characters the user needs to type before
"			the tags will be searched for namespaces and classes in typed out namespaces in
"			"use ..." context. Setting this to 0 is not recommended because that means the code
"			have to scan every tag, and vim's taglist() function runs extremly slow with a
"			"match everything" pattern.
"
"		let g:phpcomplete_parse_docblock_comments = 1/0 [default 0]
"			When enabled the preview window's content will include information
"			extracted from docblock comments of the completions.
"			Enabling this option will add return types to the completion menu for functions too.
"
"		let g:phpcomplete_cache_taglists = 1/0 [default 1]
"			When enabled the taglist() lookups will be cached and subsequent searches
"			for the same pattern will not check the tagfiles any more, thus making the
"			lookups faster. Cache expiration is based on the mtimes of the tag files.
"
"	TODO:
"	- Switching to HTML (XML?) completion (SQL) inside of phpStrings
"	- allow also for XML completion <- better do html_flavor for HTML
"	  completion
"	- outside of <?php?> getting parent tag may cause problems. Heh, even in
"	  perfect conditions GetLastOpenTag doesn't cooperate... Inside of
"	  phpStrings this can be even a bonus but outside of <?php?> it is not the
"	  best situation

if !exists('g:phpcomplete_relax_static_constraint')
	let g:phpcomplete_relax_static_constraint = 0
endif

if !exists('g:phpcomplete_complete_for_unknown_classes')
	let g:phpcomplete_complete_for_unknown_classes = 0
endif

if !exists('g:phpcomplete_search_tags_for_variables')
	let g:phpcomplete_search_tags_for_variables = 0
endif

if !exists('g:phpcomplete_min_num_of_chars_for_namespace_completion')
	let g:phpcomplete_min_num_of_chars_for_namespace_completion = 1
endif

if !exists('g:phpcomplete_parse_docblock_comments')
	let g:phpcomplete_parse_docblock_comments = 0
endif

if !exists('g:phpcomplete_cache_taglists')
	let g:phpcomplete_cache_taglists = 1
endif

if !exists('s:cache_classstructures')
	let s:cache_classstructures = {}
endif

if !exists('s:cache_tags')
	let s:cache_tags = {}
endif

if !exists('s:cache_tags_checksum')
	let s:cache_tags_checksum = ''
endif

let s:script_path = fnamemodify(resolve(expand('<sfile>:p')), ':h')

function! phpcomplete#CompletePHP(findstart, base) " {{{
	if a:findstart
		unlet! b:php_menu
		" Check if we are inside of PHP markup
		let pos = getpos('.')
		let phpbegin = searchpairpos('<?', '', '?>', 'bWn',
				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')
		let phpend = searchpairpos('<?', '', '?>', 'Wn',
				\ 'synIDattr(synID(line("."), col("."), 0), "name") =~? "string\\|comment"')

		if phpbegin == [0,0] && phpend == [0,0]
			" We are outside of any PHP markup. Complete HTML
			let htmlbegin = htmlcomplete#CompleteTags(1, '')
			let cursor_col = pos[2]
			let base = getline('.')[htmlbegin : cursor_col]
			let b:php_menu = htmlcomplete#CompleteTags(0, base)
			return htmlbegin
		else
			" locate the start of the word
			let line = getline('.')
			let start = col('.') - 1
			let compl_begin = col('.') - 2
			while start >= 0 && line[start - 1] =~ '[\\a-zA-Z_0-9\x7f-\xff$]'
				let start -= 1
			endwhile
			let b:phpbegin = phpbegin
			let b:compl_context = phpcomplete#GetCurrentInstruction(line('.'), max([0, col('.') - 2]), phpbegin)

			return start
			" We can be also inside of phpString with HTML tags. Deal with
			" it later (time, not lines).
		endif
	endif


	" If exists b:php_menu it means completion was already constructed we
	" don't need to do anything more
	if exists("b:php_menu")
		return b:php_menu
	endif

	if !exists('g:php_builtin_functions')
		call phpcomplete#LoadData()
	endif

	" a:base is very short - we need context
	if exists("b:compl_context")
		let context = b:compl_context
		unlet! b:compl_context
		" chop of the "base" from the end of the current instruction
		if a:base != ""
			let context = substitute(context, '\s*[$a-zA-Z_0-9\x7f-\xff]*$', '', '')
		end
	end

	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(getline(0, line('.')))

	if context =~? '^use\s'
		return phpcomplete#CompleteUse(a:base)
	endif

	if context =~ '\(->\|::\)$'
		" {{{
		" Get name of the class
		let classname = phpcomplete#GetClassName(line('.'), context, current_namespace, imports)

		" Get location of class definition, we have to iterate through all
		if classname != ''
			if classname =~ '\'
				" split the last \ segment as a classname, everything else is the namespace
				let classname_parts = split(classname, '\')
				let namespace = join(classname_parts[0:-2], '\')
				let classname = classname_parts[-1]
			else
				let namespace = '\'
			endif
			let classlocation = phpcomplete#GetClassLocation(classname, namespace)
		else
			let classlocation = ''
		endif

		if classlocation != ''
			if classlocation == 'VIMPHP_BUILTINOBJECT' && has_key(g:php_builtin_classes, tolower(classname))
				return phpcomplete#CompleteBuiltInClass(context, classname, a:base)
			endif

			if filereadable(classlocation)
				let classfile = readfile(classlocation)
				let classcontent = ''
				let classcontent .= "\n".phpcomplete#GetClassContents(classlocation, classname)
				let sccontent = split(classcontent, "\n")
				let visibility = expand('%:p') == fnamemodify(classlocation, ':p') ? 'private' : 'public'

				return phpcomplete#CompleteUserClass(context, a:base, sccontent, visibility)
			endif
		endif

		return phpcomplete#CompleteUnknownClass(a:base, context)
		" }}}
	elseif context =~? 'implements'
		return phpcomplete#CompleteClassName(a:base, ['i'], current_namespace, imports)
	elseif context =~? 'extends\s\+.\+$'
		return ['implements']
	elseif context =~? 'extends'
		let kinds = context =~? 'class\s' ? ['c'] : ['i']
		return phpcomplete#CompleteClassName(a:base, kinds, current_namespace, imports)
	elseif context =~? 'class [a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
		" special case when you've typed the class keyword and the name too, only extends and implements allowed there
		return filter(['extends', 'implements'], 'stridx(v:val, a:base) == 0')
	elseif context =~? 'new'
		return phpcomplete#CompleteClassName(a:base, ['c'], current_namespace, imports)
	endif

	if a:base =~ '^\$'
		return phpcomplete#CompleteVariable(a:base)
	else
		return phpcomplete#CompleteGeneral(a:base, current_namespace, imports)
	endif
endfunction
" }}}

function! phpcomplete#CompleteUse(base) " {{{
	" completes builtin class names regadless of g:phpcomplete_min_num_of_chars_for_namespace_completion
	" completes namespaces from tags
	"   * requires patched ctags
	" completes classnames from tags within the already typed out namespace using the "namespace" field of tags
	"   * requires patched ctags

	let res = []

	" class and namespace names are always considered absoltute in use ... expressions, leading slash is not recommended
	" by the php manual, so we gonna get rid of that
	if a:base =~? '^\'
		let base = substitute(a:base, '^\', '', '')
	else
		let base = a:base
	endif

	let namespace_match_pattern  = substitute(base, '\\', '\\\\', 'g')
	let classname_match_pattern = matchstr(base, '[^\\]\+$')
	let namespace_for_class = substitute(substitute(namespace_match_pattern, '\\\\', '\\', 'g'), '\\*'.classname_match_pattern.'$', '', '')

	if len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
		if len(classname_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
			let tags = phpcomplete#GetTaglist('^\('.namespace_match_pattern.'\|'.classname_match_pattern.'\)')
		else
			let tags = phpcomplete#GetTaglist('^'.namespace_match_pattern)
		endif

		let patched_ctags_detected = 0
		let namespaced_matches = []
		let no_namespace_matches = []
		for tag in tags
			if has_key(tag, 'namespace')
				let patched_ctags_detected = 1
			endif
			if tag.kind ==? 'n' && tag.name =~? '^'.namespace_match_pattern
				let patched_ctags_detected = 1
				call add(namespaced_matches, {'word': tag.name, 'kind': 'n', 'menu': tag.filename, 'info': tag.filename })
			elseif has_key(tag, 'namespace') && (tag.kind ==? 'c' || tag.kind ==? 'i') && tag.namespace ==? namespace_for_class
				call add(namespaced_matches, {'word': namespace_for_class.'\'.tag.name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
			elseif (tag.kind ==? 'c' || tag.kind ==? 'i')
				call add(no_namespace_matches, {'word': namespace_for_class.'\'.tag.name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
			endif
		endfor
		" if it seems that the tags file have namespace informations we can safely throw
		" away namespaceless tag matches since we can be sure they are invalid
		if patched_ctags_detected
			no_namespace_matches = []
		endif
		let res += namespaced_matches + no_namespace_matches
	endif

	if base !~ '\'
		let builtin_classnames = filter(keys(copy(g:php_builtin_classnames)), 'v:val =~? "^'.classname_match_pattern.'"')
		for classname in builtin_classnames
			call add(res, {'word': g:php_builtin_classes[tolower(classname)].name, 'kind': 'c'})
		endfor
		let builtin_interfacenames = filter(keys(copy(g:php_builtin_interfacenames)), 'v:val =~? "^'.classname_match_pattern.'"')
		for interfacename in builtin_interfacenames
			call add(res, {'word': g:php_builtin_interfaces[tolower(interfacename)].name, 'kind': 'i'})
		endfor
	endif

	return res
endfunction
" }}}

function! phpcomplete#CompleteGeneral(base, current_namespace, imports) " {{{
	" Complete everything
	"  + functions,  DONE
	"  + keywords of language DONE
	"  + defines (constant definitions), DONE
	"  + extend keywords for predefined constants, DONE
	"  + classes (after new), DONE
	"  + limit choice after -> and :: to funcs and vars DONE

	" Internal solution for finding functions in current file.

	if a:base =~? '^\'
		let leading_slash = '\'
	else
		let leading_slash = ''
	endif

	let file = getline(1, '$')
	call filter(file,
				\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
	let jfile = join(file, ' ')
	let int_values = split(jfile, 'function\s\+')
	let int_functions = {}
	for i in int_values
		let f_name = matchstr(i,
					\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		if f_name =~? '^'.substitute(a:base, '\\', '\\\\', 'g')
			let f_args = matchstr(i,
						\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|$\)')
			let int_functions[f_name.'('] = f_args.')'
		endif
	endfor

	" Internal solution for finding constants in current file
	let file = getline(1, '$')
	call filter(file, 'v:val =~ "define\\s*("')
	let jfile = join(file, ' ')
	let int_values = split(jfile, 'define\s*(\s*')
	let int_constants = {}
	for i in int_values
		let c_name = matchstr(i, '\(["'']\)\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze\1')
		if c_name != '' && c_name =~# '^'.substitute(a:base, '\\', '\\\\', 'g')
			let int_constants[leading_slash.c_name] = ''
		endif
	endfor

	" Prepare list of functions from tags file
	let ext_functions  = {}
	let ext_constants  = {}
	let ext_classes    = {}
	let ext_interfaces = {}
	let ext_namespaces = {}

	let base = substitute(a:base, '^\\', '', '')
	let [tag_match_pattern, namespace_for_tag] = phpcomplete#ExpandClassName(a:base, a:current_namespace, a:imports)
	let namespace_match_pattern  = substitute((namespace_for_tag == '' ? '' : namespace_for_tag.'\').tag_match_pattern, '\\', '\\\\', 'g')

	let tags = []
	if len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion && len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion && tag_match_pattern != namespace_match_pattern
		let tags = phpcomplete#GetTaglist('\c^\('.tag_match_pattern.'\|'.namespace_match_pattern.'\)')
	elseif len(namespace_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
		let tags = phpcomplete#GetTaglist('\c^'.namespace_match_pattern)
	elseif len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
		let tags = phpcomplete#GetTaglist('\c^'.tag_match_pattern)
	endif

	for tag in tags
		if !has_key(tag, 'namespace') || tag.namespace ==? a:current_namespace || tag.namespace ==? namespace_for_tag
			if has_key(tag, 'namespace')
				let full_name = tag.namespace.'\'.tag.name " absolute namespaced name (without leading '\')

				let base_parts = split(a:base, '\')
				if len(base_parts) > 1
					let namespace_part = join(base_parts[0:-2], '\')
				else
					let namespace_part = ''
				endif
				let relative_name = (namespace_part == '' ? '' : namespace_part.'\').tag.name
			endif

			if tag.kind ==? 'n' && tag.name =~? '^'.namespace_match_pattern
				let info = tag.name.' - '.tag.filename
				" patched ctag provides absolute namespace names as tag name, namespace tags dont have namespace fields
				let full_name = tag.name

				let base_parts = split(a:base, '\')
				let full_name_parts = split(full_name, '\')
				if len(base_parts) > 1
					" the first segment could be a renamed import, take the first segment from the user provided input
					" so if it's a sub namespace of a renamed namespace, just use the typed in segments in place of the absolute path
					" for example:
					"     you have a namespace NS1\SUBNS as SUB
					"     you have a sub-sub-namespace NS1\SUBNS\SUBSUB
					"     typed in SUB\SU
					"     the tags will return NS1\SUBNS\SUBSUB
					"     the completion should be: SUB\SUBSUB by replacing the NS1\SUBSN to SUB as in the import
					if has_key(a:imports, base_parts[0]) && a:imports[base_parts[0]].kind == 'n'
						let import = a:imports[base_parts[0]]
						let relative_name = substitute(full_name, '^'.substitute(import.name, '\\', '\\\\', 'g'), base_parts[0], '')
					else
						let relative_name = strpart(full_name, stridx(full_name, a:base))
					endif
				else
					let relative_name = strpart(full_name, stridx(full_name, a:base))
				endif

				if leading_slash == ''
					let ext_namespaces[relative_name.'\'] = info
				else
					let ext_namespaces['\'.full_name.'\'] = info
				endif
			elseif tag.kind ==? 'f' && !has_key(tag, 'class') " class related functions (methods) completed elsewhere, only works with patched ctags
				if has_key(tag, 'signature')
					let prototype = tag.signature[1:-2] " drop the ()s around the string
				else
					let prototype = matchstr(tag.cmd,
								\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
				endif
				let info = prototype.') - '.tag.filename

				if !has_key(tag, 'namespace')
					let ext_functions[tag.name.'('] = info
				else
					if tag.namespace ==? namespace_for_tag
						if leading_slash == ''
							let ext_functions[relative_name.'('] = info
						else
							let ext_functions['\'.full_name.'('] = info
						endif
					endif
				endif
			elseif tag.kind ==? 'd'
				let info = ' - '.tag.filename
				if !has_key(tag, 'namespace')
					let ext_constants[tag.name] = info
				else
					if tag.namespace ==? namespace_for_tag
						if leading_slash == ''
							let ext_constants[relative_name] = info
						else
							let ext_constants['\'.full_name] = info
						endif
					endif
				endif
			elseif tag.kind ==? 'c' || tag.kind ==? 'i'
				let info = ' - '.tag.filename

				let key = ''
				if !has_key(tag, 'namespace')
					let key = tag.name
				else
					if tag.namespace ==? namespace_for_tag
						if leading_slash == ''
							let key = relative_name
						else
							let key = '\'.full_name
						endif
					endif
				endif

				if key != ''
					if tag.kind ==? 'c'
						let ext_classes[key] = info
					elseif tag.kind ==? 'i'
						let ext_interfaces[key] = info
					endif
				endif
			endif
		endif
	endfor

	let builtin_constants  = {}
	let builtin_classnames = {}
	let builtin_interfaces = {}
	let builtin_functions  = {}
	let builtin_keywords   = {}
	let base = substitute(a:base, '^\', '', '')
	if a:current_namespace == '\' || (a:base =~ '^\\' && a:base =~ '^\\[^\\]*$')

		" Add builtin class names
		for [classname, info] in items(g:php_builtin_classnames)
			if classname =~? '^'.base
				let builtin_classnames[leading_slash.g:php_builtin_classes[tolower(classname)].name] = info
			endif
		endfor
		for [interfacename, info] in items(g:php_builtin_interfacenames)
			if interfacename =~? '^'.base
				let builtin_interfaces[leading_slash.interfacename] = info
			endif
		endfor
	endif

	" Prepare list of constants from built-in constants
	for [constant, info] in items(g:php_constants)
		if constant =~# '^'.base
			let builtin_constants[leading_slash.constant] = info
		endif
	endfor

	if leading_slash == '' " keywords should not be completed when base starts with '\'
		" Treat keywords as constants
		for [constant, info] in items(g:php_keywords)
			if constant =~? '^'.a:base
				let builtin_keywords[constant] = info
			endif
		endfor
	endif

	for [function_name, info] in items(g:php_builtin_functions)
		if function_name =~? '^'.base
			let builtin_functions[leading_slash.function_name] = info
		endif
	endfor

	" All constants
	call extend(int_constants, ext_constants)

	" All functions
	call extend(int_functions, ext_functions)
	call extend(int_functions, builtin_functions)

	for [imported_name, import] in items(a:imports)
		if imported_name =~? '^'.base
			if import.kind ==? 'c'
				if import.builtin
					let builtin_classnames[imported_name] = ' '.import.name
				else
					let ext_classes[imported_name] = ' '.import.name.' - '.import.filename
				endif
			elseif import.kind ==? 'i'
				if import.builtin
					let builtin_interfaces[imported_name] = ' '.import.name
				else
					let ext_interfaces[imported_name] = ' '.import.name.' - '.import.filename
				endif
			endif

			" no builtin interfaces
			if import.kind == 'n'
				let ext_namespaces[imported_name.'\'] = ' '.import.name.' - '.import.filename
			endif
		end
	endfor

	let all_values = {}

	" Add functions found in this file
	call extend(all_values, int_functions)

	" Add namespaces from tags
	call extend(all_values, ext_namespaces)

	" Add constants from the current file
	call extend(all_values, int_constants)

	" Add built-in constants
	call extend(all_values, builtin_constants)

	" Add external classes
	call extend(all_values, ext_classes)

	" Add external interfaces
	call extend(all_values, ext_interfaces)

	" Add built-in classes
	call extend(all_values, builtin_classnames)

	" Add built-in interfaces
	call extend(all_values, builtin_interfaces)

	" Add php keywords
	call extend(all_values, builtin_keywords)

	let final_list = []
	let int_list = sort(keys(all_values))
	for i in int_list
		if has_key(ext_namespaces, i)
			let final_list += [{'word':i, 'kind':'n', 'menu': ext_namespaces[i], 'info': ext_namespaces[i]}]
		elseif has_key(int_functions, i)
			let final_list +=
						\ [{'word':i,
						\	'info':i.int_functions[i],
						\	'menu':int_functions[i],
						\	'kind':'f'}]
		elseif has_key(ext_classes, i) || has_key(builtin_classnames, i)
			let info = has_key(ext_classes, i) ? ext_classes[i] : builtin_classnames[i].' - builtin'
			let final_list += [{'word':i, 'kind': 'c', 'menu': info, 'info': i.info}]
		elseif has_key(ext_interfaces, i) || has_key(builtin_interfaces, i)
			let info = has_key(ext_interfaces, i) ? ext_interfaces[i] : builtin_interfaces[i].' - builtin'
			let final_list += [{'word':i, 'kind': 'i', 'menu': info, 'info': i.info}]
		elseif has_key(int_constants, i) || has_key(builtin_constants, i)
			let info = has_key(int_constants, i) ? int_constants[i] : ' - builtin'
			let final_list += [{'word':i, 'kind': 'd', 'menu': info, 'info': i.info}]
		else
			let final_list += [{'word':i}]
		endif
	endfor

	return final_list
endfunction
" }}}

function! phpcomplete#CompleteUnknownClass(base, context) " {{{
	let res = []

	if g:phpcomplete_complete_for_unknown_classes != 1
		return []
	endif

	if a:base =~ '^\$'
		let adddollar = '$'
	else
		let adddollar = ''
	endif

	let file = getline(1, '$')

	" Internal solution for finding object properties in current file.
	if a:context =~ '::'
		let variables = filter(deepcopy(file),
					\ 'v:val =~ "^\\s*\\(static\\|static\\s\\+\\(public\\|var\\)\\|\\(public\\|var\\)\\s\\+static\\)\\s\\+\\$"')
	elseif a:context =~ '->'
		let variables = filter(deepcopy(file),
					\ 'v:val =~ "^\\s*\\(public\\|var\\)\\s\\+\\$"')
	endif
	let jvars = join(variables, ' ')
	let svars = split(jvars, '\$')
	let int_vars = {}
	for i in svars
		let c_var = matchstr(i,
					\ '^\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		if c_var != ''
			let int_vars[adddollar.c_var] = ''
		endif
	endfor

	" Internal solution for finding functions in current file.
	call filter(deepcopy(file),
			\ 'v:val =~ "function\\s\\+&\\?[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*("')
	let jfile = join(file, ' ')
	let int_values = split(jfile, 'function\s\+')
	let int_functions = {}
	for i in int_values
		let f_name = matchstr(i,
				\ '^&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		let f_args = matchstr(i,
				\ '^&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|$\)')

		let int_functions[f_name.'('] = f_args.')'
	endfor

	" collect external functions from tags
	let ext_functions = {}
	let tags = phpcomplete#GetTaglist('^'.substitute(a:base, '^\$', '', ''))
	for tag in tags
		if tag.kind ==? 'f'
			let item = tag.name
			if has_key(tag, 'signature')
				let prototype = tag.signature[1:-2]
			else
				let prototype = matchstr(tag.cmd,
						\ 'function\s\+&\?[^[:space:]]\+\s*(\s*\zs.\{-}\ze\s*)\s*{\?')
			endif
			let ext_functions[item.'('] = prototype.') - '.tag['filename']
		endif
	endfor

	" All functions to one hash for later reference when deciding kind
	call extend(int_functions, ext_functions)

	let all_values = {}
	call extend(all_values, int_functions)
	call extend(all_values, int_vars) " external variables are already in
	call extend(all_values, g:php_builtin_object_functions)

	for m in sort(keys(all_values))
		if m =~ '\(^\|::\)'.a:base
			call add(res, m)
		endif
	endfor

	let start_list = res

	let final_list = []
	for i in start_list
		if has_key(int_vars, i)
			let class = ' '
			if all_values[i] != ''
				let class = i.' class '
			endif
			let final_list += [{'word':i, 'info':class.all_values[i], 'kind':'v'}]
		else
			let final_list +=
					\ [{'word':substitute(i, '.*::', '', ''),
					\	'info':i.all_values[i],
					\	'menu':all_values[i],
					\	'kind':'f'}]
		endif
	endfor
	return final_list
endfunction
" }}}

function! phpcomplete#CompleteVariable(base) " {{{
	let res = []

	" Internal solution for current file.
	let file = getline(1, '$')
	let jfile = join(file, ' ')
	let int_vals = split(jfile, '\ze\$')
	let int_vars = {}
	for i in int_vals
		if i =~? '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*=\s*new'
			let val = matchstr(i,
						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
		else
			let val = matchstr(i,
						\ '^\$[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
		endif
		if val != ''
			let int_vars[val] = ''
		endif
	endfor

	call extend(int_vars, g:php_builtin_vars)

	" ctags has support for PHP, use tags file for external variables
	if  g:phpcomplete_search_tags_for_variables
		let ext_vars = {}
		let tags = phpcomplete#GetTaglist('\C^'.substitute(a:base, '^\$', '', ''))
		for tag in tags
			if tag.kind ==? 'v'
				let item = tag.name
				let m_menu = ''
				if tag.cmd =~? tag['name'].'\s*=\s*new\s\+'
					let m_menu = matchstr(tag.cmd,
								\ '\c=\s*new\s\+\zs[a-zA-Z_0-9\x7f-\xff]\+\ze')
				endif
				let ext_vars['$'.item] = m_menu
			endif
		endfor
		call extend(int_vars, ext_vars)
	endif

	for m in sort(keys(int_vars))
		if m =~# '^\'.a:base
			call add(res, m)
		endif
	endfor

	let int_list = res

	let int_dict = []
	for i in int_list
		if int_vars[i] != ''
			let class = ' '
			if int_vars[i] != ''
				let class = i.' class '
			endif
			let int_dict += [{'word':i, 'info':class.int_vars[i], 'menu':int_vars[i], 'kind':'v'}]
		else
			let int_dict += [{'word':i, 'kind':'v'}]
		endif
	endfor

	return int_dict
endfunction
" }}}

function! phpcomplete#CompleteClassName(base, kinds, current_namespace, imports) " {{{
	let kinds = sort(a:kinds)
	" Complete class name
	let res = []
	if a:base =~? '^\'
		let leading_slash = '\'
		let base = substitute(a:base, '^\', '', '')
	else
		let leading_slash = ''
		let base = a:base
	endif

	" Internal solution for finding classes in current file.
	let file = getline(1, '$')
	let filterstr = ''

	if kinds == ['c', 'i']
		let filterstr = 'v:val =~? "\\(class\\|interface\\)\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
	elseif kinds == ['c']
		let filterstr = 'v:val =~? "class\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
	elseif kinds == ['i']
		let filterstr = 'v:val =~? "interface\\s\\+[a-zA-Z_\\x7f-\\xff][a-zA-Z_0-9\\x7f-\\xff]*\\s*"'
	endif

	call filter(file, filterstr)

	for line in file
		let c_name = matchstr(line, '\c\(class\|interface\)\s*\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*')
		let kind = (line =~? '^\s*class' ? 'c' : 'i')
		if c_name != '' && c_name =~? '^'.base
			call add(res, {'word': c_name, 'kind': kind})
		endif
	endfor

	" resolve the typed in part with namespaces (if theres a \ in it)
	let [tag_match_pattern, namespace_for_class] = phpcomplete#ExpandClassName(a:base, a:current_namespace, a:imports)

	let tags = []
	if len(tag_match_pattern) >= g:phpcomplete_min_num_of_chars_for_namespace_completion
		let tags = phpcomplete#GetTaglist('^'.tag_match_pattern)
	endif

	if len(tags)
		let base_parts = split(a:base, '\')
		if len(base_parts) > 1
			let namespace_part = join(base_parts[0:-2], '\').'\'
		else
			let namespace_part = ''
		endif
		let no_namespace_matches = []
		let namespaced_matches = []
		let seen_namespaced_tag = 0
		for tag in tags
			if has_key(tag, 'namespace')
				let seen_namespaced_tag = 1
			endif
			let relative_name = namespace_part.tag.name
			" match base without the namespace part for namespaced base but not namespaced tags, for tagfiles with old ctags
			if !has_key(tag, 'namespace') && index(kinds, tag.kind) != -1 && stridx(tolower(tag.name), tolower(base[len(namespace_part):])) == 0
				call add(no_namespace_matches, {'word': leading_slash.relative_name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
			endif
			if has_key(tag, 'namespace') && index(kinds, tag.kind) != -1 && tag.namespace ==? namespace_for_class
				let full_name = tag.namespace.'\'.tag.name " absolute namespaced name (without leading '\')
				call add(namespaced_matches, {'word': leading_slash == '\' ? leading_slash.full_name : relative_name, 'kind': tag.kind, 'menu': tag.filename, 'info': tag.filename })
			endif
		endfor
		" if there was a tag with namespace field, assume tag files with namespace support, so the matches
		" without a namespace field are in the global namespace so if there were namespace in the base
		" we should not add them to the matches
		if seen_namespaced_tag && namespace_part != ''
			let no_namespace_matches = []
		endif
		let res += no_namespace_matches + namespaced_matches
	endif

	" look for built in classnames and interfaces
	let base_parts = split(base, '\')
	if a:current_namespace == '\' || (leading_slash == '\' && len(base_parts) < 2)
		if index(kinds, 'c') != -1
			let builtin_classnames = filter(keys(copy(g:php_builtin_classnames)), 'v:val =~? "^'.substitute(a:base, '\\', '', 'g').'"')
			for classname in builtin_classnames
				let menu = ''
				" if we have a constructor for this class, add parameters as to the info
				if has_key(g:php_builtin_classes[tolower(classname)].methods, '__construct')
					let menu = g:php_builtin_classes[tolower(classname)]['methods']['__construct']['signature']
				endif
				call add(res, {'word': leading_slash.g:php_builtin_classes[tolower(classname)].name, 'kind': 'c', 'menu': menu})
			endfor
		endif

		if index(kinds, 'i') != -1
			let builtin_interfaces = filter(keys(copy(g:php_builtin_interfaces)), 'v:val =~? "^'.substitute(a:base, '\\', '', 'g').'"')
			for interfacename in builtin_interfaces
				call add(res, {'word': leading_slash.g:php_builtin_interfaces[interfacename]['name'], 'kind': 'i', 'menu': ''})
			endfor
		endif
	endif

	" add matching imported things
	for [imported_name, import] in items(a:imports)
		if imported_name =~? '^'.base && index(kinds, import.kind) != -1
			let menu = import.name.(import.builtin ? ' - builtin' : '')
			call add(res, {'word': imported_name, 'kind': import.kind, 'menu': menu})
		endif
	endfor

	let res = sort(res, 'phpcomplete#CompareCompletionRow')
	return res
endfunction
" }}}

function! phpcomplete#CompareCompletionRow(i1, i2) " {{{
	return a:i1.word == a:i2.word ? 0 : a:i1.word > a:i2.word ? 1 : -1
endfunction
" }}}

function! phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) " {{{
	" if theres no modifier, and no modifier is allowed and no modifier is required
	if len(a:modifiers) == 0 && len(a:required_modifiers) == 0
		return 1
	else
		" check if every requred modifier is present
		for required_modifier in a:required_modifiers
			if index(a:modifiers, required_modifier) == -1
				return 0
			endif
		endfor

		for modifier in a:modifiers
			" if the modifier is prohibited its a no match
			if index(a:prohibited_modifiers, modifier) != -1
				return 0
			endif
		endfor

		" anything that is not explicitly required or prohibited is allowed
		return 1
	endif
endfunction
" }}}

function! phpcomplete#CompleteUserClass(context, base, sccontent, visibility) " {{{
	let final_list = []
	let res  = []

	let required_modifiers = []
	let prohibited_modifiers = []

	if a:visibility == 'public'
		let prohibited_modifiers += ['private', 'protected']
	endif

	" limit based on context to static or normal methods
	let static_con = ''
	if a:context =~ '::$' && a:context !~? 'parent::$'
		if g:phpcomplete_relax_static_constraint != 1
			let required_modifiers += ['static']
		endif
	elseif a:context =~ '->$'
		let prohibited_modifiers += ['static']
	endif

	let all_function = filter(deepcopy(a:sccontent),
				\ 'v:val =~ "^\\s*\\(public\\s\\+\\|protected\\s\\+\\|private\\s\\+\\|final\\s\\+\\|abstract\\s\\+\\|static\\s\\+\\)*function"')

	let functions = []
	for i in all_function
		let modifiers = split(matchstr(tolower(i), '\zs.\+\zefunction'), '\s\+')
		if phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) == 1
			call add(functions, i)
		endif
	endfor

	let c_functions = {}
	let c_doc = {}
	for i in functions
		let f_name = matchstr(i,
					\ 'function\s*&\?\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		let f_args = matchstr(i,
					\ 'function\s*&\?[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\s*(\zs.\{-}\ze)\_s*\({\|\_$\)')
		if f_name != '' && stridx(f_name, '__') != 0
			let c_functions[f_name.'('] = f_args
			if g:phpcomplete_parse_docblock_comments
				let c_doc[f_name.'('] = phpcomplete#GetDocBlock(a:sccontent, 'function\s*&\?\<'.f_name.'\>')
			endif
		endif
	endfor

	" limit based on context to static or normal attributes
	if a:context =~ '::$' && a:context !~? 'parent::$'
		" variables must have static to be accessed as static unlike functions
		let required_modifiers += ['static']
	endif
	let all_variable = filter(deepcopy(a:sccontent),
					\ 'v:val =~ "^\\s*\\(var\\s\\+\\|public\\s\\+\\|protected\\s\\+\\|private\\s\\+\\|final\\s\\+\\|abstract\\s\\+\\|static\\s\\+\\)\\+\\$"')

	let variables = []
	for i in all_variable
		let modifiers = split(matchstr(tolower(i), '\zs.\+\ze\$'), '\s\+')
		if phpcomplete#EvaluateModifiers(modifiers, required_modifiers, prohibited_modifiers) == 1
			call add(variables, i)
		endif
	endfor

	let static_vars = split(join(variables, ' '), '\$')
	let c_variables = {}

	let var_index = 0
	for i in static_vars
		let c_var = matchstr(i,
					\ '^\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		if c_var != ''
			if a:context =~ '::$'
				let c_var = '$'.c_var
			endif
			let c_variables[c_var] = ''
			if g:phpcomplete_parse_docblock_comments && len(get(variables, var_index)) > 0
				let c_doc[c_var] = phpcomplete#GetDocBlock(a:sccontent, variables[var_index])
			endif
			let var_index += 1
		endif
	endfor

	let constants = filter(deepcopy(a:sccontent),
				\ 'v:val =~ "^\\s*const\\s\\+"')

	let jcons = join(constants, ' ')
	let scons = split(jcons, 'const')

	let c_constants = {}
	let const_index = 0
	for i in scons
		let c_con = matchstr(i,
					\ '^\s*\zs[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*\ze')
		if c_con != ''
			let c_constants[c_con] = ''
			if g:phpcomplete_parse_docblock_comments && len(get(constants, const_index)) > 0
				let c_doc[c_con] = phpcomplete#GetDocBlock(a:sccontent, constants[const_index])
			endif
			let const_index += 1
		endif
	endfor

	let all_values = {}
	call extend(all_values, c_functions)
	call extend(all_values, c_variables)
	call extend(all_values, c_constants)

	for m in sort(keys(all_values))
		if stridx(m, a:base) == 0
			call add(res, m)
		endif
	endfor

	let start_list = res

	let final_list = []
	for i in start_list
		let docblock = phpcomplete#ParseDocBlock(get(c_doc, i, ''))
		if has_key(c_variables, i)
			let final_list +=
						\ [{'word': i,
						\	'info':phpcomplete#FormatDocBlock(docblock),
						\	'menu':get(docblock.var, 'type', ''),
						\	'kind':'v'}]
		elseif has_key(c_constants, i)
			let info = phpcomplete#FormatDocBlock(docblock)
			if info != ''
				let info = "\n".info
			endif
			let final_list +=
						\ [{'word':i,
						\	'info':i.info,
						\	'menu':all_values[i],
						\	'kind':'d'}]
		else
			let return_type = get(docblock.return, 'type', '')
			if return_type != ''
				let return_type = ' | '.return_type
			endif
			let info = phpcomplete#FormatDocBlock(docblock)
			if info != ''
				let info = "\n".info
			endif
			let final_list +=
						\ [{'word':substitute(i, '.*::', '', ''),
						\	'info':i.all_values[i].')'.info,
						\	'menu':all_values[i].')'.return_type,
						\	'kind':'f'}]
		endif
	endfor

	return final_list
endfunction
" }}}

function! phpcomplete#CompleteBuiltInClass(context, classname, base) " {{{
	let class_info = g:php_builtin_classes[tolower(a:classname)]
	let res = []
	if a:context =~ '->$' " complete for everything instance related
		" methods
		for [method_name, method_info] in items(class_info.methods)
			if stridx(method_name, '__') != 0 && (a:base == '' || method_name =~? '^'.a:base)
				call add(res, {'word':method_name.'(', 'kind': 'f', 'menu': method_info.signature, 'info': method_info.signature })
			endif
		endfor
		" properties
		for [property_name, property_info] in items(class_info.properties)
			if a:base == '' || property_name =~? '^'.a:base
				call add(res, {'word':property_name, 'kind': 'v', 'menu': property_info.type, 'info': property_info.type })
			endif
		endfor
	elseif a:context =~ '::$' " complete for everything static
		" methods
		for [method_name, method_info] in items(class_info.static_methods)
			if a:base == '' || method_name =~? '^'.a:base
				call add(res, {'word':method_name.'(', 'kind': 'f', 'menu': method_info.signature, 'info': method_info.signature })
			endif
		endfor
		" properties
		for [property_name, property_info] in items(class_info.static_properties)
			if a:base == '' || property_name =~? '^'.a:base
				call add(res, {'word':property_name, 'kind': 'v', 'menu': property_info.type, 'info': property_info.type })
			endif
		endfor
		" constants
		for [constant_name, constant_info] in items(class_info.constants)
			if a:base == '' || constant_name =~? '^'.a:base
				call add(res, {'word':constant_name, 'kind': 'd', 'menu': constant_info, 'info': constant_info})
			endif
		endfor
	endif
	return res
endfunction
" }}}

function! phpcomplete#GetTaglist(pattern) " {{{
	let cache_checksum = ''
	if g:phpcomplete_cache_taglists == 1
		" build a string with  format of "<tagfile>:<mtime>$<tagfile2>:<mtime2>..."
		" to validate that the tags are not changed since the time we saved the results in cache
		for tagfile in sort(tagfiles())
			let cache_checksum .= fnamemodify(tagfile, ':p').':'.getftime(tagfile).'$'
		endfor

		if s:cache_tags_checksum != cache_checksum
			" tag file(s) changed
			" since we don't know where individual tags coming from when calling taglist() we zap the whole cache
			" no way to clear only the entries originating from the changed tag file
			let s:cache_tags = {}
		endif

		if has_key(s:cache_tags, a:pattern)
			return s:cache_tags[a:pattern]
		endif
	endif

	let tags = taglist(a:pattern)
	let s:cache_tags[a:pattern] = tags
	let has_key = has_key(s:cache_tags, a:pattern)
	let s:cache_tags_checksum = cache_checksum
	return tags
endfunction
" }}}

function! phpcomplete#GetCurrentInstruction(line_number, col_number, phpbegin) " {{{
	" locate the current instruction (up until the previous non comment or string ";" or php region start (<?php or <?) without newlines
	let col_number = a:col_number
	let line_number = a:line_number
	let line = getline(a:line_number)
	let current_char = -1
	let instruction = ''
	let parent_depth = 0
	let bracket_depth = 0
	let stop_chars = [
				\ '!', '@', '%', '^', '&',
				\ '*', '/', '-', '+', '=',
				\ ':', '>', '<', '.', '?',
				\ ';', '(', '|', '['
				\ ]

	let phpbegin_length = len(matchstr(getline(a:phpbegin[0]), '\zs<?\(php\)\?\ze'))
	let phpbegin_end = [a:phpbegin[0], a:phpbegin[1] - 1 + phpbegin_length]

	" will hold the first place where a coma could have ended the match
	let first_coma_break_pos = -1
	let next_char = len(line) < col_number ? line[col_number + 1] : ''

	while !(line_number == 1 && col_number == 1)
		if current_char != -1
			let next_char = current_char
		endif

		let current_char = line[col_number]
		let synIDName = synIDattr(synID(line_number, col_number + 1, 0), 'name')

		if col_number - 1 == -1
			let prev_line_number = line_number - 1
			let prev_line = getline(line_number - 1)
			let prev_col_number = strlen(prev_line)
		else
			let prev_line_number = line_number
			let prev_col_number = col_number - 1
			let prev_line = line
		endif
		let prev_char = prev_line[prev_col_number]

		" skip comments
		if synIDName =~? 'comment\|phpDocTags'
			let current_char = ''
		endif

		" break on the last char of the "and" and "or" operators
		if synIDName == 'phpOperator' && (current_char == 'r' || current_char == 'd')
			break
		endif

		" break on statements as "return" or "throws"
		if synIDName == 'phpStatement' || synIDName == 'phpException'
			break
		endif

		" if the current char should be considered
		if current_char != '' && parent_depth >= 0 && bracket_depth >= 0 && synIDName !~? 'comment\|string'
			" break if we are on a "naked" stop_char (operators, colon, openparent...)
			if index(stop_chars, current_char) != -1
				let do_break = 1
				" dont break does not look like a "->"
				if (prev_char == '-' && current_char == '>') || (current_char == '-' && next_char == '>')
					let do_break = 0
				endif
				" dont break if its looks like a "::"
				if (prev_char == ':' && current_char == ':') || (current_char == ':' && next_char == ':')
					let do_break = 0
				endif

				if do_break
					break
				endif
			endif

			" save the coma position for later use if theres a "naked" , possibly separating a parameter and it is not in a parented part
			if first_coma_break_pos == -1 && current_char == ','
				let first_coma_break_pos = len(instruction)
			endif
		endif

		" count nested darenthesis and brackets so we can tell if we need to break on a ';' or not (think of for (;;) loops)
		if synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
			if current_char == '('
				let parent_depth += 1
			elseif current_char == ')'
				let parent_depth -= 1

			elseif current_char == '['
				let bracket_depth += 1
			elseif current_char == ']'
				let bracket_depth -= 1
			endif
		endif

		" stop collecting chars if we see a function start { (think of first line in a function)
		if (current_char == '{' || current_char == '}') && synIDName =~? 'phpBraceFunc\|phpParent\|Delimiter'
			break
		endif

		" break if we are reached the php block start (<?php or <?)
		if [line_number, col_number] == phpbegin_end
			break
		endif

		let instruction = current_char.instruction

		" step a char or a line back if we are on the first column of the line already
		let col_number -= 1
		if col_number == -1
			let line_number -= 1
			let line = getline(line_number)
			let col_number = strlen(line)
		endif
	endwhile

	" strip leading whitespace
	let instruction = substitute(instruction, '^\s\+', '', '')

	" there were a "naked" coma in the instruction
	if first_coma_break_pos != -1
		if instruction !~? '^use' && instruction !~? '^class' " use ... statements and class delcarations should not be broken up by comas
			let pos = (-1 * first_coma_break_pos) + 1
			let instruction = instruction[pos :]
		endif
	endif

	" HACK to remove one line conditionals from code like "if ($foo) echo 'bar'"
	" what the plugin really need is a proper php tokenizer
	if instruction =~? '\c^\(if\|while\|foreach\|for\)\s*('
		" clear everything up until the first (
		let instruction = substitute(instruction, '^\(if\|while\|foreach\|for\)\s*(\s*', '', '')

		" lets iterate trough the instruction until we can find the pair for the opening (
		let i = 0
		let depth = 1
		while i < len(instruction)
			if instruction[i] == '('
				let depth += 1
			endif
			if instruction[i] == ')'
				let depth -= 1
			endif
			if depth == 0
				break
			end
			let i += 1
		endwhile
		let instruction = instruction[i + 1 : len(instruction)]
	endif

	" trim whitespace from the ends
	let instruction = substitute(instruction, '\v^(^\s+)|(\s+)$', '', 'g')

	return instruction
endfunction " }}}

function! phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, imports, methodstack) " {{{
	" Tries to get the classname and namespace for a chained method call like:
	"	$this->foo()->bar()->baz()->

	let classname_candidate = a:classname_candidate
	let class_candidate_namespace = a:class_candidate_namespace
	let methodstack = a:methodstack
	let unknown_result = ['', '']
	let prev_method_is_array = (methodstack[0] =~ '\v^[^([]+\[' ? 1 : 0)
	let classname_candidate_is_array = (classname_candidate =~ '\[\]$' ? 1 : 0)

	if prev_method_is_array
		if classname_candidate_is_array
			let classname_candidate = substitute(classname_candidate, '\[\]$', '', '')
		else
			return unknown_result
		endif
	endif

	if (len(methodstack) == 1)
		let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, a:imports)
		return [classname_candidate, class_candidate_namespace]
	else
		call remove(methodstack, 0)
		let method_is_array = (methodstack[0] =~ '\v^[^[]+\[' ? 1 : 0)
		let method = matchstr(methodstack[0], '\v^\$*\zs[^[(]+\ze')

		let classlocation = phpcomplete#GetClassLocation(classname_candidate, class_candidate_namespace)

		if classlocation == 'VIMPHP_BUILTINOBJECT' && has_key(g:php_builtin_classes, tolower(classname_candidate))
			let class_info = g:php_builtin_classes[tolower(classname_candidate)]
			if has_key(class_info['methods'], method)
				return phpcomplete#GetCallChainReturnType(class_info['methods'][method].return_type, '\', a:imports, methodstack)
			endif
			if has_key(class_info['properties'], method)
				return phpcomplete#GetCallChainReturnType(class_info['properties'][method].type, '\', a:imports, methodstack)
			endif
			if has_key(class_info['static_methods'], method)
				return phpcomplete#GetCallChainReturnType(class_info['static_methods'][method].return_type, '\', a:imports, methodstack)
			endif
			if has_key(class_info['static_properties'], method)
				return phpcomplete#GetCallChainReturnType(class_info['static_properties'][method].type, '\', a:imports, methodstack)
			endif

			return unknown_result

		elseif classlocation != '' && filereadable(classlocation)
			" Read the next method from the stack and extract only the name

			let classcontents = phpcomplete#GetCachedClassContents(classlocation, classname_candidate)

			" Get Structured information of all classes and subclasses including namespace and includes
			" try to find the method's return type in docblock comment
			for classstructure in classcontents
				let doclock_target_pattern = 'function\s\+&\?'.method.'\|\(public\|private\|protected\|var\).\+\$'.method
				let doc_str = phpcomplete#GetDocBlock(split(classstructure.content, '\n'), doclock_target_pattern)
				if doc_str != ''
					break
				endif
			endfor
			if doc_str != ''
				let docblock = phpcomplete#ParseDocBlock(doc_str)
				if has_key(docblock.return, 'type') || has_key(docblock.var, 'type')
					let type = has_key(docblock.return, 'type') ? docblock.return.type : docblock.var.type

					" there's a namespace in the type, threat the type as FQCN
					if type =~ '\\'
						let parts = split(substitute(type, '^\\', '', ''), '\')
						let class_candidate_namespace = join(parts[0:-2], '\')
						let classname_candidate = parts[-1]
						" check for renamed namepsace in imports
						if has_key(classstructure.imports, class_candidate_namespace)
							let class_candidate_namespace = classstructure.imports[class_candidate_namespace].name
						endif
					else
						" no namespace in the type, threat it as a relative classname
						let returnclass = type
						if has_key(classstructure.imports, returnclass)
							if has_key(classstructure.imports[returnclass], 'namespace')
								let fullnamespace = classstructure.imports[returnclass].namespace
							else
								let fullnamespace = class_candidate_namespace
							endif
						else
							let fullnamespace = class_candidate_namespace
						endif
						" make @return self, static, $this the same way
						" (not exactly what php means by these)
						if returnclass == 'self' || returnclass == 'static' || returnclass == '$this'
							let classname_candidate = a:classname_candidate
							let class_candidate_namespace = a:class_candidate_namespace
						else
							let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(returnclass, fullnamespace, a:imports)
						endif
					endif

					return phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, a:imports, methodstack)
				endif
			endif

			return unknown_result
		else
			return unknown_result
		endif
	endif
endfunction " }}}

function! phpcomplete#GetMethodStack(line) " {{{
	let methodstack = []
	let i = 0
	let end = len(a:line)

	let current_part = ''

	let parent_depth = 0
	let in_string = 0
	let string_start = ''

	let next_char = ''

	while i	< end
		let current_char = a:line[i]
		let next_char = i + 1 < end ? a:line[i + 1] : ''
		let prev_char = i >= 1 ? a:line[i - 1] : ''
		let prev_prev_char = i >= 2 ? a:line[i - 2] : ''

		if in_string == 0 && parent_depth == 0 && ((current_char == '-' && next_char == '>') || (current_char == ':' && next_char == ':'))
			call add(methodstack, current_part)
			let current_part = ''
			let i += 2
			continue
		endif

		" if it's looks like a string
		if current_char == "'" || current_char == '"'
			" and it is not escaped
			if prev_char != '\' || (prev_char == '\' && prev_prev_char == '\')
				" and we are in a string already
				if in_string
					" and that string started with this char too
					if current_char == string_start
						" clear the string mark
						let in_string = 0
					endif
				else " ... and we are not in a string
					" set the string mark
					let in_string = 1
					let string_start = current_char
				endif
			endif
		endif

		if !in_string && a:line[i] == '('
			let parent_depth += 1
		endif
		if !in_string && a:line[i] == ')'
			let parent_depth -= 1
		endif

		let current_part .= current_char
		let i += 1
	endwhile

	" add the last remaining part, this can be an empty string and this is expected
	" the empty string represents the completion base (which happen to be an empty string)
	if current_part != ''
		call add(methodstack, current_part)
	endif

	return methodstack
endfunction
" }}}

function! phpcomplete#GetClassName(start_line, context, current_namespace, imports) " {{{
	" Get class name
	" Class name can be detected in few ways:
	" @var $myVar class
	" @var class $myVar
	" in the same line (php 5.4 (new Class)-> syntax)
	" line above
	" or line in tags file

	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
	let function_name_pattern = '[a-zA-Z_\x7f-\xff][a-zA-Z_0-9\x7f-\xff]*'
	let function_invocation_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*('
	let variable_name_pattern = '\$[a-zA-Z_\x7f-\xff][a-zA-Z0-9_\x7f-\xff]*'

	let classname_candidate = ''
	let class_candidate_namespace = a:current_namespace
	let class_candidate_imports = a:imports
	let methodstack = phpcomplete#GetMethodStack(a:context)

	if a:context =~? '\$this->' || a:context =~? '\(self\|static\)::' || a:context =~? 'parent::'
		let i = 1
		while i < a:start_line
			let line = getline(a:start_line - i)

			" Don't complete self:: or $this if outside of a class
			" (assumes correct indenting)
			if line =~ '^}'
				return ''
			endif

			if line =~? '\v^\s*(abstract\s+|final\s+)*\s*class'
				let class_name = matchstr(line, '\c\s*class\s*\zs'.class_name_pattern.'\ze')
				let extended_class = matchstr(line, '\cclass\s\+'.class_name_pattern.'\s\+extends\s\+\zs'.class_name_pattern.'\ze')

				let classname_candidate = a:context =~? 'parent::' ? extended_class : class_name
			else
				let i += 1
				continue
			endif

			if classname_candidate != ''
				let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
				" return absolute classname, without leading \
				return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
			endif
		endwhile
	elseif a:context =~? '(\s*new\s\+'.class_name_pattern.'\s*)->'
		let classname_candidate = matchstr(a:context, '\cnew\s\+\zs'.class_name_pattern.'\ze')
		let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
		" return absolute classname, without leading \
		return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
	elseif get(methodstack, 0) =~# function_invocation_pattern
		let function_name = matchstr(methodstack[0], '^\s*\zs'.function_name_pattern)
		let function_file = phpcomplete#GetFunctionLocation(function_name, a:current_namespace)

		if function_file == 'VIMPHP_BUILTINFUNCTION'
			" built in function, grab the return type from the info string
			let return_type = matchstr(g:php_builtin_functions[function_name.'('], '\v\|\s+\zs.+$')
			let classname_candidate = return_type
			let class_candidate_namespace = '\'
		elseif function_file != '' && filereadable(function_file)
			let file_lines = readfile(function_file)
			let docblock_str = phpcomplete#GetDocBlock(file_lines, 'function\s*&\?\<'.function_name.'\>')
			let docblock = phpcomplete#ParseDocBlock(docblock_str)
			if has_key(docblock.return, 'type')
				let classname_candidate = docblock.return.type
				let [class_candidate_namespace, function_imports] = phpcomplete#GetCurrentNameSpace(file_lines)
				" try to expand the classname of the returned type with the context got from the function's source file

				let [classname_candidate, unused] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, function_imports)
			endif
		endif
		if classname_candidate != ''
			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
			" return absolute classname, without leading \
			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
		endif
	else
		" extract the variable name from the context
		let object = methodstack[0]
		let object_is_array = (object =~ '\v^[^[]+\[' ? 1 : 0)
		let object = matchstr(object, variable_name_pattern)

		let function_boundary = phpcomplete#GetCurrentFunctionBoundaries()
		let search_end_line = max([1, function_boundary[0][0]])
		" -1 makes us ignore the current line (where the completion was invoked
		let lines = reverse(getline(search_end_line, line('.') - 1))

		" check Constant lookup
		let constant_object = matchstr(a:context, '\zs'.class_name_pattern.'\ze::')
		if constant_object != ''
			let classname_candidate = constant_object
		endif

		if classname_candidate == ''
			" scan the file backwards from current line for explicit type declaration (@var $variable Classname)
			for line in lines
				" in file lookup for /* @var $foo Class */
				if line =~# '@var\s\+'.object.'\s\+'.class_name_pattern
					let classname_candidate = matchstr(line, '@var\s\+'.object.'\s\+\zs'.class_name_pattern.'\(\[\]\)\?')
					let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
					break
				endif
				" in file lookup for /* @var Class $foo */
				if line =~# '@var\s\+'.class_name_pattern.'\s\+'.object
					let classname_candidate = matchstr(line, '@var\s\+\zs'.class_name_pattern.'\(\[\]\)\?\ze'.'\s\+'.object)
					let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
					break
				endif
			endfor
		endif

		if classname_candidate != ''
			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
			" return absolute classname, without leading \
			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
		endif
		" scan the file backwards from the current line
		let i = 1
		for line in lines " {{{
			" do in-file lookup of $var = new Class
			if line =~# '^\s*'.object.'\s*=\s*new\s\+'.class_name_pattern && !object_is_array
				let classname_candidate = matchstr(line, object.'\c\s*=\s*new\s*\zs'.class_name_pattern.'\ze')
				let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
				break
			endif

			" in-file lookup for Class::getInstance()
			if line =~# '^\s*'.object.'\s*=&\?\s*'.class_name_pattern.'\s*::\s*getInstance' && !object_is_array
				let classname_candidate = matchstr(line, object.'\s*=&\?\s*\zs'.class_name_pattern.'\ze\s*::\s*getInstance')
				let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
				break
			endif

			" do in-file lookup for static method invocation of a built-in class, like: $d = DateTime::createFromFormat()
			if line =~# '^\s*'.object.'\s*=&\?\s*'.class_name_pattern.'\s*::\s*$\?[a-zA-Z_0-9\x7f-\xff]\+'
				let classname  = matchstr(line, '^\s*'.object.'\s*=&\?\s*\zs'.class_name_pattern.'\ze\s*::')
				if has_key(a:imports, classname) && a:imports[classname].kind == 'c'
					let classname = a:imports[classname].name
				endif
				if has_key(g:php_builtin_classes, tolower(classname))
					let sub_methodstack = phpcomplete#GetMethodStack(matchstr(line, '^\s*'.object.'\s*=&\?\s*\s\+\zs.*'))
					let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname, '\', {}, sub_methodstack)
					return classname_candidate
				else
					" try to get the class name from the static method's docblock
					let [classname, namespace_for_class] = phpcomplete#ExpandClassName(classname, a:current_namespace, a:imports)
					let sub_methodstack = phpcomplete#GetMethodStack(matchstr(line, '^\s*'.object.'\s*=&\?\s*\s\+\zs.*'))
					let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(
						\ classname,
						\ a:current_namespace,
						\ a:imports,
						\ sub_methodstack)
					return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
				endif
			endif

			" in-file lookup for typehinted function arguments
			"   - the function can have a name or be anonymous (e.g., function qux() { ... } vs. function () { ... })
			"   - the type-hinted argument can be anywhere in the arguments list.
			if line =~? 'function\(\s\+'.function_name_pattern.'\)\?\s*(.\{-}'.class_name_pattern.'\s\+'.object && !object_is_array
				let f_args = matchstr(line, '\cfunction\(\s\+'.function_name_pattern.'\)\?\s*(\zs.\{-}\ze)')
				let args = split(f_args, '\s*\zs,\ze\s*')
				for arg in args
					if arg =~# object.'\(,\|$\)'
						let classname_candidate = matchstr(arg, '\s*\zs'.class_name_pattern.'\ze\s\+'.object)
						let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
						break
					endif
				endfor
				if classname_candidate != ''
					break
				endif
			endif

			" if we see a function declaration, try loading the docblock for it and look for matching @params
			if line =~? 'function\(\s\+'.function_name_pattern.'\)\?\s*(.\{-}'.object
				let match_line = substitute(line, '\\', '\\\\', 'g')
				let sccontent = getline(0, a:start_line - i)
				let doc_str = phpcomplete#GetDocBlock(sccontent, match_line)
				if doc_str != ''
					let docblock = phpcomplete#ParseDocBlock(doc_str)
					for param in docblock.params
						if param.name =~? object
							let classname_candidate = matchstr(param.type, class_name_pattern.'\(\[\]\)\?')
							let [classname_candidate, class_candidate_namespace] = phpcomplete#ExpandClassName(classname_candidate, a:current_namespace, a:imports)
							break
						endif
					endfor
					if classname_candidate != ''
						break
					endif
				endif
			endif

			" assignment for the variable in question with a variable on the right hand side
			if line =~# '^\s*'.object.'\s*=&\?\s*'.variable_name_pattern
				let tailing_semicolon = match(line, ';\s*$')
				let tailing_semicolon = tailing_semicolon != -1 ? tailing_semicolon : strlen(getline(a:start_line - i))
				let prev_context = phpcomplete#GetCurrentInstruction(a:start_line - i, tailing_semicolon - 1, b:phpbegin)
				let prev_class = phpcomplete#GetClassName(a:start_line - i, prev_context, a:current_namespace, a:imports)

				if stridx(prev_class, '\') != -1
					let classname_parts = split(prev_class, '\\\+')
					let classname_candidate = classname_parts[-1]
					let class_candidate_namespace = join(classname_parts[0:-2], '\')
				else
					let classname_candidate = prev_class
					let class_candidate_namespace = '\'
				endif
				break
			endif

			" assignment for the variable in question with a function on the right hand side
			if line =~# '^\s*'.object.'\s*=&\?\s*'.function_invocation_pattern
				let tailing_semicolon = match(line, ';\s*$')
				let tailing_semicolon = tailing_semicolon != -1 ? tailing_semicolon : strlen(getline(a:start_line - i))
				let prev_context = phpcomplete#GetCurrentInstruction(a:start_line - i, tailing_semicolon - 1, b:phpbegin)

				let function_name = matchstr(prev_context, '^'.function_invocation_pattern.'\ze')
				let function_name = matchstr(function_name, '^\zs.\+\ze\s*($') " strip the trailing (
				let [function_name, function_namespace] = phpcomplete#ExpandClassName(function_name, a:current_namespace, a:imports)

				let function_file = phpcomplete#GetFunctionLocation(function_name, function_namespace)

				if function_file == 'VIMPHP_BUILTINFUNCTION'
					" built in function, grab the return type from the info string
					let return_type = matchstr(g:php_builtin_functions[function_name.'('], '\v\|\s+\zs.+$')
					let classname_candidate = return_type
					let class_candidate_namespace = '\'
					break
				elseif function_file != '' && filereadable(function_file)
					let file_lines = readfile(function_file)
					let docblock_str = phpcomplete#GetDocBlock(file_lines, 'function\s*&\?\<'.function_name.'\>')
					let docblock = phpcomplete#ParseDocBlock(docblock_str)
					if has_key(docblock.return, 'type')
						let classname_candidate = docblock.return.type
						let [class_candidate_namespace, function_imports] = phpcomplete#GetCurrentNameSpace(file_lines)
						" try to expand the classname of the returned type with the context got from the function's source file
						let [classname_candidate, unused] = phpcomplete#ExpandClassName(classname_candidate, class_candidate_namespace, function_imports)
						break
					endif
				endif
			endif

			" foreach with the variable in question
			if line =~? 'foreach\s*(.\{-}\s\+'.object.'\s*)'
				let sub_context = matchstr(line, 'foreach\s*(\s*\zs.\{-}\ze\s\+as')
				let prev_class = phpcomplete#GetClassName(a:start_line - i, sub_context, a:current_namespace, a:imports)

				" the iterated expression should return an array type
				if prev_class =~ '\[\]$'
					let prev_class = matchstr(prev_class, '\v^[^[]+')
				else
					return
				endif

				if stridx(prev_class, '\') != -1
					let classname_parts = split(prev_class, '\\\+')
					let classname_candidate = classname_parts[-1]
					let class_candidate_namespace = join(classname_parts[0:-2], '\')
				else
					let classname_candidate = prev_class
					let class_candidate_namespace = '\'
				endif
				break
			endif

			" catch clause with the variable in question
			if line =~? 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object
				let classname = matchstr(line, 'catch\s*(\zs'.class_name_pattern.'\ze\s\+'.object)
				if stridx(classname, '\') != -1
					let classname_parts = split(classname, '\\\+')
					let classname_candidate = classname_parts[-1]
					let class_candidate_namespace = join(classname_parts[0:-2], '\')
				else
					let classname_candidate = classname
					let class_candidate_namespace = '\'
				endif
				break
			endif

			let i += 1
		endfor " }}}

		if classname_candidate != ''
			let [classname_candidate, class_candidate_namespace] = phpcomplete#GetCallChainReturnType(classname_candidate, class_candidate_namespace, class_candidate_imports, methodstack)
			" return absolute classname, without leading \
			return (class_candidate_namespace == '\' || class_candidate_namespace == '') ? classname_candidate : class_candidate_namespace.'\'.classname_candidate
		endif

		" OK, first way failed, now check tags file(s)
		" This method is useless when local variables are not indexed by ctags and
		" pretty inaccurate even if it is
		if g:phpcomplete_search_tags_for_variables
			let tags = phpcomplete#GetTaglist('^'.substitute(object, '^\$', '', ''))
			if len(tags) == 0
				return
			else
				for tag in tags
					if tag.kind ==? 'v' && tag.cmd =~? '=\s*new\s\+\zs'.class_name_pattern.'\ze'
						let classname = matchstr(tag.cmd, '=\s*new\s\+\zs'.class_name_pattern.'\ze')
						return classname
					endif
				endfor
			endif
		endif
	endif
endfunction
" }}}

function! phpcomplete#GetClassLocation(classname, namespace) " {{{
	" Check classname may be name of built in object
	if has_key(g:php_builtin_classes, tolower(a:classname)) && (a:namespace == '' || a:namespace == '\')
		return 'VIMPHP_BUILTINOBJECT'
	endif

	if a:namespace == '' || a:namespace == '\'
		let search_namespace = '\'
	else
		let search_namespace = tolower(a:namespace)
	endif
	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(getline(0, line('.')))

	" do in-file lookup for class definition
	let i = 1
	while i < line('.')
		let line = getline(line('.')-i)
		if line =~? '^\s*\(abstract\s\+\|final\s\+\)*\s*class\s*'.a:classname.'\(\s\+\|$\)' && tolower(current_namespace) == search_namespace
			return expand('%:p')
		else
			let i += 1
			continue
		endif
	endwhile

	" Get class location from tags
	let no_namespace_candidate = ''
	let tags = phpcomplete#GetTaglist('^'.a:classname.'$')
	for tag in tags
		if tag.kind == 'c' || tag.kind == 'i'
			if !has_key(tag, 'namespace')
				let no_namespace_candidate = tag.filename
			else
				if search_namespace == tolower(tag.namespace)
					return tag.filename
				endif
			endif
		endif
	endfor
	if no_namespace_candidate != ''
		return no_namespace_candidate
	endif

	return ''
endfunction
" }}}

function! phpcomplete#GetFunctionLocation(function_name, namespace) " {{{
	" builtin functions doesn't need explicit \ in front of them even in namespaces,
	" aliased built-in function names are not handled
	if has_key(g:php_builtin_functions, a:function_name.'(')
		return 'VIMPHP_BUILTINFUNCTION'
	endif


	" do in-file lookup for function definition
	let i = 1
	let buffer_lines = getline(1, line('$'))
	for line in buffer_lines
		if line =~? '^\s*function\s\+&\?'.a:function_name.'\s*('
			return expand('%:p')
		endif
	endfor


	if a:namespace == '' || a:namespace == '\'
		let search_namespace = '\'
	else
		let search_namespace = tolower(a:namespace)
	endif
	let no_namespace_candidate = ''
	let tags = phpcomplete#GetTaglist('\c^'.a:function_name.'$')

	for tag in tags
		if tag.kind == 'f'
			if !has_key(tag, 'namespace')
				let no_namespace_candidate = tag.filename
			else
				if search_namespace == tolower(tag.namespace)
					return tag.filename
				endif
			endif
		endif
	endfor
	if no_namespace_candidate != ''
		return no_namespace_candidate
	endif

	return ''
endfunction
" }}}

function! phpcomplete#GetCachedClassContents(classlocation, class_name) " {{{
	let full_file_path = fnamemodify(a:classlocation, ':p')
	let cache_key = full_file_path.'#'.a:class_name.'#'.getftime(full_file_path)

	" try to read from the cache first
	if has_key(s:cache_classstructures, cache_key)
		let classcontents = s:cache_classstructures[cache_key]
		" cached class contents can contain content from multiple files (superclasses) so we have to
		" validate cached result's validness by the filemtimes used to create the cached value
		let valid = 1
		for classstructure in classcontents
			if getftime(classstructure.file) != classstructure.mtime
				let valid = 0
				" we could break here, but the time required for checking probably worth
				" the the memory we can free by checking every file in the cached hirearchy
				call phpcomplete#ClearCachedClassContents(classstructure.file)
			endif
		endfor

		if valid
			" cache hit, we found an entry for this file + class pair and every
			" file in the response is also valid
			return classcontents
		else
			" clear the outdated cached value from the cache store
			call remove(s:cache_classstructures, cache_key)
			call phpcomplete#ClearCachedClassContents(full_file_path)

			" fall trough for the read from files path
		endif
	else
		call phpcomplete#ClearCachedClassContents(full_file_path)
	endif

	" cache miss, fetch the content from the files itself
	let classfile = readfile(a:classlocation)
	let classcontents = phpcomplete#GetClassContentsStructure(full_file_path, classfile, a:class_name)
	let s:cache_classstructures[cache_key] = classcontents

	return classcontents
endfunction " }}}

function! phpcomplete#ClearCachedClassContents(full_file_path) " {{{
	for [cache_key, cached_value] in items(s:cache_classstructures)
		if stridx(cache_key, a:full_file_path.'#') == 0
			call remove(s:cache_classstructures, cache_key)
		endif
	endfor
endfunction " }}}

function! phpcomplete#GetClassContentsStructure(file_path, file_lines, class_name) " {{{
	" returns dictionary containing content, namespace and imports for the class and all parent classes.
	" Example:
	" [
	"	{
	"		class: 'foo',
	"		content: '... class foo extends bar ... ',
	"		namespace: 'NS\Foo',
	"		imports : { ... },
	"		file: '/foo.php',
	"		mtime: 42,
	"	},
	"	{
	"		class: 'bar',
	"		content: '... class bar extends baz ... ',
	"		namespace: 'NS\Bar',
	"		imports : { ... }
	"		file: '/bar.php',
	"		mtime: 42,
	"	},
	"	...
	" ]
	"
	let full_file_path = fnamemodify(a:file_path, ':p')
	let class_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
	let cfile = join(a:file_lines, "\n")
	let result = []
	" We use new buffer and (later) normal! because
	" this is the most efficient way. The other way
	" is to go through the looong string looking for
	" matching {}

	" remember the window we started at
	let phpcomplete_original_window = winnr()

	silent! below 1new
	silent! 0put =cfile
	call search('\(class\|interface\)\_s\+'.a:class_name.'\(\>\|$\)')
	let cfline = line('.')
	call search('{')
	let endline = line('.')

	let content = join(getline(cfline, endline), "\n")
	" Catch extends
	if content =~? 'extends'
		let extends_class = matchstr(content, 'class\_s\+'.a:class_name.'\_s\+extends\_s\+\zs'.class_name_pattern.'\ze')
	else
		let extends_class = ''
	endif
	call searchpair('{', '', '}', 'W')
	let classcontent = join(getline(cfline, line('.')), "\n")
	silent! bw! %
	let [current_namespace, imports] = phpcomplete#GetCurrentNameSpace(a:file_lines[0:cfline])
	" go back to original window
	exe phpcomplete_original_window.'wincmd w'
	call add(result, {
				\ 'class': a:class_name,
				\ 'content': classcontent,
				\ 'namespace': current_namespace,
				\ 'imports': imports,
				\ 'file': full_file_path,
				\ 'mtime': getftime(full_file_path),
				\ })

	if extends_class != ''
		let [extends_class, namespace] = phpcomplete#ExpandClassName(extends_class, current_namespace, imports)
		if namespace == ''
			let namespace = '\'
		endif
		let classlocation = phpcomplete#GetClassLocation(extends_class, namespace)
		if classlocation == "VIMPHP_BUILTINOBJECT"
			let result += [phpcomplete#GenerateBuiltinClassStub(g:php_builtin_classes[tolower(extends_class)])]
		elseif classlocation != '' && filereadable(classlocation)
			let full_file_path = fnamemodify(classlocation, ':p')
			let result += phpcomplete#GetClassContentsStructure(full_file_path, readfile(full_file_path), extends_class)
		elseif tolower(current_namespace) == tolower(namespace)
			" try to find the declaration in the same file.
			let result += phpcomplete#GetClassContentsStructure(full_file_path, a:file_lines, extends_class)
		endif
	endif

	return result
endfunction
" }}}

function! phpcomplete#GetClassContents(classlocation, class_name) " {{{
	let classcontents = phpcomplete#GetCachedClassContents(a:classlocation, a:class_name)
	let result = []
	for classstructure in classcontents
		call add(result, classstructure.content)
	endfor
	return join(result, "\n")
endfunction
" }}}

function! phpcomplete#GenerateBuiltinClassStub(class_info) " {{{
	let re = 'class '.a:class_info['name']." {"
	for [name, initializer] in items(a:class_info.constants)
		let re .= "\n\tconst ".name." = ".initializer.";"
	endfor
	for [name, info] in items(a:class_info.properties)
		let re .= "\n\t// @var $".name." ".info.type
		let re .= "\n\tpublic $".name.";"
	endfor
	for [name, info] in items(a:class_info.static_properties)
		let re .= "\n\t// @var ".name." ".info.type
		let re .= "\n\tpublic static ".name." = ".info.initializer.";"
	endfor
	for [name, info] in items(a:class_info.methods)
		if name =~ '^__'
			continue
		endif
		let re .= "\n\t/**"
		let re .= "\n\t * ".name
		let re .= "\n\t *"
		let re .= "\n\t * @return ".info.return_type
		let re .= "\n\t */"
		let re .= "\n\tpublic function ".name."(".info.signature."){"
		let re .= "\n\t}"
	endfor
	for [name, info] in items(a:class_info.static_methods)
		let re .= "\n\t/**"
		let re .= "\n\t * ".name
		let re .= "\n\t *"
		let re .= "\n\t * @return ".info.return_type
		let re .= "\n\t */"
		let re .= "\n\tpublic static function ".name."(".info.signature."){"
		let re .= "\n\t}"
	endfor
	let re .= "\n}"

	return { 'class': a:class_info['name'],
				\ 'content': re,
				\ 'namespace': '',
				\ 'imports': {},
				\ 'file': 'VIMPHP_BUILTINOBJECT',
				\ 'mtime': 0,
				\ }
endfunction " }}}

function! phpcomplete#GetDocBlock(sccontent, search) " {{{
	let i = 0
	let l = 0
	let comment_start = -1
	let comment_end = -1
	let sccontent_len = len(a:sccontent)

	while (i < sccontent_len)
		let line = a:sccontent[i]
		" search for a function declaration
		if line =~? a:search
			let l = i - 1
			" start backward serch for the comment block
			while l != 0
				let line = a:sccontent[l]
				" if comment end found save line position and end search
				if line =~? '^\s*\*/'
					let comment_end = l
					break
				" ... or the line doesn't blank (only whitespace or nothing) end search
				elseif line !~? '^\s*$'
					break
				endif
				let l -= 1
			endwhile
			" no comment found
			if comment_end == -1
				return ''
			end

			while l != 0
				let line = a:sccontent[l]
				if line =~? '^\s*/\*\*'
					let comment_start = l
					break
				endif
				let l -= 1
			endwhile
			" no docblock comment start found
			if comment_start == -1
				return ''
			end

			let comment_start += 1 " we dont need the /**
			let comment_end   -= 1 " we dont need the */

			" remove leading whitespace and '*'s
			let docblock = join(map(copy(a:sccontent[comment_start :comment_end]), 'substitute(v:val, "^\\s*\\*\\s*", "", "")'), "\n")
			return docblock
		endif
		let i += 1
	endwhile
	return ''
endfunction
" }}}

function! phpcomplete#ParseDocBlock(docblock) " {{{
	let res = {
		\ 'description': '',
		\ 'params': [],
		\ 'return': {},
		\ 'throws': [],
		\ 'var': {},
		\ }

	let res.description = substitute(matchstr(a:docblock, '\zs\_.\{-}\ze\(@var\|@param\|@return\|$\)'), '\(^\_s*\|\_s*$\)', '', 'g')
	let docblock_lines = split(a:docblock, "\n")

	let param_lines = filter(copy(docblock_lines), 'v:val =~? "^@param"')
	for param_line in param_lines
		let parts = matchlist(param_line, '@param\s\+\(\S\+\)\s\+\(\S\+\)\s*\(.*\)')
		if len(parts) > 0
			call add(res.params, {
						\ 'line': parts[0],
						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 1, '')),
						\ 'name': get(parts, 2, ''),
						\ 'description': get(parts, 3, '')})
		endif
	endfor

	let return_line = filter(copy(docblock_lines), 'v:val =~? "^@return"')
	if len(return_line) > 0
		let return_parts = matchlist(return_line[0], '@return\s\+\(\S\+\)\s*\(.*\)')
		let res['return'] = {
					\ 'line': return_parts[0],
					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(return_parts, 1, '')),
					\ 'description': get(return_parts, 2, '')}
	endif

	let exception_lines = filter(copy(docblock_lines), 'v:val =~? "^\\(@throws\\|@exception\\)"')
	for exception_line in exception_lines
		let parts = matchlist(exception_line, '^\(@throws\|@exception\)\s\+\(\S\+\)\s*\(.*\)')
		if len(parts) > 0
			call add(res.throws, {
						\ 'line': parts[0],
						\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(parts, 2, '')),
						\ 'description': get(parts, 3, '')})
		endif
	endfor

	let var_line = filter(copy(docblock_lines), 'v:val =~? "^@var"')
	if len(var_line) > 0
		let var_parts = matchlist(var_line[0], '@var\s\+\(\S\+\)\s*\(.*\)')
		let res['var'] = {
					\ 'line': var_parts[0],
					\ 'type': phpcomplete#GetTypeFromDocBlockParam(get(var_parts, 1, '')),
					\ 'description': get(var_parts, 2, '')}
	endif

	return res
endfunction
" }}}

function! phpcomplete#GetTypeFromDocBlockParam(docblock_type) " {{{
	if a:docblock_type !~ '|'
		return a:docblock_type
	endif

	let primitive_types = [
				\ 'string', 'float', 'double', 'int',
				\ 'scalar', 'array', 'bool', 'void', 'mixed',
				\ 'null', 'callable', 'resource', 'object']

	" add array of primitives to the list too, like string[]
	let primitive_types += map(copy(primitive_types), 'v:val."[]"')
	let types = split(a:docblock_type, '|')
	for type in types
		if index(primitive_types, type) == -1
			return type
		endif
	endfor

	" only primitive types found, return the first one
	return types[0]

endfunction
" }}}

function! phpcomplete#FormatDocBlock(info) " {{{
	let res = ''
	if len(a:info.description)
		let res .= "Description:\n".join(map(split(a:info['description'], "\n"), '"\t".v:val'), "\n")."\n"
	endif

	if len(a:info.params)
		let res .= "\nArguments:\n"
		for arginfo in a:info.params
			let res .= "\t".arginfo['name'].' '.arginfo['type']
			if len(arginfo.description) > 0
				let res .= ': '.arginfo['description']
			endif
			let res .= "\n"
		endfor
	endif

	if has_key(a:info.return, 'type')
		let res .= "\nReturn:\n\t".a:info['return']['type']
		if len(a:info.return.description) > 0
			let res .= ": ".a:info['return']['description']
		endif
		let res .= "\n"
	endif

	if len(a:info.throws)
		let res .= "\nThrows:\n"
		for excinfo in a:info.throws
			let res .= "\t".excinfo['type']
			if len(excinfo['description']) > 0
				let res .= ": ".excinfo['description']
			endif
			let res .= "\n"
		endfor
	endif

	if has_key(a:info.var, 'type')
		let res .= "Type:\n\t".a:info['var']['type']."\n"
		if len(a:info['var']['description']) > 0
			let res .= ': '.a:info['var']['description']
		endif
	endif

	return res
endfunction!
" }}}

function! phpcomplete#GetCurrentNameSpace(file_lines) " {{{
	let namespace_name_pattern = '[a-zA-Z_\x7f-\xff\\][a-zA-Z_0-9\x7f-\xff\\]*'
	let file_lines = reverse(copy(a:file_lines))
	let i = 0
	let file_length = len(file_lines)
	let imports = {}

	let current_namespace = '\'

	while i < file_length
		let line = file_lines[i]

		if line =~? '^\s*namespace\s*'.namespace_name_pattern
			let current_namespace = matchstr(line, '^\s*namespace\s*\zs'.namespace_name_pattern.'\ze')
			break
		endif

		if line =~? '^\s*use\>'
			if line =~? ';'
				let use_line = line
			else
				" try to find the next line containing ';'
				let l = i
				let search_line = line
				let use_line = line

				" add lines from the file until theres no ';' in them
				while search_line !~? ';' && l > 0
					" file lines are reversed so we need to go backwards
					let l -= 1
					let search_line = file_lines[l]
					let use_line .= ' '.substitute(search_line, '\(^\s\+\|\s\+$\)', '', 'g')
				endwhile
			endif
			let use_expression = matchstr(use_line, '^\s*use\s\+\zs.\{-}\ze;')
			let use_parts = map(split(use_expression, '\s*,\s*'), 'substitute(v:val, "\\s+", " ", "g")')
			for part in use_parts
				if part =~? '\s\+as\s\+'
					let [object, name] = split(part, '\s\+as\s\+')
					let object = substitute(object, '^\\', '', '')
					let name   = substitute(name, '^\\', '', '')
				else
					let object = part
					let name = part
					let object = substitute(object, '^\\', '', '')
					let name   = substitute(name, '^\\', '', '')
					if name =~? '\\'
						let	name = matchstr(name, '\\\zs[^\\]\+\ze$')
					endif
				endif
				" leading slash is not required use imports are always absolute
				let imports[name] = {'name': object, 'kind': ''}
			endfor

			" find kind flags from tags or built in methods for the objects we extracted
			" they can be either classes, interfaces or namespaces, no other thing is importable in php
			for [key, import] in items(imports)
				" if theres a \ in the name we have it's definetly not a built in thing, look for tags
				if import.name =~ '\\'
					let patched_ctags_detected = 0
					let [classname, namespace_for_classes] = phpcomplete#ExpandClassName(import.name, '\', {})
					let namespace_name_candidate = substitute(import.name, '\\', '\\\\', 'g')
					" can be a namespace name as is, or can be a tagname at the end with a namespace
					let tags = phpcomplete#GetTaglist('^\('.namespace_name_candidate.'\|'.classname.'\)$')
					if len(tags) > 0
						for tag in tags
							" if there's a namespace with the name of the import
							if tag.kind == 'n' && tag.name == import.name
								call extend(import, tag)
								let import['builtin'] = 0
								let patched_ctags_detected = 1
								break
							endif
							" if the name matches with the extracted classname and namespace
							if (tag.kind == 'c' || tag.kind == 'i') && tag.name == classname
								if has_key(tag, 'namespace')
									let patched_ctags_detected = 1
									if tag.namespace == namespace_for_classes
										call extend(import, tag)
										let import['builtin'] = 0
										break
									endif
								elseif !exists('no_namespace_candidate')
									" save the first namespacless match to be used if no better
									" candidate found later on
									let no_namespace_candidate = tag
								endif
							endif
						endfor
						" there were a namespacless class name match, if we think that the
						" tags are not generated with patched ctags we will take it as a match
						if exists('no_namespace_candidate') && !patched_ctags_detected
							call extend(import, no_namespace_candidate)
							let import['builtin'] = 0
						endif
					else
						" if no tags are found, extract the namespace from the name
						let ns = matchstr(import.name, '\c\zs[a-zA-Z0-9\\]\+\ze\\' . name)
						if len(ns) > 0
							let import['name'] = name
							let import['namespace'] = ns
							let import['builtin'] = 0
						endif
					endif
				else
					" if no \ in the name, it can be a built in class
					if has_key(g:php_builtin_classnames, tolower(import.name))
						let import['kind'] = 'c'
						let import['builtin'] = 1
					elseif has_key(g:php_builtin_interfacenames, tolower(import.name))
						let import['kind'] = 'i'
						let import['builtin'] = 1
					else
						" or can be a tag with exactly matchign name
						let tags = phpcomplete#GetTaglist('^'.import['name'].'$')
						for tag in tags
							" search for the first matchin namespace, class, interface with no namespace
							if !has_key(tag, 'namespace') && (tag.kind == 'n' || tag.kind == 'c' || tag.kind == 'i')
								call extend(import, tag)
								let import['builtin'] = 0
								break
							endif
						endfor
					endif
				endif
				if exists('no_namespace_candidate')
					unlet no_namespace_candidate
				endif
			endfor
		endif
		let i += 1
	endwhile
	let sorted_imports = {}
	for name in sort(keys(imports))
		let sorted_imports[name] = imports[name]
	endfor
	return [current_namespace, sorted_imports]
endfunction
" }}}

function! phpcomplete#GetCurrentFunctionBoundaries() " {{{
	let old_cursor_pos = [line('.'), col('.')]
	let current_line_no = old_cursor_pos[0]
	let function_pattern = '\c\(.*\%#\)\@!\_^\s*\zs\(abstract\s\+\|final\s\+\|private\s\+\|protected\s\+\|public\s\+\|static\s\+\)*function\_.\{-}(\_.\{-})\_.\{-}{'

	let func_start_pos = searchpos(function_pattern, 'Wbc')
	if func_start_pos == [0, 0]
		call cursor(old_cursor_pos[0], old_cursor_pos[1])
		return 0
	endif

	" get the line where the function declaration actually started
	call search('\cfunction\_.\{-}(\_.\{-})\_.\{-}{', 'Wce')

	" get the position of the function block's closing "}"
	let func_end_pos = searchpairpos('{', '', '}', 'W')
	if func_end_pos == [0, 0]
		" there is a function start but no end found, assume that we are in a
		" function but the user did not typed the closing "}" yet and the
		" function runs to the end of the file
		let func_end_pos = [line('$'), len(getline(line('$')))]
	endif

	" Decho func_start_pos[0].' <= '.current_line_no.' && '.current_line_no.' <= '.func_end_pos[0]
	if func_start_pos[0] <= current_line_no && current_line_no <= func_end_pos[0]
		call cursor(old_cursor_pos[0], old_cursor_pos[1])
		return [func_start_pos, func_end_pos]
	endif

	call cursor(old_cursor_pos[0], old_cursor_pos[1])
	return 0
endfunction
" }}}

function! phpcomplete#ExpandClassName(classname, current_namespace, imports) " {{{
	" if there's an imported class, just use that class's information
	if has_key(a:imports, a:classname) && (a:imports[a:classname].kind == 'c' || a:imports[a:classname].kind == 'i')
		let namespace = has_key(a:imports[a:classname], 'namespace') ? a:imports[a:classname].namespace : ''
		return [a:imports[a:classname].name, namespace]
	endif

	" try to find relative namespace in imports, imported names takes precedence over
	" current namespace when resolving relative namespaced class names
	if a:classname !~ '^\' && a:classname =~ '\\'
		let classname_parts = split(a:classname, '\\\+')
		if has_key(a:imports, classname_parts[0]) && a:imports[classname_parts[0]].kind == 'n'
			let classname_parts[0] = a:imports[classname_parts[0]].name
			let namespace = join(classname_parts[0:-2], '\')
			let classname = classname_parts[-1]
			return [classname, namespace]
		endif
	endif

	" no imported class or namespace matched, expand with the current namespace
	let namespace = ''
	let classname = a:classname
	" if the classname have namespaces in in or we are in a namespace
	if a:classname =~ '\\' || (a:current_namespace != '\' && a:current_namespace != '')
		" add current namespace to the a:classname
		if a:classname !~ '^\'
			let classname = a:current_namespace.'\'.substitute(a:classname, '^\\', '', '')
		else
			" remove leading \, tag files doesn't have those
			let classname = substitute(a:classname, '^\\', '', '')
		endif
		" split classname to classname and namespace
		let classname_parts = split(classname, '\\\+')
		if len(classname_parts) > 1
			let namespace = join(classname_parts[0:-2], '\')
			let classname = classname_parts[-1]
		endif
	endif
	return [classname, namespace]
endfunction
" }}}

function! phpcomplete#LoadData() " {{{
" Keywords/reserved words, all other special things
" Later it is possible to add some help to values, or type of defined variable
let g:php_keywords={'PHP_SELF':'','argv':'','argc':'','GATEWAY_INTERFACE':'','SERVER_ADDR':'','SERVER_NAME':'','SERVER_SOFTWARE':'','SERVER_PROTOCOL':'','REQUEST_METHOD':'','REQUEST_TIME':'','QUERY_STRING':'','DOCUMENT_ROOT':'','HTTP_ACCEPT':'','HTTP_ACCEPT_CHARSET':'','HTTP_ACCEPT_ENCODING':'','HTTP_ACCEPT_LANGUAGE':'','HTTP_CONNECTION':'','HTTP_POST':'','HTTP_REFERER':'','HTTP_USER_AGENT':'','HTTPS':'','REMOTE_ADDR':'','REMOTE_HOST':'','REMOTE_PORT':'','SCRIPT_FILENAME':'','SERVER_ADMIN':'','SERVER_PORT':'','SERVER_SIGNATURE':'','PATH_TRANSLATED':'','SCRIPT_NAME':'','REQUEST_URI':'','PHP_AUTH_DIGEST':'','PHP_AUTH_USER':'','PHP_AUTH_PW':'','AUTH_TYPE':'','and':'','or':'','xor':'','__FILE__':'','exception':'','__LINE__':'','as':'','break':'','case':'','class':'','const':'','continue':'','declare':'','default':'','do':'','echo':'','else':'','elseif':'','enddeclare':'','endfor':'','endforeach':'','endif':'','endswitch':'','endwhile':'','extends':'','for':'','foreach':'','function':'','global':'','if':'','new':'','static':'','switch':'','use':'','var':'','while':'','final':'','php_user_filter':'','interface':'','implements':'','public':'','private':'','protected':'','abstract':'','clone':'','try':'','catch':'','throw':'','cfunction':'','old_function':'','this':'','INI_USER': '','INI_PERDIR': '','INI_SYSTEM': '','INI_ALL': '','ABDAY_1': '','ABDAY_2': '','ABDAY_3': '','ABDAY_4': '','ABDAY_5': '','ABDAY_6': '','ABDAY_7': '','DAY_1': '','DAY_2': '','DAY_3': '','DAY_4': '','DAY_5': '','DAY_6': '','DAY_7': '','ABMON_1': '','ABMON_2': '','ABMON_3': '','ABMON_4': '','ABMON_5': '','ABMON_6': '','ABMON_7': '','ABMON_8': '','ABMON_9': '','ABMON_10': '','ABMON_11': '','ABMON_12': '','MON_1': '','MON_2': '','MON_3': '','MON_4': '','MON_5': '','MON_6': '','MON_7': '','MON_8': '','MON_9': '','MON_10': '','MON_11': '','MON_12': '','AM_STR': '','D_T_FMT': '','ALT_DIGITS': '',}
" One giant hash of all built-in function, class, interface and constant grouped by extension
let php_builtin = {'functions':{},'classes':{},'interfaces':{},'constants':{},}
let php_builtin['functions']['math']={'abs(':'mixed $number | number','acos(':'float $arg | float','acosh(':'float $arg | float','asin(':'float $arg | float','asinh(':'float $arg | float','atan(':'float $arg | float','atan2(':'float $y, float $x | float','atanh(':'float $arg | float','base_convert(':'string $number, int $frombase, int $tobase | string','bindec(':'string $binary_string | number','ceil(':'float $value | float','cos(':'float $arg | float','cosh(':'float $arg | float','decbin(':'int $number | string','dechex(':'int $number | string','decoct(':'int $number | string','deg2rad(':'float $number | float','exp(':'float $arg | float','expm1(':'float $arg | float','floor(':'float $value | float','fmod(':'float $x, float $y | float','getrandmax(':'void | int','hexdec(':'string $hex_string | number','hypot(':'float $x, float $y | float','is_finite(':'float $val | bool','is_infinite(':'float $val | bool','is_nan(':'float $val | bool','lcg_value(':'void | float','log(':'float $arg [, float $base = M_E] | float','log10(':'float $arg | float','log1p(':'float $number | float','max(':'array $values | mixed','min(':'array $values | mixed','mt_getrandmax(':'void | int','mt_rand(':'void | int','mt_srand(':'[ int $seed] | void','octdec(':'string $octal_string | number','pi(':'void | float','pow(':'number $base, number $exp | number','rad2deg(':'float $number | float','rand(':'void | int','round(':'float $val [, int $precision = 0 [, int $mode = PHP_ROUND_HALF_UP]] | float','sin(':'float $arg | float','sinh(':'float $arg | float','sqrt(':'float $arg | float','srand(':'[ int $seed] | void','tan(':'float $arg | float','tanh(':'float $arg | float',}
let php_builtin['functions']['strings']={'addcslashes(':'string $str, string $charlist | string','addslashes(':'string $str | string','bin2hex(':'string $str | string','chop(':'chop — Alias of rtrim()','chr(':'int $ascii | string','chunk_split(':'string $body [, int $chunklen = 76 [, string $end = "\r\n"]] | string','convert_cyr_string(':'string $str, string $from, string $to | string','convert_uudecode(':'string $data | string','convert_uuencode(':'string $data | string','count_chars(':'string $string [, int $mode = 0] | mixed','crc32(':'string $str | int','crypt(':'string $str [, string $salt] | string','echo(':'string $arg1 [, string $...] | void','explode(':'string $delimiter, string $string [, int $limit] | array','fprintf(':'resource $handle, string $format [, mixed $args [, mixed $...]] | int','get_html_translation_table(':'[ int $table = HTML_SPECIALCHARS [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']]] | array','hebrev(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hebrevc(':'string $hebrew_text [, int $max_chars_per_line = 0] | string','hex2bin(':'string $data | string','html_entity_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'']] | string','htmlentities(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','htmlspecialchars_decode(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401] | string','htmlspecialchars(':'string $string [, int $flags = ENT_COMPAT | ENT_HTML401 [, string $encoding = ''UTF-8'' [, bool $double_encode = true]]] | string','implode(':'string $glue, array $pieces | string','join(':'join — Alias of implode()','lcfirst(':'string $str | string','levenshtein(':'string $str1, string $str2 | int','localeconv(':'void | array','ltrim(':'string $str [, string $character_mask] | string','md5_file(':'string $filename [, bool $raw_output = false] | string','md5(':'string $str [, bool $raw_output = false] | string','metaphone(':'string $str [, int $phonemes = 0] | string','money_format(':'string $format, float $number | string','nl_langinfo(':'int $item | string','nl2br(':'string $string [, bool $is_xhtml = true] | string','number_format(':'float $number [, int $decimals = 0] | string','ord(':'string $string | int','parse_str(':'string $str [, array &$arr] | void','print(':'string $arg | int','printf(':'string $format [, mixed $args [, mixed $...]] | int','quoted_printable_decode(':'string $str | string','quoted_printable_encode(':'string $str | string','quotemeta(':'string $str | string','rtrim(':'string $str [, string $character_mask] | string','setlocale(':'int $category, string $locale [, string $...] | string','sha1_file(':'string $filename [, bool $raw_output = false] | string','sha1(':'string $str [, bool $raw_output = false] | string','similar_text(':'string $first, string $second [, float &$percent] | int','soundex(':'string $str | string','sprintf(':'string $format [, mixed $args [, mixed $...]] | string','sscanf(':'string $str, string $format [, mixed &$...] | mixed','str_getcsv(':'string $input [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]] | array','str_ireplace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_pad(':'string $input, int $pad_length [, string $pad_string = " " [, int $pad_type = STR_PAD_RIGHT]] | string','str_repeat(':'string $input, int $multiplier | string','str_replace(':'mixed $search, mixed $replace, mixed $subject [, int &$count] | mixed','str_rot13(':'string $str | string','str_shuffle(':'string $str | string','str_split(':'string $string [, int $split_length = 1] | array','str_word_count(':'string $string [, int $format = 0 [, string $charlist]] | mixed','strcasecmp(':'string $str1, string $str2 | int','strchr(':'strchr — Alias of strstr()','strcmp(':'string $str1, string $str2 | int','strcoll(':'string $str1, string $str2 | int','strcspn(':'string $str1, string $str2 [, int $start [, int $length]] | int','strip_tags(':'string $str [, string $allowable_tags] | string','stripcslashes(':'string $str | string','stripos(':'string $haystack, string $needle [, int $offset = 0] | int','stripslashes(':'string $str | string','stristr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strlen(':'string $string | int','strnatcasecmp(':'string $str1, string $str2 | int','strnatcmp(':'string $str1, string $str2 | int','strncasecmp(':'string $str1, string $str2, int $len | int','strncmp(':'string $str1, string $str2, int $len | int','strpbrk(':'string $haystack, string $char_list | string','strpos(':'string $haystack, mixed $needle [, int $offset = 0] | mixed','strrchr(':'string $haystack, mixed $needle | string','strrev(':'string $string | string','strripos(':'string $haystack, string $needle [, int $offset = 0] | int','strrpos(':'string $haystack, string $needle [, int $offset = 0] | int','strspn(':'string $subject, string $mask [, int $start [, int $length]] | int','strstr(':'string $haystack, mixed $needle [, bool $before_needle = false] | string','strtok(':'string $str, string $token | string','strtolower(':'string $str | string','strtoupper(':'string $string | string','strtr(':'string $str, string $from, string $to | string','substr_compare(':'string $main_str, string $str, int $offset [, int $length [, bool $case_insensitivity = false]] | int','substr_count(':'string $haystack, string $needle [, int $offset = 0 [, int $length]] | int','substr_replace(':'mixed $string, mixed $replacement, mixed $start [, mixed $length] | mixed','substr(':'string $string, int $start [, int $length] | string','trim(':'string $str [, string $character_mask = " \t\n\r\0\x0B"] | string','ucfirst(':'string $str | string','ucwords(':'string $str | string','vfprintf(':'resource $handle, string $format, array $args | int','vprintf(':'string $format, array $args | int','vsprintf(':'string $format, array $args | string','wordwrap(':'string $str [, int $width = 75 [, string $break = "\n" [, bool $cut = false]]] | string',}
let php_builtin['functions']['apache']={'apache_child_terminate(':'void | bool','apache_get_modules(':'void | array','apache_get_version(':'void | string','apache_getenv(':'string $variable [, bool $walk_to_top = false] | string','apache_lookup_uri(':'string $filename | object','apache_note(':'string $note_name [, string $note_value = ""] | string','apache_request_headers(':'void | array','apache_reset_timeout(':'void | bool','apache_response_headers(':'void | array','apache_setenv(':'string $variable, string $value [, bool $walk_to_top = false] | bool','getallheaders(':'void | array','virtual(':'string $filename | bool',}
let php_builtin['functions']['arrays']={'array_change_key_case(':'array $array [, int $case = CASE_LOWER] | array','array_chunk(':'array $array, int $size [, bool $preserve_keys = false] | array','array_column(':'array $array, mixed $column_key [, mixed $index_key = null] | array','array_combine(':'array $keys, array $values | array','array_count_values(':'array $array | array','array_diff_assoc(':'array $array1, array $array2 [, array $...] | array','array_diff_key(':'array $array1, array $array2 [, array $...] | array','array_diff_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_diff(':'array $array1, array $array2 [, array $...] | array','array_fill_keys(':'array $keys, mixed $value | array','array_fill(':'int $start_index, int $num, mixed $value | array','array_filter(':'array $array [, callable $callback] | array','array_flip(':'array $array | array','array_intersect_assoc(':'array $array1, array $array2 [, array $...] | array','array_intersect_key(':'array $array1, array $array2 [, array $...] | array','array_intersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect_ukey(':'array $array1, array $array2 [, array $... [, callable $key_compare_func]] | array','array_intersect(':'array $array1, array $array2 [, array $...] | array','array_key_exists(':'mixed $key, array $array | bool','array_keys(':'array $array [, mixed $search_value [, bool $strict = false]] | array','array_map(':'callable $callback, array $array1 [, array $...] | array','array_merge_recursive(':'array $array1 [, array $...] | array','array_merge(':'array $array1 [, array $...] | array','array_multisort(':'array &$array1 [, mixed $array1_sort_order = SORT_ASC [, mixed $array1_sort_flags = SORT_REGULAR [, mixed $...]]] | bool','array_pad(':'array $array, int $size, mixed $value | array','array_pop(':'array &$array | mixed','array_product(':'array $array | number','array_push(':'array &$array, mixed $value1 [, mixed $...] | int','array_rand(':'array $array [, int $num = 1] | mixed','array_reduce(':'array $array, callable $callback [, mixed $initial = NULL] | mixed','array_replace_recursive(':'array $array1, array $array2 [, array $...] | array','array_replace(':'array $array1, array $array2 [, array $...] | array','array_reverse(':'array $array [, bool $preserve_keys = false] | array','array_search(':'mixed $needle, array $haystack [, bool $strict = false] | mixed','array_shift(':'array &$array | mixed','array_slice(':'array $array, int $offset [, int $length = NULL [, bool $preserve_keys = false]] | array','array_splice(':'array &$input, int $offset [, int $length [, mixed $replacement = array()]] | array','array_sum(':'array $array | number','array_udiff_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_udiff_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_udiff(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_assoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_uintersect_uassoc(':'array $array1, array $array2 [, array $... [, callable $value_compare_func [, callable $key_compare_func]]] | array','array_uintersect(':'array $array1, array $array2 [, array $... [, callable $value_compare_func]] | array','array_unique(':'array $array [, int $sort_flags = SORT_STRING] | array','array_unshift(':'array &$array, mixed $value1 [, mixed $...] | int','array_values(':'array $array | array','array_walk_recursive(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array_walk(':'array &$array, callable $callback [, mixed $userdata = NULL] | bool','array(':'[ mixed $...] | array','arsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','asort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','compact(':'mixed $varname1 [, mixed $...] | array','count(':'mixed $array_or_countable [, int $mode = COUNT_NORMAL] | int','current(':'array &$array | mixed','each(':'array &$array | array','end(':'array &$array | mixed','extract(':'array &$array [, int $flags = EXTR_OVERWRITE [, string $prefix = NULL]] | int','in_array(':'mixed $needle, array $haystack [, bool $strict = FALSE] | bool','key_exists(':'key_exists — Alias of array_key_exists()','key(':'array &$array | mixed','krsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','ksort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','list(':'mixed $var1 [, mixed $...] | array','natcasesort(':'array &$array | bool','natsort(':'array &$array | bool','next(':'array &$array | mixed','pos(':'pos — Alias of current()','prev(':'array &$array | mixed','range(':'mixed $start, mixed $end [, number $step = 1] | array','reset(':'array &$array | mixed','rsort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','shuffle(':'array &$array | bool','sizeof(':'sizeof — Alias of count()','sort(':'array &$array [, int $sort_flags = SORT_REGULAR] | bool','uasort(':'array &$array, callable $value_compare_func | bool','uksort(':'array &$array, callable $key_compare_func | bool','usort(':'array &$array, callable $value_compare_func | bool',}
let php_builtin['functions']['php_options_info']={'assert_options(':'int $what [, mixed $value] | mixed','assert(':'mixed $assertion [, string $description] | bool','cli_get_process_title(':'void | string','cli_set_process_title(':'string $title | bool','dl(':'string $library | bool','extension_loaded(':'string $name | bool','gc_collect_cycles(':'void | int','gc_disable(':'void | void','gc_enable(':'void | void','gc_enabled(':'void | bool','get_cfg_var(':'string $option | string','get_current_user(':'void | string','get_defined_constants(':'[ bool $categorize = false] | array','get_extension_funcs(':'string $module_name | array','get_include_path(':'void | string','get_included_files(':'void | array','get_loaded_extensions(':'[ bool $zend_extensions = false] | array','get_magic_quotes_gpc(':'void | bool','get_magic_quotes_runtime(':'void | bool','get_required_files(':'get_required_files — Alias of get_included_files()','getenv(':'string $varname | string','getlastmod(':'void | int','getmygid(':'void | int','getmyinode(':'void | int','getmypid(':'void | int','getmyuid(':'void | int','getopt(':'string $options [, array $longopts] | array','getrusage(':'[ int $who = 0] | array','ini_alter(':'ini_alter — Alias of ini_set()','ini_get_all(':'[ string $extension [, bool $details = true]] | array','ini_get(':'string $varname | string','ini_restore(':'string $varname | void','ini_set(':'string $varname, string $newvalue | string','magic_quotes_runtime(':'magic_quotes_runtime — Alias of set_magic_quotes_runtime()','memory_get_peak_usage(':'[ bool $real_usage = false] | int','memory_get_usage(':'[ bool $real_usage = false] | int','php_ini_loaded_file(':'void | string','php_ini_scanned_files(':'void | string','php_logo_guid(':'void | string','php_sapi_name(':'void | string','php_uname(':'[ string $mode = "a"] | string','phpcredits(':'[ int $flag = CREDITS_ALL] | bool','phpinfo(':'[ int $what = INFO_ALL] | bool','phpversion(':'[ string $extension] | string','putenv(':'string $setting | bool','restore_include_path(':'void | void','set_include_path(':'string $new_include_path | string','set_magic_quotes_runtime(':'bool $new_setting | bool','set_time_limit(':'int $seconds | void','sys_get_temp_dir(':'void | string','version_compare(':'string $version1, string $version2 [, string $operator] | mixed','zend_logo_guid(':'void | string','zend_thread_id(':'void | int','zend_version(':'void | string',}
let php_builtin['functions']['classes_objects']={'__autoload(':'string $class | void','call_user_method_array(':'string $method_name, object &$obj, array $params | mixed','call_user_method(':'string $method_name, object &$obj [, mixed $parameter [, mixed $...]] | mixed','class_alias(':'string $original, string $alias [, bool $autoload = TRUE] | bool','class_exists(':'string $class_name [, bool $autoload = true] | bool','get_called_class(':'void | string','get_class_methods(':'mixed $class_name | array','get_class_vars(':'string $class_name | array','get_class(':'[ object $object = NULL] | string','get_declared_classes(':'void | array','get_declared_interfaces(':'void | array','get_declared_traits(':'void | array','get_object_vars(':'object $object | array','get_parent_class(':'[ mixed $object] | string','interface_exists(':'string $interface_name [, bool $autoload = true] | bool','is_a(':'object $object, string $class_name [, bool $allow_string = FALSE] | bool','is_subclass_of(':'mixed $object, string $class_name [, bool $allow_string = TRUE] | bool','method_exists(':'mixed $object, string $method_name | bool','property_exists(':'mixed $class, string $property | bool','trait_exists(':'string $traitname [, bool $autoload] | bool',}
let php_builtin['functions']['urls']={'base64_decode(':'string $data [, bool $strict = false] | string','base64_encode(':'string $data | string','get_headers(':'string $url [, int $format = 0] | array','get_meta_tags(':'string $filename [, bool $use_include_path = false] | array','http_build_query(':'mixed $query_data [, string $numeric_prefix [, string $arg_separator [, int $enc_type = PHP_QUERY_RFC1738]]] | string','parse_url(':'string $url [, int $component = -1] | mixed','rawurldecode(':'string $str | string','rawurlencode(':'string $str | string','urldecode(':'string $str | string','urlencode(':'string $str | string',}
let php_builtin['functions']['filesystem']={'basename(':'string $path [, string $suffix] | string','chgrp(':'string $filename, mixed $group | bool','chmod(':'string $filename, int $mode | bool','chown(':'string $filename, mixed $user | bool','clearstatcache(':'[ bool $clear_realpath_cache = false [, string $filename]] | void','copy(':'string $source, string $dest [, resource $context] | bool','dirname(':'string $path | string','disk_free_space(':'string $directory | float','disk_total_space(':'string $directory | float','diskfreespace(':'diskfreespace — Alias of disk_free_space()','fclose(':'resource $handle | bool','feof(':'resource $handle | bool','fflush(':'resource $handle | bool','fgetc(':'resource $handle | string','fgetcsv(':'resource $handle [, int $length = 0 [, string $delimiter = '','' [, string $enclosure = ''"'' [, string $escape = ''\\'']]]] | array','fgets(':'resource $handle [, int $length] | string','fgetss(':'resource $handle [, int $length [, string $allowable_tags]] | string','file_exists(':'string $filename | bool','file_get_contents(':'string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen]]]] | string','file_put_contents(':'string $filename, mixed $data [, int $flags = 0 [, resource $context]] | int','file(':'string $filename [, int $flags = 0 [, resource $context]] | array','fileatime(':'string $filename | int','filectime(':'string $filename | int','filegroup(':'string $filename | int','fileinode(':'string $filename | int','filemtime(':'string $filename | int','fileowner(':'string $filename | int','fileperms(':'string $filename | int','filesize(':'string $filename | int','filetype(':'string $filename | string','flock(':'resource $handle, int $operation [, int &$wouldblock] | bool','fnmatch(':'string $pattern, string $string [, int $flags = 0] | bool','fopen(':'string $filename, string $mode [, bool $use_include_path = false [, resource $context]] | resource','fpassthru(':'resource $handle | int','fputcsv(':'resource $handle, array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','fputs(':'fputs — Alias of fwrite()','fread(':'resource $handle, int $length | string','fscanf(':'resource $handle, string $format [, mixed &$...] | mixed','fseek(':'resource $handle, int $offset [, int $whence = SEEK_SET] | int','fstat(':'resource $handle | array','ftell(':'resource $handle | int','ftruncate(':'resource $handle, int $size | bool','fwrite(':'resource $handle, string $string [, int $length] | int','glob(':'string $pattern [, int $flags = 0] | array','is_dir(':'string $filename | bool','is_executable(':'string $filename | bool','is_file(':'string $filename | bool','is_link(':'string $filename | bool','is_readable(':'string $filename | bool','is_uploaded_file(':'string $filename | bool','is_writable(':'string $filename | bool','is_writeable(':'is_writeable — Alias of is_writable()','lchgrp(':'string $filename, mixed $group | bool','lchown(':'string $filename, mixed $user | bool','link(':'string $target, string $link | bool','linkinfo(':'string $path | int','lstat(':'string $filename | array','mkdir(':'string $pathname [, int $mode = 0777 [, bool $recursive = false [, resource $context]]] | bool','move_uploaded_file(':'string $filename, string $destination | bool','parse_ini_file(':'string $filename [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','parse_ini_string(':'string $ini [, bool $process_sections = false [, int $scanner_mode = INI_SCANNER_NORMAL]] | array','pathinfo(':'string $path [, int $options = PATHINFO_DIRNAME | PATHINFO_BASENAME | PATHINFO_EXTENSION | PATHINFO_FILENAME] | mixed','pclose(':'resource $handle | int','popen(':'string $command, string $mode | resource','readfile(':'string $filename [, bool $use_include_path = false [, resource $context]] | int','readlink(':'string $path | string','realpath_cache_get(':'void | array','realpath_cache_size(':'void | int','realpath(':'string $path | string','rename(':'string $oldname, string $newname [, resource $context] | bool','rewind(':'resource $handle | bool','rmdir(':'string $dirname [, resource $context] | bool','set_file_buffer(':'set_file_buffer — Alias of stream_set_write_buffer()','stat(':'string $filename | array','symlink(':'string $target, string $link | bool','tempnam(':'string $dir, string $prefix | string','tmpfile(':'void | resource','touch(':'string $filename [, int $time = time() [, int $atime]] | bool','umask(':'[ int $mask] | int','unlink(':'string $filename [, resource $context] | bool',}
let php_builtin['functions']['variable_handling']={'boolval(':'mixed $var | boolean','debug_zval_dump(':'mixed $variable [, mixed $...] | void','doubleval(':'doubleval — Alias of floatval()','empty(':'mixed $var | bool','floatval(':'mixed $var | float','get_defined_vars(':'void | array','get_resource_type(':'resource $handle | string','gettype(':'mixed $var | string','import_request_variables(':'string $types [, string $prefix] | bool','intval(':'mixed $var [, int $base = 10] | int','is_array(':'mixed $var | bool','is_bool(':'mixed $var | bool','is_callable(':'callable $name [, bool $syntax_only = false [, string &$callable_name]] | bool','is_double(':'is_double — Alias of is_float()','is_float(':'mixed $var | bool','is_int(':'mixed $var | bool','is_integer(':'is_integer — Alias of is_int()','is_long(':'is_long — Alias of is_int()','is_null(':'mixed $var | bool','is_numeric(':'mixed $var | bool','is_object(':'mixed $var | bool','is_real(':'is_real — Alias of is_float()','is_resource(':'mixed $var | bool','is_scalar(':'mixed $var | bool','is_string(':'mixed $var | bool','isset(':'mixed $var [, mixed $...] | bool','print_r(':'mixed $expression [, bool $return = false] | mixed','serialize(':'mixed $value | string','settype(':'mixed &$var, string $type | bool','strval(':'mixed $var | string','unserialize(':'string $str | mixed','unset(':'mixed $var [, mixed $...] | void','var_dump(':'mixed $expression [, mixed $...] | void','var_export(':'mixed $expression [, bool $return = false] | mixed',}
let php_builtin['functions']['calendar']={'cal_days_in_month(':'int $calendar, int $month, int $year | int','cal_from_jd(':'int $jd, int $calendar | array','cal_info(':'[ int $calendar = -1] | array','cal_to_jd(':'int $calendar, int $month, int $day, int $year | int','easter_date(':'[ int $year] | int','easter_days(':'[ int $year [, int $method = CAL_EASTER_DEFAULT]] | int','frenchtojd(':'int $month, int $day, int $year | int','gregoriantojd(':'int $month, int $day, int $year | int','jddayofweek(':'int $julianday [, int $mode = CAL_DOW_DAYNO] | mixed','jdmonthname(':'int $julianday, int $mode | string','jdtofrench(':'int $juliandaycount | string','jdtogregorian(':'int $julianday | string','jdtojewish(':'int $juliandaycount [, bool $hebrew = false [, int $fl = 0]] | string','jdtojulian(':'int $julianday | string','jdtounix(':'int $jday | int','jewishtojd(':'int $month, int $day, int $year | int','juliantojd(':'int $month, int $day, int $year | int','unixtojd(':'[ int $timestamp = time()] | int',}
let php_builtin['functions']['function_handling']={'call_user_func_array(':'callable $callback, array $param_arr | mixed','call_user_func(':'callable $callback [, mixed $parameter [, mixed $...]] | mixed','create_function(':'string $args, string $code | string','forward_static_call_array(':'callable $function, array $parameters | mixed','forward_static_call(':'callable $function [, mixed $parameter [, mixed $...]] | mixed','func_get_arg(':'int $arg_num | mixed','func_get_args(':'void | array','func_num_args(':'void | int','function_exists(':'string $function_name | bool','get_defined_functions(':'void | array','register_shutdown_function(':'callable $callback [, mixed $parameter [, mixed $...]] | void','register_tick_function(':'callable $function [, mixed $arg [, mixed $...]] | bool','unregister_tick_function(':'string $function_name | void',}
let php_builtin['functions']['directories']={'chdir(':'string $directory | bool','chroot(':'string $directory | bool','closedir(':'[ resource $dir_handle] | void','dir(':'string $directory [, resource $context] | Directory','getcwd(':'void | string','opendir(':'string $path [, resource $context] | resource','readdir(':'[ resource $dir_handle] | string','rewinddir(':'[ resource $dir_handle] | void','scandir(':'string $directory [, int $sorting_order = SCANDIR_SORT_ASCENDING [, resource $context]] | array',}
let php_builtin['functions']['date_time']={'checkdate(':'int $month, int $day, int $year | bool','date_default_timezone_get(':'void | string','date_default_timezone_set(':'string $timezone_identifier | bool','date_parse_from_format(':'string $format, string $date | array','date_parse(':'string $date | array','date_sun_info(':'int $time, float $latitude, float $longitude | array','date_sunrise(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunrise_zenith") [, float $gmt_offset = 0]]]]] | mixed','date_sunset(':'int $timestamp [, int $format = SUNFUNCS_RET_STRING [, float $latitude = ini_get("date.default_latitude") [, float $longitude = ini_get("date.default_longitude") [, float $zenith = ini_get("date.sunset_zenith") [, float $gmt_offset = 0]]]]] | mixed','date(':'string $format [, int $timestamp = time()] | string','getdate(':'[ int $timestamp = time()] | array','gettimeofday(':'[ bool $return_float = false] | mixed','gmdate(':'string $format [, int $timestamp = time()] | string','gmmktime(':'[ int $hour = gmdate("H") [, int $minute = gmdate("i") [, int $second = gmdate("s") [, int $month = gmdate("n") [, int $day = gmdate("j") [, int $year = gmdate("Y") [, int $is_dst = -1]]]]]]] | int','gmstrftime(':'string $format [, int $timestamp = time()] | string','idate(':'string $format [, int $timestamp = time()] | int','localtime(':'[ int $timestamp = time() [, bool $is_associative = false]] | array','microtime(':'[ bool $get_as_float = false] | mixed','mktime(':'[ int $hour = date("H") [, int $minute = date("i") [, int $second = date("s") [, int $month = date("n") [, int $day = date("j") [, int $year = date("Y") [, int $is_dst = -1]]]]]]] | int','strftime(':'string $format [, int $timestamp = time()] | string','strptime(':'string $date, string $format | array','strtotime(':'string $time [, int $now = time()] | int','time(':'void | int','timezone_name_from_abbr(':'string $abbr [, int $gmtOffset = -1 [, int $isdst = -1]] | string','timezone_version_get(':'void | string',}
let php_builtin['functions']['network']={'checkdnsrr(':'string $host [, string $type = "MX"] | bool','closelog(':'void | bool','define_syslog_variables(':'void | void','dns_get_record(':'string $hostname [, int $type = DNS_ANY [, array &$authns [, array &$addtl [, bool &$raw = false]]]] | array','fsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','gethostbyaddr(':'string $ip_address | string','gethostbyname(':'string $hostname | string','gethostbynamel(':'string $hostname | array','gethostname(':'void | string','getmxrr(':'string $hostname, array &$mxhosts [, array &$weight] | bool','getprotobyname(':'string $name | int','getprotobynumber(':'int $number | string','getservbyname(':'string $service, string $protocol | int','getservbyport(':'int $port, string $protocol | string','header_register_callback(':'callable $callback | bool','header_remove(':'[ string $name] | void','header(':'string $string [, bool $replace = true [, int $http_response_code]] | void','headers_list(':'void | array','headers_sent(':'[ string &$file [, int &$line]] | bool','http_response_code(':'[ int $response_code] | int','inet_ntop(':'string $in_addr | string','inet_pton(':'string $address | string','ip2long(':'string $ip_address | int','long2ip(':'string $proper_address | string','openlog(':'string $ident, int $option, int $facility | bool','pfsockopen(':'string $hostname [, int $port = -1 [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout")]]]] | resource','setcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','setrawcookie(':'string $name [, string $value [, int $expire = 0 [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]]]] | bool','socket_get_status(':'socket_get_status — Alias of stream_get_meta_data()','socket_set_blocking(':'socket_set_blocking — Alias of stream_set_blocking()','socket_set_timeout(':'socket_set_timeout — Alias of stream_set_timeout()','syslog(':'int $priority, string $message | bool',}
let php_builtin['functions']['spl']={'class_implements(':'mixed $class [, bool $autoload = true] | array','class_parents(':'mixed $class [, bool $autoload = true] | array','class_uses(':'mixed $class [, bool $autoload = true] | array','iterator_apply(':'Traversable $iterator, callable $function [, array $args] | int','iterator_count(':'Traversable $iterator | int','iterator_to_array(':'Traversable $iterator [, bool $use_keys = true] | array','spl_autoload_call(':'string $class_name | void','spl_autoload_extensions(':'[ string $file_extensions] | string','spl_autoload_functions(':'void | array','spl_autoload_register(':'[ callable $autoload_function [, bool $throw = true [, bool $prepend = false]]] | bool','spl_autoload_unregister(':'mixed $autoload_function | bool','spl_autoload(':'string $class_name [, string $file_extensions = spl_autoload_extensions()] | void','spl_classes(':'void | array','spl_object_hash(':'object $obj | string',}
let php_builtin['functions']['misc']={'connection_aborted(':'void | int','connection_status(':'void | int','connection_timeout(':'void | int','constant(':'string $name | mixed','define(':'string $name, mixed $value [, bool $case_insensitive = false] | bool','defined(':'string $name | bool','eval(':'string $code | mixed','exit(':'[ string $status] | void','get_browser(':'[ string $user_agent [, bool $return_array = false]] | mixed','__halt_compiler(':'void | void','highlight_file(':'string $filename [, bool $return = false] | mixed','highlight_string(':'string $str [, bool $return = false] | mixed','ignore_user_abort(':'[ string $value] | int','pack(':'string $format [, mixed $args [, mixed $...]] | string','php_check_syntax(':'string $filename [, string &$error_message] | bool','php_strip_whitespace(':'string $filename | string','show_source(':'show_source — Alias of highlight_file()','sleep(':'int $seconds | int','sys_getloadavg(':'void | array','time_nanosleep(':'int $seconds, int $nanoseconds | mixed','time_sleep_until(':'float $timestamp | bool','uniqid(':'[ string $prefix = "" [, bool $more_entropy = false]] | string','unpack(':'string $format, string $data | array','usleep(':'int $micro_seconds | void',}
let php_builtin['functions']['curl']={'curl_close(':'resource $ch | void','curl_copy_handle(':'resource $ch | resource','curl_errno(':'resource $ch | int','curl_error(':'resource $ch | string','curl_escape(':'resource $ch, string $str | string','curl_exec(':'resource $ch | mixed','curl_getinfo(':'resource $ch [, int $opt = 0] | mixed','curl_init(':'[ string $url = NULL] | resource','curl_multi_add_handle(':'resource $mh, resource $ch | int','curl_multi_close(':'resource $mh | void','curl_multi_exec(':'resource $mh, int &$still_running | int','curl_multi_getcontent(':'resource $ch | string','curl_multi_info_read(':'resource $mh [, int &$msgs_in_queue = NULL] | array','curl_multi_init(':'void | resource','curl_multi_remove_handle(':'resource $mh, resource $ch | int','curl_multi_select(':'resource $mh [, float $timeout = 1.0] | int','curl_multi_setopt(':'resource $mh, int $option, mixed $value | bool','curl_multi_strerror(':'int $errornum | string','curl_pause(':'resource $ch, int $bitmask | int','curl_reset(':'resource $ch | void','curl_setopt_array(':'resource $ch, array $options | bool','curl_setopt(':'resource $ch, int $option, mixed $value | bool','curl_share_close(':'resource $sh | void','curl_share_init(':'void | resource','curl_share_setopt(':'resource $sh, int $option, string $value | bool','curl_strerror(':'int $errornum | string','curl_unescape(':'resource $ch, string $str | string','curl_version(':'[ int $age = CURLVERSION_NOW] | array',}
let php_builtin['functions']['error_handling']={'debug_backtrace(':'[ int $options = DEBUG_BACKTRACE_PROVIDE_OBJECT [, int $limit = 0]] | array','debug_print_backtrace(':'[ int $options = 0 [, int $limit = 0]] | void','error_get_last(':'void | array','error_log(':'string $message [, int $message_type = 0 [, string $destination [, string $extra_headers]]] | bool','error_reporting(':'[ int $level] | int','restore_error_handler(':'void | bool','restore_exception_handler(':'void | bool','set_error_handler(':'callable $error_handler [, int $error_types = E_ALL | E_STRICT] | mixed','set_exception_handler(':'callable $exception_handler | callable','trigger_error(':'string $error_msg [, int $error_type = E_USER_NOTICE] | bool',}
let php_builtin['functions']['dom']={'dom_import_simplexml(':'SimpleXMLElement $node | DOMElement',}
let php_builtin['functions']['program_execution']={'escapeshellarg(':'string $arg | string','escapeshellcmd(':'string $command | string','exec(':'string $command [, array &$output [, int &$return_var]] | string','passthru(':'string $command [, int &$return_var] | void','proc_close(':'resource $process | int','proc_get_status(':'resource $process | array','proc_nice(':'int $increment | bool','proc_open(':'string $cmd, array $descriptorspec, array &$pipes [, string $cwd [, array $env [, array $other_options]]] | resource','proc_terminate(':'resource $process [, int $signal = 15] | bool','shell_exec(':'string $cmd | string','system(':'string $command [, int &$return_var] | string',}
let php_builtin['functions']['mail']={'ezmlm_hash(':'string $addr | int','mail(':'string $to, string $subject, string $message [, string $additional_headers [, string $additional_parameters]] | bool',}
let php_builtin['functions']['fastcgi_process_manager']={'fastcgi_finish_request(':'void | boolean',}
let php_builtin['functions']['filter']={'filter_has_var(':'int $type, string $variable_name | bool','filter_id(':'string $filtername | int','filter_input_array(':'int $type [, mixed $definition [, bool $add_empty = true]] | mixed','filter_input(':'int $type, string $variable_name [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed','filter_list(':'void | array','filter_var_array(':'array $data [, mixed $definition [, bool $add_empty = true]] | mixed','filter_var(':'mixed $variable [, int $filter = FILTER_DEFAULT [, mixed $options]] | mixed',}
let php_builtin['functions']['fileinfo']={'finfo_buffer(':'resource $finfo [, string $string = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_close(':'resource $finfo | bool','finfo_file(':'resource $finfo [, string $file_name = NULL [, int $options = FILEINFO_NONE [, resource $context = NULL]]] | string','finfo_open(':'[ int $options = FILEINFO_NONE [, string $magic_file = NULL]] | resource','finfo_set_flags(':'resource $finfo, int $options | bool','mime_content_type(':'string $filename | string',}
let php_builtin['functions']['output_control']={'flush(':'void | void','ob_clean(':'void | void','ob_end_clean(':'void | bool','ob_end_flush(':'void | bool','ob_flush(':'void | void','ob_get_clean(':'void | string','ob_get_contents(':'void | string','ob_get_flush(':'void | string','ob_get_length(':'void | int','ob_get_level(':'void | int','ob_get_status(':'[ bool $full_status = FALSE] | array','ob_gzhandler(':'string $buffer, int $mode | string','ob_implicit_flush(':'[ int $flag = true] | void','ob_list_handlers(':'void | array','ob_start(':'[ callable $output_callback = NULL [, int $chunk_size = 0 [, int $flags = PHP_OUTPUT_HANDLER_STDFLAGS]]] | bool','output_add_rewrite_var(':'string $name, string $value | bool','output_reset_rewrite_vars(':'void | bool',}
let php_builtin['functions']['gd']={'gd_info(':'void | array','getimagesize(':'string $filename [, array &$imageinfo] | array','getimagesizefromstring(':'string $imagedata [, array &$imageinfo] | array','image_type_to_extension(':'int $imagetype [, bool $include_dot = TRUE] | string','image_type_to_mime_type(':'int $imagetype | string','image2wbmp(':'resource $image [, string $filename [, int $threshold]] | bool','imageaffine(':'resource $image, array $affine [, array $clip] | resource','imageaffinematrixconcat(':'array $m1, array $m2 | array','imageaffinematrixget(':'int $type [, mixed $options] | array','imagealphablending(':'resource $image, bool $blendmode | bool','imageantialias(':'resource $image, bool $enabled | bool','imagearc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color | bool','imagechar(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecharup(':'resource $image, int $font, int $x, int $y, string $c, int $color | bool','imagecolorallocate(':'resource $image, int $red, int $green, int $blue | int','imagecolorallocatealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorat(':'resource $image, int $x, int $y | int','imagecolorclosest(':'resource $image, int $red, int $green, int $blue | int','imagecolorclosestalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorclosesthwb(':'resource $image, int $red, int $green, int $blue | int','imagecolordeallocate(':'resource $image, int $color | bool','imagecolorexact(':'resource $image, int $red, int $green, int $blue | int','imagecolorexactalpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolormatch(':'resource $image1, resource $image2 | bool','imagecolorresolve(':'resource $image, int $red, int $green, int $blue | int','imagecolorresolvealpha(':'resource $image, int $red, int $green, int $blue, int $alpha | int','imagecolorset(':'resource $image, int $index, int $red, int $green, int $blue [, int $alpha = 0] | void','imagecolorsforindex(':'resource $image, int $index | array','imagecolorstotal(':'resource $image | int','imagecolortransparent(':'resource $image [, int $color] | int','imageconvolution(':'resource $image, array $matrix, float $div, float $offset | bool','imagecopy(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h | bool','imagecopymerge(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopymergegray(':'resource $dst_im, resource $src_im, int $dst_x, int $dst_y, int $src_x, int $src_y, int $src_w, int $src_h, int $pct | bool','imagecopyresampled(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecopyresized(':'resource $dst_image, resource $src_image, int $dst_x, int $dst_y, int $src_x, int $src_y, int $dst_w, int $dst_h, int $src_w, int $src_h | bool','imagecreate(':'int $width, int $height | resource','imagecreatefromgd(':'string $filename | resource','imagecreatefromgd2(':'string $filename | resource','imagecreatefromgd2part(':'string $filename, int $srcX, int $srcY, int $width, int $height | resource','imagecreatefromgif(':'string $filename | resource','imagecreatefromjpeg(':'string $filename | resource','imagecreatefrompng(':'string $filename | resource','imagecreatefromstring(':'string $image | resource','imagecreatefromwbmp(':'string $filename | resource','imagecreatefromwebp(':'string $filename | resource','imagecreatefromxbm(':'string $filename | resource','imagecreatefromxpm(':'string $filename | resource','imagecreatetruecolor(':'int $width, int $height | resource','imagecrop(':'resource $image, array $rect | resource','imagecropauto(':'resource $image [, int $mode = -1 [, float $threshold = .5 [, int $color = -1]]] | resource','imagedashedline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagedestroy(':'resource $image | bool','imageellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefill(':'resource $image, int $x, int $y, int $color | bool','imagefilledarc(':'resource $image, int $cx, int $cy, int $width, int $height, int $start, int $end, int $color, int $style | bool','imagefilledellipse(':'resource $image, int $cx, int $cy, int $width, int $height, int $color | bool','imagefilledpolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagefilledrectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagefilltoborder(':'resource $image, int $x, int $y, int $border, int $color | bool','imagefilter(':'resource $image, int $filtertype [, int $arg1 [, int $arg2 [, int $arg3 [, int $arg4]]]] | bool','imageflip(':'resource $image, int $mode | bool','imagefontheight(':'int $font | int','imagefontwidth(':'int $font | int','imageftbbox(':'float $size, float $angle, string $fontfile, string $text [, array $extrainfo] | array','imagefttext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text [, array $extrainfo] | array','imagegammacorrect(':'resource $image, float $inputgamma, float $outputgamma | bool','imagegd(':'resource $image [, string $filename] | bool','imagegd2(':'resource $image [, string $filename [, int $chunk_size [, int $type = IMG_GD2_RAW]]] | bool','imagegif(':'resource $image [, string $filename] | bool','imagegrabscreen(':'void | resource','imagegrabwindow(':'int $window_handle [, int $client_area = 0] | resource','imageinterlace(':'resource $image [, int $interlace = 0] | int','imageistruecolor(':'resource $image | bool','imagejpeg(':'resource $image [, string $filename [, int $quality]] | bool','imagelayereffect(':'resource $image, int $effect | bool','imageline(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imageloadfont(':'string $file | int','imagepalettecopy(':'resource $destination, resource $source | void','imagepalettetotruecolor(':'resource $src | bool','imagepng(':'resource $image [, string $filename [, int $quality [, int $filters]]] | bool','imagepolygon(':'resource $image, array $points, int $num_points, int $color | bool','imagepsbbox(':'string $text, resource $font, int $size | array','imagepsencodefont(':'resource $font_index, string $encodingfile | bool','imagepsextendfont(':'resource $font_index, float $extend | bool','imagepsfreefont(':'resource $font_index | bool','imagepsloadfont(':'string $filename | resource','imagepsslantfont(':'resource $font_index, float $slant | bool','imagepstext(':'resource $image, string $text, resource $font_index, int $size, int $foreground, int $background, int $x, int $y [, int $space = 0 [, int $tightness = 0 [, float $angle = 0.0 [, int $antialias_steps = 4]]]] | array','imagerectangle(':'resource $image, int $x1, int $y1, int $x2, int $y2, int $color | bool','imagerotate(':'resource $image, float $angle, int $bgd_color [, int $ignore_transparent = 0] | resource','imagesavealpha(':'resource $image, bool $saveflag | bool','imagescale(':'resource $image, int $new_width [, int $new_height = -1 [, int $mode = IMG_BILINEAR_FIXED]] | resource','imagesetbrush(':'resource $image, resource $brush | bool','imagesetinterpolation(':'resource $image [, int $method = IMG_BILINEAR_FIXED] | bool','imagesetpixel(':'resource $image, int $x, int $y, int $color | bool','imagesetstyle(':'resource $image, array $style | bool','imagesetthickness(':'resource $image, int $thickness | bool','imagesettile(':'resource $image, resource $tile | bool','imagestring(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagestringup(':'resource $image, int $font, int $x, int $y, string $string, int $color | bool','imagesx(':'resource $image | int','imagesy(':'resource $image | int','imagetruecolortopalette(':'resource $image, bool $dither, int $ncolors | bool','imagettfbbox(':'float $size, float $angle, string $fontfile, string $text | array','imagettftext(':'resource $image, float $size, float $angle, int $x, int $y, int $color, string $fontfile, string $text | array','imagetypes(':'void | int','imagewbmp(':'resource $image [, string $filename [, int $foreground]] | bool','imagewebp(':'resource $image, string $filename | bool','imagexbm(':'resource $image, string $filename [, int $foreground] | bool','iptcembed(':'string $iptcdata, string $jpeg_file_name [, int $spool] | mixed','iptcparse(':'string $iptcblock | array','jpeg2wbmp(':'string $jpegname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool','png2wbmp(':'string $pngname, string $wbmpname, int $dest_height, int $dest_width, int $threshold | bool',}
let php_builtin['functions']['iconv']={'iconv_get_encoding(':'[ string $type = "all"] | mixed','iconv_mime_decode_headers(':'string $encoded_headers [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | array','iconv_mime_decode(':'string $encoded_header [, int $mode = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv_mime_encode(':'string $field_name, string $field_value [, array $preferences = NULL] | string','iconv_set_encoding(':'string $type, string $charset | bool','iconv_strlen(':'string $str [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $charset = ini_get("iconv.internal_encoding")]] | int','iconv_strrpos(':'string $haystack, string $needle [, string $charset = ini_get("iconv.internal_encoding")] | int','iconv_substr(':'string $str, int $offset [, int $length = iconv_strlen($str, $charset) [, string $charset = ini_get("iconv.internal_encoding")]] | string','iconv(':'string $in_charset, string $out_charset, string $str | string','ob_iconv_handler(':'string $contents, int $status | string',}
let php_builtin['functions']['json']={'json_decode(':'string $json [, bool $assoc = false [, int $depth = 512 [, int $options = 0]]] | mixed','json_encode(':'mixed $value [, int $options = 0 [, int $depth = 512]] | string','json_last_error_msg(':'void | string','json_last_error(':'void | int',}
let php_builtin['functions']['libxml']={'libxml_clear_errors(':'void | void','libxml_disable_entity_loader(':'[ bool $disable = true] | bool','libxml_get_errors(':'void | array','libxml_get_last_error(':'void | LibXMLError','libxml_set_external_entity_loader(':'callable $resolver_function | void','libxml_set_streams_context(':'resource $streams_context | void','libxml_use_internal_errors(':'[ bool $use_errors = false] | bool',}
let php_builtin['functions']['multibyte_string']={'mb_check_encoding(':'[ string $var = NULL [, string $encoding = mb_internal_encoding()]] | bool','mb_convert_case(':'string $str, int $mode [, string $encoding = mb_internal_encoding()] | string','mb_convert_encoding(':'string $str, string $to_encoding [, mixed $from_encoding = mb_internal_encoding()] | string','mb_convert_kana(':'string $str [, string $option = "KV" [, string $encoding = mb_internal_encoding()]] | string','mb_convert_variables(':'string $to_encoding, mixed $from_encoding, mixed &$vars [, mixed &$...] | string','mb_decode_mimeheader(':'string $str | string','mb_decode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding()] | string','mb_detect_encoding(':'string $str [, mixed $encoding_list = mb_detect_order() [, bool $strict = false]] | string','mb_detect_order(':'[ mixed $encoding_list = mb_detect_order()] | mixed','mb_encode_mimeheader(':'string $str [, string $charset = mb_internal_encoding() [, string $transfer_encoding = "B" [, string $linefeed = "\r\n" [, int $indent = 0]]]] | string','mb_encode_numericentity(':'string $str, array $convmap [, string $encoding = mb_internal_encoding() [, bool $is_hex = FALSE]] | string','mb_encoding_aliases(':'string $encoding | array','mb_ereg_match(':'string $pattern, string $string [, string $option = "msr"] | bool','mb_ereg_replace_callback(':'string $pattern, callable $callback, string $string [, string $option = "msr"] | string','mb_ereg_replace(':'string $pattern, string $replacement, string $string [, string $option = "msr"] | string','mb_ereg_search_getpos(':'void | int','mb_ereg_search_getregs(':'void | array','mb_ereg_search_init(':'string $string [, string $pattern [, string $option = "msr"]] | bool','mb_ereg_search_pos(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_regs(':'[ string $pattern [, string $option = "ms"]] | array','mb_ereg_search_setpos(':'int $position | bool','mb_ereg_search(':'[ string $pattern [, string $option = "ms"]] | bool','mb_ereg(':'string $pattern, string $string [, array $regs] | int','mb_eregi_replace(':'string $pattern, string $replace, string $string [, string $option = "msri"] | string','mb_eregi(':'string $pattern, string $string [, array $regs] | int','mb_get_info(':'[ string $type = "all"] | mixed','mb_http_input(':'[ string $type = ""] | mixed','mb_http_output(':'[ string $encoding = mb_http_output()] | mixed','mb_internal_encoding(':'[ string $encoding = mb_internal_encoding()] | mixed','mb_language(':'[ string $language = mb_language()] | mixed','mb_list_encodings(':'void | array','mb_output_handler(':'string $contents, int $status | string','mb_parse_str(':'string $encoded_string [, array &$result] | bool','mb_preferred_mime_name(':'string $encoding | string','mb_regex_encoding(':'[ string $encoding = mb_regex_encoding()] | mixed','mb_regex_set_options(':'[ string $options = mb_regex_set_options()] | string','mb_send_mail(':'string $to, string $subject, string $message [, string $additional_headers = NULL [, string $additional_parameter = NULL]] | bool','mb_split(':'string $pattern, string $string [, int $limit = -1] | array','mb_strcut(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string','mb_strimwidth(':'string $str, int $start, int $width [, string $trimmarker = "" [, string $encoding = mb_internal_encoding()]] | string','mb_stripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_stristr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strlen(':'string $str [, string $encoding = mb_internal_encoding()] | mixed','mb_strpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrchr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strrichr(':'string $haystack, string $needle [, bool $part = false [, string $encoding = mb_internal_encoding()]] | string','mb_strripos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strrpos(':'string $haystack, string $needle [, int $offset = 0 [, string $encoding = mb_internal_encoding()]] | int','mb_strstr(':'string $haystack, string $needle [, bool $before_needle = false [, string $encoding = mb_internal_encoding()]] | string','mb_strtolower(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strtoupper(':'string $str [, string $encoding = mb_internal_encoding()] | string','mb_strwidth(':'string $str [, string $encoding = mb_internal_encoding()] | int','mb_substitute_character(':'[ mixed $substrchar = mb_substitute_character()] | mixed','mb_substr_count(':'string $haystack, string $needle [, string $encoding = mb_internal_encoding()] | int','mb_substr(':'string $str, int $start [, int $length = NULL [, string $encoding = mb_internal_encoding()]] | string',}
let php_builtin['functions']['mssql']={'mssql_bind(':'resource $stmt, string $param_name, mixed &$var, int $type [, bool $is_output = false [, bool $is_null = false [, int $maxlen = -1]]] | bool','mssql_close(':'[ resource $link_identifier] | bool','mssql_connect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_data_seek(':'resource $result_identifier, int $row_number | bool','mssql_execute(':'resource $stmt [, bool $skip_results = false] | mixed','mssql_fetch_array(':'resource $result [, int $result_type = MSSQL_BOTH] | array','mssql_fetch_assoc(':'resource $result_id | array','mssql_fetch_batch(':'resource $result | int','mssql_fetch_field(':'resource $result [, int $field_offset = -1] | object','mssql_fetch_object(':'resource $result | object','mssql_fetch_row(':'resource $result | array','mssql_field_length(':'resource $result [, int $offset = -1] | int','mssql_field_name(':'resource $result [, int $offset = -1] | string','mssql_field_seek(':'resource $result, int $field_offset | bool','mssql_field_type(':'resource $result [, int $offset = -1] | string','mssql_free_result(':'resource $result | bool','mssql_free_statement(':'resource $stmt | bool','mssql_get_last_message(':'void | string','mssql_guid_string(':'string $binary [, bool $short_format = false] | string','mssql_init(':'string $sp_name [, resource $link_identifier] | resource','mssql_min_error_severity(':'int $severity | void','mssql_min_message_severity(':'int $severity | void','mssql_next_result(':'resource $result_id | bool','mssql_num_fields(':'resource $result | int','mssql_num_rows(':'resource $result | int','mssql_pconnect(':'[ string $servername [, string $username [, string $password [, bool $new_link = false]]]] | resource','mssql_query(':'string $query [, resource $link_identifier [, int $batch_size = 0]] | mixed','mssql_result(':'resource $result, int $row, mixed $field | string','mssql_rows_affected(':'resource $link_identifier | int','mssql_select_db(':'string $database_name [, resource $link_identifier] | bool',}
let php_builtin['functions']['mysql']={'mysql_affected_rows(':'[ resource $link_identifier = NULL] | int','mysql_client_encoding(':'[ resource $link_identifier = NULL] | string','mysql_close(':'[ resource $link_identifier = NULL] | bool','mysql_connect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, bool $new_link = false [, int $client_flags = 0]]]]] | resource','mysql_create_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_data_seek(':'resource $result, int $row_number | bool','mysql_db_name(':'resource $result, int $row [, mixed $field = NULL] | string','mysql_db_query(':'string $database, string $query [, resource $link_identifier = NULL] | resource','mysql_drop_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_errno(':'[ resource $link_identifier = NULL] | int','mysql_error(':'[ resource $link_identifier = NULL] | string','mysql_escape_string(':'string $unescaped_string | string','mysql_fetch_array(':'resource $result [, int $result_type = MYSQL_BOTH] | array','mysql_fetch_assoc(':'resource $result | array','mysql_fetch_field(':'resource $result [, int $field_offset = 0] | object','mysql_fetch_lengths(':'resource $result | array','mysql_fetch_object(':'resource $result [, string $class_name [, array $params]] | object','mysql_fetch_row(':'resource $result | array','mysql_field_flags(':'resource $result, int $field_offset | string','mysql_field_len(':'resource $result, int $field_offset | int','mysql_field_name(':'resource $result, int $field_offset | string','mysql_field_seek(':'resource $result, int $field_offset | bool','mysql_field_table(':'resource $result, int $field_offset | string','mysql_field_type(':'resource $result, int $field_offset | string','mysql_free_result(':'resource $result | bool','mysql_get_client_info(':'void | string','mysql_get_host_info(':'[ resource $link_identifier = NULL] | string','mysql_get_proto_info(':'[ resource $link_identifier = NULL] | int','mysql_get_server_info(':'[ resource $link_identifier = NULL] | string','mysql_info(':'[ resource $link_identifier = NULL] | string','mysql_insert_id(':'[ resource $link_identifier = NULL] | int','mysql_list_dbs(':'[ resource $link_identifier = NULL] | resource','mysql_list_fields(':'string $database_name, string $table_name [, resource $link_identifier = NULL] | resource','mysql_list_processes(':'[ resource $link_identifier = NULL] | resource','mysql_list_tables(':'string $database [, resource $link_identifier = NULL] | resource','mysql_num_fields(':'resource $result | int','mysql_num_rows(':'resource $result | int','mysql_pconnect(':'[ string $server = ini_get("mysql.default_host") [, string $username = ini_get("mysql.default_user") [, string $password = ini_get("mysql.default_password") [, int $client_flags = 0]]]] | resource','mysql_ping(':'[ resource $link_identifier = NULL] | bool','mysql_query(':'string $query [, resource $link_identifier = NULL] | mixed','mysql_real_escape_string(':'string $unescaped_string [, resource $link_identifier = NULL] | string','mysql_result(':'resource $result, int $row [, mixed $field = 0] | string','mysql_select_db(':'string $database_name [, resource $link_identifier = NULL] | bool','mysql_set_charset(':'string $charset [, resource $link_identifier = NULL] | bool','mysql_stat(':'[ resource $link_identifier = NULL] | string','mysql_tablename(':'resource $result, int $i | string','mysql_thread_id(':'[ resource $link_identifier = NULL] | int','mysql_unbuffered_query(':'string $query [, resource $link_identifier = NULL] | resource',}
let php_builtin['functions']['mysqli']={'mysqli_disable_reads_from_master(':'mysqli $link | bool','mysqli_disable_rpl_parse(':'mysqli $link | bool','mysqli_enable_reads_from_master(':'mysqli $link | bool','mysqli_enable_rpl_parse(':'mysqli $link | bool','mysqli_get_cache_stats(':'void | array','mysqli_master_query(':'mysqli $link, string $query | bool','mysqli_rpl_parse_enabled(':'mysqli $link | int','mysqli_rpl_probe(':'mysqli $link | bool','mysqli_slave_query(':'mysqli $link, string $query | bool',}
let php_builtin['functions']['password_hashing']={'password_get_info(':'string $hash | array','password_hash(':'string $password, integer $algo [, array $options] | string','password_needs_rehash(':'string $hash, string $algo [, string $options] | boolean','password_verify(':'string $password, string $hash | boolean',}
let php_builtin['functions']['postgresql']={'pg_affected_rows(':'resource $result | int','pg_cancel_query(':'resource $connection | bool','pg_client_encoding(':'[ resource $connection] | string','pg_close(':'[ resource $connection] | bool','pg_connect(':'string $connection_string [, int $connect_type] | resource','pg_connection_busy(':'resource $connection | bool','pg_connection_reset(':'resource $connection | bool','pg_connection_status(':'resource $connection | int','pg_convert(':'resource $connection, string $table_name, array $assoc_array [, int $options = 0] | array','pg_copy_from(':'resource $connection, string $table_name, array $rows [, string $delimiter [, string $null_as]] | bool','pg_copy_to(':'resource $connection, string $table_name [, string $delimiter [, string $null_as]] | array','pg_dbname(':'[ resource $connection] | string','pg_delete(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_end_copy(':'[ resource $connection] | bool','pg_escape_bytea(':'[ resource $connection [, string $data]] | string','pg_escape_identifier(':'[ resource $connection [, string $data]] | string','pg_escape_literal(':'[ resource $connection [, string $data]] | string','pg_escape_string(':'[ resource $connection [, string $data]] | string','pg_execute(':'[ resource $connection [, string $stmtname [, array $params]]] | resource','pg_fetch_all_columns(':'resource $result [, int $column = 0] | array','pg_fetch_all(':'resource $result | array','pg_fetch_array(':'resource $result [, int $row [, int $result_type = PGSQL_BOTH]] | array','pg_fetch_assoc(':'resource $result [, int $row] | array','pg_fetch_object(':'resource $result [, int $row [, int $result_type = PGSQL_ASSOC]] | object','pg_fetch_result(':'resource $result, int $row, mixed $field | string','pg_fetch_row(':'resource $result [, int $row] | array','pg_field_is_null(':'resource $result, int $row, mixed $field | int','pg_field_name(':'resource $result, int $field_number | string','pg_field_num(':'resource $result, string $field_name | int','pg_field_prtlen(':'resource $result, int $row_number, mixed $field_name_or_number | int','pg_field_size(':'resource $result, int $field_number | int','pg_field_table(':'resource $result, int $field_number [, bool $oid_only = false] | mixed','pg_field_type_oid(':'resource $result, int $field_number | int','pg_field_type(':'resource $result, int $field_number | string','pg_free_result(':'resource $result | bool','pg_get_notify(':'resource $connection [, int $result_type] | array','pg_get_pid(':'resource $connection | int','pg_get_result(':'[ resource $connection] | resource','pg_host(':'[ resource $connection] | string','pg_insert(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_last_error(':'[ resource $connection] | string','pg_last_notice(':'resource $connection | string','pg_last_oid(':'resource $result | string','pg_lo_close(':'resource $large_object | bool','pg_lo_create(':'[ resource $connection [, mixed $object_id]] | int','pg_lo_export(':'[ resource $connection [, int $oid [, string $pathname]]] | bool','pg_lo_import(':'[ resource $connection [, string $pathname [, mixed $object_id]]] | int','pg_lo_open(':'resource $connection, int $oid, string $mode | resource','pg_lo_read_all(':'resource $large_object | int','pg_lo_read(':'resource $large_object [, int $len = 8192] | string','pg_lo_seek(':'resource $large_object, int $offset [, int $whence = PGSQL_SEEK_CUR] | bool','pg_lo_tell(':'resource $large_object | int','pg_lo_truncate(':'resource $large_object, int $size | bool','pg_lo_unlink(':'resource $connection, int $oid | bool','pg_lo_write(':'resource $large_object, string $data [, int $len] | int','pg_meta_data(':'resource $connection, string $table_name [, bool $extended] | array','pg_num_fields(':'resource $result | int','pg_num_rows(':'resource $result | int','pg_options(':'[ resource $connection] | string','pg_parameter_status(':'[ resource $connection [, string $param_name]] | string','pg_pconnect(':'string $connection_string [, int $connect_type] | resource','pg_ping(':'[ resource $connection] | bool','pg_port(':'[ resource $connection] | int','pg_prepare(':'[ resource $connection [, string $stmtname [, string $query]]] | resource','pg_put_line(':'[ resource $connection [, string $data]] | bool','pg_query_params(':'[ resource $connection [, string $query [, array $params]]] | resource','pg_query(':'[ resource $connection [, string $query]] | resource','pg_result_error_field(':'resource $result, int $fieldcode | string','pg_result_error(':'resource $result | string','pg_result_seek(':'resource $result, int $offset | bool','pg_result_status(':'resource $result [, int $type = PGSQL_STATUS_LONG] | mixed','pg_select(':'resource $connection, string $table_name, array $assoc_array [, int $options = PGSQL_DML_EXEC] | mixed','pg_send_execute(':'resource $connection, string $stmtname, array $params | bool','pg_send_prepare(':'resource $connection, string $stmtname, string $query | bool','pg_send_query_params(':'resource $connection, string $query, array $params | bool','pg_send_query(':'resource $connection, string $query | bool','pg_set_client_encoding(':'[ resource $connection [, string $encoding]] | int','pg_set_error_verbosity(':'[ resource $connection [, int $verbosity]] | int','pg_trace(':'string $pathname [, string $mode = "w" [, resource $connection]] | bool','pg_transaction_status(':'resource $connection | int','pg_tty(':'[ resource $connection] | string','pg_unescape_bytea(':'string $data | string','pg_untrace(':'[ resource $connection] | bool','pg_update(':'resource $connection, string $table_name, array $data, array $condition [, int $options = PGSQL_DML_EXEC] | mixed','pg_version(':'[ resource $connection] | array',}
let php_builtin['functions']['pcre']={'preg_filter(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_grep(':'string $pattern, array $input [, int $flags = 0] | array','preg_last_error(':'void | int','preg_match_all(':'string $pattern, string $subject [, array &$matches [, int $flags = PREG_PATTERN_ORDER [, int $offset = 0]]] | int','preg_match(':'string $pattern, string $subject [, array &$matches [, int $flags = 0 [, int $offset = 0]]] | int','preg_quote(':'string $str [, string $delimiter = NULL] | string','preg_replace_callback(':'mixed $pattern, callable $callback, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_replace(':'mixed $pattern, mixed $replacement, mixed $subject [, int $limit = -1 [, int &$count]] | mixed','preg_split(':'string $pattern, string $subject [, int $limit = -1 [, int $flags = 0]] | array',}
let php_builtin['functions']['sessions']={'session_cache_expire(':'[ string $new_cache_expire] | int','session_cache_limiter(':'[ string $cache_limiter] | string','session_commit(':'session_commit — Alias of session_write_close()','session_decode(':'string $data | bool','session_destroy(':'void | bool','session_encode(':'void | string','session_get_cookie_params(':'void | array','session_id(':'[ string $id] | string','session_is_registered(':'string $name | bool','session_module_name(':'[ string $module] | string','session_name(':'[ string $name] | string','session_regenerate_id(':'[ bool $delete_old_session = false] | bool','session_register_shutdown(':'void | void','session_register(':'mixed $name [, mixed $...] | bool','session_save_path(':'[ string $path] | string','session_set_cookie_params(':'int $lifetime [, string $path [, string $domain [, bool $secure = false [, bool $httponly = false]]]] | void','session_set_save_handler(':'callable $open, callable $close, callable $read, callable $write, callable $destroy, callable $gc | bool','session_start(':'void | bool','session_status(':'void | int','session_unregister(':'string $name | bool','session_unset(':'void | void','session_write_close(':'void | void',}
let php_builtin['functions']['streams']={'set_socket_blocking(':'set_socket_blocking — Alias of stream_set_blocking()','stream_bucket_append(':'resource $brigade, resource $bucket | void','stream_bucket_make_writeable(':'resource $brigade | object','stream_bucket_new(':'resource $stream, string $buffer | object','stream_bucket_prepend(':'resource $brigade, resource $bucket | void','stream_context_create(':'[ array $options [, array $params]] | resource','stream_context_get_default(':'[ array $options] | resource','stream_context_get_options(':'resource $stream_or_context | array','stream_context_get_params(':'resource $stream_or_context | array','stream_context_set_default(':'array $options | resource','stream_context_set_option(':'resource $stream_or_context, string $wrapper, string $option, mixed $value | bool','stream_context_set_params(':'resource $stream_or_context, array $params | bool','stream_copy_to_stream(':'resource $source, resource $dest [, int $maxlength = -1 [, int $offset = 0]] | int','stream_encoding(':'resource $stream [, string $encoding] | bool','stream_filter_append(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_prepend(':'resource $stream, string $filtername [, int $read_write [, mixed $params]] | resource','stream_filter_register(':'string $filtername, string $classname | bool','stream_filter_remove(':'resource $stream_filter | bool','stream_get_contents(':'resource $handle [, int $maxlength = -1 [, int $offset = -1]] | string','stream_get_filters(':'void | array','stream_get_line(':'resource $handle, int $length [, string $ending] | string','stream_get_meta_data(':'resource $stream | array','stream_get_transports(':'void | array','stream_get_wrappers(':'void | array','stream_is_local(':'mixed $stream_or_url | bool','stream_notification_callback(':'int $notification_code, int $severity, string $message, int $message_code, int $bytes_transferred, int $bytes_max | void','stream_resolve_include_path(':'string $filename | string','stream_select(':'array &$read, array &$write, array &$except, int $tv_sec [, int $tv_usec = 0] | int','stream_set_blocking(':'resource $stream, int $mode | bool','stream_set_chunk_size(':'resource $fp, int $chunk_size | int','stream_set_read_buffer(':'resource $stream, int $buffer | int','stream_set_timeout(':'resource $stream, int $seconds [, int $microseconds = 0] | bool','stream_set_write_buffer(':'resource $stream, int $buffer | int','stream_socket_accept(':'resource $server_socket [, float $timeout = ini_get("default_socket_timeout") [, string &$peername]] | resource','stream_socket_client(':'string $remote_socket [, int &$errno [, string &$errstr [, float $timeout = ini_get("default_socket_timeout") [, int $flags = STREAM_CLIENT_CONNECT [, resource $context]]]]] | resource','stream_socket_enable_crypto(':'resource $stream, bool $enable [, int $crypto_type [, resource $session_stream]] | mixed','stream_socket_get_name(':'resource $handle, bool $want_peer | string','stream_socket_pair(':'int $domain, int $type, int $protocol | array','stream_socket_recvfrom(':'resource $socket, int $length [, int $flags = 0 [, string &$address]] | string','stream_socket_sendto(':'resource $socket, string $data [, int $flags = 0 [, string $address]] | int','stream_socket_server(':'string $local_socket [, int &$errno [, string &$errstr [, int $flags = STREAM_SERVER_BIND | STREAM_SERVER_LISTEN [, resource $context]]]] | resource','stream_socket_shutdown(':'resource $stream, int $how | bool','stream_supports_lock(':'resource $stream | bool','stream_wrapper_register(':'string $protocol, string $classname [, int $flags = 0] | bool','stream_wrapper_restore(':'string $protocol | bool','stream_wrapper_unregister(':'string $protocol | bool',}
let php_builtin['functions']['simplexml']={'simplexml_import_dom(':'DOMNode $node [, string $class_name = "SimpleXMLElement"] | SimpleXMLElement','simplexml_load_file(':'string $filename [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement','simplexml_load_string(':'string $data [, string $class_name = "SimpleXMLElement" [, int $options = 0 [, string $ns = "" [, bool $is_prefix = false]]]] | SimpleXMLElement',}
let php_builtin['functions']['xmlwriter']={'xmlwriter_end_attribute(':'resource $xmlwriter | bool','xmlwriter_end_cdata(':'resource $xmlwriter | bool','xmlwriter_end_comment(':'resource $xmlwriter | bool','xmlwriter_end_document(':'resource $xmlwriter | bool','xmlwriter_end_dtd_attlist(':'resource $xmlwriter | bool','xmlwriter_end_dtd_element(':'resource $xmlwriter | bool','xmlwriter_end_dtd_entity(':'resource $xmlwriter | bool','xmlwriter_end_dtd(':'resource $xmlwriter | bool','xmlwriter_end_element(':'resource $xmlwriter | bool','xmlwriter_end_pi(':'resource $xmlwriter | bool','xmlwriter_flush(':'resource $xmlwriter [, bool $empty = true] | mixed','xmlwriter_full_end_element(':'resource $xmlwriter | bool','xmlwriter_open_memory(':'void | resource','xmlwriter_open_uri(':'string $uri | resource','xmlwriter_output_memory(':'resource $xmlwriter [, bool $flush = true] | string','xmlwriter_set_indent_string(':'resource $xmlwriter, string $indentString | bool','xmlwriter_set_indent(':'resource $xmlwriter, bool $indent | bool','xmlwriter_start_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_attribute(':'resource $xmlwriter, string $name | bool','xmlwriter_start_cdata(':'resource $xmlwriter | bool','xmlwriter_start_comment(':'resource $xmlwriter | bool','xmlwriter_start_document(':'resource $xmlwriter [, string $version = 1.0 [, string $encoding = NULL [, string $standalone]]] | bool','xmlwriter_start_dtd_attlist(':'resource $xmlwriter, string $name | bool','xmlwriter_start_dtd_element(':'resource $xmlwriter, string $qualifiedName | bool','xmlwriter_start_dtd_entity(':'resource $xmlwriter, string $name, bool $isparam | bool','xmlwriter_start_dtd(':'resource $xmlwriter, string $qualifiedName [, string $publicId [, string $systemId]] | bool','xmlwriter_start_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri | bool','xmlwriter_start_element(':'resource $xmlwriter, string $name | bool','xmlwriter_start_pi(':'resource $xmlwriter, string $target | bool','xmlwriter_text(':'resource $xmlwriter, string $content | bool','xmlwriter_write_attribute_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri, string $content | bool','xmlwriter_write_attribute(':'resource $xmlwriter, string $name, string $value | bool','xmlwriter_write_cdata(':'resource $xmlwriter, string $content | bool','xmlwriter_write_comment(':'resource $xmlwriter, string $content | bool','xmlwriter_write_dtd_attlist(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_element(':'resource $xmlwriter, string $name, string $content | bool','xmlwriter_write_dtd_entity(':'resource $xmlwriter, string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','xmlwriter_write_dtd(':'resource $xmlwriter, string $name [, string $publicId [, string $systemId [, string $subset]]] | bool','xmlwriter_write_element_ns(':'resource $xmlwriter, string $prefix, string $name, string $uri [, string $content] | bool','xmlwriter_write_element(':'resource $xmlwriter, string $name [, string $content] | bool','xmlwriter_write_pi(':'resource $xmlwriter, string $target, string $content | bool','xmlwriter_write_raw(':'resource $xmlwriter, string $content | bool',}
let php_builtin['functions']['zip']={'zip_close(':'resource $zip | void','zip_entry_close(':'resource $zip_entry | bool','zip_entry_compressedsize(':'resource $zip_entry | int','zip_entry_compressionmethod(':'resource $zip_entry | string','zip_entry_filesize(':'resource $zip_entry | int','zip_entry_name(':'resource $zip_entry | string','zip_entry_open(':'resource $zip, resource $zip_entry [, string $mode] | bool','zip_entry_read(':'resource $zip_entry [, int $length = 1024] | string','zip_open(':'string $filename | resource','zip_read(':'resource $zip | resource',}
let php_builtin['classes']['spl']={'appenditerator':{'name':'AppendIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'append':{'signature':'Iterator $iterator | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayIterator':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'getIteratorIndex':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayiterator':{'name':'ArrayIterator','methods':{'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'arrayobject':{'name':'ArrayObject','constants':{'STD_PROP_LIST':'1','ARRAY_AS_PROPS':'2',},'methods':{'__construct':{'signature':'[ mixed $input = [] [, int $flags = 0 [, string $iterator_class = "ArrayIterator"]]]','return_type':''},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'count':{'signature':'void | int','return_type':'int'},'exchangeArray':{'signature':'mixed $input | array','return_type':'array'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getIterator':{'signature':'void | ArrayIterator','return_type':'ArrayIterator'},'getIteratorClass':{'signature':'void | string','return_type':'string'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'serialize':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setIteratorClass':{'signature':'string $iterator_class | void','return_type':'void'},'uasort':{'signature':'callable $cmp_function | void','return_type':'void'},'uksort':{'signature':'callable $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'badfunctioncallexception':{'name':'BadFunctionCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'badmethodcallexception':{'name':'BadMethodCallException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'cachingiterator':{'name':'CachingIterator','constants':{'CALL_TOSTRING':'1','CATCH_GET_CHILD':'16','TOSTRING_USE_KEY':'2','TOSTRING_USE_CURRENT':'4','TOSTRING_USE_INNER':'8','FULL_CACHE':'256',},'methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'callbackfilteriterator':{'name':'CallbackFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'directoryiterator':{'name':'DirectoryIterator','methods':{'__construct':{'signature':'string $path','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'domainexception':{'name':'DomainException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'emptyiterator':{'name':'EmptyIterator','methods':{'current':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'filesystemiterator':{'name':'FilesystemIterator','constants':{'CURRENT_AS_PATHNAME':'32','CURRENT_AS_FILEINFO':'0','CURRENT_AS_SELF':'16','CURRENT_MODE_MASK':'240','KEY_AS_PATHNAME':'0','KEY_AS_FILENAME':'256','FOLLOW_SYMLINKS':'512','KEY_MODE_MASK':'3840','NEW_CURRENT_AND_KEY':'256','SKIP_DOTS':'4096','UNIX_PATHS':'8192',},'methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'current':{'signature':'void | DirectoryIterator','return_type':'DirectoryIterator'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isDot':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'seek':{'signature':'int $position | void','return_type':'void'},'__toString':{'signature':'void | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'filteriterator':{'name':'FilterIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Iterator $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'globiterator':{'name':'GlobIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'infiniteiterator':{'name':'InfiniteIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'next':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'invalidargumentexception':{'name':'InvalidArgumentException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'iteratoriterator':{'name':'IteratorIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'lengthexception':{'name':'LengthException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'limititerator':{'name':'LimitIterator','methods':{'__construct':{'signature':'Iterator $iterator [, int $offset = 0 [, int $count = -1]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getPosition':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | int','return_type':'int'},'valid':{'signature':'void | bool','return_type':'bool'},},},'logicexception':{'name':'LogicException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'multipleiterator':{'name':'MultipleIterator','constants':{'MIT_NEED_ANY':'0','MIT_NEED_ALL':'1','MIT_KEYS_NUMERIC':'0','MIT_KEYS_ASSOC':'2',},'methods':{'__construct':{'signature':'[ int $flags = MultipleIterator::MIT_NEED_ALL|MultipleIterator::MIT_KEYS_NUMERIC]','return_type':''},'attachIterator':{'signature':'Iterator $iterator [, string $infos] | void','return_type':'void'},'containsIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'countIterators':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | array','return_type':'array'},'detachIterator':{'signature':'Iterator $iterator | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | array','return_type':'array'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'norewinditerator':{'name':'NoRewindIterator','methods':{'__construct':{'signature':'Traversable $iterator','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Traversable','return_type':'Traversable'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'outofboundsexception':{'name':'OutOfBoundsException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'outofrangeexception':{'name':'OutOfRangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'overflowexception':{'name':'OverflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'parentiterator':{'name':'ParentIterator','methods':{'accept':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'RecursiveIterator $iterator','return_type':''},'getChildren':{'signature':'void | ParentIterator','return_type':'ParentIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},},},'rangeexception':{'name':'RangeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'recursivearrayiterator':{'name':'RecursiveArrayIterator','methods':{'getChildren':{'signature':'void | RecursiveArrayIterator','return_type':'RecursiveArrayIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'append':{'signature':'mixed $value | void','return_type':'void'},'asort':{'signature':'void | void','return_type':'void'},'__construct':{'signature':'[ mixed $array = array() [, int $flags = 0]]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getArrayCopy':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | mixed','return_type':'mixed'},'ksort':{'signature':'void | void','return_type':'void'},'natcasesort':{'signature':'void | void','return_type':'void'},'natsort':{'signature':'void | void','return_type':'void'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $position | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'string $flags | void','return_type':'void'},'uasort':{'signature':'string $cmp_function | void','return_type':'void'},'uksort':{'signature':'string $cmp_function | void','return_type':'void'},'unserialize':{'signature':'string $serialized | string','return_type':'string'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursivecachingiterator':{'name':'RecursiveCachingIterator','methods':{'__construct':{'signature':'Iterator $iterator [, string $flags = self::CALL_TOSTRING]','return_type':''},'getChildren':{'signature':'void | RecursiveCachingIterator','return_type':'RecursiveCachingIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | void','return_type':'void'},'getCache':{'signature':'void | void','return_type':'void'},'getFlags':{'signature':'void | void','return_type':'void'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'hasNext':{'signature':'void | void','return_type':'void'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'string $index | void','return_type':'void'},'offsetGet':{'signature':'string $index | void','return_type':'void'},'offsetSet':{'signature':'string $index, string $newval | void','return_type':'void'},'offsetUnset':{'signature':'string $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setFlags':{'signature':'bitmask $flags | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | void','return_type':'void'},},},'recursivecallbackfilteriterator':{'name':'RecursiveCallbackFilterIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $callback','return_type':''},'getChildren':{'signature':'void | RecursiveCallbackFilterIterator','return_type':'RecursiveCallbackFilterIterator'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | string','return_type':'string'},},},'recursivedirectoryiterator':{'name':'RecursiveDirectoryIterator','methods':{'__construct':{'signature':'string $path [, int $flags = FilesystemIterator::KEY_AS_PATHNAME | FilesystemIterator::CURRENT_AS_FILEINFO | FilesystemIterator::SKIP_DOTS]','return_type':''},'getChildren':{'signature':'void | mixed','return_type':'mixed'},'getSubPath':{'signature':'void | string','return_type':'string'},'getSubPathname':{'signature':'void | string','return_type':'string'},'hasChildren':{'signature':'[ bool $allow_links = false] | bool','return_type':'bool'},'key':{'signature':'void | string','return_type':'string'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getFlags':{'signature':'void | int','return_type':'int'},'setFlags':{'signature':'[ int $flags] | void','return_type':'void'},},},'recursivefilteriterator':{'name':'RecursiveFilterIterator','methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'getChildren':{'signature':'void | void','return_type':'void'},'hasChildren':{'signature':'void | void','return_type':'void'},'accept':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveiteratoriterator':{'name':'RecursiveIteratorIterator','constants':{'LEAVES_ONLY':'0','SELF_FIRST':'1','CHILD_FIRST':'2','CATCH_GET_CHILD':'16',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'recursiveregexiterator':{'name':'RecursiveRegexIterator','methods':{'__construct':{'signature':'RecursiveIterator $iterator, string $regex [, int $mode = self::MATCH [, int $flags = 0 [, int $preg_flags = 0]]]','return_type':''},'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},},},'recursivetreeiterator':{'name':'RecursiveTreeIterator','constants':{'BYPASS_CURRENT':'4','BYPASS_KEY':'8','PREFIX_LEFT':'0','PREFIX_MID_HAS_NEXT':'1','PREFIX_MID_LAST':'2','PREFIX_END_HAS_NEXT':'3','PREFIX_END_LAST':'4','PREFIX_RIGHT':'5',},'methods':{'beginChildren':{'signature':'void | void','return_type':'void'},'beginIteration':{'signature':'void | void','return_type':'void'},'callGetChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'callHasChildren':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'Traversable $iterator [, int $mode = RecursiveIteratorIterator::LEAVES_ONLY [, int $flags = 0]]','return_type':''},'current':{'signature':'void | mixed','return_type':'mixed'},'endChildren':{'signature':'void | void','return_type':'void'},'endIteration':{'signature':'void | void','return_type':'void'},'getEntry':{'signature':'void | string','return_type':'string'},'getPostfix':{'signature':'void | void','return_type':'void'},'getPrefix':{'signature':'void | string','return_type':'string'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'nextElement':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setPrefixPart':{'signature':'int $part, string $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getDepth':{'signature':'void | int','return_type':'int'},'getInnerIterator':{'signature':'void | iterator','return_type':'iterator'},'getMaxDepth':{'signature':'void | mixed','return_type':'mixed'},'getSubIterator':{'signature':'[ int $level] | RecursiveIterator','return_type':'RecursiveIterator'},'setMaxDepth':{'signature':'[ string $max_depth = -1] | void','return_type':'void'},},},'regexiterator':{'name':'RegexIterator','constants':{'MATCH':'0','GET_MATCH':'1','ALL_MATCHES':'2','SPLIT':'3','REPLACE':'4','USE_KEY':'1',},'methods':{'__construct':{'signature':'Iterator $iterator','return_type':''},'accept':{'signature':'void | bool','return_type':'bool'},'getFlags':{'signature':'void | int','return_type':'int'},'getMode':{'signature':'void | int','return_type':'int'},'getPregFlags':{'signature':'void | int','return_type':'int'},'getRegex':{'signature':'void | string','return_type':'string'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMode':{'signature':'int $mode | void','return_type':'void'},'setPregFlags':{'signature':'int $preg_flags | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'runtimeexception':{'name':'RuntimeException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'spldoublylinkedlist':{'name':'SplDoublyLinkedList','methods':{'__construct':{'signature':'void','return_type':''},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splfileinfo':{'name':'SplFileInfo','methods':{'__construct':{'signature':'string $file_name','return_type':''},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},},},'splfileobject':{'name':'SplFileObject','constants':{'DROP_NEW_LINE':'1','READ_AHEAD':'2','SKIP_EMPTY':'4','READ_CSV':'8',},'methods':{'__construct':{'signature':'string $file_name','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'getATime':{'signature':'void | int','return_type':'int'},'getBasename':{'signature':'[ string $suffix] | string','return_type':'string'},'getCTime':{'signature':'void | int','return_type':'int'},'getExtension':{'signature':'void | string','return_type':'string'},'getFileInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getFilename':{'signature':'void | string','return_type':'string'},'getGroup':{'signature':'void | int','return_type':'int'},'getInode':{'signature':'void | int','return_type':'int'},'getLinkTarget':{'signature':'void | string','return_type':'string'},'getMTime':{'signature':'void | int','return_type':'int'},'getOwner':{'signature':'void | int','return_type':'int'},'getPath':{'signature':'void | string','return_type':'string'},'getPathInfo':{'signature':'[ string $class_name] | SplFileInfo','return_type':'SplFileInfo'},'getPathname':{'signature':'void | string','return_type':'string'},'getPerms':{'signature':'void | int','return_type':'int'},'getRealPath':{'signature':'void | string','return_type':'string'},'getSize':{'signature':'void | int','return_type':'int'},'getType':{'signature':'void | string','return_type':'string'},'isDir':{'signature':'void | bool','return_type':'bool'},'isExecutable':{'signature':'void | bool','return_type':'bool'},'isFile':{'signature':'void | bool','return_type':'bool'},'isLink':{'signature':'void | bool','return_type':'bool'},'isReadable':{'signature':'void | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'openFile':{'signature':'[ string $open_mode = r [, bool $use_include_path = false [, resource $context = NULL]]] | SplFileObject','return_type':'SplFileObject'},'setFileClass':{'signature':'[ string $class_name] | void','return_type':'void'},'setInfoClass':{'signature':'[ string $class_name] | void','return_type':'void'},},},'splfixedarray':{'name':'SplFixedArray','methods':{'__construct':{'signature':'[ int $size = 0]','return_type':''},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getSize':{'signature':'void | int','return_type':'int'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'int $index | bool','return_type':'bool'},'offsetGet':{'signature':'int $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'int $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'int $index | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setSize':{'signature':'int $size | int','return_type':'int'},'toArray':{'signature':'void | array','return_type':'array'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},'static_methods':{'fromArray':{'signature':'array $array [, bool $save_indexes = true] | SplFixedArray','return_type':'SplFixedArray'},},},'splheap':{'name':'SplHeap','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splmaxheap':{'name':'SplMaxHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splminheap':{'name':'SplMinHeap','methods':{'compare':{'signature':'mixed $value1, mixed $value2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splobjectstorage':{'name':'SplObjectStorage','methods':{'addAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'attach':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'contains':{'signature':'object $object | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | object','return_type':'object'},'detach':{'signature':'object $object | void','return_type':'void'},'getHash':{'signature':'object $object | string','return_type':'string'},'getInfo':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'object $object | bool','return_type':'bool'},'offsetGet':{'signature':'object $object | mixed','return_type':'mixed'},'offsetSet':{'signature':'object $object [, mixed $data = NULL] | void','return_type':'void'},'offsetUnset':{'signature':'object $object | void','return_type':'void'},'removeAll':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'removeAllExcept':{'signature':'SplObjectStorage $storage | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'setInfo':{'signature':'mixed $data | void','return_type':'void'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splpriorityqueue':{'name':'SplPriorityQueue','methods':{'__construct':{'signature':'void','return_type':''},'compare':{'signature':'mixed $priority1, mixed $priority2 | int','return_type':'int'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'extract':{'signature':'void | mixed','return_type':'mixed'},'insert':{'signature':'mixed $value, mixed $priority | void','return_type':'void'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'recoverFromCorruption':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'setExtractFlags':{'signature':'int $flags | void','return_type':'void'},'top':{'signature':'void | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splqueue':{'name':'SplQueue','methods':{'__construct':{'signature':'void','return_type':''},'dequeue':{'signature':'void | mixed','return_type':'mixed'},'enqueue':{'signature':'mixed $value | void','return_type':'void'},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'splstack':{'name':'SplStack','methods':{'__construct':{'signature':'void','return_type':''},'setIteratorMode':{'signature':'int $mode | void','return_type':'void'},'bottom':{'signature':'void | mixed','return_type':'mixed'},'count':{'signature':'void | int','return_type':'int'},'current':{'signature':'void | mixed','return_type':'mixed'},'getIteratorMode':{'signature':'void | int','return_type':'int'},'isEmpty':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'offsetExists':{'signature':'mixed $index | bool','return_type':'bool'},'offsetGet':{'signature':'mixed $index | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $index, mixed $newval | void','return_type':'void'},'offsetUnset':{'signature':'mixed $index | void','return_type':'void'},'pop':{'signature':'void | mixed','return_type':'mixed'},'prev':{'signature':'void | void','return_type':'void'},'push':{'signature':'mixed $value | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'serialize':{'signature':'void | string','return_type':'string'},'shift':{'signature':'void | mixed','return_type':'mixed'},'top':{'signature':'void | mixed','return_type':'mixed'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},'unshift':{'signature':'mixed $value | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'spltempfileobject':{'name':'SplTempFileObject','methods':{'__construct':{'signature':'string $filename [, string $open_mode = "r" [, bool $use_include_path = false [, resource $context]]]','return_type':''},'current':{'signature':'void | string|array','return_type':'string|array'},'eof':{'signature':'void | bool','return_type':'bool'},'fflush':{'signature':'void | bool','return_type':'bool'},'fgetc':{'signature':'void | string','return_type':'string'},'fgetcsv':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | array','return_type':'array'},'fgets':{'signature':'void | string','return_type':'string'},'fgetss':{'signature':'[ string $allowable_tags] | string','return_type':'string'},'flock':{'signature':'int $operation [, int &$wouldblock] | bool','return_type':'bool'},'fpassthru':{'signature':'void | int','return_type':'int'},'fputcsv':{'signature':'array $fields [, string $delimiter = '','' [, string $enclosure = ''"'']] | int','return_type':'int'},'fscanf':{'signature':'string $format [, mixed &$...] | mixed','return_type':'mixed'},'fseek':{'signature':'int $offset [, int $whence = SEEK_SET] | int','return_type':'int'},'fstat':{'signature':'void | array','return_type':'array'},'ftell':{'signature':'void | int','return_type':'int'},'ftruncate':{'signature':'int $size | bool','return_type':'bool'},'fwrite':{'signature':'string $str [, int $length] | int','return_type':'int'},'getChildren':{'signature':'void | void','return_type':'void'},'getCsvControl':{'signature':'void | array','return_type':'array'},'getFlags':{'signature':'void | int','return_type':'int'},'getMaxLineLen':{'signature':'void | int','return_type':'int'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | int','return_type':'int'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'seek':{'signature':'int $line_pos | void','return_type':'void'},'setCsvControl':{'signature':'[ string $delimiter = "," [, string $enclosure = "\"" [, string $escape = "\\"]]] | void','return_type':'void'},'setFlags':{'signature':'int $flags | void','return_type':'void'},'setMaxLineLen':{'signature':'int $max_len | void','return_type':'void'},'__toString':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},},},'underflowexception':{'name':'UnderflowException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'unexpectedvalueexception':{'name':'UnexpectedValueException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['predefined_interfaces_and_classes']={'closure':{'name':'Closure','methods':{'__construct':{'signature':'void','return_type':''},'bindTo':{'signature':'object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},'static_methods':{'bind':{'signature':'Closure $closure, object $newthis [, mixed $newscope = ''static''] | Closure','return_type':'Closure'},},},'generator':{'name':'Generator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'send':{'signature':'mixed $value | mixed','return_type':'mixed'},'throw':{'signature':'Exception $exception | mixed','return_type':'mixed'},'valid':{'signature':'void | bool','return_type':'bool'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['curl']={'curlfile':{'name':'CURLFile','properties': {'name':{'initializer':'','type':''},'mime':{'initializer':'','type':''},'postname':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'string $filename [, string $mimetype [, string $postname]]','return_type':''},'getFilename':{'signature':'void | string','return_type':'string'},'getMimeType':{'signature':'void | string','return_type':'string'},'getPostFilename':{'signature':'void | string','return_type':'string'},'setMimeType':{'signature':'string $mime | void','return_type':'void'},'setPostFilename':{'signature':'string $postname | void','return_type':'void'},'__wakeup':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['date_time']={'dateinterval':{'name':'DateInterval','properties': {'y':{'initializer':'','type':'integer'},'m':{'initializer':'','type':'integer'},'d':{'initializer':'','type':'integer'},'h':{'initializer':'','type':'integer'},'i':{'initializer':'','type':'integer'},'s':{'initializer':'','type':'integer'},'invert':{'initializer':'','type':'integer'},'days':{'initializer':'','type':'mixed'},},'methods':{'__construct':{'signature':'string $interval_spec','return_type':''},'format':{'signature':'string $format | string','return_type':'string'},},'static_methods':{'createFromDateString':{'signature':'string $time | DateInterval','return_type':'DateInterval'},},},'dateperiod':{'name':'DatePeriod','constants':{'EXCLUDE_START_DATE':'1',},'methods':{'__construct':{'signature':'string $isostr [, int $options]','return_type':''},},},'datetime':{'name':'DateTime','constants':{'ATOM':'"Y-m-d\TH:i:sP"','COOKIE':'"l, d-M-y H:i:s T"','ISO8601':'"Y-m-d\TH:i:sO"','RFC822':'"D, d M y H:i:s O"','RFC850':'"l, d-M-y H:i:s T"','RFC1036':'"D, d M y H:i:s O"','RFC1123':'"D, d M Y H:i:s O"','RFC2822':'"D, d M Y H:i:s O"','RFC3339':'"Y-m-d\TH:i:sP"','RSS':'"D, d M Y H:i:s O"','W3C':'"Y-m-d\TH:i:sP"',},'methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'modify':{'signature':'string $modify | DateTime','return_type':'DateTime'},'setDate':{'signature':'int $year, int $month, int $day | DateTime','return_type':'DateTime'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTime','return_type':'DateTime'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTime','return_type':'DateTime'},'setTimestamp':{'signature':'int $unixtimestamp | DateTime','return_type':'DateTime'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTime','return_type':'DateTime'},'sub':{'signature':'DateInterval $interval | DateTime','return_type':'DateTime'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTime','return_type':'DateTime'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTime','return_type':'DateTime'},},},'datetimeimmutable':{'name':'DateTimeImmutable','methods':{'__construct':{'signature':'[ string $time = "now" [, DateTimeZone $timezone = NULL]]','return_type':''},'add':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'modify':{'signature':'string $modify | DateTimeImmutable','return_type':'DateTimeImmutable'},'setDate':{'signature':'int $year, int $month, int $day | DateTimeImmutable','return_type':'DateTimeImmutable'},'setISODate':{'signature':'int $year, int $week [, int $day = 1] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTime':{'signature':'int $hour, int $minute [, int $second = 0] | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimestamp':{'signature':'int $unixtimestamp | DateTimeImmutable','return_type':'DateTimeImmutable'},'setTimezone':{'signature':'DateTimeZone $timezone | DateTimeImmutable','return_type':'DateTimeImmutable'},'sub':{'signature':'DateInterval $interval | DateTimeImmutable','return_type':'DateTimeImmutable'},'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},'static_methods':{'createFromFormat':{'signature':'string $format, string $time [, DateTimeZone $timezone] | DateTimeImmutable','return_type':'DateTimeImmutable'},'getLastErrors':{'signature':'void | array','return_type':'array'},'__set_state':{'signature':'array $array | DateTimeImmutable','return_type':'DateTimeImmutable'},},},'datetimezone':{'name':'DateTimeZone','constants':{'AFRICA':'1','AMERICA':'2','ANTARCTICA':'4','ARCTIC':'8','ASIA':'16','ATLANTIC':'32','AUSTRALIA':'64','EUROPE':'128','INDIAN':'256','PACIFIC':'512','UTC':'1024','ALL':'2047','ALL_WITH_BC':'4095','PER_COUNTRY':'4096',},'methods':{'__construct':{'signature':'string $timezone','return_type':''},'getLocation':{'signature':'void | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getOffset':{'signature':'DateTime $datetime | int','return_type':'int'},'getTransitions':{'signature':'[ int $timestamp_begin [, int $timestamp_end]] | array','return_type':'array'},},'static_methods':{'listAbbreviations':{'signature':'void | array','return_type':'array'},'listIdentifiers':{'signature':'[ int $what = DateTimeZone::ALL [, string $country = NULL]] | array','return_type':'array'},},},}
let php_builtin['classes']['directories']={'directory':{'name':'Directory','properties': {'path':{'initializer':'','type':'string'},'handle':{'initializer':'','type':'resource'},},'methods':{'close':{'signature':'[ resource $dir_handle] | void','return_type':'void'},'read':{'signature':'[ resource $dir_handle] | string','return_type':'string'},'rewind':{'signature':'[ resource $dir_handle] | void','return_type':'void'},},},}
let php_builtin['classes']['dom']={'domattr':{'name':'DOMAttr','properties': {'name':{'initializer':'','type':'string'},'ownerElement':{'initializer':'','type':'DOMElement'},'schemaTypeInfo':{'initializer':'','type':'bool'},'specified':{'initializer':'','type':'bool'},'value':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'isId':{'signature':'void | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcdatasection':{'name':'DOMCdataSection','methods':{'__construct':{'signature':'string $value','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},},},'domcharacterdata':{'name':'DOMCharacterData','properties': {'data':{'initializer':'','type':'string'},'length':{'initializer':'','type':'int'},},'methods':{'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domcomment':{'name':'DOMComment','methods':{'__construct':{'signature':'[ string $value]','return_type':''},'appendData':{'signature':'string $data | void','return_type':'void'},'deleteData':{'signature':'int $offset, int $count | void','return_type':'void'},'insertData':{'signature':'int $offset, string $data | void','return_type':'void'},'replaceData':{'signature':'int $offset, int $count, string $data | void','return_type':'void'},'substringData':{'signature':'int $offset, int $count | string','return_type':'string'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocument':{'name':'DOMDocument','properties': {'actualEncoding':{'initializer':'','type':'string'},'config':{'initializer':'','type':'DOMConfiguration'},'doctype':{'initializer':'','type':'DOMDocumentType'},'documentElement':{'initializer':'','type':'DOMElement'},'documentURI':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'formatOutput':{'initializer':'','type':'bool'},'implementation':{'initializer':'','type':'DOMImplementation'},'preserveWhiteSpace':{'initializer':'true','type':'bool'},'recover':{'initializer':'','type':'bool'},'resolveExternals':{'initializer':'','type':'bool'},'standalone':{'initializer':'','type':'bool'},'strictErrorChecking':{'initializer':'true','type':'bool'},'substituteEntities':{'initializer':'','type':'bool'},'validateOnParse':{'initializer':'false','type':'bool'},'version':{'initializer':'','type':'string'},'xmlEncoding':{'initializer':'','type':'string'},'xmlStandalone':{'initializer':'','type':'bool'},'xmlVersion':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $version [, string $encoding]]','return_type':''},'createAttribute':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'createAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName | DOMAttr','return_type':'DOMAttr'},'createCDATASection':{'signature':'string $data | DOMCDATASection','return_type':'DOMCDATASection'},'createComment':{'signature':'string $data | DOMComment','return_type':'DOMComment'},'createDocumentFragment':{'signature':'void | DOMDocumentFragment','return_type':'DOMDocumentFragment'},'createElement':{'signature':'string $name [, string $value] | DOMElement','return_type':'DOMElement'},'createElementNS':{'signature':'string $namespaceURI, string $qualifiedName [, string $value] | DOMElement','return_type':'DOMElement'},'createEntityReference':{'signature':'string $name | DOMEntityReference','return_type':'DOMEntityReference'},'createProcessingInstruction':{'signature':'string $target [, string $data] | DOMProcessingInstruction','return_type':'DOMProcessingInstruction'},'createTextNode':{'signature':'string $content | DOMText','return_type':'DOMText'},'getElementById':{'signature':'string $elementId | DOMElement','return_type':'DOMElement'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'importNode':{'signature':'DOMNode $importedNode [, bool $deep] | DOMNode','return_type':'DOMNode'},'load':{'signature':'string $filename [, int $options = 0] | mixed','return_type':'mixed'},'loadHTML':{'signature':'string $source [, int $options = 0] | bool','return_type':'bool'},'loadHTMLFile':{'signature':'string $filename [, int $options = 0] | bool','return_type':'bool'},'loadXML':{'signature':'string $source [, int $options = 0] | mixed','return_type':'mixed'},'normalizeDocument':{'signature':'void | void','return_type':'void'},'registerNodeClass':{'signature':'string $baseclass, string $extendedclass | bool','return_type':'bool'},'relaxNGValidate':{'signature':'string $filename | bool','return_type':'bool'},'relaxNGValidateSource':{'signature':'string $source | bool','return_type':'bool'},'save':{'signature':'string $filename [, int $options] | int','return_type':'int'},'saveHTML':{'signature':'[ DOMNode $node = NULL] | string','return_type':'string'},'saveHTMLFile':{'signature':'string $filename | int','return_type':'int'},'saveXML':{'signature':'[ DOMNode $node [, int $options]] | string','return_type':'string'},'schemaValidate':{'signature':'string $filename [, int $flags] | bool','return_type':'bool'},'schemaValidateSource':{'signature':'string $source [, int $flags] | bool','return_type':'bool'},'validate':{'signature':'void | bool','return_type':'bool'},'xinclude':{'signature':'[ int $options] | int','return_type':'int'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumentfragment':{'name':'DOMDocumentFragment','methods':{'appendXML':{'signature':'string $data | bool','return_type':'bool'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domdocumenttype':{'name':'DOMDocumentType','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'entities':{'initializer':'','type':'DOMNamedNodeMap'},'notations':{'initializer':'','type':'DOMNamedNodeMap'},'internalSubset':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domelement':{'name':'DOMElement','properties': {'schemaTypeInfo':{'initializer':'','type':'bool'},'tagName':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value [, string $namespaceURI]]','return_type':''},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNode':{'signature':'string $name | DOMAttr','return_type':'DOMAttr'},'getAttributeNodeNS':{'signature':'string $namespaceURI, string $localName | DOMAttr','return_type':'DOMAttr'},'getAttributeNS':{'signature':'string $namespaceURI, string $localName | string','return_type':'string'},'getElementsByTagName':{'signature':'string $name | DOMNodeList','return_type':'DOMNodeList'},'getElementsByTagNameNS':{'signature':'string $namespaceURI, string $localName | DOMNodeList','return_type':'DOMNodeList'},'hasAttribute':{'signature':'string $name | bool','return_type':'bool'},'hasAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'removeAttribute':{'signature':'string $name | bool','return_type':'bool'},'removeAttributeNode':{'signature':'DOMAttr $oldnode | bool','return_type':'bool'},'removeAttributeNS':{'signature':'string $namespaceURI, string $localName | bool','return_type':'bool'},'setAttribute':{'signature':'string $name, string $value | DOMAttr','return_type':'DOMAttr'},'setAttributeNode':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNodeNS':{'signature':'DOMAttr $attr | DOMAttr','return_type':'DOMAttr'},'setAttributeNS':{'signature':'string $namespaceURI, string $qualifiedName, string $value | void','return_type':'void'},'setIdAttribute':{'signature':'string $name, bool $isId | void','return_type':'void'},'setIdAttributeNode':{'signature':'DOMAttr $attr, bool $isId | void','return_type':'void'},'setIdAttributeNS':{'signature':'string $namespaceURI, string $localName, bool $isId | void','return_type':'void'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentity':{'name':'DOMEntity','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},'notationName':{'initializer':'','type':'string'},'actualEncoding':{'initializer':'','type':'string'},'encoding':{'initializer':'','type':'string'},'version':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domentityreference':{'name':'DOMEntityReference','methods':{'__construct':{'signature':'string $name','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domexception':{'name':'DOMException','properties': {'code':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'domimplementation':{'name':'DOMImplementation','methods':{'__construct':{'signature':'void','return_type':''},'createDocument':{'signature':'[ string $namespaceURI = NULL [, string $qualifiedName = NULL [, DOMDocumentType $doctype = NULL]]] | DOMDocument','return_type':'DOMDocument'},'createDocumentType':{'signature':'[ string $qualifiedName = NULL [, string $publicId = NULL [, string $systemId = NULL]]] | DOMDocumentType','return_type':'DOMDocumentType'},'hasFeature':{'signature':'string $feature, string $version | bool','return_type':'bool'},},},'domnamednodemap':{'name':'DOMNamedNodeMap','properties': {'length':{'initializer':'','type':'int'},},'methods':{'getNamedItem':{'signature':'string $name | DOMNode','return_type':'DOMNode'},'getNamedItemNS':{'signature':'string $namespaceURI, string $localName | DOMNode','return_type':'DOMNode'},'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnode':{'name':'DOMNode','properties': {'nodeName':{'initializer':'','type':'string'},'nodeValue':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'parentNode':{'initializer':'','type':'DOMNode'},'childNodes':{'initializer':'','type':'DOMNodeList'},'firstChild':{'initializer':'','type':'DOMNode'},'lastChild':{'initializer':'','type':'DOMNode'},'previousSibling':{'initializer':'','type':'DOMNode'},'nextSibling':{'initializer':'','type':'DOMNode'},'attributes':{'initializer':'','type':'DOMNamedNodeMap'},'ownerDocument':{'initializer':'','type':'DOMDocument'},'namespaceURI':{'initializer':'','type':'string'},'prefix':{'initializer':'','type':'string'},'localName':{'initializer':'','type':'string'},'baseURI':{'initializer':'','type':'string'},'textContent':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domnodelist':{'name':'DOMNodeList','properties': {'length':{'initializer':'','type':'int'},},'methods':{'item':{'signature':'int $index | DOMNode','return_type':'DOMNode'},},},'domnotation':{'name':'DOMNotation','properties': {'publicId':{'initializer':'','type':'string'},'systemId':{'initializer':'','type':'string'},},'methods':{'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domprocessinginstruction':{'name':'DOMProcessingInstruction','properties': {'target':{'initializer':'','type':'string'},'data':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'string $name [, string $value]','return_type':''},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domtext':{'name':'DOMText','properties': {'wholeText':{'initializer':'','type':'string'},},'methods':{'__construct':{'signature':'[ string $value]','return_type':''},'isWhitespaceInElementContent':{'signature':'void | bool','return_type':'bool'},'splitText':{'signature':'int $offset | DOMText','return_type':'DOMText'},'appendChild':{'signature':'DOMNode $newnode | DOMNode','return_type':'DOMNode'},'C14N':{'signature':'[ bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | string','return_type':'string'},'C14NFile':{'signature':'string $uri [, bool $exclusive [, bool $with_comments [, array $xpath [, array $ns_prefixes]]]] | int','return_type':'int'},'cloneNode':{'signature':'[ bool $deep] | DOMNode','return_type':'DOMNode'},'getLineNo':{'signature':'void | int','return_type':'int'},'getNodePath':{'signature':'void | string','return_type':'string'},'hasAttributes':{'signature':'void | bool','return_type':'bool'},'hasChildNodes':{'signature':'void | bool','return_type':'bool'},'insertBefore':{'signature':'DOMNode $newnode [, DOMNode $refnode] | DOMNode','return_type':'DOMNode'},'isDefaultNamespace':{'signature':'string $namespaceURI | bool','return_type':'bool'},'isSameNode':{'signature':'DOMNode $node | bool','return_type':'bool'},'isSupported':{'signature':'string $feature, string $version | bool','return_type':'bool'},'lookupNamespaceURI':{'signature':'string $prefix | string','return_type':'string'},'lookupPrefix':{'signature':'string $namespaceURI | string','return_type':'string'},'normalize':{'signature':'void | void','return_type':'void'},'removeChild':{'signature':'DOMNode $oldnode | DOMNode','return_type':'DOMNode'},'replaceChild':{'signature':'DOMNode $newnode, DOMNode $oldnode | DOMNode','return_type':'DOMNode'},},},'domxpath':{'name':'DOMXPath','properties': {'document':{'initializer':'','type':'DOMDocument'},},'methods':{'__construct':{'signature':'DOMDocument $doc','return_type':''},'evaluate':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | mixed','return_type':'mixed'},'query':{'signature':'string $expression [, DOMNode $contextnode [, bool $registerNodeNS = true]] | DOMNodeList','return_type':'DOMNodeList'},'registerNamespace':{'signature':'string $prefix, string $namespaceURI | bool','return_type':'bool'},'registerPhpFunctions':{'signature':'[ mixed $restrict] | void','return_type':'void'},},},}
let php_builtin['classes']['predefined_exceptions']={'errorexception':{'name':'ErrorException','properties': {'severity':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, int $severity = 1 [, string $filename = __FILE__ [, int $lineno = __LINE__ [, Exception $previous = NULL]]]]]]','return_type':''},'getSeverity':{'signature':'void | int','return_type':'int'},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'exception':{'name':'Exception','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $message = "" [, int $code = 0 [, Exception $previous = NULL]]]','return_type':''},'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['classes']['libxml']={'libxmlerror':{'name':'libXMLError','properties': {'level':{'initializer':'','type':'int'},'code':{'initializer':'','type':'int'},'column':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},}
let php_builtin['classes']['mysqli']={'mysqli_driver':{'name':'mysqli_driver','properties': {'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'string'},'driver_version':{'initializer':'','type':'string'},'embedded':{'initializer':'','type':'string'},'reconnect':{'initializer':'','type':'bool'},'report_mode':{'initializer':'','type':'int'},},'methods':{'embedded_server_end':{'signature':'void | void','return_type':'void'},'embedded_server_start':{'signature':'bool $start, array $arguments, array $groups | bool','return_type':'bool'},},},'mysqli_result':{'name':'mysqli_result','properties': {'current_field':{'initializer':'','type':'int'},'field_count':{'initializer':'','type':'int'},'lengths':{'initializer':'','type':'array'},'num_rows':{'initializer':'','type':'int'},},'methods':{'data_seek':{'signature':'int $offset | bool','return_type':'bool'},'fetch_all':{'signature':'[ int $resulttype = MYSQLI_NUM] | mixed','return_type':'mixed'},'fetch_array':{'signature':'[ int $resulttype = MYSQLI_BOTH] | mixed','return_type':'mixed'},'fetch_assoc':{'signature':'void | array','return_type':'array'},'fetch_field_direct':{'signature':'int $fieldnr | object','return_type':'object'},'fetch_field':{'signature':'void | object','return_type':'object'},'fetch_fields':{'signature':'void | array','return_type':'array'},'fetch_object':{'signature':'[ string $class_name [, array $params]] | object','return_type':'object'},'fetch_row':{'signature':'void | mixed','return_type':'mixed'},'field_seek':{'signature':'int $fieldnr | bool','return_type':'bool'},'free':{'signature':'void | void','return_type':'void'},},},'mysqli_sql_exception':{'name':'mysqli_sql_exception','properties': {'sqlstate':{'initializer':'','type':'string'},'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},},'mysqli_stmt':{'name':'mysqli_stmt','properties': {'affected_rows':{'initializer':'','type':'int'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'insert_id':{'initializer':'','type':'int'},'num_rows':{'initializer':'','type':'int'},'param_count':{'initializer':'','type':'int'},'sqlstate':{'initializer':'','type':'string'},},'methods':{'attr_get':{'signature':'int $attr | int','return_type':'int'},'attr_set':{'signature':'int $attr, int $mode | bool','return_type':'bool'},'bind_param':{'signature':'string $types, mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'bind_result':{'signature':'mixed &$var1 [, mixed &$...] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'data_seek':{'signature':'int $offset | void','return_type':'void'},'execute':{'signature':'void | bool','return_type':'bool'},'fetch':{'signature':'void | bool','return_type':'bool'},'free_result':{'signature':'void | void','return_type':'void'},'get_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'get_warnings':{'signature':'mysqli_stmt $stmt | object','return_type':'object'},'prepare':{'signature':'string $query | mixed','return_type':'mixed'},'reset':{'signature':'void | bool','return_type':'bool'},'result_metadata':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'send_long_data':{'signature':'int $param_nr, string $data | bool','return_type':'bool'},'store_result':{'signature':'void | bool','return_type':'bool'},},},'mysqli_warning':{'name':'mysqli_warning','properties': {'message':{'initializer':'','type':''},'sqlstate':{'initializer':'','type':''},'errno':{'initializer':'','type':''},},'methods':{'__construct':{'signature':'void','return_type':''},'next':{'signature':'void | void','return_type':'void'},},},'mysqli':{'name':'mysqli','properties': {'affected_rows':{'initializer':'','type':'int'},'client_info':{'initializer':'','type':'string'},'client_version':{'initializer':'','type':'int'},'connect_errno':{'initializer':'','type':'string'},'connect_error':{'initializer':'','type':'string'},'errno':{'initializer':'','type':'int'},'error_list':{'initializer':'','type':'array'},'error':{'initializer':'','type':'string'},'field_count':{'initializer':'','type':'int'},'host_info':{'initializer':'','type':'string'},'protocol_version':{'initializer':'','type':'string'},'server_info':{'initializer':'','type':'string'},'server_version':{'initializer':'','type':'int'},'info':{'initializer':'','type':'string'},'insert_id':{'initializer':'','type':'mixed'},'sqlstate':{'initializer':'','type':'string'},'thread_id':{'initializer':'','type':'int'},'warning_count':{'initializer':'','type':'int'},},'methods':{'__construct':{'signature':'[ string $host = ini_get("mysqli.default_host") [, string $username = ini_get("mysqli.default_user") [, string $passwd = ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port = ini_get("mysqli.default_port") [, string $socket = ini_get("mysqli.default_socket")]]]]]]','return_type':''},'autocommit':{'signature':'bool $mode | bool','return_type':'bool'},'change_user':{'signature':'string $user, string $password, string $database | bool','return_type':'bool'},'character_set_name':{'signature':'void | string','return_type':'string'},'close':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'debug':{'signature':'string $message | bool','return_type':'bool'},'dump_debug_info':{'signature':'void | bool','return_type':'bool'},'get_charset':{'signature':'void | object','return_type':'object'},'get_client_info':{'signature':'void | string','return_type':'string'},'get_connection_stats':{'signature':'void | bool','return_type':'bool'},'get_warnings':{'signature':'void | mysqli_warning','return_type':'mysqli_warning'},'init':{'signature':'void | mysqli','return_type':'mysqli'},'kill':{'signature':'int $processid | bool','return_type':'bool'},'more_results':{'signature':'void | bool','return_type':'bool'},'multi_query':{'signature':'string $query | bool','return_type':'bool'},'next_result':{'signature':'void | bool','return_type':'bool'},'options':{'signature':'int $option, mixed $value | bool','return_type':'bool'},'ping':{'signature':'void | bool','return_type':'bool'},'prepare':{'signature':'string $query | mysqli_stmt','return_type':'mysqli_stmt'},'query':{'signature':'string $query [, int $resultmode = MYSQLI_STORE_RESULT] | mixed','return_type':'mixed'},'real_connect':{'signature':'[ string $host [, string $username [, string $passwd [, string $dbname [, int $port [, string $socket [, int $flags]]]]]]] | bool','return_type':'bool'},'escape_string':{'signature':'string $escapestr | string','return_type':'string'},'real_query':{'signature':'string $query | bool','return_type':'bool'},'reap_async_query':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'refresh':{'signature':'int $options | bool','return_type':'bool'},'rollback':{'signature':'[ int $flags [, string $name]] | bool','return_type':'bool'},'rpl_query_type':{'signature':'string $query | int','return_type':'int'},'select_db':{'signature':'string $dbname | bool','return_type':'bool'},'send_query':{'signature':'string $query | bool','return_type':'bool'},'set_charset':{'signature':'string $charset | bool','return_type':'bool'},'set_local_infile_handler':{'signature':'mysqli $link, callable $read_func | bool','return_type':'bool'},'ssl_set':{'signature':'string $key, string $cert, string $ca, string $capath, string $cipher | bool','return_type':'bool'},'stat':{'signature':'void | string','return_type':'string'},'stmt_init':{'signature':'void | mysqli_stmt','return_type':'mysqli_stmt'},'store_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},'use_result':{'signature':'void | mysqli_result','return_type':'mysqli_result'},},'static_methods':{'poll':{'signature':'array &$read, array &$error, array &$reject, int $sec [, int $usec] | int','return_type':'int'},},},}
let php_builtin['classes']['pdo']={'pdo':{'name':'PDO','constants':{'FETCH_ORI_ABS':'','ATTR_PERSISTENT':'','CLASS_CONSTANT':'','ATTR_DEFAULT_FETCH_MODE':'','FETCH_PROPS_LATE':'','FETCH_KEY_PAIR':'','FB_ATTR_DATE_FORMAT':'','FB_ATTR_TIME_FORMAT':'','FB_ATTR_TIMESTAMP_FORMAT':'','MYSQL_ATTR_READ_DEFAULT_FILE':'','MYSQL_ATTR_READ_DEFAULT_GROUP':'','ATTR_AUTOCOMMIT':'','FOURD_ATTR_CHARSET':'','FOURD_ATTR_PREFERRED_IMAGE_TYPES':'','PARAM_LOB':'','PARAM_BOOL':'','PARAM_NULL':'','PARAM_INT':'','PARAM_STR':'','PARAM_STMT':'','PARAM_INPUT_OUTPUT':'','FETCH_LAZY':'','FETCH_ASSOC':'','FETCH_NAMED':'','FETCH_NUM':'','FETCH_BOTH':'','FETCH_OBJ':'','FETCH_BOUND':'','FETCH_COLUMN':'','FETCH_CLASS':'','FETCH_INTO':'','FETCH_FUNC':'','FETCH_GROUP':'','FETCH_UNIQUE':'','FETCH_CLASSTYPE':'','FETCH_SERIALIZE':'','ATTR_PREFETCH':'','ATTR_TIMEOUT':'','ATTR_ERRMODE':'','ATTR_SERVER_VERSION':'','ATTR_CLIENT_VERSION':'','ATTR_SERVER_INFO':'','ATTR_CONNECTION_STATUS':'','ATTR_CASE':'','ATTR_CURSOR_NAME':'','ATTR_CURSOR':'','CURSOR_FWDONLY':'','CURSOR_SCROLL':'','ATTR_DRIVER_NAME':'','ATTR_ORACLE_NULLS':'','ATTR_STATEMENT_CLASS':'','ATTR_FETCH_CATALOG_NAMES':'','ATTR_FETCH_TABLE_NAMES':'','ATTR_STRINGIFY_FETCHES':'','ATTR_MAX_COLUMN_LEN':'','ATTR_EMULATE_PREPARES':'','ERRMODE_SILENT':'','ERRMODE_WARNING':'','ERRMODE_EXCEPTION':'','CASE_NATURAL':'','CASE_LOWER':'','CASE_UPPER':'','NULL_NATURAL':'','NULL_EMPTY_STRING':'','NULL_TO_STRING':'','FETCH_ORI_NEXT':'','FETCH_ORI_PRIOR':'','FETCH_ORI_FIRST':'','FETCH_ORI_LAST':'','FETCH_ORI_REL':'','ERR_NONE':'','PARAM_EVT_ALLOC':'','PARAM_EVT_FREE':'','PARAM_EVT_EXEC_PRE':'','PARAM_EVT_EXEC_POST':'','PARAM_EVT_FETCH_PRE':'','PARAM_EVT_FETCH_POST':'','PARAM_EVT_NORMALIZE':'','MYSQL_ATTR_INIT_COMMAND':'','MYSQL_ATTR_USE_BUFFERED_QUERY':'','MYSQL_ATTR_LOCAL_INFILE':'','MYSQL_ATTR_MAX_BUFFER_SIZE':'','MYSQL_ATTR_DIRECT_QUERY':'','MYSQL_ATTR_FOUND_ROWS':'','MYSQL_ATTR_IGNORE_SPACE':'','MYSQL_ATTR_COMPRESS':'','MYSQL_ATTR_SSL_CA':'','MYSQL_ATTR_SSL_CAPATH':'','MYSQL_ATTR_SSL_CERT':'','MYSQL_ATTR_SSL_CIPHER':'','MYSQL_ATTR_SSL_KEY':'','SQLSRV_TXN_READ_UNCOMMITTED':'','SQLSRV_TXN_READ_COMMITTED':'','SQLSRV_TXN_REPEATABLE_READ':'','SQLSRV_TXN_SNAPSHOT':'','SQLSRV_TXN_SERIALIZABLE':'','SQLSRV_ENCODING_BINARY':'','SQLSRV_ENCODING_SYSTEM':'','SQLSRV_ENCODING_UTF8':'','SQLSRV_ENCODING_DEFAULT':'','SQLSRV_ATTR_QUERY_TIMEOUT':'','SQLSRV_ATTR_DIRECT_QUERY':'',},'methods':{'__construct':{'signature':'string $dsn [, string $username [, string $password [, array $driver_options]]]','return_type':''},'beginTransaction':{'signature':'void | bool','return_type':'bool'},'commit':{'signature':'void | bool','return_type':'bool'},'errorCode':{'signature':'void | mixed','return_type':'mixed'},'errorInfo':{'signature':'void | array','return_type':'array'},'exec':{'signature':'string $statement | int','return_type':'int'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'inTransaction':{'signature':'void | bool','return_type':'bool'},'lastInsertId':{'signature':'[ string $name = NULL] | string','return_type':'string'},'prepare':{'signature':'string $statement [, array $driver_options = array()] | PDOStatement','return_type':'PDOStatement'},'query':{'signature':'string $statement | PDOStatement','return_type':'PDOStatement'},'quote':{'signature':'string $string [, int $parameter_type = PDO::PARAM_STR] | string','return_type':'string'},'rollBack':{'signature':'void | bool','return_type':'bool'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},},'static_methods':{'getAvailableDrivers':{'signature':'void | array','return_type':'array'},},},'pdoexception':{'name':'PDOException','properties': {'errorInfo':{'initializer':'','type':'array'},'code':{'initializer':'','type':'int'},'message':{'initializer':'','type':'string'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pdostatement':{'name':'PDOStatement','properties': {'queryString':{'initializer':'','type':'string'},},'methods':{'bindColumn':{'signature':'mixed $column, mixed &$param [, int $type [, int $maxlen [, mixed $driverdata]]] | bool','return_type':'bool'},'bindParam':{'signature':'mixed $parameter, mixed &$variable [, int $data_type = PDO::PARAM_STR [, int $length [, mixed $driver_options]]] | bool','return_type':'bool'},'bindValue':{'signature':'mixed $parameter, mixed $value [, int $data_type = PDO::PARAM_STR] | bool','return_type':'bool'},'closeCursor':{'signature':'void | bool','return_type':'bool'},'columnCount':{'signature':'void | int','return_type':'int'},'debugDumpParams':{'signature':'void | void','return_type':'void'},'errorCode':{'signature':'void | string','return_type':'string'},'errorInfo':{'signature':'void | array','return_type':'array'},'execute':{'signature':'[ array $input_parameters] | bool','return_type':'bool'},'fetch':{'signature':'[ int $fetch_style [, int $cursor_orientation = PDO::FETCH_ORI_NEXT [, int $cursor_offset = 0]]] | mixed','return_type':'mixed'},'fetchAll':{'signature':'[ int $fetch_style [, mixed $fetch_argument [, array $ctor_args = array()]]] | array','return_type':'array'},'fetchColumn':{'signature':'[ int $column_number = 0] | string','return_type':'string'},'fetchObject':{'signature':'[ string $class_name = "stdClass" [, array $ctor_args]] | mixed','return_type':'mixed'},'getAttribute':{'signature':'int $attribute | mixed','return_type':'mixed'},'getColumnMeta':{'signature':'int $column | array','return_type':'array'},'nextRowset':{'signature':'void | bool','return_type':'bool'},'rowCount':{'signature':'void | int','return_type':'int'},'setAttribute':{'signature':'int $attribute, mixed $value | bool','return_type':'bool'},'setFetchMode':{'signature':'int $mode | bool','return_type':'bool'},},},}
let php_builtin['classes']['phar']={'phar':{'name':'Phar','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'phardata':{'name':'PharData','methods':{'addEmptyDir':{'signature':'string $dirname | void','return_type':'void'},'addFile':{'signature':'string $file [, string $localname] | void','return_type':'void'},'addFromString':{'signature':'string $localname, string $contents | void','return_type':'void'},'buildFromDirectory':{'signature':'string $base_dir [, string $regex] | array','return_type':'array'},'buildFromIterator':{'signature':'Iterator $iter [, string $base_directory] | array','return_type':'array'},'compress':{'signature':'int $compression [, string $extension] | object','return_type':'object'},'compressFiles':{'signature':'int $compression | void','return_type':'void'},'__construct':{'signature':'string $fname [, int $flags [, string $alias]]','return_type':''},'convertToData':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | PharData','return_type':'PharData'},'convertToExecutable':{'signature':'[ int $format = 9021976 [, int $compression = 9021976 [, string $extension]]] | Phar','return_type':'Phar'},'copy':{'signature':'string $oldfile, string $newfile | bool','return_type':'bool'},'decompress':{'signature':'[ string $extension] | object','return_type':'object'},'decompressFiles':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'delete':{'signature':'string $entry | bool','return_type':'bool'},'extractTo':{'signature':'string $pathto [, string|array $files [, bool $overwrite = false]] | bool','return_type':'bool'},'isWritable':{'signature':'void | bool','return_type':'bool'},'offsetSet':{'signature':'string $offset, string $value | void','return_type':'void'},'offsetUnset':{'signature':'string $offset | bool','return_type':'bool'},'setAlias':{'signature':'string $alias | bool','return_type':'bool'},'setDefaultStub':{'signature':'[ string $index [, string $webindex]] | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setSignatureAlgorithm':{'signature':'int $sigtype [, string $privatekey] | void','return_type':'void'},'setStub':{'signature':'string $stub [, int $len = -1] | bool','return_type':'bool'},'compressAllFilesBZIP2':{'signature':'void | bool','return_type':'bool'},'compressAllFilesGZ':{'signature':'void | bool','return_type':'bool'},'count':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getModified':{'signature':'void | bool','return_type':'bool'},'getSignature':{'signature':'void | array','return_type':'array'},'getStub':{'signature':'void | string','return_type':'string'},'getVersion':{'signature':'void | string','return_type':'string'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isBuffering':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'void | mixed','return_type':'mixed'},'isFileFormat':{'signature':'int $format | bool','return_type':'bool'},'offsetExists':{'signature':'string $offset | bool','return_type':'bool'},'offsetGet':{'signature':'string $offset | int','return_type':'int'},'startBuffering':{'signature':'void | void','return_type':'void'},'stopBuffering':{'signature':'void | void','return_type':'void'},'uncompressAllFiles':{'signature':'void | bool','return_type':'bool'},},'static_methods':{'apiVersion':{'signature':'void | string','return_type':'string'},'canCompress':{'signature':'[ int $type = 0] | bool','return_type':'bool'},'canWrite':{'signature':'void | bool','return_type':'bool'},'createDefaultStub':{'signature':'[ string $indexfile [, string $webindexfile]] | string','return_type':'string'},'getSupportedCompression':{'signature':'void | array','return_type':'array'},'getSupportedSignatures':{'signature':'void | array','return_type':'array'},'interceptFileFuncs':{'signature':'void | void','return_type':'void'},'isValidPharFilename':{'signature':'string $filename [, bool $executable = true] | bool','return_type':'bool'},'loadPhar':{'signature':'string $filename [, string $alias] | bool','return_type':'bool'},'mapPhar':{'signature':'[ string $alias [, int $dataoffset = 0]] | bool','return_type':'bool'},'mount':{'signature':'string $pharpath, string $externalpath | void','return_type':'void'},'mungServer':{'signature':'array $munglist | void','return_type':'void'},'running':{'signature':'[ bool $retphar = true] | string','return_type':'string'},'unlinkArchive':{'signature':'string $archive | bool','return_type':'bool'},'webPhar':{'signature':'[ string $alias [, string $index = "index.php" [, string $f404 [, array $mimetypes [, callable $rewrites]]]]] | void','return_type':'void'},},},'pharexception':{'name':'PharException','properties': {'message':{'initializer':'','type':'string'},'code':{'initializer':'','type':'int'},'file':{'initializer':'','type':'string'},'line':{'initializer':'','type':'int'},},'methods':{'getMessage':{'signature':'void | string','return_type':'string'},'getPrevious':{'signature':'void | Exception','return_type':'Exception'},'getCode':{'signature':'void | mixed','return_type':'mixed'},'getFile':{'signature':'void | string','return_type':'string'},'getLine':{'signature':'void | int','return_type':'int'},'getTrace':{'signature':'void | array','return_type':'array'},'getTraceAsString':{'signature':'void | string','return_type':'string'},'__toString':{'signature':'void | string','return_type':'string'},'__clone':{'signature':'void | void','return_type':'void'},},},'pharfileinfo':{'name':'PharFileInfo','methods':{'chmod':{'signature':'int $permissions | void','return_type':'void'},'compress':{'signature':'int $compression | bool','return_type':'bool'},'__construct':{'signature':'string $entry','return_type':''},'decompress':{'signature':'void | bool','return_type':'bool'},'delMetadata':{'signature':'void | bool','return_type':'bool'},'getCRC32':{'signature':'void | int','return_type':'int'},'getCompressedSize':{'signature':'void | int','return_type':'int'},'getMetadata':{'signature':'void | mixed','return_type':'mixed'},'getPharFlags':{'signature':'void | int','return_type':'int'},'hasMetadata':{'signature':'void | bool','return_type':'bool'},'isCRCChecked':{'signature':'void | bool','return_type':'bool'},'isCompressed':{'signature':'[ int $compression_type = 9021976] | bool','return_type':'bool'},'isCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'isCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setCompressedBZIP2':{'signature':'void | bool','return_type':'bool'},'setCompressedGZ':{'signature':'void | bool','return_type':'bool'},'setMetadata':{'signature':'mixed $metadata | void','return_type':'void'},'setUncompressed':{'signature':'void | bool','return_type':'bool'},},},}
let php_builtin['classes']['streams']={'php_user_filter':{'name':'php_user_filter','properties': {'filtername':{'initializer':'','type':''},'params':{'initializer':'','type':''},},'methods':{'filter':{'signature':'resource $in, resource $out, int &$consumed, bool $closing | int','return_type':'int'},'onClose':{'signature':'void | void','return_type':'void'},'onCreate':{'signature':'void | bool','return_type':'bool'},},},}
let php_builtin['classes']['sessions']={'sessionhandler':{'name':'SessionHandler','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'int $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $session_id | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},'sessionhandlerinterface':{'name':'SessionHandlerInterface','methods':{'close':{'signature':'void | bool','return_type':'bool'},'destroy':{'signature':'string $session_id | bool','return_type':'bool'},'gc':{'signature':'string $maxlifetime | bool','return_type':'bool'},'open':{'signature':'string $save_path, string $name | bool','return_type':'bool'},'read':{'signature':'string $session_id | string','return_type':'string'},'write':{'signature':'string $session_id, string $session_data | bool','return_type':'bool'},},},}
let php_builtin['classes']['simplexml']={'simplexmlelement':{'name':'SimpleXMLElement','methods':{'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},'simplexmliterator':{'name':'SimpleXMLIterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'getChildren':{'signature':'void | SimpleXMLIterator','return_type':'SimpleXMLIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'key':{'signature':'void | mixed','return_type':'mixed'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | bool','return_type':'bool'},'__construct':{'signature':'string $data [, int $options = 0 [, bool $data_is_url = false [, string $ns = "" [, bool $is_prefix = false]]]]','return_type':''},'addAttribute':{'signature':'string $name [, string $value [, string $namespace]] | void','return_type':'void'},'addChild':{'signature':'string $name [, string $value [, string $namespace]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'asXML':{'signature':'[ string $filename] | mixed','return_type':'mixed'},'attributes':{'signature':'[ string $ns = NULL [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'children':{'signature':'[ string $ns [, bool $is_prefix = false]] | SimpleXMLElement','return_type':'SimpleXMLElement'},'count':{'signature':'void | int','return_type':'int'},'getDocNamespaces':{'signature':'[ bool $recursive = false [, bool $from_root = true]] | array','return_type':'array'},'getName':{'signature':'void | string','return_type':'string'},'getNamespaces':{'signature':'[ bool $recursive = false] | array','return_type':'array'},'registerXPathNamespace':{'signature':'string $prefix, string $ns | bool','return_type':'bool'},'__toString':{'signature':'void | string','return_type':'string'},'xpath':{'signature':'string $path | array','return_type':'array'},},},}
let php_builtin['classes']['spl_types']={'splbool':{'name':'SplBool','constants':{'__default':'false','false':'false','true':'true',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},},},'splenum':{'name':'SplEnum','constants':{'__default':'null',},'methods':{'getConstList':{'signature':'[ bool $include_default = false] | array','return_type':'array'},'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splfloat':{'name':'SplFloat','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splint':{'name':'SplInt','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'splstring':{'name':'SplString','constants':{'__default':'0',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},'spltype':{'name':'SplType','constants':{'__default':'null',},'methods':{'__construct':{'signature':'[ mixed $initial_value [, bool $strict]]','return_type':''},},},}
let php_builtin['classes']['xmlreader']={'xmlreader':{'name':'XMLReader','constants':{'NONE':'0','ELEMENT':'1','ATTRIBUTE':'2','TEXT':'3','CDATA':'4','ENTITY_REF':'5','ENTITY':'6','PI':'7','COMMENT':'8','DOC':'9','DOC_TYPE':'10','DOC_FRAGMENT':'11','NOTATION':'12','WHITESPACE':'13','SIGNIFICANT_WHITESPACE':'14','END_ELEMENT':'15','END_ENTITY':'16','XML_DECLARATION':'17','LOADDTD':'1','DEFAULTATTRS':'2','VALIDATE':'3','SUBST_ENTITIES':'4',},'properties': {'attributeCount':{'initializer':'','type':'int'},'baseURI':{'initializer':'','type':'string'},'depth':{'initializer':'','type':'int'},'hasAttributes':{'initializer':'','type':'bool'},'hasValue':{'initializer':'','type':'bool'},'isDefault':{'initializer':'','type':'bool'},'isEmptyElement':{'initializer':'','type':'bool'},'localName':{'initializer':'','type':'string'},'name':{'initializer':'','type':'string'},'namespaceURI':{'initializer':'','type':'string'},'nodeType':{'initializer':'','type':'int'},'prefix':{'initializer':'','type':'string'},'value':{'initializer':'','type':'string'},'xmlLang':{'initializer':'','type':'string'},},'methods':{'close':{'signature':'void | bool','return_type':'bool'},'expand':{'signature':'[ DOMNode $basenode] | DOMNode','return_type':'DOMNode'},'getAttribute':{'signature':'string $name | string','return_type':'string'},'getAttributeNo':{'signature':'int $index | string','return_type':'string'},'getAttributeNs':{'signature':'string $localName, string $namespaceURI | string','return_type':'string'},'getParserProperty':{'signature':'int $property | bool','return_type':'bool'},'isValid':{'signature':'void | bool','return_type':'bool'},'lookupNamespace':{'signature':'string $prefix | bool','return_type':'bool'},'moveToAttribute':{'signature':'string $name | bool','return_type':'bool'},'moveToAttributeNo':{'signature':'int $index | bool','return_type':'bool'},'moveToAttributeNs':{'signature':'string $localName, string $namespaceURI | bool','return_type':'bool'},'moveToElement':{'signature':'void | bool','return_type':'bool'},'moveToFirstAttribute':{'signature':'void | bool','return_type':'bool'},'moveToNextAttribute':{'signature':'void | bool','return_type':'bool'},'next':{'signature':'[ string $localname] | bool','return_type':'bool'},'open':{'signature':'string $URI [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},'read':{'signature':'void | bool','return_type':'bool'},'readInnerXML':{'signature':'void | string','return_type':'string'},'readOuterXML':{'signature':'void | string','return_type':'string'},'readString':{'signature':'void | string','return_type':'string'},'setParserProperty':{'signature':'int $property, bool $value | bool','return_type':'bool'},'setRelaxNGSchema':{'signature':'string $filename | bool','return_type':'bool'},'setRelaxNGSchemaSource':{'signature':'string $source | bool','return_type':'bool'},'setSchema':{'signature':'string $filename | bool','return_type':'bool'},'xml':{'signature':'string $source [, string $encoding [, int $options = 0]] | bool','return_type':'bool'},},},}
let php_builtin['classes']['xmlwriter'] = {'xmlwriter':{'name':'XMLWriter','methods':{'endAttribute':{'signature':'void | bool','return_type':'bool'},'endCData':{'signature':'void | bool','return_type':'bool'},'endComment':{'signature':'void | bool','return_type':'bool'},'endDocument':{'signature':'void | bool','return_type':'bool'},'endDTDAttlist':{'signature':'void | bool','return_type':'bool'},'endDTDElement':{'signature':'void | bool','return_type':'bool'},'endDTDEntity':{'signature':'void | bool','return_type':'bool'},'endDTD':{'signature':'void | bool','return_type':'bool'},'endElement':{'signature':'void | bool','return_type':'bool'},'endPI':{'signature':'void | bool','return_type':'bool'},'flush':{'signature':'[bool $empty = true] | bool','return_type':'bool'},'fullEndElement':{'signature':'void | bool','return_type':'bool'},'openMemory':{'signature':'void | bool','return_type':'bool'},'openURI':{'signature':'string $uri | bool','return_type':'bool'},'outputMemory':{'signature':'[bool $flush = true] | bool','return_type':'bool'},'setIndentString':{'signature':'string $indentString | bool','return_type':'bool'},'setIndent':{'signature':'bool $indent | bool','return_type':'bool'},'startAttributeNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startAttribute':{'signature':'string $name | bool','return_type':'bool'},'startCData':{'signature':'void | bool','return_type':'bool'},'startComment':{'signature':'void | bool','return_type':'bool'},'startDocument':{'signature':'[string $version = 1.0 [, string $encoding = NULL [, string $standalone ]]] | bool','return_type':'bool'},'startDTDAttlist':{'signature':'string $name | bool','return_type':'bool'},'startDTDElement':{'signature':'string $qualifiedName | bool','return_type':'bool'},'startDTDEntity':{'signature':'string $name, bool $isparam | bool','return_type':'bool'},'startDTD':{'signature':'string $qualifiedName [, string $publicId [, string $systemId ]] | bool','return_type':'bool'},'startElementNS':{'signature':'string $prefix, string $name, string $uri | bool','return_type':'bool'},'startElement':{'signature':'string $name | bool','return_type':'bool'},'startPI':{'signature':'string $target | bool','return_type':'bool'},'text':{'signature':'string $content | bool','return_type':'bool'},'writeAttributeNS':{'signature':'string $prefix, string $name, string $uri, string $content | bool','return_type':'bool'},'writeAttribute':{'signature':'string $name, string $value | bool','return_type':'bool'},'writeCData':{'signature':'string $content | bool','return_type':'bool'},'writeComment':{'signature':'string $content | bool','return_type':'bool'},'writeDTDAttlist':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDElement':{'signature':'string $name, string $content | bool','return_type':'bool'},'writeDTDEntity':{'signature':'string $name, string $content, bool $pe, string $pubid, string $sysid, string $ndataid | bool','return_type':'bool'},'writeDTD':{'signature':'string $name [, string $publicId [, string $systemId [, string $subset ]]] | bool','return_type':'bool'},'writeElementNS':{'signature':'string $prefix, string $name, string $uri [, string $content ] | bool','return_type':'bool'},'writeElement':{'signature':'string $name [, string $content ] | bool','return_type':'bool'},'writePI':{'signature':'string $target, string $content | bool','return_type':'bool'},'writeRaw':{'signature':'string $content | bool','return_type':'bool'},},},}
let php_builtin['classes']['zip']={'ziparchive':{'name':'ZipArchive','properties': {'status':{'initializer':'','type':'int'},'statusSys':{'initializer':'','type':'int'},'numFiles':{'initializer':'','type':'int'},'filename':{'initializer':'','type':'string'},'comment':{'initializer':'','type':'string'},},'methods':{'addEmptyDir':{'signature':'string $dirname | bool','return_type':'bool'},'addFile':{'signature':'string $filename [, string $localname = NULL [, int $start = 0 [, int $length = 0]]] | bool','return_type':'bool'},'addFromString':{'signature':'string $localname, string $contents | bool','return_type':'bool'},'addGlob':{'signature':'string $pattern [, int $flags = 0 [, array $options = array()]] | bool','return_type':'bool'},'addPattern':{'signature':'string $pattern [, string $path = ''.'' [, array $options = array()]] | bool','return_type':'bool'},'close':{'signature':'void | bool','return_type':'bool'},'deleteIndex':{'signature':'int $index | bool','return_type':'bool'},'deleteName':{'signature':'string $name | bool','return_type':'bool'},'extractTo':{'signature':'string $destination [, mixed $entries] | bool','return_type':'bool'},'getArchiveComment':{'signature':'[ int $flags] | string','return_type':'string'},'getCommentIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getCommentName':{'signature':'string $name [, int $flags] | string','return_type':'string'},'getFromIndex':{'signature':'int $index [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getFromName':{'signature':'string $name [, int $length = 0 [, int $flags]] | string','return_type':'string'},'getNameIndex':{'signature':'int $index [, int $flags] | string','return_type':'string'},'getStatusString':{'signature':'void | string','return_type':'string'},'getStream':{'signature':'string $name | resource','return_type':'resource'},'locateName':{'signature':'string $name [, int $flags] | int','return_type':'int'},'open':{'signature':'string $filename [, int $flags] | mixed','return_type':'mixed'},'renameIndex':{'signature':'int $index, string $newname | bool','return_type':'bool'},'renameName':{'signature':'string $name, string $newname | bool','return_type':'bool'},'setArchiveComment':{'signature':'string $comment | bool','return_type':'bool'},'setCommentIndex':{'signature':'int $index, string $comment | bool','return_type':'bool'},'setCommentName':{'signature':'string $name, string $comment | bool','return_type':'bool'},'statIndex':{'signature':'int $index [, int $flags] | array','return_type':'array'},'statName':{'signature':'string $name [, int $flags] | array','return_type':'array'},'unchangeAll':{'signature':'void | bool','return_type':'bool'},'unchangeArchive':{'signature':'void | bool','return_type':'bool'},'unchangeIndex':{'signature':'int $index | bool','return_type':'bool'},'unchangeName':{'signature':'string $name | bool','return_type':'bool'},},},}
let php_builtin['interfaces']['predefined_interfaces_and_classes']={'arrayaccess':{'name':'ArrayAccess','methods':{'offsetExists':{'signature':'mixed $offset | boolean','return_type':'boolean'},'offsetGet':{'signature':'mixed $offset | mixed','return_type':'mixed'},'offsetSet':{'signature':'mixed $offset, mixed $value | void','return_type':'void'},'offsetUnset':{'signature':'mixed $offset | void','return_type':'void'},},},'iterator':{'name':'Iterator','methods':{'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'iteratoraggregate':{'name':'IteratorAggregate','methods':{'getIterator':{'signature':'void | Traversable','return_type':'Traversable'},},},'serializable':{'name':'Serializable','methods':{'serialize':{'signature':'void | string','return_type':'string'},'unserialize':{'signature':'string $serialized | void','return_type':'void'},},},'traversable':{'name':'Traversable',},}
let php_builtin['interfaces']['spl']={'countable':{'name':'Countable','methods':{'count':{'signature':'void | int','return_type':'int'},},},'outeriterator':{'name':'OuterIterator','methods':{'getInnerIterator':{'signature':'void | Iterator','return_type':'Iterator'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'recursiveiterator':{'name':'RecursiveIterator','methods':{'getChildren':{'signature':'void | RecursiveIterator','return_type':'RecursiveIterator'},'hasChildren':{'signature':'void | bool','return_type':'bool'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'seekableiterator':{'name':'SeekableIterator','methods':{'seek':{'signature':'int $position | void','return_type':'void'},'current':{'signature':'void | mixed','return_type':'mixed'},'key':{'signature':'void | scalar','return_type':'scalar'},'next':{'signature':'void | void','return_type':'void'},'rewind':{'signature':'void | void','return_type':'void'},'valid':{'signature':'void | boolean','return_type':'boolean'},},},'splobserver':{'name':'SplObserver','methods':{'update':{'signature':'SplSubject $subject | void','return_type':'void'},},},'splsubject':{'name':'SplSubject','methods':{'attach':{'signature':'SplObserver $observer | void','return_type':'void'},'detach':{'signature':'SplObserver $observer | void','return_type':'void'},'notify':{'signature':'void | void','return_type':'void'},},},}
let php_builtin['interfaces']['date_time']={'datetimeinterface':{'name':'DateTimeInterface','methods':{'diff':{'signature':'DateTimeInterface $datetime2 [, bool $absolute = false] | DateInterval','return_type':'DateInterval'},'format':{'signature':'string $format | string','return_type':'string'},'getOffset':{'signature':'void | int','return_type':'int'},'getTimestamp':{'signature':'void | int','return_type':'int'},'getTimezone':{'signature':'void | DateTimeZone','return_type':'DateTimeZone'},'__wakeup':{'signature':'void','return_type':''},},},}
let php_builtin['interfaces']['json']={'jsonserializable':{'name':'JsonSerializable','methods':{'jsonSerialize':{'signature':'void | mixed','return_type':'mixed'},},},}
let php_builtin['constants']['common']={'TRUE':'','FALSE':'','NULL':'','E_NOTICE':'','E_DEPRECATED':'','E_RECOVERABLE_ERROR':'','E_ALL':'','E_STRICT':'','E_WARNING':'','E_ERROR':'','E_PARSE':'','E_CORE_ERROR':'','E_CORE_WARNING':'','E_COMPILE_ERROR':'','E_COMPILE_WARNING':'','E_USER_ERROR':'','E_USER_WARNING':'','E_USER_NOTICE':'','E_USER_DEPRECATED':'','__COMPILER_HALT_OFFSET__':'','__FILE__':'','__LINE__':'','__DIR__':'','__FUNCTION__':'','__CLASS__':'','__TRAIT__':'','__METHOD__':'','__NAMESPACE__':'',}
let php_builtin['constants']['arrays']={'CASE_LOWER':'','CASE_UPPER':'','SORT_ASC':'','SORT_DESC':'','SORT_REGULAR':'','SORT_NUMERIC':'','SORT_STRING':'','SORT_LOCALE_STRING':'','SORT_NATURAL':'','SORT_FLAG_CASE':'','COUNT_NORMAL':'','COUNT_RECURSIVE':'','EXTR_OVERWRITE':'','EXTR_SKIP':'','EXTR_PREFIX_SAME':'','EXTR_PREFIX_ALL':'','EXTR_PREFIX_INVALID':'','EXTR_PREFIX_IF_EXISTS':'','EXTR_IF_EXISTS':'','EXTR_REFS':'',}
let php_builtin['constants']['calendar']={'CAL_GREGORIAN':'','CAL_JULIAN':'','CAL_JEWISH':'','CAL_FRENCH':'','CAL_NUM_CALS':'','CAL_DOW_DAYNO':'','CAL_DOW_SHORT':'','CAL_DOW_LONG':'','CAL_MONTH_GREGORIAN_SHORT':'','CAL_MONTH_GREGORIAN_LONG':'','CAL_MONTH_JULIAN_SHORT':'','CAL_MONTH_JULIAN_LONG':'','CAL_MONTH_JEWISH':'','CAL_MONTH_FRENCH':'','CAL_EASTER_DEFAULT':'','CAL_EASTER_ROMAN':'','CAL_EASTER_ALWAYS_GREGORIAN':'','CAL_EASTER_ALWAYS_JULIAN':'','CAL_JEWISH_ADD_ALAFIM_GERESH':'','CAL_JEWISH_ADD_ALAFIM':'','CAL_JEWISH_ADD_GERESHAYIM':'',}
let php_builtin['constants']['curl']={'CURLOPT_POSTFIELDS':'','CURLOPT_CAINFO':'','CURLOPT_AUTOREFERER':'','CURLOPT_COOKIESESSION':'','CURLOPT_DNS_USE_GLOBAL_CACHE':'','CURLOPT_DNS_CACHE_TIMEOUT':'','CURLOPT_FTP_SSL':'','CURLFTPSSL_TRY':'','CURLFTPSSL_ALL':'','CURLFTPSSL_CONTROL':'','CURLFTPSSL_NONE':'','CURLOPT_PRIVATE':'','CURLOPT_FTPSSLAUTH':'','CURLOPT_PORT':'','CURLOPT_FILE':'','CURLOPT_INFILE':'','CURLOPT_INFILESIZE':'','CURLOPT_URL':'','CURLOPT_PROXY':'','CURLOPT_VERBOSE':'','CURLOPT_HEADER':'','CURLOPT_HTTPHEADER':'','CURLOPT_NOPROGRESS':'','CURLOPT_NOBODY':'','CURLOPT_FAILONERROR':'','CURLOPT_UPLOAD':'','CURLOPT_POST':'','CURLOPT_FTPLISTONLY':'','CURLOPT_FTPAPPEND':'','CURLOPT_FTP_CREATE_MISSING_DIRS':'','CURLOPT_NETRC':'','CURLOPT_FOLLOWLOCATION':'','CURLOPT_FTPASCII':'','CURLOPT_PUT':'','CURLOPT_MUTE':'','CURLOPT_USERPWD':'','CURLOPT_PROXYUSERPWD':'','CURLOPT_RANGE':'','CURLOPT_TIMEOUT':'','CURLOPT_TIMEOUT_MS':'','CURLOPT_TCP_NODELAY':'','CURLOPT_PROGRESSFUNCTION':'','CURLOPT_REFERER':'','CURLOPT_USERAGENT':'','CURLOPT_FTPPORT':'','CURLOPT_FTP_USE_EPSV':'','CURLOPT_LOW_SPEED_LIMIT':'','CURLOPT_LOW_SPEED_TIME':'','CURLOPT_RESUME_FROM':'','CURLOPT_COOKIE':'','CURLOPT_SSLCERT':'','CURLOPT_SSLCERTPASSWD':'','CURLOPT_WRITEHEADER':'','CURLOPT_SSL_VERIFYHOST':'','CURLOPT_COOKIEFILE':'','CURLOPT_SSLVERSION':'','CURLOPT_TIMECONDITION':'','CURLOPT_TIMEVALUE':'','CURLOPT_CUSTOMREQUEST':'','CURLOPT_STDERR':'','CURLOPT_TRANSFERTEXT':'','CURLOPT_RETURNTRANSFER':'','CURLOPT_QUOTE':'','CURLOPT_POSTQUOTE':'','CURLOPT_INTERFACE':'','CURLOPT_KRB4LEVEL':'','CURLOPT_HTTPPROXYTUNNEL':'','CURLOPT_FILETIME':'','CURLOPT_WRITEFUNCTION':'','CURLOPT_READFUNCTION':'','CURLOPT_PASSWDFUNCTION':'','CURLOPT_HEADERFUNCTION':'','CURLOPT_MAXREDIRS':'','CURLOPT_MAXCONNECTS':'','CURLOPT_CLOSEPOLICY':'','CURLOPT_FRESH_CONNECT':'','CURLOPT_FORBID_REUSE':'','CURLOPT_RANDOM_FILE':'','CURLOPT_EGDSOCKET':'','CURLOPT_CONNECTTIMEOUT':'','CURLOPT_CONNECTTIMEOUT_MS':'','CURLOPT_SSL_VERIFYPEER':'','CURLOPT_CAPATH':'','CURLOPT_COOKIEJAR':'','CURLOPT_SSL_CIPHER_LIST':'','CURLOPT_BINARYTRANSFER':'','CURLOPT_NOSIGNAL':'','CURLOPT_PROXYTYPE':'','CURLOPT_BUFFERSIZE':'','CURLOPT_HTTPGET':'','CURLOPT_HTTP_VERSION':'','CURLOPT_SSLKEY':'','CURLOPT_SSLKEYTYPE':'','CURLOPT_SSLKEYPASSWD':'','CURLOPT_SSLENGINE':'','CURLOPT_SSLENGINE_DEFAULT':'','CURLOPT_SSLCERTTYPE':'','CURLOPT_CRLF':'','CURLOPT_ENCODING':'','CURLOPT_PROXYPORT':'','CURLOPT_UNRESTRICTED_AUTH':'','CURLOPT_FTP_USE_EPRT':'','CURLOPT_HTTP200ALIASES':'','CURLOPT_HTTPAUTH':'','CURLAUTH_BASIC':'','CURLAUTH_DIGEST':'','CURLAUTH_GSSNEGOTIATE':'','CURLAUTH_NTLM':'','CURLAUTH_ANY':'','CURLAUTH_ANYSAFE':'','CURLOPT_PROXYAUTH':'','CURLOPT_MAX_RECV_SPEED_LARGE':'','CURLOPT_MAX_SEND_SPEED_LARGE':'','CURLCLOSEPOLICY_LEAST_RECENTLY_USED':'','CURLCLOSEPOLICY_LEAST_TRAFFIC':'','CURLCLOSEPOLICY_SLOWEST':'','CURLCLOSEPOLICY_CALLBACK':'','CURLCLOSEPOLICY_OLDEST':'','CURLINFO_PRIVATE':'','CURLINFO_EFFECTIVE_URL':'','CURLINFO_HTTP_CODE':'','CURLINFO_HEADER_OUT':'','CURLINFO_HEADER_SIZE':'','CURLINFO_REQUEST_SIZE':'','CURLINFO_TOTAL_TIME':'','CURLINFO_NAMELOOKUP_TIME':'','CURLINFO_CONNECT_TIME':'','CURLINFO_PRETRANSFER_TIME':'','CURLINFO_SIZE_UPLOAD':'','CURLINFO_SIZE_DOWNLOAD':'','CURLINFO_SPEED_DOWNLOAD':'','CURLINFO_SPEED_UPLOAD':'','CURLINFO_FILETIME':'','CURLINFO_SSL_VERIFYRESULT':'','CURLINFO_CONTENT_LENGTH_DOWNLOAD':'','CURLINFO_CONTENT_LENGTH_UPLOAD':'','CURLINFO_STARTTRANSFER_TIME':'','CURLINFO_CONTENT_TYPE':'','CURLINFO_REDIRECT_TIME':'','CURLINFO_REDIRECT_COUNT':'','CURL_TIMECOND_IFMODSINCE':'','CURL_TIMECOND_IFUNMODSINCE':'','CURL_TIMECOND_LASTMOD':'','CURL_VERSION_IPV6':'','CURL_VERSION_KERBEROS4':'','CURL_VERSION_SSL':'','CURL_VERSION_LIBZ':'','CURLVERSION_NOW':'','CURLE_OK':'','CURLE_UNSUPPORTED_PROTOCOL':'','CURLE_FAILED_INIT':'','CURLE_URL_MALFORMAT':'','CURLE_URL_MALFORMAT_USER':'','CURLE_COULDNT_RESOLVE_PROXY':'','CURLE_COULDNT_RESOLVE_HOST':'','CURLE_COULDNT_CONNECT':'','CURLE_FTP_WEIRD_SERVER_REPLY':'','CURLE_FTP_ACCESS_DENIED':'','CURLE_FTP_USER_PASSWORD_INCORRECT':'','CURLE_FTP_WEIRD_PASS_REPLY':'','CURLE_FTP_WEIRD_USER_REPLY':'','CURLE_FTP_WEIRD_PASV_REPLY':'','CURLE_FTP_WEIRD_227_FORMAT':'','CURLE_FTP_CANT_GET_HOST':'','CURLE_FTP_CANT_RECONNECT':'','CURLE_FTP_COULDNT_SET_BINARY':'','CURLE_PARTIAL_FILE':'','CURLE_FTP_COULDNT_RETR_FILE':'','CURLE_FTP_WRITE_ERROR':'','CURLE_FTP_QUOTE_ERROR':'','CURLE_HTTP_NOT_FOUND':'','CURLE_WRITE_ERROR':'','CURLE_MALFORMAT_USER':'','CURLE_FTP_COULDNT_STOR_FILE':'','CURLE_READ_ERROR':'','CURLE_OUT_OF_MEMORY':'','CURLE_OPERATION_TIMEOUTED':'','CURLE_FTP_COULDNT_SET_ASCII':'','CURLE_FTP_PORT_FAILED':'','CURLE_FTP_COULDNT_USE_REST':'','CURLE_FTP_COULDNT_GET_SIZE':'','CURLE_HTTP_RANGE_ERROR':'','CURLE_HTTP_POST_ERROR':'','CURLE_SSL_CONNECT_ERROR':'','CURLE_FTP_BAD_DOWNLOAD_RESUME':'','CURLE_FILE_COULDNT_READ_FILE':'','CURLE_LDAP_CANNOT_BIND':'','CURLE_LDAP_SEARCH_FAILED':'','CURLE_LIBRARY_NOT_FOUND':'','CURLE_FUNCTION_NOT_FOUND':'','CURLE_ABORTED_BY_CALLBACK':'','CURLE_BAD_FUNCTION_ARGUMENT':'','CURLE_BAD_CALLING_ORDER':'','CURLE_HTTP_PORT_FAILED':'','CURLE_BAD_PASSWORD_ENTERED':'','CURLE_TOO_MANY_REDIRECTS':'','CURLE_UNKNOWN_TELNET_OPTION':'','CURLE_TELNET_OPTION_SYNTAX':'','CURLE_OBSOLETE':'','CURLE_SSL_PEER_CERTIFICATE':'','CURLE_GOT_NOTHING':'','CURLE_SSL_ENGINE_NOTFOUND':'','CURLE_SSL_ENGINE_SETFAILED':'','CURLE_SEND_ERROR':'','CURLE_RECV_ERROR':'','CURLE_SHARE_IN_USE':'','CURLE_SSL_CERTPROBLEM':'','CURLE_SSL_CIPHER':'','CURLE_SSL_CACERT':'','CURLE_BAD_CONTENT_ENCODING':'','CURLE_LDAP_INVALID_URL':'','CURLE_FILESIZE_EXCEEDED':'','CURLE_FTP_SSL_FAILED':'','CURLFTPAUTH_DEFAULT':'','CURLFTPAUTH_SSL':'','CURLFTPAUTH_TLS':'','CURLPROXY_HTTP':'','CURLPROXY_SOCKS5':'','CURL_NETRC_OPTIONAL':'','CURL_NETRC_IGNORED':'','CURL_NETRC_REQUIRED':'','CURL_HTTP_VERSION_NONE':'','CURL_HTTP_VERSION_1_0':'','CURL_HTTP_VERSION_1_1':'','CURLM_CALL_MULTI_PERFORM':'','CURLM_OK':'','CURLM_BAD_HANDLE':'','CURLM_BAD_EASY_HANDLE':'','CURLM_OUT_OF_MEMORY':'','CURLM_INTERNAL_ERROR':'','CURLMSG_DONE':'','CURLOPT_KEYPASSWD':'','CURLOPT_SSH_AUTH_TYPES':'','CURLOPT_SSH_HOST_PUBLIC_KEY_MD5':'','CURLOPT_SSH_PRIVATE_KEYFILE':'','CURLOPT_SSH_PUBLIC_KEYFILE':'','CURLMOPT_PIPELINING':'','CURLMOPT_MAXCONNECTS':'','CURLSSH_AUTH_ANY':'','CURLSSH_AUTH_DEFAULT':'','CURLSSH_AUTH_HOST':'','CURLSSH_AUTH_KEYBOARD':'','CURLSSH_AUTH_NONE':'','CURLSSH_AUTH_PASSWORD':'','CURLSSH_AUTH_PUBLICKEY':'','CURL_WRAPPERS_ENABLED':'','CURLPAUSE_ALL':'','CURLPAUSE_CONT':'','CURLPAUSE_RECV':'','CURLPAUSE_RECV_CONT':'','CURLPAUSE_SEND':'','CURLPAUSE_SEND_CONT':'','CURLM_XXX':'','CURLOPT_CERTINFO':'','CURLOPT_CONNECT_ONLY':'','CURLINFO_':'','CURLOPT_PROTOCOLS':'','CURLOPT_REDIR_PROTOCOLS':'','CURLOPT_IPRESOLVE':'','CURL_IPRESOLVE_WHATEVER':'','CURL_IPRESOLVE_V4':'','CURL_IPRESOLVE_V6':'','CURLOPT_SHARE':'','CURLSHOPT_SHARE':'','CURLSHOPT_UNSHARE':'','CURL_LOCK_DATA_COOKIE':'','CURL_LOCK_DATA_DNS':'','CURL_LOCK_DATA_SSL_SESSION':'',}
let php_builtin['constants']['date_time']={'DATE_ATOM':'','DATE_COOKIE':'','DATE_ISO8601':'','DATE_RFC822':'','DATE_RFC850':'','DATE_RFC1036':'','DATE_RFC1123':'','DATE_RFC2822':'','DATE_RFC3339':'','DATE_RSS':'','DATE_W3C':'','SUNFUNCS_RET_TIMESTAMP':'','SUNFUNCS_RET_STRING':'','SUNFUNCS_RET_DOUBLE':'','LC_TIME':'',}
let php_builtin['constants']['libxml']={'LIBXML_ERR_WARNING':'','LIBXML_ERR_ERROR':'','LIBXML_ERR_FATAL':'','LIBXML_NONET':'','LIBXML_COMPACT':'','LIBXML_DTDATTR':'','LIBXML_DTDLOAD':'','LIBXML_DTDVALID':'','LIBXML_HTML_NOIMPLIED':'','LIBXML_HTML_NODEFDTD':'','LIBXML_NOBLANKS':'','LIBXML_NOCDATA':'','LIBXML_NOEMPTYTAG':'','LIBXML_NOENT':'','LIBXML_NOERROR':'','LIBXML_NOWARNING':'','LIBXML_NOXMLDECL':'','LIBXML_NSCLEAN':'','LIBXML_PARSEHUGE':'','LIBXML_PEDANTIC':'','LIBXML_XINCLUDE':'','LIBXML_ERR_NONE':'','LIBXML_VERSION':'','LIBXML_DOTTED_VERSION':'','LIBXML_SCHEMA_CREATE':'',}
let php_builtin['constants']['mysqli']={'MYSQLI_REPORT_OFF':'','MYSQLI_REPORT_ALL':'','MYSQLI_REPORT_STRICT':'','MYSQLI_REPORT_ERROR':'','MYSQLI_REPORT_INDEX':'','MYSQLI_ASSOC':'','MYSQLI_NUM':'','MYSQLI_BOTH':'','PHP_INT_MAX':'','MYSQLI_READ_DEFAULT_GROUP':'','MYSQLI_READ_DEFAULT_FILE':'','MYSQLI_OPT_CONNECT_TIMEOUT':'','MYSQLI_OPT_LOCAL_INFILE':'','MYSQLI_INIT_COMMAND':'','MYSQLI_CLIENT_SSL':'','MYSQLI_CLIENT_COMPRESS':'','MYSQLI_CLIENT_INTERACTIVE':'','MYSQLI_CLIENT_IGNORE_SPACE':'','MYSQLI_CLIENT_NO_SCHEMA':'','MYSQLI_CLIENT_MULTI_QUERIES':'','MYSQLI_STORE_RESULT':'','MYSQLI_USE_RESULT':'','MYSQLI_NOT_NULL_FLAG':'','MYSQLI_PRI_KEY_FLAG':'','MYSQLI_UNIQUE_KEY_FLAG':'','MYSQLI_MULTIPLE_KEY_FLAG':'','MYSQLI_BLOB_FLAG':'','MYSQLI_UNSIGNED_FLAG':'','MYSQLI_ZEROFILL_FLAG':'','MYSQLI_AUTO_INCREMENT_FLAG':'','MYSQLI_TIMESTAMP_FLAG':'','MYSQLI_SET_FLAG':'','MYSQLI_NUM_FLAG':'','MYSQLI_PART_KEY_FLAG':'','MYSQLI_GROUP_FLAG':'','MYSQLI_TYPE_DECIMAL':'','MYSQLI_TYPE_NEWDECIMAL':'','MYSQLI_TYPE_BIT':'','MYSQLI_TYPE_TINY':'','MYSQLI_TYPE_SHORT':'','MYSQLI_TYPE_LONG':'','MYSQLI_TYPE_FLOAT':'','MYSQLI_TYPE_DOUBLE':'','MYSQLI_TYPE_NULL':'','MYSQLI_TYPE_TIMESTAMP':'','MYSQLI_TYPE_LONGLONG':'','MYSQLI_TYPE_INT24':'','MYSQLI_TYPE_DATE':'','MYSQLI_TYPE_TIME':'','MYSQLI_TYPE_DATETIME':'','MYSQLI_TYPE_YEAR':'','MYSQLI_TYPE_NEWDATE':'','MYSQLI_TYPE_INTERVAL':'','MYSQLI_TYPE_ENUM':'','MYSQLI_TYPE_SET':'','MYSQLI_TYPE_TINY_BLOB':'','MYSQLI_TYPE_MEDIUM_BLOB':'','MYSQLI_TYPE_LONG_BLOB':'','MYSQLI_TYPE_BLOB':'','MYSQLI_TYPE_VAR_STRING':'','MYSQLI_TYPE_STRING':'','MYSQLI_TYPE_CHAR':'','MYSQLI_TYPE_GEOMETRY':'','MYSQLI_NEED_DATA':'','MYSQLI_NO_DATA':'','MYSQLI_DATA_TRUNCATED':'','MYSQLI_ENUM_FLAG':'','MYSQLI_BINARY_FLAG':'','MYSQLI_CURSOR_TYPE_FOR_UPDATE':'','MYSQLI_CURSOR_TYPE_NO_CURSOR':'','MYSQLI_CURSOR_TYPE_READ_ONLY':'','MYSQLI_CURSOR_TYPE_SCROLLABLE':'','MYSQLI_STMT_ATTR_CURSOR_TYPE':'','MYSQLI_STMT_ATTR_PREFETCH_ROWS':'','MYSQLI_STMT_ATTR_UPDATE_MAX_LENGTH':'','MYSQLI_SET_CHARSET_NAME':'','MYSQLI_DEBUG_TRACE_ENABLED':'','MYSQLI_SERVER_QUERY_NO_GOOD_INDEX_USED':'','MYSQLI_SERVER_QUERY_NO_INDEX_USED':'','MYSQLI_REFRESH_GRANT':'','MYSQLI_REFRESH_LOG':'','MYSQLI_REFRESH_TABLES':'','MYSQLI_REFRESH_HOSTS':'','MYSQLI_REFRESH_STATUS':'','MYSQLI_REFRESH_THREADS':'','MYSQLI_REFRESH_SLAVE':'','MYSQLI_REFRESH_MASTER':'','MYSQLI_TRANS_COR_AND_CHAIN':'','MYSQLI_TRANS_COR_AND_NO_CHAIN':'','MYSQLI_TRANS_COR_RELEASE':'','MYSQLI_TRANS_COR_NO_RELEASE':'','MYSQL_READ_DEFAULT_FILE':'','MYSQLI_SERVER_PUBLIC_KEY':'','MYSQLI_NO_CHANGE_USER_ON_PCONNECT':'','MYSQLI_ASYNC':'','MYSQLI_OPT_INT_AND_FLOAT_NATIVE':'','MYSQLI_CLIENT_FOUND_ROWS':'','MULTI_STATEMENT':'','MYSQLI_RPL_MASTER':'','MYSQLI_RPL_SLAVE':'','MYSQLI_RPL_ADMIN':'',}
let php_builtin['constants']['spl']={'READ_AHEAD':'','MIT_NEED_ALL':'','MIT_KEYS_ASSOC':'','CALL_TOSTRING':'','CATCH_GET_CHILD':'','RIT_LEAVES_ONLY':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','PHP_INT_MAX':'',}
let php_builtin['constants']['unknow']={'PHP_INI_ALL':'','PHP_INI_PERDIR':'','PHP_INI_SYSTEM':'','PHP_INI_USER':'','COUNTER_FLAG_PERSIST':'','COUNTER_FLAG_SAVE':'','COUNTER_FLAG_NO_OVERWRITE':'','COUNTER_META_NAME':'','COUNTER_META_IS_PERISTENT':'','COUNTER_RESET_NEVER':'','COUNTER_RESET_PER_LOAD':'','COUNTER_RESET_PER_REQUEST':'','PDO_PLACEHOLDER_NAMED':'','PDO_PLACEHOLDER_POSITIONAL':'','PDO_PLACEHOLDER_NONE':'','PDO_CASE_NATURAL':'','PDO_CASE_UPPER':'','PDO_CASE_LOWER':'','PDO_ATTR_CASE':'','PHP_COUNTER_API':'','PHPAPI':'','COMPILE_DL_COUNTER':'','ZEND_GET_MODULE':'','HAVE_COUNTER':'','COUNTER_G':'','TSRMLS_DC':'','TSRMLS_FETCH':'','STANDARD_MODULE_HEADER':'','STANDARD_MODULE_HEADER_EX':'','STANDARD_MODULE_PROPERTIES':'','STANDARD_MODULE_PROPERTIES_EX':'','ZEND_MODULE_API_NO':'','ZEND_DEBUG':'','USING_ZTS':'','NO_VERSION_YET':'','NO_MODULE_GLOBALS':'','PHP_MODULE_GLOBALS':'','IGNORE_PATH':'','USE_PATH':'','IGNORE_URL':'','IGNORE_URL_WIN':'','ENFORCE_SAFE_MODE':'','REPORT_ERRORS':'','STREAM_MUST_SEEK':'','STREAM_WILL_CAST':'',}
let php_builtin['constants']['directories']={'DIRECTORY_SEPARATOR':'','PATH_SEPARATOR':'','SCANDIR_SORT_ASCENDING':'','SCANDIR_SORT_DESCENDING':'','SCANDIR_SORT_NONE':'',}
let php_builtin['constants']['dom']={'XML_ELEMENT_NODE':'','XML_ATTRIBUTE_NODE':'','XML_TEXT_NODE':'','XML_CDATA_SECTION_NODE':'','XML_ENTITY_REF_NODE':'','XML_ENTITY_NODE':'','XML_PI_NODE':'','XML_COMMENT_NODE':'','XML_DOCUMENT_NODE':'','XML_DOCUMENT_TYPE_NODE':'','XML_DOCUMENT_FRAG_NODE':'','XML_NOTATION_NODE':'','XML_HTML_DOCUMENT_NODE':'','XML_DTD_NODE':'','XML_ELEMENT_DECL_NODE':'','XML_ATTRIBUTE_DECL_NODE':'','XML_ENTITY_DECL_NODE':'','XML_NAMESPACE_DECL_NODE':'','XML_ATTRIBUTE_CDATA':'','XML_ATTRIBUTE_ID':'','XML_ATTRIBUTE_IDREF':'','XML_ATTRIBUTE_IDREFS':'','XML_ATTRIBUTE_ENTITY':'','XML_ATTRIBUTE_NMTOKEN':'','XML_ATTRIBUTE_NMTOKENS':'','XML_ATTRIBUTE_ENUMERATION':'','XML_ATTRIBUTE_NOTATION':'','DOM_PHP_ERR':'','DOM_INDEX_SIZE_ERR':'','DOMSTRING_SIZE_ERR':'','DOM_HIERARCHY_REQUEST_ERR':'','DOM_WRONG_DOCUMENT_ERR':'','DOM_INVALID_CHARACTER_ERR':'','DOM_NO_DATA_ALLOWED_ERR':'','DOM_NO_MODIFICATION_ALLOWED_ERR':'','DOM_NOT_FOUND_ERR':'','DOM_NOT_SUPPORTED_ERR':'','DOM_INUSE_ATTRIBUTE_ERR':'','DOM_INVALID_STATE_ERR':'','DOM_SYNTAX_ERR':'','DOM_INVALID_MODIFICATION_ERR':'','DOM_NAMESPACE_ERR':'','DOM_INVALID_ACCESS_ERR':'','DOM_VALIDATION_ERR':'','DOM_NOT_FOUND_ERROR':'','DOM_NOT_FOUND':'',}
let php_builtin['constants']['command_line_usage']={'PHP_SAPI':'','STDIN':'','STDOUT':'','STDERR':'',}
let php_builtin['constants']['handling_file_uploads']={'UPLOAD_ERR_OK':'','UPLOAD_ERR_INI_SIZE':'','UPLOAD_ERR_FORM_SIZE':'','UPLOAD_ERR_PARTIAL':'','UPLOAD_ERR_NO_FILE':'','UPLOAD_ERR_NO_TMP_DIR':'','UPLOAD_ERR_CANT_WRITE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['fileinfo']={'FILEINFO_NONE':'','FILEINFO_SYMLINK':'','FILEINFO_MIME_TYPE':'','FILEINFO_MIME_ENCODING':'','FILEINFO_MIME':'','FILEINFO_COMPRESS':'','FILEINFO_DEVICES':'','FILEINFO_CONTINUE':'','FILEINFO_PRESERVE_ATIME':'','FILEINFO_RAW':'',}
let php_builtin['constants']['filesystem']={'SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','LOCK_SH':'','LOCK_EX':'','LOCK_UN':'','LOCK_NB':'','GLOB_BRACE':'','GLOB_ONLYDIR':'','GLOB_MARK':'','GLOB_NOSORT':'','GLOB_NOCHECK':'','GLOB_NOESCAPE':'','GLOB_AVAILABLE_FLAGS':'','PATHINFO_DIRNAME':'','PATHINFO_BASENAME':'','PATHINFO_EXTENSION':'','PATHINFO_FILENAME':'','FILE_USE_INCLUDE_PATH':'','FILE_NO_DEFAULT_CONTEXT':'','FILE_APPEND':'','FILE_IGNORE_NEW_LINES':'','FILE_SKIP_EMPTY_LINES':'','FILE_BINARY':'','FILE_TEXT':'','INI_SCANNER_NORMAL':'','INI_SCANNER_RAW':'','FNM_NOESCAPE':'','FNM_PATHNAME':'','FNM_PERIOD':'','FNM_CASEFOLD':'','GLOB_ERR':'',}
let php_builtin['constants']['filter']={'FILTER_FLAG_NO_ENCODE_QUOTES':'','INPUT_POST':'','INPUT_GET':'','INPUT_COOKIE':'','INPUT_ENV':'','INPUT_SERVER':'','INPUT_SESSION':'','INPUT_REQUEST':'','FILTER_FLAG_NONE':'','FILTER_REQUIRE_SCALAR':'','FILTER_REQUIRE_ARRAY':'','FILTER_FORCE_ARRAY':'','FILTER_NULL_ON_FAILURE':'','FILTER_VALIDATE_INT':'','FILTER_VALIDATE_BOOLEAN':'','FILTER_VALIDATE_FLOAT':'','FILTER_VALIDATE_REGEXP':'','FILTER_VALIDATE_URL':'','FILTER_VALIDATE_EMAIL':'','FILTER_VALIDATE_IP':'','FILTER_DEFAULT':'','FILTER_UNSAFE_RAW':'','FILTER_SANITIZE_STRING':'','FILTER_SANITIZE_STRIPPED':'','FILTER_SANITIZE_ENCODED':'','FILTER_SANITIZE_SPECIAL_CHARS':'','FILTER_SANITIZE_EMAIL':'','FILTER_SANITIZE_URL':'','FILTER_SANITIZE_NUMBER_INT':'','FILTER_SANITIZE_NUMBER_FLOAT':'','FILTER_SANITIZE_MAGIC_QUOTES':'','FILTER_CALLBACK':'','FILTER_FLAG_ALLOW_OCTAL':'','FILTER_FLAG_ALLOW_HEX':'','FILTER_FLAG_STRIP_LOW':'','FILTER_FLAG_STRIP_HIGH':'','FILTER_FLAG_ENCODE_LOW':'','FILTER_FLAG_ENCODE_HIGH':'','FILTER_FLAG_ENCODE_AMP':'','FILTER_FLAG_EMPTY_STRING_NULL':'','FILTER_FLAG_ALLOW_FRACTION':'','FILTER_FLAG_ALLOW_THOUSAND':'','FILTER_FLAG_ALLOW_SCIENTIFIC':'','FILTER_FLAG_PATH_REQUIRED':'','FILTER_FLAG_QUERY_REQUIRED':'','FILTER_FLAG_IPV4':'','FILTER_FLAG_IPV6':'','FILTER_FLAG_NO_RES_RANGE':'','FILTER_FLAG_NO_PRIV_RANGE':'','FILTER_SANITIZE_RAW':'','FILTER_SANITIZE_FULL_SPECIAL_CHARS':'','ENT_QUOTES':'',}
let php_builtin['constants']['php_options_info']={'ASSERT_CALLBACK':'','RUSAGE_CHILDREN':'','PHP_SAPI':'','PHP_OS':'','CREDITS_DOCS':'','CREDITS_GENERAL':'','CREDITS_GROUP':'','CREDITS_MODULES':'','CREDITS_FULLPAGE':'','PHP_VERSION_ID':'','PHP_VERSION':'','PATH_SEPARATOR':'','CREDITS_SAPI':'','CREDITS_QA':'','CREDITS_ALL':'','INFO_GENERAL':'','INFO_CREDITS':'','INFO_CONFIGURATION':'','INFO_MODULES':'','INFO_ENVIRONMENT':'','INFO_VARIABLES':'','INFO_LICENSE':'','INFO_ALL':'','ASSERT_ACTIVE':'','ASSERT_BAIL':'','ASSERT_WARNING':'','ASSERT_QUIET_EVAL':'','PHP_WINDOWS_VERSION_MAJOR':'','PHP_WINDOWS_VERSION_MINOR':'','PHP_WINDOWS_VERSION_BUILD':'','PHP_WINDOWS_VERSION_PLATFORM':'','PHP_WINDOWS_VERSION_SP_MAJOR':'','PHP_WINDOWS_VERSION_SP_MINOR':'','PHP_WINDOWS_VERSION_SUITEMASK':'','PHP_WINDOWS_VERSION_PRODUCTTYPE':'','PHP_WINDOWS_NT_DOMAIN_CONTROLLER':'','PHP_WINDOWS_NT_SERVER':'','PHP_WINDOWS_NT_WORKSTATION':'',}
let php_builtin['constants']['strings']={'CRYPT_SALT_LENGTH':'','CRYPT_STD_DES':'','CRYPT_EXT_DES':'','CRYPT_MD5':'','CRYPT_BLOWFISH':'','CRYPT_SHA256':'','CRYPT_SHA512':'','HTML_ENTITIES':'','HTML_SPECIALCHARS':'','ENT_COMPAT':'','ENT_QUOTES':'','ENT_NOQUOTES':'','ENT_HTML401':'','ENT_XML1':'','ENT_XHTML':'','ENT_HTML5':'','ENT_IGNORE':'','ENT_SUBSTITUTE':'','ENT_DISALLOWED':'','CHAR_MAX':'','LC_MONETARY':'','AM_STR':'','PM_STR':'','D_T_FMT':'','D_FMT':'','T_FMT':'','T_FMT_AMPM':'','ERA':'','ERA_YEAR':'','ERA_D_T_FMT':'','ERA_D_FMT':'','ERA_T_FMT':'','INT_CURR_SYMBOL':'','CURRENCY_SYMBOL':'','CRNCYSTR':'','MON_DECIMAL_POINT':'','MON_THOUSANDS_SEP':'','MON_GROUPING':'','POSITIVE_SIGN':'','NEGATIVE_SIGN':'','INT_FRAC_DIGITS':'','FRAC_DIGITS':'','P_CS_PRECEDES':'','P_SEP_BY_SPACE':'','N_CS_PRECEDES':'','N_SEP_BY_SPACE':'','P_SIGN_POSN':'','N_SIGN_POSN':'','DECIMAL_POINT':'','RADIXCHAR':'','THOUSANDS_SEP':'','THOUSEP':'','GROUPING':'','YESEXPR':'','NOEXPR':'','YESSTR':'','NOSTR':'','CODESET':'','LC_ALL':'','LC_COLLATE':'','LC_CTYPE':'','LC_NUMERIC':'','LC_TIME':'','LC_MESSAGES':'','PHP_INT_MAX':'','STR_PAD_RIGHT':'','STR_PAD_LEFT':'','STR_PAD_BOTH':'',}
let php_builtin['constants']['error_handling']={'DEBUG_BACKTRACE_PROVIDE_OBJECT':'','DEBUG_BACKTRACE_IGNORE_ARGS':'',}
let php_builtin['constants']['math']={'PHP_INT_MAX':'','M_PI':'','PHP_ROUND_HALF_UP':'','PHP_ROUND_HALF_DOWN':'','PHP_ROUND_HALF_EVEN':'','PHP_ROUND_HALF_ODD':'','M_E':'','M_LOG2E':'','M_LOG10E':'','M_LN2':'','M_LN10':'','M_PI_2':'','M_PI_4':'','M_1_PI':'','M_2_PI':'','M_SQRTPI':'','M_2_SQRTPI':'','M_SQRT2':'','M_SQRT3':'','M_SQRT1_2':'','M_LNPI':'','M_EULER':'','NAN':'','INF':'',}
let php_builtin['constants']['network']={'LOG_EMERG':'','LOG_ALERT':'','LOG_CRIT':'','LOG_ERR':'','LOG_WARNING':'','LOG_NOTICE':'','LOG_INFO':'','LOG_DEBUG':'','LOG_KERN':'','LOG_USER':'','LOG_MAIL':'','LOG_DAEMON':'','LOG_AUTH':'','LOG_SYSLOG':'','LOG_LPR':'','LOG_NEWS':'','LOG_CRON':'','LOG_AUTHPRIV':'','LOG_LOCAL0':'','LOG_LOCAL1':'','LOG_LOCAL2':'','LOG_LOCAL3':'','LOG_LOCAL4':'','LOG_LOCAL5':'','LOG_LOCAL6':'','LOG_LOCAL7':'','LOG_PID':'','LOG_CONS':'','LOG_ODELAY':'','LOG_NDELAY':'','LOG_NOWAIT':'','LOG_PERROR':'','DNS_A':'','DNS_CNAME':'','DNS_HINFO':'','DNS_MX':'','DNS_NS':'','DNS_PTR':'','DNS_SOA':'','DNS_TXT':'','DNS_AAAA':'','DNS_SRV':'','DNS_NAPTR':'','DNS_A6':'','DNS_ALL':'','DNS_ANY':'','SID':'','LOG_UUCP':'',}
let php_builtin['constants']['urls']={'PHP_QUERY_RFC1738':'','PHP_QUERY_RFC3986':'','PHP_URL_SCHEME':'','PHP_URL_HOST':'','PHP_URL_PORT':'','PHP_URL_USER':'','PHP_URL_PASS':'','PHP_URL_PATH':'','PHP_URL_QUERY':'','PHP_URL_FRAGMENT':'',}
let php_builtin['constants']['gd']={'IMAGETYPE_GIF':'','IMAGETYPE_JPEG':'','IMAGETYPE_PNG':'','IMAGETYPE_SWF':'','IMAGETYPE_PSD':'','IMAGETYPE_BMP':'','IMAGETYPE_TIFF_II':'','IMAGETYPE_TIFF_MM':'','IMAGETYPE_JPC':'','IMAGETYPE_JP2':'','IMAGETYPE_JPX':'','IMAGETYPE_JB2':'','IMAGETYPE_SWC':'','IMAGETYPE_IFF':'','IMAGETYPE_WBMP':'','IMAGETYPE_XBM':'','IMAGETYPE_ICO':'','IMG_CROP_THRESHOLD':'','IMG_ARC_PIE':'','IMG_ARC_CHORD':'','IMG_ARC_NOFILL':'','IMG_ARC_EDGED':'','IMG_FILTER_NEGATE':'','IMG_FILTER_GRAYSCALE':'','IMG_FILTER_BRIGHTNESS':'','IMG_FILTER_CONTRAST':'','IMG_FILTER_COLORIZE':'','IMG_FILTER_EDGEDETECT':'','IMG_FILTER_EMBOSS':'','IMG_FILTER_GAUSSIAN_BLUR':'','IMG_FILTER_SELECTIVE_BLUR':'','IMG_FILTER_MEAN_REMOVAL':'','IMG_FILTER_SMOOTH':'','IMG_FILTER_PIXELATE':'','IMG_FLIP_HORIZONTAL':'','IMG_FLIP_VERTICAL':'','IMG_FLIP_BOTH':'','IMG_GD2_RAW':'','IMG_GD2_COMPRESSED':'','IMG_EFFECT_REPLACE':'','IMG_EFFECT_ALPHABLEND':'','IMG_EFFECT_NORMAL':'','IMG_EFFECT_OVERLAY':'','PNG_NO_FILTER':'','PNG_ALL_FILTERS':'','IMG_NEAREST_NEIGHBOUR':'','IMG_BILINEAR_FIXED':'','IMG_BICUBIC':'','IMG_BICUBIC_FIXED':'','IMG_COLOR_BRUSHED':'','IMG_COLOR_STYLEDBRUSHED':'','IMG_BELL':'','IMG_BESSEL':'','IMG_BLACKMAN':'','IMG_BOX':'','IMG_BSPLINE':'','IMG_CATMULLROM':'','IMG_GAUSSIAN':'','IMG_GENERALIZED_CUBIC':'','IMG_HERMITE':'','IMG_HAMMING':'','IMG_HANNING':'','IMG_MITCHELL':'','IMG_POWER':'','IMG_QUADRATIC':'','IMG_SINC':'','IMG_WEIGHTED4':'','IMG_TRIANGLE':'','IMG_COLOR_STYLED':'','IMG_COLOR_TRANSPARENT':'','IMG_COLOR_TILED':'','IMG_GIF':'','IMG_JPG':'','IMG_PNG':'','IMG_WBMP':'','IMG_XPM':'','GD_VERSION':'','GD_MAJOR_VERSION':'','GD_MINOR_VERSION':'','GD_RELEASE_VERSION':'','GD_EXTRA_VERSION':'','GD_BUNDLED':'','IMG_JPEG':'','IMG_ARC_ROUNDED':'','IMAGETYPE_JPEG2000':'','PNG_FILTER_NONE':'','PNG_FILTER_SUB':'','PNG_FILTER_UP':'','PNG_FILTER_AVG':'','PNG_FILTER_PAETH':'',}
let php_builtin['constants']['json']={'JSON_BIGINT_AS_STRING':'','JSON_HEX_QUOT':'','JSON_HEX_TAG':'','JSON_HEX_AMP':'','JSON_HEX_APOS':'','JSON_NUMERIC_CHECK':'','JSON_PRETTY_PRINT':'','JSON_UNESCAPED_SLASHES':'','JSON_FORCE_OBJECT':'','JSON_UNESCAPED_UNICODE':'','JSON_ERROR_NONE':'','JSON_ERROR_DEPTH':'','JSON_ERROR_STATE_MISMATCH':'','JSON_ERROR_CTRL_CHAR':'','JSON_ERROR_SYNTAX':'','JSON_ERROR_UTF8':'','JSON_ERROR_RECURSION':'','JSON_ERROR_INF_OR_NAN':'','NAN':'','INF':'','JSON_ERROR_UNSUPPORTED_TYPE':'','JSON_PARTIAL_OUTPUT_ON_ERROR':'',}
let php_builtin['constants']['multibyte_string']={'MB_CASE_UPPER':'','MB_CASE_LOWER':'','MB_CASE_TITLE':'','MB_OVERLOAD_MAIL':'','MB_OVERLOAD_STRING':'','MB_OVERLOAD_REGEX':'',}
let php_builtin['constants']['mssql']={'SQLTEXT':'','SQLVARCHAR':'','SQLCHAR':'','SQLINT1':'','SQLINT2':'','SQLINT4':'','SQLBIT':'','SQLFLT4':'','SQLFLT8':'','SQLFLTN':'','MSSQL_ASSOC':'','MSSQL_NUM':'','MSSQL_BOTH':'',}
let php_builtin['constants']['mysql']={'MYSQL_CLIENT_SSL':'','MYSQL_CLIENT_COMPRESS':'','MYSQL_CLIENT_IGNORE_SPACE':'','MYSQL_CLIENT_INTERACTIVE':'','MYSQL_ASSOC':'','MYSQL_NUM':'','MYSQL_BOTH':'','MYSQL_PORT':'',}
let php_builtin['constants']['output_control']={'PHP_OUTPUT_HANDLER_STDFLAGS':'','PHP_OUTPUT_HANDLER_CLEANABLE':'','PHP_OUTPUT_HANDLER_FLUSHABLE':'','PHP_OUTPUT_HANDLER_REMOVABLE':'','PHP_OUTPUT_HANDLER_START':'','PHP_OUTPUT_HANDLER_WRITE':'','PHP_OUTPUT_HANDLER_FLUSH':'','PHP_OUTPUT_HANDLER_CLEAN':'','PHP_OUTPUT_HANDLER_FINAL':'','PHP_OUTPUT_HANDLER_CONT':'','PHP_OUTPUT_HANDLER_END':'',}
let php_builtin['constants']['password_hashing']={'PASSWORD_DEFAULT':'','PASSWORD_BCRYPT':'','CRYPT_BLOWFISH':'',}
let php_builtin['constants']['postgresql']={'PGSQL_CONNECT_FORCE_NEW':'','PGSQL_CONNECTION_OK':'','PGSQL_CONNECTION_BAD':'','PGSQL_CONV_IGNORE_DEFAULT':'','PGSQL_CONV_FORCE_NULL':'','PGSQL_CONV_IGNORE_NOT_NULL':'','PGSQL_DML_NO_CONV':'','PGSQL_DML_ESCAPE':'','PGSQL_DML_EXEC':'','PGSQL_DML_ASYNC':'','PGSQL_DML_STRING':'','PGSQL_ASSOC':'','PGSQL_NUM':'','PGSQL_BOTH':'','PGSQL_CONV_OPTS':'','INV_READ':'','INV_WRITE':'','INV_ARCHIVE':'','PGSQL_SEEK_SET':'','PGSQL_SEEK_CUR':'','PGSQL_SEEK_END':'','PGSQL_DIAG_SEVERITY':'','PGSQL_DIAG_SQLSTATE':'','PGSQL_DIAG_MESSAGE_PRIMARY':'','PGSQL_DIAG_MESSAGE_DETAIL':'','PGSQL_DIAG_MESSAGE_HINT':'','PGSQL_DIAG_STATEMENT_POSITION':'','PGSQL_DIAG_INTERNAL_POSITION':'','PGSQL_DIAG_INTERNAL_QUERY':'','PGSQL_DIAG_CONTEXT':'','PGSQL_DIAG_SOURCE_FILE':'','PGSQL_DIAG_SOURCE_LINE':'','PGSQL_DIAG_SOURCE_FUNCTION':'','PGSQL_STATUS_LONG':'','PGSQL_STATUS_STRING':'','PGSQL_EMPTY_QUERY':'','PGSQL_COMMAND_OK':'','PGSQL_TUPLES_OK':'','PGSQL_COPY_OUT':'','PGSQL_COPY_IN':'','PGSQL_BAD_RESPONSE':'','PGSQL_NONFATAL_ERROR':'','PGSQL_FATAL_ERROR':'','PGSQL_ERRORS_TERSE':'','PGSQL_ERRORS_DEFAULT':'','PGSQL_ERRORS_VERBOSE':'','PGSQL_TRANSACTION_IDLE':'','PGSQL_TRANSACTION_ACTIVE':'','PGSQL_TRANSACTION_INTRANS':'','PGSQL_TRANSACTION_INERROR':'','PGSQL_TRANSACTION_UNKNOWN':'','PG_DIAG_STATEMENT_POSITION':'','PG_DIAG_INTERNAL_QUERY':'',}
let php_builtin['constants']['pcre']={'PREG_GREP_INVERT':'','PREG_NO_ERROR':'','PREG_INTERNAL_ERROR':'','PREG_BACKTRACK_LIMIT_ERROR':'','PREG_RECURSION_LIMIT_ERROR':'','PREG_BAD_UTF8_ERROR':'','PREG_BAD_UTF8_OFFSET_ERROR':'','PREG_PATTERN_ORDER':'','PREG_SET_ORDER':'','PREG_OFFSET_CAPTURE':'','PREG_SPLIT_NO_EMPTY':'','PREG_SPLIT_DELIM_CAPTURE':'','PREG_SPLIT_OFFSET_CAPTURE':'','PCRE_VERSION':'',}
let php_builtin['constants']['program_execution']={'STDIN':'',}
let php_builtin['constants']['sessions']={'SID':'','PHP_SESSION_DISABLED':'','PHP_SESSION_NONE':'','PHP_SESSION_ACTIVE':'','UPLOAD_ERR_EXTENSION':'',}
let php_builtin['constants']['variable_handling']={'PHP_INT_MAX':'',}
let php_builtin['constants']['misc']={'WAIT_IO_COMPLETION':'','CONNECTION_ABORTED':'','CONNECTION_NORMAL':'','CONNECTION_TIMEOUT':'',}
let php_builtin['constants']['streams']={'STREAM_FILTER_READ':'','STREAM_FILTER_WRITE':'','STREAM_FILTER_ALL':'','PHP_INT_MAX':'','STREAM_CLIENT_CONNECT':'','STREAM_CLIENT_ASYNC_CONNECT':'','STREAM_CLIENT_PERSISTENT':'','STREAM_CRYPTO_METHOD_TLS_CLIENT':'','STREAM_CRYPTO_METHOD_TLS_SERVER':'','STREAM_PF_INET':'','STREAM_PF_INET6':'','STREAM_PF_UNIX':'','STREAM_SOCK_DGRAM':'','STREAM_SOCK_RAW':'','STREAM_SOCK_RDM':'','STREAM_SOCK_SEQPACKET':'','STREAM_SOCK_STREAM':'','STREAM_IPPROTO_ICMP':'','STREAM_IPPROTO_IP':'','STREAM_IPPROTO_RAW':'','STREAM_IPPROTO_TCP':'','STREAM_IPPROTO_UDP':'','STREAM_OOB':'','STREAM_PEEK':'','AF_INET':'','STREAM_SERVER_BIND':'','STREAM_SHUT_RD':'','STREAM_SHUT_WR':'','STREAM_SHUT_RDWR':'','STREAM_IS_URL':'','PSFS_PASS_ON':'','PSFS_FEED_ME':'','PSFS_ERR_FATAL':'','PSFS_FLAG_NORMAL':'','PSFS_FLAG_FLUSH_INC':'','PSFS_FLAG_FLUSH_CLOSE':'','STREAM_USE_PATH':'','STREAM_REPORT_ERRORS':'','STREAM_SERVER_LISTEN':'','STREAM_NOTIFY_RESOLVE':'','STREAM_NOTIFY_CONNECT':'','STREAM_NOTIFY_AUTH_REQUIRED':'','STREAM_NOTIFY_SEVERITY_ERR':'','STREAM_NOTIFY_MIME_TYPE_IS':'','STREAM_NOTIFY_FILE_SIZE_IS':'','STREAM_NOTIFY_REDIRECTED':'','STREAM_NOTIFY_PROGRESS':'','STREAM_NOTIFY_COMPLETED':'','STREAM_NOTIFY_FAILURE':'','STREAM_NOTIFY_AUTH_RESULT':'','STREAM_NOTIFY_SEVERITY_INFO':'','STREAM_NOTIFY_SEVERITY_WARN':'','STREAM_CAST_FOR_SELECT':'','STREAM_CAST_AS_STREAM':'','STREAM_META_TOUCH':'','STREAM_META_OWNER':'','STREAM_META_OWNER_NAME':'','STREAM_META_GROUP':'','STREAM_META_GROUP_NAME':'','STREAM_META_ACCESS':'','STREAM_MKDIR_RECURSIVE':'','LOCK_EX':'','LOCK_UN':'','LOCK_SH':'','LOCK_NB':'','SEEK_SET':'','SEEK_CUR':'','SEEK_END':'','STREAM_OPTION_BLOCKING':'','STREAM_OPTION_READ_TIMEOUT':'','STREAM_OPTION_WRITE_BUFFER':'','STREAM_BUFFER_NONE':'','STREAM_BUFFER_FULL':'',}
let php_builtin['constants']['iconv']={'ICONV_IMPL':'','ICONV_VERSION':'','ICONV_MIME_DECODE_STRICT':'','ICONV_MIME_DECODE_CONTINUE_ON_ERROR':'',}
let php_builtin['constants']['phpini_directives']={'PATH_SEPARATOR':'','PHP_INI_SYSTEM':'',}
let php_builtin['constants']['types']={'NAN':'','PHP_INT_SIZE':'','PHP_INT_MAX':'',}
let php_builtin['constants']['pdo']={'PDO_PARAM_BOOL':'',}
let php_builtin['constants']['list_of_reserved_words']={'PHP_VERSION':'','PHP_MAJOR_VERSION':'','PHP_MINOR_VERSION':'','PHP_RELEASE_VERSION':'','PHP_VERSION_ID':'','PHP_EXTRA_VERSION':'','PHP_ZTS':'','PHP_DEBUG':'','PHP_MAXPATHLEN':'','PHP_OS':'','PHP_SAPI':'','PHP_EOL':'','PHP_INT_MAX':'','PHP_INT_SIZE':'','DEFAULT_INCLUDE_PATH':'','PEAR_INSTALL_DIR':'','PEAR_EXTENSION_DIR':'','PHP_EXTENSION_DIR':'','PHP_PREFIX':'','PHP_BINDIR':'','PHP_BINARY':'','PHP_MANDIR':'','PHP_LIBDIR':'','PHP_DATADIR':'','PHP_SYSCONFDIR':'','PHP_LOCALSTATEDIR':'','PHP_CONFIG_FILE_PATH':'','PHP_CONFIG_FILE_SCAN_DIR':'','PHP_SHLIB_SUFFIX':'',}
let php_builtin['constants']['php_type_comparison_tables']={'NAN':'',}

" Built in functions
let g:php_builtin_functions = {}
for [ext, data] in items(php_builtin['functions'])
	call extend(g:php_builtin_functions, data)
endfor

" Built in classs
let g:php_builtin_classes = {}
for [ext, data] in items(php_builtin['classes'])
	call extend(g:php_builtin_classes, data)
endfor

" Built in interfaces
let g:php_builtin_interfaces = {}
for [ext, data] in items(php_builtin['interfaces'])
	call extend(g:php_builtin_interfaces, data)
endfor

" Built in constants
let g:php_constants = {}
for [ext, data] in items(php_builtin['constants'])
	call extend(g:php_constants, data)
endfor

" When the classname not found or found but the tags dosen't contain that
" class we will try to complate any method of any builtin class. To speed up
" that lookup we compile a 'ClassName::MethodName':'info' dictionary from the
" builtin class informations
let g:php_builtin_object_functions = {}

" When completing for 'everyting imaginable' (no class context, not a
" variable) we need a list of built-in classes in a format of {'classname':''}
" for performance reasons we precompile this too
let g:php_builtin_classnames = {}

" In order to reduce file size, empty keys are omitted from class structures.
" To make the structure of in-memory hashes normalized we will add them in runtime
let required_class_hash_keys = ['constants', 'properties', 'static_properties', 'methods', 'static_methods']

for [classname, class_info] in items(g:php_builtin_classes)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_classnames[classname] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[classname.'::'.method_name.'('] = method_info.signature
	endfor
endfor

let g:php_builtin_interfacenames = {}
for [interfacename, info] in items(g:php_builtin_interfaces)
	for property_name in required_class_hash_keys
		if !has_key(class_info, property_name)
			let class_info[property_name] = {}
		endif
	endfor

	let g:php_builtin_interfacenames[interfacename] = ''
	for [method_name, method_info] in items(class_info.methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
	for [method_name, method_info] in items(class_info.static_methods)
		let g:php_builtin_object_functions[interfacename.'::'.method_name.'('] = method_info.signature
	endfor
endfor


" Add control structures (they are outside regular pattern of PHP functions)
let php_control = {
			\ 'include(': 'string filename | resource',
			\ 'include_once(': 'string filename | resource',
			\ 'require(': 'string filename | resource',
			\ 'require_once(': 'string filename | resource',
			\ }
call extend(g:php_builtin_functions, php_control)


" Built-in variables " {{{
let g:php_builtin_vars ={
			\ '$GLOBALS':'',
			\ '$_SERVER':'',
			\ '$_GET':'',
			\ '$_POST':'',
			\ '$_COOKIE':'',
			\ '$_FILES':'',
			\ '$_ENV':'',
			\ '$_REQUEST':'',
			\ '$_SESSION':'',
			\ '$HTTP_SERVER_VARS':'',
			\ '$HTTP_ENV_VARS':'',
			\ '$HTTP_COOKIE_VARS':'',
			\ '$HTTP_GET_VARS':'',
			\ '$HTTP_POST_VARS':'',
			\ '$HTTP_POST_FILES':'',
			\ '$HTTP_SESSION_VARS':'',
			\ '$php_errormsg':'',
			\ '$this':'',
			\ }
" }}}
endfunction
" }}}

" vim: foldmethod=marker:noexpandtab:ts=8:sts=4
                                                                     usr/share/vim/vim74/autoload/python3complete.vim                                                    0100644 0000000 0000000 00000052003 13050207306 020377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "python3complete.vim - Omni Completion for python
" Maintainer: Aaron Griffin <aaronmgriffin@gmail.com>
" Version: 0.9
" Last Updated: 18 Jun 2009
"
" Roland Puntaier: this file contains adaptations for python3 and is parallel to pythoncomplete.vim
"
" Changes
" TODO:
" 'info' item output can use some formatting work
" Add an "unsafe eval" mode, to allow for return type evaluation
" Complete basic syntax along with import statements
"   i.e. "import url<c-x,c-o>"
" Continue parsing on invalid line??
"
" v 0.9
"   * Fixed docstring parsing for classes and functions
"   * Fixed parsing of *args and **kwargs type arguments
"   * Better function param parsing to handle things like tuples and
"     lambda defaults args
"
" v 0.8
"   * Fixed an issue where the FIRST assignment was always used instead of
"   using a subsequent assignment for a variable
"   * Fixed a scoping issue when working inside a parameterless function
"
"
" v 0.7
"   * Fixed function list sorting (_ and __ at the bottom)
"   * Removed newline removal from docs.  It appears vim handles these better in
"   recent patches
"
" v 0.6:
"   * Fixed argument completion
"   * Removed the 'kind' completions, as they are better indicated
"   with real syntax
"   * Added tuple assignment parsing (whoops, that was forgotten)
"   * Fixed import handling when flattening scope
"
" v 0.5:
" Yeah, I skipped a version number - 0.4 was never public.
"  It was a bugfix version on top of 0.3.  This is a complete
"  rewrite.
"

if !has('python3')
    echo "Error: Required vim compiled with +python3"
    finish
endif

function! python3complete#Complete(findstart, base)
    "findstart = 1 when we need to get the text length
    if a:findstart == 1
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                let idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        "vim no longer moves the cursor upon completion... fix that
        let line = getline('.')
        let idx = col('.')
        let cword = ''
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w' || c =~ '\.'
                let cword = c . cword
                continue
            elseif strlen(cword) > 0 || idx == 0
                break
            endif
        endwhile
        execute "py3 vimpy3complete('" . cword . "', '" . a:base . "')"
        return g:python3complete_completions
    endif
endfunction

function! s:DefPython()
py3 << PYTHONEOF
import sys, tokenize, io, types
from token import NAME, DEDENT, NEWLINE, STRING

debugstmts=[]
def dbg(s): debugstmts.append(s)
def showdbg():
    for d in debugstmts: print("DBG: %s " % d)

def vimpy3complete(context,match):
    global debugstmts
    debugstmts = []
    try:
        import vim
        cmpl = Completer()
        cmpl.evalsource('\n'.join(vim.current.buffer),vim.eval("line('.')"))
        all = cmpl.get_completions(context,match)
        all.sort(key=lambda x:x['abbr'].replace('_','z'))
        dictstr = '['
        # have to do this for double quoting
        for cmpl in all:
            dictstr += '{'
            for x in cmpl: dictstr += '"%s":"%s",' % (x,cmpl[x])
            dictstr += '"icase":0},'
        if dictstr[-1] == ',': dictstr = dictstr[:-1]
        dictstr += ']'
        #dbg("dict: %s" % dictstr)
        vim.command("silent let g:python3complete_completions = %s" % dictstr)
        #dbg("Completion dict:\n%s" % all)
    except vim.error:
        dbg("VIM Error: %s" % vim.error)

class Completer(object):
    def __init__(self):
       self.compldict = {}
       self.parser = PyParser()

    def evalsource(self,text,line=0):
        sc = self.parser.parse(text,line)
        src = sc.get_code()
        dbg("source: %s" % src)
        try: exec(src,self.compldict)
        except: dbg("parser: %s, %s" % (sys.exc_info()[0],sys.exc_info()[1]))
        for l in sc.locals:
            try: exec(l,self.compldict)
            except: dbg("locals: %s, %s [%s]" % (sys.exc_info()[0],sys.exc_info()[1],l))

    def _cleanstr(self,doc):
        return doc.replace('"',' ').replace("'",' ')

    def get_arguments(self,func_obj):
        def _ctor(class_ob):
            try: return class_ob.__init__
            except AttributeError:
                for base in class_ob.__bases__:
                    rc = _ctor(base)
                    if rc is not None: return rc
            return None

        arg_offset = 1
        if type(func_obj) == type: func_obj = _ctor(func_obj)
        elif type(func_obj) == types.MethodType: arg_offset = 1
        else: arg_offset = 0

        arg_text=''
        if type(func_obj) in [types.FunctionType, types.LambdaType,types.MethodType]:
            try:
                cd = func_obj.__code__
                real_args = cd.co_varnames[arg_offset:cd.co_argcount]
                defaults = func_obj.__defaults__ or []
                defaults = ["=%s" % name for name in defaults]
                defaults = [""] * (len(real_args)-len(defaults)) + defaults
                items = [a+d for a,d in zip(real_args,defaults)]
                if func_obj.__code__.co_flags & 0x4:
                    items.append("...")
                if func_obj.__code__.co_flags & 0x8:
                    items.append("***")
                arg_text = (','.join(items)) + ')'
            except:
                dbg("arg completion: %s: %s" % (sys.exc_info()[0],sys.exc_info()[1]))
                pass
        if len(arg_text) == 0:
            # The doc string sometimes contains the function signature
            #  this works for alot of C modules that are part of the
            #  standard library
            doc = func_obj.__doc__
            if doc:
                doc = doc.lstrip()
                pos = doc.find('\n')
                if pos > 0:
                    sigline = doc[:pos]
                    lidx = sigline.find('(')
                    ridx = sigline.find(')')
                    if lidx > 0 and ridx > 0:
                        arg_text = sigline[lidx+1:ridx] + ')'
        if len(arg_text) == 0: arg_text = ')'
        return arg_text

    def get_completions(self,context,match):
        #dbg("get_completions('%s','%s')" % (context,match))
        stmt = ''
        if context: stmt += str(context)
        if match: stmt += str(match)
        try:
            result = None
            all = {}
            ridx = stmt.rfind('.')
            if len(stmt) > 0 and stmt[-1] == '(':
                result = eval(_sanitize(stmt[:-1]), self.compldict)
                doc = result.__doc__
                if doc is None: doc = ''
                args = self.get_arguments(result)
                return [{'word':self._cleanstr(args),'info':self._cleanstr(doc)}]
            elif ridx == -1:
                match = stmt
                all = self.compldict
            else:
                match = stmt[ridx+1:]
                stmt = _sanitize(stmt[:ridx])
                result = eval(stmt, self.compldict)
                all = dir(result)

            dbg("completing: stmt:%s" % stmt)
            completions = []

            try: maindoc = result.__doc__
            except: maindoc = ' '
            if maindoc is None: maindoc = ' '
            for m in all:
                if m == "_PyCmplNoType": continue #this is internal
                try:
                    dbg('possible completion: %s' % m)
                    if m.find(match) == 0:
                        if result is None: inst = all[m]
                        else: inst = getattr(result,m)
                        try: doc = inst.__doc__
                        except: doc = maindoc
                        typestr = str(inst)
                        if doc is None or doc == '': doc = maindoc

                        wrd = m[len(match):]
                        c = {'word':wrd, 'abbr':m,  'info':self._cleanstr(doc)}
                        if "function" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "method" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "module" in typestr:
                            c['word'] += '.'
                        elif "type" in typestr:
                            c['word'] += '('
                            c['abbr'] += '('
                        completions.append(c)
                except:
                    i = sys.exc_info()
                    dbg("inner completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return completions
        except:
            i = sys.exc_info()
            dbg("completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return []

class Scope(object):
    def __init__(self,name,indent,docstr=''):
        self.subscopes = []
        self.docstr = docstr
        self.locals = []
        self.parent = None
        self.name = name
        self.indent = indent

    def add(self,sub):
        #print('push scope: [%s@%s]' % (sub.name,sub.indent))
        sub.parent = self
        self.subscopes.append(sub)
        return sub

    def doc(self,str):
        """ Clean up a docstring """
        d = str.replace('\n',' ')
        d = d.replace('\t',' ')
        while d.find('  ') > -1: d = d.replace('  ',' ')
        while d[0] in '"\'\t ': d = d[1:]
        while d[-1] in '"\'\t ': d = d[:-1]
        dbg("Scope(%s)::docstr = %s" % (self,d))
        self.docstr = d

    def local(self,loc):
        self._checkexisting(loc)
        self.locals.append(loc)

    def copy_decl(self,indent=0):
        """ Copy a scope's declaration only, at the specified indent level - not local variables """
        return Scope(self.name,indent,self.docstr)

    def _checkexisting(self,test):
        "Convienance function... keep out duplicates"
        if test.find('=') > -1:
            var = test.split('=')[0].strip()
            for l in self.locals:
                if l.find('=') > -1 and var == l.split('=')[0].strip():
                    self.locals.remove(l)

    def get_code(self):
        str = ""
        if len(self.docstr) > 0: str += '"""'+self.docstr+'"""\n'
        for l in self.locals:
            if l.startswith('import'): str += l+'\n'
        str += 'class _PyCmplNoType:\n    def __getattr__(self,name):\n        return None\n'
        for sub in self.subscopes:
            str += sub.get_code()
        for l in self.locals:
            if not l.startswith('import'): str += l+'\n'

        return str

    def pop(self,indent):
        #print('pop scope: [%s] to [%s]' % (self.indent,indent))
        outer = self
        while outer.parent != None and outer.indent >= indent:
            outer = outer.parent
        return outer

    def currentindent(self):
        #print('parse current indent: %s' % self.indent)
        return '    '*self.indent

    def childindent(self):
        #print('parse child indent: [%s]' % (self.indent+1))
        return '    '*(self.indent+1)

class Class(Scope):
    def __init__(self, name, supers, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.supers = supers
    def copy_decl(self,indent=0):
        c = Class(self.name,self.supers,indent, self.docstr)
        for s in self.subscopes:
            c.add(s.copy_decl(indent+1))
        return c
    def get_code(self):
        str = '%sclass %s' % (self.currentindent(),self.name)
        if len(self.supers) > 0: str += '(%s)' % ','.join(self.supers)
        str += ':\n'
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        if len(self.subscopes) > 0:
            for s in self.subscopes: str += s.get_code()
        else:
            str += '%spass\n' % self.childindent()
        return str


class Function(Scope):
    def __init__(self, name, params, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.params = params
    def copy_decl(self,indent=0):
        return Function(self.name,self.params,indent, self.docstr)
    def get_code(self):
        str = "%sdef %s(%s):\n" % \
            (self.currentindent(),self.name,','.join(self.params))
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        str += "%spass\n" % self.childindent()
        return str

class PyParser:
    def __init__(self):
        self.top = Scope('global',0)
        self.scope = self.top

    def _parsedotname(self,pre=None):
        #returns (dottedname, nexttoken)
        name = []
        if pre is None:
            tokentype, token, indent = self.donext()
            if tokentype != NAME and token != '*':
                return ('', token)
        else: token = pre
        name.append(token)
        while True:
            tokentype, token, indent = self.donext()
            if token != '.': break
            tokentype, token, indent = self.donext()
            if tokentype != NAME: break
            name.append(token)
        return (".".join(name), token)

    def _parseimportlist(self):
        imports = []
        while True:
            name, token = self._parsedotname()
            if not name: break
            name2 = ''
            if token == 'as': name2, token = self._parsedotname()
            imports.append((name, name2))
            while token != "," and "\n" not in token:
                tokentype, token, indent = self.donext()
            if token != ",": break
        return imports

    def _parenparse(self):
        name = ''
        names = []
        level = 1
        while True:
            tokentype, token, indent = self.donext()
            if token in (')', ',') and level == 1:
                if '=' not in name: name = name.replace(' ', '')
                names.append(name.strip())
                name = ''
            if token == '(':
                level += 1
                name += "("
            elif token == ')':
                level -= 1
                if level == 0: break
                else: name += ")"
            elif token == ',' and level == 1:
                pass
            else:
                name += "%s " % str(token)
        return names

    def _parsefunction(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, fname, ind = self.donext()
        if tokentype != NAME: return None

        tokentype, open, ind = self.donext()
        if open != '(': return None
        params=self._parenparse()

        tokentype, colon, ind = self.donext()
        if colon != ':': return None

        return Function(fname,params,indent)

    def _parseclass(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, cname, ind = self.donext()
        if tokentype != NAME: return None

        super = []
        tokentype, thenext, ind = self.donext()
        if thenext == '(':
            super=self._parenparse()
        elif thenext != ':': return None

        return Class(cname,super,indent)

    def _parseassignment(self):
        assign=''
        tokentype, token, indent = self.donext()
        if tokentype == tokenize.STRING or token == 'str':  
            return '""'
        elif token == '(' or token == 'tuple':
            return '()'
        elif token == '[' or token == 'list':
            return '[]'
        elif token == '{' or token == 'dict':
            return '{}'
        elif tokentype == tokenize.NUMBER:
            return '0'
        elif token == 'open' or token == 'file':
            return 'file'
        elif token == 'None':
            return '_PyCmplNoType()'
        elif token == 'type':
            return 'type(_PyCmplNoType)' #only for method resolution
        else:
            assign += token
            level = 0
            while True:
                tokentype, token, indent = self.donext()
                if token in ('(','{','['):
                    level += 1
                elif token in (']','}',')'):
                    level -= 1
                    if level == 0: break
                elif level == 0:
                    if token in (';','\n'): break
                    assign += token
        return "%s" % assign

    def donext(self):
        type, token, (lineno, indent), end, self.parserline = next(self.gen)
        if lineno == self.curline:
            #print('line found [%s] scope=%s' % (line.replace('\n',''),self.scope.name))
            self.currentscope = self.scope
        return (type, token, indent)

    def _adjustvisibility(self):
        newscope = Scope('result',0)
        scp = self.currentscope
        while scp != None:
            if type(scp) == Function:
                slice = 0
                #Handle 'self' params
                if scp.parent != None and type(scp.parent) == Class:
                    slice = 1
                    newscope.local('%s = %s' % (scp.params[0],scp.parent.name))
                for p in scp.params[slice:]:
                    i = p.find('=')
                    if len(p) == 0: continue
                    pvar = ''
                    ptype = ''
                    if i == -1:
                        pvar = p
                        ptype = '_PyCmplNoType()'
                    else:
                        pvar = p[:i]
                        ptype = _sanitize(p[i+1:])
                    if pvar.startswith('**'):
                        pvar = pvar[2:]
                        ptype = '{}'
                    elif pvar.startswith('*'):
                        pvar = pvar[1:]
                        ptype = '[]'

                    newscope.local('%s = %s' % (pvar,ptype))

            for s in scp.subscopes:
                ns = s.copy_decl(0)
                newscope.add(ns)
            for l in scp.locals: newscope.local(l)
            scp = scp.parent

        self.currentscope = newscope
        return self.currentscope

    #p.parse(vim.current.buffer[:],vim.eval("line('.')"))
    def parse(self,text,curline=0):
        self.curline = int(curline)
        buf = io.StringIO(''.join(text) + '\n')
        self.gen = tokenize.generate_tokens(buf.readline)
        self.currentscope = self.scope

        try:
            freshscope=True
            while True:
                tokentype, token, indent = self.donext()
                #dbg( 'main: token=[%s] indent=[%s]' % (token,indent))

                if tokentype == DEDENT or token == "pass":
                    self.scope = self.scope.pop(indent)
                elif token == 'def':
                    func = self._parsefunction(indent)
                    if func is None:
                        print("function: syntax error...")
                        continue
                    dbg("new scope: function")
                    freshscope = True
                    self.scope = self.scope.add(func)
                elif token == 'class':
                    cls = self._parseclass(indent)
                    if cls is None:
                        print("class: syntax error...")
                        continue
                    freshscope = True
                    dbg("new scope: class")
                    self.scope = self.scope.add(cls)
                    
                elif token == 'import':
                    imports = self._parseimportlist()
                    for mod, alias in imports:
                        loc = "import %s" % mod
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif token == 'from':
                    mod, token = self._parsedotname()
                    if not mod or token != "import":
                        print("from: syntax error...")
                        continue
                    names = self._parseimportlist()
                    for name, alias in names:
                        loc = "from %s import %s" % (mod,name)
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif tokentype == STRING:
                    if freshscope: self.scope.doc(token)
                elif tokentype == NAME:
                    name,token = self._parsedotname(token) 
                    if token == '=':
                        stmt = self._parseassignment()
                        dbg("parseassignment: %s = %s" % (name, stmt))
                        if stmt != None:
                            self.scope.local("%s = %s" % (name,stmt))
                    freshscope = False
        except StopIteration: #thrown on EOF
            pass
        except:
            dbg("parse error: %s, %s @ %s" %
                (sys.exc_info()[0], sys.exc_info()[1], self.parserline))
        return self._adjustvisibility()

def _sanitize(str):
    val = ''
    level = 0
    for c in str:
        if c in ('(','{','['):
            level += 1
        elif c in (']','}',')'):
            level -= 1
        elif level == 0:
            val += c
    return val

sys.path.extend(['.','..'])
PYTHONEOF
endfunction

call s:DefPython()
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             usr/share/vim/vim74/autoload/pythoncomplete.vim                                                     0100644 0000000 0000000 00000053037 13050207306 020324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "pythoncomplete.vim - Omni Completion for python
" Maintainer: Aaron Griffin <aaronmgriffin@gmail.com>
" Version: 0.9
" Last Updated: 18 Jun 2009
"
" Changes
" TODO:
" 'info' item output can use some formatting work
" Add an "unsafe eval" mode, to allow for return type evaluation
" Complete basic syntax along with import statements
"   i.e. "import url<c-x,c-o>"
" Continue parsing on invalid line??
"
" v 0.9
"   * Fixed docstring parsing for classes and functions
"   * Fixed parsing of *args and **kwargs type arguments
"   * Better function param parsing to handle things like tuples and
"     lambda defaults args
"
" v 0.8
"   * Fixed an issue where the FIRST assignment was always used instead of
"   using a subsequent assignment for a variable
"   * Fixed a scoping issue when working inside a parameterless function
"
"
" v 0.7
"   * Fixed function list sorting (_ and __ at the bottom)
"   * Removed newline removal from docs.  It appears vim handles these better in
"   recent patches
"
" v 0.6:
"   * Fixed argument completion
"   * Removed the 'kind' completions, as they are better indicated
"   with real syntax
"   * Added tuple assignment parsing (whoops, that was forgotten)
"   * Fixed import handling when flattening scope
"
" v 0.5:
" Yeah, I skipped a version number - 0.4 was never public.
"  It was a bugfix version on top of 0.3.  This is a complete
"  rewrite.
"

if !has('python')
    echo "Error: Required vim compiled with +python"
    finish
endif

function! pythoncomplete#Complete(findstart, base)
    "findstart = 1 when we need to get the text length
    if a:findstart == 1
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                let idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        "vim no longer moves the cursor upon completion... fix that
        let line = getline('.')
        let idx = col('.')
        let cword = ''
        while idx > 0
            let idx -= 1
            let c = line[idx]
            if c =~ '\w' || c =~ '\.'
                let cword = c . cword
                continue
            elseif strlen(cword) > 0 || idx == 0
                break
            endif
        endwhile
        execute "python vimcomplete('" . cword . "', '" . a:base . "')"
        return g:pythoncomplete_completions
    endif
endfunction

function! s:DefPython()
python << PYTHONEOF
import sys, tokenize, cStringIO, types
from token import NAME, DEDENT, NEWLINE, STRING

debugstmts=[]
def dbg(s): debugstmts.append(s)
def showdbg():
    for d in debugstmts: print "DBG: %s " % d

def vimcomplete(context,match):
    global debugstmts
    debugstmts = []
    try:
        import vim
        def complsort(x,y):
            try:
                xa = x['abbr']
                ya = y['abbr']
                if xa[0] == '_':
                    if xa[1] == '_' and ya[0:2] == '__':
                        return xa > ya
                    elif ya[0:2] == '__':
                        return -1
                    elif y[0] == '_':
                        return xa > ya
                    else:
                        return 1
                elif ya[0] == '_':
                    return -1
                else:
                   return xa > ya
            except:
                return 0
        cmpl = Completer()
        cmpl.evalsource('\n'.join(vim.current.buffer),vim.eval("line('.')"))
        all = cmpl.get_completions(context,match)
        all.sort(complsort)
        dictstr = '['
        # have to do this for double quoting
        for cmpl in all:
            dictstr += '{'
            for x in cmpl: dictstr += '"%s":"%s",' % (x,cmpl[x])
            dictstr += '"icase":0},'
        if dictstr[-1] == ',': dictstr = dictstr[:-1]
        dictstr += ']'
        #dbg("dict: %s" % dictstr)
        vim.command("silent let g:pythoncomplete_completions = %s" % dictstr)
        #dbg("Completion dict:\n%s" % all)
    except vim.error:
        dbg("VIM Error: %s" % vim.error)

class Completer(object):
    def __init__(self):
       self.compldict = {}
       self.parser = PyParser()

    def evalsource(self,text,line=0):
        sc = self.parser.parse(text,line)
        src = sc.get_code()
        dbg("source: %s" % src)
        try: exec(src) in self.compldict
        except: dbg("parser: %s, %s" % (sys.exc_info()[0],sys.exc_info()[1]))
        for l in sc.locals:
            try: exec(l) in self.compldict
            except: dbg("locals: %s, %s [%s]" % (sys.exc_info()[0],sys.exc_info()[1],l))

    def _cleanstr(self,doc):
        return doc.replace('"',' ').replace("'",' ')

    def get_arguments(self,func_obj):
        def _ctor(obj):
            try: return class_ob.__init__.im_func
            except AttributeError:
                for base in class_ob.__bases__:
                    rc = _find_constructor(base)
                    if rc is not None: return rc
            return None

        arg_offset = 1
        if type(func_obj) == types.ClassType: func_obj = _ctor(func_obj)
        elif type(func_obj) == types.MethodType: func_obj = func_obj.im_func
        else: arg_offset = 0
        
        arg_text=''
        if type(func_obj) in [types.FunctionType, types.LambdaType]:
            try:
                cd = func_obj.func_code
                real_args = cd.co_varnames[arg_offset:cd.co_argcount]
                defaults = func_obj.func_defaults or ''
                defaults = map(lambda name: "=%s" % name, defaults)
                defaults = [""] * (len(real_args)-len(defaults)) + defaults
                items = map(lambda a,d: a+d, real_args, defaults)
                if func_obj.func_code.co_flags & 0x4:
                    items.append("...")
                if func_obj.func_code.co_flags & 0x8:
                    items.append("***")
                arg_text = (','.join(items)) + ')'

            except:
                dbg("arg completion: %s: %s" % (sys.exc_info()[0],sys.exc_info()[1]))
                pass
        if len(arg_text) == 0:
            # The doc string sometimes contains the function signature
            #  this works for alot of C modules that are part of the
            #  standard library
            doc = func_obj.__doc__
            if doc:
                doc = doc.lstrip()
                pos = doc.find('\n')
                if pos > 0:
                    sigline = doc[:pos]
                    lidx = sigline.find('(')
                    ridx = sigline.find(')')
                    if lidx > 0 and ridx > 0:
                        arg_text = sigline[lidx+1:ridx] + ')'
        if len(arg_text) == 0: arg_text = ')'
        return arg_text

    def get_completions(self,context,match):
        dbg("get_completions('%s','%s')" % (context,match))
        stmt = ''
        if context: stmt += str(context)
        if match: stmt += str(match)
        try:
            result = None
            all = {}
            ridx = stmt.rfind('.')
            if len(stmt) > 0 and stmt[-1] == '(':
                result = eval(_sanitize(stmt[:-1]), self.compldict)
                doc = result.__doc__
                if doc is None: doc = ''
                args = self.get_arguments(result)
                return [{'word':self._cleanstr(args),'info':self._cleanstr(doc)}]
            elif ridx == -1:
                match = stmt
                all = self.compldict
            else:
                match = stmt[ridx+1:]
                stmt = _sanitize(stmt[:ridx])
                result = eval(stmt, self.compldict)
                all = dir(result)

            dbg("completing: stmt:%s" % stmt)
            completions = []

            try: maindoc = result.__doc__
            except: maindoc = ' '
            if maindoc is None: maindoc = ' '
            for m in all:
                if m == "_PyCmplNoType": continue #this is internal
                try:
                    dbg('possible completion: %s' % m)
                    if m.find(match) == 0:
                        if result is None: inst = all[m]
                        else: inst = getattr(result,m)
                        try: doc = inst.__doc__
                        except: doc = maindoc
                        typestr = str(inst)
                        if doc is None or doc == '': doc = maindoc

                        wrd = m[len(match):]
                        c = {'word':wrd, 'abbr':m,  'info':self._cleanstr(doc)}
                        if "function" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "method" in typestr:
                            c['word'] += '('
                            c['abbr'] += '(' + self._cleanstr(self.get_arguments(inst))
                        elif "module" in typestr:
                            c['word'] += '.'
                        elif "class" in typestr:
                            c['word'] += '('
                            c['abbr'] += '('
                        completions.append(c)
                except:
                    i = sys.exc_info()
                    dbg("inner completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return completions
        except:
            i = sys.exc_info()
            dbg("completion: %s,%s [stmt='%s']" % (i[0],i[1],stmt))
            return []

class Scope(object):
    def __init__(self,name,indent,docstr=''):
        self.subscopes = []
        self.docstr = docstr
        self.locals = []
        self.parent = None
        self.name = name
        self.indent = indent

    def add(self,sub):
        #print 'push scope: [%s@%s]' % (sub.name,sub.indent)
        sub.parent = self
        self.subscopes.append(sub)
        return sub

    def doc(self,str):
        """ Clean up a docstring """
        d = str.replace('\n',' ')
        d = d.replace('\t',' ')
        while d.find('  ') > -1: d = d.replace('  ',' ')
        while d[0] in '"\'\t ': d = d[1:]
        while d[-1] in '"\'\t ': d = d[:-1]
        dbg("Scope(%s)::docstr = %s" % (self,d))
        self.docstr = d

    def local(self,loc):
        self._checkexisting(loc)
        self.locals.append(loc)

    def copy_decl(self,indent=0):
        """ Copy a scope's declaration only, at the specified indent level - not local variables """
        return Scope(self.name,indent,self.docstr)

    def _checkexisting(self,test):
        "Convienance function... keep out duplicates"
        if test.find('=') > -1:
            var = test.split('=')[0].strip()
            for l in self.locals:
                if l.find('=') > -1 and var == l.split('=')[0].strip():
                    self.locals.remove(l)

    def get_code(self):
        str = ""
        if len(self.docstr) > 0: str += '"""'+self.docstr+'"""\n'
        for l in self.locals:
            if l.startswith('import'): str += l+'\n'
        str += 'class _PyCmplNoType:\n    def __getattr__(self,name):\n        return None\n'
        for sub in self.subscopes:
            str += sub.get_code()
        for l in self.locals:
            if not l.startswith('import'): str += l+'\n'

        return str

    def pop(self,indent):
        #print 'pop scope: [%s] to [%s]' % (self.indent,indent)
        outer = self
        while outer.parent != None and outer.indent >= indent:
            outer = outer.parent
        return outer

    def currentindent(self):
        #print 'parse current indent: %s' % self.indent
        return '    '*self.indent

    def childindent(self):
        #print 'parse child indent: [%s]' % (self.indent+1)
        return '    '*(self.indent+1)

class Class(Scope):
    def __init__(self, name, supers, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.supers = supers
    def copy_decl(self,indent=0):
        c = Class(self.name,self.supers,indent, self.docstr)
        for s in self.subscopes:
            c.add(s.copy_decl(indent+1))
        return c
    def get_code(self):
        str = '%sclass %s' % (self.currentindent(),self.name)
        if len(self.supers) > 0: str += '(%s)' % ','.join(self.supers)
        str += ':\n'
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        if len(self.subscopes) > 0:
            for s in self.subscopes: str += s.get_code()
        else:
            str += '%spass\n' % self.childindent()
        return str


class Function(Scope):
    def __init__(self, name, params, indent, docstr=''):
        Scope.__init__(self,name,indent, docstr)
        self.params = params
    def copy_decl(self,indent=0):
        return Function(self.name,self.params,indent, self.docstr)
    def get_code(self):
        str = "%sdef %s(%s):\n" % \
            (self.currentindent(),self.name,','.join(self.params))
        if len(self.docstr) > 0: str += self.childindent()+'"""'+self.docstr+'"""\n'
        str += "%spass\n" % self.childindent()
        return str

class PyParser:
    def __init__(self):
        self.top = Scope('global',0)
        self.scope = self.top
        self.parserline = 0

    def _parsedotname(self,pre=None):
        #returns (dottedname, nexttoken)
        name = []
        if pre is None:
            tokentype, token, indent = self.next()
            if tokentype != NAME and token != '*':
                return ('', token)
        else: token = pre
        name.append(token)
        while True:
            tokentype, token, indent = self.next()
            if token != '.': break
            tokentype, token, indent = self.next()
            if tokentype != NAME: break
            name.append(token)
        return (".".join(name), token)

    def _parseimportlist(self):
        imports = []
        while True:
            name, token = self._parsedotname()
            if not name: break
            name2 = ''
            if token == 'as': name2, token = self._parsedotname()
            imports.append((name, name2))
            while token != "," and "\n" not in token:
                tokentype, token, indent = self.next()
            if token != ",": break
        return imports

    def _parenparse(self):
        name = ''
        names = []
        level = 1
        while True:
            tokentype, token, indent = self.next()
            if token in (')', ',') and level == 1:
                if '=' not in name: name = name.replace(' ', '')
                names.append(name.strip())
                name = ''
            if token == '(':
                level += 1
                name += "("
            elif token == ')':
                level -= 1
                if level == 0: break
                else: name += ")"
            elif token == ',' and level == 1:
                pass
            else:
                name += "%s " % str(token)
        return names

    def _parsefunction(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, fname, ind = self.next()
        if tokentype != NAME: return None

        tokentype, open, ind = self.next()
        if open != '(': return None
        params=self._parenparse()

        tokentype, colon, ind = self.next()
        if colon != ':': return None

        return Function(fname,params,indent)

    def _parseclass(self,indent):
        self.scope=self.scope.pop(indent)
        tokentype, cname, ind = self.next()
        if tokentype != NAME: return None

        super = []
        tokentype, next, ind = self.next()
        if next == '(':
            super=self._parenparse()
        elif next != ':': return None

        return Class(cname,super,indent)

    def _parseassignment(self):
        assign=''
        tokentype, token, indent = self.next()
        if tokentype == tokenize.STRING or token == 'str':  
            return '""'
        elif token == '(' or token == 'tuple':
            return '()'
        elif token == '[' or token == 'list':
            return '[]'
        elif token == '{' or token == 'dict':
            return '{}'
        elif tokentype == tokenize.NUMBER:
            return '0'
        elif token == 'open' or token == 'file':
            return 'file'
        elif token == 'None':
            return '_PyCmplNoType()'
        elif token == 'type':
            return 'type(_PyCmplNoType)' #only for method resolution
        else:
            assign += token
            level = 0
            while True:
                tokentype, token, indent = self.next()
                if token in ('(','{','['):
                    level += 1
                elif token in (']','}',')'):
                    level -= 1
                    if level == 0: break
                elif level == 0:
                    if token in (';','\n'): break
                    assign += token
        return "%s" % assign

    def next(self):
        type, token, (lineno, indent), end, self.parserline = self.gen.next()
        if lineno == self.curline:
            #print 'line found [%s] scope=%s' % (line.replace('\n',''),self.scope.name)
            self.currentscope = self.scope
        return (type, token, indent)

    def _adjustvisibility(self):
        newscope = Scope('result',0)
        scp = self.currentscope
        while scp != None:
            if type(scp) == Function:
                slice = 0
                #Handle 'self' params
                if scp.parent != None and type(scp.parent) == Class:
                    slice = 1
                    newscope.local('%s = %s' % (scp.params[0],scp.parent.name))
                for p in scp.params[slice:]:
                    i = p.find('=')
                    if len(p) == 0: continue
                    pvar = ''
                    ptype = ''
                    if i == -1:
                        pvar = p
                        ptype = '_PyCmplNoType()'
                    else:
                        pvar = p[:i]
                        ptype = _sanitize(p[i+1:])
                    if pvar.startswith('**'):
                        pvar = pvar[2:]
                        ptype = '{}'
                    elif pvar.startswith('*'):
                        pvar = pvar[1:]
                        ptype = '[]'

                    newscope.local('%s = %s' % (pvar,ptype))

            for s in scp.subscopes:
                ns = s.copy_decl(0)
                newscope.add(ns)
            for l in scp.locals: newscope.local(l)
            scp = scp.parent

        self.currentscope = newscope
        return self.currentscope

    #p.parse(vim.current.buffer[:],vim.eval("line('.')"))
    def parse(self,text,curline=0):
        self.curline = int(curline)
        buf = cStringIO.StringIO(''.join(text) + '\n')
        self.gen = tokenize.generate_tokens(buf.readline)
        self.currentscope = self.scope

        try:
            freshscope=True
            while True:
                tokentype, token, indent = self.next()
                #dbg( 'main: token=[%s] indent=[%s]' % (token,indent))

                if tokentype == DEDENT or token == "pass":
                    self.scope = self.scope.pop(indent)
                elif token == 'def':
                    func = self._parsefunction(indent)
                    if func is None:
                        print "function: syntax error..."
                        continue
                    dbg("new scope: function")
                    freshscope = True
                    self.scope = self.scope.add(func)
                elif token == 'class':
                    cls = self._parseclass(indent)
                    if cls is None:
                        print "class: syntax error..."
                        continue
                    freshscope = True
                    dbg("new scope: class")
                    self.scope = self.scope.add(cls)
                    
                elif token == 'import':
                    imports = self._parseimportlist()
                    for mod, alias in imports:
                        loc = "import %s" % mod
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif token == 'from':
                    mod, token = self._parsedotname()
                    if not mod or token != "import":
                        print "from: syntax error..."
                        continue
                    names = self._parseimportlist()
                    for name, alias in names:
                        loc = "from %s import %s" % (mod,name)
                        if len(alias) > 0: loc += " as %s" % alias
                        self.scope.local(loc)
                    freshscope = False
                elif tokentype == STRING:
                    if freshscope: self.scope.doc(token)
                elif tokentype == NAME:
                    name,token = self._parsedotname(token) 
                    if token == '=':
                        stmt = self._parseassignment()
                        dbg("parseassignment: %s = %s" % (name, stmt))
                        if stmt != None:
                            self.scope.local("%s = %s" % (name,stmt))
                    freshscope = False
        except StopIteration: #thrown on EOF
            pass
        except:
            dbg("parse error: %s, %s @ %s" %
                (sys.exc_info()[0], sys.exc_info()[1], self.parserline))
        return self._adjustvisibility()

def _sanitize(str):
    val = ''
    level = 0
    for c in str:
        if c in ('(','{','['):
            level += 1
        elif c in (']','}',')'):
            level -= 1
        elif level == 0:
            val += c
    return val

sys.path.extend(['.','..'])
PYTHONEOF
endfunction

call s:DefPython()
" vim: set et ts=4:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/share/vim/vim74/autoload/rubycomplete.vim                                                       0100644 0000000 0000000 00000056002 13050207306 017757  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim completion script
" Language:             Ruby
" Maintainer:           Mark Guzman <segfault@hasno.info>
" URL:                  https://github.com/vim-ruby/vim-ruby
" Release Coordinator:  Doug Kearns <dougkearns@gmail.com>
" Maintainer Version:   0.8.1
" ----------------------------------------------------------------------------
"
" Ruby IRB/Complete author: Keiju ISHITSUKA(keiju@ishitsuka.com)
" ----------------------------------------------------------------------------

" {{{ requirement checks

function! s:ErrMsg(msg)
    echohl ErrorMsg
    echo a:msg
    echohl None
endfunction

if !has('ruby')
    call s:ErrMsg( "Error: Rubycomplete requires vim compiled with +ruby" )
    call s:ErrMsg( "Error: falling back to syntax completion" )
    " lets fall back to syntax completion
    setlocal omnifunc=syntaxcomplete#Complete
    finish
endif

if version < 700
    call s:ErrMsg( "Error: Required vim >= 7.0" )
    finish
endif
" }}} requirement checks

" {{{ configuration failsafe initialization
if !exists("g:rubycomplete_rails")
    let g:rubycomplete_rails = 0
endif

if !exists("g:rubycomplete_classes_in_global")
    let g:rubycomplete_classes_in_global = 0
endif

if !exists("g:rubycomplete_buffer_loading")
    let g:rubycomplete_buffer_loading = 0
endif

if !exists("g:rubycomplete_include_object")
    let g:rubycomplete_include_object = 0
endif

if !exists("g:rubycomplete_include_objectspace")
    let g:rubycomplete_include_objectspace = 0
endif
" }}} configuration failsafe initialization

" {{{ vim-side support functions
let s:rubycomplete_debug = 0

function! s:dprint(msg)
    if s:rubycomplete_debug == 1
        echom a:msg
    endif
endfunction

function! s:GetBufferRubyModule(name, ...)
    if a:0 == 1
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module", a:1)
    else
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "module")
    endif
    return snum . '..' . enum
endfunction

function! s:GetBufferRubyClass(name, ...)
    if a:0 >= 1
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class", a:1)
    else
        let [snum,enum] = s:GetBufferRubyEntity(a:name, "class")
    endif
    return snum . '..' . enum
endfunction

function! s:GetBufferRubySingletonMethods(name)
endfunction

function! s:GetBufferRubyEntity( name, type, ... )
    let lastpos = getpos(".")
    let lastline = lastpos
    if (a:0 >= 1)
        let lastline = [ 0, a:1, 0, 0 ]
        call cursor( a:1, 0 )
    endif

    let stopline = 1

    let crex = '^\s*\<' . a:type . '\>\s*\<' . a:name . '\>\s*\(<\s*.*\s*\)\?'
    let [lnum,lcol] = searchpos( crex, 'w' )
    "let [lnum,lcol] = searchpairpos( crex . '\zs', '', '\(end\|}\)', 'w' )

    if lnum == 0 && lcol == 0
        call cursor(lastpos[1], lastpos[2])
        return [0,0]
    endif

    let curpos = getpos(".")
    let [enum,ecol] = searchpairpos( crex, '', '\(end\|}\)', 'wr' )
    call cursor(lastpos[1], lastpos[2])

    if lnum > enum
        return [0,0]
    endif
    " we found a the class def
    return [lnum,enum]
endfunction

function! s:IsInClassDef()
    return s:IsPosInClassDef( line('.') )
endfunction

function! s:IsPosInClassDef(pos)
    let [snum,enum] = s:GetBufferRubyEntity( '.*', "class" )
    let ret = 'nil'

    if snum < a:pos && a:pos < enum
        let ret = snum . '..' . enum
    endif

    return ret
endfunction

function! s:GetRubyVarType(v)
    let stopline = 1
    let vtp = ''
    let pos = getpos('.')
    let sstr = '^\s*#\s*@var\s*'.escape(a:v, '*').'\>\s\+[^ \t]\+\s*$'
    let [lnum,lcol] = searchpos(sstr,'nb',stopline)
    if lnum != 0 && lcol != 0
        call setpos('.',pos)
        let str = getline(lnum)
        let vtp = substitute(str,sstr,'\1','')
        return vtp
    endif
    call setpos('.',pos)
    let ctors = '\(now\|new\|open\|get_instance'
    if exists('g:rubycomplete_rails') && g:rubycomplete_rails == 1 && s:rubycomplete_rails_loaded == 1
        let ctors = ctors.'\|find\|create'
    else
    endif
    let ctors = ctors.'\)'

    let fstr = '=\s*\([^ \t]\+.' . ctors .'\>\|[\[{"''/]\|%[xwQqr][(\[{@]\|[A-Za-z0-9@:\-()\.]\+...\?\|lambda\|&\)'
    let sstr = ''.a:v.'\>\s*[+\-*/]*'.fstr
    let [lnum,lcol] = searchpos(sstr,'nb',stopline)
    if lnum != 0 && lcol != 0
        let str = matchstr(getline(lnum),fstr,lcol)
        let str = substitute(str,'^=\s*','','')

        call setpos('.',pos)
        if str == '"' || str == '''' || stridx(tolower(str), '%q[') != -1
            return 'String'
        elseif str == '[' || stridx(str, '%w[') != -1
            return 'Array'
        elseif str == '{'
            return 'Hash'
        elseif str == '/' || str == '%r{'
            return 'Regexp'
        elseif strlen(str) >= 4 && stridx(str,'..') != -1
            return 'Range'
        elseif stridx(str, 'lambda') != -1 || str == '&'
            return 'Proc'
        elseif strlen(str) > 4
            let l = stridx(str,'.')
            return str[0:l-1]
        end
        return ''
    endif
    call setpos('.',pos)
    return ''
endfunction

"}}} vim-side support functions

"{{{ vim-side completion function
function! rubycomplete#Init()
    execute "ruby VimRubyCompletion.preload_rails"
endfunction

function! rubycomplete#Complete(findstart, base)
     "findstart = 1 when we need to get the text length
    if a:findstart
        let line = getline('.')
        let idx = col('.')
        while idx > 0
            let idx -= 1
            let c = line[idx-1]
            if c =~ '\w'
                continue
            elseif ! c =~ '\.'
                idx = -1
                break
            else
                break
            endif
        endwhile

        return idx
    "findstart = 0 when we need to return the list of completions
    else
        let g:rubycomplete_completions = []
        execute "ruby VimRubyCompletion.get_completions('" . a:base . "')"
        return g:rubycomplete_completions
    endif
endfunction
"}}} vim-side completion function

"{{{ ruby-side code
function! s:DefRuby()
ruby << RUBYEOF
# {{{ ruby completion

begin
    require 'rubygems' # let's assume this is safe...?
rescue Exception
    #ignore?
end
class VimRubyCompletion
# {{{ constants
  @@debug = false
  @@ReservedWords = [
        "BEGIN", "END",
        "alias", "and",
        "begin", "break",
        "case", "class",
        "def", "defined", "do",
        "else", "elsif", "end", "ensure",
        "false", "for",
        "if", "in",
        "module",
        "next", "nil", "not",
        "or",
        "redo", "rescue", "retry", "return",
        "self", "super",
        "then", "true",
        "undef", "unless", "until",
        "when", "while",
        "yield",
      ]

  @@Operators = [ "%", "&", "*", "**", "+",  "-",  "/",
        "<", "<<", "<=", "<=>", "==", "===", "=~", ">", ">=", ">>",
        "[]", "[]=", "^", ]
# }}} constants

# {{{ buffer analysis magic
  def load_requires
    buf = VIM::Buffer.current
    enum = buf.line_number
    nums = Range.new( 1, enum )
    nums.each do |x|
      ln = buf[x]
      begin
        eval( "require %s" % $1 ) if /.*require\s*(.*)$/.match( ln )
      rescue Exception
        #ignore?
      end
    end
  end

  def load_buffer_class(name)
    dprint "load_buffer_class(%s) START" % name
    classdef = get_buffer_entity(name, 's:GetBufferRubyClass("%s")')
    return if classdef == nil

    pare = /^\s*class\s*(.*)\s*<\s*(.*)\s*\n/.match( classdef )
    load_buffer_class( $2 ) if pare != nil  && $2 != name # load parent class if needed

    mixre = /.*\n\s*(include|prepend)\s*(.*)\s*\n/.match( classdef )
    load_buffer_module( $2 ) if mixre != nil && $2 != name # load mixins if needed

    begin
      eval classdef
    rescue Exception
      VIM::evaluate( "s:ErrMsg( 'Problem loading class \"%s\", was it already completed?' )" % name )
    end
    dprint "load_buffer_class(%s) END" % name
  end

  def load_buffer_module(name)
    dprint "load_buffer_module(%s) START" % name
    classdef = get_buffer_entity(name, 's:GetBufferRubyModule("%s")')
    return if classdef == nil

    begin
      eval classdef
    rescue Exception
      VIM::evaluate( "s:ErrMsg( 'Problem loading module \"%s\", was it already completed?' )" % name )
    end
    dprint "load_buffer_module(%s) END" % name
  end

  def get_buffer_entity(name, vimfun)
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    return nil if loading_allowed.to_i.zero?
    return nil if /(\"|\')+/.match( name )
    buf = VIM::Buffer.current
    nums = eval( VIM::evaluate( vimfun % name ) )
    return nil if nums == nil
    return nil if nums.min == nums.max && nums.min == 0

    dprint "get_buffer_entity START"
    visited = []
    clscnt = 0
    bufname = VIM::Buffer.current.name
    classdef = ""
    cur_line = VIM::Buffer.current.line_number
    while (nums != nil && !(nums.min == 0 && nums.max == 0) )
      dprint "visited: %s" % visited.to_s
      break if visited.index( nums )
      visited << nums

      nums.each do |x|
        if x != cur_line
          next if x == 0
          ln = buf[x]
          if /^\s*(module|class|def|include)\s+/.match(ln)
            clscnt += 1 if $1 == "class"
            #dprint "\$1$1
            classdef += "%s\n" % ln
            classdef += "end\n" if /def\s+/.match(ln)
            dprint ln
          end
        end
      end

      nm = "%s(::.*)*\", %s, \"" % [ name, nums.last ]
      nums = eval( VIM::evaluate( vimfun % nm ) )
      dprint "nm: \"%s\"" % nm
      dprint "vimfun: %s" % (vimfun % nm)
      dprint "got nums: %s" % nums.to_s
    end
    if classdef.length > 1
        classdef += "end\n"*clscnt
        # classdef = "class %s\n%s\nend\n" % [ bufname.gsub( /\/|\\/, "_" ), classdef ]
    end

    dprint "get_buffer_entity END"
    dprint "classdef====start"
    lns = classdef.split( "\n" )
    lns.each { |x| dprint x }
    dprint "classdef====end"
    return classdef
  end

  def get_var_type( receiver )
    if /(\"|\')+/.match( receiver )
      "String"
    else
      VIM::evaluate("s:GetRubyVarType('%s')" % receiver)
    end
  end

  def dprint( txt )
    print txt if @@debug
  end

  def escape_vim_singlequote_string(str)
    str.to_s.gsub(/'/,"\\'")
  end

  def get_buffer_entity_list( type )
    # this will be a little expensive.
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    allow_aggressive_load = VIM::evaluate("exists('g:rubycomplete_classes_in_global') && g:rubycomplete_classes_in_global")
    return [] if allow_aggressive_load.to_i.zero? || loading_allowed.to_i.zero?

    buf = VIM::Buffer.current
    eob = buf.length
    ret = []
    rg = 1..eob
    re = eval( "/^\s*%s\s*([A-Za-z0-9_:-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*/" % type )

    rg.each do |x|
      if re.match( buf[x] )
        next if type == "def" && eval( VIM::evaluate("s:IsPosInClassDef(%s)" % x) ) != nil
        ret.push $1
      end
    end

    return ret
  end

  def get_buffer_modules
    return get_buffer_entity_list( "modules" )
  end

  def get_buffer_methods
    return get_buffer_entity_list( "def" )
  end

  def get_buffer_classes
    return get_buffer_entity_list( "class" )
  end


  def load_rails
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    return if allow_rails.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    file_name = VIM::evaluate('expand("%:t")')
    vim_dir = VIM::evaluate('getcwd()')
    file_dir = buf_path.gsub( file_name, '' )
    file_dir.gsub!( /\\/, "/" )
    vim_dir.gsub!( /\\/, "/" )
    vim_dir << "/"
    dirs = [ vim_dir, file_dir ]
    sdirs = [ "", "./", "../", "../../", "../../../", "../../../../" ]
    rails_base = nil

    dirs.each do |dir|
      sdirs.each do |sub|
        trail = "%s%s" % [ dir, sub ]
        tcfg = "%sconfig" % trail

        if File.exists?( tcfg )
          rails_base = trail
          break
        end
      end
      break if rails_base
    end

    return if rails_base == nil
    $:.push rails_base unless $:.index( rails_base )

    rails_config = rails_base + "config/"
    rails_lib = rails_base + "lib/"
    $:.push rails_config unless $:.index( rails_config )
    $:.push rails_lib unless $:.index( rails_lib )

    bootfile = rails_config + "boot.rb"
    envfile = rails_config + "environment.rb"
    if File.exists?( bootfile ) && File.exists?( envfile )
      begin
        require bootfile
        require envfile
        begin
          require 'console_app'
          require 'console_with_helpers'
        rescue Exception
          dprint "Rails 1.1+ Error %s" % $!
          # assume 1.0
        end
        #eval( "Rails::Initializer.run" ) #not necessary?
        VIM::command('let s:rubycomplete_rails_loaded = 1')
        dprint "rails loaded"
      rescue Exception
        dprint "Rails Error %s" % $!
        VIM::evaluate( "s:ErrMsg('Error loading rails environment')" )
      end
    end
  end

  def get_rails_helpers
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    buf_path.gsub!( /\\/, "/" )
    path_elm = buf_path.split( "/" )
    dprint "buf_path: %s" % buf_path
    types = [ "app", "db", "lib", "test", "components", "script" ]

    i = nil
    ret = []
    type = nil
    types.each do |t|
      i = path_elm.index( t )
      break if i
    end
    type = path_elm[i]
    type.downcase!

    dprint "type: %s" % type
    case type
      when "app"
        i += 1
        subtype = path_elm[i]
        subtype.downcase!

        dprint "subtype: %s" % subtype
        case subtype
          when "views"
            ret += ActionView::Base.instance_methods
            ret += ActionView::Base.methods
          when "controllers"
            ret += ActionController::Base.instance_methods
            ret += ActionController::Base.methods
          when "models"
            ret += ActiveRecord::Base.instance_methods
            ret += ActiveRecord::Base.methods
        end

      when "db"
        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.instance_methods
        ret += ActiveRecord::ConnectionAdapters::SchemaStatements.methods
    end


    return ret
  end

  def add_rails_columns( cls )
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    begin
        eval( "#{cls}.establish_connection" )
        return [] unless eval( "#{cls}.ancestors.include?(ActiveRecord::Base).to_s" )
        col = eval( "#{cls}.column_names" )
        return col if col
    rescue
        dprint "add_rails_columns err: (cls: %s) %s" % [ cls, $! ]
        return []
    end
    return []
  end

  def clean_sel(sel, msg)
    ret = sel.reject{|x|x.nil?}.uniq
    ret = ret.grep(/^#{Regexp.quote(msg)}/) if msg != nil
    ret
  end

  def get_rails_view_methods
    allow_rails = VIM::evaluate("exists('g:rubycomplete_rails') && g:rubycomplete_rails")
    rails_loaded = VIM::evaluate('s:rubycomplete_rails_loaded')
    return [] if allow_rails.to_i.zero? || rails_loaded.to_i.zero?

    buf_path = VIM::evaluate('expand("%:p")')
    buf_path.gsub!( /\\/, "/" )
    pelm = buf_path.split( "/" )
    idx = pelm.index( "views" )

    return [] unless idx
    idx += 1

    clspl = pelm[idx].camelize.pluralize
    cls = clspl.singularize

    ret = []
    begin
      ret += eval( "#{cls}.instance_methods" )
      ret += eval( "#{clspl}Helper.instance_methods" )
    rescue Exception
      dprint "Error: Unable to load rails view helpers for %s: %s" % [ cls, $! ]
    end

    return ret
  end
# }}} buffer analysis magic

# {{{ main completion code
  def self.preload_rails
    a = VimRubyCompletion.new
    require 'Thread'
    Thread.new(a) do |b|
      begin
      b.load_rails
      rescue
      end
    end
    a.load_rails
  rescue
  end

  def self.get_completions(base)
    b = VimRubyCompletion.new
    b.get_completions base
  end

  def get_completions(base)
    loading_allowed = VIM::evaluate("exists('g:rubycomplete_buffer_loading') && g:rubycomplete_buffer_loading")
    if loading_allowed.to_i == 1
      load_requires
      load_rails
    end

    input = VIM::Buffer.current.line
    cpos = VIM::Window.current.cursor[1] - 1
    input = input[0..cpos]
    input += base
    input.sub!(/.*[ \t\n\"\\'`><=;|&{(]/, '') # Readline.basic_word_break_characters
    input.sub!(/self\./, '')
    input.sub!(/.*((\.\.[\[(]?)|([\[(]))/, '')

    dprint 'input %s' % input
    message = nil
    receiver = nil
    methods = []
    variables = []
    classes = []
    constants = []

    case input
      when /^(\/[^\/]*\/)\.([^.]*)$/ # Regexp
        receiver = $1
        message = Regexp.quote($2)
        methods = Regexp.instance_methods(true)

      when /^([^\]]*\])\.([^.]*)$/ # Array
        receiver = $1
        message = Regexp.quote($2)
        methods = Array.instance_methods(true)

      when /^([^\}]*\})\.([^.]*)$/ # Proc or Hash
        receiver = $1
        message = Regexp.quote($2)
        methods = Proc.instance_methods(true) | Hash.instance_methods(true)

      when /^(:[^:.]*)$/ # Symbol
        dprint "symbol"
        if Symbol.respond_to?(:all_symbols)
          receiver = $1
          message = $1.sub( /:/, '' )
          methods = Symbol.all_symbols.collect{|s| s.id2name}
          methods.delete_if { |c| c.match( /'/ ) }
        end

      when /^::([A-Z][^:\.\(]*)$/ # Absolute Constant or class methods
        dprint "const or cls"
        receiver = $1
        methods = Object.constants
        methods.grep(/^#{receiver}/).collect{|e| "::" + e}

      when /^(((::)?[A-Z][^:.\(]*)+?)::?([^:.]*)$/ # Constant or class methods
        receiver = $1
        message = Regexp.quote($4)
        dprint "const or cls 2 [recv: \'%s\', msg: \'%s\']" % [ receiver, message ]
        load_buffer_class( receiver )
        begin
          classes = eval("#{receiver}.constants")
          #methods = eval("#{receiver}.methods")
        rescue Exception
          dprint "exception: %s" % $!
          methods = []
        end
        methods.grep(/^#{message}/).collect{|e| receiver + "::" + e}

      when /^(:[^:.]+)\.([^.]*)$/ # Symbol
        dprint "symbol"
        receiver = $1
        message = Regexp.quote($2)
        methods = Symbol.instance_methods(true)

      when /^([0-9_]+(\.[0-9_]+)?(e[0-9]+)?)\.([^.]*)$/ # Numeric
        dprint "numeric"
        receiver = $1
        message = Regexp.quote($4)
        begin
          methods = eval(receiver).methods
        rescue Exception
          methods = []
        end

      when /^(\$[^.]*)$/ #global
        dprint "global"
        methods = global_variables.grep(Regexp.new(Regexp.quote($1)))

      when /^((\.?[^.]+)+?)\.([^.]*)$/ # variable
        dprint "variable"
        receiver = $1
        message = Regexp.quote($3)
        load_buffer_class( receiver )

        cv = eval("self.class.constants")
        vartype = get_var_type( receiver )
        dprint "vartype: %s" % vartype
        if vartype != ''
          load_buffer_class( vartype )

          begin
            methods = eval("#{vartype}.instance_methods")
            variables = eval("#{vartype}.instance_variables")
          rescue Exception
            dprint "load_buffer_class err: %s" % $!
          end
        elsif (cv).include?(receiver)
          # foo.func and foo is local var.
          methods = eval("#{receiver}.methods")
          vartype = receiver
        elsif /^[A-Z]/ =~ receiver and /\./ !~ receiver
          vartype = receiver
          # Foo::Bar.func
          begin
            methods = eval("#{receiver}.methods")
          rescue Exception
          end
        else
          # func1.func2
          ObjectSpace.each_object(Module){|m|
            next if m.name != "IRB::Context" and
              /^(IRB|SLex|RubyLex|RubyToken)/ =~ m.name
            methods.concat m.instance_methods(false)
          }
        end
        variables += add_rails_columns( "#{vartype}" ) if vartype && vartype.length > 0

      when /^\(?\s*[A-Za-z0-9:^@.%\/+*\(\)]+\.\.\.?[A-Za-z0-9:^@.%\/+*\(\)]+\s*\)?\.([^.]*)/
        message = $1
        methods = Range.instance_methods(true)

      when /^\.([^.]*)$/ # unknown(maybe String)
        message = Regexp.quote($1)
        methods = String.instance_methods(true)

    else
      dprint "default/other"
      inclass = eval( VIM::evaluate("s:IsInClassDef()") )

      if inclass != nil
        dprint "inclass"
        classdef = "%s\n" % VIM::Buffer.current[ inclass.min ]
        found = /^\s*class\s*([A-Za-z0-9_-]*)(\s*<\s*([A-Za-z0-9_:-]*))?\s*\n$/.match( classdef )

        if found != nil
          receiver = $1
          message = input
          load_buffer_class( receiver )
          begin
            methods = eval( "#{receiver}.instance_methods" )
            variables += add_rails_columns( "#{receiver}" )
          rescue Exception
            found = nil
          end
        end
      end

      if inclass == nil || found == nil
        dprint "inclass == nil"
        methods = get_buffer_methods
        methods += get_rails_view_methods

        cls_const = Class.constants
        constants = cls_const.select { |c| /^[A-Z_-]+$/.match( c ) }
        classes = eval("self.class.constants") - constants
        classes += get_buffer_classes
        classes += get_buffer_modules

        include_objectspace = VIM::evaluate("exists('g:rubycomplete_include_objectspace') && g:rubycomplete_include_objectspace")
        ObjectSpace.each_object(Class) { |cls| classes << cls.to_s } if include_objectspace == "1"
        message = receiver = input
      end

      methods += get_rails_helpers
      methods += Kernel.public_methods
    end


    include_object = VIM::evaluate("exists('g:rubycomplete_include_object') && g:rubycomplete_include_object")
    methods = clean_sel( methods, message )
    methods = (methods-Object.instance_methods) if include_object == "0"
    rbcmeth = (VimRubyCompletion.instance_methods-Object.instance_methods) # lets remove those rubycomplete methods
    methods = (methods-rbcmeth)

    variables = clean_sel( variables, message )
    classes = clean_sel( classes, message ) - ["VimRubyCompletion"]
    constants = clean_sel( constants, message )

    valid = []
    valid += methods.collect { |m| { :name => m.to_s, :type => 'm' } }
    valid += variables.collect { |v| { :name => v.to_s, :type => 'v' } }
    valid += classes.collect { |c| { :name => c.to_s, :type => 't' } }
    valid += constants.collect { |d| { :name => d.to_s, :type => 'd' } }
    valid.sort! { |x,y| x[:name] <=> y[:name] }

    outp = ""

    rg = 0..valid.length
    rg.step(150) do |x|
      stpos = 0+x
      enpos = 150+x
      valid[stpos..enpos].each { |c| outp += "{'word':'%s','item':'%s','kind':'%s'}," % [ c[:name], c[:name], c[:type] ].map{|x|escape_vim_singlequote_string(x)} }
      outp.sub!(/,$/, '')

      VIM::command("call extend(g:rubycomplete_completions, [%s])" % outp)
      outp = ""
    end
  end
# }}} main completion code

end # VimRubyCompletion
# }}} ruby completion
RUBYEOF
endfunction

let s:rubycomplete_rails_loaded = 0

call s:DefRuby()
"}}} ruby-side code


" vim:tw=78:sw=4:ts=8:et:fdm=marker:ft=vim:norl:
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/autoload/spellfile.vim                                                          0100644 0000000 0000000 00000014111 13050207306 017217  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim script to download a missing spell file
" Maintainer:	Bram Moolenaar <Bram@vim.org>
" Last Change:	2012 Jan 08

if !exists('g:spellfile_URL')
  " Prefer using http:// when netrw should be able to use it, since
  " more firewalls let this through.
  if executable("curl") || executable("wget") || executable("fetch")
    let g:spellfile_URL = 'http://ftp.vim.org/pub/vim/runtime/spell'
  else
    let g:spellfile_URL = 'ftp://ftp.vim.org/pub/vim/runtime/spell'
  endif
endif
let s:spellfile_URL = ''    " Start with nothing so that s:donedict is reset.

" This function is used for the spellfile plugin.
function! spellfile#LoadFile(lang)
  " If the netrw plugin isn't loaded we silently skip everything.
  if !exists(":Nread")
    if &verbose
      echomsg 'spellfile#LoadFile(): Nread command is not available.'
    endif
    return
  endif

  " If the URL changes we try all files again.
  if s:spellfile_URL != g:spellfile_URL
    let s:donedict = {}
    let s:spellfile_URL = g:spellfile_URL
  endif

  " I will say this only once!
  if has_key(s:donedict, a:lang . &enc)
    if &verbose
      echomsg 'spellfile#LoadFile(): Tried this language/encoding before.'
    endif
    return
  endif
  let s:donedict[a:lang . &enc] = 1

  " Find spell directories we can write in.
  let [dirlist, dirchoices] = spellfile#GetDirChoices()
  if len(dirlist) == 0
    let dir_to_create = spellfile#WritableSpellDir()
    if &verbose || dir_to_create != ''
      echomsg 'spellfile#LoadFile(): There is no writable spell directory.'
    endif
    if dir_to_create != ''
      if confirm("Shall I create " . dir_to_create, "&Yes\n&No", 2) == 1
	" After creating the directory it should show up in the list.
	call mkdir(dir_to_create, "p")
	let [dirlist, dirchoices] = spellfile#GetDirChoices()
      endif
    endif
    if len(dirlist) == 0
      return
    endif
  endif

  let msg = 'Cannot find spell file for "' . a:lang . '" in ' . &enc
  let msg .= "\nDo you want me to try downloading it?"
  if confirm(msg, "&Yes\n&No", 2) == 1
    let enc = &encoding
    if enc == 'iso-8859-15'
      let enc = 'latin1'
    endif
    let fname = a:lang . '.' . enc . '.spl'

    " Split the window, read the file into a new buffer.
    " Remember the buffer number, we check it below.
    new
    let newbufnr = winbufnr(0)
    setlocal bin fenc=
    echo 'Downloading ' . fname . '...'
    call spellfile#Nread(fname)
    if getline(2) !~ 'VIMspell'
      " Didn't work, perhaps there is an ASCII one.
      " Careful: Nread() may have opened a new window for the error message,
      " we need to go back to our own buffer and window.
      if newbufnr != winbufnr(0)
	let winnr = bufwinnr(newbufnr)
	if winnr == -1
	  " Our buffer has vanished!?  Open a new window.
	  echomsg "download buffer disappeared, opening a new one"
	  new
	  setlocal bin fenc=
	else
	  exe winnr . "wincmd w"
	endif
      endif
      if newbufnr == winbufnr(0)
	" We are back the old buffer, remove any (half-finished) download.
        g/^/d
      else
	let newbufnr = winbufnr(0)
      endif

      let fname = a:lang . '.ascii.spl'
      echo 'Could not find it, trying ' . fname . '...'
      call spellfile#Nread(fname)
      if getline(2) !~ 'VIMspell'
	echo 'Sorry, downloading failed'
	exe newbufnr . "bwipe!"
	return
      endif
    endif

    " Delete the empty first line and mark the file unmodified.
    1d
    set nomod

    let msg = "In which directory do you want to write the file:"
    for i in range(len(dirlist))
      let msg .= "\n" . (i + 1) . '. ' . dirlist[i]
    endfor
    let dirchoice = confirm(msg, dirchoices) - 2
    if dirchoice >= 0
      if exists('*fnameescape')
	let dirname = fnameescape(dirlist[dirchoice])
      else
	let dirname = escape(dirlist[dirchoice], ' ')
      endif
      setlocal fenc=
      exe "write " . dirname . '/' . fname

      " Also download the .sug file, if the user wants to.
      let msg = "Do you want me to try getting the .sug file?\n"
      let msg .= "This will improve making suggestions for spelling mistakes,\n"
      let msg .= "but it uses quite a bit of memory."
      if confirm(msg, "&No\n&Yes") == 2
	g/^/d
	let fname = substitute(fname, '\.spl$', '.sug', '')
	echo 'Downloading ' . fname . '...'
	call spellfile#Nread(fname)
	if getline(2) =~ 'VIMsug'
	  1d
	  exe "write " . dirname . '/' . fname
	  set nomod
	else
	  echo 'Sorry, downloading failed'
	  " Go back to our own buffer/window, Nread() may have taken us to
	  " another window.
	  if newbufnr != winbufnr(0)
	    let winnr = bufwinnr(newbufnr)
	    if winnr != -1
	      exe winnr . "wincmd w"
	    endif
	  endif
	  if newbufnr == winbufnr(0)
	    set nomod
	  endif
	endif
      endif
    endif

    " Wipe out the buffer we used.
    exe newbufnr . "bwipe"
  endif
endfunc

" Read "fname" from the server.
function! spellfile#Nread(fname)
  " We do our own error handling, don't want a window for it.
  if exists("g:netrw_use_errorwindow")
    let save_ew = g:netrw_use_errorwindow
  endif
  let g:netrw_use_errorwindow=0

  if g:spellfile_URL =~ '^ftp://'
    " for an ftp server use a default login and password to avoid a prompt
    let machine = substitute(g:spellfile_URL, 'ftp://\([^/]*\).*', '\1', '')
    let dir = substitute(g:spellfile_URL, 'ftp://[^/]*/\(.*\)', '\1', '')
    exe 'Nread "' . machine . ' anonymous vim7user ' . dir . '/' . a:fname . '"'
  else
    exe 'Nread ' g:spellfile_URL . '/' . a:fname
  endif

  if exists("save_ew")
    let g:netrw_use_errorwindow = save_ew
  else
    unlet g:netrw_use_errorwindow
  endif
endfunc

" Get a list of writable spell directories and choices for confirm().
function! spellfile#GetDirChoices()
  let dirlist = []
  let dirchoices = '&Cancel'
  for dir in split(globpath(&rtp, 'spell'), "\n")
    if filewritable(dir) == 2
      call add(dirlist, dir)
      let dirchoices .= "\n&" . len(dirlist)
    endif
  endfor
  return [dirlist, dirchoices]
endfunc

function! spellfile#WritableSpellDir()
  if has("unix")
    " For Unix always use the $HOME/.vim directory
    return $HOME . "/.vim/spell"
  endif
  for dir in split(&rtp, ',')
    if filewritable(dir) == 2
      return dir . "/spell"
    endif
  endfor
  return ''
endfunction
                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/autoload/sqlcomplete.vim                                                        0100644 0000000 0000000 00000112624 13050207306 017600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim OMNI completion script for SQL
" Language:    SQL
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Version:     15.0
" Last Change: 2013 May 13
" Homepage:    http://www.vim.org/scripts/script.php?script_id=1572
" Usage:       For detailed help
"              ":help sql.txt"
"              or ":help ft-sql-omni"
"              or read $VIMRUNTIME/doc/sql.txt

" History
"
" TODO
"     - Jonas Enberg - if no table is found when using column completion
"       look backwards to a FROM clause and find the first table
"       and complete it.
"
" Version 15.0 (May 2013)
"     - NF: Changed the SQL precached syntax items, omni_sql_precache_syntax_groups,
"           to use regular expressions to pick up extended syntax group names.
"           This requires an updated SyntaxComplete plugin version 13.0.
"           If the required versions have not been installed, previous
"           behaviour will not be impacted.
"
" Version 14.0 (Dec 2012)
"     - BF: Added check for cpo
"
" Version 13.0 (Dec 2012)
"     - NF: When completing column lists or drilling into a table
"           and g:omni_sql_include_owner is enabled, the
"           only the table name would be replaced with the column
"           list instead of the table name and owner (if specified).
"     - NF: When completing column lists using table aliases
"           and g:omni_sql_include_owner is enabled, account
"           for the owner name when looking up the table
"           list instead of the table name and owner (if specified).
"     - BF: When completing column lists or drilling into a table
"           and g:omni_sql_include_owner is enabled, the
"           column list could often not be found for the table.
"     - BF: When OMNI popped up, possibly the wrong word
"           would be replaced for column and column list options.
"
" Version 12.0 (Feb 2012)
"     - Partial column name completion did not work when a table
"       name or table alias was provided (Jonas Enberg).
"     - Improved the handling of column completion.  First we match any
"       columns from a previous completion.  If not matches are found, we
"       consider the partial name to be a table or table alias for the
"       query and attempt to match on it.
"
" Version 11.0 (Jan 2012)
"     Added g:omni_sql_default_compl_type variable
"         - You can specify which type of completion to default to
"           when pressing <C-X><C-O>.  The entire list of available
"           choices can be found in the calls to sqlcomplete#Map in:
"               ftplugin/sql.vim
"
" Version 10.0
"     Updated PreCacheSyntax()
"         - Now returns a List of the syntax items it finds.
"           This allows other plugins / scripts to use this list for their own
"           purposes.  In this case XPTemplate can use them for a Choose list.
"         - Verifies the parameters are the correct type and displays a
"           warning if not.
"         - Verifies the parameters are the correct type and displays a
"           warning if not.
"     Updated SQLCWarningMsg()
"         - Prepends warning message with SQLComplete so you know who issued
"           the warning.
"     Updated SQLCErrorMsg()
"         - Prepends error message with SQLComplete so you know who issued
"           the error.
"
" Version 9.0 (May 2010)
"     This change removes some of the support for tables with spaces in their
"     names in order to simplify the regexes used to pull out query table
"     aliases for more robust table name and column name code completion.
"     Full support for "table names with spaces" can be added in again
"     after 7.3.
"
" Version 8.0
"     Incorrectly re-executed the g:ftplugin_sql_omni_key_right and g:ftplugin_sql_omni_key_left
"     when drilling in and out of a column list for a table.
"
" Version 7.0 (Jan 2010)
"     Better handling of object names
"
" Version 6.0 (Apr 2008)
"     Supports object names with spaces "my table name"
"
" Set completion with CTRL-X CTRL-O to autoloaded function.
" This check is in place in case this script is
" sourced directly instead of using the autoload feature.
if exists('&omnifunc')
    " Do not set the option if already set since this
    " results in an E117 warning.
    if &omnifunc == ""
        setlocal omnifunc=sqlcomplete#Complete
    endif
endif

if exists('g:loaded_sql_completion')
    finish
endif
let g:loaded_sql_completion = 150
let s:keepcpo= &cpo
set cpo&vim

" Maintains filename of dictionary
let s:sql_file_table        = ""
let s:sql_file_procedure    = ""
let s:sql_file_view         = ""

" Define various arrays to be used for caching
let s:tbl_name              = []
let s:tbl_alias             = []
let s:tbl_cols              = []
let s:syn_list              = []
let s:syn_value             = []

" Used in conjunction with the syntaxcomplete plugin
let s:save_inc              = ""
let s:save_exc              = ""
if !exists('g:omni_syntax_group_include_sql')
    let g:omni_syntax_group_include_sql = ''
endif
if !exists('g:omni_syntax_group_exclude_sql')
    let g:omni_syntax_group_exclude_sql = ''
endif
let s:save_inc = g:omni_syntax_group_include_sql
let s:save_exc = g:omni_syntax_group_exclude_sql

" Used with the column list
let s:save_prev_table       = ""

" Default the option to verify table alias
if !exists('g:omni_sql_use_tbl_alias')
    let g:omni_sql_use_tbl_alias = 'a'
endif
" Default syntax items to precache
if !exists('g:omni_sql_precache_syntax_groups')
    let g:omni_sql_precache_syntax_groups = [
                \ 'syntax\w*',
                \ 'sqlKeyword\w*',
                \ 'sqlFunction\w*',
                \ 'sqlOption\w*',
                \ 'sqlType\w*',
                \ 'sqlStatement\w*'
                \ ]
endif
" Set ignorecase to the ftplugin standard
if !exists('g:omni_sql_ignorecase')
    let g:omni_sql_ignorecase = &ignorecase
endif
" During table completion, should the table list also
" include the owner name
if !exists('g:omni_sql_include_owner')
    let g:omni_sql_include_owner = 0
    if exists('g:loaded_dbext')
        if g:loaded_dbext >= 300
            " New to dbext 3.00, by default the table lists include the owner
            " name of the table.  This is used when determining how much of
            " whatever has been typed should be replaced as part of the
            " code replacement.
            let g:omni_sql_include_owner = 1
        endif
    endif
endif
" Default type of completion used when <C-X><C-O> is pressed
if !exists('g:omni_sql_default_compl_type')
    let g:omni_sql_default_compl_type = 'table'
endif

" This function is used for the 'omnifunc' option.
" It is called twice by omni and it is responsible
" for returning the completion list of items.
" But it must also determine context of what to complete
" and what to "replace" with the completion.
" The a:base, is replaced directly with what the user
" chooses from the choices.
" The s:prepend provides context for the completion.
function! sqlcomplete#Complete(findstart, base)

    " Default to table name completion
    let compl_type = 'table'
    " Allow maps to specify what type of object completion they want
    if exists('b:sql_compl_type')
        let compl_type = b:sql_compl_type
    endif
    let begindot = 0

    " First pass through this function determines how much of the line should
    " be replaced by whatever is chosen from the completion list
    if a:findstart
        " Locate the start of the item, including "."
        let line     = getline('.')
        let start    = col('.') - 1
        let lastword = -1
        " Check if the first character is a ".", for column completion
        if line[start - 1] == '.'
            let begindot = 1
        endif
        while start > 0
            " Additional code was required to handle objects which
            " can contain spaces like "my table name".
            if line[start - 1] !~ '\(\w\|\.\)'
                " If the previous character is not a period or word character
                break
            " elseif line[start - 1] =~ '\(\w\|\s\+\)'
            "     let start -= 1
            elseif line[start - 1] =~ '\w'
                " If the previous character is word character continue back
                let start -= 1
            elseif line[start - 1] =~ '\.' &&
                        \ compl_type =~ 'column\|table\|view\|procedure'
                " If the previous character is a period and we are completing
                " an object which can be specified with a period like this:
                "     table_name.column_name
                "     owner_name.table_name

                " If lastword has already been set for column completion
                " break from the loop, since we do not also want to pickup
                " a table name if it was also supplied.
                " Unless g:omni_sql_include_owner == 1, then we can
                " include the ownername.
                if lastword != -1 && compl_type == 'column'
                            \ && g:omni_sql_include_owner == 0
                    break
                endif
                " If column completion was specified stop at the "." if
                " a . was specified, otherwise, replace all the way up
                " to the owner name (if included).
                if lastword == -1 && compl_type == 'column' && begindot == 1
                    let lastword = start
                endif
                " If omni_sql_include_owner = 0, do not include the table
                " name as part of the substitution, so break here
                if lastword == -1 &&
                            \ compl_type =~ '\<\(table\|view\|procedure\|column\|column_csv\)\>' &&
                            \ g:omni_sql_include_owner == 0
                    let lastword = start
                    break
                endif
                let start -= 1
            else
                break
            endif
        endwhile

        " Return the column of the last word, which is going to be changed.
        " Remember the text that comes before it in s:prepended.
        if lastword == -1
            let s:prepended = ''
            return start
        endif
        let s:prepended = strpart(line, start, lastword - start)
        return lastword
    endif

    " Second pass through this function will determine what data to put inside
    " of the completion list
    " s:prepended is set by the first pass
    let base = s:prepended . a:base

    " Default the completion list to an empty list
    let compl_list = []

    " Default to table name completion
    let compl_type = g:omni_sql_default_compl_type
    " Allow maps to specify what type of object completion they want
    if exists('b:sql_compl_type')
        let compl_type = b:sql_compl_type
        unlet b:sql_compl_type
    endif

    if compl_type == 'tableReset'
        let compl_type = 'table'
        let base = ''
    endif

    if compl_type == 'table' ||
                \ compl_type == 'procedure' ||
                \ compl_type == 'view'

        " This type of completion relies upon the dbext.vim plugin
        if s:SQLCCheck4dbext() == -1
            return []
        endif

        " Allow the user to override the dbext plugin to specify whether
        " the owner/creator should be included in the list
        if g:loaded_dbext >= 300
            let saveSetting = DB_listOption('dict_show_owner')
            exec 'DBSetOption dict_show_owner='.(g:omni_sql_include_owner==1?'1':'0')
        endif

        let compl_type_uc = substitute(compl_type, '\w\+', '\u&', '')
        " Same call below, no need to do it twice
        " if s:sql_file_{compl_type} == ""
        "     let s:sql_file_{compl_type} = DB_getDictionaryName(compl_type_uc)
        " endif
        let s:sql_file_{compl_type} = DB_getDictionaryName(compl_type_uc)
        if s:sql_file_{compl_type} != ""
            if filereadable(s:sql_file_{compl_type})
                let compl_list = readfile(s:sql_file_{compl_type})
            endif
        endif

        if g:loaded_dbext > 300
            exec 'DBSetOption dict_show_owner='.saveSetting
        endif
    elseif compl_type =~? 'column'

        " This type of completion relies upon the dbext.vim plugin
        if s:SQLCCheck4dbext() == -1
            return []
        endif

        if base == ""
            " The last time we displayed a column list we stored
            " the table name.  If the user selects a column list
            " without a table name of alias present, assume they want
            " the previous column list displayed.
            let base = s:save_prev_table
        endif

        let owner  = ''
        let column = ''

        if base =~ '\.'
            " Check if the owner/creator has been specified
            let owner  = matchstr( base, '^\zs.*\ze\..*\..*' )
            let table  = matchstr( base, '^\(.*\.\)\?\zs.*\ze\..*' )
            let column = matchstr( base, '.*\.\zs.*' )

            if g:omni_sql_include_owner == 1 && owner == '' && table != '' && column != ''
                let owner  = table
                let table  = column
                let column = ''
            endif

            " It is pretty well impossible to determine if the user
            " has entered:
            "    owner.table
            "    table.column_prefix
            " So there are a couple of things we can do to mitigate
            " this issue.
            "    1.  Check if the dbext plugin has the option turned
            "        on to even allow owners
            "    2.  Based on 1, if the user is showing a table list
            "        and the DrillIntoTable (using <Right>) then
            "        this will be owner.table.  In this case, we can
            "        check to see the table.column exists in the
            "        cached table list.  If it does, then we have
            "        determined the user has actually chosen
            "        owner.table, not table.column_prefix.
            let found = -1
            if g:omni_sql_include_owner == 1 && owner == ''
                if filereadable(s:sql_file_table)
                    let tbl_list = readfile(s:sql_file_table)
                    let found    = index( tbl_list, ((table != '')?(table.'.'):'').column)
                endif
            endif
            " If the table.column was found in the table list, we can safely assume
            " the owner was not provided and shift the items appropriately.
            " OR
            " If the user has indicated not to use table owners at all and
            " the base ends in a '.' we know they are not providing a column
            " name, so we can shift the items appropriately.
            " if found != -1 || (g:omni_sql_include_owner == 0 && base !~ '\.$')
            "     let owner  = table
            "     let table  = column
            "     let column = ''
            " endif
        else
            " If no "." was provided and the user asked for
            " column level completion, first attempt the match
            " on any previous column lists.  If the user asked
            " for a list of columns comma separated, continue as usual.
            if compl_type == 'column' && s:save_prev_table != ''
                " The last time we displayed a column list we stored
                " the table name.  If the user selects a column list
                " without a table name of alias present, assume they want
                " the previous column list displayed.
                let table     = s:save_prev_table
                let list_type = ''

                let compl_list  = s:SQLCGetColumns(table, list_type)
                if ! empty(compl_list)
                    " If no column prefix has been provided and the table
                    " name was provided, append it to each of the items
                    " returned.
                    let compl_list = filter(deepcopy(compl_list), 'v:val=~"^'.base.'"' )

                    " If not empty, we have a match on columns
                    " return the list
                    if ! empty(compl_list)
                        return compl_list
                    endif
                endif
            endif
            " Since no columns were found to match the base supplied
            " assume the user is trying to complete the column list
            " for a table (and or an alias to a table).
            let table  = base
        endif

        " Get anything after the . and consider this the table name
        " If an owner has been specified, then we must consider the
        " base to be a partial column name
        " let base  = matchstr( base, '^\(.*\.\)\?\zs.*' )

        if table != ""
            let s:save_prev_table = base
            let list_type         = ''

            if compl_type == 'column_csv'
                " Return one array element, with a comma separated
                " list of values instead of multiple array entries
                " for each column in the table.
                let list_type     = 'csv'
            endif

            " If we are including the OWNER for the objects, then for
            " table completion, if we have it, it should be included
            " as there can be the same table names in a database yet
            " with different owner names.
            if g:omni_sql_include_owner == 1 && owner != '' && table != ''
                let compl_list  = s:SQLCGetColumns(owner.'.'.table, list_type)
            else
                let compl_list  = s:SQLCGetColumns(table, list_type)
            endif

            if column != ''
                " If no column prefix has been provided and the table
                " name was provided, append it to each of the items
                " returned.
                let compl_list = map(compl_list, 'table.".".v:val')
                if owner != ''
                    " If an owner has been provided append it to each of the
                    " items returned.
                    let compl_list = map(compl_list, 'owner.".".v:val')
                endif
            else
                let base = ''
            endif

            if compl_type == 'column_csv'
                " Join the column array into 1 single element array
                " but make the columns column separated
                let compl_list        = [join(compl_list, ', ')]
            endif
        endif
    elseif compl_type == 'resetCache'
        " Reset all cached items
        let s:tbl_name           = []
        let s:tbl_alias          = []
        let s:tbl_cols           = []
        let s:syn_list           = []
        let s:syn_value          = []
        let s:sql_file_table     = ""
        let s:sql_file_procedure = ""
        let s:sql_file_view      = ""

        let msg = "All SQL cached items have been removed."
        call s:SQLCWarningMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
    else
        let compl_list = s:SQLCGetSyntaxList(compl_type)
    endif

    if base != ''
        " Filter the list based on the first few characters the user entered.
        " Check if the text matches at the beginning
        "         \\(^.base.'\\)
        " or
        " Match to a owner.table or alias.column type match
        "         ^\\(\\w\\+\\.\\)\\?'.base.'\\)
        " or
        " Handle names with spaces "my table name"
        "         "\\(^'.base.'\\|^\\(\\w\\+\\.\\)\\?'.base.'\\)"'
        "
        let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|^\\(\\w\\+\\.\\)\\?'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|\\(\\.\\)\\?'.base.'\\)"'
        " let expr = 'v:val '.(g:omni_sql_ignorecase==1?'=~?':'=~#').' "\\(^'.base.'\\|\\([^.]*\\)\\?'.base.'\\)"'
        let compl_list = filter(deepcopy(compl_list), expr)

        if empty(compl_list) && compl_type == 'table' && base =~ '\.$'
            " It is possible we could be looking for column name completion
            " and the user simply hit C-X C-O to lets try it as well
            " since we had no hits with the tables.
            " If the base ends with a . it is hard to know if we are
            " completing table names or column names.
            let list_type = ''

            let compl_list  = s:SQLCGetColumns(base, list_type)
        endif
    endif

    if exists('b:sql_compl_savefunc') && b:sql_compl_savefunc != ""
        let &omnifunc = b:sql_compl_savefunc
    endif

    if empty(compl_list)
        call s:SQLCWarningMsg( 'Could not find type['.compl_type.'] using prepend[.'.s:prepended.'] base['.a:base.']' )
    endif

    return compl_list
endfunc

function! sqlcomplete#PreCacheSyntax(...)
    let syn_group_arr = []
    let syn_items     = []

    if a:0 > 0
        if type(a:1) != 3
            call s:SQLCWarningMsg("Parameter is not a list. Example:['syntaxGroup1', 'syntaxGroup2']")
            return ''
        endif
        let syn_group_arr = a:1
    else
        let syn_group_arr = g:omni_sql_precache_syntax_groups
    endif
    " For each group specified in the list, precache all
    " the sytnax items.
    if !empty(syn_group_arr)
        for group_name in syn_group_arr
            let syn_items = extend( syn_items, s:SQLCGetSyntaxList(group_name) )
        endfor
    endif

    return syn_items
endfunction

function! sqlcomplete#ResetCacheSyntax(...)
    let syn_group_arr = []

    if a:0 > 0
        if type(a:1) != 3
            call s:SQLCWarningMsg("Parameter is not a list. Example:['syntaxGroup1', 'syntaxGroup2']")
            return ''
        endif
        let syn_group_arr = a:1
    else
        let syn_group_arr = g:omni_sql_precache_syntax_groups
    endif
    " For each group specified in the list, precache all
    " the sytnax items.
    if !empty(syn_group_arr)
        for group_name in syn_group_arr
            let list_idx = index(s:syn_list, group_name, 0, &ignorecase)
            if list_idx > -1
                " Remove from list of groups
                call remove( s:syn_list, list_idx )
                " Remove from list of keywords
                call remove( s:syn_value, list_idx )
            endif
        endfor
    endif
endfunction

function! sqlcomplete#Map(type)
    " Tell the SQL plugin what you want to complete
    let b:sql_compl_type=a:type
    " Record previous omnifunc, if the SQL completion
    " is being used in conjunction with other filetype
    " completion plugins
    if &omnifunc != "" && &omnifunc != 'sqlcomplete#Complete'
        " Record the previous omnifunc, the plugin
        " will automatically set this back so that it
        " does not interfere with other ftplugins settings
        let b:sql_compl_savefunc=&omnifunc
    endif
    " Set the OMNI func for the SQL completion plugin
    let &omnifunc='sqlcomplete#Complete'
endfunction

function! sqlcomplete#DrillIntoTable()
    " If the omni popup window is visible
    if pumvisible()
        call sqlcomplete#Map('column')
        " C-Y, makes the currently highlighted entry active
        " and trigger the omni popup to be redisplayed
        call feedkeys("\<C-Y>\<C-X>\<C-O>", 'n')
    else
	" If the popup is not visible, simple perform the normal
	" key behaviour.
	" Must use exec since they key must be preceeded by "\"
	" or feedkeys will simply push each character of the string
	" rather than the "key press".
        exec 'call feedkeys("\'.g:ftplugin_sql_omni_key_right.'", "n")'
    endif
    return ""
endfunction

function! sqlcomplete#DrillOutOfColumns()
    " If the omni popup window is visible
    if pumvisible()
        call sqlcomplete#Map('tableReset')
        " Trigger the omni popup to be redisplayed
        call feedkeys("\<C-X>\<C-O>")
    else
	" If the popup is not visible, simple perform the normal
	" key behaviour.
	" Must use exec since they key must be preceeded by "\"
	" or feedkeys will simply push each character of the string
	" rather than the "key press".
        exec 'call feedkeys("\'.g:ftplugin_sql_omni_key_left.'", "n")'
    endif
    return ""
endfunction

function! s:SQLCWarningMsg(msg)
    echohl WarningMsg
    echomsg 'SQLComplete:'.a:msg
    echohl None
endfunction

function! s:SQLCErrorMsg(msg)
    echohl ErrorMsg
    echomsg 'SQLComplete:'.a:msg
    echohl None
endfunction

function! s:SQLCGetSyntaxList(syn_group)
    let syn_group  = a:syn_group
    let compl_list = []

    " Check if we have already cached the syntax list
    let list_idx = index(s:syn_list, syn_group, 0, &ignorecase)
    if list_idx > -1
        " Return previously cached value
        let compl_list = s:syn_value[list_idx]
    else
        let s:save_inc = g:omni_syntax_group_include_sql
        let s:save_exc = g:omni_syntax_group_exclude_sql
        let g:omni_syntax_group_include_sql = ''
        let g:omni_syntax_group_exclude_sql = ''

        " Request the syntax list items from the
        " syntax completion plugin
        if syn_group == 'syntax'
            " Handle this special case.  This allows the user
            " to indicate they want all the syntax items available,
            " so do not specify a specific include list.
            let syn_value                       = syntaxcomplete#OmniSyntaxList()
        else
            " The user has specified a specific syntax group
            let g:omni_syntax_group_include_sql = syn_group
            let syn_value                       = syntaxcomplete#OmniSyntaxList(syn_group)
        endif
        let g:omni_syntax_group_include_sql = s:save_inc
        let g:omni_syntax_group_exclude_sql = s:save_exc
        " Cache these values for later use
        let s:syn_list  = add( s:syn_list,  syn_group )
        let s:syn_value = add( s:syn_value, syn_value )
        let compl_list  = syn_value
    endif

    return compl_list
endfunction

function! s:SQLCCheck4dbext()
    if !exists('g:loaded_dbext')
        let msg = "The dbext plugin must be loaded for dynamic SQL completion"
        call s:SQLCErrorMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
        return -1
    elseif g:loaded_dbext < 600
        let msg = "The dbext plugin must be at least version 5.30 " .
                    \ " for dynamic SQL completion"
        call s:SQLCErrorMsg(msg)
        " Leave time for the user to read the error message
        :sleep 2
        return -1
    endif
    return 1
endfunction

function! s:SQLCAddAlias(table_name, table_alias, cols)
    " Strip off the owner if included
    let table_name  = matchstr(a:table_name, '\%(.\{-}\.\)\?\zs\(.*\)' )
    let table_alias = a:table_alias
    let cols        = a:cols

    if g:omni_sql_use_tbl_alias != 'n'
        if table_alias == ''
            if 'da' =~? g:omni_sql_use_tbl_alias
                if table_name =~ '_'
                    " Treat _ as separators since people often use these
                    " for word separators
                    let save_keyword = &iskeyword
                    setlocal iskeyword-=_

                    " Get the first letter of each word
                    " [[:alpha:]] is used instead of \w
                    " to catch extended accented characters
                    "
                    let table_alias = substitute(
                                \ table_name,
                                \ '\<[[:alpha:]]\+\>_\?',
                                \ '\=strpart(submatch(0), 0, 1)',
                                \ 'g'
                                \ )
                    " Restore original value
                    let &iskeyword = save_keyword
                elseif table_name =~ '\u\U'
                    let table_alias = substitute(
                                \ table_name, '\(\u\)\U*', '\1', 'g')
                else
                    let table_alias = strpart(table_name, 0, 1)
                endif
            endif
        endif
        if table_alias != ''
            " Following a word character, make sure there is a . and no spaces
            let table_alias = substitute(table_alias, '\w\zs\.\?\s*$', '.', '')
            if 'a' =~? g:omni_sql_use_tbl_alias && a:table_alias == ''
                let table_alias = inputdialog("Enter table alias:", table_alias)
            endif
        endif
        if table_alias != ''
            let cols = substitute(cols, '\<\w', table_alias.'&', 'g')
        endif
    endif

    return cols
endfunction

function! s:SQLCGetObjectOwner(object)
    " The owner regex matches a word at the start of the string which is
    " followed by a dot, but doesn't include the dot in the result.
    " ^           - from beginning of line
    " \("\|\[\)\? - ignore any quotes
    " \zs         - start the match now
    " .\{-}       - get owner name
    " \ze         - end the match
    " \("\|\[\)\? - ignore any quotes
    " \.          - must by followed by a .
    " let owner = matchstr( a:object, '^\s*\zs.*\ze\.' )
    let owner = matchstr( a:object, '^\("\|\[\)\?\zs\.\{-}\ze\("\|\]\)\?\.' )
    return owner
endfunction

function! s:SQLCGetColumns(table_name, list_type)
    if a:table_name =~ '\.'
        " Check if the owner/creator has been specified
        let owner  = matchstr( a:table_name, '^\zs.*\ze\..*\..*' )
        let table  = matchstr( a:table_name, '^\(.*\.\)\?\zs.*\ze\..*' )
        let column = matchstr( a:table_name, '.*\.\zs.*' )

        if g:omni_sql_include_owner == 1 && owner == '' && table != '' && column != ''
            let owner  = table
            let table  = column
            let column = ''
        endif
    else
        let owner  = ''
        let table  = matchstr(a:table_name, '^["\[\]a-zA-Z0-9_ ]\+\ze\.\?')
        let column = ''
    endif

    " Check if the table name was provided as part of the column name
    " let table_name   = matchstr(a:table_name, '^["\[\]a-zA-Z0-9_ ]\+\ze\.\?')
    let table_name   = table
    let table_cols   = []
    let table_alias  = ''
    let move_to_top  = 1

    let table_name   = substitute(table_name, '\s*\(.\{-}\)\s*$', '\1', 'g')

    " If the table name was given as:
    "     where c.
    let table_name   = substitute(table_name, '^\c\(WHERE\|AND\|OR\)\s\+', '', '')
    if g:loaded_dbext >= 300
        let saveSettingAlias = DB_listOption('use_tbl_alias')
        exec 'DBSetOption use_tbl_alias=n'
    endif

    let table_name_stripped = substitute(table_name, '["\[\]]*', '', 'g')

    " Check if we have already cached the column list for this table
    " by its name
    let list_idx = index(s:tbl_name, table_name_stripped, 0, &ignorecase)
    if list_idx > -1
        let table_cols = split(s:tbl_cols[list_idx], '\n')
    else
        " Check if we have already cached the column list for this table
        " by its alias, assuming the table_name provided was actually
        " the alias for the table instead
        "     select *
        "       from area a
        "      where a.
        let list_idx = index(s:tbl_alias, table_name_stripped, 0, &ignorecase)
        if list_idx > -1
            let table_alias = table_name_stripped
            let table_name  = s:tbl_name[list_idx]
            let table_cols  = split(s:tbl_cols[list_idx], '\n')
        endif
    endif

    " If we have not found a cached copy of the table
    " And the table ends in a "." or we are looking for a column list
    " if list_idx == -1 && (a:table_name =~ '\.' || b:sql_compl_type =~ 'column')
    " if list_idx == -1 && (a:table_name =~ '\.' || a:list_type =~ 'csv')
    if list_idx == -1
         let saveY      = @y
         let saveSearch = @/
         let saveWScan  = &wrapscan
         let curline    = line(".")
         let curcol     = col(".")

         " Do not let searchs wrap
         setlocal nowrapscan
         " If . was entered, look at the word just before the .
         " We are looking for something like this:
         "    select *
         "      from customer c
         "     where c.
         " So when . is pressed, we need to find 'c'
         "

         " Search backwards to the beginning of the statement
         " and do NOT wrap
         " exec 'silent! normal! v?\<\(select\|update\|delete\|;\)\>'."\n".'"yy'
         exec 'silent! normal! ?\<\c\(select\|update\|delete\|;\)\>'."\n"

         " Start characterwise visual mode
         " Advance right one character
         " Search foward until one of the following:
         "     1.  Another select/update/delete statement
         "     2.  A ; at the end of a line (the delimiter)
         "     3.  The end of the file (incase no delimiter)
         " Yank the visually selected text into the "y register.
         exec 'silent! normal! vl/\c\(\<select\>\|\<update\>\|\<delete\>\|;\s*$\|\%$\)'."\n".'"yy'

         let query = @y
         let query = substitute(query, "\n", ' ', 'g')
         let found = 0

         " if query =~? '^\c\(select\)'
         if query =~? '^\(select\|update\|delete\)'
             let found = 1
             "  \(\(\<\w\+\>\)\.\)\?   -
             " '\c\(from\|join\|,\).\{-}'  - Starting at the from clause (case insensitive)
             " '\zs\(\(\<\w\+\>\)\.\)\?' - Get the owner name (optional)
             " '\<\w\+\>\ze' - Get the table name
             " '\s\+\<'.table_name.'\>' - Followed by the alias
             " '\s*\.\@!.*'  - Cannot be followed by a .
             " '\(\<where\>\|$\)' - Must be followed by a WHERE clause
             " '.*'  - Exclude the rest of the line in the match
             " let table_name_new = matchstr(@y,
             "             \ '\c\(from\|join\|,\).\{-}'.
             "             \ '\zs\(\("\|\[\)\?.\{-}\("\|\]\)\.\)\?'.
             "             \ '\("\|\[\)\?.\{-}\("\|\]\)\?\ze'.
             "             \ '\s\+\%(as\s\+\)\?\<'.
             "             \ matchstr(table_name, '.\{-}\ze\.\?$').
             "             \ '\>'.
             "             \ '\s*\.\@!.*'.
             "             \ '\(\<where\>\|$\)'.
             "             \ '.*'
             "             \ )
             "
             "
             " ''\c\(\<from\>\|\<join\>\|,\)\s*'  - Starting at the from clause (case insensitive)
             " '\zs\(\("\|\[\)\?\w\+\("\|\]\)\?\.\)\?' - Get the owner name (optional)
             " '\("\|\[\)\?\w\+\("\|\]\)\?\ze' - Get the table name
             " '\s\+\%(as\s\+\)\?\<'.matchstr(table_name, '.\{-}\ze\.\?$').'\>' - Followed by the alias
             " '\s*\.\@!.*'  - Cannot be followed by a .
             " '\(\<where\>\|$\)' - Must be followed by a WHERE clause
             " '.*'  - Exclude the rest of the line in the match
             let table_name_new = matchstr(@y,
                         \ '\c\(\<from\>\|\<join\>\|,\)\s*'.
                         \ '\zs\(\("\|\[\)\?\w\+\("\|\]\)\?\.\)\?'.
                         \ '\("\|\[\)\?\w\+\("\|\]\)\?\ze'.
                         \ '\s\+\%(as\s\+\)\?\<'.
                         \ matchstr(table_name, '.\{-}\ze\.\?$').
                         \ '\>'.
                         \ '\s*\.\@!.*'.
                         \ '\(\<where\>\|$\)'.
                         \ '.*'
                         \ )

             if table_name_new != ''
                 let table_alias = table_name
                 if g:omni_sql_include_owner == 1
                    let table_name  = matchstr( table_name_new, '^\zs\(.\{-}\.\)\?\(.\{-}\.\)\?.*\ze' )
                 else
                     " let table_name  = matchstr( table_name_new, '^\(.*\.\)\?\zs.*\ze' )
                    let table_name  = matchstr( table_name_new, '^\(.\{-}\.\)\?\zs\(.\{-}\.\)\?.*\ze' )
                 endif

                 let list_idx = index(s:tbl_name, table_name, 0, &ignorecase)
                 if list_idx > -1
                     let table_cols  = split(s:tbl_cols[list_idx])
                     let s:tbl_name[list_idx]  = table_name
                     let s:tbl_alias[list_idx] = table_alias
                 else
                     let list_idx = index(s:tbl_alias, table_name, 0, &ignorecase)
                     if list_idx > -1
                         let table_cols = split(s:tbl_cols[list_idx])
                         let s:tbl_name[list_idx]  = table_name
                         let s:tbl_alias[list_idx] = table_alias
                     endif
                 endif

             endif
         else
             " Simply assume it is a table name provided with a . on the end
             let found = 1
         endif

         let @y        = saveY
         let @/        = saveSearch
         let &wrapscan = saveWScan

         " Return to previous location
         call cursor(curline, curcol)

         if found == 0
             if g:loaded_dbext > 300
                 exec 'DBSetOption use_tbl_alias='.saveSettingAlias
             endif

             " Not a SQL statement, do not display a list
             return []
         endif
    endif

    if empty(table_cols)
        " Specify silent mode, no messages to the user (tbl, 1)
        " Specify do not comma separate (tbl, 1, 1)
        " let table_cols_str = DB_getListColumn(table_name, 1, 1)
        let table_cols_str = DB_getListColumn((owner!=''?owner.'.':'').table_name, 1, 1)

        if table_cols_str != ""
            let s:tbl_name  = add( s:tbl_name,  table_name )
            let s:tbl_alias = add( s:tbl_alias, table_alias )
            let s:tbl_cols  = add( s:tbl_cols,  table_cols_str )
            let table_cols  = split(table_cols_str, '\n')
        endif

    endif

    if g:loaded_dbext > 300
        exec 'DBSetOption use_tbl_alias='.saveSettingAlias
    endif

    " If the user has asked for a comma separate list of column
    " values, ask the user if they want to prepend each column
    " with a tablename alias.
    if a:list_type == 'csv' && !empty(table_cols)
        let cols       = join(table_cols, ', ')
        let cols       = s:SQLCAddAlias(table_name, table_alias, cols)
        let table_cols = [cols]
    endif

    return table_cols
endfunction
"  Restore:
let &cpo= s:keepcpo
unlet s:keepcpo
" vim: ts=4 fdm=marker
                                                                                                            usr/share/vim/vim74/autoload/syntaxcomplete.vim                                                     0100644 0000000 0000000 00000075046 13050207306 020335  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim completion script
" Language:    All languages, uses existing syntax highlighting rules
" Maintainer:  David Fishburn <dfishburn dot vim at gmail dot com>
" Version:     13.0
" Last Change: 2013 May 14
" Usage:       For detailed help, ":help ft-syntax-omni"

" History
"
" Version 13.0
"   - Extended the option omni_syntax_group_include_{filetype}
"     to accept a comma separated list of regex's rather than
"     string.  For example, for the javascript filetype you could
"     use:
"        let g:omni_syntax_group_include_javascript = 'javascript\w\+,jquery\w\+'
"   - Some syntax files (perl.vim) use the match // syntax as a mechanism
"     to identify keywords.  This update attempts to parse the
"     match syntax and pull out syntax items which are at least
"     3 words or more.
"
" Version 12.0
"   - It is possible to have '-' as part of iskeyword, when
"     checking for character ranges, tighten up the regex.
"     E688: More targets than List items.
"
" Version 11.0
"   - Corrected which characters required escaping during
"     substitution calls.
"
" Version 10.0
"   - Cycle through all the character ranges specified in the
"     iskeyword option and build a list of valid word separators.
"     Prior to this change, only actual characters were used,
"     where for example ASCII "45" == "-".  If "45" were used
"     in iskeyword the hyphen would not be picked up.
"     This introduces a new option, since the character ranges
"     specified could be multibyte:
"         let g:omni_syntax_use_single_byte = 1
"   - This by default will only allow single byte ASCII
"     characters to be added and an additional check to ensure
"     the charater is printable (see documentation for isprint).
"
" Version 9.0
"   - Add the check for cpo.
"
" Version 8.0
"   - Updated SyntaxCSyntaxGroupItems()
"         - Some additional syntax items were also allowed
"           on nextgroup= lines which were ignored by default.
"           Now these lines are processed independently.
"
" Version 7.0
"   - Updated syntaxcomplete#OmniSyntaxList()
"         - Looking up the syntax groups defined from a syntax file
"           looked for only 1 format of {filetype}GroupName, but some
"           syntax writers use this format as well:
"               {b:current_syntax}GroupName
"   -       OmniSyntaxList() will now check for both if the first
"           method does not find a match.
"
" Version 6.0
"   - Added syntaxcomplete#OmniSyntaxList()
"         - Allows other plugins to use this for their own
"           purposes.
"         - It will return a List of all syntax items for the
"           syntax group name passed in.
"         - XPTemplate for SQL will use this function via the
"           sqlcomplete plugin to populate a Choose box.
"
" Version 5.0
"   - Updated SyntaxCSyntaxGroupItems()
"         - When processing a list of syntax groups, the final group
"           was missed in function SyntaxCSyntaxGroupItems.
"
" Set completion with CTRL-X CTRL-O to autoloaded function.
" This check is in place in case this script is
" sourced directly instead of using the autoload feature.
if exists('+omnifunc')
    " Do not set the option if already set since this
    " results in an E117 warning.
    if &omnifunc == ""
        setlocal omnifunc=syntaxcomplete#Complete
    endif
endif

if exists('g:loaded_syntax_completion')
    finish
endif
let g:loaded_syntax_completion = 130

" Turn on support for line continuations when creating the script
let s:cpo_save = &cpo
set cpo&vim

" Set ignorecase to the ftplugin standard
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_ignorecase')
    let g:omni_syntax_ignorecase = &ignorecase
endif

" Indicates whether we should use the iskeyword option to determine
" how to split words.
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_use_iskeyword')
    let g:omni_syntax_use_iskeyword = 1
endif

" When using iskeyword, this setting controls whether the characters
" should be limited to single byte characters.
if !exists('g:omni_syntax_use_single_byte')
    let g:omni_syntax_use_single_byte = 1
endif

" When using iskeyword, this setting controls whether the characters
" should be limited to single byte characters.
if !exists('g:omni_syntax_use_iskeyword_numeric')
    let g:omni_syntax_use_iskeyword_numeric = 1
endif

" Only display items in the completion window that are at least
" this many characters in length.
" This is the default setting, but if you define a buffer local
" variable you can override this on a per filetype.
if !exists('g:omni_syntax_minimum_length')
    let g:omni_syntax_minimum_length = 0
endif

" This script will build a completion list based on the syntax
" elements defined by the files in $VIMRUNTIME/syntax.
" let s:syn_remove_words = 'match,matchgroup=,contains,'.
let s:syn_remove_words = 'matchgroup=,contains,'.
            \ 'links to,start=,end='
            " \ 'links to,start=,end=,nextgroup='

let s:cache_name = []
let s:cache_list = []
let s:prepended  = ''

" This function is used for the 'omnifunc' option.
function! syntaxcomplete#Complete(findstart, base)

    " Only display items in the completion window that are at least
    " this many characters in length
    if !exists('b:omni_syntax_ignorecase')
        if exists('g:omni_syntax_ignorecase')
            let b:omni_syntax_ignorecase = g:omni_syntax_ignorecase
        else
            let b:omni_syntax_ignorecase = &ignorecase
        endif
    endif

    if a:findstart
        " Locate the start of the item, including "."
        let line = getline('.')
        let start = col('.') - 1
        let lastword = -1
        while start > 0
            " if line[start - 1] =~ '\S'
            "     let start -= 1
            " elseif line[start - 1] =~ '\.'
            if line[start - 1] =~ '\k'
                let start -= 1
                let lastword = a:findstart
            else
                break
            endif
        endwhile

        " Return the column of the last word, which is going to be changed.
        " Remember the text that comes before it in s:prepended.
        if lastword == -1
            let s:prepended = ''
            return start
        endif
        let s:prepended = strpart(line, start, (col('.') - 1) - start)
        return start
    endif

    " let base = s:prepended . a:base
    let base = s:prepended

    let filetype = substitute(&filetype, '\.', '_', 'g')
    let list_idx = index(s:cache_name, filetype, 0, &ignorecase)
    if list_idx > -1
        let compl_list = s:cache_list[list_idx]
    else
        let compl_list   = OmniSyntaxList()
        let s:cache_name = add( s:cache_name,  filetype )
        let s:cache_list = add( s:cache_list,  compl_list )
    endif

    " Return list of matches.

    if base != ''
        " let compstr    = join(compl_list, ' ')
        " let expr       = (b:omni_syntax_ignorecase==0?'\C':'').'\<\%('.base.'\)\@!\w\+\s*'
        " let compstr    = substitute(compstr, expr, '', 'g')
        " let compl_list = split(compstr, '\s\+')

        " Filter the list based on the first few characters the user
        " entered
        let expr = 'v:val '.(g:omni_syntax_ignorecase==1?'=~?':'=~#')." '^".escape(base, '\\/.*$^~[]').".*'"
        let compl_list = filter(deepcopy(compl_list), expr)
    endif

    return compl_list
endfunc

function! syntaxcomplete#OmniSyntaxList(...)
    if a:0 > 0
        let parms = []
        if 3 == type(a:1)
            let parms = a:1
        elseif 1 == type(a:1)
            let parms = split(a:1, ',')
        endif
        return OmniSyntaxList( parms )
    else
        return OmniSyntaxList()
    endif
endfunc

function! OmniSyntaxList(...)
    let list_parms = []
    if a:0 > 0
        if 3 == type(a:1)
            let list_parms = a:1
        elseif 1 == type(a:1)
            let list_parms = split(a:1, ',')
        endif
    endif

    " Default to returning a dictionary, if use_dictionary is set to 0
    " a list will be returned.
    " let use_dictionary = 1
    " if a:0 > 0 && a:1 != ''
    "     let use_dictionary = a:1
    " endif

    " Only display items in the completion window that are at least
    " this many characters in length
    if !exists('b:omni_syntax_use_iskeyword')
        if exists('g:omni_syntax_use_iskeyword')
            let b:omni_syntax_use_iskeyword = g:omni_syntax_use_iskeyword
        else
            let b:omni_syntax_use_iskeyword = 1
        endif
    endif

    " Only display items in the completion window that are at least
    " this many characters in length
    if !exists('b:omni_syntax_minimum_length')
        if exists('g:omni_syntax_minimum_length')
            let b:omni_syntax_minimum_length = g:omni_syntax_minimum_length
        else
            let b:omni_syntax_minimum_length = 0
        endif
    endif

    let saveL = @l
    let filetype = substitute(&filetype, '\.', '_', 'g')

    if empty(list_parms)
        " Default the include group to include the requested syntax group
        let syntax_group_include_{filetype} = ''
        " Check if there are any overrides specified for this filetype
        if exists('g:omni_syntax_group_include_'.filetype)
            let syntax_group_include_{filetype} =
                        \ substitute( g:omni_syntax_group_include_{filetype},'\s\+','','g')
            let list_parms = split(g:omni_syntax_group_include_{filetype}, ',')
            if syntax_group_include_{filetype} =~ '\w'
                let syntax_group_include_{filetype} =
                            \ substitute( syntax_group_include_{filetype},
                            \ '\s*,\s*', '\\|', 'g'
                            \ )
            endif
        endif
    else
        " A specific list was provided, use it
    endif

    " Loop through all the syntax groupnames, and build a
    " syntax file which contains these names.  This can
    " work generically for any filetype that does not already
    " have a plugin defined.
    " This ASSUMES the syntax groupname BEGINS with the name
    " of the filetype.  From my casual viewing of the vim7\syntax
    " directory this is true for almost all syntax definitions.
    " As an example, the SQL syntax groups have this pattern:
    "     sqlType
    "     sqlOperators
    "     sqlKeyword ...
    if !empty(list_parms) && empty(substitute(join(list_parms), '[a-zA-Z ]', '', 'g'))
        " If list_parms only includes word characters, use it to limit
        " the syntax elements.
        " If using regex syntax list will fail to find those items, so
        " simply grab the who syntax list.
        redir @l
        silent! exec 'syntax list '.join(list_parms)
        redir END
    else
        redir @l
        silent! exec 'syntax list'
        redir END
    endif

    let syntax_full = "\n".@l
    let @l = saveL

    if syntax_full =~ 'E28'
                \ || syntax_full =~ 'E411'
                \ || syntax_full =~ 'E415'
                \ || syntax_full =~ 'No Syntax items'
        return []
    endif

    let filetype = substitute(&filetype, '\.', '_', 'g')

    let list_exclude_groups = []
    if a:0 > 0
        " Do nothing since we have specific a specific list of groups
    else
        " Default the exclude group to nothing
        let syntax_group_exclude_{filetype} = ''
        " Check if there are any overrides specified for this filetype
        if exists('g:omni_syntax_group_exclude_'.filetype)
            let syntax_group_exclude_{filetype} =
                        \ substitute( g:omni_syntax_group_exclude_{filetype},'\s\+','','g')
            let list_exclude_groups = split(g:omni_syntax_group_exclude_{filetype}, ',')
            if syntax_group_exclude_{filetype} =~ '\w'
                let syntax_group_exclude_{filetype} =
                            \ substitute( syntax_group_exclude_{filetype},
                            \ '\s*,\s*', '\\|', 'g'
                            \ )
            endif
        endif
    endif

    if empty(list_parms)
        let list_parms = [&filetype.'\w\+']
    endif

    let syn_list = ''
    let index    = 0
    for group_regex in list_parms
        " Sometimes filetypes can be composite names, like c.doxygen
        " Loop through each individual part looking for the syntax
        " items specific to each individual filetype.
        " let ftindex  = 0
        " let ftindex  = match(syntax_full, group_regex, ftindex)

        " while ftindex > -1
            " let ft_part_name = matchstr( syntax_full, '\w\+', ftindex )

            " Syntax rules can contain items for more than just the current
            " filetype.  They can contain additional items added by the user
            " via autocmds or their vimrc.
            " Some syntax files can be combined (html, php, jsp).
            " We want only items that begin with the filetype we are interested in.
            let next_group_regex = '\n' .
                        \ '\zs'.group_regex.'\ze'.
                        \ '\s\+xxx\s\+'
            let index    = match(syntax_full, next_group_regex, index)

            " For the matched group name, strip off any of the regex special
            " characters and see if we get a match with the current syntax
            if index == -1 && exists('b:current_syntax') && substitute(group_regex, '[^a-zA-Z ]\+.*', '', 'g') !~ '^'.b:current_syntax
                " There appears to be two standards when writing syntax files.
                " Either items begin as:
                "     syn keyword {filetype}Keyword         values ...
                "     let b:current_syntax = "sql"
                "     let b:current_syntax = "sqlanywhere"
                " Or
                "     syn keyword {syntax_filename}Keyword  values ...
                "     let b:current_syntax = "mysql"
                " So, we will make the format of finding the syntax group names
                " a bit more flexible and look for both if the first fails to
                " find a match.
                let next_group_regex = '\n' .
                            \ '\zs'.b:current_syntax.'\w\+\ze'.
                            \ '\s\+xxx\s\+'
                let index    = 0
                let index    = match(syntax_full, next_group_regex, index)
            endif

            while index > -1
                let group_name = matchstr( syntax_full, '\w\+', index )

                let get_syn_list = 1
                for exclude_group_name in list_exclude_groups
                    if '\<'.exclude_group_name.'\>' =~ '\<'.group_name.'\>'
                        let get_syn_list = 0
                    endif
                endfor

                " This code is no longer needed in version 6.0 since we have
                " augmented the syntax list command to only retrieve the syntax
                " groups we are interested in.
                "
                " if get_syn_list == 1
                "     if syntax_group_include_{filetype} != ''
                "         if '\<'.syntax_group_include_{filetype}.'\>' !~ '\<'.group_name.'\>'
                "             let get_syn_list = 0
                "         endif
                "     endif
                " endif

                if get_syn_list == 1
                    " Pass in the full syntax listing, plus the group name we
                    " are interested in.
                    let extra_syn_list = s:SyntaxCSyntaxGroupItems(group_name, syntax_full)
                    let syn_list = syn_list . extra_syn_list . "\n"
                endif

                let index = index + strlen(group_name)
                let index = match(syntax_full, next_group_regex, index)
            endwhile

            " let ftindex  = ftindex + len(ft_part_name)
            " let ftindex  = match( syntax_full, group_regex, ftindex )
        " endwhile
    endfor

"   " Sometimes filetypes can be composite names, like c.doxygen
"   " Loop through each individual part looking for the syntax
"   " items specific to each individual filetype.
"   let syn_list = ''
"   let ftindex  = 0
"   let ftindex  = match(&filetype, '\w\+', ftindex)

"   while ftindex > -1
"       let ft_part_name = matchstr( &filetype, '\w\+', ftindex )

"       " Syntax rules can contain items for more than just the current
"       " filetype.  They can contain additional items added by the user
"       " via autocmds or their vimrc.
"       " Some syntax files can be combined (html, php, jsp).
"       " We want only items that begin with the filetype we are interested in.
"       let next_group_regex = '\n' .
"                   \ '\zs'.ft_part_name.'\w\+\ze'.
"                   \ '\s\+xxx\s\+'
"       let index    = 0
"       let index    = match(syntax_full, next_group_regex, index)

"       if index == -1 && exists('b:current_syntax') && ft_part_name != b:current_syntax
"           " There appears to be two standards when writing syntax files.
"           " Either items begin as:
"           "     syn keyword {filetype}Keyword         values ...
"           "     let b:current_syntax = "sql"
"           "     let b:current_syntax = "sqlanywhere"
"           " Or
"           "     syn keyword {syntax_filename}Keyword  values ...
"           "     let b:current_syntax = "mysql"
"           " So, we will make the format of finding the syntax group names
"           " a bit more flexible and look for both if the first fails to
"           " find a match.
"           let next_group_regex = '\n' .
"                       \ '\zs'.b:current_syntax.'\w\+\ze'.
"                       \ '\s\+xxx\s\+'
"           let index    = 0
"           let index    = match(syntax_full, next_group_regex, index)
"       endif

"       while index > -1
"           let group_name = matchstr( syntax_full, '\w\+', index )

"           let get_syn_list = 1
"           for exclude_group_name in list_exclude_groups
"               if '\<'.exclude_group_name.'\>' =~ '\<'.group_name.'\>'
"                   let get_syn_list = 0
"               endif
"           endfor

"           " This code is no longer needed in version 6.0 since we have
"           " augmented the syntax list command to only retrieve the syntax
"           " groups we are interested in.
"           "
"           " if get_syn_list == 1
"           "     if syntax_group_include_{filetype} != ''
"           "         if '\<'.syntax_group_include_{filetype}.'\>' !~ '\<'.group_name.'\>'
"           "             let get_syn_list = 0
"           "         endif
"           "     endif
"           " endif

"           if get_syn_list == 1
"               " Pass in the full syntax listing, plus the group name we
"               " are interested in.
"               let extra_syn_list = s:SyntaxCSyntaxGroupItems(group_name, syntax_full)
"               let syn_list = syn_list . extra_syn_list . "\n"
"           endif

"           let index = index + strlen(group_name)
"           let index = match(syntax_full, next_group_regex, index)
"       endwhile

"       let ftindex  = ftindex + len(ft_part_name)
"       let ftindex  = match( &filetype, '\w\+', ftindex )
"   endwhile

    " Convert the string to a List and sort it.
    let compl_list = sort(split(syn_list))

    if &filetype == 'vim'
        let short_compl_list = []
        for i in range(len(compl_list))
            if i == len(compl_list)-1
                let next = i
            else
                let next = i + 1
            endif
            if  compl_list[next] !~ '^'.compl_list[i].'.$'
                let short_compl_list += [compl_list[i]]
            endif
        endfor

        return short_compl_list
    else
        return compl_list
    endif
endfunction

function! s:SyntaxCSyntaxGroupItems( group_name, syntax_full )

    let syn_list = ""

    " From the full syntax listing, strip out the portion for the
    " request group.
    " Query:
    "     \n           - must begin with a newline
    "     a:group_name - the group name we are interested in
    "     \s\+xxx\s\+  - group names are always followed by xxx
    "     \zs          - start the match
    "     .\{-}        - everything ...
    "     \ze          - end the match
    "     \(           - start a group or 2 potential matches
    "     \n\w         - at the first newline starting with a character
    "     \|           - 2nd potential match
    "     \%$          - matches end of the file or string
    "     \)           - end a group
    let syntax_group = matchstr(a:syntax_full,
                \ "\n".a:group_name.'\s\+xxx\s\+\zs.\{-}\ze\(\n\w\|\%$\)'
                \ )

    if syntax_group != ""
        " let syn_list = substitute( @l, '^.*xxx\s*\%(contained\s*\)\?', "", '' )
        " let syn_list = substitute( @l, '^.*xxx\s*', "", '' )

        " We only want the words for the lines begining with
        " containedin, but there could be other items.

        " Tried to remove all lines that do not begin with contained
        " but this does not work in all cases since you can have
        "    contained nextgroup=...
        " So this will strip off the ending of lines with known
        " keywords.
        let syn_list = substitute(
                    \    syntax_group, '\<\('.
                    \    substitute(
                    \      escape(s:syn_remove_words, '\\/.*$^~[]')
                    \      , ',', '\\|', 'g'
                    \    ).
                    \    '\).\{-}\%($\|'."\n".'\)'
                    \    , "\n", 'g'
                    \  )

        " Attempt to deal with lines using the match syntax
        " javaScriptDocTags xxx match /@\(param\|argument\|requires\|file\)\>/
        " Though it can use any types of regex, so this plugin will attempt
        " to restrict it
        " 1.  Only use \( or \%( constructs remove all else
        " 2   Remove and []s
        " 3.  Account for match //constructs
        "                       \%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?
        " 4.  Hope for the best
        "
        "
        let syn_list_old = syn_list
        while syn_list =~ '\<match\>\s\+\/'
            if syn_list =~ 'perlElseIfError'
                let syn_list = syn_list
            endif
            " Check if the match has words at least 3 characters long
            if syn_list =~ '\<match \/\zs.\{-}\<\w\{3,}\>.\{-}\ze\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+'
                " Remove everything after / and before the first \(
                let syn_list = substitute( syn_list, '\<match \/\zs.\{-}\ze\\%\?(.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                " Remove everything after \) and up to the ending /
                let syn_list = substitute( syn_list, '\<match \/.\{-}\\)\zs.\{-}\ze\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )

                " Remove any character classes
                " let syn_list = substitute( syn_list, '\<match /\zs.\{-}\[[^]]*\].\{-}\ze\/ ', '', 'g' )
                let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\[[^]]*\]\ze.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?', '', 'g' )
                " Remove any words < 3 characters
                let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\<\w\{1,2}\>\ze.\{-}\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                " Remove all non-word characters
                " let syn_list = substitute( syn_list, '\<match /\zs.\{-}\<\W\+\>.\{-}\ze\/ ', "", 'g' )
                " let syn_list = substitute( syn_list, '\%(\<match \/[^/]\{-}\)\@<=\W\+\ze.\{-}\/ ', ' ', 'g' )
                " Do this by using the outer substitue() call to gather all
                " text between the match /.../ tags.
                " The inner substitute() call operates on the text selected
                " and replaces all non-word characters.
                let syn_list = substitute( syn_list, '\<match \/\zs\(.\{-}\)\ze\\\@<!\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+'
                            \ , '\=substitute(submatch(1), "\\W\\+", " ", "g")'
                            \ , 'g' )
                " Remove the match / / syntax
                let syn_list = substitute( syn_list, '\<match \/\(.\{-}\)\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '\1', 'g' )
            else
                " No words long enough, remove the match
                " Remove the match syntax
                " let syn_list = substitute( syn_list, '\<match \/[^\/]*\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
                let syn_list = substitute( syn_list, '\<match \/\%(.\{-}\)\?\/\%(\%(ms\|me\|hs\|he\|rs\|re\|lc\)\S\+\)\?\s\+', '', 'g' )
            endif
            if syn_list =~ '\<match\>\s\+\/'
                " Problem removing the match / / tags
                let syn_list = ''
            endif
        endwhile


        " Now strip off the newline + blank space + contained.
        " Also include lines with nextgroup=@someName skip_key_words syntax_element
                    " \    syn_list, '\%(^\|\n\)\@<=\s*\<\(contained\|nextgroup=\)'
                    " \    syn_list, '\%(^\|\n\)\@<=\s*\<\(contained\|nextgroup=[@a-zA-Z,]*\)'
        let syn_list = substitute(
                    \    syn_list, '\<\(contained\|nextgroup=[@a-zA-Z,]*\)'
                    \    , "", 'g'
                    \ )

        " This can leave lines like this
        "     =@vimMenuList  skipwhite onoremenu
        " Strip the special option keywords first
        "     :h :syn-skipwhite*
        let syn_list = substitute(
                    \    syn_list, '\<\(skipwhite\|skipnl\|skipempty\)\>'
                    \    , "", 'g'
                    \ )

        " Now remove the remainder of the nextgroup=@someName lines
        let syn_list = substitute(
                    \    syn_list, '\%(^\|\n\)\@<=\s*\(@\w\+\)'
                    \    , "", 'g'
                    \ )

        if b:omni_syntax_use_iskeyword == 0
            " There are a number of items which have non-word characters in
            " them, *'T_F1'*.  vim.vim is one such file.
            " This will replace non-word characters with spaces.
            let syn_list = substitute( syn_list, '[^0-9A-Za-z_ ]', ' ', 'g' )
        else
            if g:omni_syntax_use_iskeyword_numeric == 1
                " iskeyword can contain value like this
                " 38,42,43,45,47-58,60-62,64-90,97-122,_,+,-,*,/,%,<,=,>,:,$,?,!,@-@,94
                " Numeric values convert to their ASCII equivalent using the
                " nr2char() function.
                "     &       38
                "     *       42
                "     +       43
                "     -       45
                "     ^       94
                " Iterate through all numeric specifications and convert those
                " to their ascii equivalent ensuring the character is printable.
                " If so, add it to the list.
                let accepted_chars = ''
                for item in split(&iskeyword, ',')
                    if item =~ '\d-\d'
                        " This is a character range (ie 47-58),
                        " cycle through each character within the range
                        let [b:start, b:end] = split(item, '-')
                        for range_item in range( b:start, b:end )
                            if range_item <= 127 || g:omni_syntax_use_single_byte == 0
                                if nr2char(range_item) =~ '\p'
                                    let accepted_chars = accepted_chars . nr2char(range_item)
                                endif
                            endif
                        endfor
                    elseif item =~ '^\d\+$'
                        " Only numeric, translate to a character
                        if item < 127 || g:omni_syntax_use_single_byte == 0
                            if nr2char(item) =~ '\p'
                                let accepted_chars = accepted_chars . nr2char(item)
                            endif
                        endif
                    else
                        if char2nr(item) < 127 || g:omni_syntax_use_single_byte == 0
                            if item =~ '\p'
                                let accepted_chars = accepted_chars . item
                            endif
                        endif
                    endif
                endfor
                " Escape special regex characters
                " Looks like the wrong chars are escaped.  In a collection,
                "      :h /[]
                "      only `]', `\', `-' and `^' are special:
                " let accepted_chars = escape(accepted_chars, '\\/.*$^~[]' )
                let accepted_chars = escape(accepted_chars, ']\-^' )
                " Remove all characters that are not acceptable
                let syn_list = substitute( syn_list, '[^A-Za-z'.accepted_chars.']', ' ', 'g' )
            else
                let accept_chars = ','.&iskeyword.','
                " Remove all character ranges
                " let accept_chars = substitute(accept_chars, ',[^,]\+-[^,]\+,', ',', 'g')
                let accept_chars = substitute(accept_chars, ',\@<=[^,]\+-[^,]\+,', '', 'g')
                " Remove all numeric specifications
                " let accept_chars = substitute(accept_chars, ',\d\{-},', ',', 'g')
                let accept_chars = substitute(accept_chars, ',\@<=\d\{-},', '', 'g')
                " Remove all commas
                let accept_chars = substitute(accept_chars, ',', '', 'g')
                " Escape special regex characters
                " Looks like the wrong chars are escaped.  In a collection,
                "      :h /[]
                "      only `]', `\', `-' and `^' are special:
                " let accept_chars = escape(accept_chars, '\\/.*$^~[]' )
                let accept_chars = escape(accept_chars, ']\-^' )
                " Remove all characters that are not acceptable
                let syn_list = substitute( syn_list, '[^0-9A-Za-z_'.accept_chars.']', ' ', 'g' )
            endif
        endif

        if b:omni_syntax_minimum_length > 0
            " If the user specified a minimum length, enforce it
            let syn_list = substitute(' '.syn_list.' ', ' \S\{,'.b:omni_syntax_minimum_length.'}\ze ', ' ', 'g')
        endif
    else
        let syn_list = ''
    endif

    return syn_list
endfunction

function! OmniSyntaxShowChars(spec)
  let result = []
  for item in split(a:spec, ',')
    if len(item) > 1
      if item == '@-@'
        call add(result, char2nr(item))
      else
        call extend(result, call('range', split(item, '-')))
      endif
    else
      if item == '@'  " assume this is [A-Za-z]
        for [c1, c2] in [['A', 'Z'], ['a', 'z']]
          call extend(result, range(char2nr(c1), char2nr(c2)))
        endfor
      else
        call add(result, char2nr(item))
      endif
    endif
  endfor
  return join(map(result, 'nr2char(v:val)'), ', ')
endfunction
let &cpo = s:cpo_save
unlet s:cpo_save
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/share/vim/vim74/autoload/tar.vim                                                                0100644 0000000 0000000 00000053111 13050207306 016031  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " tar.vim: Handles browsing tarfiles
"            AUTOLOAD PORTION
" Date:			Apr 17, 2013
" Version:		29
" Maintainer:	Charles E Campbell <NdrOchip@ScampbellPfamily.AbizM-NOSPAM>
" License:		Vim License  (see vim's :help license)
"
"	Contains many ideas from Michael Toren's <tar.vim>
"
" Copyright:    Copyright (C) 2005-2011 Charles E. Campbell {{{1
"               Permission is hereby granted to use and distribute this code,
"               with or without modifications, provided that this copyright
"               notice is copied with it. Like anything else that's free,
"               tar.vim and tarPlugin.vim are provided *as is* and comes
"               with no warranty of any kind, either expressed or implied.
"               By using this plugin, you agree that in no event will the
"               copyright holder be liable for any damages resulting from
"               the use of this software.
"     call inputsave()|call input("Press <cr> to continue")|call inputrestore()
" ---------------------------------------------------------------------
" Load Once: {{{1
if &cp || exists("g:loaded_tar")
 finish
endif
let g:loaded_tar= "v29"
if v:version < 702
 echohl WarningMsg
 echo "***warning*** this version of tar needs vim 7.2"
 echohl Normal
 finish
endif
let s:keepcpo= &cpo
set cpo&vim
"DechoTabOn
"call Decho("loading autoload/tar.vim")

" ---------------------------------------------------------------------
"  Default Settings: {{{1
if !exists("g:tar_browseoptions")
 let g:tar_browseoptions= "Ptf"
endif
if !exists("g:tar_readoptions")
 let g:tar_readoptions= "OPxf"
endif
if !exists("g:tar_cmd")
 let g:tar_cmd= "tar"
endif
if !exists("g:tar_writeoptions")
 let g:tar_writeoptions= "uf"
endif
if !exists("g:netrw_cygwin")
 if has("win32") || has("win95") || has("win64") || has("win16")
  if &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
   let g:netrw_cygwin= 1
  else
   let g:netrw_cygwin= 0
  endif
 else
  let g:netrw_cygwin= 0
 endif
endif
if !exists("g:tar_copycmd")
 if !exists("g:netrw_localcopycmd")
  if has("win32") || has("win95") || has("win64") || has("win16")
   if g:netrw_cygwin
    let g:netrw_localcopycmd= "cp"
   else
    let g:netrw_localcopycmd= "copy"
   endif
  elseif has("unix") || has("macunix")
   let g:netrw_localcopycmd= "cp"
  else
   let g:netrw_localcopycmd= ""
  endif
 endif
 let g:tar_copycmd= g:netrw_localcopycmd
endif
if !exists("g:tar_extractcmd")
 let g:tar_extractcmd= "tar -xf"
endif

" set up shell quoting character
if !exists("g:tar_shq")
 if exists("+shq") && exists("&shq") && &shq != ""
  let g:tar_shq= &shq
 elseif has("win32") || has("win95") || has("win64") || has("win16")
  if exists("g:netrw_cygwin") && g:netrw_cygwin
   let g:tar_shq= "'"
  else
   let g:tar_shq= '"'
  endif
 else
  let g:tar_shq= "'"
 endif
" call Decho("g:tar_shq<".g:tar_shq.">")
endif

" ----------------
"  Functions: {{{1
" ----------------

" ---------------------------------------------------------------------
" tar#Browse: {{{2
fun! tar#Browse(tarfile)
"  call Dfunc("tar#Browse(tarfile<".a:tarfile.">)")
  let repkeep= &report
  set report=10

  " sanity checks
  if !executable(g:tar_cmd)
   redraw!
   echohl Error | echo '***error*** (tar#Browse) "'.g:tar_cmd.'" not available on your system'
   let &report= repkeep
"   call Dret("tar#Browse")
   return
  endif
  if !filereadable(a:tarfile)
"   call Decho('a:tarfile<'.a:tarfile.'> not filereadable')
   if a:tarfile !~# '^\a\+://'
    " if its an url, don't complain, let url-handlers such as vim do its thing
    redraw!
    echohl Error | echo "***error*** (tar#Browse) File not readable<".a:tarfile.">" | echohl None
   endif
   let &report= repkeep
"   call Dret("tar#Browse : file<".a:tarfile."> not readable")
   return
  endif
  if &ma != 1
   set ma
  endif
  let b:tarfile= a:tarfile

  setlocal noswapfile
  setlocal buftype=nofile
  setlocal bufhidden=hide
  setlocal nobuflisted
  setlocal nowrap
  set ft=tar

  " give header
"  call Decho("printing header")
  let lastline= line("$")
  call setline(lastline+1,'" tar.vim version '.g:loaded_tar)
  call setline(lastline+2,'" Browsing tarfile '.a:tarfile)
  call setline(lastline+3,'" Select a file with cursor and press ENTER')
  keepj $put =''
  keepj sil! 0d
  keepj $

  let tarfile= a:tarfile
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif
  let curlast= line("$")
  if tarfile =~# '\.\(gz\|tgz\)$'
"   call Decho("1: exe silent r! gzip -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.lrp'
"   call Decho("2: exe silent r! cat -- ".shellescape(tarfile,1)."|gzip -d -c -|".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! cat -- ".shellescape(tarfile,1)."|gzip -d -c -|".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(bz2\|tbz\|tb2\)$'
"   call Decho("3: exe silent r! bzip2 -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(lzma\|tlz\)$'
"   call Decho("3: exe silent r! lzma -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! lzma -d -c -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  elseif tarfile =~# '\.\(xz\|txz\)$'
"   call Decho("3: exe silent r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - ")
   exe "sil! r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_browseoptions." - "
  else
   if tarfile =~ '^\s*-'
    " A file name starting with a dash is taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("4: exe silent r! ".g:tar_cmd." -".g:tar_browseoptions." ".shellescape(tarfile,0))
   exe "sil! r! ".g:tar_cmd." -".g:tar_browseoptions." ".shellescape(tarfile,1)
  endif
  if v:shell_error != 0
   redraw!
   echohl WarningMsg | echo "***warning*** (tar#Browse) please check your g:tar_browseoptions<".g:tar_browseoptions.">"
"   call Dret("tar#Browse : a:tarfile<".a:tarfile.">")
   return
  endif
  if line("$") == curlast || ( line("$") == (curlast + 1) && getline("$") =~ '\c\%(warning\|error\|inappropriate\|unrecognized\)')
   redraw!
   echohl WarningMsg | echo "***warning*** (tar#Browse) ".a:tarfile." doesn't appear to be a tar file" | echohl None
   keepj sil! %d
   let eikeep= &ei
   set ei=BufReadCmd,FileReadCmd
   exe "r ".fnameescape(a:tarfile)
   let &ei= eikeep
   keepj sil! 1d
"   call Dret("tar#Browse : a:tarfile<".a:tarfile.">")
   return
  endif

  setlocal noma nomod ro
  noremap <silent> <buffer> <cr> :call <SID>TarBrowseSelect()<cr>

  let &report= repkeep
"  call Dret("tar#Browse : b:tarfile<".b:tarfile.">")
endfun

" ---------------------------------------------------------------------
" TarBrowseSelect: {{{2
fun! s:TarBrowseSelect()
"  call Dfunc("TarBrowseSelect() b:tarfile<".b:tarfile."> curfile<".expand("%").">")
  let repkeep= &report
  set report=10
  let fname= getline(".")
"  call Decho("fname<".fname.">")

  if !exists("g:tar_secure") && fname =~ '^\s*-\|\s\+-'
   redraw!
   echohl WarningMsg | echo '***warning*** (tar#BrowseSelect) rejecting tarfile member<'.fname.'> because of embedded "-"'
"   call Dret('tar#BrowseSelect : rejecting tarfile member<'.fname.'> because of embedded "-"')
   return
  endif

  " sanity check
  if fname =~ '^"'
   let &report= repkeep
"   call Dret("TarBrowseSelect")
   return
  endif

  " about to make a new window, need to use b:tarfile
  let tarfile= b:tarfile
  let curfile= expand("%")
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif

  new
  if !exists("g:tar_nomax") || g:tar_nomax == 0
   wincmd _
  endif
  let s:tblfile_{winnr()}= curfile
  call tar#Read("tarfile:".tarfile.'::'.fname,1)
  filetype detect
  set nomod
  exe 'com! -buffer -nargs=? -complete=file TarDiff	:call tar#Diff(<q-args>,"'.fnameescape(fname).'")'

  let &report= repkeep
"  call Dret("TarBrowseSelect : s:tblfile_".winnr()."<".s:tblfile_{winnr()}.">")
endfun

" ---------------------------------------------------------------------
" tar#Read: {{{2
fun! tar#Read(fname,mode)
"  call Dfunc("tar#Read(fname<".a:fname.">,mode=".a:mode.")")
  let repkeep= &report
  set report=10
  let tarfile = substitute(a:fname,'tarfile:\(.\{-}\)::.*$','\1','')
  let fname   = substitute(a:fname,'tarfile:.\{-}::\(.*\)$','\1','')
  if has("win32unix") && executable("cygpath")
   " assuming cygwin
   let tarfile=substitute(system("cygpath -u ".shellescape(tarfile,0)),'\n$','','e')
  endif
"  call Decho("tarfile<".tarfile.">")
"  call Decho("fname<".fname.">")

  if  fname =~ '\.bz2$' && executable("bzcat")
   let decmp= "|bzcat"
   let doro = 1
  elseif      fname =~ '\.gz$'  && executable("zcat")
   let decmp= "|zcat"
   let doro = 1
  elseif  fname =~ '\.lzma$' && executable("lzcat")
   let decmp= "|lzcat"
   let doro = 1
  elseif  fname =~ '\.xz$' && executable("xzcat")
   let decmp= "|xzcat"
   let doro = 1
  else
   let decmp=""
   let doro = 0
   if fname =~ '\.bz2$\|\.gz$\|\.lzma$\|\.xz$\|\.zip$\|\.Z$'
    setlocal bin
   endif
  endif

  if exists("g:tar_secure")
   let tar_secure= " -- "
  else
   let tar_secure= " "
  endif
  if tarfile =~# '\.bz2$'
"   call Decho("7: exe silent r! bzip2 -d -c ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp)
   exe "sil! r! bzip2 -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.\(gz\|tgz\)$'
"   call Decho("5: exe silent r! gzip -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd.' -'.g:tar_readoptions.' - '.tar_secure.shellescape(fname,1))
   exe "sil! r! gzip -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.lrp$'
"   call Decho("6: exe silent r! cat ".shellescape(tarfile,1)." | gzip -d -c - | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp)
   exe "sil! r! cat -- ".shellescape(tarfile,1)." | gzip -d -c - | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.lzma$'
"   call Decho("7: exe silent r! lzma -d -c ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp)
   exe "sil! r! lzma -d -c -- ".shellescape(tarfile,1)."| ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  elseif tarfile =~# '\.\(xz\|txz\)$'
"   call Decho("3: exe silent r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp)
   exe "sil! r! xz --decompress --stdout -- ".shellescape(tarfile,1)." | ".g:tar_cmd." -".g:tar_readoptions." - ".tar_secure.shellescape(fname,1).decmp
  else
   if tarfile =~ '^\s*-'
    " A file name starting with a dash is taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("8: exe silent r! ".g:tar_cmd." -".g:tar_readoptions.tar_secure.shellescape(tarfile,1)." ".shellescape(fname,1).decmp)
   exe "silent r! ".g:tar_cmd." -".g:tar_readoptions.shellescape(tarfile,1)." ".tar_secure.shellescape(fname,1).decmp
  endif

  if doro
   " because the reverse process of compressing changed files back into the tarball is not currently supported
   setlocal ro
  endif

  let b:tarfile= a:fname
  exe "file tarfile::".fnameescape(fname)

  " cleanup
  keepj sil! 0d
  set nomod

  let &report= repkeep
"  call Dret("tar#Read : b:tarfile<".b:tarfile.">")
endfun

" ---------------------------------------------------------------------
" tar#Write: {{{2
fun! tar#Write(fname)
"  call Dfunc("tar#Write(fname<".a:fname.">) b:tarfile<".b:tarfile."> tblfile_".winnr()."<".s:tblfile_{winnr()}.">")
  let repkeep= &report
  set report=10

  if !exists("g:tar_secure") && a:fname =~ '^\s*-\|\s\+-'
   redraw!
   echohl WarningMsg | echo '***warning*** (tar#Write) rejecting tarfile member<'.a:fname.'> because of embedded "-"'
"   call Dret('tar#Write : rejecting tarfile member<'.fname.'> because of embedded "-"')
   return
  endif

  " sanity checks
  if !executable(g:tar_cmd)
   redraw!
   echohl Error | echo '***error*** (tar#Browse) "'.g:tar_cmd.'" not available on your system'
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endif
  if !exists("*mkdir")
   redraw!
   echohl Error | echo "***error*** (tar#Write) sorry, mkdir() doesn't work on your system" | echohl None
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endif

  let curdir= getcwd()
  let tmpdir= tempname()
"  call Decho("orig tempname<".tmpdir.">")
  if tmpdir =~ '\.'
   let tmpdir= substitute(tmpdir,'\.[^.]*$','','e')
  endif
"  call Decho("tmpdir<".tmpdir.">")
  call mkdir(tmpdir,"p")

  " attempt to change to the indicated directory
  try
   exe "cd ".fnameescape(tmpdir)
  catch /^Vim\%((\a\+)\)\=:E344/
   redraw!
   echohl Error | echo "***error*** (tar#Write) cannot cd to temporary directory" | Echohl None
   let &report= repkeep
"   call Dret("tar#Write")
   return
  endtry
"  call Decho("current directory now: ".getcwd())

  " place temporary files under .../_ZIPVIM_/
  if isdirectory("_ZIPVIM_")
   call s:Rmdir("_ZIPVIM_")
  endif
  call mkdir("_ZIPVIM_")
  cd _ZIPVIM_
"  call Decho("current directory now: ".getcwd())

  let tarfile = substitute(b:tarfile,'tarfile:\(.\{-}\)::.*$','\1','')
  let fname   = substitute(b:tarfile,'tarfile:.\{-}::\(.*\)$','\1','')

  " handle compressed archives
  if tarfile =~# '\.bz2'
   call system("bzip2 -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.bz2','','e')
   let compress= "bzip2 -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.gz'
   call system("gzip -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.gz','','e')
   let compress= "gzip -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.tgz'
   call system("gzip -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.tgz','.tar','e')
   let compress= "gzip -- ".shellescape(tarfile,0)
   let tgz     = 1
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.xz'
   call system("xz -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.xz','','e')
   let compress= "xz -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  elseif tarfile =~# '\.lzma'
   call system("lzma -d -- ".shellescape(tarfile,0))
   let tarfile = substitute(tarfile,'\.lzma','','e')
   let compress= "lzma -- ".shellescape(tarfile,0)
"   call Decho("compress<".compress.">")
  endif
"  call Decho("tarfile<".tarfile.">")

  if v:shell_error != 0
   redraw!
   echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".tarfile." with ".fname | echohl None
  else

"   call Decho("tarfile<".tarfile."> fname<".fname.">")
 
   if fname =~ '/'
    let dirpath = substitute(fname,'/[^/]\+$','','e')
    if has("win32unix") && executable("cygpath")
     let dirpath = substitute(system("cygpath ".shellescape(dirpath, 0)),'\n','','e')
    endif
    call mkdir(dirpath,"p")
   endif
   if tarfile !~ '/'
    let tarfile= curdir.'/'.tarfile
   endif
   if tarfile =~ '^\s*-'
    " A file name starting with a dash may be taken as an option.  Prepend ./ to avoid that.
    let tarfile = substitute(tarfile, '-', './-', '')
   endif
"   call Decho("tarfile<".tarfile."> fname<".fname.">")
 
   if exists("g:tar_secure")
    let tar_secure= " -- "
   else
    let tar_secure= " "
   endif
   exe "w! ".fnameescape(fname)
   if has("win32unix") && executable("cygpath")
    let tarfile = substitute(system("cygpath ".shellescape(tarfile,0)),'\n','','e')
   endif
 
   " delete old file from tarfile
"   call Decho("system(".g:tar_cmd." --delete -f ".shellescape(tarfile,0)." -- ".shellescape(fname,0).")")
   call system(g:tar_cmd." --delete -f ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
   if v:shell_error != 0
    redraw!
    echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname) | echohl None
   else
 
    " update tarfile with new file 
"    call Decho(g:tar_cmd." -".g:tar_writeoptions." ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
    call system(g:tar_cmd." -".g:tar_writeoptions." ".shellescape(tarfile,0).tar_secure.shellescape(fname,0))
    if v:shell_error != 0
     redraw!
     echohl Error | echo "***error*** (tar#Write) sorry, unable to update ".fnameescape(tarfile)." with ".fnameescape(fname) | echohl None
    elseif exists("compress")
"     call Decho("call system(".compress.")")
     call system(compress)
     if exists("tgz")
"      call Decho("rename(".tarfile.".gz,".substitute(tarfile,'\.tar$','.tgz','e').")")
      call rename(tarfile.".gz",substitute(tarfile,'\.tar$','.tgz','e'))
     endif
    endif
   endif

   " support writing tarfiles across a network
   if s:tblfile_{winnr()} =~ '^\a\+://'
"    call Decho("handle writing <".tarfile."> across network to <".s:tblfile_{winnr()}.">")
    let tblfile= s:tblfile_{winnr()}
    1split|enew
    let binkeep= &l:binary
    let eikeep = &ei
    set binary ei=all
    exe "e! ".fnameescape(tarfile)
    call netrw#NetWrite(tblfile)
    let &ei       = eikeep
    let &l:binary = binkeep
    q!
    unlet s:tblfile_{winnr()}
   endif
  endif
  
  " cleanup and restore current directory
  cd ..
  call s:Rmdir("_ZIPVIM_")
  exe "cd ".fnameescape(curdir)
  setlocal nomod

  let &report= repkeep
"  call Dret("tar#Write")
endfun

" ---------------------------------------------------------------------
" tar#Diff: {{{2
fun! tar#Diff(userfname,fname)
"  call Dfunc("tar#Diff(userfname<".a:userfname."> fname<".a:fname.")")
  let fname= a:fname
  if a:userfname != ""
   let fname= a:userfname
  endif
  if filereadable(fname)
   " sets current file (from tarball) for diff'ing
   " splits window vertically
   " opens original file, sets it for diff'ing
   " sets up b:tardiff_otherbuf variables so each buffer knows about the other (for closing purposes)
   diffthis
   wincmd v
   exe "e ".fnameescape(fname)
   diffthis
  else
   redraw!
   echo "***warning*** unable to read file<".fname.">"
  endif
"  call Dret("tar#Diff")
endfun

" ---------------------------------------------------------------------
" s:Rmdir: {{{2
fun! s:Rmdir(fname)
"  call Dfunc("Rmdir(fname<".a:fname.">)")
  if has("unix")
   call system("/bin/rm -rf -- ".shellescape(a:fname,0))
  elseif has("win32") || has("win95") || has("win64") || has("win16")
   if &shell =~? "sh$"
    call system("/bin/rm -rf -- ".shellescape(a:fname,0))
   else
    call system("del /S ".shellescape(a:fname,0))
   endif
  endif
"  call Dret("Rmdir")
endfun

" ---------------------------------------------------------------------
" tar#Vimuntar: installs a tarball in the user's .vim / vimfiles directory {{{2
fun! tar#Vimuntar(...)
"  call Dfunc("tar#Vimuntar() a:0=".a:0." a:1<".(exists("a:1")? a:1 : "-n/a-").">")
  let tarball = expand("%")
"  call Decho("tarball<".tarball.">")
  let tarbase = substitute(tarball,'\..*$','','')
"  call Decho("tarbase<".tarbase.">")
  let tarhome = expand("%:p")
  if has("win32") || has("win95") || has("win64") || has("win16")
   let tarhome= substitute(tarhome,'\\','/','g')
  endif
  let tarhome= substitute(tarhome,'/[^/]*$','','')
"  call Decho("tarhome<".tarhome.">")
  let tartail = expand("%:t")
"  call Decho("tartail<".tartail.">")
  let curdir  = getcwd()
"  call Decho("curdir <".curdir.">")
  " set up vimhome
  if a:0 > 0 && a:1 != ""
   let vimhome= a:1
  else
   let vimhome= vimball#VimballHome()
  endif
"  call Decho("vimhome<".vimhome.">")

"  call Decho("curdir<".curdir."> vimhome<".vimhome.">")
  if simplify(curdir) != simplify(vimhome)
   " copy (possibly compressed) tarball to .vim/vimfiles
"   call Decho(netrw#WinPath(g:tar_copycmd)." ".shellescape(tartail)." ".shellescape(vimhome))
   call system(netrw#WinPath(g:tar_copycmd)." ".shellescape(tartail)." ".shellescape(vimhome))
"   call Decho("exe cd ".fnameescape(vimhome))
   exe "cd ".fnameescape(vimhome)
  endif
"  call Decho("getcwd<".getcwd().">")

  " if necessary, decompress the tarball; then, extract it
  if tartail =~ '\.tgz'
   if executable("gunzip")
    silent exe "!gunzip ".shellescape(tartail)
   elseif executable("gzip")
    silent exe "!gzip -d ".shellescape(tartail)
   else
    echoerr "unable to decompress<".tartail."> on this sytem"
    if simplify(curdir) != simplify(tarhome)
     " remove decompressed tarball, restore directory
"     call Decho("delete(".tartail.".tar)")
     call delete(tartail.".tar")
"     call Decho("exe cd ".fnameescape(curdir))
     exe "cd ".fnameescape(curdir)
    endif
"    call Dret("tar#Vimuntar")
    return
   endif
  else
   call vimball#Decompress(tartail,0)
  endif
  let extractcmd= netrw#WinPath(g:tar_extractcmd)
"  call Decho("system(".extractcmd." ".shellescape(tarbase.".tar").")")
  call system(extractcmd." ".shellescape(tarbase.".tar"))

  " set up help
  if filereadable("doc/".tarbase.".txt")
"   call Decho("exe helptags ".getcwd()."/doc")
   exe "helptags ".getcwd()."/doc"
  endif

  if simplify(tarhome) != simplify(vimhome)
   " remove decompressed tarball, restore directory
   call delete(vimhome."/".tarbase.".tar")
   exe "cd ".fnameescape(curdir)
  endif

"  call Dret("tar#Vimuntar")
endfun

" =====================================================================
" Modelines And Restoration: {{{1
let &cpo= s:keepcpo
unlet s:keepcpo
" vim:ts=8 fdm=marker
                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/share/vim/vim74/autoload/tohtml.vim                                                             0100644 0000000 0000000 00000076517 13050207306 016571  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " Vim autoload file for the tohtml plugin.
" Maintainer: Ben Fritz <fritzophrenic@gmail.com>
" Last Change: 2013 Jun 19
"
" Additional contributors:
"
"	      Original by Bram Moolenaar <Bram@vim.org>
"	      Diff2HTML() added by Christian Brabandt <cb@256bit.org>
"
"	      See Mercurial change logs for more!

" this file uses line continuations
let s:cpo_sav = &cpo
set cpo&vim

" Automatically find charsets from all encodings supported natively by Vim. With
" the 8bit- and 2byte- prefixes, Vim can actually support more encodings than
" this. Let the user specify these however since they won't be supported on
" every system.
"
" Note, not all of Vim's supported encodings have a charset to use.
"
" Names in this list are from:
"   http://www.iana.org/assignments/character-sets
" g:tohtml#encoding_to_charset: {{{
let g:tohtml#encoding_to_charset = {
      \ 'latin1' : 'ISO-8859-1',
      \ 'iso-8859-2' : 'ISO-8859-2',
      \ 'iso-8859-3' : 'ISO-8859-3',
      \ 'iso-8859-4' : 'ISO-8859-4',
      \ 'iso-8859-5' : 'ISO-8859-5',
      \ 'iso-8859-6' : 'ISO-8859-6',
      \ 'iso-8859-7' : 'ISO-8859-7',
      \ 'iso-8859-8' : 'ISO-8859-8',
      \ 'iso-8859-9' : 'ISO-8859-9',
      \ 'iso-8859-10' : '',
      \ 'iso-8859-13' : 'ISO-8859-13',
      \ 'iso-8859-14' : '',
      \ 'iso-8859-15' : 'ISO-8859-15',
      \ 'koi8-r' : 'KOI8-R',
      \ 'koi8-u' : 'KOI8-U',
      \ 'macroman' : 'macintosh',
      \ 'cp437' : '',
      \ 'cp775' : '',
      \ 'cp850' : '',
      \ 'cp852' : '',
      \ 'cp855' : '',
      \ 'cp857' : '',
      \ 'cp860' : '',
      \ 'cp861' : '',
      \ 'cp862' : '',
      \ 'cp863' : '',
      \ 'cp865' : '',
      \ 'cp866' : 'IBM866',
      \ 'cp869' : '',
      \ 'cp874' : '',
      \ 'cp1250' : 'windows-1250',
      \ 'cp1251' : 'windows-1251',
      \ 'cp1253' : 'windows-1253',
      \ 'cp1254' : 'windows-1254',
      \ 'cp1255' : 'windows-1255',
      \ 'cp1256' : 'windows-1256',
      \ 'cp1257' : 'windows-1257',
      \ 'cp1258' : 'windows-1258',
      \ 'euc-jp' : 'EUC-JP',
      \ 'sjis' : 'Shift_JIS',
      \ 'cp932' : 'Shift_JIS',
      \ 'cp949' : '',
      \ 'euc-kr' : 'EUC-KR',
      \ 'cp936' : 'GBK',
      \ 'euc-cn' : 'GB2312',
      \ 'big5' : 'Big5',
      \ 'cp950' : 'Big5',
      \ 'utf-8' : 'UTF-8',
      \ 'ucs-2' : 'UTF-8',
      \ 'ucs-2le' : 'UTF-8',
      \ 'utf-16' : 'UTF-8',
      \ 'utf-16le' : 'UTF-8',
      \ 'ucs-4' : 'UTF-8',
      \ 'ucs-4le' : 'UTF-8',
      \ }
lockvar g:tohtml#encoding_to_charset
" Notes:
"   1. All UCS/UTF are converted to UTF-8 because it is much better supported
"   2. Any blank spaces are there because Vim supports it but at least one major
"      web browser does not according to http://wiki.whatwg.org/wiki/Web_Encodings.
" }}}

" Only automatically find encodings supported natively by Vim, let the user
" specify the encoding if it's not natively supported. This function is only
" used when the user specifies the charset, they better know what they are
" doing!
"
" Names in this list are from:
"   http://www.iana.org/assignments/character-sets
" g:tohtml#charset_to_encoding: {{{
let g:tohtml#charset_to_encoding = {
      \ 'iso_8859-1:1987' : 'latin1',
      \ 'iso-ir-100' : 'latin1',
      \ 'iso_8859-1' : 'latin1',
      \ 'iso-8859-1' : 'latin1',
      \ 'latin1' : 'latin1',
      \ 'l1' : 'latin1',
      \ 'ibm819' : 'latin1',
      \ 'cp819' : 'latin1',
      \ 'csisolatin1' : 'latin1',
      \ 'iso_8859-2:1987' : 'iso-8859-2',
      \ 'iso-ir-101' : 'iso-8859-2',
      \ 'iso_8859-2' : 'iso-8859-2',
      \ 'iso-8859-2' : 'iso-8859-2',
      \ 'latin2' : 'iso-8859-2',
      \ 'l2' : 'iso-8859-2',
      \ 'csisolatin2' : 'iso-8859-2',
      \ 'iso_8859-3:1988' : 'iso-8859-3',
      \ 'iso-ir-109' : 'iso-8859-3',
      \ 'iso_8859-3' : 'iso-8859-3',
      \ 'iso-8859-3' : 'iso-8859-3',
      \ 'latin3' : 'iso-8859-3',
      \ 'l3' : 'iso-8859-3',
      \ 'csisolatin3' : 'iso-8859-3',
      \ 'iso_8859-4:1988' : 'iso-8859-4',
      \ 'iso-ir-110' : 'iso-8859-4',
      \ 'iso_8859-4' : 'iso-8859-4',
      \ 'iso-8859-4' : 'iso-8859-4',
      \ 'latin4' : 'iso-8859-4',
      \ 'l4' : 'iso-8859-4',
      \ 'csisolatin4' : 'iso-8859-4',
      \ 'iso_8859-5:1988' : 'iso-8859-5',
      \ 'iso-ir-144' : 'iso-8859-5',
      \ 'iso_8859-5' : 'iso-8859-5',
      \ 'iso-8859-5' : 'iso-8859-5',
      \ 'cyrillic' : 'iso-8859-5',
      \ 'csisolatincyrillic' : 'iso-8859-5',
      \ 'iso_8859-6:1987' : 'iso-8859-6',
      \ 'iso-ir-127' : 'iso-8859-6',
      \ 'iso_8859-6' : 'iso-8859-6',
      \ 'iso-8859-6' : 'iso-8859-6',
      \ 'ecma-114' : 'iso-8859-6',
      \ 'asmo-708' : 'iso-8859-6',
      \ 'arabic' : 'iso-8859-6',
      \ 'csisolatinarabic' : 'iso-8859-6',
      \ 'iso_8859-7:1987' : 'iso-8859-7',
      \ 'iso-ir-126' : 'iso-8859-7',
      \ 'iso_8859-7' : 'iso-8859-7',
      \ 'iso-8859-7' : 'iso-8859-7',
      \ 'elot_928' : 'iso-8859-7',
      \ 'ecma-118' : 'iso-8859-7',
      \ 'greek' : 'iso-8859-7',
      \ 'greek8' : 'iso-8859-7',
      \ 'csisolatingreek' : 'iso-8859-7',
      \ 'iso_8859-8:1988' : 'iso-8859-8',
      \ 'iso-ir-138' : 'iso-8859-8',
      \ 'iso_8859-8' : 'iso-8859-8',
      \ 'iso-8859-8' : 'iso-8859-8',
      \ 'hebrew' : 'iso-8859-8',
      \ 'csisolatinhebrew' : 'iso-8859-8',
      \ 'iso_8859-9:1989' : 'iso-8859-9',
      \ 'iso-ir-148' : 'iso-8859-9',
      \ 'iso_8859-9' : 'iso-8859-9',
      \ 'iso-8859-9' : 'iso-8859-9',
      \ 'latin5' : 'iso-8859-9',
      \ 'l5' : 'iso-8859-9',
      \ 'csisolatin5' : 'iso-8859-9',
      \ 'iso-8859-10' : 'iso-8859-10',
      \ 'iso-ir-157' : 'iso-8859-10',
      \ 'l6' : 'iso-8859-10',
      \ 'iso_8859-10:1992' : 'iso-8859-10',
      \ 'csisolatin6' : 'iso-8859-10',
      \ 'latin6' : 'iso-8859-10',
      \ 'iso-8859-13' : 'iso-8859-13',
      \ 'iso-8859-14' : 'iso-8859-14',
      \ 'iso-ir-199' : 'iso-8859-14',
      \ 'iso_8859-14:1998' : 'iso-8859-14',
      \ 'iso_8859-14' : 'iso-8859-14',
      \ 'latin8' : 'iso-8859-14',
      \ 'iso-celtic' : 'iso-8859-14',
      \ 'l8' : 'iso-8859-14',
      \ 'iso-8859-15' : 'iso-8859-15',
      \ 'iso_8859-15' : 'iso-8859-15',
      \ 'latin-9' : 'iso-8859-15',
      \ 'koi8-r' : 'koi8-r',
      \ 'cskoi8r' : 'koi8-r',
      \ 'koi8-u' : 'koi8-u',
      \ 'macintosh' : 'macroman',
      \ 'mac' : 'macroman',
      \ 'csmacintosh' : 'macroman',
      \ 'ibm437' : 'cp437',
      \ 'cp437' : 'cp437',
      \ '437' : 'cp437',
      \ 'cspc8codepage437' : 'cp437',
      \ 'ibm775' : 'cp775',
      \ 'cp775' : 'cp775',
      \ 'cspc775baltic' : 'cp775',
      \ 'ibm850' : 'cp850',
      \ 'cp850' : 'cp850',
      \ '850' : 'cp850',
      \ 'cspc850multilingual' : 'cp850',
      \ 'ibm852' : 'cp852',
      \ 'cp852' : 'cp852',
      \ '852' : 'cp852',
      \ 'cspcp852' : 'cp852',
      \ 'ibm855' : 'cp855',
      \ 'cp855' : 'cp855',
      \ '855' : 'cp855',
      \ 'csibm855' : 'cp855',
      \ 'ibm857' : 'cp857',
      \ 'cp857' : 'cp857',
      \ '857' : 'cp857',
      \ 'csibm857' : 'cp857',
      \ 'ibm860' : 'cp860',
      \ 'cp860' : 'cp860',
      \ '860' : 'cp860',
      \ 'csibm860' : 'cp860',
      \ 'ibm861' : 'cp861',
      \ 'cp861' : 'cp861',
      \ '861' : 'cp861',
      \ 'cp-is' : 'cp861',
      \ 'csibm861' : 'cp861',
      \ 'ibm862' : 'cp862',
      \ 'cp862' : 'cp862',
      \ '862' : 'cp862',
      \ 'cspc862latinhebrew' : 'cp862',
      \ 'ibm863' : 'cp863',
      \ 'cp863' : 'cp863',
      \ '863' : 'cp863',
      \ 'csibm863' : 'cp863',
      \ 'ibm865' : 'cp865',
      \ 'cp865' : 'cp865',
      \ '865' : 'cp865',
      \ 'csibm865' : 'cp865',
      \ 'ibm866' : 'cp866',
      \ 'cp866' : 'cp866',
      \ '866' : 'cp866',
      \ 'csibm866' : 'cp866',
      \ 'ibm869' : 'cp869',
      \ 'cp869' : 'cp869',
      \ '869' : 'cp869',
      \ 'cp-gr' : 'cp869',
      \ 'csibm869' : 'cp869',
      \ 'windows-1250' : 'cp1250',
      \ 'windows-1251' : 'cp1251',
      \ 'windows-1253' : 'cp1253',
      \ 'windows-1254' : 'cp1254',
      \ 'windows-1255' : 'cp1255',
      \ 'windows-1256' : 'cp1256',
      \ 'windows-1257' : 'cp1257',
      \ 'windows-1258' : 'cp1258',
      \ 'extended_unix_code_packed_format_for_japanese' : 'euc-jp',
      \ 'cseucpkdfmtjapanese' : 'euc-jp',
      \ 'euc-jp' : 'euc-jp',
      \ 'shift_jis' : 'sjis',
      \ 'ms_kanji' : 'sjis',
      \ 'sjis' : 'sjis',
      \ 'csshiftjis' : 'sjis',
      \ 'ibm-thai' : 'cp874',
      \ 'csibmthai' : 'cp874',
      \ 'ks_c_5601-1987' : 'cp949',
      \ 'iso-ir-149' : 'cp949',
      \ 'ks_c_5601-1989' : 'cp949',
      \ 'ksc_5601' : 'cp949',
      \ 'korean' : 'cp949',
      \ 'csksc56011987' : 'cp949',
      \ 'euc-kr' : 'euc-kr',
      \ 'cseuckr' : 'euc-kr',
      \ 'gbk' : 'cp936',
      \ 'cp936' : 'cp936',
      \ 'ms936' : 'cp936',
      \ 'windows-936' : 'cp936',
      \ 'gb_2312-80' : 'euc-cn',
      \ 'iso-ir-58' : 'euc-cn',
      \ 'chinese' : 'euc-cn',
      \ 'csiso58gb231280' : 'euc-cn',
      \ 'big5' : 'big5',
      \ 'csbig5' : 'big5',
      \ 'utf-8' : 'utf-8',
      \ 'iso-10646-ucs-2' : 'ucs-2',
      \ 'csunicode' : 'ucs-2',
      \ 'utf-16' : 'utf-16',
      \ 'utf-16be' : 'utf-16',
      \ 'utf-16le' : 'utf-16le',
      \ 'utf-32' : 'ucs-4',
      \ 'utf-32be' : 'ucs-4',
      \ 'utf-32le' : 'ucs-4le',
      \ 'iso-10646-ucs-4' : 'ucs-4',
      \ 'csucs4' : 'ucs-4'
      \ }
lockvar g:tohtml#charset_to_encoding
"}}}

func! tohtml#Convert2HTML(line1, line2) "{{{
  let s:settings = tohtml#GetUserSettings()

  if !&diff || s:settings.diff_one_file "{{{
    if a:line2 >= a:line1
      let g:html_start_line = a:line1
      let g:html_end_line = a:line2
    else
      let g:html_start_line = a:line2
      let g:html_end_line = a:line1
    endif
    runtime syntax/2html.vim "}}}
  else "{{{
    let win_list = []
    let buf_list = []
    windo | if &diff | call add(win_list, winbufnr(0)) | endif
    let s:settings.whole_filler = 1
    let g:html_diff_win_num = 0
    for window in win_list
      " switch to the next buffer to convert
      exe ":" . bufwinnr(window) . "wincmd w"

      " figure out whether current charset and encoding will work, if not
      " default to UTF-8
      if !exists('g:html_use_encoding') &&
	    \ (((&l:fileencoding=='' || (&l:buftype!='' && &l:buftype!=?'help'))
	    \      && &encoding!=?s:settings.vim_encoding)
	    \ || &l:fileencoding!='' && &l:fileencoding!=?s:settings.vim_encoding)
	echohl WarningMsg
	echomsg "TOhtml: mismatched file encodings in Diff buffers, using UTF-8"
	echohl None
	let s:settings.vim_encoding = 'utf-8'
	let s:settings.encoding = 'UTF-8'
      endif

      " set up for diff-mode conversion
      let g:html_start_line = 1
      let g:html_end_line = line('$')
      let g:html_diff_win_num += 1

      " convert this file
      runtime syntax/2html.vim

      " remember the HTML buffer for later combination
      call add(buf_list, bufnr('%'))
    endfor
    unlet g:html_diff_win_num
    call tohtml#Diff2HTML(win_list, buf_list)
  endif "}}}

  unlet g:html_start_line
  unlet g:html_end_line
  unlet s:settings
endfunc "}}}

func! tohtml#Diff2HTML(win_list, buf_list) "{{{
  let xml_line = ""
  let tag_close = '>'

  let s:old_paste = &paste
  set paste
  let s:old_magic = &magic
  set magic

  if s:settings.use_xhtml
    if s:settings.encoding != ""
      let xml_line = "<?xml version=\"1.0\" encoding=\"" . s:settings.encoding . "\"?>"
    else
      let xml_line = "<?xml version=\"1.0\"?>"
    endif
    let tag_close = ' />'
  endif

  let style = [s:settings.use_xhtml ? "" : '-->']
  let body_line = ''

  let html = []
  if s:settings.use_xhtml
    call add(html, xml_line)
  endif
  if s:settings.use_xhtml
    call add(html, "<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">")
    call add(html, '<html xmlns="http://www.w3.org/1999/xhtml">')
  elseif s:settings.use_css && !s:settings.no_pre
    call add(html, "<!DOCTYPE HTML PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html4/strict.dtd\">")
    call add(html, '<html>')
  else
    call add(html, '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"')
    call add(html, '  "http://www.w3.org/TR/html4/loose.dtd">')
    call add(html, '<html>')
  endif
  call add(html, '<head>')

  " include encoding as close to the top as possible, but only if not already
  " contained in XML information
  if s:settings.encoding != "" && !s:settings.use_xhtml
    call add(html, "<meta http-equiv=\"content-type\" content=\"text/html; charset=" . s:settings.encoding . '"' . tag_close)
  endif

  call add(html, '<title>diff</title>')
  call add(html, '<meta name="Generator" content="Vim/'.v:version/100.'.'.v:version%100.'"'.tag_close)
  call add(html, '<meta name="plugin-version" content="'.g:loaded_2html_plugin.'"'.tag_close)
  call add(html, '<meta name="settings" content="'.
	\ join(filter(keys(s:settings),'s:settings[v:val]'),',').
	\ ',prevent_copy='.s:settings.prevent_copy.
	\ '"'.tag_close)
  call add(html, '<meta name="colorscheme" content="'.
	\ (exists('g:colors_name')
	\ ? g:colors_name
	\ : 'none'). '"'.tag_close)

  call add(html, '</head>')
  let body_line_num = len(html)
  if !empty(s:settings.prevent_copy)
    call add(html, "<body onload='FixCharWidth();".(s:settings.line_ids ? " JumpToLine();" : "")."'>")
    call add(html, "<!-- hidden divs used by javascript to get the width of a char -->")
    call add(html, "<div id='oneCharWidth'>0</div>")
    call add(html, "<div id='oneInputWidth'><input size='1' value='0'".tag_close."</div>")
    call add(html, "<div id='oneEmWidth' style='width: 1em;'></div>")
  else
    call add(html, '<body'.(s:settings.line_ids ? ' onload="JumpToLine();"' : '').'>')
  endif
  call add(html, "<table border='1' width='100%' id='vimCodeElement".s:settings.id_suffix."'>")

  call add(html, '<tr>')
  for buf in a:win_list
    call add(html, '<th>'.bufname(buf).'</th>')
  endfor
  call add(html, '</tr><tr>')

  let diff_style_start = 0
  let insert_index = 0

  for buf in a:buf_list
    let temp = []
    exe bufwinnr(buf) . 'wincmd w'

    " If text is folded because of user foldmethod settings, etc. we don't want
    " to act on everything in a fold by mistake.
    setlocal nofoldenable

    " When not using CSS or when using xhtml, the <body> line can be important.
    " Assume it will be the same for all buffers and grab it from the first
    " buffer. Similarly, need to grab the body end line as well.
    if body_line == ''
      1
      call search('<body')
      let body_line = getline('.')
      $
      call search('</body>', 'b')
      let s:body_end_line = getline('.')
    endif

    " Grab the style information. Some of this will be duplicated so only insert
    " it if it's not already there. {{{
    1
    let style_start = search('^<style type="text/css">')
    1
    let style_end = search('^</style>')
    if style_start > 0 && style_end > 0
      let buf_styles = getline(style_start + 1, style_end - 1)
      for a_style in buf_styles
	if index(style, a_style) == -1
	  if diff_style_start == 0
	    if a_style =~ '\<Diff\(Change\|Text\|Add\|Delete\)'
	      let diff_style_start = len(style)-1
	    endif
	  endif
	  call insert(style, a_style, insert_index)
	  let insert_index += 1
	endif
      endfor
    endif " }}}

    " everything new will get added before the diff styles so diff highlight
    " properly overrides normal highlight
    if diff_style_start != 0
      let insert_index = diff_style_start
    endif

    " Delete those parts that are not needed so we can include the rest into the
    " resulting table.
    1,/^<body.*\%(\n<!--.*-->\_s\+.*id='oneCharWidth'.*\_s\+.*id='oneInputWidth'.*\_s\+.*id='oneEmWidth'\)\?\zs/d_
    $
    ?</body>?,$d_
    let temp = getline(1,'$')
    " clean out id on the main content container because we already set it on
    " the table
    let temp[0] = substitute(temp[0], " id='vimCodeElement[^']*'", "", "")
    " undo deletion of start and end part
    " so we can later save the file as valid html
    " TODO: restore using grabbed lines if undolevel is 1?
    normal! 2u
    if s:settings.use_css
      call add(html, '<td valign="top"><div>')
    elseif s:settings.use_xhtml
      call add(html, '<td nowrap="nowrap" valign="top"><div>')
    else
      call add(html, '<td nowrap valign="top"><div>')
    endif
    let html += temp
    call add(html, '</div></td>')

    " Close this buffer
    " TODO: the comment above says we're going to allow saving the file
    " later...but here we discard it?
    quit!
  endfor

  let html[body_line_num] = body_line

  call add(html, '</tr>')
  call add(html, '</table>')
  call add(html, s:body_end_line)
  call add(html, '</html>')

  " The generated HTML is admittedly ugly and takes a LONG time to fold.
  " Make sure the user doesn't do syntax folding when loading a generated file,
  " using a modeline.
  call add(html, '<!-- vim: set foldmethod=manual : -->')

  let i = 1
  let name = "Diff" . (s:settings.use_xhtml ? ".xhtml" : ".html")
  " Find an unused file name if current file name is already in use
  while filereadable(name)
    let name = substitute(name, '\d*\.x\?html$', '', '') . i . '.' . fnamemodify(copy(name), ":t:e")
    let i += 1
  endwhile
  exe "topleft new " . name
  setlocal modifiable

  " just in case some user autocmd creates content in the new buffer, make sure
  " it is empty before proceeding
  %d

  " set the fileencoding to match the charset we'll be using
  let &l:fileencoding=s:settings.vim_encoding

  " According to http://www.w3.org/TR/html4/charset.html#doc-char-set, the byte
  " order mark is highly recommend on the web when using multibyte encodings. But,
  " it is not a good idea to include it on UTF-8 files. Otherwise, let Vim
  " determine when it is actually inserted.
  if s:settings.vim_encoding == 'utf-8'
    setlocal nobomb
  else
    setlocal bomb
  endif

  call append(0, html)

  if len(style) > 0
    1
    let style_start = search('^</head>')-1

    " add required javascript in reverse order so we can just call append again
    " and again without adjusting {{{

    " insert script closing tag
    call append(style_start, [
	  \ '',
	  \ s:settings.use_xhtml ? '//]]>' : '-->',
	  \ "</script>"
	  \ ])

    " insert script which corrects the size of small input elements in
    " prevent_copy mode. See 2html.vim for details on why this is needed and how
    " it works.
    if !empty(s:settings.prevent_copy)
      call append(style_start, [
	    \ '',
	    \ '/* simulate a "ch" unit by asking the browser how big a zero character is */',
	    \ 'function FixCharWidth() {',
	    \ '  /* get the hidden element which gives the width of a single character */',
	    \ '  var goodWidth = document.getElementById("oneCharWidth").clientWidth;',
	    \ '  /* get all input elements, we''ll filter on class later */',
	    \ '  var inputTags = document.getElementsByTagName("input");',
	    \ '  var ratio = 5;',
	    \ '  var inputWidth = document.getElementById("oneInputWidth").clientWidth;',
	    \ '  var emWidth = document.getElementById("oneEmWidth").clientWidth;',
	    \ '  if (inputWidth > goodWidth) {',
	    \ '    while (ratio < 100*goodWidth/emWidth && ratio < 100) {',
	    \ '      ratio += 5;',
	    \ '    }',
	    \ '    document.getElementById("vimCodeElement'.s:settings.id_suffix.'").className = "em"+ratio;',
	    \ '  }',
	    \ '}'
	    \ ])
    endif
    "
    " insert javascript to get IDs from line numbers, and to open a fold before
    " jumping to any lines contained therein
    call append(style_start, [
	  \ "  /* Always jump to new location even if the line was hidden inside a fold, or",
	  \ "   * we corrected the raw number to a line ID.",
	  \ "   */",
	  \ "  if (lineElem) {",
	  \ "    lineElem.scrollIntoView(true);",
	  \ "  }",
	  \ "  return true;",
	  \ "}",
	  \ "if ('onhashchange' in window) {",
	  \ "  window.onhashchange = JumpToLine;",
	  \ "}"
	  \ ])
    if s:settings.dynamic_folds
      call append(style_start, [
	    \ "",
	    \ "  /* navigate upwards in the DOM tree to open all folds containing the line */",
	    \ "  var node = lineElem;",
	    \ "  while (node && node.id != 'vimCodeElement".s:settings.id_suffix."')",
	    \ "  {",
	    \ "    if (node.className == 'closed-fold')",
	    \ "    {",
	    \ "      /* toggle open the fold ID (remove window ID) */",
	    \ "      toggleFold(node.id.substr(4));",
	    \ "    }",
	    \ "    node = node.parentNode;",
	    \ "  }",
	    \ ])
    endif
    call append(style_start, [
	  \ "",
	  \ "/* function to open any folds containing a jumped-to line before jumping to it */",
	  \ "function JumpToLine()",
	  \ "{",
	  \ "  var lineNum;",
	  \ "  lineNum = window.location.hash;",
	  \ "  lineNum = lineNum.substr(1); /* strip off '#' */",
	  \ "",
	  \ "  if (lineNum.indexOf('L') == -1) {",
	  \ "    lineNum = 'L'+lineNum;",
	  \ "  }",
	  \ "  if (lineNum.indexOf('W') == -1) {",
	  \ "    lineNum = 'W1'+lineNum;",
	  \ "  }",
	  \ "  lineElem = document.getElementById(lineNum);"
	  \ ])

    " Insert javascript to toggle matching folds open and closed in all windows,
    " if dynamic folding is active.
    if s:settings.dynamic_folds
      call append(style_start, [
	    \  "  function toggleFold(objID)",
	    \  "  {",
	    \  "    for (win_num = 1; win_num <= ".len(a:buf_list)."; win_num++)",
	    \  "    {",
	    \  "      var fold;",
	    \  '      fold = document.getElementById("win"+win_num+objID);',
	    \  "      if(fold.className == 'closed-fold')",
	    \  "      {",
	    \  "        fold.className = 'open-fold';",
	    \  "      }",
	    \  "      else if (fold.className == 'open-fold')",
	    \  "      {",
	    \  "        fold.className = 'closed-fold';",
	    \  "      }",
	    \  "    }",
	    \  "  }",
	    \ ])
    endif

    " insert script tag; javascript is always needed for the line number
    " normalization for URL hashes
    call append(style_start, [
	  \ "<script type='text/javascript'>",
	  \ s:settings.use_xhtml ? '//<![CDATA[' : "<!--"])

    " Insert styles from all the generated html documents and additional styles
    " for the table-based layout of the side-by-side diff. The diff should take
    " up the full browser window (but not more), and be static in size,
    " horizontally scrollable when the lines are too long. Otherwise, the diff
    " is pretty useless for really long lines. {{{
    if s:settings.use_css
      call append(style_start,
	    \ ['<style type="text/css">']+
	    \ style+
	    \ [ s:settings.use_xhtml ? '' : '<!--',
	    \   'table { table-layout: fixed; }',
	    \   'html, body, table, tbody { width: 100%; margin: 0; padding: 0; }',
	    \   'th, td { width: '.printf("%.1f",100.0/len(a:win_list)).'%; }',
	    \   'td div { overflow: auto; }',
	    \   s:settings.use_xhtml ? '' : '-->',
	    \   '</style>'
	    \])
    endif "}}}
  endif

  let &paste = s:old_paste
  let &magic = s:old_magic
endfunc "}}}

" Gets a single user option and sets it in the passed-in Dict, or gives it the
" default value if the option doesn't actually exist.
func! tohtml#GetOption(settings, option, default) "{{{
  if exists('g:html_'.a:option)
    let a:settings[a:option] = g:html_{a:option}
  else
    let a:settings[a:option] = a:default
  endif
endfunc "}}}

" returns a Dict containing the values of all user options for 2html, including
" default values for those not given an explicit value by the user. Discards the
" html_ prefix of the option for nicer looking code.
func! tohtml#GetUserSettings() "{{{
  if exists('s:settings')
    " just restore the known options if we've already retrieved them
    return s:settings
  else
    " otherwise figure out which options are set
    let user_settings = {}

    " Define the correct option if the old option name exists and we haven't
    " already defined the correct one. Maybe I'll put out a warnig message about
    " this sometime and remove the old option entirely at some even later time,
    " but for now just silently accept the old option.
    if exists('g:use_xhtml') && !exists("g:html_use_xhtml")
      let g:html_use_xhtml = g:use_xhtml
    endif

    " get current option settings with appropriate defaults {{{
    call tohtml#GetOption(user_settings,    'no_progress', !has("statusline") )
    call tohtml#GetOption(user_settings,  'diff_one_file', 0 )
    call tohtml#GetOption(user_settings,   'number_lines', &number )
    call tohtml#GetOption(user_settings,       'pre_wrap', &wrap )
    call tohtml#GetOption(user_settings,        'use_css', 1 )
    call tohtml#GetOption(user_settings, 'ignore_conceal', 0 )
    call tohtml#GetOption(user_settings, 'ignore_folding', 0 )
    call tohtml#GetOption(user_settings,  'dynamic_folds', 0 )
    call tohtml#GetOption(user_settings,  'no_foldcolumn', user_settings.ignore_folding)
    call tohtml#GetOption(user_settings,   'hover_unfold', 0 )
    call tohtml#GetOption(user_settings,         'no_pre', 0 )
    call tohtml#GetOption(user_settings,     'no_invalid', 0 )
    call tohtml#GetOption(user_settings,   'whole_filler', 0 )
    call tohtml#GetOption(user_settings,      'use_xhtml', 0 )
    call tohtml#GetOption(user_settings,       'line_ids', user_settings.number_lines )
    " }}}
    
    " override those settings that need it {{{

    " hover opening implies dynamic folding
    if user_settings.hover_unfold
      let user_settings.dynamic_folds = 1
    endif

    " ignore folding overrides dynamic folding
    if user_settings.ignore_folding && user_settings.dynamic_folds
      let user_settings.dynamic_folds = 0
      let user_settings.hover_unfold = 0
    endif

    " dynamic folding with no foldcolumn implies hover opens
    if user_settings.dynamic_folds && user_settings.no_foldcolumn
      let user_settings.hover_unfold = 1
    endif

    " dynamic folding implies css
    if user_settings.dynamic_folds
      let user_settings.use_css = 1
    else
      let user_settings.no_foldcolumn = 1 " won't do anything but for consistency and for the test suite
    endif

    " if we're not using CSS we cannot use a pre section because <font> tags
    " aren't allowed inside a <pre> block
    if !user_settings.use_css
      let user_settings.no_pre = 1
    endif

    " pre_wrap doesn't do anything if not using pre or not using CSS
    if user_settings.no_pre || !user_settings.use_css
      let user_settings.pre_wrap=0
    endif
    "}}}

    " set up expand_tabs option after all the overrides so we know the
    " appropriate defaults {{{
    if user_settings.no_pre == 0
      call tohtml#GetOption(user_settings,
	    \ 'expand_tabs',
	    \ &expandtab || &ts != 8 || user_settings.number_lines ||
	    \   (user_settings.dynamic_folds && !user_settings.no_foldcolumn))
    else
      let user_settings.expand_tabs = 1
    endif
    " }}}

    " textual options
    if exists("g:html_use_encoding") "{{{
      " user specified the desired MIME charset, figure out proper
      " 'fileencoding' from it or warn the user if we cannot
      let user_settings.encoding = g:html_use_encoding
      let user_settings.vim_encoding = tohtml#EncodingFromCharset(g:html_use_encoding)
      if user_settings.vim_encoding == ''
	echohl WarningMsg
	echomsg "TOhtml: file encoding for"
	      \ g:html_use_encoding
	      \ "unknown, please set 'fileencoding'"
	echohl None
      endif
    else
      " Figure out proper MIME charset from 'fileencoding' if possible
      if &l:fileencoding != '' 
	" If the buffer is not a "normal" type, the 'fileencoding' value may not
	" be trusted; since the buffer should not be written the fileencoding is
	" not intended to be used.
	if &l:buftype=='' || &l:buftype==?'help'
	  let user_settings.vim_encoding = &l:fileencoding
	  call tohtml#CharsetFromEncoding(user_settings)
	else
	  let user_settings.encoding = '' " trigger detection using &encoding
	endif
      endif

      " else from 'encoding' if possible
      if &l:fileencoding == '' || user_settings.encoding == ''
	let user_settings.vim_encoding = &encoding
	call tohtml#CharsetFromEncoding(user_settings)
      endif

      " else default to UTF-8 and warn user
      if user_settings.encoding == ''
	let user_settings.vim_encoding = 'utf-8'
	let user_settings.encoding = 'UTF-8'
	echohl WarningMsg
	echomsg "TOhtml: couldn't determine MIME charset, using UTF-8"
	echohl None
      endif
    endif "}}}

    " Default to making nothing uncopyable, because we default to
    " not-standards way of doing things, and also because Microsoft Word and
    " others paste the <input> elements anyway.
    "
    " html_prevent_copy only has an effect when using CSS.
    "
    " All options:
    "	  f - fold column
    "	  n - line numbers (also within fold text)
    "	  t - fold text
    "	  d - diff filler
    "	  c - concealed text (reserved future)
    "	  l - listchars (reserved possible future)
    "	  s - signs (reserved possible future)
    "
    " Normal text is always selectable.
    let user_settings.prevent_copy = ""
    if user_settings.use_css
      if exists("g:html_prevent_copy")
	if user_settings.dynamic_folds && !user_settings.no_foldcolumn && g:html_prevent_copy =~# 'f'
	  let user_settings.prevent_copy .= 'f'
	endif
	if user_settings.number_lines && g:html_prevent_copy =~# 'n'
	  let user_settings.prevent_copy .= 'n'
	endif
	if &diff && g:html_prevent_copy =~# 'd'
	  let user_settings.prevent_copy .= 'd'
	endif
	if !user_settings.ignore_folding && g:html_prevent_copy =~# 't'
	  let user_settings.prevent_copy .= 't'
	endif
      else
	let user_settings.prevent_copy = ""
      endif
    endif
    if empty(user_settings.prevent_copy)
      let user_settings.no_invalid = 0
    endif

    if exists('g:html_id_expr')
      let user_settings.id_suffix = eval(g:html_id_expr)
      if user_settings.id_suffix !~ '^[-_:.A-Za-z0-9]*$'
	echohl WarningMsg
	echomsg '2html: g:html_id_expr evaluated to invalid string for HTML id attributes'
	echomsg '2html: Omitting user-specified suffix'
	echohl None
	sleep 3
	let user_settings.id_suffix=""
      endif
    else
      let user_settings.id_suffix=""
    endif

    " TODO: font

    return user_settings
  endif
endfunc "}}}

" get the proper HTML charset name from a Vim encoding option.
function! tohtml#CharsetFromEncoding(settings) "{{{
  let l:vim_encoding = a:settings.vim_encoding
  if exists('g:html_charset_override') && has_key(g:html_charset_override, l:vim_encoding)
    let a:settings.encoding = g:html_charset_override[l:vim_encoding]
  else
    if l:vim_encoding =~ '^8bit\|^2byte'
      " 8bit- and 2byte- prefixes are to indicate encodings available on the
      " system that Vim will convert with iconv(), look up just the encoding name,
      " not Vim's prefix.
      let l:vim_encoding = substitute(l:vim_encoding, '^8bit-\|^2byte-', '', '')
    endif
    if has_key(g:tohtml#encoding_to_charset, l:vim_encoding)
      let a:settings.encoding = g:tohtml#encoding_to_charset[l:vim_encoding]
    else
      let a:settings.encoding = ""
    endif
  endif
  if a:settings.encoding != ""
    let l:vim_encoding = tohtml#EncodingFromCharset(a:settings.encoding)
    if l:vim_encoding != ""
      " if the Vim encoding to HTML encoding conversion is set up (by default or
      " by the user) to convert to a different encoding, we need to also change
      " the Vim encoding of the new buffer
      let a:settings.vim_encoding = l:vim_encoding
    endif
  endif
endfun "}}}

" Get the proper Vim encoding option setting from an HTML charset name.
function! tohtml#EncodingFromCharset(encoding) "{{{
  if exists('g:html_encoding_override') && has_key(g:html_encoding_override, a:encoding)
    return g:html_encoding_override[a:encoding]
  elseif has_key(g:tohtml#charset_to_encoding, tolower(a:encoding))
    return g:tohtml#charset_to_encoding[tolower(a:encoding)]
  else
    return ""
  endif
endfun "}}}

let &cpo = s:cpo_sav
unlet s:cpo_sav

" Make sure any patches will probably use consistent indent
"   vim: ts=8 sw=2 sts=2 noet fdm=marker
                                                                                                                                                                                 usr/share/vim/vim74/autoload/vimball.vim                                                            0100644 0000000 0000000 00000057415 13050207306 016704  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        " vimball.vim : construct a file containing both paths and files
" Author:	Charles E. Campbell, Jr.
" Date:		Jan 17, 2012
" Version:	35
" GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
" Copyright: (c) 2004-2011 by Charles E. Campbell, Jr.
"            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
"            (see |copyright|) except use "Vimball" instead of "Vim".
"            No warranty, express or implied.
"  *** ***   Use At-Your-Own-Risk!   *** ***

" ---------------------------------------------------------------------
"  Load Once: {{{1
if &cp || exists("g:loaded_vimball")
 finish
endif
let g:loaded_vimball = "v35"
if v:version < 702
 echohl WarningMsg
 echo "***warning*** this version of vimball needs vim 7.2"
 echohl Normal
 finish
endif
let s:keepcpo= &cpo
set cpo&vim
"DechoTabOn

" =====================================================================
" Constants: {{{1
if !exists("s:USAGE")
 let s:USAGE   = 0
 let s:WARNING = 1
 let s:ERROR   = 2

 " determine if cygwin is in use or not
 if !exists("g:netrw_cygwin")
  if has("win32") || has("win95") || has("win64") || has("win16")
   if &shell =~ '\%(\<bash\>\|\<zsh\>\)\%(\.exe\)\=$'
    let g:netrw_cygwin= 1
   else
    let g:netrw_cygwin= 0
   endif
  else
   let g:netrw_cygwin= 0
  endif
 endif

 " set up g:vimball_mkdir if the mkdir() call isn't defined
 if !exists("*mkdir")
  if exists("g:netrw_local_mkdir")
   let g:vimball_mkdir= g:netrw_local_mkdir
  elseif executable("mkdir")
   let g:vimball_mkdir= "mkdir"
  elseif executable("makedir")
   let g:vimball_mkdir= "makedir"
  endif
  if !exists(g:vimball_mkdir)
   call vimball#ShowMesg(s:WARNING,"(vimball) g:vimball_mkdir undefined")
  endif
 endif
endif

" =====================================================================
"  Functions: {{{1

" ---------------------------------------------------------------------
" vimball#MkVimball: creates a vimball given a list of paths to files {{{2
" Input:
"     line1,line2: a range of lines containing paths to files to be included in the vimball
"     writelevel : if true, force a write to filename.vmb, even if it exists
"                  (usually accomplished with :MkVimball! ...
"     filename   : base name of file to be created (ie. filename.vmb)
" Output: a filename.vmb using vimball format:
"     path
"     filesize
"     [file]
"     path
"     filesize
"     [file]
fun! vimball#MkVimball(line1,line2,writelevel,...) range
"  call Dfunc("MkVimball(line1=".a:line1." line2=".a:line2." writelevel=".a:writelevel." vimballname<".a:1.">) a:0=".a:0)
  if a:1 =~ '\.vim$' || a:1 =~ '\.txt$'
   let vbname= substitute(a:1,'\.\a\{3}$','.vmb','')
  else
   let vbname= a:1
  endif
  if vbname !~ '\.vmb$'
   let vbname= vbname.'.vmb'
  endif
"  call Decho("vbname<".vbname.">")
  if !a:writelevel && a:1 =~ '[\/]'
   call vimball#ShowMesg(s:ERROR,"(MkVimball) vimball name<".a:1."> should not include slashes; use ! to insist")
"   call Dret("MkVimball : vimball name<".a:1."> should not include slashes")
   return
  endif
  if !a:writelevel && filereadable(vbname)
   call vimball#ShowMesg(s:ERROR,"(MkVimball) file<".vbname."> exists; use ! to insist")
"   call Dret("MkVimball : file<".vbname."> already exists; use ! to insist")
   return
  endif

  " user option bypass
  call vimball#SaveSettings()

  if a:0 >= 2
   " allow user to specify where to get the files
   let home= expand(a:2)
  else
   " use first existing directory from rtp
   let home= vimball#VimballHome()
  endif

  " save current directory
  let curdir = getcwd()
  call s:ChgDir(home)

  " record current tab, initialize while loop index
  let curtabnr = tabpagenr()
  let linenr   = a:line1
"  call Decho("curtabnr=".curtabnr)

  while linenr <= a:line2
   let svfile  = getline(linenr)
"   call Decho("svfile<".svfile.">")
 
   if !filereadable(svfile)
    call vimball#ShowMesg(s:ERROR,"unable to read file<".svfile.">")
	call s:ChgDir(curdir)
	call vimball#RestoreSettings()
"    call Dret("MkVimball")
    return
   endif
 
   " create/switch to mkvimball tab
   if !exists("vbtabnr")
    tabnew
    sil! file Vimball
    let vbtabnr= tabpagenr()
   else
    exe "tabn ".vbtabnr
   endif
 
   let lastline= line("$") + 1
   if lastline == 2 && getline("$") == ""
	call setline(1,'" Vimball Archiver by Charles E. Campbell, Jr., Ph.D.')
	call setline(2,'UseVimball')
	call setline(3,'finish')
	let lastline= line("$") + 1
   endif
   call setline(lastline  ,substitute(svfile,'$','	[[[1',''))
   call setline(lastline+1,0)

   " write the file from the tab
"   call Decho("exe $r ".fnameescape(svfile))
   exe "$r ".fnameescape(svfile)

   call setline(lastline+1,line("$") - lastline - 1)
"   call Decho("lastline=".lastline." line$=".line("$"))

  " restore to normal tab
   exe "tabn ".curtabnr
   let linenr= linenr + 1
  endwhile

  " write the vimball
  exe "tabn ".vbtabnr
  call s:ChgDir(curdir)
  setlocal ff=unix
  if a:writelevel
"   call Decho("exe w! ".fnameescape(vbname))
   exe "w! ".fnameescape(vbname)
  else
"   call Decho("exe w ".fnameescape(vbname))
   exe "w ".fnameescape(vbname)
  endif
"  call Decho("Vimball<".vbname."> created")
  echo "Vimball<".vbname."> created"

  " remove the evidence
  setlocal nomod bh=wipe
  exe "tabn ".curtabnr
  exe "tabc ".vbtabnr

  " restore options
  call vimball#RestoreSettings()

"  call Dret("MkVimball")
endfun

" ---------------------------------------------------------------------
" vimball#Vimball: extract and distribute contents from a vimball {{{2
"                  (invoked the the UseVimball command embedded in 
"                  vimballs' prologue)
fun! vimball#Vimball(really,...)
"  call Dfunc("vimball#Vimball(really=".a:really.") a:0=".a:0)

  if v:version < 701 || (v:version == 701 && !exists('*fnameescape'))
   echoerr "your vim is missing the fnameescape() function (pls upgrade to vim 7.2 or later)"
"   call Dret("vimball#Vimball : needs 7.1 with patch 299 or later")
   return
  endif

  if getline(1) !~ '^" Vimball Archiver'
   echoerr "(Vimball) The current file does not appear to be a Vimball!"
"   call Dret("vimball#Vimball")
   return
  endif

  " set up standard settings
  call vimball#SaveSettings()
  let curtabnr    = tabpagenr()
  let vimballfile = expand("%:tr")

  " set up vimball tab
"  call Decho("setting up vimball tab")
  tabnew
  sil! file Vimball
  let vbtabnr= tabpagenr()
  let didhelp= ""

  " go to vim plugin home
  if a:0 > 0
   " let user specify the directory where the vimball is to be unpacked.
   " If, however, the user did not specify a full path, set the home to be below the current directory
   let home= expand(a:1)
   if has("win32") || has("win95") || has("win64") || has("win16")
	if home !~ '^\a:[/\\]'
	 let home= getcwd().'/'.a:1
	endif
   elseif home !~ '^/'
	let home= getcwd().'/'.a:1
   endif
  else
   let home= vimball#VimballHome()
  endif
"  call Decho("home<".home.">")

  " save current directory and remove older same-named vimball, if any
  let curdir = getcwd()
"  call Decho("home<".home.">")
"  call Decho("curdir<".curdir.">")

  call s:ChgDir(home)
  let s:ok_unablefind= 1
  call vimball#RmVimball(vimballfile)
  unlet s:ok_unablefind

  let linenr  = 4
  let filecnt = 0

  " give title to listing of (extracted) files from Vimball Archive
  if a:really
   echohl Title     | echomsg "Vimball Archive"         | echohl None
  else             
   echohl Title     | echomsg "Vimball Archive Listing" | echohl None
   echohl Statement | echomsg "files would be placed under: ".home | echohl None
  endif

  " apportion vimball contents to various files
"  call Decho("exe tabn ".curtabnr)
  exe "tabn ".curtabnr
"  call Decho("linenr=".linenr." line$=".line("$"))
  while 1 < linenr && linenr < line("$")
   let fname   = substitute(getline(linenr),'\t\[\[\[1$','','')
   let fname   = substitute(fname,'\\','/','g')
   let fsize   = substitute(getline(linenr+1),'^\(\d\+\).\{-}$','\1','')+0
   let fenc    = substitute(getline(linenr+1),'^\d\+\s*\(\S\{-}\)$','\1','')
   let filecnt = filecnt + 1
"   call Decho("fname<".fname."> fsize=".fsize." filecnt=".filecnt. " fenc=".fenc)

   if a:really
    echomsg "extracted <".fname.">: ".fsize." lines"
   else
    echomsg "would extract <".fname.">: ".fsize." lines"
   endif
"   call Decho("using L#".linenr.": will extract file<".fname.">")
"   call Decho("using L#".(linenr+1).": fsize=".fsize)

   " Allow AsNeeded/ directory to take place of plugin/ directory
   " when AsNeeded/filename is filereadable or was present in VimballRecord
   if fname =~ '\<plugin/'
   	let anfname= substitute(fname,'\<plugin/','AsNeeded/','')
	if filereadable(anfname) || (exists("s:VBRstring") && s:VBRstring =~ anfname)
"	 call Decho("using anfname<".anfname."> instead of <".fname.">")
	 let fname= anfname
	endif
   endif

   " make directories if they don't exist yet
   if a:really
"    call Decho("making directories if they don't exist yet (fname<".fname.">)")
    let fnamebuf= substitute(fname,'\\','/','g')
	let dirpath = substitute(home,'\\','/','g')
"	call Decho("init: fnamebuf<".fnamebuf.">")
"	call Decho("init: dirpath <".dirpath.">")
    while fnamebuf =~ '/'
     let dirname  = dirpath."/".substitute(fnamebuf,'/.*$','','')
	 let dirpath  = dirname
     let fnamebuf = substitute(fnamebuf,'^.\{-}/\(.*\)$','\1','')
"	 call Decho("dirname<".dirname.">")
"	 call Decho("dirpath<".dirpath.">")
     if !isdirectory(dirname)
"      call Decho("making <".dirname.">")
      if exists("g:vimball_mkdir")
	   call system(g:vimball_mkdir." ".shellescape(dirname))
      else
       call mkdir(dirname)
      endif
	  call s:RecordInVar(home,"rmdir('".dirname."')")
     endif
    endwhile
   endif
   call s:ChgDir(home)

   " grab specified qty of lines and place into "a" buffer
   " (skip over path/filename and qty-lines)
   let linenr   = linenr + 2
   let lastline = linenr + fsize - 1
"   call Decho("exe ".linenr.",".lastline."yank a")
   " no point in handling a zero-length file
   if lastline >= linenr
    exe "silent ".linenr.",".lastline."yank a"

    " copy "a" buffer into tab
"   call Decho('copy "a buffer into tab#'.vbtabnr)
    exe "tabn ".vbtabnr
    setlocal ma
    sil! %d
    silent put a
    1
    sil! d

    " write tab to file
    if a:really
     let fnamepath= home."/".fname
"    call Decho("exe w! ".fnameescape(fnamepath))
	if fenc != ""
	 exe "silent w! ++enc=".fnameescape(fenc)." ".fnameescape(fnamepath)
	else
	 exe "silent w! ".fnameescape(fnamepath)
	endif
	echo "wrote ".fnameescape(fnamepath)
	call s:RecordInVar(home,"call delete('".fnamepath."')")
    endif

    " return to tab with vimball
"   call Decho("exe tabn ".curtabnr)
    exe "tabn ".curtabnr

    " set up help if its a doc/*.txt file
"   call Decho("didhelp<".didhelp."> fname<".fname.">")
    if a:really && didhelp == "" && fname =~ 'doc/[^/]\+\.\(txt\|..x\)$'
    	let didhelp= substitute(fname,'^\(.*\<doc\)[/\\][^.]*\.\(txt\|..x\)$','\1','')
"	call Decho("didhelp<".didhelp.">")
    endif
   endif

   " update for next file
"   call Decho("update linenr= [linenr=".linenr."] + [fsize=".fsize."] = ".(linenr+fsize))
   let linenr= linenr + fsize
  endwhile

  " set up help
"  call Decho("about to set up help: didhelp<".didhelp.">")
  if didhelp != ""
   let htpath= home."/".didhelp
"   call Decho("exe helptags ".htpath)
   exe "helptags ".fnameescape(htpath)
   echo "did helptags"
  endif

  " make sure a "Press ENTER..." prompt appears to keep the messages showing!
  while filecnt <= &ch
   echomsg " "
   let filecnt= filecnt + 1
  endwhile

  " record actions in <.VimballRecord>
  call s:RecordInFile(home)

  " restore events, delete tab and buffer
  exe "tabn ".vbtabnr
  setlocal nomod bh=wipe
  exe "tabn ".curtabnr
  exe "tabc ".vbtabnr
  call vimball#RestoreSettings()
  call s:ChgDir(curdir)

"  call Dret("vimball#Vimball")
endfun

" ---------------------------------------------------------------------
" vimball#RmVimball: remove any files, remove any directories made by any {{{2
"               previous vimball extraction based on a file of the current
"               name.
"  Usage:  RmVimball  (assume current file is a vimball; remove)
"          RmVimball vimballname
fun! vimball#RmVimball(...)
"  call Dfunc("vimball#RmVimball() a:0=".a:0)
  if exists("g:vimball_norecord")
"   call Dret("vimball#RmVimball : (g:vimball_norecord)")
   return
  endif

  if a:0 == 0
   let curfile= expand("%:tr")
"   call Decho("case a:0=0: curfile<".curfile."> (used expand(%:tr))")
  else
   if a:1 =~ '[\/]'
    call vimball#ShowMesg(s:USAGE,"RmVimball vimballname [path]")
"    call Dret("vimball#RmVimball : suspect a:1<".a:1.">")
    return
   endif
   let curfile= a:1
"   call Decho("case a:0=".a:0.": curfile<".curfile.">")
  endif
  if curfile =~ '\.vmb$'
   let curfile= substitute(curfile,'\.vmb','','')
  elseif curfile =~ '\.vba$'
   let curfile= substitute(curfile,'\.vba','','')
  endif
  if a:0 >= 2
   let home= expand(a:2)
  else
   let home= vimball#VimballHome()
  endif
  let curdir = getcwd()
"  call Decho("home   <".home.">")
"  call Decho("curfile<".curfile.">")
"  call Decho("curdir <".curdir.">")

  call s:ChgDir(home)
  if filereadable(".VimballRecord")
"   call Decho(".VimballRecord is readable")
"   call Decho("curfile<".curfile.">")
   keepalt keepjumps 1split 
   sil! keepalt keepjumps e .VimballRecord
   let keepsrch= @/
"   call Decho('search for ^\M'.curfile.'.\m: ')
"   call Decho('search for ^\M'.curfile.'.\m{vba|vmb}: ')
"   call Decho('search for ^\M'.curfile.'\m[-0-9.]*\.{vba|vmb}: ')
   if search('^\M'.curfile."\m: ".'cw')
	let foundit= 1
   elseif search('^\M'.curfile.".\mvmb: ",'cw')
	let foundit= 2
   elseif search('^\M'.curfile.'\m[-0-9.]*\.vmb: ','cw')
	let foundit= 2
   elseif search('^\M'.curfile.".\mvba: ",'cw')
	let foundit= 1
   elseif search('^\M'.curfile.'\m[-0-9.]*\.vba: ','cw')
	let foundit= 1
   else
    let foundit = 0
   endif
   if foundit
	if foundit == 1
	 let exestring  = substitute(getline("."),'^\M'.curfile.'\m\S\{-}\.vba: ','','')
	else
	 let exestring  = substitute(getline("."),'^\M'.curfile.'\m\S\{-}\.vmb: ','','')
	endif
    let s:VBRstring= substitute(exestring,'call delete(','','g')
    let s:VBRstring= substitute(s:VBRstring,"[')]",'','g')
"	call Decho("exe ".exestring)
	sil! keepalt keepjumps exe exestring
	sil! keepalt keepjumps d
	let exestring= strlen(substitute(exestring,'call delete(.\{-})|\=',"D","g"))
"	call Decho("exestring<".exestring.">")
	echomsg "removed ".exestring." files"
   else
    let s:VBRstring= ''
	let curfile    = substitute(curfile,'\.vmb','','')
"    call Decho("unable to find <".curfile."> in .VimballRecord")
	if !exists("s:ok_unablefind")
     call vimball#ShowMesg(s:WARNING,"(RmVimball) unable to find <".curfile."> in .VimballRecord")
	endif
   endif
   sil! keepalt keepjumps g/^\s*$/d
   sil! keepalt keepjumps wq!
   let @/= keepsrch
  endif
  call s:ChgDir(curdir)

"  call Dret("vimball#RmVimball")
endfun

" ---------------------------------------------------------------------
" vimball#Decompress: attempts to automatically decompress vimballs {{{2
fun! vimball#Decompress(fname,...)
"  call Dfunc("Decompress(fname<".a:fname.">) a:0=".a:0)

  " decompression:
  if     expand("%") =~ '.*\.gz'  && executable("gunzip")
   " handle *.gz with gunzip
   silent exe "!gunzip ".shellescape(a:fname)
   if v:shell_error != 0
	call vimball#ShowMesg(s:WARNING,"(vimball#Decompress) gunzip may have failed with <".a:fname.">")
   endif
   let fname= substitute(a:fname,'\.gz$','','')
   exe "e ".escape(fname,' \')
   if a:0 == 0| call vimball#ShowMesg(s:USAGE,"Source this file to extract it! (:so %)") | endif

  elseif expand("%") =~ '.*\.gz' && executable("gzip")
   " handle *.gz with gzip -d
   silent exe "!gzip -d ".shellescape(a:fname)
   if v:shell_error != 0
	call vimball#ShowMesg(s:WARNING,'(vimball#Decompress) "gzip -d" may have failed with <'.a:fname.">")
   endif
   let fname= substitute(a:fname,'\.gz$','','')
   exe "e ".escape(fname,' \')
   if a:0 == 0| call vimball#ShowMesg(s:USAGE,"Source this file to extract it! (:so %)") | endif

  elseif expand("%") =~ '.*\.bz2' && executable("bunzip2")
   " handle *.bz2 with bunzip2
   silent exe "!bunzip2 ".shellescape(a:fname)
   if v:shell_error != 0
	call vimball#ShowMesg(s:WARNING,"(vimball#Decompress) bunzip2 may have failed with <".a:fname.">")
   endif
   let fname= substitute(a:fname,'\.bz2$','','')
   exe "e ".escape(fname,' \')
   if a:0 == 0| call vimball#ShowMesg(s:USAGE,"Source this file to extract it! (:so %)") | endif

  elseif expand("%") =~ '.*\.bz2' && executable("bzip2")
   " handle *.bz2 with bzip2 -d
   silent exe "!bzip2 -d ".shellescape(a:fname)
   if v:shell_error != 0
	call vimball#ShowMesg(s:WARNING,'(vimball#Decompress) "bzip2 -d" may have failed with <'.a:fname.">")
   endif
   let fname= substitute(a:fname,'\.bz2$','','')
   exe "e ".escape(fname,' \')
   if a:0 == 0| call vimball#ShowMesg(s:USAGE,"Source this file to extract it! (:so %)") | endif

  elseif expand("%") =~ '.*\.zip' && executable("unzip")
   " handle *.zip with unzip
   silent exe "!unzip ".shellescape(a:fname)
   if v:shell_error != 0
	call vimball#ShowMesg(s:WARNING,"(vimball#Decompress) unzip may have failed with <".a:fname.">")
   endif
   let fname= substitute(a:fname,'\.zip$','','')
   exe "e ".escape(fname,' \')
   if a:0 == 0| call vimball#ShowMesg(s:USAGE,"Source this file to extract it! (:so %)") | endif
  endif

  if a:0 == 0| setlocal noma bt=nofile fmr=[[[,]]] fdm=marker | endif

"  call Dret("Decompress")
endfun

" ---------------------------------------------------------------------
" vimball#ShowMesg: {{{2
fun! vimball#ShowMesg(level,msg)
"  call Dfunc("vimball#ShowMesg(level=".a:level." msg<".a:msg.">)")

  let rulerkeep   = &ruler
  let showcmdkeep = &showcmd
  set noruler noshowcmd
  redraw!

  if &fo =~ '[ta]'
   echomsg "***vimball*** ".a:msg
  else
   if a:level == s:WARNING || a:level == s:USAGE
    echohl WarningMsg
   elseif a:level == s:ERROR
    echohl Error
   endif
   echomsg "***vimball*** ".a:msg
   echohl None
  endif

  if a:level != s:USAGE
   call inputsave()|let ok= input("Press <cr> to continue")|call inputrestore()
  endif

  let &ruler   = rulerkeep
  let &showcmd = showcmdkeep

"  call Dret("vimball#ShowMesg")
endfun
" =====================================================================
" s:ChgDir: change directory (in spite of Windoze) {{{2
fun! s:ChgDir(newdir)
"  call Dfunc("ChgDir(newdir<".a:newdir.">)")
  if (has("win32") || has("win95") || has("win64") || has("win16"))
   try
    exe 'silent cd '.fnameescape(substitute(a:newdir,'/','\\','g'))
   catch  /^Vim\%((\a\+)\)\=:E/
    call mkdir(fnameescape(substitute(a:newdir,'/','\\','g')))
    exe 'silent cd '.fnameescape(substitute(a:newdir,'/','\\','g'))
   endtry
  else
   try
    exe 'silent cd '.fnameescape(a:newdir)
   catch  /^Vim\%((\a\+)\)\=:E/
    call mkdir(fnameescape(a:newdir))
    exe 'silent cd '.fnameescape(a:newdir)
   endtry
  endif
"  call Dret("ChgDir : curdir<".getcwd().">")
endfun

" ---------------------------------------------------------------------
" s:RecordInVar: record a un-vimball command in the .VimballRecord file {{{2
fun! s:RecordInVar(home,cmd)
"  call Dfunc("RecordInVar(home<".a:home."> cmd<".a:cmd.">)")
  if a:cmd =~ '^rmdir'
"   if !exists("s:recorddir")
"    let s:recorddir= substitute(a:cmd,'^rmdir',"call s:Rmdir",'')
"   else
"    let s:recorddir= s:recorddir."|".substitute(a:cmd,'^rmdir',"call s:Rmdir",'')
"   endif
  elseif !exists("s:recordfile")
   let s:recordfile= a:cmd
  else
   let s:recordfile= s:recordfile."|".a:cmd
  endif
"  call Dret("RecordInVar : s:recordfile<".(exists("s:recordfile")? s:recordfile : "")."> s:recorddir<".(exists("s:recorddir")? s:recorddir : "").">")
endfun

" ---------------------------------------------------------------------
" s:RecordInFile: {{{2
fun! s:RecordInFile(home)
"  call Dfunc("s:RecordInFile()")
  if exists("g:vimball_norecord")
"   call Dret("s:RecordInFile : g:vimball_norecord")
   return
  endif

  if exists("s:recordfile") || exists("s:recorddir")
   let curdir= getcwd()
   call s:ChgDir(a:home)
   keepalt keepjumps 1split 

   let cmd= expand("%:tr").": "
"   call Decho("cmd<".cmd.">")

   sil! keepalt keepjumps e .VimballRecord
   setlocal ma
   $
   if exists("s:recordfile") && exists("s:recorddir")
   	let cmd= cmd.s:recordfile."|".s:recorddir
   elseif exists("s:recorddir")
   	let cmd= cmd.s:recorddir
   elseif exists("s:recordfile")
   	let cmd= cmd.s:recordfile
   else
"    call Dret("s:RecordInFile : neither recordfile nor recorddir exist")
	return
   endif
"   call Decho("cmd<".cmd.">")

   " put command into buffer, write .VimballRecord `file
   keepalt keepjumps put=cmd
   sil! keepalt keepjumps g/^\s*$/d
   sil! keepalt keepjumps wq!
   call s:ChgDir(curdir)

   if exists("s:recorddir")
"	call Decho("unlet s:recorddir<".s:recorddir.">")
   	unlet s:recorddir
   endif
   if exists("s:recordfile")
"	call Decho("unlet s:recordfile<".s:recordfile.">")
   	unlet s:recordfile
   endif
  else
"   call Decho("s:record[file|dir] doesn't exist")
  endif

"  call Dret("s:RecordInFile")
endfun

" ---------------------------------------------------------------------
" vimball#VimballHome: determine/get home directory path (usually from rtp) {{{2
fun! vimball#VimballHome()
"  call Dfunc("vimball#VimballHome()")
  if exists("g:vimball_home")
   let home= g:vimball_home
  else
   " go to vim plugin home
   for home in split(&rtp,',') + ['']
    if isdirectory(home) && filewritable(home) | break | endif
	let basehome= substitute(home,'[/\\]\.vim$','','')
    if isdirectory(basehome) && filewritable(basehome)
	 let home= basehome."/.vim"
	 break
	endif
   endfor
   if home == ""
    " just pick the first directory
    let home= substitute(&rtp,',.*$','','')
   endif
   if (has("win32") || has("win95") || has("win64") || has("win16"))
    let home= substitute(home,'/','\\','g')
   endif
  endif
  " insure that the home directory exists
"  call Decho("picked home<".home.">")
  if !isdirectory(home)
   if exists("g:vimball_mkdir")
"	call Decho("home<".home."> isn't a directory -- making it now with g:vimball_mkdir<".g:vimball_mkdir.">")
"    call Decho("system(".g:vimball_mkdir." ".shellescape(home).")")
    call system(g:vimball_mkdir." ".shellescape(home))
   else
"	call Decho("home<".home."> isn't a directory -- making it now with mkdir()")
    call mkdir(home)
   endif
  endif
"  call Dret("vimball#VimballHome <".home.">")
  return home
endfun

" ---------------------------------------------------------------------
" vimball#SaveSettings: {{{2
fun! vimball#SaveSettings()
"  call Dfunc("SaveSettings()")
  let s:makeep  = getpos("'a")
  let s:regakeep= @a
  if exists("&acd")
   let s:acdkeep = &acd
  endif
  let s:eikeep  = &ei
  let s:fenkeep = &l:fen
  let s:hidkeep = &hidden
  let s:ickeep  = &ic
  let s:lzkeep  = &lz
  let s:pmkeep  = &pm
  let s:repkeep = &report
  let s:vekeep  = &ve
  let s:ffkeep  = &l:ff
  let s:swfkeep = &l:swf
  if exists("&acd")
   setlocal ei=all ve=all noacd nofen noic report=999 nohid bt= ma lz pm= ff=unix noswf
  else
   setlocal ei=all ve=all       nofen noic report=999 nohid bt= ma lz pm= ff=unix noswf
  endif
  " vimballs should be in unix format
  setlocal ff=unix
"  call Dret("SaveSettings")
endfun

" ---------------------------------------------------------------------
" vimball#RestoreSettings: {{{2
fun! vimball#RestoreSettings()
"  call Dfunc("RestoreSettings()")
  let @a      = s:regakeep
  if exists("&acd")
   let &acd   = s:acdkeep
  endif
  let &l:fen  = s:fenkeep
  let &hidden = s:hidkeep
  let &ic     = s:ickeep
  let &lz     = s:lzkeep
  let &pm     = s:pmkeep
  let &report = s:repkeep
  let &ve     = s:vekeep
  let &ei     = s:eikeep
  let &l:ff   = s:ffkeep
  if s:makeep[0] != 0
   " restore mark a
"   call Decho("restore mark-a: makeep=".string(makeep))
   call setpos("'a",s:makeep)
  endif
  if exists("&acd")
   unlet s:acdkeep
  endif
  unlet s:regakeep s:eikeep s:fenkeep s:hidkeep s:ickeep s:repkeep s:vekeep s:makeep s:lzkeep s:pmkeep s:ffkeep
"  call Dret("RestoreSettings")
endfun

let &cpo = s:keepcpo
unlet s:keepcpo

" ---------------------------------------------------------------------
" Modelines: {{{1
" vim: fdm=marker
                                                                                                                                                                                                                                                   usr/share/vim/vim74/autoload/xml/                                                                   0040755 0000000 0000000 00000000000 13101201173 015321  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/share/vim/vim74/autoload/xml/html32.vim                                                         0100644 0000000 0000000 00000043632 13050207306 017163  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        let g:xmldata_html32 = {
\ 'vimxmlentities': ['AElig', 'Aacute', 'Acirc', 'Agrave', 'Aring', 'Atilde', 'Auml', 'Ccedil', 'ETH', 'Eacute', 'Ecirc', 'Egrave', 'Euml', 'Iacute', 'Icirc', 'Igrave', 'Iuml', 'Ntilde', 'Oacute', 'Ocirc', 'Ograve', 'Oslash', 'Otilde', 'Ouml', 'THORN', 'Uacute', 'Ucirc', 'Ugrave', 'Uuml', 'Yacute', 'aacute', 'acirc', 'acute', 'aelig', 'agrave', 'amp', 'aring', 'atilde', 'auml', 'brvbar', 'ccedil', 'cedil', 'cent', 'copy', 'curren', 'deg', 'divide', 'eacute', 'ecirc', 'egrave', 'eth', 'euml', 'frac12', 'frac14', 'frac34', 'gt', 'iacute', 'icirc', 'iexcl', 'igrave', 'iquest', 'iuml', 'laquo', 'lt', 'macr', 'micro', 'middot', 'nbsp', 'not', 'ntilde', 'oacute', 'ocirc', 'ograve', 'ordf', 'ordm', 'oslash', 'otilde', 'ouml', 'para', 'plusmn', 'pound', 'raquo', 'reg', 'sect', 'shy', 'sup1', 'sup2', 'sup3', 'szlig', 'thorn', 'times', 'uacute', 'ucirc', 'ugrave', 'uml', 'uuml', 'yacute', 'yen', 'yuml'],
\ 'vimxmlroot': ['html'],
\ 'a': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'rel': [], 'href': [], 'name': [], 'rev': [], 'title': []}
\ ],
\ 'address': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p'],
\ { }
\ ],
\ 'applet': [
\ ['param', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'width': [], 'vspace': [], 'alt': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'name': [], 'height': [], 'hspace': [], 'codebase': [], 'code': []}
\ ],
\ 'area': [
\ [],
\ { 'alt': [], 'coords': [], 'nohref': ['BOOL'], 'href': [], 'shape': ['rect', 'circle', 'poly']}
\ ],
\ 'b': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'base': [
\ [],
\ { 'href': []}
\ ],
\ 'basefont': [
\ [],
\ { 'size': []}
\ ],
\ 'big': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'blockquote': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { }
\ ],
\ 'body': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { 'link': [], 'vlink': [], 'background': [], 'alink': [], 'bgcolor': [], 'text': []}
\ ],
\ 'br': [
\ [],
\ { 'clear': ['none', 'left', 'all', 'right', 'none']}
\ ],
\ 'caption': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['top', 'bottom']}
\ ],
\ 'center': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { }
\ ],
\ 'cite': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'code': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'dd': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table'],
\ { }
\ ],
\ 'dfn': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'dir': [
\ ['li'],
\ { 'compact': ['BOOL']}
\ ],
\ 'div': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'dl': [
\ ['dt', 'dd'],
\ { 'compact': ['BOOL']}
\ ],
\ 'dt': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'em': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'font': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'size': [], 'color': []}
\ ],
\ 'form': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'isindex', 'hr', 'table', 'address'],
\ { 'enctype': ['application/x-www-form-urlencoded'], 'action': [], 'method': ['GET', 'POST']}
\ ],
\ 'h1': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'h2': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'h3': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'h4': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'h5': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'h6': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'head': [
\ ['title', 'isindex', 'base', 'script', 'style', 'meta', 'link'],
\ { }
\ ],
\ 'hr': [
\ [],
\ { 'width': [], 'align': ['left', 'right', 'center'], 'size': [], 'noshade': ['BOOL']}
\ ],
\ 'html': [
\ ['head', 'body', 'plaintext'],
\ { 'version': ['-//W3C//DTD HTML 3.2 Final//EN']}
\ ],
\ 'i': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'img': [
\ [],
\ { 'width': [], 'vspace': [], 'alt': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'usemap': [], 'ismap': ['BOOL'], 'src': [], 'height': [], 'border': [], 'hspace': []}
\ ],
\ 'input': [
\ [],
\ { 'maxlength': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'value': [], 'src': [], 'name': [], 'size': [], 'checked': ['BOOL'], 'type': ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'IMAGE']}
\ ],
\ 'isindex': [
\ [],
\ { 'prompt': []}
\ ],
\ 'kbd': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'li': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table'],
\ { 'value': [], 'type': []}
\ ],
\ 'link': [
\ [],
\ { 'rel': [], 'href': [], 'rev': [], 'title': []}
\ ],
\ 'listing': [
\ [],
\ { }
\ ],
\ 'map': [
\ ['area'],
\ { 'name': []}
\ ],
\ 'menu': [
\ ['li'],
\ { 'compact': ['BOOL']}
\ ],
\ 'meta': [
\ [],
\ { 'http-equiv': [], 'name': [], 'content': []}
\ ],
\ 'ol': [
\ ['li'],
\ { 'compact': ['BOOL'], 'type': [], 'start': []}
\ ],
\ 'option': [
\ [''],
\ { 'value': [], 'selected': ['BOOL']}
\ ],
\ 'p': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'align': ['left', 'center', 'right']}
\ ],
\ 'param': [
\ [],
\ { 'value': [], 'name': []}
\ ],
\ 'plaintext': [
\ [],
\ { }
\ ],
\ 'pre': [
\ ['tt', 'i', 'b', 'u', 'strike', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'applet', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { 'width': ['#implied']}
\ ],
\ 'samp': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'script': [
\ [],
\ { }
\ ],
\ 'select': [
\ ['option'],
\ { 'name': [], 'size': [], 'multiple': ['BOOL']}
\ ],
\ 'small': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'strike': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'strong': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'style': [
\ [],
\ { }
\ ],
\ 'sub': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'sup': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'table': [
\ ['caption', 'tr'],
\ { 'width': [], 'align': ['left', 'center', 'right'], 'border': [], 'cellspacing': [], 'cellpadding': []}
\ ],
\ 'td': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { 'width': [], 'align': ['left', 'center', 'right'], 'nowrap': ['BOOL'], 'valign': ['top', 'middle', 'bottom'], 'height': [], 'rowspan': ['1'], 'colspan': ['1']}
\ ],
\ 'textarea': [
\ [''],
\ { 'name': [], 'rows': [], 'cols': []}
\ ],
\ 'th': [
\ ['h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea', 'p', 'ul', 'ol', 'dir', 'menu', 'pre', 'xmp', 'listing', 'dl', 'div', 'center', 'blockquote', 'form', 'isindex', 'hr', 'table', 'address'],
\ { 'width': [], 'align': ['left', 'center', 'right'], 'nowrap': ['BOOL'], 'valign': ['top', 'middle', 'bottom'], 'height': [], 'rowspan': ['1'], 'colspan': ['1']}
\ ],
\ 'title': [
\ [''],
\ { }
\ ],
\ 'tr': [
\ ['th', 'td'],
\ { 'align': ['left', 'center', 'right'], 'valign': ['top', 'middle', 'bottom']}
\ ],
\ 'tt': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'u': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'ul': [
\ ['li'],
\ { 'compact': ['BOOL'], 'type': ['disc', 'square', 'circle']}
\ ],
\ 'var': [
\ ['tt', 'i', 'b', 'u', 'strike', 'big', 'small', 'sub', 'sup', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'a', 'img', 'applet', 'font', 'basefont', 'br', 'script', 'map', 'input', 'select', 'textarea'],
\ { }
\ ],
\ 'xmp': [
\ [],
\ { }
\ ],
\ 'vimxmlattrinfo' : {
\ 'accept' : ['ContentType', ''],
\ 'accesskey' : ['Character', ''],
\ 'action' : ['*URI', ''],
\ 'align' : ['String', ''],
\ 'alt' : ['*Text', ''],
\ 'archive' : ['UriList', ''],
\ 'axis' : ['CDATA', ''],
\ 'border' : ['Pixels', ''],
\ 'cellpadding' : ['Length', ''],
\ 'cellspacing' : ['Length', ''],
\ 'char' : ['Character', ''],
\ 'charoff' : ['Length', ''],
\ 'charset' : ['LangCode', ''],
\ 'checked' : ['Bool', ''],
\ 'class' : ['CDATA', ''],
\ 'codetype' : ['ContentType', ''],
\ 'cols' : ['*Number', ''],
\ 'colspan' : ['Number', ''],
\ 'content' : ['*CDATA', ''],
\ 'coords' : ['Coords', ''],
\ 'data' : ['URI', ''],
\ 'datetime' : ['DateTime', ''],
\ 'declare' : ['Bool', ''],
\ 'defer' : ['Bool', ''],
\ 'dir' : ['String', ''],
\ 'disabled' : ['Bool', ''],
\ 'enctype' : ['ContentType', ''],
\ 'for' : ['ID', ''],
\ 'headers' : ['IDREFS', ''],
\ 'height' : ['Number', ''],
\ 'href' : ['*URI', ''],
\ 'hreflang' : ['LangCode', ''],
\ 'id' : ['ID', ''],
\ 'ismap' : ['Bool', ''],
\ 'label' : ['*Text', ''],
\ 'lang' : ['LangCode', ''],
\ 'longdesc' : ['URI', ''],
\ 'maxlength' : ['Number', ''],
\ 'media' : ['MediaDesc', ''],
\ 'method' : ['String', ''],
\ 'multiple' : ['Bool', ''],
\ 'name' : ['CDATA', ''],
\ 'nohref' : ['Bool', ''],
\ 'onblur' : ['Script', ''],
\ 'onchange' : ['Script', ''],
\ 'onclick' : ['Script', ''],
\ 'ondblclick' : ['Script', ''],
\ 'onfocus' : ['Script', ''],
\ 'onkeydown' : ['Script', ''],
\ 'onkeypress' : ['Script', ''],
\ 'onkeyup' : ['Script', ''],
\ 'onload' : ['Script', ''],
\ 'onmousedown' : ['Script', ''],
\ 'onmousemove' : ['Script', ''],
\ 'onmouseout' : ['Script', ''],
\ 'onmouseover' : ['Script', ''],
\ 'onmouseup' : ['Script', ''],
\ 'onreset' : ['Script', ''],
\ 'onselect' : ['Script', ''],
\ 'onsubmit' : ['Script', ''],
\ 'onunload' : ['Script', ''],
\ 'profile' : ['URI', ''],
\ 'readonly' : ['Bool', ''],
\ 'rel' : ['LinkTypes', ''],
\ 'rev' : ['LinkTypes', ''],
\ 'rows' : ['*Number', ''],
\ 'rules' : ['String', ''],
\ 'scheme' : ['CDATA', ''],
\ 'selected' : ['Bool', ''],
\ 'shape' : ['Shape', ''],
\ 'size' : ['CDATA', ''],
\ 'span' : ['Number', ''],
\ 'src' : ['*URI', ''],
\ 'standby' : ['Text', ''],
\ 'style' : ['StyleSheet', ''],
\ 'summary' : ['*Text', ''],
\ 'tabindex' : ['Number', ''],
\ 'title' : ['Text', ''],
\ 'type' : ['*ContentType', ''],
\ 'usemap' : ['URI', ''],
\ 'valign' : ['String', ''],
\ 'valuetype' : ['String', ''],
\ 'width' : ['Number', ''],
\ 'xmlns' : ['URI', '']
\ },
\ 'vimxmltaginfo': {
\ 'area': ['/>', ''],
\ 'base': ['/>', ''],
\ 'basefont': ['/>', ''],
\ 'br': ['/>', ''],
\ 'hr': ['/>', ''],
\ 'img': ['/>', ''],
\ 'input': ['/>', ''],
\ 'isindex': ['/>', ''],
\ 'link': ['/>', ''],
\ 'meta': ['/>', ''],
\ 'param': ['/>', ''],
\ }
\ }
                                                                                                      usr/share/vim/vim74/autoload/xml/html401f.vim                                                       0100644 0000000 0000000 00000151552 13050207306 017412  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        let g:xmldata_html401t = {
\ 'vimxmlentities': ['AElig', 'Aacute', 'Acirc', 'Agrave', 'Alpha', 'Aring', 'Atilde', 'Auml', 'Beta', 'Ccedil', 'Chi', 'Dagger', 'Delta', 'ETH', 'Eacute', 'Ecirc', 'Egrave', 'Epsilon', 'Eta', 'Euml', 'Gamma', 'Iacute', 'Icirc', 'Igrave', 'Iota', 'Iuml', 'Kappa', 'Lambda', 'Mu', 'Ntilde', 'Nu', 'OElig', 'Oacute', 'Ocirc', 'Ograve', 'Omega', 'Omicron', 'Oslash', 'Otilde', 'Ouml', 'Phi', 'Pi', 'Prime', 'Psi', 'Rho', 'Scaron', 'Sigma', 'THORN', 'Tau', 'Theta', 'Uacute', 'Ucirc', 'Ugrave', 'Upsilon', 'Uuml', 'Xi', 'Yacute', 'Yuml', 'Zeta', 'aacute', 'acirc', 'acute', 'aelig', 'agrave', 'alefsym', 'alpha', 'amp', 'and', 'ang', 'apos', 'aring', 'asymp', 'atilde', 'auml', 'bdquo', 'beta', 'brvbar', 'bull', 'cap', 'ccedil', 'cedil', 'cent', 'chi', 'circ', 'clubs', 'cong', 'copy', 'crarr', 'cup', 'curren', 'dArr', 'dagger', 'darr', 'deg', 'delta', 'diams', 'divide', 'eacute', 'ecirc', 'egrave', 'empty', 'emsp', 'ensp', 'epsilon', 'equiv', 'eta', 'eth', 'euml', 'euro', 'exist', 'fnof', 'forall', 'frac12', 'frac14', 'frac34', 'frasl', 'gamma', 'ge', 'gt', 'hArr', 'harr', 'hearts', 'hellip', 'iacute', 'icirc', 'iexcl', 'igrave', 'image', 'infin', 'int', 'iota', 'iquest', 'isin', 'iuml', 'kappa', 'lArr', 'lambda', 'lang', 'laquo', 'larr', 'lceil', 'ldquo', 'le', 'lfloor', 'lowast', 'loz', 'lrm', 'lsaquo', 'lsquo', 'lt', 'macr', 'mdash', 'micro', 'middot', 'minus', 'mu', 'nabla', 'nbsp', 'ndash', 'ne', 'ni', 'not', 'notin', 'nsub', 'ntilde', 'nu', 'oacute', 'ocirc', 'oelig', 'ograve', 'oline', 'omega', 'omicron', 'oplus', 'or', 'ordf', 'ordm', 'oslash', 'otilde', 'otimes', 'ouml', 'para', 'part', 'permil', 'perp', 'phi', 'pi', 'piv', 'plusmn', 'pound', 'prime', 'prod', 'prop', 'psi', 'quot', 'rArr', 'radic', 'rang', 'raquo', 'rarr', 'rceil', 'rdquo', 'real', 'reg', 'rfloor', 'rho', 'rlm', 'rsaquo', 'rsquo', 'sbquo', 'scaron', 'sdot', 'sect', 'shy', 'sigma', 'sigmaf', 'sim', 'spades', 'sub', 'sube', 'sum', 'sup', 'sup1', 'sup2', 'sup3', 'supe', 'szlig', 'tau', 'there4', 'theta', 'thetasym', 'thinsp', 'thorn', 'tilde', 'times', 'trade', 'uArr', 'uacute', 'uarr', 'ucirc', 'ugrave', 'uml', 'upsih', 'upsilon', 'uuml', 'weierp', 'xi', 'yacute', 'yen', 'yuml', 'zeta', 'zwj', 'zwnj'],
\ 'vimxmlroot': ['html'],
\ 'a': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'rel': [], 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'target': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'tabindex': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'shape': ['rect', 'circle', 'poly', 'default']}
\ ],
\ 'abbr': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'acronym': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'address': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'p'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'applet': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'object': [], 'id': [], 'code': [], 'vspace': [], 'archive': [], 'alt': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'style': [], 'name': [], 'height': [], 'hspace': [], 'title': [], 'class': [], 'codebase': []}
\ ],
\ 'area': [
\ [],
\ { 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'target': [], 'nohref': ['BOOL'], 'onfocus': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'alt': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'shape': ['rect', 'circle', 'poly', 'default'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'b': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'base': [
\ [],
\ { 'target': [], 'href': []}
\ ],
\ 'basefont': [
\ [],
\ { 'size': [], 'face': [], 'color': [], 'id': []}
\ ],
\ 'bdo': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'big': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'blockquote': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'body': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'ins', 'del'],
\ { 'vlink': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'alink': [], 'onkeyup': [], 'bgcolor': [], 'text': [], 'onmouseup': [], 'id': [], 'link': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'background': [], 'onunload': [], 'onkeypress': [], 'onmousedown': [], 'onload': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'br': [
\ [],
\ { 'clear': ['none', 'left', 'all', 'right', 'none'], 'id': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'button': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'hr', 'table', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo'],
\ { 'accesskey': [], 'disabled': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'tabindex': [], 'value': [], 'name': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': ['submit', 'button', 'submit', 'reset']}
\ ],
\ 'caption': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'center': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'cite': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'code': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'col': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'colgroup': [
\ ['col'],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dd': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'del': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dfn': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dir': [
\ ['li'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'div': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dl': [
\ ['dt', 'dd'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'em': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'fieldset': [
\ ['legend', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'font': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'size': [], 'face': [], 'color': [], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'form': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'enctype': ['application/x-www-form-urlencoded'], 'onsubmit': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'target': [], 'onkeyup': [], 'onmouseup': [], 'onreset': [], 'id': [], 'method': ['GET', 'POST'], 'onmouseover': [], 'lang': [], 'accept': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'accept-charset': [], 'onkeypress': [], 'onmousedown': [], 'action': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h1': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h2': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h3': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h4': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h5': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h6': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'head': [
\ ['title', 'isindex', 'base', 'script', 'style', 'meta', 'link', 'object'],
\ { 'profile': [], 'dir': ['ltr', 'rtl'], 'lang': []}
\ ],
\ 'hr': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'size': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'noshade': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'html': [
\ ['head', 'frameset'],
\ { 'xmlns': ['http://www.w3.org/1999/xhtml'], 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'xml:lang': []}
\ ],
\ 'frameset': [
\ ['frameset', 'frame', 'noframes'],
\ { 'rows': [], 'cols': [], 'id': [], 'style': [], 'onunload': [], 'onload': [], 'class': [], 'title': []}
\ ],
\ 'frame': [
\ [],
\ { 'scrolling': ['auto', 'yes', 'no', 'auto'], 'noresize': ['BOOL'], 'marginwidth': [], 'id': [], 'marginheight': [], 'longdesc': [], 'src': [], 'style': [], 'name': [], 'frameborder': ['1', '0'], 'title': [], 'class': []}
\ ],
\ 'i': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'iframe': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'scrolling': ['auto', 'yes', 'no', 'auto'], 'marginwidth': [], 'id': [], 'marginheight': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'longdesc': [], 'src': [], 'style': [], 'name': [], 'height': [], 'frameborder': ['1', '0'], 'title': [], 'class': []}
\ ],
\ 'img': [
\ [],
\ { 'width': [], 'usemap': [], 'ismap': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'vspace': [], 'onmouseover': [], 'alt': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'src': [], 'longdesc': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'height': [], 'border': [], 'hspace': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'input': [
\ [],
\ { 'ondblclick': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'value': [], 'src': [], 'name': [], 'checked': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'type': ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'IMAGE', 'BUTTON'], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'usemap': [], 'ismap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'maxlength': [], 'onselect': [], 'tabindex': [], 'accept': [], 'alt': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ins': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'cite': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'isindex': [
\ [],
\ { 'id': [], 'lang': [], 'prompt': [], 'class': [], 'title': [], 'dir': ['ltr', 'rtl'], 'style': []}
\ ],
\ 'kbd': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'label': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'for': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'legend': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'li': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'link': [
\ [],
\ { 'rel': [], 'ondblclick': [], 'onkeydown': [], 'target': [], 'onkeyup': [], 'href': [], 'media': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'map': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'area'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'menu': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'meta': [
\ [],
\ { 'http-equiv': [], 'content': [], 'lang': [], 'name': [], 'scheme': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'noframes': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'noscript': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'object': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'name': [], 'data': [], 'declare': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'width': [], 'usemap': [], 'dir': ['ltr', 'rtl'], 'vspace': [], 'tabindex': [], 'standby': [], 'archive': [], 'classid': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'height': [], 'border': [], 'codetype': [], 'hspace': [], 'codebase': []}
\ ],
\ 'ol': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'start': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'optgroup': [
\ ['option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'option': [
\ [''],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'selected': ['BOOL']}
\ ],
\ 'p': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'param': [
\ [],
\ { 'id': [], 'value': [], 'name': [], 'type': [], 'valuetype': ['DATA', 'REF', 'OBJECT']}
\ ],
\ 'pre': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'br', 'script', 'map', 'q', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'width': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'q': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'cite': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 's': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'samp': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'script': [
\ [],
\ { 'src': [], 'for': [], 'charset': [], 'event': [], 'type': [], 'defer': ['BOOL'], 'language': []}
\ ],
\ 'select': [
\ ['optgroup', 'option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'multiple': ['BOOL']}
\ ],
\ 'small': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'span': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strike': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strong': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'style': [
\ [],
\ { 'media': [], 'lang': [], 'type': [], 'title': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'sub': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'sup': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'table': [
\ ['caption', 'col', 'colgroup', 'thead', 'tfoot', 'tbody'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'datapagesize': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'frame': ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'], 'rules': ['none', 'groups', 'rows', 'cols', 'all'], 'dir': ['ltr', 'rtl'], 'summary': [], 'bgcolor': [], 'cellspacing': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'border': [], 'cellpadding': []}
\ ],
\ 'tbody': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'td': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'textarea': [
\ [''],
\ { 'ondblclick': [], 'cols': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'rows': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onselect': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'tfoot': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'th': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'thead': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'title': [
\ [''],
\ { 'lang': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'tr': [
\ ['th', 'td'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'tt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'u': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ul': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': ['disc', 'square', 'circle'], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'var': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'vimxmlattrinfo' : {
\ 'accept' : ['ContentType', ''],
\ 'accesskey' : ['Character', ''],
\ 'action' : ['*URI', ''],
\ 'align' : ['String', ''],
\ 'alt' : ['*Text', ''],
\ 'archive' : ['UriList', ''],
\ 'axis' : ['CDATA', ''],
\ 'border' : ['Pixels', ''],
\ 'cellpadding' : ['Length', ''],
\ 'cellspacing' : ['Length', ''],
\ 'char' : ['Character', ''],
\ 'charoff' : ['Length', ''],
\ 'charset' : ['LangCode', ''],
\ 'checked' : ['Bool', ''],
\ 'class' : ['CDATA', ''],
\ 'codetype' : ['ContentType', ''],
\ 'cols' : ['*Number', ''],
\ 'colspan' : ['Number', ''],
\ 'content' : ['*CDATA', ''],
\ 'coords' : ['Coords', ''],
\ 'data' : ['URI', ''],
\ 'datetime' : ['DateTime', ''],
\ 'declare' : ['Bool', ''],
\ 'defer' : ['Bool', ''],
\ 'dir' : ['String', ''],
\ 'disabled' : ['Bool', ''],
\ 'enctype' : ['ContentType', ''],
\ 'for' : ['ID', ''],
\ 'headers' : ['IDREFS', ''],
\ 'height' : ['Number', ''],
\ 'href' : ['*URI', ''],
\ 'hreflang' : ['LangCode', ''],
\ 'id' : ['ID', ''],
\ 'ismap' : ['Bool', ''],
\ 'label' : ['*Text', ''],
\ 'lang' : ['LangCode', ''],
\ 'longdesc' : ['URI', ''],
\ 'maxlength' : ['Number', ''],
\ 'media' : ['MediaDesc', ''],
\ 'method' : ['String', ''],
\ 'multiple' : ['Bool', ''],
\ 'name' : ['CDATA', ''],
\ 'nohref' : ['Bool', ''],
\ 'onblur' : ['Script', ''],
\ 'onchange' : ['Script', ''],
\ 'onclick' : ['Script', ''],
\ 'ondblclick' : ['Script', ''],
\ 'onfocus' : ['Script', ''],
\ 'onkeydown' : ['Script', ''],
\ 'onkeypress' : ['Script', ''],
\ 'onkeyup' : ['Script', ''],
\ 'onload' : ['Script', ''],
\ 'onmousedown' : ['Script', ''],
\ 'onmousemove' : ['Script', ''],
\ 'onmouseout' : ['Script', ''],
\ 'onmouseover' : ['Script', ''],
\ 'onmouseup' : ['Script', ''],
\ 'onreset' : ['Script', ''],
\ 'onselect' : ['Script', ''],
\ 'onsubmit' : ['Script', ''],
\ 'onunload' : ['Script', ''],
\ 'profile' : ['URI', ''],
\ 'readonly' : ['Bool', ''],
\ 'rel' : ['LinkTypes', ''],
\ 'rev' : ['LinkTypes', ''],
\ 'rows' : ['*Number', ''],
\ 'rules' : ['String', ''],
\ 'scheme' : ['CDATA', ''],
\ 'selected' : ['Bool', ''],
\ 'shape' : ['Shape', ''],
\ 'size' : ['CDATA', ''],
\ 'span' : ['Number', ''],
\ 'src' : ['*URI', ''],
\ 'standby' : ['Text', ''],
\ 'style' : ['StyleSheet', ''],
\ 'summary' : ['*Text', ''],
\ 'tabindex' : ['Number', ''],
\ 'title' : ['Text', ''],
\ 'type' : ['*ContentType', ''],
\ 'usemap' : ['URI', ''],
\ 'valign' : ['String', ''],
\ 'valuetype' : ['String', ''],
\ 'width' : ['Number', ''],
\ 'xmlns' : ['URI', '']
\ },
\ 'vimxmltaginfo': {
\ 'area': ['/>', ''],
\ 'base': ['/>', ''],
\ 'basefont': ['/>', ''],
\ 'br': ['/>', ''],
\ 'col': ['/>', ''],
\ 'hr': ['/>', ''],
\ 'img': ['/>', ''],
\ 'input': ['/>', ''],
\ 'isindex': ['/>', ''],
\ 'link': ['/>', ''],
\ 'meta': ['/>', ''],
\ 'param': ['/>', ''],
\ }
\ }
                                                                                                                                                      usr/share/vim/vim74/autoload/xml/html401s.vim                                                       0100644 0000000 0000000 00000121102 13050207306 017413  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        let g:xmldata_html401s = {
\ 'vimxmlentities': ['AElig', 'Aacute', 'Acirc', 'Agrave', 'Alpha', 'Aring', 'Atilde', 'Auml', 'Beta', 'Ccedil', 'Chi', 'Dagger', 'Delta', 'ETH', 'Eacute', 'Ecirc', 'Egrave', 'Epsilon', 'Eta', 'Euml', 'Gamma', 'Iacute', 'Icirc', 'Igrave', 'Iota', 'Iuml', 'Kappa', 'Lambda', 'Mu', 'Ntilde', 'Nu', 'OElig', 'Oacute', 'Ocirc', 'Ograve', 'Omega', 'Omicron', 'Oslash', 'Otilde', 'Ouml', 'Phi', 'Pi', 'Prime', 'Psi', 'Rho', 'Scaron', 'Sigma', 'THORN', 'Tau', 'Theta', 'Uacute', 'Ucirc', 'Ugrave', 'Upsilon', 'Uuml', 'Xi', 'Yacute', 'Yuml', 'Zeta', 'aacute', 'acirc', 'acute', 'aelig', 'agrave', 'alefsym', 'alpha', 'amp', 'and', 'ang', 'apos', 'aring', 'asymp', 'atilde', 'auml', 'bdquo', 'beta', 'brvbar', 'bull', 'cap', 'ccedil', 'cedil', 'cent', 'chi', 'circ', 'clubs', 'cong', 'copy', 'crarr', 'cup', 'curren', 'dArr', 'dagger', 'darr', 'deg', 'delta', 'diams', 'divide', 'eacute', 'ecirc', 'egrave', 'empty', 'emsp', 'ensp', 'epsilon', 'equiv', 'eta', 'eth', 'euml', 'euro', 'exist', 'fnof', 'forall', 'frac12', 'frac14', 'frac34', 'frasl', 'gamma', 'ge', 'gt', 'hArr', 'harr', 'hearts', 'hellip', 'iacute', 'icirc', 'iexcl', 'igrave', 'image', 'infin', 'int', 'iota', 'iquest', 'isin', 'iuml', 'kappa', 'lArr', 'lambda', 'lang', 'laquo', 'larr', 'lceil', 'ldquo', 'le', 'lfloor', 'lowast', 'loz', 'lrm', 'lsaquo', 'lsquo', 'lt', 'macr', 'mdash', 'micro', 'middot', 'minus', 'mu', 'nabla', 'nbsp', 'ndash', 'ne', 'ni', 'not', 'notin', 'nsub', 'ntilde', 'nu', 'oacute', 'ocirc', 'oelig', 'ograve', 'oline', 'omega', 'omicron', 'oplus', 'or', 'ordf', 'ordm', 'oslash', 'otilde', 'otimes', 'ouml', 'para', 'part', 'permil', 'perp', 'phi', 'pi', 'piv', 'plusmn', 'pound', 'prime', 'prod', 'prop', 'psi', 'quot', 'rArr', 'radic', 'rang', 'raquo', 'rarr', 'rceil', 'rdquo', 'real', 'reg', 'rfloor', 'rho', 'rlm', 'rsaquo', 'rsquo', 'sbquo', 'scaron', 'sdot', 'sect', 'shy', 'sigma', 'sigmaf', 'sim', 'spades', 'sub', 'sube', 'sum', 'sup', 'sup1', 'sup2', 'sup3', 'supe', 'szlig', 'tau', 'there4', 'theta', 'thetasym', 'thinsp', 'thorn', 'tilde', 'times', 'trade', 'uArr', 'uacute', 'uarr', 'ucirc', 'ugrave', 'uml', 'upsih', 'upsilon', 'uuml', 'weierp', 'xi', 'yacute', 'yen', 'yuml', 'zeta', 'zwj', 'zwnj'],
\ 'vimxmlroot': ['html'],
\ 'a': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'rel': [], 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onkeydown': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'tabindex': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'name': [], 'style': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'shape': ['rect', 'circle', 'poly', 'default']}
\ ],
\ 'abbr': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'acronym': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'address': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'area': [
\ [],
\ { 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'nohref': ['BOOL'], 'onfocus': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'alt': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'shape': ['rect', 'circle', 'poly', 'default'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'b': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'base': [
\ [],
\ { 'href': []}
\ ],
\ 'bdo': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'big': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'blockquote': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'script'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'body': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'script', 'ins', 'del'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onunload': [], 'onkeypress': [], 'onmousedown': [], 'onload': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'br': [
\ [],
\ { 'id': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'button': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'hr', 'table', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo'],
\ { 'accesskey': [], 'disabled': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'tabindex': [], 'value': [], 'name': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': ['submit', 'button', 'submit', 'reset']}
\ ],
\ 'caption': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'cite': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'code': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'col': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'colgroup': [
\ ['col'],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dd': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'del': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dfn': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'div': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dl': [
\ ['dt', 'dd'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dt': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'em': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'fieldset': [
\ ['legend', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'form': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'hr', 'table', 'fieldset', 'address', 'script'],
\ { 'enctype': ['application/x-www-form-urlencoded'], 'onsubmit': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'onreset': [], 'id': [], 'method': ['GET', 'POST'], 'onmouseover': [], 'lang': [], 'accept': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'accept-charset': [], 'onkeypress': [], 'onmousedown': [], 'action': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h1': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'h2': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'h3': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'h4': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'h5': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'h6': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'head': [
\ ['title', 'base', 'script', 'style', 'meta', 'link', 'object'],
\ { 'profile': [], 'dir': ['ltr', 'rtl'], 'lang': []}
\ ],
\ 'hr': [
\ [],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'html': [
\ ['head', 'body'],
\ { 'dir': ['ltr', 'rtl'], 'lang': []}
\ ],
\ 'i': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'img': [
\ [],
\ { 'width': [], 'usemap': [], 'ismap': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'alt': [], 'lang': [], 'src': [], 'longdesc': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'height': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'input': [
\ [],
\ { 'ondblclick': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'src': [], 'name': [], 'checked': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'type': ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'IMAGE', 'BUTTON'], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'usemap': [], 'ismap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'maxlength': [], 'onselect': [], 'accept': [], 'alt': [], 'tabindex': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ins': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'cite': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'kbd': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'label': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'for': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'legend': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'li': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'link': [
\ [],
\ { 'rel': [], 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'href': [], 'media': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'map': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'area'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'meta': [
\ [],
\ { 'http-equiv': [], 'content': [], 'lang': [], 'name': [], 'scheme': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'noscript': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'object': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'data': [], 'declare': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'width': [], 'usemap': [], 'dir': ['ltr', 'rtl'], 'archive': [], 'standby': [], 'tabindex': [], 'classid': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'codetype': [], 'codebase': []}
\ ],
\ 'ol': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'optgroup': [
\ ['option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'option': [
\ [''],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'selected': ['BOOL']}
\ ],
\ 'p': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'param': [
\ [],
\ { 'id': [], 'value': [], 'name': [], 'type': [], 'valuetype': ['DATA', 'REF', 'OBJECT']}
\ ],
\ 'pre': [
\ ['tt', 'i', 'b', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'br', 'script', 'map', 'q', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'q': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'cite': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'samp': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'script': [
\ [],
\ { 'src': [], 'for': [], 'charset': [], 'event': [], 'type': [], 'defer': ['BOOL']}
\ ],
\ 'select': [
\ ['optgroup', 'option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'multiple': ['BOOL']}
\ ],
\ 'small': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'span': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strong': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'style': [
\ [],
\ { 'media': [], 'lang': [], 'type': [], 'title': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'sub': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'sup': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'table': [
\ ['caption', 'col', 'colgroup', 'thead', 'tfoot', 'tbody'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'datapagesize': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'frame': ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'], 'rules': ['none', 'groups', 'rows', 'cols', 'all'], 'dir': ['ltr', 'rtl'], 'summary': [], 'cellspacing': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'border': [], 'cellpadding': []}
\ ],
\ 'tbody': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'td': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'headers': [], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'textarea': [
\ [''],
\ { 'ondblclick': [], 'cols': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'rows': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onselect': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'tfoot': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'th': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'pre', 'dl', 'div', 'noscript', 'blockquote', 'form', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'headers': [], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'thead': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'title': [
\ [''],
\ { 'lang': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'tr': [
\ ['th', 'td'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'tt': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ul': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'var': [
\ ['tt', 'i', 'b', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'object', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'vimxmlattrinfo' : {
\ 'accept' : ['ContentType', ''],
\ 'accesskey' : ['Character', ''],
\ 'action' : ['*URI', ''],
\ 'align' : ['String', ''],
\ 'alt' : ['*Text', ''],
\ 'archive' : ['UriList', ''],
\ 'axis' : ['CDATA', ''],
\ 'border' : ['Pixels', ''],
\ 'cellpadding' : ['Length', ''],
\ 'cellspacing' : ['Length', ''],
\ 'char' : ['Character', ''],
\ 'charoff' : ['Length', ''],
\ 'charset' : ['LangCode', ''],
\ 'checked' : ['Bool', ''],
\ 'class' : ['CDATA', ''],
\ 'codetype' : ['ContentType', ''],
\ 'cols' : ['*Number', ''],
\ 'colspan' : ['Number', ''],
\ 'content' : ['*CDATA', ''],
\ 'coords' : ['Coords', ''],
\ 'data' : ['URI', ''],
\ 'datetime' : ['DateTime', ''],
\ 'declare' : ['Bool', ''],
\ 'defer' : ['Bool', ''],
\ 'dir' : ['String', ''],
\ 'disabled' : ['Bool', ''],
\ 'enctype' : ['ContentType', ''],
\ 'for' : ['ID', ''],
\ 'headers' : ['IDREFS', ''],
\ 'height' : ['Number', ''],
\ 'href' : ['*URI', ''],
\ 'hreflang' : ['LangCode', ''],
\ 'id' : ['ID', ''],
\ 'ismap' : ['Bool', ''],
\ 'label' : ['*Text', ''],
\ 'lang' : ['LangCode', ''],
\ 'longdesc' : ['URI', ''],
\ 'maxlength' : ['Number', ''],
\ 'media' : ['MediaDesc', ''],
\ 'method' : ['String', ''],
\ 'multiple' : ['Bool', ''],
\ 'name' : ['CDATA', ''],
\ 'nohref' : ['Bool', ''],
\ 'onblur' : ['Script', ''],
\ 'onchange' : ['Script', ''],
\ 'onclick' : ['Script', ''],
\ 'ondblclick' : ['Script', ''],
\ 'onfocus' : ['Script', ''],
\ 'onkeydown' : ['Script', ''],
\ 'onkeypress' : ['Script', ''],
\ 'onkeyup' : ['Script', ''],
\ 'onload' : ['Script', ''],
\ 'onmousedown' : ['Script', ''],
\ 'onmousemove' : ['Script', ''],
\ 'onmouseout' : ['Script', ''],
\ 'onmouseover' : ['Script', ''],
\ 'onmouseup' : ['Script', ''],
\ 'onreset' : ['Script', ''],
\ 'onselect' : ['Script', ''],
\ 'onsubmit' : ['Script', ''],
\ 'onunload' : ['Script', ''],
\ 'profile' : ['URI', ''],
\ 'readonly' : ['Bool', ''],
\ 'rel' : ['LinkTypes', ''],
\ 'rev' : ['LinkTypes', ''],
\ 'rows' : ['*Number', ''],
\ 'rules' : ['String', ''],
\ 'scheme' : ['CDATA', ''],
\ 'selected' : ['Bool', ''],
\ 'shape' : ['Shape', ''],
\ 'size' : ['CDATA', ''],
\ 'span' : ['Number', ''],
\ 'src' : ['*URI', ''],
\ 'standby' : ['Text', ''],
\ 'style' : ['StyleSheet', ''],
\ 'summary' : ['*Text', ''],
\ 'tabindex' : ['Number', ''],
\ 'title' : ['Text', ''],
\ 'type' : ['*ContentType', ''],
\ 'usemap' : ['URI', ''],
\ 'valign' : ['String', ''],
\ 'valuetype' : ['String', ''],
\ 'width' : ['Number', ''],
\ 'xmlns' : ['URI', '']
\ },
\ 'vimxmltaginfo': {
\ 'area': ['/>', ''],
\ 'base': ['/>', ''],
\ 'br': ['/>', ''],
\ 'col': ['/>', ''],
\ 'hr': ['/>', ''],
\ 'img': ['/>', ''],
\ 'input': ['/>', ''],
\ 'link': ['/>', ''],
\ 'meta': ['/>', ''],
\ 'param': ['/>', ''],
\ }
\ }
                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/share/vim/vim74/autoload/xml/html401t.vim                                                       0100644 0000000 0000000 00000150673 13050207306 017433  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        let g:xmldata_html401t = {
\ 'vimxmlentities': ['AElig', 'Aacute', 'Acirc', 'Agrave', 'Alpha', 'Aring', 'Atilde', 'Auml', 'Beta', 'Ccedil', 'Chi', 'Dagger', 'Delta', 'ETH', 'Eacute', 'Ecirc', 'Egrave', 'Epsilon', 'Eta', 'Euml', 'Gamma', 'Iacute', 'Icirc', 'Igrave', 'Iota', 'Iuml', 'Kappa', 'Lambda', 'Mu', 'Ntilde', 'Nu', 'OElig', 'Oacute', 'Ocirc', 'Ograve', 'Omega', 'Omicron', 'Oslash', 'Otilde', 'Ouml', 'Phi', 'Pi', 'Prime', 'Psi', 'Rho', 'Scaron', 'Sigma', 'THORN', 'Tau', 'Theta', 'Uacute', 'Ucirc', 'Ugrave', 'Upsilon', 'Uuml', 'Xi', 'Yacute', 'Yuml', 'Zeta', 'aacute', 'acirc', 'acute', 'aelig', 'agrave', 'alefsym', 'alpha', 'amp', 'and', 'ang', 'apos', 'aring', 'asymp', 'atilde', 'auml', 'bdquo', 'beta', 'brvbar', 'bull', 'cap', 'ccedil', 'cedil', 'cent', 'chi', 'circ', 'clubs', 'cong', 'copy', 'crarr', 'cup', 'curren', 'dArr', 'dagger', 'darr', 'deg', 'delta', 'diams', 'divide', 'eacute', 'ecirc', 'egrave', 'empty', 'emsp', 'ensp', 'epsilon', 'equiv', 'eta', 'eth', 'euml', 'euro', 'exist', 'fnof', 'forall', 'frac12', 'frac14', 'frac34', 'frasl', 'gamma', 'ge', 'gt', 'hArr', 'harr', 'hearts', 'hellip', 'iacute', 'icirc', 'iexcl', 'igrave', 'image', 'infin', 'int', 'iota', 'iquest', 'isin', 'iuml', 'kappa', 'lArr', 'lambda', 'lang', 'laquo', 'larr', 'lceil', 'ldquo', 'le', 'lfloor', 'lowast', 'loz', 'lrm', 'lsaquo', 'lsquo', 'lt', 'macr', 'mdash', 'micro', 'middot', 'minus', 'mu', 'nabla', 'nbsp', 'ndash', 'ne', 'ni', 'not', 'notin', 'nsub', 'ntilde', 'nu', 'oacute', 'ocirc', 'oelig', 'ograve', 'oline', 'omega', 'omicron', 'oplus', 'or', 'ordf', 'ordm', 'oslash', 'otilde', 'otimes', 'ouml', 'para', 'part', 'permil', 'perp', 'phi', 'pi', 'piv', 'plusmn', 'pound', 'prime', 'prod', 'prop', 'psi', 'quot', 'rArr', 'radic', 'rang', 'raquo', 'rarr', 'rceil', 'rdquo', 'real', 'reg', 'rfloor', 'rho', 'rlm', 'rsaquo', 'rsquo', 'sbquo', 'scaron', 'sdot', 'sect', 'shy', 'sigma', 'sigmaf', 'sim', 'spades', 'sub', 'sube', 'sum', 'sup', 'sup1', 'sup2', 'sup3', 'supe', 'szlig', 'tau', 'there4', 'theta', 'thetasym', 'thinsp', 'thorn', 'tilde', 'times', 'trade', 'uArr', 'uacute', 'uarr', 'ucirc', 'ugrave', 'uml', 'upsih', 'upsilon', 'uuml', 'weierp', 'xi', 'yacute', 'yen', 'yuml', 'zeta', 'zwj', 'zwnj'],
\ 'vimxmlroot': ['html'],
\ 'a': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'rel': [], 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'target': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'tabindex': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'shape': ['rect', 'circle', 'poly', 'default']}
\ ],
\ 'abbr': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'acronym': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'address': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'p'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'applet': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'object': [], 'id': [], 'code': [], 'vspace': [], 'archive': [], 'alt': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'style': [], 'name': [], 'height': [], 'hspace': [], 'title': [], 'class': [], 'codebase': []}
\ ],
\ 'area': [
\ [],
\ { 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'target': [], 'nohref': ['BOOL'], 'onfocus': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'alt': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'shape': ['rect', 'circle', 'poly', 'default'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'b': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'base': [
\ [],
\ { 'target': [], 'href': []}
\ ],
\ 'basefont': [
\ [],
\ { 'size': [], 'face': [], 'color': [], 'id': []}
\ ],
\ 'bdo': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'big': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'blockquote': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'body': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'ins', 'del'],
\ { 'vlink': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'alink': [], 'onkeyup': [], 'bgcolor': [], 'text': [], 'onmouseup': [], 'id': [], 'link': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'background': [], 'onunload': [], 'onkeypress': [], 'onmousedown': [], 'onload': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'br': [
\ [],
\ { 'clear': ['none', 'left', 'all', 'right', 'none'], 'id': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'button': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'hr', 'table', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo'],
\ { 'accesskey': [], 'disabled': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'tabindex': [], 'value': [], 'name': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': ['submit', 'button', 'submit', 'reset']}
\ ],
\ 'caption': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'center': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'cite': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'code': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'col': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'colgroup': [
\ ['col'],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dd': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'del': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dfn': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dir': [
\ ['li'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'div': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dl': [
\ ['dt', 'dd'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'em': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'fieldset': [
\ ['legend', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'font': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'size': [], 'face': [], 'color': [], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'form': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'enctype': ['application/x-www-form-urlencoded'], 'onsubmit': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'target': [], 'onkeyup': [], 'onmouseup': [], 'onreset': [], 'id': [], 'method': ['GET', 'POST'], 'onmouseover': [], 'lang': [], 'accept': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'accept-charset': [], 'onkeypress': [], 'onmousedown': [], 'action': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h1': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h2': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h3': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h4': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h5': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h6': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'head': [
\ ['title', 'isindex', 'base', 'script', 'style', 'meta', 'link', 'object'],
\ { 'profile': [], 'dir': ['ltr', 'rtl'], 'lang': []}
\ ],
\ 'hr': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'size': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'noshade': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'html': [
\ ['head', 'body'],
\ { 'dir': ['ltr', 'rtl'], 'lang': [], 'version': ['-//W3C//DTD HTML 4.01 Transitional//EN']}
\ ],
\ 'i': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'iframe': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'scrolling': ['auto', 'yes', 'no', 'auto'], 'marginwidth': [], 'id': [], 'marginheight': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'longdesc': [], 'src': [], 'style': [], 'name': [], 'height': [], 'frameborder': ['1', '0'], 'title': [], 'class': []}
\ ],
\ 'img': [
\ [],
\ { 'width': [], 'usemap': [], 'ismap': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'vspace': [], 'onmouseover': [], 'alt': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'src': [], 'longdesc': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'height': [], 'border': [], 'hspace': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'input': [
\ [],
\ { 'ondblclick': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'value': [], 'src': [], 'name': [], 'checked': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'type': ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'IMAGE', 'BUTTON'], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'usemap': [], 'ismap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'maxlength': [], 'onselect': [], 'tabindex': [], 'accept': [], 'alt': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ins': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'cite': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'isindex': [
\ [],
\ { 'id': [], 'lang': [], 'prompt': [], 'class': [], 'title': [], 'dir': ['ltr', 'rtl'], 'style': []}
\ ],
\ 'kbd': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'label': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'for': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'legend': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'li': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'link': [
\ [],
\ { 'rel': [], 'ondblclick': [], 'onkeydown': [], 'target': [], 'onkeyup': [], 'href': [], 'media': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'map': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'area'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'menu': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'meta': [
\ [],
\ { 'http-equiv': [], 'content': [], 'lang': [], 'name': [], 'scheme': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'noframes': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'noscript': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'object': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'name': [], 'data': [], 'declare': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'width': [], 'usemap': [], 'dir': ['ltr', 'rtl'], 'vspace': [], 'tabindex': [], 'standby': [], 'archive': [], 'classid': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'height': [], 'border': [], 'codetype': [], 'hspace': [], 'codebase': []}
\ ],
\ 'ol': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'start': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'optgroup': [
\ ['option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'option': [
\ [''],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'selected': ['BOOL']}
\ ],
\ 'p': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'param': [
\ [],
\ { 'id': [], 'value': [], 'name': [], 'type': [], 'valuetype': ['DATA', 'REF', 'OBJECT']}
\ ],
\ 'pre': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'br', 'script', 'map', 'q', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'width': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'q': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'cite': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 's': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'samp': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'script': [
\ [],
\ { 'src': [], 'for': [], 'charset': [], 'event': [], 'type': [], 'defer': ['BOOL'], 'language': []}
\ ],
\ 'select': [
\ ['optgroup', 'option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'multiple': ['BOOL']}
\ ],
\ 'small': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'span': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strike': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strong': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'style': [
\ [],
\ { 'media': [], 'lang': [], 'type': [], 'title': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'sub': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'sup': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'table': [
\ ['caption', 'col', 'colgroup', 'thead', 'tfoot', 'tbody'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'datapagesize': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'frame': ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'], 'rules': ['none', 'groups', 'rows', 'cols', 'all'], 'dir': ['ltr', 'rtl'], 'summary': [], 'bgcolor': [], 'cellspacing': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'border': [], 'cellpadding': []}
\ ],
\ 'tbody': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'td': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'textarea': [
\ [''],
\ { 'ondblclick': [], 'cols': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'rows': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onselect': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'tfoot': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'th': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'thead': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'title': [
\ [''],
\ { 'lang': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'tr': [
\ ['th', 'td'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'tt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'u': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ul': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': ['disc', 'square', 'circle'], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'var': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'vimxmlattrinfo' : {
\ 'accept' : ['ContentType', ''],
\ 'accesskey' : ['Character', ''],
\ 'action' : ['*URI', ''],
\ 'align' : ['String', ''],
\ 'alt' : ['*Text', ''],
\ 'archive' : ['UriList', ''],
\ 'axis' : ['CDATA', ''],
\ 'border' : ['Pixels', ''],
\ 'cellpadding' : ['Length', ''],
\ 'cellspacing' : ['Length', ''],
\ 'char' : ['Character', ''],
\ 'charoff' : ['Length', ''],
\ 'charset' : ['LangCode', ''],
\ 'checked' : ['Bool', ''],
\ 'class' : ['CDATA', ''],
\ 'codetype' : ['ContentType', ''],
\ 'cols' : ['*Number', ''],
\ 'colspan' : ['Number', ''],
\ 'content' : ['*CDATA', ''],
\ 'coords' : ['Coords', ''],
\ 'data' : ['URI', ''],
\ 'datetime' : ['DateTime', ''],
\ 'declare' : ['Bool', ''],
\ 'defer' : ['Bool', ''],
\ 'dir' : ['String', ''],
\ 'disabled' : ['Bool', ''],
\ 'enctype' : ['ContentType', ''],
\ 'for' : ['ID', ''],
\ 'headers' : ['IDREFS', ''],
\ 'height' : ['Number', ''],
\ 'href' : ['*URI', ''],
\ 'hreflang' : ['LangCode', ''],
\ 'id' : ['ID', ''],
\ 'ismap' : ['Bool', ''],
\ 'label' : ['*Text', ''],
\ 'lang' : ['LangCode', ''],
\ 'longdesc' : ['URI', ''],
\ 'maxlength' : ['Number', ''],
\ 'media' : ['MediaDesc', ''],
\ 'method' : ['String', ''],
\ 'multiple' : ['Bool', ''],
\ 'name' : ['CDATA', ''],
\ 'nohref' : ['Bool', ''],
\ 'onblur' : ['Script', ''],
\ 'onchange' : ['Script', ''],
\ 'onclick' : ['Script', ''],
\ 'ondblclick' : ['Script', ''],
\ 'onfocus' : ['Script', ''],
\ 'onkeydown' : ['Script', ''],
\ 'onkeypress' : ['Script', ''],
\ 'onkeyup' : ['Script', ''],
\ 'onload' : ['Script', ''],
\ 'onmousedown' : ['Script', ''],
\ 'onmousemove' : ['Script', ''],
\ 'onmouseout' : ['Script', ''],
\ 'onmouseover' : ['Script', ''],
\ 'onmouseup' : ['Script', ''],
\ 'onreset' : ['Script', ''],
\ 'onselect' : ['Script', ''],
\ 'onsubmit' : ['Script', ''],
\ 'onunload' : ['Script', ''],
\ 'profile' : ['URI', ''],
\ 'readonly' : ['Bool', ''],
\ 'rel' : ['LinkTypes', ''],
\ 'rev' : ['LinkTypes', ''],
\ 'rows' : ['*Number', ''],
\ 'rules' : ['String', ''],
\ 'scheme' : ['CDATA', ''],
\ 'selected' : ['Bool', ''],
\ 'shape' : ['Shape', ''],
\ 'size' : ['CDATA', ''],
\ 'span' : ['Number', ''],
\ 'src' : ['*URI', ''],
\ 'standby' : ['Text', ''],
\ 'style' : ['StyleSheet', ''],
\ 'summary' : ['*Text', ''],
\ 'tabindex' : ['Number', ''],
\ 'title' : ['Text', ''],
\ 'type' : ['*ContentType', ''],
\ 'usemap' : ['URI', ''],
\ 'valign' : ['String', ''],
\ 'valuetype' : ['String', ''],
\ 'width' : ['Number', ''],
\ 'xmlns' : ['URI', '']
\ },
\ 'vimxmltaginfo': {
\ 'area': ['/>', ''],
\ 'base': ['/>', ''],
\ 'basefont': ['/>', ''],
\ 'br': ['/>', ''],
\ 'col': ['/>', ''],
\ 'hr': ['/>', ''],
\ 'img': ['/>', ''],
\ 'input': ['/>', ''],
\ 'isindex': ['/>', ''],
\ 'link': ['/>', ''],
\ 'meta': ['/>', ''],
\ 'param': ['/>', ''],
\ }
\ }
                                                                     usr/share/vim/vim74/autoload/xml/html40f.vim                                                        0100644 0000000 0000000 00000151415 13050207306 017327  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        let g:xmldata_html40t = {
\ 'vimxmlentities': ['AElig', 'Aacute', 'Acirc', 'Agrave', 'Alpha', 'Aring', 'Atilde', 'Auml', 'Beta', 'Ccedil', 'Chi', 'Dagger', 'Delta', 'ETH', 'Eacute', 'Ecirc', 'Egrave', 'Epsilon', 'Eta', 'Euml', 'Gamma', 'Iacute', 'Icirc', 'Igrave', 'Iota', 'Iuml', 'Kappa', 'Lambda', 'Mu', 'Ntilde', 'Nu', 'OElig', 'Oacute', 'Ocirc', 'Ograve', 'Omega', 'Omicron', 'Oslash', 'Otilde', 'Ouml', 'Phi', 'Pi', 'Prime', 'Psi', 'Rho', 'Scaron', 'Sigma', 'THORN', 'Tau', 'Theta', 'Uacute', 'Ucirc', 'Ugrave', 'Upsilon', 'Uuml', 'Xi', 'Yacute', 'Yuml', 'Zeta', 'aacute', 'acirc', 'acute', 'aelig', 'agrave', 'alefsym', 'alpha', 'amp', 'and', 'ang', 'apos', 'aring', 'asymp', 'atilde', 'auml', 'bdquo', 'beta', 'brvbar', 'bull', 'cap', 'ccedil', 'cedil', 'cent', 'chi', 'circ', 'clubs', 'cong', 'copy', 'crarr', 'cup', 'curren', 'dArr', 'dagger', 'darr', 'deg', 'delta', 'diams', 'divide', 'eacute', 'ecirc', 'egrave', 'empty', 'emsp', 'ensp', 'epsilon', 'equiv', 'eta', 'eth', 'euml', 'euro', 'exist', 'fnof', 'forall', 'frac12', 'frac14', 'frac34', 'frasl', 'gamma', 'ge', 'gt', 'hArr', 'harr', 'hearts', 'hellip', 'iacute', 'icirc', 'iexcl', 'igrave', 'image', 'infin', 'int', 'iota', 'iquest', 'isin', 'iuml', 'kappa', 'lArr', 'lambda', 'lang', 'laquo', 'larr', 'lceil', 'ldquo', 'le', 'lfloor', 'lowast', 'loz', 'lrm', 'lsaquo', 'lsquo', 'lt', 'macr', 'mdash', 'micro', 'middot', 'minus', 'mu', 'nabla', 'nbsp', 'ndash', 'ne', 'ni', 'not', 'notin', 'nsub', 'ntilde', 'nu', 'oacute', 'ocirc', 'oelig', 'ograve', 'oline', 'omega', 'omicron', 'oplus', 'or', 'ordf', 'ordm', 'oslash', 'otilde', 'otimes', 'ouml', 'para', 'part', 'permil', 'perp', 'phi', 'pi', 'piv', 'plusmn', 'pound', 'prime', 'prod', 'prop', 'psi', 'quot', 'rArr', 'radic', 'rang', 'raquo', 'rarr', 'rceil', 'rdquo', 'real', 'reg', 'rfloor', 'rho', 'rlm', 'rsaquo', 'rsquo', 'sbquo', 'scaron', 'sdot', 'sect', 'shy', 'sigma', 'sigmaf', 'sim', 'spades', 'sub', 'sube', 'sum', 'sup', 'sup1', 'sup2', 'sup3', 'supe', 'szlig', 'tau', 'there4', 'theta', 'thetasym', 'thinsp', 'thorn', 'tilde', 'times', 'trade', 'uArr', 'uacute', 'uarr', 'ucirc', 'ugrave', 'uml', 'upsih', 'upsilon', 'uuml', 'weierp', 'xi', 'yacute', 'yen', 'yuml', 'zeta', 'zwj', 'zwnj'],
\ 'vimxmlroot': ['html'],
\ 'a': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'rel': [], 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'target': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'tabindex': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'name': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'shape': ['rect', 'circle', 'poly', 'default']}
\ ],
\ 'abbr': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'acronym': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'address': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'p'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'applet': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'object': [], 'id': [], 'code': [], 'vspace': [], 'archive': [], 'alt': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'style': [], 'name': [], 'height': [], 'hspace': [], 'title': [], 'class': [], 'codebase': []}
\ ],
\ 'area': [
\ [],
\ { 'accesskey': [], 'coords': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'target': [], 'nohref': ['BOOL'], 'onfocus': [], 'onkeyup': [], 'href': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'alt': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'shape': ['rect', 'circle', 'poly', 'default'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'b': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'base': [
\ [],
\ { 'target': [], 'href': []}
\ ],
\ 'basefont': [
\ [],
\ { 'size': [], 'face': [], 'color': [], 'id': []}
\ ],
\ 'bdo': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'big': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'blockquote': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'body': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button', 'ins', 'del'],
\ { 'vlink': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'alink': [], 'onkeyup': [], 'bgcolor': [], 'text': [], 'onmouseup': [], 'id': [], 'link': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'background': [], 'onunload': [], 'onkeypress': [], 'onmousedown': [], 'onload': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'br': [
\ [],
\ { 'clear': ['none', 'left', 'all', 'right', 'none'], 'id': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'button': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'hr', 'table', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo'],
\ { 'accesskey': [], 'disabled': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onkeydown': [], 'onfocus': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'tabindex': [], 'value': [], 'name': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': ['submit', 'button', 'submit', 'reset']}
\ ],
\ 'caption': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'center': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'cite': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'code': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'col': [
\ [],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'colgroup': [
\ ['col'],
\ { 'width': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'charoff': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'char': [], 'span': ['1'], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dd': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'del': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'cite': [], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dfn': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dir': [
\ ['li'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'div': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'dl': [
\ ['dt', 'dd'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'dt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'em': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'fieldset': [
\ ['legend', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'font': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'dir': ['ltr', 'rtl'], 'size': [], 'face': [], 'color': [], 'id': [], 'lang': [], 'style': [], 'class': [], 'title': []}
\ ],
\ 'form': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'enctype': ['application/x-www-form-urlencoded'], 'onsubmit': [], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'target': [], 'onkeyup': [], 'onmouseup': [], 'onreset': [], 'id': [], 'method': ['GET', 'POST'], 'onmouseover': [], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'accept-charset': [], 'onkeypress': [], 'onmousedown': [], 'action': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h1': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h2': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h3': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h4': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h5': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'h6': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'head': [
\ ['title', 'isindex', 'base', 'script', 'style', 'meta', 'link', 'object'],
\ { 'profile': [], 'dir': ['ltr', 'rtl'], 'lang': []}
\ ],
\ 'hr': [
\ [],
\ { 'width': [], 'ondblclick': [], 'size': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right'], 'style': [], 'onmousemove': [], 'onmouseout': [], 'noshade': ['BOOL'], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'html': [
\ ['head', 'frameset'],
\ { 'xmlns': ['http://www.w3.org/1999/xhtml'], 'dir': ['ltr', 'rtl'], 'id': [], 'lang': [], 'xml:lang': []}
\ ],
\ 'frameset': [
\ ['frameset', 'frame', 'noframes'],
\ { 'rows': [], 'cols': [], 'id': [], 'style': [], 'onunload': [], 'onload': [], 'class': [], 'title': []}
\ ],
\ 'frame': [
\ [],
\ { 'scrolling': ['auto', 'yes', 'no', 'auto'], 'noresize': ['BOOL'], 'marginwidth': [], 'id': [], 'marginheight': [], 'longdesc': [], 'src': [], 'style': [], 'name': [], 'frameborder': ['1', '0'], 'title': [], 'class': []}
\ ],
\ 'i': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': []}
\ ],
\ 'iframe': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'width': [], 'scrolling': ['auto', 'yes', 'no', 'auto'], 'marginwidth': [], 'id': [], 'marginheight': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'longdesc': [], 'src': [], 'style': [], 'name': [], 'height': [], 'frameborder': ['1', '0'], 'title': [], 'class': []}
\ ],
\ 'img': [
\ [],
\ { 'width': [], 'usemap': [], 'ismap': ['BOOL'], 'ondblclick': [], 'dir': ['ltr', 'rtl'], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'vspace': [], 'onmouseover': [], 'alt': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'src': [], 'longdesc': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'border': [], 'hspace': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': []}
\ ],
\ 'input': [
\ [],
\ { 'ondblclick': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'value': [], 'src': [], 'name': [], 'checked': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'type': ['TEXT', 'PASSWORD', 'CHECKBOX', 'RADIO', 'SUBMIT', 'RESET', 'FILE', 'IMAGE', 'BUTTON'], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'usemap': [], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'maxlength': [], 'onselect': [], 'accept': [], 'alt': [], 'tabindex': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ins': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'datetime': [], 'cite': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'isindex': [
\ [],
\ { 'id': [], 'lang': [], 'prompt': [], 'class': [], 'title': [], 'dir': ['ltr', 'rtl'], 'style': []}
\ ],
\ 'kbd': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'label': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'for': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'legend': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['top', 'bottom', 'left', 'right'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'li': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'link': [
\ [],
\ { 'rel': [], 'ondblclick': [], 'onkeydown': [], 'target': [], 'onkeyup': [], 'href': [], 'media': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'charset': [], 'hreflang': [], 'onkeypress': [], 'onmousedown': [], 'rev': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'map': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'area'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'menu': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'meta': [
\ [],
\ { 'http-equiv': [], 'content': [], 'lang': [], 'name': [], 'scheme': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'noframes': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'noscript': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'object': [
\ ['param', 'p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['top', 'middle', 'bottom', 'left', 'right'], 'name': [], 'data': [], 'declare': ['BOOL'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'type': [], 'width': [], 'usemap': [], 'dir': ['ltr', 'rtl'], 'vspace': [], 'tabindex': [], 'standby': [], 'archive': [], 'classid': [], 'style': [], 'onmousemove': [], 'onmouseout': [], 'height': [], 'border': [], 'codetype': [], 'hspace': [], 'codebase': []}
\ ],
\ 'ol': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': [], 'class': [], 'title': [], 'onclick': [], 'start': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'optgroup': [
\ ['option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'option': [
\ [''],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'value': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'label': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': [], 'selected': ['BOOL']}
\ ],
\ 'p': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify'], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'param': [
\ [],
\ { 'id': [], 'value': [], 'name': [], 'type': [], 'valuetype': ['DATA', 'REF', 'OBJECT']}
\ ],
\ 'pre': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'br', 'script', 'map', 'q', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'width': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'q': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'cite': [], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 's': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'samp': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'script': [
\ [],
\ { 'src': [], 'for': [], 'charset': [], 'event': [], 'type': [], 'defer': ['BOOL'], 'language': []}
\ ],
\ 'select': [
\ ['optgroup', 'option'],
\ { 'ondblclick': [], 'onkeydown': [], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'disabled': ['BOOL'], 'dir': ['ltr', 'rtl'], 'size': [], 'onblur': [], 'onfocus': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'multiple': ['BOOL']}
\ ],
\ 'small': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'span': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strike': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'strong': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'style': [
\ [],
\ { 'media': [], 'lang': [], 'type': [], 'title': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'sub': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'sup': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'table': [
\ ['caption', 'col', 'colgroup', 'thead', 'tfoot', 'tbody'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'datapagesize': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'frame': ['void', 'above', 'below', 'hsides', 'lhs', 'rhs', 'vsides', 'box', 'border'], 'rules': ['none', 'groups', 'rows', 'cols', 'all'], 'dir': ['ltr', 'rtl'], 'summary': [], 'bgcolor': [], 'cellspacing': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'border': [], 'cellpadding': []}
\ ],
\ 'tbody': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'td': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'textarea': [
\ [''],
\ { 'ondblclick': [], 'cols': [], 'onkeydown': [], 'readonly': ['BOOL'], 'onchange': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'name': [], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'accesskey': [], 'disabled': ['BOOL'], 'rows': [], 'dir': ['ltr', 'rtl'], 'onblur': [], 'onfocus': [], 'onselect': [], 'tabindex': [], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'tfoot': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'th': [
\ ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'ul', 'ol', 'dir', 'menu', 'pre', 'dl', 'div', 'center', 'noscript', 'noframes', 'blockquote', 'form', 'isindex', 'hr', 'table', 'fieldset', 'address', 'tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'axis': [], 'onkeydown': [], 'abbr': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'scope': ['row', 'col', 'rowgroup', 'colgroup'], 'onmouseover': [], 'lang': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'width': [], 'headers': [], 'nowrap': ['BOOL'], 'dir': ['ltr', 'rtl'], 'rowspan': ['1'], 'colspan': ['1'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'height': [], 'char': []}
\ ],
\ 'thead': [
\ ['tr'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'title': [
\ [''],
\ { 'lang': [], 'dir': ['ltr', 'rtl']}
\ ],
\ 'tr': [
\ ['th', 'td'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'align': ['left', 'center', 'right', 'justify', 'char'], 'lang': [], 'valign': ['top', 'middle', 'bottom', 'baseline'], 'onkeypress': [], 'onmousedown': [], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'bgcolor': [], 'charoff': [], 'onmouseout': [], 'onmousemove': [], 'style': [], 'char': []}
\ ],
\ 'tt': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'u': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'ul': [
\ ['li'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'compact': ['BOOL'], 'onmouseover': [], 'lang': [], 'onkeypress': [], 'onmousedown': [], 'type': ['disc', 'square', 'circle'], 'class': [], 'title': [], 'onclick': [], 'dir': ['ltr', 'rtl'], 'onmouseout': [], 'onmousemove': [], 'style': []}
\ ],
\ 'var': [
\ ['tt', 'i', 'b', 'u', 's', 'strike', 'big', 'small', 'em', 'strong', 'dfn', 'code', 'samp', 'kbd', 'var', 'cite', 'abbr', 'acronym', 'a', 'img', 'applet', 'object', 'font', 'basefont', 'br', 'script', 'map', 'q', 'sub', 'sup', 'span', 'bdo', 'iframe', 'input', 'select', 'textarea', 'label', 'button'],
\ { 'ondblclick': [], 'onkeydown': [], 'onkeyup': [], 'onmouseup': [], 'id': [], 'onmouseover': [], 'lang': [], 'onmousedown': [], 'onkeypress': [], 'onclick': [], 'title': [], 'class': [], 'dir': ['ltr', 'rtl'], 'style': [], 'onmousemove': [], 'onmouseout': []}
\ ],
\ 'vimxmlattrinfo' : {
\ 'accept' : ['ContentType', ''],
\ 'accesskey' : ['Character', ''],
\ 'action' : ['*URI', ''],
\ 'align' : ['String', ''],
\ 'alt' : ['*Text', ''],
\ 'archive' : ['UriList', ''],
\ 'axis' : ['CDATA', ''],
\ 'border' : ['Pixels', ''],
\ 'cellpadding' : ['Length', ''],
\ 'cellspacing' : ['Length', ''],
\ 'char' : ['Character', ''],
\ 'charoff' : ['Length', ''],
\ 'charset' : ['LangCode', ''],
\ 'checked' : ['Bool', ''],
\ 'class' : ['CDATA', ''],
\ 'codetype' : ['ContentType', ''],
\ 'cols' : ['*Number', ''],
\ 'colspan' : ['Number', ''],
\ 'content' : ['*CDATA', ''],
\ 'coords' : ['Coords', ''],
\ 'data' : ['URI', ''],
\ 'datetime' : ['DateTime', ''],
\ 'declare' : ['Bool', ''],
\ 'defer' : ['Bool', ''],
\ 'dir' : ['String', ''],
\ 'disabled' : ['Bool', ''],
\ 'enctype' : ['ContentType', ''],
\ 'for' : ['ID', ''],
\ 'headers' : ['IDREFS', ''],
\ 'height' : ['Number', ''],
\ 'href' : ['*URI', ''],
\ 'hreflang' : ['LangCode', ''],
\ 'id' : ['ID', '