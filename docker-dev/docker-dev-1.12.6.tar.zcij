 IOAudioEngineStatus
 * @abstract Shared-memory structure giving audio engine status
 * @discussion
 * @field fVersion Indicates version of this structure
 * @field fCurrentLoopCount Number of times around the ring buffer since the audio engine started
 * @field fLastLoopTime Timestamp of the last time the ring buffer wrapped
 * @field fEraseHeadSampleFrame Location of the erase head in sample frames - erased up to but not
 *        including the given sample frame
 */

typedef struct _IOAudioEngineStatus {
    UInt32					fVersion;
    volatile UInt32			fCurrentLoopCount;
    volatile AbsoluteTime                    fLastLoopTime;
    volatile UInt32			fEraseHeadSampleFrame;
} IOAudioEngineStatus;

#define kIOAudioEngineCurrentStatusStructVersion		2

typedef struct _IOAudioStreamFormat {
    UInt32	fNumChannels;
    UInt32	fSampleFormat;
    UInt32	fNumericRepresentation;
    UInt8	fBitDepth;
    UInt8	fBitWidth;
    UInt8	fAlignment;
    UInt8	fByteOrder;
    UInt8	fIsMixable;
    UInt32	fDriverTag;
} IOAudioStreamFormat;

#define kFormatExtensionInvalidVersion					0
#define kFormatExtensionCurrentVersion					1

typedef struct _IOAudioStreamFormatExtension {
    UInt32	fVersion;
    UInt32	fFlags;
    UInt32	fFramesPerPacket;
    UInt32	fBytesPerPacket;
} IOAudioStreamFormatExtension;

typedef struct _IOAudioBufferDataDescriptor {
	UInt32	fActualDataByteSize;
	UInt32	fActualNumSampleFrames;
	UInt32	fTotalDataByteSize;
	UInt32	fNominalDataByteSize;
	UInt8	fData[1];
} IOAudioBufferDataDescriptor;

#define kStreamDataDescriptorInvalidVersion				0
#define kStreamDataDescriptorCurrentVersion				1

typedef struct _IOAudioStreamDataDescriptor {
    UInt32	fVersion;
    UInt32	fNumberOfStreams;
    UInt32	fStreamLength[1];			// Array with fNumberOfStreams number of entries
} IOAudioStreamDataDescriptor;

typedef struct _IOAudioSampleIntervalDescriptor {
	UInt32	sampleIntervalHi;
	UInt32	sampleIntervalLo;
} IOAudioSampleIntervalDescriptor;

/*!
    @struct         SMPTETime
    @abstract       A structure for holding a SMPTE time.
    @field          fSubframes
                        The number of subframes in the full message.
    @field          fSubframeDivisor
                        The number of subframes per frame (typically 80).
    @field          fCounter
                        The total number of messages received.
    @field          fType
                        The kind of SMPTE time using the SMPTE time type constants.
    @field          fFlags
                        A set of flags that indicate the SMPTE state.
    @field          fHours
                        The number of hourse in the full message.
    @field          fMinutes
                        The number of minutes in the full message.
    @field          fSeconds
                        The number of seconds in the full message.
    @field          fFrames
                        The number of frames in the full message.
*/
typedef struct _IOAudioSMPTETime
{
    SInt16  fSubframes;
    SInt16  fSubframeDivisor;
    UInt32  fCounter;
    UInt32  fType;
    UInt32  fFlags;
    SInt16  fHours;
    SInt16  fMinutes;
    SInt16  fSeconds;
    SInt16  fFrames;

} IOAudioSMPTETime;

//	constants describing SMPTE types (taken from the MTC spec), <rdar://11955717>
enum
{
	kIOAudioSMPTETimeType24			= 0,
	kIOAudioSMPTETimeType25			= 1,
	kIOAudioSMPTETimeType30Drop		= 2,
	kIOAudioSMPTETimeType30			= 3,
	kIOAudioSMPTETimeType2997		= 4,
	kIOAudioSMPTETimeType2997Drop	= 5,
    kIOAudioSMPTETimeType60         = 6,
    kIOAudioSMPTETimeType5994       = 7,
    kIOAudioSMPTETimeType60Drop     = 8,
    kIOAudioSMPTETimeType5994Drop   = 9,
    kIOAudioSMPTETimeType50         = 10,
    kIOAudioSMPTETimeType2398       = 11
};

//	flags describing a SMPTE time stamp
enum
{
	kIOAudioSMPTETimeValid		= (1L << 0),	//	the full time is valid
	kIOAudioSMPTETimeRunning	= (1L << 1)		//	time is running
};

//	A struct for encapsulating the parts of a time stamp. The flags
//	say which fields are valid.
typedef struct _IOAudioTimeStamp
{
	UInt64				fSampleTime;	//	the absolute sample time, was a Float64
	UInt64				fHostTime;		//	the host's root timebase's time
	UInt64				fRateScalar;	//	the system rate scalar, was a Float64
	UInt64				fWordClockTime;	//	the word clock time
	IOAudioSMPTETime	fSMPTETime;		//	the SMPTE time
	UInt32				fFlags;			//	the flags indicate which fields are valid
	UInt32				fReserved;		//	reserved, pads the structure out to force 8 byte alignment
} IOAudioTimeStamp;

//	flags for the AudioTimeStamp sturcture
enum
{
	kIOAudioTimeStampSampleTimeValid	= (1L << 0),
	kIOAudioTimeStampHostTimeValid		= (1L << 1),
	kIOAudioTimeStampRateScalarValid	= (1L << 2),
	kIOAudioTimeStampWordClockTimeValid	= (1L << 3),
	kIOAudioTimeStampSMPTETimeValid		= (1L << 4)
};

//	Some commonly used combinations of timestamp flags
enum
{
	kIOAudioTimeStampSampleHostTimeValid	= (kIOAudioTimeStampSampleTimeValid | kIOAudioTimeStampHostTimeValid)
};

/*!
* @enum IOAudioStreamDirection
 * @abstract Represents the direction of an IOAudioStream
 * @constant kIOAudioStreamDirectionOutput Output buffer
 * @constant kIOAudioStreamDirectionInput Input buffer
 */

typedef enum _IOAudioStreamDirection {
    kIOAudioStreamDirectionOutput	= 0,
    kIOAudioStreamDirectionInput	= 1
} IOAudioStreamDirection;

enum {
	kIOAudioDeviceCanBeDefaultNothing	= 0,
	kIOAudioDeviceCanBeDefaultInput		= (1L << 0),
	kIOAudioDeviceCanBeDefaultOutput	= (1L << 1),
	kIOAudioDeviceCanBeSystemOutput		= (1L << 2)
};

/*!
 * @defined kIOAudioEngineDefaultMixBufferSampleSize
 */

#define kIOAudioEngineDefaultMixBufferSampleSize		sizeof(float)

/* The following are for use only by the IOKit.framework audio family code */

/*!
 * @enum IOAudioControlCalls
 * @abstract The set of constants passed to IOAudioControlUserClient::getExternalMethodForIndex() when making calls
 *  from the IOAudioFamily user client code.
 * @constant kIOAudioControlCallSetValue Used to set the value of an IOAudioControl.
 * @constant kIOAudioControlCallGetValue Used to get the value of an IOAudioControl.
 */
typedef enum _IOAudioControlCalls {
    kIOAudioControlCallSetValue = 0,
    kIOAudioControlCallGetValue = 1
} IOAudioControlCalls;

/*! @defined kIOAudioControlNumCalls The number of elements in the IOAudioControlCalls enum. */
#define kIOAudioControlNumCalls 	2

/*!
 * @enum IOAudioControlNotifications
 * @abstract The set of constants passed in the type field of IOAudioControlUserClient::registerNotificaitonPort().
 * @constant kIOAudioControlValueChangeNotification Used to request value change notifications.
 * @constant kIOAudioControlRangeChangeNotification Used to request range change notifications.
 */
typedef enum _IOAudioControlNotifications {
    kIOAudioControlValueChangeNotification = 0,
	kIOAudioControlRangeChangeNotification = 1
} IOAudioControlNotifications;

/*!
 * @struct IOAudioNotificationMessage
 * @abstract Used in the mach message for IOAudio notifications.
 * @field messageHeader Standard mach message header
 * @field ref The param passed to registerNotificationPort() in refCon.
 */
typedef struct _IOAudioNotificationMessage {
    mach_msg_header_t	messageHeader;
    UInt32		type;
    UInt32		ref;
    void *		sender;
} IOAudioNotificationMessage;

typedef struct _IOAudioSampleRate {
    UInt32	whole;
    UInt32	fraction;
} IOAudioSampleRate;

#define kNoIdleAudioPowerDown		0xffffffffffffffffULL

enum {
    kIOAudioPortTypeOutput		= 'outp',
    kIOAudioPortTypeInput		= 'inpt',
    kIOAudioPortTypeMixer		= 'mixr',
    kIOAudioPortTypePassThru	= 'pass',
    kIOAudioPortTypeProcessing	= 'proc'
};

enum {
    kIOAudioOutputPortSubTypeInternalSpeaker	= 'ispk',
    kIOAudioOutputPortSubTypeExternalSpeaker	= 'espk',
    kIOAudioOutputPortSubTypeHeadphones			= 'hdpn',
    kIOAudioOutputPortSubTypeLine				= 'line',
    kIOAudioOutputPortSubTypeSPDIF				= 'spdf',
    
    kIOAudioInputPortSubTypeInternalMicrophone	= 'imic',
    kIOAudioInputPortSubTypeExternalMicrophone	= 'emic',
    kIOAudioInputPortSubTypeCD					= 'cd  ',
    kIOAudioInputPortSubTypeLine				= 'line',
    kIOAudioInputPortSubTypeSPDIF				= 'spdf'
};

enum {
    kIOAudioControlTypeLevel			= 'levl',
    kIOAudioControlTypeToggle			= 'togl',
	kIOAudioControlTypeJack				= 'jack',
    kIOAudioControlTypeSelector			= 'slct'
};

//	<rdar://8325563>	Added kIOAudioToggleControlSubTypePhantomPower, kIOAudioToggleControlSubTypePhaseInvert & 
//	kIOAudioSelectorControlSubTypeChannelHighPassFilter
enum {
    kIOAudioLevelControlSubTypeVolume						= 'vlme',
	kIOAudioLevelControlSubTypeLFEVolume					= 'subv',
	kIOAudioLevelControlSubTypePRAMVolume					= 'pram',
    kIOAudioToggleControlSubTypeMute						= 'mute',
    kIOAudioToggleControlSubTypeSolo						= 'solo',
	kIOAudioToggleControlSubTypeLFEMute						= 'subm',
	kIOAudioToggleControlSubTypeiSubAttach					= 'atch',
	kIOAudioToggleControlSubTypePhantomPower				= 'phan',
	kIOAudioToggleControlSubTypePhaseInvert					= 'phsi',
    kIOAudioSelectorControlSubTypeOutput					= 'outp',
    kIOAudioSelectorControlSubTypeInput						= 'inpt',
    kIOAudioSelectorControlSubTypeClockSource				= 'clck',
    kIOAudioSelectorControlSubTypeDestination				= 'dest',
	kIOAudioSelectorControlSubTypeChannelNominalLineLevel	= 'nlev',
	kIOAudioSelectorControlSubTypeChannelLevelPlus4dBu		= '4dbu',
	kIOAudioSelectorControlSubTypeChannelLevelMinus10dBV	= '10db',
	kIOAudioSelectorControlSubTypeChannelLevelMinus20dBV	= '20db',
	kIOAudioSelectorControlSubTypeChannelLevelMicLevel		= 'micl',
	kIOAudioSelectorControlSubTypeChannelLevelInstrumentLevel		= 'istl',
	kIOAudioSelectorControlSubTypeChannelHighPassFilter		= 'hipf'
};

enum {
    kIOAudioControlUsageOutput				= 'outp',
    kIOAudioControlUsageInput				= 'inpt',
    kIOAudioControlUsagePassThru			= 'pass',
    kIOAudioControlUsageCoreAudioProperty	= 'prop'
};

enum {
    kIOAudioControlChannelNumberInactive				= -1,
    kIOAudioControlChannelIDAll							= 0,
    kIOAudioControlChannelIDDefaultLeft					= 1,
    kIOAudioControlChannelIDDefaultRight				= 2,
    kIOAudioControlChannelIDDefaultCenter				= 3,
    kIOAudioControlChannelIDDefaultLeftRear				= 4,
    kIOAudioControlChannelIDDefaultRightRear			= 5,
    kIOAudioControlChannelIDDefaultSub					= 6,
    kIOAudioControlChannelIDDefaultFrontLeftCenter		= 7,
    kIOAudioControlChannelIDDefaultFrontRightCenter		= 8,
    kIOAudioControlChannelIDDefaultRearCenter			= 9,
    kIOAudioControlChannelIDDefaultSurroundLeft			= 10,
    kIOAudioControlChannelIDDefaultSurroundRight		= 11
};

enum {
    kIOAudioSelectorControlSelectionValueNone				= 'none',
    
    // Output-specific selection IDs 
    kIOAudioSelectorControlSelectionValueInternalSpeaker	= 'ispk',
    kIOAudioSelectorControlSelectionValueExternalSpeaker	= 'espk',
    kIOAudioSelectorControlSelectionValueHeadphones			= 'hdpn',
    
    // Input-specific selection IDs
    kIOAudioSelectorControlSelectionValueInternalMicrophone	= 'imic',
    kIOAudioSelectorControlSelectionValueExternalMicrophone	= 'emic',
    kIOAudioSelectorControlSelectionValueCD					= 'cd  ',
    
    // Common selection IDs
    kIOAudioSelectorControlSelectionValueLine				= 'line',
    kIOAudioSelectorControlSelectionValueSPDIF				= 'spdf'
};

enum {
    kIOAudioStreamSampleFormatLinearPCM		= 'lpcm',
    kIOAudioStreamSampleFormatIEEEFloat		= 'ieee',
    kIOAudioStreamSampleFormatALaw			= 'alaw',
    kIOAudioStreamSampleFormatMuLaw			= 'ulaw',
    kIOAudioStreamSampleFormatMPEG			= 'mpeg',
    kIOAudioStreamSampleFormatAC3			= 'ac-3',
    kIOAudioStreamSampleFormat1937AC3		= 'cac3',
    kIOAudioStreamSampleFormat1937MPEG1		= 'mpg1',
    kIOAudioStreamSampleFormat1937MPEG2		= 'mpg2',
	kIOAudioStreamSampleFormatTimeCode		= 'time'		//	a stream of IOAudioTimeStamp structures that capture any incoming time code information
};

enum {
    kIOAudioStreamNumericRepresentationSignedInt	= 'sint',
    kIOAudioStreamNumericRepresentationUnsignedInt	= 'uint',
	kIOAudioStreamNumericRepresentationIEEE754Float = 'flot'
};

enum {
	kIOAudioClockSelectorTypeInternal			= 'int ',
	kIOAudioClockSelectorTypeExternal			= 'ext ',
	kIOAudioClockSelectorTypeAESEBU				= 'asbu',
	kIOAudioClockSelectorTypeTOSLink			= 'tosl',
	kIOAudioClockSelectorTypeSPDIF				= 'spdf',
	kIOAudioClockSelectorTypeADATOptical		= 'adto',
	kIOAudioClockSelectorTypeADAT9Pin			= 'adt9',
	kIOAudioClockSelectorTypeSMPTE				= 'smpt',
	kIOAudioClockSelectorTypeVideo				= 'vdeo',
	kIOAudioClockSelectorTypeControl			= 'cnrl',
	kIOAudioClockSelectorTypeOther				= 'othr',
};

enum {
    kIOAudioStreamAlignmentLowByte					= 0,
    kIOAudioStreamAlignmentHighByte					= 1
};

enum {
    kIOAudioStreamByteOrderBigEndian				= 0,
    kIOAudioStreamByteOrderLittleEndian				= 1
};

enum {
    kIOAudioLevelControlNegativeInfinity			= 0xffffffff
};

enum {
    kIOAudioNewClockDomain							= 0xffffffff
};

// Device connection types
#ifndef __OPEN_SOURCE__
//	<rdar://7130813>	Added kIOAudioDeviceTransportTypeDisplayPort
#endif
enum {
	kIOAudioDeviceTransportTypeBuiltIn				= 'bltn',
	kIOAudioDeviceTransportTypePCI					= 'pci ',
	kIOAudioDeviceTransportTypeUSB					= 'usb ',
	kIOAudioDeviceTransportTypeFireWire				= '1394',
	kIOAudioDeviceTransportTypeNetwork				= 'ntwk',
	kIOAudioDeviceTransportTypeWireless				= 'wrls',
	kIOAudioDeviceTransportTypeOther				= 'othr',
	kIOAudioDeviceTransportTypeBluetooth			= 'blue',
	kIOAudioDeviceTransportTypeVirtual				= 'virt',
	kIOAudioDeviceTransportTypeDisplayPort			= 'dprt',
	kIOAudioDeviceTransportTypeHdmi					= 'hdmi',
    kIOAudioDeviceTransportTypeAVB            		= 'eavb',			//<rdar://10874672>
    kIOAudioDeviceTransportTypeThunderbolt    		= 'thun'			//<rdar://10874672>
};

// types that go nowhere
enum {
	OUTPUT_NULL										= 0x0100,
	INPUT_NULL										= 0x0101
};

// Input terminal types
enum {
	INPUT_UNDEFINED									= 0x0200,
	INPUT_MICROPHONE								= 0x0201,
	INPUT_DESKTOP_MICROPHONE						= 0x0202,
	INPUT_PERSONAL_MICROPHONE						= 0x0203,
	INPUT_OMNIDIRECTIONAL_MICROPHONE				= 0x0204,
	INPUT_MICROPHONE_ARRAY							= 0x0205,
	INPUT_PROCESSING_MICROPHONE_ARRAY				= 0x0206,
	INPUT_MODEM_AUDIO								= 0x207
};

// Output terminal types
enum {
	OUTPUT_UNDEFINED								= 0x0300,
	OUTPUT_SPEAKER									= 0x0301,
	OUTPUT_HEADPHONES								= 0x0302,
	OUTPUT_HEAD_MOUNTED_DISPLAY_AUDIO				= 0x0303,
	OUTPUT_DESKTOP_SPEAKER							= 0x0304,
	OUTPUT_ROOM_SPEAKER								= 0x0305,
	OUTPUT_COMMUNICATION_SPEAKER					= 0x0306,
	OUTPUT_LOW_FREQUENCY_EFFECTS_SPEAKER			= 0x0307
};

// Bi-directional terminal types
enum {
	BIDIRECTIONAL_UNDEFINED							= 0x0400,
	BIDIRECTIONAL_HANDSET							= 0x0401,
	BIDIRECTIONAL_HEADSET							= 0x0402,
	BIDIRECTIONAL_SPEAKERPHONE_NO_ECHO_REDX			= 0x0403,
	BIDIRECTIONAL_ECHO_SUPPRESSING_SPEAKERPHONE		= 0x0404,
	BIDIRECTIONAL_ECHO_CANCELING_SPEAKERPHONE		= 0x0405
};

// Telephony terminal types
enum {
	TELEPHONY_UNDEFINED								= 0x0500,
	TELEPHONY_PHONE_LINE							= 0x0501,
	TELEPHONY_TELEPHONE								= 0x0502,
	TELEPHONY_DOWN_LINE_PHONE						= 0x0503
};

// External terminal types
enum {
	EXTERNAL_UNDEFINED								= 0x0600,
	EXTERNAL_ANALOG_CONNECTOR						= 0x0601,
	EXTERNAL_DIGITAL_AUDIO_INTERFACE				= 0x0602,
	EXTERNAL_LINE_CONNECTOR							= 0x0603,
	EXTERNAL_LEGACY_AUDIO_CONNECTOR					= 0x0604,
	EXTERNAL_SPDIF_INTERFACE						= 0x0605,
	EXTERNAL_1394_DA_STREAM							= 0x0606,
	EXTERNAL_1394_DV_STREAM_SOUNDTRACK				= 0x0607,
	EXTERNAL_ADAT									= 0x0608,
	EXTERNAL_TDIF									= 0x0609,
	EXTERNAL_MADI									= 0x060A
};

// Embedded terminal types
enum {
	EMBEDDED_UNDEFINED								= 0x0700,
	EMBEDDED_LEVEL_CALIBRATION_NOISE_SOURCE			= 0x0701,
	EMBEDDED_EQUALIZATION_NOISE						= 0x0702,
	EMBEDDED_CD_PLAYER								= 0x0703,
	EMBEDDED_DAT									= 0x0704,
	EMBEDDED_DCC									= 0x0705,
	EMBEDDED_MINIDISK								= 0x0706,
	EMBEDDED_ANALOG_TAPE							= 0x0707,
	EMBEDDED_PHONOGRAPH								= 0x0708,
	EMBEDDED_VCR_AUDIO								= 0x0709,
	EMBEDDED_VIDEO_DISC_AUDIO						= 0x070A,
	EMBEDDED_DVD_AUDIO								= 0x070B,
	EMBEDDED_TV_TUNER_AUDIO							= 0x070C,
	EMBEDDED_SATELLITE_RECEIVER_AUDIO				= 0x070D,
	EMBEDDED_CABLE_TUNER_AUDIO						= 0x070E,
	EMBEDDED_DSS_AUDIO								= 0x070F,
	EMBEDDED_RADIO_RECEIVER							= 0x0710,
	EMBEDDED_RADIO_TRANSMITTER						= 0x0711,
	EMBEDDED_MULTITRACK_RECORDER					= 0x0712,
	EMBEDDED_SYNTHESIZER							= 0x0713
};

// Processing terminal types
enum {
	PROCESSOR_UNDEFINED								= 0x0800,
	PROCESSOR_GENERAL								= 0x0801
};

//	Channel spatial position types

#ifndef __OPEN_SOURCE__
//	<rdar://6868206>	NOTE: the following are derived from CoreAudioTypes.h
#endif

#define	kIOAudioChannelLabel_Discrete_field_ba		16
enum {
    kIOAudioChannelLabel_Unknown                  = 0xFFFFFFFF,   // unknown or unspecified other use
    kIOAudioChannelLabel_Unused                   = 0,            // channel is present, but has no intended use or destination
    kIOAudioChannelLabel_UseCoordinates           = 100,          // channel is described by the mCoordinates fields.
	
    kIOAudioChannelLabel_Left                     = 1,
    kIOAudioChannelLabel_Right                    = 2,
    kIOAudioChannelLabel_Center                   = 3,
    kIOAudioChannelLabel_LFEScreen                = 4,
    kIOAudioChannelLabel_LeftSurround             = 5,            // WAVE: "Back Left"
    kIOAudioChannelLabel_RightSurround            = 6,            // WAVE: "Back Right"
    kIOAudioChannelLabel_LeftCenter               = 7,
    kIOAudioChannelLabel_RightCenter              = 8,
    kIOAudioChannelLabel_CenterSurround           = 9,            // WAVE: "Back Center" or plain "Rear Surround"
    kIOAudioChannelLabel_LeftSurroundDirect       = 10,           // WAVE: "Side Left"
    kIOAudioChannelLabel_RightSurroundDirect      = 11,           // WAVE: "Side Right"
    kIOAudioChannelLabel_TopCenterSurround        = 12,
    kIOAudioChannelLabel_VerticalHeightLeft       = 13,           // WAVE: "Top Front Left"
    kIOAudioChannelLabel_VerticalHeightCenter     = 14,           // WAVE: "Top Front Center"
    kIOAudioChannelLabel_VerticalHeightRight      = 15,           // WAVE: "Top Front Right"
	
    kIOAudioChannelLabel_TopBackLeft              = 16,
    kIOAudioChannelLabel_TopBackCenter            = 17,
    kIOAudioChannelLabel_TopBackRight             = 18,
	
    kIOAudioChannelLabel_RearSurroundLeft         = 33,
    kIOAudioChannelLabel_RearSurroundRight        = 34,
    kIOAudioChannelLabel_LeftWide                 = 35,
    kIOAudioChannelLabel_RightWide                = 36,
    kIOAudioChannelLabel_LFE2                     = 37,
    kIOAudioChannelLabel_LeftTotal                = 38,           // matrix encoded 4 channels
    kIOAudioChannelLabel_RightTotal               = 39,           // matrix encoded 4 channels
    kIOAudioChannelLabel_HearingImpaired          = 40,
    kIOAudioChannelLabel_Narration                = 41,
    kIOAudioChannelLabel_Mono                     = 42,
    kIOAudioChannelLabel_DialogCentricMix         = 43,
	
    kIOAudioChannelLabel_CenterSurroundDirect     = 44,           // back center, non diffuse
    
    kIOAudioChannelLabel_Haptic                   = 45,
	
    // first order ambisonic channels
    kIOAudioChannelLabel_Ambisonic_W              = 200,
    kIOAudioChannelLabel_Ambisonic_X              = 201,
    kIOAudioChannelLabel_Ambisonic_Y              = 202,
    kIOAudioChannelLabel_Ambisonic_Z              = 203,
	
    // Mid/Side Recording
    kIOAudioChannelLabel_MS_Mid                   = 204,
    kIOAudioChannelLabel_MS_Side                  = 205,
	
    // X-Y Recording
    kIOAudioChannelLabel_XY_X                     = 206,
    kIOAudioChannelLabel_XY_Y                     = 207,
	
    // other
    kIOAudioChannelLabel_HeadphonesLeft           = 301,
    kIOAudioChannelLabel_HeadphonesRight          = 302,
    kIOAudioChannelLabel_ClickTrack               = 304,
    kIOAudioChannelLabel_ForeignLanguage          = 305,
	
    // generic discrete channel
    kIOAudioChannelLabel_Discrete                 = 400,
	
    // numbered discrete channel
    kIOAudioChannelLabel_Discrete_0               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 0,
    kIOAudioChannelLabel_Discrete_1               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 1,
    kIOAudioChannelLabel_Discrete_2               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 2,
    kIOAudioChannelLabel_Discrete_3               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 3,
    kIOAudioChannelLabel_Discrete_4               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 4,
    kIOAudioChannelLabel_Discrete_5               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 5,
    kIOAudioChannelLabel_Discrete_6               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 6,
    kIOAudioChannelLabel_Discrete_7               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 7,
    kIOAudioChannelLabel_Discrete_8               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 8,
    kIOAudioChannelLabel_Discrete_9               = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 9,
    kIOAudioChannelLabel_Discrete_10              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 10,
    kIOAudioChannelLabel_Discrete_11              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 11,
    kIOAudioChannelLabel_Discrete_12              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 12,
    kIOAudioChannelLabel_Discrete_13              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 13,
    kIOAudioChannelLabel_Discrete_14              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 14,
    kIOAudioChannelLabel_Discrete_15              = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 15,
    kIOAudioChannelLabel_Discrete_65535           = ( 1 << kIOAudioChannelLabel_Discrete_field_ba ) | 65535
};



#endif /* _IOKIT_IOAUDIOTYPES_H */
                                                                                                      avc/                                                                                                0040755 0001750 0001750 00000000000 12612224741 031350  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOFireWireAVCConsts.h                                                                               0100644 0001750 0001750 00000017157 12566177542 035237  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/avc                                                                   /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOKIT_IOFIREWIREAVCCONSTS_H
#define _IOKIT_IOFIREWIREAVCCONSTS_H

// Fields of AVC frame
typedef enum {
    kAVCCommandResponse = 0,
    kAVCAddress = 1,
    kAVCOpcode = 2,
    kAVCOperand0 = 3,
    kAVCOperand1 = 4,
    kAVCOperand2 = 5,
    kAVCOperand3 = 6,
    kAVCOperand4 = 7,
    kAVCOperand5 = 8,
    kAVCOperand6 = 9,
    kAVCOperand7 = 10,
    kAVCOperand8 = 11
} IOAVCFrameFields;

// Command/Response values
typedef enum {
    kAVCControlCommand                      = 0x00,
    kAVCStatusInquiryCommand                = 0x01,
    kAVCSpecificInquiryCommand				= 0x02,
    kAVCNotifyCommand						= 0x03,
    kAVCGeneralInquiryCommand				= 0x04,
    kAVCNotImplementedStatus				= 0x08,
    kAVCAcceptedStatus						= 0x09,
    kAVCRejectedStatus						= 0x0a,
    kAVCInTransitionStatus					= 0x0b,
    kAVCImplementedStatus					= 0x0c,
    kAVCChangedStatus						= 0x0d,
    kAVCInterimStatus						= 0x0f
} IOAVCCommandResponse;

// Opcodes
typedef enum {

    // Unit commands
    kAVCPlugInfoOpcode						= 0x02,
    kAVCOutputPlugSignalFormatOpcode		= 0x18,
    kAVCInputPlugSignalFormatOpcode			= 0x19,
    kAVCUnitInfoOpcode						= 0x30,
    kAVCSubunitInfoOpcode					= 0x31,
    kAVCConnectionsOpcode					= 0x22,
    kAVCConnectOpcode						= 0x24,
    kAVCDisconnectOpcode					= 0x25,
    kAVCPowerOpcode							= 0xB2,
	kAVCSignalSourceOpcode					= 0x1A,
	
    // Vendor dependent commands
    kAVCVendorDependentOpcode				= 0x00,

    // Subunit commands
    kAVCOutputSignalModeOpcode              = 0x78,
    kAVCInputSignalModeOpcode               = 0x79, 
    kAVCSignalModeSD525_60                  = 0x00,
    kAVCSignalModeSDL525_60                 = 0x04,
    kAVCSignalModeHD1125_60                 = 0x08,
    kAVCSignalModeSD625_50                  = 0x80, 
    kAVCSignalModeSDL625_50                 = 0x84, 
    kAVCSignalModeHD1250_50                 = 0x88,
    kAVCSignalModeDVCPro525_60				= 0x78,
    kAVCSignalModeDVCPro625_50				= 0xf8,
    
    kAVCSignalModeDummyOperand              = 0xff,
    kAVCSignalModeMask_50					= 0x80,
    kAVCSignalModeMask_STYPE				= 0x7c,          
    kAVCSignalModeMask_SDL					= 0x04,          
    kAVCSignalModeMask_DVCPro25				= 0x78        

} IOAVCOpcodes;

// Unit/Subunit types
typedef enum {
    kAVCVideoMonitor						= 0x00,
    kAVCAudio								= 0x01,
    kAVCPrinter								= 0x02,
    kAVCDiskRecorder						= 0x03,
    kAVCTapeRecorder						= 0x04,
    kAVCTuner								= 0x05,
    kAVCVideoCamera							= 0x07,
    kAVCCameraStorage						= 0x0b,
    kAVCVendorUnique						= 0x1c,
    kAVCNumSubUnitTypes						= 0x20
} IOAVCUnitTypes;

#define kAVCAllOpcodes 0xFF
#define kAVCAllSubunitsAndUnit 0xEE
#define kAVCMaxNumPlugs 31
#define kAVCAnyAvailableIsochPlug 0x7F
#define kAVCAnyAvailableExternalPlug 0xFF
#define kAVCAnyAvailableSubunitPlug 0xFF
#define kAVCMultiplePlugs 0xFD
#define kAVCInvalidPlug 0xFE


#define IOAVCAddress(type, id) (((type) << 3) | (id))
#define kAVCUnitAddress 0xff
#define IOAVCType(address) ((address) >> 3)
#define IOAVCId(address) ((address) & 0x7)

// Macros for Plug Control Register field manipulation

// Master control registers
#define kIOFWPCRDataRate FWBitRange(0,1)
#define kIOFWPCRDataRatePhase FWBitRangePhase(0,1)
#define kIOFWPCRExtension FWBitRange(8,15)
#define kIOFWPCRExtensionPhase FWBitRangePhase(8,15)
#define kIOFWPCRNumPlugs FWBitRange(27,31)
#define kIOFWPCRNumPlugsPhase FWBitRangePhase(27,31)

// master output register
#define kIOFWPCRBroadcastBase FWBitRange(2,7)
#define kIOFWPCRBroadcastBasePhase FWBitRangePhase(2,7)

// plug registers
#define kIOFWPCROnline FWBitRange(0,0)
#define kIOFWPCROnlinePhase FWBitRangePhase(0,0)
#define kIOFWPCRBroadcast FWBitRange(1,1)
#define kIOFWPCRBroadcastPhase FWBitRangePhase(1,1)
#define kIOFWPCRP2PCount FWBitRange(2,7)
#define kIOFWPCRP2PCountPhase FWBitRangePhase(2,7)
#define kIOFWPCRChannel FWBitRange(10,15)
#define kIOFWPCRChannelPhase FWBitRangePhase(10,15)

// Extra fields for output plug registers
#define kIOFWPCROutputDataRate FWBitRange(16,17)
#define kIOFWPCROutputDataRatePhase FWBitRangePhase(16,17)
#define kIOFWPCROutputOverhead FWBitRange(18,21)
#define kIOFWPCROutputOverheadPhase FWBitRangePhase(18,21)
#define kIOFWPCROutputPayload FWBitRange(22,31)
#define kIOFWPCROutputPayloadPhase FWBitRangePhase(22,31)

// async plug numbers

enum
{
	kFWAVCAsyncPlug0 	= 0xa0,
	kFWAVCAsyncPlug1 	= 0xa1,
	kFWAVCAsyncPlug2 	= 0xa2,
	kFWAVCAsyncPlug3 	= 0xa3,
	kFWAVCAsyncPlug4 	= 0xa4,
	kFWAVCAsyncPlug5 	= 0xa5,
	kFWAVCAsyncPlug6 	= 0xa6,
	kFWAVCAsyncPlug7 	= 0xa7,
	kFWAVCAsyncPlug8 	= 0xa8,
	kFWAVCAsyncPlug9 	= 0xa9,
	kFWAVCAsyncPlug10 	= 0xa1,
	kFWAVCAsyncPlug11	= 0xab,
	kFWAVCAsyncPlug12 	= 0xac,
	kFWAVCAsyncPlug13	= 0xad,
	kFWAVCAsyncPlug14	= 0xae,
	kFWAVCAsyncPlug15 	= 0xaf,
	kFWAVCAsyncPlug16 	= 0xb0,
	kFWAVCAsyncPlug17 	= 0xb1,
	kFWAVCAsyncPlug18	= 0xb2,
	kFWAVCAsyncPlug19 	= 0xb3,
	kFWAVCAsyncPlug20 	= 0xb4,
	kFWAVCAsyncPlug21 	= 0xb5,
	kFWAVCAsyncPlug22 	= 0xb6,
	kFWAVCAsyncPlug23 	= 0xb7,
	kFWAVCAsyncPlug24 	= 0xb8,
	kFWAVCAsyncPlug25 	= 0xb9,
	kFWAVCAsyncPlug26 	= 0xba,
	kFWAVCAsyncPlug27 	= 0xbb,
	kFWAVCAsyncPlug28 	= 0xbc,
	kFWAVCAsyncPlug29 	= 0xbd,
	kFWAVCAsyncPlug30	= 0xbe,
	kFWAVCAsyncPlugAny	= 0xbf
};

enum
{
    kFWAVCStateBusSuspended 	= 0,
    kFWAVCStateBusResumed 		= 1,
    kFWAVCStatePlugReconnected 	= 2,
    kFWAVCStatePlugDisconnected = 3,
    kFWAVCStateDeviceRemoved	= 4
};

enum
{
    kFWAVCConsumerMode_MORE		= 1,
    kFWAVCConsumerMode_LAST		= 4,
    kFWAVCConsumerMode_LESS		= 5,
    kFWAVCConsumerMode_JUNK		= 6,
    kFWAVCConsumerMode_LOST		= 7
};

enum
{
    kFWAVCProducerMode_SEND		= 5,
    kFWAVCProducerMode_TOSS		= 7
};


typedef enum
{
	IOFWAVCPlugSubunitSourceType,
	IOFWAVCPlugSubunitDestType,
	IOFWAVCPlugIsochInputType,
	IOFWAVCPlugIsochOutputType,
	IOFWAVCPlugAsynchInputType,
	IOFWAVCPlugAsynchOutputType,
	IOFWAVCPlugExternalInputType,
	IOFWAVCPlugExternalOutputType
} IOFWAVCPlugTypes;

typedef enum
{
	kIOFWAVCSubunitPlugMsgConnected,
	kIOFWAVCSubunitPlugMsgDisconnected,
	kIOFWAVCSubunitPlugMsgConnectedPlugModified,
	kIOFWAVCSubunitPlugMsgSignalFormatModified
} IOFWAVCSubunitPlugMessages;

// Some plug signal formats
#define kAVCPlugSignalFormatNTSCDV 0x80000000
#define kAVCPlugSignalFormatPalDV 0x80800000 
#define kAVCPlugSignalFormatMPEGTS 0xA0000000

// Possible states of an AVCAsynchronousCommand
typedef enum
{
	kAVCAsyncCommandStatePendingRequest,
	kAVCAsyncCommandStateRequestSent,
	kAVCAsyncCommandStateRequestFailed,
	kAVCAsyncCommandStateWaitingForResponse,
	kAVCAsyncCommandStateReceivedInterimResponse,
	kAVCAsyncCommandStateReceivedFinalResponse,
	kAVCAsyncCommandStateTimeOutBeforeResponse,
	kAVCAsyncCommandStateBusReset,
	kAVCAsyncCommandStateOutOfMemory,
	kAVCAsyncCommandStateCanceled
} IOFWAVCAsyncCommandState;

#endif // _IOKIT_IOFIREWIREAVCCONSTS_H
                                                                                                                                                                                                                                                                                                                                                                                                                 IOFireWireAVCLib.h                                                                                  0100644 0001750 0001750 00000100503 12566177542 034460  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/avc                                                                   /*
 * Copyright (c) 1998-2001 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 *
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 *
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFIREWIREAVCLIB_H_
#define _IOKIT_IOFIREWIREAVCLIB_H_

#include <IOKit/IOCFPlugIn.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/avc/IOFireWireAVCConsts.h>

// Unit type UUID
/* 6AAF2EF7-D476-11D5-B57C-0003934B81A0 */
#define kIOFireWireAVCLibUnitTypeID CFUUIDGetConstantUUIDWithBytes(NULL,		\
0x6A, 0xAF, 0x2E, 0xF7, 0xD4, 0x76, 0x11, 0xD5, 0xB5, 0x7C, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// Unit Factory UUID
/* 3F4057BC-D479-11D5-9F05-0003934B81A0 */
#define kIOFireWireAVCLibUnitFactoryID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
0x3F, 0x40, 0x57, 0xBC, 0xD4, 0x79, 0x11, 0xD5, 0x9F, 0x05, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// IOFireWireAVCUnitInterface UUID
/* FC65C030-D498-11D5-878D-0003934B81A0 */
#define kIOFireWireAVCLibUnitInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
0xFC, 0x65, 0xC0, 0x30, 0xD4, 0x98, 0x11, 0xD5, 0x87, 0x8D, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// kIOFireWireAVCLibUnitInterfaceID_v2 UUID - No Throttling of AVC Commands
/* 85B5E954-0AEF-11D8-8D19-000393914ABA */
#define kIOFireWireAVCLibUnitInterfaceID_v2  CFUUIDGetConstantUUIDWithBytes(NULL, 	\
0x85, 0xB5, 0xE9, 0x54, 0x0A, 0xEF, 0x11, 0xD8, 0x8D, 0x19, 0x00, 0x03, 0x93, 0x91, 0x4A, 0xBA)

// Protocol type UUID
/* B54BC8F8-D53B-11D5-A1A1-0003934B81A0 */
#define kIOFireWireAVCLibProtocolTypeID CFUUIDGetConstantUUIDWithBytes(NULL,		\
0xB5, 0x4B, 0xC8, 0xF8, 0xD5, 0x3B, 0x11, 0xD5, 0xA1, 0xA1, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// Protocol Factory UUID
/* 8E9AD5AC-D55E-11D5-B7D2-0003934B81A0 */
#define kIOFireWireAVCLibProtocolFactoryID CFUUIDGetConstantUUIDWithBytes(NULL,		\
0x8E, 0x9A, 0xD5, 0xAC, 0xD5, 0x5E, 0x11, 0xD5, 0xB7, 0xD2, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// IOFireWireAVCProtocolInterface UUID
/* CC85D421-D55E-11D5-8A10-0003934B81A0 */
#define kIOFireWireAVCLibProtocolInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,		\
0xCC, 0x85, 0xD4, 0x21, 0xD5, 0x5E, 0x11, 0xD5, 0x8A, 0x10, 0x00, 0x03, 0x93, 0x4B, 0x81, 0xA0)

// IOFireWireAVCLibConsumerInterfaceID 
/* 7FB7A454-226F-11D6-B889-000A277E7234 */
#define kIOFireWireAVCLibConsumerInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,		\
0x7F, 0xB7, 0xA4, 0x54, 0x22, 0x6F, 0x11, 0xD6, 0xB8, 0x89, 0x00, 0x0A, 0x27, 0x7E, 0x72, 0x34)

typedef void (*IOFWAVCMessageCallback)( void * refCon, UInt32 type, void * arg );

/*! @typedef IOFWAVCRequestCallback
	@abstract This Callback has been deprecated. Use installAVCCommandHandler instead.
*/
typedef IOReturn (*IOFWAVCRequestCallback)( void *refCon, UInt32 generation, UInt16 srcNodeID,
                const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);

/*!
    @typedef IOFWAVCPCRCallback
	@abstract Callback called after a successful lock transaction to a CMP plug.
    @param refcon refcon supplied when a client is registered
    @param generation Bus generation command was received in
	@param nodeID is the node originating the request
	@param plug is the plug number
	@param oldVal is the value the plug used to contain
    @param newVal is the quad written into the plug
 */
typedef void (*IOFWAVCPCRCallback)(void *refcon, UInt32 generation, UInt16 nodeID, UInt32 plug,
                                                                    UInt32 oldVal, UInt32 newVal);

/*!
    @typedef IOFWAVCCommandHandlerCallback
    @abstract Callback called when a incoming AVC command matching a registered command handler is received.
    @param refCon The refcon supplied when a client is registered
    @param generation The FireWire bus generation value at the time the command was received
    @param srcNodeID The node ID of the device who sent us this command
    @param speed The speed the AVC command packet
    @param command A pointer to the command bytes
    @param cmdLen The length of the AVC command bytes buffer in bytes
    @result The callback handler should return success if it will send the AVC response, or an error if it doesn't want to handle the command
 */
typedef IOReturn (*IOFWAVCCommandHandlerCallback)( void *refCon, UInt32 generation, UInt16 srcNodeID, IOFWSpeed speed, const UInt8 * command, UInt32 cmdLen);

/*!
    @typedef IOFWAVCSubunitPlugHandlerCallback
    @abstract Callback called when a incoming AVC command matching a registered command handler is received.
    @param refCon The refcon supplied when a client is registered
    @param subunitTypeAndID The subunit type and id of this plug
    @param plugType The type of plug receiving the message
    @param plugNum The number of the plug receiving the message
    @param plugMessage The plug message
    @param messageParams The parameters associated with the plug message
    @result The return value is only pertinent for the kIOFWAVCSubunitPlugMsgSignalFormatModified message. Return an error if not accepting the sig format change.
 */
typedef IOReturn (*IOFWAVCSubunitPlugHandlerCallback)(void *refCon,
												   UInt32 subunitTypeAndID,
												   IOFWAVCPlugTypes plugType,
												   UInt32 plugNum,
												   IOFWAVCSubunitPlugMessages plugMessage,
												   UInt32 messageParams);

typedef struct _IOFireWireAVCLibProtocolInterface IOFireWireAVCLibProtocolInterface;

typedef struct _IOFireWireAVCLibAsynchronousCommand
{
	IOFWAVCAsyncCommandState cmdState;
	void	*pRefCon;
	UInt8	*pCommandBuf;
	UInt32	cmdLen;
	UInt8	*pInterimResponseBuf;
	UInt32	interimResponseLen;
	UInt8	*pFinalResponseBuf;
	UInt32	finalResponseLen;
}IOFireWireAVCLibAsynchronousCommand;

typedef void (*IOFireWireAVCLibAsynchronousCommandCallback)(void *pRefCon, IOFireWireAVCLibAsynchronousCommand *pCommandObject);

/*!
    @class IOFireWireAVCLibUnitInterface
    @abstract Initial interface discovered for all AVC Unit drivers. 
    @discussion The IOFireWireAVCLibUnitInterface is the initial interface discovered by most drivers. It supplies the methods that control the operation of the AVC unit as a whole.
    Finally, the Unit can supply a reference to the IOFireWireUnit.  This can be useful if a driver wishes to access the standard FireWire APIs.  
*/

typedef struct
 {

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;

    /*!
		@function open
		@abstract Exclusively opens a connection to the in-kernel device.
		@discussion Exclusively opens a connection to the in-kernel device.  As long as the in-kernel 
        device object is open, no other drivers will be able to open a connection to the device. When 
        open, the device on the bus may disappear, but the in-kernel object representing it will stay
        instantiated and can begin communicating with the device again if it ever reappears. 
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @result Returns kIOReturnSuccess on success.
    */
    
	IOReturn (*open)( void * self );
    
    /*!
		@function openWithSessionRef
		@abstract Opens a connection to a device that is not already open.
		@discussion Sometimes it is desirable to open multiple user clients on a device.  In the case 
        of FireWire sometimes we wish to have both the FireWire User Client and the AVC User Client 
        open at the same time.  The technique to arbitrate this is as follows:<br>First open normally 
        the device furthest from the root in the I/O Registry.<br>Second, get its sessionRef with the 
        getSessionRef call.<br>Third, open the device further up the chain by calling this method and 
        passing the sessionRef returned from the call in step 2.
        @param sessionRef SessionRef returned from getSessionRef call. 
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @result Returns kIOReturnSuccess on success.
    */
    
	IOReturn (*openWithSessionRef)( void * self, IOFireWireSessionRef sessionRef );

    /*!
		@function getSessionRef
		@abstract Get the session reference.
		@discussion Gets the sessionRef to be used with openWithSessionRef.
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @result Returns a sessionRef on success.
    */

	IOFireWireSessionRef (*getSessionRef)(void * self);

    /*!
		@function close
		@abstract Closes an exclusive access to the device.
		@discussion Closes an exclusive access to the device.  When a device is closed it may be 
        unloaded by the kernel.  If it is unloaded and then later reappears it will be represented 
        by a different object.  You won't be able to use this user client on the new object.  The 
        new object will have to be looked up in the I/O Registry and a new user client will have to 
        be opened on it. 
        @param self Pointer to IOFireWireAVCLibUnitInterface.
    */

	void (*close)( void * self );

    /*!
		@function addCallbackDispatcherToRunLoop
		@abstract Adds a dispatcher for kernel callbacks to the specified runloop.
		@discussion The user space portions of the AVC API communicate with the in-kernel services by 
        messaging the kernel.  Similarly, the kernel messages the user space services in response.  
        These responses need to be picked up by a piece of code.  This call adds that code to the specified
        run loop.  Most drivers will call this method on the run loop that was created when your task was 
        created.  To avoid deadlock you must avoid sleeping (or spin waiting) the run loop to wait for 
        AVC response.  If you do this the dispatcher will never get to run and you will wait forever.
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param cfRunLoopRef Reference to a run loop.
        @result Returns kIOReturnSuccess on success.
    */
    	
	IOReturn (*addCallbackDispatcherToRunLoop)( void *self, CFRunLoopRef cfRunLoopRef );
	
    /*!
		@function removeCallbackDispatcherFromRunLoop
		@abstract Removes a dispatcher for kernel callbacks to the specified run loop.
		@discussion Undoes the work of addCallbackDispatcherToRunLoop.
        @param self Pointer to IOFireWireAVCLibUnitInterface.
    */
    
    void (*removeCallbackDispatcherFromRunLoop)( void * self );

    /*!
		@function setMessageCallback
		@abstract Sets callback for user space message routine.
		@discussion In FireWire and AVC, bus status messages are delivered via IOKit's message routine.  
        This routine is emulated in user space for AVC and FireWire messages via this callback.  You should
        register here for bus reset and reconnect messages.
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param refCon RefCon to be returned as first argument of completion routine.
        @param callback Address of completion routine.
    */
    
	void (*setMessageCallback)( void *self, void * refCon, IOFWAVCMessageCallback callback);
    
    /*!
		@function AVCCommand
		@abstract Sends an AVC command to the device and returns the response.
		@discussion This function will block until the device returns a response or the kernel driver times out. 
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param command Pointer to command to send.
        @param cmdLen Length (in bytes) of command.
        @param response Pointer to place to store the response sent by the device.
        @param responseLen Pointer to place to store the length of the response.
    */

	IOReturn (*AVCCommand)( void * self,
        const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);
    
    /*!
		@function AVCCommandInGeneration
		@abstract Sends an AVC command to the device and returns the response.
		@discussion Sends an AVC command to the device and returns the response.  The command must complete in the specified bus generation.  This function is only available if the interface version is > 1 (MacOSX 10.2.0 or later?).  This function will block until the device returns a response or the kernel driver times out. 
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param busGeneration FireWire bus generation that the command is valid in.
        @param command Pointer to command to send.
        @param cmdLen Length (in bytes) of command.
        @param response Pointer to place to store the response sent by the device.
        @param responseLen Pointer to place to store the length of the response.
    */

	IOReturn (*AVCCommandInGeneration)( void * self, UInt32 busGeneration,
        const UInt8 * command, UInt32 cmdLen, UInt8 * response, UInt32 *responseLen);
        
	/*!	
        @function getAncestorInterface
        @abstract Creates a plug-in object for an ancestor (in the I/O Registry) of the AVC unit and returns an interface to it.
        @discussion This function is only available if the interface version is > 1 (MacOSX 10.2.0 or later?).
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param object_class Class name of ancestor of the device to get an interface for.
        @param pluginType An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the type of plug-in service to be returned for the ancestor.
        @param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the type of interface to be returned for the created plug-in object.
        @result Returns a COM-style interface pointer. Returns 0 upon failure.
    */
	void * (*getAncestorInterface)( void * self, char * object_class, REFIID pluginType, REFIID iid) ;

	/*!	
        @function getProtocolInterface
        @abstract Creates a plug-in object for a protocol driver for the FireWire bus the AVC unit
        is connected to and returns an interface to it.
        @discussion This function is only available if the interface version is > 1 (MacOSX 10.2.0 or later?).
        @param self Pointer to IOFireWireAVCLibUnitInterface.
        @param pluginType An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the type of plug-in service to be returned for the created protocol object.
        @param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the type of interface to be returned for the created protocol device object.
        @result Returns a COM-style interface pointer. Returns 0 upon failure.
    */
	void * (*getProtocolInterface)( void * self, REFIID pluginType, REFIID iid) ;
	
	/*
	*/
	IOReturn (*getAsyncConnectionPlugCounts)
                        ( void *self, UInt8 * inputPlugCount, UInt8 * outputPlugCount );

	/*
	*/
    IUnknownVTbl ** (*createConsumerPlug)( void *self, UInt8 plugNumber, REFIID iid );

    /*!
        @function updateAVCCommandTimeout
        @abstract Updates an AVCCommand's timeout back to 10 seconds.
        @discussion AVCCommands will time out after 10 seconds unless this function is called (from another thread) to update the command's timeout back to 10 seconds.
        This function is only available if the interface version is > 2.
    */
    IOReturn (*updateAVCCommandTimeout)(void * self);
    
    /*!
        @function makeP2PInputConnection
        @abstract Increments the point-to-point connection count of a unit input plug.
        @discussion This function is only available if the interface version is > 3.
    */
    IOReturn (*makeP2PInputConnection)(void * self, UInt32 inputPlug, UInt32 chan);
    
    /*!
        @function breakP2PInputConnection
        @abstract Decrements the point-to-point connection count of a unit input plug.
        @discussion This function is only available if the interface version is > 3.
    */
    IOReturn (*breakP2PInputConnection)(void * self, UInt32 inputPlug);

    /*!
        @function makeP2POutputConnection
        @abstract Increments the point-to-point connection count of a unit output plug.
        @discussion This function is only available if the interface version is > 3.
    */
    IOReturn (*makeP2POutputConnection)(void * self, UInt32 outputPlug, UInt32 chan, IOFWSpeed speed);
    
    /*!
        @function breakP2POutputConnection
        @abstract Decrements the point-to-point connection count of a unit output plug.
        @discussion This function is only available if the interface version is > 3.
    */
    IOReturn (*breakP2POutputConnection)(void * self, UInt32 outputPlug);

    /*!
		@function createAVCAsynchronousCommand
	 */

	IOReturn (*createAVCAsynchronousCommand)(void * self,
										  const UInt8 * command,
										  UInt32 cmdLen,
										  IOFireWireAVCLibAsynchronousCommandCallback completionCallback,
										  void *pRefCon,
										  IOFireWireAVCLibAsynchronousCommand **ppCommandObject);

    /*!
		@function AVCAsynchronousCommandSubmit
	 */

	IOReturn (*AVCAsynchronousCommandSubmit)(void * self, IOFireWireAVCLibAsynchronousCommand *pCommandObject);

    /*!
		@function AVCAsynchronousCommandReinit
	 */

	IOReturn (*AVCAsynchronousCommandReinit)(void * self, IOFireWireAVCLibAsynchronousCommand *pCommandObject);

	/*!
		@function AVCAsynchronousCommandCancel
	 */

	IOReturn (*AVCAsynchronousCommandCancel)(void * self, IOFireWireAVCLibAsynchronousCommand *pCommandObject);

    /*!
		@function AVCAsynchronousCommandRelease
	 */

	IOReturn (*AVCAsynchronousCommandRelease)(void * self, IOFireWireAVCLibAsynchronousCommand *pCommandObject);

    /*!
		@function AVCAsynchronousCommandReinitWithCommandBytes
	 */

	IOReturn (*AVCAsynchronousCommandReinitWithCommandBytes)(void * self, 
															 IOFireWireAVCLibAsynchronousCommand *pCommandObject, 
															 const UInt8 * command,
															 UInt32 cmdLen);
 } IOFireWireAVCLibUnitInterface;

/*!
    @class IOFireWireAVCLibProtocolInterface
    @abstract Initial interface discovered for all AVC protocol drivers. 
    @discussion The IOFireWireAVCLibProtocolInterface is used to set up local plug control registers and to receive AVC requests.
*/

typedef struct _IOFireWireAVCLibProtocolInterface
 {
	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;
    /*!
		@function addCallbackDispatcherToRunLoop
		@abstract Adds a dispatcher for kernel callbacks to the specified run loop.
		@discussion The user space portions of the AVC API communicate with the in-kernel services by 
        messaging the kernel.  Similarly, the kernel messages the user space services in response.  
        These responses need to be picked up by a piece of code.  This call adds that code to the specified
        run loop.  Most drivers will call this method on the run loop that was created when your task was 
        created.  To avoid deadlock you must avoid sleeping (or spin waiting) the run loop to wait for 
        AVC response.  If you do this the dispatcher will never get to run and you will wait forever.
        @param self Pointer to IOFireWireAVCLibProtocolInterface.
        @param cfRunLoopRef Reference to a run loop.
        @result Returns kIOReturnSuccess on success.
    */
    	
	IOReturn (*addCallbackDispatcherToRunLoop)( void *self, CFRunLoopRef cfRunLoopRef );
	
    /*!
        @function removeCallbackDispatcherFromRunLoop
        @abstract Removes a dispatcher for kernel callbacks to the specified run loop.
        @discussion Undoes the work of addCallbackDispatcherToRunLoop.
        @param self Pointer to IOFireWireAVCLibProtocolInterface.
    */
    
    void (*removeCallbackDispatcherFromRunLoop)( void * self );
    
    /*!
		@function setMessageCallback
		@abstract Sets callback for user space message routine.
		@discussion In FireWire and AVC, bus status messages are delivered via IOKit's message routine.  
        This routine is emulated in user space for AVC and FireWire messages via this callback.  You should
        register here for bus reset and reconnect messages.
        @param self Pointer to IOFireWireAVCLibProtocolInterface.
        @param refCon RefCon to be returned as first argument of completion routine.
        @param callback Address of completion routine.
    */
    
	void (*setMessageCallback)( void *self, void * refCon, IOFWAVCMessageCallback callback);
    
    /*!
		@function setAVCRequestCallback
		@abstract This function has been deprecated. Use installAVCCommandHandler instead.
    */
    
    IOReturn (*setAVCRequestCallback)( void *self, UInt32 subUnitType, UInt32 subUnitID,
                                                void *refCon, IOFWAVCRequestCallback callback);

/*!
    @function allocateInputPlug
    @abstract Allocates an input plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param refcon Arbitrary value passed back as first argument of callback.
    @param func Callback function when a successful lock transaction to the plug has been performed.
    @param plug Set to the plug number if a plug is successfully allocated.
*/
    IOReturn (*allocateInputPlug)( void *self, void *refcon, IOFWAVCPCRCallback func, UInt32 *plug);
/*!
    @function freeInputPlug
    @abstract Deallocates an input plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateInputPlug.
*/
    void (*freeInputPlug)( void *self, UInt32 plug);
/*!
    @function readInputPlug
    @abstract Returns the current value of an input plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateInputPlug.
*/
    UInt32 (*readInputPlug)( void *self, UInt32 plug);
/*!
    @function updateInputPlug
    @abstract Updates the value of an input plug (simulating a lock transaction).
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateInputPlug.
    @param oldVal Value returned by readInputPlug.
    @param newVal New value to store in plug if its current value is oldVal.
*/
    IOReturn (*updateInputPlug)( void *self, UInt32 plug, UInt32 oldVal, UInt32 newVal);
/*!
    @function allocateOutputPlug
    @abstract Allocates an output plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param refcon Arbitrary value passed back as first argument of callback.
    @param func Callback function when a successful lock transaction to the plug has been performed.
    @param plug Set to the plug number if a plug is successfully allocated.
*/
    IOReturn (*allocateOutputPlug)( void *self, void *refcon, IOFWAVCPCRCallback func, UInt32 *plug);
/*!
    @function freeOutputPlug
    @abstract Deallocates an output plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateOutputPlug.
*/
    void (*freeOutputPlug)( void *self, UInt32 plug);
/*!
    @function readOutputPlug
    @abstract Returns the current value of an output plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateOutputPlug.
*/
    UInt32 (*readOutputPlug)( void *self, UInt32 plug);
/*!
    @function updateOutputPlug
    @abstract Updates the value of an output plug (simulating a lock transaction).
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param plug Value returned by allocateOutputPlug.
    @param oldVal Value returned by readOutputPlug.
    @param newVal New value to store in plug if its current value is oldVal.
*/
   IOReturn (*updateOutputPlug)( void *self, UInt32 plug, UInt32 oldVal, UInt32 newVal);
/*!
    @function readOutputMasterPlug
    @abstract Returns the current value of the output master plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
*/
    UInt32 (*readOutputMasterPlug)( void *self);
/*!
    @function updateOutputMasterPlug
    @abstract Updates the value of the master output plug (simulating a lock transaction).
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param oldVal Value returned by readOutputMasterPlug.
    @param newVal New value to store in plug if its current value is oldVal.
*/
    IOReturn (*updateOutputMasterPlug)( void *self, UInt32 oldVal, UInt32 newVal);
/*!
    @function readInputMasterPlug
    @abstract Returns the current value of the input master plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    
*/
    UInt32 (*readInputMasterPlug)( void *self);
/*!
    @function updateInputMasterPlug
    @abstract Updates the value of the master input plug (simulating a lock transaction).
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param oldVal Value returned by readInputMasterPlug.
    @param newVal New value to store in plug if its current value is oldVal.
*/
    IOReturn (*updateInputMasterPlug)( void *self, UInt32 oldVal, UInt32 newVal);

/*!
    @function publishAVCUnitDirectory
    @abstract Publishes an AVC unit directory in the config ROM.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
*/
	IOReturn (*publishAVCUnitDirectory)(void *self);

/*!
    @function installAVCCommandHandler
    @abstract Installs a command handler for handling specific incoming AVC commands.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param subUnitTypeAndID The subunit type and ID for this command handler.
    @param opCode The opcode for this command handler.
    @param refCon Arbitrary value passed back as first argument of callback.
    @param callback A pointer to the callback function
*/
	IOReturn (*installAVCCommandHandler)(void *self,
									  UInt32 subUnitTypeAndID,
									  UInt32 opCode,
									  void *refCon,
									  IOFWAVCCommandHandlerCallback callback);

/*!
    @function sendAVCResponse
    @abstract Sends an AVC response packet.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param generation The Firewire bus generation that this response should be sent in.
    @param nodeID The node ID of the device we are sending this response to.
    @param response A pointer to the response bytes.
    @param responseLen The number of response bytes.
*/
	IOReturn (*sendAVCResponse)(void *self,
							 UInt32 generation,
							 UInt16 nodeID,
							 const char *response,
							 UInt32 responseLen);

/*!
    @function addSubunit
    @abstract Installs a virtual AVC subunit.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param subunitType The type of subunit to create.
    @param numSourcePlugs The number of source plugs for this subunit.
    @param numDestPlugs The number of destination plugs for this subunit.
    @param refCon Arbitrary value passed back as first argument of callback.
    @param callback A pointer to the callback to receive plug management messages.
    @param pSubunitTypeAndID A pointer to a byte to hold the returned subunit address for the new subunit.
 */
	IOReturn (*addSubunit)(void *self,
						UInt32 subunitType,
						UInt32 numSourcePlugs,
						UInt32 numDestPlugs,
						void *refCon,
						IOFWAVCSubunitPlugHandlerCallback callback,
						UInt32 *pSubunitTypeAndID);

/*!
    @function setSubunitPlugSignalFormat
    @abstract Sets the signal format of the specifed plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param subunitTypeAndID The subunit type and ID of the plug.
    @param plugType The plug type.
    @param plugNum The plug number.
    @param signalFormat The 32-bit signal format value.
*/
	IOReturn (*setSubunitPlugSignalFormat)(void *self,
										UInt32 subunitTypeAndID,
										IOFWAVCPlugTypes plugType,
										UInt32 plugNum,
										UInt32 signalFormat);

/*!
    @function getSubunitPlugSignalFormat
    @abstract Gets the signal format of the specifed plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param subunitTypeAndID The subunit type and ID of the plug.
    @param plugType The plug type.
    @param plugNum The plug number.
    @param pSignalFormat A pointer to the location to return the signal format value.
*/
	IOReturn (*getSubunitPlugSignalFormat)(void *self,
										UInt32 subunitTypeAndID,
										IOFWAVCPlugTypes plugType,
										UInt32 plugNum,
										UInt32 *pSignalFormat);

/*!
    @function connectTargetPlugs
    @abstract Establishes an internal AVC plug connection between subunit/unit plugs.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param sourceSubunitTypeAndID The subunit type and ID for the source plug
    @param sourcePlugType The source plug type.
    @param pSourcePlugNum A pointer to the source plug num. Will return the actual source plug num here.
    @param destSubunitTypeAndID The subunit type and ID for the destination plug.
    @param destPlugType The dest plug type.
    @param pDestPlugNum A pointer to the dest plug num. Will return the actual dest plug num here.
    @param lockConnection A flag to specify if this connection should be locked.
    @param permConnection A flag to specify if this connection is permanent.
*/
	IOReturn (*connectTargetPlugs)(void *self,
								UInt32 sourceSubunitTypeAndID,
								IOFWAVCPlugTypes sourcePlugType,
								UInt32 *pSourcePlugNum,
								UInt32 destSubunitTypeAndID,
								IOFWAVCPlugTypes destPlugType,
								UInt32 *pDestPlugNum,
								bool lockConnection,
								bool permConnection);

/*!
    @function disconnectTargetPlugs
    @abstract Breaks an internal AVC plug connection between subunit/unit plugs.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param sourceSubunitTypeAndID The subunit type and ID for the source plug.
    @param sourcePlugType The source plug type.
    @param sourcePlugNum The source plug num.
    @param destSubunitTypeAndID The subunit type and ID for the destination plug.
    @param destPlugType The dest plug type.
    @param destPlugNum The dest plug num.
*/
	IOReturn (*disconnectTargetPlugs)(void *self,
								   UInt32 sourceSubunitTypeAndID,
								   IOFWAVCPlugTypes sourcePlugType,
								   UInt32 sourcePlugNum,
								   UInt32 destSubunitTypeAndID,
								   IOFWAVCPlugTypes destPlugType,
								   UInt32 destPlugNum);

/*!
    @function getTargetPlugConnection
    @abstract Gets the connection details for a specific plug.
    @param self Pointer to IOFireWireAVCLibProtocolInterface.
    @param subunitTypeAndID The subunit type and ID of the plug.
    @param plugType The plug type.
    @param plugNum The plug number.
    @param pConnectedSubunitTypeAndID The subunit type and ID of the connected plug.
    @param pConnectedPlugType The type of the connected plug.
    @param pConnectedPlugNum The number of the connected plug.
    @param pLockConnection A pointer for returning the lock status of the connection.
    @param pPermConnection A pointer for returning the perm status of the connection.
*/
	IOReturn (*getTargetPlugConnection)(void *self,
									 UInt32 subunitTypeAndID,
									 IOFWAVCPlugTypes plugType,
									 UInt32 plugNum,
									 UInt32 *pConnectedSubunitTypeAndID,
									 IOFWAVCPlugTypes *pConnectedPlugType,
									 UInt32 *pConnectedPlugNum,
									 bool *pLockConnection,
									 bool *pPermConnection);
} IOFireWireAVCLibProtocolInterface;


typedef void (*IOFireWireAVCPortStateHandler)( void * refcon, UInt32 state );
typedef void (*IOFireWireAVCFrameStatusHandler)( void * refcon, UInt32 mode, UInt32 count );



/*!
    @class IOFireWireAVCLibConsumerInterface
    @abstract   Interface for an asynchronous connection consumer.
    @discussion Used to receive data from an asynchronous connection producer.
*/

typedef struct
{

	IUNKNOWN_C_GUTS;

	UInt16	version;						
    UInt16	revision;
   
    void (*setSubunit)( void * self, UInt8 subunit );
    void (*setRemotePlug)( void * self, UInt8 plugNumber );

    IOReturn (*connectToRemotePlug)( void * self );
    IOReturn (*disconnectFromRemotePlug)( void * self );

    void (*setFrameStatusHandler)( void * self, void * refcon, IOFireWireAVCFrameStatusHandler handler );
    void (*frameProcessed)( void * self, UInt32 mode );
 
    void (*setMaxPayloadSize)( void * self, UInt32 size );

    IOReturn (*setSegmentSize)( void * self, UInt32 size );
    UInt32 (*getSegmentSize)( void * self );
    char * (*getSegmentBuffer)( void * self );
 
    void (*setPortStateHandler)( void * self, void * refcon, IOFireWireAVCPortStateHandler handler );

       
    void (*setPortFlags)( void * self, UInt32 flags );
    void (*clearPortFlags)( void * self, UInt32 flags );
    UInt32 (*getPortFlags)( void * self );

} IOFireWireAVCLibConsumerInterface;

#endif
                                                                                                                                                                                             firewire/                                                                                           0040755 0001750 0001750 00000000000 12612224741 032413  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOFWIsoch.h                                                                                         0100644 0001750 0001750 00000002527 12566200640 034321  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/firewire                                                              /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
	File:		IOFWIsoch.h

	Contains:	Definitions for FireWire isochronous transfers.

	Copyright:	 1996-1999 by Apple Computer, Inc., all rights reserved.

*/

#ifndef __IOFWISOCH_H__
#define __IOFWISOCH_H__

#warning This file is no longer needed. Please use <IOKit/firewire/IOFireWireFamilyCommon.h> instead.

#include <IOKit/firewire/IOFireWireFamilyCommon.h>

#endif /* __IOFWISOCH_H */
                                                                                                                                                                         IOFireWireFamilyCommon.h                                                                            0100644 0001750 0001750 00000111704 12566200640 037044  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/firewire                                                              /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *  IOFireWireFamilyCommon.h
 *  IOFireWireUserClient/IOFireWireFamily
 *
 *  Created by NWG on Fri Apr 28 2000.
 *  Copyright (c) 2000-2001 Apple Computer, Inc. All rights reserved.
 *
 */
/*
	$Log: not supported by cvs2svn $
	Revision 1.78  2008/05/08 02:33:22  collin
	more K64
	
	Revision 1.77  2008/04/24 00:01:39  collin
	more K640
	
	Revision 1.76  2007/12/05 04:52:08  collin
	integrate chex workaround
	
	Revision 1.75  2007/08/31 20:29:06  collin
	fixed 5437835
	
	Revision 1.74  2007/04/24 21:40:23  arulchan
	headerdoc changes
	
	Revision 1.73  2007/04/24 21:28:24  arulchan
	changes for headerdoc
	
	Revision 1.72  2007/04/13 19:37:01  calderon
	Integrated FireWireKPrintf implemented
	
	Revision 1.71  2007/03/14 18:41:43  collin
	*** empty log message ***
	
	Revision 1.70  2007/02/28 23:10:13  ayanowit
	Another IRMAllocation fix.
	
	Revision 1.69  2007/02/20 01:25:28  collin
	*** empty log message ***
	
	Revision 1.68  2007/02/17 00:26:51  collin
	*** empty log message ***
	
	Revision 1.67  2007/02/15 19:42:07  ayanowit
	For 4369537, eliminated support for legacy DCL SendPacketWithHeader, since it didn't work anyway, and NuDCL does support it.
	
	Revision 1.66  2007/02/15 01:23:39  arulchan
	changes in AssignCycleMaster
	
	Revision 1.65  2007/02/09 04:44:06  collin
	*** empty log message ***
	
	Revision 1.64  2007/01/26 20:52:31  ayanowit
	changes to user-space isoch stuff to support 64-bit apps.
	
	Revision 1.63  2007/01/16 01:41:02  gecko1
	4159728 Add improved async lock based check for bad IRMs
	
	Revision 1.62  2007/01/15 23:29:05  arulchan
	Fixed Skipped Packet Handler Notifications
	
	Revision 1.61  2007/01/12 22:15:14  arulchan
	Added flag kIOFWEnableBeingRoot
	
	Revision 1.60  2007/01/10 22:14:44  calderon
	Fixed 4046607 Propagate vendor/model from IIDC UnitDepedantInfoDir
	Fixed some null termination shinanigans in getIndexValue(string)
	
	Revision 1.59  2007/01/08 18:47:19  ayanowit
	More 64-bit changes for isoch.
	
	Revision 1.58  2006/07/07 20:18:25  calderon
	4227201: SpeedMap and HopCount table reductions.
	
	Revision 1.57  2006/04/03 21:29:48  collin
	*** empty log message ***
	
	Revision 1.56  2006/02/09 00:21:51  niels
	merge chardonnay branch to tot
	
	Revision 1.55.4.1  2005/08/06 01:31:31  collin
	*** empty log message ***
	
	Revision 1.55  2005/03/12 03:27:51  collin
	*** empty log message ***
	
	Revision 1.54  2005/01/12 06:34:53  collin
	*** empty log message ***
	
	Revision 1.53  2004/05/04 22:52:19  niels
	*** empty log message ***
	
	Revision 1.52  2004/03/26 01:42:53  gecko1
	Add code to disable any port directly connected to an iPod when we go to sleep.
	
	Revision 1.51  2004/03/05 00:33:59  calderon
	Fixed 3570909 - FireWire - iokit_fw_errs should be defined in hex
	All decimal #define errors in header changed to hex
	
	Revision 1.50  2003/11/07 21:01:18  niels
	Revision 1.49  2003/10/21 01:16:41  collin
	Revision 1.48  2003/10/17 00:25:24  collin
	Revision 1.47  2003/10/15 02:19:45  collin
	Revision 1.46  2003/07/22 10:49:47  niels
	Revision 1.45  2003/07/21 06:52:59  niels
	merge isoch to TOT
	
	Revision 1.44.4.5  2003/07/21 06:44:44  niels
	Revision 1.44.4.4  2003/07/18 00:17:42  niels
	Revision 1.44.4.3  2003/07/14 22:08:53  niels
	Revision 1.44.4.2  2003/07/09 21:24:01  niels
	Revision 1.44.4.1  2003/07/01 20:54:07  niels
	isoch merge
	
	Revision 1.44  2003/03/17 01:05:22  collin
	Revision 1.43  2003/03/07 01:26:06  collin
	Revision 1.42  2003/02/19 22:33:17  niels
	add skip cycle DCL
	
	Revision 1.41  2003/02/18 00:14:01  collin
	Revision 1.40  2003/02/17 21:47:52  collin
	Revision 1.39  2002/12/05 19:08:37  niels
	remove trailing commas from enums in IOFireWireFamilyCommon.h
	
	Revision 1.38  2002/11/01 20:45:57  collin
	add enhanced IRM with support for the BROADCAST_CHANNEL register
	
	Revision 1.37  2002/10/01 02:40:27  collin
	security mode support
	
	Revision 1.36  2002/09/25 21:17:14  collin
	fix headers again.
	
	Revision 1.35  2002/09/25 00:27:23  niels
	flip your world upside-down
	
	Revision 1.34  2002/09/12 22:41:53  niels
	add GetIRMNodeID() to user client
	
*/

/*! @header IOFireWireFamilyCommon.h
This file contains useful definitions for working with FireWire
in the kernel and in user space
*/

#ifndef __IOFireWireFamilyCommon_H__
#define __IOFireWireFamilyCommon_H__

#ifdef KERNEL
#ifndef __IOKIT_IOTYPES_H
	#include <IOKit/IOTypes.h>
#endif
#else
#include <IOKit/IOKitLib.h>
#endif

//#define LEGACY_SHUTDOWN

#define FW_OLD_DCL_DEFS
#define FW_OLD_BIT_DEFS

// =================================================================
// bit ranges and fields
// =================================================================
#pragma mark -
#pragma mark BITS

// FireWire bit defs.

#define BIT(x)		( 1 << (x) )
#define FW_BIT(x)	( 1 << (31 - (x) ) )

#define FWBitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (start)) >>			\
	 ((start) + (31 - (end)))) <<					\
	(31 - (end))									\
)

#define FWBitRangePhase(start, end)					\
	(31 - (end))

#define BitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (31 - (end))) >>		\
	 ((31 - (end)) + (start))) <<					\
	(start)											\
)
 

#define BitRangePhase(start, end)					\
	(start)

// =================================================================
// FireWire messages & errors
// =================================================================
#pragma mark -
#pragma mark MESSAGES AND ERRORS

#define	iokit_fw_err(return) (sys_iokit|sub_iokit_firewire|return)

// e0008010 -> 0xe000801f Response codes from response packets

// Base of Response error codes
#define kIOFireWireResponseBase							iokit_fw_err(0x10)

// e0008020 -- Bus reset during command execution (current bus generation does
//             not match that specified in command.)
#define kIOFireWireBusReset								(kIOFireWireResponseBase+kFWResponseBusResetError)

// e0008001 -- Can't find requested entry in ROM
#define kIOConfigNoEntry								iokit_fw_err(0x1)

// e0008002 -- In pending queue waiting to execute
#define kIOFireWirePending								iokit_fw_err(0x2)

// e0008003 -- Last DCL callback of program (internal use)
#define kIOFireWireLastDCLToken							iokit_fw_err(0x3)

// e0008004
#define kIOFireWireConfigROMInvalid						iokit_fw_err(0x4)

// e0008005
#define kIOFireWireAlreadyRegistered					iokit_fw_err(0x5)

// e0008006
#define kIOFireWireMultipleTalkers						iokit_fw_err(0x6)

// e0008007
#define kIOFireWireChannelActive						iokit_fw_err(0x7)

// e0008008
#define kIOFireWireNoListenerOrTalker					iokit_fw_err(0x8)

// e0008009
#define kIOFireWireNoChannels							iokit_fw_err(0x9)

// e000800A
#define kIOFireWireChannelNotAvailable					iokit_fw_err(0xA)

// e000800B
#define kIOFireWireSeparateBus							iokit_fw_err(0xB)

// e000800C
#define kIOFireWireBadSelfIDs							iokit_fw_err(0xC)

// e000800D
#define kIOFireWireLowCableVoltage						iokit_fw_err(0xD)

// e000800E
#define kIOFireWireInsufficientPower					iokit_fw_err(0xE)

// e000800f
#define kIOFireWireOutOfTLabels							iokit_fw_err(0xF)

// NOTE: errors 1631 used for address space response codes.. (see above)

// e0008101
#define kIOFireWireBogusDCLProgram						iokit_fw_err(0x101)

// e0008102
#define kIOFireWireTalkingAndListening					iokit_fw_err(0x102)

// e0008103
#define kIOFireWireHardwareSlept						iokit_fw_err(0x103)

// e0008104		// let's resume here...

// e0008104 -- In the middle of completing
#define kIOFireWireCompleting							iokit_fw_err(0x104)

// e0008105 -- Invalid Response Length
#define kIOFireWireInvalidResponseLength				iokit_fw_err(0x105)

// e0008106 -- Isoch Bandwidth Not Available
#define kIOFireWireIsochBandwidthNotAvailable			iokit_fw_err(0x106)


// e00087d0
#define kIOFWMessageServiceIsRequestingClose 			(UInt32)iokit_fw_err(0x7D0)
#define kIOFWMessagePowerStateChanged 					(UInt32)iokit_fw_err(0x7D1)
#define kIOFWMessageTopologyChanged						(UInt32)iokit_fw_err(0x7D2)
// =================================================================
// Pseudo address space response codes
// =================================================================
#pragma mark -
#pragma mark PSEDUO ADDRESS SPACE RESPONSE CODES
enum
{
	kFWResponseComplete			= 0,	// OK!
	kFWResponseConflictError	= 4,	// Resource conflict, may retry
	kFWResponseDataError		= 5,	// Data not available
	kFWResponseTypeError		= 6,	// Operation not supported
	kFWResponseAddressError		= 7,	// Address not valid in target device
	kFWResponseBusResetError	= 16,	// Pseudo response generated locally
	kFWResponsePending			= 17	// Pseudo response, real response sent later.
};

//
// Pseudo address space response codes
//
enum
{
	kFWAckTimeout				= -1,	// Pseudo ack generated locally
	kFWAckComplete				= 1,
	kFWAckPending				= 2,
	kFWAckBusyX					= 4,
	kFWAckBusyA					= 5,
	kFWAckBusyB					= 6,
	kFWAckDataError				= 13,
	kFWAckTypeError				= 14
};

// =================================================================
// FireWire bus speed numbers
// =================================================================
#pragma mark -
#pragma mark BUS SPEED NUMBERS

typedef enum
{
	kFWSpeed100MBit			= 0,
	kFWSpeed200MBit			= 1,
	kFWSpeed400MBit			= 2,
	kFWSpeed800MBit			= 3,
	kFWSpeedReserved		= 3,	// In all cases, 1394B Devices report this speed, 
									// each port of the PHY could be different
	
	kFWSpeedUnknownMask		= 0x80,	// If speed was reserved and we haven't probed it further
	
	kFWSpeedMaximum			= 0x7FFFFFFF,	
	kFWSpeedInvalid			= 0x80000000
} IOFWSpeed;

// =================================================================
// FWAddress
// =================================================================
#pragma mark -
#pragma mark FWADDRESS
//
// The venerable FWAddress structure. This is the standard
// struct to use for passing FireWire addresses.
//

typedef struct FWAddressStruct
{
    UInt16	nodeID;		// bus/node
    UInt16	addressHi;	// Top 16 bits of node address.
    UInt32	addressLo;	// Bottom 32 bits of node address
	
	//
	// Useful C++ only constructors
	//
	#ifdef __cplusplus
	FWAddressStruct(const FWAddressStruct & a): 
			nodeID(a.nodeID), addressHi(a.addressHi), addressLo(a.addressLo) {};
    FWAddressStruct(UInt16 h=0xdead, UInt32 l=0xcafebabe) : 
			nodeID(0), addressHi(h), addressLo(l) {};
	FWAddressStruct(UInt16 h, UInt32 l, UInt16 n) :
			nodeID(n), addressHi(h), addressLo(l) {};
	#endif
} FWAddress, *FWAddressPtr ;

// =================================================================
// Config ROM
// =================================================================
#pragma mark -
#pragma mark CONFIG ROM

//
// CSR bit defs.
//

#define CSR_BIT(x) FW_BIT(x)

#define CSRBitRange(start, end)						\
(													\
	((((UInt32) 0xFFFFFFFF) << (start)) >>			\
	((start) + (31 - (end)))) <<					\
	(31 - (end))									\
)

#define CSRBitRangePhase(start, end)				\
	(31 - end)

//
// Key types.
//

typedef enum
{
	kConfigImmediateKeyType		= 0,
	kConfigOffsetKeyType		= 1,
	kConfigLeafKeyType		= 2,
	kConfigDirectoryKeyType		= 3,
	kInvalidConfigROMEntryType	= 0xff
} IOConfigKeyType;

//
// Key values.
//

enum
{
	kConfigTextualDescriptorKey		= 0x01,
	kConfigBusDependentInfoKey		= 0x02,
	kConfigModuleVendorIdKey		= 0x03,
	kConfigModuleHwVersionKey		= 0x04,
	kConfigModuleSpecIdKey			= 0x05,
	kConfigModuleSwVersionKey		= 0x06,
	kConfigModuleDependentInfoKey	= 0x07,
	kConfigNodeVendorIdKey			= 0x08,
	kConfigNodeHwVersionKey			= 0x09,
	kConfigNodeSpecIdKey			= 0x0A,
	kConfigNodeSwVersionKey			= 0x0B,
	kConfigNodeCapabilitiesKey		= 0x0C,
	kConfigNodeUniqueIdKey			= 0x0D,
	kConfigNodeUnitsExtentKey		= 0x0E,
	kConfigNodeMemoryExtentKey		= 0x0F,
	kConfigNodeDependentInfoKey		= 0x10,
	kConfigUnitDirectoryKey			= 0x11,
	kConfigUnitSpecIdKey			= 0x12,
	kConfigUnitSwVersionKey			= 0x13,
	kConfigUnitDependentInfoKey		= 0x14,
	kConfigUnitLocationKey			= 0x15,
	kConfigUnitPollMaskKey			= 0x16,
	kConfigModelIdKey				= 0x17,
	kConfigGenerationKey			= 0x38,		// Apple-specific

	kConfigRootDirectoryKey			= 0xffff	// Not a real key
};

enum
{
	kConfigSBP2LUN					= 0x14,
	kConfigSBP2Revision				= 0x21,
	kConfigSBP2MAO					= 0x54	
};

// Core CSR registers.
enum
{
	kCSRStateUnitDepend			= CSRBitRange(0, 15),
	kCSRStateUnitDependPhase	= CSRBitRangePhase(0, 15),

	kCSRStateBusDepend			= CSRBitRange(16, 23),
	kCSRStateBusDependPhase		= CSRBitRangePhase(16, 23),

	kCSRStateLost				= CSR_BIT(24),
	kCSRStateDReq				= CSR_BIT(25),
	kCSRStateELog				= CSR_BIT(27),
	kCSRStateAtn				= CSR_BIT(28),
	kCSRStateOff				= CSR_BIT(29),

	kCSRStateState				= CSRBitRange(30, 31),
	kCSRStateStatePhase			= CSRBitRangePhase(30, 31),
	kCSRStateStateRunning		= 0,
	kCSRStateStateInitializing	= 1,
	kCSRStateStateTesting		= 2,
	kCSRStateStateDead			= 3
};

// Config ROM entry bit locations.

enum
{
	kConfigBusInfoBlockLength		= CSRBitRange (0, 7),
	kConfigBusInfoBlockLengthPhase	= CSRBitRangePhase (0, 7),

	kConfigROMCRCLength				= CSRBitRange (8, 15),
	kConfigROMCRCLengthPhase		= CSRBitRangePhase (8, 15),

	kConfigROMCRCValue				= CSRBitRange (16, 31),
	kConfigROMCRCValuePhase			= CSRBitRangePhase (16, 31),

	kConfigEntryKeyType				= CSRBitRange (0, 1),
	kConfigEntryKeyTypePhase		= CSRBitRangePhase (0, 1),

	kConfigEntryKeyValue			= CSRBitRange (2, 7),
	kConfigEntryKeyValuePhase		= CSRBitRangePhase (2, 7),

	kConfigEntryValue				= CSRBitRange (8, 31),
	kConfigEntryValuePhase			= CSRBitRangePhase (8, 31),

	kConfigLeafDirLength			= CSRBitRange (0, 15),
	kConfigLeafDirLengthPhase		= CSRBitRangePhase (0, 15),

	kConfigLeafDirCRC				= CSRBitRange (16, 31),
	kConfigLeafDirCRCPhase			= CSRBitRangePhase (16, 31)
};

//
// Key types.
//
typedef enum
{
	kCSRImmediateKeyType		= 0,
	kCSROffsetKeyType			= 1,
	kCSRLeafKeyType				= 2,
	kCSRDirectoryKeyType		= 3,
    kInvalidCSRROMEntryType		= 0xff
} IOCSRKeyType;

// CSR 64-bit fixed address defs.

enum
{
	kCSRNodeID								= CSRBitRange (0, 15),
	kCSRNodeIDPhase							= CSRBitRangePhase (0, 15),

	kCSRInitialMemorySpaceBaseAddressHi		= 0x00000000,
	kCSRInitialMemorySpaceBaseAddressLo		= 0x00000000,

	kCSRPrivateSpaceBaseAddressHi			= 0x0000FFFF,
	kCSRPrivateSpaceBaseAddressLo			= 0xE0000000,

	kCSRRegisterSpaceBaseAddressHi			= 0x0000FFFF,
	kCSRRegisterSpaceBaseAddressLo			= 0xF0000000,

	kCSRCoreRegistersBaseAddress			= kCSRRegisterSpaceBaseAddressLo,
	kCSRStateClearAddress					= kCSRCoreRegistersBaseAddress + 0x0000,
	kCSRStateSetAddress						= kCSRCoreRegistersBaseAddress + 0x0004,
	kCSRNodeIDsAddress						= kCSRCoreRegistersBaseAddress + 0x0008,
	kCSRResetStartAddress					= kCSRCoreRegistersBaseAddress + 0x000C,
	kCSRIndirectAddressAddress				= kCSRCoreRegistersBaseAddress + 0x0010,
	kCSRIndirectDataAddress					= kCSRCoreRegistersBaseAddress + 0x0014,
	kCSRSplitTimeoutHiAddress				= kCSRCoreRegistersBaseAddress + 0x0018,
	kCSRSplitTimeoutLoAddress				= kCSRCoreRegistersBaseAddress + 0x001C,
	kCSRArgumentHiAddress					= kCSRCoreRegistersBaseAddress + 0x0020,
	kCSRArgumentLoAddress					= kCSRCoreRegistersBaseAddress + 0x0024,
	kCSRTestStartAddress					= kCSRCoreRegistersBaseAddress + 0x0028,
	kCSRTestStatusAddress					= kCSRCoreRegistersBaseAddress + 0x002C,
	kCSRUnitsBaseHiAddress					= kCSRCoreRegistersBaseAddress + 0x0030,
	kCSRUnitsBaseLoAddress					= kCSRCoreRegistersBaseAddress + 0x0034,
	kCSRUnitsBoundHiAddress					= kCSRCoreRegistersBaseAddress + 0x0038,
	kCSRUnitsBoundLoAddress					= kCSRCoreRegistersBaseAddress + 0x003C,
	kCSRMemoryBaseHiAddress					= kCSRCoreRegistersBaseAddress + 0x0040,
	kCSRMemoryBaseLoAddress					= kCSRCoreRegistersBaseAddress + 0x0044,
	kCSRMemoryBoundHiAddress				= kCSRCoreRegistersBaseAddress + 0x0048,
	kCSRMemoryBoundLoAddress				= kCSRCoreRegistersBaseAddress + 0x004C,
	kCSRInterruptTargetAddress				= kCSRCoreRegistersBaseAddress + 0x0050,
	kCSRInterruptMaskAddress				= kCSRCoreRegistersBaseAddress + 0x0054,
	kCSRClockValueHiAddress					= kCSRCoreRegistersBaseAddress + 0x0058,
	kCSRClockValueMidAddress				= kCSRCoreRegistersBaseAddress + 0x005C,
	kCSRClockTickPeriodMidAddress			= kCSRCoreRegistersBaseAddress + 0x0060,
	kCSRClockTickPeriodLoAddress			= kCSRCoreRegistersBaseAddress + 0x0064,
	kCSRClockStrobeArrivedHiAddress			= kCSRCoreRegistersBaseAddress + 0x0068,
	kCSRClockStrobeArrivedMidAddress		= kCSRCoreRegistersBaseAddress + 0x006C,
	kCSRClockInfo0Address					= kCSRCoreRegistersBaseAddress + 0x0070,
	kCSRClockInfo1Address					= kCSRCoreRegistersBaseAddress + 0x0074,
	kCSRClockInfo2Address					= kCSRCoreRegistersBaseAddress + 0x0078,
	kCSRClockInfo3Address					= kCSRCoreRegistersBaseAddress + 0x007C,
	kCSRMessageRequestAddress				= kCSRCoreRegistersBaseAddress + 0x0080,
	kCSRMessageResponseAddress				= kCSRCoreRegistersBaseAddress + 0x00C0,
	kCSRErrorLogBufferAddress				= kCSRCoreRegistersBaseAddress + 0x0180,

	kCSRBusDependentRegistersBaseAddress	= kCSRRegisterSpaceBaseAddressLo + 0x0200,
	kCSRBusyTimeout							= kCSRRegisterSpaceBaseAddressLo + 0x0210,
	kCSRBusManagerID						= kCSRRegisterSpaceBaseAddressLo + 0x021C,
	kCSRBandwidthAvailable					= kCSRRegisterSpaceBaseAddressLo + 0x0220,
	kCSRChannelsAvailable31_0				= kCSRRegisterSpaceBaseAddressLo + 0x0224,
	kCSRChannelsAvailable63_32				= kCSRRegisterSpaceBaseAddressLo + 0x0228,
	kCSRBroadcastChannel					= kCSRRegisterSpaceBaseAddressLo + 0x0234,
	
	kConfigROMBaseAddress					= kCSRRegisterSpaceBaseAddressLo + 0x0400,
	kConfigBIBHeaderAddress					= kConfigROMBaseAddress,
	kConfigBIBBusNameAddress				= kConfigROMBaseAddress + 4,
	
	kPCRBaseAddress							= kCSRRegisterSpaceBaseAddressLo + 0x900,
	kFCPCommandAddress						= kCSRRegisterSpaceBaseAddressLo + 0xb00,
	kFCPResponseAddress						= kCSRRegisterSpaceBaseAddressLo + 0xd00
};

// from figure 10-7 of 1394a
#define kBroadcastChannelInitialValues 	0x8000001f
#define kBroadcastChannelValidMask 		0x40000000

// CSR defined 64 bit unique ID.

typedef UInt64 CSRNodeUniqueID;

// FireWire core CSR registers.

enum
{
	kFWCSRStateGone				= FW_BIT(16),
	kFWCSRStateLinkOff			= FW_BIT(22),
	kFWCSRStateCMstr			= FW_BIT(23)
};

// FireWire bus/nodeID address defs.

enum
{
	kFWAddressBusID				= FWBitRange (16, 25) << kCSRNodeIDPhase,
	kFWAddressBusIDPhase		= FWBitRangePhase (16, 25) + kCSRNodeIDPhase,

	kFWAddressNodeID			= FWBitRange (26, 31) << kCSRNodeIDPhase,
	kFWAddressNodeIDPhase		= FWBitRangePhase (26, 31) + kCSRNodeIDPhase,

	kFWLocalBusID				= 1023,
	kFWBroadcastNodeID			= 63,
	kFWBadNodeID				= 0xffff,

	kFWLocalBusAddress			= kFWLocalBusID << kFWAddressBusIDPhase,
	kFWBroadcastAddress			= kFWBroadcastNodeID << kFWAddressNodeIDPhase
};

#define FWNodeBaseAddress(busID, nodeID)												\
(																						\
	(busID << kFWAddressBusIDPhase) |													\
	(nodeID << kFWAddressNodeIDPhase)													\
)

#define FWNodeRegisterSpaceBaseAddressHi(busID, nodeID)									\
(																						\
	FWNodeBaseAddress (busID, nodeID) |													\
	kCSRRegisterSpaceBaseAddressHi														\
)

// FireWire CSR bus info block defs.

enum
{
	kFWBIBHeaderAddress					= kConfigBIBHeaderAddress,
	kFWBIBBusNameAddress				= kConfigBIBBusNameAddress,
	kFWBIBNodeCapabilitiesAddress		= kConfigROMBaseAddress + 8,
	kFWBIBNodeUniqueIDHiAddress			= kConfigROMBaseAddress + 12,
	kFWBIBNodeUniqueIDLoAddress			= kConfigROMBaseAddress + 16,

	kFWBIBBusName						= 0x31333934, //'1394'

	kFWBIBIrmc							= FW_BIT(0),
	kFWBIBCmc							= FW_BIT(1),
	kFWBIBIsc							= FW_BIT(2),
	kFWBIBBmc							= FW_BIT(3),
	kFWBIBCycClkAcc						= FWBitRange (8, 15),
	kFWBIBCycClkAccPhase				= FWBitRangePhase (8, 15),
	kFWBIBMaxRec						= FWBitRange (16, 19),
	kFWBIBMaxRecPhase					= FWBitRangePhase (16, 19),
	kFWBIBMaxROM						= FWBitRange (20, 21),
	kFWBIBMaxROMPhase					= FWBitRangePhase (20, 21),
	kFWBIBGeneration					= FWBitRange (24, 27),
	kFWBIBGenerationPhase				= FWBitRangePhase (24, 27),
	kFWBIBLinkSpeed						= FWBitRange (29, 31),
	kFWBIBLinkSpeedPhase				= FWBitRangePhase (29, 31)
};

enum
{
	kConfigUnitSpecAppleA27				= 0x000a27,
	kConfigUnitSpec1394TA1				= 0x00a02d,
	
	kConfigUnitSWVersMacintosh10		= 10,
	kConfigUnitSWVersIIDC100			= 0x000100,
	kConfigUnitSWVersIIDC101			= 0x000101,
	kConfigUnitSWVersIIDC102			= 0x000102
};


// =================================================================
// Isoch defines
// =================================================================
#pragma mark -
#pragma mark ISOCH

enum
{
	kFWIsochDataLength		= FWBitRange (0, 15),
	kFWIsochDataLengthPhase	= FWBitRangePhase (0, 15),
	
	kFWIsochTag				= FWBitRange (16, 17),
	kFWIsochTagPhase		= FWBitRangePhase (16, 17),

	kFWIsochChanNum			= FWBitRange (18, 23),
	kFWIsochChanNumPhase	= FWBitRangePhase (18, 23),

	kFWIsochTCode			= FWBitRange (24, 27),
	kFWIsochTCodePhase		= FWBitRangePhase (24, 27),

	kFWIsochSy				= FWBitRange (28, 31),
	kFWIsochSyPhase			= FWBitRangePhase (28, 31)
};

#define CHAN_BIT(x) 		(((UInt64)1) << (63 - (x))
#define CHAN_MASK(x) 		(~CHAN_BIT(X))

typedef enum
{
	kFWNeverMultiMode = 0,
	kFWAllowMultiMode,
	kFWSuggestMultiMode,
	kFWAlwaysMultiMode,
	
	kFWDefaultIsochResourceFlags = kFWNeverMultiMode
} IOFWIsochResourceFlags ;

enum
{
	kFWIsochChannelDefaultFlags = 0,
	kFWIsochChannelDoNotResumeOnWake = BIT(1)
} ;

typedef enum
{
	kFWIsochPortDefaultOptions = 0,
	kFWIsochPortUseSeparateKernelThread		= BIT(1),
	kFWIsochEnableRobustness			= BIT(2),
	kFWIsochBigEndianUpdates			= BIT(3),	// private
	kFWIsochRequireLastContext			= BIT(4),	// private
} IOFWIsochPortOptions ;

// =================================================================
// DCL opcode defs.
// =================================================================
#pragma mark -
#pragma mark DCL OPCODES

enum
{
	kFWDCLImmediateEvent				= 0,
	kFWDCLCycleEvent					= 1,
	kFWDCLSyBitsEvent					= 2
};

typedef enum
{
	kFWDCLInvalidNotification				= 0
	, kFWDCLUpdateNotification				= 1
	, kFWDCLModifyNotification				= 2
	, kFWNuDCLModifyNotification			= 3
	, kFWNuDCLModifyJumpNotification		= 4
	, kFWNuDCLUpdateNotification			= 5
} IOFWDCLNotificationType ;

enum
{
	kFWDCLOpDynamicFlag					= BIT(16),
	kFWDCLOpVendorDefinedFlag			= BIT(17),
	kFWDCLOpFlagMask					= BitRange (16, 31),
	kFWDCLOpFlagPhase					= BitRangePhase (16, 31)
};

enum
{
	kDCLInvalidOp						= 0,
	kDCLSendPacketStartOp				= 1,
	//kDCLSendPacketWithHeaderStartOp		= 2, // Deprecated legacy DCL opcode! Use NuDCL instead!
	kDCLSendPacketOp					= 3,
	kDCLSendBufferOp					= 4,	// obsolete - do not use
	kDCLReceivePacketStartOp			= 5,
	kDCLReceivePacketOp					= 6,
	kDCLReceiveBufferOp					= 7,	// obsolete - do not use
	kDCLCallProcOp						= 8,
	kDCLLabelOp							= 9,
	kDCLJumpOp							= 10,
	kDCLSetTagSyncBitsOp				= 11,
	kDCLUpdateDCLListOp					= 12,
	kDCLTimeStampOp						= 13,
	kDCLPtrTimeStampOp					= 14,
	kDCLSkipCycleOp						= 15,

	kDCLNuDCLLeaderOp					= 20	// compilerData field contains NuDCLRef to start of NuDCL
												// program.
												// Should not need to use this directly.
};

#ifdef FW_OLD_DCL_DEFS

//typedef struct DCLCommandStruct ;
//typedef void (DCLCallCommandProc)(DCLCommandStruct* command);

#else

//typedef struct DCLCommand ;
//typedef void (DCLCallCommandProc)(DCLCommand* command);

#endif

// =================================================================
// DCL structs
// =================================================================
#pragma mark -
#pragma mark DCL

#ifdef __LP64__		
typedef void* DCLCallProcDataType;
#else
typedef UInt32 DCLCallProcDataType;
#endif

#ifdef KERNEL
	#ifdef __LP64__		
		typedef void* DCLCompilerDataType;
	#else
		typedef UInt32 DCLCompilerDataType;
	#endif
#else
		typedef UInt32 DCLCompilerDataType;
#endif

typedef struct DCLCommandStruct
{
	struct DCLCommandStruct *	pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType			compilerData;			// Data for use by DCL compiler.
	UInt32						opcode;					// DCL opcode.
	UInt32						operands[1];			// DCL operands (size varies)
} DCLCommand;

typedef void (DCLCallCommandProc)(DCLCommand * command);

typedef struct DCLTransferPacketStruct
{
	DCLCommand *			pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType		compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	void *					buffer;					// Packet buffer.
	UInt32					size;					// Buffer size.
} DCLTransferPacket ;

typedef struct DCLTransferBufferStruct
{
	DCLCommand *			pNextDCLCommand;		// Next DCL command.
	DCLCompilerDataType		compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	void *					buffer;					// Buffer.
	UInt32					size;					// Buffer size.
	UInt16					packetSize;				// Size of packets to send.
	UInt16					reserved;
	UInt32					bufferOffset;			// Current offset into buffer.
} DCLTransferBuffer ;

typedef struct DCLCallProcStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLCallCommandProc *	proc;				// Procedure to call.
	DCLCallProcDataType		procData;			// Data for use by called procedure.
} DCLCallProc;

typedef struct DCLLabelStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
} DCLLabel;

typedef struct DCLJumpStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLLabel *				pJumpDCLLabel;		// DCL label to jump to.
} DCLJump;

typedef struct DCLSetTagSyncBitsStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt16					tagBits;			// Tag bits for following packets.
	UInt16					syncBits;			// Sync bits for following packets.
} DCLSetTagSyncBits;

typedef struct DCLUpdateDCLListStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	DCLCommand **			dclCommandList;		// List of DCL commands to update.
	UInt32					numDCLCommands;		// Number of DCL commands in list.
} DCLUpdateDCLList;

typedef struct DCLTimeStampStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32					timeStamp;			// Time stamp.
} DCLTimeStamp;

typedef struct DCLPtrTimeStampStruct
{
	DCLCommand *			pNextDCLCommand;	// Next DCL command.
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32 *				timeStampPtr;		// Where to store the time stamp.
} DCLPtrTimeStamp ;

typedef struct 
{
	DCLCommand *			pNextDCLCommand ;	// unused - always NULL
	DCLCompilerDataType		compilerData;		// Data for use by DCL compiler.
	UInt32					opcode ;			// must be kDCLNuDCLLeaderOp
	void*				 	program ;			// NuDCL program here...
} DCLNuDCLLeader ;

#ifdef FW_OLD_DCL_DEFS

//  should not use these...

typedef DCLCommand*				DCLCommandPtr ;
typedef DCLTransferBuffer*		DCLTransferBufferPtr ;
typedef DCLTransferPacket*		DCLTransferPacketPtr ;
typedef DCLCallProc*			DCLCallProcPtr ;
typedef DCLLabel*				DCLLabelPtr ;
typedef DCLJump*				DCLJumpPtr ;
typedef DCLSetTagSyncBits*		DCLSetTagSyncBitsPtr ;
typedef DCLUpdateDCLList*		DCLUpdateDCLListPtr ;
typedef DCLTimeStamp*			DCLTimeStampPtr ;
typedef DCLPtrTimeStamp*		DCLPtrTimeStampPtr ;
typedef DCLCallCommandProc* 	DCLCallCommandProcPtr ;

#endif


// =================================================================
// User-Lib Export DCL structs - Thses structus are used to pass
// a user-created legacy DCL program down into kernel space. These
// structs allow support for both 32-bit and 64-bit user-space clients.
// These structs should only be used internally. They are not for
// clients to create DCL programs with.
// =================================================================

typedef struct UserExportDCLCommandStruct
{
	mach_vm_address_t					pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t					pNextDCLCommand;		// Next DCL command.
	uint64_t							compilerData;			// Data for use by DCL compiler.
	UInt32								opcode;					// DCL opcode.
	UInt32								operands[1];			// DCL operands (size varies)
} __attribute__ ((packed)) UserExportDCLCommand;

typedef void (UserExportDCLCallCommandProc)(UserExportDCLCommand * command);

typedef struct UserExportDCLTransferPacketStruct
{
	mach_vm_address_t		pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;		// Next DCL command.
	uint64_t				compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	mach_vm_address_t		buffer;					// Packet buffer.
	UInt32					size;					// Buffer size.
} __attribute__ ((packed)) UserExportDCLTransferPacket ;

typedef struct UserExportDCLTransferBufferStruct
{
	mach_vm_address_t		pClientDCLStruct;		// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;		// Next DCL command.
	uint64_t				compilerData;			// Data for use by DCL compiler.
	UInt32					opcode;					// DCL opcode.
	mach_vm_address_t		buffer;					// Buffer.
	UInt32					size;					// Buffer size.
	UInt16					packetSize;				// Size of packets to send.
	UInt16					reserved;
	UInt32					bufferOffset;			// Current offset into buffer.
} __attribute__ ((packed)) UserExportDCLTransferBuffer ;

typedef struct UserExportDCLCallProcStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		proc;				// Procedure to call.
	uint64_t				procData;			// Data for use by called procedure.
} __attribute__ ((packed)) UserExportDCLCallProc;

typedef struct UserExportDCLLabelStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
} __attribute__ ((packed)) UserExportDCLLabel;

typedef struct UserExportDCLJumpStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		pJumpDCLLabel;		// DCL label to jump to.
} __attribute__ ((packed)) UserExportDCLJump;

typedef struct UserExportDCLSetTagSyncBitsStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt16					tagBits;			// Tag bits for following packets.
	UInt16					syncBits;			// Sync bits for following packets.
} __attribute__ ((packed)) UserExportDCLSetTagSyncBits;

typedef struct UserExportDCLUpdateDCLListStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		dclCommandList;		// List of DCL commands to update.
	UInt32					numDCLCommands;		// Number of DCL commands in list.
} __attribute__ ((packed)) UserExportDCLUpdateDCLList;

typedef struct UserExportDCLTimeStampStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	UInt32					timeStamp;			// Time stamp.
} __attribute__ ((packed)) UserExportDCLTimeStamp;

typedef struct UserExportDCLPtrTimeStampStruct
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand;	// Next DCL command.
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode;				// DCL opcode.
	mach_vm_address_t		timeStampPtr;		// Where to store the time stamp.
} __attribute__ ((packed)) UserExportDCLPtrTimeStamp ;

typedef struct 
{
	mach_vm_address_t		pClientDCLStruct;	// A pointer to the client's DCL struct
	mach_vm_address_t		pNextDCLCommand ;	// unused - always NULL
	uint64_t				compilerData;		// Data for use by DCL compiler.
	UInt32					opcode ;			// must be kDCLNuDCLLeaderOp
	mach_vm_address_t	 	program ;			// NuDCL program here...
} __attribute__ ((packed)) UserExportDCLNuDCLLeader ;


// =================================================================
// NuDCL
// =================================================================
#pragma mark -
#pragma mark NUDCL

typedef struct __NuDCL *	NuDCLRef ;
typedef NuDCLRef			NuDCLSendPacketRef ;
typedef NuDCLRef			NuDCLSkipCycleRef ;
typedef NuDCLRef			NuDCLReceivePacketRef ;

typedef void (*NuDCLCallback)( void* refcon, NuDCLRef dcl );

typedef enum
{
	kNuDCLDynamic = BIT( 1 ),
	kNuDCLUpdateBeforeCallback = BIT( 2 )

} NuDCLFlags ;

// =================================================================
// Miscellaneous
// =================================================================
#pragma mark -
#pragma mark MISCELLANEOUS

typedef void* FWClientCommandID ;

typedef struct IOFireWireSessionRefOpaqueStuct* IOFireWireSessionRef ;

//
// bus management constants.
//

enum
{
	kFWBusManagerArbitrationTimeoutDuration	= 625 // durationMillisecond
};

//
// bus characteristics.
//

enum
{
	kFWMaxBusses				= 1023,
	kFWMaxNodesPerBus			= 63,
	kFWMaxNodeHops				= 16
};

/*! @enum		NodeFlags

	@abstract	Flags that specify characteristics of the FireWire device node.
	
	@constant	kIOFWDisablePhysicalAccess 		Disable physical memory access
	
	@constant	kIOFWDisableAllPhysicalAccess	Disable all physical memory access
	
	@constant	kIOFWEnableRetryOnAckD			Enable retry on Ack D
	
	@constant	kIOFWLimitAsyncPacketSize		Limit async packet size
	
	@constant	kIOFWDisablePhyOnSleep			Disable Phy, when machine is in Sleep mode
	
	@constant	kIOFWMustBeRoot					Attempt to make this device root, There is no guarentee Mac OS will succeed in making the device 
	                                            root.
												
	@constant	kIOFWMustNotBeRoot				Attempt to prevent this device from being root, There is no guarentee Mac OS will succeed in preventing the device 
	                                            from being root.
												
	@constant	kIOFWMustHaveGap63				Attempt to ensure the gap count is 63, when this device is on the bus. Gap 63 reduces bus performance significantly,
												so this flag should be used only when absolutely necessary. There is no guarentee Mac OS will succeed in forcing
												the gap count to 63.
*/
enum
{
    kIOFWDisablePhysicalAccess 		= (1 << 0),
	kIOFWDisableAllPhysicalAccess 	= (1 << 1),
	kIOFWEnableRetryOnAckD			= (1 << 2),
	kIOFWLimitAsyncPacketSize		= (1 << 3),
	kIOFWDisablePhyOnSleep			= (1 << 4),
	kIOFWMustBeRoot					= (1 << 5),
	kIOFWMustNotBeRoot				= (1 << 6),
	kIOFWMustHaveGap63				= (1 << 7)
};

//
// write flags
//

enum IOFWWriteFlags
{
	kIOFWWriteFlagsNone				= 0x00000000,
	kIOFWWriteFlagsDeferredNotify 	= 0x00000001,
	kIOFWWriteFastRetryOnBusy		= 0x00000002,
	kIOFWWriteBlockRequest			= 0x00000004,		// force a block request
};

//
// read flags
//

enum IOFWReadFlags
{
	kIOFWReadFlagsNone				= 0x00000000,
	kIOFWReadBlockRequest			= 0x00000004,		// force a block request
	kIOFWReadPingTime				= 0x00000008		// ping time
};

//
// security modes
//

enum IOFWSecurityMode
{
	kIOFWSecurityModeNormal = 0,
	kIOFWSecurityModeSecure = 1,
	kIOFWSecurityModeSecurePermanent = 2
};

//
// physical access settings
//

enum IOFWPhysicalAccessMode
{
	kIOFWPhysicalAccessEnabled = 0,
	kIOFWPhysicalAccessDisabled = 1,
	kIOFWPhysicalAccessDisabledForGeneration = 2
};

enum
{
	kIOFWSpecID_AAPL = 0xa27,
	kIOFWSWVers_KPF = 0x40
};

// old style bit defs
#ifdef FW_OLD_BIT_DEFS

	#define kBit0	BIT(0)
	#define kBit1	BIT(1)
	#define kBit2	BIT(2)
	#define kBit3	BIT(3)
	#define kBit4	BIT(4)
	#define kBit5	BIT(5)
	#define kBit6	BIT(6)
	#define kBit7	BIT(7)
	#define kBit8	BIT(8)
	#define kBit9	BIT(9)
	#define kBit10	BIT(10)
	#define kBit11	BIT(11)
	#define kBit12	BIT(12)
	#define kBit13	BIT(13)
	#define kBit14	BIT(14)
	#define kBit15	BIT(15)
	#define kBit16	BIT(16)
	#define kBit17	BIT(17)
	#define kBit18	BIT(18)
	#define kBit19	BIT(19)
	#define kBit20	BIT(20)
	#define kBit21	BIT(21)
	#define kBit22	BIT(22)
	#define kBit23	BIT(23)
	#define kBit24	BIT(24)
	#define kBit25	BIT(25)
	#define kBit26	BIT(26)
	#define kBit27	BIT(27)
	#define kBit28	BIT(28)
	#define kBit29	BIT(29)
	#define kBit30	BIT(30)
	#define kBit31	BIT(31)

#endif

#endif //__IOFireWireFamilyCommon_H__
                                                            IOFireWireLib.h                                                                                     0100644 0001750 0001750 00000504623 12566200640 035166  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/firewire                                                              /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *  IOFireWireLib.h
 *  IOFireWireLib
 *
 *  Created on Thu Apr 27 2000.
 *  Copyright (c) 2000-2002 Apple Computer, Inc. All rights reserved.
 *
 */

/*! @header IOFireWireLib.h
IOFireWireLib is the software used by user space software to communicate with FireWire
devices and control the FireWire bus. IOFireWireLib is the lowest-level FireWire interface available
in user space.

To communicate with a device on the FireWire bus, an instance of IOFireWireDeviceInterface (a struct
which is defined below) is created. The methods of IOFireWireDeviceInterface allow you
to communicate with the device and create instances of other interfaces which provide extended 
functionality (for example, creation of unit directories on the local machine).

References to interfaces should be kept using the interface reference typedefs defined herein.
For example, you should use IOFireWireLibDeviceRef to refer to instances of IOFireWireDeviceInterface, 
IOFireWireLibCommandRef to refer to instances of IOFireWireCommandInterface, and so on.

To obtain an IOFireWireDeviceInterface for a device on the FireWire bus, use the function 
IOCreatePlugInInterfaceForService() defined in IOKit/IOCFPlugIn.h. (Note the "i" in "PlugIn" is 
always upper-case.) Quick usage reference:<br>
<ul>
	<li>'service' is a reference to the IOKit registry entry of the kernel object 
		(usually of type IOFireWireDevice) representing the device
		of interest. This reference can be obtained using the functions defined in
		IOKit/IOKitLib.h.</li>
	<li>'plugInType' should be CFUUIDGetUUIDBytes(kIOCFPlugInInterfaceID)</li>
	<li>'interfaceType' should be CFUUIDGetUUIDBytes(kIOFireWireLibTypeID) when using IOFireWireLib</li>
</ul>
The interface returned by IOCreatePlugInInterfaceForService() should be deallocated using 
IODestroyPlugInInterface(). Do not call Release() on it.

*/
/*
	$Log: not supported by cvs2svn $
	Revision 1.77  2009/10/29 22:28:28  calderon
	<rdar://7308574> IOFireWireLib.h and IOFireWireLibIsoch.h headerdoc markup patch

	Revision 1.76  2008/12/12 04:43:57  collin
	user space compare swap command fixes
	
	Revision 1.75  2008/09/12 23:44:05  calderon
	<rdar://5971979/> PseudoAddressSpace skips/mangles packets
	<rdar://5708169/> FireWire synchronous commands' headerdoc missing callback info
	
	Revision 1.74  2007/11/09 01:39:04  arulchan
	fix for rdar://5555060
	
	Revision 1.73  2007/10/16 16:50:21  ayanowit
	Removed existing "work-in-progress" support for buffer-fill isoch.
	
	Revision 1.72  2007/06/21 04:08:45  collin
	*** empty log message ***
	
	Revision 1.71  2007/05/12 01:10:45  arulchan
	Asyncstream transmit command interface
	
	Revision 1.70  2007/05/03 01:21:29  arulchan
	Asyncstream transmit APIs
	
	Revision 1.69  2007/04/28 02:54:23  collin
	*** empty log message ***
	
	Revision 1.68  2007/04/28 01:42:35  collin
	*** empty log message ***
	
	Revision 1.67  2007/04/11 03:37:41  collin
	*** empty log message ***
	
	Revision 1.66  2007/04/05 22:32:09  collin
	*** empty log message ***
	
	Revision 1.65  2007/03/23 01:47:17  collin
	*** empty log message ***
	
	Revision 1.64  2007/03/22 00:30:00  collin
	*** empty log message ***
	
	Revision 1.63  2007/03/14 02:29:35  collin
	*** empty log message ***
	
	Revision 1.62  2007/03/06 06:30:05  collin
	*** empty log message ***
	
	Revision 1.61  2007/03/06 04:50:21  collin
	*** empty log message ***
	
	Revision 1.60  2007/03/03 05:52:20  collin
	*** empty log message ***
	
	Revision 1.59  2007/03/03 04:47:15  collin
	*** empty log message ***
	
	Revision 1.58  2007/02/16 19:09:15  arulchan
	*** empty log message ***
	
	Revision 1.57  2007/02/16 17:41:00  ayanowit
	More Leopard changes.
	
	Revision 1.56  2007/02/15 22:02:38  ayanowit
	More fixes for new IRMAllocation stuff.
	
	Revision 1.55  2007/02/14 22:43:34  collin
	*** empty log message ***
	
	Revision 1.54  2007/02/10 02:40:58  collin
	*** empty log message ***
	
	Revision 1.53  2007/02/09 20:36:46  ayanowit
	More Leopard IRMAllocation changes.
	
	Revision 1.52  2007/01/17 23:22:40  collin
	*** empty log message ***
	
	Revision 1.51  2007/01/17 03:46:27  collin
	*** empty log message ***
	
	Revision 1.50  2007/01/11 04:34:18  collin
	*** empty log message ***
	
	Revision 1.49  2007/01/04 04:07:25  collin
	*** empty log message ***
	
	Revision 1.48  2006/12/22 05:15:13  collin
	*** empty log message ***
	
	Revision 1.47  2006/12/22 03:50:40  collin
	*** empty log message ***
	
	Revision 1.46  2006/12/06 00:01:10  arulchan
	Isoch Channel 31 Generic Receiver
	
	Revision 1.45  2006/10/26 00:39:16  calderon
	Changed headerdoc to specify release() need on GetConfigDirectory
	
	Revision 1.44  2006/09/28 23:50:05  collin
	*** empty log message ***
	
	Revision 1.43  2006/09/28 22:47:06  ayanowit
	Another tweak to new APIs.
	
	Revision 1.42  2006/09/28 22:31:31  arulchan
	New Feature rdar::3413505
	
	Revision 1.41  2006/09/27 22:42:12  ayanowit
	Merged in Leopard changes for new IRMAllocation API.
	
	Revision 1.40  2006/09/22 06:45:19  collin
	*** empty log message ***
	
	Revision 1.39  2004/06/10 20:57:37  niels
	*** empty log message ***
	
	Revision 1.38  2004/05/04 22:52:20  niels
	*** empty log message ***
	
	Revision 1.37  2004/04/19 21:51:49  niels
	Revision 1.36  2004/03/25 00:00:24  niels
	fix panic allocating large physical address spaces
	
	Revision 1.35  2004/02/27 21:02:20  calderon
	Changed headerdoc abstract of function "GetSpeedBetweenNodes" from "Get
	maximum transfer speed to device to which this interface is attached." to
	"Get the maximum transfer speed between nodes 'srcNodeID' and 'destNodeID'."
	
	Revision 1.34  2003/11/20 19:14:08  niels
	Revision 1.33  2003/11/07 21:24:28  niels
	Revision 1.32  2003/11/07 21:01:19  niels
	Revision 1.31  2003/09/10 23:01:48  collin
	Revision 1.30  2003/09/06 01:37:24  collin
	Revision 1.29  2003/08/25 08:39:17  niels
	Revision 1.28  2003/08/08 21:03:47  gecko1
	Merge max-rec clipping code into TOT
	
	Revision 1.27  2003/07/21 06:53:10  niels
	merge isoch to TOT
	
	Revision 1.26.14.2  2003/07/18 00:17:47  niels
	Revision 1.26.14.1  2003/07/01 20:54:23  niels
	isoch merge
	
	Revision 1.26  2002/11/06 23:44:21  wgulland
	Update header doc for CreateLocalIsochPort
	
	Revision 1.25  2002/09/25 00:27:33  niels
	flip your world upside-down
	
	Revision 1.24  2002/09/12 22:41:55  niels
	add GetIRMNodeID() to user client
	
*/

#ifndef __IOFireWireLib_H__
#define __IOFireWireLib_H__

#ifndef KERNEL
#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOCFPlugIn.h>
#include <IOKit/firewire/IOFireWireFamilyCommon.h>

// ============================================================
// plugin loading
// ============================================================

#pragma mark IOFIREWIRELIB TYPE UUID
//	uuid string: CDCFCA94-F197-11D4-87E6-000502072F80
#define kIOFireWireLibTypeID			CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xCD, 0xCF, 0xCA, 0x94, 0xF1, 0x97, 0x11, 0xD4,\
											0x87, 0xE6, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

#pragma mark -
#pragma mark DEVICE/UNIT/NUB INTERFACE UUIDs
// ============================================================
// device/unit/nub interfaces (newest first)
// ============================================================

//
// version 9  // 10.5 Leopard
//
// kIOFireWireDeviceInterface_v9
//		uuid: EE0A94D7-29B4-4D76-A857-57CA477C73B1
#define kIOFireWireDeviceInterfaceID_v9	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xEE, 0x0A, 0x94, 0xD7, 0x29, 0xB4, 0x4D, 0x76, \
											0xA8, 0x57, 0x57, 0xCA, 0x47, 0x7C, 0x73, 0xB1 )

//
// version 8
//
// kIOFireWireDeviceInterface_v8
//		uuid: 22A258BB-A859-11D8-AA56-000A95992A78
#define kIOFireWireDeviceInterfaceID_v8	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x22, 0xA2, 0x58, 0xBB, 0xA8, 0x59, 0x11, 0xD8, \
											0xAA, 0x56, 0x00, 0x0A, 0x95, 0x99, 0x2A, 0x78 )

//
// version 7
//
// kIOFireWireDeviceInterface_v7
//		uuid: 188517DE-10B4-11D8-B5CC-000393CFACEA
#define kIOFireWireDeviceInterfaceID_v7	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x18, 0x85, 0x17, 0xDE, 0x10, 0xB4, 0x11, 0xD8,\
											0xB5, 0xCC, 0x00, 0x03, 0x93, 0xCF, 0xAC, 0xEA )

//
// version 6 (obsolete)
//

// kIOFireWireDeviceInterface_v6
//		uuid: C2AB2F11-45E2-11D7-815C-000393470256
#define kIOFireWireDeviceInterfaceID_v6	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xC2, 0xAB, 0x2F, 0x11, 0x45, 0xE2, 0x11, 0xD7,\
											0x81, 0x5C, 0x00, 0x03, 0x93, 0x47, 0x02, 0x56 )

//
// 	version 5 interfaces (obsolete)
//
//
//	kIOFireWireNubInterface_v5
//		uuid string: D4900C5A-C69E-11D6-AEA5-0003938BEB0A
#define kIOFireWireNubInterfaceID_v5	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xD4, 0x90, 0x0C, 0x5A, 0xC6, 0x9E, 0x11, 0xD6,\
											0xAE, 0xA5, 0x00, 0x03, 0x93, 0x8B, 0xEB, 0x0A )
//	kIOFireWireUnitInterfaceID_v5
//		uuid string: 121D7347-C69F-11D6-9B31-0003938BEB0A
#define kIOFireWireUnitInterfaceID_v5	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x12, 0x1D, 0x73, 0x47, 0xC6, 0x9F, 0x11, 0xD6,\
											0x9B, 0x31, 0x00, 0x03, 0x93, 0x8B, 0xEB, 0x0A )
//	kIOFireWireDeviceInterfaceID_v5
//		uuid string: 127A12F6-C69F-11D6-9D11-0003938BEB0A
#define kIOFireWireDeviceInterfaceID_v5	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x12, 0x7A, 0x12, 0xF6, 0xC6, 0x9F, 0x11, 0xD6,\
											0x9D, 0x11, 0x00, 0x03, 0x93, 0x8B, 0xEB, 0x0A )

//
// 	version 4 interfaces (obsolete)
//
//		availability: 
//				Mac OS X 10.2 "Jaguar" and later
//
//	kIOFireWireNubInterface_v4
//		uuid string: 939151B8-6945-11D6-BEC7-0003933F84F0
#define kIOFireWireNubInterfaceID_v4	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x93, 0x91, 0x51, 0xB8, 0x69, 0x45, 0x11, 0xD6,\
											0xBE, 0xC7, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//	kIOFireWireUnitInterface_v4
//		uuid string: D1A395C9-6945-11D6-9B32-0003933F84F0
#define kIOFireWireUnitInterfaceID_v4	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xD1, 0xA3, 0x95, 0xC9, 0x69, 0x45, 0x11, 0xD6,\
											0x9B, 0x32, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//	kIOFireWireDeviceInterface_v4
//		uuid string: F4B3748B-6945-11D6-8299-0003933F84F0
#define kIOFireWireDeviceInterfaceID_v4	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xF4, 0xB3, 0x74, 0x8B, 0x69, 0x45, 0x11, 0xD6,\
											0x82, 0x99, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//
// 	version 3 interfaces  (obsolete)
//
//		availability: 
//				Mac OS X 10.2 "Jaguar" and later
//

//	kIOFireWireNubInterfaceID_v3
//		uuid string: F70FE149-E393-11D5-958A-0003933F84F0
#define kIOFireWireNubInterfaceID_v3	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xF7, 0x0F, 0xE1, 0x49, 0xE3, 0x93, 0x11, 0xD5,\
											0x95, 0x8A, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//	kIOFireWireUnitInterfaceID_v3
//		uuid string: FE7A02EB-E393-11D5-8A61-0003933F84F0
#define kIOFireWireUnitInterfaceID_v3	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xFE, 0x7A, 0x02, 0xEB, 0xE3, 0x93, 0x11, 0xD5,\
											0x8A, 0x61, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )
											
//	kIOFireWireDeviceInterfaceID_v3
//  	uuid string: 00EB71A0-E394-11D5-829A-0003933F84F0
#define kIOFireWireDeviceInterfaceID_v3	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x00, 0xEB, 0x71, 0xA0, 0xE3, 0x94, 0x11, 0xD5,\
											0x82, 0x9A, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//
// 	version 2 interfaces (obsolete)
//
//		availability: 
//				Mac OS X 10.1 and later
//

//	kIOFireWireNubInterfaceID
//		uuid string: 2575E4C4-B6C1-11D5-8F73-003065AF75CC
#define kIOFireWireNubInterfaceID		CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x25, 0x75, 0xE4, 0xC4, 0xB6, 0xC1, 0x11, 0xD5,\
											0x8F, 0x73, 0x00, 0x30, 0x65, 0xAF, 0x75, 0xCC )

//	kIOFireWireUnitInterfaceID
//		uuid string: A02CC5D4-B6C1-11D5-AEA8-003065AF75CC
#define kIOFireWireUnitInterfaceID		CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xA0, 0x2C, 0xC5, 0xD4, 0xB6, 0xC1, 0x11, 0xD5,\
											0xAE, 0xA8, 0x00, 0x30, 0x65, 0xAF, 0x75, 0xCC )

//	kIOFireWireDeviceInterfaceID_v2
//  	uuid string: B3993EB8-56E2-11D5-8BD0-003065423456
#define kIOFireWireDeviceInterfaceID_v2	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xB3, 0x99, 0x3E, 0xB8, 0x56, 0xE2, 0x11, 0xD5,\
											0x8B, 0xD0, 0x00, 0x30, 0x65, 0x42, 0x34, 0x56)

//
//	version 1 interfaces  (obsolete)
//
//		availablity: 
//				Mac OS X 10.0.0 and later
//

//	kIOFireWireDeviceInterfaceID
// 	(obsolete: do not use. may be removed in the future.)
//		uuid string: E3DF4460-F197-11D4-8AC8-000502072F80
#define kIOFireWireDeviceInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xE3, 0xDF, 0x44, 0x60, 0xF1, 0x97, 0x11, 0xD4,\
											0x8A, 0xC8, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

#pragma mark -
#pragma mark COMMAND OBJECT UUIDs
// ============================================================
// command objects
// ============================================================

// version 3 interfaces:
//
//	availability:
//		Mac OS X "Leopard" and later
//

//		uuid string : 18B932AA-697A-4C7E-8F22-80EE746773A9
#define kIOFireWireAsyncStreamCommandInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault, \
													0x18, 0xB9, 0x32, 0xAA, 0x69, 0x7A, 0x4C, 0x7E, \
													0x8F, 0x22, 0x80, 0xEE, 0x74, 0x67, 0x73, 0xA9 )


//		uuid string : F3FF3AC6-FE88-47A0-ACB7-509009808128
#define kIOFireWirePHYCommandInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xF3, 0xFF, 0x3A, 0xC6, 0xFE, 0x88, 0x47, 0xA0, \
											0xAC, 0xB7, 0x50, 0x90, 0x09, 0x80, 0x81, 0x28 )

//		uuid string : FAF5529D-9F99-42CB-B0E8-67860807F551
#define kIOFireWireVectorCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xFA, 0xF5, 0x52, 0x9D, 0x9F, 0x99, 0x42, 0xCB,\
											0xB0, 0xE8, 0x67, 0x86, 0x08, 0x07, 0xF5, 51)
											
//		uuid: 12DE8E37-0BE4-4094-882F-FD0B932A3174
#define kIOFireWireIRMAllocationInterfaceID	CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0x12, 0xDE, 0x8E, 0x37, 0x0B, 0xE4, 0x40, 0x94, \
											0x88, 0x2F, 0xFD, 0x0B, 0x93, 0x2A, 0x31, 0x74 )

//	uuid string: 577B1AFE-1A48-4137-8993-71077820E0CD
#define kIOFireWireCommandInterfaceID_v3	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x57, 0x7B, 0x1A, 0xFE, 0x1A, 0x48, 0x41, 0x37,\
											0x89, 0x93, 0x71, 0x07, 0x78, 0x20, 0xE0, CD )

//  uuid string: 30FB7D2A-FF2E-4236-871B-2A473B0B7B3B
#define kIOFireWireReadCommandInterfaceID_v3 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x30, 0xFB, 0x7D, 0x2A, 0xFF, 0x2E, 0x42, 0x36,\
											0x87, 0x1B, 0x2A, 0x47, 0x3B, 0x0B, 0x7B, 0x3B )
											
//	uuid string: EF55343D-40A4-4007-BF99-DF1413251309
#define kIOFireWireWriteCommandInterfaceID_v3 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xEF, 0x55, 0x34, 0x3D, 0x40, 0xA4, 0x40, 0x07,\
											0xBF, 0x99, 0xDF, 0x14, 0x13, 0x25, 0x13, 0x09 )
											
//	uuid string: 037F5D98-F5F9-4FBF-9267-4B9BFE9642D6
#define kIOFireWireCompareSwapCommandInterfaceID_v3	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x03, 0x7F, 0x5D, 0x98, 0xF5, 0xF9, 0x4F, 0xBF,\
											0x92, 0x67, 0x4B, 0x9B, 0xFE, 0x96, 0x42, 0xD6 )											
//
//	version 2 interfaces:
//
//		availability: 
//				Mac OS X "Jaguar" and later
//

//	kIOFireWireCompareSwapCommandInterfaceID_v2
//	uuid string: 6100FEC9-6946-11D6-8A49-0003933F84F0
#define kIOFireWireCompareSwapCommandInterfaceID_v2		CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x61, 0x00, 0xFE, 0xC9, 0x69, 0x46, 0x11, 0xD6,\
											0x8A, 0x49, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//
//	version 1 interfaces  (obsolete)
//

//	uuid string: F8B6993A-F197-11D4-A3F1-000502072F80
#define kIOFireWireCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xF8, 0xB6, 0x99, 0x3A, 0xF1, 0x97, 0x11, 0xD4,\
											0xA3, 0xF1, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

//  uuid string: AB26F124-76E9-11D5-86D5-003065423456
#define kIOFireWireReadCommandInterfaceID_v2 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xAB, 0x26, 0xF1, 0x24, 0x76, 0xE9, 0x11, 0xD5,\
											0x86, 0xD5, 0x00, 0x30, 0x65, 0x42, 0x34, 0x56)

//	uuid string: 1023605C-76EA-11D5-B82A-003065423456
#define kIOFireWireWriteCommandInterfaceID_v2 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x10, 0x23, 0x60, 0x5C, 0x76, 0xEA, 0x11, 0xD5,\
											0xB8, 0x2A, 0x00, 0x30, 0x65, 0x42, 0x34, 0x56)

//	uuid string: 70C10E38-F64A-11D4-AFE7-0050E4D93B36
#define kIOFireWireCompareSwapCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x70, 0xC1, 0x0E, 0x38, 0xF6, 0x4A, 0x11, 0xD4,\
											0xAF, 0xE7, 0x00, 0x50, 0xE4, 0xD9, 0x3B, 0x36)

// obsolete: do not use. may be removed in the future.
//	uuid string: 3D72672A-F64A-11D4-9683-0050E4D93B36
#define kIOFireWireReadQuadletCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x3D, 0x72, 0x67, 0x2A, 0xF6, 0x4A, 0x11, 0xD4,\
											0x96, 0x83, 0x00, 0x50, 0xE4, 0xD9, 0x3B, 0x36)

// obsolete: do not use. may be removed in the future.
//	uuid string: 5C9423CE-F64A-11D4-AB7B-0050E4D93B36
#define kIOFireWireWriteQuadletCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x5C, 0x94, 0x23, 0xCE, 0xF6, 0x4A, 0x11, 0xD4,\
											0xAB, 0x7B, 0x00, 0x50, 0xE4, 0xD9, 0x3B, 0x3)

// obsolete: do not use. may be removed in the future.
//	uuid string: 6E32F9D4-F63A-11D4-A194-003065423456
#define kIOFireWireReadCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x6E, 0x32, 0xF9, 0xD4, 0xF6, 0x3A, 0x11, 0xD4,\
											0xA1, 0x94, 0x00, 0x30, 0x65, 0x42, 0x34, 0x56)

// obsolete: do not use. may be removed in the future.
//	uuid string: 4EDDED10-F64A-11D4-B7A5-0050E4D93B36
#define kIOFireWireWriteCommandInterfaceID	CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x4E, 0xDD, 0xED, 0x10, 0xF6, 0x4A, 0x11, 0xD4,\
											0xB7, 0xA5, 0x00, 0x50, 0xE4, 0xD9, 0x3B, 0x36)

#pragma mark -
#pragma mark ADDRESS SPACE UUIDs
// ============================================================
// address spaces
// ============================================================

//	uuid string: 0D32AC50-F198-11D4-8DB5-000502072F80
#define kIOFireWirePseudoAddressSpaceInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x0D, 0x32, 0xAC, 0x50, 0xF1, 0x98, 0x11, 0xD4,\
											0x8D, 0xB5, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

//	uuid string: 489110F6-F198-11D4-8BEB-000502072F80
#define kIOFireWirePhysicalAddressSpaceInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x48, 0x91, 0x10, 0xF6, 0xF1, 0x98, 0x11, 0xD4,\
											0x8B, 0xEB, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)


//	uuid string: 763F18CA-5E84-4612-A2BD-10011730E131
#define kIOFireWirePHYPacketListenerInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x76, 0x3F, 0x18, 0xCA, 0x5E, 0x84, 0x46, 0x12,\
											0xA2, 0xBD, 0x10, 0x01, 0x17, 0x30, 0xE1, 0x31)

#pragma mark -
#pragma mark CONFIG ROM UUIDs
// ============================================================
// config ROM
// ============================================================

//	uuid string: 69CA4D74-F198-11D4-B325-000502072F80
#define kIOFireWireLocalUnitDirectoryInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x69, 0xCA, 0x4D, 0x74, 0xF1, 0x98, 0x11, 0xD4,\
											0xB3, 0x25, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

//  uuid string: 7D43B506-F198-11D4-AA10-000502072F80
#define kIOFireWireConfigDirectoryInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x7D, 0x43, 0xB5, 0x06, 0xF1, 0x98, 0x11, 0xD4,\
											0xAA, 0x10, 0x00, 0x05, 0x02, 0x07, 0x2F, 0x80)

#pragma mark -
#pragma mark INTERFACE TYPES
// ============================================================
// IOFireWireLib interface types
// ============================================================

typedef struct 	IOFireWireDeviceInterface_t**	 			IOFireWireLibDeviceRef ;
typedef		   	IOFireWireLibDeviceRef						IOFireWireLibUnitRef ;
typedef			IOFireWireLibDeviceRef						IOFireWireLibNubRef ;
typedef struct 	IOFireWirePseudoAddressSpaceInterface_t**	IOFireWireLibPseudoAddressSpaceRef ;
typedef struct 	IOFireWirePhysicalAddressSpaceInterface_t**	IOFireWireLibPhysicalAddressSpaceRef ;
typedef struct 	IOFireWireLocalUnitDirectoryInterface_t**	IOFireWireLibLocalUnitDirectoryRef ;
typedef struct 	IOFireWireConfigDirectoryInterface_t**		IOFireWireLibConfigDirectoryRef ;

typedef struct 	IOFireWireCommandInterface_t**				IOFireWireLibCommandRef ;
typedef struct 	IOFireWireReadCommandInterface_t**			IOFireWireLibReadCommandRef ;
typedef struct 	IOFireWireReadQuadletCommandInterface_t**	IOFireWireLibReadQuadletCommandRef ;
typedef struct 	IOFireWireWriteCommandInterface_t**			IOFireWireLibWriteCommandRef ;
typedef struct 	IOFireWireWriteQuadletCommandInterface_t**	IOFireWireLibWriteQuadletCommandRef ;
typedef struct 	IOFireWireCompareSwapCommandInterface_t**	IOFireWireLibCompareSwapCommandRef ;
typedef struct	IOFireWireLibVectorCommandInterface_t**		IOFireWireLibVectorCommandRef;
typedef struct	IOFireWirePHYCommandInterface_t**			IOFireWireLibPHYCommandRef;
typedef struct	IOFireWireAsyncStreamCommandInterface_t**	IOFireWireLibAsyncStreamCommandRef;

typedef struct 	IOFireWireCompareSwapCommandInterface_v3_t**	IOFireWireLibCompareSwapCommandV3Ref ;

typedef struct  IOFireWireLibIRMAllocationInterface_t**		IOFireWireLibIRMAllocationRef ; 

// --- isoch interfaces ----------
typedef struct 	IOFireWireIsochChannelInterface_t**			IOFireWireLibIsochChannelRef ;
typedef struct 	IOFireWireIsochPortInterface_t**			IOFireWireLibIsochPortRef ;
typedef struct 	IOFireWireRemoteIsochPortInterface_t**		IOFireWireLibRemoteIsochPortRef ;
typedef struct 	IOFireWireLocalIsochPortInterface_t**		IOFireWireLibLocalIsochPortRef ;
typedef struct 	IOFireWireDCLCommandPoolInterface_t**		IOFireWireLibDCLCommandPoolRef ;
typedef struct	IOFireWireNuDCLPoolInterface_t**			IOFireWireLibNuDCLPoolRef ;
typedef struct  IOFWAsyncStreamListenerInterface_t**		IOFWAsyncStreamListenerInterfaceRef;
typedef struct  IOFireWireLibPHYPacketListenerInterface_t**	IOFireWireLibPHYPacketListenerRef;

#pragma mark -
#pragma mark CALLBACK TYPES
// ============================================================
// IOFireWireLib callback types
// ============================================================

/*!	@typedef IOFireWirePseudoAddressSpaceReadHandler
	@abstract This callback is called to handle read requests to pseudo address spaces. This function
		should fill in the specified area in the pseudo address space backing store and call
		ClientCommandIsComplete with the specified command ID
	@param addressSpace The address space to which the request is being made
	@param commandID An FWClientCommandID which should be passed to ClientCommandIsComplete when
		the buffer has been filled in
	@param packetLen number of bytes requested
	@param packetOffset number of bytes from beginning of address space backing store
	@param srcNodeID nodeID of the requester
	@param destAddressHi high 16 bits of destination address on this computer
	@param destAddressLo low 32 bits of destination address on this computer
	@param refCon user specified reference number passed in when the address space was created
*/
typedef UInt32	(*IOFireWirePseudoAddressSpaceReadHandler)(
					IOFireWireLibPseudoAddressSpaceRef	addressSpace,
					FWClientCommandID					commandID,
					UInt32								packetLen,
					UInt32								packetOffset,
					UInt16								srcNodeID,		// nodeID of requester
					UInt32								destAddressHi,	// destination on this node
					UInt32								destAddressLo,
					void *								refCon) ;

/*!	@typedef IOFireWirePseudoAddressSpaceSkippedPacketHandler
	@abstract Callback called when incoming packets have been dropped from the internal queue
	@param addressSpace The address space which dropped the packet(s)
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param skippedPacketCount The number of skipped packets
*/
typedef void	(*IOFireWirePseudoAddressSpaceSkippedPacketHandler)(
					IOFireWireLibPseudoAddressSpaceRef	addressSpace,
					FWClientCommandID					commandID,
					UInt32								skippedPacketCount) ;

/*! @typedef IOFireWirePseudoAddressSpaceWriteHandler
	@abstract Callback called to handle write requests to a pseudo address space.
	@param addressSpace The address space to which the write is being made
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param packetLen Length in bytes of incoming packet
	@param packet Pointer to the received data
	@param srcNodeID Node ID of the sender
	@param destAddressHi high 16 bits of destination address on this computer
	@param destAddressLo low 32 bits of destination address on this computer
	@param refCon user specified reference number passed in when the address space was created
*/
typedef UInt32 (*IOFireWirePseudoAddressSpaceWriteHandler)(
					IOFireWireLibPseudoAddressSpaceRef	addressSpace,
					FWClientCommandID					commandID,
					UInt32								packetLen,
					void*								packet,
					UInt16								srcNodeID,		// nodeID of sender
					UInt32								destAddressHi,	// destination on this node
					UInt32								destAddressLo,
					void *								refCon) ;

/*!	@typedef IOFireWireBusResetHandler
	@abstract Called when a bus reset has occured, but before FireWire has completed
		configuring the bus.
	@param interface A reference to the device on which the callback was installed
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
*/
typedef void 	(*IOFireWireBusResetHandler)(
					IOFireWireLibDeviceRef				interface,
					FWClientCommandID					commandID );	// parameters may change
					
/*!
	@typedef IOFireWireBusResetDoneHandler
	@abstract Called when a bus reset has occured and FireWire has completed configuring
		the bus.
	@param interface A reference to the device on which the callback was installed
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
*/
typedef void 	(*IOFireWireBusResetDoneHandler)(
					IOFireWireLibDeviceRef				interface,
					FWClientCommandID					commandID ) ;	// parameters may change

/*!	@typedef IOFireWireLibCommandCallback
	@abstract Callback called when an asynchronous command has completed executing
	@param refCon A user specified reference value set before command object was submitted
*/
typedef void	(*IOFireWireLibCommandCallback)(
					void*								refCon,
					IOReturn							completionStatus) ;

/*!	@typedef IOFireWireLibPHYPacketCallback
	@abstract Callback called to handle incoming PHY packets
	@param listener The listener which received the callback
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param data1 first quad of received PHY packet
	@param data2 second quad of received PHY packet	
	@param refCon user specified reference value specified on the listener  
*/
typedef void	(*IOFireWireLibPHYPacketCallback)(
					IOFireWireLibPHYPacketListenerRef	listener,
					FWClientCommandID					commandID,
					UInt32								data1,
					UInt32								data2,
					void *								refCon );

/*!	@typedef IOFireWireLibPHYPacketSkippedCallback
	@abstract Callback called when incoming packets have been dropped from the internal queue
	@param listener The listener which dropped the packets
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param skippedPacketCount The number of skipped packets
	@param refCon user specified reference value specified on the listener  
*/
typedef void	(*IOFireWireLibPHYPacketSkippedCallback)(
					IOFireWireLibPHYPacketListenerRef	listener,
					FWClientCommandID					commandID,
					UInt32								skippedPacketCount,
					void *								refCon );

/*!	@typedef IOFireWireLibIRMAllocationLostNotificationProc
@abstract Callback called when an IOFireWireLibIRMAllocationRef fails to reclaim IRM resources after a bus-reset
*/
typedef void	(*IOFireWireLibIRMAllocationLostNotificationProc)(IOFireWireLibIRMAllocationRef irmAllocation, void *refCon);

/*! @typedef IOFWAsyncStreamListenerHandler
	@abstract Callback called to handle Async Stream packets.
	@param listener The listener which received the callback
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param packet Pointer to the received data
	@param refCon user specified reference number passed in when async stream 
	                 interface is created   
*/
typedef UInt32 (*IOFWAsyncStreamListenerHandler)(
					IOFWAsyncStreamListenerInterfaceRef	listener,
					FWClientCommandID					commandID,
					UInt32								size,
					void*								packet,
					void*								refCon) ;


/*!	@typedef IOFWAsyncStreamListenerSkippedPacketHandler
	@abstract Callback called when incoming packets have been dropped from the internal queue
	@param listener The listener which dropped the packets
	@param commandID An FWClientCommandID to be passed to ClientCommandIsComplete()
	@param skippedPacketCount The number of skipped packets
*/
typedef void	(*IOFWAsyncStreamListenerSkippedPacketHandler)(
					IOFWAsyncStreamListenerInterfaceRef	listener,
					FWClientCommandID					commandID,
					UInt32								skippedPacketCount) ;

#pragma mark -
#pragma mark DEVICE INTERFACE
// ============================================================
// IOFireWireDeviceInterface
// ============================================================

/*!	@class
	@abstract IOFireWireDeviceInterface is your primary gateway to the functionality contained in
		IOFireWireLib.
	@discussion	
		You can use IOFireWireDeviceInterface to:<br>
	<ul>
		<li>perform synchronous read, write and lock operations</li>
		<li>perform other miscellanous bus operations, such as reset the FireWire bus. </li>
		<li>create FireWire command objects and interfaces used to perform
			synchronous/asynchronous read, write and lock operations. These include:</li>
		<ul type="square">
			<li>IOFireWireReadCommandInterface
			<li>IOFireWireReadQuadletCommandInterface
			<li>IOFireWireWriteCommandInterface
			<li>IOFireWireWriteQuadletCommandInterface
			<li>IOFireWireCompareSwapCommandInterface
		</ul>
		<li>create interfaces which provide a other extended services. These include:</li>
		<ul type="square">	
			<li>IOFireWirePseudoAddressSpaceInterface -- pseudo address space services</li>
			<li>IOFireWirePhysicalAddressSpaceInterface -- physical address space services</li>
			<li>IOFireWireLocalUnitDirectoryInterface -- manage local unit directories in the mac</li>
			<li>IOFireWireConfigDirectoryInterface -- access and browse remote device config directories</li>
		</ul>
		<li>create interfaces which provide isochronous services (see IOFireWireLibIsoch.h). These include:</li>
		<ul type="square">	
			<li>IOFireWireIsochChannelInterface -- create/manage talker and listener isoch channels</li>
			<li>IOFireWireLocalIsochPortInterface -- create local isoch ports</li>
			<li>IOFireWireRemoteIsochPortInterface -- create remote isoch ports</li>
			<li>IOFireWireDCLCommandPoolInterface -- create a DCL command pool allocator.</li>
		</ul>
	</ul>

*/
typedef struct IOFireWireDeviceInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version */
	UInt32 version;

	/*! Interface revision */
 	UInt32 revision; // version/revision
	
		// --- maintenance methods -------------
    /*!
        @function InterfaceIsInited
        @abstract Determine whether interface has been properly inited.
        @param self The device interface to use.
        @result Returns true if interface is inited and false if is it not.
    */
	Boolean				(*InterfaceIsInited)(IOFireWireLibDeviceRef self) ;

    /*!
        @function GetDevice
        @abstract Get the IOKit service to which this interface is connected.
        @param self The device interface to use.
        @result Returns an io_object_t corresponding to the device the interface is
			using
    */
	io_object_t			(*GetDevice)(IOFireWireLibDeviceRef self) ;

    /*!
        @function Open
        @abstract Open the connected device for exclusive access. When you have
			the device open using this method, all accesses by other clients of 
			this device will be denied until Close() is called.
        @param self The device interface to use.
        @result An IOReturn error code
    */
	IOReturn			(*Open)(IOFireWireLibDeviceRef self) ;

    /*!
        @function OpenWithSessionRef
        @abstract An open function which allows this interface to have access
			to the device when already opened. The service which has already opened
			the device must be able to provide an IOFireWireSessionRef.
        @param self The device interface to use
		@param sessionRef The sessionRef returned from the client who has
			the device open
        @result An IOReturn error code
    */
	IOReturn			(*OpenWithSessionRef)(IOFireWireLibDeviceRef self, IOFireWireSessionRef sessionRef) ;

    /*!
        @function Close
        @abstract Release exclusive access to the device
        @param self The device interface to use
    */
	void				(*Close)(IOFireWireLibDeviceRef self) ;
	
		// --- notification --------------------
	/*!
		@function NotificationIsOn
		@abstract Determine whether callback notifications for this interface are currently active
        @param self The device interface to use
		@result A Boolean value where true indicates notifications are active
	*/
	const Boolean		(*NotificationIsOn)(IOFireWireLibDeviceRef self) ;
	
	/*!
		@function AddCallbackDispatcherToRunLoop
		@abstract Installs the proper run loop event source to allow callbacks to function. This method
			must be called before callback notifications for this interface or any interfaces
			created using this interface can function.
        @param self The device interface to use.
		@param inRunLoop The run loop on which to install the event source
	*/
	const IOReturn 		(*AddCallbackDispatcherToRunLoop)(IOFireWireLibDeviceRef self, CFRunLoopRef inRunLoop) ;
	
	/*!
		@function RemoveCallbackDispatcherFromRunLoop
		@abstract Reverses the effects of AddCallbackDispatcherToRunLoop(). This method removes 
			the run loop event source that was added to the specified run loop preventing any 
			future callbacks from being called
        @param self The device interface to use.			
	*/
	const void			(*RemoveCallbackDispatcherFromRunLoop)(IOFireWireLibDeviceRef self) ;
	
	/*!
		@function TurnOnNotification
		@abstract Activates any callbacks specified for this device interface. Only works after 
			AddCallbackDispatcherToRunLoop has been called. See also AddIsochCallbackDispatcherToRunLoop().
        @param self The device interface to use.
		@result A Boolean value. Returns true on success.
	*/
	const Boolean 		(*TurnOnNotification)(IOFireWireLibDeviceRef self) ;

	/*!
		@function TurnOffNotification
		@abstract Deactivates and callbacks specified for this device interface. Reverses the 
			effects of TurnOnNotification()
        @param self The device interface to use.
	*/
	void				(*TurnOffNotification)(IOFireWireLibDeviceRef self) ;
	
	/*!
		@function SetBusResetHandler
		@abstract Sets the callback that should be called when a bus reset occurs. Note that this callback
			can be called multiple times before the bus reset done handler is called. (f.ex., multiple bus
			resets might occur before bus reconfiguration has completed.)
        @param self The device interface to use.
		@param handler Function pointer to the handler to install
		@result Returns an IOFireWireBusResetHandler function pointer to the previously installed
			bus reset handler. Returns 0 if none was set.
	*/
	const IOFireWireBusResetHandler	
						(*SetBusResetHandler)(IOFireWireLibDeviceRef self, IOFireWireBusResetHandler handler) ;
	
	/*!
		@function SetBusResetDoneHandler
		@abstract Sets the callback that should be called after a bus reset has occurred and reconfiguration
			of the bus has been completed. This function will only be called once per bus reset.
        @param self The device interface to use.
		@param handler Function pointer to the handler to install
		@result Returns on IOFireWireBusResetDoneHandler function pointer to the previously installed
			bus reset handler. Returns 0 if none was set.
	*/
	const IOFireWireBusResetDoneHandler	
						(*SetBusResetDoneHandler)(IOFireWireLibDeviceRef self, IOFireWireBusResetDoneHandler handler) ;
	/*!
		@function ClientCommandIsComplete
		@abstract This function must be called from callback routines once they have completed processing
			a callback. This function only applies to callbacks which take an IOFireWireLibDeviceRef (i.e. bus reset),
			parameter.
		@param commandID The command ID passed to the callback function when it was called
		@param status An IOReturn value indicating the completion status of the callback function
	*/
	void				(*ClientCommandIsComplete)(IOFireWireLibDeviceRef self, FWClientCommandID commandID, IOReturn status) ;
	
		// --- read/write/lock operations -------
	/*!
		@function Read
		@abstract Perform synchronous block read
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to read. 
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
		@param addr Command target address
		@param buf A pointer to a buffer where the results will be stored
		@param size Number of bytes to read
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in generation. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
			
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOReturn error code
	*/
	IOReturn			(*Read)(IOFireWireLibDeviceRef	self, 
								io_object_t 		device,
								const FWAddress* addr, 
								void* 				buf, 
								UInt32* 			size, 
								Boolean 			failOnReset, 
								UInt32 				generation) ;

	/*!
		@function ReadQuadlet
		@abstract Perform synchronous quadlet read
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to read. 
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
		@param addr Command target address
		@param val A pointer to where to data should be stored
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in generation. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration()
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOReturn error code
	*/
	IOReturn			(*ReadQuadlet)(	IOFireWireLibDeviceRef	self, 
										io_object_t 			device,
										const FWAddress* 		addr, 
										UInt32* 				val, 
										Boolean 				failOnReset, 
										UInt32 					generation) ;
	/*!
		@function Write
		@abstract Perform synchronous block write
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
		@param addr Command target address
		@param buf A pointer to a buffer where the results will be stored
		@param size Number of bytes to read
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOReturn error code
	*/
	IOReturn			(*Write)(	IOFireWireLibDeviceRef 	self, 
									io_object_t 			device, 
									const FWAddress* 		addr, 
									const void* 			buf, 
									UInt32* 				size,
									Boolean 				failOnReset, 
									UInt32 					generation) ;

	/*!
		@function WriteQuadlet
		@abstract Perform synchronous quadlet write
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
		@param addr Command target address
		@param val The value to write
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOReturn error code
	*/
	IOReturn (*WriteQuadlet)(IOFireWireLibDeviceRef self, io_object_t device, const FWAddress* addr, const UInt32 val, Boolean failOnReset, UInt32 generation) ;

	/*!
		@function CompareSwap
		@abstract Perform synchronous lock operation
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
		@param addr Command target address
		@param cmpVal The check/compare value
		@param newVal Value to set
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOReturn error code
	*/
	IOReturn (*CompareSwap)(IOFireWireLibDeviceRef self, io_object_t device, const FWAddress* addr, UInt32 cmpVal, UInt32 newVal, Boolean failOnReset, UInt32 generation) ;
	
	// --- FireWire command object methods ---------

	/*!
		@function CreateReadCommand
		@abstract Create a block read command object.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param buf A pointer to a buffer where the results will be stored
		@param size Number of bytes to read
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.
	*/
	IOFireWireLibCommandRef (*CreateReadCommand)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress * addr, void* buf, UInt32 size, IOFireWireLibCommandCallback callback, Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

	/*!	@function CreateReadQuadletCommand
		@abstract Create a quadlet read command object.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param quads An array of quadlets where results should be stored
		@param numQuads Number of quadlets to read
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.*/
	IOFireWireLibCommandRef (*CreateReadQuadletCommand)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress * addr, UInt32 quads[], UInt32 numQuads, IOFireWireLibCommandCallback callback, Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

	/*!	@function CreateWriteCommand
		@abstract Create a block write command object.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param buf A pointer to the buffer containing the data to be written
		@param size Number of bytes to write
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.*/
	IOFireWireLibCommandRef (*CreateWriteCommand)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress * addr, void* buf, UInt32  size, IOFireWireLibCommandCallback callback, Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

	/*!
		@function CreateWriteQuadletCommand
		@abstract Create a quadlet write command object.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param quads An array of quadlets containing quadlets to be written
		@param numQuads Number of quadlets to write
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.
	*/
	IOFireWireLibCommandRef (*CreateWriteQuadletCommand)(IOFireWireLibDeviceRef	self, io_object_t device, const FWAddress *	addr, UInt32 quads[], UInt32 numQuads, IOFireWireLibCommandCallback callback, Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

	/*!
		@function CreateCompareSwapCommand
		@abstract Create a quadlet compare/swap command object.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param cmpVal 32-bit value expected at target address
		@param newVal 32-bit value to be set at target address
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false. Must be a valid generation number when using 64-bit absolute addressing.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.	*/
	IOFireWireLibCommandRef (*CreateCompareSwapCommand)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress *  addr, UInt32      cmpVal, UInt32      newVal, IOFireWireLibCommandCallback callback, Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

		// --- other methods ---------------------------
	/*!	@function BusReset
		@abstract Cause a bus reset
		@param self The device interface to use. */	
	IOReturn (*BusReset)( IOFireWireLibDeviceRef  self) ;

	/*!	@function GetCycleTime
		@abstract Get bus cycle time.
		@param self The device interface to use.
		@param outCycleTime A pointer to a UInt32 to hold the result
		@result An IOReturn error code.	*/	
	IOReturn (*GetCycleTime)( IOFireWireLibDeviceRef  self, UInt32*  outCycleTime) ;

	/*!	@function GetGenerationAndNodeID
		@abstract (Obsolete) Get bus generation and remote device node ID.
		@discussion Obsolete -- Please use GetBusGeneration() and/or GetRemoteNodeID() in
			interface v4.
		@param self The device interface to use.
		@param outGeneration A pointer to a UInt32 to hold the generation result
		@param outNodeID A pointer to a UInt16 to hold the remote device node ID
		@result An IOReturn error code.	*/	
	IOReturn (*GetGenerationAndNodeID)( IOFireWireLibDeviceRef  self, UInt32*  outGeneration, UInt16*  outNodeID) ;

	/*!	@function GetLocalNodeID
		@abstract (Obsolete) Get local node ID.
		@discussion Obsolete -- Please use GetBusGeneration() and GetLocalNodeIDWithGeneration() in
			interface v4.
		@param self The device interface to use.
		@param outLocalNodeID A pointer to a UInt16 to hold the local device node ID
		@result An IOReturn error code.	*/	
	IOReturn (*GetLocalNodeID)( IOFireWireLibDeviceRef  self, UInt16*  outLocalNodeID) ;

	/*!	@function GetResetTime
		@abstract Get time since last bus reset.
		@param self The device interface to use.
		@param outResetTime A pointer to an AbsolutTime to hold the result.
		@result An IOReturn error code.	*/	
	IOReturn			(*GetResetTime)(
								IOFireWireLibDeviceRef 	self, 
								AbsoluteTime* 			outResetTime) ;

		// --- unit directory support ------------------
	/*!	@function CreateLocalUnitDirectory
		@abstract Creates a local unit directory object and returns an interface to it. An
			instance of a unit directory object corresponds to an instance of a unit 
			directory in the local machine's configuration ROM.
		@param self The device interface to use.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created unit directory object.
		@result An IOFireWireLibLocalUnitDirectoryRef. Returns 0 upon failure */
	 IOFireWireLibLocalUnitDirectoryRef (*CreateLocalUnitDirectory)( IOFireWireLibDeviceRef  self, REFIID  iid) ;

		// --- config directory support ----------------
	/*!	@function GetConfigDirectory
		@abstract Creates a config directory object and returns an interface to it. The
			created config directory object represents the config directory in the remote
			device or unit to which the creating device interface is attached.
		@param self The device interface to use.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created config directory object.
		@result An IOFireWireLibConfigDirectoryRef which should be released using Release().
			Returns 0 upon failure. */
	IOFireWireLibConfigDirectoryRef (*GetConfigDirectory)( IOFireWireLibDeviceRef  self, REFIID  iid) ;

	/*!	@function CreateConfigDirectoryWithIOObject
		@abstract This function can be used to create a config directory object and a
			corresponding interface from an opaque IOObject reference. Some configuration
			directory interface methods may return an io_object_t instead of an
			IOFireWireLibConfigDirectoryRef. Use this function to obtain an 
			IOFireWireLibConfigDirectoryRef from an io_object_t.
		@param self The device interface to use.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created config directory object.
		@result An IOFireWireLibConfigDirectoryRef. Returns 0 upon failure */
	IOFireWireLibConfigDirectoryRef (*CreateConfigDirectoryWithIOObject)( IOFireWireLibDeviceRef  self, io_object_t  inObject, REFIID  iid) ;

		// --- address space support -------------------
	/*!	@function CreatePseudoAddressSpace
		@abstract Creates a pseudo address space object and returns an interface to it. This
			will create a pseudo address space (software-backed) on the local machine. 
		@param self The device interface to use.
		@param inSize The size in bytes of this address space.
		@param inRefCon A user specified reference value. This will be passed to all callback functions.
		@param inQueueBufferSize The size of the queue which receives packets from the bus before they are handed to
			the client and/or put in the backing store. A larger queue can help eliminate dropped packets
			when receiving large bursts of data. When a packet is received which can not fit into the queue, 
			the packet dropped callback will be called. 
		@param inBackingStore An optional block of allocated memory representing the contents of the address space. This 
			memory block must be of size inSize.
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set
			for this address space.
			<ul>
				<li>kFWAddressSpaceNoFlags -- All flags off</li>
				<li>kFWAddressSpaceNoWriteAccess -- Write access to this address space will be disallowed. 
					Setting this flag also disables compare/swap transactions on this address space.</li>
				<li>kFWAddressSpaceNoReadAccess -- Read access access to this address space will be disallowed. 
					Setting this flag also disables compare/swap transactions on this address space.</li>
				<li>kFWAddressSpaceAutoWriteReply -- Writes will be made automatically, directly modifying the contents
					of the backing store. The user process will not be notified of writes.</li>
				<li>kFWAddressSpaceAutoReadReply -- Reads to this address space will be answered automagically
					using the contents of the backing store. The user process will not be notified of reads.</li>
				<li>kFWAddressSpaceAutoCopyOnWrite -- Writes to this address space will be made directly
					to the backing store at the same time the user process is notified of a write.</li>
			</ul>
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created pseudo address space object.
		@result An IOFireWireLibPseudoAddressSpaceRef. Returns 0 upon failure */
	IOFireWireLibPseudoAddressSpaceRef	(*CreatePseudoAddressSpace)( 
												IOFireWireLibDeviceRef  	self, 
												UInt32  					inSize, 
												void*  						inRefCon, 
												UInt32  					inQueueBufferSize, 
												void*  						inBackingStore, 
												UInt32  					inFlags, 
												REFIID  					iid) ;

	/*!	@function CreatePhysicalAddressSpace
		@abstract Creates a physical address space object and returns an interface to it. This
			will create a physical address space on the local machine. 
		@param self The device interface to use.
		@param inSize The size in bytes of this address space.
		@param inBackingStore An block of allocated memory representing the contents of the address space.
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set
			for this address space. For future use -- always pass 0.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created physical address space object.
		@result An IOFireWireLibPhysicalAddressSpaceRef. Returns 0 upon failure */
	IOFireWireLibPhysicalAddressSpaceRef (*CreatePhysicalAddressSpace)( IOFireWireLibDeviceRef  self, UInt32  inSize, void*  inBackingStore, UInt32  inFlags, REFIID  iid) ;
		
		// --- debugging -------------------------------

	/*! Description forthcoming */
	IOReturn (*FireBugMsg)( IOFireWireLibDeviceRef  self, const char*  msg) ;

	//
	// NOTE: the following methods available only in interface v2 and later
	//

		// --- eye-sock-run-U.S. -----------------------
	/*!	@function AddIsochCallbackDispatcherToRunLoop
		@abstract This function adds an event source for the isochronous callback dispatcher
			to the specified CFRunLoop. Isochronous related callbacks will not function
			before this function is called. This functions is similar to 
			AddCallbackDispatcherToRunLoop. The passed CFRunLoop can be different
			from that passed to AddCallbackDispatcherToRunLoop. 
		@param self The device interface to use.
		@param inRunLoop A CFRunLoopRef for the run loop to which the event loop source 
			should be added
		@result An IOReturn error code.	*/	
	IOReturn			(*AddIsochCallbackDispatcherToRunLoop)(
								IOFireWireLibDeviceRef 	self, 
								CFRunLoopRef 			inRunLoop) ;

	/*!	@function CreateRemoteIsochPort
		@abstract Creates a remote isochronous port object and returns an interface to it. A
			remote isochronous port object is an abstract entity used to represent a remote
			talker or listener device on an isochronous channel. 
		@param self The device interface to use.
		@param inTalking Pass true if this port represents an isochronous talker. Pass
			false if this port represents an isochronous listener.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created remote isochronous port object.
		@result An IOFireWireLibRemoteIsochPortRef. Returns 0 upon failure */
	IOFireWireLibRemoteIsochPortRef
						(*CreateRemoteIsochPort)(
								IOFireWireLibDeviceRef	self,
								Boolean					inTalking,
								REFIID					iid) ;

	/*!	@function CreateLocalIsochPort
		@abstract Creates a local isochronous port object and returns an interface to it. A
			local isochronous port object is an abstract entity used to represent a
			talking or listening endpoint in the local machine. 
		@param self The device interface to use.
		@param inTalking Pass true if this port represents an isochronous talker. Pass
			false if this port represents an isochronous listener.
		@param inDCLProgram A pointer to the first DCL command struct of the DCL program
			to be compiled and used to send or receive data on this port.
		@param inStartEvent Start event: 0 or kFWDCLCycleEvent or kFWDCLSyBitsEvent
		@param inStartState Start state bits. For kFWDCLCycleEvent specifies the cycle to start the DMA on.
            For kFWDCLSyBitsEvent specifies the packet sync field value for the first packet to receive.
		@param inStartMask Start mask bits. For kFWDCLCycleEvent specifies a mask for the start cycle:
            the DMA will start when currentCycle & inStartMask == inStartEvent & inStartMask.
            For kFWDCLSyBitsEvent specifies a mask for the sync field:
            the DMA will start when packet sync == inStartEvent & inStartMask.
		@param inDCLProgramRanges This is an optional optimization parameter which can be used
			to decrease the time the local port object spends determining which set of virtual
			ranges the passed DCL program occupies. Pass a pointer to an array of IOVirtualRange
			structs or nil to ignore this parameter.
		@param inDCLProgramRangeCount The number of virtual ranges passed to inDCLProgramRanges.
			Pass 0 for none.
		@param inBufferRanges This is an optional optimization parameter which can be used
			to decrease the time the local port object spends determining which set of virtual
			ranges the data buffers referenced by the passed DCL program occupy. Pass a pointer
			to an array of IOVirtualRange structs or nil to ignore this parameter.
		@param inBufferRangeCount The number of virtual ranges passed to inBufferRanges.
			Pass 0 for none.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created object.
		@result An IOFireWireLibLocalIsochPortRef. Returns 0 upon failure */
	IOFireWireLibLocalIsochPortRef
						(*CreateLocalIsochPort)(
								IOFireWireLibDeviceRef 	self, 
								Boolean					inTalking,
								DCLCommand*				inDCLProgram,
								UInt32					inStartEvent,
								UInt32					inStartState,
								UInt32					inStartMask,
								IOVirtualRange			inDCLProgramRanges[],	// optional optimization parameters
								UInt32					inDCLProgramRangeCount,	
								IOVirtualRange			inBufferRanges[],
								UInt32					inBufferRangeCount, 
								REFIID 					iid) ; 

	/*!	@function CreateIsochChannel
		@abstract Creates an isochronous channel object and returns an interface to it. An
			isochronous channel object is an abstract entity used to represent a
			FireWire isochronous channel. 
		@param self The device interface to use.
		@param doIrm Controls whether the channel automatically performs IRM operations. 
			Pass true if the channel should allocate its channel and bandwidth with
			the IRM. Pass false to ignore the IRM.
		@param packetSize Size of payload in bytes of packets being sent or received with this channel,
			excluding headers. This is automatically translated into a bandwidth allocation appropriate
			for the speed passed in prefSpeed.
		@param prefSpeed The preferred bus speed of this channel.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created object.
		@result An IOFireWireLibIsochChannelRef. Returns 0 upon failure */
	IOFireWireLibIsochChannelRef
						(*CreateIsochChannel)(
								IOFireWireLibDeviceRef 	self, 
								Boolean 				doIrm, 
								UInt32 					packetSize, 
								IOFWSpeed 				prefSpeed, 
								REFIID 					iid ) ;

	/*!	@function CreateDCLCommandPool
		@abstract Creates a command pool object and returns an interface to it. The command 
			pool can be used to build DCL programs.
		@param self The device interface to use.
		@param size Starting size of command pool
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created object.
		@result An IOFireWireLibDCLCommandPoolRef. Returns 0 upon failure */
	IOFireWireLibDCLCommandPoolRef
						(*CreateDCLCommandPool)(
								IOFireWireLibDeviceRef	self, 
								IOByteCount 			size, 
								REFIID 					iid ) ;

	// --- refcons ---------------------------------
	/*!	@function GetRefCon
		@abstract Get user reference value set on this interface
		@param self The device interface to use.
		@result Returns the user's reference value set on this interface. */
	void*				(*GetRefCon)(
								IOFireWireLibDeviceRef	self) ;
	/*!	@function SetRefCon
		@abstract Set user reference value on this interface
		@param self The device interface to use.
		@param refCon The reference value to set. */
	void				(*SetRefCon)(
								IOFireWireLibDeviceRef	self,
								const void*				refCon) ;

	// --- debugging -------------------------------
	// do not use this function
	/*! @function
	    @description
		Do not use this function.
	 */
	CFTypeRef			(*GetDebugProperty)(
								IOFireWireLibDeviceRef	self,
								void*					interface,
								CFStringRef				inPropertyName,
								CFTypeID*				outPropertyType) ;

	/*!	@function PrintDCLProgram
		@abstract Walk a DCL program linked list and print its contents
		@param self The device interface to use.
		@param inProgram A pointer to the first DCL of the program to print
		@param inLength Number of DCLs expected in the program. PrintDCLProgram() will
			report an error if this number does not match the number of DCLs found
			in the program. */
	void 				(*PrintDCLProgram)(
								IOFireWireLibDeviceRef	self, 
								const DCLCommand*		inProgram, 
								UInt32 					inLength) ;

	//
	// NOTE: the following methods available only in interface v3 and later
	//

	// --- v3 functions ----------
	/*!	@function CreateInitialUnitsPseudoAddressSpace
		@abstract Creates a pseudo address space in initial units space.
		@discussion Creates a pseudo address space object in initial units space and returns an interface to it. This
			will create a pseudo address space (software-backed) on the local machine.
			
			Availablilty: IOFireWireDeviceInterface_v3,  and newer
			
		@param self The device interface to use.
		@param inAddressLo The lower 32 bits of the base address of the address space to be created. The address is always
			in initial units space.
		@param inSize The size in bytes of this address space.
		@param inRefCon A user specified reference value. This will be passed to all callback functions.
		@param inQueueBufferSize The size of the queue which receives packets from the bus before they are handed to
			the client and/or put in the backing store. A larger queue can help eliminate dropped packets
			when receiving large bursts of data. When a packet is received which can not fit into the queue, 
			the packet dropped callback will be called. 
		@param inBackingStore An optional block of allocated memory representing the contents of the address space. This
			memory block must be of size inSize.
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set
			for this address space.
			<ul>
				<li>kFWAddressSpaceNoFlags -- All flags off</li>
				<li>kFWAddressSpaceNoWriteAccess -- Write access to this address space will be disallowed. 
					Setting this flag also disables compare/swap transactions on this address space.</li>
				<li>kFWAddressSpaceNoReadAccess -- Read access access to this address space will be disallowed. 
					Setting this flag also disables compare/swap transactions on this address space.</li>
				<li>kFWAddressSpaceAutoWriteReply -- Writes will be made automatically, directly modifying the contents
					of the backing store. The user process will not be notified of writes.</li>
				<li>kFWAddressSpaceAutoReadReply -- Reads to this address space will be answered automagically
					using the contents of the backing store. The user process will not be notified of reads.</li>
				<li>kFWAddressSpaceAutoCopyOnWrite -- Writes to this address space will be made directly
					to the backing store at the same time the user process is notified of a write. Clients
					will only be notified of a write if kFWAddressSpaceAutoWriteReply is not set.</li>
				<li>kFWAddressSpaceShareIfExists -- Allows creation of this address space even if another client
					already has an address space at the requested address. All clients will be notified of writes to
					covered addresses.</li>
				<li>kFWAddressSpaceExclusive -- Ensures that the allocation of this address space will fail if any portion
					of this address range is already allocated. If the allocation is successful this flag ensures that any 
					future allocations overlapping this range will fail even if allocted with kFWAddressSpaceShareIfExists.</li>
			</ul>
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created pseudo address space object.
		@result An IOFireWireLibPseudoAddressSpaceRef. Returns 0 upon failure */
	IOFireWireLibPseudoAddressSpaceRef	(*CreateInitialUnitsPseudoAddressSpace)( 
												IOFireWireLibDeviceRef  	self,
												UInt32						inAddressLo,
												UInt32  					inSize, 
												void*  						inRefCon, 
												UInt32  					inQueueBufferSize, 
												void*  						inBackingStore, 
												UInt32  					inFlags,
												REFIID  					iid) ;
	/*!
		@function AddCallbackDispatcherToRunLoopForMode
		@abstract Add a run loop event source to allow IOFireWireLib callbacks to function.
        @discussion Installs the proper run loop event source to allow callbacks to function. This method
			must be called before callback notifications for this interface or any interfaces
			created using this interface can function. With this function, you can additionally specify
			for which run loop modes this source should be added.
			
			Availability: IOFireWireDeviceInterface_v3, and newer
			
		@param self The device interface to use.
		@param inRunLoop The run loop on which to install the event source
		@param inRunLoopMode The run loop mode(s) for which to install the event source
		@result An IOReturn error code.	*/	
	IOReturn 			(*AddCallbackDispatcherToRunLoopForMode)(
								IOFireWireLibDeviceRef 	self, 
								CFRunLoopRef 			inRunLoop,
								CFStringRef				inRunLoopMode ) ;
	/*!	@function AddIsochCallbackDispatcherToRunLoop
		@abstract Add a run loop event source to allow IOFireWireLib isoch callbacks to function.
		@discussion This function adds an event source for the isochronous callback dispatcher
			to the specified CFRunLoop. Isochronous related callbacks will not be called unless
			this function has been called. This function is similar to AddCallbackDispatcherToRunLoop. 
			The passed CFRunLoop can be different from that passed to AddCallbackDispatcherToRunLoop. 

			Availability: IOFireWireDeviceInterface_v3, and newer

		@param self The device interface to use.
		@param inRunLoop A CFRunLoopRef for the run loop to which the event loop source 
			should be added
		@param inRunLoopMode The run loop mode(s) for which to install the event source
		@result An IOReturn error code.	*/	
	IOReturn			(*AddIsochCallbackDispatcherToRunLoopForMode)(
								IOFireWireLibDeviceRef 	self,
								CFRunLoopRef			inRunLoop,
								CFStringRef 			inRunLoopMode ) ;
	/*!
		@function RemoveIsochCallbackDispatcherFromRunLoop
		@abstract Removes an IOFireWireLib-added run loop event source.
		@discussion Reverses the effects of AddIsochCallbackDispatcherToRunLoop(). This method removes 
			the run loop event source that was added to the specified run loop preventing any 
			future callbacks from being called.
			
			Availability: IOFireWireDeviceInterface_v3, and newer

        @param self The device interface to use.			
	*/
	void				(*RemoveIsochCallbackDispatcherFromRunLoop)(
								IOFireWireLibDeviceRef 	self) ;

	/*!
		@function Seize
		@abstract Seize control of device/unit
		@discussion Allows a user space client to seize control of an in-kernel service even if
			that service has been Opened() by another client or in-kernel driver. This function should be
			used with care. Admin rights are required to use this function.
			
			Calling this method makes it appear to all other drivers that the device has been unplugged.
			Open() should be called after this method has been invoked.
			
			When access is complete, Close() and then IOServiceRequestProbe() should be called to restore 
			normal operation. Calling IOServiceRequestProbe() makes it appear that the device has been "re-plugged."
        @param self The device interface to use.
		@param inFlags Reserved for future use. Set to NULL.  Description forthcoming?
	*/
	IOReturn			(*Seize)(
								IOFireWireLibDeviceRef 	self,
								IOOptionBits			inFlags,
								... ) ;

	/*!
		@function FireLog
		@abstract Logs string to in-kernel debug buffer
        @param self The device interface to use.
	*/
	IOReturn			(*FireLog)(
								IOFireWireLibDeviceRef 	self,
								const char*				format,
								... ) ;

	/*!	@function GetBusCycleTime
		@abstract Get bus and cycle time.
		@param self The device interface to use.
		@param outBusTime A pointer to a UInt32 to hold the bus time
		@param outCycleTime A pointer to a UInt32 to hold the cycle time
		@result An IOReturn error code.	*/	
	IOReturn (*GetBusCycleTime)( IOFireWireLibDeviceRef  self, UInt32*  outBusTime, UInt32*  outCycleTime) ;

	//
	// v4
	//

	/*!
		@function CreateCompareSwapCommand64
		@abstract Create a quadlet compare/swap command object and initialize it with 64-bit values.
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported. Setting the callback value to nil defaults to synchronous execution.
		@param addr Command target address
		@param cmpVal 64-bit value expected at target address
		@param newVal 64-bit value to be set at target address
		@param callback Command completion callback.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration()
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false.
		@result An IOFireWireLibCommandRef interface. See IOFireWireLibCommandRef.	*/
	IOFireWireLibCommandRef (*CreateCompareSwapCommand64)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress* addr, 
																UInt64 cmpVal, UInt64 newVal, IOFireWireLibCommandCallback callback, 
																Boolean failOnReset, UInt32 generation, void* inRefCon, REFIID iid) ;

	/*!
		@function CompareSwap64
		@abstract Perform synchronous lock operation
		@param self The device interface to use.
		@param device The service (representing an attached FireWire device) to which to write.
			For 48-bit, device relative addressing, pass the service used to create the device interface. This
			can be obtained by calling GetDevice(). For 64-bit absolute addressing, pass 0. Other values are
			unsupported.
			
			If the quadlets stored at 'oldVal' match those passed to 'expectedVal', the lock operation was
			successful.
		@param addr Command target address
		@param expectedVal Pointer to quadlets expected at target.
		@param newVal Pointer to quadlets to atomically set at target if compare is successful.
		@param oldVal Pointer to quadlets to hold value found at target address after transaction if completed.
		@param size Size in bytes of compare swap transaction to perform. Value values are 4 and 8.
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration()
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false.
		@result An IOReturn error code
	*/
	IOReturn (*CompareSwap64)( IOFireWireLibDeviceRef self, io_object_t device, const FWAddress* addr, 
										UInt32* expectedVal, UInt32* newVal, UInt32* oldVal, IOByteCount size, 
										Boolean failOnReset, UInt32 generation) ;

	/*!	@function GetBusGeneration
		@abstract Get bus generation number.
		@discussion The bus generation number stays constant between bus resets and can be
			used in combination with a FireWire node ID to uniquely identify nodes on the bus.
			Pass the generation number to functions that take or return FireWire node IDs.
		
			Availability: IOFireWireDeviceInterface_v4 and newer
			
		@param self The device interface to use.
		@param outGeneration A pointer to a UInt32 to hold the bus generation  number
		@result Returns kIOReturnSuccess if a valid bus generation has been returned in 'outGeneration'.*/	
	IOReturn (*GetBusGeneration)( IOFireWireLibDeviceRef self, UInt32* outGeneration ) ;

	/*!	@function GetLocalNodeIDWithGeneration
		@abstract Get node ID of local machine.
		@discussion Use this function instead of GetLocalNodeID().
		
			Availability: IOFireWireDeviceInterface_v4 and newer
			
		@param self The device interface to use.
		@param checkGeneration A bus generation number obtained from GetBusGeneration()
		@param outLocalNodeID A pointer to a UInt16 to hold the node ID of the local machine.
		@result Returns kIOReturnSuccess if a valid nodeID has been returned in 'outLocalNodeID'. Returns
			kIOFireWireBusReset if 'checkGeneration' does not match the current bus generation number.*/
	IOReturn (*GetLocalNodeIDWithGeneration)( IOFireWireLibDeviceRef self, UInt32 checkGeneration, UInt16* outLocalNodeID ) ;

	/*!	@function GetRemoteNodeID
		@abstract Get node ID of device to which this interface is attached.
		@discussion
		
			Availability: IOFireWireDeviceInterface_v4 and newer
			
		@param self The device interface to use.
		@param checkGeneration A bus generation number obtained from GetBusGeneration()
		@param outRemoteNodeID A pointer to a UInt16 to hold the node ID of the remote device.
		@result Returns kIOReturnSuccess if a valid nodeID has been returned in 'outRemoteNodeID'. Returns
			kIOFireWireBusReset if 'checkGeneration' does not match the current bus generation number.*/
	IOReturn (*GetRemoteNodeID)( IOFireWireLibDeviceRef self, UInt32 checkGeneration, UInt16* outRemoteNodeID ) ;

	/*!	@function GetSpeedToNode
		@abstract Get maximum transfer speed to device to which this interface is attached.
		@discussion
		
			Availability: IOFireWireDeviceInterface_v4 and newer
			
		@param self The device interface to use.
		@param checkGeneration A bus generation number obtained from GetBusGeneration()
		@param outSpeed A pointer to an IOFWSpeed to hold the maximum speed to the remote device.
		@result Returns kIOReturnSuccess if a valid speed has been returned in 'outSpeed'. Returns
			kIOFireWireBusReset if 'checkGeneration' does not match the current bus generation number.*/
	IOReturn (*GetSpeedToNode)( IOFireWireLibDeviceRef self, UInt32 checkGeneration, IOFWSpeed* outSpeed) ;

	/*!	@function GetSpeedBetweenNodes
		@abstract Get the maximum transfer speed between nodes 'srcNodeID' and 'destNodeID'.
		@discussion
		
			Availability: IOFireWireDeviceInterface_v4 and newer
			
		@param self The device interface to use.
		@param checkGeneration A bus generation number obtained from GetBusGeneration()
		@param srcNodeID A FireWire node ID.
		@param destNodeID A FireWire node ID.
		@param outSpeed A pointer to an IOFWSpeed to hold the maximum transfer speed between node 'srcNodeID' and 'destNodeID'.
		@result Returns kIOReturnSuccess if a valid speed has been returned in 'outSpeed'. Returns
			kIOFireWireBusReset if 'checkGeneration' does not match the current bus generation number.*/
	IOReturn (*GetSpeedBetweenNodes)( IOFireWireLibDeviceRef self, UInt32 checkGeneration, UInt16 srcNodeID, UInt16 destNodeID,  IOFWSpeed* outSpeed) ;

	//
	// v5
	//

	/*! Description forthcoming */
	IOReturn (*GetIRMNodeID)( IOFireWireLibDeviceRef self, UInt32 checkGeneration, UInt16* outIRMNodeID ) ;
	
	//
	// v6
	//
	
	/*! Description forthcoming */
	IOReturn (*ClipMaxRec2K)( IOFireWireLibDeviceRef self, Boolean clipMaxRec ) ;

	/*! Description forthcoming */
	IOFireWireLibNuDCLPoolRef				(*CreateNuDCLPool)( IOFireWireLibDeviceRef self, UInt32 capacity, REFIID iid ) ;

	//
	// v7
	//
	
	/*! Description forthcoming */
	IOFireWireSessionRef		(*GetSessionRef)( IOFireWireLibDeviceRef self ) ;
	
	//
	// v8
	//
	
	/*!	@function CreateLocalIsochPortWithOptions
		@abstract Create a local isoch port
		@discussion
		
			Same as CreateLocalIsochPort(), above, but allows additional options to be passed.
			Availability: IOFireWireDeviceInterface_v8 and newer
			
		@param options Currently supported options are 'kFWIsochPortUseSeparateKernelThread'. If this
			option is used, a separate kernel thread will be created to handle interrupt
			processing for this port only.
			Pass 'kFWIsochPortDefaultOptions' for no options.
		@result Returns kIOReturnSuccess if a valid speed has been returned in 'outSpeed'. Returns
			kIOFireWireBusReset if 'checkGeneration' does not match the current bus generation number.*/	
	
	IOFireWireLibLocalIsochPortRef (*CreateLocalIsochPortWithOptions)( 
			IOFireWireLibDeviceRef  self, 
			Boolean					inTalking,
			DCLCommand *			dclProgram,
			UInt32					startEvent,
			UInt32					startState,
			UInt32					startMask,
			IOVirtualRange			dclProgramRanges[],	// optional optimization parameters
			UInt32					dclProgramRangeCount,	
			IOVirtualRange			bufferRanges[],
			UInt32					bufferRangeCount,
			IOFWIsochPortOptions	options,
			REFIID 					iid) ; 

	//
	// v9
	//
	
	/*!	@function CreateVectorCommand
		@abstract Create a vector command object.
		@param self The device interface to use.
		@param callback Command completion callback. Setting the callback value to nil defaults to synchronous execution.
		@param inRefCon Reference constant for 3rd party use.
		@result An IOFireWireLibVectorCommandRef interface*/
		IOFireWireLibVectorCommandRef (*CreateVectorCommand)( IOFireWireLibDeviceRef self, IOFireWireLibCommandCallback callback, void* inRefCon, REFIID iid) ;

		/*!	@function AllocateIRMBandwidthInGeneration
			@abstract Attempt to allocate some isochronous bandwidth from the IRM
			@discussion
			
			Attempts to allocates some isochronous bandwidth from the IRM, if the generation matches the current generation.
			Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param bandwidthUnits The number of bandwidth units to allocate
			
			@param generation The bus generation that this allocation attempt is to take place in.
			
			@result Returns kIOReturnSuccess if bandwidth allocation was successful. Returns kIOFireWireBusReset if 
			'generation' does not match the current bus generation number. Returns kIOReturnError for any other
			error (such as the allocation failed) */	
		IOReturn (*AllocateIRMBandwidthInGeneration)(IOFireWireLibDeviceRef self, UInt32 bandwidthUnits, UInt32 generation) ;
		
		/*!	@function ReleaseIRMBandwidthInGeneration
			@abstract Attempt to release some isochronous bandwidth from the IRM
			@discussion
			
			Attempts to release some isochronous bandwidth from the IRM, if the generation matches the current generation.
				Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param bandwidthUnits The number of bandwidth units to release
			
			@param generation The bus generation that this release attempt is to take place in.
			
			@result Returns kIOReturnSuccess if bandwidth release was successful. Returns kIOFireWireBusReset if 
			'generation' does not match the current bus generation number. Returns kIOReturnError for any other
			error (such as the allocation failed) */	
		IOReturn (*ReleaseIRMBandwidthInGeneration)(IOFireWireLibDeviceRef self, UInt32 bandwidthUnits, UInt32 generation) ;
		
		/*!	@function AllocateIRMChannelInGeneration
			@abstract Attempt to allocate an isochronous channel from the IRM
			@discussion
			
			Attempts to allocates an isochronous channel from the IRM, if the generation matches the current generation.
			Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param isochChannel The isochronous channel to allocate
			
			@param generation The bus generation that this allocation attempt is to take place in.
			
			@result Returns kIOReturnSuccess if channel allocation was successful. Returns kIOFireWireBusReset if 
			'generation' does not match the current bus generation number. Returns kIOReturnError for any other
			error (such as the allocation failed) */	
		IOReturn (*AllocateIRMChannelInGeneration)(IOFireWireLibDeviceRef self, UInt8 isochChannel, UInt32 generation) ;
		
		/*!	@function ReleaseIRMChannelInGeneration
			@abstract Attempt to release an isochronous channel from the IRM
			@discussion
			
			Attempts to release an isochronous channel from the IRM, if the generation matches the current generation.
			Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param isochChannel The isochronous channel to release
			
			@param generation The bus generation that this release attempt is to take place in.
			
			@result Returns kIOReturnSuccess if channel relase was successful. Returns kIOFireWireBusReset if 
			'generation' does not match the current bus generation number. Returns kIOReturnError for any other
			error (such as the allocation failed) */	
		IOReturn (*ReleaseIRMChannelInGeneration)(IOFireWireLibDeviceRef self, UInt8 isochChannel, UInt32 generation) ;
		
		/*!	@function CreateIRMAllocation
			@abstract Attempt to create an IRM allocation that persists accross bus-resets.
			@discussion
			
			Create an IOFireWireIRMAllocation object, which can be used to allocate IRM resources, and will reallocate automatically after bus-resets (if possible).
			
			Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param releaseIRMResourcesOnFree Specify whether or not the IRM resources shall be released when the IOFireWireLibIRMAllocation is destroyed. Can be overrided later.
			
			@param callback The handler to notify clients of failure to reclaim IRM resources after bus-reset.
			
			@param pLostNotificationProcRefCon The refCon passed with the callback.
			
			@result Returns a pointer to the newly created IRM allocation object, if successful, NULL otherwise.
			*/	
		IOFireWireLibIRMAllocationRef (*CreateIRMAllocation)( IOFireWireLibDeviceRef	self, 
															  Boolean					releaseIRMResourcesOnFree, 
															  IOFireWireLibIRMAllocationLostNotificationProc callback,
															  void						*pLostNotificationProcRefCon,
															  REFIID					iid) ; 

	/*!	@function CreateAsyncStreamListener
		@abstract Creates a async stream listener object and returns an interface to it.
		@param self		The device interface to use.
		@param channel	The channel to allocate.
		@param inRefCon A user specified reference value. This will be passed to all callback functions.
		@param inQueueBufferSize The size of the queue which receives packets from the bus before they are handed to
			the client. A larger queue can help eliminate dropped packets
			when receiving large bursts of data. When a packet is received which can not fit into the queue, 
			the packet dropped callback will be called. 
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created ayns stream listener object.
		@result An IOFWAsyncStreamListenerInterfaceRef. Returns 0 upon failure */
		IOFWAsyncStreamListenerInterfaceRef	(*CreateAsyncStreamListener)(  IOFireWireLibDeviceRef			self, 
																			UInt32							channel,
																			IOFWAsyncStreamListenerHandler	callback,																			
																			void*							inRefCon, 
																			UInt32							inQueueBufferSize, 
																			REFIID							iid) ;


		/*!	@function GetIsochAsyncPort
			@abstract Returns the notification port used for async and isoch callbacks
			@discussion
			
			If necessary GetIsochAsyncPort will allocate the port. 
			
			Availability: IOFireWireDeviceInterface_v9 and newer
			
			@param self		The device interface to use.
			@result Returns the mach_port used for notifications */	

		mach_port_t (*GetIsochAsyncPort)( IOFireWireLibDeviceRef self ); 
															  
	/*!
		@function CreatePHYCommand
		@abstract Create a command object for sending a PHY packet
		@param self The device interface to use.
		@param data1 phy packet quadlet 1
		@param data2 phy packet quadlet 1
		@param callback completion callback
		@param failOnReset Pass true if the command should only be executed during the FireWire bus generation
			specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
			obtained by calling GetBusGeneration()
		@param generation The FireWire bus generation during which the command should be executed. Ignored
			if failOnReset is false.
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created phy command object.
		@result An IOReturn error code
	*/
		
		IOFireWireLibCommandRef		(*CreatePHYCommand)( IOFireWireLibDeviceRef			self,
														UInt32							data1,
														UInt32							data2,
														IOFireWireLibCommandCallback	callback,
														Boolean							failOnReset, 
														UInt32							generation,
														void*							inRefCon, 
														REFIID							iid );
														
	/*!
		@function CreatePHYPacketListener
		@abstract Create a listener object for receiving PHY packets
		@param self The device interface to use.
		@param queueCount The maximum queue size to use to buffer phy packets between kernel and user space
		@param iid An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
			type of interface to be returned for the created phy packet listener object.
		@result An IOReturn error code
	*/
		
		IOFireWireLibPHYPacketListenerRef	(*CreatePHYPacketListener)( IOFireWireLibDeviceRef			self,
																		UInt32							queueCount,
																		REFIID							iid );														
																		

		/*!
			@function CreateAsyncStreamCommand
			@abstract Create a command object for sending Async Stream packets
			@param self			The device interface to use.
			@param channel		The channel number to use.
			@param buf			A pointer to the buffer containing the data to be written
			@param size			Number of bytes to write
			@param callback		Command completion callback.
			@param failOnReset	Pass true if the command should only be executed during the FireWire bus generation
								specified in 'generation'. Pass false to ignore the generation parameter. The generation can be
								obtained by calling GetBusGeneration(). Must be 'true' when using 64-bit addressing.
			@param inRefCon		A user specified reference value. This will be passed to all callback functions.
			@param iid			An ID number, of type CFUUIDBytes (see CFUUID.h), identifying the
								type of interface to be returned for the created phy packet listener object.
			@result An IOReturn error code
		*/
		IOFireWireLibCommandRef	(*CreateAsyncStreamCommand)(IOFireWireLibDeviceRef				self, 
																UInt32							channel,
																UInt32							sync,
																UInt32							tag,
																void*							buf, 
																UInt32							size,
																IOFireWireLibCommandCallback	callback, 
																Boolean							failOnReset,
																UInt32							generation,
																void*							inRefCon,
																REFIID							iid);
	
		/*!	@function GetCycleTimeAndUpTime
			@abstract Get bus cycle time and cpu uptime.
			@param self The device interface to use.
			@param outCycleTime A pointer to a UInt32 to hold the result
			@param outUpTime A pointer to a UInt64 to hold the result
			@result An IOReturn error code.	*/	
		IOReturn (*GetCycleTimeAndUpTime)( IOFireWireLibDeviceRef  self, UInt32*  outCycleTime, UInt64*  outUpTime) ;
					
} IOFireWireDeviceInterface, IOFireWireUnitInterface, IOFireWireNubInterface ;
#endif // ifdef KERNEL

#pragma mark -
#pragma mark PSEUDO ADDRESS SPACE
// ============================================================
// IOFireWirePseudoAddressSpaceInterface
// ============================================================

// creation flags
/*! FireWire address space creation flags */
typedef enum
{
	kFWAddressSpaceNoFlags			= 0,
	kFWAddressSpaceNoWriteAccess 	= (1 << 0) ,
	kFWAddressSpaceNoReadAccess 	= (1 << 1) ,
	kFWAddressSpaceAutoWriteReply	= (1 << 2) ,
	kFWAddressSpaceAutoReadReply	= (1 << 3) ,
	kFWAddressSpaceAutoCopyOnWrite	= (1 << 4) ,
	kFWAddressSpaceShareIfExists	= (1 << 5) ,
	kFWAddressSpaceExclusive		= (1 << 6)
} FWAddressSpaceFlags ;

#ifndef KERNEL
/*!	@class
	@discussion Represents and provides management functions for a pseudo address 
		space (software-backed) in the local machine.

		Pseudo address space objects can be created using IOFireWireDeviceInterface.*/
typedef struct IOFireWirePseudoAddressSpaceInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version */
	UInt32 version;

	/*! Interface revision */
	UInt32 revision;

	/*!	@function SetWriteHandler
		@abstract Set the callback that should be called to handle write accesses to
			the corresponding address space
		@param self The address space interface to use.
		@param inWriter The callback to set.
		@result Returns the callback that was previously set or nil for none.*/
	const IOFireWirePseudoAddressSpaceWriteHandler (*SetWriteHandler)( IOFireWireLibPseudoAddressSpaceRef self, IOFireWirePseudoAddressSpaceWriteHandler inWriter) ;

	/*!	@function SetReadHandler
		@abstract Set the callback that should be called to handle read accesses to
			the corresponding address space
		@param self The address space interface to use.
		@param inReader The callback to set.
		@result Returns the callback that was previously set or nil for none.*/
	const IOFireWirePseudoAddressSpaceReadHandler (*SetReadHandler)( IOFireWireLibPseudoAddressSpaceRef self, IOFireWirePseudoAddressSpaceReadHandler inReader) ;

	/*!	@function SetSkippedPacketHandler
		@abstract Set the callback that should be called when incoming packets are
			dropped by the address space.
		@param self The address space interface to use.
		@param inHandler The callback to set.
		@result Returns the callback that was previously set or nil for none.*/
	const IOFireWirePseudoAddressSpaceSkippedPacketHandler (*SetSkippedPacketHandler)( IOFireWireLibPseudoAddressSpaceRef self, IOFireWirePseudoAddressSpaceSkippedPacketHandler inHandler) ;

	/*!	@function NotificationIsOn
		@abstract Is notification on?
		@param self The address space interface to use.
		@result Returns true if packet notifications for this address space are active */
	Boolean (*NotificationIsOn)(IOFireWireLibPseudoAddressSpaceRef self) ;

	/*!	@function TurnOnNotification
		@abstract Try to turn on packet notifications for this address space.
		@param self The address space interface to use.
		@result Returns true upon success */
	Boolean (*TurnOnNotification)(IOFireWireLibPseudoAddressSpaceRef self) ;

	/*!	@function TurnOffNotification
		@abstract Force packet notification off.
		@param self The pseudo address interface to use. */
	void (*TurnOffNotification)(IOFireWireLibPseudoAddressSpaceRef self) ;	

	/*!	@function ClientCommandIsComplete
		@abstract Notify the address space that a packet notification handler has completed.
		@discussion Packet notifications are received one at a time, in order. This function
			must be called after a packet handler has completed its work.
		@param self The address space interface to use.
		@param commandID The ID of the packet notification being completed. This is the same
			ID that was passed when a packet notification handler is called.
		@param status The completion status of the packet handler */
	void		(*ClientCommandIsComplete)(IOFireWireLibPseudoAddressSpaceRef self, FWClientCommandID commandID, IOReturn status) ;

		// --- accessors ----------
	/*!	@function GetFWAddress
		@abstract Get the FireWire address of this address space
		@param self The pseudo address interface to use. */
	void (*GetFWAddress)(IOFireWireLibPseudoAddressSpaceRef self, FWAddress* outAddr) ;

	/*!	@function GetBuffer
		@abstract Get a pointer to the backing store for this address space
		@param self The address space interface to use.
		@result A pointer to the backing store of this pseudo address space. Returns
			nil if none. */
	void* (*GetBuffer)(IOFireWireLibPseudoAddressSpaceRef self) ;

	/*!	@function GetBufferSize
		@abstract Get the size in bytes of this address space.
		@param self The address space interface to use.
		@result Size of the pseudo address space in bytes. Returns 0 for none.*/
	const UInt32 (*GetBufferSize)(IOFireWireLibPseudoAddressSpaceRef self) ;

	/*!	@function GetRefCon
		@abstract Returns the user refCon value for this address space.
		@param self The address space interface to use.
		@result Size of the pseudo address space in bytes. Returns 0 for none.*/
	void* (*GetRefCon)(IOFireWireLibPseudoAddressSpaceRef self) ;


} IOFireWirePseudoAddressSpaceInterface ;

#pragma mark -
#pragma mark IRM ALLOCATION
// ============================================================
// IOFireWireLibIRMAllocationInterface
// ============================================================
/*!	@class
		Description forthcoming 
 */
typedef struct IOFireWireLibIRMAllocationInterface_t
{
	IUNKNOWN_C_GUTS ;
	UInt32 version, revision ;

	/*!	@function setReleaseIRMResourcesOnFree
	 @abstract Set a new value for releaseIRMResourcesOnFree
	 @param self The IRMAllocation interface to use.
	 @param doRelease The new value for releaseIRMResourcesOnFree. */
	const void (*setReleaseIRMResourcesOnFree)( IOFireWireLibIRMAllocationRef self, Boolean doRelease) ;
	
	/*!	@function allocateIsochResources
	 @abstract Use this interface to allocate isochronous resources
	 @param self The IRMAllocation interface to use.
	 @param isochChannel The isoch channel to allocate.
	 @param bandwidthUnits The bandwidth units to allocate.
	 @result Returns true if allocation success */
	IOReturn (*allocateIsochResources)(IOFireWireLibIRMAllocationRef self, UInt8 isochChannel, UInt32 bandwidthUnits);
	
	/*!	@function deallocateIsochResources
	 @abstract Deallocate previously allocated resources
	 @param self The IRMAllocation interface to use.
	 @result Returns true if deallocation success */
	IOReturn (*deallocateIsochResources)(IOFireWireLibIRMAllocationRef self);

	/*!	@function areIsochResourcesAllocated
	 @abstract Poll to see if IRM resources are still allocated
	 @param self The IRMAllocation interface to use.
	 @param pAllocatedIsochChannel If allocated, the channel
	 @param pAllocatedBandwidthUnits If allocated, the amount of bandwidth
	 @result Returns true if currently allocated, false otherwise */
	Boolean (*areIsochResourcesAllocated)(IOFireWireLibIRMAllocationRef self, UInt8 *pAllocatedIsochChannel, UInt32 *pAllocatedBandwidthUnits);
	
	/*!	@function NotificationIsOn
	 @abstract Is notification on?
	 @param self The IRMAllocation interface to use.
	 @result Returns true if notifications for this IRMAllocation are enabled */
	Boolean (*NotificationIsOn)(IOFireWireLibIRMAllocationRef self) ;
	
	/*!	@function TurnOnNotification
	 @abstract Try to turn on notifications
	 @param self The IRMAllocation interface to use.
	 @result Returns true upon success */
	Boolean (*TurnOnNotification)(IOFireWireLibIRMAllocationRef self) ;
	
	/*!	@function TurnOffNotification
	 @abstract Force notification off.
	 @param self The IRMAllocation interface to use. */
	void (*TurnOffNotification)(IOFireWireLibIRMAllocationRef self) ;
	
	/*!	@function SetRefCon
	 @abstract Set a new refcon
	 @param self The IRMAllocation interface to use.
	 @param refCon The new refcon value. */
	void (*SetRefCon)(IOFireWireLibIRMAllocationRef self, void* refCon) ;

	/*!	@function GetRefCon
	 @abstract Get the current refcon
	 @param self The IRMAllocation interface to use.
	 @result Returns the current refcon value */
	void* (*GetRefCon)(IOFireWireLibIRMAllocationRef self) ;
}IOFireWireLibIRMAllocationInterface;

#pragma mark -
#pragma mark LOCAL UNIT DIRECTORY INTERFACE
// ============================================================
//
// IOFireWireLocalUnitDirectoryInterface
//
// ============================================================

/*!	@class
	@discussion Allows creation and management of unit directories in the config
		ROM of the local machine. After the unit directory has been built, 
		Publish() should be called to cause it to appear in the config ROM.
		Unpublish() has the reverse effect as Publish().

		This interface can be created using IOFireWireDeviceInterface::CreateLocalUnitDirectory. */
typedef struct IOFireWireLocalUnitDirectoryInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version */
	UInt32 version;

	/*! Interface revision */
	UInt32 revision ;

	// --- adding to ROM -------------------
	/*!	@function AddEntry_Ptr
		@abstract Append a data leaf
		@discussion Appends a leaf data node to a unit directory
		@param self The local unit directory interface to use.
		@param key The config ROM key for the data to be added.
		@param inBuffer A pointer to the data to be placed in the added leaf.
		@param inLen Length of the data being added.
		@param inDesc Reserved; set to NULL.  */
	IOReturn			(*AddEntry_Ptr)(IOFireWireLibLocalUnitDirectoryRef self, int key, void* inBuffer, size_t inLen, CFStringRef inDesc) ;

	/*!	@function AddEntry_UInt32
		@abstract Append an immediate leaf
		@discussion Appends an immediate leaf to a unit directory. Note that only the lower 3 bytes
			of the passed in value can appear in the unit directory.
		@param self The local unit directory interface to use.
		@param key The config ROM key for the data to be added.
		@param value The value to be added.
		@param inDesc Reserved; set to NULL.  */
	IOReturn			(*AddEntry_UInt32)(IOFireWireLibLocalUnitDirectoryRef self, int key, UInt32 value, CFStringRef inDesc) ;

	/*!	@function AddEntry_FWAddress
		@abstract Append an offset leaf
		@discussion Appends an offset leaf to a unit directory. The address passed in value should be an
			address in initial unit space of the local config ROM.
		@param self The local unit directory interface to use.
		@param key The config ROM key for the data to be added.
		@param value A pointer to a FireWire address.
		@param inDesc Reserved; set to NULL.  */
	IOReturn			(*AddEntry_FWAddress)(IOFireWireLibLocalUnitDirectoryRef self, int key, const FWAddress* value, CFStringRef inDesc) ;

	// Use this function to cause your unit directory to appear in the Mac's config ROM.
	/*!	@function Publish
		@abstract Causes a constructed or updated unit directory to appear in the local machine's
			config ROM. Note that this call will cause a bus reset, after which the unit directory will
			be visible to devices on the bus.
		@param self The local unit directory interface to use. */
	IOReturn			(*Publish)(IOFireWireLibLocalUnitDirectoryRef self) ;

	/*!	@function Unpublish
		@abstract Has the opposite effect from Publish(). This call removes a unit directory from the 
			local machine's config ROM. Note that this call will cause a bus reset, after which the unit directory will
			no longer appear to devices on the bus.
		@param self The local unit directory interface to use. */
	IOReturn			(*Unpublish)(IOFireWireLibLocalUnitDirectoryRef self) ;
} IOFireWireLocalUnitDirectoryInterface ;

#pragma mark -
#pragma mark PHYSICAL ADDRESS SPACE INTERFACE
// ============================================================
//
// IOFireWireLibPhysicalAddressSpaceInterface
//
// ============================================================

/*!	@class
	@abstract IOFireWireLib physical address space object. ( interface name: IOFireWirePhysicalAddressSpaceInterface )
	@discussion Represents and provides management functions for a physical address 
		space (hardware-backed) in the local machine.<br>
		Physical address space objects can be created using IOFireWireDeviceInterface.*/
typedef struct IOFireWirePhysicalAddressSpaceInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision ;
	/*!	@function GetPhysicalSegments
		@abstract Returns the list of physical memory ranges this address space occupies
			on the local machine.
		@param self The address space interface to use.
		@param ioSegmentCount Pass in a pointer to the number of list entries in 
			outSegments and outAddress. Upon completion, this will contain the actual
			number of segments returned in outSegments and outAddress
		@param outSegments A pointer to an array to hold the function results. Upon
			completion, this will contain the lengths of the physical segments this
			address space occupies on the local machine
		@param outAddresses A pointer to an array to hold the function results. Upon
			completion, this will contain the addresses of the physical segments this
			address space occupies on the local machine. If NULL, ioSegmentCount
			will contain the number of physical segments in the address space.*/
			
	void				(*GetPhysicalSegments)(
								IOFireWireLibPhysicalAddressSpaceRef self,
								UInt32*				ioSegmentCount,
								IOByteCount			outSegments[],
								IOPhysicalAddress	outAddresses[]) ;						
	/*!	@function GetPhysicalSegment
		@abstract Returns the physical segment containing the address at a specified offset
			from the beginning of this address space
		@param self The address space interface to use.
		@param offset Offset from beginning of address space
		@param length Pointer to a value which upon completion will contain the length of
			the segment returned by the function.
		@result The address of the physical segment containing the address at the specified
			offset of the address space	*/
	IOPhysicalAddress	(*GetPhysicalSegment)(
								IOFireWireLibPhysicalAddressSpaceRef self,
								IOByteCount 		offset,
								IOByteCount*		length) ;

	/*!	@function GetPhysicalAddress
		@abstract Returns the physical address of the beginning of this address space
		@param self The address space interface to use.
		@result The physical address of the start of this address space	*/
	IOPhysicalAddress	(*GetPhysicalAddress)(
								IOFireWireLibPhysicalAddressSpaceRef self) ;

		// --- accessors ----------
	/*!	@function GetFWAddress
		@abstract Get the FireWire address of this address space
		@param self The address space interface to use.	*/
	void				(*GetFWAddress)(
								IOFireWireLibPhysicalAddressSpaceRef self, 
								FWAddress* outAddr) ;

	/*!	@function GetBuffer
		@abstract Get a pointer to the backing store for this address space
		@param self The address space interface to use.
		@result A pointer to the backing store of this address space.*/
	void*				(*GetBuffer)(
								IOFireWireLibPhysicalAddressSpaceRef self) ;

	/*!	@function GetBufferSize
		@abstract Get the size in bytes of this address space.
		@param self The address space interface to use.
		@result Size of the pseudo address space in bytes.	*/
	const UInt32		(*GetBufferSize)(
								IOFireWireLibPhysicalAddressSpaceRef self) ;

} IOFireWirePhysicalAddressSpaceInterface ;
#endif // ifndef KERNEL

#pragma mark -
#pragma mark COMMAND OBJECT INTERFACES
// =================================================================
// command objects
// =================================================================

#define kFireWireCommandUserFlagsMask (0x0000FFFF)

// 8 quadlets
#define kFWUserCommandSubmitWithCopyMaxBufferBytes	32

//
// Flags to be set on IOFireWireLib command objects
// Passed to SetFlags()
//
/*! @enum IOFireWireLib Command Flags
    @abstract Flags for IOFireWireLib command objects
    @discussion
	Pass these flags to the object's SetFlags callback.
 */
enum
{
	kFWCommandNoFlags						= 0,
	kFWCommandInterfaceForceNoCopy			= (1 << 0),
	kFWCommandInterfaceForceCopyAlways		= (1 << 1),
	kFWCommandInterfaceSyncExecute			= (1 << 2),
	kFWCommandInterfaceAbsolute				= (1 << 3),
	kFWVectorCommandInterfaceOrdered		= (1 << 4),
	kFWCommandInterfaceForceBlockRequest	= (1 << 5)
} ;

/*! @enum IOFireWireLib failOnReset Flags
    @abstract Flags for IOFireWireLib commands
    @discussion
	Pass these flags in the failOnReset of various commands.
 */
enum
{
	kFWDontFailOnReset = false,
	kFWFailOnReset = true
} ;

/*! @enum IOFireWireLib Additional Command Flags
    @abstract Flags for IOFireWireLib commands
    @discussion
	Pass these flags to the object's SetFlags callback.
 */
enum {
	kFireWireCommandUseCopy				= (1 << 16),
	kFireWireCommandAbsolute			= (1 << 17)
} ;

#ifndef KERNEL
//
// IOFIREWIRELIBCOMMAND_C_GUTS
// Macro used to insert generic superclass function definitions into all subclass of
// IOFireWireCommand. Comments for functions contained in this macro follow below:
//
/*! @parseOnly */
#define IOFIREWIRELIBCOMMAND_C_GUTS \
	/*!	@function GetStatus \
		@abstract Return command completion status. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
					 \
		@param self The command object interface of interest \
		@result An IOReturn error code indicating the completion error (if any) returned the last \
			time this command object was executed	*/ \
	IOReturn			(*GetStatus)(IOFireWireLibCommandRef	self) ;	\
	/*!	@function GetTransferredBytes \
		@abstract Return number of bytes transferred by this command object when it last completed \
			execution. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@result A UInt32 containing the bytes transferred value	*/ \
	UInt32				(*GetTransferredBytes)(IOFireWireLibCommandRef self) ; \
	/*!	@function GetTargetAddress \
		@abstract Get command target address. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param outAddr A pointer to an FWAddress to contain the function result. */ \
	void				(*GetTargetAddress)(IOFireWireLibCommandRef self, FWAddress* outAddr) ; \
	/*!	@function SetTarget \
		@abstract Set command target address \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param addr A pointer to an FWAddress. */ \
	void				(*SetTarget)(IOFireWireLibCommandRef self, const FWAddress* addr) ;	\
	/*!	@function SetGeneration \
		@abstract Set FireWire bus generation for which the command object shall be valid. \
			If the failOnReset attribute has been set, the command will only be considered for \
			execution during the bus generation specified by this function. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param generation A bus generation. The current bus generation can be obtained \
			from IOFireWireDeviceInterface::GetBusGeneration().	*/ \
	void				(*SetGeneration)(IOFireWireLibCommandRef self, UInt32 generation) ;	\
	/*!	@function SetCallback \
		@abstract Set the completion handler to be called once the command completes \
			asynchronous execution . \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param inCallback A callback handler. Passing nil forces the command object to  \
			execute synchronously. */ \
	void				(*SetCallback)(IOFireWireLibCommandRef self, IOFireWireLibCommandCallback inCallback) ;	\
	/*!	@function SetRefCon \
		@abstract Set the user refCon value. This is the user defined value that will be passed \
			in the refCon argument to the completion function. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> */ \
	void				(*SetRefCon)(IOFireWireLibCommandRef self, void* refCon) ;	\
	/*!	@function IsExecuting \
		@abstract Is this command object currently executing? \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@result Returns true if the command object is executing.	*/ \
	const Boolean		(*IsExecuting)(IOFireWireLibCommandRef self) ;	\
	/*! Description forthcoming */ \
	IOReturn			(*Submit)(IOFireWireLibCommandRef self) ;	\
	/*!	@function Submit \
		@abstract Submit this command object to FireWire for execution. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@result An IOReturn result code indicating whether or not the command was successfully \
			submitted */ \
	/*!	@function SubmitWithRefconAndCallback \
		@abstract Set the command refCon value and callback handler, and submit the command \
			to FireWire for execution. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@result An IOReturn result code indicating whether or not the command was successfully \
			submitted	*/ \
	IOReturn			(*SubmitWithRefconAndCallback)(IOFireWireLibCommandRef self, void* refCon, IOFireWireLibCommandCallback inCallback) ;\
	/*!	@function Cancel \
		@abstract Cancel command execution \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@result An IOReturn result code	*/ \
	IOReturn			(*Cancel)(IOFireWireLibCommandRef self, IOReturn reason)

/*! @parseOnly */
#define IOFIREWIRELIBCOMMAND_C_GUTS_v2	\
	/*!	@function SetBuffer \
		@abstract Set the buffer where read data should be stored. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param size Size in bytes of the receive buffer. \
		@param buf A pointer to the receive buffer. */ \
	void 				(*SetBuffer)(IOFireWireLibCommandRef self, UInt32 size, void* buf) ;	\
	/*!	@function GetBuffer \
		@abstract Set the command refCon value and callback handler, and submit the command \
			to FireWire for execution. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest */ \
	void 				(*GetBuffer)(IOFireWireLibCommandRef self, UInt32* outSize, void** outBuf) ;	\
	/*!	@function SetMaxPacket \
		@abstract Set the maximum size in bytes of packets transferred by this command. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param maxPacketSize Size in bytes of largest packet that should be transferred \
			by this command. \
		@result An IOReturn result code indicating whether or not the command was successfully \
			submitted	*/ \
	IOReturn			(*SetMaxPacket)(IOFireWireLibCommandRef self, IOByteCount maxPacketSize) ;	\
	/*!	@function SetFlags \
		@abstract Set flags governing this command's execution. \
		@discussion Availability: (for interfaces obtained with ID) \
		<table border="0" rules="all"> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteCommandInterfaceID_v2</code></td> \
				<td>YES</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireReadQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireWriteQuadletCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireCompareSwapCommandInterfaceID</code></td> \
				<td>NO</td> \
			</tr> \
			<tr> \
				<td width="20%"></td> \
				<td><code>kIOFireWireAsyncStreamCommandInterfaceID</code></td> \
				<td>YES</td> \
			</tr> \
		</table> \
		@param self The command object interface of interest \
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set \
			for this command object. The following values may be used:<br> \
			<ul> \
				<li>kFWCommandNoFlags -- all flags off</li> \
				<li>kFWCommandInterfaceForceNoCopy -- data sent by this command should always be \
					received/sent directly from the buffer set with SetBuffer(). Whatever data \
					is in the buffer when the command is submitted will be used.</li> \
				<li>kFWCommandInterfaceForceCopyAlways -- data will always be copied out of the \
					command object data buffer when SetBuffer() is called, up to a maximum \
					allowed size (kFWUserCommandSubmitWithCopyMaxBufferBytes). This can result \
					in faster data transfer. Changes made to the data buffer contents after \
					calling SetBuffer() will be ignored; SetBuffer() should be called whenever  \
					the data buffer contents change.</li> \
				<li>kFWCommandInterfaceSyncExecute -- Setting this flag causes the command object \
					to execute synchronously. The calling context will block until the command \
					object has completed execution or an error occurs. Using synchronous execution \
					can avoid kernel transitions associated with asynchronous completion and often \
					remove the need for a state machine.</li> \
				<li>kFWCommandInterfaceForceBlockRequest -- Setting this flag causes read and write \
					transactions to use block request packets even if the payload is 4 bytes. If this \
					flag is not set 4 byte transactions will occur using quadlet transactions.</li> \
			</ul>*/ \
	void				(*SetFlags)(IOFireWireLibCommandRef self, UInt32 inFlags)

/*! @parseOnly */
#define IOFIREWIRELIBCOMMAND_C_GUTS_v3 \
	/*!	@function SetTimeoutDuration \
		@abstract Sets the duration of the timeout for this command. \
		@param self A reference to the command \
		@param duration A timeout value in microseconds \
		@result void	*/ \
	void				(*SetTimeoutDuration)(IOFireWireLibCommandRef self, UInt32 duration ); \
	/*!	@function SetMaxRetryCount \
		@abstract Sets the maximum number of retries for this command. \
		@param self A reference to the command \
		@param count The number of retires \
		@result void	*/ \
	void				(*SetMaxRetryCount)(IOFireWireLibCommandRef self, UInt32 count ); \
	/*!	@function GetAckCode \
		@abstract Gets the most recently received ack code for this transaction.  \
		@param self A reference to the command \
		@result The FireWire ack code. */ \
	UInt32				(*GetAckCode)( IOFireWireLibCommandRef self ); \
	/*!	@function GetResponseCode \
		@abstract Gets the most recently received response code for this transaction.  \
		@param self A reference to the command \
		@result The FireWire response code. */ \
	UInt32				(*GetResponseCode)( IOFireWireLibCommandRef self ); \
	/*!	@function SetMaxPacketSpeed \
		@abstract Gets the most recently received ack code for this transaction.  \
		@param self A reference to the command \
		@param speed the desired maximum packet speed \
		@result void */ \
	void				(*SetMaxPacketSpeed)( IOFireWireLibCommandRef self, IOFWSpeed speed ); \
	/*!	@function GetRefCon \
		@abstract Gets the refcon associated with this command \
		@param self A reference to the command \
		@result void */ \
	void *				(*GetRefCon)( IOFireWireLibCommandRef self )
	
/*!	@class
	@abstract IOFireWireLib command object.
	@discussion Represents an object that is configured and submitted to issue synchronous
		and asynchronous bus commands. This is a superclass containing all command object
		functionality not specific to any kind of bus transaction.
		
		Note that data may not always be transferred to or from the data buffer
		for command objects at the time the command is submitted. In some cases the
		transfer may happen as soon as SetBuffer() (below, v2 interfaces and newer) 
		is called. You can use the SetFlags() call (below, v2 interfaces and newer) to 
		control this behavior.

*/
typedef struct IOFireWireCommandInterface_t
{
	
	IUNKNOWN_C_GUTS ;

	/*! Interface version */
	UInt32 version;

	/*! Interface revision */
	UInt32 revision;
	
	/* IMPORTANT: Do not add HeaderDoc markup to the following symbols; they
	   contain HeaderDoc markup, and that would be bad.
	 */

	IOFIREWIRELIBCOMMAND_C_GUTS ;

	// version 2 interfaces: (appear in IOFireWireReadCommandInterface_v2 and IOFireWireWriteCommandInterface_v2)
	IOFIREWIRELIBCOMMAND_C_GUTS_v2 ;
	
	IOFIREWIRELIBCOMMAND_C_GUTS_v3 ;

} IOFireWireCommandInterface ;

/*!	@class
	@abstract IOFireWireLib block read command object.
	@discussion Represents an object that is configured and submitted to issue synchronous
		and asynchronous block read commands.
		
	This interface contains all methods of IOFireWireCommandInterface.
	This interface will contain all v2 methods of IOFireWireCommandInterface
		when instantiated as v2 or newer. */
typedef struct IOFireWireReadCommandInterface_t
{

	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS ;

	// following functions
	// available only in IOFireWireReadCommandInterface interface v2 and newer
	IOFIREWIRELIBCOMMAND_C_GUTS_v2 ;
	
	IOFIREWIRELIBCOMMAND_C_GUTS_v3 ;
} IOFireWireReadCommandInterface ;

/*!	@class
	@abstract IOFireWireLib block read command object.
	@discussion Represents an object that is configured and submitted to issue synchronous
		and asynchronous block read commands.
		
		This interface contains all methods of IOFireWireCommandInterface.
		This interface will contain all v2 methods of IOFireWireCommandInterface
			when instantiated as v2 or newer. */
typedef struct IOFireWireWriteCommandInterface_t
{
	
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS ;

	// following functions
	// available only in IOFireWireWriteCommandInterface_v2 and newer
	IOFIREWIRELIBCOMMAND_C_GUTS_v2 ;
	
	IOFIREWIRELIBCOMMAND_C_GUTS_v3 ;

} IOFireWireWriteCommandInterface ;


/*!	@class
	Description forthcoming 
*/
typedef struct IOFireWireCompareSwapCommandInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS ;

	/*!	@function SetValues
		@abstract Set values for 32-bit compare swap operation. Calling this function will
			make the command object perform 32-bit compare swap transactions on the bus. To perform
			64-bit compare swap operations, use the SetValues64() call, below.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param cmpVal The value expected at the address targeted by this command object
		@param newVal The value to be written at the address targeted by this command object */
	void	(*SetValues)(IOFireWireLibCompareSwapCommandRef self, UInt32 cmpVal, UInt32 newVal) ;
	
	// --- v2 ---
	
	/*!	@function SetValues64
		@abstract Set values for 64-bit compare swap operation. Calling this function will
			make the command object perform 64-bit compare swap transactions on the bus. To perform
			32-bit compare swap operations, use the SetValues() call, above.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param cmpVal The value expected at the address targeted by this command object
		@param newVal The value to be written at the address targeted by this command object */
	void	(*SetValues64)(IOFireWireLibCompareSwapCommandRef self, UInt64 cmpVal, UInt64 newVal) ;

	/*!	@function DidLock
		@abstract Was the last lock operation successful?
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@result Returns true if the last lock operation performed by this command object was successful,
			false otherwise. */
	Boolean	(*DidLock)(IOFireWireLibCompareSwapCommandRef self) ;

	/*!	@function Locked
		@abstract Get the 32-bit value returned on the last compare swap operation.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param oldValue A pointer to contain the value returned by the target of this command
			on the last compare swap operation
		@result Returns kIOReturnBadArgument if the last compare swap operation performed was 64-bit. */
	IOReturn (*Locked)(IOFireWireLibCompareSwapCommandRef self, UInt32* oldValue) ;

	/*!	@function Locked64
		@abstract Get the 64-bit value returned on the last compare swap operation.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param oldValue A pointer to contain the value returned by the target of this command
			on the last compare swap operation
		@result Returns kIOReturnBadArgument if the last compare swap performed was 32-bit. */
	IOReturn (*Locked64)(IOFireWireLibCompareSwapCommandRef self, UInt64* oldValue) ;

	/*!	@function SetFlags
		@abstract Set flags governing this command's execution.
		@discussion Available in v2 and newer. Same as SetFlags() above.
		@param self The command object interface of interest.
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set. */
	void (*SetFlags)(IOFireWireLibCompareSwapCommandRef self, UInt32 inFlags) ;
	
} IOFireWireCompareSwapCommandInterface ;

/*!	@class
	Description forthcoming 
*/
typedef struct IOFireWireCompareSwapCommandInterface_v3_t
{

	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface version. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS;

	IOFIREWIRELIBCOMMAND_C_GUTS_v2;

	IOFIREWIRELIBCOMMAND_C_GUTS_v3;

	/*!	@function SetValues
		@abstract Set values for 32-bit compare swap operation. Calling this function will
			make the command object perform 32-bit compare swap transactions on the bus. To perform
			64-bit compare swap operations, use the SetValues64() call, below.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param cmpVal The value expected at the address targeted by this command object
		@param newVal The value to be written at the address targeted by this command object */
	void	(*SetValues)(IOFireWireLibCompareSwapCommandV3Ref self, UInt32 cmpVal, UInt32 newVal) ;
	
	// --- v2 ---
	
	/*!	@function SetValues64
		@abstract Set values for 64-bit compare swap operation. Calling this function will
			make the command object perform 64-bit compare swap transactions on the bus. To perform
			32-bit compare swap operations, use the SetValues() call, above.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param cmpVal The value expected at the address targeted by this command object
		@param newVal The value to be written at the address targeted by this command object */
	void	(*SetValues64)(IOFireWireLibCompareSwapCommandV3Ref self, UInt64 cmpVal, UInt64 newVal) ;

	/*!	@function DidLock
		@abstract Was the last lock operation successful?
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@result Returns true if the last lock operation performed by this command object was successful,
			false otherwise. */
	Boolean	(*DidLock)(IOFireWireLibCompareSwapCommandV3Ref self) ;

	/*!	@function Locked
		@abstract Get the 32-bit value returned on the last compare swap operation.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param oldValue A pointer to contain the value returned by the target of this command
			on the last compare swap operation
		@result Returns kIOReturnBadArgument if the last compare swap operation performed was 64-bit. */
	IOReturn (*Locked)(IOFireWireLibCompareSwapCommandV3Ref self, UInt32* oldValue) ;

	/*!	@function Locked64
		@abstract Get the 64-bit value returned on the last compare swap operation.
		@discussion Available in v2 and newer.
		@param self The command object interface of interest
		@param oldValue A pointer to contain the value returned by the target of this command
			on the last compare swap operation
		@result Returns kIOReturnBadArgument if the last compare swap performed was 32-bit. */
	IOReturn (*Locked64)(IOFireWireLibCompareSwapCommandV3Ref self, UInt64* oldValue) ;
	
} IOFireWireCompareSwapCommandInterface_v3 ;

/*!	@class
	Description forthcoming 
*/
typedef struct IOFireWirePHYCommandInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS;

	IOFIREWIRELIBCOMMAND_C_GUTS_v2;

	IOFIREWIRELIBCOMMAND_C_GUTS_v3;

	/*!	@function SetDataQuads
		@abstract Set the 2 quadlets of data to be sent in a PHY packet.
		@discussion Available in v1 and newer.
		@param self The command object interface of interest
		@param data1 The value of the first quad of the phy packet
		@param data2 The value of the second quad of the phy packet */
	void	(*SetDataQuads)( IOFireWireLibPHYCommandRef self, UInt32 data1, UInt32 data2 );
		
} IOFireWirePHYCommandInterface;

/*!	@class
	Description forthcoming 
*/
typedef struct IOFireWireAsyncStreamCommandInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS;

	IOFIREWIRELIBCOMMAND_C_GUTS_v2;

	IOFIREWIRELIBCOMMAND_C_GUTS_v3;
	
	/*!	@function SetChannel
	@abstract Set the new channel to transmit the AsyncStream command.
	@discussion Available in v1 and newer.
	@param self The command object interface of interest
	@param channel The channel for AsyncStream command transmit.*/
	void	(*SetChannel)( IOFireWireLibAsyncStreamCommandRef self, UInt32 channel );

	/*!	@function SetSyncBits
		@abstract Set the sync bits for the AsynStream packets.
		@discussion Available in v1 and newer.
		@param self The command object interface of interest
		@param sync The value for sync bits in the AsyncStream packet */
	void	(*SetSyncBits)( IOFireWireLibAsyncStreamCommandRef self, UInt16 sync );

	/*!	@function SetTagBits
		@abstract Set the tag bits for the AsynStream packets.
		@discussion Available in v1 and newer.
		@param self The command object interface of interest
		@param tag The value for tag bits in the AsyncStream packet */
	void	(*SetTagBits)( IOFireWireLibAsyncStreamCommandRef self, UInt16 tag );
		
} IOFireWireAsyncStreamCommandInterface;

/*!	@class
	@abstract IOFireWireReadQuadletCommandInterface -- IOFireWireLib quadlet read command object.
	@discussion Obsolete; do not use. Use IOFireWireReadCommandInterface v2 or newer
		and its function SetMaxPacket() */
typedef struct IOFireWireReadQuadletCommandInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS ;

	/*!	@function SetQuads
		@abstract Set destination for read data
		@param self The command object interface of interest
		@param inQuads An array of quadlets
		@param inNumQuads Number of quadlet in 'inQuads'	*/
	void (*SetQuads)(IOFireWireLibReadQuadletCommandRef self, UInt32 inQuads[], UInt32 inNumQuads) ;
} IOFireWireReadQuadletCommandInterface ;

/*!	@class
	@abstract IOFireWireLib quadlet read command object.
	@discussion Obsolete; do not use. Use IOFireWireWriteCommandInterface v2 or newer
		and its function SetMaxPacket() */
typedef struct IOFireWireWriteQuadletCommandInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	IOFIREWIRELIBCOMMAND_C_GUTS ;

	/*! IOFireWireLibWriteQuadletCommandRef */
	void (*SetQuads)(IOFireWireLibWriteQuadletCommandRef self, UInt32 inQuads[], UInt32 inNumQuads) ;
	
} IOFireWireWriteQuadletCommandInterface ;

#pragma mark -
#pragma mark CONFIG DIRECTORY INTERFACE
// ============================================================
// IOFireWireConfigDirectoryInterface
// ============================================================


/*!	@class
	@abstract IOFireWireLib device config ROM browsing interface
	@discussion Represents an interface to the config ROM of a remote device. You can use the
		methods of this interface to browser the ROM and obtain key values. You can also
		create additional IOFireWireConfigDirectoryInterface's to represent subdirectories
		within the ROM.*/
typedef struct IOFireWireConfigDirectoryInterface_t
{

	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision ;
	
	/*!	@function Update
		@abstract Causes the ROM data to be updated through the specified byte offset. This
			function should not be called in normal usage.
		@param self The config directory interface of interest
		@param inOffset Offset in bytes indicating length of ROM to be updated.
		@result An IOReturn result code	*/
	IOReturn (*Update)							( IOFireWireLibConfigDirectoryRef self, UInt32 inOffset) ;

    /*! Description forthcoming */
    IOReturn (*GetKeyType)						( IOFireWireLibConfigDirectoryRef self, int inKey, IOConfigKeyType* outType);
    /*! Description forthcoming */
    IOReturn (*GetKeyValue_UInt32)				( IOFireWireLibConfigDirectoryRef self, int inKey, UInt32* outValue, CFStringRef* outText);
    /*! Description forthcoming */
    IOReturn (*GetKeyValue_Data)				( IOFireWireLibConfigDirectoryRef self, int inKey, CFDataRef* outValue, CFStringRef* outText);
    /*! Description forthcoming */
    IOReturn (*GetKeyValue_ConfigDirectory)		( IOFireWireLibConfigDirectoryRef self, int inKey, IOFireWireLibConfigDirectoryRef* outValue, REFIID iid, CFStringRef* outText);
    /*! Description forthcoming */
    IOReturn (*GetKeyOffset_FWAddress)			( IOFireWireLibConfigDirectoryRef self, int inKey, FWAddress* outValue, CFStringRef* text);
    /*! Description forthcoming */
    IOReturn (*GetIndexType)					( IOFireWireLibConfigDirectoryRef self, int inIndex, IOConfigKeyType* 	type);
    /*! Description forthcoming */
    IOReturn (*GetIndexKey)						( IOFireWireLibConfigDirectoryRef self, int inIndex, int * key);
    /*! Description forthcoming */
    IOReturn (*GetIndexValue_UInt32)			( IOFireWireLibConfigDirectoryRef self, int inIndex, UInt32 * value);
    /*! Description forthcoming */
    IOReturn (*GetIndexValue_Data)				( IOFireWireLibConfigDirectoryRef self, int inIndex, CFDataRef * value);
    /*! Description forthcoming */
    IOReturn (*GetIndexValue_String)			( IOFireWireLibConfigDirectoryRef self, int inIndex, CFStringRef* outValue);
    /*! Description forthcoming */
    IOReturn (*GetIndexValue_ConfigDirectory)	( IOFireWireLibConfigDirectoryRef self, int inIndex, IOFireWireLibConfigDirectoryRef* outValue, REFIID iid);
    /*! Description forthcoming */
    IOReturn (*GetIndexOffset_FWAddress)		( IOFireWireLibConfigDirectoryRef self, int inIndex, FWAddress* outValue);
    /*! Description forthcoming */
    IOReturn (*GetIndexOffset_UInt32)			( IOFireWireLibConfigDirectoryRef self, int inIndex, UInt32* outValue);
    /*! Description forthcoming */
    IOReturn (*GetIndexEntry)					( IOFireWireLibConfigDirectoryRef self, int inIndex, UInt32* outValue);
    /*! Description forthcoming */
    IOReturn (*GetSubdirectories)				( IOFireWireLibConfigDirectoryRef self, io_iterator_t* outIterator);
    /*! Description forthcoming */
    IOReturn (*GetKeySubdirectories)			( IOFireWireLibConfigDirectoryRef self, int inKey, io_iterator_t* outIterator);
    /*! Description forthcoming */
	IOReturn (*GetType)							( IOFireWireLibConfigDirectoryRef self, int* outType) ;
    /*! Description forthcoming */
	IOReturn (*GetNumEntries)					( IOFireWireLibConfigDirectoryRef self, int* outNumEntries) ;

} IOFireWireConfigDirectoryInterface ;

/*! Description forthcoming */
CF_INLINE IOVirtualRange
IOVirtualRangeMake( IOVirtualAddress address, IOByteCount length )
{
	IOVirtualRange range ;
	range.address = address ;
	range.length = length ;
	return range ;
}

#pragma mark -
#pragma mark VECTOR COMMAND INTERFACE
// ============================================================
// IOFireWireVectorCommandInterface
// ============================================================


/*!	@class
	@abstract IOFireWireLib command object for grouping commands execution.
	@discussion Read and Write commands can be attached in order to the vector command. When 
		the vector command is submitted all the commands are sent to the kernel for execution.
		When all the commands in a vector command are complete the vector command's completion is called.
		The advantage over submitting and completeing each command simultaneously is that only one kernel transition
		will be used for submission and one for completion, regardless of the number of commands in the vector.*/
typedef struct IOFireWireLibVectorCommandInterface_t
{

	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt32 version;

	/*! Interface revision. */
	UInt32 revision;
	
	/*!	@function Submit
		@abstract Submit this command object to FireWire for execution.
		@param self A reference to the vector command object
		@result An IOReturn result code	*/

	IOReturn					(*Submit)(IOFireWireLibVectorCommandRef self);

	/*!	@function Submit
		@abstract Submit this command object to FireWire for execution.
		@discussion A convienence method to set the callback and refcon and then submit.
		@param self A reference to the vector command object
		@param refCon A reference constant for 3rd party use. This is the same refcon set with SetRefCon and retreived with GetRefCon.
		@param inCallback A callback function to be called upon command completion.
		@result An IOReturn result code	*/

	IOReturn					(*SubmitWithRefconAndCallback)(IOFireWireLibVectorCommandRef self, void* refCon, IOFireWireLibCommandCallback inCallback);
	
	/*!	@function IsExecuting
		@abstract Checks if the vector command is currently executing.
		@param self A reference to the vector command object
		@result True if the command is executing, false otherwise */

	Boolean						(*IsExecuting)(IOFireWireLibVectorCommandRef self);

	/*!	@function SetCallback
		@abstract Set the callback routine for this command.
		@param self A reference to the vector command object
		@param inCallback A callback function to be called upon command completion.
		@result void	*/
	
	void						(*SetCallback)(IOFireWireLibVectorCommandRef self, IOFireWireLibCommandCallback inCallback);

	/*!	@function SetRefCon
		@abstract Set the reference constant for this command.
		@param self A reference to the vector command object
		@param refCon A reference constant for 3rd party use.
		@result void	*/
			
	void						(*SetRefCon)(IOFireWireLibVectorCommandRef self, void* refCon);
	
	/*!	@function GetRefCon
		@abstract Get the reference constant for this command.
		@param self A reference to the vector command object
		@result The reference contant set in SetRefCon	*/
		
	void *						(*GetRefCon)(IOFireWireLibVectorCommandRef self);

	/*!	@function SetFlags
		@abstract Set flags governing this command's execution.
		@param self A reference to the vector command object
		@param inFlags A UInt32 with bits set corresponding to the flags that should be set
			for this command object. The following values may be used:<br>
			<ul>
				<li>kFWCommandNoFlags -- all flags off</li>
				<li>kFWCommandInterfaceSyncExecute -- Setting this flag causes the command object
					to execute synchronously. The calling context will block until the command
					object has completed execution or an error occurs. Using synchronous execution
					can avoid kernel transitions associated with asynchronous completion and often
					remove the need for a state machine.</li>
				<li>kFWVectorCommandInterfaceOrdered - Normally all commands in a vector are executed
				    simultaneously. Setting this flag will dispatch a command only after the prior 
					command has completed.
			</ul>
			@result void	*/
	
	void						(*SetFlags)(IOFireWireLibVectorCommandRef self, UInt32 inFlags);
	
	/*!	@function GetFlags
		@abstract Get the flags currently set for this command.
		@param self A reference to the vector command object
		@result The flags set in SetFlags	*/
		
	UInt32						(*GetFlags)(IOFireWireLibVectorCommandRef self);
	
	/*!	@function EnsureCapacity
		@abstract Sets the number of commands this vector can hold.
		@discussion The vector can grow dynamically, but for performance
			reasons developers may want the storage preallocated for a certain 
			number of commmands
		@param self A reference to the vector command object
		@param capacity The number of commands this vector command should expect to hold
		@result  An IOReturn result code	*/
		
	IOReturn					(*EnsureCapacity)(IOFireWireLibVectorCommandRef self, UInt32 capacity);
	
	/*!	@function AddCommand
		@abstract Adds a command to the vector command.
		@param self A reference to the vector command object
		@param command A reference to the command to add
		@result An IOReturn result code	*/
	
	void					(*AddCommand)(IOFireWireLibVectorCommandRef self, IOFireWireLibCommandRef command);
	
	/*!	@function RemoveCommand
		@abstract Removes a command to the vector command.
		@param self A reference to the vector command object
		@param command A reference to the command to be removed
		@result An IOReturn result code	*/
		
	void					(*RemoveCommand)(IOFireWireLibVectorCommandRef self, IOFireWireLibCommandRef command);
	
	/*!	@function InsertCommandAtIndex
		@abstract Inserts a command at a given index. Commands at and after 
			this index will be moved to their next sequential index.
		@param self A reference to the vector command object
		@param command A reference to the command to be inserted
		@param index The index to insert the command at.
	*/
		
	void					(*InsertCommandAtIndex)(IOFireWireLibVectorCommandRef self, IOFireWireLibCommandRef command, UInt32 index);
	
	/*!	@function GetCommandAtIndex
		@abstract Returns the command at a given index.
		@discussion Returns kIOReturnBadArgument if the index is out of bounds.
		@param self A reference to the vector command object
		@param index The index to return a command from
		@result The IOFireWireLibCommandRef at the specified index on return	*/
		
	IOFireWireLibCommandRef		(*GetCommandAtIndex)(IOFireWireLibVectorCommandRef self, UInt32 index);
		
	/*!	@function GetIndexOfCommand
		@abstract Returns the index of the specified command. 
		@discussion Returns kIOReturnNotFound if the command does not exist in this vector.
		@param self A reference to the vector command object
		@param command The command in question
		@result The index of the specified command	*/
		
	UInt32						(*GetIndexOfCommand)(IOFireWireLibVectorCommandRef self, IOFireWireLibCommandRef command);

	/*!	@function RemoveCommandAtIndex
		@abstract Removes the command at a give index. Commands at and afte
			this index will be moved to their previous sequential index.
		@discussion Returns kIOReturnBadArgument if the index is out of bounds.
		@param self A reference to the vector command object
		@param index Will be set to the index of the specified command.
	*/
		
	void					(*RemoveCommandAtIndex)(IOFireWireLibVectorCommandRef self, UInt32 index);
	
	/*!	@function RemoveAllCommands
		@abstract Removes all commands from the vector.
		@param self A reference to the vector command object
	*/
		
	void						(*RemoveAllCommands)(IOFireWireLibVectorCommandRef self);
	
	/*!	@function GetCommandCount
		@abstract Returns the number of commands currently in this vector.
		@param self A reference to the vector command object
		@result UInt32 The number of commands in this vector	*/
		
	UInt32						(*GetCommandCount)(IOFireWireLibVectorCommandRef self);
	
} IOFireWireLibVectorCommandInterface;

#pragma mark -
#pragma mark PHY PACKET LISTENER INTERFACE
// ============================================================
// IOFireWireLibPHYPacketListenerInterface Interface
// ============================================================

/*!	@class
	@discussion Represents and provides management functions for a phy packet listener object.
*/
typedef struct IOFireWireLibPHYPacketListenerInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt16 version;

	/*! Interface revision. */
	UInt16 revision;

	/*!	@function SetListenerCallback
		@abstract Set the callback that should be called to handle incoming phy packets
		@param self The PHY packet listener object.
		@param inCallback The callback to set.
	*/
	void (*SetListenerCallback)( IOFireWireLibPHYPacketListenerRef self, IOFireWireLibPHYPacketCallback inCallback );

	/*!	@function SetSkippedPacketCallback
		@abstract Set the callback that should be called when incoming phy packets are
			dropped by the listener space.
		@param self The PHY packet listener object.
		@param inCallback The callback to set.
	*/
	void (*SetSkippedPacketCallback)( IOFireWireLibPHYPacketListenerRef self, IOFireWireLibPHYPacketSkippedCallback inCallback );

	/*!	@function NotificationIsOn
		@abstract Is notification on?
		@param self The PHY packet listener object.
		@result Returns true if packet notifications for this listener are active 
	*/
	Boolean (*NotificationIsOn)( IOFireWireLibPHYPacketListenerRef self );

	/*!	@function TurnOnNotification
		@abstract Try to turn on packet notifications for this listener.
		@param self The PHY packet listener object.
		@result Returns kIOReturnSuccess if successful */
	IOReturn (*TurnOnNotification)( IOFireWireLibPHYPacketListenerRef self );

	/*!	@function TurnOffNotification
		@abstract Turn packet notification off.
		@param self The PHY packet listener object. */
	void (*TurnOffNotification)( IOFireWireLibPHYPacketListenerRef self );

	/*!	@function ClientCommandIsComplete
		@abstract Notify the PHY packet listener object that a packet notification handler has completed.
		@discussion Packet notifications are received one at a time, in order. This function
			must be called after a packet handler has completed its work.
		@param self The PHY packet listener object.
		@param commandID The ID of the packet notification being completed. This is the same
			ID that was passed when a packet notification handler is called.
	*/
	void (*ClientCommandIsComplete)(IOFireWireLibPHYPacketListenerRef self, FWClientCommandID commandID );

	// --- accessors ----------

	/*!	@function SetRefCon
		@abstract Sets the user refCon value for this interface.
		@param self The PHY packet listener object.
		@param refcon the refcon */
	void (*SetRefCon)( IOFireWireLibPHYPacketListenerRef self, void * refcon );
		
	/*!	@function GetRefCon
		@abstract Returns the user refCon value for thisinterface.
		@param self The PHY packet listener object.
		@result returns the refcon */
	void* (*GetRefCon)( IOFireWireLibPHYPacketListenerRef self );

	/*!	@function SetFlags
		@abstract set flags for the listener.
		@param self The PHY packet listener object.
		@param flags No current flags are defined.
	*/	
	void (*SetFlags)( IOFireWireLibPHYPacketListenerRef self, UInt32 flags );
		
	/*!	@function GetFlags
		@abstract get the flags of listener.
		@param self The PHY packet listener object.
		@result flags No current flags are defined.	*/	
	UInt32 (*GetFlags)( IOFireWireLibPHYPacketListenerRef self );

} IOFireWireLibPHYPacketListenerInterface;

#endif // ifndef KERNEL

#endif //__IOFireWireLib_H__
                                                                                                             IOFireWireLibIsoch.h                                                                                0100644 0001750 0001750 00000140513 12566200640 036146  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/firewire                                                              /*
 * Copyright (c) 1998-2002 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 *  IOFireWireLibIsoch.h
 *  IOFireWireFamily
 *
 *  Created on Mon Mar 19 2001.
 *  Copyright (c) 2001-2002 Apple Computer, Inc. All rights reserved.
 *
 */

#ifndef __IOFireWireLibIsoch_H__
#define __IOFireWireLibIsoch_H__

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOCFPlugIn.h>

#include <IOKit/firewire/IOFireWireFamilyCommon.h>
#include <IOKit/firewire/IOFireWireLib.h>

//
// local isoch port
//

//	uuid string: 541971C6-CE72-11D7-809D-000393C0B9D8
#define kIOFireWireLocalIsochPortInterfaceID_v5 CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault \
											, 0x54, 0x19, 0x71, 0xC6, 0xCE, 0x72, 0x11, 0xD7\
											, 0x80, 0x9D, 0x00, 0x03, 0x93, 0xC0, 0xB9, 0xD8 )

//	uuid string: FECAA2F6-4E84-11D7-B6FD-0003938BEB0A
#define kIOFireWireLocalIsochPortInterfaceID_v4 CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault \
											,0xFE, 0xCA, 0xA2, 0xF6, 0x4E, 0x84, 0x11, 0xD7\
											,0xB6, 0xFD, 0x00, 0x03, 0x93, 0x8B, 0xEB, 0x0A )

//  uuid string: A0AD095E-6D2F-11D6-AC82-0003933F84F0
#define kIOFireWireLocalIsochPortInterfaceID_v3 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xA0, 0xAD, 0x09, 0x5E, 0x6D, 0x2F, 0x11, 0xD6,\
											0xAC, 0x82, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//	Availability: Mac OS X "Jaguar" and later
//  uuid string: 73C76D09-6D2F-11D6-AF7F-0003933F84F0
#define kIOFireWireLocalIsochPortInterfaceID_v2 CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x73, 0xC7, 0x6D, 0x09, 0x6D, 0x2F, 0x11, 0xD6,\
											0xAF, 0x7F, 0x00, 0x03, 0x93, 0x3F, 0x84, 0xF0 )

//  uuid string: 0F5E33C8-1350-11D5-9BE7-003065AF75CC
#define kIOFireWireLocalIsochPortInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x0F, 0x5E, 0x33, 0xC8, 0x13, 0x50, 0x11, 0xD5,\
											0x9B, 0xE7, 0x00, 0x30, 0x65, 0xAF, 0x75, 0xCC)

//
// remote isoch port
//

//	uuid string: AAFDBDB0-489F-11D5-BC9B-003065423456
#define kIOFireWireRemoteIsochPortInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0xAA, 0xFD, 0xBD, 0xB0, 0x48, 0x9F, 0x11, 0xD5,\
											0xBC, 0x9B, 0x00, 0x30, 0x65, 0x42, 0x34, 0x56)


//
// isoch channel
//

//  uuid string: 2EC1E404-1350-11D5-89B5-003065AF75CC
#define kIOFireWireIsochChannelInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x2E, 0xC1, 0xE4, 0x04, 0x13, 0x50, 0x11, 0xD5,\
											0x89, 0xB5, 0x00, 0x30, 0x65, 0xAF, 0x75, 0xCC)

//
// DCL command pool
//

//  uuid string: 4A4B1710-1350-11D5-9B12-003065AF75CC
#define kIOFireWireDCLCommandPoolInterfaceID CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x4A, 0x4B, 0x17, 0x10, 0x13, 0x50, 0x11, 0xD5,\
											0x9B, 0x12, 0x00, 0x30, 0x65, 0xAF, 0x75, 0xCC)

//
// NuDCL pool
//

//	uuid string: D3837670-4463-11D7-B79A-0003938BEB0A
#define kIOFireWireNuDCLPoolInterfaceID CFUUIDGetConstantUUIDWithBytes( kCFAllocatorDefault,\
											0xD3, 0x83, 0x76, 0x70, 0x44, 0x63, 0x11, 0xD7,\
											0xB7, 0x9A, 0x00, 0x03, 0x93, 0x8B, 0xEB, 0x0A)

//  uuid string: 6D1FDE59-50CE-4ED4-880A-9D13A4624038
#define kIOFireWireAsyncStreamListenerInterfaceID  CFUUIDGetConstantUUIDWithBytes(kCFAllocatorDefault,\
											0x6D, 0x1F, 0xDE, 0x59, 0x50, 0xCE, 0x4E, 0xD4,\
											0x88, 0x0A, 0x90, 0x13, 0xA4, 0x62, 0x40, 0x38)


typedef void	(*IOFireWireIsochChannelForceStopHandler)(
	IOFireWireLibIsochChannelRef	interface, 
	UInt32							stopCondition);

typedef IOReturn	(*IOFireWireLibIsochPortCallback)(
	IOFireWireLibIsochPortRef		interface) ;
	
typedef IOReturn	(*IOFireWireLibIsochPortAllocateCallback)(
	IOFireWireLibIsochPortRef		interface,
	IOFWSpeed						maxSpeed,
	UInt32							channel) ;

typedef IOReturn	(*IOFireWireLibIsochPortGetSupportedCallback)(
	IOFireWireLibIsochPortRef		interface,
	IOFWSpeed*						outMaxSpeed,
	UInt64*							outChanSupported) ;

typedef IOReturn	(*IOFireWireLibIsochPortFinalizeCallback)( void* refcon ) ;

// ============================================================
//
// IOFireWireIsochPort
//
// ============================================================

/*! @parseOnly */
#define IOFIREWIRELIBISOCHPORT_C_GUTS	\
	/*!	@function GetSupported \
		@abstract The method is called to determine which FireWire isochronous \
			channels and speed this port supports. \
		@discussion This method is called by the channel object to which a port \
			has been added. Subclasses of IOFireWireIsochPortInterface override \
			this method to support specific hardware. Do not call this method \
			directly. \
		@param self The isoch port interface to use. \
		@param maxSpeed A pointer to an IOFWSpeed which should be filled with \
			the maximum speed this port can talk or listen. \
		@param chanSupported A pointer to a UInt64 which should be filled with \
			a bitmask representing the FireWire bus isochonous channels on \
			which the port can talk or listen. Set '1' for supported, '0' for \
			unsupported. \
		@result Return kIOReturnSuccess on success, other return any other \
			IOReturn error code.*/ \
	IOReturn	(*GetSupported)	( IOFireWireLibIsochPortRef self, IOFWSpeed* maxSpeed, UInt64* chanSupported ) ;	\
	/*!	@function AllocatePort \
		@abstract The method is called when the port should configure its \
			associated hardware to prepare to send or receive isochronous data \
			on the channel number and at the speed specified. \
		@discussion This method is called by the channel object to which a port \
			has been added. Subclasses of IOFireWireIsochPortInterface override \
			this method to support specific hardware. Do not call this method \
			directly. \
		@param self The isoch port interface to use. \
		@param speed Channel speed \
		@param chan Channel number (0-63) \
		@result Return kIOReturnSuccess on success, other return any other \
			IOReturn error code.*/ \
	IOReturn	(*AllocatePort)	( IOFireWireLibIsochPortRef self, IOFWSpeed speed, UInt32 chan ) ;	\
	/*!	@function ReleasePort \
		@abstract The method is called to release the hardware after the \
			channel has been stopped. \
		@discussion This method is called by the channel object to which a port \
			has been added. Subclasses of IOFireWireIsochPortInterface override \
			this method to support specific hardware. Do not call this method \
			directly. \
		@param self The isoch port interface to use. \
		@result Return kIOReturnSuccess on success, other return any other IOReturn error code.*/ \
	IOReturn 	(*ReleasePort)	( IOFireWireLibIsochPortRef self ) ;	\
	/*!	@function Start \
		@abstract The method is called when the port is to begin talking or listening. \
		@discussion This method is called by the channel object to which a port \
			has been added. Subclasses of IOFireWireIsochPortInterface override \
			this method to support specific hardware. Do not call this method \
			directly. \
		@param self The isoch port interface to use. \
		@result Return kIOReturnSuccess on success, other return any other IOReturn error code.*/ \
	IOReturn	(*Start)		( IOFireWireLibIsochPortRef self ) ;	\
	/*!	@function Stop \
		@abstract The method is called when the port is to stop talking or listening. \
		@discussion This method is called by the channel object to which a port \
			has been added. Subclasses of IOFireWireIsochPortInterface override \
			this method to support specific hardware. Do not call this method \
			directly. \
		@param self The isoch port interface to use. \
		@result Return kIOReturnSuccess on success, other return any \
			other IOReturn error code.*/ \
	IOReturn	(*Stop)			( IOFireWireLibIsochPortRef self ) ;	\
	/*!	@function SetRefCon \
		@abstract Set reference value associated with this port. \
		@discussion Retrieve the reference value with GetRefCon() \
		@param self The isoch port interface to use. \
		@param inRefCon The new reference value.*/ \
	void 		(*SetRefCon)	( IOFireWireLibIsochPortRef self, void* inRefCon) ;	\
	/*!	@function GetRefCon \
		@abstract Get reference value associated with this port. \
		@discussion Set the reference value with SetRefCon() \
		@param self The isoch port interface to use. \
		@result The port refcon value.*/ \
	void*		(*GetRefCon)	( IOFireWireLibIsochPortRef self)

/*!	@class
	@abstract FireWire user client isochronous port interface
	@discussion Isochronous ports represent talkers or listeners on a
		FireWire isochronous channel. This is a base class containing all
		isochronous port functionality not specific to any type of port.
		Ports are added to channel interfaces
		(IOFireWireIsochChannelInterface) which coordinate the start and
		stop of isochronous traffic on a FireWire bus isochronous channel.
 */
typedef struct IOFireWireIsochPortInterface_t
{
	IUNKNOWN_C_GUTS ;
	/*! Interface revision. */
	UInt32 revision;
	/*! Interface version. */
	UInt32 version;

	IOFIREWIRELIBISOCHPORT_C_GUTS ;

} IOFireWireIsochPortInterface ;

/*! @class
	Description forthcoming
 */
typedef struct IOFireWireRemoteIsochPortInterface_t
{
	IUNKNOWN_C_GUTS ;
	/*! Interface revision. */
	UInt32 revision;
	/*! Interface version. */
	UInt32 version;

	IOFIREWIRELIBISOCHPORT_C_GUTS ;

	/*! Description forthcoming */
	IOFireWireLibIsochPortGetSupportedCallback (*SetGetSupportedHandler) ( IOFireWireLibRemoteIsochPortRef self, IOFireWireLibIsochPortGetSupportedCallback inHandler) ;
	/*! Description forthcoming */
	IOFireWireLibIsochPortAllocateCallback	   (*SetAllocatePortHandler) ( IOFireWireLibRemoteIsochPortRef self, IOFireWireLibIsochPortAllocateCallback inHandler) ;
	/*! Description forthcoming */
	IOFireWireLibIsochPortCallback	(*SetReleasePortHandler)( IOFireWireLibRemoteIsochPortRef self, IOFireWireLibIsochPortCallback inHandler) ;
	/*! Description forthcoming */
	IOFireWireLibIsochPortCallback	(*SetStartHandler)( IOFireWireLibRemoteIsochPortRef self, IOFireWireLibIsochPortCallback inHandler) ;
	/*! Description forthcoming */
	IOFireWireLibIsochPortCallback	(*SetStopHandler)( IOFireWireLibRemoteIsochPortRef self, IOFireWireLibIsochPortCallback inHandler) ;

} IOFireWireRemoteIsochPortInterface ;

/*!	@class
	@abstract FireWire user client local isochronous port object.
	@discussion Represents a FireWire isochronous talker or listener
		within the local machine. Isochronous transfer is controlled by
		an associated DCL (Data Stream Control Language) program, which
		is similar to a hardware DMA program but is hardware agnostic.
		DCL programs can be written using the
		IOFireWireDCLCommandPoolInterface object.

	This interface contains all methods of IOFireWireIsochPortInterface
		and IOFireWireLocalIsochPortInterface. This interface will
		contain all v2 methods of IOFireWireLocalIsochPortInterface when
		instantiated as v2 or newer.
		
	Transfer buffers for the local isoch port must all come from a single allocation
	made with vm_allocate() or mmap(..., MAP_ANON ).
	
	Calling vm_deallocate() on the buffers before deallocating a local isoch port object
	may result in a deadlock.
	
	Note: Calling Release() on the local isoch port may not immediately release the isoch port;
	so it may not be safe to call vm_deallocate() on your transfer buffers. To guarantee
	the port has been release, run the isochronous runloop until the port is finalized (it has
	processed any pending callbacks). The finalize callback will be called when
	the port is finalized. Set the finalize callback using SetFinalizeCallback().
	*/
typedef struct IOFireWireLocalIsochPortInterface_t {

	IUNKNOWN_C_GUTS ;
	/*! Interface revision */
	UInt32 revision;
	/*! Interface revision */
	UInt32 version;

	IOFIREWIRELIBISOCHPORT_C_GUTS ;
	
	/*!	@function ModifyJumpDCL
		@abstract Change the jump target label of a jump DCL.
		@discussion Use this function to change the flow of a DCL
			program. Works whether the DCL program is currently running
			or not.
		@param self The local isoch port interface to use.
		@param inJump The jump DCL to modify.
		@param inLabel The label to jump to.
		@result kIOReturnSuccess on success. Will return an error if 'inJump'
			does not point to a valid jump DCL or 'inLabel' does not point to a
			valid label DCL.*/
	IOReturn 	(*ModifyJumpDCL)( IOFireWireLibLocalIsochPortRef self, DCLJump* inJump, DCLLabel* inLabel) ;
	
	// --- utility functions ----------
	/*!	@function PrintDCLProgram
		@abstract Display the contents of a DCL program.
		@param self The local isoch port interface to use.
		@param inProgram A pointer to the first DCL of the program to display.
		@param inLength The length (in DCLs) of the program.*/
	void 		(*PrintDCLProgram)( IOFireWireLibLocalIsochPortRef self, const DCLCommand* inProgram, UInt32 inLength) ;

	//
	// --- v2
	//
	
	/*!	@function ModifyTransferPacketDCLSize
		@abstract Modify the transfer size of a transfer packet DCL (send or
			receive)
		@discussion Allows you to modify transfer packet DCLs after they have
			been compiled and while the DCL program is still running. The
			transfer size can be set to any size less than or equal to the size
			set when the DCL program was compiled (including 0).

		Availability: IOFireWireLocalIsochPortInterface_v2 and newer.

		@param self The local isoch port interface to use.
		@param inDCL A pointer to the DCL to modify.
		@param size The new size of data to be transferred.
		@result Returns kIOReturnSuccess on success. Will return an
			error if 'size' is too large for this program.*/
	IOReturn	(*ModifyTransferPacketDCLSize)( IOFireWireLibLocalIsochPortRef self, DCLTransferPacket* inDCL, IOByteCount size ) ;

	//
	// --- v3
	//
	
	/*!	@function ModifyTransferPacketDCLBuffer
		@abstract NOT IMPLEMENTED. Modify the transfer size of a
			transfer packet DCL (send or receive)
		@discussion NOT IMPLEMENTED. Allows you to modify transfer packet DCLs
			after they have been compiled and while the DCL program is still
			running. The buffer can be set to be any location within the range
			of buffers specified when the DCL program was compiled (including
			0).

		Availability: IOFireWireLocalIsochPortInterface_v3 and newer.

		@param self The local isoch port interface to use.
		@param inDCL A pointer to the DCL to modify.
		@param buffer The new buffer to or from data will be transferred.
		@result Returns kIOReturnSuccess on success. Will return an
			error if the range specified by [buffer, buffer+size] is not
			in the range of memory locked down for this program.*/
	IOReturn	(*ModifyTransferPacketDCLBuffer)( IOFireWireLibLocalIsochPortRef self, DCLTransferPacket* inDCL, void* buffer ) ;

	/*!	@function ModifyTransferPacketDCL
		@abstract Modify the transfer size of a transfer packet DCL (send or receive)
		@discussion Allows you to modify transfer packet DCLs after they
			have been compiled and while the DCL program is still
			running. The transfer size can be set to any size less than
			or equal to the size set when the DCL program was compiled
			(including 0).
			
			Availability: IOFireWireLocalIsochPortInterface_v3 and newer.
			
		@param self The local isoch port interface to use.
		@param inDCL A pointer to the DCL to modify.
		@param buffer The new buffer to or from data will be transferred.
		@param size The new size of data to be transferred.
		@result Returns kIOReturnSuccess on success. Will return an
			error if 'size' is too large or 'inDCL' does not point to a
			valid transfer packet DCL, or the range specified by
			[buffer, buffer+size] is not in the range of memory locked
			down for this program.*/
	IOReturn	(*ModifyTransferPacketDCL)( IOFireWireLibLocalIsochPortRef self, DCLTransferPacket* inDCL, void* buffer, IOByteCount size ) ;

	//
	// v4
	// 
	
	/*!	@function SetFinalizeCallback
		@abstract Set the finalize callback for a local isoch port
		@discussion When Stop() is called on a LocalIsochPortInterface, there may or
			may not be isoch callbacks still pending for this isoch port. The port must be allowed
			to handle any pending callbacks, so the isoch runloop should not be stopped until a port 
			has handled all pending callbacks. The finalize callback is called after the final 
			callback has been made on the isoch runloop. After this callback is sent, it is safe
			to stop the isoch runloop.
			
			You should not access the isoch port after the finalize callback has been made; it may
			be released immediately after this callback is sent.
						
			Availability: IOFireWireLocalIsochPortInterface_v4 and newer.
			
		@param self The local isoch port interface to use.
		@param finalizeCallback The finalize callback.
		@result Returns true if this isoch port has no more pending callbacks and does not
			need any more runloop time.*/
	IOReturn		(*SetFinalizeCallback)( IOFireWireLibLocalIsochPortRef self, IOFireWireLibIsochPortFinalizeCallback finalizeCallback ) ;

	//
	// v5
	//
	
	IOReturn		(*SetResourceUsageFlags)( IOFireWireLibLocalIsochPortRef self, IOFWIsochResourceFlags flags ) ;
	IOReturn		(*Notify)( IOFireWireLibLocalIsochPortRef self, IOFWDCLNotificationType notificationType, void ** inDCLList, UInt32 numDCLs ) ;

} IOFireWireLocalIsochPortInterface ;

// ============================================================
//
// IOFireWireIsochChannelInterface
//
// ============================================================

	/*!	@class
		@abstract FireWire user client isochronous channel object.
		@discussion IOFireWireIsochChannelInterface is an abstract
			representataion of a FireWire bus isochronous channel. This
			interface coordinates starting and stopping traffic on a
			FireWire bus isochronous channel and can optionally
			communicate with the IRM to automatically allocate bandwidth
			and channel numbers. When using automatic IRM allocation,
			the channel interface reallocates its bandwidth and channel
			reservation after each bus reset.

		Isochronous port interfaces representing FireWire isochronous talkers
			and listeners must be added to the channel using SetTalker() and
			AddListener()
	*/
typedef struct IOFireWireIsochChannelInterface_t
{
	IUNKNOWN_C_GUTS ;
	/*! Interface revision. */
	UInt32 revision;
	/*! Interface version. */
	UInt32 version;

	/*!	@function SetTalker
		@abstract Set the talker port for this channel.
		@param self The isoch channel interface to use.
		@param talker The new talker.
		@result Returns an IOReturn error code. */
	IOReturn 			(*SetTalker)		( IOFireWireLibIsochChannelRef self, IOFireWireLibIsochPortRef talker ) ;

	/*!	@function AddListener
		@abstract Modify the transfer size of a transfer packet DCL (send or receive)
		@discussion Allows you to modify transfer packet DCLs after they have
			been compiled and while the DCL program is still running. The
			transfer size can be set to any size less than or equal to the size
			set when the DCL program was compiled (including 0).

		Availability: IOFireWireLocalIsochPortInterface_v3 and newer.

		@param self The isoch channel interface to use.
		@param listener The listener to add.
		@result Returns an IOReturn error code. */
	IOReturn			(*AddListener)		( IOFireWireLibIsochChannelRef self, IOFireWireLibIsochPortRef listener ) ;
	
	/*!	@function AllocateChannel
		@abstract Prepare all hardware to begin sending or receiving isochronous data.
		@discussion Calling this function will result in all listener and talker ports on this 
			isochronous channel having their AllocatePort method called.
		@param self The isoch channel interface to use.
		@result Returns an IOReturn error code. */
	IOReturn			(*AllocateChannel)	( IOFireWireLibIsochChannelRef self ) ;

	/*!	@function ReleaseChannel
		@abstract Release all hardware after stopping the isochronous channel.
		@discussion Calling this function will result in all listener and talker ports on this 
			isochronous channel having their ReleasePort method called.
		@param self The isoch channel interface to use.
		@result Returns an IOReturn error code. */
	IOReturn			(*ReleaseChannel)	( IOFireWireLibIsochChannelRef self ) ;

	/*!	@function Start
		@abstract Start the channel.
		@discussion Calling this function will result in all listener and talker ports on this 
			isochronous channel having their Start method called.
		@param self The isoch channel interface to use.
		@result Returns an IOReturn error code. */
	IOReturn			(*Start)			( IOFireWireLibIsochChannelRef self ) ;

	/*!	@function Stop
		@abstract Stop the channel.
		@discussion Calling this function will result in all listener and talker ports on this 
			isochronous channel having their Stop method called.
		@param self The isoch channel interface to use.
		@result Returns an IOReturn error code. */
	IOReturn			(*Stop)				( IOFireWireLibIsochChannelRef self ) ;
	
	// --- notification
	/*!	@function SetChannelForceStopHandler
		@abstract Set the channel force stop handler.
		@discussion The specified callback is called when the channel is stopped and cannot be 
			restarted automatically.
		@param self The isoch channel interface to use.
		@param stopProc The handler to set.
		@result Returns the previously set handler or NULL is no handler was set.*/
	IOFireWireIsochChannelForceStopHandler (*SetChannelForceStopHandler)
													( IOFireWireLibIsochChannelRef self, IOFireWireIsochChannelForceStopHandler stopProc) ;

	/*!	@function SetRefCon
		@abstract Set reference value associated with this channel.
		@discussion Retrieve the reference value with GetRefCon()
		@param self The isoch channel interface to use.
		@param stopProcRefCon The new reference value.*/
	void 				(*SetRefCon)				( IOFireWireLibIsochChannelRef self, void* stopProcRefCon) ;

	/*!	@function GetRefCon
		@abstract Set reference value associated with this channel.
		@discussion Retrieve the reference value with SetRefCon()
		@param self The isoch channel interface to use.*/
	void*				(*GetRefCon)				( IOFireWireLibIsochChannelRef self) ;

	/*! Description forthcoming */
	Boolean				(*NotificationIsOn) 		( IOFireWireLibIsochChannelRef self) ;
	/*! Description forthcoming */
	Boolean				(*TurnOnNotification) 		( IOFireWireLibIsochChannelRef self) ;
	/*! Description forthcoming */
	void				(*TurnOffNotification) 		( IOFireWireLibIsochChannelRef self) ;	
	/*! Description forthcoming */
	void				(*ClientCommandIsComplete)	( IOFireWireLibIsochChannelRef self, FWClientCommandID commandID, IOReturn status) ;

} IOFireWireIsochChannelInterface ;

// ============================================================
//
// IOFireWireDCLCommandPoolInterface
//
// ============================================================

/*!	@class IOFireWireDCLCommandPoolInterface
	Description forthcoming.
*/
typedef struct IOFireWireDCLCommandPoolInterface_t
{
	IUNKNOWN_C_GUTS ;
	/*! Interface revision. */
	UInt32 revision;
	/*! Interface version. */
	UInt32 version;

	/*! Description forthcoming */
	DCLCommand*			(*Allocate)						( IOFireWireLibDCLCommandPoolRef self, IOByteCount inSize ) ;
	/*! Description forthcoming */
	IOReturn			(*AllocateWithOpcode)			( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, DCLCommand** outDCL, UInt32 opcode, ... ) ;
	
	/*! Description forthcoming */
	DCLCommand*			(*AllocateTransferPacketDCL)	( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, UInt32 inOpcode, void* inBuffer, IOByteCount inSize) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateTransferBufferDCL)	( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, UInt32 inOpcode, void* inBuffer, IOByteCount inSize, IOByteCount inPacketSize, UInt32 inBufferOffset) ;

	/*! Description forthcoming */
	DCLCommand*			(*AllocateSendPacketStartDCL)	( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize) ;
	
	// AllocateSendPacketWithHeaderStartDCL has been deprecated! If you need this functionality, you should be using NuDCL!
	/*! Description forthcoming */
	DCLCommand*			(*AllocateSendPacketWithHeaderStartDCL)( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize) ;
	
	/*! Description forthcoming */
	DCLCommand*			(*AllocateSendBufferDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize, IOByteCount inPacketSize, UInt32 inBufferOffset) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateSendPacketDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize) ;

	/*! Description forthcoming */
	DCLCommand*			(*AllocateReceivePacketStartDCL)( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateReceivePacketDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateReceiveBufferDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, void* inBuffer, IOByteCount inSize, IOByteCount inPacketSize, UInt32 inBufferOffset) ;

	/*! Description forthcoming */
	DCLCommand*			(*AllocateCallProcDCL)			( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, DCLCallCommandProc* inProc, DCLCallProcDataType inProcData) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateLabelDCL)				( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateJumpDCL)				( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, DCLLabel* pInJumpDCLLabel) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateSetTagSyncBitsDCL)	( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, UInt16 inTagBits, UInt16 inSyncBits) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocateUpdateDCLListDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, DCLCommand** inDCLCommandList, UInt32 inNumCommands) ;
	/*! Description forthcoming */
	DCLCommand*			(*AllocatePtrTimeStampDCL)		( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL, UInt32* inTimeStampPtr) ;

	/*! Description forthcoming */
	void 				(*Free)							( IOFireWireLibDCLCommandPoolRef self, DCLCommand* inDCL ) ;
	
	/*! Description forthcoming */
	IOByteCount			(*GetSize)						( IOFireWireLibDCLCommandPoolRef self ) ;
	/*! Description forthcoming */
	Boolean				(*SetSize)						( IOFireWireLibDCLCommandPoolRef self, IOByteCount inSize ) ;
	/*! Description forthcoming */
	IOByteCount			(*GetBytesRemaining)			( IOFireWireLibDCLCommandPoolRef self ) ;
} IOFireWireDCLCommandPoolInterface ;

/*!	@class IOFireWireNuDCLPoolInterface
	@discussion Use this interface to build NuDCL-based DCL programs.
*/
typedef struct IOFireWireNuDCLPoolInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version */
	UInt32 revision;
	/*! Interface version */
	UInt32 version;

	// Command pool management:

	/*!	@function GetProgram
		@abstract Finds the first DCL in the pool not preceeded by any other DCL.
		@discussion Returns a backwards-compatible DCL program pointer. This can be passed
			to IOFireWireLibDeviceRef::CreateLocalIsochPort.
		@param self The NuDCL pool to use.
		@result A DCLCommand pointer.*/
	DCLCommand*				(*GetProgram)( IOFireWireLibNuDCLPoolRef self ) ;
	
	/*!	@function GetDCLs
		@abstract Returns the pool's DCL program as a CFArray of NuDCLRef's. 
		@param self The NuDCL pool to use.
		@result A CFArrayRef.*/
	CFArrayRef				(*GetDCLs)( IOFireWireLibNuDCLPoolRef self ) ;

	/*! Description forthcoming */
	void					(*PrintProgram)( IOFireWireLibNuDCLPoolRef self ) ;
	/*! Description forthcoming */
	void					(*PrintDCL)( NuDCLRef dcl ) ;
	
	// Allocating transmit NuDCLs:

	/*!	@function SetCurrentTagAndSync
		@abstract Set current tag and sync bits
		@discussion Sets the DCL pool's current tag and sync bits. All send DCLs allocated after calling
			this function will transmit the specified tag and sync values. These fields can also be
			set on each DCL using SetDCLTagBits() and SetDCLSyncBits().
		@param self The NuDCL pool to use.
		@param tag Tag field value for subsequently allocated send DCLs
		@param sync Sync field value for subsequently allocated send DCLs */
	void					(*SetCurrentTagAndSync)( IOFireWireLibNuDCLPoolRef self, UInt8 tag, UInt8 sync ) ;

	/*!	@function AllocateSendPacket
		@abstract Allocate a SendPacket NuDCL and append it to the program.
		@discussion The SendPacket DCL sends an isochronous packet on the bus. One DCL runs per bus cycle.
			The isochronous header is automatically generated, but can be overriden. An update must be run to
			regenerate the isochronous header. The sync and tag fields of allocated DCLs default to 0, unless
			If SetCurrentTagAndSync has been called.
			
			Send DCLs can be modified using other functions of IOFireWireLibNuDCLPool.
		@param self The NuDCL pool to use.
		@param saveBag The allocated DCL can be added to a CFBag for easily setting DCL update lists. Pass a CFMutableSetRef to add the allocated
			DCL to a CFBag; pass NULL to ignore. SaveBag is unmodified on failure.
		@param numBuffers The number of virtual ranges in 'buffers'.
		@param buffers An array of virtual memory ranges containing the packet contents. The array is copied
			into the DCL.
		@result Returns an NuDCLSendPacketRef on success or 0 on failure. */
	NuDCLSendPacketRef		(*AllocateSendPacket)( IOFireWireLibNuDCLPoolRef self, CFMutableSetRef saveBag, UInt32 numBuffers, IOVirtualRange* buffers ) ;	

	/*!	@function AllocateSendPacket_v
		@abstract Allocate a SendPacket NuDCL and append it to the program.
		@discussion Same as AllocateSendPacket but ranges are passed as a NULL-terminated vector of IOVirtualRange's
		@param self The NuDCL pool to use.
		@param saveBag The allocated DCL can be added to a CFBag for easily setting DCL update lists. Pass a CFMutableSetRef to add the allocated
			DCL to a CFBag; pass NULL to ignore. SaveBag is unmodified on failure.
		@param firstRange The first buffer to be transmitted. Follow with additional ranges; terminate with NULL.
		@result Returns an NuDCLSendPacketRef on success or 0 on failure. */
	NuDCLSendPacketRef		(*AllocateSendPacket_v)( IOFireWireLibNuDCLPoolRef self, CFMutableSetRef saveBag, IOVirtualRange* firstRange, ... ) ;	

	/*!	@function AllocateSkipCycle
		@abstract Allocate a SkipCycle NuDCL and append it to the program.
		@discussion The SkipCycle DCL causes the DCL program to "sends" an empty cycle.
		@param self The NuDCL pool to use.
		@result Returns an NuDCLSkipCycleRef on success or 0 on failure. */
	NuDCLSkipCycleRef		(*AllocateSkipCycle)( IOFireWireLibNuDCLPoolRef self ) ;
	
	// Allocating receive NuDCLs:

	/*!	@function AllocateReceivePacket
		@abstract Allocate a ReceivePacket NuDCL and append it to the program
		@discussion The ReceivePacket DCL receives an isochronous packet from the bus. One DCL runs per bus cycle.
			If receiving isochronous headers, an update must be run before the isochronous header is valid.
			
			Receive DCLs can be modified using other functions of IOFireWireLibNuDCLPool.

		@param self The NuDCL pool to use.
		@param headerBytes Number of bytes of isochronous header to receive with the data. Valid values are 0, 4, and 8.
		@param saveBag The allocated DCL can be added to a CFBag for easily setting DCL update lists. Pass a CFMutableSetRef to add the allocated
			DCL to a CFBag; pass NULL to ignore. SaveBag is unmodified on failure.
		@param numBuffers The number of virtual ranges in 'buffers'.
		@param buffers An array of virtual memory ranges containing the packet contents. The array is copied
			into the DCL.
		@result Returns an NuDCLReceivePacketRef on success or 0 on failure. */
	NuDCLReceivePacketRef	(*AllocateReceivePacket)( IOFireWireLibNuDCLPoolRef self, CFMutableSetRef saveBag, UInt8 headerBytes, UInt32 numBuffers, IOVirtualRange* buffers ) ;

	/*!	@function AllocateReceivePacket_v
		@abstract Allocate a ReceivePacket NuDCL and append it to the program
		@discussion Same as AllocateReceivePacket but ranges are passed as a NULL-terminated vector of IOVirtualRange's
		@param self The NuDCL pool to use.
		@param saveBag The allocated DCL can be added to a CFBag for easily setting DCL update lists. Pass a CFMutableSetRef to add the allocated
			DCL to a CFBag; pass NULL to ignore. SaveBag is unmodified on failure.
		@param headerBytes Number of bytes of isochronous header to receive with the data. Valid values are 0, 4, and 8.
		@param firstRange The first buffer to be transmitted. Follow with additional ranges; terminate with NULL.
		@result Returns an NuDCLReceivePacketRef on success or 0 on failure. */
	NuDCLReceivePacketRef	(*AllocateReceivePacket_v)( IOFireWireLibNuDCLPoolRef self, CFMutableSetRef saveBag, UInt8 headerBytes, IOVirtualRange* firstRange, ... ) ;

	// NuDCL configuration

	/*!	@function FindDCLNextDCL
		@abstract Get the next pointer for a NuDCL
		@discussion Applies: Any NuDCLRef
		@param dcl The dcl whose next pointer will be returned
		@result Returns the DCL immediately following this DCL in program order (ignoring branches) or 0 for none.*/
	NuDCLRef			(*FindDCLNextDCL)( IOFireWireLibNuDCLPoolRef self, NuDCLRef dcl ) ;

	/*!	@function SetDCLBranch
		@abstract Set the branch pointer for a NuDCL
		@discussion Program execution will jump to the DCL pointed to by 'branchDCL', after the DCL is executed. If set to 0, 
			execution will stop after this DCL.
		
			This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()

			Applies: Any NuDCLRef.
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLBranch)( NuDCLRef dcl, NuDCLRef branchDCL ) ;

	/*!	@function GetDCLBranch
		@abstract Get the branch pointer for a NuDCL
		@discussion Applies: Any NuDCLRef.
		@param dcl The dcl whose branch pointer will be returned.
		@result Returns the branch pointer of 'dcl' or 0 for none is set.*/
	NuDCLRef			(*GetDCLBranch)( NuDCLRef dcl ) ;

	/*!	@function SetDCLTimeStampPtr
		@abstract Set the time stamp pointer for a NuDCL
		@discussion Setting a the time stamp pointer for a NuDCL causes a time stamp to be recorded when a DCL executes. 
			This DCL must be updated after it has executed for the timestamp to be valid.

			This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()

			Applies: Any NuDCLRef.

		@param dcl The DCL for which time stamp pointer will be set
		@param timeStampPtr A pointer to a quadlet which will hold the timestamp after 'dcl' is updated.
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLTimeStampPtr)( NuDCLRef dcl, UInt32* timeStampPtr ) ;

	/*!	@function GetDCLTimeStampPtr
		@abstract Get the time stamp pointer for a NuDCL.
		@discussion Applies: Any NuDCLRef.

		@param dcl The DCL whose timestamp pointer will be returned.
		@result Returns a UInt32 time stamp pointer.*/
	UInt32*				(*GetDCLTimeStampPtr)( NuDCLRef dcl ) ;

	/*!	@function SetDCLStatusPtr
		@abstract Set the status pointer for a NuDCL
		@discussion Setting a the status pointer for a NuDCL causes the packet transmit/receive hardware status to be recorded when the DCL executes. 
			This DCL must be updated after it has executed for the status to be valid. 
			
			This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()

			Status values are as follows: (from the OHCI spec, section 3.1.1)
			
			<dfn><table bgcolor="#EBEBEB">
				<tr>
					<td><b>5'h00</b></td> <td>No event status. </td>
				</tr>
				<tr>
					<td><b>5'h02</b></td> <td>evt_long_packet (receive)</td> <td>The received data length was greater than the buffer's data_length. </td>
				</tr>
				<tr>
					<td><b>5'h05</b></td> <td>evt_overrun (receive)</td> <td>A receive FIFO overflowed during the reception of an isochronous packet. </td>
				</tr>
				<tr>
					<td><b>5'h06</b></td> <td>evt_descriptor_read (receive/transmit)</td> <td>An unrecoverable error occurred while the Host Controller was reading a descriptor  block. </td>
				</tr>
				<tr>
					<td><b>5'h07</b></td> <td>evt_data_read (transmit)</td> <td>An error occurred while the Host Controller was attempting to read from host memory  in the data stage of descriptor processing. </td>
				</tr>
				<tr>
					<td><b>5'h08</b></td> <td>evt_data_write (receive/transmit)</td> <td>An error occurred while the Host Controller was attempting to write to host memory  either in the data stage of descriptor processing (AR, IR), or when processing a single  16-bit host memory write (IT). </td>
				</tr>
				<tr>
					<td><b>5'h0A</b></td> <td>evt_timeout (transmit)</td> <td>Indicates that the asynchronous transmit response packet expired and was not  transmitted, or that an IT DMA context experienced a skip processing overflow (See  section9.3.4). </td>
				</tr>
				<tr>
					<td><b>5'h0B</b></td> <td>evt_tcode_err (transmit)</td> <td>A bad tCode is associated with this packet. The packet was flushed. </td>
				</tr>
				<tr>
					<td><b>5'h0E</b></td> <td>evt_unknown (receive/transmit)</td> <td>An error condition has occurred that cannot be represented by any other event codes defined herein. </td>
				</tr>
				<tr>
					<td><b>5'h11</b></td> <td>ack_complete (receive/transmit)</td> <td>No event occurred. (Success)</td>
				</tr>
				<tr>
					<td><b>5'h1D</b></td> <td>ack_data_error (receive)</td> <td>A data field CRC or data_length error.</td>
				</tr>
			</table>
			</dfn>
			
			Applies: Any NuDCLRef.

		@param dcl The DCL for which status pointer will be set
		@param statusPtr A pointer to a quadlet which will hold the status after 'dcl' is updated.
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLStatusPtr)( NuDCLRef dcl, UInt32* statusPtr ) ;

	/*!	@function GetDCLStatusPtr
		@abstract Get the status pointer for a NuDCL.
		@discussion Applies: Any NuDCLRef.
		@param dcl The DCL whose status pointer will be returned.
		@result Returns a UInt32 status pointer.*/
	UInt32*				(*GetDCLStatusPtr)( NuDCLRef dcl ) ;
	

	/*!	@function AppendDCLRanges
		@abstract Add a memory range to the scatter gather list of a NuDCL
		@discussion This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()
		
			Applies: NuDCLSendPacketRef, NuDCLReceivePacketRef

		@param dcl The DCL to modify
		@param range A IOVirtualRange to add to this DCL buffer list. Do not pass NULL.
		@result Returns an IOReturn error code.*/
	IOReturn			(*AppendDCLRanges)			( NuDCLRef dcl, UInt32 numRanges, IOVirtualRange* range ) ;

	/*!	@function SetDCLRanges
		@abstract Set the scatter gather list for a NuDCL
		@discussion Set the list of data buffers for a DCL. Setting too many ranges may result in a memory region
			with too many discontinous physical segments for the hardware to send or receive in a single packet.
			This will result in an error when the program is compiled.

			This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()

			Applies: NuDCLSendPacketRef, NuDCLReceivePacketRef

		@param dcl The DCL to modify
		@param numRanges number of ranges in 'ranges'.
		@param ranges An array of virtual ranges
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLRanges)				( NuDCLRef dcl, UInt32 numRanges, IOVirtualRange* ranges ) ;

	IOReturn			(*SetDCLRanges_v)			( NuDCLRef dcl, IOVirtualRange* firstRange, ... ) ;
	
	/*!	@function GetDCLRanges
		@abstract Get the scatter-gather list for a NuDCL
		@discussion 

			Applies: NuDCLSendPacketRef, NuDCLReceivePacketRef

		@param dcl The DCL to query
		@param maxRanges Description forthcoming.
		@param outRanges Description forthcoming.
		@result Returns the previously set handler or NULL is no handler was set.*/
	UInt32				(*GetDCLRanges)				( NuDCLRef dcl, UInt32 maxRanges, IOVirtualRange* outRanges ) ;

	/*!	@function CountDCLRanges
		@abstract Returns number of buffers for a NuDCL
		@discussion 

			Applies: NuDCLSendPacketRef, NuDCLReceivePacket

		@param dcl The DCL to query
		@result Returns number of ranges in DCLs scatter-gather list*/
	UInt32				(*CountDCLRanges)			( NuDCLRef dcl ) ;

	/*!	@function GetDCLSpan
		@abstract Returns a virtual range spanning lowest referenced buffer address to highest
		@discussion 

			Applies: NuDCLSendPacketRef, NuDCLReceivePacket

		@param dcl The DCL to query
		@result Returns an IOVirtualRange.*/
	IOReturn			(*GetDCLSpan)				( NuDCLRef dcl, IOVirtualRange* spanRange ) ;

	/*!	@function GetDCLSize
		@abstract Returns number of bytes to be transferred by a NuDCL
		@discussion 

			Applies: NuDCLSendPacketRef, NuDCLReceivePacket

		@param dcl The DCL to query
		@result Returns an IOByteCount.*/
	IOByteCount			(*GetDCLSize)				( NuDCLRef dcl ) ;

	/*!	@function SetDCLCallback
		@abstract Set the callback for a NuDCL
		@discussion A callback can be called each time a NuDCL is run. Use SetDCLCallback() to set the
			callback for a NuDCL. If the update option is also set, the callback will be called after the update
			has run.

			This change will apply immediately to a non-running DCL program. To apply the change to a running program
			use IOFireWireLocalIsochPortInterface::Notify()

			Applies: Any NuDCLRef
		
		@param dcl The DCL to modify
		@param callback The callback function.
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLCallback)				( NuDCLRef dcl, NuDCLCallback callback ) ;

	/*!	@function GetDCLCallback
		@abstract Get callback for a NuDCL
		@discussion Returns the callback function for a DCL

			Applies: Any NuDCLRef

		@param dcl The DCL to query
		@result Returns the DCLs callback function or NULL if none is set.*/
	NuDCLCallback		(*GetDCLCallback)( NuDCLRef dcl ) ;

	/*!	@function SetDCLUserHeaderPtr
		@abstract Set a user specified header for a send NuDCL
		@discussion Allows the client to create a custom header for a transmitted isochronous packet. The header is masked with 'mask', 
			and the FireWire system software fills in the masked out bits.
			
			This change will apply immediately to a non-running DCL program. 
			An update must be run on the DCL for changes to take effect in a running program.

			Applies: NuDCLSendPacketRef
		
		@param dcl The DCL to modify
		@param headerPtr A pointer to a two-quadlet header. See section 9.6 of the the OHCI specification. 
		@param mask A pointer to a two-quadlet mask. The quadlets in headerPtr are masked with 'mask' and the masked-out bits
			are replaced by the FireWire system software.
		@result Returns an IOReturn error code.*/
	IOReturn			(*SetDCLUserHeaderPtr)( NuDCLRef dcl, UInt32 * headerPtr, UInt32 * mask ) ;

	/*! Description forthcoming */
	UInt32 *			(*GetDCLUserHeaderPtr)( NuDCLRef dcl ) ;

	/*! Description forthcoming */
	UInt32 *			(*GetUserHeaderMaskPtr)( NuDCLRef dcl ) ;
	
	/*! Description forthcoming */
	void				(*SetDCLRefcon)( NuDCLRef dcl, void* refcon ) ;
	/*! Description forthcoming */
	void*				(*GetDCLRefcon)( NuDCLRef dcl ) ;
	
	/*! Description forthcoming */
	IOReturn			(*AppendDCLUpdateList)( NuDCLRef dcl, NuDCLRef updateDCL ) ;

	// consumes a reference on dclList..
	/*! Description forthcoming */
	IOReturn			(*SetDCLUpdateList)( NuDCLRef dcl, CFSetRef dclList ) ;
	/*! Description forthcoming */
	CFSetRef			(*CopyDCLUpdateList)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*RemoveDCLUpdateList)( NuDCLRef dcl ) ;
	
	/*! Description forthcoming */
	IOReturn			(*SetDCLWaitControl)( NuDCLRef dcl, Boolean wait ) ;
	
	/*! Description forthcoming */
	void				(*SetDCLFlags)( NuDCLRef dcl, UInt32 flags ) ;
	/*! Description forthcoming */
	UInt32				(*GetDCLFlags)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*SetDCLSkipBranch)( NuDCLRef dcl, NuDCLRef skipCycleDCL ) ;
	/*! Description forthcoming */
	NuDCLRef			(*GetDCLSkipBranch)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*SetDCLSkipCallback)( NuDCLRef dcl, NuDCLCallback callback ) ;
	/*! Description forthcoming */
	NuDCLCallback		(*GetDCLSkipCallback)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*SetDCLSkipRefcon)( NuDCLRef dcl, void * refcon ) ;
	/*! Description forthcoming */
	void *				(*GetDCLSkipRefcon)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*SetDCLSyncBits)( NuDCLRef dcl, UInt8 syncBits ) ;
	/*! Description forthcoming */
	UInt8				(*GetDCLSyncBits)( NuDCLRef dcl ) ;
	/*! Description forthcoming */
	IOReturn			(*SetDCLTagBits)( NuDCLRef dcl, UInt8 tagBits ) ;
	/*! Description forthcoming */
	UInt8				(*GetDCLTagBits)( NuDCLRef dcl ) ;

} IOFireWireNuDCLPoolInterface ;

#pragma mark -
#pragma mark ASYNCSTREAM LISTENER INTERFACE
// ============================================================
// IOFWAsyncStreamListener Interface
// ============================================================

/*!	@class
	@discussion Represents and provides management functions for a asyn stream listener object.
*/
typedef struct IOFWAsyncStreamListenerInterface_t
{
	IUNKNOWN_C_GUTS ;

	/*! Interface version. */
	UInt16 version;
	/*! Interface revision. */
	UInt16 revision;

	/*!	@function SetListenerHandler
		@abstract Set the callback that should be called to handle incoming async stream packets
		@param self The async stream interface to use.
		@param inReceiver The callback to set.
		@result Returns the callback that was previously set or nil for none.*/
	const IOFWAsyncStreamListenerHandler (*SetListenerHandler)( IOFWAsyncStreamListenerInterfaceRef self, IOFWAsyncStreamListenerHandler inReceiver) ;

	/*!	@function SetSkippedPacketHandler
		@abstract Set the callback that should be called when incoming packets are
			dropped by the address space.
		@param self The address space interface to use.
		@param inHandler The callback to set.
		@result Returns the callback that was previously set or nil for none.*/
	const IOFWAsyncStreamListenerSkippedPacketHandler (*SetSkippedPacketHandler)( IOFWAsyncStreamListenerInterfaceRef self, IOFWAsyncStreamListenerSkippedPacketHandler inHandler) ;

	/*!	@function NotificationIsOn
		@abstract Is notification on?
		@param self The async stream interface to use.
		@result Returns true if packet notifications for this channel are active */
	Boolean (*NotificationIsOn)(IOFWAsyncStreamListenerInterfaceRef self) ;

	/*!	@function TurnOnNotification
		@abstract Try to turn on packet notifications for this channel.
		@param self The async stream interface to use.
		@result Returns true upon success */
	Boolean (*TurnOnNotification)(IOFWAsyncStreamListenerInterfaceRef self) ;

	/*!	@function TurnOffNotification
		@abstract Force packet notification off.
		@param self The async stream interface to use. */
	void (*TurnOffNotification)(IOFWAsyncStreamListenerInterfaceRef self) ;	

	/*!	@function ClientCommandIsComplete
		@abstract Notify the async stream object that a packet notification handler has completed.
		@discussion Packet notifications are received one at a time, in order. This function
			must be called after a packet handler has completed its work.
		@param self The async stream interface to use.
		@param commandID The ID of the packet notification being completed. This is the same
			ID that was passed when a packet notification handler is called.
		@param status The completion status of the packet handler */
	void (*ClientCommandIsComplete)(IOFWAsyncStreamListenerInterfaceRef self, FWClientCommandID commandID, IOReturn status) ;

	// --- accessors ----------
	
	/*!	@function GetRefCon
		@abstract Returns the user refCon value for this async stream interface.
		@param self The async stream interface to use.
		@result returns the callback object.*/
	void* (*GetRefCon)(IOFWAsyncStreamListenerInterfaceRef self) ;

	/*!	@function SetFlags
		@abstract set flags for the listener.
		@param self The async stream interface to use.
		@param flags indicate performance metrics.
		@result none.	*/	
	void (*SetFlags)( IOFWAsyncStreamListenerInterfaceRef self, UInt32 flags );
		
	/*!	@function GetFlags
		@abstract get the flags of listener.
		@param self The async stream interface to use.
		@result flags.	*/	
	UInt32 (*GetFlags)(IOFWAsyncStreamListenerInterfaceRef self);
	
	
	/*!	@function GetOverrunCounter
		@abstract get overrun counter from the DCL program.
		@param self The async stream interface to use.
		@result returns the counter value.	*/	
	UInt32 (*GetOverrunCounter)(IOFWAsyncStreamListenerInterfaceRef self);

} IOFWAsyncStreamListenerInterface ;

#endif //__IOFireWireLibIsoch_H__
                                                                                                                                                                                     graphics/                                                                                           0040755 0001750 0001750 00000000000 12612224741 032377  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOAccelClientConnect.h                                                                              0100644 0001750 0001750 00000002477 12567452457 036507  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_CLIENT_CONNECT_H
#define _IOACCEL_CLIENT_CONNECT_H


/*
** The IOAccelerator service name
*/
#define kIOAcceleratorClassName "IOAccelerator"


/*
** IOAccelerator public client types.  Private client types start with
** kIOAccelNumClientTypes.
*/
enum eIOAcceleratorClientTypes {
        kIOAccelSurfaceClientType,
        kIOAccelNumClientTypes
};


#endif /* _IOACCEL_CLIENT_CONNECT_H */

                                                                                                                                                                                                 IOAccelSurfaceConnect.h                                                                             0100644 0001750 0001750 00000013722 12567452457 036654  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_SURFACE_CONNECT_H
#define _IOACCEL_SURFACE_CONNECT_H

#include <IOKit/graphics/IOAccelTypes.h>
#include <IOKit/graphics/IOAccelClientConnect.h>

/*
** Surface visible region in device coordinates.
**
** num_rects:   The number of rectangles in the rect array.  If num_rects
**              is zero the bounds rectangle is used for the visible rectangle.
**              If num_rects is zero the surface must be completely contained
**              by the device.
**
** bounds:      The unclipped surface rectangle in device coords.  Extends
**              beyond the device bounds if the surface is not totally on
**              the device.
**
** rect[]:      An array of visible rectangles in device coords.  If num_rects
**              is non-zero only the region described by these rectangles is
**              copied to the frame buffer during a flush operation.
*/
typedef struct
{
        UInt32        num_rects;
        IOAccelBounds bounds;
        IOAccelBounds rect[0];
} IOAccelDeviceRegion;


/*
** Determine the size of a region.
*/
#define IOACCEL_SIZEOF_DEVICE_REGION(_rgn_) (sizeof(IOAccelDeviceRegion) + (_rgn_)->num_rects * sizeof(IOAccelBounds))


/*
** Surface client public memory types.  Private memory types start with
** kIOAccelNumSurfaceMemoryTypes.
*/
enum eIOAccelSurfaceMemoryTypes {
        kIOAccelNumSurfaceMemoryTypes
};


/*
** Surface client public methods.  Private methods start with
** kIOAccelNumSurfaceMethods.
*/
enum eIOAccelSurfaceMethods {
        kIOAccelSurfaceReadLockOptions,
        kIOAccelSurfaceReadUnlockOptions,
        kIOAccelSurfaceGetState,
        kIOAccelSurfaceWriteLockOptions,
        kIOAccelSurfaceWriteUnlockOptions,
        kIOAccelSurfaceRead,
        kIOAccelSurfaceSetShapeBacking,

        kIOAccelSurfaceSetIDMode,
        kIOAccelSurfaceSetScale,

        kIOAccelSurfaceSetShape,
        kIOAccelSurfaceFlush,

        kIOAccelSurfaceQueryLock,

        kIOAccelSurfaceReadLock,
        kIOAccelSurfaceReadUnlock,
        kIOAccelSurfaceWriteLock,
        kIOAccelSurfaceWriteUnlock,

        kIOAccelSurfaceControl,
        kIOAccelSurfaceSetShapeBackingAndLength,

        kIOAccelNumSurfaceMethods
};


/*
** Option bits for IOAccelCreateSurface and the kIOAccelSurfaceSetIDMode method.
** The color depth field can take any value of the _CGSDepth enumeration.
*/
typedef enum {
        kIOAccelSurfaceModeColorDepth1555  = 0x00000003,  
        kIOAccelSurfaceModeColorDepth8888  = 0x00000004,  
//      kIOAccelSurfaceModeColorDepthRGB565 = 0x00000005,  
        kIOAccelSurfaceModeColorDepthYUV   = 0x00000006,
        kIOAccelSurfaceModeColorDepthYUV9  = 0x00000007,
        kIOAccelSurfaceModeColorDepthYUV12 = 0x00000008,
        kIOAccelSurfaceModeColorDepthYUV2  = 0x00000009,
        kIOAccelSurfaceModeColorDepthBGRA32 = 0x0000000A,

//      kIOAccelSurfaceModeColorDepthRGBA64       = 0x0000000B,
//      kIOAccelSurfaceModeColorDepthRGBAFloat64  = 0x0000000C,
//      kIOAccelSurfaceModeColorDepthRGBAFloat128 = 0x0000000D,
        
//      kIOAccelSurfaceModeColorDepthYUV420  = 0x0000000E,
        kIOAccelSurfaceModeColorDepth2101010 = 0x0000000F,
        
        kIOAccelSurfaceModeColorDepthBits  = 0x0000000F,

        kIOAccelSurfaceModeStereoBit       = 0x00000010,
        kIOAccelSurfaceModeWindowedBit     = 0x00000020,

        kIOAccelSurfaceModeBeamSync        = 0x00008000
} eIOAccelSurfaceModeBits;


/*
** Options bits for IOAccelSetSurfaceShape and the kIOAccelSurfaceSetShape method.
*/
typedef enum {
        kIOAccelSurfaceShapeNone             = 0x00000000,
        kIOAccelSurfaceShapeNonBlockingBit   = 0x00000001,
        kIOAccelSurfaceShapeNonSimpleBit     = 0x00000002,
        kIOAccelSurfaceShapeIdentityScaleBit = 0x00000004,
        kIOAccelSurfaceShapeFrameSyncBit     = 0x00000008,
        kIOAccelSurfaceShapeBeamSyncBit      = 0x00000010,
        kIOAccelSurfaceShapeStaleBackingBit  = 0x00000020,
        kIOAccelSurfaceShapeAssemblyBit      = 0x00000040,
        kIOAccelSurfaceShapeWaitEnabledBit   = 0x00000080,

        /* wrong name, use kIOAccelSurfaceShapeNonBlockingBit */
        kIOAccelSurfaceShapeBlockingBit      = kIOAccelSurfaceShapeNonBlockingBit
} eIOAccelSurfaceShapeBits;

/*
** Return bits for the kIOAccelSurfaceGetState method.
*/
typedef enum {
        kIOAccelSurfaceStateNone    = 0x00000000,
        kIOAccelSurfaceStateIdleBit = 0x00000001
} eIOAccelSurfaceStateBits;

/*
** Option bits for the kIOAccelSurfaceSetScale method.
*/
typedef enum {
        kIOAccelSurfaceBeamSyncSwaps = 0x00000001,
        kIOAccelSurfaceFixedSource   = 0x00000002,

        kIOAccelSurfaceFiltering     = 0x000000f0,
        kIOAccelSurfaceFilterDefault = 0x00000000,
        kIOAccelSurfaceFilterNone    = 0x00000010,
        kIOAccelSurfaceFilterLinear  = 0x00000020

} eIOAccelSurfaceScaleBits;

/*
** Option bits for the kIOAccelSurfaceLock methods.
*/
typedef enum {
    kIOAccelSurfaceLockInBacking  = 0,
    kIOAccelSurfaceLockInAccel    = 1,
    kIOAccelSurfaceLockInDontCare = 2,
    kIOAccelSurfaceLockInMask     = 0x00000003
} eIOAccelSurfaceLockBits;

#endif /* _IOACCEL_SURFACE_CONNECT_H */

                                              IOAccelTypes.h                                                                                      0100644 0001750 0001750 00000004717 12567452457 035062  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOACCEL_TYPES_H
#define _IOACCEL_TYPES_H

#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>

#define IOACCEL_TYPES_REV       12

#if !defined(OSTYPES_K64_REV) && !defined(MAC_OS_X_VERSION_10_6)
#define IOACCELTYPES_10_5       1
#endif

/* Integer rectangle in device coordinates */
typedef struct
{
    SInt16      x;
    SInt16      y;
    SInt16      w;
    SInt16      h;
} IOAccelBounds;

typedef struct
{
    SInt16      w;
    SInt16      h;
} IOAccelSize;

/* Surface information */

enum {
    kIOAccelVolatileSurface     = 0x00000001
};

typedef struct
{
#if IOACCELTYPES_10_5
    vm_address_t        address[4];
#else
    mach_vm_address_t   address[4];
#endif /* IOACCELTYPES_10_5 */
    UInt32              rowBytes;
    UInt32              width;
    UInt32              height;
    UInt32              pixelFormat;
    IOOptionBits        flags;
    IOFixed             colorTemperature[4];
    UInt32              typeDependent[4];
} IOAccelSurfaceInformation;

typedef struct
{
#if IOACCELTYPES_10_5
        long x, y, w, h;
        void *client_addr;
        unsigned long client_row_bytes;
#else
        SInt32                    x, y, w, h;
        mach_vm_address_t client_addr;
        UInt32            client_row_bytes;
#endif /* IOACCELTYPES_10_5 */
} IOAccelSurfaceReadData;

typedef struct {
        IOAccelBounds   buffer;
        IOAccelSize     source;
        UInt32          reserved[8];
} IOAccelSurfaceScaling;


typedef SInt32 IOAccelID;

enum {
    kIOAccelPrivateID           = 0x00000001
};


#endif /* _IOACCEL_TYPES_H */

                                                 IOFramebufferShared.h                                                                               0100644 0001750 0001750 00000031743 12567452457 036400  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOFRAMEBUFFERSHARED_H
#define _IOKIT_IOFRAMEBUFFERSHARED_H

#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/graphics/IOGraphicsTypes.h>
#include <libkern/OSAtomic.h>

#ifdef __cplusplus
extern "C" {
#endif

/*! @header IOFramebufferShared
The IOFramebufferShared.h header contains definitions of objects and types shared between a kernel level IOFrameBuffer service and a non-kernel window server. In Mac OS X this structure is used by the CoreGraphics server and IOGraphics Family, and is not available to other clients. IOFramebuffer subclasses and IOFramebuffer clients within the kernel should also not rely on this structure definition and constants. It is public only for use on Darwin based window servers. Cursor and window server state data is exchanged by kernel and non-kernel tasks through a slice of shared memory containing a StdFBShmem_t structure.<br>
For a non-kernel task to get access to this slice of shared memory, a connection to an IOFramebuffer service must be made. A connection is made with the IOServiceOpen() function described in IOKitLib.h. A connection type of kIOFBServerConnectType or kIOFBSharedConnectType (for read-only access) should be specified. An io_connect_t handle is returned by IOServiceOpen(). This handle must be passed to IOFBCreateSharedCursor() to create the slice of shared memory. Then IOConnectMapMemory() may be called with a memory type of kIOFBCursorMemory to map the shared memory into the non-kernel task.
*/

#ifdef KERNEL
// CGS use optional
/*! @defined IOFB_ARBITRARY_SIZE_CURSOR
    @discussion When IOFB_ARBITRARY_SIZE_CURSOR is not defined, the maximum cursor size is assumed to be CURSORWIDTH x CURSORHEIGHT and this header file will define a number of structures for storing cursor images accordingly. A non-kernel task may define IOFB_ARBITRARY_SIZE_CURSOR and use cursors up to the size specified when IOFBCreateSharedCursor() was called. In this case appropriate structures for storing cursor images must be defined elsewhere. In the kernel, IOFB_ARBITRARY_SIZE_CURSOR is always defined.
*/
#define IOFB_ARBITRARY_SIZE_CURSOR
#define IOFB_ARBITRARY_FRAMES_CURSOR    1
#endif

#define IOFB_SUPPORTS_XOR_CURSOR
#define IOFB_SUPPORTS_HW_SHIELD
#define IOFB_SUPPORTS_ARBITRARY_FRAMES_CURSOR

//
// Cursor and Window Server state data, occupying a slice of shared memory
// between the kernel and WindowServer.
//
/*! @enum CursorParameters
    @constant kIOFBNumCursorFrames The number of cursor images stored in the StdFBShmem_t structure.
    @constant kIOFBNumCursorFramesShift Used with waiting cursors.
    @constant kIOFBMaxCursorDepth The maximum cursor pixel depth.
*/
enum {
#if IOFB_ARBITRARY_FRAMES_CURSOR
    kIOFBMainCursorIndex        = 0,
    kIOFBWaitCursorIndex        = 1,
    kIOFBNumCursorIndex         = 4,
#else
    kIOFBNumCursorFrames        = 4,
    kIOFBNumCursorFramesShift   = 2,
#endif
    kIOFBMaxCursorDepth         = 32
};

#ifndef IOFB_ARBITRARY_SIZE_CURSOR

/*! @defined CURSORWIDTH
    @discussion The maximum width of the cursor image in pixels. This is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
*/
#define CURSORWIDTH  16         /* width in pixels */

/*! @defined CURSORHEIGHT
    @discussion The maximum height of the cursor image in pixels. This is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
*/
#define CURSORHEIGHT 16         /* height in pixels */

/*! @struct bm12Cursor
    @abstract Cursor image for 1-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 1-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array contains the cursor images.
    @field mask This array contains the cursor mask.
    @field save This array stores the pixel values of the region underneath the cursor in its last drawn position.
*/
struct bm12Cursor {
    unsigned int image[4][16];
    unsigned int mask[4][16];
    unsigned int save[16];
};

/*! @struct bm18Cursor
    @abstract Cursor image for 8-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 8-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array contains cursor color values, which are converted to displayed colors through the color table. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel.
    @field mask This array contains the cursor alpha mask. The array is two dimensional with the same indexing as the image. If an alpha mask pixel is 0 and the corresponding image pixel is set to white for the display, then this cursor pixel will invert pixels on the display.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm18Cursor {
    unsigned char image[4][256];
    unsigned char mask[4][256];
    unsigned char save[256];
};

/*! @struct bm34Cursor
    @abstract Cursor image for 15-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 15-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. A value of 0 means the pixel is transparent. Non-zero values are stored with the red, green, blue, and alpha values encoded with the following masks:<BR>
    red mask = 0xF000<br>
    blue mask 0x0F00<br>
    green mask 0x00F0<br>
    alpha mask = 0x000F<br>
Note, only 4 bits are allocated for each color component.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm34Cursor {
    unsigned short image[4][256];
    unsigned short save[256];
};

/*! @struct bm38Cursor
    @abstract Cursor image for 24-bit cursor.
    @discussion This structure stores 16 pixel x 16 pixel cursors to be used with 24-bit color depth. This structure is only defined if IOFB_ARBITRARY_SIZE_CURSOR is not defined.
    @field image This array defines the cursor color values and transparency. The array is two dimensional and its first index is the cursor frame and the second index is the cursor pixel. The lower 24 bits of a pixel's value contain the RGB color, while the upper 8 bits contain the alpha value.
    @field save This array stores the color values of the region underneath the cursor in its last drawn position.
*/
struct bm38Cursor {
    unsigned int image[4][256];
    unsigned int save[256];
};

#endif /* IOFB_ARBITRARY_SIZE_CURSOR */

enum {
    kIOFBCursorImageNew         = 0x01,
    kIOFBCursorHWCapable        = 0x02
};
enum {
    kIOFBHardwareCursorActive   = 0x01,
    kIOFBHardwareCursorInVRAM   = 0x02
};

/*! @struct StdFBShmem_t
    @discussion This structure contains cursor and window server state data and occupies a slice of shared memory between the kernel and window server. Several elements of this structure are only used in software cursor mode. Unless otherwise indicated, the coordinates in this structure are given in display space. Display space is the coordinate space that encompasses all the screens. The positions of the screens within display space indicate their location relative to each other as the cursor moves between them. If there is only one screen, the screen coordinates and display space coordinates will be the same.
    @field cursorSema Semaphore lock for write access to the shared data in this structure.
    @field frame The current cursor frame index.
    @field cursorShow The cursor is displayed when cursorShow is 0.
    @field cursorObscured If this is true, the cursor has been obscured and cursorShow should not be 0. The cursor will be shown again the next time it is moved.
    @field shieldFlag When this is set to true the cursor will not be displayed in the region specified by shieldRect.
    @field shielded True if the cursor has been hidden because it entered the shielded region.
    @field saveRect The region that is saved underneath the cursor in software cursor mode.
    @field shieldRect The region that the cursor will not be displayed in if shieldFlag is true.
    @field cursorLoc The location of the cursor hot spot.
    @field cursorRect The region that the cursor image currently occupies in software cursor mode.
    @field oldCursorRect The region that the cursor image occupied the last time the cursor was drawn in software cursor mode.
    @field screenBounds The region that the current screen occupies.
    @field version Contains kIOFBCurrentShmemVersion so that a user client can ensure it is using the same version of this structure as the kernel.
    @field structSize Contains the size of this structure.
    @field vblTime The time of the most recent vertical blanking.
    @field vblDelta The interval between the two most recent vertical blankings.
    @field vblCount A running count of vertical blank interrupts.
    @field reservedC Reserved for future use.
    @field hardwareCursorCapable True if the hardware is capable of using hardware cursor mode.
    @field hardwareCursorActive True if currently using the hardware cursor mode.
    @field reservedB Reserved for future use.
    @field cursorSize This array contains the cursor sizes indexed by frame.
    @field hotSpot This array contains the location of the cursor hot spots indexed by frame. The hot spots coordinates are given relative to the top left corner of the cursor image.
    @field cursor A union of structures that define the cursor images. The structure used depends on the framebuffer's bit depth. These structures are defined above.
*/

struct StdFBShmem_t {
    OSSpinLock cursorSema;  
    int frame;
    char cursorShow;
    char cursorObscured;
    char shieldFlag;
    char shielded;
    IOGBounds saveRect;
    IOGBounds shieldRect;
    IOGPoint cursorLoc;
    IOGBounds cursorRect;
    IOGBounds oldCursorRect;
    IOGBounds screenBounds;
    int version;
    int structSize;
    AbsoluteTime vblTime;
    AbsoluteTime vblDelta;
    unsigned long long int vblCount;
#if IOFB_ARBITRARY_FRAMES_CURSOR
    unsigned long long int vblDrift;
    unsigned long long int vblDeltaMeasured;
    AbsoluteTime vblDeltaReal;
    unsigned int reservedC[22];
#else
    unsigned int reservedC[27];
    unsigned char hardwareCursorFlags[kIOFBNumCursorFrames];
#endif
    unsigned char hardwareCursorCapable;
    unsigned char hardwareCursorActive;
    unsigned char hardwareCursorShields;
    unsigned char reservedB[1];
#if IOFB_ARBITRARY_FRAMES_CURSOR
    IOGSize cursorSize[kIOFBNumCursorIndex];
    IOGPoint hotSpot[kIOFBNumCursorIndex];
#else
    IOGSize cursorSize[kIOFBNumCursorFrames];
    IOGPoint hotSpot[kIOFBNumCursorFrames];
#endif
#ifndef IOFB_ARBITRARY_SIZE_CURSOR
    union {
        struct bm12Cursor bw;
        struct bm18Cursor bw8;
        struct bm34Cursor rgb;
        struct bm38Cursor rgb24;
    } cursor;
#else  /* IOFB_ARBITRARY_SIZE_CURSOR */
    unsigned char cursor[0];
#endif /* IOFB_ARBITRARY_SIZE_CURSOR */
};
#ifndef __cplusplus
typedef volatile struct StdFBShmem_t StdFBShmem_t;
#endif


/*! @enum FramebufferConstants
    @constant kIOFBCurrentShmemVersion The current version of the slice of shared memory that contains the cursor and window server state data in the StdFBShmem_t structure.
    @constant kIOFBCursorMemory The memory type for IOConnectMapMemory() to get a slice of shared memory that contains the StdFBShmem_t structure.
*/
enum {
    // version for IOFBCreateSharedCursor
    kIOFBShmemVersionMask       = 0x000000ff,
    kIOFBTenPtOneShmemVersion   = 2,
    kIOFBTenPtTwoShmemVersion   = 3,
    kIOFBCurrentShmemVersion    = 2,

    // number of frames in animating cursor (if > kIOFBTenPtTwoShmemVersion)
    kIOFBShmemCursorNumFramesMask       = 0x00ff0000,
    kIOFBShmemCursorNumFramesShift      = 16,

    // memory types for IOConnectMapMemory.
    kIOFBCursorMemory           = 100
};

/*! @defined IOFRAMEBUFFER_CONFORMSTO
    @discussion The class name of the framebuffer service.
*/
#define IOFRAMEBUFFER_CONFORMSTO        "IOFramebuffer"

#ifdef __cplusplus
}
#endif

#endif /* ! _IOKIT_IOFRAMEBUFFERSHARED_H */
                             IOGraphicsEngine.h                                                                                  0100644 0001750 0001750 00000003037 12567452457 035706  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1998 Apple Computer, Inc.  All rights reserved. 
 *
 * HISTORY
 *
 * 10 Mar 99 sdouglas created.
 */


struct IOGraphicsEngineContext {
    OSSpinLock          contextLock;
    IOOptionBits        state;
    void *              owner;
    UInt32              version;
    IOByteCount         structSize;
    UInt32              reserved[ 8 ];
};
#ifndef __cplusplus
typedef volatile struct IOGraphicsEngineContext IOGraphicsEngineContext;
#endif

enum {
    // memory type for IOMapMemory
    kIOGraphicsEngineContext            = 100
};

enum {
    // version
    kIOGraphicsEngineContextVersion     = 1
};
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOGraphicsInterface.h                                                                               0100644 0001750 0001750 00000013000 12567452457 036370  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1999-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSINTERFACE_H
#define _IOKIT_IOGRAPHICSINTERFACE_H

#ifdef KERNEL
#define NO_CFPLUGIN     1
#endif

#ifndef NO_CFPLUGIN
#include <IOKit/IOCFPlugIn.h>
#endif /* ! NO_CFPLUGIN */

#define IOGA_COMPAT     1

#include <IOKit/graphics/IOGraphicsInterfaceTypes.h>

#define kIOGraphicsAcceleratorTypeID                    \
        (CFUUIDGetConstantUUIDWithBytes(NULL,           \
                                0xAC, 0xCF, 0x00, 0x00, \
                                0x00, 0x00,             \
                                0x00, 0x00,             \
                                0x00, 0x00,             \
                                0x00, 0x0a, 0x27, 0x89, 0x90, 0x4e))

// IOGraphicsAcceleratorType objects must implement the
// IOGraphicsAcceleratorInterface

#define kIOGraphicsAcceleratorInterfaceID               \
        (CFUUIDGetConstantUUIDWithBytes(NULL,           \
                                0x67, 0x66, 0xE9, 0x4A, \
                                0x00, 0x00,             \
                                0x00, 0x00,             \
                                0x00, 0x00,             \
                                0x00, 0x0a, 0x27, 0x89, 0x90, 0x4e))

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

typedef
IOReturn (*IOBlitAccumulatePtr)(void *thisPointer,
                                SInt32 a, SInt32 b, SInt32 c,
                                SInt32 d, SInt32 e, SInt32 f );

#ifdef IOGA_COMPAT
typedef
IOReturn (*IOBlitProcPtr)(void *thisPointer,
                          IOOptionBits options,
                          IOBlitType type, IOBlitSourceDestType sourceDestType,
                          IOBlitOperation * operation,
                          void * source, void * destination,
                          IOBlitCompletionToken * completionToken );
#endif

typedef
IOReturn (*IOBlitterPtr)(void *thisPointer,
                          IOOptionBits options,
                          IOBlitType type, IOBlitSourceType sourceType,
                          IOBlitOperation * operation,
                          void * source );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef NO_CFPLUGIN

typedef struct IOGraphicsAcceleratorInterfaceStruct {
    IUNKNOWN_C_GUTS;
    IOCFPLUGINBASE;
    
    IOReturn (*Reset)
        (void *thisPointer, IOOptionBits options);
    IOReturn (*CopyCapabilities)
        (void *thisPointer, FourCharCode select, CFTypeRef * capabilities);
#ifdef IOGA_COMPAT
    IOReturn (*GetBlitProc)
        (void *thisPointer, IOOptionBits options,
         IOBlitType type, IOBlitSourceDestType sourceDestType,
         IOBlitProcPtr * blitProc );
#else
    void * __gaInterfaceReserved0;
#endif

    IOReturn (*Flush)
        (void *thisPointer, IOOptionBits options);
#ifdef IOGA_COMPAT
    IOReturn (*WaitForCompletion)
        (void *thisPointer, IOOptionBits options,
         IOBlitCompletionToken completionToken);
#else
    void * __gaInterfaceReserved1;
#endif
    IOReturn (*Synchronize)
        (void *thisPointer, UInt32 options,
         UInt32 x, UInt32 y, UInt32 w, UInt32 h );
    IOReturn (*GetBeamPosition)
        (void *thisPointer, IOOptionBits options, SInt32 * position);
    IOReturn (*AllocateSurface)
        (void *thisPointer, IOOptionBits options,
         IOBlitSurface * surface, void * cgsSurfaceID );
    IOReturn (*FreeSurface)
        (void *thisPointer, IOOptionBits options, IOBlitSurface * surface);
    IOReturn (*LockSurface)
        (void *thisPointer, IOOptionBits options, IOBlitSurface * surface,
         vm_address_t * address );
    IOReturn (*UnlockSurface)
        (void *thisPointer, IOOptionBits options, IOBlitSurface * surface,
         IOOptionBits * swapFlags);
    IOReturn (*SwapSurface)
        (void *thisPointer, IOOptionBits options,
         IOBlitSurface * surface, IOOptionBits * swapFlags);

    IOReturn (*SetDestination)
        (void *thisPointer, IOOptionBits options, IOBlitSurface * surface );

    IOReturn (*GetBlitter)
        (void *thisPointer, IOOptionBits options,
         IOBlitType type, IOBlitSourceType sourceType,
         IOBlitterPtr * blitter );
    IOReturn (*WaitComplete)
        (void *thisPointer, IOOptionBits options);

    void * __gaInterfaceReserved[ 24 ];

} IOGraphicsAcceleratorInterface;

#endif /* ! NO_CFPLUGIN */

/* Helper function for plugin use */
IOReturn IOAccelFindAccelerator( io_service_t framebuffer,
                                 io_service_t * pAccelerator, UInt32 * pFramebufferIndex );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* !_IOKIT_IOGRAPHICSINTERFACE_H */
IOGraphicsInterfaceTypes.h                                                                          0100644 0001750 0001750 00000024765 12567452457 037441  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1999-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSINTERFACETYPES_H
#define _IOKIT_IOGRAPHICSINTERFACETYPES_H

#include <IOKit/graphics/IOAccelSurfaceConnect.h>

#define IO_FOUR_CHAR_CODE(x)    (x)

typedef UInt32 IOFourCharCode;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define kCurrentGraphicsInterfaceVersion        1
#define kCurrentGraphicsInterfaceRevision       2


#ifdef IOGA_COMPAT
typedef SInt32          IOBlitCompletionToken;
#endif

typedef UInt32          IOBlitType;
enum {
    kIOBlitTypeVerbMask                 = 0x000000ff,
    kIOBlitTypeRects                    = 0,
    kIOBlitTypeCopyRects,
    kIOBlitTypeLines,
    kIOBlitTypeScanlines,
    kIOBlitTypeCopyRegion,

    kIOBlitTypeMoveCursor,
    kIOBlitTypeShowCursor,
    kIOBlitTypeHideCursor,

    kIOBlitTypeMonoExpand               = 0x00000100,
    kIOBlitTypeColorSpaceConvert        = 0x00000200,
    kIOBlitTypeScale                    = 0x00000400,

    kIOBlitTypeSourceKeyColorModeMask   = 0x00003000,
    kIOBlitTypeDestKeyColorModeMask     = 0x0000c000,
    kIOBlitTypeSourceKeyColorEqual      = 0x00001000,
    kIOBlitTypeSourceKeyColorNotEqual   = 0x00002000,
    kIOBlitTypeDestKeyColorEqual        = 0x00004000,
    kIOBlitTypeDestKeyColorNotEqual     = 0x00008000,

    kIOBlitTypeOperationMask            = 0x0fff0000,
    kIOBlitTypeOperationShift           = 16,
    kIOBlitTypeOperationTypeMask        = 0x0f000000,

    kIOBlitTypeOperationType0           = 0x00000000,
    kIOBlitCopyOperation                = 0x00000000 | kIOBlitTypeOperationType0,
    kIOBlitOrOperation                  = 0x00010000 | kIOBlitTypeOperationType0,
    kIOBlitXorOperation                 = 0x00020000 | kIOBlitTypeOperationType0,
    kIOBlitBlendOperation               = 0x00030000 | kIOBlitTypeOperationType0,
    kIOBlitHighlightOperation           = 0x00040000 | kIOBlitTypeOperationType0
};

typedef UInt32          IOBlitSourceType;
enum {
    kIOBlitSourceDefault                = 0x00000000,
    kIOBlitSourceFramebuffer            = 0x00001000,
    kIOBlitSourceMemory                 = 0x00002000,
    kIOBlitSourceOOLMemory              = 0x00003000,
    kIOBlitSourcePattern                = 0x00004000,
    kIOBlitSourceOOLPattern             = 0x00005000,
    kIOBlitSourceSolid                  = 0x00006000,
    kIOBlitSourceCGSSurface             = 0x00007000,
    kIOBlitSourceIsSame                 = 0x80000000
};

#ifdef IOGA_COMPAT
typedef IOBlitSourceType        IOBlitSourceDestType;
enum {
    kIOBlitDestFramebuffer              = 0x00000001
};
#endif

typedef struct IOBlitOperationStruct {
    UInt32              color0;
    UInt32              color1;
    SInt32              offsetX;
    SInt32              offsetY;
    UInt32              sourceKeyColor;
    UInt32              destKeyColor;
    UInt32              specific[16];
} IOBlitOperation;

typedef struct IOBlitRectangleStruct {
    SInt32              x;
    SInt32              y;
    SInt32              width;
    SInt32              height;
} IOBlitRectangle;

typedef struct IOBlitRectanglesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitRectangle     rects[1];
} IOBlitRectangles;

typedef struct IOBlitCopyRectangleStruct {
    SInt32              sourceX;
    SInt32              sourceY;
    SInt32              x;
    SInt32              y;
    SInt32              width;
    SInt32              height;
} IOBlitCopyRectangle;

typedef struct IOBlitCopyRectanglesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitCopyRectangle rects[1];
} IOBlitCopyRectangles;


typedef struct IOBlitCopyRegionStruct {
    IOBlitOperation       operation;
    SInt32                deltaX;
    SInt32                deltaY;
    IOAccelDeviceRegion * region;
} IOBlitCopyRegion;


typedef struct IOBlitVertexStruct {
    SInt32              x;
    SInt32              y;
} IOBlitVertex;

typedef struct IOBlitVerticesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    IOBlitVertex        vertices[2];
} IOBlitVertices;

typedef struct IOBlitScanlinesStruct {
    IOBlitOperation     operation;
    IOItemCount         count;
    SInt32              y;
    SInt32              height;
    SInt32              x[2];
} IOBlitScanlines;


typedef struct IOBlitCursorStruct {
    IOBlitOperation     operation;
    IOBlitRectangle     rect;
} IOBlitCursor;

typedef struct _IOBlitMemory * IOBlitMemoryRef;


/* Quickdraw.h pixel formats*/

enum {
        kIO1MonochromePixelFormat       = 0x00000001,           /* 1 bit indexed*/
        kIO2IndexedPixelFormat          = 0x00000002,           /* 2 bit indexed*/
        kIO4IndexedPixelFormat          = 0x00000004,           /* 4 bit indexed*/
        kIO8IndexedPixelFormat          = 0x00000008,           /* 8 bit indexed*/
        kIO16BE555PixelFormat           = 0x00000010,           /* 16 bit BE rgb 555 (Mac)*/
        kIO24RGBPixelFormat             = 0x00000018,           /* 24 bit rgb */
        kIO32ARGBPixelFormat            = 0x00000020,           /* 32 bit argb  (Mac)*/
        kIO1IndexedGrayPixelFormat      = 0x00000021,           /* 1 bit indexed gray*/
        kIO2IndexedGrayPixelFormat      = 0x00000022,           /* 2 bit indexed gray*/
        kIO4IndexedGrayPixelFormat      = 0x00000024,           /* 4 bit indexed gray*/
        kIO8IndexedGrayPixelFormat      = 0x00000028            /* 8 bit indexed gray*/
};

enum {
        kIO16LE555PixelFormat   = IO_FOUR_CHAR_CODE('L555'),    /* 16 bit LE rgb 555 (PC)*/
        kIO16LE5551PixelFormat  = IO_FOUR_CHAR_CODE('5551'),    /* 16 bit LE rgb 5551*/
        kIO16BE565PixelFormat   = IO_FOUR_CHAR_CODE('B565'),    /* 16 bit BE rgb 565*/
        kIO16LE565PixelFormat   = IO_FOUR_CHAR_CODE('L565'),    /* 16 bit LE rgb 565*/
        kIO24BGRPixelFormat     = IO_FOUR_CHAR_CODE('24BG'),    /* 24 bit bgr */
        kIO32BGRAPixelFormat    = IO_FOUR_CHAR_CODE('BGRA'),    /* 32 bit bgra  (Matrox)*/
        kIO32ABGRPixelFormat    = IO_FOUR_CHAR_CODE('ABGR'),    /* 32 bit abgr  */
        kIO32RGBAPixelFormat    = IO_FOUR_CHAR_CODE('RGBA'),    /* 32 bit rgba  */
        kIOYUVSPixelFormat      = IO_FOUR_CHAR_CODE('yuvs'),    /* YUV 4:2:2 byte ordering 16-unsigned = 'YUY2'*/
        kIOYUVUPixelFormat      = IO_FOUR_CHAR_CODE('yuvu'),    /* YUV 4:2:2 byte ordering 16-signed*/
        kIOYVU9PixelFormat      = IO_FOUR_CHAR_CODE('YVU9'),    /* YVU9 Planar  9*/
        kIOYUV411PixelFormat    = IO_FOUR_CHAR_CODE('Y411'),    /* YUV 4:1:1 Interleaved 16*/
        kIOYVYU422PixelFormat   = IO_FOUR_CHAR_CODE('YVYU'),    /* YVYU 4:2:2 byte ordering 16*/
        kIOUYVY422PixelFormat   = IO_FOUR_CHAR_CODE('UYVY'),    /* UYVY 4:2:2 byte ordering 16*/
        kIOYUV211PixelFormat    = IO_FOUR_CHAR_CODE('Y211'),    /* YUV 2:1:1 Packed     8*/
        kIO2vuyPixelFormat      = IO_FOUR_CHAR_CODE('2vuy') /* UYVY 4:2:2 byte ordering   16*/
};

/* Non Quickdraw.h pixel formats*/
enum {
        kIO16LE4444PixelFormat     = IO_FOUR_CHAR_CODE('L444'), /* 16 bit LE argb 4444*/
        kIO16BE4444PixelFormat     = IO_FOUR_CHAR_CODE('B444'), /* 16 bit BE argb 4444*/
        kIO64BGRAPixelFormat       = IO_FOUR_CHAR_CODE('B16I'), /* 64 bit bgra  */
        kIO64RGBAFloatPixelFormat  = IO_FOUR_CHAR_CODE('B16F'), /* 64 bit rgba  */
        kIO128RGBAFloatPixelFormat = IO_FOUR_CHAR_CODE('B32F')  /* 128 bit rgba float */
};

enum {
    kIOBlitMemoryRequiresHostFlush      = 0x00000001
};

typedef struct IOBlitSurfaceStruct {
    union {
        UInt8 *         bytes;
        IOBlitMemoryRef ref;
    }                   memory;
    IOFourCharCode      pixelFormat;
    IOBlitRectangle     size;
    UInt32              rowBytes;
    UInt32              byteOffset;
    UInt32 *            palette;
    IOOptionBits        accessFlags;
    IOBlitMemoryRef     interfaceRef;
    UInt32              more[14];
} IOBlitSurface;

typedef IOBlitSurface IOBlitMemory;


/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

enum {
    // options for Synchronize
    kIOBlitSynchronizeWaitBeamExit      = 0x00000001,
    kIOBlitSynchronizeFlushHostWrites   = 0x00000002
};

enum {
    // options for WaitComplete & Flush
    kIOBlitWaitContext                  = 0x00000000,
    kIOBlitWaitAll2D                    = 0x00000001,
    kIOBlitWaitGlobal                   = 0x00000001,
    kIOBlitWaitAll                      = 0x00000002,
    kIOBlitWaitCheck                    = 0x00000080,
    kIOBlitFlushWithSwap                = 0x00010000
};

enum {
    // options for AllocateSurface
    kIOBlitHasCGSSurface                = 0x00000001,
    kIOBlitFixedSource                  = 0x00000002,
    kIOBlitBeamSyncSwaps                = 0x00000004,
    kIOBlitReferenceSource              = 0x00000008
};

enum {
    // options for UnlockSurface
    kIOBlitUnlockWithSwap               = 0x80000000
};

enum {
    // options for SetDestination
    kIOBlitFramebufferDestination       = 0x00000000,
    kIOBlitSurfaceDestination           = 0x00000001
};



enum {
    // options for blit procs
    kIOBlitBeamSync                     = 0x00000001,
    kIOBlitBeamSyncAlways               = 0x00000002,
    kIOBlitBeamSyncSpin                 = 0x00000004,

    kIOBlitAllOptions                   = 0xffffffff
};

enum {
    // capabilities
    kIOBlitColorSpaceTypes              = IO_FOUR_CHAR_CODE('cspc')
};


// keys for IOAccelFindAccelerator()
#define kIOAccelTypesKey                        "IOAccelTypes"
#define kIOAccelIndexKey                        "IOAccelIndex"

#define kIOAccelRevisionKey                     "IOAccelRevision"

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* !_IOKIT_IOGRAPHICSINTERFACETYPES_H */
           IOGraphicsLib.h                                                                                     0100644 0001750 0001750 00000100060 12566177313 035173  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1999-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSLIB_H
#define _IOKIT_IOGRAPHICSLIB_H

#ifdef __cplusplus
extern "C" {
#endif

#include <IOKit/IOKitLib.h>
#include <IOKit/graphics/IOFramebufferShared.h>
#include <IOKit/graphics/IOGraphicsInterface.h>

/*! @header IOGraphicsLib
IOGraphicsLib implements non-kernel task access to IOGraphics family object types - IOFramebuffer and IOAccelerator. These functions implement a graphics family specific API.<br>
A connection to a graphics IOService must be made before these functions are called. A connection is made with the IOServiceOpen() function described in IOKitLib.h. An io_connect_t handle is returned by IOServiceOpen(), which must be passed to the IOGraphicsLib functions. The appropriate connection type from IOGraphicsTypes.h must be specified in the call to IOServiceOpen(). All of the IOFramebuffer functions can only be called from a kIOFBServerConnectType connection. Except as specified below, functions whose names begin with IOFB are IOFramebuffer functions. Functions whose names begin with IOPS are IOAccelerator functions and must be called from connections of type kIOFBEngineControllerConnectType or kIOFBEngineConnectType.<br>
The functions in IOGraphicsLib use a number of special types. The display mode is the screen's resolution and refresh rate. The known display modes are referred to by an index of type IODisplayModeID. The display depth is the number of significant color bits used in representing each pixel. Depths are also referred to by an index value that is 0 for 8 bits, 1 for 15 bits, and 2 for 24 bits. A combination of display mode and depth may have a number of supported pixel formats. The pixel aperture is an index of supported pixel formats for a display mode and depth. This index is of type IOPixelAperture. All of these graphics specific types are defined in IOGraphicsTypes.h.
*/
/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

extern kern_return_t
IOFramebufferOpen(
        io_service_t    service,
        task_port_t     owningTask,
        unsigned int    type,
        io_connect_t  * connect );

/*! @function IOFBCreateSharedCursor
    @abstract Create shared cursor memory.
    @discussion This function allocates memory, containing details about the cursor, that can be shared with a calling non-kernel task. The memory contains a StdFBShmem_t structure, which is defined in IOFrameBufferShared.h. This structure contains information on the cursor image, whether it is current shown, its location, etc. The allocated memory can be mapped to the non-kernel task's memory space by calling IOConnectMapMemory() and passing kIOFBCursorMemory for memoryType.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param version The version of cursor shared memory to use. For the current version, pass kIOFBCurrentShmemVersion.
    @param maxWidth The maximum width of the cursor.
    @param maxHeight The maximum height of the cursor.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBCreateSharedCursor( io_connect_t connect,
        unsigned int version,
        unsigned int maxWidth, unsigned int maxHeight );

/*! @function IOFBGetFramebufferInformationForAperture
    @abstract Get framebuffer information for a pixel format.
    @discussion This function returns framebuffer information for a pixel format that is supported for the current display mode and depth. The returned IOFrameBufferInformation structure contains details on the physical address of the framebuffer, height, width, etc. This structure is defined in IOGraphicsTypes.h.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param aperture The pixel aperture to retrieve information on. The pixel aperture is an index into supported pixel formats for a display mode and depth. To get information for the current aperture, use kIOFBSystemAperture.
    @param info A pointer to an IOFramebufferInformation structure where the information will be returned.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBGetFramebufferInformationForAperture( io_connect_t connect,
            IOPixelAperture               aperture,
            IOFramebufferInformation    * info );

/*! @function IOFBGetFramebufferOffsetForAperture
    @abstract Get the byte offset for a framebuffer's VRAM.
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param aperture The pixel aperture to retrieve information on. The pixel aperture is an index into supported pixel formats. To get information for the current aperture, use kIOFBSystemAperture.
    @param offset The number of bytes offset is returned on success.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBGetFramebufferOffsetForAperture( mach_port_t connect,
            IOPixelAperture               aperture,
            IOByteCount                 * offset );

/*! @function IOFBSetBounds
    @abstract Set the location of the framebuffer within display space.
    @discussion If there is more than one screen in use, the locations of the screens relative to each other must be specified. These locations are specified in a "display space" that encompasses all the screens. The bounding regions of the screens within display space indicate their location relative to each other as the cursor moves between them. This function sets the bounding region for a framebuffer within display space. If there is only one screen, this does not need to specified, because by default the screen coordinates and display space coordinates will be the same.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param rect An IOGBounds structure specifying a rectangular region of the framebuffer.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSetBounds( io_connect_t connect,
            IOGBounds   * rect );

/*!
 * @function IOFBSetVirtualBounds
 *
 * @abstract
 * Set the location of the framebuffer within display space and
 * within desktop space.
 *
 * @param connect       The connect handle from <code>IOServiceOpen</code>
 *                      to an IOFramebuffer service with a
 *                      <code>kIOFBServerConnectType</code> connection.
 * @param screenBounds  An <code>IOGBounds</code> structure specifying
 *                      a rectangular region of the framebuffer
 *                      in display space.
 * @param desktopBounds An <code>IOGBounds</code> structure specifying
 *                      a rectangular region of the framebuffer
 *                      in desktop space.
 * @result              A <code>kern_return_t</code> error code.
 *
 * @discussion
 * If there is more than one screen in use, the locations of the screens relative
 * to each other must be specified. Each physical screen will have a rectangular 
 * region of "display space" that it is responsible for showing. When the "display 
 * space" does not have a 1:1 mapping to the "desktop space" (e.g when using zooming, 
 * or HiDPI), this function is used to define how "desktop space" maps into "display 
 * space". Note that "desktop space" and "display space" should be contiguous, and 
 * the mapping between them should be functional (i.e. 1-to-1, though not necessarily 
 * contiguous).
 */
    
extern kern_return_t
IOFBSetVirtualBounds(io_connect_t connect,
                     IOGBounds   * screenBounds,
                     IOGBounds   * desktopBounds );
    
/*! @function IOFBGetCurrentDisplayModeAndDepth
    @abstract Get the current display mode and depth.
    @discussion The display mode index returned by this function can be used to determine information about the current display mode and its supported pixel formats through calls to IOFBGetDisplayModeInformation(), IOFBGetPixelFormats(), and IOFBGetPixelInformation().
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode The ID of the current display mode is returned.
    @param depth The current display depth is returned (0 = 8 bits, 1 = 15 bits, 2 = 24 bits)
    @result A kern_return_t error code. */

extern kern_return_t
IOFBGetCurrentDisplayModeAndDepth( io_connect_t connect,
        IODisplayModeID * displayMode,
        IOIndex         * depth );

/*! @function IOFBGetPixelFormat
    @abstract Get pixel format information.
    @discussion Displayed colors are encoded in framebuffer memory in a variety of ways. IOFBGetPixelFormat returns a pixel encoding array specifying how each bit of a particular pixel should be interpreted. The definition of the IOPixelEncoding array returned and common Apple pixel formats are described in IOGraphicsTypes.h.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode A display mode index.
    @param depth A display depth index.
    @param aperture The pixel aperture to retrieve the pixel format for. The pixel aperture is an index into supported pixel formats. To get information on the current aperture, use kIOFBSystemAperture.
    @param pixelFormat The returned pixel format.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBGetPixelFormat( io_connect_t connect,
        IODisplayModeID displayMode,
        IOIndex         depth,
        IOPixelAperture aperture,
        IOPixelEncoding * pixelFormat );

/*! @function IOFBSetCLUT
    @abstract Set the color table.
    @discussion Indexed pixel formats require a color table to convert from the index stored in a pixel memory location to a displayed color. IOFBSetCLUT sets one or more entries of the color table.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param startIndex The first index to set in the color table.
    @param numEntries The number of entries to set.
    @param options kSetCLUTByValue may be set to use the index member of the IOColorEntry structure to determine where the entry should be written to the color table. Otherwise the index is taken from the location in the IOColorEntry array. kSetClutImmediately may be set to change the color table immediately instead of waiting for vertical blanking interval. kSetClubWithLuminance may be set to use luminance rather than RGB entries.
    @param colors The array of color table entries to set. The IOColorEntry structure is defined in IOGraphicsTypes.h.
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSetCLUT( io_connect_t connect,
        UInt32          startIndex,
        UInt32          numEntries,
        IOOptionBits    options,
        IOColorEntry *  colors );

/*! @function IOFBSetGamma
    @abstract Set the gamma data.
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param channelCount
    @param dataCount
    @param dataWidth
    @param data
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSetGamma( io_connect_t connect,
        UInt32          channelCount,
        UInt32          dataCount,
        UInt32          dataWidth,
        void *          data );

/*! @function IOFBSet888To256Table
    @abstract [place holder]
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param table
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSet888To256Table( io_connect_t connect,
        const unsigned char *   table );

/*! @function IOFBSet256To888Table
    @abstract [place holder]
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param table
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSet256To888Table( io_connect_t connect,
        const unsigned int *    table );

/*! @function IOFBSet444To555Table
    @abstract [place holder]
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param table
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSet444To555Table( io_connect_t connect,
        const unsigned char *   table );

/*! @function IOFBSet555To444Table
    @abstract [place holder]
    @discussion [place holder]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param table
    @result A kern_return_t error code. */

extern kern_return_t
IOFBSet555To444Table( io_connect_t connect,
        const unsigned char *   table );

// Array of supported display modes

/*! @function IOFBGetDisplayModeCount
    @abstract Get the number of display modes.
    @discussion IOFBGetDisplayModeCount returns the number of display modes that the IOFramebuffer service is aware of.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param count The display mode count is returned.
    @result A kern_return_t error code. */

kern_return_t
IOFBGetDisplayModeCount( io_connect_t connect,
        UInt32 * count );

/*! @function IOFBGetDisplayModes
    @abstract Get an array of known display modes.
    @discussion This function returns an array containing the display modes that the framebuffer service is aware of. To get all display modes, pass the count from IOFBGetDisplayModeCount().
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param count The number of display modes to get.
    @param allDisplayModes An array of IODisplayModeID's with enough space for all entries. The array is filled in upon return.
    @result A kern_return_t error code. */

kern_return_t
IOFBGetDisplayModes( io_connect_t connect,
        UInt32                  count,
        IODisplayModeID *       allDisplayModes );

// Info about a display mode

/*! @function IOFBGetDisplayModeInformation
    @abstract Get information about a display mode.
    @discussion Display modes are referred to by their index of type IODisplayModeID. This function returns a structure containing the width, height, refresh rate, maximum depth, etc. of a display mode. The IODisplayModeInformation structure is defined in IOGraphicsTypes.h.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode The display mode index.
    @param info A pointer to an IODisplayModeInformation structure where the display mode information will be returned.
    @result A kern_return_t error code. */

kern_return_t
IOFBGetDisplayModeInformation( io_connect_t connect,
        IODisplayModeID         displayMode,
        IODisplayModeInformation * info );


// Mask of pixel formats available in mode and depth

/*! @function IOFBGetPixelFormats
    @abstract Get pixel formats that are supported for a display mode and depth.
    @discussion This function returns a mask of all supported pixel formats for a particular display mode and depth. [How should the mask be interpreted?]
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode A display mode index.
    @param depth A display depth index.
    @param mask The returned mask of pixel formats.
    @result A kern_return_t error code. */

kern_return_t
IOFBGetPixelFormats( io_connect_t connect,
        IODisplayModeID         displayMode,
        IOIndex                 depth,
        UInt32 *                mask );

/*! @function IOFBGetPixelInformation
    @abstract Get information about a pixel format.
    @discussion IOFBGetPixelInformation returns a structure containing information about a pixel format such as the bits per pixel, pixel format, etc. The IOPixelInformation structure is defined in IOGraphicsTypes.h.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode A display mode index.
    @param depth A display depth index.
    @param aperture A pixel aperture. The pixel aperture is an index into supported pixel formats for a display mode and depth. To get information on the current aperture, use kIOFBSystemAperture.
    @param pixelInfo A pointer to an IOPixelInformation structure where the pixel information will be returned.
    @result A kern_return_t error code. */

kern_return_t
IOFBGetPixelInformation( io_connect_t connect,
        IODisplayModeID         displayMode,
        IOIndex                 depth,
        IOPixelAperture         aperture,
        IOPixelInformation *    pixelInfo );

/*! @function IOFBSetDisplayModeAndDepth
    @abstract Set the current display mode and depth.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode The index of the new display mode.
    @param depth The index of the new depth.
    @result A kern_return_t error code. */

kern_return_t
IOFBSetDisplayModeAndDepth( io_connect_t connect,
        IODisplayModeID         displayMode,
        IOIndex                 depth );

/*! @function IOFBSetStartupDisplayModeAndDepth
    @abstract Set the display mode and depth to use on startup.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param displayMode The index of the new display mode.
    @param depth The index of the new depth.
    @result A kern_return_t error code. */

kern_return_t
IOFBSetStartupDisplayModeAndDepth( io_connect_t connect,
        IODisplayModeID         displayMode,
        IOIndex                 depth );

kern_return_t
IOFBGetDefaultDisplayMode( io_connect_t connect,
        IODisplayModeID * displayMode, IOIndex * displayDepth );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

struct IOFBMessageCallbacks {
    IOReturn (*WillPowerOff)          (void * callbackRef, void * notificationID);
    IOReturn (*DidPowerOn)            (void * callbackRef, void * notificationID);
    IOReturn (*ConnectionChange)      (void * callbackRef, void * notificationID);
    IOReturn (*WillPowerOffWithImages)(void * callbackRef, void * notificationID,
				       uint32_t            imageCount,
				       mach_vm_address_t * buffers,
				       mach_vm_size_t *    bufferSizes);
};
typedef struct IOFBMessageCallbacks IOFBMessageCallbacks;

#define IOFBMESSAGECALLBACKSVERSIONCURRENT 	2
enum {
    kIOFBMessageCallbacksVersionCurrent = IOFBMESSAGECALLBACKSVERSIONCURRENT,
    IOFBMessageCallbacksVersion         = kIOFBMessageCallbacksVersionCurrent,
};

mach_port_t
IOFBGetNotificationMachPort( io_connect_t connect );

kern_return_t
IOFBDispatchMessageNotification( io_connect_t connect, mach_msg_header_t * message,
                                 UInt32 version, const IOFBMessageCallbacks * callbacks, void * callbackRef);

kern_return_t
IOFBAcknowledgeNotification( void * notificationID );

enum {
    kIOFBConnectStateOnline     = 0x00000001,
    kIOFBConnectStateUnusable   = 0x00000002,
    kIOFBConnectStateHWOnline   = 0x00000004
};

kern_return_t
IOFBGetConnectState( io_connect_t connect, IOOptionBits * state );

kern_return_t
IOFBGetAttributeForFramebuffer( io_connect_t connect, io_connect_t otherConnect,
                                IOSelect attribute, UInt32 * value );
kern_return_t
IOFBSetAttributeForFramebuffer( io_connect_t connect, io_connect_t otherConnect,
                                IOSelect attribute, UInt32 value );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @function IOFBCreateDisplayModeDictionary
    @abstract Create a CFDictionary with information about a display mode.
    @discussion This function creates a dictionary containing information about a display mode. The display mode properties that are represented by the kernel as OSDictionary, OSArray, OSSet, OSSymbol, OSString, OSData, OSNumber, or OSBoolean are converted to their CF counterparts and put in the dictionary.
    @param framebuffer The IOService handle for an IOFramebuffer service.
    @param displayMode A display mode index.
    @result The returned CFDictionary that should be released by the caller with CFRelease(). */

CFDictionaryRef
IOFBCreateDisplayModeDictionary(
        io_service_t            framebuffer,
        IODisplayModeID         displayMode );

/*! @function IOFBGetPixelInfoDictionary
    @abstract Get a CFDictionary with information about a pixel format.
    @discussion This function extracts a CFDictionary containing information about a supported pixel format from a larger CFDictionary describing a display mode. IOFBCreateDisplayModeDictionary() must be called first to generate the CFDictionary for a display mode.
    @param modeDictionary The CFDictionary containing information about a display mode.
    @param depth A depth index.
    @param aperture The pixel aperture to information about. The pixel aperture is an index into supported pixel formats. To get information on the current aperture, use kIOFBSystemAperture.
    @result The returned CFDictionary that should be released by the caller with CFRelease(). */

CFDictionaryRef
IOFBGetPixelInfoDictionary( 
        CFDictionaryRef         modeDictionary,
        IOIndex                 depth,
        IOPixelAperture         aperture );

/*! @enum IODisplayDictionaryOptions
    @constant kIODisplayMatchingInfo Include only the keys necessary to match two displays with IODisplayMatchDictionaries().
    @constant kIODisplayOnlyPreferredName The kDisplayProductName property includes only the localized names returned by CFBundleCopyPreferredLocalizationsFromArray().
    @constant kIODisplayNoProductName The kDisplayProductName property is not included in the returned dictionary.
*/
enum {
    kIODisplayMatchingInfo      = 0x00000100,
    kIODisplayOnlyPreferredName = 0x00000200,
    kIODisplayNoProductName     = 0x00000400
};

/*! @function IODisplayCreateInfoDictionary
    @abstract Create a CFDictionary with information about display hardware.
    @discussion The CFDictionary created by this function contains information about the display hardware associated with a framebuffer. The keys for the dictionary are listed in IOGraphicsTypes.h.
    @param framebuffer The IOService handle for an IOFramebuffer service.
    @param options Use IODisplayDictionaryOptions to specify which keys to include.
    @result The returned CFDictionary that should be released by the caller with CFRelease(). */

CFDictionaryRef
IODisplayCreateInfoDictionary(
        io_service_t            framebuffer,
        IOOptionBits            options );

/*! @defined IOCreateDisplayInfoDictionary
    @discussion IOCreateDisplayInfoDictionary() was renamed IODisplayCreateInfoDictionary(). IOCreateDisplayInfoDictionary() is now a macro for IODisplayCreateInfoDictionary() for compatibility with older code. */

#define IOCreateDisplayInfoDictionary(f,o)      \
        IODisplayCreateInfoDictionary(f,o)

/*! @function IODisplayMatchDictionaries
    @abstract Match two display information dictionaries to see if they are for the same display.
    @discussion By comparing two CFDictionaries returned from IODisplayCreateInfoDictionary(), this function determines if the displays are the same. The information compared is what is returned by calling IODisplayCreateInfoDictionary() with an option of kIODisplayMatchingInfo. This includes information such as the vendor, product, and serial number.
    @param matching1 A CFDictionary returned from IODisplayCreateInfoDictionary().
    @param matching2 Another CFDictionary returned from IODisplayCreateInfoDictionary().
    @param options No options are currently defined.
    @result Returns FALSE if the two displays are not equivalent or TRUE if they are. */

SInt32
IODisplayMatchDictionaries(
        CFDictionaryRef         matching1,
        CFDictionaryRef         matching2,
        IOOptionBits            options );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

io_service_t
IODisplayForFramebuffer(
        io_service_t    framebuffer,
        IOOptionBits    options );

IOReturn
IODisplaySetParameters(
        io_service_t    service,
        IOOptionBits    options,
        CFDictionaryRef params );

IOReturn
IODisplaySetFloatParameter(
        io_service_t    service,
        IOOptionBits    options,
        CFStringRef     parameterName,
        float           value );
IOReturn
IODisplaySetIntegerParameter(
        io_service_t    service,
        IOOptionBits    options,
        CFStringRef     parameterName,
        SInt32          value );

IOReturn
IODisplayCopyParameters(
        io_service_t      service,
        IOOptionBits      options,
        CFDictionaryRef * params );

IOReturn
IODisplayCopyFloatParameters(
        io_service_t      service,
        IOOptionBits      options,
        CFDictionaryRef * params );

IOReturn
IODisplayGetFloatParameter(
        io_service_t    service,
        IOOptionBits    options,
        CFStringRef     parameterName,
        float *         value );

IOReturn
IODisplayGetIntegerRangeParameter(
        io_service_t    service,
        IOOptionBits    options,
        CFStringRef     parameterName,
        SInt32 *        value,
        SInt32 *        min,
        SInt32 *        max );

IOReturn
IODisplayCommitParameters(
        io_service_t    service,
        IOOptionBits    options );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @function IOFBSetNewCursor
    @abstract Set a new hardware cursor.
    @discussion A non-kernel task interacts with the IOFramebuffer service through a slice of shared memory that is created with the IOFBCreateSharedCursor function. The shared memory is a structure of type StdFBShmem_t. In this shared memory several cursor images, or frames may be defined. The maximum number of frames is kIOFBNumCursorFrames. StdFBShmem_t and kIOFBNumCursorFrames are defined in IOFramebufferShared.h. This function sets a new frame to be used as the current cursor image and activates the hardware cursor.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param cursor This parameter is currently not used and must be 0.
    @param frame An index to the cursor image to use that must be less than kIOFBNumCursorFrames. Currently only frame 0 is supported.
    @param options No options are currently defined.
    @result A kern_return_t error code. */

kern_return_t
IOFBSetNewCursor( io_connect_t connect,
        void *                  cursor,
        IOIndex                 frame,
        IOOptionBits            options );

/*! @function IOFBSetCursorVisible
    @abstract Set the hardware cursor visible or invisible.
    @discussion The hardware cursor can only be set visible or invisible when it is active. Use IOFBSetNewCursor() to activate the hardware cursor.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param visible TRUE to make the cursor visible and FALSE to make it invisible.
    @result A kern_return_t error code. */

kern_return_t
IOFBSetCursorVisible( io_connect_t connect,
        int                     visible );

/*! @function IOFBSetCursorPosition
    @abstract Set the hardware cursor position.
    @discussion This function only works with the hardware cursor and will fail if a hardware cursor is not supported.
    @param connect The connect handle from IOServiceOpen() to an IOFramebuffer service with a kIOFBServerConnectType connection.
    @param x The x coordinate.
    @param y The y coordinate.
    @result A kern_return_t error code. */

kern_return_t
IOFBSetCursorPosition( io_connect_t connect,
        long int                x,
        long int                y );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

kern_return_t
IOFBAcknowledgePM( io_connect_t connect );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

kern_return_t
IOPSAllocateBlitEngine( io_connect_t framebuffer,
                void ** blitterRef, int * quality);

kern_return_t
IOPSBlitReset( void * blitterRef);

kern_return_t
IOPSBlitDeallocate( void * blitterRef);

kern_return_t
IOPSBlitIdle( void * blitterRef);

kern_return_t
IOPSBlitFill( void * blitterRef,
                int dst_x, int dst_y, int width, int height, int data );

kern_return_t
IOPSBlitCopy( void * blitterRef,
                int src_x, int src_y, int width, int height,
                int dst_x, int dst_y );

kern_return_t
IOPSBlitInvert( void * blitterRef,
                int x, int y, int w, int h );

enum {
    // options for IOFBSynchronize
    kIOFBSynchronizeWaitBeamExit        = kIOBlitSynchronizeWaitBeamExit,
    kIOFBSynchronizeFlushWrites         = kIOBlitSynchronizeFlushHostWrites
};

enum {
    // options for IOFBBlitVRAMCopy
    kIOFBBlitBeamSync                   = kIOBlitBeamSync,
    kIOFBBlitBeamSyncAlways             = kIOBlitBeamSyncAlways,
    kIOFBBlitBeamSyncSpin               = kIOBlitBeamSyncSpin
};

kern_return_t
IOFBBlitVRAMCopy( void * blitterRef,
                int src_x, int src_y, int width, int height,
                int dst_x, int dst_y, IOOptionBits options );

kern_return_t
IOFBBlitSurfaceCopy( void * blitterRef, IOOptionBits options, void * surfaceID,
                     IOAccelDeviceRegion * region, UInt32 surfaceX, UInt32 surfaceY );

kern_return_t
IOFBBlitSurfaceSurfaceCopy( void * blitterRef, IOOptionBits options,
                            void * sourceSurfaceID, void * destSurfaceID,
                            IOAccelDeviceRegion * region, UInt32 surfaceX, UInt32 surfaceY );

kern_return_t
IOFBSynchronize( void * blitterRef,
                 UInt32 x, UInt32 y, UInt32 w, UInt32 h, UInt32 options );

kern_return_t
IOFBBeamPosition( void * blitterRef, UInt32 options, SInt32 * position );

kern_return_t
IOFBSetupFIFOBurst( void * blitterRef,
                        UInt32 x, UInt32 y, UInt32 w, UInt32 h,
                        UInt32 options, void ** burstRef );

void
IOFBBurstWrite32( void * p1, void * p2, void * p3, void * p4,
                  void * p5, void * p6, void * p7, void * p8 );

void
IOFBSetBurstRef( void * burstRef );

kern_return_t
IOFBCommitMemory( void * blitterRef,
                vm_address_t start, vm_size_t length, IOOptionBits options,
                void ** memoryRef, IOByteCount * offset );

kern_return_t
IOFBReleaseMemory( void * blitterRef, void * memoryRef );

kern_return_t
IOFBWaitForCompletion( void * blitterRef, SInt32 token );

kern_return_t
IOFBMemoryCopy( void * blitterRef,
                        UInt32 destLeft, UInt32 destTop,
                        UInt32 width, UInt32 height, 
                        UInt32 srcByteOffset, UInt32 srcRowBytes,
                        SInt32 * token);

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifdef __cplusplus
}
#endif

#endif /* ! _IOKIT_IOGRAPHICSLIB_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                                                IOGraphicsTypes.h                                                                                   0100644 0001750 0001750 00000166236 12567452457 035620  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/graphics                                                              /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOGRAPHICSTYPES_H
#define _IOKIT_IOGRAPHICSTYPES_H


#include <IOKit/IOTypes.h>
#include <IOKit/IOKitKeys.h>

#ifdef __cplusplus
extern "C" {
#endif

#define IOGRAPHICSTYPES_REV     42

typedef SInt32  IOIndex;
typedef UInt32  IOSelect;
typedef UInt32  IOFixed1616;
typedef UInt32  IODisplayVendorID;
typedef UInt32  IODisplayProductID;

typedef SInt32  IODisplayModeID;
enum {
    // This is the ID given to a programmable timing used at boot time
    kIODisplayModeIDBootProgrammable = (IODisplayModeID)0xFFFFFFFB,
    // Lowest (unsigned) DisplayModeID reserved by Apple
    kIODisplayModeIDReservedBase     = (IODisplayModeID)0x80000000
};

enum {
    kIOMaxPixelBits     = 64
};
typedef char IOPixelEncoding[ kIOMaxPixelBits ];

// Common Apple pixel formats

#define IO1BitIndexedPixels     "P"
#define IO2BitIndexedPixels     "PP"
#define IO4BitIndexedPixels     "PPPP"
#define IO8BitIndexedPixels     "PPPPPPPP"
#define IO16BitDirectPixels     "-RRRRRGGGGGBBBBB"
#define IO32BitDirectPixels     "--------RRRRRRRRGGGGGGGGBBBBBBBB"

#define kIO30BitDirectPixels    "--RRRRRRRRRRGGGGGGGGGGBBBBBBBBBB"
#define kIO64BitDirectPixels    "-16R16G16B16"

#define kIO16BitFloatPixels     "-16FR16FG16FB16"
#define kIO32BitFloatPixels     "-32FR32FG32FB32"

// other possible pixel formats

#define IOYUV422Pixels          "Y4U2V2"
#define IO8BitOverlayPixels     "O8"
// page flipping
#define IOPagedPixels           "Page1"

#define IO_SampleTypeAlpha      'A'
#define IO_SampleTypeSkip       '-'

// Info about a pixel format
enum {
    kIOCLUTPixels                   = 0,
    kIOFixedCLUTPixels              = 1,
    kIORGBDirectPixels              = 2,
    kIOMonoDirectPixels             = 3,
    kIOMonoInverseDirectPixels      = 4,
    kIORGBSignedDirectPixels        = 5,
    kIORGBSignedFloatingPointPixels = 6
};

/*!
 * @struct IOPixelInformation
 * @abstract A structure defining the format of a framebuffer.
 * @discussion This structure is used by IOFramebuffer to define the format of the pixels.
 * @field bytesPerRow The number of bytes per row.
 * @field bytesPerPlane Not used.
 * @field bitsPerPixel The number of bits per pixel, including unused bits and alpha.
 * @field pixelType One of kIOCLUTPixels (indexed pixels with changeable CLUT), kIORGBDirectPixels (direct pixels).
 * @field componentCount One for indexed pixels, three for direct pixel formats.
 * @field bitsPerComponent Number of bits per component in each pixel.
 * @field componentMasks Mask of the bits valid for each component of the pixel - in R, G, B order for direct pixels.
 * @field pixelFormat String description of the pixel format - IO32BitDirectPixels, IO16BitDirectPixels etc.
 * @field flags None defined - set to zero.
 * @field activeWidth Number of pixels visible per row.
 * @field activeHeight Number of visible pixel rows.
 * @field reserved Set to zero.
 */

struct IOPixelInformation {
    UInt32                      bytesPerRow;
    UInt32                      bytesPerPlane;
    UInt32                      bitsPerPixel;
    UInt32                      pixelType;
    UInt32                      componentCount;
    UInt32                      bitsPerComponent;
    UInt32                      componentMasks[ 8 * 2 ];
    IOPixelEncoding             pixelFormat;
    UInt32                      flags;
    UInt32                      activeWidth;
    UInt32                      activeHeight;
    UInt32                      reserved[ 2 ];
};
typedef struct IOPixelInformation IOPixelInformation;

// ID for industry standard display timings
typedef UInt32  IOAppleTimingID;

/*!
 * @struct IODisplayModeInformation
 * @abstract A structure defining the format of a framebuffer.
 * @discussion This structure is used by IOFramebuffer to define the format of the pixels.
 * @field nominalWidth Number of pixels visible per row.
 * @field nominalHeight Number of visible pixel rows.
 * @field refreshRate Refresh rate in fixed point 16.16.
 * @field maxDepthIndex Highest depth index available in this display mode.
 * @field flags Flags for the mode, including: <br>
 *   kDisplayModeInterlacedFlag mode is interlaced. <br>
 *   kDisplayModeSimulscanFlag mode is available on multiple display connections. <br>
 *   kDisplayModeNotPresetFlag mode is not a factory preset for the display (geometry may need correction). <br>
 *   kDisplayModeStretchedFlag mode is stretched/distorted to match the display aspect ratio. <br>
 * @field imageWidth Physical width of active image if known, in millimeters, otherwise zero. <br>
 * @field imageHeight Physical height of active image if known, in millimeters, otherwise zero. <br>
 * @field reserved Set to zero.
 */

struct IODisplayModeInformation {
    UInt32                      nominalWidth;
    UInt32                      nominalHeight;
    IOFixed1616                 refreshRate;
    IOIndex                     maxDepthIndex;
    UInt32                      flags;
    UInt16						imageWidth;
    UInt16						imageHeight;
    UInt32                      reserved[ 3 ];
};
typedef struct IODisplayModeInformation IODisplayModeInformation;

// flags
enum {
    kDisplayModeSafetyFlags             = 0x00000007,

    kDisplayModeAlwaysShowFlag          = 0x00000008,
    kDisplayModeNeverShowFlag           = 0x00000080,
    kDisplayModeNotResizeFlag           = 0x00000010,
    kDisplayModeRequiresPanFlag         = 0x00000020,

    kDisplayModeInterlacedFlag          = 0x00000040,

    kDisplayModeSimulscanFlag           = 0x00000100,
    kDisplayModeBuiltInFlag             = 0x00000400,
    kDisplayModeNotPresetFlag           = 0x00000200,
    kDisplayModeStretchedFlag           = 0x00000800,
    kDisplayModeNotGraphicsQualityFlag  = 0x00001000,
    kDisplayModeValidateAgainstDisplay  = 0x00002000,
    kDisplayModeTelevisionFlag          = 0x00100000,
    kDisplayModeValidForMirroringFlag   = 0x00200000,
    kDisplayModeAcceleratorBackedFlag   = 0x00400000,
    kDisplayModeValidForHiResFlag       = 0x00800000,
    kDisplayModeValidForAirPlayFlag     = 0x01000000,
    kDisplayModeNativeFlag              = 0x02000000
};
enum {
    kDisplayModeValidFlag               = 0x00000001,
    kDisplayModeSafeFlag                = 0x00000002,
    kDisplayModeDefaultFlag             = 0x00000004
};

#ifndef KERNEL
// Framebuffer info - obsolete

struct IOFramebufferInformation {
    IOPhysicalAddress           baseAddress;
    UInt32                      activeWidth;
    UInt32                      activeHeight;
    IOByteCount                 bytesPerRow;
    IOByteCount                 bytesPerPlane;
    UInt32                      bitsPerPixel;
    UInt32                      pixelType;
    UInt32                      flags;
    UInt32                      reserved[ 4 ];
};
typedef struct IOFramebufferInformation IOFramebufferInformation;
#endif

// flags
enum {
    kFramebufferSupportsCopybackCache   = 0x00010000,
    kFramebufferSupportsWritethruCache  = 0x00020000,
    kFramebufferSupportsGammaCorrection = 0x00040000,
    kFramebufferDisableAltivecAccess    = 0x00080000
};

// Aperture is an index into supported pixel formats for a mode & depth
typedef IOIndex IOPixelAperture;
enum {
    kIOFBSystemAperture = 0
};

//// CLUTs

typedef UInt16 IOColorComponent;

/*!
 * @struct IOColorEntry
 * @abstract A structure defining one entry of a color lookup table.
 * @discussion This structure is used by IOFramebuffer to define an entry of a color lookup table.
 * @field index Number of pixels visible per row.
 * @field red Value of red component 0-65535.
 * @field green Value of green component 0-65535.
 * @field blue Value of blue component 0-65535.
 */

struct IOColorEntry {
    UInt16                      index;
    IOColorComponent            red;
    IOColorComponent            green;
    IOColorComponent            blue;
};
typedef struct IOColorEntry IOColorEntry;

// options (masks)
enum {
    kSetCLUTByValue             = 0x00000001,           // else at index
    kSetCLUTImmediately         = 0x00000002,           // else at VBL
    kSetCLUTWithLuminance       = 0x00000004            // else RGB
};

//// Controller attributes

enum {
    kIOPowerStateAttribute              = 'pwrs',
    kIOPowerAttribute                   = 'powr',
    kIODriverPowerAttribute             = 'dpow',
    kIOHardwareCursorAttribute          = 'crsr',

    kIOMirrorAttribute                  = 'mirr',
    kIOMirrorDefaultAttribute           = 'mrdf',

    kIOCapturedAttribute                = 'capd',

    kIOCursorControlAttribute           = 'crsc',

    kIOSystemPowerAttribute             = 'spwr',
    kIOWindowServerActiveAttribute      = 'wsrv',
    kIOVRAMSaveAttribute                = 'vrsv',
    kIODeferCLUTSetAttribute            = 'vclt',

    kIOClamshellStateAttribute          = 'clam',

	kIOFBDisplayPortTrainingAttribute   = 'dpta',
};

// values for kIOMirrorAttribute
enum {
    kIOMirrorIsPrimary                  = 0x80000000,
    kIOMirrorHWClipped                  = 0x40000000,
    kIOMirrorIsMirrored                 = 0x20000000
};

// values for kIOMirrorDefaultAttribute
enum {
    kIOMirrorDefault                    = 0x00000001,
    kIOMirrorForced                     = 0x00000002
};

//// Display mode timing information

struct IODetailedTimingInformationV1 {
    // from EDID defn
    UInt32                      pixelClock;             // Hertz
    UInt32                      horizontalActive;       // pixels
    UInt32                      horizontalBlanking;     // pixels
    UInt32                      horizontalBorder;       // pixels
    UInt32                      horizontalSyncOffset;   // pixels
    UInt32                      horizontalSyncWidth;    // pixels
    UInt32                      verticalActive;         // lines
    UInt32                      verticalBlanking;       // lines
    UInt32                      verticalBorder;         // lines
    UInt32                      verticalSyncOffset;     // lines
    UInt32                      verticalSyncWidth;      // lines
};
typedef struct IODetailedTimingInformationV1 IODetailedTimingInformationV1;

/*!
 * @struct IODetailedTimingInformationV2
 * @abstract A structure defining the detailed timing information of a display mode.
 * @discussion This structure is used by IOFramebuffer to define detailed timing information for a display mode. The VESA EDID document has more information.
 * @field __reservedA Set to zero.
 * @field horizontalScaledInset If the mode is scaled, sets the number of active pixels to remove the left and right edges in order to display an underscanned image.
 * @field verticalScaledInset If the mode is scaled, sets the number of active lines to remove the top and bottom edges in order to display an underscanned image.
 * @field scalerFlags If the mode is scaled,
 *    kIOScaleStretchToFit may be set to allow stretching.
 *    kIOScaleRotateFlags is mask which may have the value given by kIOScaleRotate90, kIOScaleRotate180, kIOScaleRotate270 to display a rotated framebuffer.
 * @field horizontalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
 * @field verticalScaled If the mode is scaled, sets the size of the image before scaling or rotation.
 * @field signalConfig 
 *    kIOAnalogSetupExpected set if display expects a blank-to-black setup or pedestal.  See VESA signal standards. <br>
 *    kIOInterlacedCEATiming set for a CEA style interlaced timing:<br>
 *      Field 1 vertical blanking = half specified vertical blanking lines. <br>
 *      Field 2 vertical blanking = (half vertical blanking lines) + 1 line. <br>
 *      Field 1 vertical offset = half specified vertical sync offset. <br>
 *      Field 2 vertical offset = (half specified vertical sync offset) + 0.5 lines. <br>
 * @field signalLevels One of:<br>
 *   kIOAnalogSignalLevel_0700_0300 0.700 - 0.300 V p-p.<br>
 *   kIOAnalogSignalLevel_0714_0286 0.714 - 0.286 V p-p.<br>
 *   kIOAnalogSignalLevel_1000_0400 1.000 - 0.400 V p-p.<br>
 *   kIOAnalogSignalLevel_0700_0000 0.700 - 0.000 V p-p.<br>
 * @field pixelClock Pixel clock frequency in Hz.
 * @field minPixelClock Minimum pixel clock frequency in Hz, with error.
 * @field maxPixelClock Maximum pixel clock frequency in Hz, with error.
 * @field horizontalActive Pixel clocks per line.
 * @field horizontalBlanking Blanking clocks per line.
 * @field horizontalSyncOffset First clock of horizontal sync.
 * @field horizontalSyncPulseWidth Width of horizontal sync.
 * @field verticalActive Number of lines per frame.
 * @field verticalBlanking Blanking lines per frame.
 * @field verticalSyncOffset First line of vertical sync.
 * @field verticalSyncPulseWidth Height of vertical sync.
 * @field horizontalBorderLeft Number of pixels in left horizontal border.
 * @field horizontalBorderRight Number of pixels in right horizontal border.
 * @field verticalBorderTop Number of lines in top vertical border.
 * @field verticalBorderBottom Number of lines in bottom vertical border.
 * @field horizontalSyncConfig kIOSyncPositivePolarity for positive polarity horizontal sync (0 for negative).
 * @field horizontalSyncLevel Zero.
 * @field verticalSyncConfig kIOSyncPositivePolarity for positive polarity vertical sync (0 for negative).
 * @field verticalSyncLevel Zero.
 * @field numLinks number of links to be used by a dual link timing, if zero, assume one link.
 * @field __reservedB Reserved set to zero.
 */

struct IODetailedTimingInformationV2 {

    UInt32      __reservedA[3];                 // Init to 0
    UInt32      horizontalScaledInset;          // pixels
    UInt32      verticalScaledInset;            // lines

    UInt32      scalerFlags;
    UInt32      horizontalScaled;
    UInt32      verticalScaled;

    UInt32      signalConfig;
    UInt32      signalLevels;

    UInt64      pixelClock;                     // Hz

    UInt64      minPixelClock;                  // Hz - With error what is slowest actual clock
    UInt64      maxPixelClock;                  // Hz - With error what is fasted actual clock

    UInt32      horizontalActive;               // pixels
    UInt32      horizontalBlanking;             // pixels
    UInt32      horizontalSyncOffset;           // pixels
    UInt32      horizontalSyncPulseWidth;       // pixels

    UInt32      verticalActive;                 // lines
    UInt32      verticalBlanking;               // lines
    UInt32      verticalSyncOffset;             // lines
    UInt32      verticalSyncPulseWidth;         // lines

    UInt32      horizontalBorderLeft;           // pixels
    UInt32      horizontalBorderRight;          // pixels
    UInt32      verticalBorderTop;              // lines
    UInt32      verticalBorderBottom;           // lines

    UInt32      horizontalSyncConfig;
    UInt32      horizontalSyncLevel;            // Future use (init to 0)
    UInt32      verticalSyncConfig;
    UInt32      verticalSyncLevel;              // Future use (init to 0)
    UInt32      numLinks;

    UInt32      __reservedB[7];                 // Init to 0
};
typedef struct IODetailedTimingInformationV2 IODetailedTimingInformationV2;
typedef struct IODetailedTimingInformationV2 IODetailedTimingInformation;

struct IOTimingInformation {
    IOAppleTimingID             appleTimingID;  // kIOTimingIDXXX const
    UInt32                      flags;
    union {
      IODetailedTimingInformationV1     v1;
      IODetailedTimingInformationV2     v2;
    }                           detailedInfo;
};
typedef struct IOTimingInformation IOTimingInformation;

enum {
    // IOTimingInformation flags
    kIODetailedTimingValid      = 0x80000000,
    kIOScalingInfoValid         = 0x40000000
};

enum {
    // scalerFlags
    kIOScaleStretchToFit        = 0x00000001,

    kIOScaleRotateFlags         = 0x000000f0,

    kIOScaleSwapAxes            = 0x00000010,
    kIOScaleInvertX             = 0x00000020,
    kIOScaleInvertY             = 0x00000040,

    kIOScaleRotate0             = 0x00000000,
    kIOScaleRotate90            = kIOScaleSwapAxes | kIOScaleInvertX,
    kIOScaleRotate180           = kIOScaleInvertX  | kIOScaleInvertY,
    kIOScaleRotate270           = kIOScaleSwapAxes | kIOScaleInvertY
};


#pragma pack(push, 4)
struct IOFBDisplayModeDescription {
    IODisplayModeInformation    info;
    IOTimingInformation         timingInfo;
};
typedef struct IOFBDisplayModeDescription IOFBDisplayModeDescription;
#pragma pack(pop)

/*!
 * @struct IODisplayTimingRange
 * @abstract A structure defining the limits and attributes of a display or framebuffer.
 * @discussion This structure is used to define the limits for modes programmed as detailed timings by the OS. The VESA EDID is useful background information for many of these fields. A data property with this structure under the key kIOFBTimingRangeKey in a framebuffer will allow the OS to program detailed timings that fall within its range.
 * @field __reservedA Set to zero.
 * @field version Set to zero.
 * @field __reservedB Set to zero.
 * @field minPixelClock minimum pixel clock frequency in range, in Hz.
 * @field minPixelClock maximum pixel clock frequency in range, in Hz.
 * @field maxPixelError largest variation between specified and actual pixel clock frequency, in Hz.
 * @field supportedSyncFlags mask of supported sync attributes. The following are defined:<br>
 *    kIORangeSupportsSeparateSyncs - digital separate syncs.<br>
 *    kIORangeSupportsSyncOnGreen - sync on green.<br>
 *    kIORangeSupportsCompositeSync - composite sync.<br>
 *    kIORangeSupportsVSyncSerration - vertical sync has serration and equalization pulses.<br>
 * @field supportedSignalLevels mask of possible signal levels. The following are defined:<br>
 *    kIORangeSupportsSignal_0700_0300 0.700 - 0.300 V p-p.<br>
 *    kIORangeSupportsSignal_0714_0286 0.714 - 0.286 V p-p.<br>
 *    kIORangeSupportsSignal_1000_0400 1.000 - 0.400 V p-p.<br>
 *    kIORangeSupportsSignal_0700_0000 0.700 - 0.000 V p-p.<br>
 * @field supportedSignalConfigs mask of possible signal configurations. The following are defined:<br>
 *    kIORangeSupportsInterlacedCEATiming Supports CEA style interlaced timing:<br>
 *      Field 1 vertical blanking = specified vertical blanking lines. <br>
 *      Field 2 vertical blanking = vertical blanking lines + 1 line. <br> 
 *      Field 1 vertical offset = specified vertical sync offset. <br>
 *      Field 2 vertical offset = specified vertical sync offset + 0.5 lines. <br>
 *    kIORangeSupportsInterlacedCEATimingWithConfirm Supports CEA style interlaced timing, but require a confirm.
 * @field minFrameRate minimum frame rate (vertical refresh frequency) in range, in Hz.
 * @field maxFrameRate maximum frame rate (vertical refresh frequency) in range, in Hz.
 * @field minLineRate minimum line rate (horizontal refresh frequency) in range, in Hz.
 * @field maxLineRate maximum line rate (horizontal refresh frequency) in range, in Hz.
 * @field maxHorizontalTotal maximum clocks in horizontal line (active + blanking).
 * @field maxVerticalTotal maximum lines in vertical frame (active + blanking).
 * @field __reservedD Set to zero.
 * @field charSizeHorizontalActive horizontalActive must be a multiple of charSizeHorizontalActive.
 * @field charSizeHorizontalBlanking horizontalBlanking must be a multiple of charSizeHorizontalBlanking.
 * @field charSizeHorizontalSyncOffset horizontalSyncOffset must be a multiple of charSizeHorizontalSyncOffset.
 * @field charSizeHorizontalSyncPulse horizontalSyncPulse must be a multiple of charSizeHorizontalSyncPulse.
 * @field charSizeVerticalActive verticalActive must be a multiple of charSizeVerticalActive.
 * @field charSizeVerticalBlanking verticalBlanking must be a multiple of charSizeVerticalBlanking.
 * @field charSizeVerticalSyncOffset verticalSyncOffset must be a multiple of charSizeVerticalSyncOffset.
 * @field charSizeVerticalSyncPulse verticalSyncPulse must be a multiple of charSizeVerticalSyncPulse.
 * @field charSizeHorizontalBorderLeft horizontalBorderLeft must be a multiple of charSizeHorizontalBorderLeft.
 * @field charSizeHorizontalBorderRight horizontalBorderRight must be a multiple of charSizeHorizontalBorderRight.
 * @field charSizeVerticalBorderTop verticalBorderTop must be a multiple of charSizeVerticalBorderTop.
 * @field charSizeVerticalBorderBottom verticalBorderBottom must be a multiple of charSizeVerticalBorderBottom.
 * @field charSizeHorizontalTotal (horizontalActive + horizontalBlanking) must be a multiple of charSizeHorizontalTotal.
 * @field charSizeVerticalTotal (verticalActive + verticalBlanking) must be a multiple of charSizeVerticalTotal.
 * @field __reservedE Set to zero.
 * @field minHorizontalActiveClocks minimum value of horizontalActive.
 * @field maxHorizontalActiveClocks maximum value of horizontalActive.
 * @field minHorizontalBlankingClocks minimum value of horizontalBlanking.
 * @field maxHorizontalBlankingClocks maximum value of horizontalBlanking.
 * @field minHorizontalSyncOffsetClocks minimum value of horizontalSyncOffset.
 * @field maxHorizontalSyncOffsetClocks maximum value of horizontalSyncOffset.
 * @field minHorizontalPulseWidthClocks minimum value of horizontalPulseWidth.
 * @field maxHorizontalPulseWidthClocks maximum value of horizontalPulseWidth.
 * @field minVerticalActiveClocks minimum value of verticalActive.
 * @field maxVerticalActiveClocks maximum value of verticalActive.
 * @field minVerticalBlankingClocks minimum value of verticalBlanking.
 * @field maxVerticalBlankingClocks maximum value of verticalBlanking.
 * @field minVerticalSyncOffsetClocks minimum value of verticalSyncOffset.
 * @field maxVerticalSyncOffsetClocks maximum value of verticalSyncOffset.
 * @field minVerticalPulseWidthClocks minimum value of verticalPulseWidth.
 * @field maxVerticalPulseWidthClocks maximum value of verticalPulseWidth.
 * @field minHorizontalBorderLeft minimum value of horizontalBorderLeft.
 * @field maxHorizontalBorderLeft maximum value of horizontalBorderLeft.
 * @field minHorizontalBorderRight minimum value of horizontalBorderRight.
 * @field maxHorizontalBorderRight maximum value of horizontalBorderRight.
 * @field minVerticalBorderTop minimum value of verticalBorderTop.
 * @field maxVerticalBorderTop maximum value of verticalBorderTop.
 * @field minVerticalBorderBottom minimum value of verticalBorderBottom.
 * @field maxVerticalBorderBottom maximum value of verticalBorderBottom.
 * @field maxNumLinks number of links supported, if zero, 1 link is assumed.
 * @field minLink0PixelClock minimum pixel clock for link 0 (kHz).
 * @field maxLink0PixelClock maximum pixel clock for link 0 (kHz).
 * @field minLink1PixelClock minimum pixel clock for link 1 (kHz).
 * @field maxLink1PixelClock maximum pixel clock for link 1 (kHz).
 * @field __reservedF Set to zero.
 */

struct IODisplayTimingRange
{
    UInt32      __reservedA[2];                 // Init to 0
    UInt32      version;                        // Init to 0
    UInt32      __reservedB[5];                 // Init to 0

    UInt64      minPixelClock;                  // Min dot clock in Hz
    UInt64      maxPixelClock;                  // Max dot clock in Hz

    UInt32      maxPixelError;                  // Max dot clock error
    UInt32      supportedSyncFlags;
    UInt32      supportedSignalLevels;
    UInt32      supportedSignalConfigs;

    UInt32      minFrameRate;                   // Hz
    UInt32      maxFrameRate;                   // Hz
    UInt32      minLineRate;                    // Hz
    UInt32      maxLineRate;                    // Hz

    UInt32      maxHorizontalTotal;             // Clocks - Maximum total (active + blanking)
    UInt32      maxVerticalTotal;               // Clocks - Maximum total (active + blanking)
    UInt32      __reservedD[2];                 // Init to 0

    UInt8       charSizeHorizontalActive;
    UInt8       charSizeHorizontalBlanking;     
    UInt8       charSizeHorizontalSyncOffset; 
    UInt8       charSizeHorizontalSyncPulse; 

    UInt8       charSizeVerticalActive;         
    UInt8       charSizeVerticalBlanking;       
    UInt8       charSizeVerticalSyncOffset;     
    UInt8       charSizeVerticalSyncPulse;      

    UInt8       charSizeHorizontalBorderLeft; 
    UInt8       charSizeHorizontalBorderRight; 
    UInt8       charSizeVerticalBorderTop;      
    UInt8       charSizeVerticalBorderBottom; 

    UInt8       charSizeHorizontalTotal;                // Character size for active + blanking
    UInt8       charSizeVerticalTotal;                  // Character size for active + blanking
    UInt16      __reservedE;                            // Reserved (Init to 0)

    UInt32      minHorizontalActiveClocks;
    UInt32      maxHorizontalActiveClocks;
    UInt32      minHorizontalBlankingClocks;
    UInt32      maxHorizontalBlankingClocks;

    UInt32      minHorizontalSyncOffsetClocks;
    UInt32      maxHorizontalSyncOffsetClocks;
    UInt32      minHorizontalPulseWidthClocks;
    UInt32      maxHorizontalPulseWidthClocks;

    UInt32      minVerticalActiveClocks;
    UInt32      maxVerticalActiveClocks;
    UInt32      minVerticalBlankingClocks;
    UInt32      maxVerticalBlankingClocks;

    UInt32      minVerticalSyncOffsetClocks;
    UInt32      maxVerticalSyncOffsetClocks;
    UInt32      minVerticalPulseWidthClocks;
    UInt32      maxVerticalPulseWidthClocks;

    UInt32      minHorizontalBorderLeft;
    UInt32      maxHorizontalBorderLeft;
    UInt32      minHorizontalBorderRight;
    UInt32      maxHorizontalBorderRight;

    UInt32      minVerticalBorderTop;
    UInt32      maxVerticalBorderTop;
    UInt32      minVerticalBorderBottom;
    UInt32      maxVerticalBorderBottom;
    UInt32      maxNumLinks;                       // number of links, if zero, assume link 1
    UInt32      minLink0PixelClock;                // min pixel clock for link 0 (kHz)
    UInt32      maxLink0PixelClock;                // max pixel clock for link 0 (kHz)
    UInt32      minLink1PixelClock;                // min pixel clock for link 1 (kHz)
    UInt32      maxLink1PixelClock;                // max pixel clock for link 1 (kHz)

    UInt32      __reservedF[3];                 // Init to 0
};
typedef struct IODisplayTimingRange  IODisplayTimingRange;

enum {
    // supportedSignalLevels
    kIORangeSupportsSignal_0700_0300    = 0x00000001,
    kIORangeSupportsSignal_0714_0286    = 0x00000002,
    kIORangeSupportsSignal_1000_0400    = 0x00000004,
    kIORangeSupportsSignal_0700_0000    = 0x00000008
};
enum {
    // supportedSyncFlags
    kIORangeSupportsSeparateSyncs        = 0x00000001,
    kIORangeSupportsSyncOnGreen          = 0x00000002,
    kIORangeSupportsCompositeSync        = 0x00000004,
    kIORangeSupportsVSyncSerration       = 0x00000008
};
enum {
    // supportedSignalConfigs
    kIORangeSupportsInterlacedCEATiming            = 0x00000004,
    kIORangeSupportsInterlacedCEATimingWithConfirm = 0x00000008
};

enum {
    // signalConfig
    kIODigitalSignal          = 0x00000001,
    kIOAnalogSetupExpected    = 0x00000002,
    kIOInterlacedCEATiming    = 0x00000004,
    kIONTSCTiming             = 0x00000008,
    kIOPALTiming              = 0x00000010
};

enum {
    // signalLevels for analog
    kIOAnalogSignalLevel_0700_0300 = 0,
    kIOAnalogSignalLevel_0714_0286 = 1,
    kIOAnalogSignalLevel_1000_0400 = 2,
    kIOAnalogSignalLevel_0700_0000 = 3
};

enum {
    // horizontalSyncConfig and verticalSyncConfig
    kIOSyncPositivePolarity     = 0x00000001
};

/*!
 * @struct IODisplayScalerInformation
 * @abstract A structure defining the scaling capabilities of a framebuffer.
 * @discussion This structure is used to define the limits for modes programmed as detailed timings by the OS. A data property with this structure under the key kIOFBScalerInfoKey in a framebuffer will allow the OS to program detailed timings that are scaled to a displays native resolution.
 * @field __reservedA Set to zero.
 * @field version Set to zero.
 * @field __reservedB Set to zero.
 * @field scalerFeatures Mask of scaling features. The following are defined:<br>
 *   kIOScaleStretchOnly If set the framebuffer can only provide stretched scaling with non-square pixels, without borders.<br>
 *   kIOScaleCanUpSamplePixels If set framebuffer can scale up from a smaller number of source pixels to a larger native timing (eg. 640x480 pixels on a 1600x1200 timing).<br>
 *   kIOScaleCanDownSamplePixels If set framebuffer can scale down from a larger number of source pixels to a smaller native timing (eg. 1600x1200 pixels on a 640x480 timing).<br>
 *   kIOScaleCanScaleInterlaced If set framebuffer can scale an interlaced detailed timing.<br>
 *   kIOScaleCanSupportInset If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields.<br>
 *   kIOScaleCanRotate If set framebuffer can support some of the flags in the kIOScaleRotateFlags mask.<br>
 *   kIOScaleCanBorderInsetOnly If set framebuffer can support scaled modes with non-zero horizontalScaledInset, verticalScaledInset fields, but requires the active pixels to be equal in size to the inset area, ie. can do insets with a border versus scaling an image.<br>
 * @field maxHorizontalPixels Maximum number of horizontal source pixels (horizontalScaled).<br>
 * @field maxVerticalPixels Maximum number of vertical source pixels (verticalScaled).<br>
 * @field __reservedC Set to zero.
 */

struct IODisplayScalerInformation {
    UInt32              __reservedA[1];         // Init to 0
    UInt32              version;                // Init to 0
    UInt32              __reservedB[2];         // Init to 0
    
    IOOptionBits        scalerFeatures;
    UInt32              maxHorizontalPixels;
    UInt32              maxVerticalPixels;
    UInt32              __reservedC[5];         // Init to 0
};
typedef struct IODisplayScalerInformation IODisplayScalerInformation;

enum {
    /* scalerFeatures */
    kIOScaleStretchOnly           = 0x00000001,
    kIOScaleCanUpSamplePixels     = 0x00000002,
    kIOScaleCanDownSamplePixels   = 0x00000004,
    kIOScaleCanScaleInterlaced    = 0x00000008,
    kIOScaleCanSupportInset       = 0x00000010,
    kIOScaleCanRotate             = 0x00000020,
    kIOScaleCanBorderInsetOnly    = 0x00000040
};

//// Connections

enum {
    kOrConnections                      = 0xffffffe,
    kAndConnections                     = 0xffffffd
};

enum {
    kConnectionFlags                    = 'flgs',
    kConnectionSyncEnable               = 'sync',
    kConnectionSyncFlags                = 'sycf',
    kConnectionSupportsAppleSense       = 'asns',
    kConnectionSupportsLLDDCSense       = 'lddc',
    kConnectionSupportsHLDDCSense       = 'hddc',
    kConnectionEnable                   = 'enab',
    kConnectionCheckEnable              = 'cena',
    kConnectionProbe                    = 'prob',
    kConnectionChanged                  = 'chng',
    kConnectionPower                    = 'powr',
    kConnectionPostWake                 = 'pwak',
    kConnectionDisplayParameterCount    = 'pcnt',
    kConnectionDisplayParameters        = 'parm',
    kConnectionOverscan                 = 'oscn',
    kConnectionVideoBest                = 'vbst',

    kConnectionRedGammaScale            = 'rgsc',
    kConnectionGreenGammaScale          = 'ggsc',
    kConnectionBlueGammaScale           = 'bgsc',
    kConnectionGammaScale               = 'gsc ',
    kConnectionFlushParameters          = 'flus',

    kConnectionVBLMultiplier            = 'vblm',

    kConnectionHandleDisplayPortEvent   = 'dpir',

    kConnectionPanelTimingDisable       = 'pnlt',

    kConnectionColorMode                = 'cyuv',
    kConnectionColorModesSupported      = 'colr',
    kConnectionColorDepthsSupported     = ' bpc',

    kConnectionControllerDepthsSupported = '\0grd',
    kConnectionControllerColorDepth      = '\0dpd',
    kConnectionControllerDitherControl   = '\0gdc',

    kConnectionDisplayFlags              = 'dflg',

    kConnectionEnableAudio               = 'aud ',
    kConnectionAudioStreaming            = 'auds',
};

// kConnectionFlags values
enum {
    kIOConnectionBuiltIn                = 0x00000800,
    kIOConnectionStereoSync             = 0x00008000
};

// kConnectionSyncControl values
enum {
    kIOHSyncDisable                     = 0x00000001,
    kIOVSyncDisable                     = 0x00000002,
    kIOCSyncDisable                     = 0x00000004,
    kIONoSeparateSyncControl            = 0x00000040,
    kIOTriStateSyncs                    = 0x00000080,
    kIOSyncOnBlue                       = 0x00000008,
    kIOSyncOnGreen                      = 0x00000010,
    kIOSyncOnRed                        = 0x00000020
};

// kConnectionHandleDisplayPortEvent values
enum {
    kIODPEventStart                             = 1,
    kIODPEventIdle                              = 2,

    kIODPEventForceRetrain                      = 3,

    kIODPEventRemoteControlCommandPending       = 256,
    kIODPEventAutomatedTestRequest              = 257,
    kIODPEventContentProtection                 = 258,
    kIODPEventMCCS                              = 259,
    kIODPEventSinkSpecific                      = 260
};

#define kIODisplayAttributesKey         "IODisplayAttributes"

#define kIODisplaySupportsUnderscanKey  "IODisplaySupportsUnderscan"
#define kIODisplaySupportsBasicAudioKey "IODisplaySupportsBasicAudio"
#define kIODisplaySupportsYCbCr444Key   "IODisplaySupportsYCbCr444"
#define kIODisplaySupportsYCbCr422Key   "IODisplaySupportsYCbCr422"
#define kIODisplaySelectedColorModeKey  "cmod"

enum
{ 
    kIODisplayColorMode         = kConnectionColorMode,
};

#if 0
enum
{
    // kConnectionColorMode attribute
    kIODisplayColorModeReserved   = 0x00000000,
    kIODisplayColorModeRGB        = 0x00000001,
    kIODisplayColorModeYCbCr422   = 0x00000010,
    kIODisplayColorModeYCbCr444   = 0x00000100,
    kIODisplayColorModeRGBLimited = 0x00001000,
    kIODisplayColorModeAuto       = 0x10000000,
};
#endif

enum
{ 
    // kConnectionColorDepthsSupported attribute
    kIODisplayRGBColorComponentBitsUnknown       = 0x00000000,
    kIODisplayRGBColorComponentBits6             = 0x00000001,
    kIODisplayRGBColorComponentBits8             = 0x00000002,
    kIODisplayRGBColorComponentBits10            = 0x00000004,
    kIODisplayRGBColorComponentBits12            = 0x00000008,
    kIODisplayRGBColorComponentBits14            = 0x00000010,
    kIODisplayRGBColorComponentBits16            = 0x00000020,

    kIODisplayYCbCr444ColorComponentBitsUnknown  = 0x00000000,
    kIODisplayYCbCr444ColorComponentBits6        = 0x00000100,
    kIODisplayYCbCr444ColorComponentBits8        = 0x00000200,
    kIODisplayYCbCr444ColorComponentBits10       = 0x00000400,
    kIODisplayYCbCr444ColorComponentBits12       = 0x00000800,
    kIODisplayYCbCr444ColorComponentBits14       = 0x00001000,
    kIODisplayYCbCr444ColorComponentBits16       = 0x00002000,

    kIODisplayYCbCr422ColorComponentBitsUnknown  = 0x00000000,
    kIODisplayYCbCr422ColorComponentBits6        = 0x00010000,
    kIODisplayYCbCr422ColorComponentBits8        = 0x00020000,
    kIODisplayYCbCr422ColorComponentBits10       = 0x00040000,
    kIODisplayYCbCr422ColorComponentBits12       = 0x00080000,
    kIODisplayYCbCr422ColorComponentBits14       = 0x00100000,
    kIODisplayYCbCr422ColorComponentBits16       = 0x00200000,
};

enum
{ 
    // kConnectionDitherControl attribute
    kIODisplayDitherDisable          = 0x00000000,
    kIODisplayDitherSpatial          = 0x00000001,
    kIODisplayDitherTemporal         = 0x00000002,
    kIODisplayDitherFrameRateControl = 0x00000004,
    kIODisplayDitherDefault          = 0x00000080,
    kIODisplayDitherAll              = 0x000000FF,
    kIODisplayDitherRGBShift         = 0,
    kIODisplayDitherYCbCr444Shift    = 8,
    kIODisplayDitherYCbCr422Shift    = 16,
};

enum
{ 
    // kConnectionDisplayFlags attribute
    kIODisplayNeedsCEAUnderscan      = 0x00000001,
};

enum
{
	kIODisplayPowerStateOff       =	0,
	kIODisplayPowerStateMinUsable =	1,
	kIODisplayPowerStateOn        = 2,
};

#define IO_DISPLAY_CAN_FILL             0x00000040
#define IO_DISPLAY_CAN_BLIT             0x00000020

#define IO_24BPP_TRANSFER_TABLE_SIZE    256
#define IO_15BPP_TRANSFER_TABLE_SIZE    256
#define IO_8BPP_TRANSFER_TABLE_SIZE     256
#define IO_12BPP_TRANSFER_TABLE_SIZE    256
#define IO_2BPP_TRANSFER_TABLE_SIZE     256

#define STDFB_BM256_TO_BM38_MAP_SIZE    256
#define STDFB_BM38_TO_BM256_MAP_SIZE    256
#define STDFB_BM38_TO_256_WITH_LOGICAL_SIZE     \
        (STDFB_BM38_TO_BM256_MAP_SIZE + (256/sizeof(int)))

#define STDFB_4BPS_TO_5BPS_MAP_SIZE     16
#define STDFB_5BPS_TO_4BPS_MAP_SIZE     32

enum {
    // connection types for IOServiceOpen
    kIOFBServerConnectType              = 0,
    kIOFBSharedConnectType              = 1
};

enum {
    // options for IOServiceRequestProbe()
    kIOFBUserRequestProbe               = 0x00000001
};

struct IOGPoint {
    SInt16      x;
    SInt16      y;
};
typedef struct IOGPoint IOGPoint;

struct IOGSize {
    SInt16      width;
    SInt16      height;
};
typedef struct IOGSize IOGSize;

struct IOGBounds {
    SInt16      minx;
    SInt16      maxx;
    SInt16      miny;
    SInt16      maxy;
};
typedef struct IOGBounds IOGBounds;

#ifndef kIODescriptionKey

#if !defined(__Point__) && !defined(BINTREE_H) && !defined(__MACTYPES__)
#define __Point__
typedef IOGPoint Point;
#endif

#if !defined(__Bounds__) && !defined(BINTREE_H) && !defined(__MACTYPES__)
#define __Bounds__
typedef IOGBounds Bounds;
#endif

#endif /* !kIODescriptionKey */

// cursor description

enum {
   kTransparentEncoding         = 0,
   kInvertingEncoding
};

enum {
   kTransparentEncodingShift    = (kTransparentEncoding << 1),
   kTransparentEncodedPixel     = (0x01 << kTransparentEncodingShift),

   kInvertingEncodingShift      = (kInvertingEncoding << 1),
   kInvertingEncodedPixel       = (0x01 << kInvertingEncodingShift)
};

enum {
   kHardwareCursorDescriptorMajorVersion        = 0x0001,
   kHardwareCursorDescriptorMinorVersion        = 0x0000
};

/*!
 * @struct IOHardwareCursorDescriptor
 * @abstract A structure defining the format of a hardware cursor.
 * @discussion This structure is used by IOFramebuffer to define the format of a hardware cursor.
 * @field majorVersion Set to kHardwareCursorDescriptorMajorVersion.
 * @field minorVersion Set to kHardwareCursorDescriptorMinorVersion.
 * @field height Maximum size of the cursor.
 * @field width Maximum size of the cursor.
 * @field bitDepth Number bits per pixel, or a QD/QT pixel type, for example kIO8IndexedPixelFormat, kIO32ARGBPixelFormat.
 * @field maskBitDepth Unused.
 * @field numColors Number of colors for indexed pixel types.
 * @field colorEncodings An array pointer specifying the pixel values corresponding to the indices into the color table, for indexed pixel types.
 * @field flags None defined, set to zero.
 * @field supportedSpecialEncodings Mask of supported special pixel values, eg. kTransparentEncodedPixel, kInvertingEncodedPixel.
 * @field specialEncodings Array of pixel values for each supported special encoding.
 */

struct IOHardwareCursorDescriptor {
   UInt16               majorVersion;
   UInt16               minorVersion;
   UInt32               height;
   UInt32               width;
   UInt32               bitDepth;                       // bits per pixel, or a QD/QT pixel type
   UInt32               maskBitDepth;                   // unused
   UInt32               numColors;                      // number of colors in the colorMap. ie. 
   UInt32 *             colorEncodings;
   UInt32               flags;
   UInt32               supportedSpecialEncodings;
   UInt32               specialEncodings[16];
};
typedef struct IOHardwareCursorDescriptor IOHardwareCursorDescriptor;

enum {
   kHardwareCursorInfoMajorVersion              = 0x0001,
   kHardwareCursorInfoMinorVersion              = 0x0000
};

/*!
 * @struct IOHardwareCursorInfo
 * @abstract A structure defining the converted data of a hardware cursor.
 * @discussion This structure is used by IOFramebuffer to return the data of a hardware cursor by convertCursorImage() after conversion based on the IOHardwareCursorDescriptor passed to that routine.
 * @field majorVersion Set to kHardwareCursorInfoMajorVersion.
 * @field minorVersion Set to kHardwareCursorInfoMinorVersion.
 * @field cursorHeight The actual size of the cursor is returned.
 * @field cursorWidth The actual size of the cursor is returned.
 * @field colorMap Pointer to array of IOColorEntry structures, with the number of elements set by the numColors field of the IOHardwareCursorDescriptor. Zero should be passed for direct pixel formats.
 * @field hardwareCursorData Buffer to receive the converted cursor data.
 * @field cursorHotSpotX Cursor's hotspot.
 * @field cursorHotSpotY Cursor's hotspot.
 * @field reserved Reserved, set to zero.
 */

struct IOHardwareCursorInfo {
   UInt16               majorVersion;
   UInt16               minorVersion;
   UInt32               cursorHeight;
   UInt32               cursorWidth;
   // nil or big enough for hardware's max colors
   IOColorEntry *       colorMap;
   UInt8 *              hardwareCursorData;
   UInt16               cursorHotSpotX;
   UInt16               cursorHotSpotY;
   UInt32               reserved[5];
};
typedef struct IOHardwareCursorInfo IOHardwareCursorInfo;

// interrupt types

enum {
    kIOFBVBLInterruptType               = 'vbl ',
    kIOFBHBLInterruptType               = 'hbl ',
    kIOFBFrameInterruptType             = 'fram',
    // Demand to check configuration (Hardware unchanged)
    kIOFBConnectInterruptType           = 'dci ',
    // Demand to rebuild (Hardware has reinitialized on dependent change)
    kIOFBChangedInterruptType           = 'chng',
    // Demand to remove framebuffer (Hardware not available on dependent change -- but must not buserror)
    kIOFBOfflineInterruptType           = 'remv',
    // Notice that hardware is available (after being removed)
    kIOFBOnlineInterruptType            = 'add ',
    // DisplayPort short pulse
    kIOFBDisplayPortInterruptType           = 'dpir',
    // DisplayPort link event
    kIOFBDisplayPortLinkChangeInterruptType = 'dplk',
    // MCCS
    kIOFBMCCSInterruptType                  = 'mccs',
    // early vram notification
    kIOFBWakeInterruptType                  = 'vwak'
};

// IOAppleTimingID's
enum {
    kIOTimingIDInvalid               = 0,       /*  Not a standard timing */
    kIOTimingIDApple_FixedRateLCD    = 42,      /*  Lump all fixed-rate LCDs into one category.*/
    kIOTimingIDApple_512x384_60hz    = 130,     /*  512x384  (60 Hz) Rubik timing. */
    kIOTimingIDApple_560x384_60hz    = 135,     /*  560x384  (60 Hz) Rubik-560 timing. */
    kIOTimingIDApple_640x480_67hz    = 140,     /*  640x480  (67 Hz) HR timing. */
    kIOTimingIDApple_640x400_67hz    = 145,     /*  640x400  (67 Hz) HR-400 timing. */
    kIOTimingIDVESA_640x480_60hz     = 150,     /*  640x480  (60 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_72hz     = 152,     /*  640x480  (72 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_75hz     = 154,     /*  640x480  (75 Hz) VGA timing. */
    kIOTimingIDVESA_640x480_85hz     = 158,     /*  640x480  (85 Hz) VGA timing. */
    kIOTimingIDGTF_640x480_120hz     = 159,     /*  640x480  (120 Hz) VESA Generalized Timing Formula */
    kIOTimingIDApple_640x870_75hz    = 160,     /*  640x870  (75 Hz) FPD timing.*/
    kIOTimingIDApple_640x818_75hz    = 165,     /*  640x818  (75 Hz) FPD-818 timing.*/
    kIOTimingIDApple_832x624_75hz    = 170,     /*  832x624  (75 Hz) GoldFish timing.*/
    kIOTimingIDVESA_800x600_56hz     = 180,     /*  800x600  (56 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_60hz     = 182,     /*  800x600  (60 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_72hz     = 184,     /*  800x600  (72 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_75hz     = 186,     /*  800x600  (75 Hz) SVGA timing. */
    kIOTimingIDVESA_800x600_85hz     = 188,     /*  800x600  (85 Hz) SVGA timing. */
    kIOTimingIDVESA_1024x768_60hz    = 190,     /* 1024x768  (60 Hz) VESA 1K-60Hz timing. */
    kIOTimingIDVESA_1024x768_70hz    = 200,     /* 1024x768  (70 Hz) VESA 1K-70Hz timing. */
    kIOTimingIDVESA_1024x768_75hz    = 204,     /* 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to kIOTimingIDApple_1024x768_75hz). */
    kIOTimingIDVESA_1024x768_85hz    = 208,     /* 1024x768  (85 Hz) VESA timing. */
    kIOTimingIDApple_1024x768_75hz   = 210,     /* 1024x768  (75 Hz) Apple 19" RGB. */
    kIOTimingIDVESA_1152x864_75hz    = 215,     /* 1152x864  (75 Hz) VESA timing. */
    kIOTimingIDApple_1152x870_75hz   = 220,     /* 1152x870  (75 Hz) Apple 21" RGB. */
    kIOTimingIDAppleNTSC_ST          = 230,     /*  512x384  (60 Hz, interlaced, non-convolved). */
    kIOTimingIDAppleNTSC_FF          = 232,     /*  640x480  (60 Hz, interlaced, non-convolved). */
    kIOTimingIDAppleNTSC_STconv      = 234,     /*  512x384  (60 Hz, interlaced, convolved). */
    kIOTimingIDAppleNTSC_FFconv      = 236,     /*  640x480  (60 Hz, interlaced, convolved). */
    kIOTimingIDApplePAL_ST           = 238,     /*  640x480  (50 Hz, interlaced, non-convolved). */
    kIOTimingIDApplePAL_FF           = 240,     /*  768x576  (50 Hz, interlaced, non-convolved). */
    kIOTimingIDApplePAL_STconv       = 242,     /*  640x480  (50 Hz, interlaced, convolved). */
    kIOTimingIDApplePAL_FFconv       = 244,     /*  768x576  (50 Hz, interlaced, convolved). */
    kIOTimingIDVESA_1280x960_75hz    = 250,     /* 1280x960  (75 Hz) */
    kIOTimingIDVESA_1280x960_60hz    = 252,     /* 1280x960  (60 Hz) */
    kIOTimingIDVESA_1280x960_85hz    = 254,     /* 1280x960  (85 Hz) */
    kIOTimingIDVESA_1280x1024_60hz   = 260,     /* 1280x1024 (60 Hz) */
    kIOTimingIDVESA_1280x1024_75hz   = 262,     /* 1280x1024 (75 Hz) */
    kIOTimingIDVESA_1280x1024_85hz   = 268,     /* 1280x1024 (85 Hz) */
    kIOTimingIDVESA_1600x1200_60hz   = 280,     /* 1600x1200 (60 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_65hz   = 282,     /* 1600x1200 (65 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_70hz   = 284,     /* 1600x1200 (70 Hz) VESA timing. */
    kIOTimingIDVESA_1600x1200_75hz   = 286,     /* 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). */
    kIOTimingIDVESA_1600x1200_80hz   = 288,     /* 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. */
    kIOTimingIDVESA_1600x1200_85hz   = 289,     /* 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). */
    kIOTimingIDVESA_1792x1344_60hz   = 296,     /* 1792x1344 (60 Hz) VESA timing (204.75 Mhz dot clock). */
    kIOTimingIDVESA_1792x1344_75hz   = 298,     /* 1792x1344 (75 Hz) VESA timing (261.75 Mhz dot clock). */
    kIOTimingIDVESA_1856x1392_60hz   = 300,     /* 1856x1392 (60 Hz) VESA timing (218.25 Mhz dot clock). */
    kIOTimingIDVESA_1856x1392_75hz   = 302,     /* 1856x1392 (75 Hz) VESA timing (288 Mhz dot clock). */
    kIOTimingIDVESA_1920x1440_60hz   = 304,     /* 1920x1440 (60 Hz) VESA timing (234 Mhz dot clock). */
    kIOTimingIDVESA_1920x1440_75hz   = 306,     /* 1920x1440 (75 Hz) VESA timing (297 Mhz dot clock). */
    kIOTimingIDSMPTE240M_60hz        = 400,     /* 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. */
    kIOTimingIDFilmRate_48hz         = 410,     /* 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. */
    kIOTimingIDSony_1600x1024_76hz   = 500,     /* 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). */
    kIOTimingIDSony_1920x1080_60hz   = 510,     /* 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). */
    kIOTimingIDSony_1920x1080_72hz   = 520,     /* 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). */
    kIOTimingIDSony_1920x1200_76hz   = 540,     /* 1900x1200 (76 Hz) Sony timing (pixel clock is 243.20 Mhz dot clock). */
    kIOTimingIDApple_0x0_0hz_Offline = 550,     /* Indicates that this timing will take the display off-line and remove it from the system. */
    kIOTimingIDVESA_848x480_60hz     = 570,     /*  848x480 (60 Hz)  VESA timing. */
    kIOTimingIDVESA_1360x768_60hz    = 590      /* 1360x768 (60 Hz)  VESA timing. */
};

// framebuffer property keys

#define kIOFramebufferInfoKey           "IOFramebufferInformation"

#define kIOFBWidthKey                   "IOFBWidth"
#define kIOFBHeightKey                  "IOFBHeight"
#define kIOFBRefreshRateKey             "IOFBRefreshRate"
#define kIOFBFlagsKey                   "IOFBFlags"
#define kIOFBBytesPerRowKey             "IOFBBytesPerRow"
#define kIOFBBytesPerPlaneKey           "IOFBBytesPerPlane"
#define kIOFBBitsPerPixelKey            "IOFBBitsPerPixel"
#define kIOFBComponentCountKey          "IOFBComponentCount"
#define kIOFBBitsPerComponentKey        "IOFBBitsPerComponent"

#define kIOFBDetailedTimingsKey         "IOFBDetailedTimings"
#define kIOFBTimingRangeKey             "IOFBTimingRange"
#define kIOFBScalerInfoKey              "IOFBScalerInfo"
#define kIOFBCursorInfoKey              "IOFBCursorInfo"
#define kIOFBHDMIDongleROMKey           "IOFBHDMIDongleROM"

#define kIOFBHostAccessFlagsKey         "IOFBHostAccessFlags"

#define kIOFBMemorySizeKey              "IOFBMemorySize"

#define kIOFBNeedsRefreshKey            "IOFBNeedsRefresh"

#define kIOFBProbeOptionsKey            "IOFBProbeOptions"

#define kIOFBGammaWidthKey              "IOFBGammaWidth"
#define kIOFBGammaCountKey              "IOFBGammaCount"
#define kIOFBCLUTDeferKey               "IOFBCLUTDefer"

#define kIOFBDisplayPortConfigurationDataKey    "dpcd-registers"
        
// exists on the hibernate progress display device
#ifndef kIOHibernatePreviewActiveKey
#define kIOHibernatePreviewActiveKey    "IOHibernatePreviewActive"
// values for kIOHibernatePreviewActiveKey set by driver
enum {
    kIOHibernatePreviewActive  = 0x00000001,
    kIOHibernatePreviewUpdates = 0x00000002
};
#endif

#define kIOHibernateEFIGfxStatusKey    "IOHibernateEFIGfxStatus"

// CFNumber/CFData
#define kIOFBAVSignalTypeKey            "av-signal-type"
enum {
    kIOFBAVSignalTypeUnknown = 0x00000000,
    kIOFBAVSignalTypeVGA     = 0x00000001,
    kIOFBAVSignalTypeDVI     = 0x00000002,
    kIOFBAVSignalTypeHDMI    = 0x00000008,
    kIOFBAVSignalTypeDP      = 0x00000010,
};

// kIOFBDisplayPortTrainingAttribute data

struct IOFBDPLinkConfig
{
    uint16_t version;		 // 8 bit high (major); 8 bit low (minor)
    uint8_t  bitRate;		 // same encoding as the spec
    uint8_t  __reservedA[1]; // reserved set to zero
	uint16_t t1Time;		 // minimum duration of the t1 pattern (microseconds)
	uint16_t t2Time;		 // minimum duration of the t2 pattern
	uint16_t t3Time;		 // minimum duration of the t3 pattern
	uint8_t  idlePatterns;   // minimum number of idle patterns
	uint8_t  laneCount;		 // number of lanes in the link
	uint8_t  voltage;
	uint8_t  preEmphasis;
	uint8_t  downspread;
	uint8_t  scrambler;
	uint8_t  maxBitRate;	 // same encoding as the bitRate field
	uint8_t  maxLaneCount;	 // an integer
	uint8_t  maxDownspread;	 // 0 = Off. 1 = 0.5
	uint8_t  __reservedB[9];	// reserved set to zero - fix align and provide 8 bytes of padding.
};
typedef struct IOFBDPLinkConfig IOFBDPLinkConfig;

enum
{
    kIOFBBitRateRBR		= 0x06,		// 1.62 Gbps per lane
    kIOFBBitRateHBR		= 0x0A,		// 2.70 Gbps per lane
    kIOFBBitRateHBR2	= 0x14,		// 5.40 Gbps per lane
};

enum {
    kIOFBLinkVoltageLevel0	= 0x00,
    kIOFBLinkVoltageLevel1	= 0x01,
    kIOFBLinkVoltageLevel2	= 0x02,
    kIOFBLinkVoltageLevel3	= 0x03
};

enum
{
    kIOFBLinkPreEmphasisLevel0 = 0x00,
    kIOFBLinkPreEmphasisLevel1 = 0x01,
    kIOFBLinkPreEmphasisLevel2 = 0x02,
    kIOFBLinkPreEmphasisLevel3 = 0x03
};

enum
{
    kIOFBLinkDownspreadNone  = 0x0,
    kIOFBLinkDownspreadMax   = 0x1
};

enum
{
    kIOFBLinkScramblerNormal    = 0x0, // for external displays
    kIOFBLinkScramblerAlternate = 0x1  // used for eDP
};

// diagnostic keys

#define kIOFBConfigKey                  "IOFBConfig"
#define kIOFBModesKey                   "IOFBModes"
#define kIOFBModeIDKey                  "ID"
#define kIOFBModeDMKey                  "DM"
#define kIOFBModeTMKey                  "TM"
#define kIOFBModeAIDKey                 "AID"
#define kIOFBModeDFKey                  "DF"
#define kIOFBModePIKey                  "PI"

// display property keys

#define kIODisplayEDIDKey               "IODisplayEDID"
#define kIODisplayEDIDOriginalKey       "IODisplayEDIDOriginal"
#define kIODisplayLocationKey           "IODisplayLocation"             // CFString
#define kIODisplayConnectFlagsKey       "IODisplayConnectFlags"         // CFNumber
#define kIODisplayHasBacklightKey       "IODisplayHasBacklight"         // CFBoolean
#define kIODisplayIsDigitalKey          "IODisplayIsDigital"            // CFBoolean
#define kDisplayBundleKey               "DisplayBundle"

#define kAppleDisplayTypeKey            "AppleDisplayType"
#define kAppleSenseKey                  "AppleSense"

#define kIODisplayMCCSVersionKey                "IODisplayMCCSVersion"
#define kIODisplayTechnologyTypeKey             "IODisplayTechnologyType"
#define kIODisplayUsageTimeKey                  "IODisplayUsageTime"
#define kIODisplayFirmwareLevelKey              "IODisplayFirmwareLevel"

enum {
    kDisplayVendorIDUnknown     = 'unkn',
    kDisplayProductIDGeneric    = 0x717
};

#define kDisplayVendorID                "DisplayVendorID"        // CFNumber
#define kDisplayProductID               "DisplayProductID"       // CFNumber
#define kDisplaySerialNumber            "DisplaySerialNumber"    // CFNumber
#define kDisplaySerialString            "DisplaySerialString"    // CFString
#define kDisplayWeekOfManufacture       "DisplayWeekManufacture" // CFNumber
#define kDisplayYearOfManufacture       "DisplayYearManufacture" // CFNumber

// CFDictionary of language-locale keys, name values
// eg. "en"="Color LCD", "en-GB"="Colour LCD"
#define kDisplayProductName             "DisplayProductName"

// all CFNumber or CFArray of CFNumber (floats)
#define kDisplayWhitePointX             "DisplayWhitePointX"
#define kDisplayWhitePointY             "DisplayWhitePointY"
#define kDisplayRedPointX               "DisplayRedPointX"
#define kDisplayRedPointY               "DisplayRedPointY"
#define kDisplayGreenPointX             "DisplayGreenPointX"
#define kDisplayGreenPointY             "DisplayGreenPointY"
#define kDisplayBluePointX              "DisplayBluePointX"
#define kDisplayBluePointY              "DisplayBluePointY"
#define kDisplayWhiteGamma              "DisplayWhiteGamma"
#define kDisplayRedGamma                "DisplayRedGamma"
#define kDisplayGreenGamma              "DisplayGreenGamma"
#define kDisplayBlueGamma               "DisplayBlueGamma"

// Display gamma
#define kDisplayGammaChannels           "DisplayGammaChannels"    // CFNumber 1 or 3 channel count
#define kDisplayGammaEntryCount         "DisplayGammaEntryCount"  // CFNumber 1-based count of entries per channel
#define kDisplayGammaEntrySize          "DisplayGammaEntrySize"   // CFNumber size in bytes of each table entry
#define kDisplayGammaTable              "DisplayGammaTable"       // CFData

// CFBoolean
#define kDisplayBrightnessAffectsGamma  "DisplayBrightnessAffectsGamma"
#define kDisplayViewAngleAffectsGamma   "DisplayViewAngleAffectsGamma"

// CFData
#define kDisplayCSProfile               "DisplayCSProfile"

// CFNumber
#define kDisplayHorizontalImageSize     "DisplayHorizontalImageSize"
#define kDisplayVerticalImageSize       "DisplayVerticalImageSize"

// Pixel description

// CFBoolean
#define kDisplayFixedPixelFormat        "DisplayFixedPixelFormat"

enum {
    kDisplaySubPixelLayoutUndefined     = 0x00000000,
    kDisplaySubPixelLayoutRGB           = 0x00000001,
    kDisplaySubPixelLayoutBGR           = 0x00000002,
    kDisplaySubPixelLayoutQuadGBL       = 0x00000003,
    kDisplaySubPixelLayoutQuadGBR       = 0x00000004,

    kDisplaySubPixelConfigurationUndefined    = 0x00000000,
    kDisplaySubPixelConfigurationDelta        = 0x00000001,
    kDisplaySubPixelConfigurationStripe       = 0x00000002,
    kDisplaySubPixelConfigurationStripeOffset = 0x00000003,
    kDisplaySubPixelConfigurationQuad         = 0x00000004,

    kDisplaySubPixelShapeUndefined      = 0x00000000,
    kDisplaySubPixelShapeRound          = 0x00000001,
    kDisplaySubPixelShapeSquare         = 0x00000002,
    kDisplaySubPixelShapeRectangular    = 0x00000003,
    kDisplaySubPixelShapeOval           = 0x00000004,
    kDisplaySubPixelShapeElliptical     = 0x00000005
};

// CFNumbers
#define kDisplaySubPixelLayout          "DisplaySubPixelLayout"
#define kDisplaySubPixelConfiguration   "DisplaySubPixelConfiguration"
#define kDisplaySubPixelShape           "DisplaySubPixelShape"

#define kIODisplayOverrideMatchingKey   "IODisplayOverrideMatching"

// Display parameters

#define kIODisplayParametersKey         "IODisplayParameters"
#define kIODisplayGUIDKey               "IODisplayGUID"

#define kIODisplayValueKey              "value"
#define kIODisplayMinValueKey           "min"
#define kIODisplayMaxValueKey           "max"

#define kIODisplayBrightnessKey             "brightness"
#define kIODisplayLinearBrightnessKey       "linear-brightness"
#define kIODisplayUsableLinearBrightnessKey "usable-linear-brightness"
#define kIODisplayBrightnessFadeKey         "brightness-fade"
#define kIODisplayContrastKey               "contrast"
#define kIODisplayHorizontalPositionKey     "horizontal-position"
#define kIODisplayHorizontalSizeKey     	"horizontal-size"
#define kIODisplayVerticalPositionKey   	"vertical-position"
#define kIODisplayVerticalSizeKey           "vertical-size"
#define kIODisplayTrapezoidKey              "trapezoid"
#define kIODisplayPincushionKey             "pincushion"
#define kIODisplayParallelogramKey          "parallelogram"
#define kIODisplayRotationKey               "rotation"
#define kIODisplayTheatreModeKey            "theatre-mode"
#define kIODisplayTheatreModeWindowKey      "theatre-mode-window"
#define kIODisplayOverscanKey               "oscn"
#define kIODisplayVideoBestKey              "vbst"

#define kIODisplaySpeakerVolumeKey              "speaker-volume"
#define kIODisplaySpeakerSelectKey              "speaker-select"
#define kIODisplayMicrophoneVolumeKey           "microphone-volume"
#define kIODisplayAmbientLightSensorKey         "ambient-light-sensor"
#define kIODisplayAudioMuteAndScreenBlankKey    "audio-mute-and-screen-blank"
#define kIODisplayAudioTrebleKey                "audio-treble"
#define kIODisplayAudioBassKey                  "audio-bass"
#define kIODisplayAudioBalanceLRKey             "audio-balance-LR"
#define kIODisplayAudioProcessorModeKey         "audio-processor-mode"
#define kIODisplayPowerModeKey                  "power-mode"
#define kIODisplayManufacturerSpecificKey       "manufacturer-specific"

#define kIODisplayPowerStateKey       			"dsyp"

#define kIODisplayControllerIDKey				"IODisplayControllerID"
#define kIODisplayCapabilityStringKey       	"IODisplayCapabilityString"

#define kIODisplayRedGammaScaleKey      "rgsc"
#define kIODisplayGreenGammaScaleKey    "ggsc"
#define kIODisplayBlueGammaScaleKey     "bgsc"
#define kIODisplayGammaScaleKey         "gsc "

#define kIODisplayParametersCommitKey   "commit"
#define kIODisplayParametersDefaultKey  "defaults"
#define kIODisplayParametersFlushKey    "flush"

#ifdef __cplusplus
}
#endif

#endif /* ! _IOKIT_IOGRAPHICSTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                  hid/                                                                                                0040755 0001750 0001750 00000000000 12612224741 031343  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOHIDBase.h                                                                                         0100644 0001750 0001750 00000016736 12566177313 033167  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDBASE_H_
#define _IOKIT_HID_IOHIDBASE_H_

#include <IOKit/hid/IOHIDKeys.h>

__BEGIN_DECLS

/*! @typedef IOHIDDeviceRef
	This is the type of a reference to the IOHIDDevice.
*/
typedef struct __IOHIDDevice * IOHIDDeviceRef;

/*! @typedef IOHIDElementRef
	This is the type of a reference to the IOHIDElement.
*/
typedef struct __IOHIDElement * IOHIDElementRef;

/*! @typedef IOHIDValueRef
	This is the type of a reference to the IOHIDValue.
*/
typedef struct __IOHIDValue * IOHIDValueRef;

/*!
    @typedef    IOHIDTransactionDirectionType
    @abstract   Direction for an IOHIDDeviceTransactionInterface.
    @constant   kIOHIDTransactionDirectionTypeInput Transaction direction used for requesting element values from a device. 
    @constant   kIOHIDTransactionDirectionTypeOutput Transaction direction used for dispatching element values to a device. 
*/
enum {
    kIOHIDTransactionDirectionTypeInput,
    kIOHIDTransactionDirectionTypeOutput
};
typedef uint32_t IOHIDTransactionDirectionType;

/*!
    @enum       IOHIDTransactionOption
    @abstract   Options to be used in conjuntion with an IOHIDDeviceTransactionInterface.
    @constant   kIOHIDTransactionOptionDefaultOutputValue Option to set the default element value to be used with an
                IOHIDDeviceTransactionInterface of direction kIOHIDTransactionDirectionTypeOutput. 
*/
enum {
    kIOHIDTransactionOptionDefaultOutputValue = 0x0001
};


/*! @typedef IOHIDCallback
    @discussion Type and arguments of callout C function that is used when a completion routine is called.
    @param context void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param refcon void * pointer to more data.
    @param sender Interface instance sending the completion routine.
*/
typedef void (*IOHIDCallback)(
                                    void *                  context, 
                                    IOReturn                result, 
                                    void *                  sender);

/*! @typedef IOHIDReportCallback
    @discussion Type and arguments of callout C function that is used when a HID report completion routine is called.
    @param context void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param sender Interface instance sending the completion routine.
    @param type The type of the report that was completed.
    @param reportID The ID of the report that was completed.
    @param report Pointer to the buffer containing the contents of the report.
    @param reportLength Size of the buffer received upon completion.
*/
typedef void (*IOHIDReportCallback) (
                                    void *                  context, 
                                    IOReturn                result, 
                                    void *                  sender, 
                                    IOHIDReportType         type, 
                                    uint32_t                reportID,
                                    uint8_t *               report, 
                                    CFIndex                 reportLength);

/*! @typedef IOHIDReportCallback
    @discussion Type and arguments of callout C function that is used when a HID report completion routine is called.
    @param context void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param sender Interface instance sending the completion routine.
    @param type The type of the report that was completed.
    @param reportID The ID of the report that was completed.
    @param report Pointer to the buffer containing the contents of the report.
    @param reportLength Size of the buffer received upon completion.
    @param timeStamp The time at which the report arrived.
*/
typedef void (*IOHIDReportWithTimeStampCallback) (
                                    void *                  context, 
                                    IOReturn                result, 
                                    void *                  sender, 
                                    IOHIDReportType         type, 
                                    uint32_t                reportID,
                                    uint8_t *               report, 
                                    CFIndex                 reportLength,
                                    uint64_t                timeStamp);

/*! @typedef IOHIDValueCallback
    @discussion Type and arguments of callout C function that is used when an element value completion routine is called.
    @param context void * pointer to more data.
    @param result Completion result of desired operation.
    @param sender Interface instance sending the completion routine.
    @param value IOHIDValueRef containing the returned element value.
*/
typedef void (*IOHIDValueCallback) ( 
                                    void *                  context,
                                    IOReturn                result, 
                                    void *                  sender,
                                    IOHIDValueRef           value);

/*! @typedef IOHIDValueMultipleCallback
    @discussion Type and arguments of callout C function that is used when an element value completion routine is called.
    @param context void * pointer to more data.
    @param result Completion result of desired operation.
    @param sender Interface instance sending the completion routine.
    @param multiple CFDictionaryRef containing the returned element key value pairs.
*/
typedef void (*IOHIDValueMultipleCallback) ( 
                                    void *                  context,
                                    IOReturn                result, 
                                    void *                  sender,
                                    CFDictionaryRef         multiple);

/*! @typedef IOHIDDeviceCallback
    @discussion Type and arguments of callout C function that is used when a device routine is called.
    @param context void * pointer to more data.
    @param result Completion result of desired operation.
    @param device IOHIDDeviceRef containing the sending device.
*/
typedef void (*IOHIDDeviceCallback) ( 
                                    void *                  context,
                                    IOReturn                result, 
                                    void *                  sender,
                                    IOHIDDeviceRef          device);

__END_DECLS
#endif /* _IOKIT_HID_IOHIDBASE_H_ */
                                  IOHIDDevice.h                                                                                       0100644 0001750 0001750 00000100544 12566177313 033503  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDDEVICE_USER_H
#define _IOKIT_HID_IOHIDDEVICE_USER_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/hid/IOHIDBase.h>

/*!
	@header IOHIDDevice
    IOHIDDevice defines a Human Interface Device (HID) object, which interacts 
    with an IOHIDDevicePlugIn object that typically maps to an object in the 
    kernel.  IOHIDDevice is used to communicate with a single HID device in 
    order to obtain or set device properties, element values, and reports.
    IOHIDDevice is also a CFType object and as such conforms to all the 
    conventions expected such object.
    <p>
    This documentation assumes that you have a basic understanding of the 
    material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as 
    matching dictionary, family, and driver, see the overview of I/O Kit terms 
    and concepts n the "Device Access and the I/O Kit" chapter of 
    <i>Accessing Hardware From Applications</i>.

    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header 
    file <font face="Courier New,Courier,Monaco">IOHIDDevice.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDDevice.h</font>.
*/

__BEGIN_DECLS

/*!
	@function   IOHIDDeviceGetTypeID
	@abstract   Returns the type identifier of all IOHIDDevice instances.
*/
CF_EXPORT
CFTypeID IOHIDDeviceGetTypeID(void)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDDeviceCreate
	@abstract   Creates an element from an io_service_t.
    @discussion The io_service_t passed in this method must reference an object 
                in the kernel of type IOHIDDevice.
    @param      allocator Allocator to be used during creation.
    @param      service Reference to service object in the kernel.
    @result     Returns a new IOHIDDeviceRef.
*/
CF_EXPORT
IOHIDDeviceRef IOHIDDeviceCreate(
                                CFAllocatorRef                  allocator, 
                                io_service_t                    service)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
    @function   IOHIDDeviceGetService
    @abstract   Returns the io_service_t for an IOHIDDevice, if it has one.
    @discussion If the IOHIDDevice references an object in the kernel, this is
                used to get the io_service_t for that object.
    @param      device Reference to an IOHIDDevice.
    @result     Returns the io_service_t if the IOHIDDevice has one, or 
                MACH_PORT_NULL if it does not.
 */
CF_EXPORT
io_service_t IOHIDDeviceGetService(
                                 IOHIDDeviceRef                  device)
AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
	@function   IOHIDDeviceOpen
	@abstract   Opens a HID device for communication.
    @discussion Before the client can issue commands that change the state of 
                the device, it must have succeeded in opening the device. This 
                establishes a link between the client's task and the actual 
                device.  To establish an exclusive link use the 
                kIOHIDOptionsTypeSeizeDevice option. 
    @param      device Reference to an IOHIDDevice.
    @param      options Option bits to be sent down to the device.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceOpen(          
                                IOHIDDeviceRef                  device, 
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDDeviceClose
	@abstract   Closes communication with a HID device.
    @discussion This closes a link between the client's task and the actual 
                device.
    @param      device Reference to an IOHIDDevice.
    @param      options Option bits to be sent down to the device.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceClose(
                                IOHIDDeviceRef                  device, 
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDDeviceConformsTo
	@abstract   Convenience function that scans the Application Collection 
                elements to see if it conforms to the provided usagePage 
                and usage.
    @discussion Examples of Application Collection usages pairs are:
                <br>
                    usagePage = kHIDPage_GenericDesktop  <br>
                    usage = kHIDUsage_GD_Mouse
                <br>
                <b>or</b>
                <br>
                    usagePage = kHIDPage_GenericDesktop  <br>
                    usage = kHIDUsage_GD_Keyboard
    @param      device Reference to an IOHIDDevice.
    @param      usagePage Device usage page
    @param      usage Device usage
    @result     Returns TRUE if device conforms to provided usage.
*/
CF_EXPORT
Boolean IOHIDDeviceConformsTo(          
                                IOHIDDeviceRef                  device, 
                                uint32_t                        usagePage,
                                uint32_t                        usage)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*!
	@function   IOHIDDeviceGetProperty
	@abstract   Obtains a property from an IOHIDDevice.
    @discussion Property keys are prefixed by kIOHIDDevice and declared in 
                <IOKit/hid/IOHIDKeys.h>.
    @param      device Reference to an IOHIDDevice.
    @param      key CFStringRef containing key to be used when querying the 
                device.
    @result     Returns CFTypeRef containing the property.
*/
CF_EXPORT
CFTypeRef IOHIDDeviceGetProperty(
                                IOHIDDeviceRef                  device, 
                                CFStringRef                     key)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDDeviceSetProperty
	@abstract   Sets a property for an IOHIDDevice.
    @discussion Property keys are prefixed by kIOHIDDevice and declared in 
                <IOKit/hid/IOHIDKeys.h>.
    @param      device Reference to an IOHIDDevice.
    @param      key CFStringRef containing key to be used when modifiying the 
                device property.
    @param      property CFTypeRef containg the property to be set.
    @result     Returns TRUE if successful.
*/
CF_EXPORT
Boolean IOHIDDeviceSetProperty(
                                IOHIDDeviceRef                  device,
                                CFStringRef                     key,
                                CFTypeRef                       property)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDDeviceCopyMatchingElements
    @abstract   Obtains HID elements that match the criteria contained in the 
                matching dictionary.
    @discussion Matching keys are prefixed by kIOHIDElement and declared in 
                <IOKit/hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
                in all device elements being returned.
    @param      device Reference to an IOHIDDevice.
    @param      matching CFDictionaryRef containg element matching criteria.
    @param      options Reserved for future use.
    @result     Returns CFArrayRef containing multiple IOHIDElement object.
*/
CF_EXPORT 
CFArrayRef IOHIDDeviceCopyMatchingElements(
                                IOHIDDeviceRef                  device, 
                                CFDictionaryRef                 matching, 
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceScheduleWithRunLoop
    @abstract   Schedules HID device with run loop.
    @discussion Formally associates device with client's run loop. Scheduling
                this device with the run loop is necessary before making use of
                any asynchronous APIs.
    @param      device Reference to an IOHIDDevice.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDDeviceScheduleWithRunLoop(
                                IOHIDDeviceRef                  device, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceUnscheduleFromRunLoop
    @abstract   Unschedules HID device with run loop.
    @discussion Formally disassociates device with client's run loop.
    @param      device Reference to an IOHIDDevice.
    @param      runLoop RunLoop to be used when unscheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when unscheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDDeviceUnscheduleFromRunLoop(  
                                IOHIDDeviceRef                  device, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceRegisterRemovalCallback
    @abstract   Registers a callback to be used when a IOHIDDevice is removed.
    @discussion In most cases this occurs when a device is unplugged.
    @param      device Reference to an IOHIDDevice.
    @param      callback Pointer to a callback method of type IOHIDCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDDeviceRegisterRemovalCallback( 
                                IOHIDDeviceRef                  device, 
                                IOHIDCallback                   callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceRegisterInputValueCallback
    @abstract   Registers a callback to be used when an input value is issued by 
                the device.
    @discussion An input element refers to any element of type 
                kIOHIDElementTypeInput and is usually issued by interrupt driven
                reports.  If more specific element values are desired, you can 
                specify matching criteria via IOHIDDeviceSetInputValueMatching
                and IOHIDDeviceSetInputValueMatchingMultiple.
    @param      device Reference to an IOHIDDevice.
    @param      callback Pointer to a callback method of type IOHIDValueCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDDeviceRegisterInputValueCallback(
                                IOHIDDeviceRef                  device, 
                                IOHIDValueCallback              callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceRegisterInputReportCallback
    @abstract   Registers a callback to be used when an input report is issued 
                by the device.
    @discussion An input report is an interrupt driver report issued by the 
                device.
    @param      device Reference to an IOHIDDevice.
    @param      report Pointer to preallocated buffer in which to copy inbound
                report data.
    @param      reportLength Length of preallocated buffer.
    @param      callback Pointer to a callback method of type 
                IOHIDReportCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDDeviceRegisterInputReportCallback( 
                                IOHIDDeviceRef                  device, 
                                uint8_t *                       report, 
                                CFIndex                         reportLength,
                                IOHIDReportCallback             callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceRegisterInputReportWithTimeStampCallback
    @abstract   Registers a timestamped callback to be used when an input report is issued 
                by the device.
    @discussion An input report is an interrupt driver report issued by the 
                device.
    @param      device Reference to an IOHIDDevice.
    @param      report Pointer to preallocated buffer in which to copy inbound
                report data.
    @param      reportLength Length of preallocated buffer.
    @param      callback Pointer to a callback method of type 
                IOHIDReportWithTimeStampCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDDeviceRegisterInputReportWithTimeStampCallback(
                                IOHIDDeviceRef                      device, 
                                uint8_t *                           report, 
                                CFIndex                             reportLength,
                                IOHIDReportWithTimeStampCallback    callback, 
                                void *                              context)
AVAILABLE_MAC_OS_X_VERSION_10_10_AND_LATER;

/*! @function   IOHIDDeviceSetInputValueMatching
    @abstract   Sets matching criteria for input values received via 
                IOHIDDeviceRegisterInputValueCallback.
    @discussion Matching keys are prefixed by kIOHIDElement and declared in 
                <IOKit/hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
                in all devices being enumerated. Any subsequent calls will cause
                the hid manager to release previously matched input elements and 
                restart the matching process using the revised criteria.  If 
                interested in multiple, specific device elements, please defer to
                using IOHIDDeviceSetInputValueMatchingMultiple.
    @param      device Reference to an IOHIDDevice.
    @param      matching CFDictionaryRef containg device matching criteria.
*/
CF_EXPORT
void IOHIDDeviceSetInputValueMatching(
                                IOHIDDeviceRef                  device, 
                                CFDictionaryRef                 matching)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDDeviceSetInputValueMatchingMultiple
    @abstract   Sets multiple matching criteria for input values received via 
                IOHIDDeviceRegisterInputValueCallback.
    @discussion Matching keys are prefixed by kIOHIDElement and declared in 
                <IOKit/hid/IOHIDKeys.h>.  This method is useful if interested 
                in multiple, specific elements .
    @param      device Reference to an IOHIDDevice.
    @param      multiple CFArrayRef containing multiple CFDictionaryRef objects
                containg input element matching criteria.
*/
CF_EXPORT
void IOHIDDeviceSetInputValueMatchingMultiple(
                                IOHIDDeviceRef                  device, 
                                CFArrayRef                      multiple)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDDeviceSetValue
    @abstract   Sets a value for an element.
    @discussion This method behaves synchronously and will block until the
                report has been issued to the device.  It is only relevent for 
                either output or feature type elements.  If setting values for 
                multiple elements you may want to consider using 
                IOHIDDeviceSetValueMultiple or IOHIDTransaction.
    @param      device Reference to an IOHIDDevice.
    @param      element IOHIDElementRef whose value is to be modified.
    @param      value IOHIDValueRef containing value to be set.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetValue(
                                IOHIDDeviceRef                  device, 
                                IOHIDElementRef                 element, 
                                IOHIDValueRef                   value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceSetValueMultiple
    @abstract   Sets multiple values for multiple elements.
    @discussion This method behaves synchronously and will block until the
                report has been issued to the device.  It is only relevent for 
                either output or feature type elements.
    @param      device Reference to an IOHIDDevice.
    @param      multiple CFDictionaryRef where key is IOHIDElementRef and
                value is IOHIDValueRef.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetValueMultiple(
                                IOHIDDeviceRef                  device, 
                                CFDictionaryRef                 multiple)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceSetValueWithCallback
    @abstract   Sets a value for an element and returns status via a completion
                callback.
    @discussion This method behaves asynchronously and will invoke the callback
                once the report has been issued to the device.  It is only 
                relevent for either output or feature type elements.  
                If setting values for multiple elements you may want to 
                consider using IOHIDDeviceSetValueWithCallback or 
                IOHIDTransaction.
    @param      device Reference to an IOHIDDevice.
    @param      element IOHIDElementRef whose value is to be modified.
    @param      value IOHIDValueRef containing value to be set.
    @param      timeout CFTimeInterval containing the timeout.
    @param      callback Pointer to a callback method of type 
                IOHIDValueCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetValueWithCallback(
                                IOHIDDeviceRef                  device, 
                                IOHIDElementRef                 element, 
                                IOHIDValueRef                   value, 
                                CFTimeInterval                  timeout,
                                IOHIDValueCallback              callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceSetValueMultipleWithCallback
    @abstract   Sets multiple values for multiple elements and returns status 
                via a completion callback.
    @discussion This method behaves asynchronously and will invoke the callback
                once the report has been issued to the device.  It is only 
                relevent for either output or feature type elements.  
    @param      device Reference to an IOHIDDevice.
    @param      multiple CFDictionaryRef where key is IOHIDElementRef and
                value is IOHIDValueRef.
    @param      timeout CFTimeInterval containing the timeout.
    @param      callback Pointer to a callback method of type 
                IOHIDValueMultipleCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetValueMultipleWithCallback(
                                IOHIDDeviceRef                  device, 
                                CFDictionaryRef                 multiple,
                                CFTimeInterval                  timeout,
                                IOHIDValueMultipleCallback      callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceGetValue
    @abstract   Gets a value for an element.
    @discussion This method behaves synchronously and return back immediately
                for input type element.  If requesting a value for a feature
                element, this will block until the report has been issued to the
                device.  If obtaining values for multiple elements you may want 
                to consider using IOHIDDeviceCopyValueMultiple or IOHIDTransaction.
    @param      device Reference to an IOHIDDevice.
    @param      element IOHIDElementRef whose value is to be obtained.
    @param      pValue Pointer to IOHIDValueRef to be obtained.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceGetValue(
                                IOHIDDeviceRef                  device, 
                                IOHIDElementRef                 element, 
                                IOHIDValueRef *                 pValue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceCopyValueMultiple
    @abstract   Copies a values for multiple elements.
    @discussion This method behaves synchronously and return back immediately
                for input type element.  If requesting a value for a feature
                element, this will block until the report has been issued to the
                device.
    @param      device Reference to an IOHIDDevice.
    @param      elements CFArrayRef containing multiple IOHIDElementRefs whose 
                values are to be obtained.
    @param      pMultiple Pointer to CFDictionaryRef where the keys are the 
                provided elements and the values are the requested values.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceCopyValueMultiple(
                                IOHIDDeviceRef                  device, 
                                CFArrayRef                      elements, 
                                CFDictionaryRef *               pMultiple)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceGetValueWithCallback
    @abstract   Gets a value for an element and returns status via a completion
                callback.
    @discussion This method behaves asynchronusly and is only relevent for 
                either output or feature type elements. If obtaining values for 
                multiple elements you may want to consider using 
                IOHIDDeviceCopyValueMultipleWithCallback or IOHIDTransaction.
    @param      device Reference to an IOHIDDevice.
    @param      element IOHIDElementRef whose value is to be obtained.
    @param      pValue Pointer to IOHIDValueRef to be passedback.
    @param      timeout CFTimeInterval containing the timeout.
    @param      callback Pointer to a callback method of type 
                IOHIDValueCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceGetValueWithCallback(
                                IOHIDDeviceRef                  device, 
                                IOHIDElementRef                 element, 
                                IOHIDValueRef *                 pValue,
                                CFTimeInterval                  timeout,
                                IOHIDValueCallback              callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*! @function   IOHIDDeviceCopyValueMultipleWithCallback
    @abstract   Copies a values for multiple elements and returns status via a 
                completion callback.
    @discussion This method behaves asynchronusly and is only relevent for 
                either output or feature type elements.
    @param      device Reference to an IOHIDDevice.
    @param      elements CFArrayRef containing multiple IOHIDElementRefs whose 
                values are to be obtained.
    @param      pMultiple Pointer to CFDictionaryRef where the keys are the 
                provided elements and the values are the requested values.
    @param      timeout CFTimeInterval containing the timeout.
    @param      callback Pointer to a callback method of type 
                IOHIDValueMultipleCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceCopyValueMultipleWithCallback(
                                IOHIDDeviceRef                  device, 
                                CFArrayRef                      elements, 
                                CFDictionaryRef *               pMultiple,
                                CFTimeInterval                  timeout,
                                IOHIDValueMultipleCallback      callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDDeviceSetReport
    @abstract   Sends a report to the device.
    @discussion This method behaves synchronously and will block until the
                report has been issued to the device.  It is only relevent for 
                either output or feature type reports.
    @param      device Reference to an IOHIDDevice.
    @param      reportType Type of report being sent.
    @param      reportID ID of the report being sent.  If the device supports
                multiple reports, this should also be set in the first byte of
                the report.
    @param      report The report bytes to be sent to the device.
    @param      reportLength The length of the report to be sent to the device.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetReport(
                                IOHIDDeviceRef                  device,
                                IOHIDReportType                 reportType,
                                CFIndex                         reportID,
                                const uint8_t *                 report,
                                CFIndex                         reportLength)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDDeviceSetReportWithCallback
    @abstract   Sends a report to the device.
    @discussion This method behaves asynchronously and will block until the
                report has been issued to the device.  It is only relevent for 
                either output or feature type reports.
    @param      device Reference to an IOHIDDevice.
    @param      reportType Type of report being sent.
    @param      reportID ID of the report being sent.  If the device supports
                multiple reports, this should also be set in the first byte of
                the report.
    @param      report The report bytes to be sent to the device.
    @param      reportLength The length of the report to be sent to the device.
    @param      timeout CFTimeInterval containing the timeout.
    @param      callback Pointer to a callback method of type 
                IOHIDReportCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceSetReportWithCallback(
                                IOHIDDeviceRef                  device,
                                IOHIDReportType                 reportType,
                                CFIndex                         reportID,
                                const uint8_t *                 report,
                                CFIndex                         reportLength,
                                CFTimeInterval                  timeout,
                                IOHIDReportCallback             callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceGetReport
    @abstract   Obtains a report from the device.
    @discussion This method behaves synchronously and will block until the
                report has been received from the device.  This is only intended 
                for feature reports because of sporadic devicesupport for 
                polling input reports.  Please defer to using 
                IOHIDDeviceRegisterInputReportCallback for obtaining input 
                reports.
    @param      device Reference to an IOHIDDevice.
    @param      reportType Type of report being requested.
    @param      reportID ID of the report being requested.
    @param      report Pointer to preallocated buffer in which to copy inbound
                report data.
    @param      pReportLength Pointer to length of preallocated buffer.  This
                value will be modified to refect the length of the returned 
                report.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceGetReport(
                                IOHIDDeviceRef                  device,
                                IOHIDReportType                 reportType,
                                CFIndex                         reportID,
                                uint8_t *                       report,
                                CFIndex *                       pReportLength)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDDeviceGetReportWithCallback
    @abstract   Obtains a report from the device.
    @discussion This method behaves asynchronously and will block until the
                report has been received from the device.  This is only intended 
                for feature reports because of sporadic devicesupport for 
                polling input reports.  Please defer to using 
                IOHIDDeviceRegisterInputReportCallback for obtaining input 
                reports.
    @param      device Reference to an IOHIDDevice.
    @param      reportType Type of report being requested.
    @param      reportID ID of the report being requested.
    @param      report Pointer to preallocated buffer in which to copy inbound
                report data.
    @param      pReportLength Pointer to length of preallocated buffer.
    @param      pReportLength Pointer to length of preallocated buffer.  This
                value will be modified to refect the length of the returned 
                report.
    @param      callback Pointer to a callback method of type 
                IOHIDReportCallback.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDDeviceGetReportWithCallback(
                                IOHIDDeviceRef                  device,
                                IOHIDReportType                 reportType,
                                CFIndex                         reportID,
                                uint8_t *                       report,
                                CFIndex *                       pReportLength,
                                CFTimeInterval                  timeout,
                                IOHIDReportCallback             callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
__END_DECLS

#endif /* _IOKIT_HID_IOHIDDEVICE_USER_H */
                                                                                                                                                            IOHIDDevicePlugIn.h                                                                                 0100644 0001750 0001750 00000116741 12566177313 034630  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDDEVICEPLUGIN_H
#define _IOKIT_HID_IOHIDDEVICEPLUGIN_H


#include <sys/cdefs.h>
#include <CoreFoundation/CoreFoundation.h>
#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
#include <CoreFoundation/CFPlugInCOM.h>
#endif

#include <IOKit/IOTypes.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IOCFPlugIn.h>
#include <IOKit/hid/IOHIDBase.h>
#include <IOKit/hid/IOHIDKeys.h>
#include <IOKit/hid/IOHIDLibObsolete.h>

__BEGIN_DECLS
/*! @header IOHIDDevicePlugIn
    This documentation describes the details of the programming interface for accessing Human Interface Devices and
    interfaces from code running in user space.  It is intended that user mode HID drivers properly inplement all
    interfaces described here in order to be visible via the HID Manager.
    <p>
    This documentation assumes that you have a basic understanding
    of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.
    
    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOHIDLib.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDDevicePlugIn.h</font>.
*/


/* 13AA9C44-6F1B-11D4-907C-0005028F18D5 */
/*! @defined kIOHIDDeviceFactoryID
    @discussion This UUID constant is used internally by the system, and 
    should not have to be used by any driver code to access the device interfaces.
*/
#define kIOHIDDeviceFactoryID CFUUIDGetConstantUUIDWithBytes(NULL,	\
    0x13, 0xAA, 0x9C, 0x44, 0x6F, 0x1B, 0x11, 0xD4,			\
    0x90, 0x7C, 0x00, 0x05, 0x02, 0x8F, 0x18, 0xD5)

/* 7DDEECA8-A7B4-11DA-8A0E-0014519758EF */
/*! @defined kIOHIDDeviceTypeID
    @discussion This UUID constant is used to obtain a device interface corresponding to 
    an io_service_t corresponding to an IOHIDDevice in the kernel. Once you have 
    obtained the IOCFPlugInInterface for the service, you must use the QueryInterface 
    function to obtain the device interface for the user client itself.

    Example:
    <pre>
    @textblock
    io_service_t            hidDeviceRef;   // obtained earlier
        
    IOCFPlugInInterface     **iodev;        // fetching this now
        
    SInt32                  score;          // not used
    IOReturn                err;
        
    err = IOCreatePlugInInterfaceForService(hidDeviceRef,
                                    kIOHIDDeviceTypeID,
                                    kIOCFPlugInInterfaceID,
                                    &iodev,
                                    &score);
    @/textblock
    </pre>
*/
#define kIOHIDDeviceTypeID CFUUIDGetConstantUUIDWithBytes(NULL, \
    0x7d, 0xde, 0xec, 0xa8, 0xa7, 0xb4, 0x11, 0xda, \
    0x8a, 0x0e, 0x00, 0x14, 0x51, 0x97, 0x58, 0xef)

/* 474BDC8E-9F4A-11DA-B366-000D936D06D2 */
/*! @defined kIOHIDDeviceDeviceInterfaceID
    @discussion This UUID constant is used to obtain a device interface corresponding 
    to an IOHIDDevice service in the kernel. The type of this device interface is IOHIDDeviceDeviceInterface. 
    This device interface is obtained after the IOCFPlugInInterface for the service itself has been obtained.
    
    <b>Note:</b> Please note that subsequent calls to QueryInterface with the UUID 
    kIOHIDDeviceDeviceInterfaceID, will return a retained instance of an existing IOHIDDeviceDeviceInterface.

    Example:
    <pre>
    @textblock
    IOCFPluginInterface **          iodev;  // obtained earlier
    
    IOHIDDeviceDeviceInterface **   dev;    // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                    CFUUIDGetUUIDBytes(kIOHIDDeviceDeviceInterfaceID),
                                    (LPVoid)&dev);
    @/textblock
    </pre>
*/
#define kIOHIDDeviceDeviceInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, \
    0x47, 0x4b, 0xdc, 0x8e, 0x9f, 0x4a, 0x11, 0xda, \
    0xb3, 0x66, 0x00, 0x0d, 0x93, 0x6d, 0x06, 0xd2 )
    
/* B473256C-6A72-4E04-B694-C4001D202020 */
/*! @defined kIOHIDDeviceDeviceInterfaceID2
    @discussion This UUID constant is used to obtain a device interface corresponding
    to an IOHIDDevice service in the kernel, but only for timestamped report callbacks.
    The type of this device interface is IOHIDDeviceTimeStampedDeviceInterface.
    This device interface is obtained after the IOCFPlugInInterface for the service itself has been obtained.

    <b>Note:</b> Please note that subsequent calls to QueryInterface with the UUID 
    kIOHIDDeviceDeviceInterfaceID2, will return a retained instance of an existing IOHIDDeviceTimeStampedDeviceInterface.

    Example:
    <pre>
    @textblock
    IOCFPluginInterface                     **iodev;  // obtained earlier

    IOHIDDeviceTimeStampedDeviceInterface   **devTime;// fetching this now
    IOReturn                                err;

    err = (*iodev)->QueryInterface(iodev,
                                   CFUUIDGetUUIDBytes(kIOHIDDeviceDeviceInterfaceID2),
                                   (LPVoid)&devTime);
    @/textblock
    </pre>
*/
#define kIOHIDDeviceDeviceInterfaceID2 CFUUIDGetConstantUUIDWithBytes(NULL, \
   0xB4, 0x73, 0x25, 0x6C, 0x6A, 0x72, 0x4E, 0x04, \
   0xB6, 0x94, 0xC4, 0x00, 0x1D, 0x20, 0x20, 0x20)

/* 2EC78BDB-9F4E-11DA-B65C-000D936D06D2 */
/*! @defined kIOHIDDeviceQueueInterfaceID
    @discussion This UUID constant is used to obtain a queue interface corresponding 
    to an IOHIDDevice service in the kernel. The type of this queue interface 
    is IOHIDDeviceQueueInterface. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> Please note that subsequent calls to QueryInterface with the UUID 
    kIOHIDDeviceQueueInterfaceID, will return a retained instance of a new IOHIDDeviceQueueInterface.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface **          iodev; 	// obtained earlier
    
    IOHIDDeviceQueueInterface **    intf;   // fetching this now
    IOReturn                        err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOHIDDeviceQueueInterfaceID),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOHIDDeviceQueueInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x2e, 0xc7, 0x8b, 0xdb, 0x9f, 0x4e, 0x11, 0xda, \
    0xb6, 0x5c, 0x00, 0x0d, 0x93, 0x6d, 0x06, 0xd2)

/* 1F2E78FA-9FFA-11DA-90B4-000D936D06D2 */
/*! @defined kIOHIDDeviceTransactionInterfaceID
    @discussion This UUID constant is used to obtain a transaction interface corresponding 
    to an IOHIDDevice service in the kernel. The type of this queue interface 
    is IOHIDDeviceTransactionInterface. This device interface is obtained after the device interface 
    for the service itself has been obtained.
    
    <b>Note:</b> Please note that subsequent calls to QueryInterface with the UUID 
    kIOHIDDeviceTransactionInterfaceID, will return a retained instance of a new IOHIDDeviceTransactionInterface.
    
    Example:
    <pre>
    @textblock
    IOCFPluginInterface **              iodev;  // obtained earlier
    
    IOHIDDeviceTransactionInterface	**  intf;   // fetching this now
    IOReturn                            err;
    
    err = (*iodev)->QueryInterface(iodev,
                                CFUUIDGetUUIDBytes(kIOHIDDeviceTransactionInterfaceID),
                                (LPVoid)&intf);
    @/textblock
    </pre>
*/
#define kIOHIDDeviceTransactionInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x1f, 0x2e, 0x78, 0xfa, 0x9f, 0xfa, 0x11, 0xda, \
    0x90, 0xb4, 0x00, 0x0d, 0x93, 0x6d, 0x06, 0xd2)


#define IOHID_DEVICE_DEVICE_FUNCS_V1                                                                    \
        IOReturn (*open)(void * self, IOOptionBits options);                                            \
        IOReturn (*close)(void * self, IOOptionBits options);                                           \
        IOReturn (*getProperty)(void * self, CFStringRef key, CFTypeRef * pProperty);                   \
        IOReturn (*setProperty)(void * self, CFStringRef key, CFTypeRef property);                      \
        IOReturn (*getAsyncEventSource)(void * self, CFTypeRef * pSource);                              \
        IOReturn (*copyMatchingElements)(void * self, CFDictionaryRef matchingDict, CFArrayRef * pElements, IOOptionBits options); \
        IOReturn (*setValue)(void * self, IOHIDElementRef element, IOHIDValueRef value, uint32_t timeout, IOHIDValueCallback callback, void * context, IOOptionBits options); \
        IOReturn (*getValue)(void * self, IOHIDElementRef element, IOHIDValueRef * pValue, uint32_t timeout, IOHIDValueCallback callback, void * context, IOOptionBits options); \
        IOReturn (*setInputReportCallback)(void * self, uint8_t * report, CFIndex reportLength, IOHIDReportCallback callback, void * context, IOOptionBits options); \
        IOReturn (*setReport)(void * self, IOHIDReportType reportType, uint32_t reportID, const uint8_t * report, CFIndex reportLength, uint32_t timeout, IOHIDReportCallback callback, void * context, IOOptionBits options); \
        IOReturn (*getReport)(void * self, IOHIDReportType reportType, uint32_t reportID, uint8_t * report, CFIndex * pReportLength, uint32_t timeout, IOHIDReportCallback callback, void * context, IOOptionBits options)
/*! @interface  IOHIDDeviceDeviceInterface
    @abstract   The object you use to access HID devices from user space, returned by version 1.5 of the IOHIDFamily.
    @discussion The functions listed here will work with any version of the IOHIDDeviceDeviceInterface. 
    
    <b>Note:</b> Please note that methods declared in this interface follow the copy/get/set conventions.
*/
typedef struct IOHIDDeviceDeviceInterface {
    IUNKNOWN_C_GUTS;
#ifdef IOHID_DEVICE_DEVICE_FUNCS_V1 // {
    IOHID_DEVICE_DEVICE_FUNCS_V1;
#else // } {
    /*! @function   open
        @abstract   Opens the IOHIDDevice.
        @discussion Before the client can issue commands that change the state of the device, it must have succeeded in 
                    opening the device. This establishes a link between the client's task and the actual device.  To 
                    establish an exclusive link use the kIOHIDOptionsTypeSeizeDevice option.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      options Option bits to be passed down to the user client.
        @result     Returns kIOReturnSuccess if successful, some other mach error if the connection is no longer valid.
    */
    IOReturn (*open)(void * self, IOOptionBits options);

    /*! @function   close
        @abstract   Closes the task's connection to the IOHIDDevice.
        @discussion Releases the client's access to the IOHIDDevice.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      options Option bits to be passed down to the user client.
        @result     Returns kIOReturnSuccess if successful, kIOReturnNoDevice if there is no connection to an IOService.
    */    
    IOReturn (*close)(void * self, IOOptionBits options);

    /*! @function   getProperty
        @abstract   Obtains a property related to the IOHIDDevice.
        @discussion Property keys are prefixed by kIOHIDDevice and declared in IOHIDKeys.h.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      key CFStringRef key
        @param      pProperty Pointer to a CFTypeRef property.
        @result     Returns kIOReturnSuccess if successful.
    */    
    IOReturn (*getProperty)(void * self, CFStringRef key, CFTypeRef * pProperty);

    /*! @function   setProperty
        @abstract   Sets a property related to the IOHIDDevice.
        @discussion Property keys are prefixed by kIOHIDDevice and declared in IOHIDKeys.h.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      key CFStringRef key
        @param      property CFTypeRef property.
        @result     Returns kIOReturnSuccess if successful.
    */    
    IOReturn (*setProperty)(void * self, CFStringRef key, CFTypeRef property);
    
    /*! @function   getAsyncEventSource
        @abstract   Obtains the event source for this IOHIDDeviceDeviceInterface instance.
        @discussion The returned event source can be of type CFRunLoopSourceRef or CFRunLoopTimerRef.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      pSource Pointer to a CFType to return the run loop event source.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getAsyncEventSource)(void * self, CFTypeRef * pSource);

    /*! @function   copyMatchingElements
        @abstract   Obtains a CFArrayRef containing the IOHIDDeviceDeviceInterface elements that match 
                    the passed matching dictionary.
        @discussion Objects contained in the returned array are of type IOHIDElementRef.  Please see 
                    IOHIDElement.h for additional API information.  Elemenet properties are prefixed by 
                    kIOHIDElement and declared in IOHIDKeys.h.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      matchingDict CFDictionaryRef containing the element properties to match on.
        @param      pElements CFArrayRef containing matched elements.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*copyMatchingElements)(void * self, CFDictionaryRef matchingDict, CFArrayRef * pElements, IOOptionBits options);
    
    /*! @function   setValue
        @abstract   Sets the value for an element.
        @discussion If setting multiple element values, please consider using an IOHIDDeviceTransactionInterface
                    with the kIOHIDTransactionDirectionTypeOutput direction.
                    <br>
                    <b>Note:</b> In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
                    must be added to a run loop. 
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      element IOHIDElementRef referencing the element of interest.
        @param      value IOHIDValueRef containing element value to be set.
        @param      timeout Time in milliseconds to wait before aborting request.
        @param      callback Callback of type IOHIDValueCallback to be used after report data has been sent to the device.
                    If null, this method will behave synchronously.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setValue)(void * self, IOHIDElementRef element, IOHIDValueRef value,
                    uint32_t timeout, IOHIDValueCallback callback, void * context, IOOptionBits options);

    /*! @function   getValue
        @abstract   Obtains the current value for an element.
        @discussion If an element of type kIOHIDElementTypeFeature is passed, this method will issue a request to the IOHIDDevice.  
                    Otherwise, this will return the last value reported by the IOHIDDevice.  If requesting multiple feature element 
                    values, please consider using an IOHIDDeviceTransactionInterface with the kIOHIDTransactionDirectionTypeInput direction.
                    <br>
                    <b>Note:</b> In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
                    must be added to a run loop. 
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      element IOHIDElementRef referencing the element of interest.
        @param      pValue Pointer to a IOHIDValueRef to return the element value.
        @param      timeout Time in milliseconds to wait before aborting request.
        @param      callback Callback of type IOHIDReportCallback to be used when element value has been received from the device.
                    If null, this method will behave synchronously.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getValue)(void * self, IOHIDElementRef element, IOHIDValueRef * pValue,
                    uint32_t timeout, IOHIDValueCallback callback, void * context, IOOptionBits options);

    /*!
        @function   setInputReportCallback
        @abstract   Sets the input report callback to be used when data is received from the Input pipe.
        @discussion In order to function properly, the event source obtained using getAsyncEventSource must be added to a run loop.
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      report Pointer to a pre-allocated buffer to be filled and passed back via the callback.
        @param      reportLength Length of the report buffer.
        @param      callback Callback of type IOHIDReportCallback to be used when report data has been receieved by the IOHIDDevice.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setInputReportCallback)(void * self, uint8_t * report, CFIndex reportLength,
                    IOHIDReportCallback callback, void * context, IOOptionBits options);

    /*! @function   setReport
        @abstract   Sends a report of type kIOHIDReportTypeOutput or kIOHIDReportTypeFeature to the IOHIDDevice.
        @discussion This method is useful if specific knowledge of the unparsed report is known to the caller.  Otherwise, using
                    an IOHIDDeviceTransactionInterface with the kIOHIDTransactionDirectionTypeOutput direction is recommended.
                    <br>
                    <b>Note:</b> In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
                    must be added to a run loop. 
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      reportType The report type.
        @param      reportID The report id.
        @param      report Pointer to a buffer containing the report data to be sent.
        @param      reportLength Length of the report buffer.
        @param      timeout Timeout in milliseconds for issuing the setReport.
        @param      callback Callback of type IOHIDReportCallback to be used after report data has been sent to the device.
                    If null, this method will behave synchronously.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setReport)(void * self, IOHIDReportType reportType, uint32_t reportID, const uint8_t * report, CFIndex reportLength,
                    uint32_t timeout, IOHIDReportCallback callback, void * context, IOOptionBits options);

    /*! @function   getReport
        @abstract   Obtains a report of type kIOHIDReportTypeInput or kIOHIDReportTypeFeature from the IOHIDDevice.
        @discussion This method is useful if specific knowledge of the unparsed report is known to the caller.  Otherwise, using
                    an IOHIDDeviceTransactionInterface with the kIOHIDTransactionDirectionTypeInput direction is recommended.
                    <br>
                    <b>Note:</b> In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
                    must be added to a run loop. 
        @param      self Pointer to the IOHIDDeviceDeviceInterface.
        @param      reportType The report type.
        @param      reportID The report id.
        @param      report Pointer to a pre-allocated buffer to be filled.
        @param      pReportLength Length of the report buffer.  When finished, this will contain the actual length of the report.
        @param      timeout Timeout in milliseconds for issuing the getReport.
        @param      callback Callback of type IOHIDReportCallback to be used when report data has been received from the device.
                    If null, this method will behave synchronously.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getReport)(void * self, IOHIDReportType reportType, uint32_t reportID, uint8_t * report, CFIndex * pReportLength,
                    uint32_t timeout, IOHIDReportCallback callback, void * context, IOOptionBits options);
#endif // }
} IOHIDDeviceDeviceInterface;

#define IOHID_DEVICE_DEVICE_FUNCS_V2                                                        \
        IOReturn (*setInputReportWithTimeStampCallback)(void * self, uint8_t * report, CFIndex reportLength, IOHIDReportWithTimeStampCallback callback, void * context, IOOptionBits options)
/*! @interface  IOHIDDeviceTimeStampedDeviceInterface
    @abstract   The object you use to access HID devices from user space, returned by version 2.1 of the IOHIDFamily.
    @discussion The functions listed here include all of the functions from the IOHIDDeviceDeviceInterface.
    
    <b>Note:</b> Please note that methods declared in this interface follow the copy/get/set conventions.
*/
typedef struct IOHIDDeviceTimeStampedDeviceInterface {
    IUNKNOWN_C_GUTS;
    IOHID_DEVICE_DEVICE_FUNCS_V1;
#ifdef IOHID_DEVICE_DEVICE_FUNCS_V2 // {
    IOHID_DEVICE_DEVICE_FUNCS_V2;
#else // } {
/*!
    @function   setInputReportWithTimeStampCallback
    @abstract   Sets the input report callback to be used when data is received from the Input pipe.
    @discussion In order to function properly, the event source obtained using getAsyncEventSource must be added to a run loop.
    @param      self Pointer to the IOHIDDeviceDeviceInterface.
    @param      report Pointer to a pre-allocated buffer to be filled and passed back via the callback.
    @param      reportLength Length of the report buffer.
    @param      callback Callback of type IOHIDReportWithTimeStampCallback to be used when report data has been receieved by the IOHIDDevice.
    @param      context Pointer to data to be passed to the callback.
    @param      options Reserved for future use. Ignored in current implementation. Set to zero.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
*/
IOReturn (*setInputReportWithTimeStampCallback)(void * self, uint8_t * report, CFIndex reportLength,
                IOHIDReportWithTimeStampCallback callback, void * context, IOOptionBits options);

#endif // }
} IOHIDDeviceTimeStampedDeviceInterface;

/*!
    @interface  IOHIDDeviceQueueInterface
    @abstract   The object you use to access a HID queue from user space, returned by version 1.5 of the IOHIDFamily.
    @discussion The functions listed here will work with any version of the IOHIDDeviceQueueInterface.  This behavior is useful when you 
                need to keep track of all values of an input element, rather than just the most recent one.
                <br>
                <b>Note:</b>Absolute element values (based on a fixed origin) will only be placed on a queue if there is a change in value. 
*/
typedef struct IOHIDDeviceQueueInterface {
    IUNKNOWN_C_GUTS;

    /*! @function   getAsyncEventSource
        @abstract   Obtains the event source for this IOHIDDeviceQueueInterface instance.
        @discussion The returned event source can be of type CFRunLoopSourceRef or CFRunLoopTimerRef.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      pSource Pointer to a CFType to return the run loop event source.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getAsyncEventSource)(void * self, CFTypeRef * pSource);
    
    /*! @function   setDepth
        @abstract   Sets the depth for this IOHIDDeviceQueueInterface instance.
        @discussion Regardless of element value size, queue will guarantee n=depth elements will be serviced.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      depth The maximum number of elements in the queue before the oldest elements in the queue begin to be lost.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setDepth)(void *self, uint32_t depth, IOOptionBits options);

    /*! @function   getDepth
        @abstract   Obtains the queue depth for this IOHIDDeviceQueueInterface instance.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      pDepth Pointer to a uint32_t to obtain the number of elements that can be serviced by the queue.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getDepth)(void *self, uint32_t * pDepth);

    /*! @function   addElement
        @abstract   Adds an element to this IOHIDDeviceQueueInterface instance.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      element IOHIDElementRef referencing the element to be added to the queue.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*addElement)(void * self, IOHIDElementRef element, IOOptionBits options);

    /*! @function   removeElement
        @abstract   Removes an element from this IOHIDDeviceQueueInterface instance.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      element IOHIDElementRef referencing the element to be removed from the queue.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*removeElement)(void * self, IOHIDElementRef element, IOOptionBits options);

    /*! @function   containsElement
        @abstract   Determines whether an element has been added to this IOHIDDeviceQueueInterface instance.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      element IOHIDElementRef referencing the element to be be found in the queue.
        @param      pValue Pointer to a Boolean to return whether or not the element was found in the queue.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*containsElement)(void * self, IOHIDElementRef element, Boolean * pValue, IOOptionBits options);

    /*! @function   start
        @abstract   Starts element value delivery to the queue.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*start)(void * self, IOOptionBits options);

    /*! @function   stop
        @abstract   Stops element value delivery to the queue.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*stop)(void * self, IOOptionBits options);
    
    /*! @function   setValueAvailableCallback
        @abstract   Sets callback to be used when the queue transitions to non-empty.
        @discussion In order to make use of asynchronous behavior, the event source obtained using getAsyncEventSource
                    must be added to a run loop. 
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      callback Callback of type IOHIDCallback to be used when data is placed on the queue.
        @param      context Pointer to data to be passed to the callback.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setValueAvailableCallback)(void * self, IOHIDCallback callback, void * context);
    
    /*! @function   copyNextValue
        @abstract   Dequeues a retained copy of an element value from the head of an IOHIDDeviceQueueInterface.
        @discussion Because the value is a retained copy, it is up to the caller to release the value using CFRelease. 
                    Use with setValueCallback to avoid polling the queue for data.
        @param      self Pointer to the IOHIDDeviceQueueInterface.
        @param      pValue Pointer to a IOHIDValueRef to return the value at the head of the queue.
        @param      timeout Timeout in milliseconds before aborting an attempt to dequeue a value from the head of a queue.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful, kIOReturnUnderrun if data is unavailble, or a kern_return_t if unsuccessful.
    */
    IOReturn (*copyNextValue)(void * self, IOHIDValueRef * pValue, uint32_t timeout, IOOptionBits options);
} IOHIDDeviceQueueInterface;


/*!
    @interface  IOHIDDeviceTransactionInterface
    @abstract   The object you use to access a HID transaction from user space, returned by version 1.5 of the IOHIDFamily.
    @discussion The functions listed here will work with any version of the IOHIDDeviceTransactionInterface. This functionality
                is useful when either setting or getting the values for multiple parsed elements.
*/
typedef struct IOHIDDeviceTransactionInterface {
    IUNKNOWN_C_GUTS;

    /*! @function   getAsyncEventSource
        @abstract   Obtains the event source for this IOHIDDeviceTransactionInterface instance.
        @discussion The returned event source can be of type CFRunLoopSourceRef or CFRunLoopTimerRef.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      pSource Pointer to a CFType to return the run loop event source.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getAsyncEventSource)(void * self, CFTypeRef * pSource);

    /*! @function   setDirection
        @abstract   Sets the direction for this IOHIDDeviceTransactionInterface instance.
        @discussion Direction constants are declared in IOHIDTransactionDirectionType.  Changing directions
                    is useful when dealing with elements of type kIOHIDElementTypeFeature as you use the
                    transaction to both set and get element values.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      direction Transaction direction of type IOHIDTransactionDirectionType.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setDirection)(void * self, IOHIDTransactionDirectionType direction, IOOptionBits options);

    /*! @function   getDirection
        @abstract   Obtains the direction for this IOHIDDeviceTransactionInterface instance.
        @discussion Direction constants are declared in IOHIDTransactionDirectionType.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      pDirection Pointer to a IOHIDTransactionDirectionType to obtain transaction direction.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getDirection)(void * self, IOHIDTransactionDirectionType * pDirection);
    
    /*! @function   addElement
        @abstract   Adds an element to this IOHIDDeviceTransactionInterface instance.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      element IOHIDElementRef referencing the element to be added to the transaction.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*addElement)(void * self, IOHIDElementRef element, IOOptionBits options);
    
    /*! @function   removeElement
        @abstract   Removes an element from this IOHIDDeviceTransactionInterface instance.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      element IOHIDElementRef referencing the element to be removed from the transaction.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*removeElement)(void * self, IOHIDElementRef element, IOOptionBits options);

    /*! @function   containsElement
        @abstract   Checks whether an element has been added to this IOHIDDeviceTransactionInterface instance.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      element IOHIDElementRef referencing the element to be be found in the transaction.
        @param      pValue Pointer to a Boolean to return whether or not the element was found in the transaction.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*containsElement)(void * self, IOHIDElementRef element, Boolean * pValue, IOOptionBits options);

    /*! @function   setValue
        @abstract   Sets the transaction value for an element in this IOHIDDeviceTransactionInterface instance.
        @discussion This method is intended for use with transaction of direction kIOHIDTransactionDirectionTypeOutput.
                    Use the kIOHIDTransactionOptionDefaultOutputValue option to set the default element value.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      element IOHIDElementRef referencing the element of interest.
        @param      value IOHIDValueRef referencing element value to be used in the transaction.
        @param      options See IOHIDTransactionOption.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*setValue)(void * self, IOHIDElementRef element, IOHIDValueRef value, IOOptionBits options);

    /*! @function   getValue
        @abstract   Obtains the transaction value for an element in this IOHIDDeviceTransactionInterface instance.
        @discussion Use the kIOHIDTransactionOptionDefaultOutputValue option to get the default element value.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      element IOHIDElementRef referencing the element of interest.
        @param      pValue Pointer to an IOHIDValueRef to return the element value of the transaction.
        @param      options See IOHIDTransactionOption.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*getValue)(void * self, IOHIDElementRef element, IOHIDValueRef *pValue, IOOptionBits options);
    
    /*! @function   commit
        @abstract   Commits element transaction to an IOHIDDevice in this IOHIDDeviceTransactionInterface instance.
        @discussion In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be used if
                    element values are not set.  If neither are set, that element will be omitted from the commit. After 
                    a transaction is committed, transaction element values will be cleared and default values preserved.
                    <br>
                    <b>Note:</b> It is possible for elements from different reports to be present in a given transaction 
                    causing a commit to transcend multiple reports. Keep this in mind when setting a timeout.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      timeout Timeout in milliseconds for issuing the transaction.
        @param      callback Callback of type IOHIDCallback to be used when transaction has been completed.  If null, 
                    this method will behave synchronously.
        @param      context Pointer to data to be passed to the callback.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*commit)(void * self, uint32_t timeout, IOHIDCallback callback, void * context, IOOptionBits options);

    /*! @function   clear
        @abstract   Clears element transaction values for an IOHIDDeviceTransactionInterface.
        @discussion In regards to kIOHIDTransactionDirectionTypeOutput direction, default element values will be preserved.
        @param      self Pointer to the IOHIDDeviceTransactionInterface.
        @param      options Reserved for future use. Ignored in current implementation. Set to zero.
        @result     Returns kIOReturnSuccess if successful or a kern_return_t if unsuccessful.
    */
    IOReturn (*clear)(void * self, IOOptionBits options);
} IOHIDDeviceTransactionInterface;

__END_DECLS

#endif /* _IOKIT_HID_IOHIDDEVICEPLUGIN_H */
                               IOHIDElement.h                                                                                      0100644 0001750 0001750 00000045134 12566177313 033700  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDELEMENT_USER_H
#define _IOKIT_HID_IOHIDELEMENT_USER_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/hid/IOHIDKeys.h>
#include <IOKit/hid/IOHIDBase.h>

/*!
	@header IOHIDElement
    IOHIDElement defines a parsed item contained within a Human Interface Device
    (HID) object.  It is used to obtain properties of the parsed.  It can also
    be used to set properties such as calibration settings.  IOHIDElement is a 
    CFType object and as such conforms to all the conventions expected such 
    object.
    <p>
    This documentation assumes that you have a basic understanding of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.
    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOHIDElement.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDElement.h</font>.
*/

__BEGIN_DECLS

/*!
	@function   IOHIDElementGetTypeID
	@abstract   Returns the type identifier of all IOHIDElement instances.
*/
CF_EXPORT
CFTypeID IOHIDElementGetTypeID(void)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementCreateWithDictionary
	@abstract   Creates an element from a dictionary.
    @discussion The dictionary should contain keys defined in IOHIDKeys.h and start with kIOHIDElement.  This call is meant be used by a IOHIDDeviceDeviceInterface object.
    @param      allocator Allocator to be used during creation.
    @param      dictionary dictionary containing values in which to create element.
    @result     Returns a new IOHIDElementRef.
*/
CF_EXPORT
IOHIDElementRef IOHIDElementCreateWithDictionary(CFAllocatorRef allocator, CFDictionaryRef dictionary)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetDevice
	@abstract   Obtain the device associated with the element.
    @param      element IOHIDElement to be queried. 
    @result     Returns the a reference to the device.
*/
CF_EXPORT
IOHIDDeviceRef IOHIDElementGetDevice(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetParent
	@abstract   Returns the parent for the element.
    @discussion The parent element can be an element of type kIOHIDElementTypeCollection.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns an IOHIDElementRef referencing the parent element.
*/
CF_EXPORT
IOHIDElementRef IOHIDElementGetParent(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetChildren
	@abstract   Returns the children for the element.
    @discussion An element of type kIOHIDElementTypeCollection usually contains children.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns an CFArrayRef containing element objects of type IOHIDElementRef.
*/
CF_EXPORT
CFArrayRef IOHIDElementGetChildren(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementAttach
	@abstract   Establish a relationship between one or more elements.
    @discussion This is useful for grouping HID elements with related functionality.
    @param      element The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @param      toAttach The element to be attached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
*/
CF_EXPORT
void IOHIDElementAttach(IOHIDElementRef element, IOHIDElementRef toAttach)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementDetach
	@abstract   Remove a relationship between one or more elements.
    @discussion This is useful for grouping HID elements with related functionality.
    @param      element The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @param      toDetach The element to be detached. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
*/
CF_EXPORT
void IOHIDElementDetach(IOHIDElementRef element, IOHIDElementRef toDetach)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementCopyAttached
	@abstract   Obtain attached elements.
    @discussion Attached elements are those that have been grouped via IOHIDElementAttach.
    @param      element The element to be modified. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns a copy of the current attached elements.
*/
CF_EXPORT
CFArrayRef IOHIDElementCopyAttached(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetCookie
	@abstract   Retrieves the cookie for the element.
    @discussion The IOHIDElementCookie represent a unique identifier for an element within a device.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the IOHIDElementCookie for the element.
*/
CF_EXPORT
IOHIDElementCookie IOHIDElementGetCookie(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetType
	@abstract   Retrieves the type for the element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the IOHIDElementType for the element.
*/
CF_EXPORT
IOHIDElementType IOHIDElementGetType(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetCollectionType
	@abstract   Retrieves the collection type for the element.
    @discussion The value returned by this method only makes sense if the element type is kIOHIDElementTypeCollection.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the IOHIDElementCollectionType for the element.
*/
CF_EXPORT
IOHIDElementCollectionType IOHIDElementGetCollectionType(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetUsagePage
	@abstract   Retrieves the usage page for an element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the usage page for the element.
*/
CF_EXPORT
uint32_t IOHIDElementGetUsagePage(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetUsage
	@abstract   Retrieves the usage for an element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the usage for the element.
*/
CF_EXPORT
uint32_t IOHIDElementGetUsage(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementIsVirtual
	@abstract   Returns the virtual property for the element.
    @discussion Indicates whether the element is a virtual element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the TRUE if virtual or FALSE if not.
*/
CF_EXPORT
Boolean IOHIDElementIsVirtual(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementIsRelative
	@abstract   Returns the relative property for the element.
    @discussion Indicates whether the data is relative (indicating the change in value from the last report) or absolute 
                (based on a fixed origin).
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if relative or FALSE if absolute.
*/
CF_EXPORT
Boolean IOHIDElementIsRelative(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementIsWrapping
	@abstract   Returns the wrap property for the element.
    @discussion Wrap indicates whether the data "rolls over" when reaching either the extreme high or low value.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if wrapping or FALSE if non-wrapping.
*/
CF_EXPORT
Boolean IOHIDElementIsWrapping(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementIsArray
	@abstract   Returns the array property for the element.
    @discussion Indicates whether the element represents variable or array data values. Variable values represent data from a 
                physical control.  An array returns an index in each field that corresponds to the pressed button 
                (like keyboard scan codes).
                <br>
                <b>Note:</b> The HID Manager will represent most elements as "variable" including the possible usages of an array.  
                Array indices will remain as "array" elements with a usage of 0xffffffff.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if array or FALSE if variable.
*/
CF_EXPORT
Boolean IOHIDElementIsArray(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementIsNonLinear
	@abstract   Returns the linear property for the element.
    @discussion Indicates whether the value for the element has been processed in some way, and no longer represents a linear 
                relationship between what is measured and the value that is reported.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if non linear or FALSE if linear.
*/
CF_EXPORT
Boolean IOHIDElementIsNonLinear(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementHasPreferredState
	@abstract   Returns the preferred state property for the element.
    @discussion Indicates whether the element has a preferred state to which it will return when the user is not physically 
                interacting with the control.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if preferred state or FALSE if no preferred state.
*/
CF_EXPORT
Boolean IOHIDElementHasPreferredState(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementHasNullState
	@abstract   Returns the null state property for the element.
    @discussion Indicates whether the element has a state in which it is not sending meaningful data. 
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns TRUE if null state or FALSE if no null state.
*/
CF_EXPORT
Boolean IOHIDElementHasNullState(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetName
	@abstract   Returns the name for the element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns CFStringRef containing the element name.
*/
CF_EXPORT
CFStringRef IOHIDElementGetName(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetReportID
	@abstract   Returns the report ID for the element.
    @discussion The report ID represents what report this particular element belongs to.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the report ID.
*/
CF_EXPORT
uint32_t IOHIDElementGetReportID(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetReportSize
	@abstract   Returns the report size in bits for the element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the report size.
*/
CF_EXPORT
uint32_t IOHIDElementGetReportSize(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetReportCount
	@abstract   Returns the report count for the element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the report count.
*/
CF_EXPORT
uint32_t IOHIDElementGetReportCount(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetUnit
	@abstract   Returns the unit property for the element.
    @discussion The unit property is described in more detail in Section 6.2.2.7 of the 
                "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the unit.
*/
CF_EXPORT
uint32_t IOHIDElementGetUnit(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetUnitExponent
	@abstract   Returns the unit exponenet in base 10 for the element.
    @discussion The unit exponent property is described in more detail in Section 6.2.2.7 of the 
                "Device Class Definition for Human Interface Devices(HID)" Specification, Version 1.11.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the unit exponent.
*/
CF_EXPORT
uint32_t IOHIDElementGetUnitExponent(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetLogicalMin
	@abstract   Returns the minimum value possible for the element.
    @discussion This corresponds to the logical minimun, which indicates the lower bounds of a variable element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the logical minimum.
*/
CF_EXPORT
CFIndex IOHIDElementGetLogicalMin(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetLogicalMax
	@abstract   Returns the maximum value possible for the element.
    @discussion This corresponds to the logical maximum, which indicates the upper bounds of a variable element.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the logical maximum.
*/
CF_EXPORT
CFIndex IOHIDElementGetLogicalMax(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetPhysicalMin
	@abstract   Returns the scaled minimum value possible for the element.
    @discussion Minimum value for the physical extent of a variable element. This represents the value for the logical minimum with units applied to it.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the physical minimum.
*/
CF_EXPORT
CFIndex IOHIDElementGetPhysicalMin(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetPhysicalMax
	@abstract   Returns the scaled maximum value possible for the element.
    @discussion Maximum value for the physical extent of a variable element.  This represents the value for the logical maximum with units applied to it.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @result     Returns the physical maximum.
*/
CF_EXPORT
CFIndex IOHIDElementGetPhysicalMax(IOHIDElementRef element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementGetProperty
	@abstract   Returns the an element property.
    @discussion Property keys are prefixed by kIOHIDElement and declared in IOHIDKeys.h.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @param      key The key to be used when querying the element.
    @result     Returns the property.
*/
CF_EXPORT
CFTypeRef IOHIDElementGetProperty(IOHIDElementRef element, CFStringRef key)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDElementSetProperty
	@abstract   Sets an element property.
    @discussion This method can be used to set arbitrary element properties, such as application specific references.
    @param      element The element to be queried. If this parameter is not a valid IOHIDElementRef, the behavior is undefined.
    @param      key The key to be used when querying the element.
    @result     Returns TRUE if successful.
*/
CF_EXPORT 
Boolean IOHIDElementSetProperty(IOHIDElementRef element, CFStringRef key, CFTypeRef property)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


__END_DECLS

#endif /* _IOKIT_HID_IOHIDELEMENT_USER_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                    IOHIDKeys.h                                                                                         0100644 0001750 0001750 00000041716 12567452123 033220  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDKEYS_H_
#define _IOKIT_HID_IOHIDKEYS_H_

#include <sys/cdefs.h>
#include <IOKit/hidsystem/IOHIDParameter.h>
#include <IOKit/IOReturn.h>
#include <IOKit/IOMessage.h>

__BEGIN_DECLS

/* The following keys are used to search the IORegistry for HID related services
*/

/* This is used to find HID Devices in the IORegistry */
#define kIOHIDDeviceKey                     "IOHIDDevice"

/*!
    @defined HID Device Property Keys
    @abstract Keys that represent properties of a paticular device.
    @discussion Keys that represent properties of a paticular device.  Can be added
        to your matching dictionary when refining searches for HID devices.
        <br><br>
        <b>Please note:</b><br>
        kIOHIDPrimaryUsageKey and kIOHIDPrimaryUsagePageKey are no longer 
        rich enough to describe a device's capabilities.  Take, for example, a
        device that describes both a keyboard and a mouse in the same descriptor.  
        The previous behavior was to only describe the keyboard behavior with the 
        primary usage and usage page.   Needless to say, this would sometimes cause 
        a program interested in mice to skip this device when matching.  
        <br>
        Thus we have added 3 
        additional keys:
        <ul>
            <li>kIOHIDDeviceUsageKey</li>
            <li>kIOHIDDeviceUsagePageKey</li>
            <li>kIOHIDDeviceUsagePairsKey</li>
        </ul>
        kIOHIDDeviceUsagePairsKey is used to represent an array of dictionaries containing 
        key/value pairs referenced by kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey.  
        These usage pairs describe all application type collections (behaviors) defined 
        by the device.
        <br><br>
        An application intersted in only matching on one criteria would only add the 
        kIOHIDDeviceUsageKey and kIOHIDDeviceUsagePageKey keys to the matching dictionary.
        If it is interested in a device that has multiple behaviors, the application would
        instead add an array or dictionaries referenced by kIOHIDDeviceUsagePairsKey to his 
        matching dictionary.
*/
#define kIOHIDTransportKey                  "Transport"
#define kIOHIDVendorIDKey                   "VendorID"
#define kIOHIDVendorIDSourceKey             "VendorIDSource"
#define kIOHIDProductIDKey                  "ProductID"
#define kIOHIDVersionNumberKey              "VersionNumber"
#define kIOHIDManufacturerKey               "Manufacturer"
#define kIOHIDProductKey                    "Product"
#define kIOHIDSerialNumberKey               "SerialNumber"
#define kIOHIDCountryCodeKey                "CountryCode"
#define kIOHIDStandardTypeKey               "StandardType"
#define kIOHIDLocationIDKey                 "LocationID"
#define kIOHIDDeviceUsageKey                "DeviceUsage"
#define kIOHIDDeviceUsagePageKey            "DeviceUsagePage"
#define kIOHIDDeviceUsagePairsKey           "DeviceUsagePairs"
#define kIOHIDPrimaryUsageKey               "PrimaryUsage"
#define kIOHIDPrimaryUsagePageKey           "PrimaryUsagePage"
#define kIOHIDMaxInputReportSizeKey         "MaxInputReportSize"
#define kIOHIDMaxOutputReportSizeKey        "MaxOutputReportSize"
#define kIOHIDMaxFeatureReportSizeKey       "MaxFeatureReportSize"
#define kIOHIDReportIntervalKey             "ReportInterval"
#define kIOHIDSampleIntervalKey             "SampleInterval"
#define kIOHIDBatchIntervalKey              "BatchInterval"
#define kIOHIDRequestTimeoutKey             "RequestTimeout"
#define kIOHIDReportDescriptorKey           "ReportDescriptor"
#define kIOHIDResetKey                      "Reset"
#define kIOHIDKeyboardLanguageKey           "KeyboardLanguage"
#define kIOHIDAltHandlerIdKey               "alt_handler_id"
#define kIOHIDBuiltInKey                    "Built-In"
#define kIOHIDDisplayIntegratedKey          "DisplayIntegrated"
#define kIOHIDProductIDMaskKey              "ProductIDMask"
#define kIOHIDProductIDArrayKey             "ProductIDArray"
#define kIOHIDPowerOnDelayNSKey             "HIDPowerOnDelayNS"
#define kIOHIDCategoryKey                   "Category"
#define kIOHIDMaxResponseLatencyKey         "MaxResponseLatency"
#define kIOHIDUniqueIDKey                   "UniqueID"


#define kIOHIDTransportUSBValue                 "USB"
#define kIOHIDTransportBluetoothValue           "Bluetooth"
#define kIOHIDTransportBluetoothLowEnergyValue  "BluetoothLowEnergy"
#define kIOHIDTransportAIDBValue                "AIDB"
#define kIOHIDTransportI2CValue                 "I2C"
#define kIOHIDTransportSPIValue                 "SPI"
#define kIOHIDTransportSerialValue              "Serial"
#define kIOHIDTransportIAPValue                 "IAP"
#define kIOHIDTransportAirPlayValue             "AirPlay"
#define kIOHIDTransportSPUValue                 "SPU"



#define kIOHIDCategoryAutomotiveValue       "Automotive"

/*!
    @define kIOHIDElementKey
    @abstract Keys that represents an element property.
    @discussion Property for a HID Device or element dictionary.
        Elements can be heirarchical, so they can contain other elements.
*/
#define kIOHIDElementKey                    "Elements"

/*!
    @defined HID Element Dictionary Keys
    @abstract Keys that represent properties of a particular elements.
    @discussion These keys can also be added to a matching dictionary 
        when searching for elements via copyMatchingElements.  
*/
#define kIOHIDElementCookieKey                      "ElementCookie"
#define kIOHIDElementTypeKey                        "Type"
#define kIOHIDElementCollectionTypeKey              "CollectionType"
#define kIOHIDElementUsageKey                       "Usage"
#define kIOHIDElementUsagePageKey                   "UsagePage"
#define kIOHIDElementMinKey                         "Min"
#define kIOHIDElementMaxKey                         "Max"
#define kIOHIDElementScaledMinKey                   "ScaledMin"
#define kIOHIDElementScaledMaxKey                   "ScaledMax"
#define kIOHIDElementSizeKey                        "Size"
#define kIOHIDElementReportSizeKey                  "ReportSize"
#define kIOHIDElementReportCountKey                 "ReportCount"
#define kIOHIDElementReportIDKey                    "ReportID"
#define kIOHIDElementIsArrayKey                     "IsArray"
#define kIOHIDElementIsRelativeKey                  "IsRelative"
#define kIOHIDElementIsWrappingKey                  "IsWrapping"
#define kIOHIDElementIsNonLinearKey                 "IsNonLinear"
#define kIOHIDElementHasPreferredStateKey           "HasPreferredState"
#define kIOHIDElementHasNullStateKey                "HasNullState"
#define kIOHIDElementFlagsKey                       "Flags"
#define kIOHIDElementUnitKey                        "Unit"
#define kIOHIDElementUnitExponentKey                "UnitExponent"
#define kIOHIDElementNameKey                        "Name"
#define kIOHIDElementValueLocationKey               "ValueLocation"
#define kIOHIDElementDuplicateIndexKey              "DuplicateIndex"
#define kIOHIDElementParentCollectionKey            "ParentCollection"

#ifndef __ppc__
    #define kIOHIDElementVendorSpecificKey          "VendorSpecific"
#else
    #define kIOHIDElementVendorSpecificKey          "VendorSpecifc"
#endif

/*!
    @defined HID Element Match Keys
    @abstract Keys used for matching particular elements.
    @discussion These keys should only be used with a matching  
        dictionary when searching for elements via copyMatchingElements.  
*/
#define kIOHIDElementCookieMinKey           "ElementCookieMin"
#define kIOHIDElementCookieMaxKey           "ElementCookieMax"
#define kIOHIDElementUsageMinKey            "UsageMin"
#define kIOHIDElementUsageMaxKey            "UsageMax"

/*!
    @defined kIOHIDElementCalibrationMinKey
    @abstract The minimum bounds for a calibrated value.  
*/
#define kIOHIDElementCalibrationMinKey              "CalibrationMin"

/*!
    @defined kIOHIDElementCalibrationMaxKey
    @abstract The maximum bounds for a calibrated value.  
*/
#define kIOHIDElementCalibrationMaxKey              "CalibrationMax"

/*!
    @defined kIOHIDElementCalibrationSaturationMinKey
    @abstract The mininum tolerance to be used when calibrating a logical element value. 
    @discussion The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element. 
*/
#define kIOHIDElementCalibrationSaturationMinKey    "CalibrationSaturationMin"

/*!
    @defined kIOHIDElementCalibrationSaturationMaxKey
    @abstract The maximum tolerance to be used when calibrating a logical element value.  
    @discussion The saturation property is used to allow for slight differences in the minimum and maximum value returned by an element. 
*/
#define kIOHIDElementCalibrationSaturationMaxKey    "CalibrationSaturationMax"

/*!
    @defined kIOHIDElementCalibrationDeadZoneMinKey
    @abstract The minimum bounds near the midpoint of a logical value in which the value is ignored.  
    @discussion The dead zone property is used to allow for slight differences in the idle value returned by an element. 
*/
#define kIOHIDElementCalibrationDeadZoneMinKey      "CalibrationDeadZoneMin"

/*!
    @defined kIOHIDElementCalibrationDeadZoneMinKey
    @abstract The maximum bounds near the midpoint of a logical value in which the value is ignored.  
    @discussion The dead zone property is used to allow for slight differences in the idle value returned by an element. 
*/
#define kIOHIDElementCalibrationDeadZoneMaxKey      "CalibrationDeadZoneMax"

/*!
    @defined kIOHIDElementCalibrationGranularityKey
    @abstract The scale or level of detail returned in a calibrated element value.  
    @discussion Values are rounded off such that if granularity=0.1, values after calibration are 0, 0.1, 0.2, 0.3, etc.
*/
#define kIOHIDElementCalibrationGranularityKey      "CalibrationGranularity"

/*!
    @typedef IOHIDElementCookie
    @abstract Abstract data type used as a unique identifier for an element.
*/
#ifdef __LP64__
    typedef uint32_t IOHIDElementCookie;
#else
    typedef void * IOHIDElementCookie;
#endif

/*!
  @typedef IOHIDElementType
  @abstract Describes different types of HID elements.
  @discussion Used by the IOHIDFamily to identify the type of
  element processed.  Represented by the key kIOHIDElementTypeKey in the 
    dictionary describing the element.
  @constant kIOHIDElementTypeInput_Misc
    Misc input data field or varying size.
  @constant kIOHIDElementTypeInput_Button 
    One bit input data field.
  @constant kIOHIDElementTypeInput_Axis 
    Input data field used to represent an axis.
  @constant kIOHIDElementTypeInput_ScanCodes
    Input data field used to represent a scan code or usage selector.
  @constant kIOHIDElementTypeOutput
    Used to represent an output data field in a report.
  @constant kIOHIDElementTypeFeature
    Describes input and output elements not intended for 
    consumption by the end user.
  @constant kIOHIDElementTypeCollection
    Element used to identify a relationship between two or more elements.
*/
enum IOHIDElementType {
    kIOHIDElementTypeInput_Misc        = 1,
    kIOHIDElementTypeInput_Button      = 2,
    kIOHIDElementTypeInput_Axis        = 3,
    kIOHIDElementTypeInput_ScanCodes   = 4,
    kIOHIDElementTypeOutput            = 129,
    kIOHIDElementTypeFeature           = 257,
    kIOHIDElementTypeCollection        = 513
};
typedef enum IOHIDElementType IOHIDElementType;

/*!
  @typedef IOHIDElementCollectionType
  @abstract Describes different types of HID collections.
  @discussion Collections identify a relationship between two or more
    elements.
  @constant kIOHIDElementCollectionTypePhysical   
    Used for a set of data items that represent data points 
    collected at one geometric point.
  @constant kIOHIDElementCollectionTypeApplication 
    Identifies item groups serving different purposes in a single device.
  @constant kIOHIDElementCollectionTypeLogical
    Used when a set of data items form a composite data structure.
  @constant kIOHIDElementCollectionTypeReport 
    Wraps all the fields in a report.
  @constant kIOHIDElementCollectionTypeNamedArray 
    Contains an array of selector usages.
  @constant kIOHIDElementCollectionTypeUsageSwitch 
    Modifies the meaning of the usage it contains.
  @constant kIOHIDElementCollectionTypeUsageModifier 
    Modifies the meaning of the usage attached to the encompassing collection.
*/
enum IOHIDElementCollectionType{
    kIOHIDElementCollectionTypePhysical    = 0x00,
    kIOHIDElementCollectionTypeApplication,
    kIOHIDElementCollectionTypeLogical,
    kIOHIDElementCollectionTypeReport,
    kIOHIDElementCollectionTypeNamedArray,
    kIOHIDElementCollectionTypeUsageSwitch,
    kIOHIDElementCollectionTypeUsageModifier
};
typedef enum IOHIDElementCollectionType IOHIDElementCollectionType;


/*!
  @typedef IOHIDReportType
  @abstract Describes different type of HID reports.
  @discussion Used by the IOHIDFamily to identify the type of
    report being processed.
  @constant kIOHIDReportTypeInput Input report.
  @constant kIOHIDReportTypeOutput Output report.
  @constant kIOHIDReportTypeFeature Feature report.
*/
enum IOHIDReportType{
    kIOHIDReportTypeInput = 0,
    kIOHIDReportTypeOutput,
    kIOHIDReportTypeFeature,
    kIOHIDReportTypeCount
};
typedef enum IOHIDReportType IOHIDReportType;

/*!
  @typedef IOHIDOptionsType
  @abstract Options for opening a device via IOHIDLib.
  @constant kIOHIDOptionsTypeNone Default option.
  @constant kIOHIDOptionsTypeSeizeDevice Used to open exclusive
    communication with the device.  This will prevent the system
    and other clients from receiving events from the device.
*/
enum {
    kIOHIDOptionsTypeNone     = 0x00,
    kIOHIDOptionsTypeSeizeDevice = 0x01
};
typedef uint32_t IOHIDOptionsType;


/*!
  @typedef IOHIDQueueOptionsType
  @abstract Options for creating a queue via IOHIDLib.
  @constant kIOHIDQueueOptionsTypeNone Default option.
  @constant kIOHIDQueueOptionsTypeEnqueueAll Force the IOHIDQueue
    to enqueue all events, relative or absolute, regardless of change.
*/
enum {
    kIOHIDQueueOptionsTypeNone     = 0x00,
    kIOHIDQueueOptionsTypeEnqueueAll = 0x01
};
typedef uint32_t IOHIDQueueOptionsType;


enum {
    kIOHIDElementFlagsConstantMask        = 0x0001,
    kIOHIDElementFlagsVariableMask        = 0x0002,
    kIOHIDElementFlagsRelativeMask        = 0x0004,
    kIOHIDElementFlagsWrapMask            = 0x0008,
    kIOHIDElementFlagsNonLinearMask       = 0x0010,
    kIOHIDElementFlagsNoPreferredMask     = 0x0020,
    kIOHIDElementFlagsNullStateMask       = 0x0040,
    kIOHIDElementFlagsVolativeMask        = 0x0080,
    kIOHIDElementFlagsBufferedByteMask    = 0x0100
};
typedef uint32_t IOHIDElementFlags;

/*!
  @typedef IOHIDStandardType
  @abstract Type to define what industrial standard the device is referencing.
  @constant kIOHIDStandardTypeANSI ANSI.
  @constant kIOHIDStandardTypeISO ISO.
  @constant kIOHIDStandardTypeJIS JIS.
*/
enum {
    kIOHIDStandardTypeANSI                = 0,
    kIOHIDStandardTypeISO                 = 1,
    kIOHIDStandardTypeJIS                 = 2
};
typedef uint32_t IOHIDStandardType;

/*!
 @typedef IOHIDValueScaleType
 @abstract Describes different types of scaling that can be performed on element values.
 @constant kIOHIDValueScaleTypeCalibrated Type for value that is scaled with respect to the calibration properties.
 @constant kIOHIDValueScaleTypePhysical Type for value that is scaled with respect to the physical min and physical max of the element.
 */
enum {
    kIOHIDValueScaleTypeCalibrated,
    kIOHIDValueScaleTypePhysical
};
typedef uint32_t IOHIDValueScaleType;

/*!
 @typedef IOHIDValueOptions
 @abstract Describes options for gathering element values.
 @constant kIOHIDValueOptionsFlagRelativeSimple Compares against previous value
 */
enum {
    kIOHIDValueOptionsFlagRelativeSimple    = (1<<0),
    kIOHIDValueOptionsFlagPrevious          = (1<<1)
};
typedef uint32_t IOHIDValueOptions;

#define kIOHIDDigitizerGestureCharacterStateKey "DigitizerCharacterGestureState"

/* 
 * kIOHIDSystemButtonPressedDuringDarkBoot - Used to message that a wake button was pressed during dark boot
 */
#define kIOHIDSystemButtonPressedDuringDarkBoot     iokit_family_msg(sub_iokit_hidsystem, 7)



__END_DECLS

#endif /* !_IOKIT_HID_IOHIDKEYS_H_ */
                                                  IOHIDLib.h                                                                                          0100644 0001750 0001750 00000003011 12566177313 033001  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDLIB_H_
#define _IOKIT_HID_IOHIDLIB_H_

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/IOTypes.h>
#include <IOKit/IOReturn.h>
#include <IOKit/hid/IOHIDBase.h>
#include <IOKit/hid/IOHIDDevice.h>
#include <IOKit/hid/IOHIDElement.h>
#include <IOKit/hid/IOHIDKeys.h>
#include <IOKit/hid/IOHIDLibObsolete.h>
#include <IOKit/hid/IOHIDManager.h>
#include <IOKit/hid/IOHIDQueue.h>
#include <IOKit/hid/IOHIDUsageTables.h>
#include <IOKit/hid/IOHIDValue.h>
#include <IOKit/hid/IOHIDTransaction.h>

#endif /* _IOKIT_HID_IOHIDLIB_H_ */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       IOHIDLibObsolete.h                                                                                  0100644 0001750 0001750 00000107721 12567452123 034507  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDLIBOBSOLETE_H_
#define _IOKIT_HID_IOHIDLIBOBSOLETE_H_

#include <sys/cdefs.h>

__BEGIN_DECLS
#include <CoreFoundation/CoreFoundation.h>
#if COREFOUNDATION_CFPLUGINCOM_SEPARATE
#include <CoreFoundation/CFPlugInCOM.h>
#endif

#include <IOKit/IOTypes.h>
#include <IOKit/IOReturn.h>

#include <IOKit/hid/IOHIDKeys.h>

struct IOHIDEventStruct
{
    IOHIDElementType	type;
    IOHIDElementCookie	elementCookie;
    int32_t             value;
    AbsoluteTime        timestamp;
    uint32_t            longValueSize;
    void *              longValue;
};
typedef struct IOHIDEventStruct IOHIDEventStruct;

/* FA12FA38-6F1A-11D4-BA0C-0005028F18D5 */
#define kIOHIDDeviceUserClientTypeID CFUUIDGetConstantUUIDWithBytes(NULL, \
    0xFA, 0x12, 0xFA, 0x38, 0x6F, 0x1A, 0x11, 0xD4,			\
    0xBA, 0x0C, 0x00, 0x05, 0x02, 0x8F, 0x18, 0xD5)

/* 78BD420C-6F14-11D4-9474-0005028F18D5 */
/*! @defined kIOHIDDeviceInterfaceID
    @discussion Interface ID for the IOHIDDeviceInterface. Corresponds to an
                 available HID device. */
#define kIOHIDDeviceInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x78, 0xBD, 0x42, 0x0C, 0x6F, 0x14, 0x11, 0xD4,			\
    0x94, 0x74, 0x00, 0x05, 0x02, 0x8F, 0x18, 0xD5)
    
/* 7D0B510E-16D5-11D7-9E9B-000393992E38 */
/*! @defined kIOHIDDeviceInterfaceID121
    @discussion Interface ID for the IOHIDDeviceInterface121. Corresponds to 
                an available HID device that includes methods from
                IOHIDDeviceInterface.  This interface is available on 
                IOHIDLib 1.2.1 and Mac OS X 10.2.3 or later.*/
#define kIOHIDDeviceInterfaceID121 CFUUIDGetConstantUUIDWithBytes(NULL, \
    0x7d, 0xb, 0x51, 0xe, 0x16, 0xd5, 0x11, 0xd7, 			\
    0x9e, 0x9b, 0x0, 0x3, 0x93, 0x99, 0x2e, 0x38)

/* B70ABF31-16D5-11D7-AB35-000393992E38 */
/*! @defined kIOHIDDeviceInterfaceID122
    @discussion Interface ID for the IOHIDDeviceInterface122. Corresponds to 
                an available HID device that includes methods from
                IOHIDDeviceInterface and IOHIDDeviceInterface121. This 
                interface is available on IOHIDLib 1.2.2 and Mac OS X 10.3
                or later.*/
#define kIOHIDDeviceInterfaceID122 CFUUIDGetConstantUUIDWithBytes(NULL, \
    0xb7, 0xa, 0xbf, 0x31, 0x16, 0xd5, 0x11, 0xd7, 			\
    0xab, 0x35, 0x0, 0x3, 0x93, 0x99, 0x2e, 0x38)

/* 8138629E-6F14-11D4-970E-0005028F18D5 */
/*! @defined kIOHIDQueueInterfaceID
    @discussion Interface ID for the kIOHIDQueueInterfaceID. Corresponds to a
                queue for a specific HID device. */
#define kIOHIDQueueInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL, 	\
    0x81, 0x38, 0x62, 0x9E, 0x6F, 0x14, 0x11, 0xD4,			\
    0x97, 0x0E, 0x00, 0x05, 0x02, 0x8F, 0x18, 0xD5)

/* 80CDCC00-755D-11D4-8E0F-0005028F18D5 */
/*! @defined kIOHIDOutputTransactionInterfaceID
    @discussion Interface ID for the kIOHIDOutputTransactionInterfaceID.
                Corresponds to an output transaction for one or more report IDs
                on a specific device. */
#define kIOHIDOutputTransactionInterfaceID CFUUIDGetConstantUUIDWithBytes(NULL,\
    0x80, 0xCD, 0xCC, 0x00, 0x75, 0x5D, 0x11, 0xD4,			\
    0x80, 0xEF, 0x00, 0x05, 0x02, 0x8F, 0x18, 0xD5)

/*! @typedef IOHIDCallbackFunction
    @discussion Type and arguments of callout C function that is used when a
                completion routine is called, see
                IOHIDLib.h:setRemovalCallback().
    @param target void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param refcon void * pointer to more data.
    @param sender Interface instance sending the completion routine.
*/
typedef void (*IOHIDCallbackFunction)(void * target, IOReturn result, void * refcon, void * sender);

/*! @typedef IOHIDElementCallbackFunction
    @discussion Type and arguments of callout C function that is used when a
                completion routine is called, see IOHIDLib.h:setElementValue().
    @param target void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param refcon void * pointer to more data.
    @param sender Interface instance sending the completion routine.
    @param elementCookie Element within interface instance sending completion.
*/
typedef void (*IOHIDElementCallbackFunction) (void * target, IOReturn result, void * refcon, void * sender, IOHIDElementCookie 	elementCookie);

/*! @typedef IOHIDReportCallbackFunction
    @discussion Type and arguments of callout C function that is used when a
                completion routine is called, see IOHIDLib.h:setReport().
    @param target void * pointer to your data, often a pointer to an object.
    @param result Completion result of desired operation.
    @param refcon void * pointer to more data.
    @param sender Interface instance sending the completion routine.
    @param bufferSize Size of the buffer received upon completion.
*/
typedef void (*IOHIDReportCallbackFunction) (void * target, IOReturn result, void * refcon,  void * sender,  uint32_t bufferSize);
               

/* Forward declarations of the queue and output transaction interfaces */
struct IOHIDQueueInterface;
struct IOHIDOutputTransactionInterface;
typedef struct IOHIDQueueInterface IOHIDQueueInterface;
typedef struct IOHIDOutputTransactionInterface IOHIDOutputTransactionInterface;

//
// IOHIDDeviceInterface Functions available in version 1.0 (10.0) and higher of Mac OS X
//
#define IOHIDDEVICEINTERFACE_FUNCS_100 							\
    IOReturn (*createAsyncEventSource)(void * self, CFRunLoopSourceRef * source); 	\
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);				\
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);			\
    mach_port_t (*getAsyncPort)(void * self);						\
    IOReturn (*open)(void * self, IOOptionBits flags);					\
    IOReturn (*close)(void * self);							\
    IOReturn (*setRemovalCallback)(void * self, IOHIDCallbackFunction removalCallback,	\
                                   void * removalTarget, void * removalRefcon);		\
    IOReturn (*getElementValue)(void * self, IOHIDElementCookie	elementCookie,		\
                                IOHIDEventStruct * valueEvent);				\
    IOReturn (*setElementValue)(void * self, IOHIDElementCookie elementCookie,		\
                                IOHIDEventStruct * valueEvent, uint32_t timeoutMS,	\
                                IOHIDElementCallbackFunction callback,			\
                                void * callbackTarget, void * callbackRefcon);		\
    IOReturn (*queryElementValue)(void * self, IOHIDElementCookie elementCookie,	\
                                IOHIDEventStruct * valueEvent, uint32_t timeoutMS,	\
                                IOHIDElementCallbackFunction callback,			\
                                void * callbackTarget, void * callbackRefcon);		\
    IOReturn (*startAllQueues)(void * self);						\
    IOReturn (*stopAllQueues)(void * self);						\
    IOHIDQueueInterface ** (*allocQueue) (void *self);					\
    IOHIDOutputTransactionInterface ** (*allocOutputTransaction) (void *self)
    
//
// IOHIDDeviceInterface Functions available in version 1.2.1 (10.2.3) and higher of Mac OS X
//
#define IOHIDDEVICEINTERFACE_FUNCS_121	 						\
    IOReturn (*setReport)(void * self, IOHIDReportType reportType, uint32_t reportID,	\
                                void * reportBuffer, uint32_t reportBufferSize,		\
                                uint32_t timeoutMS, IOHIDReportCallbackFunction callback,	\
                                void * callbackTarget, void * callbackRefcon);		\
    IOReturn (*getReport)(void * self, IOHIDReportType reportType,			\
                                uint32_t reportID, void * reportBuffer,			\
                                uint32_t * reportBufferSize, uint32_t timeoutMS,		\
                                IOHIDReportCallbackFunction callback,			\
                                void * callbackTarget, void * callbackRefcon)
                                                                
//
// IOHIDDeviceInterface Functions available in version 1.2.2 (10.3) and higher of Mac OS X
//
#define IOHIDDEVICEINTERFACE_FUNCS_122	 						\
    IOReturn (*copyMatchingElements)(void * self, CFDictionaryRef matchingDict, 	\
                                CFArrayRef * elements);					\
    IOReturn (*setInterruptReportHandlerCallback)(void * self, void * reportBuffer, 		\
                                uint32_t reportBufferSize, 				\
                                IOHIDReportCallbackFunction callback,			\
                                void * callbackTarget, void * callbackRefcon)	
                                
typedef struct IOHIDDeviceInterface
{
    IUNKNOWN_C_GUTS;
    IOHIDDEVICEINTERFACE_FUNCS_100;
    IOHIDDEVICEINTERFACE_FUNCS_121;
} IOHIDDeviceInterface;

typedef struct IOHIDDeviceInterface121
{
    IUNKNOWN_C_GUTS;
    IOHIDDEVICEINTERFACE_FUNCS_100;
    IOHIDDEVICEINTERFACE_FUNCS_121;
} IOHIDDeviceInterface121;

typedef struct IOHIDDeviceInterface122
{
    IUNKNOWN_C_GUTS;
    IOHIDDEVICEINTERFACE_FUNCS_100;
    IOHIDDEVICEINTERFACE_FUNCS_121;
    IOHIDDEVICEINTERFACE_FUNCS_122;
} IOHIDDeviceInterface122;

//
// IOHIDQueueInterface Functions available in version 1.0 (10.0) and higher of Mac OS X
//
#define IOHIDQUEUEINTERFACE_FUNCS_100							\
    IOReturn (*createAsyncEventSource)(void * self, CFRunLoopSourceRef * source);	\
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);				\
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);			\
    mach_port_t (*getAsyncPort)(void * self);						\
    IOReturn (*create)(void * self, uint32_t flags, uint32_t depth);			\
    IOReturn (*dispose)(void * self);							\
    IOReturn (*addElement)(void * self, IOHIDElementCookie elementCookie, uint32_t flags);\
    IOReturn (*removeElement)(void * self, IOHIDElementCookie elementCookie);		\
    Boolean (*hasElement)(void * self, IOHIDElementCookie elementCookie);		\
    IOReturn (*start)(void * self);							\
    IOReturn (*stop)(void * self);							\
    IOReturn (*getNextEvent)(void * self, IOHIDEventStruct * event,			\
                                AbsoluteTime maxTime, uint32_t timeoutMS);		\
    IOReturn (*setEventCallout)(void * self, IOHIDCallbackFunction callback,		\
                                void * callbackTarget,  void * callbackRefcon);		\
    IOReturn (*getEventCallout)(void * self, IOHIDCallbackFunction * outCallback,	\
                                void ** outCallbackTarget, void ** outCallbackRefcon)

struct IOHIDQueueInterface
{
    IUNKNOWN_C_GUTS;
    IOHIDQUEUEINTERFACE_FUNCS_100;
};

//
// IOHIDOutputTransactionInterface Functions available in version 1.2 (10.2) and higher of Mac OS X
//
#define IOHIDOUTPUTTRANSACTIONINTERFACE_FUNCS_120 					\
    IOReturn (*createAsyncEventSource)(void * self, CFRunLoopSourceRef * source);	\
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);				\
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);			\
    mach_port_t (*getAsyncPort)(void * self);						\
    IOReturn (*create)(void * self);							\
    IOReturn (*dispose)(void * self);							\
    IOReturn (*addElement)(void * self, IOHIDElementCookie elementCookie);		\
    IOReturn (*removeElement)(void * self, IOHIDElementCookie elementCookie);		\
    Boolean  (*hasElement)(void * self, IOHIDElementCookie elementCookie);		\
    IOReturn (*setElementDefault)(void *self, IOHIDElementCookie elementCookie,		\
                                IOHIDEventStruct * valueEvent);				\
    IOReturn (*getElementDefault)(void * self, IOHIDElementCookie elementCookie,	\
                                IOHIDEventStruct * outValueEvent);			\
    IOReturn (*setElementValue)(void * self, IOHIDElementCookie elementCookie,		\
                                IOHIDEventStruct * valueEvent);				\
    IOReturn (*getElementValue)(void * self, IOHIDElementCookie elementCookie,		\
                                IOHIDEventStruct * outValueEvent);			\
    IOReturn (*commit)(void * self, uint32_t timeoutMS, IOHIDCallbackFunction callback,	\
                                void * callbackTarget, void * callbackRefcon);		\
    IOReturn (*clear)(void * self)

struct IOHIDOutputTransactionInterface
{
    IUNKNOWN_C_GUTS;
    IOHIDOUTPUTTRANSACTIONINTERFACE_FUNCS_120;
};


//
//  BEGIN READABLE STRUCTURE DEFINITIONS 
//  
//  This portion of uncompiled code provides a more reader friendly representation of 
//  the CFPlugin methods defined above.

#if 0
/*! @class IOHIDDeviceInterface
    @discussion CFPlugin object subclass which provides the primary interface to
                HID devices.
*/
typedef struct IOHIDDeviceInterface
{

    IUNKNOWN_C_GUTS;

/*! @function createAsyncEventSource
    @abstract Creates async eventsource.
    @discussion This method will create an async mach port, if one
        has not already been created.
    @param source Reference to CFRunLoopSourceRef that is created.
    @result Returns an IOReturn code.
*/
    IOReturn (*createAsyncEventSource)(void * 			self,
                                       CFRunLoopSourceRef * 	source);

/*! @function getAsyncEventSource
    @abstract Gets the created async event source.
    @result Returns a CFRunLoopSourceRef.
*/
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);
    
/*! @function createAsyncPort
    @abstract Creates an async port.
    @discussion The port must be created before any callbacks can be used. 
    @param port Reference to mach port that is created. 
    @result Returns an IOReturn code.
*/
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);
    
/*! @function getAsyncPort
    @abstract Gets the current async port.
    @result Returns a mach_port_t.
*/
    mach_port_t (*getAsyncPort)(void * self);
    
/*! @function open
    @abstract Opens the device.
    @param flags Flags to be passed down to the user client.
    @result Returns an IOReturn code.
*/
    IOReturn (*open)(void * self, uint32_t flags);
    
/*! @function close
    @abstract Closes the device.
    @result Returns an IOReturn code.
*/
    IOReturn (*close)(void * self);

/*! @function setRemovalCallback
    @abstract Sets callback to be used when device is removed.
    @param removalCallback Called when the device is removed. 
    @param removalTarget Passed to the callback.
    @param removalRefcon Passed to the callback.
    @result Returns an IOReturn code.
*/
    IOReturn (*setRemovalCallback)(void * 			self,
                                   IOHIDCallbackFunction	removalCallback,
                                   void *			removalTarget,
                                   void *			removalRefcon);

/*! @function getElementValue
    @abstract Obtains the most recent value of an element.
    @discussion This call is most useful for interrupt driven elements,
        such as input type elements.  Since feature type element values 
        need to be polled from the device, it is recommended to use the 
        queryElementValue method to obtain the current value.  The  
        timestamp field in the event details the last time the element 
        value was altered.
    @param elementCookie The element of interest. 
    @param valueEvent The event that will be filled.   If a long value is 
        present, it is up to the caller to deallocate it.
    @result Returns an IOReturn code.
*/
    IOReturn (*getElementValue)(void * 			self,
                                IOHIDElementCookie	elementCookie,
                                IOHIDEventStruct *	valueEvent);

/*! @function setElementValue
    @abstract Sets an element value on the device.
    @discussion This call is most useful for feature type elements.  It is
        recommended to use IOOutputTransaction for output type elements.
    @param elementCookie The element of interest. 
    @param valueEvent The event that will be filled.  If a long value is
        present, it will be copied.
    @param timeoutMS UNSUPPORTED.
    @param callback UNSUPPORTED.
    @param callbackTarget UNSUPPORTED.
    @param callbackRefcon UNSUPPORTED.
    @result Returns an IOReturn code.
*/
    IOReturn (*setElementValue)(void *	 			self,
                                IOHIDElementCookie		elementCookie,
                                IOHIDEventStruct *		valueEvent,
                                uint32_t 				timeoutMS,
                                IOHIDElementCallbackFunction	callback,
                                void * 				callbackTarget,
                                void *				callbackRefcon);

/*! @function queryElementValue
    @abstract Obtains the current value of an element.
    @discussion This call is most useful for feature type elements.  This
        method will poll the device for the current element value.
    @param elementCookie The element of interest. 
    @param valueEvent The event that will be filled.  If a long value is 
        present, it is up to the caller to deallocate it.
    @param timeoutMS UNSUPPORTED.
    @param callback UNSUPPORTED.
    @param callbackTarget UNSUPPORTED.
    @param callbackRefcon UNSUPPORTED.
    @result Returns an IOReturn code.
*/
    IOReturn (*queryElementValue)(void * 			self,
                                IOHIDElementCookie		elementCookie,
                                IOHIDEventStruct *		valueEvent,
                                uint32_t 				timeoutMS,
                                IOHIDElementCallbackFunction	callback,
                                void * 				callbackTarget,
                                void *				callbackRefcon);

/*! @function startAllQueues
    @abstract Starts data delivery on all queues for this device.
    @result Returns an IOReturn code.
*/
    IOReturn (*startAllQueues)(void * self);
    
/*! @function stopAllQueues
    @abstract Stops data delivery on all queues for this device.
    @result Returns an IOReturn code.
*/
    IOReturn (*stopAllQueues)(void * self);

/*! @function allocQueue
    @abstract Wrapper to return instances of the IOHIDQueueInterface. 
    @result Returns the created IOHIDQueueInterface.
*/
    IOHIDQueueInterface ** (*allocQueue) (void *self);
    
/*! @function allocOutputTransaction
    @abstract Wrapper to return instances of the IOHIDOutputTransactionInterface. 
    @result Returns the created IOHIDOutputTransactionInterface.
*/
    IOHIDOutputTransactionInterface ** (*allocOutputTransaction) (void *self);
    
} IOHIDDeviceInterface;

/*! @class IOHIDDeviceInterface121
    @discussion CFPlugin object subclass which provides the primary interface to
                HID devices.  This class is a subclass of IOHIDDeviceInterface.
*/
typedef struct IOHIDDeviceInterface121
{

    IUNKNOWN_C_GUTS;
    IOHIDDEVICEINTERFACE_FUNCS_100;

/*! @function setReport
    @abstract Sends a report to the device.
    @param reportType The report type.
    @param reportID The report id.
    @param reportBuffer Pointer to a preallocated buffer.
    @param reportBufferSize Size of the reportBuffer in bytes.
    @param timeoutMS
    @param callback If null, this method will behave synchronously.
    @param callbackTarget The callback target passed to the callback.
    @param callbackRefcon The callback refcon passed to the callback. 
    @result Returns an IOReturn code.
*/
    IOReturn (*setReport)	(void * 			self,
                                IOHIDReportType			reportType,
                                uint32_t				reportID,
                                void *				reportBuffer,
                                uint32_t				reportBufferSize,
                                uint32_t 				timeoutMS,
                                IOHIDReportCallbackFunction	callback,
                                void * 				callbackTarget,
                                void *				callbackRefcon);

/*! @function getReport
    @abstract Obtains a report from the device.
    @param reportType The report type.
    @param reportID The report ID.
    @param reportBuffer Pointer to a preallocated buffer.
    @param reportBufferSize Size of the reportBuffer in bytes.  
        When finished, will contain the actual size of the report.
    @param timeoutMS
    @param callback If null, this method will behave synchronously.
    @param callbackTarget The callback target passed to the callback.
    @param callbackRefcon The callback refcon passed to the callback. 
    @result Returns an IOReturn code.
*/
    IOReturn (*getReport)	(void * 			self,
                                IOHIDReportType			reportType,
                                uint32_t				reportID,
                                void *				reportBuffer,
                                uint32_t *			reportBufferSize,
                                uint32_t 				timeoutMS,
                                IOHIDReportCallbackFunction	callback,
                                void * 				callbackTarget,
                                void *				callbackRefcon);
                                
}IOHIDDeviceInterface121;

/*! @class IOHIDDeviceInterface122
    @discussion CFPlugin object subclass which provides the primary interface to
                HID devices.  This class is a subclass of IOHIDDeviceInterface121.
*/
typedef struct IOHIDDeviceInterface122
{

    IUNKNOWN_C_GUTS;
    IOHIDDEVICEINTERFACE_FUNCS_100;
    IOHIDDEVICEINTERFACE_FUNCS_121;

/*! @function copyMatchingElements
    @abstract Obtains specific elements defined by the device.
    @discussion Using keys defined in IOHIDKeys.h for elements, create a 
            matching dictonary containing items that you wish to search for.  
            A null array indicates that no elements matching that criteria 
            were found. Each item in the array is a reference to the same 
            dictionary item that represents each element in the I/O Registry.
            It is up to the caller to release the returned array of elements. 
    @param matchingDict Dictionary containg key/value pairs to match on.  Pass
            a null value to match on all elements.
    @param elements Pointer to a CFArrayRef that will be returned by this
            method.  It is up to the caller to release it when finished. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*copyMatchingElements)(void * 			self, 
                                CFDictionaryRef 		matchingDict, 
                                CFArrayRef * 			elements);
                                
/*! @function setInterruptReportHandlerCallback
    @abstract Sets the report handler callout to be called when the data 
        is received from the Interrupt-In pipe.
    @discussion In order for this to work correctly, you must call
        createAsyncPort and createAsyncEventSource.
    @param reportBuffer Pointer to a preallocated buffer.
    @param reportBufferSize Size of the reportBuffer in bytes.  
    @param callback If non-NULL, is a callback to be called when data 
        is received from the device.
    @param callbackTarget The callback target passed to the callback
    @param callbackRefcon The callback refcon passed to the callback.
    @result Returns an IOReturn code. 
*/
    IOReturn (*setInterruptReportHandlerCallback)(
                            void * 				self,
                            void *				reportBuffer,
                            uint32_t				reportBufferSize, 
                            IOHIDReportCallbackFunction 	callback,
                            void * 				callbackTarget, 
                            void * 				callbackRefcon);
    
}IOHIDDeviceInterface122;

/*! @class IOHIDQueueInterface
    @discussion CFPlugin object subclass which provides an interface for input
                queues from HID devices. Created by an IOHIDDeviceInterface
                object.
*/
typedef struct IOHIDQueueInterface
{

    IUNKNOWN_C_GUTS;

/*! @function createAsyncEventSource
    @abstract Creates an async event source.
    @discussion This will be used with setEventCallout.
    @param source The newly created event source.
    @result Returns an IOReturn code. 
*/
    IOReturn (*createAsyncEventSource)(void * 			self, 
                                        CFRunLoopSourceRef * 	source);

/*! @function getAsyncEventSource
    @abstract Obtains the current event source.
    @result Returns a CFRunLoopSourceRef.
*/
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);

/*! @function createAsyncPort
    @abstract Creates an async port.
    @discussion This will be used with createAsyncEventSource.
    @param port The newly created async port.
    @result Returns an IOReturn code.
*/
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);
    
/*! @function getAsyncPort
    @abstract Obtains the current async port.
    @result Returns a mach_port_t.
*/
    mach_port_t (*getAsyncPort)(void * self);
    
/*! @function create
    @abstract Creates the current queue. 
    @param flags Pass kIOHIDQueueOptionsTypeEnqueueAll option to 
    force the IOHIDQueue to enqueue all events, relative or absolute, 
    regardless of change.
    @param depth The maximum number of elements in the queue 
        before the oldest elements in the queue begin to be lost.
    @result Returns an IOReturn code. 
*/
    IOReturn (*create)(void * 			self, 
                        uint32_t 			flags,
                        uint32_t			depth);

/*! @function dispose
    @abstract Disposes of the current queue. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*dispose)(void * self);
    
/*! @function addElement
    @abstract Adds an element to the queue.
    @discussion If the element has already been added to queue,
        an error will be returned.
    @param elementCookie The element of interest. 
    @param flags 
    @result Returns an IOReturn code. 
*/
    IOReturn (*addElement)(void * self,
                           IOHIDElementCookie elementCookie,
                           uint32_t flags);

/*! @function removeElement
    @abstract Removes an element from the queue.
    @discussion If the element has not been added to queue,
        an error will be returned.
    @param elementCookie The element of interest. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*removeElement)(void * self, IOHIDElementCookie elementCookie);
    
/*! @function hasElement
    @abstract Checks whether an element has been added to 
        the queue.
    @discussion Will return true if present, otherwise will return false.
    @param elementCookie The element of interest. 
    @result Returns a Boolean value. 
*/
    Boolean (*hasElement)(void * self, IOHIDElementCookie elementCookie);

/*! @function start
    @abstract Starts event delivery to the queue. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*start)(void * self);
    
/*! @function stop
    @abstract Stops event delivery to the queue. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*stop)(void * self);

/*! @function getNextEvent
    @abstract Reads next event from the queue.
    @param event The event that will be filled.  If a long value is
        present, it is up to the caller to deallocate it.
    @param maxTime UNSUPPORTED.  If non-zero, limits read events to 
        those that occurred on or before maxTime.
    @param timeoutMS UNSUPPORTED.  The timeout in milliseconds, a zero  
        timeout will cause this call to be non-blocking (returning  
        queue empty) if there is a NULL callback, and blocking forever 
        until the queue is non-empty if there is a valid callback.
    @result Returns an IOReturn code. 
*/
    IOReturn (*getNextEvent)(void * 			self,
                            IOHIDEventStruct *		event,
                            AbsoluteTime		maxTime,
                            uint32_t 			timeoutMS);

/*! @function setEventCallout
    @abstract Sets the event callout to be called when the queue 
        transitions to non-empty.
    @discussion In order for this to work correctly, you must call
        createAsyncPort and createAsyncEventSource.
    @param callback if non-NULL is a callback to be called when data 
        is  inserted to the queue
    @param callbackTarget The callback target passed to the callback
    @param callbackRefcon The callback refcon passed to the callback.
    @result Returns an IOReturn code.
*/
    IOReturn (*setEventCallout)(void * 			self,
                                IOHIDCallbackFunction   callback,
                                void * 			callbackTarget,
                                void *			callbackRefcon);

/*! @function getEventCallout
    @abstract Gets the event callout.
    @discussion This callback will be called the queue transitions
        to non-empty.
    @param outCallback if non-NULL is a callback to be called when data 
        is  inserted to the queue
    @param outCallbackTarget The callback target passed to the callback
    @param outCallbackRefcon The callback refcon passed to the callback 
    @result Returns an IOReturn code. 
*/
    IOReturn (*getEventCallout)(void * 			self,
                                IOHIDCallbackFunction * outCallback,
                                void ** 		outCallbackTarget,
                                void **			outCallbackRefcon);
} IOHIDQueueInterface;

/*! @class IOHIDOutputTransactionInterface
    @discussion CFPlugin object subclass which privides interface for output
                transactions to HID devices. Created by a IOHIDDeviceInterface
                object. */

typedef struct IOHIDOutputTransactionInterface
{
    IUNKNOWN_C_GUTS;
                    
/*! @function createAsyncEventSource
    @abstract Creates an async event source.
    @discussion This will be used with setEventCallout.
    @param source The newly created event source 
    @result Returns an IOReturn code. 
*/
    IOReturn (*createAsyncEventSource)(void * 			self, 
                                        CFRunLoopSourceRef * 	source);

/*! @function getAsyncEventSource
    @abstract Obtains the current event source.
    @result Returns a CFRunLoopSourceRef.
*/
    CFRunLoopSourceRef (*getAsyncEventSource)(void * self);

/*! @function createAsyncPort
    @abstract Creates an async port.
    @discussion This will be used with createAsyncEventSource.
    @param port The newly created async port. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*createAsyncPort)(void * self, mach_port_t * port);
    
/*! @function getAsyncPort
    @abstract Obtains the current async port. 
    @result Returns a mach_port_t.
*/
    mach_port_t (*getAsyncPort)(void * self);
    
/*! @function create
    @abstract Creates the current transaction.
    @discussion This method will free any memory that has been
        allocated for this transaction. 
    @result Returns an IOReturn code.
*/
    IOReturn (*create)(void * self);
    
/*! @function dispose
    @abstract Disposes of the current transaction.
    @discussion The transaction will have to be recreated, in order
        to perform any operations on the transaction. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*dispose)(void * self);
    
/*! @function addElement
    @abstract Adds an element to the transaction.
    @discussion If the element has already been added to transaction,
        an error will be returned.
    @param elementCookie The element of interest.
    @result Returns an IOReturn code. 
*/
    IOReturn (*addElement)	(void * self, IOHIDElementCookie elementCookie);
    
/*! @function removeElement
    @abstract Removes an element from the transaction.
    @discussion If the element has not been added to transaction,
        an error will be returned.
    @param elementCookie The element of interest. 
    @result Returns an IOReturn code.
*/
    IOReturn (*removeElement)	(void * self, IOHIDElementCookie elementCookie);
    
/*! @function hasElement
    @abstract Checks whether an element has been added to 
        the transaction.
    @discussion Will return true if present, otherwise will return false.
    @param elementCookie The element of interest. 
    @result Returns a Boolean value. 
*/
    Boolean  (*hasElement)	(void * self, IOHIDElementCookie elementCookie);
    
/*! @function setElementDefault
    @abstract Sets the default value of an element in a 
        transaction.
    @discussion An error will be returned if the element has not been
        added to the transaction.
    @param elementCookie The element of interest. 
    @param valueEvent The event that will be filled.  If a long value is
        present, it will be copied. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*setElementDefault)(void *	 	self,
                                    IOHIDElementCookie	elementCookie,
                                    IOHIDEventStruct *	valueEvent);
    
/*! @function getElementDefault
    @abstract Obtains the default value of an element in a 
        transaction.
    @discussion An error will be returned if the element has not been 
        added to the transaction.
    @param elementCookie The element of interest. 
    @param outValueEvent The event that will be filled.  If a long value is 
        present, it is up to the caller to deallocate it. 
    @result Returns an IOReturn code.
*/
    IOReturn (*getElementDefault)(void *	 	self,
                                    IOHIDElementCookie	elementCookie,
                                    IOHIDEventStruct *	outValueEvent);
    
/*! @function setElementValue
    @abstract Sets the value of an element in a transaction.
    @discussion An error will be returned if the element has not been
        added to the transaction.
    @param elementCookie The element of interest. 
    @param valueEvent The event that will be filled.  If a long value is
        present, it will be copied.
    @result Returns an IOReturn code. 
*/
    IOReturn (*setElementValue)(void *	 		self,
                                IOHIDElementCookie	elementCookie,
                                IOHIDEventStruct *	valueEvent);
    
/*! @function getElementValue
    @abstract Obtains the value of an element in a transaction.
    @discussion An error will be returned if the element has not been 
        added to the transaction.
    @param elementCookie The element of interest. 
    @param outValueEvent The event that will be filled.  If a long value is 
        present, it is up to the caller to deallocate it. 
    @result Returns an IOReturn code.
*/
    IOReturn (*getElementValue)(void *	 		self,
                                IOHIDElementCookie	elementCookie,
                                IOHIDEventStruct *	outValueEvent);
    
/*! @function commit
    @abstract Commits the transaction.
    @discussion Transaction element values, if set, will be sent to the 
        device.  Otherwise, the default element value will be used.  If
        neither are set, that element will be omitted from the commit.
        After a transaction is committed, transaction element values 
        will be cleared.  Default values will be preserved.
    @param timeoutMS UNSUPPORTED
    @param callback UNSUPPORTED
    @param callbackTarget UNSUPPORTED
    @param callbackRefcon UNSUPPORTED 
    @result Returns an IOReturn code.
*/
    IOReturn (*commit)(void * 			self,
                        uint32_t 			timeoutMS,
                        IOHIDCallbackFunction   callback,
                        void * 			callbackTarget,
                        void *			callbackRefcon);
    
/*! @function clear
    @abstract Clears the transaction.
    @discussion Transaction element values will cleared.   Default 
        values will be preserved. 
    @result Returns an IOReturn code. 
*/
    IOReturn (*clear)(void * self);
} IOHIDOutputTransactionInterface;

#endif

__END_DECLS

#endif /* !_IOKIT_HID_IOHIDLIBOBSOLETE_H_ */
                                               IOHIDManager.h                                                                                      0100644 0001750 0001750 00000043452 12566177313 033662  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDMANAGER_H_
#define _IOKIT_HID_IOHIDMANAGER_H_

#include <IOKit/IOTypes.h>
#include <IOKit/IOReturn.h>
#include <IOKit/hid/IOHIDLib.h>
#include <CoreFoundation/CoreFoundation.h>

/*!
	@header IOHIDManager
    IOHIDManager defines an Human Interface Device (HID) managment object.  
    It provides global interaction with managed HID devices such as 
    discovery/removal and receiving input events.  IOHIDManager is also a CFType 
    object and as such conforms to all the conventions expected such object.
    <p>
    This documentation assumes that you have a basic understanding of the 
    material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as 
    matching dictionary, family, and driver, see the overview of I/O Kit terms 
    and concepts n the "Device Access and the I/O Kit" chapter of 
    <i>Accessing Hardware From Applications</i>.
    
    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header 
    file <font face="Courier New,Courier,Monaco">IOHIDManager.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDManager.h</font>.
*/

__BEGIN_DECLS

/*!
 @enum IOHIDManagerOptions
 @abstract Various options that can be supplied to IOHIDManager functions.
 @const kIOHIDManagerOptionNone For those times when supplying 0 just isn't explicit enough.
 @const kIOHIDManagerOptionUsePersistentProperties This constant can be supplied to @link IOHIDManagerCreate @/link
 to create and/or use a persistent properties store.
 @const kIOHIDManagerOptionDoNotLoadProperties This constant can be supplied to @link IOHIDManagerCreate when you wish to overwrite 
 the persistent properties store without loading it first.
 @const kIOHIDManagerOptionDoNotSaveProperties This constant can be supplied to @link IOHIDManagerCreate @/link when you want to 
 use the persistent property store but do not want to add to it.
 */
typedef enum {
    kIOHIDManagerOptionNone = 0x0,
    kIOHIDManagerOptionUsePersistentProperties = 0x1,
    kIOHIDManagerOptionDoNotLoadProperties = 0x2,
    kIOHIDManagerOptionDoNotSaveProperties = 0x4,
} IOHIDManagerOptions;

/*! @typedef IOHIDManagerRef
	@abstract This is the type of a reference to the IOHIDManager.
*/
typedef struct __IOHIDManager * IOHIDManagerRef;

/*!
	@function   IOHIDManagerGetTypeID
	@abstract   Returns the type identifier of all IOHIDManager instances.
*/
CF_EXPORT
CFTypeID IOHIDManagerGetTypeID(void) 
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDManagerCreate
	@abstract   Creates an IOHIDManager object.
    @discussion The IOHIDManager object is meant as a global management system
                for communicating with HID devices.
    @param      allocator Allocator to be used during creation.
    @param      options Supply @link kIOHIDManagerOptionUsePersistentProperties @/link to load
                properties from the default persistent property store. Otherwise supply
                @link kIOHIDManagerOptionNone @/link (or 0).                
    @result     Returns a new IOHIDManagerRef.
*/
CF_EXPORT 
IOHIDManagerRef IOHIDManagerCreate(     
                                CFAllocatorRef                  allocator,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDManagerOpen
	@abstract   Opens the IOHIDManager.
    @discussion This will open both current and future devices that are 
                enumerated. To establish an exclusive link use the 
                kIOHIDOptionsTypeSeizeDevice option. 
    @param      manager Reference to an IOHIDManager.
    @param      options Option bits to be sent down to the manager and device.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDManagerOpen(
                                IOHIDManagerRef                 manager,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDManagerClose
	@abstract   Closes the IOHIDManager.
    @discussion This will also close all devices that are currently enumerated.
    @param      manager Reference to an IOHIDManager.
    @param      options Option bits to be sent down to the manager and device.
    @result     Returns kIOReturnSuccess if successful.
*/
CF_EXPORT
IOReturn IOHIDManagerClose(
                                IOHIDManagerRef                 manager,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDManagerGetProperty
	@abstract   Obtains a property of an IOHIDManager.
    @discussion Property keys are prefixed by kIOHIDDevice and declared in 
                <IOKit/hid/IOHIDKeys.h>.
    @param      manager Reference to an IOHIDManager.
    @param      key CFStringRef containing key to be used when querying the 
                manager.
    @result     Returns CFTypeRef containing the property.
*/
CF_EXPORT
CFTypeRef IOHIDManagerGetProperty(
                                IOHIDManagerRef                 manager,
                                CFStringRef                     key)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDManagerSetProperty
	@abstract   Sets a property for an IOHIDManager.
    @discussion Property keys are prefixed by kIOHIDDevice and kIOHIDManager and
                declared in <IOKit/hid/IOHIDKeys.h>. This method will propagate 
                any relevent properties to current and future devices that are 
                enumerated.
    @param      manager Reference to an IOHIDManager.
    @param      key CFStringRef containing key to be used when modifiying the 
                device property.
    @param      value CFTypeRef containing the property value to be set.
    @result     Returns TRUE if successful.
*/
CF_EXPORT
Boolean IOHIDManagerSetProperty(
                                IOHIDManagerRef                 manager,
                                CFStringRef                     key,
                                CFTypeRef                       value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                        
/*! @function   IOHIDManagerScheduleWithRunLoop
    @abstract   Schedules HID manager with run loop.
    @discussion Formally associates manager with client's run loop. Scheduling
                this device with the run loop is necessary before making use of
                any asynchronous APIs.  This will propagate to current and 
                future devices that are enumerated.
    @param      manager Reference to an IOHIDManager.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDManagerScheduleWithRunLoop(
                                IOHIDManagerRef                 manager,
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerUnscheduleFromRunLoop
    @abstract   Unschedules HID manager with run loop.
    @discussion Formally disassociates device with client's run loop. This will 
                propagate to current devices that are enumerated.
    @param      manager Reference to an IOHIDManager.
    @param      runLoop RunLoop to be used when unscheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when unscheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDManagerUnscheduleFromRunLoop(
                                IOHIDManagerRef                 manager,
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDManagerSetDeviceMatching
    @abstract   Sets matching criteria for device enumeration.
    @discussion Matching keys are prefixed by kIOHIDDevice and declared in 
                <IOKit/hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
                in all devices being enumerated. Any subsequent calls will cause
                the hid manager to release previously enumerated devices and 
                restart the enuerate process using the revised criteria.  If 
                interested in multiple, specific device classes, please defer to
                using IOHIDManagerSetDeviceMatchingMultiple.
    @param      manager Reference to an IOHIDManager.
    @param      matching CFDictionaryRef containg device matching criteria.
*/
CF_EXPORT
void IOHIDManagerSetDeviceMatching(
                                IOHIDManagerRef                 manager,
                                CFDictionaryRef                 matching)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDManagerSetDeviceMatchingMultiple
    @abstract   Sets multiple matching criteria for device enumeration.
    @discussion Matching keys are prefixed by kIOHIDDevice and declared in 
                <IOKit/hid/IOHIDKeys.h>.  This method is useful if interested 
                in multiple, specific device classes.
    @param      manager Reference to an IOHIDManager.
    @param      multiple CFArrayRef containing multiple CFDictionaryRef objects
                containg device matching criteria.
*/
CF_EXPORT
void IOHIDManagerSetDeviceMatchingMultiple(
                                IOHIDManagerRef                 manager,
                                CFArrayRef                      multiple)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! @function   IOHIDManagerCopyDevices
    @abstract   Obtains currently enumerated devices.
    @param      manager Reference to an IOHIDManager.
    @result     CFSetRef containing IOHIDDeviceRefs.
*/
CF_EXPORT
CFSetRef IOHIDManagerCopyDevices(
                                IOHIDManagerRef                 manager)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerRegisterDeviceMatchingCallback
    @abstract   Registers a callback to be used a device is enumerated.
    @discussion Only device matching the set criteria will be enumerated.
    @param      manager Reference to an IOHIDManagerRef.
    @param      callback Pointer to a callback method of type 
                IOHIDDeviceCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDManagerRegisterDeviceMatchingCallback(
                                IOHIDManagerRef                 manager,
                                IOHIDDeviceCallback             callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerRegisterDeviceRemovalCallback
    @abstract   Registers a callback to be used when any enumerated device is 
                removed.
    @discussion In most cases this occurs when a device is unplugged.
    @param      manager Reference to an IOHIDManagerRef.
    @param      callback Pointer to a callback method of type 
                IOHIDDeviceCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDManagerRegisterDeviceRemovalCallback(
                                IOHIDManagerRef                 manager,
                                IOHIDDeviceCallback             callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerRegisterInputReportCallback
    @abstract   Registers a callback to be used when an input report is issued by 
                any enumerated device.
    @discussion An input report is an interrupt driver report issued by a device.
    @param      manager Reference to an IOHIDManagerRef.
    @param      callback Pointer to a callback method of type IOHIDReportCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDManagerRegisterInputReportCallback( 
                                    IOHIDManagerRef             manager,
                                    IOHIDReportCallback         callback,
                                    void *                      context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                                                    
/*! @function   IOHIDManagerRegisterInputValueCallback
    @abstract   Registers a callback to be used when an input value is issued by 
                any enumerated device.
    @discussion An input element refers to any element of type 
                kIOHIDElementTypeInput and is usually issued by interrupt driven
                reports.
    @param      manager Reference to an IOHIDManagerRef.
    @param      callback Pointer to a callback method of type IOHIDValueCallback.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDManagerRegisterInputValueCallback( 
                                IOHIDManagerRef                 manager,
                                IOHIDValueCallback              callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerSetInputValueMatching
    @abstract   Sets matching criteria for input values received via 
                IOHIDManagerRegisterInputValueCallback.
    @discussion Matching keys are prefixed by kIOHIDElement and declared in 
                <IOKit/hid/IOHIDKeys.h>.  Passing a NULL dictionary will result
                in all devices being enumerated. Any subsequent calls will cause
                the hid manager to release previously matched input elements and 
                restart the matching process using the revised criteria.  If 
                interested in multiple, specific device elements, please defer to
                using IOHIDManagerSetInputValueMatchingMultiple.
    @param      manager Reference to an IOHIDManager.
    @param      matching CFDictionaryRef containg device matching criteria.
*/
CF_EXPORT
void IOHIDManagerSetInputValueMatching(
                                IOHIDManagerRef                 manager,
                                CFDictionaryRef                 matching)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! @function   IOHIDManagerSetInputValueMatchingMultiple
    @abstract   Sets multiple matching criteria for input values received via 
                IOHIDManagerRegisterInputValueCallback.
    @discussion Matching keys are prefixed by kIOHIDElement and declared in 
                <IOKit/hid/IOHIDKeys.h>.  This method is useful if interested 
                in multiple, specific elements .
    @param      manager Reference to an IOHIDManager.
    @param      multiple CFArrayRef containing multiple CFDictionaryRef objects
                containing input element matching criteria.
*/

CF_EXPORT
void IOHIDManagerSetInputValueMatchingMultiple(
                                               IOHIDManagerRef                 manager,
                                               CFArrayRef                      multiple)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
 @abstract   Used to write out the current properties to a specific domain.
 @discussion Using this function will cause the persistent properties to be saved out
 replacing any properties that already existed in the specified domain. All arguments 
 must be non-NULL except options.
 @param     manager Reference to an IOHIDManager.
 @param     applicationID Reference to a CFPreferences applicationID.
 @param     userName Reference to a CFPreferences userName.
 @param     hostName Reference to a CFPreferences hostName.
 @param     options Reserved for future use.
 */
CF_EXPORT
void IOHIDManagerSaveToPropertyDomain(IOHIDManagerRef                 manager,
                                      CFStringRef                     applicationID,
                                      CFStringRef                     userName,
                                      CFStringRef                     hostName,
                                      IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;



__END_DECLS

#endif /* _IOKIT_HID_IOHIDMANAGER_H_ */

                                                                                                                                                                                                                      IOHIDQueue.h                                                                                        0100644 0001750 0001750 00000027057 12566177313 033377  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDQUEUE_USER_H
#define _IOKIT_HID_IOHIDQUEUE_USER_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/hid/IOHIDBase.h>

/*!
	@header IOHIDQueue
    IOHIDQueue defines an object used to queue values from input parsed items 
    (IOHIDElement) contained within a Human Interface Device (HID) object.  This
    object is useful when you need to keep track of all values of an input 
    element, rather than just the most recent one.  IOHIDQueue is a CFType 
    object and as such conforms to all the conventions expected such object.
    <p>
    IOHIDQueue should be considered optional and is only useful for working with
    complex input elements.  These elements include those whose length are 
    greater than sizeof(CFIndex) or elements that are duplicate items. 
    Whenever possible please defer to using 
    IOHIDManagerRegisterInputValueCallback or 
    IOHIDDeviceRegisterInputValueCallback.
    <p>
    <b>Note:</b>Absolute element values (based on a fixed origin) will only be 
    placed on a queue if there is a change in value. 
    <p>
    This documentation assumes that you have a basic understanding of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.

    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOHIDQueue.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDQueue.h</font>.
*/

__BEGIN_DECLS

/*! @typedef IOHIDQueueRef
	This is the type of a reference to the IOHIDQueue.
*/
typedef struct __IOHIDQueue * IOHIDQueueRef;

/*!
	@function   IOHIDQueueGetTypeID
	@abstract   Returns the type identifier of all IOHIDQueue instances.
*/
CF_EXPORT
CFTypeID IOHIDQueueGetTypeID(void)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDQueueCreate
	@abstract   Creates an IOHIDQueue object for the specified device.
    @discussion Take care in specifying an appropriate depth to prevent dropping
                events.
    @param      allocator Allocator to be used during creation.
    @param      device IOHIDDevice object 
    @param      depth The number of values that can be handled by the queue.
    @param      options Reserved for future use.
    @result     Returns a new IOHIDQueueRef.
*/
CF_EXPORT
IOHIDQueueRef IOHIDQueueCreate(
                                CFAllocatorRef                  allocator, 
                                IOHIDDeviceRef                  device,
                                CFIndex                         depth,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDQueueGetDevice
	@abstract   Obtain the device associated with the queue.
    @param      queue IOHIDQueue to be queried. 
    @result     Returns the a reference to the device.
*/
CF_EXPORT
IOHIDDeviceRef IOHIDQueueGetDevice(     
                                IOHIDQueueRef                   queue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*!
	@function   IOHIDQueueGetDepth
	@abstract   Obtain the depth of the queue.
    @param      queue IOHIDQueue to be queried. 
    @result     Returns the queue depth.
*/
CF_EXPORT
CFIndex IOHIDQueueGetDepth(     
                                IOHIDQueueRef                   queue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDQueueSetDepth
	@abstract   Sets the depth of the queue.
    @discussion Set the appropriate depth value based on the number of elements
                contained in a queue.
    @param      queue IOHIDQueue object to be modified.
    @param      depth The new queue depth.
*/
CF_EXPORT
void IOHIDQueueSetDepth(        
                                IOHIDQueueRef                   queue,
                                CFIndex                         depth)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDQueueAddElement
	@abstract   Adds an element to the queue
    @param      queue IOHIDQueue object to be modified.
    @param      element Element to be added to the queue.
*/
CF_EXPORT
void IOHIDQueueAddElement(      
                                IOHIDQueueRef                   queue,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDQueueRemoveElement
	@abstract   Removes an element from the queue
    @param      queue IOHIDQueue object to be modified.
    @param      element Element to be removed from the queue.
*/
CF_EXPORT
void IOHIDQueueRemoveElement(
                                IOHIDQueueRef                   queue,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDQueueContainsElement
	@abstract   Queries the queue to determine if elemement has been added.
    @param      queue IOHIDQueue object to be queried.
    @param      element Element to be queried.
    @result     Returns true or false depending if element is present.
*/
CF_EXPORT
Boolean IOHIDQueueContainsElement(
                                IOHIDQueueRef                   queue,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*! 
    @function   IOHIDQueueStart
    @abstract   Starts element value delivery to the queue.
    @param      queue IOHIDQueue object to be started.
*/
CF_EXPORT
void IOHIDQueueStart(           IOHIDQueueRef                   queue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! 
    @function   IOHIDQueueStop
    @abstract   Stops element value delivery to the queue.
    @param      queue IOHIDQueue object to be stopped.
*/
CF_EXPORT
void IOHIDQueueStop(            IOHIDQueueRef                   queue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDQueueScheduleWithRunLoop
	@abstract   Schedules queue with run loop.
    @discussion Formally associates queue with client's run loop. Scheduling
                this queue with the run loop is necessary before making 
                use of any asynchronous APIs.
    @param      queue IOHIDQueue object to be modified.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDQueueScheduleWithRunLoop(
                                IOHIDQueueRef                   queue, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDQueueUnscheduleFromRunLoop
	@abstract   Unschedules queue with run loop.
    @discussion Formally disassociates queue with client's run loop.
    @param      queue IOHIDQueue object to be modified.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDQueueUnscheduleFromRunLoop(  
                                IOHIDQueueRef                   queue, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDQueueRegisterValueAvailableCallback
	@abstract   Sets callback to be used when the queue transitions to non-empty.
    @discussion In order to make use of asynchronous behavior, the queue needs
                to be scheduled with the run loop.
    @param      queue IOHIDQueue object to be modified.
    @param      callback Callback of type IOHIDCallback to be used when data is 
                placed on the queue.
    @param      context Pointer to data to be passed to the callback.
*/
CF_EXPORT
void IOHIDQueueRegisterValueAvailableCallback(
                                IOHIDQueueRef                   queue,
                                IOHIDCallback                   callback,
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! 
    @function   IOHIDQueueCopyNextValue
    @abstract   Dequeues a retained copy of an element value from the head of an 
                IOHIDQueue.
    @discussion Because the value is a retained copy, it is up to the caller to 
                release the value using CFRelease. Use with setValueCallback to 
                avoid polling the queue for data.
    @param      queue IOHIDQueue object to be queried.
    @result     Returns valid IOHIDValueRef if data is available.
*/
CF_EXPORT
IOHIDValueRef IOHIDQueueCopyNextValue(
                                IOHIDQueueRef                   queue)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! 
    @function   IOHIDQueueCopyNextValueWithTimeout
    @abstract   Dequeues a retained copy of an element value from the head of an 
                IOHIDQueue.  This method will block until either a value is
                available or it times out.
    @discussion Because the value is a retained copy, it is up to the caller to 
                release the value using CFRelease. Use with setValueCallback to 
                avoid polling the queue for data.
    @param      queue IOHIDQueue object to be queried.
    @param      timeout Timeout before aborting an attempt to dequeue a value 
                from the head of a queue.
    @result     Returns valid IOHIDValueRef if data is available.
*/
CF_EXPORT
IOHIDValueRef IOHIDQueueCopyNextValueWithTimeout(
                                IOHIDQueueRef                   queue,
                                CFTimeInterval                  timeout)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

__END_DECLS

#endif /* _IOKIT_HID_IOHIDQUEUE_USER_H */                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 IOHIDTransaction.h                                                                                  0100644 0001750 0001750 00000034061 12566177313 034571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDTRANSACTION_USER_H
#define _IOKIT_HID_IOHIDTRANSACTION_USER_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/hid/IOHIDBase.h>

/*!
	@header IOHIDTransaction
    IOHIDTransaction defines an object used to manipulate multiple parsed items 
    (IOHIDElement) contained within a Human Interface Device (HID) object.  It
    is used to minimize device communication when interacting with feature and
    output type elements that are grouped by their report IDs.  IOHIDTransaction 
    is a CFType object and as such conforms to all the conventions expected such 
    object.
    <p>
    This documentation assumes that you have a basic understanding of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.

    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOHIDTransaction.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDTransaction.h</font>.
*/

__BEGIN_DECLS

/*! @typedef IOHIDTransactionRef
	This is the type of a reference to the IOHIDTransaction.
*/
typedef struct __IOHIDTransaction * IOHIDTransactionRef;

/*!
	@function   IOHIDTransactionGetTypeID
	@abstract   Returns the type identifier of all IOHIDTransaction instances.
*/
CF_EXPORT
CFTypeID IOHIDTransactionGetTypeID(void)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionCreate
	@abstract   Creates an IOHIDTransaction object for the specified device.
    @discussion IOHIDTransaction objects can be used to either send or receive
                multiple element values.  As such the direction used should 
                represent they type of objects added to the transaction.
    @param      allocator Allocator to be used during creation.
    @param      device IOHIDDevice object 
    @param      direction The direction, either in or out, for the transaction.
    @param      options Reserved for future use.
    @result     Returns a new IOHIDTransactionRef.
*/
CF_EXPORT
IOHIDTransactionRef IOHIDTransactionCreate(
                                CFAllocatorRef                  allocator, 
                                IOHIDDeviceRef                  device,
                                IOHIDTransactionDirectionType   direction,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;


/*!
	@function   IOHIDTransactionGetDevice
	@abstract   Obtain the device associated with the transaction.
    @param      transaction IOHIDTransaction to be queried. 
    @result     Returns the a reference to the device.
*/
CF_EXPORT
IOHIDDeviceRef IOHIDTransactionGetDevice(     
                                IOHIDTransactionRef             transaction)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionGetDirection
	@abstract   Obtain the direction of the transaction.
    @param      transaction IOHIDTransaction to be queried. 
    @result     Returns the transaction direction.
*/
CF_EXPORT
IOHIDTransactionDirectionType IOHIDTransactionGetDirection(     
                                IOHIDTransactionRef             transaction)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionSetDirection
	@abstract   Sets the direction of the transaction
    @disussion  This method is useful for manipulating bi-direction (feature) 
                elements such that you can set or get element values without
                creating an additional transaction object.
    @param      transaction IOHIDTransaction object to be modified.
    @param      direction The new transaction direction.
*/
CF_EXPORT
void IOHIDTransactionSetDirection(        
                                IOHIDTransactionRef             transaction,
                                IOHIDTransactionDirectionType   direction)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDTransactionAddElement
	@abstract   Adds an element to the transaction
    @disussion  To minimize device traffic it is important to add elements that
                share a common report type and report id.
    @param      transaction IOHIDTransaction object to be modified.
    @param      element Element to be added to the transaction.
*/
CF_EXPORT
void IOHIDTransactionAddElement(      
                                IOHIDTransactionRef             transaction,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDTransactionRemoveElement
	@abstract   Removes an element to the transaction
    @param      transaction IOHIDTransaction object to be modified.
    @param      element Element to be removed to the transaction.
*/
CF_EXPORT
void IOHIDTransactionRemoveElement(
                                IOHIDTransactionRef             transaction,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDTransactionContainsElement
	@abstract   Queries the transaction to determine if elemement has been added.
    @param      transaction IOHIDTransaction object to be queried.
    @param      element Element to be queried.
    @result     Returns true or false depending if element is present.
*/
CF_EXPORT
Boolean IOHIDTransactionContainsElement(
                                IOHIDTransactionRef             transaction,
                                IOHIDElementRef                 element)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionScheduleWithRunLoop
	@abstract   Schedules transaction with run loop.
    @discussion Formally associates transaction with client's run loop. 
                Scheduling this transaction with the run loop is necessary 
                before making use of any asynchronous APIs.
    @param      transaction IOHIDTransaction object to be modified.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDTransactionScheduleWithRunLoop(
                                IOHIDTransactionRef             transaction, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionUnscheduleFromRunLoop
	@abstract   Unschedules transaction with run loop.
    @discussion Formally disassociates transaction with client's run loop.
    @param      transaction IOHIDTransaction object to be modified.
    @param      runLoop RunLoop to be used when scheduling any asynchronous 
                activity.
    @param      runLoopMode Run loop mode to be used when scheduling any 
                asynchronous activity.
*/
CF_EXPORT
void IOHIDTransactionUnscheduleFromRunLoop(  
                                IOHIDTransactionRef             transaction, 
                                CFRunLoopRef                    runLoop, 
                                CFStringRef                     runLoopMode)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionSetValue
	@abstract   Sets the value for a transaction element.
    @discussion The value set is pended until the transaction is committed and
                is only used if the transaction direction is 
                kIOHIDTransactionDirectionTypeOutput.  Use the 
                kIOHIDTransactionOptionDefaultOutputValue option to set the 
                default element value.
    @param      transaction IOHIDTransaction object to be modified.
    @param      element Element to be modified after a commit.
    @param      value Value to be set for the given element.
    @param      options See IOHIDTransactionOption.
*/
CF_EXPORT
void IOHIDTransactionSetValue(
                                IOHIDTransactionRef             transaction,
                                IOHIDElementRef                 element, 
                                IOHIDValueRef                   value,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDTransactionGetValue
	@abstract   Obtains the value for a transaction element.
    @discussion If the transaction direction is 
                kIOHIDTransactionDirectionTypeInput the value represents what
                was obtained from the device from the transaction.  Otherwise, 
                if the transaction direction is 
                kIOHIDTransactionDirectionTypeOutput the value represents the 
                pending value to be sent to the device.  Use the 
                kIOHIDTransactionOptionDefaultOutputValue option to get the 
                default element value.
    @param      transaction IOHIDTransaction object to be queried.
    @param      element Element to be queried.
    @param      options See IOHIDTransactionOption.
    @result     Returns IOHIDValueRef for the given element.
*/
CF_EXPORT
IOHIDValueRef IOHIDTransactionGetValue(
                                IOHIDTransactionRef             transaction,
                                IOHIDElementRef                 element,
                                IOOptionBits                    options)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
       
/*!
	@function   IOHIDTransactionCommit
	@abstract   Synchronously commits element transaction to the device.
    @discussion In regards to kIOHIDTransactionDirectionTypeOutput direction, 
                default element values will be used if element values are not 
                set.  If neither are set, that element will be omitted from the 
                commit. After a transaction is committed, transaction element 
                values will be cleared and default values preserved.
    @param      transaction IOHIDTransaction object to be modified.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if 
                unsuccessful.
*/
CF_EXPORT
IOReturn IOHIDTransactionCommit(
                                IOHIDTransactionRef             transaction)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
/*!
	@function   IOHIDTransactionCommitWithCallback
	@abstract   Commits element transaction to the device.
    @discussion In regards to kIOHIDTransactionDirectionTypeOutput direction, 
                default element values will be used if element values are not 
                set.  If neither are set, that element will be omitted from the 
                commit. After a transaction is committed, transaction element 
                values will be cleared and default values preserved.
                <br>
                <b>Note:</b> It is possible for elements from different reports
                to be present in a given transaction causing a commit to
                transcend multiple reports. Keep this in mind when setting a 
                appropriate timeout.
    @param      transaction IOHIDTransaction object to be modified.
    @param      timeout Timeout for issuing the transaction.
    @param      callback Callback of type IOHIDCallback to be used when 
                transaction has been completed.  If null, this method will 
                behave synchronously.
    @param      context Pointer to data to be passed to the callback.
    @result     Returns kIOReturnSuccess if successful or a kern_return_t if 
                unsuccessful.
*/
CF_EXPORT
IOReturn IOHIDTransactionCommitWithCallback(
                                IOHIDTransactionRef             transaction,
                                CFTimeInterval                  timeout, 
                                IOHIDCallback                   callback, 
                                void *                          context)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*! 
    @function   IOHIDTransactionClear
    @abstract   Clears element transaction values.
    @discussion In regards to kIOHIDTransactionDirectionTypeOutput direction, 
                default element values will be preserved.
    @param      transaction IOHIDTransaction object to be modified.
*/
CF_EXPORT
void IOHIDTransactionClear(
                                IOHIDTransactionRef             transaction)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;
                                
__END_DECLS

#endif /* _IOKIT_HID_IOHIDTRANSACTION_USER_H */                                                                                                                                                                                                                                                                                                                                                                                                                                                                               IOHIDUsageTables.h                                                                                  0100644 0001750 0001750 00000416451 12567452123 034506  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
#ifndef _IOHIDUSAGETABLES_H
#define _IOHIDUSAGETABLES_H

/* ******************************************************************************************
 * HID Usage Tables
 *
 * The following constants are from the USB 'HID Usage Tables' specification, revision 1.1rc3
 * ****************************************************************************************** */


/* Usage Pages */
enum
{
    kHIDPage_Undefined              = 0x00,
    kHIDPage_GenericDesktop         = 0x01,
    kHIDPage_Simulation             = 0x02,
    kHIDPage_VR                     = 0x03,
    kHIDPage_Sport                  = 0x04,
    kHIDPage_Game                   = 0x05,
    kHIDPage_GenericDeviceControls  = 0x06,
    kHIDPage_KeyboardOrKeypad       = 0x07,    /* USB Device Class Definition for Human Interface Devices (HID). Note: the usage type for all key codes is Selector (Sel). */
    kHIDPage_LEDs                   = 0x08,
    kHIDPage_Button                 = 0x09,
    kHIDPage_Ordinal                = 0x0A,
    kHIDPage_Telephony              = 0x0B,
    kHIDPage_Consumer               = 0x0C,
    kHIDPage_Digitizer              = 0x0D,
    /* Reserved 0x0E */
    kHIDPage_PID                    = 0x0F,    /* USB Physical Interface Device definitions for force feedback and related devices. */
    kHIDPage_Unicode                = 0x10,
    /* Reserved 0x11 - 0x13 */
    kHIDPage_AlphanumericDisplay    = 0x14,
    /* Reserved 0x15 - 0x1F */
    kHIDPage_Sensor                 = 0x20,
    /* Reserved 0x21 - 0x7f */
    kHIDPage_Monitor                = 0x80,
    kHIDPage_MonitorEnumerated      = 0x81,
    kHIDPage_MonitorVirtual         = 0x82,
    kHIDPage_MonitorReserved        = 0x83,
    /* Power 0x84 - 0x87     USB Device Class Definition for Power Devices */
    kHIDPage_PowerDevice            = 0x84,                 /* Power Device Page */
    kHIDPage_BatterySystem          = 0x85,                 /* Battery System Page */
    kHIDPage_PowerReserved          = 0x86,
    kHIDPage_PowerReserved2         = 0x87,
    /* Reserved 0x88 - 0x8B */
    kHIDPage_BarCodeScanner         = 0x8C,    /* (Point of Sale) USB Device Class Definition for Bar Code Scanner Devices */
    kHIDPage_WeighingDevice         = 0x8D,    /* (Point of Sale) USB Device Class Definition for Weighing Devices */
    kHIDPage_Scale                  = 0x8D,    /* (Point of Sale) USB Device Class Definition for Scale Devices */
    kHIDPage_MagneticStripeReader   = 0x8E,
    /* ReservedPointofSalepages 0x8F */
    kHIDPage_CameraControl          = 0x90,    /* USB Device Class Definition for Image Class Devices */
    kHIDPage_Arcade                 = 0x91,    /* OAAF Definitions for arcade and coinop related Devices */
    /* Reserved 0x92 - 0xFEFF */
    /* VendorDefined 0xFF00 - 0xFFFF */
    kHIDPage_VendorDefinedStart     = 0xFF00
};

/* Undefined Usage for all usage pages */
enum
{
    kHIDUsage_Undefined    = 0x00
};

/* GenericDesktop Page (0x01) */
enum
{
    kHIDUsage_GD_Pointer    = 0x01,    /* Physical Collection */
    kHIDUsage_GD_Mouse    = 0x02,    /* Application Collection */
    /* 0x03 Reserved */
    kHIDUsage_GD_Joystick    = 0x04,    /* Application Collection */
    kHIDUsage_GD_GamePad    = 0x05,    /* Application Collection */
    kHIDUsage_GD_Keyboard    = 0x06,    /* Application Collection */
    kHIDUsage_GD_Keypad    = 0x07,    /* Application Collection */
    kHIDUsage_GD_MultiAxisController    = 0x08,    /* Application Collection */
    /* 0x09 - 0x2F Reserved */
    kHIDUsage_GD_X    = 0x30,    /* Dynamic Value */
    kHIDUsage_GD_Y    = 0x31,    /* Dynamic Value */
    kHIDUsage_GD_Z    = 0x32,    /* Dynamic Value */
    kHIDUsage_GD_Rx    = 0x33,    /* Dynamic Value */
    kHIDUsage_GD_Ry    = 0x34,    /* Dynamic Value */
    kHIDUsage_GD_Rz    = 0x35,    /* Dynamic Value */
    kHIDUsage_GD_Slider    = 0x36,    /* Dynamic Value */
    kHIDUsage_GD_Dial    = 0x37,    /* Dynamic Value */
    kHIDUsage_GD_Wheel    = 0x38,    /* Dynamic Value */
    kHIDUsage_GD_Hatswitch    = 0x39,    /* Dynamic Value */
    kHIDUsage_GD_CountedBuffer    = 0x3A,    /* Logical Collection */
    kHIDUsage_GD_ByteCount    = 0x3B,    /* Dynamic Value */
    kHIDUsage_GD_MotionWakeup    = 0x3C,    /* One-Shot Control */
    kHIDUsage_GD_Start    = 0x3D,    /* On/Off Control */
    kHIDUsage_GD_Select    = 0x3E,    /* On/Off Control */
    /* 0x3F Reserved */
    kHIDUsage_GD_Vx    = 0x40,    /* Dynamic Value */
    kHIDUsage_GD_Vy    = 0x41,    /* Dynamic Value */
    kHIDUsage_GD_Vz    = 0x42,    /* Dynamic Value */
    kHIDUsage_GD_Vbrx    = 0x43,    /* Dynamic Value */
    kHIDUsage_GD_Vbry    = 0x44,    /* Dynamic Value */
    kHIDUsage_GD_Vbrz    = 0x45,    /* Dynamic Value */
    kHIDUsage_GD_Vno    = 0x46,    /* Dynamic Value */
    /* 0x47 - 0x7F Reserved */
    kHIDUsage_GD_SystemControl    = 0x80,    /* Application Collection */
    kHIDUsage_GD_SystemPowerDown    = 0x81,    /* One-Shot Control */
    kHIDUsage_GD_SystemSleep    = 0x82,    /* One-Shot Control */
    kHIDUsage_GD_SystemWakeUp    = 0x83,    /* One-Shot Control */
    kHIDUsage_GD_SystemContextMenu    = 0x84,    /* One-Shot Control */
    kHIDUsage_GD_SystemMainMenu    = 0x85,    /* One-Shot Control */
    kHIDUsage_GD_SystemAppMenu    = 0x86,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuHelp    = 0x87,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuExit    = 0x88,    /* One-Shot Control */
    kHIDUsage_GD_SystemMenuSelect    = 0x89,    /* Selector */
    kHIDUsage_GD_SystemMenu    = kHIDUsage_GD_SystemMenuSelect,    /* Selector */
    kHIDUsage_GD_SystemMenuRight    = 0x8A,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuLeft    = 0x8B,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuUp    = 0x8C,    /* Re-Trigger Control */
    kHIDUsage_GD_SystemMenuDown    = 0x8D,    /* Re-Trigger Control */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_GD_DPadUp    = 0x90,    /* On/Off Control */
    kHIDUsage_GD_DPadDown    = 0x91,    /* On/Off Control */
    kHIDUsage_GD_DPadRight    = 0x92,    /* On/Off Control */
    kHIDUsage_GD_DPadLeft    = 0x93,    /* On/Off Control */
    /* 0x94 - 0xFFFF Reserved */
    kHIDUsage_GD_Reserved = 0xFFFF
};

/* Simulation Page (0x02) */
/* This section provides detailed descriptions of the usages employed by simulation devices. */
enum
{
    kHIDUsage_Sim_FlightSimulationDevice    = 0x01,    /* Application Collection */
    kHIDUsage_Sim_AutomobileSimulationDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Sim_TankSimulationDevice    = 0x03,    /* Application Collection */
    kHIDUsage_Sim_SpaceshipSimulationDevice    = 0x04,    /* Application Collection */
    kHIDUsage_Sim_SubmarineSimulationDevice    = 0x05,    /* Application Collection */
    kHIDUsage_Sim_SailingSimulationDevice    = 0x06,    /* Application Collection */
    kHIDUsage_Sim_MotorcycleSimulationDevice    = 0x07,    /* Application Collection */
    kHIDUsage_Sim_SportsSimulationDevice    = 0x08,    /* Application Collection */
    kHIDUsage_Sim_AirplaneSimulationDevice    = 0x09,    /* Application Collection */
    kHIDUsage_Sim_HelicopterSimulationDevice    = 0x0A,    /* Application Collection */
    kHIDUsage_Sim_MagicCarpetSimulationDevice    = 0x0B,    /* Application Collection */
    kHIDUsage_Sim_BicycleSimulationDevice    = 0x0C,    /* Application Collection */
    /* 0x0D - 0x1F Reserved */
    kHIDUsage_Sim_FlightControlStick    = 0x20,    /* Application Collection */
    kHIDUsage_Sim_FlightStick    = 0x21,    /* Application Collection */
    kHIDUsage_Sim_CyclicControl    = 0x22,    /* Physical Collection */
    kHIDUsage_Sim_CyclicTrim    = 0x23,    /* Physical Collection */
    kHIDUsage_Sim_FlightYoke    = 0x24,    /* Application Collection */
    kHIDUsage_Sim_TrackControl    = 0x25,    /* Physical Collection */
    /* 0x26 - 0xAF Reserved */
    kHIDUsage_Sim_Aileron    = 0xB0,    /* Dynamic Value */
    kHIDUsage_Sim_AileronTrim    = 0xB1,    /* Dynamic Value */
    kHIDUsage_Sim_AntiTorqueControl    = 0xB2,    /* Dynamic Value */
    kHIDUsage_Sim_AutopilotEnable    = 0xB3,    /* On/Off Control */
    kHIDUsage_Sim_ChaffRelease    = 0xB4,    /* One-Shot Control */
    kHIDUsage_Sim_CollectiveControl    = 0xB5,    /* Dynamic Value */
    kHIDUsage_Sim_DiveBrake    = 0xB6,    /* Dynamic Value */
    kHIDUsage_Sim_ElectronicCountermeasures    = 0xB7,    /* On/Off Control */
    kHIDUsage_Sim_Elevator    = 0xB8,    /* Dynamic Value */
    kHIDUsage_Sim_ElevatorTrim    = 0xB9,    /* Dynamic Value */
    kHIDUsage_Sim_Rudder    = 0xBA,    /* Dynamic Value */
    kHIDUsage_Sim_Throttle    = 0xBB,    /* Dynamic Value */
    kHIDUsage_Sim_FlightCommunications    = 0xBC,    /* On/Off Control */
    kHIDUsage_Sim_FlareRelease    = 0xBD,    /* One-Shot Control */
    kHIDUsage_Sim_LandingGear    = 0xBE,    /* On/Off Control */
    kHIDUsage_Sim_ToeBrake    = 0xBF,    /* Dynamic Value */
    kHIDUsage_Sim_Trigger    = 0xC0,    /* Momentary Control */
    kHIDUsage_Sim_WeaponsArm    = 0xC1,    /* On/Off Control */
    kHIDUsage_Sim_Weapons    = 0xC2,    /* Selector */
    kHIDUsage_Sim_WingFlaps    = 0xC3,    /* Dynamic Value */
    kHIDUsage_Sim_Accelerator    = 0xC4,    /* Dynamic Value */
    kHIDUsage_Sim_Brake    = 0xC5,    /* Dynamic Value */
    kHIDUsage_Sim_Clutch    = 0xC6,    /* Dynamic Value */
    kHIDUsage_Sim_Shifter    = 0xC7,    /* Dynamic Value */
    kHIDUsage_Sim_Steering    = 0xC8,    /* Dynamic Value */
    kHIDUsage_Sim_TurretDirection    = 0xC9,    /* Dynamic Value */
    kHIDUsage_Sim_BarrelElevation    = 0xCA,    /* Dynamic Value */
    kHIDUsage_Sim_DivePlane    = 0xCB,    /* Dynamic Value */
    kHIDUsage_Sim_Ballast    = 0xCC,    /* Dynamic Value */
    kHIDUsage_Sim_BicycleCrank    = 0xCD,    /* Dynamic Value */
    kHIDUsage_Sim_HandleBars    = 0xCE,    /* Dynamic Value */
    kHIDUsage_Sim_FrontBrake    = 0xCF,    /* Dynamic Value */
    kHIDUsage_Sim_RearBrake    = 0xD0,    /* Dynamic Value */
    /* 0xD1 - 0xFFFF Reserved */
    kHIDUsage_Sim_Reserved = 0xFFFF
};

/* VR Page (0x03) */
/* Virtual Reality controls depend on designators to identify the individual controls. Most of the following are */
/* usages are applied to the collections of entities that comprise the actual device. */
enum
{
    kHIDUsage_VR_Belt    = 0x01,    /* Application Collection */
    kHIDUsage_VR_BodySuit    = 0x02,    /* Application Collection */
    kHIDUsage_VR_Flexor    = 0x03,    /* Physical Collection */
    kHIDUsage_VR_Glove    = 0x04,    /* Application Collection */
    kHIDUsage_VR_HeadTracker    = 0x05,    /* Physical Collection */
    kHIDUsage_VR_HeadMountedDisplay    = 0x06,    /* Application Collection */
    kHIDUsage_VR_HandTracker    = 0x07,    /* Application Collection */
    kHIDUsage_VR_Oculometer    = 0x08,    /* Application Collection */
    kHIDUsage_VR_Vest    = 0x09,    /* Application Collection */
    kHIDUsage_VR_AnimatronicDevice    = 0x0A,    /* Application Collection */
    /* 0x0B - 0x1F Reserved */
    kHIDUsage_VR_StereoEnable    = 0x20,    /* On/Off Control */
    kHIDUsage_VR_DisplayEnable    = 0x21,    /* On/Off Control */
    /* 0x22 - 0xFFFF Reserved */
    kHIDUsage_VR_Reserved = 0xFFFF
};

/* Sport Page (0x04) */
enum
{
    kHIDUsage_Sprt_BaseballBat    = 0x01,    /* Application Collection */
    kHIDUsage_Sprt_GolfClub    = 0x02,    /* Application Collection */
    kHIDUsage_Sprt_RowingMachine    = 0x03,    /* Application Collection */
    kHIDUsage_Sprt_Treadmill    = 0x04,    /* Application Collection */
    /* 0x05 - 0x2F Reserved */
    kHIDUsage_Sprt_Oar    = 0x30,    /* Dynamic Value */
    kHIDUsage_Sprt_Slope    = 0x31,    /* Dynamic Value */
    kHIDUsage_Sprt_Rate    = 0x32,    /* Dynamic Value */
    kHIDUsage_Sprt_StickSpeed    = 0x33,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFaceAngle    = 0x34,    /* Dynamic Value */
    kHIDUsage_Sprt_StickHeelOrToe    = 0x35,    /* Dynamic Value */
    kHIDUsage_Sprt_StickFollowThrough    = 0x36,    /* Dynamic Value */
    kHIDUsage_Sprt_StickTempo    = 0x37,    /* Dynamic Value */
    kHIDUsage_Sprt_StickType    = 0x38,    /* Named Array */
    kHIDUsage_Sprt_StickHeight    = 0x39,    /* Dynamic Value */
    /* 0x3A - 0x4F Reserved */
    kHIDUsage_Sprt_Putter    = 0x50,    /* Selector */
    kHIDUsage_Sprt_1Iron    = 0x51,    /* Selector */
    kHIDUsage_Sprt_2Iron    = 0x52,    /* Selector */
    kHIDUsage_Sprt_3Iron    = 0x53,    /* Selector */
    kHIDUsage_Sprt_4Iron    = 0x54,    /* Selector */
    kHIDUsage_Sprt_5Iron    = 0x55,    /* Selector */
    kHIDUsage_Sprt_6Iron    = 0x56,    /* Selector */
    kHIDUsage_Sprt_7Iron    = 0x57,    /* Selector */
    kHIDUsage_Sprt_8Iron    = 0x58,    /* Selector */
    kHIDUsage_Sprt_9Iron    = 0x59,    /* Selector */
    kHIDUsage_Sprt_10Iron    = 0x5A,    /* Selector */
    kHIDUsage_Sprt_11Iron    = 0x5B,    /* Selector */
    kHIDUsage_Sprt_SandWedge    = 0x5C,    /* Selector */
    kHIDUsage_Sprt_LoftWedge    = 0x5D,    /* Selector */
    kHIDUsage_Sprt_PowerWedge    = 0x5E,    /* Selector */
    kHIDUsage_Sprt_1Wood    = 0x5F,    /* Selector */
    kHIDUsage_Sprt_3Wood    = 0x60,    /* Selector */
    kHIDUsage_Sprt_5Wood    = 0x61,    /* Selector */
    kHIDUsage_Sprt_7Wood    = 0x62,    /* Selector */
    kHIDUsage_Sprt_9Wood    = 0x63,    /* Selector */
    /* 0x64 - 0xFFFF Reserved */
    kHIDUsage_Sprt_Reserved = 0xFFFF
};

/* Game Page (0x05) */
enum
{
    kHIDUsage_Game_3DGameController    = 0x01,    /* Application Collection */
    kHIDUsage_Game_PinballDevice    = 0x02,    /* Application Collection */
    kHIDUsage_Game_GunDevice    = 0x03,    /* Application Collection */
    /* 0x04 - 0x1F Reserved */
    kHIDUsage_Game_PointofView    = 0x20,    /* Physical Collection */
    kHIDUsage_Game_TurnRightOrLeft    = 0x21,    /* Dynamic Value */
    kHIDUsage_Game_PitchUpOrDown    = 0x22,    /* Dynamic Value */
    kHIDUsage_Game_RollRightOrLeft    = 0x23,    /* Dynamic Value */
    kHIDUsage_Game_MoveRightOrLeft    = 0x24,    /* Dynamic Value */
    kHIDUsage_Game_MoveForwardOrBackward    = 0x25,    /* Dynamic Value */
    kHIDUsage_Game_MoveUpOrDown    = 0x26,    /* Dynamic Value */
    kHIDUsage_Game_LeanRightOrLeft    = 0x27,    /* Dynamic Value */
    kHIDUsage_Game_LeanForwardOrBackward    = 0x28,    /* Dynamic Value */
    kHIDUsage_Game_HeightOfPOV    = 0x29,    /* Dynamic Value */
    kHIDUsage_Game_Flipper    = 0x2A,    /* Momentary Control */
    kHIDUsage_Game_SecondaryFlipper    = 0x2B,    /* Momentary Control */
    kHIDUsage_Game_Bump    = 0x2C,    /* Momentary Control */
    kHIDUsage_Game_NewGame    = 0x2D,    /* One-Shot Control */
    kHIDUsage_Game_ShootBall    = 0x2E,    /* One-Shot Control */
    kHIDUsage_Game_Player    = 0x2F,    /* One-Shot Control */
    kHIDUsage_Game_GunBolt    = 0x30,    /* On/Off Control */
    kHIDUsage_Game_GunClip    = 0x31,    /* On/Off Control */
    kHIDUsage_Game_Gun    = 0x32,    /* Selector */
    kHIDUsage_Game_GunSingleShot    = 0x33,    /* Selector */
    kHIDUsage_Game_GunBurst    = 0x34,    /* Selector */
    kHIDUsage_Game_GunAutomatic    = 0x35,    /* Selector */
    kHIDUsage_Game_GunSafety    = 0x36,    /* On/Off Control */
    kHIDUsage_Game_GamepadFireOrJump    = 0x37,    /* Logical Collection */
    kHIDUsage_Game_GamepadTrigger    = 0x39,    /* Logical Collection */
    /* 0x3A - 0xFFFF Reserved */
    kHIDUsage_Game_Reserved = 0xFFFF
};

/* Generic Device Controls (0x0g) */
enum
{
    kHIDUsage_GenDevControls_BackgroundControls     = 0x01, /* Application Collection */
};

/* KeyboardOrKeypad Page (0x07) */
/* This section is the Usage Page for key codes to be used in implementing a USB keyboard. A Boot Keyboard (84-, 101- or 104-key) should at a minimum support all associated usage codes as indicated in the Boot */
/* column below. */
/* The usage type of all key codes is Selectors (Sel), except for the modifier keys Keyboard Left Control (0x224) to Keyboard Right GUI (0x231) which are Dynamic Flags (DV). */
/* Note: A general note on Usages and languages: Due to the variation of keyboards from language to language, it is not feasible to specify exact key mappings for every language. Where this list is not specific for a key function in a language, the closest equivalent key position should be used, so that a keyboard may be modified for a different language by simply printing different keycaps. One example is the Y key on a North American keyboard. In Germany this is typically Z. Rather than changing the keyboard firmware to put the Z Usage into that place in the descriptor list, the vendor should use the Y Usage on both the North American and German keyboards. This continues to be the existing practice in the industry, in order to minimize the number of changes to the electronics to accommodate otherlanguages. */
enum
{
    kHIDUsage_KeyboardErrorRollOver    = 0x01,    /* ErrorRollOver */
    kHIDUsage_KeyboardPOSTFail    = 0x02,    /* POSTFail */
    kHIDUsage_KeyboardErrorUndefined    = 0x03,    /* ErrorUndefined */
    kHIDUsage_KeyboardA    = 0x04,    /* a or A */
    kHIDUsage_KeyboardB    = 0x05,    /* b or B */
    kHIDUsage_KeyboardC    = 0x06,    /* c or C */
    kHIDUsage_KeyboardD    = 0x07,    /* d or D */
    kHIDUsage_KeyboardE    = 0x08,    /* e or E */
    kHIDUsage_KeyboardF    = 0x09,    /* f or F */
    kHIDUsage_KeyboardG    = 0x0A,    /* g or G */
    kHIDUsage_KeyboardH    = 0x0B,    /* h or H */
    kHIDUsage_KeyboardI    = 0x0C,    /* i or I */
    kHIDUsage_KeyboardJ    = 0x0D,    /* j or J */
    kHIDUsage_KeyboardK    = 0x0E,    /* k or K */
    kHIDUsage_KeyboardL    = 0x0F,    /* l or L */
    kHIDUsage_KeyboardM    = 0x10,    /* m or M */
    kHIDUsage_KeyboardN    = 0x11,    /* n or N */
    kHIDUsage_KeyboardO    = 0x12,    /* o or O */
    kHIDUsage_KeyboardP    = 0x13,    /* p or P */
    kHIDUsage_KeyboardQ    = 0x14,    /* q or Q */
    kHIDUsage_KeyboardR    = 0x15,    /* r or R */
    kHIDUsage_KeyboardS    = 0x16,    /* s or S */
    kHIDUsage_KeyboardT    = 0x17,    /* t or T */
    kHIDUsage_KeyboardU    = 0x18,    /* u or U */
    kHIDUsage_KeyboardV    = 0x19,    /* v or V */
    kHIDUsage_KeyboardW    = 0x1A,    /* w or W */
    kHIDUsage_KeyboardX    = 0x1B,    /* x or X */
    kHIDUsage_KeyboardY    = 0x1C,    /* y or Y */
    kHIDUsage_KeyboardZ    = 0x1D,    /* z or Z */
    kHIDUsage_Keyboard1    = 0x1E,    /* 1 or ! */
    kHIDUsage_Keyboard2    = 0x1F,    /* 2 or @ */
    kHIDUsage_Keyboard3    = 0x20,    /* 3 or # */
    kHIDUsage_Keyboard4    = 0x21,    /* 4 or $ */
    kHIDUsage_Keyboard5    = 0x22,    /* 5 or % */
    kHIDUsage_Keyboard6    = 0x23,    /* 6 or ^ */
    kHIDUsage_Keyboard7    = 0x24,    /* 7 or & */
    kHIDUsage_Keyboard8    = 0x25,    /* 8 or * */
    kHIDUsage_Keyboard9    = 0x26,    /* 9 or ( */
    kHIDUsage_Keyboard0    = 0x27,    /* 0 or ) */
    kHIDUsage_KeyboardReturnOrEnter    = 0x28,    /* Return (Enter) */
    kHIDUsage_KeyboardEscape    = 0x29,    /* Escape */
    kHIDUsage_KeyboardDeleteOrBackspace    = 0x2A,    /* Delete (Backspace) */
    kHIDUsage_KeyboardTab    = 0x2B,    /* Tab */
    kHIDUsage_KeyboardSpacebar    = 0x2C,    /* Spacebar */
    kHIDUsage_KeyboardHyphen    = 0x2D,    /* - or _ */
    kHIDUsage_KeyboardEqualSign    = 0x2E,    /* = or + */
    kHIDUsage_KeyboardOpenBracket    = 0x2F,    /* [ or { */
    kHIDUsage_KeyboardCloseBracket    = 0x30,    /* ] or } */
    kHIDUsage_KeyboardBackslash    = 0x31,    /* \ or | */
    kHIDUsage_KeyboardNonUSPound    = 0x32,    /* Non-US # or _ */
    kHIDUsage_KeyboardSemicolon    = 0x33,    /* ; or : */
    kHIDUsage_KeyboardQuote    = 0x34,    /* ' or " */
    kHIDUsage_KeyboardGraveAccentAndTilde    = 0x35,    /* Grave Accent and Tilde */
    kHIDUsage_KeyboardComma    = 0x36,    /* , or < */
    kHIDUsage_KeyboardPeriod    = 0x37,    /* . or > */
    kHIDUsage_KeyboardSlash    = 0x38,    /* / or ? */
    kHIDUsage_KeyboardCapsLock    = 0x39,    /* Caps Lock */
    kHIDUsage_KeyboardF1    = 0x3A,    /* F1 */
    kHIDUsage_KeyboardF2    = 0x3B,    /* F2 */
    kHIDUsage_KeyboardF3    = 0x3C,    /* F3 */
    kHIDUsage_KeyboardF4    = 0x3D,    /* F4 */
    kHIDUsage_KeyboardF5    = 0x3E,    /* F5 */
    kHIDUsage_KeyboardF6    = 0x3F,    /* F6 */
    kHIDUsage_KeyboardF7    = 0x40,    /* F7 */
    kHIDUsage_KeyboardF8    = 0x41,    /* F8 */
    kHIDUsage_KeyboardF9    = 0x42,    /* F9 */
    kHIDUsage_KeyboardF10    = 0x43,    /* F10 */
    kHIDUsage_KeyboardF11    = 0x44,    /* F11 */
    kHIDUsage_KeyboardF12    = 0x45,    /* F12 */
    kHIDUsage_KeyboardPrintScreen    = 0x46,    /* Print Screen */
    kHIDUsage_KeyboardScrollLock    = 0x47,    /* Scroll Lock */
    kHIDUsage_KeyboardPause    = 0x48,    /* Pause */
    kHIDUsage_KeyboardInsert    = 0x49,    /* Insert */
    kHIDUsage_KeyboardHome    = 0x4A,    /* Home */
    kHIDUsage_KeyboardPageUp    = 0x4B,    /* Page Up */
    kHIDUsage_KeyboardDeleteForward    = 0x4C,    /* Delete Forward */
    kHIDUsage_KeyboardEnd    = 0x4D,    /* End */
    kHIDUsage_KeyboardPageDown    = 0x4E,    /* Page Down */
    kHIDUsage_KeyboardRightArrow    = 0x4F,    /* Right Arrow */
    kHIDUsage_KeyboardLeftArrow    = 0x50,    /* Left Arrow */
    kHIDUsage_KeyboardDownArrow    = 0x51,    /* Down Arrow */
    kHIDUsage_KeyboardUpArrow    = 0x52,    /* Up Arrow */
    kHIDUsage_KeypadNumLock    = 0x53,    /* Keypad NumLock or Clear */
    kHIDUsage_KeypadSlash    = 0x54,    /* Keypad / */
    kHIDUsage_KeypadAsterisk    = 0x55,    /* Keypad * */
    kHIDUsage_KeypadHyphen    = 0x56,    /* Keypad - */
    kHIDUsage_KeypadPlus    = 0x57,    /* Keypad + */
    kHIDUsage_KeypadEnter    = 0x58,    /* Keypad Enter */
    kHIDUsage_Keypad1    = 0x59,    /* Keypad 1 or End */
    kHIDUsage_Keypad2    = 0x5A,    /* Keypad 2 or Down Arrow */
    kHIDUsage_Keypad3    = 0x5B,    /* Keypad 3 or Page Down */
    kHIDUsage_Keypad4    = 0x5C,    /* Keypad 4 or Left Arrow */
    kHIDUsage_Keypad5    = 0x5D,    /* Keypad 5 */
    kHIDUsage_Keypad6    = 0x5E,    /* Keypad 6 or Right Arrow */
    kHIDUsage_Keypad7    = 0x5F,    /* Keypad 7 or Home */
    kHIDUsage_Keypad8    = 0x60,    /* Keypad 8 or Up Arrow */
    kHIDUsage_Keypad9    = 0x61,    /* Keypad 9 or Page Up */
    kHIDUsage_Keypad0    = 0x62,    /* Keypad 0 or Insert */
    kHIDUsage_KeypadPeriod    = 0x63,    /* Keypad . or Delete */
    kHIDUsage_KeyboardNonUSBackslash    = 0x64,    /* Non-US \ or | */
    kHIDUsage_KeyboardApplication    = 0x65,    /* Application */
    kHIDUsage_KeyboardPower    = 0x66,    /* Power */
    kHIDUsage_KeypadEqualSign    = 0x67,    /* Keypad = */
    kHIDUsage_KeyboardF13    = 0x68,    /* F13 */
    kHIDUsage_KeyboardF14    = 0x69,    /* F14 */
    kHIDUsage_KeyboardF15    = 0x6A,    /* F15 */
    kHIDUsage_KeyboardF16    = 0x6B,    /* F16 */
    kHIDUsage_KeyboardF17    = 0x6C,    /* F17 */
    kHIDUsage_KeyboardF18    = 0x6D,    /* F18 */
    kHIDUsage_KeyboardF19    = 0x6E,    /* F19 */
    kHIDUsage_KeyboardF20    = 0x6F,    /* F20 */
    kHIDUsage_KeyboardF21    = 0x70,    /* F21 */
    kHIDUsage_KeyboardF22    = 0x71,    /* F22 */
    kHIDUsage_KeyboardF23    = 0x72,    /* F23 */
    kHIDUsage_KeyboardF24    = 0x73,    /* F24 */
    kHIDUsage_KeyboardExecute    = 0x74,    /* Execute */
    kHIDUsage_KeyboardHelp    = 0x75,    /* Help */
    kHIDUsage_KeyboardMenu    = 0x76,    /* Menu */
    kHIDUsage_KeyboardSelect    = 0x77,    /* Select */
    kHIDUsage_KeyboardStop    = 0x78,    /* Stop */
    kHIDUsage_KeyboardAgain    = 0x79,    /* Again */
    kHIDUsage_KeyboardUndo    = 0x7A,    /* Undo */
    kHIDUsage_KeyboardCut    = 0x7B,    /* Cut */
    kHIDUsage_KeyboardCopy    = 0x7C,    /* Copy */
    kHIDUsage_KeyboardPaste    = 0x7D,    /* Paste */
    kHIDUsage_KeyboardFind    = 0x7E,    /* Find */
    kHIDUsage_KeyboardMute    = 0x7F,    /* Mute */
    kHIDUsage_KeyboardVolumeUp    = 0x80,    /* Volume Up */
    kHIDUsage_KeyboardVolumeDown    = 0x81,    /* Volume Down */
    kHIDUsage_KeyboardLockingCapsLock    = 0x82,    /* Locking Caps Lock */
    kHIDUsage_KeyboardLockingNumLock    = 0x83,    /* Locking Num Lock */
    kHIDUsage_KeyboardLockingScrollLock    = 0x84,    /* Locking Scroll Lock */
    kHIDUsage_KeypadComma    = 0x85,    /* Keypad Comma */
    kHIDUsage_KeypadEqualSignAS400    = 0x86,    /* Keypad Equal Sign for AS/400 */
    kHIDUsage_KeyboardInternational1    = 0x87,    /* International1 */
    kHIDUsage_KeyboardInternational2    = 0x88,    /* International2 */
    kHIDUsage_KeyboardInternational3    = 0x89,    /* International3 */
    kHIDUsage_KeyboardInternational4    = 0x8A,    /* International4 */
    kHIDUsage_KeyboardInternational5    = 0x8B,    /* International5 */
    kHIDUsage_KeyboardInternational6    = 0x8C,    /* International6 */
    kHIDUsage_KeyboardInternational7    = 0x8D,    /* International7 */
    kHIDUsage_KeyboardInternational8    = 0x8E,    /* International8 */
    kHIDUsage_KeyboardInternational9    = 0x8F,    /* International9 */
    kHIDUsage_KeyboardLANG1    = 0x90,    /* LANG1 */
    kHIDUsage_KeyboardLANG2    = 0x91,    /* LANG2 */
    kHIDUsage_KeyboardLANG3    = 0x92,    /* LANG3 */
    kHIDUsage_KeyboardLANG4    = 0x93,    /* LANG4 */
    kHIDUsage_KeyboardLANG5    = 0x94,    /* LANG5 */
    kHIDUsage_KeyboardLANG6    = 0x95,    /* LANG6 */
    kHIDUsage_KeyboardLANG7    = 0x96,    /* LANG7 */
    kHIDUsage_KeyboardLANG8    = 0x97,    /* LANG8 */
    kHIDUsage_KeyboardLANG9    = 0x98,    /* LANG9 */
    kHIDUsage_KeyboardAlternateErase    = 0x99,    /* AlternateErase */
    kHIDUsage_KeyboardSysReqOrAttention    = 0x9A,    /* SysReq/Attention */
    kHIDUsage_KeyboardCancel    = 0x9B,    /* Cancel */
    kHIDUsage_KeyboardClear    = 0x9C,    /* Clear */
    kHIDUsage_KeyboardPrior    = 0x9D,    /* Prior */
    kHIDUsage_KeyboardReturn    = 0x9E,    /* Return */
    kHIDUsage_KeyboardSeparator    = 0x9F,    /* Separator */
    kHIDUsage_KeyboardOut    = 0xA0,    /* Out */
    kHIDUsage_KeyboardOper    = 0xA1,    /* Oper */
    kHIDUsage_KeyboardClearOrAgain    = 0xA2,    /* Clear/Again */
    kHIDUsage_KeyboardCrSelOrProps    = 0xA3,    /* CrSel/Props */
    kHIDUsage_KeyboardExSel    = 0xA4,    /* ExSel */
    /* 0xA5-0xDF Reserved */
    kHIDUsage_KeyboardLeftControl    = 0xE0,    /* Left Control */
    kHIDUsage_KeyboardLeftShift    = 0xE1,    /* Left Shift */
    kHIDUsage_KeyboardLeftAlt    = 0xE2,    /* Left Alt */
    kHIDUsage_KeyboardLeftGUI    = 0xE3,    /* Left GUI */
    kHIDUsage_KeyboardRightControl    = 0xE4,    /* Right Control */
    kHIDUsage_KeyboardRightShift    = 0xE5,    /* Right Shift */
    kHIDUsage_KeyboardRightAlt    = 0xE6,    /* Right Alt */
    kHIDUsage_KeyboardRightGUI    = 0xE7,    /* Right GUI */
    /* 0xE8-0xFFFF Reserved */
    kHIDUsage_Keyboard_Reserved = 0xFFFF
};

/* LEDs Page (0x08) */
/* An LED or indicator is implemented as an On/Off Control (OOF) using the Single button toggle mode, where a value of 1 will turn on the indicator, and a value of 0 will turn it off. The exceptions are described below. */
enum
{
    kHIDUsage_LED_NumLock    = 0x01,    /* On/Off Control */
    kHIDUsage_LED_CapsLock    = 0x02,    /* On/Off Control */
    kHIDUsage_LED_ScrollLock    = 0x03,    /* On/Off Control */
    kHIDUsage_LED_Compose    = 0x04,    /* On/Off Control */
    kHIDUsage_LED_Kana    = 0x05,    /* On/Off Control */
    kHIDUsage_LED_Power    = 0x06,    /* On/Off Control */
    kHIDUsage_LED_Shift    = 0x07,    /* On/Off Control */
    kHIDUsage_LED_DoNotDisturb    = 0x08,    /* On/Off Control */
    kHIDUsage_LED_Mute    = 0x09,    /* On/Off Control */
    kHIDUsage_LED_ToneEnable    = 0x0A,    /* On/Off Control */
    kHIDUsage_LED_HighCutFilter    = 0x0B,    /* On/Off Control */
    kHIDUsage_LED_LowCutFilter    = 0x0C,    /* On/Off Control */
    kHIDUsage_LED_EqualizerEnable    = 0x0D,    /* On/Off Control */
    kHIDUsage_LED_SoundFieldOn    = 0x0E,    /* On/Off Control */
    kHIDUsage_LED_SurroundOn    = 0x0F,    /* On/Off Control */
    kHIDUsage_LED_Repeat    = 0x10,    /* On/Off Control */
    kHIDUsage_LED_Stereo    = 0x11,    /* On/Off Control */
    kHIDUsage_LED_SamplingRateDetect    = 0x12,    /* On/Off Control */
    kHIDUsage_LED_Spinning    = 0x13,    /* On/Off Control */
    kHIDUsage_LED_CAV    = 0x14,    /* On/Off Control */
    kHIDUsage_LED_CLV    = 0x15,    /* On/Off Control */
    kHIDUsage_LED_RecordingFormatDetect    = 0x16,    /* On/Off Control */
    kHIDUsage_LED_OffHook    = 0x17,    /* On/Off Control */
    kHIDUsage_LED_Ring    = 0x18,    /* On/Off Control */
    kHIDUsage_LED_MessageWaiting    = 0x19,    /* On/Off Control */
    kHIDUsage_LED_DataMode    = 0x1A,    /* On/Off Control */
    kHIDUsage_LED_BatteryOperation    = 0x1B,    /* On/Off Control */
    kHIDUsage_LED_BatteryOK    = 0x1C,    /* On/Off Control */
    kHIDUsage_LED_BatteryLow    = 0x1D,    /* On/Off Control */
    kHIDUsage_LED_Speaker    = 0x1E,    /* On/Off Control */
    kHIDUsage_LED_HeadSet    = 0x1F,    /* On/Off Control */
    kHIDUsage_LED_Hold    = 0x20,    /* On/Off Control */
    kHIDUsage_LED_Microphone    = 0x21,    /* On/Off Control */
    kHIDUsage_LED_Coverage    = 0x22,    /* On/Off Control */
    kHIDUsage_LED_NightMode    = 0x23,    /* On/Off Control */
    kHIDUsage_LED_SendCalls    = 0x24,    /* On/Off Control */
    kHIDUsage_LED_CallPickup    = 0x25,    /* On/Off Control */
    kHIDUsage_LED_Conference    = 0x26,    /* On/Off Control */
    kHIDUsage_LED_StandBy    = 0x27,    /* On/Off Control */
    kHIDUsage_LED_CameraOn    = 0x28,    /* On/Off Control */
    kHIDUsage_LED_CameraOff    = 0x29,    /* On/Off Control */
    kHIDUsage_LED_OnLine    = 0x2A,    /* On/Off Control */
    kHIDUsage_LED_OffLine    = 0x2B,    /* On/Off Control */
    kHIDUsage_LED_Busy    = 0x2C,    /* On/Off Control */
    kHIDUsage_LED_Ready    = 0x2D,    /* On/Off Control */
    kHIDUsage_LED_PaperOut    = 0x2E,    /* On/Off Control */
    kHIDUsage_LED_PaperJam    = 0x2F,    /* On/Off Control */
    kHIDUsage_LED_Remote    = 0x30,    /* On/Off Control */
    kHIDUsage_LED_Forward    = 0x31,    /* On/Off Control */
    kHIDUsage_LED_Reverse    = 0x32,    /* On/Off Control */
    kHIDUsage_LED_Stop    = 0x33,    /* On/Off Control */
    kHIDUsage_LED_Rewind    = 0x34,    /* On/Off Control */
    kHIDUsage_LED_FastForward    = 0x35,    /* On/Off Control */
    kHIDUsage_LED_Play    = 0x36,    /* On/Off Control */
    kHIDUsage_LED_Pause    = 0x37,    /* On/Off Control */
    kHIDUsage_LED_Record    = 0x38,    /* On/Off Control */
    kHIDUsage_LED_Error    = 0x39,    /* On/Off Control */
    kHIDUsage_LED_Usage    = 0x3A,    /* Selector */
    kHIDUsage_LED_UsageInUseIndicator    = 0x3B,    /* Usage Switch */
    kHIDUsage_LED_UsageMultiModeIndicator    = 0x3C,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorOn    = 0x3D,    /* Selector */
    kHIDUsage_LED_IndicatorFlash    = 0x3E,    /* Selector */
    kHIDUsage_LED_IndicatorSlowBlink    = 0x3F,    /* Selector */
    kHIDUsage_LED_IndicatorFastBlink    = 0x40,    /* Selector */
    kHIDUsage_LED_IndicatorOff    = 0x41,    /* Selector */
    kHIDUsage_LED_FlashOnTime    = 0x42,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOnTime    = 0x43,    /* Dynamic Value */
    kHIDUsage_LED_SlowBlinkOffTime    = 0x44,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOnTime    = 0x45,    /* Dynamic Value */
    kHIDUsage_LED_FastBlinkOffTime    = 0x46,    /* Dynamic Value */
    kHIDUsage_LED_UsageIndicatorColor    = 0x47,    /* Usage Modifier */
    kHIDUsage_LED_IndicatorRed    = 0x48,    /* Selector */
    kHIDUsage_LED_IndicatorGreen    = 0x49,    /* Selector */
    kHIDUsage_LED_IndicatorAmber    = 0x4A,    /* Selector */
    kHIDUsage_LED_GenericIndicator    = 0x4B,    /* On/Off Control */
    kHIDUsage_LED_SystemSuspend    = 0x4C,    /* On/Off Control */
    kHIDUsage_LED_ExternalPowerConnected    = 0x4D,    /* On/Off Control */
    /* 0x4E - 0xFFFF Reserved */
    kHIDUsage_LED_Reserved = 0xFFFF
};

/* Button Page (0x09) */
/* The Button page is the first place an application should look for user selection controls. System graphical user interfaces typically employ a pointer and a set of hierarchical selectors to select, move and otherwise manipulate their environment. For these purposes the following assignment of significance can be applied to the Button usages: */
/*  Button 1, Primary Button. Used for object selecting, dragging, and double click activation. On MacOS, this is the only button. Microsoft operating systems call this a logical left button, because it */
/* is not necessarily physically located on the left of the pointing device. */
/*  Button 2, Secondary Button. Used by newer graphical user interfaces to browse object properties. Exposed by systems to applications that typically assign application-specific functionality. */
/*  Button 3, Tertiary Button. Optional control. Exposed to applications, but seldom assigned functionality due to prevalence of two- and one-button devices. */
/*  Buttons 4 -55. As the button number increases, its significance as a selector decreases. */
/* In many ways the assignment of button numbers is similar to the assignment of Effort in Physical descriptors. Button 1 would be used to define the button a finger rests on when the hand is in the at rest position, that is, virtually no effort is required by the user to activate the button. Button values increment as the finger has to stretch to reach a control. See Section 6.2.3, Physical Descriptors, in the HID Specification for methods of further qualifying buttons. */
enum
{
    kHIDUsage_Button_1    = 0x01,    /* (primary/trigger) */
    kHIDUsage_Button_2    = 0x02,    /* (secondary) */
    kHIDUsage_Button_3    = 0x03,    /* (tertiary) */
    kHIDUsage_Button_4    = 0x04, /* 4th button */
    /* ... */
    kHIDUsage_Button_65535    = 0xFFFF
};

/* Ordinal Page (0x0A) */
/* The Ordinal page allows multiple instances of a control or sets of controls to be declared without requiring individual enumeration in the native usage page. For example, it is not necessary to declare usages of Pointer 1, Pointer 2, and so forth on the Generic Desktop page. When parsed, the ordinal instance number is, in essence, concatenated to the usages attached to the encompassing collection to create Pointer 1, Pointer 2, and so forth. */
/* For an example, see Section A.5, Multiple Instances of a Control, in Appendix A, Usage Examples. By convention, an Ordinal collection is placed inside the collection for which it is declaring multiple instances. */
/* Instances do not have to be identical. */
enum
{
    /* 0x00 Reserved */
    kHIDUsage_Ord_Instance1    = 0x01,    /* Usage Modifier */
    kHIDUsage_Ord_Instance2    = 0x02,    /* Usage Modifier */
    kHIDUsage_Ord_Instance3    = 0x03,    /* Usage Modifier */
    kHIDUsage_Ord_Instance4    = 0x04,    /* Usage Modifier */
    kHIDUsage_Ord_Instance65535    = 0xFFFF    /* Usage Modifier */
};

/* Telephony Page (0x0B) */
/* This usage page defines the keytop and control usages for telephony devices. */
/* Indicators on a phone are handled by wrapping them in LED: Usage In Use Indicator and LED: Usage Selected Indicator usages. For example, a message-indicator LED would be identified by a Telephony: Message usage declared as a Feature or Output in a LED: Usage In Use Indicator collection. */
/* See Section 14, Consumer Page (0x0C), for audio volume and tone controls. */
enum
{
    kHIDUsage_Tfon_Phone    = 0x01,    /* Application Collection */
    kHIDUsage_Tfon_AnsweringMachine    = 0x02,    /* Application Collection */
    kHIDUsage_Tfon_MessageControls    = 0x03,    /* Logical Collection */
    kHIDUsage_Tfon_Handset    = 0x04,    /* Logical Collection */
    kHIDUsage_Tfon_Headset    = 0x05,    /* Logical Collection */
    kHIDUsage_Tfon_TelephonyKeyPad    = 0x06,    /* Named Array */
    kHIDUsage_Tfon_ProgrammableButton    = 0x07,    /* Named Array */
    /* 0x08 - 0x1F Reserved */
    kHIDUsage_Tfon_HookSwitch    = 0x20,    /* On/Off Control */
    kHIDUsage_Tfon_Flash    = 0x21,    /* Momentary Control */
    kHIDUsage_Tfon_Feature    = 0x22,    /* One-Shot Control */
    kHIDUsage_Tfon_Hold    = 0x23,    /* On/Off Control */
    kHIDUsage_Tfon_Redial    = 0x24,    /* One-Shot Control */
    kHIDUsage_Tfon_Transfer    = 0x25,    /* One-Shot Control */
    kHIDUsage_Tfon_Drop    = 0x26,    /* One-Shot Control */
    kHIDUsage_Tfon_Park    = 0x27,    /* On/Off Control */
    kHIDUsage_Tfon_ForwardCalls    = 0x28,    /* On/Off Control */
    kHIDUsage_Tfon_AlternateFunction    = 0x29,    /* Momentary Control */
    kHIDUsage_Tfon_Line    = 0x2A,    /* One-Shot Control */
    kHIDUsage_Tfon_SpeakerPhone    = 0x2B,    /* On/Off Control */
    kHIDUsage_Tfon_Conference    = 0x2C,    /* On/Off Control */
    kHIDUsage_Tfon_RingEnable    = 0x2D,    /* On/Off Control */
    kHIDUsage_Tfon_Ring    = 0x2E,    /* Selector */
    kHIDUsage_Tfon_PhoneMute    = 0x2F,    /* On/Off Control */
    kHIDUsage_Tfon_CallerID    = 0x30,    /* Momentary Control */
    /* 0x31 - 0x4F Reserved */
    kHIDUsage_Tfon_SpeedDial    = 0x50,    /* One-Shot Control */
    kHIDUsage_Tfon_StoreNumber    = 0x51,    /* One-Shot Control */
    kHIDUsage_Tfon_RecallNumber    = 0x52,    /* One-Shot Control */
    kHIDUsage_Tfon_PhoneDirectory    = 0x53,    /* On/Off Control */
    /* 0x54 - 0x6F Reserved */
    kHIDUsage_Tfon_VoiceMail    = 0x70,    /* On/Off Control */
    kHIDUsage_Tfon_ScreenCalls    = 0x71,    /* On/Off Control */
    kHIDUsage_Tfon_DoNotDisturb    = 0x72,    /* On/Off Control */
    kHIDUsage_Tfon_Message    = 0x73,    /* One-Shot Control */
    kHIDUsage_Tfon_AnswerOnOrOff    = 0x74,    /* On/Off Control */
    /* 0x75 - 0x8F Reserved */
    kHIDUsage_Tfon_InsideDialTone    = 0x90,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideDialTone    = 0x91,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingTone    = 0x92,    /* Momentary Control */
    kHIDUsage_Tfon_OutsideRingTone    = 0x93,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingTone    = 0x94,    /* Momentary Control */
    kHIDUsage_Tfon_InsideRingback    = 0x95,    /* Momentary Control */
    kHIDUsage_Tfon_PriorityRingback    = 0x96,    /* Momentary Control */
    kHIDUsage_Tfon_LineBusyTone    = 0x97,    /* Momentary Control */
    kHIDUsage_Tfon_ReorderTone    = 0x98,    /* Momentary Control */
    kHIDUsage_Tfon_CallWaitingTone    = 0x99,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone1    = 0x9A,    /* Momentary Control */
    kHIDUsage_Tfon_ConfirmationTone2    = 0x9B,    /* Momentary Control */
    kHIDUsage_Tfon_TonesOff    = 0x9C,    /* On/Off Control */
    kHIDUsage_Tfon_OutsideRingback    = 0x9D,    /* Momentary Control */
    /* 0x9E - 0xAF Reserved */
    kHIDUsage_Tfon_PhoneKey0    = 0xB0,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey1    = 0xB1,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey2    = 0xB2,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey3    = 0xB3,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey4    = 0xB4,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey5    = 0xB5,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey6    = 0xB6,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey7    = 0xB7,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey8    = 0xB8,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKey9    = 0xB9,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyStar    = 0xBA,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyPound    = 0xBB,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyA    = 0xBC,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyB    = 0xBD,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyC    = 0xBE,    /* Selector/One-Shot Control */
    kHIDUsage_Tfon_PhoneKeyD    = 0xBF,    /* Selector/One-Shot Control */
    /* 0xC0 - 0xFFFF Reserved */
    kHIDUsage_TFon_Reserved = 0xFFFF
};

/* Consumer Page (0x0C) */
/* All controls on the Consumer page are application-specific. That is, they affect a specific device, not the system as a whole. */
enum
{
    kHIDUsage_Csmr_ConsumerControl    = 0x01,    /* Application Collection */
    kHIDUsage_Csmr_NumericKeyPad    = 0x02,    /* Named Array */
    kHIDUsage_Csmr_ProgrammableButtons    = 0x03,    /* Named Array */
    kHIDUsage_Csmr_Microphone   = 0x04,    /* Application Collection */
    kHIDUsage_Csmr_Headphone   = 0x05,    /* Application Collection */
    kHIDUsage_Csmr_GraphicEqualizer   = 0x06,    /* Application Collection */
    /* 0x07 - 0x1F Reserved */
    kHIDUsage_Csmr_Plus10    = 0x20,    /* One-Shot Control */
    kHIDUsage_Csmr_Plus100    = 0x21,    /* One-Shot Control */
    kHIDUsage_Csmr_AMOrPM    = 0x22,    /* One-Shot Control */
    /* 0x23 - 0x3F Reserved */
    kHIDUsage_Csmr_Power    = 0x30,    /* On/Off Control */
    kHIDUsage_Csmr_Reset    = 0x31,    /* One-Shot Control */
    kHIDUsage_Csmr_Sleep    = 0x32,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepAfter    = 0x33,    /* One-Shot Control */
    kHIDUsage_Csmr_SleepMode    = 0x34,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Illumination    = 0x35,    /* On/Off Control */
    kHIDUsage_Csmr_FunctionButtons    = 0x36,    /* Named Array */
    /* 0x37 - 0x3F Reserved */
    kHIDUsage_Csmr_Menu    = 0x40,    /* On/Off Control */
    kHIDUsage_Csmr_MenuPick    = 0x41,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuUp    = 0x42,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuDown    = 0x43,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuLeft    = 0x44,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuRight    = 0x45,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuEscape    = 0x46,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueIncrease    = 0x47,    /* One-Shot Control */
    kHIDUsage_Csmr_MenuValueDecrease    = 0x48,    /* One-Shot Control */
    /* 0x49 - 0x5F Reserved */
    kHIDUsage_Csmr_DataOnScreen    = 0x60,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaption    = 0x61,    /* On/Off Control */
    kHIDUsage_Csmr_ClosedCaptionSelect    = 0x62,    /* Selector */
    kHIDUsage_Csmr_VCROrTV    = 0x63,    /* On/Off Control */
    kHIDUsage_Csmr_BroadcastMode    = 0x64,    /* One-Shot Control */
    kHIDUsage_Csmr_Snapshot    = 0x65,    /* One-Shot Control */
    kHIDUsage_Csmr_Still    = 0x66,    /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureToggle = 0x67, /* One-Shot Control */
    kHIDUsage_Csmr_PictureInPictureSwap = 0x68, /* One-Shot Control */
    kHIDUsage_Csmr_RedMenuButton = 0x69, /* Momentary Control */
    kHIDUsage_Csmr_GreenMenuButton = 0x6A, /* Momentary Control */
    kHIDUsage_Csmr_BlueMenuButton = 0x6B, /* Momentary Control */
    kHIDUsage_Csmr_YellowMenuButton = 0x6C, /* Momentary Control */
    kHIDUsage_Csmr_Aspect = 0x6D, /* One-shot Control */
    kHIDUsage_Csmr_3DModeSelect = 0x6E, /* One-shot Control */
    kHIDUsage_Csmr_DisplayBrightnessIncrement = 0x6F, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightnessDecrement = 0x70, /* Re-Trigger Control */
    kHIDUsage_Csmr_DisplayBrightness = 0x71, /* Logical Collection */
    kHIDUsage_Csmr_DisplayBacklightToggle = 0x72, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMinimum = 0x73, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessMaximum = 0x74, /* One Shot Control */
    kHIDUsage_Csmr_DisplayBrightnessSetAutoBrightness = 0x75, /* On Off Control */
    /* 0x76 - 0x7F Reserved */
    kHIDUsage_Csmr_Selection    = 0x80,    /* Named Array */
    kHIDUsage_Csmr_Assign    = 0x81,    /* Selector */
    kHIDUsage_Csmr_ModeStep    = 0x82,    /* One-Shot Control */
    kHIDUsage_Csmr_RecallLast    = 0x83,    /* One-Shot Control */
    kHIDUsage_Csmr_EnterChannel    = 0x84,    /* One-Shot Control */
    kHIDUsage_Csmr_OrderMovie    = 0x85,    /* One-Shot Control */
    kHIDUsage_Csmr_Channel    = 0x86,    /* Linear Control */
    kHIDUsage_Csmr_MediaSelection    = 0x87,    /* Selector */
    kHIDUsage_Csmr_MediaSelectComputer    = 0x88,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTV    = 0x89,    /* Selector */
    kHIDUsage_Csmr_MediaSelectWWW    = 0x8A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectDVD    = 0x8B,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTelephone    = 0x8C,    /* Selector */
    kHIDUsage_Csmr_MediaSelectProgramGuide    = 0x8D,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVideoPhone    = 0x8E,    /* Selector */
    kHIDUsage_Csmr_MediaSelectGames    = 0x8F,    /* Selector */
    kHIDUsage_Csmr_MediaSelectMessages    = 0x90,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCD    = 0x91,    /* Selector */
    kHIDUsage_Csmr_MediaSelectVCR    = 0x92,    /* Selector */
    kHIDUsage_Csmr_MediaSelectTuner    = 0x93,    /* Selector */
    kHIDUsage_Csmr_Quit    = 0x94,    /* One-Shot Control */
    kHIDUsage_Csmr_Help    = 0x95,    /* On/Off Control */
    kHIDUsage_Csmr_MediaSelectTape    = 0x96,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCable    = 0x97,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSatellite    = 0x98,    /* Selector */
    kHIDUsage_Csmr_MediaSelectSecurity    = 0x99,    /* Selector */
    kHIDUsage_Csmr_MediaSelectHome    = 0x9A,    /* Selector */
    kHIDUsage_Csmr_MediaSelectCall    = 0x9B,    /* Selector */
    kHIDUsage_Csmr_ChannelIncrement    = 0x9C,    /* One-Shot Control */
    kHIDUsage_Csmr_ChannelDecrement    = 0x9D,    /* One-Shot Control */
    kHIDUsage_Csmr_Media    = 0x9E,    /* Selector */
    /* 0x9F Reserved */
    kHIDUsage_Csmr_VCRPlus    = 0xA0,    /* One-Shot Control */
    kHIDUsage_Csmr_Once    = 0xA1,    /* One-Shot Control */
    kHIDUsage_Csmr_Daily    = 0xA2,    /* One-Shot Control */
    kHIDUsage_Csmr_Weekly    = 0xA3,    /* One-Shot Control */
    kHIDUsage_Csmr_Monthly    = 0xA4,    /* One-Shot Control */
    /* 0xA5 - 0xAF Reserved */
    kHIDUsage_Csmr_Play    = 0xB0,    /* On/Off Control */
    kHIDUsage_Csmr_Pause    = 0xB1,    /* On/Off Control */
    kHIDUsage_Csmr_Record    = 0xB2,    /* On/Off Control */
    kHIDUsage_Csmr_FastForward    = 0xB3,    /* On/Off Control */
    kHIDUsage_Csmr_Rewind    = 0xB4,    /* On/Off Control */
    kHIDUsage_Csmr_ScanNextTrack    = 0xB5,    /* One-Shot Control */
    kHIDUsage_Csmr_ScanPreviousTrack    = 0xB6,    /* One-Shot Control */
    kHIDUsage_Csmr_Stop    = 0xB7,    /* One-Shot Control */
    kHIDUsage_Csmr_Eject    = 0xB8,    /* One-Shot Control */
    kHIDUsage_Csmr_RandomPlay    = 0xB9,    /* On/Off Control */
    kHIDUsage_Csmr_SelectDisc    = 0xBA,    /* Named Array */
    kHIDUsage_Csmr_EnterDisc    = 0xBB,    /* Momentary Control */
    kHIDUsage_Csmr_Repeat    = 0xBC,    /* One-Shot Control */
    kHIDUsage_Csmr_Tracking    = 0xBD,    /* Linear Control */
    kHIDUsage_Csmr_TrackNormal    = 0xBE,    /* One-Shot Control */
    kHIDUsage_Csmr_SlowTracking    = 0xBF,    /* Linear Control */
    kHIDUsage_Csmr_FrameForward    = 0xC0,    /* Re-Trigger Control */
    kHIDUsage_Csmr_FrameBack    = 0xC1,    /* Re-Trigger Control */
    kHIDUsage_Csmr_Mark    = 0xC2,    /* One-Shot Control */
    kHIDUsage_Csmr_ClearMark    = 0xC3,    /* One-Shot Control */
    kHIDUsage_Csmr_RepeatFromMark    = 0xC4,    /* On/Off Control */
    kHIDUsage_Csmr_ReturnToMark    = 0xC5,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkForward    = 0xC6,    /* One-Shot Control */
    kHIDUsage_Csmr_SearchMarkBackwards    = 0xC7,    /* One-Shot Control */
    kHIDUsage_Csmr_CounterReset    = 0xC8,    /* One-Shot Control */
    kHIDUsage_Csmr_ShowCounter    = 0xC9,    /* One-Shot Control */
    kHIDUsage_Csmr_TrackingIncrement    = 0xCA,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrackingDecrement    = 0xCB,    /* Re-Trigger Control */
    kHIDUsage_Csmr_StopOrEject    = 0xCC,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrPause    = 0xCD,    /* One-Shot Control */
    kHIDUsage_Csmr_PlayOrSkip    = 0xCE,    /* One-Shot Control */
    kHIDUsage_Csmr_VoiceCommand    = 0xCF, /* One-Shot Control */
    /* 0xCF - 0xDF Reserved */
    kHIDUsage_Csmr_Volume    = 0xE0,    /* Linear Control */
    kHIDUsage_Csmr_Balance    = 0xE1,    /* Linear Control */
    kHIDUsage_Csmr_Mute    = 0xE2,    /* On/Off Control */
    kHIDUsage_Csmr_Bass    = 0xE3,    /* Linear Control */
    kHIDUsage_Csmr_Treble    = 0xE4,    /* Linear Control */
    kHIDUsage_Csmr_BassBoost    = 0xE5,    /* On/Off Control */
    kHIDUsage_Csmr_SurroundMode    = 0xE6,    /* One-Shot Control */
    kHIDUsage_Csmr_Loudness    = 0xE7,    /* On/Off Control */
    kHIDUsage_Csmr_MPX    = 0xE8,    /* On/Off Control */
    kHIDUsage_Csmr_VolumeIncrement    = 0xE9,    /* Re-Trigger Control */
    kHIDUsage_Csmr_VolumeDecrement    = 0xEA,    /* Re-Trigger Control */
    /* 0xEB - 0xEF Reserved */
    kHIDUsage_Csmr_Speed    = 0xF0,    /* Selector */
    kHIDUsage_Csmr_PlaybackSpeed    = 0xF1,    /* Named Array */
    kHIDUsage_Csmr_StandardPlay    = 0xF2,    /* Selector */
    kHIDUsage_Csmr_LongPlay    = 0xF3,    /* Selector */
    kHIDUsage_Csmr_ExtendedPlay    = 0xF4,    /* Selector */
    kHIDUsage_Csmr_Slow    = 0xF5,    /* One-Shot Control */
    /* 0xF6 - 0xFF Reserved */
    kHIDUsage_Csmr_FanEnable    = 0x100,    /* On/Off Control */
    kHIDUsage_Csmr_FanSpeed    = 0x101,    /* Linear Control */
    kHIDUsage_Csmr_LightEnable    = 0x102,    /* On/Off Control */
    kHIDUsage_Csmr_LightIlluminationLevel    = 0x103,    /* Linear Control */
    kHIDUsage_Csmr_ClimateControlEnable    = 0x104,    /* On/Off Control */
    kHIDUsage_Csmr_RoomTemperature    = 0x105,    /* Linear Control */
    kHIDUsage_Csmr_SecurityEnable    = 0x106,    /* On/Off Control */
    kHIDUsage_Csmr_FireAlarm    = 0x107,    /* One-Shot Control */
    kHIDUsage_Csmr_PoliceAlarm    = 0x108,    /* One-Shot Control */
    kHIDUsage_Csmr_Proximity    = 0x109,    /* Linear Control */
    kHIDUsage_Csmr_Motion    = 0x10A,    /* One-Shot Control */
    kHIDUsage_Csmr_DuressAlarm    = 0x10B,    /* One-Shot Control */
    kHIDUsage_Csmr_HoldupAlarm    = 0x10C,    /* One-Shot Control */
    kHIDUsage_Csmr_MedicalAlarm    = 0x10D,    /* One-Shot Control */
    /* 0x10E - 0x14F Reserved */
    kHIDUsage_Csmr_BalanceRight    = 0x150,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BalanceLeft    = 0x151,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassIncrement    = 0x152,    /* Re-Trigger Control */
    kHIDUsage_Csmr_BassDecrement    = 0x153,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleIncrement    = 0x154,    /* Re-Trigger Control */
    kHIDUsage_Csmr_TrebleDecrement    = 0x155,    /* Re-Trigger Control */
    /* 0x156 - 0x15F Reserved */
    kHIDUsage_Csmr_SpeakerSystem    = 0x160,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLeft    = 0x161,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelRight    = 0x162,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenter    = 0x163,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelFront    = 0x164,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelCenterFront    = 0x165,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSide    = 0x166,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelSurround    = 0x167,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelLowFrequencyEnhancement    = 0x168,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelTop    = 0x169,    /* Logical Collection */
    kHIDUsage_Csmr_ChannelUnknown    = 0x16A,    /* Logical Collection */
    /* 0x16B - 0x16F Reserved */
    kHIDUsage_Csmr_SubChannel    = 0x170,    /* Linear Control */
    kHIDUsage_Csmr_SubChannelIncrement    = 0x171,    /* One-Shot Control */
    kHIDUsage_Csmr_SubChannelDecrement    = 0x172,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioIncrement    = 0x173,    /* One-Shot Control */
    kHIDUsage_Csmr_AlternateAudioDecrement    = 0x174,    /* One-Shot Control */
    /* 0x175 - 0x17F Reserved */
    kHIDUsage_Csmr_ApplicationLaunchButtons    = 0x180,    /* Named Array */
    kHIDUsage_Csmr_ALLaunchButtonConfigurationTool    = 0x181,    /* Selector */
    kHIDUsage_Csmr_ALProgrammableButtonConfiguration    = 0x182,    /* Selector */
    kHIDUsage_Csmr_ALConsumerControlConfiguration    = 0x183,    /* Selector */
    kHIDUsage_Csmr_ALWordProcessor    = 0x184,    /* Selector */
    kHIDUsage_Csmr_ALTextEditor    = 0x185,    /* Selector */
    kHIDUsage_Csmr_ALSpreadsheet    = 0x186,    /* Selector */
    kHIDUsage_Csmr_ALGraphicsEditor    = 0x187,    /* Selector */
    kHIDUsage_Csmr_ALPresentationApp    = 0x188,    /* Selector */
    kHIDUsage_Csmr_ALDatabaseApp    = 0x189,    /* Selector */
    kHIDUsage_Csmr_ALEmailReader    = 0x18A,    /* Selector */
    kHIDUsage_Csmr_ALNewsreader    = 0x18B,    /* Selector */
    kHIDUsage_Csmr_ALVoicemail    = 0x18C,    /* Selector */
    kHIDUsage_Csmr_ALContactsOrAddressBook    = 0x18D,    /* Selector */
    kHIDUsage_Csmr_ALCalendarOrSchedule    = 0x18E,    /* Selector */
    kHIDUsage_Csmr_ALTaskOrProjectManager    = 0x18F,    /* Selector */
    kHIDUsage_Csmr_ALLogOrJournalOrTimecard    = 0x190,    /* Selector */
    kHIDUsage_Csmr_ALCheckbookOrFinance    = 0x191,    /* Selector */
    kHIDUsage_Csmr_ALCalculator    = 0x192,    /* Selector */
    kHIDUsage_Csmr_ALAOrVCaptureOrPlayback    = 0x193,    /* Selector */
    kHIDUsage_Csmr_ALLocalMachineBrowser    = 0x194,    /* Selector */
    kHIDUsage_Csmr_ALLANOrWANBrowser    = 0x195,    /* Selector */
    kHIDUsage_Csmr_ALInternetBrowser    = 0x196,    /* Selector */
    kHIDUsage_Csmr_ALRemoteNetworkingOrISPConnect    = 0x197,    /* Selector */
    kHIDUsage_Csmr_ALNetworkConference    = 0x198,    /* Selector */
    kHIDUsage_Csmr_ALNetworkChat    = 0x199,    /* Selector */
    kHIDUsage_Csmr_ALTelephonyOrDialer    = 0x19A,    /* Selector */
    kHIDUsage_Csmr_ALLogon    = 0x19B,    /* Selector */
    kHIDUsage_Csmr_ALLogoff    = 0x19C,    /* Selector */
    kHIDUsage_Csmr_ALLogonOrLogoff    = 0x19D,    /* Selector */
    kHIDUsage_Csmr_ALTerminalLockOrScreensaver    = 0x19E,    /* Selector */
    kHIDUsage_Csmr_ALControlPanel    = 0x19F,    /* Selector */
    kHIDUsage_Csmr_ALCommandLineProcessorOrRun    = 0x1A0,    /* Selector */
    kHIDUsage_Csmr_ALProcessOrTaskManager    = 0x1A1,    /* Selector */
    kHIDUsage_Csmr_AL    = 0x1A2,    /* Selector */
    kHIDUsage_Csmr_ALNextTaskOrApplication    = 0x1A3,    /* Selector */
    kHIDUsage_Csmr_ALPreviousTaskOrApplication    = 0x1A4,    /* Selector */
    kHIDUsage_Csmr_ALPreemptiveHaltTaskOrApplication    = 0x1A5,    /* Selector */
    kHIDUsage_Csmr_ALIntegratedHelpCenter   = 0x1A6, /* Selector */
    kHIDUsage_Csmr_ALDocuments   = 0x1A7, /* Selector */
    kHIDUsage_Csmr_ALThesaurus   = 0x1A8, /* Selector */
    kHIDUsage_Csmr_ALDictionary   = 0x1A9, /* Selector */
    kHIDUsage_Csmr_ALDesktop   = 0x1AA, /* Selector */
    kHIDUsage_Csmr_ALSpellCheck   = 0x1AB, /* Selector */
    kHIDUsage_Csmr_ALGrammerCheck   = 0x1AC, /* Selector */
    kHIDUsage_Csmr_ALWirelessStatus   = 0x1AD, /* Selector */
    kHIDUsage_Csmr_ALKeyboardLayout   = 0x1AE, /* Selector */
    kHIDUsage_Csmr_ALVirusProtection   = 0x1AF, /* Selector */
    kHIDUsage_Csmr_ALEncryption   = 0x1B0, /* Selector */
    kHIDUsage_Csmr_ALScreenSaver   = 0x1B1, /* Selector */
    kHIDUsage_Csmr_ALAlarms   = 0x1B2, /* Selector */
    kHIDUsage_Csmr_ALClock   = 0x1B3, /* Selector */
    kHIDUsage_Csmr_ALFileBrowser   = 0x1B4, /* Selector */
    kHIDUsage_Csmr_ALPowerStatus   = 0x1B5, /* Selector */
    kHIDUsage_Csmr_ALImageBrowser   = 0x1B6, /* Selector */
    kHIDUsage_Csmr_ALAudioBrowser   = 0x1B7, /* Selector */
    kHIDUsage_Csmr_ALMovieBrowser   = 0x1B8, /* Selector */
    kHIDUsage_Csmr_ALDigitalRightsManager   = 0x1B9, /* Selector */
    kHIDUsage_Csmr_ALDigitalWallet   = 0x1BA, /* Selector */
    /* 0x1BB Reserved */
    kHIDUsage_Csmr_ALInstantMessaging   = 0x1BC, /* Selector */
    kHIDUsage_Csmr_ALOEMFeatureBrowser  = 0x1BD, /* Selector */
    kHIDUsage_Csmr_ALOEMHelp    = 0x1BE, /* Selector */
    kHIDUsage_Csmr_ALOnlineCommunity    = 0x1BF, /* Selector */
    kHIDUsage_Csmr_ALEntertainmentContentBrowser    = 0x1C0, /* Selector */
    kHIDUsage_Csmr_ALOnlineShoppingBrowswer = 0x1C1, /* Selector */
    kHIDUsage_Csmr_ALSmartCardInformationOrHelp = 0x1C2, /* Selector */
    kHIDUsage_Csmr_ALMarketMonitorOrFinanceBrowser  = 0x1C3, /* Selector */
    kHIDUsage_Csmr_ALCustomizedCorporateNewsBrowser = 0x1C4, /* Selector */
    kHIDUsage_Csmr_ALOnlineActivityBrowswer= 0x1C5, /* Selector */
    kHIDUsage_Csmr_ALResearchOrSearchBrowswer   = 0x1C6, /* Selector */
    kHIDUsage_Csmr_ALAudioPlayer= 0x1C7, /* Selector */
    /* 0x1C8 - 0x1FF Reserved */
    kHIDUsage_Csmr_GenericGUIApplicationControls    = 0x200,    /* Named Array */
    kHIDUsage_Csmr_ACNew    = 0x201,    /* Selector */
    kHIDUsage_Csmr_ACOpen    = 0x202,    /* Selector */
    kHIDUsage_Csmr_ACClose    = 0x203,    /* Selector */
    kHIDUsage_Csmr_ACExit    = 0x204,    /* Selector */
    kHIDUsage_Csmr_ACMaximize    = 0x205,    /* Selector */
    kHIDUsage_Csmr_ACMinimize    = 0x206,    /* Selector */
    kHIDUsage_Csmr_ACSave    = 0x207,    /* Selector */
    kHIDUsage_Csmr_ACPrint    = 0x208,    /* Selector */
    kHIDUsage_Csmr_ACProperties    = 0x209,    /* Selector */
    kHIDUsage_Csmr_ACUndo    = 0x21A,    /* Selector */
    kHIDUsage_Csmr_ACCopy    = 0x21B,    /* Selector */
    kHIDUsage_Csmr_ACCut    = 0x21C,    /* Selector */
    kHIDUsage_Csmr_ACPaste    = 0x21D,    /* Selector */
    kHIDUsage_Csmr_AC    = 0x21E,    /* Selector */
    kHIDUsage_Csmr_ACFind    = 0x21F,    /* Selector */
    kHIDUsage_Csmr_ACFindandReplace    = 0x220,    /* Selector */
    kHIDUsage_Csmr_ACSearch    = 0x221,    /* Selector */
    kHIDUsage_Csmr_ACGoTo    = 0x222,    /* Selector */
    kHIDUsage_Csmr_ACHome    = 0x223,    /* Selector */
    kHIDUsage_Csmr_ACBack    = 0x224,    /* Selector */
    kHIDUsage_Csmr_ACForward    = 0x225,    /* Selector */
    kHIDUsage_Csmr_ACStop    = 0x226,    /* Selector */
    kHIDUsage_Csmr_ACRefresh    = 0x227,    /* Selector */
    kHIDUsage_Csmr_ACPreviousLink    = 0x228,    /* Selector */
    kHIDUsage_Csmr_ACNextLink    = 0x229,    /* Selector */
    kHIDUsage_Csmr_ACBookmarks    = 0x22A,    /* Selector */
    kHIDUsage_Csmr_ACHistory    = 0x22B,    /* Selector */
    kHIDUsage_Csmr_ACSubscriptions    = 0x22C,    /* Selector */
    kHIDUsage_Csmr_ACZoomIn    = 0x22D,    /* Selector */
    kHIDUsage_Csmr_ACZoomOut    = 0x22E,    /* Selector */
    kHIDUsage_Csmr_ACZoom    = 0x22F,    /* Selector */
    kHIDUsage_Csmr_ACFullScreenView    = 0x230,    /* Selector */
    kHIDUsage_Csmr_ACNormalView    = 0x231,    /* Selector */
    kHIDUsage_Csmr_ACViewToggle    = 0x232,    /* Selector */
    kHIDUsage_Csmr_ACScrollUp    = 0x233,    /* Selector */
    kHIDUsage_Csmr_ACScrollDown    = 0x234,    /* Selector */
    kHIDUsage_Csmr_ACScroll    = 0x235,    /* Selector */
    kHIDUsage_Csmr_ACPanLeft    = 0x236,    /* Selector */
    kHIDUsage_Csmr_ACPanRight    = 0x237,    /* Selector */
    kHIDUsage_Csmr_ACPan    = 0x238,    /* Selector */
    kHIDUsage_Csmr_ACNewWindow    = 0x239,    /* Selector */
    kHIDUsage_Csmr_ACTileHorizontally    = 0x23A,    /* Selector */
    kHIDUsage_Csmr_ACTileVertically    = 0x23B,    /* Selector */
    kHIDUsage_Csmr_ACFormat    = 0x23C,    /* Selector */
    kHIDUsage_Csmr_ACEdit   = 0x23D,    /* Selector */
    kHIDUsage_Csmr_ACBold   = 0x23E,    /* Selector */
    kHIDUsage_Csmr_ACItalics    = 0x23F,    /* Selector */
    kHIDUsage_Csmr_ACUnderline  = 0x240,    /* Selector */
    kHIDUsage_Csmr_ACStrikethrough  = 0x241,    /* Selector */
    kHIDUsage_Csmr_ACSubscript  = 0x242,    /* Selector */
    kHIDUsage_Csmr_ACSuperscript    = 0x243,    /* Selector */
    kHIDUsage_Csmr_ACAllCaps    = 0x244,    /* Selector */
    kHIDUsage_Csmr_ACRotate = 0x245,    /* Selector */
    kHIDUsage_Csmr_ACResize = 0x246,    /* Selector */
    kHIDUsage_Csmr_ACFlipHorizontal = 0x247,    /* Selector */
    kHIDUsage_Csmr_ACFlipVertical   = 0x248,    /* Selector */
    kHIDUsage_Csmr_ACMirrorHorizontal   = 0x249,    /* Selector */
    kHIDUsage_Csmr_ACMirrorVertical = 0x24A,    /* Selector */
    kHIDUsage_Csmr_ACFontSelect = 0x24B,    /* Selector */
    kHIDUsage_Csmr_ACFontColor  = 0x24C,    /* Selector */
    kHIDUsage_Csmr_ACFontSize   = 0x24D,    /* Selector */
    kHIDUsage_Csmr_ACJustifyLeft    = 0x24E,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterH = 0x24F,    /* Selector */
    kHIDUsage_Csmr_ACJustifyRight   = 0x250,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockH  = 0x251,    /* Selector */
    kHIDUsage_Csmr_ACJustifyTop     = 0x252,    /* Selector */
    kHIDUsage_Csmr_ACJustifyCenterV = 0x253,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBottom  = 0x254,    /* Selector */
    kHIDUsage_Csmr_ACJustifyBlockV  = 0x255,    /* Selector */
    kHIDUsage_Csmr_ACIndentyDecrease    = 0x256,    /* Selector */
    kHIDUsage_Csmr_ACIndentyIncrease    = 0x257,    /* Selector */
    kHIDUsage_Csmr_ACNumberedList   = 0x258,    /* Selector */
    kHIDUsage_Csmr_ACRestartNumbering   = 0x259,    /* Selector */
    kHIDUsage_Csmr_ACBulletedList   = 0x25A,    /* Selector */
    kHIDUsage_Csmr_ACPromote    = 0x25B,    /* Selector */
    kHIDUsage_Csmr_ACDemote = 0x25C,    /* Selector */
    kHIDUsage_Csmr_ACYes    = 0x25D,    /* Selector */
    kHIDUsage_Csmr_ACNo = 0x25E,    /* Selector */
    kHIDUsage_Csmr_ACCancel = 0x25F,    /* Selector */
    kHIDUsage_Csmr_ACCatalog    = 0x260,    /* Selector */
    kHIDUsage_Csmr_ACBuyOrCheckout  = 0x261,    /* Selector */
    kHIDUsage_Csmr_ACAddToCart  = 0x262,    /* Selector */
    kHIDUsage_Csmr_ACExpand = 0x263,    /* Selector */
    kHIDUsage_Csmr_ACExpandAll  = 0x264,    /* Selector */
    kHIDUsage_Csmr_ACCollapse   = 0x265,    /* Selector */
    kHIDUsage_Csmr_ACCollapseAll    = 0x266,    /* Selector */
    kHIDUsage_Csmr_ACPrintPreview   = 0x267,    /* Selector */
    kHIDUsage_Csmr_ACPasteSpecial   = 0x268,    /* Selector */
    kHIDUsage_Csmr_ACInsertMode = 0x269,    /* Selector */
    kHIDUsage_Csmr_ACDelete = 0x26A,    /* Selector */
    kHIDUsage_Csmr_ACLock   = 0x26B,    /* Selector */
    kHIDUsage_Csmr_ACUnlock = 0x26C,    /* Selector */
    kHIDUsage_Csmr_ACProtect    = 0x26D,    /* Selector */
    kHIDUsage_Csmr_ACUnprotect  = 0x26E,    /* Selector */
    kHIDUsage_Csmr_ACAttachComment  = 0x26F,    /* Selector */
    kHIDUsage_Csmr_ACDetachComment  = 0x270,    /* Selector */
    kHIDUsage_Csmr_ACViewComment    = 0x271,    /* Selector */
    kHIDUsage_Csmr_ACSelectWord = 0x272,    /* Selector */
    kHIDUsage_Csmr_ACSelectSentence = 0x273,    /* Selector */
    kHIDUsage_Csmr_ACSelectParagraph    = 0x274,    /* Selector */
    kHIDUsage_Csmr_ACSelectColumn   = 0x275,    /* Selector */
    kHIDUsage_Csmr_ACSelectRow  = 0x276,    /* Selector */
    kHIDUsage_Csmr_ACSelectTable    = 0x277,    /* Selector */
    kHIDUsage_Csmr_ACSelectObject   = 0x278,    /* Selector */
    kHIDUsage_Csmr_ACRedoOrRepeat   = 0x279,    /* Selector */
    kHIDUsage_Csmr_ACSort   = 0x27A,    /* Selector */
    kHIDUsage_Csmr_ACSortAscending  = 0x27B,    /* Selector */
    kHIDUsage_Csmr_ACSortDescending = 0x27C,    /* Selector */
    kHIDUsage_Csmr_ACFilter = 0x27D,    /* Selector */
    kHIDUsage_Csmr_ACSetClock   = 0x27E,    /* Selector */
    kHIDUsage_Csmr_ACViewClock  = 0x27F,    /* Selector */
    kHIDUsage_Csmr_ACSelectTimeZone = 0x280,    /* Selector */
    kHIDUsage_Csmr_ACEditTimeZones  = 0x281,    /* Selector */
    kHIDUsage_Csmr_ACSetAlarm   = 0x282,    /* Selector */
    kHIDUsage_Csmr_ACClearAlarm = 0x283,    /* Selector */
    kHIDUsage_Csmr_ACSnoozeAlarm    = 0x284,    /* Selector */
    kHIDUsage_Csmr_ACResetAlarm = 0x285,    /* Selector */
    kHIDUsage_Csmr_ACSynchronize    = 0x286,    /* Selector */
    kHIDUsage_Csmr_ACSendOrReceive  = 0x287,    /* Selector */
    kHIDUsage_Csmr_ACSendTo = 0x288,    /* Selector */
    kHIDUsage_Csmr_ACReply  = 0x289,    /* Selector */
    kHIDUsage_Csmr_ACReplyAll   = 0x28A,    /* Selector */
    kHIDUsage_Csmr_ACForwardMessage = 0x28B,    /* Selector */
    kHIDUsage_Csmr_ACSend   = 0x28C,    /* Selector */
    kHIDUsage_Csmr_ACAttachFile = 0x28D,    /* Selector */
    kHIDUsage_Csmr_ACUpload = 0x28E,    /* Selector */
    kHIDUsage_Csmr_ACDownload   = 0x28F,    /* Selector */
    kHIDUsage_Csmr_ACSetBorders = 0x290,    /* Selector */
    kHIDUsage_Csmr_ACInsertRow  = 0x291,    /* Selector */
    kHIDUsage_Csmr_ACInsertColumn   = 0x292,    /* Selector */
    kHIDUsage_Csmr_ACInsertFile = 0x293,    /* Selector */
    kHIDUsage_Csmr_ACInsertPicture  = 0x294,    /* Selector */
    kHIDUsage_Csmr_ACInsertObject   = 0x295,    /* Selector */
    kHIDUsage_Csmr_ACInsertSymbol   = 0x296,    /* Selector */
    kHIDUsage_Csmr_ACSaveAndClose   = 0x297,    /* Selector */
    kHIDUsage_Csmr_ACRename = 0x298,    /* Selector */
    kHIDUsage_Csmr_ACMerge  = 0x299,    /* Selector */
    kHIDUsage_Csmr_ACSplit  = 0x29A,    /* Selector */
    kHIDUsage_Csmr_ACDistributeH    = 0x29B,    /* Selector */
    kHIDUsage_Csmr_ACDistributeV    = 0x29C,    /* Selector */
    /* 0x29D - 0xFFFF Reserved */
    kHIDUsage_Csmr_Reserved = 0xFFFF
};

/* Digitizer Page (0x0D) */
/* This section provides detailed descriptions of the usages employed by Digitizer Devices. */
enum
{
    kHIDUsage_Dig_Digitizer                         = 0x01,     /* Application Collection */
    kHIDUsage_Dig_Pen                               = 0x02,     /* Application Collection */
    kHIDUsage_Dig_LightPen                          = 0x03,     /* Application Collection */
    kHIDUsage_Dig_TouchScreen                       = 0x04,     /* Application Collection */
    kHIDUsage_Dig_TouchPad                          = 0x05,     /* Application Collection */
    kHIDUsage_Dig_WhiteBoard                        = 0x06,     /* Application Collection */
    kHIDUsage_Dig_CoordinateMeasuringMachine        = 0x07,     /* Application Collection */
    kHIDUsage_Dig_3DDigitizer                       = 0x08,     /* Application Collection */
    kHIDUsage_Dig_StereoPlotter                     = 0x09,     /* Application Collection */
    kHIDUsage_Dig_ArticulatedArm                    = 0x0A,     /* Application Collection */
    kHIDUsage_Dig_Armature                          = 0x0B,     /* Application Collection */
    kHIDUsage_Dig_MultiplePointDigitizer            = 0x0C,     /* Application Collection */
    kHIDUsage_Dig_FreeSpaceWand                     = 0x0D,     /* Application Collection */
    kHIDUsage_Dig_DeviceConfiguration               = 0x0E,     /* Application Collection */
    /* 0x0F - 0x1F Reserved */
    kHIDUsage_Dig_Stylus                            = 0x20,     /* Logical Collection */
    kHIDUsage_Dig_Puck                              = 0x21,     /* Logical Collection */
    kHIDUsage_Dig_Finger                            = 0x22,     /* Logical Collection */
    kHIDUsage_Dig_DeviceSettings                    = 0x23,     /* Logical Collection */
    kHIDUsage_Dig_GestureCharacter                  = 0x24,     /* Logical Collection */
    /* 0x25 - 0x2F Reserved */
    kHIDUsage_Dig_TipPressure                       = 0x30,     /* Dynamic Value */
    kHIDUsage_Dig_BarrelPressure                    = 0x31,     /* Dynamic Value */
    kHIDUsage_Dig_InRange                           = 0x32,     /* Momentary Control */
    kHIDUsage_Dig_Touch                             = 0x33,     /* Momentary Control */
    kHIDUsage_Dig_Untouch                           = 0x34,     /* One-Shot Control */
    kHIDUsage_Dig_Tap                               = 0x35,     /* One-Shot Control */
    kHIDUsage_Dig_Quality                           = 0x36,     /* Dynamic Value */
    kHIDUsage_Dig_DataValid                         = 0x37,     /* Momentary Control */
    kHIDUsage_Dig_TransducerIndex                   = 0x38,     /* Dynamic Value */
    kHIDUsage_Dig_TabletFunctionKeys                = 0x39,     /* Logical Collection */
    kHIDUsage_Dig_ProgramChangeKeys                 = 0x3A,     /* Logical Collection */
    kHIDUsage_Dig_BatteryStrength                   = 0x3B,     /* Dynamic Value */
    kHIDUsage_Dig_Invert                            = 0x3C,     /* Momentary Control */
    kHIDUsage_Dig_XTilt                             = 0x3D,     /* Dynamic Value */
    kHIDUsage_Dig_YTilt                             = 0x3E,     /* Dynamic Value */
    kHIDUsage_Dig_Azimuth                           = 0x3F,     /* Dynamic Value */
    kHIDUsage_Dig_Altitude                          = 0x40,     /* Dynamic Value */
    kHIDUsage_Dig_Twist                             = 0x41,     /* Dynamic Value */
    kHIDUsage_Dig_TipSwitch                         = 0x42,     /* Momentary Control */
    kHIDUsage_Dig_SecondaryTipSwitch                = 0x43,     /* Momentary Control */
    kHIDUsage_Dig_BarrelSwitch                      = 0x44,     /* Momentary Control */
    kHIDUsage_Dig_Eraser                            = 0x45,     /* Momentary Control */
    kHIDUsage_Dig_TabletPick                        = 0x46,     /* Momentary Control */
    kHIDUsage_Dig_TouchValid                        = 0x47,     /* Momentary Control */
    kHIDUsage_Dig_Width                             = 0x48,     /* Dynamic Value */
    kHIDUsage_Dig_Height                            = 0x49,     /* Dynamic Value */
    /* 0x4A - 0x50 Reserved */
    kHIDUsage_Dig_ContactIdentifier                 = 0x51,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceMode                        = 0x52,     /* Dynamic Value */
    kHIDUsage_Dig_DeviceIdentifier                  = 0x53,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCount                      = 0x54,     /* Dynamic Value */
    kHIDUsage_Dig_ContactCountMaximum               = 0x55,     /* Static Value */
    
    /* 0x56 - 0x5F Reserved */
    kHIDUsage_Dig_GestureCharacterEnable            = 0x60,     /* Dynamic Flag */
    kHIDUsage_Dig_GestureCharacterQuality           = 0x61,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterDataLength        = 0x62,     /* Dynamic Value */
    kHIDUsage_Dig_GestureCharacterData              = 0x63,     /* Buffered Bytes */
    kHIDUsage_Dig_GestureCharacterEncoding          = 0x64,     /* Named Array */
    kHIDUsage_Dig_GestureCharacterEncodingUTF8      = 0x65,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16LE   = 0x66,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF16BE   = 0x67,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32LE   = 0x68,     /* Selector */
    kHIDUsage_Dig_GestureCharacterEncodingUTF32BE   = 0x69,     /* Selector */
    
    /* 0x70 - 0xFFFF Reserved */
    kHIDUsage_Dig_Reserved                          = 0xFFFF
};

/* Physical Interface Device Page (0x0F) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    kHIDUsage_PID_PhysicalInterfaceDevice = 0x01,        /* CA - A collection of PID usages */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_PID_Normal = 0x20,                        /* DV - A force applied perpendicular to the surface of an object */
    kHIDUsage_PID_SetEffectReport = 0x21,                /* XXX */
    kHIDUsage_PID_EffectBlockIndex = 0x22,                /* XXX */
    kHIDUsage_PID_ParamBlockOffset = 0x23,                /* XXX */
    kHIDUsage_PID_ROM_Flag = 0x24,                        /* XXX */
    kHIDUsage_PID_EffectType = 0x25,                    /* XXX */
    kHIDUsage_PID_ET_ConstantForce = 0x26,                /* XXX */
    kHIDUsage_PID_ET_Ramp = 0x27,                        /* XXX */
    kHIDUsage_PID_ET_CustomForceData = 0x28,            /* XXX */
    /* 0x29 - 0x2F Reserved */
    kHIDUsage_PID_ET_Square = 0x30,                        /* XXX */
    kHIDUsage_PID_ET_Sine = 0x31,                        /* XXX */
    kHIDUsage_PID_ET_Triangle = 0x32,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothUp = 0x33,                    /* XXX */
    kHIDUsage_PID_ET_SawtoothDown = 0x34,                /* XXX */
    /* 0x35 - 0x3F Reserved */
    kHIDUsage_PID_ET_Spring = 0x40,                        /* XXX */
    kHIDUsage_PID_ET_Damper = 0x41,                        /* XXX */
    kHIDUsage_PID_ET_Inertia = 0x42,                    /* XXX */
    kHIDUsage_PID_ET_Friction = 0x43,                    /* XXX */
    /* 0x44 - 0x4F Reserved */
    kHIDUsage_PID_Duration = 0x50,                        /* XXX */
    kHIDUsage_PID_SamplePeriod = 0x51,                    /* XXX */
    kHIDUsage_PID_Gain = 0x52,                            /* XXX */
    kHIDUsage_PID_TriggerButton = 0x53,                    /* XXX */
    kHIDUsage_PID_TriggerRepeatInterval = 0x54,            /* XXX */
    kHIDUsage_PID_AxesEnable = 0x55,                    /* XXX */
    kHIDUsage_PID_DirectionEnable = 0x56,                /* XXX */
    kHIDUsage_PID_Direction = 0x57,                        /* XXX */
    kHIDUsage_PID_TypeSpecificBlockOffset = 0x58,        /* XXX */
    kHIDUsage_PID_BlockType = 0x59,                        /* XXX */
    kHIDUsage_PID_SetEnvelopeReport = 0x5A,                /* XXX */
    kHIDUsage_PID_AttackLevel = 0x5B,                    /* XXX */
    kHIDUsage_PID_AttackTime = 0x5C,                    /* XXX */
    kHIDUsage_PID_FadeLevel = 0x5D,                        /* XXX */
    kHIDUsage_PID_FadeTime = 0x5E,                        /* XXX */
    kHIDUsage_PID_SetConditionReport = 0x5F,            /* XXX */
    
    kHIDUsage_PID_CP_Offset = 0x60,                        /* XXX */
    kHIDUsage_PID_PositiveCoefficient = 0x61,            /* XXX */
    kHIDUsage_PID_NegativeCoefficient = 0x62,            /* XXX */
    kHIDUsage_PID_PositiveSaturation = 0x63,            /* XXX */
    kHIDUsage_PID_NegativeSaturation = 0x64,            /* XXX */
    kHIDUsage_PID_DeadBand = 0x65,                        /* XXX */
    kHIDUsage_PID_DownloadForceSample = 0x66,            /* XXX */
    kHIDUsage_PID_IsochCustomForceEnable = 0x67,        /* XXX */
    kHIDUsage_PID_CustomForceDataReport = 0x68,            /* XXX */
    kHIDUsage_PID_CustomForceData = 0x69,                /* XXX */
    kHIDUsage_PID_CustomForceVendorDefinedData = 0x6A,    /* XXX */
    kHIDUsage_PID_SetCustomForceReport = 0x6B,            /* XXX */
    kHIDUsage_PID_CustomForceDataOffset = 0x6C,            /* XXX */
    kHIDUsage_PID_SampleCount = 0x6D,                    /* XXX */
    kHIDUsage_PID_SetPeriodicReport = 0x6E,                /* XXX */
    kHIDUsage_PID_Offset = 0x6F,                        /* XXX */
    
    kHIDUsage_PID_Magnitude = 0x70,                        /* XXX */
    kHIDUsage_PID_Phase = 0x71,                            /* XXX */
    kHIDUsage_PID_Period = 0x72,                        /* XXX */
    kHIDUsage_PID_SetConstantForceReport = 0x73,        /* XXX */
    kHIDUsage_PID_SetRampForceReport = 0x74,            /* XXX */
    kHIDUsage_PID_RampStart = 0x75,                        /* XXX */
    kHIDUsage_PID_RampEnd = 0x76,                        /* XXX */
    kHIDUsage_PID_EffectOperationReport = 0x77,            /* XXX */
    kHIDUsage_PID_EffectOperation = 0x78,                /* XXX */
    kHIDUsage_PID_OpEffectStart = 0x79,                    /* XXX */
    kHIDUsage_PID_OpEffectStartSolo = 0x7A,                /* XXX */
    kHIDUsage_PID_OpEffectStop = 0x7B,                    /* XXX */
    kHIDUsage_PID_LoopCount = 0x7C,                        /* XXX */
    kHIDUsage_PID_DeviceGainReport = 0x7D,                /* XXX */
    kHIDUsage_PID_DeviceGain = 0x7E,                    /* XXX */
    kHIDUsage_PID_PoolReport = 0x7F,                    /* XXX */
    
    kHIDUsage_PID_RAM_PoolSize = 0x80,                    /* XXX */
    kHIDUsage_PID_ROM_PoolSize = 0x81,                    /* XXX */
    kHIDUsage_PID_ROM_EffectBlockCount = 0x82,            /* XXX */
    kHIDUsage_PID_SimultaneousEffectsMax = 0x83,        /* XXX */
    kHIDUsage_PID_PoolAlignment = 0x84,                    /* XXX */
    kHIDUsage_PID_PoolMoveReport = 0x85,                /* XXX */
    kHIDUsage_PID_MoveSource = 0x86,                    /* XXX */
    kHIDUsage_PID_MoveDestination = 0x87,                /* XXX */
    kHIDUsage_PID_MoveLength = 0x88,                    /* XXX */
    kHIDUsage_PID_BlockLoadReport = 0x89,                /* XXX */
    /* 0x8A Reserved */
    kHIDUsage_PID_BlockLoadStatus = 0x8B,                /* XXX */
    kHIDUsage_PID_BlockLoadSuccess = 0x8C,                /* XXX */
    kHIDUsage_PID_BlockLoadFull = 0x8D,                    /* XXX */
    kHIDUsage_PID_BlockLoadError = 0x8E,                /* XXX */
    kHIDUsage_PID_BlockHandle = 0x8F,                    /* XXX */
    
    kHIDUsage_PID_BlockFreeReport = 0x90,                /* XXX */
    kHIDUsage_PID_TypeSpecificBlockHandle = 0x91,        /* XXX */
    kHIDUsage_PID_StateReport = 0x92,                    /* XXX */
    /* 0x93 Reserved */
    kHIDUsage_PID_EffectPlaying = 0x94,                    /* XXX */
    kHIDUsage_PID_DeviceControlReport = 0x95,            /* XXX */
    kHIDUsage_PID_DeviceControl = 0x96,                    /* XXX */
    kHIDUsage_PID_DC_EnableActuators = 0x97,            /* XXX */
    kHIDUsage_PID_DC_DisableActuators = 0x98,            /* XXX */
    kHIDUsage_PID_DC_StopAllEffects = 0x99,                /* XXX */
    kHIDUsage_PID_DC_DeviceReset = 0x9A,                /* XXX */
    kHIDUsage_PID_DC_DevicePause = 0x9B,                /* XXX */
    kHIDUsage_PID_DC_DeviceContinue = 0x9C,                /* XXX */
    /* 0x9d - 0x9E Reserved */
    kHIDUsage_PID_DevicePaused = 0x9F,                    /* XXX */
    
    kHIDUsage_PID_ActuatorsEnabled = 0xA0,                /* XXX */
    /* 0xA1 - 0xA3 Reserved */
    kHIDUsage_PID_SafetySwitch = 0xA4,                    /* XXX */
    kHIDUsage_PID_ActuatorOverrideSwitch = 0xA5,        /* XXX */
    kHIDUsage_PID_ActuatorPower = 0xA6,                    /* XXX */
    kHIDUsage_PID_StartDelay = 0xA7,                    /* XXX */
    kHIDUsage_PID_ParameterBlockSize = 0xA8,            /* XXX */
    kHIDUsage_PID_DeviceManagedPool = 0xA9,                /* XXX */
    kHIDUsage_PID_SharedParameterBlocks = 0xAA,            /* XXX */
    kHIDUsage_PID_CreateNewEffectReport = 0xAB,            /* XXX */
    kHIDUsage_PID_RAM_PoolAvailable = 0xAC,                /* XXX */
    /* 0xAD - 0xFFFF Reserved */
    kHIDUsage_PID_Reserved = 0xFFFF
};

/* AlphanumericDisplay Page (0x14) */
/* The Alphanumeric Display page is intended for use by simple alphanumeric displays that are used on consumer devices. */
enum
{
    kHIDUsage_AD_AlphanumericDisplay    = 0x01,    /* Application Collection */
    /* 0x02 - 0x1F Reserved */
    kHIDUsage_AD_DisplayAttributesReport    = 0x20,    /* Logical Collection */
    kHIDUsage_AD_ASCIICharacterSet    = 0x21,    /* Static Flag */
    kHIDUsage_AD_DataReadBack    = 0x22,    /* Static Flag */
    kHIDUsage_AD_FontReadBack    = 0x23,    /* Static Flag */
    kHIDUsage_AD_DisplayControlReport    = 0x24,    /* Logical Collection */
    kHIDUsage_AD_ClearDisplay    = 0x25,    /* Dynamic Flag */
    kHIDUsage_AD_DisplayEnable    = 0x26,    /* Dynamic Flag */
    kHIDUsage_AD_ScreenSaverDelay    = 0x27,    /* Static Value */
    kHIDUsage_AD_ScreenSaverEnable    = 0x28,    /* Dynamic Flag */
    kHIDUsage_AD_VerticalScroll    = 0x29,    /* Static Flag */
    kHIDUsage_AD_HorizontalScroll    = 0x2A,    /* Static Flag */
    kHIDUsage_AD_CharacterReport    = 0x2B,    /* Logical Collection */
    kHIDUsage_AD_DisplayData    = 0x2C,    /* Dynamic Value */
    kHIDUsage_AD_DisplayStatus    = 0x2D,    /* Logical Collection */
    kHIDUsage_AD_StatNotReady    = 0x2E,    /* Selector */
    kHIDUsage_AD_StatReady    = 0x2F,    /* Selector */
    kHIDUsage_AD_ErrNotaloadablecharacter    = 0x30,    /* Selector */
    kHIDUsage_AD_ErrFontdatacannotberead    = 0x31,    /* Selector */
    kHIDUsage_AD_CursorPositionReport    = 0x32,    /* Logical Collection */
    kHIDUsage_AD_Row    = 0x33,    /* Dynamic Value */
    kHIDUsage_AD_Column    = 0x34,    /* Dynamic Value */
    kHIDUsage_AD_Rows    = 0x35,    /* Static Value */
    kHIDUsage_AD_Columns    = 0x36,    /* Static Value */
    kHIDUsage_AD_CursorPixelPositioning    = 0x37,    /* Static Flag */
    kHIDUsage_AD_CursorMode    = 0x38,    /* Dynamic Flag */
    kHIDUsage_AD_CursorEnable    = 0x39,    /* Dynamic Flag */
    kHIDUsage_AD_CursorBlink    = 0x3A,    /* Dynamic Flag */
    kHIDUsage_AD_FontReport    = 0x3B,    /* Logical Collection */
    kHIDUsage_AD_FontData    = 0x3C,    /* Buffered Byte */
    kHIDUsage_AD_CharacterWidth    = 0x3D,    /* Static Value */
    kHIDUsage_AD_CharacterHeight    = 0x3E,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingHorizontal    = 0x3F,    /* Static Value */
    kHIDUsage_AD_CharacterSpacingVertical    = 0x40,    /* Static Value */
    kHIDUsage_AD_UnicodeCharacterSet    = 0x41,    /* Static Flag */
    /* 0x42 - 0xFFFF Reserved */
    kHIDUsage_AD_Reserved = 0xFFFF
};

/* Sensor Page (0x14) */
/* The Sensor page is intended for use by devices that capture biometric, electrical, environmental, light, location, mechanical, motion, orientation, scanner, etc events. */
enum
{
    kHIDUsage_Snsr_Undefined                            = 0x00,
    kHIDUsage_Snsr_Sensor                               = 0x01,     /* Application/Physical Collection */
    /* 0x02 - 0x0F Reserved */
    kHIDUsage_Snsr_Biometric                            = 0x10,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanPresence              = 0x11,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanProximity             = 0x12,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Biometric_HumanTouch                 = 0x13,     /* Application/Physical Collection */
    /* 0x14 - 0x1F Reserved */
    kHIDUsage_Snsr_Electrical                           = 0x20,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Capacitance               = 0x21,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Current                   = 0x22,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Power                     = 0x23,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Inductance                = 0x24,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Resistance                = 0x25,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Voltage                   = 0x26,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Potentiometer             = 0x27,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Frequency                 = 0x28,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Electrical_Period                    = 0x29,     /* Application/Physical Collection */
    /* 0x2A - 0x2F Reserved */
    kHIDUsage_Snsr_Environmental                        = 0x30,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_AtmosphericPressure    = 0x31,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Humidity               = 0x32,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_Temperature            = 0x33,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindDirection          = 0x34,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Environmental_WindSpeed              = 0x35,     /* Application/Physical Collection */
    /* 0x36 - 0x3F Reserved */
    kHIDUsage_Snsr_Light                                = 0x40,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_AmbientLight                   = 0x41,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Light_ConsumerInfrared               = 0x42,     /* Application/Physical Collection */
    /* 0x43 - 0x4F Reserved */
    kHIDUsage_Snsr_Location                             = 0x50,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Broadcast                   = 0x51,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_DeadReckoning               = 0x52,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_GPS                         = 0x53,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Lookup                      = 0x54,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Other                       = 0x55,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Static                      = 0x56,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Location_Triangulation               = 0x57,     /* Application/Physical Collection */
    /* 0x58 - 0x5F Reserved */
    kHIDUsage_Snsr_Mechanical                           = 0x60,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitch             = 0x61,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_BooleanSwitchArray        = 0x62,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_MultivalueSwitch          = 0x63,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Force                     = 0x64,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Pressure                  = 0x65,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Strain                    = 0x66,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_Weight                    = 0x67,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HapticVibrator            = 0x68,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Mechanical_HallEffectSwitch          = 0x69,     /* Application/Physical Collection */
    /* 0x6A - 0x6F Reserved */
    kHIDUsage_Snsr_Motion                               = 0x70,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer1D               = 0x71,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer2D               = 0x72,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer3D               = 0x73,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer1D                   = 0x74,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer2D                   = 0x75,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer3D                   = 0x76,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_MotionDetector                = 0x77,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Speedometer                   = 0x78,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Accelerometer                 = 0x79,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Motion_Gyrometer                     = 0x7A,     /* Application/Physical Collection */
    /* 0x7B - 0x7F Reserved */
    kHIDUsage_Snsr_Orientation                          = 0x80,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass1D                = 0x81,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass2D                = 0x82,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Compass3D                = 0x83,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer1D           = 0x84,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer2D           = 0x85,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Inclinometer3D           = 0x86,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance1D               = 0x87,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance2D               = 0x88,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_Distance3D               = 0x89,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DeviceOrientation        = 0x8A,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_CompassD                 = 0x8B,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_InclinometerD            = 0x8C,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Orientation_DistanceD                = 0x8D,     /* Application/Physical Collection */
    /* 0x8E - 0x8F Reserved */
    kHIDUsage_Snsr_Scanner                              = 0x90,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_Barcode                      = 0x91,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_RFID                         = 0x92,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Scanner_NFC                          = 0x93,     /* Application/Physical Collection */
    /* 0x94 - 0x9F Reserved */
    kHIDUsage_Snsr_Time                                 = 0xA0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_AlarmTimer                      = 0xA1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Time_RealTimeClock                   = 0xA2,     /* Application/Physical Collection */
    /* 0xA3 - 0xDF Reserved */
    kHIDUsage_Snsr_Other                                = 0xE0,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Custom                         = 0xE1,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_Generic                        = 0xE2,     /* Application/Physical Collection */
    kHIDUsage_Snsr_Other_GenericEnumerator              = 0xE3,     /* Application/Physical Collection */
    /* 0xE4 - 0xEF Reserved */
    /* 0xF0 - 0xFF Vendor Reserved */
    
    /* Common Sensor Type Data Fields */

    /* Usage Switches used in conjunction with other Data Usages. The value of the modifier is OR-ed in to the upper nibble of the 16bit Data Usage. */
    kHIDUsage_Snsr_Modifier_None                                = 0x0,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityAbsolute           = 0x1,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Max                                 = 0x2,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Min                                 = 0x3,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Accuracy                            = 0x4,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_Resolution                          = 0x5,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdHigh                       = 0x6,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ThresholdLow                        = 0x7,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationOffset                   = 0x8,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_CalibrationMultiplier               = 0x9,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ReportInterval                      = 0xA,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_FrequencyMax                        = 0xB,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_PeriodMax                           = 0xC,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRange       = 0xD,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_ChangeSensitivityPercentRelative    = 0xE,      /* Data Field Usage Switch */
    kHIDUsage_Snsr_Modifier_VendorDefined                       = 0xF,      /* Data Field Usage Switch */

    /* Event Usages */
    kHIDUsage_Snsr_Event                                        = 0x0200,
    kHIDUsage_Snsr_Event_SensorState                            = 0x0201,
    kHIDUsage_Snsr_Event_SensorEvent                            = 0x0202,
    /* 0x0203 - 0x02FF Event Reserved */
    
    kHIDUsage_Snsr_Event_SensorState_Undefined                  = 0x0800,
    kHIDUsage_Snsr_Event_SensorState_Ready                      = 0x0801,
    kHIDUsage_Snsr_Event_SensorState_NotAvailable               = 0x0802,
    kHIDUsage_Snsr_Event_SensorState_NoData                     = 0x0803,
    kHIDUsage_Snsr_Event_SensorState_Initializing               = 0x0804,
    kHIDUsage_Snsr_Event_SensorState_AccessDenied               = 0x0805,
    kHIDUsage_Snsr_Event_SensorState_Error                      = 0x0806,
    /* 0x0807 - 0x080F Reserved */
    
    kHIDUsage_Snsr_Event_SensorEvent_Unknown                    = 0x0810,
    kHIDUsage_Snsr_Event_SensorEvent_StateChanged               = 0x0811,
    kHIDUsage_Snsr_Event_SensorEvent_PropertyChanged            = 0x0812,
    kHIDUsage_Snsr_Event_SensorEvent_DataUpdated                = 0x0813,
    kHIDUsage_Snsr_Event_SensorEvent_PollResponse               = 0x0814,
    kHIDUsage_Snsr_Event_SensorEvent_ChangeSensitivity          = 0x0815,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMaxReached            = 0x0816,
    kHIDUsage_Snsr_Event_SensorEvent_RangeMinReached            = 0x0817,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossUp       = 0x0818,
    kHIDUsage_Snsr_Event_SensorEvent_HighThresholdCrossDown     = 0x0819,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossUp        = 0x081A,
    kHIDUsage_Snsr_Event_SensorEvent_LowThresholdCrossDown      = 0x081B,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossUp       = 0x081C,
    kHIDUsage_Snsr_Event_SensorEvent_ZeroThresholdCrossDown     = 0x081D,
    kHIDUsage_Snsr_Event_SensorEvent_PeriodExceeded             = 0x081E,
    kHIDUsage_Snsr_Event_SensorEvent_FrequencyExceeded          = 0x081F,
    kHIDUsage_Snsr_Event_SensorEvent_ComplexTrigger             = 0x0820,
    /* 0x0821 - 0x082F Reserved */

    /* Property Usages */
    kHIDUsage_Snsr_Property                                     = 0x0300,
    kHIDUsage_Snsr_Property_FriendlyName                        = 0x0301,
    kHIDUsage_Snsr_Property_PersistentUniqueID                  = 0x0302,
    kHIDUsage_Snsr_Property_SensorStatus                        = 0x0303,
    kHIDUsage_Snsr_Property_MinimumReportInterval               = 0x0304,
    kHIDUsage_Snsr_Property_Manufacturer                        = 0x0305,
    kHIDUsage_Snsr_Property_Model                               = 0x0306,
    kHIDUsage_Snsr_Property_SerialNumber                        = 0x0307,
    kHIDUsage_Snsr_Property_Description                         = 0x0308,
    kHIDUsage_Snsr_Property_ConnectionType                      = 0x0309,
    kHIDUsage_Snsr_Property_DevicePath                          = 0x030A,
    kHIDUsage_Snsr_Property_HardwareRevision                    = 0x030B,
    kHIDUsage_Snsr_Property_FirmwareVersion                     = 0x030C,
    kHIDUsage_Snsr_Property_ReleaseData                         = 0x030D,
    kHIDUsage_Snsr_Property_ReportInterval                      = 0x030E,
    kHIDUsage_Snsr_Property_ChangeSensitivityAbsolute           = 0x030F,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRange       = 0x0310,
    kHIDUsage_Snsr_Property_ChangeSensitivityPercentRelative    = 0x0311,
    kHIDUsage_Snsr_Property_Accuracy                            = 0x0312,
    kHIDUsage_Snsr_Property_Resolution                          = 0x0313,
    kHIDUsage_Snsr_Property_Maximum                             = 0x0314,
    kHIDUsage_Snsr_Property_Minimum                             = 0x0315,
    kHIDUsage_Snsr_Property_ReportingState                      = 0x0316,
    kHIDUsage_Snsr_Property_SamplingRate                        = 0x0317,
    kHIDUsage_Snsr_Property_ResponseCurve                       = 0x0318,
    kHIDUsage_Snsr_Property_PowerState                          = 0x0319,
    /* 0x031A - 0x03FF Reserved */
    
    kHIDUsage_Snsr_Property_ConnectionType_Integrated           = 0x0830,
    kHIDUsage_Snsr_Property_ConnectionType_Attached             = 0x0831,
    kHIDUsage_Snsr_Property_ConnectionType_External             = 0x0832,
    /* 0x0833 - 0x083F Reserved */
    kHIDUsage_Snsr_Property_ReportingState_NoEvents             = 0x0840,
    kHIDUsage_Snsr_Property_ReportingState_AllEvents            = 0x0841,
    kHIDUsage_Snsr_Property_ReportingState_ThresholdEvents      = 0x0842,
    kHIDUsage_Snsr_Property_ReportingState_WakeNoEvents         = 0x0843,
    kHIDUsage_Snsr_Property_ReportingState_WakeAllEvents        = 0x0844,
    kHIDUsage_Snsr_Property_ReportingState_WakeThresholdEvents  = 0x0845,
    /* 0x0846 - 0x084F Reserved */
    kHIDUsage_Snsr_Property_PowerState_Undefined                = 0x0850,
    kHIDUsage_Snsr_Property_PowerState_D0_FullPower             = 0x0851,
    kHIDUsage_Snsr_Property_PowerState_D1_LowPower              = 0x0852,
    kHIDUsage_Snsr_Property_PowerState_D2_Standby               = 0x0853,
    kHIDUsage_Snsr_Property_PowerState_D3_Sleep                 = 0x0854,
    kHIDUsage_Snsr_Property_PowerState_D4_PowerOff              = 0x0855,
    /* 0x0855 - 0x085F Reserved */
    
    /* Specific Sensor Type Data Fields */
    /*** TODO ***/
};

/* Power Device Page (0x84) */
/* This section provides detailed descriptions of the usages employed by Power Devices. */
enum
{
    
    kHIDUsage_PD_Undefined = 0x00,                /* Power Device Undefined Usage */
    kHIDUsage_PD_iName = 0x01,                    /* CL- Power Device Name Index */
    kHIDUsage_PD_PresentStatus = 0x02,            /* CL- Power Device Present Status */
    kHIDUsage_PD_ChangedStatus = 0x03,            /* CA- Power Device Changed Status */
    kHIDUsage_PD_UPS = 0x04,                    /* CA- Uninterruptible Power Supply */
    kHIDUsage_PD_PowerSupply = 0x05,            /* CA- Power Supply */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_PD_BatterySystem = 0x10,            /* CP- Battery System power module */
    kHIDUsage_PD_BatterySystemID = 0x11,        /* SV IF- Battery System ID */
    kHIDUsage_PD_Battery = 0x12,                /* CP- Battery */
    kHIDUsage_PD_BatteryID = 0x13,                /* SV IF- Battery ID */
    kHIDUsage_PD_Charger = 0x14,                /* CP- Charger */
    kHIDUsage_PD_ChargerID = 0x15,                /* SV IF- Charger ID */
    kHIDUsage_PD_PowerConverter = 0x16,            /* CP- Power Converter power module */
    kHIDUsage_PD_PowerConverterID = 0x17,        /* SV IF- Power Converter ID */
    kHIDUsage_PD_OutletSystem = 0x18,            /* CP- Outlet System power module */
    kHIDUsage_PD_OutletSystemID = 0x19,            /* SV IF-Outlet System ID */
    kHIDUsage_PD_Input = 0x1A,                    /* CP- Power Device Input */
    kHIDUsage_PD_InputID = 0x1B,                /* SV IF- Power Device Input ID */
    kHIDUsage_PD_Output = 0x1C,                    /* CP- Power Device Output */
    kHIDUsage_PD_OutputID = 0x1D,                /* SV IF- Power Device Output ID */
    kHIDUsage_PD_Flow = 0x1E,                    /* CP- Power Device Flow */
    kHIDUsage_PD_FlowID = 0x1F,                    /* Item IF- Power Device Flow ID */
    kHIDUsage_PD_Outlet = 0x20,                    /* CP- Power Device Outlet */
    kHIDUsage_PD_OutletID = 0x21,                /* SV IF- Power Device Outlet ID */
    kHIDUsage_PD_Gang = 0x22,                    /* CL/CP- Power Device Gang */
    kHIDUsage_PD_GangID = 0x23,                    /* SV IF- Power Device Gang ID */
    kHIDUsage_PD_PowerSummary = 0x24,            /* CL/CP- Power Device Power Summary */
    kHIDUsage_PD_PowerSummaryID = 0x25,            /* SV IF- Power Device Power Summary ID */
    /* Reserved 0x26 - 0x2F */
    kHIDUsage_PD_Voltage = 0x30,                /* DV IF- Power Device Voltage */
    kHIDUsage_PD_Current = 0x31,                /* DV IF- Power Device Current */
    kHIDUsage_PD_Frequency = 0x32,                /* DV IF- Power Device Frequency */
    kHIDUsage_PD_ApparentPower = 0x33,            /* DV IF- Power Device Apparent Power */
    kHIDUsage_PD_ActivePower = 0x34,            /* DV IF- Power Device RMS Power */
    kHIDUsage_PD_PercentLoad = 0x35,            /* DV IF- Power Device Percent Load */
    kHIDUsage_PD_Temperature = 0x36,            /* DV IF- Power Device Temperature */
    kHIDUsage_PD_Humidity = 0x37,                /* DV IF- Power Device Humidity */
    kHIDUsage_PD_BadCount = 0x38,                /* DV IF- Power Device Bad Condition Count */
    /* Reserved 0x39 - 0x3F */
    kHIDUsage_PD_ConfigVoltage = 0x40,            /* SV/DV F- Power Device Nominal Voltage */
    kHIDUsage_PD_ConfigCurrent = 0x41,            /* SV/DV F- Power Device Nominal Current */
    kHIDUsage_PD_ConfigFrequency = 0x42,        /* SV/DV F- Power Device Nominal Frequency */
    kHIDUsage_PD_ConfigApparentPower = 0x43,    /* SV/DV F- Power Device Nominal Apparent Power */
    kHIDUsage_PD_ConfigActivePower = 0x44,        /* SV/DV F- Power Device Nominal RMS Power */
    kHIDUsage_PD_ConfigPercentLoad = 0x45,        /* SV/DV F- Power Device Nominal Percent Load */
    kHIDUsage_PD_ConfigTemperature = 0x46,        /* SV/DV F- Power Device Nominal Temperature */
    kHIDUsage_PD_ConfigHumidity = 0x47,            /* SV/DV F- Power Device Nominal Humidity */
    /* Reserved 0x48 - 0x4F */
    kHIDUsage_PD_SwitchOnControl = 0x50,        /* DV F- Power Device Switch On Control */
    kHIDUsage_PD_SwitchOffControl = 0x51,        /* DV F- Power Device Switch Off Control */
    kHIDUsage_PD_ToggleControl = 0x52,            /* DV F- Power Device Toogle Sequence Control */
    kHIDUsage_PD_LowVoltageTransfer = 0x53,        /* DV F- Power Device Min Transfer Voltage */
    kHIDUsage_PD_HighVoltageTransfer = 0x54,    /* DV F- Power Device Max Transfer Voltage */
    kHIDUsage_PD_DelayBeforeReboot = 0x55,        /* DV F- Power Device Delay Before Reboot */
    kHIDUsage_PD_DelayBeforeStartup = 0x56,        /* DV F- Power Device Delay Before Startup */
    kHIDUsage_PD_DelayBeforeShutdown = 0x57,    /* DV F- Power Device Delay Before Shutdown */
    kHIDUsage_PD_Test = 0x58,                    /* DV F- Power Device Test Request/Result */
    kHIDUsage_PD_ModuleReset = 0x59,            /* DV F- Power Device Reset Request/Result */
    kHIDUsage_PD_AudibleAlarmControl = 0x5A,    /* DV F- Power Device Audible Alarm Control */
    /* Reserved 0x5B - 0x5F */
    kHIDUsage_PD_Present = 0x60,                /* DV IOF- Power Device Present */
    kHIDUsage_PD_Good = 0x61,                    /* DV IOF- Power Device Good */
    kHIDUsage_PD_InternalFailure = 0x62,        /* DV IOF- Power Device Internal Failure */
    kHIDUsage_PD_VoltageOutOfRange = 0x63,        /* DV IOF- Power Device Voltage Out Of Range */
    kHIDUsage_PD_FrequencyOutOfRange = 0x64,    /* DV IOF- Power Device Frequency Out Of Range */
    kHIDUsage_PD_Overload = 0x65,                /* DV IOF- Power Device Overload */
    kHIDUsage_PD_OverCharged = 0x66,            /* DV IOF- Power Device Over Charged */
    kHIDUsage_PD_OverTemperature = 0x67,        /* DV IOF- Power Device Over Temperature */
    kHIDUsage_PD_ShutdownRequested = 0x68,        /* DV IOF- Power Device Shutdown Requested */
    kHIDUsage_PD_ShutdownImminent = 0x69,        /* DV IOF- Power Device Shutdown Imminent */
    /* Reserved 0x6A */
    kHIDUsage_PD_SwitchOnOff = 0x6B,            /* DV IOF- Power Device On/Off Switch Status */
    kHIDUsage_PD_Switchable = 0x6C,                /* DV IOF- Power Device Switchable */
    kHIDUsage_PD_Used = 0x6D,                    /* DV IOF- Power Device Used */
    kHIDUsage_PD_Boost = 0x6E,                    /* DV IOF- Power Device Boosted */
    kHIDUsage_PD_Buck = 0x6F,                    /* DV IOF- Power Device Bucked */
    kHIDUsage_PD_Initialized = 0x70,            /* DV IOF- Power Device Initialized */
    kHIDUsage_PD_Tested = 0x71,                    /* DV IOF- Power Device Tested */
    kHIDUsage_PD_AwaitingPower = 0x72,            /* DV IOF- Power Device Awaiting Power */
    kHIDUsage_PD_CommunicationLost = 0x73,        /* DV IOF- Power Device Communication Lost */
    /* Reserved 0x74 - 0xFC */
    kHIDUsage_PD_iManufacturer = 0xFD,            /* SV F- Power Device Manufacturer String Index */
    kHIDUsage_PD_iProduct = 0xFE,                /* SV F- Power Device Product String Index */
    kHIDUsage_PD_iserialNumber = 0xFF            /* SV F- Power Device Serial Number String Index */
};

/* Battery System Page (x85) */
/* This section provides detailed descriptions of the usages employed by Battery Systems. */    
enum
{
    kHIDUsage_BS_Undefined = 0x00,                /* Battery System Undefined */
    kHIDUsage_BS_SMBBatteryMode = 0x01,            /* CL - SMB Mode */
    kHIDUsage_BS_SMBBatteryStatus = 0x02,        /* CL - SMB Status */
    kHIDUsage_BS_SMBAlarmWarning = 0x03,        /* CL - SMB Alarm Warning */
    kHIDUsage_BS_SMBChargerMode = 0x04,            /* CL - SMB Charger Mode */
    kHIDUsage_BS_SMBChargerStatus = 0x05,        /* CL - SMB Charger Status */
    kHIDUsage_BS_SMBChargerSpecInfo = 0x06,        /* CL - SMB Charger Extended Status */
    kHIDUsage_BS_SMBSelectorState = 0x07,        /* CL - SMB Selector State */
    kHIDUsage_BS_SMBSelectorPresets = 0x08,        /* CL - SMB Selector Presets */
    kHIDUsage_BS_SMBSelectorInfo = 0x09,        /* CL - SMB Selector Info */
    /* Reserved 0x0A - 0x0F */
    kHIDUsage_BS_OptionalMfgFunction1 = 0x10,    /* DV F - Battery System Optional SMB Mfg Function 1 */
    kHIDUsage_BS_OptionalMfgFunction2 = 0x11,    /* DV F - Battery System Optional SMB Mfg Function 2 */
    kHIDUsage_BS_OptionalMfgFunction3 = 0x12,    /* DV F - Battery System Optional SMB Mfg Function 3 */
    kHIDUsage_BS_OptionalMfgFunction4 = 0x13,    /* DV F - Battery System Optional SMB Mfg Function 4 */
    kHIDUsage_BS_OptionalMfgFunction5 = 0x14,    /* DV F - Battery System Optional SMB Mfg Function 5 */
    kHIDUsage_BS_ConnectionToSMBus = 0x15,        /* DF F - Battery System Connection To System Management Bus */
    kHIDUsage_BS_OutputConnection = 0x16,        /* DF F - Battery System Output Connection Status */
    kHIDUsage_BS_ChargerConnection = 0x17,        /* DF F - Battery System Charger Connection */
    kHIDUsage_BS_BatteryInsertion = 0x18,        /* DF F - Battery System Battery Insertion */
    kHIDUsage_BS_Usenext = 0x19,                /* DF F - Battery System Use Next */
    kHIDUsage_BS_OKToUse = 0x1A,                /* DF F - Battery System OK To Use */
    kHIDUsage_BS_BatterySupported = 0x1B,        /* DF F - Battery System Battery Supported */
    kHIDUsage_BS_SelectorRevision = 0x1C,        /* DF F - Battery System Selector Revision */
    kHIDUsage_BS_ChargingIndicator = 0x1D,        /* DF F - Battery System Charging Indicator */
    /* Reserved 0x1E - 0x27 */
    kHIDUsage_BS_ManufacturerAccess = 0x28,        /* DV F - Battery System Manufacturer Access */
    kHIDUsage_BS_RemainingCapacityLimit = 0x29,    /* DV F - Battery System Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimit = 0x2A,        /* DV F - Battery System Remaining Time Limit */
    kHIDUsage_BS_AtRate = 0x2B,                    /* DV F - Battery System At Rate... */
    kHIDUsage_BS_CapacityMode = 0x2C,            /* DV F - Battery System Capacity Mode */
    kHIDUsage_BS_BroadcastToCharger = 0x2D,        /* DV F - Battery System Broadcast To Charger */
    kHIDUsage_BS_PrimaryBattery = 0x2E,            /* DV F - Battery System Primary Battery */
    kHIDUsage_BS_ChargeController = 0x2F,        /* DV F - Battery System Charge Controller */
    /* Reserved 0x30 - 0x3F */
    kHIDUsage_BS_TerminateCharge = 0x40,        /* DF IOF - Battery System Terminate Charge */
    kHIDUsage_BS_TerminateDischarge = 0x41,        /* DF IOF - Battery System Terminate Discharge */
    kHIDUsage_BS_BelowRemainingCapacityLimit = 0x42, /* DF IOF - Battery System Below Remaining Capacity Limit */
    kHIDUsage_BS_RemainingTimeLimitExpired = 0x43, /* DF IOF - Battery System Remaining Time Limit Expired */
    kHIDUsage_BS_Charging = 0x44,                /* DF IOF - Battery System Charging */
    kHIDUsage_BS_Discharging = 0x45,            /* DV IOF - Battery System Discharging */
    kHIDUsage_BS_FullyCharged = 0x46,            /* DF IOF - Battery System Fully Charged */
    kHIDUsage_BS_FullyDischarged = 0x47,        /* DV IOF - Battery System Fully Discharged */
    kHIDUsage_BS_ConditioningFlag = 0x48,        /* DV IOF - Battery System Conditioning Flag */
    kHIDUsage_BS_AtRateOK = 0x49,                /* DV IOF - Battery System At Rate OK */
    kHIDUsage_BS_SMBErrorCode = 0x4A,            /* DF IOF - Battery System SMB Error Code */
    kHIDUsage_BS_NeedReplacement = 0x4B,        /* DF IOF - Battery System Need Replacement */
    /* Reserved 0x4C - 0x5F */
    kHIDUsage_BS_AtRateTimeToFull = 0x60,        /* DV IF - Battery System At Rate Time To Full */
    kHIDUsage_BS_AtRateTimeToEmpty = 0x61,        /* DV IF - Battery System At Rate Time To Empty */
    kHIDUsage_BS_AverageCurrent = 0x62,            /* DV IF - Battery System Average Current */
    kHIDUsage_BS_Maxerror = 0x63,                /* DV IF - Battery System Max Error */
    kHIDUsage_BS_RelativeStateOfCharge = 0x64,    /* DV IF - Battery System Relative State Of Charge */
    kHIDUsage_BS_AbsoluteStateOfCharge = 0x65,    /* DV IF - Battery System Absolute State Of Charge */
    kHIDUsage_BS_RemainingCapacity = 0x66,        /* DV IF - Battery System Remaining Capacity */
    kHIDUsage_BS_FullChargeCapacity = 0x67,        /* DV IF - Battery System Full Charge Capacity */
    kHIDUsage_BS_RunTimeToEmpty = 0x68,            /* DV IF - Battery System Run Time To Empty */
    kHIDUsage_BS_AverageTimeToEmpty = 0x69,        /* DV IF - Battery System Average Time To Empty */
    kHIDUsage_BS_AverageTimeToFull = 0x6A,        /* DV IF - Battery System Average Time To Full */
    kHIDUsage_BS_CycleCount = 0x6B,                /* DV IF - Battery System Cycle Count */
    /* Reserved 0x6C - 0x7F */
    kHIDUsage_BS_BattPackModelLevel = 0x80,        /* SV F - Battery System Batt Pack Model Level */
    kHIDUsage_BS_InternalChargeController = 0x81, /* SF F - Battery System Internal Charge Controller */
    kHIDUsage_BS_PrimaryBatterySupport = 0x82,    /* SF F - Battery System Primary Battery Support */
    kHIDUsage_BS_DesignCapacity = 0x83,            /* SV F - Battery System Design Capacity */
    kHIDUsage_BS_SpecificationInfo = 0x84,        /* SV F - Battery System Specification Info */
    kHIDUsage_BS_ManufacturerDate = 0x85,        /* SV F - Battery System Manufacturer Date */
    kHIDUsage_BS_SerialNumber = 0x86,            /* SV F - Battery System Serial Number */
    kHIDUsage_BS_iManufacturerName = 0x87,        /* SV F - Battery System Manufacturer Name Index */
    kHIDUsage_BS_iDevicename = 0x88,            /* SV F - Battery System Device Name Index */
    kHIDUsage_BS_iDeviceChemistry = 0x89,        /* SV F - Battery System Device Chemistry Index */
    kHIDUsage_BS_ManufacturerData = 0x8A,        /* SV F - Battery System Manufacturer Data */
    kHIDUsage_BS_Rechargable = 0x8B,            /* SV F - Battery System Rechargable */
    kHIDUsage_BS_WarningCapacityLimit = 0x8C,    /* SV F - Battery System Warning Capacity Limit */
    kHIDUsage_BS_CapacityGranularity1 = 0x8D,    /* SV F - Battery System Capacity Granularity 1 */
    kHIDUsage_BS_CapacityGranularity2 = 0x8E,    /* SV F - Battery System Capacity Granularity 2 */
    kHIDUsage_BS_iOEMInformation = 0x8F,        /* SV F - Battery System OEM Information Index */
    /* Reserved 0x90 - 0xBF */
    kHIDUsage_BS_InhibitCharge = 0xC0,            /* DF IOF - Battery System Inhibit Charge */
    kHIDUsage_BS_EnablePolling = 0xC1,            /* DF IOF - Battery System Enable Polling */
    kHIDUsage_BS_ResetToZero = 0xC2,            /* DF IOF - Battery System Reset To Zero */
    /* Reserved 0xC3 - 0xCF */
    kHIDUsage_BS_ACPresent = 0xD0,                /* DF IOF - Battery System AC Present */
    kHIDUsage_BS_BatteryPresent = 0xD1,            /* DF IOF - Battery System Battery Present */
    kHIDUsage_BS_PowerFail = 0xD2,                /* DF IOF - Battery System Power Fail */
    kHIDUsage_BS_AlarmInhibited = 0xD3,            /* DF IOF - Battery System Alarm Inhibited */
    kHIDUsage_BS_ThermistorUnderRange = 0xD4,    /* DF IOF - Battery System Thermistor Under Range */
    kHIDUsage_BS_ThermistorHot = 0xD5,            /* DF IOF - Battery System Thermistor Hot */
    kHIDUsage_BS_ThermistorCold = 0xD6,            /* DF IOF - Battery System Thermistor Cold */
    kHIDUsage_BS_ThermistorOverRange = 0xD7,    /* DF IOF - Battery System Thermistor Over Range */
    kHIDUsage_BS_VoltageOutOfRange = 0xD8,        /* DF IOF - Battery System Voltage Out Of Range */
    kHIDUsage_BS_CurrentOutOfRange = 0xD9,        /* DF IOF - Battery System Current Out Of Range */
    kHIDUsage_BS_CurrentNotRegulated = 0xDA,    /* DF IOF - Battery System Current Not Regulated */
    kHIDUsage_BS_VoltageNotRegulated = 0xDB,    /* DF IOF - Battery System Voltage Not Regulated */
    kHIDUsage_BS_MasterMode = 0xDC,                /* DF IOF - Battery System Master Mode */
    /* Reserved 0xDD - 0xEF */
    kHIDUsage_BS_ChargerSelectorSupport = 0xF0,    /* SF F- Battery System Charger Support Selector */
    kHIDUsage_BS_ChargerSpec = 0xF1,            /* SF F- Battery System Charger Specification */
    kHIDUsage_BS_Level2 = 0xF2,                    /* SF F- Battery System Charger Level 2 */
    kHIDUsage_BS_Level3 = 0xF3                    /* SF F- Battery System Charger Level 3 */
    /* Reserved 0xF2 - 0xFF */
};

/* Bar Code Scanner Page (0x8C) */
/* This section provides detailed descriptions of the usages employed by Bar Code Scanner Devices. */
enum
{
    kHIDUsage_BCS_Undefined = 0x00,                     /* Bar Code Scanner Undefined Usage */
    kHIDUsage_BCS_BadgeReader = 0x01,                   /* CA - Bar Code Badge Reader */
    kHIDUsage_BCS_BarCodeScanner = 0x02,                /* CA -Bar Code Scanner */
    kHIDUsage_BCS_DumbBarCodeScanner = 0x03,            /* CA -Dumb Bar Code Scanner  Usage */
    kHIDUsage_BCS_CordlessScannerBase = 0x04,           /* CA -Cordless Base Usage */
    kHIDUsage_BCS_BarCodeScannerCradle = 0x05,          /* CA -Bar Code Scanner Cradle Usage */
    /* Reserved 0x06 - 0x0F */
    kHIDUsage_BCS_AttributeReport = 0x10,               /* CL - Attribute Report */
    kHIDUsage_BCS_SettingsReport = 0x11,                /* CL - Settings Report */
    kHIDUsage_BCS_ScannedDataReport = 0x12,             /* CL - Scanned Data Report */
    kHIDUsage_BCS_RawScannedDataReport = 0x13,          /* CL - Raw Scanned Data Report */
    kHIDUsage_BCS_TriggerReport = 0x14,                 /* CL - Trigger Report */
    kHIDUsage_BCS_StatusReport = 0x15,                  /* CL - Status Report */
    kHIDUsage_BCS_UPC_EANControlReport = 0x16,          /* CL - UPC/EAN Control Report */
    kHIDUsage_BCS_EAN2_3LabelControlReport = 0x17,      /* CL - EAN 2/3 Label Control Report */
    kHIDUsage_BCS_Code39ControlReport = 0x18,           /* CL - Code 39 Control Report */
    kHIDUsage_BCS_Interleaved2of5ControlReport = 0x19,  /* CL - Interleaved 2 of 5 Control Report */
    kHIDUsage_BCS_Standard2of5ControlReport = 0x1A,     /* CL - Standard 2 of 5 Control Report */
    kHIDUsage_BCS_MSIPlesseyControlReport = 0x1B,       /* CL - MSI Plessey Control Report */
    kHIDUsage_BCS_CodabarControlReport = 0x1C,          /* CL - Codabar Control Report */
    kHIDUsage_BCS_Code128ControlReport = 0x1D,          /* CL - Code 128 Control Report */
    kHIDUsage_BCS_Misc1DControlReport = 0x1E,           /* CL - Misc 1D Control Report */
    kHIDUsage_BCS_2DControlReport = 0x1F,               /* CL - 2D Control Report */
    /* Reserved 0x20 - 0x2F */
    kHIDUsage_BCS_Aiming_PointerMide = 0x30,            /* SF - Aiming Pointer Mode */
    kHIDUsage_BCS_BarCodePresentSensor = 0x31,          /* SF - Bar Code Present Sensor */
    kHIDUsage_BCS_Class1ALaser = 0x32,                  /* SF - Class 1A Laser */
    kHIDUsage_BCS_Class2Laser = 0x33,                   /* SF - Class 2 Laser */
    kHIDUsage_BCS_HeaterPresent = 0x34,                 /* SF - Heater Present */
    kHIDUsage_BCS_ContactScanner = 0x35,                /* SF - Contact Scanner */
    kHIDUsage_BCS_ElectronicArticleSurveillanceNotification = 0x36, /* SF - Electronic Article Surveillance Notification */
    kHIDUsage_BCS_ConstantElectronicArticleSurveillance = 0x37, /* SF - Constant Electronic Article Surveillance */
    kHIDUsage_BCS_ErrorIndication = 0x38,               /* SF - Error Indication */
    kHIDUsage_BCS_FixedBeeper = 0x39,                   /* SF - Fixed Beeper */
    kHIDUsage_BCS_GoodDecodeIndication = 0x3A,          /* SF - Good Decode Indication */
    kHIDUsage_BCS_HandsFreeScanning = 0x3B,             /* SF - Hands Free Scanning */
    kHIDUsage_BCS_IntrinsicallySafe = 0x3C,             /* SF - Intrinsically Safe */
    kHIDUsage_BCS_KlasseEinsLaser = 0x3D,               /* SF - Klasse Eins Laser */
    kHIDUsage_BCS_LongRangeScanner = 0x3E,              /* SF - Long Range Scanner */
    kHIDUsage_BCS_MirrorSpeedControl = 0x3F,            /* SF - Mirror Speed Control */
    kHIDUsage_BCS_NotOnFileIndication = 0x40,           /* SF - Not On File Indication */
    kHIDUsage_BCS_ProgrammableBeeper = 0x41,            /* SF - Programmable Beeper */
    kHIDUsage_BCS_Triggerless = 0x42,                   /* SF - Triggerless */
    kHIDUsage_BCS_Wand = 0x43,                          /* SF - Wand */
    kHIDUsage_BCS_WaterResistant = 0x44,                /* SF - Water Resistant */
    kHIDUsage_BCS_MultiRangeScanner = 0x45,             /* SF - Multi-Range Scanner */
    kHIDUsage_BCS_ProximitySensor = 0x46,               /* SF - Proximity Sensor */
    /* Reserved 0x47 - 0x4C */
    kHIDUsage_BCS_FragmentDecoding = 0x4D,              /* DF - Fragment Decoding */
    kHIDUsage_BCS_ScannerReadConfidence = 0x4E,         /* DV - Scanner Read Confidence */
    kHIDUsage_BCS_DataPrefix = 0x4F,                    /* NAry - Data Prefix  */
    kHIDUsage_BCS_PrefixAIMI = 0x50,                    /* SEL - Prefix AIMI */
    kHIDUsage_BCS_PrefixNone = 0x51,                    /* SEL - Prefix None */
    kHIDUsage_BCS_PrefixProprietary = 0x52,             /* SEL - Prefix Proprietary */
    /* Reserved 0x53 - 0x54 */
    kHIDUsage_BCS_ActiveTime = 0x55,                    /* DV - Active Time */
    kHIDUsage_BCS_AimingLaserPattern = 0x56,            /* DF - Aiming Laser Pattern */
    kHIDUsage_BCS_BarCodePresent = 0x57,                /* OOC - Bar Code Present */
    kHIDUsage_BCS_BeeperState = 0x58,                   /* OOC - Beeper State */
    kHIDUsage_BCS_LaserOnTime = 0x59,                   /* DV - Laser On Time */
    kHIDUsage_BCS_LaserState = 0x5A,                    /* OOC - Laser State */
    kHIDUsage_BCS_LockoutTime = 0x5B,                   /* DV - Lockout Time */
    kHIDUsage_BCS_MotorState = 0x5C,                    /* OOC - Motor State */
    kHIDUsage_BCS_MotorTimeout = 0x5D,                  /* DV - Motor Timeout */
    kHIDUsage_BCS_PowerOnResetScanner = 0x5E,           /* DF - Power On Reset Scanner */
    kHIDUsage_BCS_PreventReadOfBarcodes = 0x5F,         /* DF - Prevent Read of Barcodes */
    kHIDUsage_BCS_InitiateBarcodeRead = 0x60,           /* DF - Initiate Barcode Read */
    kHIDUsage_BCS_TriggerState = 0x61,                  /* DF - Trigger State */
    kHIDUsage_BCS_TriggerMode = 0x62,                   /* NAry - Trigger Mode */
    kHIDUsage_BCS_TriggerModeBlinkingLaserOn = 0x63,    /* SEL - Trigger Mode Blinking Laser On */
    kHIDUsage_BCS_TriggerModeContinuousLaserOn = 0x64,  /* SEL - Trigger Mode Continuous Laser On */
    kHIDUsage_BCS_TriggerModeLaserOnWhilePulled = 0x65, /* SEL - Trigger Mode Laser on while Pulled */
    kHIDUsage_BCS_TriggerModeLaserStaysOnAfterTriggerRelease = 0x66, /* SEL - Trigger Mode Laser stays on after Trigger Release */
    /* Reserved 0x67 - 0x6C */
    kHIDUsage_BCS_CommitParametersToNVM = 0x6D,         /* DF - Commit Parameters to NVM */
    kHIDUsage_BCS_ParameterScanning = 0x6E,             /* DF - Parameter Scanning */
    kHIDUsage_BCS_ParametersChanged = 0x6F,             /* OOC - Parameters Changed */
    kHIDUsage_BCS_SetParameterDefaultValues = 0x70,     /* DF - Set parameter default values */
    /* Reserved 0x71 - 0x74 */
    kHIDUsage_BCS_ScannerInCradle = 0x75,               /* OOC - Scanner In Cradle */
    kHIDUsage_BCS_ScannerInRange = 0x76,                /* OOC - Scanner In Range */
    /* Reserved 0x77 - 0x79 */
    kHIDUsage_BCS_AimDuration = 0x7A,                   /* DV - Aim Duration */
    kHIDUsage_BCS_GoodReadLampDuration = 0x7B,          /* DV - Good Read Lamp Duration */
    kHIDUsage_BCS_GoodReadLampIntensity = 0x7C,         /* DV - Good Read Lamp Intensity */
    kHIDUsage_BCS_GoodReadLED = 0x7D,                   /* DF - Good Read LED */
    kHIDUsage_BCS_GoodReadToneFrequency = 0x7E,         /* DV - Good Read Tone Frequency*/
    kHIDUsage_BCS_GoodReadToneLength = 0x7F,            /* DV - Good Read Tone Length */
    kHIDUsage_BCS_GoodReadToneVolume = 0x80,            /* DV - Good Read Tone Volume */
    /* Reserved 0x81 */
    kHIDUsage_BCS_NoReadMessage = 0x82,                 /* DF - No Read Message */
    kHIDUsage_BCS_NotOnFileVolume = 0x83,               /* DV - Not on File Volume */
    kHIDUsage_BCS_PowerupBeep = 0x84,                   /* DF - Powerup Beep */
    kHIDUsage_BCS_SoundErrorBeep = 0x85,               /* DF - Sound Error Beep */
    kHIDUsage_BCS_SoundGoodReadBeep = 0x86,             /* DF - Sound Good Read Beep */
    kHIDUsage_BCS_SoundNotOnFileBeep = 0x87,            /* DF - Sound Not On File Beep */
    kHIDUsage_BCS_GoodReadWhenToWrite = 0x88,           /* NArry - Good Read When to Write */
    kHIDUsage_BCS_GRWTIAfterDecode = 0x89,              /* SEL - GRWTI After Decode */
    kHIDUsage_BCS_GRWTIBeep_LampAfterTransmit = 0x8A,   /* SEL - GRWTI Beep/Lamp after transmit */
    kHIDUsage_BCS_GRWTINoBeep_LampUseAtAll = 0x8B,      /* SEL - GRWTI No Beep/Lamp at all */
    /* Reserved 0x8C - 0x90 */
    kHIDUsage_BCS_BooklandEAN = 0x91,                   /* DF - Bookland EAN */
    kHIDUsage_BCS_ConvertEAN8To13Type = 0x92,           /* DF - Convert EAN 8 to 13 Type */
    kHIDUsage_BCS_ConvertUPCAToEAN_13 = 0x93,           /* DF - Convert UPC A to EAN-13 */
    kHIDUsage_BCS_ConvertUPC_EToA = 0x94,               /* DF - Convert UPC-E to A */
    kHIDUsage_BCS_EAN_13 = 0x95,                        /* DF - EAN-13 */
    kHIDUsage_BCS_EAN_8 = 0x96,                         /* DF - EAN_8 */
    kHIDUsage_BCS_EAN_99_128_Mandatory  = 0x97,         /* DF - EAN-99 128_Mandatory  */
    kHIDUsage_BCS_EAN_99_P5_128_Optional = 0x98,        /* DF - EAN-99 P5/128_Optional */
    /* Reserved 0x99 */
    kHIDUsage_BCS_UPC_EAN = 0x9A,                       /* DF - UPC/EAN */
    kHIDUsage_BCS_UPC_EANCouponCode = 0x9B,             /* DF - UPC/EAN Coupon Code */
    kHIDUsage_BCS_UPC_EANPeriodicals = 0x9C,            /* DV - UPC/EAN Periodicals */
    kHIDUsage_BCS_UPC_A = 0x9D,                         /* DF - UPC-A */
    kHIDUsage_BCS_UPC_AWith128Mandatory = 0x9E,         /* DF - UPC-A with 128 Mandatory */
    kHIDUsage_BCS_UPC_AWith128Optical = 0x9F,           /* DF - UPC-A with 128 Optical */
    kHIDUsage_BCS_UPC_AWithP5Optional = 0xA0,           /* DF - UPC-A with P5 Optional */
    kHIDUsage_BCS_UPC_E = 0xA1,                         /* DF - UPC-E */
    kHIDUsage_BCS_UPC_E1 = 0xA2,                        /* DF - UPC-E1 */
    /* Reserved 0xA3 - 0xA8 */
    kHIDUsage_BCS_Periodical = 0xA9,                    /* NArry - Periodical */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus2 = 0xAA,/* SEL - Periodical Auto-Discriminate + 2 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus2 = 0xAB, /* SEL - Periodical Only Decode with + 2 */
    kHIDUsage_BCS_PeriodicalIgnorePlus2 = 0xAC,         /* SEL - Periodical Ignore + 2 */
    kHIDUsage_BCS_PeriodicalAutoDiscriminatePlus5 = 0xAD,/* SEL - Periodical Auto-Discriminate + 5 */
    kHIDUsage_BCS_PeriodicalOnlyDecodeWithPlus5 = 0xAE, /* SEL - Periodical Only Decode with + 5 */
    kHIDUsage_BCS_PeriodicalIgnorePlus5 = 0xAF,         /* SEL - Periodical Ignore + 5 */
    kHIDUsage_BCS_Check = 0xB0,                         /* NArry - Check */
    kHIDUsage_BCS_CheckDisablePrice = 0xB1,             /* SEL - Check Disable Price */
    kHIDUsage_BCS_CheckEnable4DigitPrice = 0xB2,        /* SEL - Check Enable 4 digit Price */
    kHIDUsage_BCS_CheckEnable5DigitPrice = 0xB3,        /* SEL - Check Enable 5 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean4DigitPrice = 0xB4,/* SEL - Check Enable European 4 digit Price */
    kHIDUsage_BCS_CheckEnableEuropean5DigitPrice = 0xB5,/* SEL - Check Enable European 5 digit Price */
    /* Reserved 0xB6 */
    kHIDUsage_BCS_EANTwoLabel = 0xB7,                   /* DF - EAN Two Label  */
    kHIDUsage_BCS_EANThreeLabel  = 0xB8,                /* DF - EAN Thread Label */
    kHIDUsage_BCS_EAN8FlagDigit1 = 0xB9,                /* DV - EAN 8 Flag Digit 1 */
    kHIDUsage_BCS_EAN8FlagDigit2 = 0xBA,                /* DV - EAN 8 Flag Digit 2 */
    kHIDUsage_BCS_EAN8FlagDigit3 = 0xBB,                /* DV - EAN 8 Flag Digit 3 */
    kHIDUsage_BCS_EAN13FlagDigit1 = 0xBC,               /* DV - EAN 13 Flag Digit 1 */
    kHIDUsage_BCS_EAN13FlagDigit2 = 0xBD,               /* DV - EAN 13 Flag Digit 2 */
    kHIDUsage_BCS_EAN13FlagDigit3 = 0xBE,               /* DV - EAN 13 Flag Digit 3 */
    kHIDUsage_BCS_AddEAN2_3LabelDefinition = 0xBF,      /* DF - Add EAN 2/3 Label Definition */
    kHIDUsage_BCS_ClearAllEAN2_3LabelDefinitions = 0xC0,/* DF - Clear all EAN 2/3 Label Definitions */
    /* Reserved 0xC1 - 0xC2 */
    kHIDUsage_BCS_Codabar = 0xC3,                       /* DF - Codabar */
    kHIDUsage_BCS_Code128 = 0xC4,                       /* DF - Code 128 */
    /* Reserved 0xC5 - 0xC6 */
    kHIDUsage_BCS_Code39 = 0xC7,                        /* DF - Code 39 */
    kHIDUsage_BCS_Code93 = 0xC8,                        /* DF - Code 93 */
    kHIDUsage_BCS_FullASCIIConversion = 0xC9,           /* DF - Full ASCII Conversion */
    kHIDUsage_BCS_Interleaved2of5 = 0xCA,               /* DF - Interleaved 2 of 5 */
    kHIDUsage_BCS_ItalianPharmacyCode = 0xCB,           /* DF - Italian Pharmacy Code */
    kHIDUsage_BCS_MSI_Plessey = 0xCC,                   /* DF - MSI/Plessey */
    kHIDUsage_BCS_Standard2of5IATA = 0xCD,              /* DF - Standard 2 of 5 IATA */
    kHIDUsage_BCS_Standard2of5 = 0xCE,                  /* DF - Standard 2 of 5 */
    /* Reserved 0xCF - 0xD2 */
    kHIDUsage_BCS_TransmitStart_Stop = 0xD3,            /* DF - Transmit Start/Stop */
    kHIDUsage_BCS_TriOptic = 0xD4,                      /* DF - Tri-Optic  */
    kHIDUsage_BCS_UCC_EAN_128 = 0xD5,                   /* DF - UCC/EAN-128  */
    kHIDUsage_BCS_CheckDigit = 0xD6,                    /* NArry - Check Digit */
    kHIDUsage_BCS_CheckDigitDisable = 0xD7,             /* SEL - Check Digit Disable */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5OPCC = 0xD8, /* SEL - Check Digit Enable Interleaved 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableInterleaved2of5USS = 0xD9, /* SEL - Check Digit Enable Interleaved 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5OPCC = 0xD8, /* SEL - Check Digit Enable Standard 2 of 5 OPCC */
    kHIDUsage_BCS_CheckDigitEnableStandard2of5USS = 0xD9, /* SEL - Check Digit Enable Standard 2 of 5 USS */
    kHIDUsage_BCS_CheckDigitEnableOneMSIPlessey = 0xDC, /* SEL - Check Digit Enable One MSI Plessey */
    kHIDUsage_BCS_CheckDigitEnableTwoMSIPlessey = 0xDD, /* SEL - Check Digit Enable Two MSI Plessey */
    kHIDUsage_BCS_CheckDigitCodabarEnable = 0xDE,       /* SEL - Check Digit Codabar Enable */
    kHIDUsage_BCS_CheckDigitCode99Enable = 0xDF,        /* SEL - Check Digit Code 99 Enable */
    /* Reserved 0xE0 - 0xEF */
    kHIDUsage_BCS_TransmitCheckDigit = 0xF0,            /* NArry - Transmit Check Digit */
    kHIDUsage_BCS_DisableCheckDigitTransmit = 0xF1,     /* SEL - Disable Check Digit Transmit */
    kHIDUsage_BCS_EnableCheckDigitTransmit = 0xF2,      /* SEL - Enable Check Digit Transmit */
    /* Reserved 0xF3 - 0xFA */
    kHIDUsage_BCS_SymbologyIdentifier1 = 0xFB,          /* DV - Symbology Identifier 1 */
    kHIDUsage_BCS_SymbologyIdentifier2 = 0xFC,          /* DV - Symbology Identifier 2 */
    kHIDUsage_BCS_SymbologyIdentifier3 = 0xFD,          /* DV - Symbology Identifier 3 */
    kHIDUsage_BCS_DecodedData = 0xFE,                   /* DV - Decoded Data */
    kHIDUsage_BCS_DecodeDataContinued = 0xFF,           /* DF - Decode Data Continued */
    kHIDUsage_BCS_BarSpaceData = 0x100,                 /* DV - Bar Space Data */
    kHIDUsage_BCS_ScannerDataAccuracy = 0x101,          /* DV - Scanner Data Accuracy */
    kHIDUsage_BCS_RawDataPolarity = 0x102,              /* NArry - Raw Data Polarity */
    kHIDUsage_BCS_PolarityInvertedBarCode = 0x103,      /* SEL - Polarity Inverted Bar Code */
    kHIDUsage_BCS_PolarityNormalBarCode = 0x103,        /* SEL - Polarity Normal Bar Code */
    /* Reserved 0x105 */
    kHIDUsage_BCS_MinimumLengthToDecode = 0x106,        /* DV - Minimum Length to Decode */
    kHIDUsage_BCS_MaximumLengthToDecode = 0x107,        /* DV - Maximum Length to Decode */
    kHIDUsage_BCS_FirstDiscreteLengthToDecode = 0x108,  /* DV - First Discrete Length to Decode */
    kHIDUsage_BCS_SecondDiscreteLengthToDecode = 0x109, /* DV - Second Discrete Length to Decode */
    kHIDUsage_BCS_DataLengthMethod = 0x10A,             /* NArry - Data Length Method */
    kHIDUsage_BCS_DLMethodReadAny = 0x10B,              /* DF - DL Method Read any */
    kHIDUsage_BCS_DLMethodCheckInRange = 0x10C,         /* DF - DL Method Check in Range */
    kHIDUsage_BCS_DLMethodCheckForDiscrete = 0x10D,     /* DF - DL Method Check for Discrete */
    /* Reserved 0x10E - 0x10F */
    kHIDUsage_BCS_AztecCode = 0x110,                    /* DF - Aztec Code */
    kHIDUsage_BCS_BC412 = 0x111,                        /* DF - BC412 */
    kHIDUsage_BCS_ChannelCode = 0x112,                  /* DF - Channel Code */
    kHIDUsage_BCS_Code16 = 0x113,                       /* DF - Code 16 */
    kHIDUsage_BCS_Code32 = 0x114,                       /* DF - Code 32 */
    kHIDUsage_BCS_Code49 = 0x115,                       /* DF - Code 49 */
    kHIDUsage_BCS_CodeOne = 0x116,                      /* DF - Code One */
    kHIDUsage_BCS_Colorcode = 0x117,                    /* DF - Colorcode */
    kHIDUsage_BCS_DataMatrix = 0x118,                   /* DF - Data Matrix */
    kHIDUsage_BCS_MaxiCode = 0x119,                     /* DF - MaxiCode */
    kHIDUsage_BCS_MicroPDF = 0x11A,                     /* DF - MicroPDF */
    kHIDUsage_BCS_PDF_417 = 0x11B,                      /* DF - PDF-417 */
    kHIDUsage_BCS_PosiCode = 0x11C,                     /* DF - PosiCode */
    kHIDUsage_BCS_QRCode = 0x11D,                       /* DF - QR Code */
    kHIDUsage_BCS_SuperCode = 0x11E,                    /* DF - SuperCode */
    kHIDUsage_BCS_UltraCode = 0x11F,                    /* DF - UltraCode */
    kHIDUsage_BCS_USB_5_SlugCode = 0x120,               /* DF - USD-5 (Slug Code) */
    kHIDUsage_BCS_VeriCode = 0x121                      /* DF - VeriCode */
    /* Reserved 0x122 - 0xFFFF */
};

/* Weighing Devices Page (0x8D) */
/* This section provides detailed descriptions of the usages employed by Weighing Devices. */
enum
{
    kHIDUsage_WD_Undefined = 0x00,                      /* Weighing Device Undefined Usage */
    kHIDUsage_WD_WeighingDevice = 0x01,                 /* CA - Weighing Device */
    /* Reserved 0x02 - 0x1F */
    kHIDUsage_WD_ScaleScaleDevice = 0x20,               /* CL - Scale Device */
    kHIDUsage_WD_ScaleScaleClassIMetricCL = 0x21,       /* CL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIMetric = 0x22,         /* SEL - Scale Class I Metric */
    kHIDUsage_WD_ScaleScaleClassIIMetric = 0x23,        /* SEL - Scale Class II Metric */
    kHIDUsage_WD_ScaleScaleClassIIIMetric = 0x24,       /* SEL - Scale Class III Metric */
    kHIDUsage_WD_ScaleScaleClassIIILMetric = 0x25,      /* SEL - Scale Class IIIL Metric */
    kHIDUsage_WD_ScaleScaleClassIVMetric = 0x26,        /* SEL - Scale Class IV Metric */
    kHIDUsage_WD_ScaleScaleClassIIIEnglish = 0x27,      /* SEL - Scale Class III English */
    kHIDUsage_WD_ScaleScaleClassIIILEnglish = 0x28,     /* SEL - Scale Class IIIL English */
    kHIDUsage_WD_ScaleScaleClassIVEnglish = 0x29,       /* SEL - Scale Class IV English */
    kHIDUsage_WD_ScaleScaleClassGeneric = 0x2A,         /* SEL - Scale Class Generic */
    /* Reserved 0x2B - 0x2F */
    kHIDUsage_WD_ScaleAtrributeReport = 0x30,           /* CL - Scale Attribute Report */
    kHIDUsage_WD_ScaleControlReport = 0x31,             /* CL - Scale Control Report */
    kHIDUsage_WD_ScaleDataReport = 0x32,                /* CL - Scale Data Report */
    kHIDUsage_WD_ScaleStatusReport = 0x33,              /* CL - Scale Status Report */
    kHIDUsage_WD_ScaleWeightLimitReport = 0x34,         /* CL - Scale Weight Limit Report */
    kHIDUsage_WD_ScaleStatisticsReport = 0x35,          /* CL - Scale Statistics Report */
    /* Reserved 0x36 - 0x3F */
    kHIDUsage_WD_DataWeight = 0x40,                     /* DV - Data Weight */
    kHIDUsage_WD_DataScaling = 0x41,                    /* DV - Data Scaling */
    /* Reserved 0x42 - 0x4F */
    kHIDUsage_WD_WeightUnit = 0x50,                     /* CL - Weight Unit */
    kHIDUsage_WD_WeightUnitMilligram = 0x51,            /* SEL - Weight Unit Milligram */
    kHIDUsage_WD_WeightUnitGram = 0x52,                 /* SEL - Weight Unit Gram */
    kHIDUsage_WD_WeightUnitKilogram = 0x53,             /* SEL - Weight Unit Kilogram */
    kHIDUsage_WD_WeightUnitCarats = 0x54,               /* SEL - Weight Unit Carats */
    kHIDUsage_WD_WeightUnitTaels = 0x55,                /* SEL - Weight Unit Taels */
    kHIDUsage_WD_WeightUnitGrains = 0x56,               /* SEL - Weight Unit Grains */
    kHIDUsage_WD_WeightUnitPennyweights = 0x57,         /* SEL - Weight Unit Pennyweights */
    kHIDUsage_WD_WeightUnitMetricTon = 0x58,            /* SEL - Weight Unit Metric Ton */
    kHIDUsage_WD_WeightUnitAvoirTon = 0x59,             /* SEL - Weight Unit Avoir Ton */
    kHIDUsage_WD_WeightUnitTroyOunce = 0x5A,            /* SEL - Weight Unit Troy Ounce */
    kHIDUsage_WD_WeightUnitOunce = 0x5B,                /* SEL - Weight Unit Ounce */
    kHIDUsage_WD_WeightUnitPound = 0x5C,                /* SEL - Weight Unit Pound */
    /* Reserved 0x5D - 0x5F */
    kHIDUsage_WD_CalibrationCount = 0x60,               /* DV - Calibration Count */
    kHIDUsage_WD_RezeroCount = 0x61,                    /* DV - Re-Zero Count*/
    /* Reserved 0x62 - 0x6F */
    kHIDUsage_WD_ScaleStatus = 0x70,                    /* CL - Scale Status */
    kHIDUsage_WD_ScaleStatusFault = 0x71,               /* SEL - Scale Status Fault */
    kHIDUsage_WD_ScaleStatusStableAtZero = 0x72,        /* SEL - Scale Status Stable at Center of  Zero */
    kHIDUsage_WD_ScaleStatusInMotion = 0x73,            /* SEL - Scale Status In Motion */
    kHIDUsage_WD_ScaleStatusWeightStable = 0x74,        /* SEL - Scale Status Weight Stable */
    kHIDUsage_WD_ScaleStatusUnderZero = 0x75,           /* SEL - Scale Status Under Zero */
    kHIDUsage_WD_ScaleStatusOverWeightLimit = 0x76,     /* SEL - Scale Status Over Weight Limit */
    kHIDUsage_WD_ScaleStatusRequiresCalibration = 0x77, /* SEL - Scale Status Requires Calibration */
    kHIDUsage_WD_ScaleStatusRequiresRezeroing = 0x78,   /* SEL - Scale Status Requires Re-zeroing */
    /* Reserved 0x79 - 0x7F */
    kHIDUsage_WD_ZeroScale = 0x80,                      /* OOC - Zero Scale */
    kHIDUsage_WD_EnforcedZeroReturn = 0x81              /* OOC - Enforced Zero Return */
    /* Reserved 0x82 - 0xFFFF */
    
};

/* Magnetic Stripe Reader Page (0x8E) */
/* This section provides detailed descriptions of the usages employed by Magnetic Stripe Reader Devices. */
enum 
{
    kHIDUsage_MSR_Undefined = 0x00,                     /* MagStripe Undefined Usage */
    kHIDUsage_MSR_DeviceReadOnly = 0x01,                /* CA - MSR Device Read-Only */
    /* Reserved 0x02 - 0x10 */
    kHIDUsage_MSR_Track1Length = 0x11,                     /* SF, DF, SEL - Track 1 Length */
    kHIDUsage_MSR_Track2Length = 0x12,                     /* SF, DF, SEL - Track 2 Length */
    kHIDUsage_MSR_Track3Length = 0x13,                     /* SF, DF, SEL - Track 3 Length */
    kHIDUsage_MSR_TrackJISLength = 0x14,                   /* SF, DF, SEL - Track JIS Length */
    /* Reserved 0x15 - 0x1F */
    kHIDUsage_MSR_TrackData = 0x20,                        /* SF, DF, SEL - Track Data */
    kHIDUsage_MSR_Track1Data = 0x21,                       /* SF, DF, SEL - Track 1 Data */
    kHIDUsage_MSR_Track2Data = 0x22,                       /* SF, DF, SEL - Track 2 Data */
    kHIDUsage_MSR_Track3Data = 0x23,                       /* SF, DF, SEL - Track 3 Data */
    kHIDUsage_MSR_TrackJISData = 0x24                      /* SF, DF, SEL - Track JIS Data */
    /* Reserved 0x25 - 0xFFFF */
};

#endif /* _IOHIDUSAGETABLES_H */
                                                                                                                                                                                                                       IOHIDValue.h                                                                                        0100644 0001750 0001750 00000023252 12566177313 033360  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hid                                                                   /*
 * Copyright (c) 1999-2008 Apple Computer, Inc.  All Rights Reserved.
 * 
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_HID_IOHIDELEMENTEVENT_H
#define _IOKIT_HID_IOHIDELEMENTEVENT_H

#include <CoreFoundation/CoreFoundation.h>
#include <IOKit/hid/IOHIDBase.h>
#include <IOKit/hid/IOHIDKeys.h>

/*!
	@header IOHIDValue
    IOHIDValue defines a value at a given time from an parsed item 
    (IOHIDElement) contained within a Human Interface Device (HID) object.  It 
    is used to obtain either integer or data element values along with scaled 
    values based on physical or calibrated settings. IOHIDValue is a CFType 
    object and as such conforms to all the conventions expected such object.
    <p>
    This documentation assumes that you have a basic understanding of the material contained in <a href="http://developer.apple.com/documentation/DeviceDrivers/Conceptual/AccessingHardware/index.html"><i>Accessing Hardware From Applications</i></a>
    For definitions of I/O Kit terms used in this documentation, such as matching dictionary, family, and driver, see the overview of I/O Kit terms and concepts 
    in the "Device Access and the I/O Kit" chapter of <i>Accessing Hardware From Applications</i>.

    This documentation also assumes you have read <a href="http://developer.apple.com/documentation/DeviceDrivers/HumanInterfaceDeviceForceFeedback-date.html"><i>Human Interface Device & Force Feedback</i></a>.
    Please review documentation before using this reference.
    <p>
    All of the information described in this document is contained in the header file <font face="Courier New,Courier,Monaco">IOHIDValue.h</font> found at 
    <font face="Courier New,Courier,Monaco">/System/Library/Frameworks/IOKit.framework/Headers/hid/IOHIDValue.h</font>.
*/

__BEGIN_DECLS

/*!
	@function   IOHIDValueGetTypeID
	@abstract   Returns the type identifier of all IOHIDValue instances.
*/
CF_EXPORT
CFTypeID IOHIDValueGetTypeID(void)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueCreateWithIntegerValue
	@abstract   Creates a new element value using an integer value.
    @discussion IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime.
                To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    @param      allocator The CFAllocator which should be used to allocate memory for the value.  This 
                parameter may be NULL in which case the current default CFAllocator is used. If this 
                reference is not a valid CFAllocator, the behavior is undefined.
    @param      element IOHIDElementRef associated with this value.
    @param      timeStamp OS absolute time timestamp for this value.
    @param      value Integer value to be copied to this object.
    @result     Returns a reference to a new IOHIDValueRef.
*/
CF_EXPORT
IOHIDValueRef IOHIDValueCreateWithIntegerValue(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, CFIndex value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueCreateWithBytes
	@abstract   Creates a new element value using byte data.
    @discussion IOHIDValueGetTimeStamp should represent OS AbsoluteTime, not CFAbsoluteTime.
                To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    @param      allocator The CFAllocator which should be used to allocate memory for the value.  This 
                parameter may be NULL in which case the current default CFAllocator is used. If this 
                reference is not a valid CFAllocator, the behavior is undefined.
    @param      element IOHIDElementRef associated with this value.
    @param      timeStamp OS absolute time timestamp for this value.
    @param      bytes Pointer to a buffer of uint8_t to be copied to this object.
    @param      length Number of bytes in the passed buffer.
    @result     Returns a reference to a new IOHIDValueRef.
*/
CF_EXPORT
IOHIDValueRef IOHIDValueCreateWithBytes(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t * bytes, CFIndex length)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueCreateWithBytesNoCopy
	@abstract   Creates a new element value using byte data without performing a copy.
    @discussion The timestamp value passed should represent OS AbsoluteTime, not CFAbsoluteTime.
                To obtain the OS AbsoluteTime, please reference the APIs declared in <mach/mach_time.h>
    @param      allocator The CFAllocator which should be used to allocate memory for the value.  This 
                parameter may be NULL in which case the current default CFAllocator is used. If this 
                reference is not a valid CFAllocator, the behavior is undefined.
    @param      element IOHIDElementRef associated with this value.
    @param      timeStamp OS absolute time timestamp for this value.
    @param      bytes Pointer to a buffer of uint8_t to be referenced by this object.
    @param      length Number of bytes in the passed buffer.
    @result     Returns a reference to a new IOHIDValueRef.
*/
CF_EXPORT
IOHIDValueRef IOHIDValueCreateWithBytesNoCopy(CFAllocatorRef allocator, IOHIDElementRef element, uint64_t timeStamp, const uint8_t * bytes, CFIndex length)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetElement
	@abstract   Returns the element value associated with this IOHIDValueRef.
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @result     Returns a IOHIDElementRef referenced by this value.
*/
CF_EXPORT
IOHIDElementRef IOHIDValueGetElement(IOHIDValueRef value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetTimeStamp
	@abstract   Returns the timestamp value contained in this IOHIDValueRef.
    @discussion The timestamp value returned represents OS AbsoluteTime, not CFAbsoluteTime.
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @result     Returns a uint64_t representing the timestamp of this value.
*/
CF_EXPORT
uint64_t IOHIDValueGetTimeStamp(IOHIDValueRef value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetLength
	@abstract   Returns the size, in bytes, of the value contained in this IOHIDValueRef.
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @result     Returns length of the value.
*/
CF_EXPORT
CFIndex IOHIDValueGetLength(IOHIDValueRef value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetBytePtr
	@abstract   Returns a byte pointer to the value contained in this IOHIDValueRef.
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @result     Returns a pointer to the value.
*/
CF_EXPORT
const uint8_t * IOHIDValueGetBytePtr(IOHIDValueRef value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetIntegerValue
	@abstract   Returns an integer representaion of the value contained in this IOHIDValueRef.
    @discussion The value is based on the logical element value contained in the report returned by the device.
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @result     Returns an integer representation of the value.
*/
CF_EXPORT
CFIndex IOHIDValueGetIntegerValue(IOHIDValueRef value)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

/*!
	@function   IOHIDValueGetScaledValue
	@abstract   Returns an scaled representaion of the value contained in this IOHIDValueRef based on the scale type.
    @discussion The scaled value is based on the range described by the scale type's min and max, such that:
        <br>
        scaledValue = ((value - min) * (scaledMax - scaledMin) / (max - min)) + scaledMin
        <br>
        <b>Note:</b>
        <br>
        There are currently two types of scaling that can be applied:  
        <ul>
        <li><b>kIOHIDValueScaleTypePhysical</b>: Scales element value using the physical bounds of the device such that <b>scaledMin = physicalMin</b> and <b>scaledMax = physicalMax</b>.
        <li><b>kIOHIDValueScaleTypeCalibrated</b>: Scales element value such that <b>scaledMin = -1</b> and <b>scaledMax = 1</b>.  This value will also take into account the calibration properties associated with this element.
        </ul>
    @param      value The value to be queried. If this parameter is not a valid IOHIDValueRef, the behavior is undefined.
    @param      type The type of scaling to be performed.
    @result     Returns an scaled floating point representation of the value.
*/
CF_EXPORT
double_t IOHIDValueGetScaledValue(IOHIDValueRef value, IOHIDValueScaleType type)
AVAILABLE_MAC_OS_X_VERSION_10_5_AND_LATER;

__END_DECLS

#endif /* _IOKIT_HID_IOHIDELEMENTEVENT_H */
                                                                                                                                                                                                                                                                                                                                                      hidsystem/                                                                                          0040755 0001750 0001750 00000000000 12612224741 032610  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOHIDLib.h                                                                                          0100644 0001750 0001750 00000011364 12566177313 034260  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * Copyright (c) 1999-2009 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1999 Apple Computer, Inc.  All rights reserved.
 *
 * HISTORY
 *
 */

#ifndef _IOKIT_IOHIDLIB_H
#define _IOKIT_IOHIDLIB_H

#include <IOKit/hidsystem/IOHIDShared.h>
#include <sys/cdefs.h>

__BEGIN_DECLS

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

extern kern_return_t
IOHIDCreateSharedMemory( io_connect_t connect,
	unsigned int version );

extern kern_return_t
IOHIDSetEventsEnable( io_connect_t connect,
	boolean_t enable );

extern kern_return_t
IOHIDSetCursorEnable( io_connect_t connect,
	boolean_t enable );

enum {
    // Options for IOHIDPostEvent()
    kIOHIDSetGlobalEventFlags       = 0x00000001,
    kIOHIDSetCursorPosition         = 0x00000002,
    kIOHIDSetRelativeCursorPosition = 0x00000004,
    kIOHIDPostHIDManagerEvent       = 0x00000008
};

extern kern_return_t
IOHIDPostEvent( io_connect_t        connect,
                UInt32              eventType,
                IOGPoint            location,
                const NXEventData * eventData,
                UInt32              eventDataVersion,
                IOOptionBits        eventFlags,
                IOOptionBits        options );

extern kern_return_t
IOHIDSetMouseLocation( io_connect_t connect,
	int x, int y);

extern kern_return_t
IOHIDGetButtonEventNum( io_connect_t connect,
	NXMouseButton button, int * eventNum );

extern kern_return_t
IOHIDSetCursorBounds( io_connect_t connect, const IOGBounds * bounds );

extern kern_return_t
IOHIDSetOnScreenCursorBounds( io_connect_t connect, const IOGPoint * point, const IOGBounds * bounds );

extern kern_return_t
IOHIDGetScrollAcceleration( io_connect_t handle, double * acceleration );

extern kern_return_t
IOHIDSetScrollAcceleration( io_connect_t handle, double acceleration );

extern kern_return_t
IOHIDGetMouseAcceleration( io_connect_t handle, double * acceleration );

extern kern_return_t
IOHIDSetMouseAcceleration( io_connect_t handle, double acceleration );

extern kern_return_t
IOHIDGetMouseButtonMode( io_connect_t handle, int * mode );

extern kern_return_t
IOHIDSetMouseButtonMode( io_connect_t handle, int mode );

extern kern_return_t
IOHIDGetAccelerationWithKey( io_connect_t handle, CFStringRef key, double * acceleration );

extern kern_return_t
IOHIDSetAccelerationWithKey( io_connect_t handle, CFStringRef key, double acceleration );

extern kern_return_t
IOHIDGetParameter( io_connect_t handle, CFStringRef key, IOByteCount maxSize, 
		void * bytes, IOByteCount * actualSize );

extern kern_return_t
IOHIDSetParameter( io_connect_t handle, CFStringRef key, 
		const void * bytes, IOByteCount size );

extern kern_return_t
IOHIDCopyCFTypeParameter( io_connect_t handle, CFStringRef key,
                CFTypeRef * parameter );

extern kern_return_t
IOHIDSetCFTypeParameter( io_connect_t handle, CFStringRef key,
                CFTypeRef parameter );

// selectors are found in IOHIDParameter.h
extern kern_return_t
IOHIDGetModifierLockState( io_connect_t handle, int selector, bool *state );

extern kern_return_t
IOHIDSetModifierLockState( io_connect_t handle, int selector, bool state );

extern kern_return_t
IOHIDGetStateForSelector( io_connect_t handle, int selector, UInt32 *state );

extern kern_return_t
IOHIDSetStateForSelector( io_connect_t handle, int selector, UInt32 state );

// Used by Window Server only
extern kern_return_t
IOHIDRegisterVirtualDisplay( io_connect_t handle, UInt32 *display_token );

extern kern_return_t
IOHIDUnregisterVirtualDisplay( io_connect_t handle, UInt32 display_token );

extern kern_return_t
IOHIDSetVirtualDisplayBounds( io_connect_t handle, UInt32 display_token, const IOGBounds * bounds );

extern kern_return_t
IOHIDGetActivityState( io_connect_t handle, bool *hidActivityIdle );

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

__END_DECLS

#endif /* ! _IOKIT_IOHIDLIB_H */

                                                                                                                                                                                                                                                                            IOHIDParameter.h                                                                                    0100644 0001750 0001750 00000030307 12567452123 035464  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved. 
 *
 * evsio.h - Get/Set parameter calls for Event Status Driver.
 *
 *	CAUTION: Developers should stick to the API exported in
 *		<drivers/event_status_driver.h> to guarantee
 *		binary compatability of their applications in future
 *		releases.
 *
 * HISTORY
 * 22 May 1992    Mike Paquette at NeXT
 *      Created. 
 */
#ifndef _DEV_EVSIO_H
#define _DEV_EVSIO_H

/* Public type definitions. */
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hidsystem/IOLLEvent.h>

/*
 * Identify this driver as one that uses the new driverkit and messaging API
 */
#ifndef _NeXT_MACH_EVENT_DRIVER_
#define _NeXT_MACH_EVENT_DRIVER_	(1)
#endif /* !_NeXT_MACH_EVENT_DRIVER_ */

/* * */

#define kIOHIDKindKey					"HIDKind"
#define kIOHIDInterfaceIDKey			"HIDInterfaceID"
#define kIOHIDSubinterfaceIDKey			"HIDSubinterfaceID"
#define kIOHIDOriginalSubinterfaceIDKey "HIDOriginalSubinterfaceID"

#define kIOHIDParametersKey				"HIDParameters"

#define kIOHIDVirtualHIDevice                   "HIDVirtualDevice"

#define kIOHIDKeyRepeatKey				"HIDKeyRepeat"
#define kIOHIDInitialKeyRepeatKey		"HIDInitialKeyRepeat"
#define kIOHIDKeyMappingKey				"HIDKeyMapping"
#define kIOHIDResetKeyboardKey			"HIDResetKeyboard"

#define kIOHIDKeyboardModifierMappingPairsKey   "HIDKeyboardModifierMappingPairs"
#define kIOHIDKeyboardModifierMappingSrcKey     "HIDKeyboardModifierMappingSrc"
#define kIOHIDKeyboardModifierMappingDstKey     "HIDKeyboardModifierMappingDst"

#define kIOHIDKeyboardCapsLockDoesLockKey       "HIDKeyboardCapsLockDoesLock"
#define kIOHIDKeyboardSupportsF12EjectKey       "HIDKeyboardSupportsF12Eject"
#define kIOHIDKeyboardSupportedModifiersKey     "HIDKeyboardSupportedModifiers"

#define kIOHIDPointerResolutionKey		"HIDPointerResolution"
#define kIOHIDResetPointerKey			"HIDResetPointer"
#define kIOHIDPointerConvertAbsoluteKey	"HIDPointerConvertAbsolute"
#define kIOHIDPointerContactToMoveKey	"HIDPointerContactToMove"
#define kIOHIDPointerPressureToClickKey	"HIDPointerPressureToClick"
#define kIOHIDPointerButtonMode			"HIDPointerButtonMode"
#define kIOHIDPointerButtonCountKey	"HIDPointerButtonCount"

#define kIOHIDPointerAccelerationKey	"HIDPointerAcceleration"
#define kIOHIDPointerAccelerationSettingsKey	"HIDPointerAccelerationSettings"
#define kIOHIDPointerAccelerationTypeKey	"HIDPointerAccelerationType"
#define kIOHIDPointerAccelerationTableKey  "HIDPointerAccelerationTable"

#define kIOHIDScrollResetKey			"HIDScrollReset"
#define kIOHIDScrollResolutionKey		"HIDScrollResolution"
#define kIOHIDScrollReportRateKey       "HIDScrollReportRate"
#define kIOHIDScrollAccelerationKey		"HIDScrollAcceleration"
#define kIOHIDScrollAccelerationTypeKey     "HIDScrollAccelerationType"
#define kIOHIDScrollAccelerationTableKey	"HIDScrollAccelerationTable"

#define kIOHIDScrollResolutionXKey		"HIDScrollResolutionX"
#define kIOHIDScrollResolutionYKey		"HIDScrollResolutionY"
#define kIOHIDScrollResolutionZKey		"HIDScrollResolutionZ"

#define kIOHIDScrollAccelerationTableXKey	"HIDScrollAccelerationTableX"
#define kIOHIDScrollAccelerationTableYKey	"HIDScrollAccelerationTableY"
#define kIOHIDScrollAccelerationTableZKey	"HIDScrollAccelerationTableZ"

#define kIOHIDScrollMouseButtonKey      "HIDScrollMouseButton"

#define kIOHIDScrollZoomModifierMaskKey "HIDScrollZoomModifierMask"

#define kIOHIDTrackpadScrollAccelerationKey "HIDTrackpadScrollAcceleration"
#define kIOHIDMouseScrollAccelerationKey   "HIDMouseScrollAcceleration"

#define kIOHIDTrackpadAccelerationType	"HIDTrackpadAcceleration"
#define kIOHIDMouseAccelerationType		"HIDMouseAcceleration"

#define kIOHIDClickTimeKey				"HIDClickTime"
#define kIOHIDClickSpaceKey				"HIDClickSpace"

#define kIOHIDWaitCursorFrameIntervalKey	"HIDWaitCursorFrameInterval"

#define kIOHIDAutoDimThresholdKey		"HIDAutoDimThreshold"
#define kIOHIDAutoDimStateKey			"HIDAutoDimState"
#define kIOHIDAutoDimTimeKey			"HIDAutoDimTime"
#define kIOHIDIdleTimeKey				"HIDIdleTime"

#define kIOHIDBrightnessKey				"HIDBrightness"
#define kIOHIDAutoDimBrightnessKey		"HIDAutoDimBrightness"

#define kIOHIDFKeyModeKey			"HIDFKeyMode"

// if kIOHIDStickyKeysDisabledKey is 1, then all sticky keys functionality
// is completely turned off. Multiple shifts will have no effect.
#define kIOHIDStickyKeysDisabledKey		"HIDStickyKeysDisabled"

// if kIOHIDStickyKeysOnKey is 1 then a depressed modifier will stay down
// until a non-modifer key is pressed (or sticky keys is turned off)
#define kIOHIDStickyKeysOnKey			"HIDStickyKeysOn"

// if kIOHIDStickyKeysShiftTogglesKey is 1, then a sequence of five
// shift keys in sequence will toggle sticky keys on or off
#define kIOHIDStickyKeysShiftTogglesKey	"HIDStickyKeysShiftToggles"

// if kIOHIDMouseKeysOptionTogglesKey is 1, then a sequence of five
// option keys in sequence will toggle mouse keys on or off
#define kIOHIDMouseKeysOptionTogglesKey	"HIDMouseKeysOptionToggles"

// kIOHIDSlowKeysDelayKey represents the delay used for slow keys.
// if kIOHIDSlowKeysDelayKey is 0, then slow keys off
#define kIOHIDSlowKeysDelayKey			"HIDSlowKeysDelay"

#define kIOHIDF12EjectDelayKey			"HIDF12EjectDelay"

#define kIOHIDMouseKeysOnKey			"HIDMouseKeysOn"

#define kIOHIDUseKeyswitchKey           "HIDUseKeyswitch"

#define kIOHIDDisallowRemappingOfPrimaryClickKey	"HIDDisallowRemappingOfPrimaryClick"
#define kIOHIDMouseKeysEnablesVirtualNumPadKey	"HIDMouseKeysEnablesVirtualNumPad"

#define kIOHIDResetLEDsKey          "HIDResetLEDs"

// Parametric Acceleration Keys
#define kHIDAccelParametricCurvesKey            "HIDAccelCurves"
#define kHIDTrackingAccelParametricCurvesKey    "HIDTrackingAccelCurves"
#define kHIDScrollAccelParametricCurvesKey      "HIDScrollAccelCurves"
#define kHIDAccelParametricCurvesDebugKey       "HIDAccelCurvesDebug"
#define kHIDScrollAccelParametricCurvesDebugKey "HIDScrollAccelCurvesDebug"
#define kHIDAccelGainLinearKey                  "HIDAccelGainLinear"
#define kHIDAccelGainParabolicKey               "HIDAccelGainParabolic"
#define kHIDAccelGainCubicKey                   "HIDAccelGainCubic"
#define kHIDAccelGainQuarticKey              "HIDAccelGainQuartic"
#define kHIDAccelTangentSpeedLinearKey          "HIDAccelTangentSpeedLinear"
#define kHIDAccelTangentSpeedParabolicRootKey   "HIDAccelTangentSpeedParabolicRoot"
#define kHIDAccelTangentSpeedCubicRootKey       "HIDAccelTangentSpeedCubicRoot"
#define kHIDAccelTangentSpeedQuarticRootKey  "HIDAccelTangentSpeedQuarticRoot"
#define kHIDAccelIndexKey                       "HIDAccelIndex"

// Scroll Count Keys
#define kIOHIDScrollCountMaxTimeDeltaBetweenKey         "HIDScrollCountMaxTimeDeltaBetween"
#define kIOHIDScrollCountMaxTimeDeltaToSustainKey       "HIDScrollCountMaxTimeDeltaToSustain"
#define kIOHIDScrollCountMinDeltaToStartKey             "HIDScrollCountMinDeltaToStart"
#define kIOHIDScrollCountMinDeltaToSustainKey           "HIDScrollCountMinDeltaToSustain"
#define kIOHIDScrollCountIgnoreMomentumScrollsKey       "HIDScrollCountIgnoreMomentumScrolls"
#define kIOHIDScrollCountMouseCanResetKey               "HIDScrollCountMouseCanReset"
#define kIOHIDScrollCountMaxKey                         "HIDScrollCountMax"
#define kIOHIDScrollCountAccelerationFactorKey          "HIDScrollCountAccelerationFactor"
#define kIOHIDScrollCountZeroKey                        "HIDScrollCountZero"
#define kIOHIDScrollCountBootDefaultKey                 "HIDScrollCountBootDefault"
#define kIOHIDScrollCountResetKey                       "HIDScrollCountReset"

// the following values are used in kIOHIDPointerButtonMode
typedef enum {
	kIOHIDButtonMode_BothLeftClicks = 0,
	kIOHIDButtonMode_ReverseLeftRightClicks = 1,
	kIOHIDButtonMode_EnableRightClick = 2
} IOHIDButtonModes;

#ifdef _undef
#define EVS_PREFIX	"Evs_"	/* All EVS calls start with this string */

/* WaitCursor-related ioctls */

#define EVSIOSWT "Evs_SetWaitThreshold"
#define EVSIOSWT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSWS "Evs_SetWaitSustain"
#define EVSIOSWS_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSWFI "Evs_SetWaitFrameInterval"
#define EVSIOSWFI_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOCWINFO	"Evs_CurrentWaitCursorInfo"
#define EVSIOCWINFO_THRESH	0
#define EVSIOCWINFO_SUSTAIN	(EVSIOCWINFO_THRESH + EVS_PACKED_TIME_SIZE)
#define EVSIOCWINFO_FINTERVAL	(EVSIOCWINFO_SUSTAIN + EVS_PACKED_TIME_SIZE)
#define EVSIOCWINFO_SIZE	(EVSIOCWINFO_FINTERVAL + EVS_PACKED_TIME_SIZE)
#endif

#define EVS_PACKED_TIME_SIZE (sizeof(UInt64) / sizeof( unsigned int))

/* Device control ioctls. Levels specified may be in the range 0 - 64. */

#define EVSIOSB	  	kIOHIDBrightnessKey
#define EVSIOSB_SIZE	1

#define EVSIOSADB 	kIOHIDAutoDimBrightnessKey
#define EVSIOSADB_SIZE	1

#ifdef _undef
#define EVSIOSA	  "Evs_SetAttenuation"
#define EVIOSA_SIZE	1

#define EVSIO_DCTLINFO	"Evs_DeviceControlInfo"
typedef enum {
	EVSIO_DCTLINFO_BRIGHT,
	EVSIO_DCTLINFO_ATTEN,
	EVSIO_DCTLINFO_AUTODIMBRIGHT
} evsio_DCTLINFOIndices;
#define EVSIO_DCTLINFO_SIZE	(EVSIO_DCTLINFO_AUTODIMBRIGHT + 1)
#endif

/*
 * Device status request
 */
#define	EVSIOINFO  NX_EVS_DEVICE_INFO


/* Keyboard-related ioctls - implemented within Event Sources */

#define EVSIOSKR  	kIOHIDKeyRepeatKey
#define EVSIOSKR_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSIKR 	kIOHIDInitialKeyRepeatKey
#define EVSIOSIKR_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIORKBD 	kIOHIDResetKeyboardKey
#define EVSIORKBD_SIZE	1

#define EVSIOCKR_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOCKML 	kIOHIDKeyMappingKey
#define EVSIOCKML_SIZE	1

/* The following two tokens are for use with the get/set character routines. */
#define EVSIOSKM  	kIOHIDKeyMappingKey
#define EVSIOSKM_SIZE	4096

#define	EVSIOCKM  	kIOHIDKeyMappingKey
#define EVSIOCKM_SIZE	4096

/* Mouse-related ioctls - implemented within Event Sources */

#define	EVSIOSMS  	kIOHIDPointerAccelerationKey
#define	EVSIOSMS_SIZE		(1)

#define	EVSIOCMS  	kIOHIDPointerAccelerationKey
#define	EVSIOCMS_SIZE		(1)

#ifdef _undef
#define EVSIOSMH  "Evs_SetMouseHandedness"
#define EVSIOSMH_SIZE	1		// value from NXMouseButton enum

#define EVSIOCMH  "Evs_CurrentMouseHandedness"
#define EVSIOCMH_SIZE	1
#endif

/* Generic pointer device controls, implemented by the Event Driver. */
#define	EVSIOSCT  	kIOHIDClickTimeKey
#define EVSIOSCT_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOSCS  	kIOHIDClickSpaceKey
typedef enum {
	EVSIOSCS_X,
	EVSIOSCS_Y
} evsioEVSIOSCSIndices;
#define EVSIOSCS_SIZE	(EVSIOSCS_Y + 1)

#define EVSIOSADT	 kIOHIDAutoDimThresholdKey
#define EVSIOSADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOSADS 	kIOHIDAutoDimStateKey
#define EVSIOSADS_SIZE	1

#define EVSIORMS  	kIOHIDResetPointerKey
#define EVSIORMS_SIZE	1

#define	EVSIOCCT  	kIOHIDClickTimeKey
#define EVSIOCCT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOCADT 	kIOHIDAutoDimThresholdKey
#define EVSIOCADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOGDADT 	kIOHIDAutoDimTimeKey
#define EVSIOGDADT_SIZE	EVS_PACKED_TIME_SIZE

#define EVSIOIDLE 	kIOHIDIdleTimeKey
#define EVSIOIDLE_SIZE	EVS_PACKED_TIME_SIZE

#define	EVSIOCCS  	kIOHIDClickSpaceKey
typedef enum {
	EVSIOCCS_X,
	EVSIOCCS_Y
} evsioEVSIOCCSIndices;
#define EVSIOCCS_SIZE	(EVSIOCCS_Y + 1)

#define EVSIOCADS 	kIOHIDAutoDimStateKey
#define EVSIOCADS_SIZE	1

enum {
    // Selectors for IOHIDGetModifierLockState and IOHIDSetModifierLockState
    kIOHIDCapsLockState             = 0x00000001,
    kIOHIDNumLockState              = 0x00000002,
    kIOHIDActivityUserIdle          = 0x00000003,
    kIOHIDActivityDisplayOn         = 0x00000004,
};

#endif /* !_DEV_EVSIO_H */
                                                                                                                                                                                                                                                                                                                         IOHIDShared.h                                                                                       0100644 0001750 0001750 00000024441 12567452123 034754  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2011 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _DEV_EVIO_H
#define _DEV_EVIO_H

#include <sys/cdefs.h>

__BEGIN_DECLS

#if KERNEL
#include <IOKit/system.h>
#else /* !KERNEL */
#include <mach/message.h>
#include <IOKit/IOKitLib.h>
#endif /* KERNEL */

#include <IOKit/IOReturn.h>
#include <IOKit/graphics/IOGraphicsTypes.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <IOKit/hidsystem/IOLLEvent.h>

/*
 * Identify this driver as one that uses the new driverkit and messaging API
 */
#ifndef _NeXT_MACH_EVENT_DRIVER_
#define _NeXT_MACH_EVENT_DRIVER_	(1)
#endif /* _NeXT_MACH_EVENT_DRIVER_ */


/* Pressure Constants */
#define MINPRESSURE EV_MINPRESSURE
#define MAXPRESSURE EV_MAXPRESSURE

#define	LLEQSIZE 240	/* Entries in low-level event queue */

typedef struct _NXEQElStruct {
    int	next;		/* Slot of lleq for next event */
    OSSpinLock sema; /* Is high-level code reading this event now? */
    NXEvent event;	/* The event itself */
} NXEQElement;

/******************************************************************************
    SHARED MEMORY OVERVIEW
    
    PERSPECTIVE
    The ev driver and PostScript share at least one page of wired memory.
    This memory contains the low-level event queue which ev deposits events
    into and PostScript reads events from. Also, this memory contains other
    important data such as wait cursor state and some general cursor state.
    This memory is critical for speed.  That is, we avoid having to make
    system calls for common operations.
    
    SHARED MEMORY REGIONS
    There are currently three "regions" or "zones" delineated within this
    shared memory.  The first zone is the EvOffsets structure. This structure
    contains two offsets from the beginning of shared memory. The first offset
    is to the second zone, EvGlobals. The second offset is to the third
    zone, private shmem for drivers.
    
    INITIALIZATION OF SHARED MEMORY
    When the WindowServer starts up, it finds all screens that will be active.
    It then opens the ev driver and calls the EVIOSSCR ioctl repeatedly for
    each screen in use. This lets the ev driver set up the evScreen array
    and fill in each element. This ioctl also returns to PostScript a running
    total shared memory size with which to allocate. PostScript then allocates
    a region of memory this size and calls evmmap to "map in" this shared
    region.  Evmmap initializes and fills in the EvOffsets and EvGlobals.
    Next the WindowServer calls each screen in turn to register itself with
    the ev driver in the same sequence as presented to EVIOSSCR.  Each screen
    driver calls ev_register_screen() which among other things allocates a
    part of the private shmem (of the third shared memory zone) for the driver.
    
    DEBUGGING NOTES
    You can easily display and set this shared memory from kgdb, but usually
    cannot do so from within PostScript.  Gdb (or some weird interaction
    between gdb and the os) chokes on this shmem.  So if you read or write
    this area of memory, copy-on-write will occur and you'll get a completely
    new page for PostScript.  This will render the shared memory scheme
    useless and you will have to restart PostScript.  It was my understanding
    that before, we were able to "read" this area from PS, but not write to
    it (the idea behind copy-on-WRITE).  However, this seems to be broken
    in 2.0.  We think this is a kernel bug.
******************************************************************************/

typedef volatile struct _evOffsets {
    int	evGlobalsOffset;	/* Offset to EvGlobals structure */
    int evShmemOffset;		/* Offset to private shmem regions */
} EvOffsets;

/******************************************************************************
    EvGlobals
    This structures defines the portion of the events driver data structure
    that is exported to the PostScript server. It contains the event queue
    which is in memory shared between the driver and the PostScript server.
    All the variables necessary to read and process events from the queue are
    contained here.
******************************************************************************/

typedef volatile struct _evGlobals {
    OSSpinLock cursorSema; 	/* set to disable periodic code */
    int eNum;                       /* Unique id for mouse events */
    int buttons;                    /* State of the mouse buttons 1==down, 0==up */
    int eventFlags;                 /* The current value of event.flags */
    int VertRetraceClock;           /* The current value of event.time */
    IOGPoint cursorLoc;             /* The current location of the cursor, in desktop coordinates */
    int frame;                      /* current cursor frame */
    IOGBounds workBounds;           /* bounding box of all screens */
    IOGBounds mouseRect;            /* Rect for mouse-exited events */
    int version;                    /* for run time checks */
    int	structSize;                 /* for run time checks */
    int lastFrame;
                                    /* The current location of the cursor, 24.8 bit fixed point format */
    IOFixedPoint32 screenCursorFixed; /* in Screen coordinates  */
    IOFixedPoint32 desktopCursorFixed;/* in Desktop coordinates  */
    unsigned int reservedA[27];

    unsigned reserved:25;
    unsigned updateCursorPositionFromFixed:1; /* if this is set, IOHIDSystem will take any cursor position updates from desktopCursorFixed instead of cursorLoc */
    unsigned logCursorUpdates:1;    /* log cursor updates */
    unsigned wantPressure:1;        /* pressure in current mouseRect? */
    unsigned wantPrecision:1;       /* precise coordinates in current mouseRect? */
    unsigned dontWantCoalesce:1;    /* coalesce within the current mouseRect? */
    unsigned dontCoalesce:1;        /* actual flag which determines coalescing */
    unsigned mouseRectValid:1;      /* If nonzero, post a mouse-exited whenever mouse outside mouseRect. */
    int movedMask;                  /* This contains an event mask for the three events MOUSEMOVED,
                                        LMOUSEDRAGGED,  and RMOUSEDRAGGED. It says whether driver should
                                        generate those events. */
    OSSpinLock waitCursorSema; /* protects wait cursor fields */
    int AALastEventSent;            /* timestamp for wait cursor */
    int AALastEventConsumed;        /* timestamp for wait cursor */	
    int waitCursorUp;               /* Is wait cursor up? */
    char ctxtTimedOut;              /* Has wait cursor timer expired? */
    char waitCursorEnabled;         /* Play wait cursor game (per ctxt)? */
    char globalWaitCursorEnabled;   /* Play wait cursor game (global)? */
    int waitThreshold;              /* time before wait cursor appears */

    int LLEHead;                    /* The next event to be read */
    int LLETail;                    /* Where the next event will go */
    int LLELast;                    /* The last event entered */
    NXEQElement lleq[LLEQSIZE];     /* The event queue itself */
} EvGlobals;

/* These evio structs are used in various calls supported by the ev driver. */

struct evioLLEvent {
    int setCursor;
    int type;
    IOGPoint location;
    NXEventData data;
    int setFlags;
    int flags;
};

typedef struct evioLLEvent _NXLLEvent;

#ifdef mach3xxx

/*
 * On a keypress of a VOL UP or VOL DOWN key, we send a message to the 
 * sound server to notify it of the volume change.  The message includes
 * a flag to indicate which key was pressed, and the machine independant
 * flag bits to indicate which modifier keys were pressed.
 */

struct evioSpecialKeyMsg
{
	msg_header_t Head;
	msg_type_t keyType;
	int key;		// special key number, from bsd/dev/ev_keymap.h
	msg_type_t directionType;
	int direction;		// NX_KEYDOWN, NX_KEYUP from event.h
	msg_type_t flagsType;
	int flags;		// device independant flags from event.h
	msg_type_t levelType;
	int level;		// EV_AUDIO_MIN_VOLUME to EV_AUDIO_MAX_VOLUME
};
#else
struct evioSpecialKeyMsg
{
	mach_msg_header_t Head;
	int key;		// special key number, from bsd/dev/ev_keymap.h
	int direction;		// NX_KEYDOWN, NX_KEYUP from event.h
	int flags;		// device independant flags from event.h
	int level;		// EV_AUDIO_MIN_VOLUME to EV_AUDIO_MAX_VOLUME
};
#endif

#define EV_SPECIAL_KEY_MSG_ID	(('S'<<24) | ('k'<<16) | ('e'<<8) | ('y'))
typedef struct evioSpecialKeyMsg *evioSpecialKeyMsg_t;

/*
 * Volume ranges
 */
#define EV_AUDIO_MIN_VOLUME	0
#define EV_AUDIO_MAX_VOLUME	64

#define kIOHIDSystemClass	"IOHIDSystem"
#define kIOHIKeyboardClass	"IOHIKeyboard"
#define kIOHIPointingClass	"IOHIPointing"

#define IOHIDSYSTEM_CONFORMSTO	kIOHIDSystemClass

enum {
    kIOHIDEventNotification     = 0,
};
#define kIOHIDCurrentShmemVersion           4
#define kIOHIDLastCompatibleShmemVersion    3

enum {
    kIOHIDServerConnectType	= 0,
    kIOHIDParamConnectType	= 1,
    kIOHIDEventSystemConnectType = 3,
};

enum {
    kIOHIDGlobalMemory          = 0
};

enum {
    kIOHIDEventQueueTypeKernel  = 0,
    kIOHIDEventQueueTypeUser    = 1
};

#ifdef KERNEL
typedef UInt16 (*MasterVolumeUpdate)(void);
typedef bool (*MasterMuteUpdate)(void);

typedef struct {
    MasterVolumeUpdate incrementMasterVolume;
    MasterVolumeUpdate decrementMasterVolume;
    MasterMuteUpdate toggleMasterMute;
} MasterAudioFunctions;

extern MasterAudioFunctions *masterAudioFunctions;
#endif

#ifndef KERNEL
#ifndef _IOKIT_IOHIDLIB_H
#include <IOKit/hidsystem/IOHIDLib.h>
#endif
#endif /* !KERNEL */

__END_DECLS


#endif /* !_DEV_EVIO_H */
                                                                                                                                                                                                                               IOHIDTypes.h                                                                                        0100644 0001750 0001750 00000013660 12567452123 034653  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/******************************************************************************
	ev_types.h
	Data types for the events status driver.
	This file contains public API.
	mpaque 11Oct91
	
	Copyright 1991 NeXT Computer, Inc.
	Copyright 1997-2011 Apple, Inc.
	
	Modified:
	
******************************************************************************/

#ifndef _DEV_EV_TYPES_H
#define _DEV_EV_TYPES_H

#include <mach/boolean.h>
#include <libkern/OSAtomic.h>
#include <IOKit/graphics/IOGraphicsTypes.h>

// This should be removed, but is being used by others
// <rdar://problem/8917741> IOHIDFamily-355 causes projects to fail to build with 'ev_lock_data_t' does not name a type
#include <IOKit/IOSharedLock.h>

/* Shared memory versions */
#define EVENT_SYSTEM_VERSION   2

/* Maximum length of SetMouseScaling arrays */
#define NX_MAXMOUSESCALINGS 20

typedef struct evsioKeymapping		/* Match old struct names in kernel */
{
    int size;
    char *mapping;
} NXKeyMapping;

typedef struct evsioMouseScaling	/* Match old struct names in kernel */
{
    int numScaleLevels;
    short scaleThresholds[NX_MAXMOUSESCALINGS];
    short scaleFactors[NX_MAXMOUSESCALINGS];
} NXMouseScaling;

typedef enum {
    NX_OneButton,
    NX_LeftButton,
    NX_RightButton
} NXMouseButton;

// IOFixedPoint32 is a 24.8 format
typedef struct __IOFixedPoint32 {
    int32_t     x;
    int32_t     y;
} IOFixedPoint32;

/*
 * NXEventSystemInfo() information structures.  These are designed to
 * allow for expansion.
 *
 * The current implementation of NXEventSystemInfo() uses an ioctl call.
 * THIS WILL CHANGE.
 */
 
/*
 * Generic query max size and typedefs.
 *
 *	The maximum size is selected to support anticipated future extensions
 *	of request flavors.  Certain flavors planned for future releases may 
 *	require roughtly 800 ints to represent.  We allow a little extra, in
 *	case further growth is needed.
 */
typedef int *NXEventSystemInfoType;
#define NX_EVS_INFO_MAX		(1024)	/* Max array size */
typedef int NXEventSystemInfoData[NX_EVS_INFO_MAX];

/* Event System Devices query */
#define NX_EVS_DEVICE_MAX	16

	/* Interface types */
#define NX_EVS_DEVICE_INTERFACE_OTHER		0
#define NX_EVS_DEVICE_INTERFACE_NeXT		1 // NeXT custom, in older sys
#define NX_EVS_DEVICE_INTERFACE_ADB		2 // NeXT/fruit keybds/mice
#define NX_EVS_DEVICE_INTERFACE_ACE		3 // For x86 PC keyboards
#define NX_EVS_DEVICE_INTERFACE_SERIAL_ACE	4 // For PC serial mice 
#define NX_EVS_DEVICE_INTERFACE_BUS_ACE		5 // For PC bus mice 
#define NX_EVS_DEVICE_INTERFACE_HIL		6 // For HIL hp keyboard 
#define NX_EVS_DEVICE_INTERFACE_TYPE5		7 // For Sun Type5 keyboard

/*
 * Note! if any new interface types are added above, the following
 * definition of the number of interfaces supported must reflect this.
 * This is used in the libkeymap project (storemap.c module) which needs
 * to be cognizant of the number of new devices coming online
 * via support for heterogeneous architecture platforms.
 * e.g., PCs, HP's HIL, Sun's Type5 keyboard,...
 */
#define NUM_SUPPORTED_INTERFACES	(NX_EVS_DEVICE_INTERFACE_TYPE5 + 1)
					// Other, NeXT, ADB, ACE,...

	/* Device types */
#define NX_EVS_DEVICE_TYPE_OTHER	0
#define NX_EVS_DEVICE_TYPE_KEYBOARD	1
#define NX_EVS_DEVICE_TYPE_MOUSE	2	// Relative position devices
#define NX_EVS_DEVICE_TYPE_TABLET	3	// Absolute position devices

typedef struct {
	int	interface;	/* NeXT, ADB, other */
	int	interface_addr;	/* Device address on the interface */
	int	dev_type;	/* Keyboard, mouse, tablet, other */
	int	id;		/* manufacturer's device handler ID */
} NXEventSystemDevice;

typedef struct {
	NXEventSystemDevice	dev[NX_EVS_DEVICE_MAX];
} NXEventSystemDeviceList;

#define __OLD_NX_EVS_DEVICE_INFO		1
#define NX_EVS_DEVICE_INFO			"Evs_EventDeviceInfo"
#define NX_EVS_DEVICE_INFO_COUNT \
	(sizeof (NXEventSystemDeviceList) / sizeof (int))

/*
 * Types used in evScreen protocol compliant operations.
 */

typedef enum {EVNOP, EVHIDE, EVSHOW, EVMOVE, EVLEVEL} EvCmd; /* Cursor state */

#define EV_SCREEN_MIN_BRIGHTNESS	0
#define EV_SCREEN_MAX_BRIGHTNESS	64
/* Scale should lie between MIN_BRIGHTNESS and MAX_BRIGHTNESS */
#define EV_SCALE_BRIGHTNESS( scale, datum ) \
	((((UInt32)(datum))*((UInt32)scale)) >> 6)

/*
 * Definition of a tick, as a time in milliseconds. This controls how
 * often the event system periodic jobs are run.  All actual tick times
 * are derived from the nanosecond timer.  These values are typically used
 * as part of computing mouse velocity for acceleration purposes.
 */
#define EV_TICK_TIME		16			/* 16 milliseconds */
#define EV_TICKS_PER_SEC	(1000/EV_TICK_TIME)	/* ~ 62 Hz */

/* Mouse Button bits, as passed from an EventSrc to the Event Driver */
#define EV_RB			(0x01)
#define EV_LB			(0x04)
#define EV_MOUSEBUTTONMASK	(EV_LB | EV_RB)

/* Tablet Pressure Constants, as passed from an EventSrc to the Event Driver */
#define EV_MINPRESSURE 0
#define EV_MAXPRESSURE 255

/* Cursor size in pixels */
#define EV_CURSOR_WIDTH		16
#define EV_CURSOR_HEIGHT	16


#define kAppleOnboardGUID 	0x0610000000000000ULL

#endif /* !_DEV_EV_TYPES_H */

                                                                                IOLLEvent.h                                                                                         0100644 0001750 0001750 00000053745 12567452123 034543  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * @APPLE_LICENSE_HEADER_START@
 * 
 * Copyright (c) 1999-2009 Apple Computer, Inc.  All Rights Reserved.
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/******************************************************************************
	event.h (PostScript side version)
	
	CONFIDENTIAL
	Copyright (c) 1988 NeXT, Inc. as an unpublished work.
	All Rights Reserved.

	Created Leo 01Mar88

	Modified:
	04May88 Leo  Final event types and record
	22Aug88 Leo  Change short -> int for window, add reserved
	26May90 Ted  Added NX_UNDIMMASK to correct triggering of UndoAutoDim
	12Dec91 Mike Brought into sync with dpsclient/event.h, and fixed
		     the #ifndef interlock with dpsclient/event.h that was
		     broken during the Great Header Revision.

	The PostScript version of this file differs from the
	Window Kit version in that the coordinates here are
	ints instead of floats.
******************************************************************************/

#ifndef _DEV_EVENT_H
#define _DEV_EVENT_H

#include <libkern/OSTypes.h>
#include <IOKit/hidsystem/IOHIDTypes.h>

#ifdef EVENT_H		/* Interlock with dpsclient/event.h */
#if !defined(_NXSIZE_)	/* Work around patch for old event.h in Phase 3 projs*/
#define _NXSIZE_	1	/* NXCoord, NXPoint, NXSize decl seen */
#define _NXSize_	NXSize
#endif /* _NXSIZE_ */
#else  /* EVENT_H */		/* Haven't seen dpsclient/event.h, so define away */
#define EVENT_H

#ifdef	KERNEL
#else	/* KERNEL */

#if !defined(_NXSIZE_)	/* Work around patch for old event.h in Phase 3 projs*/
#define _NXSIZE_	1	/* NXCoord, NXPoint, NXSize decl seen */
typedef float   NXCoord;

typedef struct _NXPoint {	/* point */
    NXCoord         x, y;
} NXPoint;

typedef struct _NXSize {	/* size */
    NXCoord         width, height;
} NXSize;
#define _NXSize_	NXSize	/* Correct usage in event_status_driver.h */
#endif /* _NXSIZE_ */

#endif	/* KERNEL */

/* Event types */

#define NX_NULLEVENT		0	/* internal use */

/* mouse events */

#define NX_LMOUSEDOWN		1	/* left mouse-down event */
#define NX_LMOUSEUP		2	/* left mouse-up event */
#define NX_RMOUSEDOWN		3	/* right mouse-down event */
#define NX_RMOUSEUP		4	/* right mouse-up event */
#define NX_MOUSEMOVED		5	/* mouse-moved event */
#define NX_LMOUSEDRAGGED	6	/* left mouse-dragged event */
#define NX_RMOUSEDRAGGED	7	/* right mouse-dragged event */
#define NX_MOUSEENTERED		8	/* mouse-entered event */
#define NX_MOUSEEXITED		9	/* mouse-exited event */

/* other mouse events
 *
 * event.data.mouse.buttonNumber should contain the 
 * button number (2-31) changing state.
 */
#define NX_OMOUSEDOWN		25	/* other mouse-down event */
#define NX_OMOUSEUP		26	/* other mouse-up event */
#define NX_OMOUSEDRAGGED	27	/* other mouse-dragged event */

/* keyboard events */

#define NX_KEYDOWN		10	/* key-down event */
#define NX_KEYUP		11	/* key-up event */
#define NX_FLAGSCHANGED		12	/* flags-changed event */

/* composite events */

#define NX_KITDEFINED		13	/* application-kit-defined event */
#define NX_SYSDEFINED		14	/* system-defined event */
#define NX_APPDEFINED		15	/* application-defined event */
/* There are additional DPS client defined events past this point. */

/* Scroll wheel events */

#define NX_SCROLLWHEELMOVED	22

/* Zoom events */
#define NX_ZOOM             28

/* tablet events */

#define NX_TABLETPOINTER	23	/* for non-mousing transducers */
#define NX_TABLETPROXIMITY	24  /* for non-mousing transducers */

/* event range */

#define NX_FIRSTEVENT		0
#define NX_LASTEVENT		28
#define NX_NUMPROCS		(NX_LASTEVENT-NX_FIRSTEVENT+1)

/* Event masks */
#define NX_NULLEVENTMASK        (1 << NX_NULLEVENT)     /* NULL event */
#define NX_LMOUSEDOWNMASK       (1 << NX_LMOUSEDOWN)	/* left mouse-down */
#define NX_LMOUSEUPMASK         (1 << NX_LMOUSEUP)      /* left mouse-up */
#define NX_RMOUSEDOWNMASK       (1 << NX_RMOUSEDOWN)	/* right mouse-down */
#define NX_RMOUSEUPMASK         (1 << NX_RMOUSEUP)      /* right mouse-up */
#define NX_OMOUSEDOWNMASK       (1 << NX_OMOUSEDOWN)	/* other mouse-down */
#define NX_OMOUSEUPMASK         (1 << NX_OMOUSEUP)      /* other mouse-up  */
#define NX_MOUSEMOVEDMASK       (1 << NX_MOUSEMOVED)	/* mouse-moved */
#define NX_LMOUSEDRAGGEDMASK	(1 << NX_LMOUSEDRAGGED)	/* left-dragged */
#define NX_RMOUSEDRAGGEDMASK	(1 << NX_RMOUSEDRAGGED)	/* right-dragged */
#define NX_OMOUSEDRAGGEDMASK	(1 << NX_OMOUSEDRAGGED)	/* other-dragged */
#define NX_MOUSEENTEREDMASK     (1 << NX_MOUSEENTERED)	/* mouse-entered */
#define NX_MOUSEEXITEDMASK      (1 << NX_MOUSEEXITED)	/* mouse-exited */
#define NX_KEYDOWNMASK          (1 << NX_KEYDOWN)       /* key-down */
#define NX_KEYUPMASK            (1 << NX_KEYUP)         /* key-up */
#define NX_FLAGSCHANGEDMASK     (1 << NX_FLAGSCHANGED)	/* flags-changed */
#define NX_KITDEFINEDMASK       (1 << NX_KITDEFINED)	/* kit-defined */
#define NX_SYSDEFINEDMASK       (1 << NX_SYSDEFINED)	/* system-defined */
#define NX_APPDEFINEDMASK       (1 << NX_APPDEFINED)	/* app-defined */
#define NX_SCROLLWHEELMOVEDMASK	(1 << NX_SCROLLWHEELMOVED)	/* scroll wheel moved */
#define NX_ZOOMMASK             (1 << NX_ZOOM)          /* Zoom */
#define NX_TABLETPOINTERMASK	(1 << NX_TABLETPOINTER)	/* tablet pointer moved */
#define NX_TABLETPROXIMITYMASK	(1 << NX_TABLETPROXIMITY)	/* tablet pointer proximity */

#define EventCodeMask(type)	(1 << (type))
#define NX_ALLEVENTS		-1	/* Check for all events */

/* sub types for mouse and move events */

#define NX_SUBTYPE_DEFAULT					0
#define NX_SUBTYPE_TABLET_POINT				1
#define NX_SUBTYPE_TABLET_PROXIMITY			2
#define NX_SUBTYPE_MOUSE_TOUCH              3

/* sub types for system defined events */

#define NX_SUBTYPE_POWER_KEY				1
#define NX_SUBTYPE_AUX_MOUSE_BUTTONS		7

/* 
 * NX_SUBTYPE_AUX_CONTROL_BUTTONS usage
 *
 * The incoming NXEvent for other mouse button down/up has event.type 
 * NX_SYSDEFINED and event.data.compound.subtype NX_SUBTYPE_AUX_MOUSE_BUTTONS.
 * Within the event.data.compound.misc.L[0] contains bits for all the buttons 
 * that have changed state, and event.data.compound.misc.L[1] contains the 
 * current button state as a bitmask, with 1 representing down, and 0
 * representing up.  Bit 0 is the left button, bit one is the right button, 
 * bit 2 is the center button and so forth.
 */
#define NX_SUBTYPE_AUX_CONTROL_BUTTONS		8

#define NX_SUBTYPE_EJECT_KEY				10
#define NX_SUBTYPE_SLEEP_EVENT				11
#define NX_SUBTYPE_RESTART_EVENT			12
#define NX_SUBTYPE_SHUTDOWN_EVENT			13

#define NX_SUBTYPE_STICKYKEYS_ON			100
#define NX_SUBTYPE_STICKYKEYS_OFF			101
#define NX_SUBTYPE_STICKYKEYS_SHIFT			102
#define NX_SUBTYPE_STICKYKEYS_CONTROL			103
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE			104
#define NX_SUBTYPE_STICKYKEYS_COMMAND			105
#define NX_SUBTYPE_STICKYKEYS_RELEASE			106
#define NX_SUBTYPE_STICKYKEYS_TOGGLEMOUSEDRIVING	107

// New stickykeys key events
// These were created to send an event describing the 
// different state of the modifiers
#define NX_SUBTYPE_STICKYKEYS_SHIFT_DOWN		110
#define NX_SUBTYPE_STICKYKEYS_CONTROL_DOWN		111
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_DOWN		112
#define NX_SUBTYPE_STICKYKEYS_COMMAND_DOWN		113
#define NX_SUBTYPE_STICKYKEYS_FN_DOWN			114

#define NX_SUBTYPE_STICKYKEYS_SHIFT_LOCK		120
#define NX_SUBTYPE_STICKYKEYS_CONTROL_LOCK		121
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_LOCK		122
#define NX_SUBTYPE_STICKYKEYS_COMMAND_LOCK		123
#define NX_SUBTYPE_STICKYKEYS_FN_LOCK			124

#define NX_SUBTYPE_STICKYKEYS_SHIFT_UP			130
#define NX_SUBTYPE_STICKYKEYS_CONTROL_UP		131
#define NX_SUBTYPE_STICKYKEYS_ALTERNATE_UP		132
#define NX_SUBTYPE_STICKYKEYS_COMMAND_UP		133
#define NX_SUBTYPE_STICKYKEYS_FN_UP			134



// SlowKeys 
#define NX_SUBTYPE_SLOWKEYS_START			200
#define NX_SUBTYPE_SLOWKEYS_ABORT			201
#define NX_SUBTYPE_SLOWKEYS_END				202

// HID Parameter Property Modified
#define NX_SUBTYPE_HIDPARAMETER_MODIFIED		210

/* Masks for the bits in event.flags */

/* device-independent */

#define	NX_ALPHASHIFTMASK	0x00010000
#define	NX_SHIFTMASK		0x00020000
#define	NX_CONTROLMASK		0x00040000
#define	NX_ALTERNATEMASK	0x00080000
#define	NX_COMMANDMASK		0x00100000
#define	NX_NUMERICPADMASK	0x00200000
#define	NX_HELPMASK		0x00400000
#define	NX_SECONDARYFNMASK	0x00800000
#define NX_ALPHASHIFT_STATELESS_MASK    0x01000000

/* device-dependent (really?) */

#define	NX_DEVICELCTLKEYMASK	0x00000001
#define	NX_DEVICELSHIFTKEYMASK	0x00000002
#define	NX_DEVICERSHIFTKEYMASK	0x00000004
#define	NX_DEVICELCMDKEYMASK	0x00000008
#define	NX_DEVICERCMDKEYMASK	0x00000010
#define	NX_DEVICELALTKEYMASK	0x00000020
#define	NX_DEVICERALTKEYMASK	0x00000040
#define NX_DEVICE_ALPHASHIFT_STATELESS_MASK 0x00000080
#define NX_DEVICERCTLKEYMASK	0x00002000

/* 
 * Additional reserved bits in event.flags
 */

#define NX_STYLUSPROXIMITYMASK	0x00000080	/* deprecated */
#define NX_NONCOALSESCEDMASK	0x00000100

/* click state values
 * If you have the following events in close succession, the click
 * field has the indicated value:
 *	
 *  Event	Click Value	Comments
 *  mouse-down	1		Not part of any click yet
 *  mouse-up	1		Aha! A click!
 *  mouse-down	2		Doing a double-click
 *  mouse-up	2		It's finished
 *  mouse-down	3		A triple
 *  mouse-up	3
 */

/* Values for the character set in event.data.key.charSet */

#define	NX_ASCIISET		0
#define NX_SYMBOLSET		1
#define	NX_DINGBATSSET		2

/* tablet button masks
 * Mask bits for the tablet barrel buttons placed in tablet.buttons.
 * The buttons field uses adopts the following convention:
 *
 * Bit      Comments
 * 0        Left Mouse Button ( kHIDUsage_Button_1 )
 * 1        Right Mouse Button ( kHIDUsage_Button_2 )
 * 2        Middle Mouse Button ( kHIDUsage_Button_3 )
 * 3        4th Mouse Button ( kHIDUsage_Button_4 )
 * ...
 * 15       15th Mouse Button
 *
 * For your convenience, the following mask bits have been defined
 * for tablet specific application:
 */
 
#define NX_TABLET_BUTTON_PENTIPMASK             0x0001
#define NX_TABLET_BUTTON_PENLOWERSIDEMASK       0x0002
#define NX_TABLET_BUTTON_PENUPPERSIDEMASK       0x0004


/* tablet capability masks
 * Mask bits for the tablet capabilities field.   Use these 
 * masks with the capabilities field of a proximity event to 
 * determine what fields in a Tablet Event are valid for this 
 * device.
 */
#define NX_TABLET_CAPABILITY_DEVICEIDMASK           0x0001
#define NX_TABLET_CAPABILITY_ABSXMASK               0x0002
#define NX_TABLET_CAPABILITY_ABSYMASK               0x0004
#define NX_TABLET_CAPABILITY_VENDOR1MASK            0x0008
#define NX_TABLET_CAPABILITY_VENDOR2MASK            0x0010
#define NX_TABLET_CAPABILITY_VENDOR3MASK            0x0020
#define NX_TABLET_CAPABILITY_BUTTONSMASK            0x0040
#define NX_TABLET_CAPABILITY_TILTXMASK              0x0080
#define NX_TABLET_CAPABILITY_TILTYMASK              0x0100
#define NX_TABLET_CAPABILITY_ABSZMASK               0x0200
#define NX_TABLET_CAPABILITY_PRESSUREMASK           0x0400
#define NX_TABLET_CAPABILITY_TANGENTIALPRESSUREMASK 0x0800
#define NX_TABLET_CAPABILITY_ORIENTINFOMASK         0x1000
#define NX_TABLET_CAPABILITY_ROTATIONMASK           0x2000

/* proximity pointer types
 * Value that describes the type of pointing device placed in
 * proximity.pointerType.
 */
 
#define NX_TABLET_POINTER_UNKNOWN               0
#define NX_TABLET_POINTER_PEN                   1
#define NX_TABLET_POINTER_CURSOR                2
#define NX_TABLET_POINTER_ERASER                3

/* TabletPointData type: defines the tablet data for points included
 * in mouse events created by a tablet driver.
 */

typedef struct _NXTabletPointData {
	SInt32  x;  /* absolute x coordinate in tablet space at full tablet resolution */
    SInt32  y;  /* absolute y coordinate in tablet space at full tablet resolution */
	SInt32  z;  /* absolute z coordinate in tablet space at full tablet resolution */
    UInt16  buttons;   /* one bit per button - bit 0 is first button - 1 = closed  */
    UInt16  pressure;  /* scaled pressure value; MAX=(2^16)-1, MIN=0 */
    struct {           /* tilt range is -((2^15)-1) to (2^15)-1 (-32767 to 32767)  */
        SInt16 x;      /* scaled tilt x value */
        SInt16 y;      /* scaled tilt y value */
	} tilt;
	UInt16  rotation;  /* Fixed-point representation of device rotation in a 10.6 format */
	SInt16  tangentialPressure; /* tangential pressure on the device; same range as tilt */
	UInt16  deviceID;  /* system-assigned unique device ID */
	SInt16  vendor1;   /* vendor-defined signed 16-bit integer */
	SInt16  vendor2;   /* vendor-defined signed 16-bit integer */
	SInt16  vendor3;   /* vendor-defined signed 16-bit integer */
} NXTabletPointData, *NXTabletPointDataPtr;

/* TabletProximityData type: defines the tablet data for proximity
 * events included in mouse events created by a tablet driver.
 */

typedef struct _NXTabletProximityData {
    UInt16  vendorID;             /* vendor-defined ID - typically the USB vendor ID */
	UInt16  tabletID;             /* vendor-defined tablet ID - typically the USB product ID */
	UInt16  pointerID;            /* vendor-defined ID of the specific pointing device */
	UInt16  deviceID;             /* system-assigned unique device ID */
	UInt16  systemTabletID;       /* system-assigned unique tablet ID */
	UInt16  vendorPointerType;    /* vendor-defined pointer type */
	UInt32  pointerSerialNumber;  /* vendor-defined serial number */
	UInt64  uniqueID __attribute__ ((packed));             /* vendor-defined unique ID */
	UInt32  capabilityMask;       /* capabilities mask of the device */
	UInt8   pointerType;          /* type of pointing device */
	UInt8   enterProximity;       /* non-zero = entering; zero = leaving */
	SInt16  reserved1;
} NXTabletProximityData, *NXTabletProximityDataPtr;

/* EventData type: defines the data field of an event */

typedef	union {
    struct {    /* For mouse-down and mouse-up events */
        UInt8   subx;       /* sub-pixel position for x */
        UInt8   suby;       /* sub-pixel position for y */
        SInt16  eventNum;   /* unique identifier for this button */
        SInt32  click;      /* click state of this event */
        UInt8   pressure;   /* pressure value: 0=none, 255=full */
        UInt8   buttonNumber;/* button generating other button event (0-31) */
        UInt8   subType;
        UInt8   reserved2;
        SInt32  reserved3;
        union {
            NXTabletPointData      point;     /* tablet point data */
            NXTabletProximityData  proximity; /* tablet proximity data */
        } tablet;
    } mouse;
    struct {
        SInt32  dx;
        SInt32  dy;
        UInt8   subx;
        UInt8   suby;
        UInt8   subType;
        UInt8   reserved1;
        SInt32  reserved2;
        union {
            NXTabletPointData      point;     /* tablet point data */
            NXTabletProximityData  proximity; /* tablet proximity data */
        } tablet;
    } mouseMove;
    struct {    /* For key-down and key-up events */
        UInt16  origCharSet;    /* unmodified character set code */
        SInt16  repeat;         /* for key-down: nonzero if really a repeat */
        UInt16  charSet;        /* character set code */
        UInt16  charCode;       /* character code in that set */
        UInt16  keyCode;        /* device-dependent key number */
        UInt16  origCharCode;   /* unmodified character code */
        SInt32  reserved1;
        UInt32  keyboardType;
        SInt32  reserved2;
        SInt32  reserved3;
        SInt32  reserved4;
        SInt32  reserved5[4];
    } key;
    struct {    /* For mouse-entered and mouse-exited events */
        SInt16  reserved;
        SInt16  eventNum;       /* unique identifier from mouse down event */
        SInt32  trackingNum;    /* unique identifier from settrackingrect */
        SInt32  userData;       /* uninterpreted integer from settrackingrect */
        SInt32  reserved1;
        SInt32  reserved2;
        SInt32  reserved3;
        SInt32  reserved4;
        SInt32  reserved5;
        SInt32  reserved6[4];
    } tracking;
    struct {
        SInt16  deltaAxis1;
        SInt16  deltaAxis2;
        SInt16  deltaAxis3;
        SInt16  reserved1;
        SInt32  fixedDeltaAxis1;
        SInt32  fixedDeltaAxis2;
        SInt32  fixedDeltaAxis3;
        SInt32  pointDeltaAxis1;
        SInt32  pointDeltaAxis2;
        SInt32  pointDeltaAxis3;
        SInt32  reserved8[4];
    } scrollWheel, zoom;
    struct {    /* For window-changed, sys-defined, and app-defined events */
        SInt16  reserved;
        SInt16  subType;    /* event subtype for compound events */
        union {
            float   F[11];  /* for use in compound events */
            SInt32  L[11];  /* for use in compound events */
            SInt16  S[22];  /* for use in compound events */
            char    C[44];  /* for use in compound events */
        } misc;
    } compound;
    struct {
        SInt32  x;  /* absolute x coordinate in tablet space at full tablet resolution */
        SInt32  y;  /* absolute y coordinate in tablet space at full tablet resolution */
        SInt32  z;  /* absolute z coordinate in tablet space at full tablet resolution */
        UInt16  buttons;   /* one bit per button - bit 0 is first button - 1 = closed  */
        UInt16  pressure;  /* scaled pressure value; MAX=(2^16)-1, MIN=0 */
        struct {           /* tilt range is -((2^15)-1) to (2^15)-1 (-32767 to 32767)  */
            SInt16 x;      /* scaled tilt x value */
            SInt16 y;      /* scaled tilt y value */
        } tilt;
        UInt16  rotation;  /* Fixed-point representation of device rotation in a 10.6 format */
        SInt16  tangentialPressure; /* tangential pressure on the device; same range as tilt */
        UInt16  deviceID;  /* system-assigned unique device ID */
        SInt16  vendor1;   /* vendor-defined signed 16-bit integer */
        SInt16  vendor2;   /* vendor-defined signed 16-bit integer */
        SInt16  vendor3;   /* vendor-defined signed 16-bit integer */
        SInt32  reserved[4];
    } tablet;
    struct {
        UInt16  vendorID;  /* vendor-defined ID - typically the USB vendor ID */
        UInt16  tabletID;  /* vendor-defined tablet ID - typically the USB product ID */
        UInt16  pointerID; /* vendor-defined ID of the specific pointing device */
        UInt16  deviceID;             /* system-assigned unique device ID */
        UInt16  systemTabletID;       /* system-assigned unique tablet ID */
        UInt16  vendorPointerType;    /* vendor-defined pointer type */
        UInt32  pointerSerialNumber;  /* vendor-defined serial number */
        UInt64  uniqueID __attribute__ ((packed));             /* vendor-defined unique ID */
        UInt32  capabilityMask;       /* capabilities mask of the device */
        UInt8   pointerType;          /* type of pointing device */
        UInt8   enterProximity;       /* non-zero = entering; zero = leaving */
        SInt16  reserved1;
        SInt32  reserved2[4];
    } proximity;
} NXEventData;

/* The current version number of the NXEventData structure. */

#define kNXEventDataVersion		2

/* Finally! The event record! */
#ifndef __ppc__
typedef struct _NXEvent {
	SInt32              type;		/* An event type from above */
    struct {
        SInt32	x, y;					/* Base coordinates in window, */
    } 					location;	/* from bottom left */
    UInt64              time __attribute__ ((packed));		/* time since launch */
    SInt32              flags;		/* key state flags */
    UInt32              window;		/* window number of assigned window */
    UInt64              service_id __attribute__ ((packed)); /* service id */
    SInt32              ext_pid;    /* external pid */
    NXEventData			data;		/* type-dependent data */
} NXEvent, *NXEventPtr;

#else

typedef struct _NXEvent {
	SInt32              type;		/* An event type from above */
    struct {
        SInt32	x, y;					/* Base coordinates in window, */
    } 					location;	/* from bottom left */
    UInt64              time __attribute__ ((packed));		/* time since launch */
    SInt32              flags;		/* key state flags */
    UInt32              window;		/* window number of assigned window */
    NXEventData			data;		/* type-dependent data */
    UInt64              service_id __attribute__ ((packed)); /* service id */
    SInt32              ext_pid;    /* external pid */
} NXEvent, *NXEventPtr;
#endif

/* The current version number of the NXEvent structure. */

#define kNXEventVersion		2

/* How to pick window(s) for event (for PostEvent) */
#define NX_NOWINDOW		-1
#define NX_BYTYPE		0
#define NX_BROADCAST		1
#define NX_TOPWINDOW		2
#define NX_FIRSTWINDOW		3
#define NX_MOUSEWINDOW		4
#define NX_NEXTWINDOW		5
#define NX_LASTLEFT		6
#define NX_LASTRIGHT		7
#define NX_LASTKEY		8
#define NX_EXPLICIT		9
#define NX_TRANSMIT		10
#define NX_BYPSCONTEXT		11

#endif /* EVENT_H */	/* End of defs common with dpsclient/event.h */

/* Mask of events that cause the screen to wake up */
#define NX_WAKEMASK     (   NX_KEYDOWNMASK | NX_FLAGSCHANGEDMASK | \
                            NX_LMOUSEDOWNMASK | NX_LMOUSEUPMASK | \
                            NX_RMOUSEDOWNMASK | NX_RMOUSEUPMASK | \
                            NX_OMOUSEDOWNMASK | NX_OMOUSEUPMASK   \
                        )

/* Mask of events that cause screen to undim */
#define NX_UNDIMMASK    (   NX_WAKEMASK | NX_KEYUPMASK | NX_SCROLLWHEELMOVEDMASK | \
                            NX_LMOUSEDRAGGEDMASK | NX_RMOUSEDRAGGEDMASK | NX_OMOUSEDRAGGEDMASK | \
                            NX_MOUSEMOVEDMASK | NX_MOUSEENTEREDMASK | NX_MOUSEEXITEDMASK | \
                            NX_TABLETPOINTERMASK | NX_TABLETPROXIMITYMASK \
                        )

#endif /* !_DEV_EVENT_H */

                           ev_keymap.h                                                                                         0100644 0001750 0001750 00000014105 12567452123 034745  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * @APPLE_LICENSE_HEADER_START@
 *
 * Copyright (c) 1999-2003 Apple Computer, Inc.  All Rights Reserved.
 *
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 *
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 *
 * @APPLE_LICENSE_HEADER_END@
 */
/* 	Copyright (c) 1992 NeXT Computer, Inc.  All rights reserved.
 *
 *	ev_keymap.h
 *	Defines the structure used for parsing keymappings.  These structures
 *	and definitions are used by event sources in the kernel and by
 *	applications and utilities which manipulate keymaps.
 *
 * HISTORY
 * 02-Jun-1992    Mike Paquette at NeXT
 *      Created.
 */

#ifndef _DEV_EV_KEYMAP_H
#define _DEV_EV_KEYMAP_H

#define	NX_NUMKEYCODES	256	/* Highest key code is 0xff. ADB used to use 0x80 for keydown state, but who the heck uses adb anymore. */
#define NX_NUMSEQUENCES	128	/* Maximum possible number of sequences */
#define	NX_NUMMODIFIERS	16	/* Maximum number of modifier bits */
#define	NX_BYTE_CODES	0	/* If first short 0, all are bytes (else shorts) */

#define	NX_WHICHMODMASK	0x0f 	/* bits out of keyBits for bucky bits */
#define	NX_MODMASK	0x10	/* Bit out of keyBits indicates modifier bit */
#define	NX_CHARGENMASK	0x20	/* bit out of keyBits for char gen */
#define	NX_SPECIALKEYMASK 0x40	/* bit out of keyBits for specialty key */
#define	NX_KEYSTATEMASK	0x80	/* OBSOLETE - DO NOT USE IN NEW DESIGNS */

/*
 * Special keys currently known to and understood by the system.
 * If new specialty keys are invented, extend this list as appropriate.
 * The presence of these keys in a particular implementation is not
 * guaranteed.
 */
#define NX_NOSPECIALKEY			0xFFFF
#define NX_KEYTYPE_SOUND_UP		0
#define NX_KEYTYPE_SOUND_DOWN		1
#define NX_KEYTYPE_BRIGHTNESS_UP	2
#define NX_KEYTYPE_BRIGHTNESS_DOWN	3
#define NX_KEYTYPE_CAPS_LOCK		4
#define NX_KEYTYPE_HELP			5
#define NX_POWER_KEY			6
#define	NX_KEYTYPE_MUTE			7
#define NX_UP_ARROW_KEY			8
#define NX_DOWN_ARROW_KEY		9
#define NX_KEYTYPE_NUM_LOCK		10

#define NX_KEYTYPE_CONTRAST_UP		11
#define NX_KEYTYPE_CONTRAST_DOWN	12
#define NX_KEYTYPE_LAUNCH_PANEL		13
#define NX_KEYTYPE_EJECT		14
#define NX_KEYTYPE_VIDMIRROR		15

#define NX_KEYTYPE_PLAY			16
#define NX_KEYTYPE_NEXT			17
#define NX_KEYTYPE_PREVIOUS		18
#define NX_KEYTYPE_FAST			19
#define NX_KEYTYPE_REWIND		20

#define NX_KEYTYPE_ILLUMINATION_UP	21
#define NX_KEYTYPE_ILLUMINATION_DOWN	22
#define NX_KEYTYPE_ILLUMINATION_TOGGLE	23

#define	NX_NUMSPECIALKEYS		24 /* Maximum number of special keys */
#define NX_NUM_SCANNED_SPECIALKEYS	24 /* First 24 special keys are */
					  /* actively scanned in kernel */

/* Mask of special keys that are posted as events */

#define NX_SPECIALKEY_POST_MASK		\
                                ((1 << NX_KEYTYPE_SOUND_UP) | (1 << NX_KEYTYPE_SOUND_DOWN) | \
                                (1 << NX_POWER_KEY) | (1 << NX_KEYTYPE_MUTE) | \
                                (1 << NX_KEYTYPE_BRIGHTNESS_UP) | (1 << NX_KEYTYPE_BRIGHTNESS_DOWN) | \
                                (1 << NX_KEYTYPE_CONTRAST_UP) | (1 << NX_KEYTYPE_CONTRAST_UP) | \
                                (1 << NX_KEYTYPE_LAUNCH_PANEL) | (1 << NX_KEYTYPE_EJECT) | \
                                (1 << NX_KEYTYPE_VIDMIRROR) | (1 << NX_KEYTYPE_PLAY) | \
                                (1 << NX_KEYTYPE_NEXT) | (1 << NX_KEYTYPE_PREVIOUS) | \
                                (1 << NX_KEYTYPE_FAST) | (1 << NX_KEYTYPE_REWIND) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_UP) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_DOWN) | \
                                (1 << NX_KEYTYPE_ILLUMINATION_TOGGLE) | 0)

/* Modifier key indices into modDefs[] */
#define NX_MODIFIERKEY_ALPHALOCK	0
#define NX_MODIFIERKEY_SHIFT		1
#define NX_MODIFIERKEY_CONTROL		2
#define NX_MODIFIERKEY_ALTERNATE	3
#define NX_MODIFIERKEY_COMMAND		4
#define NX_MODIFIERKEY_NUMERICPAD	5
#define NX_MODIFIERKEY_HELP		6
#define NX_MODIFIERKEY_SECONDARYFN     	7
#define NX_MODIFIERKEY_NUMLOCK		8

/* support for right hand modifier */
#define NX_MODIFIERKEY_RSHIFT		9
#define NX_MODIFIERKEY_RCONTROL		10
#define NX_MODIFIERKEY_RALTERNATE	11
#define NX_MODIFIERKEY_RCOMMAND		12

#define NX_MODIFIERKEY_ALPHALOCK_STATELESS  13
#define NX_MODIFIERKEY_LAST_KEY     13


typedef struct _NXParsedKeyMapping_ {
 	/* If nonzero, all numbers are shorts; if zero, all numbers are bytes*/
	short	shorts;

	/*
	 *  For each keycode, low order bit says if the key
	 *  generates characters.
	 *  High order bit says if the key is assigned to a modifier bit.
	 *  The second to low order bit gives the current state of the key.
	 */
	char	keyBits[NX_NUMKEYCODES];

	/* Bit number of highest numbered modifier bit */
	int			maxMod;

	/* Pointers to where the list of keys for each modifiers bit begins,
	 * or NULL.
	 */
	unsigned char *modDefs[NX_NUMMODIFIERS];

	/* Key code of highest key deinfed to generate characters */
	int			numDefs;

	/* Pointer into the keyMapping where this key's definitions begin */
	unsigned char *keyDefs[NX_NUMKEYCODES];

	/* number of sequence definitions */
	int			numSeqs;

	/* pointers to sequences */
	unsigned char *seqDefs[NX_NUMSEQUENCES];

	/* Special key definitions */
	int			numSpecialKeys;

	/* Special key values, or 0xFFFF if none */
	unsigned short specialKeys[NX_NUMSPECIALKEYS];

	/* Pointer to the original keymapping string */
	const unsigned char *mapping;

	/* Length of the original string */
	int	mappingLen;
} NXParsedKeyMapping;

#endif /* !_DEV_EV_KEYMAP_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                           event_status_driver.h                                                                               0100644 0001750 0001750 00000006657 12566177313 037105  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/hidsystem                                                             /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/******************************************************************************
	event_status_driver.h
	API for the events status driver.
	This file contains public API.
	mpaque 11Oct91
	
	Copyright 1991 NeXT Computer, Inc.
	
	Modified:
	
******************************************************************************/

#ifndef _DRIVERS_EVENT_STATUS_DRIVER_
#define _DRIVERS_EVENT_STATUS_DRIVER_

__BEGIN_DECLS

#include <mach/port.h>
#include <IOKit/hidsystem/IOLLEvent.h>
#include <IOKit/hidsystem/IOHIDTypes.h>
#include <AvailabilityMacros.h> 

/*
 * Event System Handle:
 *
 * Information used by the system between calls to NXOpenEventSystem and
 * NXCloseEventSystem.  The application should not
 * access any of the elements of this structure.
 */
typedef mach_port_t NXEventHandle;

/* Open and Close */
NXEventHandle NXOpenEventStatus(void);
void NXCloseEventStatus(NXEventHandle handle);

/* Status */
extern NXEventSystemInfoType NXEventSystemInfo(NXEventHandle handle,
				char *flavor,
				int *evs_info,
				unsigned int *evs_info_cnt);
/* Keyboard */
extern void NXSetKeyRepeatInterval(NXEventHandle handle, double seconds);
extern double NXKeyRepeatInterval(NXEventHandle handle);
extern void NXSetKeyRepeatThreshold(NXEventHandle handle, double threshold);
extern double NXKeyRepeatThreshold(NXEventHandle handle);
extern void NXResetKeyboard(NXEventHandle handle);

/* Mouse */
extern void NXSetClickTime(NXEventHandle handle, double seconds);
extern double NXClickTime(NXEventHandle handle);
extern void NXSetClickSpace(NXEventHandle handle, _NXSize_ *area);
extern void NXGetClickSpace(NXEventHandle handle, _NXSize_ *area);
extern void NXResetMouse(NXEventHandle handle);

/*
* The following functions have been removed.
*
* NXIdleTime
* See CGEventSourceSecondsSinceLastEventType.
*
* NXSetKeyMapping
* NXKeyMappingLength
* NXGetKeyMapping
* These do not have a drop in replacement. See UCKeyTranslate.
*
* NXSetMouseScaling
* See IOHIDSetAccelerationWithKey and IOHIDSetMouseAcceleration.
*
* NXGetMouseScaling
* See IOHIDGetAccelerationWithKey and IOHIDGetMouseAcceleration.
*
* NXSetAutoDimThreshold
* NXSetAutoDimState
* See IOPMSetAggressiveness and kPMMinutesToDim.
*
* NXAutoDimThreshold
* NXAutoDimTime
* NXAutoDimState
* See IOPMGetAggressiveness and kPMMinutesToDim.
*
* NXSetAutoDimBrightness
* NXAutoDimBrightness
* NXSetScreenBrightness
* NXScreenBrightness
* This functionality is unsupported.
*/

__END_DECLS

#endif /*_DRIVERS_EVENT_STATUS_DRIVER_ */

                                                                                 i2c/                                                                                                0040755 0001750 0001750 00000000000 12612224741 031254  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOI2CInterface.h                                                                                    0100644 0001750 0001750 00000027114 12567452457 034075  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/i2c                                                                   /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#ifndef _IOKIT_IOI2CINTERFACE_H
#define _IOKIT_IOI2CINTERFACE_H

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

typedef struct IOI2CRequest IOI2CRequest;
typedef struct IOI2CBuffer IOI2CBuffer;

typedef void (*IOI2CRequestCompletion) (IOI2CRequest * request);

// IOI2CRequest.sendTransactionType, IOI2CRequest.replyTransactionType
enum {
    kIOI2CNoTransactionType         = 0,
    kIOI2CSimpleTransactionType     = 1,
    kIOI2CDDCciReplyTransactionType = 2,
    kIOI2CCombinedTransactionType   = 3,
    kIOI2CDisplayPortNativeTransactionType = 4
};

// IOI2CRequest.commFlags
enum {
    kIOI2CUseSubAddressCommFlag     = 0x00000002
};

/*!
 * @struct IOI2CRequest
 * @abstract A structure defining an I2C bus transaction.
 * @discussion This structure is used to request an I2C transaction consisting of a send (write) to and reply (read) from a device, either of which is optional, to be carried out atomically on an I2C bus.
 * @field __reservedA Set to zero.
 * @field result The result of the transaction. Common errors are kIOReturnNoDevice if there is no device responding at the given address, kIOReturnUnsupportedMode if the type of transaction is unsupported on the requested bus.
 * @field completion A completion routine to be executed when the request completes. If NULL is passed, the request is synchronous, otherwise it may execute asynchronously.
 * @field commFlags Flags that modify the I2C transaction type. The following flags are defined:<br>
 *      kIOI2CUseSubAddressCommFlag Transaction includes a subaddress.<br>
 * @field minReplyDelay Minimum delay as absolute time between send and reply transactions.
 * @field sendAddress I2C address to write.
 * @field sendSubAddress I2C subaddress to write.
 * @field __reservedB Set to zero.
 * @field sendTransactionType The following types of transaction are defined for the send part of the request:<br>
 *      kIOI2CNoTransactionType No send transaction to perform. <br>
 *      kIOI2CSimpleTransactionType Simple I2C message. <br>
 *      kIOI2CCombinedTransactionType Combined format I2C R/~W transaction. <br>
 * @field sendBuffer Pointer to the send buffer.
 * @field sendBytes Number of bytes to send. Set to actual bytes sent on completion of the request.
 * @field replyAddress I2C Address from which to read.
 * @field replySubAddress I2C Address from which to read.
 * @field __reservedC Set to zero.
 * @field replyTransactionType The following types of transaction are defined for the reply part of the request:<br>
 *      kIOI2CNoTransactionType No reply transaction to perform. <br>
 *      kIOI2CSimpleTransactionType Simple I2C message. <br>
 *      kIOI2CDDCciReplyTransactionType DDC/ci message (with embedded length). See VESA DDC/ci specification. <br>
 *      kIOI2CCombinedTransactionType Combined format I2C R/~W transaction. <br>
 * @field replyBuffer Pointer to the reply buffer.
 * @field replyBytes Max bytes to reply (size of replyBuffer). Set to actual bytes received on completion of the request.
 * @field __reservedD Set to zero.
 */

#pragma pack(push, 4)
struct IOI2CRequest
{
    IOOptionBits                sendTransactionType;
    IOOptionBits                replyTransactionType;
    uint32_t                    sendAddress;
    uint32_t                    replyAddress;
    uint8_t                     sendSubAddress;
    uint8_t                     replySubAddress;
    uint8_t                     __reservedA[2];

    uint64_t                    minReplyDelay;

    IOReturn                    result;
    IOOptionBits                commFlags;

#if defined(__LP64__)
    uint32_t                    __padA;
#else
    vm_address_t                sendBuffer;
#endif
    uint32_t                    sendBytes;

    uint32_t                    __reservedB[2];

#if defined(__LP64__)
    uint32_t                    __padB;
#else
    vm_address_t                replyBuffer;
#endif
    uint32_t                    replyBytes;

    IOI2CRequestCompletion      completion;
#if !defined(__LP64__)
    uint32_t                    __padC[5];
#else
    vm_address_t                sendBuffer;
    vm_address_t                replyBuffer;
#endif

    uint32_t                    __reservedC[10];
#ifdef __ppc__
    uint32_t                    __reservedD;
#endif
};
#pragma pack(pop)

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#define kIOI2CInterfaceClassName        "IOI2CInterface"

#define kIOI2CInterfaceIDKey            "IOI2CInterfaceID"
#define kIOI2CBusTypeKey                "IOI2CBusType"
#define kIOI2CTransactionTypesKey       "IOI2CTransactionTypes"
#define kIOI2CSupportedCommFlagsKey     "IOI2CSupportedCommFlags"

#define kIOFBI2CInterfaceInfoKey        "IOFBI2CInterfaceInfo"
#define kIOFBI2CInterfaceIDsKey         "IOFBI2CInterfaceIDs"

// kIOI2CBusTypeKey values
enum {
    kIOI2CBusTypeI2C            = 1,
    kIOI2CBusTypeDisplayPort    = 2
};

/*!
 * @struct IOI2CBusTiming
 * @abstract A structure defining low level timing for an I2C bus.
 * @discussion This structure is used to specify timeouts and pulse widths for an I2C bus implementation.
 * @field bitTimeout Maximum time a slave can delay (by pulling the clock line low) a single bit response.
 * @field byteTimeout Maximum time a slave can delay (by pulling the clock line low) the first bit of a byte response.
 * @field acknowledgeTimeout Maximum time to wait for a slave to respond with an ACK after writing a byte.
 * @field startTimeout Maximum time to wait for a slave to respond after a start signal.
 * @field riseFallTime Time to wait after any change in output signal.
 * @field __reservedA Set to zero.
 */

struct IOI2CBusTiming
{
    AbsoluteTime                bitTimeout;
    AbsoluteTime                byteTimeout;
    AbsoluteTime                acknowledgeTimeout;
    AbsoluteTime                startTimeout;
    AbsoluteTime                holdTime;
    AbsoluteTime                riseFallTime;
    UInt32                      __reservedA[8];
};
typedef struct IOI2CBusTiming IOI2CBusTiming;

#ifndef KERNEL

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

// options for IOFBCopyI2CInterfaceForBus()
enum {
    kIOI2CBusNumberMask                 = 0x000000ff
};


/*! @function IOFBGetI2CInterfaceCount
    @abstract Returns a count of I2C interfaces available associated with an IOFramebuffer instance.
    @discussion Returns a count of I2C interfaces available associated with an IOFramebuffer instance.
    @param framebuffer The io_service_t of an IOFramebuffer instance. CoreGraphics will provide this for a CGDisplay with the CGDisplayIOServicePort() call.
    @param count Interface count is returned.
    @result An IOReturn code. */

IOReturn IOFBGetI2CInterfaceCount( io_service_t framebuffer, IOItemCount * count );

/*! @function IOFBCopyI2CInterfaceForBus
    @abstract Returns an instance of an I2C bus interface, associated with an IOFramebuffer instance / bus index pair.
    @discussion Some graphics devices will allow access to an I2C bus routed through a display connector in order to control external devices on that bus. This function returns an instance of an I2C bus interface, associated with an IOFramebuffer instance / bus index pair. The number of I2C buses is available from the IOFBGetI2CInterfaceCount() call. The interface may be used with the IOI2CInterfaceOpen/Close/SendRequest() calls to carry out I2C transactions on that bus. Not all graphics devices support this functionality.
    @param bus The zero based index of the bus on the requested framebuffer.
    @param interface The interface instance is returned. The caller should release this instance with IOObjectRelease().
    @result An IOReturn code. */

IOReturn IOFBCopyI2CInterfaceForBus( io_service_t framebuffer, IOOptionBits bus, io_service_t * interface );

typedef struct IOI2CConnect * IOI2CConnectRef;  /* struct IOI2CConnect is opaque */

IOReturn IOI2CCopyInterfaceForID( CFTypeRef identifier, io_service_t * interface );

/*! @function IOI2CInterfaceOpen
    @abstract Opens an instance of an I2C bus interface, allowing I2C requests to be made.
    @discussion An instance of an I2C bus interface, obtained by IOFBCopyI2CInterfaceForBus, is opened with this function allowing I2C requests to be made.
    @param interface An I2C bus interface (see IOFBCopyI2CInterfaceForBus). The interface may be released after this call is made.
    @param options Pass kNilOptions.
    @param connect The opaque IOI2CConnectRef is returned, for use with IOI2CSendRequest() and IOI2CInterfaceClose().
    @result An IOReturn code. */

IOReturn IOI2CInterfaceOpen( io_service_t interface, IOOptionBits options,
                             IOI2CConnectRef * connect );

/*! @function IOI2CInterfaceClose
    @abstract Closes an IOI2CConnectRef.
    @discussion Frees the resources associated with an IOI2CConnectRef.
    @param connect The opaque IOI2CConnectRef returned by IOI2CInterfaceOpen().
    @param options Pass kNilOptions.
    @result An IOReturn code. */

IOReturn IOI2CInterfaceClose( IOI2CConnectRef connect, IOOptionBits options );

/*! @function IOI2CSendRequest
    @abstract Carries out the I2C transaction specified by an IOI2CRequest structure.
    @discussion Frees the resources associated with an IOI2CConnectRef.
    @param connect The opaque IOI2CConnectRef returned by IOI2CInterfaceOpen().
    @param options Pass kNilOptions.
    @param request Pass a pointer to a IOI2CRequest structure describing the request. If an asynchronous request (with a non-NULL completion routine) the request structure must be valid for the life of the request.
    @result An IOReturn code reflecting only the result of starting the transaction. If the result of IOI2CSendRequest() is kIOReturnSuccess, the I2C transaction result is returned in the result field of the request structure. */

IOReturn IOI2CSendRequest( IOI2CConnectRef connect, IOOptionBits options, 
                           IOI2CRequest * request );

#else

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

/*! @class IOI2CInterface
    @abstract The base class for an I2C bus interface.
    @discussion The IOI2CInterface base class defines an I2C bus interface. Not useful for developers. */

class IOI2CInterface : public IOService
{
    OSDeclareDefaultStructors(IOI2CInterface)
    
protected:
    UInt64      fID;

public:
    IOReturn newUserClient( task_t              owningTask,
                            void *              security_id,
                            UInt32              type,
                            IOUserClient **     handler );

    bool registerI2C( UInt64 id );

    virtual IOReturn startIO( IOI2CRequest * request ) = 0;
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#endif /* KERNEL */

#endif /* ! _IOKIT_IOI2CINTERFACE_H */

                                                                                                                                                                                                                                                                                                                                                                                                                                                    iokitmig.h                                                                                          0100644 0001750 0001750 00000277372 12566177365 032624  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       #if !defined(__LP64__)

#ifndef	_iokit_user_
#define	_iokit_user_

/* Module iokit */

#include <string.h>
#include <mach/ndr.h>
#include <mach/boolean.h>
#include <mach/kern_return.h>
#include <mach/notify.h>
#include <mach/mach_types.h>
#include <mach/message.h>
#include <mach/mig_errors.h>
#include <mach/port.h>

#ifdef AUTOTEST
#ifndef FUNCTION_PTR_T
#define FUNCTION_PTR_T
typedef void (*function_ptr_t)(mach_port_t, char *, mach_msg_type_number_t);
typedef struct {
        char            *name;
        function_ptr_t  function;
} function_table_entry;
typedef function_table_entry   *function_table_t;
#endif /* FUNCTION_PTR_T */
#endif /* AUTOTEST */

#ifndef	iokit_MSG_COUNT
#define	iokit_MSG_COUNT	87
#endif	/* iokit_MSG_COUNT */

#include <mach/std_types.h>
#include <mach/mig.h>
#include <mach/mig.h>
#include <mach/mach_types.h>
#include <mach/mach_types.h>
#include <device/device_types.h>

#ifdef __BeforeMigUserHeader
__BeforeMigUserHeader
#endif /* __BeforeMigUserHeader */

#include <sys/cdefs.h>
__BEGIN_DECLS


/* Routine io_object_get_class */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_class
(
	mach_port_t object,
	io_name_t className
);

/* Routine io_object_conforms_to */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_conforms_to
(
	mach_port_t object,
	io_name_t className,
	boolean_t *conforms
);

/* Routine io_iterator_next */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_next
(
	mach_port_t iterator,
	mach_port_t *object
);

/* Routine io_iterator_reset */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_reset
(
	mach_port_t iterator
);

/* Routine io_service_get_matching_services */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *existing
);

/* Routine io_registry_entry_get_property */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_create_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_create_iterator
(
	mach_port_t master_port,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
);

/* Routine io_registry_iterator_enter_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_iterator_enter_entry
(
	mach_port_t iterator
);

/* Routine io_registry_iterator_exit_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_iterator_exit_entry
(
	mach_port_t iterator
);

/* Routine io_registry_entry_from_path */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_from_path
(
	mach_port_t master_port,
	io_string_t path,
	mach_port_t *registry_entry
);

/* Routine io_registry_entry_get_name */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_name
(
	mach_port_t registry_entry,
	io_name_t name
);

/* Routine io_registry_entry_get_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_entry_get_property_bytes */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_bytes
(
	mach_port_t registry_entry,
	io_name_t property_name,
	io_struct_inband_t data,
	mach_msg_type_number_t *dataCnt
);

/* Routine io_registry_entry_get_child_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_child_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
);

/* Routine io_registry_entry_get_parent_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_parent_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	mach_port_t *iterator
);

/* Routine io_service_close */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_close
(
	mach_port_t connection
);

/* Routine io_connect_get_service */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_get_service
(
	mach_port_t connection,
	mach_port_t *service
);

/* Routine io_connect_set_notification_port */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_set_notification_port
(
	mach_port_t connection,
	uint32_t notification_type,
	mach_port_t port,
	uint32_t reference
);

/* Routine io_connect_map_memory */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_map_memory
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t into_task,
	vm_address_t *address,
	vm_size_t *size,
	uint32_t flags
);

/* Routine io_connect_add_client */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_add_client
(
	mach_port_t connection,
	mach_port_t connect_to
);

/* Routine io_connect_set_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_set_properties
(
	mach_port_t connection,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
);

/* Routine io_connect_method_scalarI_scalarO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_scalarI_scalarO
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_scalar_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_connect_method_scalarI_structureO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_scalarI_structureO
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_connect_method_scalarI_structureI */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_scalarI_structureI
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t inputStruct,
	mach_msg_type_number_t inputStructCnt
);

/* Routine io_connect_method_structureI_structureO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_structureI_structureO
(
	mach_port_t connection,
	uint32_t selector,
	io_struct_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_registry_entry_get_path */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_path
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_t path
);

/* Routine io_registry_get_root_entry */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_get_root_entry
(
	mach_port_t master_port,
	mach_port_t *root
);

/* Routine io_registry_entry_set_properties */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_set_properties
(
	mach_port_t registry_entry,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result
);

/* Routine io_registry_entry_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	boolean_t *inPlane
);

/* Routine io_object_get_retain_count */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_retain_count
(
	mach_port_t object,
	uint32_t *retainCount
);

/* Routine io_service_get_busy_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_busy_state
(
	mach_port_t service,
	uint32_t *busyState
);

/* Routine io_service_wait_quiet */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_wait_quiet
(
	mach_port_t service,
	mach_timespec_t wait_time
);

/* Routine io_registry_entry_create_iterator */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_create_iterator
(
	mach_port_t registry_entry,
	io_name_t plane,
	uint32_t options,
	mach_port_t *iterator
);

/* Routine io_iterator_is_valid */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_iterator_is_valid
(
	mach_port_t iterator,
	boolean_t *is_valid
);

/* Routine io_catalog_send_data */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_send_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t inData,
	mach_msg_type_number_t inDataCnt,
	kern_return_t *result
);

/* Routine io_catalog_terminate */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_terminate
(
	mach_port_t master_port,
	uint32_t flag,
	io_name_t name
);

/* Routine io_catalog_get_data */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_get_data
(
	mach_port_t master_port,
	uint32_t flag,
	io_buf_ptr_t *outData,
	mach_msg_type_number_t *outDataCnt
);

/* Routine io_catalog_get_gen_count */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_get_gen_count
(
	mach_port_t master_port,
	uint32_t *genCount
);

/* Routine io_catalog_module_loaded */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_module_loaded
(
	mach_port_t master_port,
	io_name_t name
);

/* Routine io_catalog_reset */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_catalog_reset
(
	mach_port_t master_port,
	uint32_t flag
);

/* Routine io_service_request_probe */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_request_probe
(
	mach_port_t service,
	uint32_t options
);

/* Routine io_registry_entry_get_name_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_name_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t name
);

/* Routine io_service_match_property_table */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table
(
	mach_port_t service,
	io_string_t matching,
	boolean_t *matches
);

/* Routine io_async_method_scalarI_scalarO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_async_method_scalarI_scalarO
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_scalar_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_async_method_scalarI_structureO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_async_method_scalarI_structureO
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_async_method_scalarI_structureI */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_async_method_scalarI_structureI
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t inputStruct,
	mach_msg_type_number_t inputStructCnt
);

/* Routine io_async_method_structureI_structureO */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_async_method_structureI_structureO
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_struct_inband_t input,
	mach_msg_type_number_t inputCnt,
	io_struct_inband_t output,
	mach_msg_type_number_t *outputCnt
);

/* Routine io_service_add_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_string_t matching,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_service_add_interest_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_interest_notification
(
	mach_port_t service,
	io_name_t type_of_interest,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_service_acknowledge_notification */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_acknowledge_notification
(
	mach_port_t service,
	natural_t notify_ref,
	natural_t response
);

/* Routine io_connect_get_notification_semaphore */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_get_notification_semaphore
(
	mach_port_t connection,
	natural_t notification_type,
	semaphore_t *semaphore
);

/* Routine io_connect_unmap_memory */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_unmap_memory
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t into_task,
	vm_address_t address
);

/* Routine io_registry_entry_get_location_in_plane */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_location_in_plane
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t location
);

/* Routine io_registry_entry_get_property_recursively */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_recursively
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_service_get_state */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_state
(
	mach_port_t service,
	uint64_t *state,
	uint32_t *busy_state,
	uint64_t *accumulated_busy_time
);

/* Routine io_service_get_matching_services_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *existing
);

/* Routine io_service_match_property_table_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table_ool
(
	mach_port_t service,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	boolean_t *matches
);

/* Routine io_service_add_notification_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification_ool
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	kern_return_t *result,
	mach_port_t *notification
);

/* Routine io_object_get_superclass */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_superclass
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
);

/* Routine io_object_get_bundle_identifier */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_object_get_bundle_identifier
(
	mach_port_t master_port,
	io_name_t obj_name,
	io_name_t class_name
);

/* Routine io_service_open_extended */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_open_extended
(
	mach_port_t service,
	task_t owningTask,
	uint32_t connect_type,
	NDR_record_t ndr,
	io_buf_ptr_t properties,
	mach_msg_type_number_t propertiesCnt,
	kern_return_t *result,
	mach_port_t *connection
);

/* Routine io_connect_map_memory_into_task */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_map_memory_into_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t into_task,
	mach_vm_address_t *address,
	mach_vm_size_t *size,
	uint32_t flags
);

/* Routine io_connect_unmap_memory_from_task */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_unmap_memory_from_task
(
	mach_port_t connection,
	uint32_t memory_type,
	task_t from_task,
	mach_vm_address_t address
);

/* Routine io_connect_method */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
);

/* Routine io_connect_async_method */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_async_method
(
	mach_port_t connection,
	mach_port_t wake_port,
	io_async_ref64_t reference,
	mach_msg_type_number_t referenceCnt,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	mach_vm_address_t ool_output,
	mach_vm_size_t *ool_output_size
);

/* Routine io_registry_entry_get_registry_entry_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_registry_entry_id
(
	mach_port_t registry_entry,
	uint64_t *entry_id
);

/* Routine io_connect_method_var_output */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_connect_method_var_output
(
	mach_port_t connection,
	uint32_t selector,
	io_scalar_inband64_t scalar_input,
	mach_msg_type_number_t scalar_inputCnt,
	io_struct_inband_t inband_input,
	mach_msg_type_number_t inband_inputCnt,
	mach_vm_address_t ool_input,
	mach_vm_size_t ool_input_size,
	io_struct_inband_t inband_output,
	mach_msg_type_number_t *inband_outputCnt,
	io_scalar_inband64_t scalar_output,
	mach_msg_type_number_t *scalar_outputCnt,
	io_buf_ptr_t *var_output,
	mach_msg_type_number_t *var_outputCnt
);

/* Routine io_service_get_matching_service */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service
(
	mach_port_t master_port,
	io_string_t matching,
	mach_port_t *service
);

/* Routine io_service_get_matching_service_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service_ool
(
	mach_port_t master_port,
	io_buf_ptr_t matching,
	mach_msg_type_number_t matchingCnt,
	kern_return_t *result,
	mach_port_t *service
);

/* Routine io_service_get_authorization_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_authorization_id
(
	mach_port_t service,
	uint64_t *authorization_id
);

/* Routine io_service_set_authorization_id */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_set_authorization_id
(
	mach_port_t service,
	uint64_t authorization_id
);

/* Routine io_server_version */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_server_version
(
	mach_port_t master_port,
	uint64_t *version
);

/* Routine io_registry_entry_get_properties_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_properties_bin
(
	mach_port_t registry_entry,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_registry_entry_get_property_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_property_bin
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_name_t property_name,
	uint32_t options,
	io_buf_ptr_t *properties,
	mach_msg_type_number_t *propertiesCnt
);

/* Routine io_service_get_matching_service_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_service_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *service
);

/* Routine io_service_get_matching_services_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_get_matching_services_bin
(
	mach_port_t master_port,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t *existing
);

/* Routine io_service_match_property_table_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_match_property_table_bin
(
	mach_port_t service,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	boolean_t *matches
);

/* Routine io_service_add_notification_bin */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_service_add_notification_bin
(
	mach_port_t master_port,
	io_name_t notification_type,
	io_struct_inband_t matching,
	mach_msg_type_number_t matchingCnt,
	mach_port_t wake_port,
	io_async_ref_t reference,
	mach_msg_type_number_t referenceCnt,
	mach_port_t *notification
);

/* Routine io_registry_entry_get_path_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_get_path_ool
(
	mach_port_t registry_entry,
	io_name_t plane,
	io_string_inband_t path,
	io_buf_ptr_t *path_ool,
	mach_msg_type_number_t *path_oolCnt
);

/* Routine io_registry_entry_from_path_ool */
#ifdef	mig_external
mig_external
#else
extern
#endif	/* mig_external */
kern_return_t io_registry_entry_from_path_ool
(
	mach_port_t master_port,
	io_string_inband_t path,
	io_buf_ptr_t path_ool,
	mach_msg_type_number_t path_oolCnt,
	kern_return_t *result,
	mach_port_t *registry_entry
);

__END_DECLS

/********************** Caution **************************/
/* The following data types should be used to calculate  */
/* maximum message sizes only. The actual message may be */
/* smaller, and the position of the arguments within the */
/* message layout may vary from what is presented here.  */
/* For example, if any of the arguments are variable-    */
/* sized, and less than the maximum is sent, the data    */
/* will be packed tight in the actual message to reduce  */
/* the presence of holes.                                */
/********************** Caution **************************/

/* typedefs for all requests */

#ifndef __Request__iokit_subsystem__defined
#define __Request__iokit_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_object_get_class_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} __Request__io_object_conforms_to_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_next_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_get_matching_services_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
	} __Request__io_registry_entry_get_property_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} __Request__io_registry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_iterator_enter_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_iterator_exit_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} __Request__io_registry_entry_from_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		mach_msg_type_number_t dataCnt;
	} __Request__io_registry_entry_get_property_bytes_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_child_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_parent_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_close_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_connect_get_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t notification_type;
		uint32_t reference;
	} __Request__io_connect_set_notification_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t into_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		vm_address_t address;
		vm_size_t size;
		uint32_t flags;
	} __Request__io_connect_map_memory_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connect_to;
		/* end of the kernel processed data */
	} __Request__io_connect_add_client_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_connect_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t outputCnt;
	} __Request__io_connect_method_scalarI_scalarO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t outputCnt;
	} __Request__io_connect_method_scalarI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t inputStructCnt;
		char inputStruct[4096];
	} __Request__io_connect_method_scalarI_structureI_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		char input[4096];
		mach_msg_type_number_t outputCnt;
	} __Request__io_connect_method_structureI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_get_root_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_registry_entry_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_object_get_retain_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_busy_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_timespec_t wait_time;
	} __Request__io_service_wait_quiet_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		uint32_t options;
	} __Request__io_registry_entry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_iterator_is_valid_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t inData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t inDataCnt;
	} __Request__io_catalog_send_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Request__io_catalog_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} __Request__io_catalog_get_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_catalog_get_gen_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Request__io_catalog_module_loaded_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t flag;
	} __Request__io_catalog_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t options;
	} __Request__io_service_request_probe_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_name_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_match_property_table_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t outputCnt;
	} __Request__io_async_method_scalarI_scalarO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t outputCnt;
	} __Request__io_async_method_scalarI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		io_user_scalar_t input[16];
		mach_msg_type_number_t inputStructCnt;
		char inputStruct[4096];
	} __Request__io_async_method_scalarI_structureI_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t inputCnt;
		char input[4096];
		mach_msg_type_number_t outputCnt;
	} __Request__io_async_method_structureI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t type_of_interestOffset; /* MiG doesn't use it */
		mach_msg_type_number_t type_of_interestCnt;
		char type_of_interest[128];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_interest_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		natural_t notify_ref;
		natural_t response;
	} __Request__io_service_acknowledge_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		natural_t notification_type;
	} __Request__io_connect_get_notification_semaphore_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t into_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		vm_address_t address;
	} __Request__io_connect_unmap_memory_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_location_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} __Request__io_registry_entry_get_property_recursively_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_get_matching_services_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_match_property_table_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} __Request__io_object_get_superclass_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t obj_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t obj_nameCnt;
		char obj_name[128];
	} __Request__io_object_get_bundle_identifier_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t owningTask;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t connect_type;
		NDR_record_t ndr;
		mach_msg_type_number_t propertiesCnt;
	} __Request__io_service_open_extended_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t into_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
		mach_vm_size_t size;
		uint32_t flags;
	} __Request__io_connect_map_memory_into_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t from_task;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		uint32_t memory_type;
		mach_vm_address_t address;
	} __Request__io_connect_unmap_memory_from_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		uint64_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} __Request__io_connect_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t referenceCnt;
		uint64_t reference[8];
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		uint64_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
		mach_vm_address_t ool_output;
		mach_vm_size_t ool_output_size;
	} __Request__io_connect_async_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_registry_entry_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint32_t selector;
		mach_msg_type_number_t scalar_inputCnt;
		uint64_t scalar_input[16];
		mach_msg_type_number_t inband_inputCnt;
		char inband_input[4096];
		mach_vm_address_t ool_input;
		mach_vm_size_t ool_input_size;
		mach_msg_type_number_t inband_outputCnt;
		mach_msg_type_number_t scalar_outputCnt;
	} __Request__io_connect_method_var_output_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingOffset; /* MiG doesn't use it */
		mach_msg_type_number_t matchingCnt;
		char matching[512];
	} __Request__io_service_get_matching_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t matching;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
	} __Request__io_service_get_matching_service_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_service_get_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		uint64_t authorization_id;
	} __Request__io_service_set_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_server_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
	} __Request__io_registry_entry_get_properties_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
		mach_msg_type_number_t property_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t property_nameCnt;
		char property_name[128];
		uint32_t options;
	} __Request__io_registry_entry_get_property_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_get_matching_service_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_get_matching_services_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
	} __Request__io_service_match_property_table_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t wake_port;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t notification_typeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t notification_typeCnt;
		char notification_type[128];
		mach_msg_type_number_t matchingCnt;
		char matching[4096];
		mach_msg_type_number_t referenceCnt;
		io_user_reference_t reference[8];
	} __Request__io_service_add_notification_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		mach_msg_type_number_t planeOffset; /* MiG doesn't use it */
		mach_msg_type_number_t planeCnt;
		char plane[128];
	} __Request__io_registry_entry_get_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} __Request__io_registry_entry_from_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Request__iokit_subsystem__defined */

/* union of all requests */

#ifndef __RequestUnion__iokit_subsystem__defined
#define __RequestUnion__iokit_subsystem__defined
union __RequestUnion__iokit_subsystem {
	__Request__io_object_get_class_t Request_io_object_get_class;
	__Request__io_object_conforms_to_t Request_io_object_conforms_to;
	__Request__io_iterator_next_t Request_io_iterator_next;
	__Request__io_iterator_reset_t Request_io_iterator_reset;
	__Request__io_service_get_matching_services_t Request_io_service_get_matching_services;
	__Request__io_registry_entry_get_property_t Request_io_registry_entry_get_property;
	__Request__io_registry_create_iterator_t Request_io_registry_create_iterator;
	__Request__io_registry_iterator_enter_entry_t Request_io_registry_iterator_enter_entry;
	__Request__io_registry_iterator_exit_entry_t Request_io_registry_iterator_exit_entry;
	__Request__io_registry_entry_from_path_t Request_io_registry_entry_from_path;
	__Request__io_registry_entry_get_name_t Request_io_registry_entry_get_name;
	__Request__io_registry_entry_get_properties_t Request_io_registry_entry_get_properties;
	__Request__io_registry_entry_get_property_bytes_t Request_io_registry_entry_get_property_bytes;
	__Request__io_registry_entry_get_child_iterator_t Request_io_registry_entry_get_child_iterator;
	__Request__io_registry_entry_get_parent_iterator_t Request_io_registry_entry_get_parent_iterator;
	__Request__io_service_close_t Request_io_service_close;
	__Request__io_connect_get_service_t Request_io_connect_get_service;
	__Request__io_connect_set_notification_port_t Request_io_connect_set_notification_port;
	__Request__io_connect_map_memory_t Request_io_connect_map_memory;
	__Request__io_connect_add_client_t Request_io_connect_add_client;
	__Request__io_connect_set_properties_t Request_io_connect_set_properties;
	__Request__io_connect_method_scalarI_scalarO_t Request_io_connect_method_scalarI_scalarO;
	__Request__io_connect_method_scalarI_structureO_t Request_io_connect_method_scalarI_structureO;
	__Request__io_connect_method_scalarI_structureI_t Request_io_connect_method_scalarI_structureI;
	__Request__io_connect_method_structureI_structureO_t Request_io_connect_method_structureI_structureO;
	__Request__io_registry_entry_get_path_t Request_io_registry_entry_get_path;
	__Request__io_registry_get_root_entry_t Request_io_registry_get_root_entry;
	__Request__io_registry_entry_set_properties_t Request_io_registry_entry_set_properties;
	__Request__io_registry_entry_in_plane_t Request_io_registry_entry_in_plane;
	__Request__io_object_get_retain_count_t Request_io_object_get_retain_count;
	__Request__io_service_get_busy_state_t Request_io_service_get_busy_state;
	__Request__io_service_wait_quiet_t Request_io_service_wait_quiet;
	__Request__io_registry_entry_create_iterator_t Request_io_registry_entry_create_iterator;
	__Request__io_iterator_is_valid_t Request_io_iterator_is_valid;
	__Request__io_catalog_send_data_t Request_io_catalog_send_data;
	__Request__io_catalog_terminate_t Request_io_catalog_terminate;
	__Request__io_catalog_get_data_t Request_io_catalog_get_data;
	__Request__io_catalog_get_gen_count_t Request_io_catalog_get_gen_count;
	__Request__io_catalog_module_loaded_t Request_io_catalog_module_loaded;
	__Request__io_catalog_reset_t Request_io_catalog_reset;
	__Request__io_service_request_probe_t Request_io_service_request_probe;
	__Request__io_registry_entry_get_name_in_plane_t Request_io_registry_entry_get_name_in_plane;
	__Request__io_service_match_property_table_t Request_io_service_match_property_table;
	__Request__io_async_method_scalarI_scalarO_t Request_io_async_method_scalarI_scalarO;
	__Request__io_async_method_scalarI_structureO_t Request_io_async_method_scalarI_structureO;
	__Request__io_async_method_scalarI_structureI_t Request_io_async_method_scalarI_structureI;
	__Request__io_async_method_structureI_structureO_t Request_io_async_method_structureI_structureO;
	__Request__io_service_add_notification_t Request_io_service_add_notification;
	__Request__io_service_add_interest_notification_t Request_io_service_add_interest_notification;
	__Request__io_service_acknowledge_notification_t Request_io_service_acknowledge_notification;
	__Request__io_connect_get_notification_semaphore_t Request_io_connect_get_notification_semaphore;
	__Request__io_connect_unmap_memory_t Request_io_connect_unmap_memory;
	__Request__io_registry_entry_get_location_in_plane_t Request_io_registry_entry_get_location_in_plane;
	__Request__io_registry_entry_get_property_recursively_t Request_io_registry_entry_get_property_recursively;
	__Request__io_service_get_state_t Request_io_service_get_state;
	__Request__io_service_get_matching_services_ool_t Request_io_service_get_matching_services_ool;
	__Request__io_service_match_property_table_ool_t Request_io_service_match_property_table_ool;
	__Request__io_service_add_notification_ool_t Request_io_service_add_notification_ool;
	__Request__io_object_get_superclass_t Request_io_object_get_superclass;
	__Request__io_object_get_bundle_identifier_t Request_io_object_get_bundle_identifier;
	__Request__io_service_open_extended_t Request_io_service_open_extended;
	__Request__io_connect_map_memory_into_task_t Request_io_connect_map_memory_into_task;
	__Request__io_connect_unmap_memory_from_task_t Request_io_connect_unmap_memory_from_task;
	__Request__io_connect_method_t Request_io_connect_method;
	__Request__io_connect_async_method_t Request_io_connect_async_method;
	__Request__io_registry_entry_get_registry_entry_id_t Request_io_registry_entry_get_registry_entry_id;
	__Request__io_connect_method_var_output_t Request_io_connect_method_var_output;
	__Request__io_service_get_matching_service_t Request_io_service_get_matching_service;
	__Request__io_service_get_matching_service_ool_t Request_io_service_get_matching_service_ool;
	__Request__io_service_get_authorization_id_t Request_io_service_get_authorization_id;
	__Request__io_service_set_authorization_id_t Request_io_service_set_authorization_id;
	__Request__io_server_version_t Request_io_server_version;
	__Request__io_registry_entry_get_properties_bin_t Request_io_registry_entry_get_properties_bin;
	__Request__io_registry_entry_get_property_bin_t Request_io_registry_entry_get_property_bin;
	__Request__io_service_get_matching_service_bin_t Request_io_service_get_matching_service_bin;
	__Request__io_service_get_matching_services_bin_t Request_io_service_get_matching_services_bin;
	__Request__io_service_match_property_table_bin_t Request_io_service_match_property_table_bin;
	__Request__io_service_add_notification_bin_t Request_io_service_add_notification_bin;
	__Request__io_registry_entry_get_path_ool_t Request_io_registry_entry_get_path_ool;
	__Request__io_registry_entry_from_path_ool_t Request_io_registry_entry_from_path_ool;
};
#endif /* !__RequestUnion__iokit_subsystem__defined */
/* typedefs for all replies */

#ifndef __Reply__iokit_subsystem__defined
#define __Reply__iokit_subsystem__defined

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t classNameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t classNameCnt;
		char className[128];
	} __Reply__io_object_get_class_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t conforms;
	} __Reply__io_object_conforms_to_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t object;
		/* end of the kernel processed data */
	} __Reply__io_iterator_next_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_iterator_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_services_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_registry_iterator_enter_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_registry_iterator_exit_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_from_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply__io_registry_entry_get_name_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t dataCnt;
		char data[4096];
	} __Reply__io_registry_entry_get_property_bytes_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_get_child_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_get_parent_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_close_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_connect_get_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_set_notification_port_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		vm_address_t address;
		vm_size_t size;
	} __Reply__io_connect_map_memory_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_add_client_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_connect_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		io_user_scalar_t output[16];
	} __Reply__io_connect_method_scalarI_scalarO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		char output[4096];
	} __Reply__io_connect_method_scalarI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_method_scalarI_structureI_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		char output[4096];
	} __Reply__io_connect_method_structureI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[512];
	} __Reply__io_registry_entry_get_path_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t root;
		/* end of the kernel processed data */
	} __Reply__io_registry_get_root_entry_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_registry_entry_set_properties_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t inPlane;
	} __Reply__io_registry_entry_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t retainCount;
	} __Reply__io_object_get_retain_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t busyState;
	} __Reply__io_service_get_busy_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_wait_quiet_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t iterator;
		/* end of the kernel processed data */
	} __Reply__io_registry_entry_create_iterator_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t is_valid;
	} __Reply__io_iterator_is_valid_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
	} __Reply__io_catalog_send_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_terminate_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t outData;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t outDataCnt;
	} __Reply__io_catalog_get_data_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint32_t genCount;
	} __Reply__io_catalog_get_gen_count_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_module_loaded_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_catalog_reset_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_request_probe_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t nameCnt;
		char name[128];
	} __Reply__io_registry_entry_get_name_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply__io_service_match_property_table_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		io_user_scalar_t output[16];
	} __Reply__io_async_method_scalarI_scalarO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		char output[4096];
	} __Reply__io_async_method_scalarI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_async_method_scalarI_structureI_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t outputCnt;
		char output[4096];
	} __Reply__io_async_method_structureI_structureO_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_interest_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_acknowledge_notification_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t semaphore;
		/* end of the kernel processed data */
	} __Reply__io_connect_get_notification_semaphore_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_unmap_memory_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t locationOffset; /* MiG doesn't use it */
		mach_msg_type_number_t locationCnt;
		char location[128];
	} __Reply__io_registry_entry_get_location_in_plane_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_recursively_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t state;
		uint32_t busy_state;
		uint64_t accumulated_busy_time;
	} __Reply__io_service_get_state_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_get_matching_services_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		kern_return_t result;
		boolean_t matches;
	} __Reply__io_service_match_property_table_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_add_notification_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply__io_object_get_superclass_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t class_nameOffset; /* MiG doesn't use it */
		mach_msg_type_number_t class_nameCnt;
		char class_name[128];
	} __Reply__io_object_get_bundle_identifier_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t connection;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_open_extended_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_vm_address_t address;
		mach_vm_size_t size;
	} __Reply__io_connect_map_memory_into_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_connect_unmap_memory_from_task_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		uint64_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply__io_connect_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		uint64_t scalar_output[16];
		mach_vm_size_t ool_output_size;
	} __Reply__io_connect_async_method_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t entry_id;
	} __Reply__io_registry_entry_get_registry_entry_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t var_output;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t inband_outputCnt;
		char inband_output[4096];
		mach_msg_type_number_t scalar_outputCnt;
		uint64_t scalar_output[16];
		mach_msg_type_number_t var_outputCnt;
	} __Reply__io_connect_method_var_output_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_service_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_service_get_matching_service_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t authorization_id;
	} __Reply__io_service_get_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
	} __Reply__io_service_set_authorization_id_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		uint64_t version;
	} __Reply__io_server_version_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_properties_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t properties;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t propertiesCnt;
	} __Reply__io_registry_entry_get_property_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t service;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_service_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t existing;
		/* end of the kernel processed data */
	} __Reply__io_service_get_matching_services_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		NDR_record_t NDR;
		kern_return_t RetCode;
		boolean_t matches;
	} __Reply__io_service_match_property_table_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t notification;
		/* end of the kernel processed data */
	} __Reply__io_service_add_notification_bin_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_ool_descriptor_t path_ool;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		mach_msg_type_number_t pathOffset; /* MiG doesn't use it */
		mach_msg_type_number_t pathCnt;
		char path[4096];
		mach_msg_type_number_t path_oolCnt;
	} __Reply__io_registry_entry_get_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif

#ifdef  __MigPackStructs
#pragma pack(4)
#endif
	typedef struct {
		mach_msg_header_t Head;
		/* start of the kernel processed data */
		mach_msg_body_t msgh_body;
		mach_msg_port_descriptor_t registry_entry;
		/* end of the kernel processed data */
		NDR_record_t NDR;
		kern_return_t result;
	} __Reply__io_registry_entry_from_path_ool_t __attribute__((unused));
#ifdef  __MigPackStructs
#pragma pack()
#endif
#endif /* !__Reply__iokit_subsystem__defined */

/* union of all replies */

#ifndef __ReplyUnion__iokit_subsystem__defined
#define __ReplyUnion__iokit_subsystem__defined
union __ReplyUnion__iokit_subsystem {
	__Reply__io_object_get_class_t Reply_io_object_get_class;
	__Reply__io_object_conforms_to_t Reply_io_object_conforms_to;
	__Reply__io_iterator_next_t Reply_io_iterator_next;
	__Reply__io_iterator_reset_t Reply_io_iterator_reset;
	__Reply__io_service_get_matching_services_t Reply_io_service_get_matching_services;
	__Reply__io_registry_entry_get_property_t Reply_io_registry_entry_get_property;
	__Reply__io_registry_create_iterator_t Reply_io_registry_create_iterator;
	__Reply__io_registry_iterator_enter_entry_t Reply_io_registry_iterator_enter_entry;
	__Reply__io_registry_iterator_exit_entry_t Reply_io_registry_iterator_exit_entry;
	__Reply__io_registry_entry_from_path_t Reply_io_registry_entry_from_path;
	__Reply__io_registry_entry_get_name_t Reply_io_registry_entry_get_name;
	__Reply__io_registry_entry_get_properties_t Reply_io_registry_entry_get_properties;
	__Reply__io_registry_entry_get_property_bytes_t Reply_io_registry_entry_get_property_bytes;
	__Reply__io_registry_entry_get_child_iterator_t Reply_io_registry_entry_get_child_iterator;
	__Reply__io_registry_entry_get_parent_iterator_t Reply_io_registry_entry_get_parent_iterator;
	__Reply__io_service_close_t Reply_io_service_close;
	__Reply__io_connect_get_service_t Reply_io_connect_get_service;
	__Reply__io_connect_set_notification_port_t Reply_io_connect_set_notification_port;
	__Reply__io_connect_map_memory_t Reply_io_connect_map_memory;
	__Reply__io_connect_add_client_t Reply_io_connect_add_client;
	__Reply__io_connect_set_properties_t Reply_io_connect_set_properties;
	__Reply__io_connect_method_scalarI_scalarO_t Reply_io_connect_method_scalarI_scalarO;
	__Reply__io_connect_method_scalarI_structureO_t Reply_io_connect_method_scalarI_structureO;
	__Reply__io_connect_method_scalarI_structureI_t Reply_io_connect_method_scalarI_structureI;
	__Reply__io_connect_method_structureI_structureO_t Reply_io_connect_method_structureI_structureO;
	__Reply__io_registry_entry_get_path_t Reply_io_registry_entry_get_path;
	__Reply__io_registry_get_root_entry_t Reply_io_registry_get_root_entry;
	__Reply__io_registry_entry_set_properties_t Reply_io_registry_entry_set_properties;
	__Reply__io_registry_entry_in_plane_t Reply_io_registry_entry_in_plane;
	__Reply__io_object_get_retain_count_t Reply_io_object_get_retain_count;
	__Reply__io_service_get_busy_state_t Reply_io_service_get_busy_state;
	__Reply__io_service_wait_quiet_t Reply_io_service_wait_quiet;
	__Reply__io_registry_entry_create_iterator_t Reply_io_registry_entry_create_iterator;
	__Reply__io_iterator_is_valid_t Reply_io_iterator_is_valid;
	__Reply__io_catalog_send_data_t Reply_io_catalog_send_data;
	__Reply__io_catalog_terminate_t Reply_io_catalog_terminate;
	__Reply__io_catalog_get_data_t Reply_io_catalog_get_data;
	__Reply__io_catalog_get_gen_count_t Reply_io_catalog_get_gen_count;
	__Reply__io_catalog_module_loaded_t Reply_io_catalog_module_loaded;
	__Reply__io_catalog_reset_t Reply_io_catalog_reset;
	__Reply__io_service_request_probe_t Reply_io_service_request_probe;
	__Reply__io_registry_entry_get_name_in_plane_t Reply_io_registry_entry_get_name_in_plane;
	__Reply__io_service_match_property_table_t Reply_io_service_match_property_table;
	__Reply__io_async_method_scalarI_scalarO_t Reply_io_async_method_scalarI_scalarO;
	__Reply__io_async_method_scalarI_structureO_t Reply_io_async_method_scalarI_structureO;
	__Reply__io_async_method_scalarI_structureI_t Reply_io_async_method_scalarI_structureI;
	__Reply__io_async_method_structureI_structureO_t Reply_io_async_method_structureI_structureO;
	__Reply__io_service_add_notification_t Reply_io_service_add_notification;
	__Reply__io_service_add_interest_notification_t Reply_io_service_add_interest_notification;
	__Reply__io_service_acknowledge_notification_t Reply_io_service_acknowledge_notification;
	__Reply__io_connect_get_notification_semaphore_t Reply_io_connect_get_notification_semaphore;
	__Reply__io_connect_unmap_memory_t Reply_io_connect_unmap_memory;
	__Reply__io_registry_entry_get_location_in_plane_t Reply_io_registry_entry_get_location_in_plane;
	__Reply__io_registry_entry_get_property_recursively_t Reply_io_registry_entry_get_property_recursively;
	__Reply__io_service_get_state_t Reply_io_service_get_state;
	__Reply__io_service_get_matching_services_ool_t Reply_io_service_get_matching_services_ool;
	__Reply__io_service_match_property_table_ool_t Reply_io_service_match_property_table_ool;
	__Reply__io_service_add_notification_ool_t Reply_io_service_add_notification_ool;
	__Reply__io_object_get_superclass_t Reply_io_object_get_superclass;
	__Reply__io_object_get_bundle_identifier_t Reply_io_object_get_bundle_identifier;
	__Reply__io_service_open_extended_t Reply_io_service_open_extended;
	__Reply__io_connect_map_memory_into_task_t Reply_io_connect_map_memory_into_task;
	__Reply__io_connect_unmap_memory_from_task_t Reply_io_connect_unmap_memory_from_task;
	__Reply__io_connect_method_t Reply_io_connect_method;
	__Reply__io_connect_async_method_t Reply_io_connect_async_method;
	__Reply__io_registry_entry_get_registry_entry_id_t Reply_io_registry_entry_get_registry_entry_id;
	__Reply__io_connect_method_var_output_t Reply_io_connect_method_var_output;
	__Reply__io_service_get_matching_service_t Reply_io_service_get_matching_service;
	__Reply__io_service_get_matching_service_ool_t Reply_io_service_get_matching_service_ool;
	__Reply__io_service_get_authorization_id_t Reply_io_service_get_authorization_id;
	__Reply__io_service_set_authorization_id_t Reply_io_service_set_authorization_id;
	__Reply__io_server_version_t Reply_io_server_version;
	__Reply__io_registry_entry_get_properties_bin_t Reply_io_registry_entry_get_properties_bin;
	__Reply__io_registry_entry_get_property_bin_t Reply_io_registry_entry_get_property_bin;
	__Reply__io_service_get_matching_service_bin_t Reply_io_service_get_matching_service_bin;
	__Reply__io_service_get_matching_services_bin_t Reply_io_service_get_matching_services_bin;
	__Reply__io_service_match_property_table_bin_t Reply_io_service_match_property_table_bin;
	__Reply__io_service_add_notification_bin_t Reply_io_service_add_notification_bin;
	__Reply__io_registry_entry_get_path_ool_t Reply_io_registry_entry_get_path_ool;
	__Reply__io_registry_entry_from_path_ool_t Reply_io_registry_entry_from_path_ool;
};
#endif /* !__RequestUnion__iokit_subsystem__defined */

#ifndef subsystem_to_name_map_iokit
#define subsystem_to_name_map_iokit \
    { "io_object_get_class", 2800 },\
    { "io_object_conforms_to", 2801 },\
    { "io_iterator_next", 2802 },\
    { "io_iterator_reset", 2803 },\
    { "io_service_get_matching_services", 2804 },\
    { "io_registry_entry_get_property", 2805 },\
    { "io_registry_create_iterator", 2806 },\
    { "io_registry_iterator_enter_entry", 2807 },\
    { "io_registry_iterator_exit_entry", 2808 },\
    { "io_registry_entry_from_path", 2809 },\
    { "io_registry_entry_get_name", 2810 },\
    { "io_registry_entry_get_properties", 2811 },\
    { "io_registry_entry_get_property_bytes", 2812 },\
    { "io_registry_entry_get_child_iterator", 2813 },\
    { "io_registry_entry_get_parent_iterator", 2814 },\
    { "io_service_close", 2816 },\
    { "io_connect_get_service", 2817 },\
    { "io_connect_set_notification_port", 2818 },\
    { "io_connect_map_memory", 2819 },\
    { "io_connect_add_client", 2820 },\
    { "io_connect_set_properties", 2821 },\
    { "io_connect_method_scalarI_scalarO", 2822 },\
    { "io_connect_method_scalarI_structureO", 2823 },\
    { "io_connect_method_scalarI_structureI", 2824 },\
    { "io_connect_method_structureI_structureO", 2825 },\
    { "io_registry_entry_get_path", 2826 },\
    { "io_registry_get_root_entry", 2827 },\
    { "io_registry_entry_set_properties", 2828 },\
    { "io_registry_entry_in_plane", 2829 },\
    { "io_object_get_retain_count", 2830 },\
    { "io_service_get_busy_state", 2831 },\
    { "io_service_wait_quiet", 2832 },\
    { "io_registry_entry_create_iterator", 2833 },\
    { "io_iterator_is_valid", 2834 },\
    { "io_catalog_send_data", 2836 },\
    { "io_catalog_terminate", 2837 },\
    { "io_catalog_get_data", 2838 },\
    { "io_catalog_get_gen_count", 2839 },\
    { "io_catalog_module_loaded", 2840 },\
    { "io_catalog_reset", 2841 },\
    { "io_service_request_probe", 2842 },\
    { "io_registry_entry_get_name_in_plane", 2843 },\
    { "io_service_match_property_table", 2844 },\
    { "io_async_method_scalarI_scalarO", 2845 },\
    { "io_async_method_scalarI_structureO", 2846 },\
    { "io_async_method_scalarI_structureI", 2847 },\
    { "io_async_method_structureI_structureO", 2848 },\
    { "io_service_add_notification", 2849 },\
    { "io_service_add_interest_notification", 2850 },\
    { "io_service_acknowledge_notification", 2851 },\
    { "io_connect_get_notification_semaphore", 2852 },\
    { "io_connect_unmap_memory", 2853 },\
    { "io_registry_entry_get_location_in_plane", 2854 },\
    { "io_registry_entry_get_property_recursively", 2855 },\
    { "io_service_get_state", 2856 },\
    { "io_service_get_matching_services_ool", 2857 },\
    { "io_service_match_property_table_ool", 2858 },\
    { "io_service_add_notification_ool", 2859 },\
    { "io_object_get_superclass", 2860 },\
    { "io_object_get_bundle_identifier", 2861 },\
    { "io_service_open_extended", 2862 },\
    { "io_connect_map_memory_into_task", 2863 },\
    { "io_connect_unmap_memory_from_task", 2864 },\
    { "io_connect_method", 2865 },\
    { "io_connect_async_method", 2866 },\
    { "io_registry_entry_get_registry_entry_id", 2871 },\
    { "io_connect_method_var_output", 2872 },\
    { "io_service_get_matching_service", 2873 },\
    { "io_service_get_matching_service_ool", 2874 },\
    { "io_service_get_authorization_id", 2875 },\
    { "io_service_set_authorization_id", 2876 },\
    { "io_server_version", 2877 },\
    { "io_registry_entry_get_properties_bin", 2878 },\
    { "io_registry_entry_get_property_bin", 2879 },\
    { "io_service_get_matching_service_bin", 2880 },\
    { "io_service_get_matching_services_bin", 2881 },\
    { "io_service_match_property_table_bin", 2882 },\
    { "io_service_add_notification_bin", 2883 },\
    { "io_registry_entry_get_path_ool", 2885 },\
    { "io_registry_entry_from_path_ool", 2886 }
#endif

#ifdef __AfterMigUserHeader
__AfterMigUserHeader
#endif /* __AfterMigUserHeader */

#endif	 /* _iokit_user_ */

#endif /* !__LP64__ */
                                                                                                                                                                                                                                                                      kext/                                                                                               0040755 0001750 0001750 00000000000 12612224741 031552  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       KextManager.h                                                                                       0100644 0001750 0001750 00000021577 12566177313 034154  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/kext                                                                  /*
 * Copyright (c) 2000-2008, 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_OSREFERENCE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. The rights granted to you under the License
 * may not be used to create, or enable the creation or redistribution of,
 * unlawful or unlicensed copies of an Apple operating system, or to
 * circumvent, violate, or enable the circumvention or violation of, any
 * terms of an Apple operating system software license agreement.
 * 
 * Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_OSREFERENCE_LICENSE_HEADER_END@
 */
#ifndef __KEXTMANAGER_H__
#define __KEXTMANAGER_H__

#include <CoreFoundation/CoreFoundation.h>
#include <libkern/OSReturn.h>

#include <sys/cdefs.h>

__BEGIN_DECLS

/*!
 * @header KextManager.h
 *
 * @abstract
 * The KextManager API provides a simple interface for applications
 * to load kernel extensions (kexts) via RPC to kextd, and to look up the
 * URLs for kexts by bundle identifier.
 */
 
/*!
 * @function KextManagerCreateURLForBundleIdentifier
 * @abstract Create a URL locating a kext with a given bundle identifier.
 *
 * @param    allocator
 *           The allocator to use to allocate memory for the new object.
 *           Pass <code>NULL</code> or <code>kCFAllocatorDefault</code>
 *           to use the current default allocator.
 * @param    kextIdentifier
 *           The bundle identifier to look up.
 *
 * @result
 * A CFURLRef locating a kext with the requested bundle identifier.
 * Returns <code>NULL</code> if the kext cannot be found, or on error.
 *
 * @discussion
 * Kexts are looked up first by whether they are loaded, second by version.
 * Specifically, if <code>kextIdentifier</code> identifies a kext
 * that is currently loaded,
 * the returned URL will locate that kext if it's still present on disk.
 * If the requested kext is not loaded,
 * or if its bundle is not at the location it was originally loaded from,
 * the returned URL will locate the latest version of the desired kext,
 * if one can be found within the system extensions folder.
 * If no version of the kext can be found, <code>NULL</code> is returned.
 */
CFURLRef KextManagerCreateURLForBundleIdentifier(
    CFAllocatorRef allocator,
    CFStringRef    kextIdentifier) AVAILABLE_MAC_OS_X_VERSION_10_2_AND_LATER;

/*!
 * @function KextManagerLoadKextWithIdentifier
 * @abstract
 * Request the kext loading system to load a kext with a given bundle identifier.
 *
 * @param    kextIdentifier
 *           The bundle identifier of the kext to look up and load.
 * @param    dependencyKextAndFolderURLs
 *           An array of additional URLs, of individual kexts and
 *           of folders that may contain kexts.
 *
 * @result
 * <code>kOSReturnSuccess</code> if the kext is successfully loaded
 * (or is already loaded), otherwise returns on error.
 *
 * @discussion
 * <code>kextIdentifier</code> is looked up in the system extensions
 * folder and among any kexts from <code>dependencyKextAndFolderURLs</code>.
 * Any non-kext URLs in <code>dependencyKextAndFolderURLs</code>
 * are scanned at the top level for kexts and plugins of kexts.
 *
 * Either the calling process must have an effective user id of 0 (superuser),
 * or the kext being loaded and all its dependencies must reside in
 * /System and have an OSBundleAllowUserLoad property of <code>true</code>.
 */
OSReturn KextManagerLoadKextWithIdentifier(
    CFStringRef    kextIdentifier,
    CFArrayRef     dependencyKextAndFolderURLs) AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
 * @function KextManagerLoadKextWithURL
 * @abstract
 * Request the kext loading system to load a kext with a given URL.
 *
 * @param    kextURL
 *           The URL of the kext to load.
 * @param    dependencyKextAndFolderURLs
 *           An array of additional URLs, of individual kexts and
 *           of folders that may contain kexts.
 *
 * @result
 * <code>kOSReturnSuccess</code> if the kext is successfully loaded
 * (or is already loaded), otherwise returns on error.
 *
 * @discussion
 * Any non-kext URLs in <code>dependencyKextAndFolderURLs</code>
 * are scanned at the top level for kexts and plugins of kexts.
 *
 * Either the calling process must have an effective user id of 0 (superuser),
 * or the kext being loaded and all its dependencies must reside in
 * /System and have an OSBundleAllowUserLoad property of <code>true</code>.
 */
OSReturn KextManagerLoadKextWithURL(
    CFURLRef    kextURL,
    CFArrayRef  dependencyKextAndFolderURLs) AVAILABLE_MAC_OS_X_VERSION_10_6_AND_LATER;

/*!
 * @function KextManagerUnloadKextWithIdentifier
 * @abstract
 * Request the kernel to unload a kext with a given bundle identifier.
 *
 * @param    kextIdentifier
 *           The bundle identifier of the kext to unload.
 *
 * @result
 * <code>kOSReturnSuccess</code> if the kext is
 * found and successfully unloaded,
 * otherwise returns on error.
 * See <code>/usr/include/libkern/OSKextLib.h</code>
 * for error codes.
 *
 * @discussion
 * The calling process must have an effective user id of 0 (superuser).
 */
OSReturn KextManagerUnloadKextWithIdentifier(
    CFStringRef kextIdentifier) AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;

/*!
 * @function KextManagerCopyLoadedKextInfo
 * @abstract Returns information about loaded kexts in a dictionary.
 *
 * @param    kextIdentifiers   An array of kext identifiers to read from the kernel.
 *                             Pass <code>NULL</code> to read info for all loaded kexts.
 * @param    infoKeys          An array of info keys to read from the kernel.
 *                             Pass <code>NULL</code> to read all information.
 * @result
 * A dictionary, keyed by bundle identifier,
 * of dictionaries containing information about loaded kexts.
 *
 * @discussion
 * The information keys returned by this function are listed below.
 * Some are taken directly from the kext's information property list,
 * and some are generated at run time.
 * Never assume a given key will be present for a kext.
 *
 * <ul>
 *   <li><code>CFBundleIdentifier</code> - CFString</li>
 *   <li><code>CFBundleVersion</code> - CFString (note: version strings may be canonicalized
 *       but their numeric values will be the same; "1.2.0" may become "1.2", for example)</li>
 *   <li><code>OSBundleCompatibleVersion</code> - CFString</li>
 *   <li><code>OSBundleIsInterface</code> - CFBoolean</li>
 *   <li><code>OSKernelResource</code> - CFBoolean</li>
 *   <li><code>OSBundleCPUType</code> - CFNumber</li>
 *   <li><code>OSBundleCPUSubtype</code> - CFNumber</li>
 *   <li><code>OSBundlePath</code> - CFString (this is merely a hint stored in the kernel;
 *       the kext is not guaranteed to be at this path)</li>
 *   <li><code>OSBundleExecutablePath</code> - CFString
 *       (the absolute path to the executable within the kext bundle; a hint as above)</li>
 *   <li><code>OSBundleUUID</code> - CFData (the UUID of the kext executable, if it has one)</li>
 *   <li><code>OSBundleStarted</code> - CFBoolean (true if the kext is running)</li>
 *   <li><code>OSBundlePrelinked</code> - CFBoolean (true if the kext is loaded from a prelinked kernel)</li>
 *   <li><code>OSBundleLoadTag</code> - CFNumber (the "Index" given by kextstat)</li>
 *   <li><code>OSBundleLoadAddress</code> - CFNumber</li>
 *   <li><code>OSBundleLoadSize</code> - CFNumber</li>
 *   <li><code>OSBundleWiredSize</code> - CFNumber</li>
 *   <li><code>OSBundleDependencies</code> - CFArray of load tags identifying immediate link dependencies</li>
 *   <li><code>OSBundleRetainCount</code> - CFNumber (the OSObject retain count of the kext itself)</li>
 *   <li><code>OSBundleClasses</code> - CFArray of CFDictionary containing info on C++ classes
 *       defined by the kext:</li>
 *       <ul>
 *         <li><code>OSMetaClassName</code> - CFString</li>
 *         <li><code>OSMetaClassSuperclassName</code> - CFString, absent for root classes</li>
 *         <li><code>OSMetaClassTrackingCount</code> - CFNumber giving the instance count
 *             of the class itself, <i>plus</i> 1 for each direct subclass with any instances</li>
 *       </ul>
 * </ul>
 */
CFDictionaryRef KextManagerCopyLoadedKextInfo(
    CFArrayRef  kextIdentifiers,
    CFArrayRef  infoKeys) AVAILABLE_MAC_OS_X_VERSION_10_7_AND_LATER;


__END_DECLS

#endif /* __KEXTMANAGER_H__ */
                                                                                                                                 ndrvsupport/                                                                                        0040755 0001750 0001750 00000000000 12612224741 033205  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers                                                                       IOMacOSTypes.h                                                                                      0100644 0001750 0001750 00000037063 12567452457 035623  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ndrvsupport                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
 * Copyright (c) 1997 Apple Computer, Inc.
 *
 *
 * HISTORY
 *
 * sdouglas  22 Oct 97 - first checked in.
 * sdouglas  21 July 98 - start IOKit
 */

/*
    File:       Types.h
 
    Contains:   Basic Macintosh data types.
 
    Version:    Technology: PowerSurge 1.0.2.
                Package:    Universal Interfaces 2.1.2 on ETO #20
 
    Copyright:   1984-1995 by Apple Computer, Inc.
                All rights reserved.
 
    Bugs?:      If you find a problem with this file, use the Apple Bug Reporter
                stack.  Include the file and version information (from above)
                in the problem description and send to:
                    Internet:   apple.bugs@applelink.apple.com
                    AppleLink:  APPLE.BUGS
 
*/

#ifndef _IOKIT_IOMACOSTYPES_H
#define _IOKIT_IOMACOSTYPES_H
#ifndef __MACTYPES__

#include <IOKit/IOTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

#ifndef NULL
#if !defined(__cplusplus) && (defined(__SC__) || defined(THINK_C))
#define NULL ((void *) 0)
#else
#define NULL 0
#endif
#endif

enum {
    noErr                       = 0
};

typedef unsigned char Byte;

typedef signed char SignedByte;

typedef UInt16 UniChar;

typedef char *Ptr;

typedef Ptr *Handle;

typedef UInt32 Fixed;

typedef Fixed *FixedPtr;

typedef UInt32 Fract;

typedef Fract *FractPtr;

/*
enum {
    false,
    true
};
#if !__option(bool)
    #ifndef true
        #define true            1
    #endif
    #ifndef false
        #define false           0
    #endif
#endif

typedef unsigned char Boolean;
*/


typedef short OSErr;

typedef unsigned int FourCharCode;

typedef FourCharCode OSType;

typedef FourCharCode ResType;

typedef OSType *OSTypePtr;

typedef ResType *ResTypePtr;

struct Rect {
    short                           top;
    short                           left;
    short                           bottom;
    short                           right;
};
typedef struct Rect Rect;

typedef Rect *RectPtr;

// Quickdraw.i

/*
    kVariableLengthArray is used in array bounds to specify a variable length array.
    It is ususally used in variable length structs when the last field is an array
    of any size.  Before ANSI C, we used zero as the bounds of variable length 
    array, but that is illegal in ANSI C.  Example:
    
        struct FooList 
        {
            short   listLength;
            Foo     elements[kVariableLengthArray];
        };
*/

enum {
    kVariableLengthArray        = 1
};

/* Numeric version part of 'vers' resource */
struct NumVersion {
    UInt8                           majorRev;                   /*1st part of version number in BCD*/
    UInt8                           minorAndBugRev;             /*2nd & 3rd part of version number share a byte*/
    UInt8                           stage;                      /*stage code: dev, alpha, beta, final*/
    UInt8                           nonRelRev;                  /*revision level of non-released version*/
};
typedef struct NumVersion NumVersion;

typedef struct OpaqueRef *KernelID;

typedef UInt8 *BytePtr;

typedef IOByteCount ByteCount;

typedef IOItemCount ItemCount;

typedef void *LogicalAddress;

#if !defined(__LP64__)
typedef void *PhysicalAddress;
#endif

typedef UInt32 PBVersion;

typedef SInt32 Duration;

#define kInvalidID 0

enum {
    kNilOptions                 = 0
};


typedef unsigned char Str31[32];


/*
From:
        File:           DriverFamilyMatching.i <18>
        Copyright:       1995-1996 by Apple Computer, Inc., all rights reserved.
*/

//##############################################
// Well known properties in the Name Registry
//##############################################

#define kPropertyName                                   "name"
#define kPropertyCompatible                             "compatible"
#define kPropertyDriverPtr                              "driver-ptr"
#define kPropertyDriverDesc                             "driver-description"
#define kPropertyReg                                    "reg"
#define kPropertyAAPLAddress                            "AAPL,address"
#define kPropertyMatching                               "matching"


//#########################################################
// Descriptor for Drivers and NDRVs
//#########################################################
/* Driver Typing Information Used to Match Drivers With Devices */
struct DriverType {
        Str31                                                   nameInfoStr;                            /* Driver Name/Info String*/
        NumVersion                                              version;                                        /* Driver Version Number*/
};
typedef struct DriverType                       DriverType;
typedef DriverType *                            DriverTypePtr;

/* OS Runtime Information Used to Setup and Maintain a Driver's Runtime Environment */
typedef IOOptionBits RuntimeOptions;


enum {
        kDriverIsLoadedUponDiscovery = 0x00000001,                                      /* auto-load driver when discovered*/
        kDriverIsOpenedUponLoad         =  0x00000002,                                  /* auto-open driver when loaded*/
        kDriverIsUnderExpertControl     =  0x00000004,                                  /* I/O expert handles loads/opens*/
        kDriverIsConcurrent                     =  0x00000008,                                  /* supports concurrent requests*/
        kDriverQueuesIOPB                       =  0x00000010,                                  /* device manager doesn't queue IOPB*/
        kDriverIsLoadedAtBoot           =  0x00000020,                                  /* Driver is loaded at the boot time */
        kDriverIsForVirtualDevice       =  0x00000040,                                  /* Driver is for a virtual Device */ 
        kDriverSupportDMSuspendAndResume = 0x00000080                           /* Driver supports Device Manager Suspend and Resume command */
};

struct DriverOSRuntime {
        RuntimeOptions                                  driverRuntime;                          /* Options for OS Runtime*/
        Str31                                                   driverName;                                     /* Driver's name to the OS*/
        UInt32                                                  driverDescReserved[8];          /* Reserved area*/
};
typedef struct DriverOSRuntime          DriverOSRuntime;
typedef DriverOSRuntime *                       DriverOSRuntimePtr;

/* OS Service Information Used To Declare What APIs a Driver Supports */
typedef UInt32 ServiceCount;

struct DriverServiceInfo {
        OSType                                                  serviceCategory;                        /* Service Category Name*/
        OSType                                                  serviceType;                            /* Type within Category*/
        NumVersion                                              serviceVersion;                         /* Version of service*/
};
typedef struct DriverServiceInfo        DriverServiceInfo;
typedef DriverServiceInfo *                     DriverServiceInfoPtr;

struct DriverOSService {
        ServiceCount                                    nServices;                                      /* Number of Services Supported*/
        DriverServiceInfo                               service[1];                                     /* The List of Services (at least one)*/
};
typedef struct DriverOSService          DriverOSService;
typedef DriverOSService *                       DriverOSServicePtr;

/* Categories */

enum {
        kServiceCategoryDisplay                 = 'disp',                                               /* Display Manager*/
        kServiceCategoryOpenTransport   = 'otan',                                               /* Open Transport*/
        kServiceCategoryBlockStorage    = 'blok',                                               /* Block Storage*/
        kServiceCategoryNdrvDriver              = 'ndrv',                                               /* Generic Native Driver*/
        kServiceCategoryScsiSIM                 = 'scsi',                                               /* SCSI */
        kServiceCategoryFileManager             = 'file',                                               /* File Manager */
        kServiceCategoryIDE                             = 'ide-',                                               /* ide */
        kServiceCategoryADB                             = 'adb-',                                               /* adb */
        kServiceCategoryPCI                             = 'pci-',                                               /* pci bus */
                                                                                                                                        /* Nu Bus */
        kServiceCategoryDFM                             = 'dfm-',                                               /* DFM */
        kServiceCategoryMotherBoard             = 'mrbd',                                               /* mother Board */
        kServiceCategoryKeyboard                = 'kybd',                                               /* Keyboard */
        kServiceCategoryPointing                = 'poit',                                               /* Pointing */
        kServiceCategoryRTC                             = 'rtc-',                                               /* RTC */
        kServiceCategoryNVRAM                   = 'nram',                                               /* NVRAM */
        kServiceCategorySound                   = 'sond',                                               /* Sound (1/3/96 MCS) */
        kServiceCategoryPowerMgt                = 'pgmt',                                               /* Power Management */
        kServiceCategoryGeneric                 = 'genr'                                                /* Generic Service Category to receive general Events */
};

/* Ndrv ServiceCategory Types */
enum {
        kNdrvTypeIsGeneric                      = 'genr',                                               /* generic*/
        kNdrvTypeIsVideo                        = 'vido',                                               /* video*/
        kNdrvTypeIsBlockStorage         = 'blok',                                               /* block storage*/
        kNdrvTypeIsNetworking           = 'netw',                                               /* networking*/
        kNdrvTypeIsSerial                       = 'serl',                                               /* serial*/
        kNdrvTypeIsParallel                     = 'parl',                                               /* parallel */
        kNdrvTypeIsSound                        = 'sond',                                               /* sound*/
        kNdrvTypeIsBusBridge            = 'brdg'
};

typedef UInt32 DriverDescVersion;

/*      The Driver Description */
enum {
        kInitialDriverDescriptor        = 0,
        kVersionOneDriverDescriptor     = 1
};

enum {
        kTheDescriptionSignature        = 'mtej',
        kDriverDescriptionSignature     = 'pdes'                                                
};


struct DriverDescription {
        OSType                                                  driverDescSignature;            /* Signature field of this structure*/
        DriverDescVersion                               driverDescVersion;                      /* Version of this data structure*/
        DriverType                                              driverType;                                     /* Type of Driver*/
        DriverOSRuntime                                 driverOSRuntimeInfo;            /* OS Runtime Requirements of Driver*/
        DriverOSService                                 driverServices;                         /* Apple Service API Membership*/
};
typedef struct DriverDescription        DriverDescription;
typedef DriverDescription *                     DriverDescriptionPtr;


#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __MACTYPES__ */

#ifndef __QUICKDRAW__

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

struct RGBColor {
 unsigned short red;                /*magnitude of red component*/
 unsigned short green;              /*magnitude of green component*/
 unsigned short blue;               /*magnitude of blue component*/
};
typedef struct RGBColor     RGBColor;
typedef RGBColor            *RGBColorPtr;
typedef RGBColorPtr         *RGBColorHdl;

struct ColorSpec {
 short value;                       /*index or other value*/
 RGBColor rgb;                      /*true color*/
};

typedef struct ColorSpec    ColorSpec;
typedef ColorSpec           *ColorSpecPtr;

struct GammaTbl {
 short gVersion;                    /*gamma version number*/
 short gType;                       /*gamma data type*/
 short gFormulaSize;                /*Formula data size*/
 short gChanCnt;                    /*number of channels of data*/
 short gDataCnt;                    /*number of values/channel*/
 short gDataWidth;                  /*bits/corrected value (data packed to next larger byte size)*/
 short gFormulaData[1];             /*data for formulas followed by gamma values*/
};
typedef struct GammaTbl     GammaTbl;
typedef GammaTbl            *GammaTblPtr;

struct RegEntryID
{
    void * opaque[4];
};
typedef struct RegEntryID RegEntryID;
typedef RegEntryID *                    RegEntryIDPtr;

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

struct IONDRVControlParameters {
    UInt8       __reservedA[0x1a];
    UInt16      code;
    void *      params;
    UInt8       __reservedB[0x12];
};

enum {
    kIONDRVOpenCommand                = 128 + 0,
    kIONDRVCloseCommand               = 128 + 1,
    kIONDRVReadCommand                = 128 + 2,
    kIONDRVWriteCommand               = 128 + 3,
    kIONDRVControlCommand             = 128 + 4,
    kIONDRVStatusCommand              = 128 + 5,
    kIONDRVKillIOCommand              = 128 + 6,
    kIONDRVInitializeCommand          = 128 + 7,                /* init driver and device*/
    kIONDRVFinalizeCommand            = 128 + 8,                /* shutdown driver and device*/
    kIONDRVReplaceCommand             = 128 + 9,                /* replace an old driver*/
    kIONDRVSupersededCommand          = 128 + 10                /* prepare to be replaced by a new driver*/
};
enum {
    kIONDRVSynchronousIOCommandKind   = 0x00000001,
    kIONDRVAsynchronousIOCommandKind  = 0x00000002,
    kIONDRVImmediateIOCommandKind     = 0x00000004
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */

#ifndef __LP64__
#pragma options align=reset
#endif

#ifdef __cplusplus
}
#endif

#endif /* __QUICKDRAW__ */

#endif /* _IOKIT_IOMACOSTYPES_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                             IOMacOSVideo.h                                                                                      0100644 0001750 0001750 00000241003 12567452457 035554  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/IOKit.framework/Versions/A/Headers/ndrvsupport                                                           /*
 * Copyright (c) 1998-2000 Apple Computer, Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * The contents of this file constitute Original Code as defined in and
 * are subject to the Apple Public Source License Version 1.1 (the
 * "License").  You may not use this file except in compliance with the
 * License.  Please obtain a copy of the License at
 * http://www.apple.com/publicsource and read it before using this file.
 * 
 * This Original Code and all software distributed under the License are
 * distributed on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE OR NON-INFRINGEMENT.  Please see the
 * License for the specific language governing rights and limitations
 * under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */
/*
     File:       Video.h
 
     Contains:   Video Driver Interfaces.
 
     Copyright:  (c) 1986-2000 by Apple Computer, Inc., all rights reserved
 
     Bugs?:      For bug reports, consult the following page on
                 the World Wide Web:
 
                     http://developer.apple.com/bugreporter/
 
*/
#ifndef __IOMACOSVIDEO__
#define __IOMACOSVIDEO__

#define PRAGMA_STRUCT_ALIGN 1
#define FOUR_CHAR_CODE(x)           (x)
#include <IOKit/ndrvsupport/IOMacOSTypes.h>

#ifdef __cplusplus
extern "C" {
#endif

#ifndef __LP64__
#pragma options align=mac68k
#endif

enum {
    mBaseOffset                 = 1,                            /*Id of mBaseOffset.*/
    mRowBytes                   = 2,                            /*Video sResource parameter Id's */
    mBounds                     = 3,                            /*Video sResource parameter Id's */
    mVersion                    = 4,                            /*Video sResource parameter Id's */
    mHRes                       = 5,                            /*Video sResource parameter Id's */
    mVRes                       = 6,                            /*Video sResource parameter Id's */
    mPixelType                  = 7,                            /*Video sResource parameter Id's */
    mPixelSize                  = 8,                            /*Video sResource parameter Id's */
    mCmpCount                   = 9,                            /*Video sResource parameter Id's */
    mCmpSize                    = 10,                           /*Video sResource parameter Id's */
    mPlaneBytes                 = 11,                           /*Video sResource parameter Id's */
    mVertRefRate                = 14,                           /*Video sResource parameter Id's */
    mVidParams                  = 1,                            /*Video parameter block id.*/
    mTable                      = 2,                            /*Offset to the table.*/
    mPageCnt                    = 3,                            /*Number of pages*/
    mDevType                    = 4,                            /*Device Type*/
    oneBitMode                  = 128,                          /*Id of OneBitMode Parameter list.*/
    twoBitMode                  = 129,                          /*Id of TwoBitMode Parameter list.*/
    fourBitMode                 = 130,                          /*Id of FourBitMode Parameter list.*/
    eightBitMode                = 131                           /*Id of EightBitMode Parameter list.*/
};

enum {
    sixteenBitMode              = 132,                          /*Id of SixteenBitMode Parameter list.*/
    thirtyTwoBitMode            = 133,                          /*Id of ThirtyTwoBitMode Parameter list.*/
    firstVidMode                = 128,                          /*The new, better way to do the above. */
    secondVidMode               = 129,                          /* QuickDraw only supports six video */
    thirdVidMode                = 130,                          /* at this time.      */
    fourthVidMode               = 131,
    fifthVidMode                = 132,
    sixthVidMode                = 133,
    spGammaDir                  = 64,
    spVidNamesDir               = 65
};

typedef UInt32                          AVIDType;
typedef AVIDType                        DisplayIDType;
typedef IODisplayModeID                 DisplayModeID;
typedef UInt16                          DepthMode;
typedef UInt32                          VideoDeviceType;
typedef UInt32                          GammaTableID;

/* csTimingFormat values in VDTimingInfo */
/* look in the declaration rom for timing info */
enum {
    kDeclROMtables              = FOUR_CHAR_CODE('decl'),
    kDetailedTimingFormat       = FOUR_CHAR_CODE('arba')        /* Timing is a detailed timing*/
};

/* Size of a block of EDID (Extended Display Identification Data) */
enum {
    kDDCBlockSize               = 128
};

/* ddcBlockType constants*/
enum {
    kDDCBlockTypeEDID           = 0                             /* EDID block type. */
};

/* ddcFlags constants*/
enum {
    kDDCForceReadBit            = 0,                            /* Force a new read of the EDID. */
    kDDCForceReadMask           = (1 << kDDCForceReadBit)       /* Mask for kddcForceReadBit. */
};


/* Timing mode constants for Display Manager MultiMode support
    Corresponding   .h equates are in Video.h
                    .a equates are in Video.a
                    .r equates are in DepVideoEqu.r
    
    The second enum is the old names (for compatibility).
    The first enum is the new names.
*/
enum {
    timingInvalid               = 0,                            /*    Unknown timing... force user to confirm. */
    timingInvalid_SM_T24        = 8,                            /*    Work around bug in SM Thunder24 card.*/
    timingApple_FixedRateLCD    = 42,                           /*    Lump all fixed-rate LCDs into one category.*/
    timingApple_512x384_60hz    = 130,                          /*  512x384  (60 Hz) Rubik timing. */
    timingApple_560x384_60hz    = 135,                          /*  560x384  (60 Hz) Rubik-560 timing. */
    timingApple_640x480_67hz    = 140,                          /*  640x480  (67 Hz) HR timing. */
    timingApple_640x400_67hz    = 145,                          /*  640x400  (67 Hz) HR-400 timing. */
    timingVESA_640x480_60hz     = 150,                          /*  640x480  (60 Hz) VGA timing. */
    timingVESA_640x480_72hz     = 152,                          /*  640x480  (72 Hz) VGA timing. */
    timingVESA_640x480_75hz     = 154,                          /*  640x480  (75 Hz) VGA timing. */
    timingVESA_640x480_85hz     = 158,                          /*  640x480  (85 Hz) VGA timing. */
    timingGTF_640x480_120hz     = 159,                          /*  640x480  (120 Hz) VESA Generalized Timing Formula */
    timingApple_640x870_75hz    = 160,                          /*  640x870  (75 Hz) FPD timing.*/
    timingApple_640x818_75hz    = 165,                          /*  640x818  (75 Hz) FPD-818 timing.*/
    timingApple_832x624_75hz    = 170,                          /*  832x624  (75 Hz) GoldFish timing.*/
    timingVESA_800x600_56hz     = 180,                          /*  800x600  (56 Hz) SVGA timing. */
    timingVESA_800x600_60hz     = 182,                          /*  800x600  (60 Hz) SVGA timing. */
    timingVESA_800x600_72hz     = 184,                          /*  800x600  (72 Hz) SVGA timing. */
    timingVESA_800x600_75hz     = 186,                          /*  800x600  (75 Hz) SVGA timing. */
    timingVESA_800x600_85hz     = 188,                          /*  800x600  (85 Hz) SVGA timing. */
    timingVESA_1024x768_60hz    = 190,                          /* 1024x768  (60 Hz) VESA 1K-60Hz timing. */
    timingVESA_1024x768_70hz    = 200,                          /* 1024x768  (70 Hz) VESA 1K-70Hz timing. */
    timingVESA_1024x768_75hz    = 204,                          /* 1024x768  (75 Hz) VESA 1K-75Hz timing (very similar to timingApple_1024x768_75hz). */
    timingVESA_1024x768_85hz    = 208,                          /* 1024x768  (85 Hz) VESA timing. */
    timingApple_1024x768_75hz   = 210,                          /* 1024x768  (75 Hz) Apple 19" RGB. */
    timingApple_1152x870_75hz   = 220,                          /* 1152x870  (75 Hz) Apple 21" RGB. */
    timingAppleNTSC_ST          = 230,                          /*  512x384  (60 Hz, interlaced, non-convolved). */
    timingAppleNTSC_FF          = 232,                          /*  640x480  (60 Hz, interlaced, non-convolved). */
    timingAppleNTSC_STconv      = 234,                          /*  512x384  (60 Hz, interlaced, convolved). */
    timingAppleNTSC_FFconv      = 236,                          /*  640x480  (60 Hz, interlaced, convolved). */
    timingApplePAL_ST           = 238,                          /*  640x480  (50 Hz, interlaced, non-convolved). */
    timingApplePAL_FF           = 240,                          /*  768x576  (50 Hz, interlaced, non-convolved). */
    timingApplePAL_STconv       = 242,                          /*  640x480  (50 Hz, interlaced, convolved). */
    timingApplePAL_FFconv       = 244,                          /*  768x576  (50 Hz, interlaced, convolved). */
    timingVESA_1280x960_75hz    = 250,                          /* 1280x960  (75 Hz) */
    timingVESA_1280x960_60hz    = 252,                          /* 1280x960  (60 Hz) */
    timingVESA_1280x960_85hz    = 254,                          /* 1280x960  (85 Hz) */
    timingVESA_1280x1024_60hz   = 260,                          /* 1280x1024 (60 Hz) */
    timingVESA_1280x1024_75hz   = 262,                          /* 1280x1024 (75 Hz) */
    timingVESA_1280x1024_85hz   = 268,                          /* 1280x1024 (85 Hz) */
    timingVESA_1600x1200_60hz   = 280,                          /* 1600x1200 (60 Hz) VESA timing. */
    timingVESA_1600x1200_65hz   = 282,                          /* 1600x1200 (65 Hz) VESA timing. */
    timingVESA_1600x1200_70hz   = 284,                          /* 1600x1200 (70 Hz) VESA timing. */
    timingVESA_1600x1200_75hz   = 286,                          /* 1600x1200 (75 Hz) VESA timing (pixel clock is 189.2 Mhz dot clock). */
    timingVESA_1600x1200_80hz   = 288,                          /* 1600x1200 (80 Hz) VESA timing (pixel clock is 216>? Mhz dot clock) - proposed only. */
    timingVESA_1600x1200_85hz   = 289,                          /* 1600x1200 (85 Hz) VESA timing (pixel clock is 229.5 Mhz dot clock). */
    timingVESA_1792x1344_60hz   = 296,                          /* 1792x1344 (60 Hz) VESA timing (204.75 Mhz dot clock). */
    timingVESA_1792x1344_75hz   = 298,                          /* 1792x1344 (75 Hz) VESA timing (261.75 Mhz dot clock). */
    timingVESA_1856x1392_60hz   = 300,                          /* 1856x1392 (60 Hz) VESA timing (218.25 Mhz dot clock). */
    timingVESA_1856x1392_75hz   = 302,                          /* 1856x1392 (75 Hz) VESA timing (288 Mhz dot clock). */
    timingVESA_1920x1440_60hz   = 304,                          /* 1920x1440 (60 Hz) VESA timing (234 Mhz dot clock). */
    timingVESA_1920x1440_75hz   = 306,                          /* 1920x1440 (75 Hz) VESA timing (297 Mhz dot clock). */
    timingSMPTE240M_60hz        = 400,                          /* 60Hz V, 33.75KHz H, interlaced timing, 16:9 aspect, typical resolution of 1920x1035. */
    timingFilmRate_48hz         = 410,                          /* 48Hz V, 25.20KHz H, non-interlaced timing, typical resolution of 640x480. */
    timingSony_1600x1024_76hz   = 500,                          /* 1600x1024 (76 Hz) Sony timing (pixel clock is 170.447 Mhz dot clock). */
    timingSony_1920x1080_60hz   = 510,                          /* 1920x1080 (60 Hz) Sony timing (pixel clock is 159.84 Mhz dot clock). */
    timingSony_1920x1080_72hz   = 520,                          /* 1920x1080 (72 Hz) Sony timing (pixel clock is 216.023 Mhz dot clock). */
    timingSony_1920x1200_76hz   = 540,                          /* 1900x1200 (76 Hz) Sony timing (pixel clock is 243.20 Mhz dot clock). */
    timingApple_0x0_0hz_Offline = 550                           /* Indicates that this timing will take the display off-line and remove it from the system. */
};


/* Deprecated timing names.*/
enum {
    timingApple12               = timingApple_512x384_60hz,
    timingApple12x              = timingApple_560x384_60hz,
    timingApple13               = timingApple_640x480_67hz,
    timingApple13x              = timingApple_640x400_67hz,
    timingAppleVGA              = timingVESA_640x480_60hz,
    timingApple15               = timingApple_640x870_75hz,
    timingApple15x              = timingApple_640x818_75hz,
    timingApple16               = timingApple_832x624_75hz,
    timingAppleSVGA             = timingVESA_800x600_56hz,
    timingApple1Ka              = timingVESA_1024x768_60hz,
    timingApple1Kb              = timingVESA_1024x768_70hz,
    timingApple19               = timingApple_1024x768_75hz,
    timingApple21               = timingApple_1152x870_75hz,
    timingSony_1900x1200_74hz   = 530,                          /* 1900x1200 (74 Hz) Sony timing (pixel clock is 236.25 Mhz dot clock). */
    timingSony_1900x1200_76hz   = timingSony_1920x1200_76hz     /* 1900x1200 (76 Hz) Sony timing (pixel clock is 245.48 Mhz dot clock). */
};

/* csConnectFlags values in VDDisplayConnectInfo */
enum {
    kAllModesValid              = 0,                            /* All modes not trimmed by primary init are good close enough to try */
    kAllModesSafe               = 1,                            /* All modes not trimmed by primary init are know to be safe */
    kReportsTagging             = 2,                            /* Can detect tagged displays (to identify smart monitors) */
    kHasDirectConnectio