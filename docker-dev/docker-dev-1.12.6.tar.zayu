y, MultiScrolledLists.py, MultiStatusBar.py, NEWS.txt,
	ObjectBrowser.py, OldStackViewer.py, OutputWindow.py,
	ParenMatch.py, PathBrowser.py, Percolator.py, PyParse.py,
	PyShell.py, README.txt, Remote.py, RemoteInterp.py,
	ReplaceDialog.py, ScriptBinding.py, ScrolledList.py,
	SearchBinding.py, SearchDialog.py, SearchDialogBase.py,
	SearchEngine.py, Separator.py, StackViewer.py, TODO.txt,
	ToolTip.py, TreeWidget.py, UndoDelegator.py, WidgetRedirector.py,
	WindowList.py, ZoomHeight.py, __init__.py, config-unix.txt,
	config-win.txt, config.txt, eventparse.py, extend.txt, help.txt,
	idle, idle.bat, idle.py, idle.pyw, idlever.py, keydefs.py,
	loader.py, protocol.py, pyclbr.py, setup.py, spawn.py, tabnanny.py,
	testcode.py: Null commit with -f option to force an uprev and put
	HEADs firmly on the trunk.

2001-06-27 10:24  elguavas

	* IDLEFORK.html: updated contact details

2001-06-25 17:23  elguavas

	* idle, RemoteInterp.py, setup.py: Initial revision

2001-06-25 17:23  elguavas

	* idle, RemoteInterp.py, setup.py: import current python cvs idle
	as a vendor branch

2001-06-24 15:10  elguavas

	* IDLEFORK.html: tiny change to test new syncmail setup

2001-06-24 14:41  elguavas

	* IDLEFORK.html: change to new developer contact, also a test
	commit for new syncmail setup

2001-06-23 18:15  elguavas

	* IDLEFORK.html: tiny test update for revitalised idle-fork

2000-09-24 17:29  nriley

	* protocol.py: Fixes for Python 1.6 compatibility - socket bind and
	connect get a tuple instead two arguments.

2000-09-24 17:28  nriley

	* spawn.py: Change for Python 1.6 compatibility - UNIX's 'os'
	module defines 'spawnv' now, so we check for 'fork' first.

2000-08-15 22:51  nowonder

	* IDLEFORK.html: 
	corrected email address

2000-08-15 22:47  nowonder

	* IDLEFORK.html: 
	added .html file for http://idlefork.sourceforge.net

2000-08-15 11:13  dscherer

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, __init__.py, ChangeLog, ClassBrowser.py,
	ColorDelegator.py, ConfigParser.py, Debugger.py, Delegator.py,
	FileList.py, FormatParagraph.py, FrameViewer.py, GrepDialog.py,
	IOBinding.py, IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, NEWS.txt, ObjectBrowser.py, OldStackViewer.py,
	OutputWindow.py, ParenMatch.py, PathBrowser.py, Percolator.py,
	PyParse.py, PyShell.py, README.txt, ReplaceDialog.py,
	ScriptBinding.py, ScrolledList.py, SearchBinding.py,
	SearchDialog.py, SearchDialogBase.py, SearchEngine.py,
	Separator.py, StackViewer.py, TODO.txt, ToolTip.py, TreeWidget.py,
	UndoDelegator.py, WidgetRedirector.py, WindowList.py, help.txt,
	ZoomHeight.py, config-unix.txt, config-win.txt, config.txt,
	eventparse.py, extend.txt, idle.bat, idle.py, idle.pyw, idlever.py,
	keydefs.py, loader.py, pyclbr.py, tabnanny.py, testcode.py,
	EditorWindow.py, ExecBinding.py, Remote.py, protocol.py, spawn.py,
	Icons/folder.gif, Icons/minusnode.gif, Icons/openfolder.gif,
	Icons/plusnode.gif, Icons/python.gif, Icons/tk.gif: Initial
	revision

2000-08-15 11:13  dscherer

	* AutoExpand.py, AutoIndent.py, Bindings.py, CallTipWindow.py,
	CallTips.py, __init__.py, ChangeLog, ClassBrowser.py,
	ColorDelegator.py, ConfigParser.py, Debugger.py, Delegator.py,
	FileList.py, FormatParagraph.py, FrameViewer.py, GrepDialog.py,
	IOBinding.py, IdleConf.py, IdleHistory.py, MultiScrolledLists.py,
	MultiStatusBar.py, NEWS.txt, ObjectBrowser.py, OldStackViewer.py,
	OutputWindow.py, ParenMatch.py, PathBrowser.py, Percolator.py,
	PyParse.py, PyShell.py, README.txt, ReplaceDialog.py,
	ScriptBinding.py, ScrolledList.py, SearchBinding.py,
	SearchDialog.py, SearchDialogBase.py, SearchEngine.py,
	Separator.py, StackViewer.py, TODO.txt, ToolTip.py, TreeWidget.py,
	UndoDelegator.py, WidgetRedirector.py, WindowList.py, help.txt,
	ZoomHeight.py, config-unix.txt, config-win.txt, config.txt,
	eventparse.py, extend.txt, idle.bat, idle.py, idle.pyw, idlever.py,
	keydefs.py, loader.py, pyclbr.py, tabnanny.py, testcode.py,
	EditorWindow.py, ExecBinding.py, Remote.py, protocol.py, spawn.py,
	Icons/folder.gif, Icons/minusnode.gif, Icons/openfolder.gif,
	Icons/plusnode.gif, Icons/python.gif, Icons/tk.gif: Modified IDLE
	from VPython 0.2


original IDLE ChangeLog:
========================

Tue Feb 15 18:08:19 2000  Guido van Rossum  <guido@cnri.reston.va.us>

	* NEWS.txt: Notice status bar and stack viewer.

	* EditorWindow.py: Support for Moshe's status bar.

	* MultiStatusBar.py: Status bar code -- by Moshe Zadka.

	* OldStackViewer.py:
	Adding the old stack viewer implementation back, for the debugger.

	* StackViewer.py: New stack viewer, uses a tree widget.
	(XXX: the debugger doesn't yet use this.)

	* WindowList.py:
	Correct a typo and remove an unqualified except that was hiding the error.

	* ClassBrowser.py: Add an XXX comment about the ClassBrowser AIP.

	* ChangeLog: Updated change log.

	* NEWS.txt: News update.  Probably incomplete; what else is new?

	* README.txt:
	Updated for pending IDLE 0.5 release (still very rough -- just getting
	it out in a more convenient format than CVS).

	* TODO.txt: Tiny addition.

Thu Sep  9 14:16:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: A few new TODO entries.

Thu Aug 26 23:06:22 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* Bindings.py: Add Python Documentation entry to Help menu.

	* EditorWindow.py:
	Find the help.txt file relative to __file__ or ".", not in sys.path.
	(Suggested by Moshe Zadka, but implemented differently.)

	Add <<python-docs>> event which, on Unix, brings up Netscape pointing
	to http://www.python.doc/current/ (a local copy would be nice but its
	location can't be predicted).  Windows solution TBD.

Wed Aug 11 14:55:43 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TreeWidget.py:
	Moshe noticed an inconsistency in his comment, so I'm rephrasing it to
	be clearer.

	* TreeWidget.py:
	Patch inspired by Moshe Zadka to search for the Icons directory in the
	same directory as __file__, rather than searching for it along sys.path.
	This works better when idle is a package.

Thu Jul 15 13:11:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: New wishes.

Sat Jul 10 13:17:35 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* IdlePrefs.py:
	Make the color for stderr red (i.e. the standard warning/danger/stop
	color) rather than green.  Suggested by Sam Schulenburg.

Fri Jun 25 17:26:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Close debugger when closing.  This may break a cycle.

	* Debugger.py: Break cycle on close.

	* ClassBrowser.py: Destroy the tree when closing.

	* TreeWidget.py: Add destroy() method to recursively destroy a tree.

	* PyShell.py: Extend _close() to break cycles.
	Break some other cycles too (and destroy the root when done).

	* EditorWindow.py:
	Add _close() method that does the actual cleanup (close() asks the
	user what they want first if there's unsaved stuff, and may cancel).
	It closes more than before.

	Add unload_extensions() method to unload all extensions; called from
	_close().  It calls an extension's close() method if it has one.

	* Percolator.py: Add close() method that breaks cycles.

	* WidgetRedirector.py: Add unregister() method.
	Unregister everything at closing.
	Don't call close() in __del__, rely on explicit call to close().

	* IOBinding.py, FormatParagraph.py, CallTips.py:
	Add close() method that breaks a cycle.

Fri Jun 11 15:03:00 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, FormatParagraph.py:
	Tim Peters smart.patch:

	EditorWindow.py:

	+ Added get_tabwidth & set_tabwidth "virtual text" methods, that get/set the
	widget's view of what a tab means.

	+ Moved TK_TABWIDTH_DEFAULT here from AutoIndent.

	+ Renamed Mark's get_selection_index to get_selection_indices (sorry, Mark,
	but the name was plain wrong <wink>).

	FormatParagraph.py:  renamed use of get_selection_index.

	AutoIndent.py:

	+ Moved TK_TABWIDTH_DEFAULT to EditorWindow.

	+ Rewrote set_indentation_params to use new VTW get/set_tabwidth methods.

	+ Changed smart_backspace_event to delete whitespace back to closest
	preceding virtual tab stop or real character (note that this may require
	inserting characters if backspacing over a tab!).

	+ Nuked almost references to the selection tag, in favor of using
	get_selection_indices.  The sole exception is in set_region, for which no
	"set_selection" abstraction has yet been agreed upon.

	+ Had too much fun using the spiffy new features of the format-paragraph
	cmd.

Thu Jun 10 17:48:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Code by Mark Hammond to format paragraphs embedded in comments.
	Read the comments (which I reformatted using the new feature :-)
	for some limitations.

	* EditorWindow.py:
	Added abstraction get_selection_index() (Mark Hammond).  Also
	reformatted some comment blocks to show off a cool feature I'm about
	to check in next.

	* ClassBrowser.py:
	Adapt to the new pyclbr's support of listing top-level functions.  If
	this functionality is not present (e.g. when used with a vintage
	Python 1.5.2 installation) top-level functions are not listed.

	(Hmm...  Any distribution of IDLE 0.5 should probably include a copy
	of the new pyclbr.py!)

	* AutoIndent.py:
	Fix off-by-one error in Tim's recent change to comment_region(): the
	list of lines returned by get_region() contains an empty line at the
	end representing the start of the next line, and this shouldn't be
	commented out!

	* CallTips.py:
	Mark Hammond writes: Here is another change that allows it to work for
	class creation - tries to locate an __init__ function.  Also updated
	the test code to reflect your new "***" change.

	* CallTipWindow.py:
	Mark Hammond writes: Tim's suggestion of copying the font for the
	CallTipWindow from the text control makes sense, and actually makes
	the control look better IMO.

Wed Jun  9 20:34:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* CallTips.py:
	Append "..." if the appropriate flag (for varargs) in co_flags is set.
	Ditto "***" for kwargs.

Tue Jun  8 13:06:07 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ReplaceDialog.py:
	Hmm...  Tim didn't turn "replace all" into a single undo block.
	I think I like it better if it os, so here.

	* ReplaceDialog.py: Tim Peters: made replacement atomic for undo/redo.

	* AutoIndent.py: Tim Peters:

	+ Set usetabs=1.  Editing pyclbr.py was driving me nuts <0.6 wink>.
	usetabs=1 is the Emacs pymode default too, and thanks to indentwidth !=
	tabwidth magical usetabs disabling, new files are still created with tabs
	turned off.  The only implication is that if you open a file whose first
	indent is a single tab, IDLE will now magically use tabs for that file (and
	set indentwidth to 8).  Note that the whole scheme doesn't work right for
	PythonWin, though, since Windows users typically set tabwidth to 4; Mark
	probably has to hide the IDLE algorithm from them (which he already knows).

	+ Changed comment_region_event to stick "##" in front of every line.  The
	"holes" previously left on blank lines were visually confusing (made it
	needlessly hard to figure out what to uncomment later).

Mon Jun  7 15:38:40 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TreeWidget.py, ObjectBrowser.py:
	Remove unnecessary reference to pyclbr from test() code.

	* PyParse.py: Tim Peters:

	Smarter logic for finding a parse synch point.

	Does a half to a fifth the work in normal cases; don't notice the speedup,
	but makes  more breathing room for other extensions.

	Speeds terrible cases by at least a factor of 10. "Terrible" == e.g. you put
	""" at the start of Tkinter.py, undo it, zoom to the bottom, and start
	typing in code.  Used to take about 8 seconds for ENTER to respond, now some
	large fraction of a second.  The new code gets indented correctly, despite
	that it all remains "string colored" until the colorizer catches up (after
	which, ENTER appears instantaneous again).

Fri Jun  4 19:21:19 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* extend.py: Might as well enable CallTips by default.
	If there are too many complaints I'll remove it again or fix it.

Thu Jun  3 14:32:16 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, PyParse.py:
	New offerings by Tim Peters; he writes:

	IDLE is now the first Python editor in the Universe not confused by my
	doctest.py <wink>.

	As threatened, this defines IDLE's is_char_in_string function as a
	method of EditorWindow.  You just need to define one similarly in
	whatever it is you pass as editwin to AutoIndent; looking at the
	EditorWindow.py part of the patch should make this clear.

	* GrepDialog.py: Enclose pattern in quotes in status message.

	* CallTips.py:
	Mark Hammond fixed some comments and improved the way the tip text is
	constructed.

Wed Jun  2 18:18:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* CallTips.py:
	My fix to Mark's code: restore the universal check on <KeyRelease>.
	Always cancel on <Key-Escape> or <ButtonPress>.

	* CallTips.py:
	A version that Mark Hammond posted to the newsgroup.  Has some newer
	stuff for getting the tip.  Had to fix the Key-( and Key-) events
	for Unix.  Will have to re-apply my patch for catching KeyRelease and
	ButtonRelease events.

	* CallTipWindow.py, CallTips.py:
	Call tips by Mark Hammond (plus tiny fix by me.)

	* IdleHistory.py:
	Changes by Mark Hammond: (1) support optional output_sep argument to
	the constructor so he can eliminate the sys.ps2 that PythonWin leaves
	in the source; (2) remove duplicate history items.

	* AutoIndent.py:
	Changes by Mark Hammond to allow using IDLE extensions in PythonWin as
	well: make three dialog routines instance variables.

	* EditorWindow.py:
	Change by Mark Hammond to allow using IDLE extensions in PythonWin as
	well: make three dialog routines instance variables.

Tue Jun  1 20:06:44 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py: Hah!  A fix of my own to Tim's code!
	Unix bindings for <<toggle-tabs>> and <<change-indentwidth>> were
	missing, and somehow that meant the events were never generated,
	even though they were in the menu.  The new Unix bindings are now
	the same as the Windows bindings (M-t and M-u).

	* AutoIndent.py, PyParse.py, PyShell.py: Tim Peters again:

	The new version (attached) is fast enough all the time in every real module
	I have <whew!>.  You can make it slow by, e.g., creating an open list with
	5,000 90-character identifiers (+ trailing comma) each on its own line, then
	adding an item to the end -- but that still consumes less than a second on
	my P5-166.  Response time in real code appears instantaneous.

	Fixed some bugs.

	New feature:  when hitting ENTER and the cursor is beyond the line's leading
	indentation, whitespace is removed on both sides of the cursor; before
	whitespace was removed only on the left; e.g., assuming the cursor is
	between the comma and the space:

	def something(arg1, arg2):
	                   ^ cursor to the left of here, and hit ENTER
	               arg2):   # new line used to end up here
	              arg2):    # but now lines up the way you expect

	New hack:  AutoIndent has grown a context_use_ps1 Boolean config option,
	defaulting to 0 (false) and set to 1 (only) by PyShell.  Reason:  handling
	the fancy stuff requires looking backward for a parsing synch point; ps1
	lines are the only sensible thing to look for in a shell window, but are a
	bad thing to look for in a file window (ps1 lines show up in my module
	docstrings often).  PythonWin's shell should set this true too.

	Persistent problem:  strings containing def/class can still screw things up
	completely.  No improvement.  Simplest workaround is on the user's head, and
	consists of inserting e.g.

	def _(): pass

	(or any other def/class) after the end of the multiline string that's
	screwing them up.  This is especially irksome because IDLE's syntax coloring
	is *not* confused, so when this happens the colors don't match the
	indentation behavior they see.

	* AutoIndent.py: Tim Peters again:

	[Tim, after adding some bracket smarts to AutoIndent.py]
	> ...
	> What it can't possibly do without reparsing large gobs of text is
	> suggest a reasonable indent level after you've *closed* a bracket
	> left open on some previous line.
	> ...

	The attached can, and actually fast enough to use -- most of the time.  The
	code is tricky beyond belief to achieve that, but it works so far; e.g.,

	        return len(string.expandtabs(str[self.stmt_start :
	                                         ^ indents to caret
	                                         i],
	                                     ^ indents to caret
	                                     self.tabwidth)) + 1
	    ^ indents to caret

	It's about as smart as pymode now, wrt both bracket and backslash
	continuation rules.  It does require reparsing large gobs of text, and if it
	happens to find something that looks like a "def" or "class" or sys.ps1
	buried in a multiline string, but didn't suck up enough preceding text to
	see the start of the string, it's completely hosed.  I can't repair that --
	it's just too slow to reparse from the start of the file all the time.

	AutoIndent has grown a new num_context_lines tuple attribute that controls
	how far to look back, and-- like other params --this could/should be made
	user-overridable at startup and per-file on the fly.

	* PyParse.py: New file by Tim Peters:

	One new file in the attached, PyParse.py.  The LineStudier (whatever it was
	called <wink>) class was removed from AutoIndent; PyParse subsumes its
	functionality.

	* AutoIndent.py: Tim Peters keeps revising this module (more to come):

	Removed "New tabwidth" menu binding.

	Added "a tab means how many spaces?" dialog to block tabify and untabify.  I
	think prompting for this is good now:  they're usually at-most-once-per-file
	commands, and IDLE can't let them change tabwidth from the Tk default
	anymore, so IDLE can no longer presume to have any idea what a tab means.

	Irony:  for the purpose of keeping comments aligned via tabs, Tk's
	non-default approach is much nicer than the Emacs/Notepad/Codewright/vi/etc
	approach.

	* EditorWindow.py:
	1. Catch NameError on import (could be raised by case mismatch on Windows).
	2. No longer need to reset pyclbr cache and show watch cursor when calling
	   ClassBrowser -- the ClassBrowser takes care of pyclbr and the TreeWidget
	   takes care of the watch cursor.
	3. Reset the focus to the current window after error message about class
	   browser on buffer without filename.

	* Icons/minusnode.gif, Icons/plusnode.gif: Missed a few.

	* ClassBrowser.py, PathBrowser.py: Rewritten based on TreeWidget.py

	* ObjectBrowser.py: Object browser, based on TreeWidget.py.

	* TreeWidget.py: Tree widget done right.

	* ToolTip.py: As yet unused code for tool tips.

	* ScriptBinding.py:
	Ensure sys.argv[0] is the script name on Run Script.

	* ZoomHeight.py: Move zoom height functionality to separate function.

	* Icons/folder.gif, Icons/openfolder.gif, Icons/python.gif, Icons/tk.gif:
	A few icons used by ../TreeWidget.py and its callers.

	* AutoIndent.py: New version by Tim Peters improves block opening test.

Fri May 21 04:46:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/History.py, PyShell.py: Rename History to IdleHistory.
	Add isatty() to pseudo files.

	* StackViewer.py: Make initial stack viewer wider

	* TODO.txt: New wishes

	* AutoIndent.py, EditorWindow.py, PyShell.py:
	Much improved autoindent and handling of tabs,
	by Tim Peters.

Mon May  3 15:49:52 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py, EditorWindow.py, FormatParagraph.py, UndoDelegator.py:
	Tim Peters writes:

	I'm still unsure, but couldn't stand the virtual event trickery so tried a
	different sin (adding undo_block_start/stop methods to the Text instance in
	EditorWindow.py).  Like it or not, it's efficient and works <wink>.  Better
	idea?

	Give the attached a whirl.  Even if you hate the implementation, I think
	you'll like the results.  Think I caught all the "block edit" cmds,
	including Format Paragraph, plus subtler ones involving smart indents and
	backspacing.

	* WidgetRedirector.py: Tim Peters writes:

	[W]hile trying to dope out how redirection works, stumbled into two
	possible glitches.  In the first, it doesn't appear to make sense to try to
	rename a command that's already been destroyed; in the second, the name
	"previous" doesn't really bring to mind "ignore the previous value" <wink>.

Fri Apr 30 19:39:25 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* __init__.py: Support for using idle as a package.

	* PathBrowser.py:
	Avoid listing files more than once (e.g. foomodule.so has two hits:
	once for foo + module.so, once for foomodule + .so).

Mon Apr 26 22:20:38 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ChangeLog, ColorDelegator.py, PyShell.py: Tim Peters strikes again:

	Ho ho ho -- that's trickier than it sounded!  The colorizer is working with
	"line.col" strings instead of Text marks, and the absolute coordinates of
	the point of interest can change across the self.update call (voice of
	baffled experience, when two quick backspaces no longer fooled it, but a
	backspace followed by a quick ENTER did <wink>).

	Anyway, the attached appears to do the trick.  CPU usage goes way up when
	typing quickly into a long triple-quoted string, but the latency is fine for
	me (a relatively fast typist on a relatively slow machine).  Most of the
	changes here are left over from reducing the # of vrbl names to help me
	reason about the logic better; I hope the code is a *little* easier to

Fri Apr 23 14:01:25 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py:
	Provide full arguments to __import__ so it works in packagized IDLE.

Thu Apr 22 23:20:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

        * help.txt:
        Bunch of updates necessary due to recent changes; added docs for File
        menu, command line and color preferences.

        * Bindings.py: Remove obsolete 'script' menu.

	* TODO.txt: Several wishes fulfilled.

	* OutputWindow.py:
	Moved classes OnDemandOutputWindow and PseudoFile here,
	from ScriptBinding.py where they are no longer needed.

	* ScriptBinding.py:
	Mostly rewritten.  Instead of the old Run module and Debug module,
	there are two new commands:

	Import module (F5) imports or reloads the module and also adds its
	name to the __main__ namespace.  This gets executed in the PyShell
	window under control of its debug settings.

	Run script (Control-F5) is similar but executes the contents of the
	file directly in the __main__ namespace.

	* PyShell.py: Nits: document use of $IDLESTARTUP; display idle version

	* idlever.py: New version to celebrate new command line

	* OutputWindow.py: Added flush(), for completeness.

	* PyShell.py:
	A lot of changes to make the command line more useful.  You can now do:
	  idle.py -e file ...    -- to edit files
	  idle.py script arg ... -- to run a script
	  idle.py -c cmd arg ... -- to run a command
	Other options, see also the usage message (also new!) for more details:
	  -d       -- enable debugger
	  -s       -- run $IDLESTARTUP or $PYTHONSTARTUP
	  -t title -- set Python Shell window's title
	sys.argv is set accordingly, unless -e is used.
	sys.path is absolutized, and all relevant paths are inserted into it.

	Other changes:
	- the environment in which commands are executed is now the
	  __main__ module
	- explicitly save sys.stdout etc., don't restore from sys.__stdout__
	- new interpreter methods execsource(), execfile(), stuffsource()
	- a few small nits

	* TODO.txt:
	Some more TODO items.  Made up my mind about command line args,
	Run/Import, __main__.

	* ColorDelegator.py:
	Super-elegant patch by Tim Peters that speeds up colorization
	dramatically (up to 15 times he claims).  Works by reading more than
	one line at a time, up to 100-line chunks (starting with one line and
	then doubling up to the limit).  On a typical machine (e.g. Tim's
	P5-166) this doesn't reduce interactive responsiveness in a noticeable
	way.

Wed Apr 21 15:49:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ColorDelegator.py:
	Patch by Tim Peters to speed up colorizing of big multiline strings.

Tue Apr 20 17:32:52 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* extend.txt:
	For an event 'foo-bar', the corresponding method must be called
	foo_bar_event().  Therefore, fix the references to zoom_height() in
	the example.

	* IdlePrefs.py: Restored the original IDLE color scheme.

	* PyShell.py, IdlePrefs.py, ColorDelegator.py, EditorWindow.py:
	Color preferences code by Loren Luke (massaged by me somewhat)

	* SearchEngine.py:
	Patch by Mark Favas: it fixes the search engine behaviour where an
	unsuccessful search wraps around and re-searches that part of the file
	between the start of the search and the end of the file - only really
	an issue for very large files, but... (also removes a redundant
	m.span() call).

Mon Apr 19 16:26:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: A few wishes are now fulfilled.

	* AutoIndent.py: Tim Peters implements some of my wishes:

	o Makes the tab key intelligently insert spaces when appropriate
	(see Help list banter twixt David Ascher and me; idea stolen from
	every other editor on earth <wink>).

	o newline_and_indent_event trims trailing whitespace on the old
	line (pymode and Codewright).

	o newline_and_indent_event no longer fooled by trailing whitespace or
	comment after ":" (pymode, PTUI).

	o newline_and_indent_event now reduces the new line's indentation after
	return, break, continue, raise and pass stmts (pymode).

	The last two are easy to fool in the presence of strings &
	continuations, but pymode requires Emacs's high-powered C parsing
	functions to avoid that in finite time.

======================================================================
	Python release 1.5.2c1, IDLE version 0.4
======================================================================

Wed Apr  7 18:41:59 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* README.txt, NEWS.txt: New version.

	* idlever.py: Version bump awaiting impending new release.
	(Not much has changed :-( )

Mon Mar 29 14:52:28 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ScriptBinding.py, PyShell.py:
	At Tim Peters' recommendation, add a dummy flush() method to
	PseudoFile.

Thu Mar 11 23:21:23 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PathBrowser.py: Don't crash when sys.path contains an empty string.

	* Attic/Outline.py: This file was never supposed to be part of IDLE.

	* PathBrowser.py:
	- Don't crash in the case where a superclass is a string instead of a
	pyclbr.Class object; this can happen when the superclass is
	unrecognizable (to pyclbr), e.g. when module renaming is used.

	- Show a watch cursor when calling pyclbr (since it may take a while
	recursively parsing imported modules!).

Wed Mar 10 05:18:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, Bindings.py: Add PathBrowser to File module

	* PathBrowser.py: "Path browser" - 4 scrolled lists displaying:
	    directories on sys.path
	    modules in selected directory
	    classes in selected module
	    methods of selected class

	Sinlge clicking in a directory, module or class item updates the next
	column with info about the selected item.  Double clicking in a
	module, class or method item opens the file (and selects the clicked
	item if it is a class or method).

	I guess eventually I should be using a tree widget for this, but the
	ones I've seen don't work well enough, so for now I use the old
	Smalltalk or NeXT style multi-column hierarchical browser.

	* MultiScrolledLists.py:
	New utility: multiple scrolled lists in parallel

	* ScrolledList.py: - White background.
	- Display "(None)" (or text of your choosing) when empty.
	- Don't set the focus.

======================================================================
	Python release 1.5.2b2, IDLE version 0.3
======================================================================
	
Wed Feb 17 22:47:41 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* NEWS.txt: News in 0.3.

	* README.txt, idlever.py: Bump version to 0.3.

	* EditorWindow.py:
	After all, we don't need to call the callbacks ourselves!

	* WindowList.py:
	When deleting, call the callbacks *after* deleting the window from our list!

	* EditorWindow.py:
	Fix up the Windows menu via the new callback mechanism instead of
	depending on menu post commands (which don't work when the menu is
	torn off).

	* WindowList.py:
	Support callbacks to patch up Windows menus everywhere.

	* ChangeLog: Oh, why not.  Checking in the Emacs-generated change log.

Tue Feb 16 22:34:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ScriptBinding.py:
	Only pop up the stack viewer when requested in the Debug menu.

Mon Feb  8 22:27:49 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* WindowList.py: Don't crash if a window no longer exists.

	* TODO.txt: Restructured a bit.

Mon Feb  1 23:06:17 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Add current dir or paths of file args to sys.path.

	* Debugger.py: Add canonic() function -- for brand new bdb.py feature.

	* StackViewer.py: Protect against accessing an empty stack.

Fri Jan 29 20:44:45 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* ZoomHeight.py:
	Use only the height to decide whether to zoom in or out.

Thu Jan 28 22:24:30 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, FileList.py:
	Make sure the Tcl variables are shared between windows.

	* PyShell.py, EditorWindow.py, Bindings.py:
	Move menu/key binding code from Bindings.py to EditorWindow.py,
	with changed APIs -- it makes much more sense there.
	Also add a new feature: if the first character of a menu label is
	a '!', it gets a checkbox.  Checkboxes are bound to Boolean Tcl variables
	that can be accessed through the new getvar/setvar/getrawvar API;
	the variable is named after the event to which the menu is bound.

	* Debugger.py: Add Quit button to the debugger window.

	* SearchDialog.py:
	When find_again() finds exactly the current selection, it's a failure.

	* idle.py, Attic/idle: Rename idle -> idle.py

Mon Jan 18 15:18:57 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* EditorWindow.py, WindowList.py: Only deiconify when iconic.

	* TODO.txt: Misc

Tue Jan 12 22:14:34 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* testcode.py, Attic/test.py:
	Renamed test.py to testcode.py so one can import Python's
	test package from inside IDLE.  (Suggested by Jack Jansen.)

	* EditorWindow.py, ColorDelegator.py:
	Hack to close a window that is colorizing.

	* Separator.py: Vladimir Marangozov's patch:
	The separator dances too much and seems to jump by arbitrary amounts
	in arbitrary directions when I try to move it for resizing the frames.
	This patch makes it more quiet.

Mon Jan 11 14:52:40 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* TODO.txt: Some requests have been fulfilled.

	* EditorWindow.py:
	Set the cursor to a watch when opening the class browser (which may
	take quite a while, browsing multiple files).

	Newer, better center() -- but assumes no wrapping.

	* SearchBinding.py:
	Got rid of debug print statement in goto_line_event().

	* ScriptBinding.py:
	I think I like it better if it prints the traceback even when it displays
	the stack viewer.

	* Debugger.py: Bind ESC to close-window.

	* ClassBrowser.py: Use a HSeparator between the classes and the items.
	Make the list of classes wider by default (40 chars).
	Bind ESC to close-window.

	* Separator.py:
	Separator classes (draggable divider between two panes).

Sat Jan  9 22:01:33 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* WindowList.py:
	Don't traceback when wakeup() is called when the window has been destroyed.
	This can happen when a torn-of Windows menu references closed windows.
	And Tim Peters claims that the Windows menu is his favorite to tear off...

	* EditorWindow.py: Allow tearing off of the Windows menu.

	* StackViewer.py: Close on ESC.

	* help.txt: Updated a bunch of things (it was mostly still 0.1!)

	* extend.py: Added ScriptBinding to standard bindings.

	* ScriptBinding.py:
	This now actually works.  See doc string.  It can run a module (i.e.
	import or reload) or debug it (same with debugger control).  Output
	goes to a fresh output window, only created when needed.

======================================================================
	Python release 1.5.2b1, IDLE version 0.2
======================================================================
	
Fri Jan  8 17:26:02 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* README.txt, NEWS.txt: What's new in this release.

	* Bindings.py, PyShell.py:
	Paul Prescod's patches to allow the stack viewer to pop up when a
	traceback is printed.

Thu Jan  7 00:12:15 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Change paragraph width limit to 70 (like Emacs M-Q).

	* README.txt:
	Separating TODO from README.  Slight reformulation of features.  No
	exact release date.

	* TODO.txt: Separating TODO from README.

Mon Jan  4 21:19:09 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* FormatParagraph.py:
	Hm.  There was a boundary condition error at the end of the file too.

	* SearchBinding.py: Hm.  Add Unix binding for replace, too.

	* keydefs.py: Ran eventparse.py again.

	* FormatParagraph.py: Added Unix Meta-q key binding;
	fix find_paragraph when at start of file.

	* AutoExpand.py: Added Meta-/ binding for Unix as alt for Alt-/.

	* SearchBinding.py:
	Add unix binding for grep (otherwise the menu entry doesn't work!)

	* ZoomHeight.py: Adjusted Unix height to work with fvwm96. :=(

	* GrepDialog.py: Need to import sys!

	* help.txt, extend.txt, README.txt: Formatted some paragraphs

	* extend.py, FormatParagraph.py:
	Add new extension to reformat a (text) paragraph.

	* ZoomHeight.py: Typo in Win specific height setting.

Sun Jan  3 00:47:35 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* AutoIndent.py: Added something like Tim Peters' backspace patch.

	* ZoomHeight.py: Adapted to Unix (i.e., more hardcoded constants).

Sat Jan  2 21:28:54 1999  Guido van Rossum  <guido@cnri.reston.va.us>

	* keydefs.py, idlever.py, idle.pyw, idle.bat, help.txt, extend.txt, extend.py, eventparse.py, ZoomHeight.py, WindowList.py, UndoDelegator.py, StackViewer.py, SearchEngine.py, SearchDialogBase.py, SearchDialog.py, ScrolledList.py, SearchBinding.py, ScriptBinding.py, ReplaceDialog.py, Attic/README, README.txt, PyShell.py, Attic/PopupMenu.py, OutputWindow.py, IOBinding.py, Attic/HelpWindow.py, History.py, GrepDialog.py, FileList.py, FrameViewer.py, EditorWindow.py, Debugger.py, Delegator.py, ColorDelegator.py, Bindings.py, ClassBrowser.py, AutoExpand.py, AutoIndent.py:
	Checking in IDLE 0.2.

	Much has changed -- too much, in fact, to write down.
	The big news is that there's a standard way to write IDLE extensions;
	see extend.txt.  Some sample extensions have been provided, and
	some existing code has been converted to extensions.  Probably the
	biggest new user feature is a new search dialog with more options,
	search and replace, and even search in files (grep).

	This is exactly as downloaded from my laptop after returning
	from the holidays -- it hasn't even been tested on Unix yet.

Fri Dec 18 15:52:54 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* FileList.py, ClassBrowser.py:
	Fix the class browser to work even when the file is not on sys.path.

Tue Dec  8 20:39:36 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: Moved to Python 1.5.2/Lib

Fri Nov 27 03:19:20 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* help.txt: Typo

	* EditorWindow.py, FileList.py: Support underlining of menu labels

	* Bindings.py:
	New approach, separate tables for menus (platform-independent) and key
	definitions (platform-specific), and generating accelerator strings
	automatically from the key definitions.

Mon Nov 16 18:37:42 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/README: Clarify portability and main program.

	* Attic/README: Added intro for 0.1 release and append Grail notes.

Mon Oct 26 18:49:00 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: root is now a global called _root

Sat Oct 24 16:38:38 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Attic/turtle.py: Raise the root window on reset().
	Different action on WM_DELETE_WINDOW is more likely to do the right thing,
	allowing us to destroy old windows.

	* Attic/turtle.py:
	Split the goto() function in two: _goto() is the internal one,
	using Canvas coordinates, and goto() uses turtle coordinates
	and accepts variable argument lists.

	* Attic/turtle.py: Cope with destruction of the window

	* Attic/turtle.py: Turtle graphics

	* Debugger.py: Use of Breakpoint class should be bdb.Breakpoint.

Mon Oct 19 03:33:40 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* SearchBinding.py:
	Speed up the search a bit -- don't drag a mark around...

	* PyShell.py:
	Change our special entries from <console#N> to <pyshell#N>.
	Patch linecache.checkcache() to keep our special entries alive.
	Add popup menu to all editor windows to set a breakpoint.

	* Debugger.py:
	Use and pass through the 'force' flag to set_dict() where appropriate.
	Default source and globals checkboxes to false.
	Don't interact in user_return().
	Add primitive set_breakpoint() method.

	* ColorDelegator.py:
	Raise priority of 'sel' tag so its foreground (on Windows) will take
	priority over text colorization (which on Windows is almost the
	same color as the selection background).

	Define a tag and color for breakpoints ("BREAK").

	* Attic/PopupMenu.py: Disable "Open stack viewer" and "help" commands.

	* StackViewer.py:
	Add optional 'force' argument (default 0) to load_dict().
	If set, redo the display even if it's the same dict.

Fri Oct 16 21:10:12 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* StackViewer.py: Do nothing when loading the same dict as before.

	* PyShell.py: Details for debugger interface.

	* Debugger.py:
	Restructured and more consistent.  Save checkboxes across instantiations.

	* EditorWindow.py, Attic/README, Bindings.py:
	Get rid of conflicting ^X binding.  Use ^W.

	* Debugger.py, StackViewer.py:
	Debugger can now show local and global variables.

	* Debugger.py: Oops

	* Debugger.py, PyShell.py: Better debugger support (show stack etc).

	* Attic/PopupMenu.py: Follow renames in StackViewer module

	* StackViewer.py:
	Rename classes to StackViewer (the widget) and StackBrowser (the toplevel).

	* ScrolledList.py: Add close() method

	* EditorWindow.py: Clarify 'Open Module' dialog text

	* StackViewer.py: Restructured into a browser and a widget.

Thu Oct 15 23:27:08 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* ClassBrowser.py, ScrolledList.py:
	Generalized the scrolled list which is the base for the class and
	method browser into a separate class in its own module.

	* Attic/test.py: Cosmetic change

	* Debugger.py: Don't show function name if there is none

Wed Oct 14 03:43:05 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Debugger.py, PyShell.py: Polish the Debugger GUI a bit.
	Closing it now also does the right thing.

Tue Oct 13 23:51:13 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* Debugger.py, PyShell.py, Bindings.py:
	Ad primitive debugger interface (so far it will step and show you the
	source, but it doesn't yet show the stack).

	* Attic/README: Misc

	* StackViewer.py: Whoops -- referenced self.top before it was set.

	* help.txt: Added history and completion commands.

	* help.txt: Updated

	* FileList.py: Add class browser functionality.

	* StackViewer.py:
	Add a close() method and bind to WM_DELETE_WINDOW protocol

	* PyShell.py: Clear the linecache before printing a traceback

	* Bindings.py: Added class browser binding.

	* ClassBrowser.py: Much improved, much left to do.

	* PyShell.py: Make the return key do what I mean more often.

	* ClassBrowser.py:
	Adding the beginnings of a Class browser.  Incomplete, yet.

	* EditorWindow.py, Bindings.py:
	Add new command, "Open module".  You select or type a module name,
	and it opens the source.

Mon Oct 12 23:59:27 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* PyShell.py: Subsume functionality from Popup menu in Debug menu.
	Other stuff so the PyShell window can be resurrected from the Windows menu.

	* FileList.py: Get rid of PopUp menu.
	Create a simple Windows menu.  (Imperfect when Untitled windows exist.)
	Add wakeup() method: deiconify, raise, focus.

	* EditorWindow.py: Generalize menu creation.

	* Bindings.py: Add Debug and Help menu items.

	* EditorWindow.py: Added a menu bar to every window.

	* Bindings.py: Add menu configuration to the event configuration.

	* Attic/PopupMenu.py: Pass a root to the help window.

	* SearchBinding.py:
	Add parent argument to 'to to line number' dialog box.

Sat Oct 10 19:15:32 1998  Guido van Rossum  <guido@cnri.reston.va.us>

	* StackViewer.py:
	Add a label at the top showing (very basic) help for the stack viewer.
	Add a label at the bottom showing the exception info.

	* Attic/test.py, Attic/idle: Add Unix main script and test program.

	* idle.pyw, help.txt, WidgetRedirector.py, UndoDelegator.py, StackViewer.py, SearchBinding.py, Attic/README, PyShell.py, Attic/PopupMenu.py, Percolator.py, Outline.py, IOBinding.py, History.py, Attic/HelpWindow.py, FrameViewer.py, FileList.py, EditorWindow.py, Delegator.py, ColorDelegator.py, Bindings.py, AutoIndent.py, AutoExpand.py:
	Initial checking of Tk-based Python IDE.
	Features: text editor with syntax coloring and undo;
	subclassed into interactive Python shell which adds history.

                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/ClassBrowser.py                                                           0100644 0000000 0000000 00000015200 12415221640 016754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Class browser.

XXX TO DO:

- reparse when source changed (maybe just a button would be OK?)
    (or recheck on window popup)
- add popup menu with more options (e.g. doc strings, base classes, imports)
- show function argument list? (have to do pattern matching on source)
- should the classes and methods lists also be in the module's menu bar?
- add base classes to class browser tree
"""

import os
import sys
import pyclbr

from idlelib import PyShell
from idlelib.WindowList import ListedToplevel
from idlelib.TreeWidget import TreeNode, TreeItem, ScrolledCanvas
from idlelib.configHandler import idleConf

class ClassBrowser:

    def __init__(self, flist, name, path, _htest=False):
        # XXX This API should change, if the file doesn't end in ".py"
        # XXX the code here is bogus!
        """
        _htest - bool, change box when location running htest.
        """
        self.name = name
        self.file = os.path.join(path[0], self.name + ".py")
        self._htest = _htest
        self.init(flist)

    def close(self, event=None):
        self.top.destroy()
        self.node.destroy()

    def init(self, flist):
        self.flist = flist
        # reset pyclbr
        pyclbr._modules.clear()
        # create top
        self.top = top = ListedToplevel(flist.root)
        top.protocol("WM_DELETE_WINDOW", self.close)
        top.bind("<Escape>", self.close)
        if self._htest: # place dialog below parent if running htest
            top.geometry("+%d+%d" %
                (flist.root.winfo_rootx(), flist.root.winfo_rooty() + 200))
        self.settitle()
        top.focus_set()
        # create scrolled canvas
        theme = idleConf.GetOption('main','Theme','name')
        background = idleConf.GetHighlight(theme, 'normal')['background']
        sc = ScrolledCanvas(top, bg=background, highlightthickness=0, takefocus=1)
        sc.frame.pack(expand=1, fill="both")
        item = self.rootnode()
        self.node = node = TreeNode(sc.canvas, None, item)
        node.update()
        node.expand()

    def settitle(self):
        self.top.wm_title("Class Browser - " + self.name)
        self.top.wm_iconname("Class Browser")

    def rootnode(self):
        return ModuleBrowserTreeItem(self.file)

class ModuleBrowserTreeItem(TreeItem):

    def __init__(self, file):
        self.file = file

    def GetText(self):
        return os.path.basename(self.file)

    def GetIconName(self):
        return "python"

    def GetSubList(self):
        sublist = []
        for name in self.listclasses():
            item = ClassBrowserTreeItem(name, self.classes, self.file)
            sublist.append(item)
        return sublist

    def OnDoubleClick(self):
        if os.path.normcase(self.file[-3:]) != ".py":
            return
        if not os.path.exists(self.file):
            return
        PyShell.flist.open(self.file)

    def IsExpandable(self):
        return os.path.normcase(self.file[-3:]) == ".py"

    def listclasses(self):
        dir, file = os.path.split(self.file)
        name, ext = os.path.splitext(file)
        if os.path.normcase(ext) != ".py":
            return []
        try:
            dict = pyclbr.readmodule_ex(name, [dir] + sys.path)
        except ImportError:
            return []
        items = []
        self.classes = {}
        for key, cl in dict.items():
            if cl.module == name:
                s = key
                if hasattr(cl, 'super') and cl.super:
                    supers = []
                    for sup in cl.super:
                        if type(sup) is type(''):
                            sname = sup
                        else:
                            sname = sup.name
                            if sup.module != cl.module:
                                sname = "%s.%s" % (sup.module, sname)
                        supers.append(sname)
                    s = s + "(%s)" % ", ".join(supers)
                items.append((cl.lineno, s))
                self.classes[s] = cl
        items.sort()
        list = []
        for item, s in items:
            list.append(s)
        return list

class ClassBrowserTreeItem(TreeItem):

    def __init__(self, name, classes, file):
        self.name = name
        self.classes = classes
        self.file = file
        try:
            self.cl = self.classes[self.name]
        except (IndexError, KeyError):
            self.cl = None
        self.isfunction = isinstance(self.cl, pyclbr.Function)

    def GetText(self):
        if self.isfunction:
            return "def " + self.name + "(...)"
        else:
            return "class " + self.name

    def GetIconName(self):
        if self.isfunction:
            return "python"
        else:
            return "folder"

    def IsExpandable(self):
        if self.cl:
            try:
                return not not self.cl.methods
            except AttributeError:
                return False

    def GetSubList(self):
        if not self.cl:
            return []
        sublist = []
        for name in self.listmethods():
            item = MethodBrowserTreeItem(name, self.cl, self.file)
            sublist.append(item)
        return sublist

    def OnDoubleClick(self):
        if not os.path.exists(self.file):
            return
        edit = PyShell.flist.open(self.file)
        if hasattr(self.cl, 'lineno'):
            lineno = self.cl.lineno
            edit.gotoline(lineno)

    def listmethods(self):
        if not self.cl:
            return []
        items = []
        for name, lineno in self.cl.methods.items():
            items.append((lineno, name))
        items.sort()
        list = []
        for item, name in items:
            list.append(name)
        return list

class MethodBrowserTreeItem(TreeItem):

    def __init__(self, name, cl, file):
        self.name = name
        self.cl = cl
        self.file = file

    def GetText(self):
        return "def " + self.name + "(...)"

    def GetIconName(self):
        return "python" # XXX

    def IsExpandable(self):
        return 0

    def OnDoubleClick(self):
        if not os.path.exists(self.file):
            return
        edit = PyShell.flist.open(self.file)
        edit.gotoline(self.cl.methods[self.name])

def _class_browser(parent): #Wrapper for htest
    try:
        file = __file__
    except NameError:
        file = sys.argv[0]
        if sys.argv[1:]:
            file = sys.argv[1]
        else:
            file = sys.argv[0]
    dir, file = os.path.split(file)
    name = os.path.splitext(file)[0]
    flist = PyShell.PyShellFileList(parent)
    ClassBrowser(flist, name, [dir], _htest=True)
    parent.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_class_browser)
                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.4/idlelib/CodeContext.py                                                            0100644 0000000 0000000 00000020241 12415221640 016563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """CodeContext - Extension to display the block context above the edit window

Once code has scrolled off the top of a window, it can be difficult to
determine which block you are in.  This extension implements a pane at the top
of each IDLE edit window which provides block structure hints.  These hints are
the lines which contain the block opening keywords, e.g. 'if', for the
enclosing block.  The number of hint lines is determined by the numlines
variable in the CodeContext section of config-extensions.def. Lines which do
not open blocks are not shown in the context hints pane.

"""
import tkinter
from tkinter.constants import TOP, LEFT, X, W, SUNKEN
import re
from sys import maxsize as INFINITY
from idlelib.configHandler import idleConf

BLOCKOPENERS = set(["class", "def", "elif", "else", "except", "finally", "for",
                    "if", "try", "while", "with"])
UPDATEINTERVAL = 100 # millisec
FONTUPDATEINTERVAL = 1000 # millisec

getspacesfirstword =\
                   lambda s, c=re.compile(r"^(\s*)(\w*)"): c.match(s).groups()

class CodeContext:
    menudefs = [('options', [('!Code Conte_xt', '<<toggle-code-context>>')])]
    context_depth = idleConf.GetOption("extensions", "CodeContext",
                                       "numlines", type="int", default=3)
    bgcolor = idleConf.GetOption("extensions", "CodeContext",
                                 "bgcolor", type="str", default="LightGray")
    fgcolor = idleConf.GetOption("extensions", "CodeContext",
                                 "fgcolor", type="str", default="Black")
    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        self.textfont = self.text["font"]
        self.label = None
        # self.info is a list of (line number, indent level, line text, block
        # keyword) tuples providing the block structure associated with
        # self.topvisible (the linenumber of the line displayed at the top of
        # the edit window). self.info[0] is initialized as a 'dummy' line which
        # starts the toplevel 'block' of the module.
        self.info = [(0, -1, "", False)]
        self.topvisible = 1
        visible = idleConf.GetOption("extensions", "CodeContext",
                                     "visible", type="bool", default=False)
        if visible:
            self.toggle_code_context_event()
            self.editwin.setvar('<<toggle-code-context>>', True)
        # Start two update cycles, one for context lines, one for font changes.
        self.text.after(UPDATEINTERVAL, self.timer_event)
        self.text.after(FONTUPDATEINTERVAL, self.font_timer_event)

    def toggle_code_context_event(self, event=None):
        if not self.label:
            # Calculate the border width and horizontal padding required to
            # align the context with the text in the main Text widget.
            #
            # All values are passed through int(str(<value>)), since some
            # values may be pixel objects, which can't simply be added to ints.
            widgets = self.editwin.text, self.editwin.text_frame
            # Calculate the required vertical padding
            padx = 0
            for widget in widgets:
                padx += int(str( widget.pack_info()['padx'] ))
                padx += int(str( widget.cget('padx') ))
            # Calculate the required border width
            border = 0
            for widget in widgets:
                border += int(str( widget.cget('border') ))
            self.label = tkinter.Label(self.editwin.top,
                                       text="\n" * (self.context_depth - 1),
                                       anchor=W, justify=LEFT,
                                       font=self.textfont,
                                       bg=self.bgcolor, fg=self.fgcolor,
                                       width=1, #don't request more than we get
                                       padx=padx, border=border,
                                       relief=SUNKEN)
            # Pack the label widget before and above the text_frame widget,
            # thus ensuring that it will appear directly above text_frame
            self.label.pack(side=TOP, fill=X, expand=False,
                            before=self.editwin.text_frame)
        else:
            self.label.destroy()
            self.label = None
        idleConf.SetOption("extensions", "CodeContext", "visible",
                           str(self.label is not None))
        idleConf.SaveUserCfgFiles()

    def get_line_info(self, linenum):
        """Get the line indent value, text, and any block start keyword

        If the line does not start a block, the keyword value is False.
        The indentation of empty lines (or comment lines) is INFINITY.

        """
        text = self.text.get("%d.0" % linenum, "%d.end" % linenum)
        spaces, firstword = getspacesfirstword(text)
        opener = firstword in BLOCKOPENERS and firstword
        if len(text) == len(spaces) or text[len(spaces)] == '#':
            indent = INFINITY
        else:
            indent = len(spaces)
        return indent, text, opener

    def get_context(self, new_topvisible, stopline=1, stopindent=0):
        """Get context lines, starting at new_topvisible and working backwards.

        Stop when stopline or stopindent is reached. Return a tuple of context
        data and the indent level at the top of the region inspected.

        """
        assert stopline > 0
        lines = []
        # The indentation level we are currently in:
        lastindent = INFINITY
        # For a line to be interesting, it must begin with a block opening
        # keyword, and have less indentation than lastindent.
        for linenum in range(new_topvisible, stopline-1, -1):
            indent, text, opener = self.get_line_info(linenum)
            if indent < lastindent:
                lastindent = indent
                if opener in ("else", "elif"):
                    # We also show the if statement
                    lastindent += 1
                if opener and linenum < new_topvisible and indent >= stopindent:
                    lines.append((linenum, indent, text, opener))
                if lastindent <= stopindent:
                    break
        lines.reverse()
        return lines, lastindent

    def update_code_context(self):
        """Update context information and lines visible in the context pane.

        """
        new_topvisible = int(self.text.index("@0,0").split('.')[0])
        if self.topvisible == new_topvisible:      # haven't scrolled
            return
        if self.topvisible < new_topvisible:       # scroll down
            lines, lastindent = self.get_context(new_topvisible,
                                                 self.topvisible)
            # retain only context info applicable to the region
            # between topvisible and new_topvisible:
            while self.info[-1][1] >= lastindent:
                del self.info[-1]
        elif self.topvisible > new_topvisible:     # scroll up
            stopindent = self.info[-1][1] + 1
            # retain only context info associated
            # with lines above new_topvisible:
            while self.info[-1][0] >= new_topvisible:
                stopindent = self.info[-1][1]
                del self.info[-1]
            lines, lastindent = self.get_context(new_topvisible,
                                                 self.info[-1][0]+1,
                                                 stopindent)
        self.info.extend(lines)
        self.topvisible = new_topvisible
        # empty lines in context pane:
        context_strings = [""] * max(0, self.context_depth - len(self.info))
        # followed by the context hint lines:
        context_strings += [x[2] for x in self.info[-self.context_depth:]]
        self.label["text"] = '\n'.join(context_strings)

    def timer_event(self):
        if self.label:
            self.update_code_context()
        self.text.after(UPDATEINTERVAL, self.timer_event)

    def font_timer_event(self):
        newtextfont = self.text["font"]
        if self.label and newtextfont != self.textfont:
            self.textfont = newtextfont
            self.label["font"] = self.textfont
        self.text.after(FONTUPDATEINTERVAL, self.font_timer_event)
                                                                                                                                                                                                                                                                                                                                                               usr/lib/python3.4/idlelib/ColorDelegator.py                                                         0100644 0000000 0000000 00000022717 12415221640 017263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import time
import re
import keyword
import builtins
from tkinter import *
from idlelib.Delegator import Delegator
from idlelib.configHandler import idleConf

DEBUG = False

def any(name, alternates):
    "Return a named group pattern matching list of alternates."
    return "(?P<%s>" % name + "|".join(alternates) + ")"

def make_pat():
    kw = r"\b" + any("KEYWORD", keyword.kwlist) + r"\b"
    builtinlist = [str(name) for name in dir(builtins)
                                        if not name.startswith('_') and \
                                        name not in keyword.kwlist]
    # self.file = open("file") :
    # 1st 'file' colorized normal, 2nd as builtin, 3rd as string
    builtin = r"([^.'\"\\#]\b|^)" + any("BUILTIN", builtinlist) + r"\b"
    comment = any("COMMENT", [r"#[^\n]*"])
    stringprefix = r"(\br|u|ur|R|U|UR|Ur|uR|b|B|br|Br|bR|BR|rb|rB|Rb|RB)?"
    sqstring = stringprefix + r"'[^'\\\n]*(\\.[^'\\\n]*)*'?"
    dqstring = stringprefix + r'"[^"\\\n]*(\\.[^"\\\n]*)*"?'
    sq3string = stringprefix + r"'''[^'\\]*((\\.|'(?!''))[^'\\]*)*(''')?"
    dq3string = stringprefix + r'"""[^"\\]*((\\.|"(?!""))[^"\\]*)*(""")?'
    string = any("STRING", [sq3string, dq3string, sqstring, dqstring])
    return kw + "|" + builtin + "|" + comment + "|" + string +\
           "|" + any("SYNC", [r"\n"])

prog = re.compile(make_pat(), re.S)
idprog = re.compile(r"\s+(\w+)", re.S)

class ColorDelegator(Delegator):

    def __init__(self):
        Delegator.__init__(self)
        self.prog = prog
        self.idprog = idprog
        self.LoadTagDefs()

    def setdelegate(self, delegate):
        if self.delegate is not None:
            self.unbind("<<toggle-auto-coloring>>")
        Delegator.setdelegate(self, delegate)
        if delegate is not None:
            self.config_colors()
            self.bind("<<toggle-auto-coloring>>", self.toggle_colorize_event)
            self.notify_range("1.0", "end")
        else:
            # No delegate - stop any colorizing
            self.stop_colorizing = True
            self.allow_colorizing = False

    def config_colors(self):
        for tag, cnf in self.tagdefs.items():
            if cnf:
                self.tag_configure(tag, **cnf)
        self.tag_raise('sel')

    def LoadTagDefs(self):
        theme = idleConf.GetOption('main','Theme','name')
        self.tagdefs = {
            "COMMENT": idleConf.GetHighlight(theme, "comment"),
            "KEYWORD": idleConf.GetHighlight(theme, "keyword"),
            "BUILTIN": idleConf.GetHighlight(theme, "builtin"),
            "STRING": idleConf.GetHighlight(theme, "string"),
            "DEFINITION": idleConf.GetHighlight(theme, "definition"),
            "SYNC": {'background':None,'foreground':None},
            "TODO": {'background':None,'foreground':None},
            "ERROR": idleConf.GetHighlight(theme, "error"),
            # The following is used by ReplaceDialog:
            "hit": idleConf.GetHighlight(theme, "hit"),
            }

        if DEBUG: print('tagdefs',self.tagdefs)

    def insert(self, index, chars, tags=None):
        index = self.index(index)
        self.delegate.insert(index, chars, tags)
        self.notify_range(index, index + "+%dc" % len(chars))

    def delete(self, index1, index2=None):
        index1 = self.index(index1)
        self.delegate.delete(index1, index2)
        self.notify_range(index1)

    after_id = None
    allow_colorizing = True
    colorizing = False

    def notify_range(self, index1, index2=None):
        self.tag_add("TODO", index1, index2)
        if self.after_id:
            if DEBUG: print("colorizing already scheduled")
            return
        if self.colorizing:
            self.stop_colorizing = True
            if DEBUG: print("stop colorizing")
        if self.allow_colorizing:
            if DEBUG: print("schedule colorizing")
            self.after_id = self.after(1, self.recolorize)

    close_when_done = None # Window to be closed when done colorizing

    def close(self, close_when_done=None):
        if self.after_id:
            after_id = self.after_id
            self.after_id = None
            if DEBUG: print("cancel scheduled recolorizer")
            self.after_cancel(after_id)
        self.allow_colorizing = False
        self.stop_colorizing = True
        if close_when_done:
            if not self.colorizing:
                close_when_done.destroy()
            else:
                self.close_when_done = close_when_done

    def toggle_colorize_event(self, event):
        if self.after_id:
            after_id = self.after_id
            self.after_id = None
            if DEBUG: print("cancel scheduled recolorizer")
            self.after_cancel(after_id)
        if self.allow_colorizing and self.colorizing:
            if DEBUG: print("stop colorizing")
            self.stop_colorizing = True
        self.allow_colorizing = not self.allow_colorizing
        if self.allow_colorizing and not self.colorizing:
            self.after_id = self.after(1, self.recolorize)
        if DEBUG:
            print("auto colorizing turned",\
                  self.allow_colorizing and "on" or "off")
        return "break"

    def recolorize(self):
        self.after_id = None
        if not self.delegate:
            if DEBUG: print("no delegate")
            return
        if not self.allow_colorizing:
            if DEBUG: print("auto colorizing is off")
            return
        if self.colorizing:
            if DEBUG: print("already colorizing")
            return
        try:
            self.stop_colorizing = False
            self.colorizing = True
            if DEBUG: print("colorizing...")
            t0 = time.perf_counter()
            self.recolorize_main()
            t1 = time.perf_counter()
            if DEBUG: print("%.3f seconds" % (t1-t0))
        finally:
            self.colorizing = False
        if self.allow_colorizing and self.tag_nextrange("TODO", "1.0"):
            if DEBUG: print("reschedule colorizing")
            self.after_id = self.after(1, self.recolorize)
        if self.close_when_done:
            top = self.close_when_done
            self.close_when_done = None
            top.destroy()

    def recolorize_main(self):
        next = "1.0"
        while True:
            item = self.tag_nextrange("TODO", next)
            if not item:
                break
            head, tail = item
            self.tag_remove("SYNC", head, tail)
            item = self.tag_prevrange("SYNC", head)
            if item:
                head = item[1]
            else:
                head = "1.0"

            chars = ""
            next = head
            lines_to_get = 1
            ok = False
            while not ok:
                mark = next
                next = self.index(mark + "+%d lines linestart" %
                                         lines_to_get)
                lines_to_get = min(lines_to_get * 2, 100)
                ok = "SYNC" in self.tag_names(next + "-1c")
                line = self.get(mark, next)
                ##print head, "get", mark, next, "->", repr(line)
                if not line:
                    return
                for tag in self.tagdefs:
                    self.tag_remove(tag, mark, next)
                chars = chars + line
                m = self.prog.search(chars)
                while m:
                    for key, value in m.groupdict().items():
                        if value:
                            a, b = m.span(key)
                            self.tag_add(key,
                                         head + "+%dc" % a,
                                         head + "+%dc" % b)
                            if value in ("def", "class"):
                                m1 = self.idprog.match(chars, b)
                                if m1:
                                    a, b = m1.span(1)
                                    self.tag_add("DEFINITION",
                                                 head + "+%dc" % a,
                                                 head + "+%dc" % b)
                    m = self.prog.search(chars, m.end())
                if "SYNC" in self.tag_names(next + "-1c"):
                    head = next
                    chars = ""
                else:
                    ok = False
                if not ok:
                    # We're in an inconsistent state, and the call to
                    # update may tell us to stop.  It may also change
                    # the correct value for "next" (since this is a
                    # line.col string, not a true mark).  So leave a
                    # crumb telling the next invocation to resume here
                    # in case update tells us to leave.
                    self.tag_add("TODO", next)
                self.update()
                if self.stop_colorizing:
                    if DEBUG: print("colorizing stopped")
                    return

    def removecolors(self):
        for tag in self.tagdefs:
            self.tag_remove(tag, "1.0", "end")

def _color_delegator(parent):
    from idlelib.Percolator import Percolator
    root = Tk()
    root.title("Test ColorDelegator")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    source = "if somename: x = 'abc' # comment\nprint"
    text = Text(root, background="white")
    text.insert("insert", source)
    text.pack(expand=1, fill="both")
    p = Percolator(text)
    d = ColorDelegator()
    p.insertfilter(d)
    root.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_color_delegator)
                                                 usr/lib/python3.4/idlelib/Debugger.py                                                               0100644 0000000 0000000 00000037733 12415221640 016106  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import bdb
from tkinter import *
from idlelib.WindowList import ListedToplevel
from idlelib.ScrolledList import ScrolledList
from idlelib import macosxSupport


class Idb(bdb.Bdb):

    def __init__(self, gui):
        self.gui = gui
        bdb.Bdb.__init__(self)

    def user_line(self, frame):
        if self.in_rpc_code(frame):
            self.set_step()
            return
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame)

    def user_exception(self, frame, info):
        if self.in_rpc_code(frame):
            self.set_step()
            return
        message = self.__frame2message(frame)
        self.gui.interaction(message, frame, info)

    def in_rpc_code(self, frame):
        if frame.f_code.co_filename.count('rpc.py'):
            return True
        else:
            prev_frame = frame.f_back
            if prev_frame.f_code.co_filename.count('Debugger.py'):
                # (that test will catch both Debugger.py and RemoteDebugger.py)
                return False
            return self.in_rpc_code(prev_frame)

    def __frame2message(self, frame):
        code = frame.f_code
        filename = code.co_filename
        lineno = frame.f_lineno
        basename = os.path.basename(filename)
        message = "%s:%s" % (basename, lineno)
        if code.co_name != "?":
            message = "%s: %s()" % (message, code.co_name)
        return message


class Debugger:

    vstack = vsource = vlocals = vglobals = None

    def __init__(self, pyshell, idb=None):
        if idb is None:
            idb = Idb(self)
        self.pyshell = pyshell
        self.idb = idb
        self.frame = None
        self.make_gui()
        self.interacting = 0

    def run(self, *args):
        try:
            self.interacting = 1
            return self.idb.run(*args)
        finally:
            self.interacting = 0

    def close(self, event=None):
        if self.interacting:
            self.top.bell()
            return
        if self.stackviewer:
            self.stackviewer.close(); self.stackviewer = None
        # Clean up pyshell if user clicked debugger control close widget.
        # (Causes a harmless extra cycle through close_debugger() if user
        # toggled debugger from pyshell Debug menu)
        self.pyshell.close_debugger()
        # Now close the debugger control window....
        self.top.destroy()

    def make_gui(self):
        pyshell = self.pyshell
        self.flist = pyshell.flist
        self.root = root = pyshell.root
        self.top = top = ListedToplevel(root)
        self.top.wm_title("Debug Control")
        self.top.wm_iconname("Debug")
        top.wm_protocol("WM_DELETE_WINDOW", self.close)
        self.top.bind("<Escape>", self.close)
        #
        self.bframe = bframe = Frame(top)
        self.bframe.pack(anchor="w")
        self.buttons = bl = []
        #
        self.bcont = b = Button(bframe, text="Go", command=self.cont)
        bl.append(b)
        self.bstep = b = Button(bframe, text="Step", command=self.step)
        bl.append(b)
        self.bnext = b = Button(bframe, text="Over", command=self.next)
        bl.append(b)
        self.bret = b = Button(bframe, text="Out", command=self.ret)
        bl.append(b)
        self.bret = b = Button(bframe, text="Quit", command=self.quit)
        bl.append(b)
        #
        for b in bl:
            b.configure(state="disabled")
            b.pack(side="left")
        #
        self.cframe = cframe = Frame(bframe)
        self.cframe.pack(side="left")
        #
        if not self.vstack:
            self.__class__.vstack = BooleanVar(top)
            self.vstack.set(1)
        self.bstack = Checkbutton(cframe,
            text="Stack", command=self.show_stack, variable=self.vstack)
        self.bstack.grid(row=0, column=0)
        if not self.vsource:
            self.__class__.vsource = BooleanVar(top)
        self.bsource = Checkbutton(cframe,
            text="Source", command=self.show_source, variable=self.vsource)
        self.bsource.grid(row=0, column=1)
        if not self.vlocals:
            self.__class__.vlocals = BooleanVar(top)
            self.vlocals.set(1)
        self.blocals = Checkbutton(cframe,
            text="Locals", command=self.show_locals, variable=self.vlocals)
        self.blocals.grid(row=1, column=0)
        if not self.vglobals:
            self.__class__.vglobals = BooleanVar(top)
        self.bglobals = Checkbutton(cframe,
            text="Globals", command=self.show_globals, variable=self.vglobals)
        self.bglobals.grid(row=1, column=1)
        #
        self.status = Label(top, anchor="w")
        self.status.pack(anchor="w")
        self.error = Label(top, anchor="w")
        self.error.pack(anchor="w", fill="x")
        self.errorbg = self.error.cget("background")
        #
        self.fstack = Frame(top, height=1)
        self.fstack.pack(expand=1, fill="both")
        self.flocals = Frame(top)
        self.flocals.pack(expand=1, fill="both")
        self.fglobals = Frame(top, height=1)
        self.fglobals.pack(expand=1, fill="both")
        #
        if self.vstack.get():
            self.show_stack()
        if self.vlocals.get():
            self.show_locals()
        if self.vglobals.get():
            self.show_globals()

    def interaction(self, message, frame, info=None):
        self.frame = frame
        self.status.configure(text=message)
        #
        if info:
            type, value, tb = info
            try:
                m1 = type.__name__
            except AttributeError:
                m1 = "%s" % str(type)
            if value is not None:
                try:
                    m1 = "%s: %s" % (m1, str(value))
                except:
                    pass
            bg = "yellow"
        else:
            m1 = ""
            tb = None
            bg = self.errorbg
        self.error.configure(text=m1, background=bg)
        #
        sv = self.stackviewer
        if sv:
            stack, i = self.idb.get_stack(self.frame, tb)
            sv.load_stack(stack, i)
        #
        self.show_variables(1)
        #
        if self.vsource.get():
            self.sync_source_line()
        #
        for b in self.buttons:
            b.configure(state="normal")
        #
        self.top.wakeup()
        self.root.mainloop()
        #
        for b in self.buttons:
            b.configure(state="disabled")
        self.status.configure(text="")
        self.error.configure(text="", background=self.errorbg)
        self.frame = None

    def sync_source_line(self):
        frame = self.frame
        if not frame:
            return
        filename, lineno = self.__frame2fileline(frame)
        if filename[:1] + filename[-1:] != "<>" and os.path.exists(filename):
            self.flist.gotofileline(filename, lineno)

    def __frame2fileline(self, frame):
        code = frame.f_code
        filename = code.co_filename
        lineno = frame.f_lineno
        return filename, lineno

    def cont(self):
        self.idb.set_continue()
        self.root.quit()

    def step(self):
        self.idb.set_step()
        self.root.quit()

    def next(self):
        self.idb.set_next(self.frame)
        self.root.quit()

    def ret(self):
        self.idb.set_return(self.frame)
        self.root.quit()

    def quit(self):
        self.idb.set_quit()
        self.root.quit()

    stackviewer = None

    def show_stack(self):
        if not self.stackviewer and self.vstack.get():
            self.stackviewer = sv = StackViewer(self.fstack, self.flist, self)
            if self.frame:
                stack, i = self.idb.get_stack(self.frame, None)
                sv.load_stack(stack, i)
        else:
            sv = self.stackviewer
            if sv and not self.vstack.get():
                self.stackviewer = None
                sv.close()
            self.fstack['height'] = 1

    def show_source(self):
        if self.vsource.get():
            self.sync_source_line()

    def show_frame(self, stackitem):
        self.frame = stackitem[0]  # lineno is stackitem[1]
        self.show_variables()

    localsviewer = None
    globalsviewer = None

    def show_locals(self):
        lv = self.localsviewer
        if self.vlocals.get():
            if not lv:
                self.localsviewer = NamespaceViewer(self.flocals, "Locals")
        else:
            if lv:
                self.localsviewer = None
                lv.close()
                self.flocals['height'] = 1
        self.show_variables()

    def show_globals(self):
        gv = self.globalsviewer
        if self.vglobals.get():
            if not gv:
                self.globalsviewer = NamespaceViewer(self.fglobals, "Globals")
        else:
            if gv:
                self.globalsviewer = None
                gv.close()
                self.fglobals['height'] = 1
        self.show_variables()

    def show_variables(self, force=0):
        lv = self.localsviewer
        gv = self.globalsviewer
        frame = self.frame
        if not frame:
            ldict = gdict = None
        else:
            ldict = frame.f_locals
            gdict = frame.f_globals
            if lv and gv and ldict is gdict:
                ldict = None
        if lv:
            lv.load_dict(ldict, force, self.pyshell.interp.rpcclt)
        if gv:
            gv.load_dict(gdict, force, self.pyshell.interp.rpcclt)

    def set_breakpoint_here(self, filename, lineno):
        self.idb.set_break(filename, lineno)

    def clear_breakpoint_here(self, filename, lineno):
        self.idb.clear_break(filename, lineno)

    def clear_file_breaks(self, filename):
        self.idb.clear_all_file_breaks(filename)

    def load_breakpoints(self):
        "Load PyShellEditorWindow breakpoints into subprocess debugger"
        for editwin in self.pyshell.flist.inversedict:
            filename = editwin.io.filename
            try:
                for lineno in editwin.breakpoints:
                    self.set_breakpoint_here(filename, lineno)
            except AttributeError:
                continue

class StackViewer(ScrolledList):

    def __init__(self, master, flist, gui):
        if macosxSupport.isAquaTk():
            # At least on with the stock AquaTk version on OSX 10.4 you'll
            # get an shaking GUI that eventually kills IDLE if the width
            # argument is specified.
            ScrolledList.__init__(self, master)
        else:
            ScrolledList.__init__(self, master, width=80)
        self.flist = flist
        self.gui = gui
        self.stack = []

    def load_stack(self, stack, index=None):
        self.stack = stack
        self.clear()
        for i in range(len(stack)):
            frame, lineno = stack[i]
            try:
                modname = frame.f_globals["__name__"]
            except:
                modname = "?"
            code = frame.f_code
            filename = code.co_filename
            funcname = code.co_name
            import linecache
            sourceline = linecache.getline(filename, lineno)
            sourceline = sourceline.strip()
            if funcname in ("?", "", None):
                item = "%s, line %d: %s" % (modname, lineno, sourceline)
            else:
                item = "%s.%s(), line %d: %s" % (modname, funcname,
                                                 lineno, sourceline)
            if i == index:
                item = "> " + item
            self.append(item)
        if index is not None:
            self.select(index)

    def popup_event(self, event):
        "override base method"
        if self.stack:
            return ScrolledList.popup_event(self, event)

    def fill_menu(self):
        "override base method"
        menu = self.menu
        menu.add_command(label="Go to source line",
                         command=self.goto_source_line)
        menu.add_command(label="Show stack frame",
                         command=self.show_stack_frame)

    def on_select(self, index):
        "override base method"
        if 0 <= index < len(self.stack):
            self.gui.show_frame(self.stack[index])

    def on_double(self, index):
        "override base method"
        self.show_source(index)

    def goto_source_line(self):
        index = self.listbox.index("active")
        self.show_source(index)

    def show_stack_frame(self):
        index = self.listbox.index("active")
        if 0 <= index < len(self.stack):
            self.gui.show_frame(self.stack[index])

    def show_source(self, index):
        if not (0 <= index < len(self.stack)):
            return
        frame, lineno = self.stack[index]
        code = frame.f_code
        filename = code.co_filename
        if os.path.isfile(filename):
            edit = self.flist.open(filename)
            if edit:
                edit.gotoline(lineno)


class NamespaceViewer:

    def __init__(self, master, title, dict=None):
        width = 0
        height = 40
        if dict:
            height = 20*len(dict) # XXX 20 == observed height of Entry widget
        self.master = master
        self.title = title
        import reprlib
        self.repr = reprlib.Repr()
        self.repr.maxstring = 60
        self.repr.maxother = 60
        self.frame = frame = Frame(master)
        self.frame.pack(expand=1, fill="both")
        self.label = Label(frame, text=title, borderwidth=2, relief="groove")
        self.label.pack(fill="x")
        self.vbar = vbar = Scrollbar(frame, name="vbar")
        vbar.pack(side="right", fill="y")
        self.canvas = canvas = Canvas(frame,
                                      height=min(300, max(40, height)),
                                      scrollregion=(0, 0, width, height))
        canvas.pack(side="left", fill="both", expand=1)
        vbar["command"] = canvas.yview
        canvas["yscrollcommand"] = vbar.set
        self.subframe = subframe = Frame(canvas)
        self.sfid = canvas.create_window(0, 0, window=subframe, anchor="nw")
        self.load_dict(dict)

    dict = -1

    def load_dict(self, dict, force=0, rpc_client=None):
        if dict is self.dict and not force:
            return
        subframe = self.subframe
        frame = self.frame
        for c in list(subframe.children.values()):
            c.destroy()
        self.dict = None
        if not dict:
            l = Label(subframe, text="None")
            l.grid(row=0, column=0)
        else:
            #names = sorted(dict)
            ###
            # Because of (temporary) limitations on the dict_keys type (not yet
            # public or pickleable), have the subprocess to send a list of
            # keys, not a dict_keys object.  sorted() will take a dict_keys
            # (no subprocess) or a list.
            #
            # There is also an obscure bug in sorted(dict) where the
            # interpreter gets into a loop requesting non-existing dict[0],
            # dict[1], dict[2], etc from the RemoteDebugger.DictProxy.
            ###
            keys_list = dict.keys()
            names = sorted(keys_list)
            ###
            row = 0
            for name in names:
                value = dict[name]
                svalue = self.repr.repr(value) # repr(value)
                # Strip extra quotes caused by calling repr on the (already)
                # repr'd value sent across the RPC interface:
                if rpc_client:
                    svalue = svalue[1:-1]
                l = Label(subframe, text=name)
                l.grid(row=row, column=0, sticky="nw")
                l = Entry(subframe, width=0, borderwidth=0)
                l.insert(0, svalue)
                l.grid(row=row, column=1, sticky="nw")
                row = row+1
        self.dict = dict
        # XXX Could we use a <Configure> callback for the following?
        subframe.update_idletasks() # Alas!
        width = subframe.winfo_reqwidth()
        height = subframe.winfo_reqheight()
        canvas = self.canvas
        self.canvas["scrollregion"] = (0, 0, width, height)
        if height > 300:
            canvas["height"] = 300
            frame.pack(expand=1)
        else:
            canvas["height"] = height
            frame.pack(expand=0)

    def close(self):
        self.frame.destroy()
                                     usr/lib/python3.4/idlelib/Delegator.py                                                              0100644 0000000 0000000 00000001231 12415221640 016250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        class Delegator:

    # The cache is only used to be able to change delegates!

    def __init__(self, delegate=None):
        self.delegate = delegate
        self.__cache = set()

    def __getattr__(self, name):
        attr = getattr(self.delegate, name) # May raise AttributeError
        setattr(self, name, attr)
        self.__cache.add(name)
        return attr

    def resetcache(self):
        for key in self.__cache:
            try:
                delattr(self, key)
            except AttributeError:
                pass
        self.__cache.clear()

    def setdelegate(self, delegate):
        self.resetcache()
        self.delegate = delegate
                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/EditorWindow.py                                                           0100644 0000000 0000000 00000202236 12415221640 016770  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import importlib
import importlib.abc
import importlib.util
import os
import platform
import re
import string
import sys
from tkinter import *
import tkinter.simpledialog as tkSimpleDialog
import tkinter.messagebox as tkMessageBox
import traceback
import webbrowser

from idlelib.MultiCall import MultiCallCreator
from idlelib import idlever
from idlelib import WindowList
from idlelib import SearchDialog
from idlelib import GrepDialog
from idlelib import ReplaceDialog
from idlelib import PyParse
from idlelib.configHandler import idleConf
from idlelib import aboutDialog, textView, configDialog
from idlelib import macosxSupport

# The default tab setting for a Text widget, in average-width characters.
TK_TABWIDTH_DEFAULT = 8

_py_version = ' (%s)' % platform.python_version()

def _sphinx_version():
    "Format sys.version_info to produce the Sphinx version string used to install the chm docs"
    major, minor, micro, level, serial = sys.version_info
    release = '%s%s' % (major, minor)
    release += '%s' % (micro,)
    if level == 'candidate':
        release += 'rc%s' % (serial,)
    elif level != 'final':
        release += '%s%s' % (level[0], serial)
    return release


class HelpDialog(object):

    def __init__(self):
        self.parent = None      # parent of help window
        self.dlg = None         # the help window iteself

    def display(self, parent, near=None):
        """ Display the help dialog.

            parent - parent widget for the help window

            near - a Toplevel widget (e.g. EditorWindow or PyShell)
                   to use as a reference for placing the help window
        """
        if self.dlg is None:
            self.show_dialog(parent)
        if near:
            self.nearwindow(near)

    def show_dialog(self, parent):
        self.parent = parent
        fn=os.path.join(os.path.abspath(os.path.dirname(__file__)),'help.txt')
        self.dlg = dlg = textView.view_file(parent,'Help',fn, modal=False)
        dlg.bind('<Destroy>', self.destroy, '+')

    def nearwindow(self, near):
        # Place the help dialog near the window specified by parent.
        # Note - this may not reposition the window in Metacity
        #  if "/apps/metacity/general/disable_workarounds" is enabled
        dlg = self.dlg
        geom = (near.winfo_rootx() + 10, near.winfo_rooty() + 10)
        dlg.withdraw()
        dlg.geometry("=+%d+%d" % geom)
        dlg.deiconify()
        dlg.lift()

    def destroy(self, ev=None):
        self.dlg = None
        self.parent = None

helpDialog = HelpDialog()  # singleton instance
def _help_dialog(parent):  # wrapper for htest
    helpDialog.show_dialog(parent)


class EditorWindow(object):
    from idlelib.Percolator import Percolator
    from idlelib.ColorDelegator import ColorDelegator
    from idlelib.UndoDelegator import UndoDelegator
    from idlelib.IOBinding import IOBinding, filesystemencoding, encoding
    from idlelib import Bindings
    from tkinter import Toplevel
    from idlelib.MultiStatusBar import MultiStatusBar

    help_url = None

    def __init__(self, flist=None, filename=None, key=None, root=None):
        if EditorWindow.help_url is None:
            dochome =  os.path.join(sys.base_prefix, 'Doc', 'index.html')
            if sys.platform.count('linux'):
                # look for html docs in a couple of standard places
                pyver = 'python-docs-' + '%s.%s.%s' % sys.version_info[:3]
                if os.path.isdir('/var/www/html/python/'):  # "python2" rpm
                    dochome = '/var/www/html/python/index.html'
                else:
                    basepath = '/usr/share/doc/'  # standard location
                    dochome = os.path.join(basepath, pyver,
                                           'Doc', 'index.html')
            elif sys.platform[:3] == 'win':
                chmfile = os.path.join(sys.base_prefix, 'Doc',
                                       'Python%s.chm' % _sphinx_version())
                if os.path.isfile(chmfile):
                    dochome = chmfile
            elif sys.platform == 'darwin':
                # documentation may be stored inside a python framework
                dochome = os.path.join(sys.base_prefix,
                        'Resources/English.lproj/Documentation/index.html')
            dochome = os.path.normpath(dochome)
            if os.path.isfile(dochome):
                EditorWindow.help_url = dochome
                if sys.platform == 'darwin':
                    # Safari requires real file:-URLs
                    EditorWindow.help_url = 'file://' + EditorWindow.help_url
            else:
                EditorWindow.help_url = "https://docs.python.org/%d.%d/" % sys.version_info[:2]
        currentTheme=idleConf.CurrentTheme()
        self.flist = flist
        root = root or flist.root
        self.root = root
        try:
            sys.ps1
        except AttributeError:
            sys.ps1 = '>>> '
        self.menubar = Menu(root)
        self.top = top = WindowList.ListedToplevel(root, menu=self.menubar)
        if flist:
            self.tkinter_vars = flist.vars
            #self.top.instance_dict makes flist.inversedict available to
            #configDialog.py so it can access all EditorWindow instances
            self.top.instance_dict = flist.inversedict
        else:
            self.tkinter_vars = {}  # keys: Tkinter event names
                                    # values: Tkinter variable instances
            self.top.instance_dict = {}
        self.recent_files_path = os.path.join(idleConf.GetUserCfgDir(),
                'recent-files.lst')
        self.text_frame = text_frame = Frame(top)
        self.vbar = vbar = Scrollbar(text_frame, name='vbar')
        self.width = idleConf.GetOption('main', 'EditorWindow',
                                        'width', type='int')
        text_options = {
                'name': 'text',
                'padx': 5,
                'wrap': 'none',
                'width': self.width,
                'height': idleConf.GetOption('main', 'EditorWindow',
                                             'height', type='int')}
        if TkVersion >= 8.5:
            # Starting with tk 8.5 we have to set the new tabstyle option
            # to 'wordprocessor' to achieve the same display of tabs as in
            # older tk versions.
            text_options['tabstyle'] = 'wordprocessor'
        self.text = text = MultiCallCreator(Text)(text_frame, **text_options)
        self.top.focused_widget = self.text

        self.createmenubar()
        self.apply_bindings()

        self.top.protocol("WM_DELETE_WINDOW", self.close)
        self.top.bind("<<close-window>>", self.close_event)
        if macosxSupport.isAquaTk():
            # Command-W on editorwindows doesn't work without this.
            text.bind('<<close-window>>', self.close_event)
            # Some OS X systems have only one mouse button,
            # so use control-click for pulldown menus there.
            #  (Note, AquaTk defines <2> as the right button if
            #   present and the Tk Text widget already binds <2>.)
            text.bind("<Control-Button-1>",self.right_menu_event)
        else:
            # Elsewhere, use right-click for pulldown menus.
            text.bind("<3>",self.right_menu_event)
        text.bind("<<cut>>", self.cut)
        text.bind("<<copy>>", self.copy)
        text.bind("<<paste>>", self.paste)
        text.bind("<<center-insert>>", self.center_insert_event)
        text.bind("<<help>>", self.help_dialog)
        text.bind("<<python-docs>>", self.python_docs)
        text.bind("<<about-idle>>", self.about_dialog)
        text.bind("<<open-config-dialog>>", self.config_dialog)
        text.bind("<<open-module>>", self.open_module)
        text.bind("<<do-nothing>>", lambda event: "break")
        text.bind("<<select-all>>", self.select_all)
        text.bind("<<remove-selection>>", self.remove_selection)
        text.bind("<<find>>", self.find_event)
        text.bind("<<find-again>>", self.find_again_event)
        text.bind("<<find-in-files>>", self.find_in_files_event)
        text.bind("<<find-selection>>", self.find_selection_event)
        text.bind("<<replace>>", self.replace_event)
        text.bind("<<goto-line>>", self.goto_line_event)
        text.bind("<<smart-backspace>>",self.smart_backspace_event)
        text.bind("<<newline-and-indent>>",self.newline_and_indent_event)
        text.bind("<<smart-indent>>",self.smart_indent_event)
        text.bind("<<indent-region>>",self.indent_region_event)
        text.bind("<<dedent-region>>",self.dedent_region_event)
        text.bind("<<comment-region>>",self.comment_region_event)
        text.bind("<<uncomment-region>>",self.uncomment_region_event)
        text.bind("<<tabify-region>>",self.tabify_region_event)
        text.bind("<<untabify-region>>",self.untabify_region_event)
        text.bind("<<toggle-tabs>>",self.toggle_tabs_event)
        text.bind("<<change-indentwidth>>",self.change_indentwidth_event)
        text.bind("<Left>", self.move_at_edge_if_selection(0))
        text.bind("<Right>", self.move_at_edge_if_selection(1))
        text.bind("<<del-word-left>>", self.del_word_left)
        text.bind("<<del-word-right>>", self.del_word_right)
        text.bind("<<beginning-of-line>>", self.home_callback)

        if flist:
            flist.inversedict[self] = key
            if key:
                flist.dict[key] = self
            text.bind("<<open-new-window>>", self.new_callback)
            text.bind("<<close-all-windows>>", self.flist.close_all_callback)
            text.bind("<<open-class-browser>>", self.open_class_browser)
            text.bind("<<open-path-browser>>", self.open_path_browser)
            text.bind("<<open-turtle-demo>>", self.open_turtle_demo)

        self.set_status_bar()
        vbar['command'] = text.yview
        vbar.pack(side=RIGHT, fill=Y)
        text['yscrollcommand'] = vbar.set
        fontWeight = 'normal'
        if idleConf.GetOption('main', 'EditorWindow', 'font-bold', type='bool'):
            fontWeight='bold'
        text.config(font=(idleConf.GetOption('main', 'EditorWindow', 'font'),
                          idleConf.GetOption('main', 'EditorWindow',
                                             'font-size', type='int'),
                          fontWeight))
        text_frame.pack(side=LEFT, fill=BOTH, expand=1)
        text.pack(side=TOP, fill=BOTH, expand=1)
        text.focus_set()

        # usetabs true  -> literal tab characters are used by indent and
        #                  dedent cmds, possibly mixed with spaces if
        #                  indentwidth is not a multiple of tabwidth,
        #                  which will cause Tabnanny to nag!
        #         false -> tab characters are converted to spaces by indent
        #                  and dedent cmds, and ditto TAB keystrokes
        # Although use-spaces=0 can be configured manually in config-main.def,
        # configuration of tabs v. spaces is not supported in the configuration
        # dialog.  IDLE promotes the preferred Python indentation: use spaces!
        usespaces = idleConf.GetOption('main', 'Indent',
                                       'use-spaces', type='bool')
        self.usetabs = not usespaces

        # tabwidth is the display width of a literal tab character.
        # CAUTION:  telling Tk to use anything other than its default
        # tab setting causes it to use an entirely different tabbing algorithm,
        # treating tab stops as fixed distances from the left margin.
        # Nobody expects this, so for now tabwidth should never be changed.
        self.tabwidth = 8    # must remain 8 until Tk is fixed.

        # indentwidth is the number of screen characters per indent level.
        # The recommended Python indentation is four spaces.
        self.indentwidth = self.tabwidth
        self.set_notabs_indentwidth()

        # If context_use_ps1 is true, parsing searches back for a ps1 line;
        # else searches for a popular (if, def, ...) Python stmt.
        self.context_use_ps1 = False

        # When searching backwards for a reliable place to begin parsing,
        # first start num_context_lines[0] lines back, then
        # num_context_lines[1] lines back if that didn't work, and so on.
        # The last value should be huge (larger than the # of lines in a
        # conceivable file).
        # Making the initial values larger slows things down more often.
        self.num_context_lines = 50, 500, 5000000
        self.per = per = self.Percolator(text)
        self.undo = undo = self.UndoDelegator()
        per.insertfilter(undo)
        text.undo_block_start = undo.undo_block_start
        text.undo_block_stop = undo.undo_block_stop
        undo.set_saved_change_hook(self.saved_change_hook)
        # IOBinding implements file I/O and printing functionality
        self.io = io = self.IOBinding(self)
        io.set_filename_change_hook(self.filename_change_hook)
        self.good_load = False
        self.set_indentation_params(False)
        self.color = None # initialized below in self.ResetColorizer
        if filename:
            if os.path.exists(filename) and not os.path.isdir(filename):
                if io.loadfile(filename):
                    self.good_load = True
                    is_py_src = self.ispythonsource(filename)
                    self.set_indentation_params(is_py_src)
            else:
                io.set_filename(filename)
                self.good_load = True

        self.ResetColorizer()
        self.saved_change_hook()
        self.update_recent_files_list()
        self.load_extensions()
        menu = self.menudict.get('windows')
        if menu:
            end = menu.index("end")
            if end is None:
                end = -1
            if end >= 0:
                menu.add_separator()
                end = end + 1
            self.wmenu_end = end
            WindowList.register_callback(self.postwindowsmenu)

        # Some abstractions so IDLE extensions are cross-IDE
        self.askyesno = tkMessageBox.askyesno
        self.askinteger = tkSimpleDialog.askinteger
        self.showerror = tkMessageBox.showerror

        self._highlight_workaround()  # Fix selection tags on Windows

    def _highlight_workaround(self):
        # On Windows, Tk removes painting of the selection
        # tags which is different behavior than on Linux and Mac.
        # See issue14146 for more information.
        if not sys.platform.startswith('win'):
            return

        text = self.text
        text.event_add("<<Highlight-FocusOut>>", "<FocusOut>")
        text.event_add("<<Highlight-FocusIn>>", "<FocusIn>")
        def highlight_fix(focus):
            sel_range = text.tag_ranges("sel")
            if sel_range:
                if focus == 'out':
                    HILITE_CONFIG = idleConf.GetHighlight(
                            idleConf.CurrentTheme(), 'hilite')
                    text.tag_config("sel_fix", HILITE_CONFIG)
                    text.tag_raise("sel_fix")
                    text.tag_add("sel_fix", *sel_range)
                elif focus == 'in':
                    text.tag_remove("sel_fix", "1.0", "end")

        text.bind("<<Highlight-FocusOut>>",
                lambda ev: highlight_fix("out"))
        text.bind("<<Highlight-FocusIn>>",
                lambda ev: highlight_fix("in"))


    def _filename_to_unicode(self, filename):
        """convert filename to unicode in order to display it in Tk"""
        if isinstance(filename, str) or not filename:
            return filename
        else:
            try:
                return filename.decode(self.filesystemencoding)
            except UnicodeDecodeError:
                # XXX
                try:
                    return filename.decode(self.encoding)
                except UnicodeDecodeError:
                    # byte-to-byte conversion
                    return filename.decode('iso8859-1')

    def new_callback(self, event):
        dirname, basename = self.io.defaultfilename()
        self.flist.new(dirname)
        return "break"

    def home_callback(self, event):
        if (event.state & 4) != 0 and event.keysym == "Home":
            # state&4==Control. If <Control-Home>, use the Tk binding.
            return
        if self.text.index("iomark") and \
           self.text.compare("iomark", "<=", "insert lineend") and \
           self.text.compare("insert linestart", "<=", "iomark"):
            # In Shell on input line, go to just after prompt
            insertpt = int(self.text.index("iomark").split(".")[1])
        else:
            line = self.text.get("insert linestart", "insert lineend")
            for insertpt in range(len(line)):
                if line[insertpt] not in (' ','\t'):
                    break
            else:
                insertpt=len(line)
        lineat = int(self.text.index("insert").split('.')[1])
        if insertpt == lineat:
            insertpt = 0
        dest = "insert linestart+"+str(insertpt)+"c"
        if (event.state&1) == 0:
            # shift was not pressed
            self.text.tag_remove("sel", "1.0", "end")
        else:
            if not self.text.index("sel.first"):
                # there was no previous selection
                self.text.mark_set("my_anchor", "insert")
            else:
                if self.text.compare(self.text.index("sel.first"), "<",
                                     self.text.index("insert")):
                    self.text.mark_set("my_anchor", "sel.first") # extend back
                else:
                    self.text.mark_set("my_anchor", "sel.last") # extend forward
            first = self.text.index(dest)
            last = self.text.index("my_anchor")
            if self.text.compare(first,">",last):
                first,last = last,first
            self.text.tag_remove("sel", "1.0", "end")
            self.text.tag_add("sel", first, last)
        self.text.mark_set("insert", dest)
        self.text.see("insert")
        return "break"

    def set_status_bar(self):
        self.status_bar = self.MultiStatusBar(self.top)
        if sys.platform == "darwin":
            # Insert some padding to avoid obscuring some of the statusbar
            # by the resize widget.
            self.status_bar.set_label('_padding1', '    ', side=RIGHT)
        self.status_bar.set_label('column', 'Col: ?', side=RIGHT)
        self.status_bar.set_label('line', 'Ln: ?', side=RIGHT)
        self.status_bar.pack(side=BOTTOM, fill=X)
        self.text.bind("<<set-line-and-column>>", self.set_line_and_column)
        self.text.event_add("<<set-line-and-column>>",
                            "<KeyRelease>", "<ButtonRelease>")
        self.text.after_idle(self.set_line_and_column)

    def set_line_and_column(self, event=None):
        line, column = self.text.index(INSERT).split('.')
        self.status_bar.set_label('column', 'Col: %s' % column)
        self.status_bar.set_label('line', 'Ln: %s' % line)

    menu_specs = [
        ("file", "_File"),
        ("edit", "_Edit"),
        ("format", "F_ormat"),
        ("run", "_Run"),
        ("options", "_Options"),
        ("windows", "_Windows"),
        ("help", "_Help"),
    ]

    if sys.platform == "darwin":
        menu_specs[-2] = ("windows", "_Window")


    def createmenubar(self):
        mbar = self.menubar
        self.menudict = menudict = {}
        for name, label in self.menu_specs:
            underline, label = prepstr(label)
            menudict[name] = menu = Menu(mbar, name=name)
            mbar.add_cascade(label=label, menu=menu, underline=underline)
        if macosxSupport.isCarbonTk():
            # Insert the application menu
            menudict['application'] = menu = Menu(mbar, name='apple')
            mbar.add_cascade(label='IDLE', menu=menu)
        self.fill_menus()
        self.recent_files_menu = Menu(self.menubar)
        self.menudict['file'].insert_cascade(3, label='Recent Files',
                                             underline=0,
                                             menu=self.recent_files_menu)
        self.base_helpmenu_length = self.menudict['help'].index(END)
        self.reset_help_menu_entries()

    def postwindowsmenu(self):
        # Only called when Windows menu exists
        menu = self.menudict['windows']
        end = menu.index("end")
        if end is None:
            end = -1
        if end > self.wmenu_end:
            menu.delete(self.wmenu_end+1, end)
        WindowList.add_windows_to_menu(menu)

    rmenu = None

    def right_menu_event(self, event):
        self.text.mark_set("insert", "@%d,%d" % (event.x, event.y))
        if not self.rmenu:
            self.make_rmenu()
        rmenu = self.rmenu
        self.event = event
        iswin = sys.platform[:3] == 'win'
        if iswin:
            self.text.config(cursor="arrow")

        for item in self.rmenu_specs:
            try:
                label, eventname, verify_state = item
            except ValueError: # see issue1207589
                continue

            if verify_state is None:
                continue
            state = getattr(self, verify_state)()
            rmenu.entryconfigure(label, state=state)


        rmenu.tk_popup(event.x_root, event.y_root)
        if iswin:
            self.text.config(cursor="ibeam")

    rmenu_specs = [
        # ("Label", "<<virtual-event>>", "statefuncname"), ...
        ("Close", "<<close-window>>", None), # Example
    ]

    def make_rmenu(self):
        rmenu = Menu(self.text, tearoff=0)
        for item in self.rmenu_specs:
            label, eventname = item[0], item[1]
            if label is not None:
                def command(text=self.text, eventname=eventname):
                    text.event_generate(eventname)
                rmenu.add_command(label=label, command=command)
            else:
                rmenu.add_separator()
        self.rmenu = rmenu

    def rmenu_check_cut(self):
        return self.rmenu_check_copy()

    def rmenu_check_copy(self):
        try:
            indx = self.text.index('sel.first')
        except TclError:
            return 'disabled'
        else:
            return 'normal' if indx else 'disabled'

    def rmenu_check_paste(self):
        try:
            self.text.tk.call('tk::GetSelection', self.text, 'CLIPBOARD')
        except TclError:
            return 'disabled'
        else:
            return 'normal'

    def about_dialog(self, event=None):
        aboutDialog.AboutDialog(self.top,'About IDLE')

    def config_dialog(self, event=None):
        configDialog.ConfigDialog(self.top,'Settings')

    def help_dialog(self, event=None):
        if self.root:
            parent = self.root
        else:
            parent = self.top
        helpDialog.display(parent, near=self.top)

    def python_docs(self, event=None):
        if sys.platform[:3] == 'win':
            try:
                os.startfile(self.help_url)
            except OSError as why:
                tkMessageBox.showerror(title='Document Start Failure',
                    message=str(why), parent=self.text)
        else:
            webbrowser.open(self.help_url)
        return "break"

    def cut(self,event):
        self.text.event_generate("<<Cut>>")
        return "break"

    def copy(self,event):
        if not self.text.tag_ranges("sel"):
            # There is no selection, so do nothing and maybe interrupt.
            return
        self.text.event_generate("<<Copy>>")
        return "break"

    def paste(self,event):
        self.text.event_generate("<<Paste>>")
        self.text.see("insert")
        return "break"

    def select_all(self, event=None):
        self.text.tag_add("sel", "1.0", "end-1c")
        self.text.mark_set("insert", "1.0")
        self.text.see("insert")
        return "break"

    def remove_selection(self, event=None):
        self.text.tag_remove("sel", "1.0", "end")
        self.text.see("insert")

    def move_at_edge_if_selection(self, edge_index):
        """Cursor move begins at start or end of selection

        When a left/right cursor key is pressed create and return to Tkinter a
        function which causes a cursor move from the associated edge of the
        selection.

        """
        self_text_index = self.text.index
        self_text_mark_set = self.text.mark_set
        edges_table = ("sel.first+1c", "sel.last-1c")
        def move_at_edge(event):
            if (event.state & 5) == 0: # no shift(==1) or control(==4) pressed
                try:
                    self_text_index("sel.first")
                    self_text_mark_set("insert", edges_table[edge_index])
                except TclError:
                    pass
        return move_at_edge

    def del_word_left(self, event):
        self.text.event_generate('<Meta-Delete>')
        return "break"

    def del_word_right(self, event):
        self.text.event_generate('<Meta-d>')
        return "break"

    def find_event(self, event):
        SearchDialog.find(self.text)
        return "break"

    def find_again_event(self, event):
        SearchDialog.find_again(self.text)
        return "break"

    def find_selection_event(self, event):
        SearchDialog.find_selection(self.text)
        return "break"

    def find_in_files_event(self, event):
        GrepDialog.grep(self.text, self.io, self.flist)
        return "break"

    def replace_event(self, event):
        ReplaceDialog.replace(self.text)
        return "break"

    def goto_line_event(self, event):
        text = self.text
        lineno = tkSimpleDialog.askinteger("Goto",
                "Go to line number:",parent=text)
        if lineno is None:
            return "break"
        if lineno <= 0:
            text.bell()
            return "break"
        text.mark_set("insert", "%d.0" % lineno)
        text.see("insert")

    def open_module(self, event=None):
        # XXX Shouldn't this be in IOBinding?
        try:
            name = self.text.get("sel.first", "sel.last")
        except TclError:
            name = ""
        else:
            name = name.strip()
        name = tkSimpleDialog.askstring("Module",
                 "Enter the name of a Python module\n"
                 "to search on sys.path and open:",
                 parent=self.text, initialvalue=name)
        if name:
            name = name.strip()
        if not name:
            return
        # XXX Ought to insert current file's directory in front of path
        try:
            spec = importlib.util.find_spec(name)
        except (ValueError, ImportError) as msg:
            tkMessageBox.showerror("Import error", str(msg), parent=self.text)
            return
        if spec is None:
            tkMessageBox.showerror("Import error", "module not found",
                                   parent=self.text)
            return
        if not isinstance(spec.loader, importlib.abc.SourceLoader):
            tkMessageBox.showerror("Import error", "not a source-based module",
                                   parent=self.text)
            return
        try:
            file_path = spec.loader.get_filename(name)
        except AttributeError:
            tkMessageBox.showerror("Import error",
                                   "loader does not support get_filename",
                                   parent=self.text)
            return
        if self.flist:
            self.flist.open(file_path)
        else:
            self.io.loadfile(file_path)

    def open_class_browser(self, event=None):
        filename = self.io.filename
        if not filename:
            tkMessageBox.showerror(
                "No filename",
                "This buffer has no associated filename",
                master=self.text)
            self.text.focus_set()
            return None
        head, tail = os.path.split(filename)
        base, ext = os.path.splitext(tail)
        from idlelib import ClassBrowser
        ClassBrowser.ClassBrowser(self.flist, base, [head])

    def open_path_browser(self, event=None):
        from idlelib import PathBrowser
        PathBrowser.PathBrowser(self.flist)

    def open_turtle_demo(self, event = None):
        import subprocess

        cmd = [sys.executable,
               '-c',
               'from turtledemo.__main__ import main; main()']
        p = subprocess.Popen(cmd, shell=False)

    def gotoline(self, lineno):
        if lineno is not None and lineno > 0:
            self.text.mark_set("insert", "%d.0" % lineno)
            self.text.tag_remove("sel", "1.0", "end")
            self.text.tag_add("sel", "insert", "insert +1l")
            self.center()

    def ispythonsource(self, filename):
        if not filename or os.path.isdir(filename):
            return True
        base, ext = os.path.splitext(os.path.basename(filename))
        if os.path.normcase(ext) in (".py", ".pyw"):
            return True
        line = self.text.get('1.0', '1.0 lineend')
        return line.startswith('#!') and 'python' in line

    def close_hook(self):
        if self.flist:
            self.flist.unregister_maybe_terminate(self)
            self.flist = None

    def set_close_hook(self, close_hook):
        self.close_hook = close_hook

    def filename_change_hook(self):
        if self.flist:
            self.flist.filename_changed_edit(self)
        self.saved_change_hook()
        self.top.update_windowlist_registry(self)
        self.ResetColorizer()

    def _addcolorizer(self):
        if self.color:
            return
        if self.ispythonsource(self.io.filename):
            self.color = self.ColorDelegator()
        # can add more colorizers here...
        if self.color:
            self.per.removefilter(self.undo)
            self.per.insertfilter(self.color)
            self.per.insertfilter(self.undo)

    def _rmcolorizer(self):
        if not self.color:
            return
        self.color.removecolors()
        self.per.removefilter(self.color)
        self.color = None

    def ResetColorizer(self):
        "Update the colour theme"
        # Called from self.filename_change_hook and from configDialog.py
        self._rmcolorizer()
        self._addcolorizer()
        theme = idleConf.GetOption('main','Theme','name')
        normal_colors = idleConf.GetHighlight(theme, 'normal')
        cursor_color = idleConf.GetHighlight(theme, 'cursor', fgBg='fg')
        select_colors = idleConf.GetHighlight(theme, 'hilite')
        self.text.config(
            foreground=normal_colors['foreground'],
            background=normal_colors['background'],
            insertbackground=cursor_color,
            selectforeground=select_colors['foreground'],
            selectbackground=select_colors['background'],
            )

    IDENTCHARS = string.ascii_letters + string.digits + "_"

    def colorize_syntax_error(self, text, pos):
        text.tag_add("ERROR", pos)
        char = text.get(pos)
        if char and char in self.IDENTCHARS:
            text.tag_add("ERROR", pos + " wordstart", pos)
        if '\n' == text.get(pos):   # error at line end
            text.mark_set("insert", pos)
        else:
            text.mark_set("insert", pos + "+1c")
        text.see(pos)

    def ResetFont(self):
        "Update the text widgets' font if it is changed"
        # Called from configDialog.py
        fontWeight='normal'
        if idleConf.GetOption('main','EditorWindow','font-bold',type='bool'):
            fontWeight='bold'
        self.text.config(font=(idleConf.GetOption('main','EditorWindow','font'),
                idleConf.GetOption('main','EditorWindow','font-size',
                                   type='int'),
                fontWeight))

    def RemoveKeybindings(self):
        "Remove the keybindings before they are changed."
        # Called from configDialog.py
        self.Bindings.default_keydefs = keydefs = idleConf.GetCurrentKeySet()
        for event, keylist in keydefs.items():
            self.text.event_delete(event, *keylist)
        for extensionName in self.get_standard_extension_names():
            xkeydefs = idleConf.GetExtensionBindings(extensionName)
            if xkeydefs:
                for event, keylist in xkeydefs.items():
                    self.text.event_delete(event, *keylist)

    def ApplyKeybindings(self):
        "Update the keybindings after they are changed"
        # Called from configDialog.py
        self.Bindings.default_keydefs = keydefs = idleConf.GetCurrentKeySet()
        self.apply_bindings()
        for extensionName in self.get_standard_extension_names():
            xkeydefs = idleConf.GetExtensionBindings(extensionName)
            if xkeydefs:
                self.apply_bindings(xkeydefs)
        #update menu accelerators
        menuEventDict = {}
        for menu in self.Bindings.menudefs:
            menuEventDict[menu[0]] = {}
            for item in menu[1]:
                if item:
                    menuEventDict[menu[0]][prepstr(item[0])[1]] = item[1]
        for menubarItem in self.menudict:
            menu = self.menudict[menubarItem]
            end = menu.index(END)
            if end is None:
                # Skip empty menus
                continue
            end += 1
            for index in range(0, end):
                if menu.type(index) == 'command':
                    accel = menu.entrycget(index, 'accelerator')
                    if accel:
                        itemName = menu.entrycget(index, 'label')
                        event = ''
                        if menubarItem in menuEventDict:
                            if itemName in menuEventDict[menubarItem]:
                                event = menuEventDict[menubarItem][itemName]
                        if event:
                            accel = get_accelerator(keydefs, event)
                            menu.entryconfig(index, accelerator=accel)

    def set_notabs_indentwidth(self):
        "Update the indentwidth if changed and not using tabs in this window"
        # Called from configDialog.py
        if not self.usetabs:
            self.indentwidth = idleConf.GetOption('main', 'Indent','num-spaces',
                                                  type='int')

    def reset_help_menu_entries(self):
        "Update the additional help entries on the Help menu"
        help_list = idleConf.GetAllExtraHelpSourcesList()
        helpmenu = self.menudict['help']
        # first delete the extra help entries, if any
        helpmenu_length = helpmenu.index(END)
        if helpmenu_length > self.base_helpmenu_length:
            helpmenu.delete((self.base_helpmenu_length + 1), helpmenu_length)
        # then rebuild them
        if help_list:
            helpmenu.add_separator()
            for entry in help_list:
                cmd = self.__extra_help_callback(entry[1])
                helpmenu.add_command(label=entry[0], command=cmd)
        # and update the menu dictionary
        self.menudict['help'] = helpmenu

    def __extra_help_callback(self, helpfile):
        "Create a callback with the helpfile value frozen at definition time"
        def display_extra_help(helpfile=helpfile):
            if not helpfile.startswith(('www', 'http')):
                helpfile = os.path.normpath(helpfile)
            if sys.platform[:3] == 'win':
                try:
                    os.startfile(helpfile)
                except OSError as why:
                    tkMessageBox.showerror(title='Document Start Failure',
                        message=str(why), parent=self.text)
            else:
                webbrowser.open(helpfile)
        return display_extra_help

    def update_recent_files_list(self, new_file=None):
        "Load and update the recent files list and menus"
        rf_list = []
        if os.path.exists(self.recent_files_path):
            with open(self.recent_files_path, 'r',
                      encoding='utf_8', errors='replace') as rf_list_file:
                rf_list = rf_list_file.readlines()
        if new_file:
            new_file = os.path.abspath(new_file) + '\n'
            if new_file in rf_list:
                rf_list.remove(new_file)  # move to top
            rf_list.insert(0, new_file)
        # clean and save the recent files list
        bad_paths = []
        for path in rf_list:
            if '\0' in path or not os.path.exists(path[0:-1]):
                bad_paths.append(path)
        rf_list = [path for path in rf_list if path not in bad_paths]
        ulchars = "1234567890ABCDEFGHIJK"
        rf_list = rf_list[0:len(ulchars)]
        try:
            with open(self.recent_files_path, 'w',
                        encoding='utf_8', errors='replace') as rf_file:
                rf_file.writelines(rf_list)
        except OSError as err:
            if not getattr(self.root, "recentfilelist_error_displayed", False):
                self.root.recentfilelist_error_displayed = True
                tkMessageBox.showerror(title='IDLE Error',
                    message='Unable to update Recent Files list:\n%s'
                        % str(err),
                    parent=self.text)
        # for each edit window instance, construct the recent files menu
        for instance in self.top.instance_dict:
            menu = instance.recent_files_menu
            menu.delete(0, END)  # clear, and rebuild:
            for i, file_name in enumerate(rf_list):
                file_name = file_name.rstrip()  # zap \n
                # make unicode string to display non-ASCII chars correctly
                ufile_name = self._filename_to_unicode(file_name)
                callback = instance.__recent_file_callback(file_name)
                menu.add_command(label=ulchars[i] + " " + ufile_name,
                                 command=callback,
                                 underline=0)

    def __recent_file_callback(self, file_name):
        def open_recent_file(fn_closure=file_name):
            self.io.open(editFile=fn_closure)
        return open_recent_file

    def saved_change_hook(self):
        short = self.short_title()
        long = self.long_title()
        if short and long:
            title = short + " - " + long + _py_version
        elif short:
            title = short
        elif long:
            title = long
        else:
            title = "Untitled"
        icon = short or long or title
        if not self.get_saved():
            title = "*%s*" % title
            icon = "*%s" % icon
        self.top.wm_title(title)
        self.top.wm_iconname(icon)

    def get_saved(self):
        return self.undo.get_saved()

    def set_saved(self, flag):
        self.undo.set_saved(flag)

    def reset_undo(self):
        self.undo.reset_undo()

    def short_title(self):
        filename = self.io.filename
        if filename:
            filename = os.path.basename(filename)
        else:
            filename = "Untitled"
        # return unicode string to display non-ASCII chars correctly
        return self._filename_to_unicode(filename)

    def long_title(self):
        # return unicode string to display non-ASCII chars correctly
        return self._filename_to_unicode(self.io.filename or "")

    def center_insert_event(self, event):
        self.center()

    def center(self, mark="insert"):
        text = self.text
        top, bot = self.getwindowlines()
        lineno = self.getlineno(mark)
        height = bot - top
        newtop = max(1, lineno - height//2)
        text.yview(float(newtop))

    def getwindowlines(self):
        text = self.text
        top = self.getlineno("@0,0")
        bot = self.getlineno("@0,65535")
        if top == bot and text.winfo_height() == 1:
            # Geometry manager hasn't run yet
            height = int(text['height'])
            bot = top + height - 1
        return top, bot

    def getlineno(self, mark="insert"):
        text = self.text
        return int(float(text.index(mark)))

    def get_geometry(self):
        "Return (width, height, x, y)"
        geom = self.top.wm_geometry()
        m = re.match(r"(\d+)x(\d+)\+(-?\d+)\+(-?\d+)", geom)
        return list(map(int, m.groups()))

    def close_event(self, event):
        self.close()

    def maybesave(self):
        if self.io:
            if not self.get_saved():
                if self.top.state()!='normal':
                    self.top.deiconify()
                self.top.lower()
                self.top.lift()
            return self.io.maybesave()

    def close(self):
        reply = self.maybesave()
        if str(reply) != "cancel":
            self._close()
        return reply

    def _close(self):
        if self.io.filename:
            self.update_recent_files_list(new_file=self.io.filename)
        WindowList.unregister_callback(self.postwindowsmenu)
        self.unload_extensions()
        self.io.close()
        self.io = None
        self.undo = None
        if self.color:
            self.color.close(False)
            self.color = None
        self.text = None
        self.tkinter_vars = None
        self.per.close()
        self.per = None
        self.top.destroy()
        if self.close_hook:
            # unless override: unregister from flist, terminate if last window
            self.close_hook()

    def load_extensions(self):
        self.extensions = {}
        self.load_standard_extensions()

    def unload_extensions(self):
        for ins in list(self.extensions.values()):
            if hasattr(ins, "close"):
                ins.close()
        self.extensions = {}

    def load_standard_extensions(self):
        for name in self.get_standard_extension_names():
            try:
                self.load_extension(name)
            except:
                print("Failed to load extension", repr(name))
                traceback.print_exc()

    def get_standard_extension_names(self):
        return idleConf.GetExtensions(editor_only=True)

    def load_extension(self, name):
        try:
            try:
                mod = importlib.import_module('.' + name, package=__package__)
            except (ImportError, TypeError):
                mod = importlib.import_module(name)
        except ImportError:
            print("\nFailed to import extension: ", name)
            raise
        cls = getattr(mod, name)
        keydefs = idleConf.GetExtensionBindings(name)
        if hasattr(cls, "menudefs"):
            self.fill_menus(cls.menudefs, keydefs)
        ins = cls(self)
        self.extensions[name] = ins
        if keydefs:
            self.apply_bindings(keydefs)
            for vevent in keydefs:
                methodname = vevent.replace("-", "_")
                while methodname[:1] == '<':
                    methodname = methodname[1:]
                while methodname[-1:] == '>':
                    methodname = methodname[:-1]
                methodname = methodname + "_event"
                if hasattr(ins, methodname):
                    self.text.bind(vevent, getattr(ins, methodname))

    def apply_bindings(self, keydefs=None):
        if keydefs is None:
            keydefs = self.Bindings.default_keydefs
        text = self.text
        text.keydefs = keydefs
        for event, keylist in keydefs.items():
            if keylist:
                text.event_add(event, *keylist)

    def fill_menus(self, menudefs=None, keydefs=None):
        """Add appropriate entries to the menus and submenus

        Menus that are absent or None in self.menudict are ignored.
        """
        if menudefs is None:
            menudefs = self.Bindings.menudefs
        if keydefs is None:
            keydefs = self.Bindings.default_keydefs
        menudict = self.menudict
        text = self.text
        for mname, entrylist in menudefs:
            menu = menudict.get(mname)
            if not menu:
                continue
            for entry in entrylist:
                if not entry:
                    menu.add_separator()
                else:
                    label, eventname = entry
                    checkbutton = (label[:1] == '!')
                    if checkbutton:
                        label = label[1:]
                    underline, label = prepstr(label)
                    accelerator = get_accelerator(keydefs, eventname)
                    def command(text=text, eventname=eventname):
                        text.event_generate(eventname)
                    if checkbutton:
                        var = self.get_var_obj(eventname, BooleanVar)
                        menu.add_checkbutton(label=label, underline=underline,
                            command=command, accelerator=accelerator,
                            variable=var)
                    else:
                        menu.add_command(label=label, underline=underline,
                                         command=command,
                                         accelerator=accelerator)

    def getvar(self, name):
        var = self.get_var_obj(name)
        if var:
            value = var.get()
            return value
        else:
            raise NameError(name)

    def setvar(self, name, value, vartype=None):
        var = self.get_var_obj(name, vartype)
        if var:
            var.set(value)
        else:
            raise NameError(name)

    def get_var_obj(self, name, vartype=None):
        var = self.tkinter_vars.get(name)
        if not var and vartype:
            # create a Tkinter variable object with self.text as master:
            self.tkinter_vars[name] = var = vartype(self.text)
        return var

    # Tk implementations of "virtual text methods" -- each platform
    # reusing IDLE's support code needs to define these for its GUI's
    # flavor of widget.

    # Is character at text_index in a Python string?  Return 0 for
    # "guaranteed no", true for anything else.  This info is expensive
    # to compute ab initio, but is probably already known by the
    # platform's colorizer.

    def is_char_in_string(self, text_index):
        if self.color:
            # Return true iff colorizer hasn't (re)gotten this far
            # yet, or the character is tagged as being in a string
            return self.text.tag_prevrange("TODO", text_index) or \
                   "STRING" in self.text.tag_names(text_index)
        else:
            # The colorizer is missing: assume the worst
            return 1

    # If a selection is defined in the text widget, return (start,
    # end) as Tkinter text indices, otherwise return (None, None)
    def get_selection_indices(self):
        try:
            first = self.text.index("sel.first")
            last = self.text.index("sel.last")
            return first, last
        except TclError:
            return None, None

    # Return the text widget's current view of what a tab stop means
    # (equivalent width in spaces).

    def get_tk_tabwidth(self):
        current = self.text['tabs'] or TK_TABWIDTH_DEFAULT
        return int(current)

    # Set the text widget's current view of what a tab stop means.

    def set_tk_tabwidth(self, newtabwidth):
        text = self.text
        if self.get_tk_tabwidth() != newtabwidth:
            # Set text widget tab width
            pixels = text.tk.call("font", "measure", text["font"],
                                  "-displayof", text.master,
                                  "n" * newtabwidth)
            text.configure(tabs=pixels)

### begin autoindent code ###  (configuration was moved to beginning of class)

    def set_indentation_params(self, is_py_src, guess=True):
        if is_py_src and guess:
            i = self.guess_indent()
            if 2 <= i <= 8:
                self.indentwidth = i
            if self.indentwidth != self.tabwidth:
                self.usetabs = False
        self.set_tk_tabwidth(self.tabwidth)

    def smart_backspace_event(self, event):
        text = self.text
        first, last = self.get_selection_indices()
        if first and last:
            text.delete(first, last)
            text.mark_set("insert", first)
            return "break"
        # Delete whitespace left, until hitting a real char or closest
        # preceding virtual tab stop.
        chars = text.get("insert linestart", "insert")
        if chars == '':
            if text.compare("insert", ">", "1.0"):
                # easy: delete preceding newline
                text.delete("insert-1c")
            else:
                text.bell()     # at start of buffer
            return "break"
        if  chars[-1] not in " \t":
            # easy: delete preceding real char
            text.delete("insert-1c")
            return "break"
        # Ick.  It may require *inserting* spaces if we back up over a
        # tab character!  This is written to be clear, not fast.
        tabwidth = self.tabwidth
        have = len(chars.expandtabs(tabwidth))
        assert have > 0
        want = ((have - 1) // self.indentwidth) * self.indentwidth
        # Debug prompt is multilined....
        if self.context_use_ps1:
            last_line_of_prompt = sys.ps1.split('\n')[-1]
        else:
            last_line_of_prompt = ''
        ncharsdeleted = 0
        while 1:
            if chars == last_line_of_prompt:
                break
            chars = chars[:-1]
            ncharsdeleted = ncharsdeleted + 1
            have = len(chars.expandtabs(tabwidth))
            if have <= want or chars[-1] not in " \t":
                break
        text.undo_block_start()
        text.delete("insert-%dc" % ncharsdeleted, "insert")
        if have < want:
            text.insert("insert", ' ' * (want - have))
        text.undo_block_stop()
        return "break"

    def smart_indent_event(self, event):
        # if intraline selection:
        #     delete it
        # elif multiline selection:
        #     do indent-region
        # else:
        #     indent one level
        text = self.text
        first, last = self.get_selection_indices()
        text.undo_block_start()
        try:
            if first and last:
                if index2line(first) != index2line(last):
                    return self.indent_region_event(event)
                text.delete(first, last)
                text.mark_set("insert", first)
            prefix = text.get("insert linestart", "insert")
            raw, effective = classifyws(prefix, self.tabwidth)
            if raw == len(prefix):
                # only whitespace to the left
                self.reindent_to(effective + self.indentwidth)
            else:
                # tab to the next 'stop' within or to right of line's text:
                if self.usetabs:
                    pad = '\t'
                else:
                    effective = len(prefix.expandtabs(self.tabwidth))
                    n = self.indentwidth
                    pad = ' ' * (n - effective % n)
                text.insert("insert", pad)
            text.see("insert")
            return "break"
        finally:
            text.undo_block_stop()

    def newline_and_indent_event(self, event):
        text = self.text
        first, last = self.get_selection_indices()
        text.undo_block_start()
        try:
            if first and last:
                text.delete(first, last)
                text.mark_set("insert", first)
            line = text.get("insert linestart", "insert")
            i, n = 0, len(line)
            while i < n and line[i] in " \t":
                i = i+1
            if i == n:
                # the cursor is in or at leading indentation in a continuation
                # line; just inject an empty line at the start
                text.insert("insert linestart", '\n')
                return "break"
            indent = line[:i]
            # strip whitespace before insert point unless it's in the prompt
            i = 0
            last_line_of_prompt = sys.ps1.split('\n')[-1]
            while line and line[-1] in " \t" and line != last_line_of_prompt:
                line = line[:-1]
                i = i+1
            if i:
                text.delete("insert - %d chars" % i, "insert")
            # strip whitespace after insert point
            while text.get("insert") in " \t":
                text.delete("insert")
            # start new line
            text.insert("insert", '\n')

            # adjust indentation for continuations and block
            # open/close first need to find the last stmt
            lno = index2line(text.index('insert'))
            y = PyParse.Parser(self.indentwidth, self.tabwidth)
            if not self.context_use_ps1:
                for context in self.num_context_lines:
                    startat = max(lno - context, 1)
                    startatindex = repr(startat) + ".0"
                    rawtext = text.get(startatindex, "insert")
                    y.set_str(rawtext)
                    bod = y.find_good_parse_start(
                              self.context_use_ps1,
                              self._build_char_in_string_func(startatindex))
                    if bod is not None or startat == 1:
                        break
                y.set_lo(bod or 0)
            else:
                r = text.tag_prevrange("console", "insert")
                if r:
                    startatindex = r[1]
                else:
                    startatindex = "1.0"
                rawtext = text.get(startatindex, "insert")
                y.set_str(rawtext)
                y.set_lo(0)

            c = y.get_continuation_type()
            if c != PyParse.C_NONE:
                # The current stmt hasn't ended yet.
                if c == PyParse.C_STRING_FIRST_LINE:
                    # after the first line of a string; do not indent at all
                    pass
                elif c == PyParse.C_STRING_NEXT_LINES:
                    # inside a string which started before this line;
                    # just mimic the current indent
                    text.insert("insert", indent)
                elif c == PyParse.C_BRACKET:
                    # line up with the first (if any) element of the
                    # last open bracket structure; else indent one
                    # level beyond the indent of the line with the
                    # last open bracket
                    self.reindent_to(y.compute_bracket_indent())
                elif c == PyParse.C_BACKSLASH:
                    # if more than one line in this stmt already, just
                    # mimic the current indent; else if initial line
                    # has a start on an assignment stmt, indent to
                    # beyond leftmost =; else to beyond first chunk of
                    # non-whitespace on initial line
                    if y.get_num_lines_in_stmt() > 1:
                        text.insert("insert", indent)
                    else:
                        self.reindent_to(y.compute_backslash_indent())
                else:
                    assert 0, "bogus continuation type %r" % (c,)
                return "break"

            # This line starts a brand new stmt; indent relative to
            # indentation of initial line of closest preceding
            # interesting stmt.
            indent = y.get_base_indent_string()
            text.insert("insert", indent)
            if y.is_block_opener():
                self.smart_indent_event(event)
            elif indent and y.is_block_closer():
                self.smart_backspace_event(event)
            return "break"
        finally:
            text.see("insert")
            text.undo_block_stop()

    # Our editwin provides a is_char_in_string function that works
    # with a Tk text index, but PyParse only knows about offsets into
    # a string. This builds a function for PyParse that accepts an
    # offset.

    def _build_char_in_string_func(self, startindex):
        def inner(offset, _startindex=startindex,
                  _icis=self.is_char_in_string):
            return _icis(_startindex + "+%dc" % offset)
        return inner

    def indent_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, self.tabwidth)
                effective = effective + self.indentwidth
                lines[pos] = self._make_blanks(effective) + line[raw:]
        self.set_region(head, tail, chars, lines)
        return "break"

    def dedent_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, self.tabwidth)
                effective = max(effective - self.indentwidth, 0)
                lines[pos] = self._make_blanks(effective) + line[raw:]
        self.set_region(head, tail, chars, lines)
        return "break"

    def comment_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines) - 1):
            line = lines[pos]
            lines[pos] = '##' + line
        self.set_region(head, tail, chars, lines)

    def uncomment_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        for pos in range(len(lines)):
            line = lines[pos]
            if not line:
                continue
            if line[:2] == '##':
                line = line[2:]
            elif line[:1] == '#':
                line = line[1:]
            lines[pos] = line
        self.set_region(head, tail, chars, lines)

    def tabify_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        tabwidth = self._asktabwidth()
        if tabwidth is None: return
        for pos in range(len(lines)):
            line = lines[pos]
            if line:
                raw, effective = classifyws(line, tabwidth)
                ntabs, nspaces = divmod(effective, tabwidth)
                lines[pos] = '\t' * ntabs + ' ' * nspaces + line[raw:]
        self.set_region(head, tail, chars, lines)

    def untabify_region_event(self, event):
        head, tail, chars, lines = self.get_region()
        tabwidth = self._asktabwidth()
        if tabwidth is None: return
        for pos in range(len(lines)):
            lines[pos] = lines[pos].expandtabs(tabwidth)
        self.set_region(head, tail, chars, lines)

    def toggle_tabs_event(self, event):
        if self.askyesno(
              "Toggle tabs",
              "Turn tabs " + ("on", "off")[self.usetabs] +
              "?\nIndent width " +
              ("will be", "remains at")[self.usetabs] + " 8." +
              "\n Note: a tab is always 8 columns",
              parent=self.text):
            self.usetabs = not self.usetabs
            # Try to prevent inconsistent indentation.
            # User must change indent width manually after using tabs.
            self.indentwidth = 8
        return "break"

    # XXX this isn't bound to anything -- see tabwidth comments
##     def change_tabwidth_event(self, event):
##         new = self._asktabwidth()
##         if new != self.tabwidth:
##             self.tabwidth = new
##             self.set_indentation_params(0, guess=0)
##         return "break"

    def change_indentwidth_event(self, event):
        new = self.askinteger(
                  "Indent width",
                  "New indent width (2-16)\n(Always use 8 when using tabs)",
                  parent=self.text,
                  initialvalue=self.indentwidth,
                  minvalue=2,
                  maxvalue=16)
        if new and new != self.indentwidth and not self.usetabs:
            self.indentwidth = new
        return "break"

    def get_region(self):
        text = self.text
        first, last = self.get_selection_indices()
        if first and last:
            head = text.index(first + " linestart")
            tail = text.index(last + "-1c lineend +1c")
        else:
            head = text.index("insert linestart")
            tail = text.index("insert lineend +1c")
        chars = text.get(head, tail)
        lines = chars.split("\n")
        return head, tail, chars, lines

    def set_region(self, head, tail, chars, lines):
        text = self.text
        newchars = "\n".join(lines)
        if newchars == chars:
            text.bell()
            return
        text.tag_remove("sel", "1.0", "end")
        text.mark_set("insert", head)
        text.undo_block_start()
        text.delete(head, tail)
        text.insert(head, newchars)
        text.undo_block_stop()
        text.tag_add("sel", head, "insert")

    # Make string that displays as n leading blanks.

    def _make_blanks(self, n):
        if self.usetabs:
            ntabs, nspaces = divmod(n, self.tabwidth)
            return '\t' * ntabs + ' ' * nspaces
        else:
            return ' ' * n

    # Delete from beginning of line to insert point, then reinsert
    # column logical (meaning use tabs if appropriate) spaces.

    def reindent_to(self, column):
        text = self.text
        text.undo_block_start()
        if text.compare("insert linestart", "!=", "insert"):
            text.delete("insert linestart", "insert")
        if column:
            text.insert("insert", self._make_blanks(column))
        text.undo_block_stop()

    def _asktabwidth(self):
        return self.askinteger(
            "Tab width",
            "Columns per tab? (2-16)",
            parent=self.text,
            initialvalue=self.indentwidth,
            minvalue=2,
            maxvalue=16)

    # Guess indentwidth from text content.
    # Return guessed indentwidth.  This should not be believed unless
    # it's in a reasonable range (e.g., it will be 0 if no indented
    # blocks are found).

    def guess_indent(self):
        opener, indented = IndentSearcher(self.text, self.tabwidth).run()
        if opener and indented:
            raw, indentsmall = classifyws(opener, self.tabwidth)
            raw, indentlarge = classifyws(indented, self.tabwidth)
        else:
            indentsmall = indentlarge = 0
        return indentlarge - indentsmall

# "line.col" -> line, as an int
def index2line(index):
    return int(float(index))

# Look at the leading whitespace in s.
# Return pair (# of leading ws characters,
#              effective # of leading blanks after expanding
#              tabs to width tabwidth)

def classifyws(s, tabwidth):
    raw = effective = 0
    for ch in s:
        if ch == ' ':
            raw = raw + 1
            effective = effective + 1
        elif ch == '\t':
            raw = raw + 1
            effective = (effective // tabwidth + 1) * tabwidth
        else:
            break
    return raw, effective

import tokenize
_tokenize = tokenize
del tokenize

class IndentSearcher(object):

    # .run() chews over the Text widget, looking for a block opener
    # and the stmt following it.  Returns a pair,
    #     (line containing block opener, line containing stmt)
    # Either or both may be None.

    def __init__(self, text, tabwidth):
        self.text = text
        self.tabwidth = tabwidth
        self.i = self.finished = 0
        self.blkopenline = self.indentedline = None

    def readline(self):
        if self.finished:
            return ""
        i = self.i = self.i + 1
        mark = repr(i) + ".0"
        if self.text.compare(mark, ">=", "end"):
            return ""
        return self.text.get(mark, mark + " lineend+1c")

    def tokeneater(self, type, token, start, end, line,
                   INDENT=_tokenize.INDENT,
                   NAME=_tokenize.NAME,
                   OPENERS=('class', 'def', 'for', 'if', 'try', 'while')):
        if self.finished:
            pass
        elif type == NAME and token in OPENERS:
            self.blkopenline = line
        elif type == INDENT and self.blkopenline:
            self.indentedline = line
            self.finished = 1

    def run(self):
        save_tabsize = _tokenize.tabsize
        _tokenize.tabsize = self.tabwidth
        try:
            try:
                tokens = _tokenize.generate_tokens(self.readline)
                for token in tokens:
                    self.tokeneater(*token)
            except (_tokenize.TokenError, SyntaxError):
                # since we cut off the tokenizer early, we can trigger
                # spurious errors
                pass
        finally:
            _tokenize.tabsize = save_tabsize
        return self.blkopenline, self.indentedline

### end autoindent code ###

def prepstr(s):
    # Helper to extract the underscore from a string, e.g.
    # prepstr("Co_py") returns (2, "Copy").
    i = s.find('_')
    if i >= 0:
        s = s[:i] + s[i+1:]
    return i, s


keynames = {
 'bracketleft': '[',
 'bracketright': ']',
 'slash': '/',
}

def get_accelerator(keydefs, eventname):
    keylist = keydefs.get(eventname)
    # issue10940: temporary workaround to prevent hang with OS X Cocoa Tk 8.5
    # if not keylist:
    if (not keylist) or (macosxSupport.isCocoaTk() and eventname in {
                            "<<open-module>>",
                            "<<goto-line>>",
                            "<<change-indentwidth>>"}):
        return ""
    s = keylist[0]
    s = re.sub(r"-[a-z]\b", lambda m: m.group().upper(), s)
    s = re.sub(r"\b\w+\b", lambda m: keynames.get(m.group(), m.group()), s)
    s = re.sub("Key-", "", s)
    s = re.sub("Cancel","Ctrl-Break",s)   # dscherer@cmu.edu
    s = re.sub("Control-", "Ctrl-", s)
    s = re.sub("-", "+", s)
    s = re.sub("><", " ", s)
    s = re.sub("<", "", s)
    s = re.sub(">", "", s)
    return s


def fixwordbreaks(root):
    # Make sure that Tk's double-click and next/previous word
    # operations use our definition of a word (i.e. an identifier)
    tk = root.tk
    tk.call('tcl_wordBreakAfter', 'a b', 0) # make sure word.tcl is loaded
    tk.call('set', 'tcl_wordchars', '[a-zA-Z0-9_]')
    tk.call('set', 'tcl_nonwordchars', '[^a-zA-Z0-9_]')


def _editor_window(parent):
    root = parent
    fixwordbreaks(root)
    if sys.argv[1:]:
        filename = sys.argv[1]
    else:
        filename = None
    macosxSupport.setupApp(root, None)
    edit = EditorWindow(root=root, filename=filename)
    edit.text.bind("<<close-all-windows>>", edit.close_event)
    parent.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_help_dialog, _editor_window)
                                                                                                                                                                                                                                                                                                                                                                  usr/lib/python3.4/idlelib/FileList.py                                                               0100644 0000000 0000000 00000007345 12415221640 016071  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
from tkinter import *
import tkinter.messagebox as tkMessageBox


class FileList:

    # N.B. this import overridden in PyShellFileList.
    from idlelib.EditorWindow import EditorWindow

    def __init__(self, root):
        self.root = root
        self.dict = {}
        self.inversedict = {}
        self.vars = {} # For EditorWindow.getrawvar (shared Tcl variables)

    def open(self, filename, action=None):
        assert filename
        filename = self.canonize(filename)
        if os.path.isdir(filename):
            # This can happen when bad filename is passed on command line:
            tkMessageBox.showerror(
                "File Error",
                "%r is a directory." % (filename,),
                master=self.root)
            return None
        key = os.path.normcase(filename)
        if key in self.dict:
            edit = self.dict[key]
            edit.top.wakeup()
            return edit
        if action:
            # Don't create window, perform 'action', e.g. open in same window
            return action(filename)
        else:
            edit = self.EditorWindow(self, filename, key)
            if edit.good_load:
                return edit
            else:
                edit._close()
                return None

    def gotofileline(self, filename, lineno=None):
        edit = self.open(filename)
        if edit is not None and lineno is not None:
            edit.gotoline(lineno)

    def new(self, filename=None):
        return self.EditorWindow(self, filename)

    def close_all_callback(self, *args, **kwds):
        for edit in list(self.inversedict):
            reply = edit.close()
            if reply == "cancel":
                break
        return "break"

    def unregister_maybe_terminate(self, edit):
        try:
            key = self.inversedict[edit]
        except KeyError:
            print("Don't know this EditorWindow object.  (close)")
            return
        if key:
            del self.dict[key]
        del self.inversedict[edit]
        if not self.inversedict:
            self.root.quit()

    def filename_changed_edit(self, edit):
        edit.saved_change_hook()
        try:
            key = self.inversedict[edit]
        except KeyError:
            print("Don't know this EditorWindow object.  (rename)")
            return
        filename = edit.io.filename
        if not filename:
            if key:
                del self.dict[key]
            self.inversedict[edit] = None
            return
        filename = self.canonize(filename)
        newkey = os.path.normcase(filename)
        if newkey == key:
            return
        if newkey in self.dict:
            conflict = self.dict[newkey]
            self.inversedict[conflict] = None
            tkMessageBox.showerror(
                "Name Conflict",
                "You now have multiple edit windows open for %r" % (filename,),
                master=self.root)
        self.dict[newkey] = edit
        self.inversedict[edit] = newkey
        if key:
            try:
                del self.dict[key]
            except KeyError:
                pass

    def canonize(self, filename):
        if not os.path.isabs(filename):
            try:
                pwd = os.getcwd()
            except OSError:
                pass
            else:
                filename = os.path.join(pwd, filename)
        return os.path.normpath(filename)


def _test():
    from idlelib.EditorWindow import fixwordbreaks
    import sys
    root = Tk()
    fixwordbreaks(root)
    root.withdraw()
    flist = FileList(root)
    if sys.argv[1:]:
        for filename in sys.argv[1:]:
            flist.open(filename)
    else:
        flist.new()
    if flist.inversedict:
        root.mainloop()

if __name__ == '__main__':
    _test()
                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/FormatParagraph.py                                                        0100644 0000000 0000000 00000016032 12415221640 017425  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Extension to format a paragraph or selection to a max width.

Does basic, standard text formatting, and also understands Python
comment blocks. Thus, for editing Python source code, this
extension is really only suitable for reformatting these comment
blocks or triple-quoted strings.

Known problems with comment reformatting:
* If there is a selection marked, and the first line of the
  selection is not complete, the block will probably not be detected
  as comments, and will have the normal "text formatting" rules
  applied.
* If a comment block has leading whitespace that mixes tabs and
  spaces, they will not be considered part of the same block.
* Fancy comments, like this bulleted list, aren't handled :-)
"""

import re
from idlelib.configHandler import idleConf

class FormatParagraph:

    menudefs = [
        ('format', [   # /s/edit/format   dscherer@cmu.edu
            ('Format Paragraph', '<<format-paragraph>>'),
         ])
    ]

    def __init__(self, editwin):
        self.editwin = editwin

    def close(self):
        self.editwin = None

    def format_paragraph_event(self, event, limit=None):
        """Formats paragraph to a max width specified in idleConf.

        If text is selected, format_paragraph_event will start breaking lines
        at the max width, starting from the beginning selection.

        If no text is selected, format_paragraph_event uses the current
        cursor location to determine the paragraph (lines of text surrounded
        by blank lines) and formats it.

        The length limit parameter is for testing with a known value.
        """
        if limit == None:
            limit = idleConf.GetOption(
                    'main', 'FormatParagraph', 'paragraph', type='int')
        text = self.editwin.text
        first, last = self.editwin.get_selection_indices()
        if first and last:
            data = text.get(first, last)
            comment_header = get_comment_header(data)
        else:
            first, last, comment_header, data = \
                    find_paragraph(text, text.index("insert"))
        if comment_header:
            newdata = reformat_comment(data, limit, comment_header)
        else:
            newdata = reformat_paragraph(data, limit)
        text.tag_remove("sel", "1.0", "end")

        if newdata != data:
            text.mark_set("insert", first)
            text.undo_block_start()
            text.delete(first, last)
            text.insert(first, newdata)
            text.undo_block_stop()
        else:
            text.mark_set("insert", last)
        text.see("insert")
        return "break"

def find_paragraph(text, mark):
    """Returns the start/stop indices enclosing the paragraph that mark is in.

    Also returns the comment format string, if any, and paragraph of text
    between the start/stop indices.
    """
    lineno, col = map(int, mark.split("."))
    line = text.get("%d.0" % lineno, "%d.end" % lineno)

    # Look for start of next paragraph if the index passed in is a blank line
    while text.compare("%d.0" % lineno, "<", "end") and is_all_white(line):
        lineno = lineno + 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    first_lineno = lineno
    comment_header = get_comment_header(line)
    comment_header_len = len(comment_header)

    # Once start line found, search for end of paragraph (a blank line)
    while get_comment_header(line)==comment_header and \
              not is_all_white(line[comment_header_len:]):
        lineno = lineno + 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    last = "%d.0" % lineno

    # Search back to beginning of paragraph (first blank line before)
    lineno = first_lineno - 1
    line = text.get("%d.0" % lineno, "%d.end" % lineno)
    while lineno > 0 and \
              get_comment_header(line)==comment_header and \
              not is_all_white(line[comment_header_len:]):
        lineno = lineno - 1
        line = text.get("%d.0" % lineno, "%d.end" % lineno)
    first = "%d.0" % (lineno+1)

    return first, last, comment_header, text.get(first, last)

# This should perhaps be replaced with textwrap.wrap
def reformat_paragraph(data, limit):
    """Return data reformatted to specified width (limit)."""
    lines = data.split("\n")
    i = 0
    n = len(lines)
    while i < n and is_all_white(lines[i]):
        i = i+1
    if i >= n:
        return data
    indent1 = get_indent(lines[i])
    if i+1 < n and not is_all_white(lines[i+1]):
        indent2 = get_indent(lines[i+1])
    else:
        indent2 = indent1
    new = lines[:i]
    partial = indent1
    while i < n and not is_all_white(lines[i]):
        # XXX Should take double space after period (etc.) into account
        words = re.split("(\s+)", lines[i])
        for j in range(0, len(words), 2):
            word = words[j]
            if not word:
                continue # Can happen when line ends in whitespace
            if len((partial + word).expandtabs()) > limit and \
                   partial != indent1:
                new.append(partial.rstrip())
                partial = indent2
            partial = partial + word + " "
            if j+1 < len(words) and words[j+1] != " ":
                partial = partial + " "
        i = i+1
    new.append(partial.rstrip())
    # XXX Should reformat remaining paragraphs as well
    new.extend(lines[i:])
    return "\n".join(new)

def reformat_comment(data, limit, comment_header):
    """Return data reformatted to specified width with comment header."""

    # Remove header from the comment lines
    lc = len(comment_header)
    data = "\n".join(line[lc:] for line in data.split("\n"))
    # Reformat to maxformatwidth chars or a 20 char width,
    # whichever is greater.
    format_width = max(limit - len(comment_header), 20)
    newdata = reformat_paragraph(data, format_width)
    # re-split and re-insert the comment header.
    newdata = newdata.split("\n")
    # If the block ends in a \n, we dont want the comment prefix
    # inserted after it. (Im not sure it makes sense to reformat a
    # comment block that is not made of complete lines, but whatever!)
    # Can't think of a clean solution, so we hack away
    block_suffix = ""
    if not newdata[-1]:
        block_suffix = "\n"
        newdata = newdata[:-1]
    return '\n'.join(comment_header+line for line in newdata) + block_suffix

def is_all_white(line):
    """Return True if line is empty or all whitespace."""

    return re.match(r"^\s*$", line) is not None

def get_indent(line):
    """Return the initial space or tab indent of line."""
    return re.match(r"^([ \t]*)", line).group()

def get_comment_header(line):
    """Return string with leading whitespace and '#' from line or ''.

    A null return indicates that the line is not a comment line. A non-
    null return, such as '    #', will be used to find the other lines of
    a comment block with the same  indent.
    """
    m = re.match(r"^([ \t]*#*)", line)
    if m is None: return ""
    return m.group(1)

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_formatparagraph',
            verbosity=2, exit=False)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/GrepDialog.py                                                             0100644 0000000 0000000 00000012027 12415221640 016364  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import fnmatch
import re  # for htest
import sys
from tkinter import StringVar, BooleanVar, Checkbutton  # for GrepDialog
from tkinter import Tk, Text, Button, SEL, END  # for htest
from idlelib import SearchEngine
import itertools
from idlelib.SearchDialogBase import SearchDialogBase
# Importing OutputWindow fails due to import loop
# EditorWindow -> GrepDialop -> OutputWindow -> EditorWindow

def grep(text, io=None, flist=None):
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_grepdialog"):
        engine._grepdialog = GrepDialog(root, engine, flist)
    dialog = engine._grepdialog
    searchphrase = text.get("sel.first", "sel.last")
    dialog.open(text, searchphrase, io)

class GrepDialog(SearchDialogBase):

    title = "Find in Files Dialog"
    icon = "Grep"
    needwrapbutton = 0

    def __init__(self, root, engine, flist):
        SearchDialogBase.__init__(self, root, engine)
        self.flist = flist
        self.globvar = StringVar(root)
        self.recvar = BooleanVar(root)

    def open(self, text, searchphrase, io=None):
        SearchDialogBase.open(self, text, searchphrase)
        if io:
            path = io.filename or ""
        else:
            path = ""
        dir, base = os.path.split(path)
        head, tail = os.path.splitext(base)
        if not tail:
            tail = ".py"
        self.globvar.set(os.path.join(dir, "*" + tail))

    def create_entries(self):
        SearchDialogBase.create_entries(self)
        self.globent = self.make_entry("In files:", self.globvar)[0]

    def create_other_buttons(self):
        f = self.make_frame()[0]

        btn = Checkbutton(f, anchor="w",
                variable=self.recvar,
                text="Recurse down subdirectories")
        btn.pack(side="top", fill="both")
        btn.select()

    def create_command_buttons(self):
        SearchDialogBase.create_command_buttons(self)
        self.make_button("Search Files", self.default_command, 1)

    def default_command(self, event=None):
        prog = self.engine.getprog()
        if not prog:
            return
        path = self.globvar.get()
        if not path:
            self.top.bell()
            return
        from idlelib.OutputWindow import OutputWindow  # leave here!
        save = sys.stdout
        try:
            sys.stdout = OutputWindow(self.flist)
            self.grep_it(prog, path)
        finally:
            sys.stdout = save

    def grep_it(self, prog, path):
        dir, base = os.path.split(path)
        list = self.findfiles(dir, base, self.recvar.get())
        list.sort()
        self.close()
        pat = self.engine.getpat()
        print("Searching %r in %s ..." % (pat, path))
        hits = 0
        try:
            for fn in list:
                try:
                    with open(fn, errors='replace') as f:
                        for lineno, line in enumerate(f, 1):
                            if line[-1:] == '\n':
                                line = line[:-1]
                            if prog.search(line):
                                sys.stdout.write("%s: %s: %s\n" %
                                                 (fn, lineno, line))
                                hits += 1
                except OSError as msg:
                    print(msg)
            print(("Hits found: %s\n"
                  "(Hint: right-click to open locations.)"
                  % hits) if hits else "No hits.")
        except AttributeError:
            # Tk window has been closed, OutputWindow.text = None,
            # so in OW.write, OW.text.insert fails.
            pass

    def findfiles(self, dir, base, rec):
        try:
            names = os.listdir(dir or os.curdir)
        except OSError as msg:
            print(msg)
            return []
        list = []
        subdirs = []
        for name in names:
            fn = os.path.join(dir, name)
            if os.path.isdir(fn):
                subdirs.append(fn)
            else:
                if fnmatch.fnmatch(name, base):
                    list.append(fn)
        if rec:
            for subdir in subdirs:
                list.extend(self.findfiles(subdir, base, rec))
        return list

    def close(self, event=None):
        if self.top:
            self.top.grab_release()
            self.top.withdraw()


def _grep_dialog(parent):  # for htest
    from idlelib.PyShell import PyShellFileList
    root = Tk()
    root.title("Test GrepDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))

    flist = PyShellFileList(root)
    text = Text(root, height=5)
    text.pack()

    def show_grep_dialog():
        text.tag_add(SEL, "1.0", END)
        grep(text, flist=flist)
        text.tag_remove(SEL, "1.0", END)

    button = Button(root, text="Show GrepDialog", command=show_grep_dialog)
    button.pack()
    root.mainloop()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_grep', verbosity=2, exit=False)

    from idlelib.idle_test.htest import run
    run(_grep_dialog)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python3.4/idlelib/HISTORY.txt                                                               0100644 0000000 0000000 00000024115 12415221640 015700  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        IDLE History
============

This file contains the release messages for previous IDLE releases.
As you read on you go back to the dark ages of IDLE's history.


What's New in IDLEfork 0.8.1?
=============================

*Release date: 22-Jul-2001*

- New tarball released as a result of the 'revitalisation' of the IDLEfork
  project. 

- This release requires python 2.1 or better. Compatibility with earlier
  versions of python (especially ancient ones like 1.5x) is no longer a
  priority in IDLEfork development.

- This release is based on a merging of the earlier IDLE fork work with current
  cvs IDLE (post IDLE version 0.8), with some minor additional coding by Kurt
  B. Kaiser and Stephen M. Gava.

- This release is basically functional but also contains some known breakages,
  particularly with running things from the shell window. Also the debugger is
  not working, but I believe this was the case with the previous IDLE fork
  release (0.7.1) as well.

- This release is being made now to mark the point at which IDLEfork is 
  launching into a new stage of development. 

- IDLEfork CVS will now be branched to enable further development and
  exploration of the two "execution in a remote process" patches submitted by
  David Scherer (David's is currently in IDLEfork) and GvR, while stabilisation
  and development of less heavyweight improvements (like user customisation)
  can continue on the trunk.


What's New in IDLEfork 0.7.1?
==============================

*Release date: 15-Aug-2000*

- First project tarball released.

- This was the first release of IDLE fork, which at this stage was a
  combination of IDLE 0.5 and the VPython idle fork, with additional changes
  coded by David Scherer, Peter Schneider-Kamp and Nicholas Riley.



IDLEfork 0.7.1 - 29 May 2000
-----------------------------

   David Scherer  <dscherer@cmu.edu>

- This is a modification of the CVS version of IDLE 0.5, updated as of
  2000-03-09.  It is alpha software and might be unstable.  If it breaks, you
  get to keep both pieces.

- If you have problems or suggestions, you should either contact me or post to
  the list at http://www.python.org/mailman/listinfo/idle-dev (making it clear
  that you are using this modified version of IDLE).

- Changes:

  - The ExecBinding module, a replacement for ScriptBinding, executes programs
    in a separate process, piping standard I/O through an RPC mechanism to an
    OnDemandOutputWindow in IDLE.  It supports executing unnamed programs
    (through a temporary file).  It does not yet support debugging.

  - When running programs with ExecBinding, tracebacks will be clipped to
    exclude system modules.  If, however, a system module calls back into the
    user program, that part of the traceback will be shown.

  - The OnDemandOutputWindow class has been improved.  In particular, it now
    supports a readline() function used to implement user input, and a
    scroll_clear() operation which is used to hide the output of a previous run
    by scrolling it out of the window.

  - Startup behavior has been changed.  By default IDLE starts up with just a
    blank editor window, rather than an interactive window.  Opening a file in
    such a blank window replaces the (nonexistent) contents of that window
    instead of creating another window.  Because of the need to have a
    well-known port for the ExecBinding protocol, only one copy of IDLE can be
    running.  Additional invocations use the RPC mechanism to report their
    command line arguments to the copy already running.

  - The menus have been reorganized.  In particular, the excessively large
    'edit' menu has been split up into 'edit', 'format', and 'run'.

  - 'Python Documentation' now works on Windows, if the win32api module is
    present.

  - A few key bindings have been changed: F1 now loads Python Documentation
    instead of the IDLE help; shift-TAB is now a synonym for unindent.

- New modules:
  
  ExecBinding.py         Executes program through loader
  loader.py              Bootstraps user program
  protocol.py            RPC protocol
  Remote.py              User-process interpreter
  spawn.py               OS-specific code to start programs

- Files modified:

  autoindent.py          ( bindings tweaked )
  bindings.py            ( menus reorganized )
  config.txt             ( execbinding enabled )
  editorwindow.py        ( new menus, fixed 'Python Documentation' )
  filelist.py            ( hook for "open in same window" )
  formatparagraph.py     ( bindings tweaked )
  idle.bat               ( removed absolute pathname )
  idle.pyw               ( weird bug due to import with same name? )
  iobinding.py           ( open in same window, EOL convention )
  keydefs.py             ( bindings tweaked )
  outputwindow.py        ( readline, scroll_clear, etc )
  pyshell.py             ( changed startup behavior )
  readme.txt             ( <Recursion on file with id=1234567> )



IDLE 0.5 - February 2000 - Release Notes
----------------------------------------

This is an early release of IDLE, my own attempt at a Tkinter-based
IDE for Python.

(For a more detailed change log, see the file ChangeLog.)

FEATURES

IDLE has the following features:

- coded in 100% pure Python, using the Tkinter GUI toolkit (i.e. Tcl/Tk)

- cross-platform: works on Windows and Unix (on the Mac, there are
currently problems with Tcl/Tk)

- multi-window text editor with multiple undo, Python colorizing
and many other features, e.g. smart indent and call tips

- Python shell window (a.k.a. interactive interpreter)

- debugger (not complete, but you can set breakpoints, view  and step)

USAGE

The main program is in the file "idle.py"; on Unix, you should be able
to run it by typing "./idle.py" to your shell.  On Windows, you can
run it by double-clicking it; you can use idle.pyw to avoid popping up
a DOS console.  If you want to pass command line arguments on Windows,
use the batch file idle.bat.

Command line arguments: files passed on the command line are executed,
not opened for editing, unless you give the -e command line option.
Try "./idle.py -h" to see other command line options.

IDLE requires Python 1.5.2, so it is currently only usable with a
Python 1.5.2 distribution.  (An older version of IDLE is distributed
with Python 1.5.2; you can drop this version on top of it.)

COPYRIGHT

IDLE is covered by the standard Python copyright notice
(http://www.python.org/doc/Copyright.html).


New in IDLE 0.5 (2/15/2000)
---------------------------

Tons of stuff, much of it contributed by Tim Peters and Mark Hammond:

- Status bar, displaying current line/column (Moshe Zadka).

- Better stack viewer, using tree widget.  (XXX Only used by Stack
Viewer menu, not by the debugger.)

- Format paragraph now recognizes Python block comments and reformats
them correctly (MH)

- New version of pyclbr.py parses top-level functions and understands
much more of Python's syntax; this is reflected in the class and path
browsers (TP)

- Much better auto-indent; knows how to indent the insides of
multi-line statements (TP)

- Call tip window pops up when you type the name of a known function
followed by an open parenthesis.  Hit ESC or click elsewhere in the
window to close the tip window (MH)

- Comment out region now inserts ## to make it stand out more (TP)

- New path and class browsers based on a tree widget that looks
familiar to Windows users

- Reworked script running commands to be more intuitive: I/O now
always goes to the *Python Shell* window, and raw_input() works
correctly.  You use F5 to import/reload a module: this adds the module
name to the __main__ namespace.  You use Control-F5 to run a script:
this runs the script *in* the __main__ namespace.  The latter also
sets sys.argv[] to the script name


New in IDLE 0.4 (4/7/99)
------------------------

Most important change: a new menu entry "File -> Path browser", shows
a 4-column hierarchical browser which lets you browse sys.path,
directories, modules, and classes.  Yes, it's a superset of the Class
browser menu entry.  There's also a new internal module,
MultiScrolledLists.py, which provides the framework for this dialog.


New in IDLE 0.3 (2/17/99)
-------------------------

Most important changes:

- Enabled support for running a module, with or without the debugger.
Output goes to a new window.  Pressing F5 in a module is effectively a
reload of that module; Control-F5 loads it under the debugger.

- Re-enable tearing off the Windows menu, and make a torn-off Windows
menu update itself whenever a window is opened or closed.

- Menu items can now be have a checkbox (when the menu label starts
with "!"); use this for the Debugger and "Auto-open stack viewer"
(was: JIT stack viewer) menu items.

- Added a Quit button to the Debugger API.

- The current directory is explicitly inserted into sys.path.

- Fix the debugger (when using Python 1.5.2b2) to use canonical
filenames for breakpoints, so these actually work.  (There's still a
lot of work to be done to the management of breakpoints in the
debugger though.)

- Closing a window that is still colorizing now actually works.

- Allow dragging of the separator between the two list boxes in the
class browser.

- Bind ESC to "close window" of the debugger, stack viewer and class
browser.  It removes the selection highlighting in regular text
windows.  (These are standard Windows conventions.)


New in IDLE 0.2 (1/8/99)
------------------------

Lots of changes; here are the highlights:

General:

- You can now write and configure your own IDLE extension modules; see
extend.txt.


File menu:

The command to open the Python shell window is now in the File menu.


Edit menu:

New Find dialog with more options; replace dialog; find in files dialog.

Commands to tabify or untabify a region.

Command to format a paragraph.


Debug menu:

JIT (Just-In-Time) stack viewer toggle -- if set, the stack viewer
automaticall pops up when you get a traceback.

Windows menu:

Zoom height -- make the window full height.


Help menu:

The help text now show up in a regular window so you can search and
even edit it if you like.



IDLE 0.1 was distributed with the Python 1.5.2b1 release on 12/22/98.

======================================================================
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/HyperParser.py                                                            0100644 0000000 0000000 00000031115 12415221640 016612  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Provide advanced parsing abilities for ParenMatch and other extensions.

HyperParser uses PyParser.  PyParser mostly gives information on the
proper indentation of code.  HyperParser gives additional information on
the structure of code.
"""

import string
from keyword import iskeyword
from idlelib import PyParse


# all ASCII chars that may be in an identifier
_ASCII_ID_CHARS = frozenset(string.ascii_letters + string.digits + "_")
# all ASCII chars that may be the first char of an identifier
_ASCII_ID_FIRST_CHARS = frozenset(string.ascii_letters + "_")

# lookup table for whether 7-bit ASCII chars are valid in a Python identifier
_IS_ASCII_ID_CHAR = [(chr(x) in _ASCII_ID_CHARS) for x in range(128)]
# lookup table for whether 7-bit ASCII chars are valid as the first
# char in a Python identifier
_IS_ASCII_ID_FIRST_CHAR = \
    [(chr(x) in _ASCII_ID_FIRST_CHARS) for x in range(128)]


class HyperParser:
    def __init__(self, editwin, index):
        "To initialize, analyze the surroundings of the given index."

        self.editwin = editwin
        self.text = text = editwin.text

        parser = PyParse.Parser(editwin.indentwidth, editwin.tabwidth)

        def index2line(index):
            return int(float(index))
        lno = index2line(text.index(index))

        if not editwin.context_use_ps1:
            for context in editwin.num_context_lines:
                startat = max(lno - context, 1)
                startatindex = repr(startat) + ".0"
                stopatindex = "%d.end" % lno
                # We add the newline because PyParse requires a newline
                # at end. We add a space so that index won't be at end
                # of line, so that its status will be the same as the
                # char before it, if should.
                parser.set_str(text.get(startatindex, stopatindex)+' \n')
                bod = parser.find_good_parse_start(
                          editwin._build_char_in_string_func(startatindex))
                if bod is not None or startat == 1:
                    break
            parser.set_lo(bod or 0)
        else:
            r = text.tag_prevrange("console", index)
            if r:
                startatindex = r[1]
            else:
                startatindex = "1.0"
            stopatindex = "%d.end" % lno
            # We add the newline because PyParse requires it. We add a
            # space so that index won't be at end of line, so that its
            # status will be the same as the char before it, if should.
            parser.set_str(text.get(startatindex, stopatindex)+' \n')
            parser.set_lo(0)

        # We want what the parser has, minus the last newline and space.
        self.rawtext = parser.str[:-2]
        # Parser.str apparently preserves the statement we are in, so
        # that stopatindex can be used to synchronize the string with
        # the text box indices.
        self.stopatindex = stopatindex
        self.bracketing = parser.get_last_stmt_bracketing()
        # find which pairs of bracketing are openers. These always
        # correspond to a character of rawtext.
        self.isopener = [i>0 and self.bracketing[i][1] >
                         self.bracketing[i-1][1]
                         for i in range(len(self.bracketing))]

        self.set_index(index)

    def set_index(self, index):
        """Set the index to which the functions relate.

        The index must be in the same statement.
        """
        indexinrawtext = (len(self.rawtext) -
                          len(self.text.get(index, self.stopatindex)))
        if indexinrawtext < 0:
            raise ValueError("Index %s precedes the analyzed statement"
                             % index)
        self.indexinrawtext = indexinrawtext
        # find the rightmost bracket to which index belongs
        self.indexbracket = 0
        while (self.indexbracket < len(self.bracketing)-1 and
               self.bracketing[self.indexbracket+1][0] < self.indexinrawtext):
            self.indexbracket += 1
        if (self.indexbracket < len(self.bracketing)-1 and
            self.bracketing[self.indexbracket+1][0] == self.indexinrawtext and
           not self.isopener[self.indexbracket+1]):
            self.indexbracket += 1

    def is_in_string(self):
        """Is the index given to the HyperParser in a string?"""
        # The bracket to which we belong should be an opener.
        # If it's an opener, it has to have a character.
        return (self.isopener[self.indexbracket] and
                self.rawtext[self.bracketing[self.indexbracket][0]]
                in ('"', "'"))

    def is_in_code(self):
        """Is the index given to the HyperParser in normal code?"""
        return (not self.isopener[self.indexbracket] or
                self.rawtext[self.bracketing[self.indexbracket][0]]
                not in ('#', '"', "'"))

    def get_surrounding_brackets(self, openers='([{', mustclose=False):
        """Return bracket indexes or None.

        If the index given to the HyperParser is surrounded by a
        bracket defined in openers (or at least has one before it),
        return the indices of the opening bracket and the closing
        bracket (or the end of line, whichever comes first).

        If it is not surrounded by brackets, or the end of line comes
        before the closing bracket and mustclose is True, returns None.
        """

        bracketinglevel = self.bracketing[self.indexbracket][1]
        before = self.indexbracket
        while (not self.isopener[before] or
              self.rawtext[self.bracketing[before][0]] not in openers or
              self.bracketing[before][1] > bracketinglevel):
            before -= 1
            if before < 0:
                return None
            bracketinglevel = min(bracketinglevel, self.bracketing[before][1])
        after = self.indexbracket + 1
        while (after < len(self.bracketing) and
              self.bracketing[after][1] >= bracketinglevel):
            after += 1

        beforeindex = self.text.index("%s-%dc" %
            (self.stopatindex, len(self.rawtext)-self.bracketing[before][0]))
        if (after >= len(self.bracketing) or
           self.bracketing[after][0] > len(self.rawtext)):
            if mustclose:
                return None
            afterindex = self.stopatindex
        else:
            # We are after a real char, so it is a ')' and we give the
            # index before it.
            afterindex = self.text.index(
                "%s-%dc" % (self.stopatindex,
                 len(self.rawtext)-(self.bracketing[after][0]-1)))

        return beforeindex, afterindex

    # the set of built-in identifiers which are also keywords,
    # i.e. keyword.iskeyword() returns True for them
    _ID_KEYWORDS = frozenset({"True", "False", "None"})

    @classmethod
    def _eat_identifier(cls, str, limit, pos):
        """Given a string and pos, return the number of chars in the
        identifier which ends at pos, or 0 if there is no such one.

        This ignores non-identifier eywords are not identifiers.
        """
        is_ascii_id_char = _IS_ASCII_ID_CHAR

        # Start at the end (pos) and work backwards.
        i = pos

        # Go backwards as long as the characters are valid ASCII
        # identifier characters. This is an optimization, since it
        # is faster in the common case where most of the characters
        # are ASCII.
        while i > limit and (
                ord(str[i - 1]) < 128 and
                is_ascii_id_char[ord(str[i - 1])]
        ):
            i -= 1

        # If the above loop ended due to reaching a non-ASCII
        # character, continue going backwards using the most generic
        # test for whether a string contains only valid identifier
        # characters.
        if i > limit and ord(str[i - 1]) >= 128:
            while i - 4 >= limit and ('a' + str[i - 4:pos]).isidentifier():
                i -= 4
            if i - 2 >= limit and ('a' + str[i - 2:pos]).isidentifier():
                i -= 2
            if i - 1 >= limit and ('a' + str[i - 1:pos]).isidentifier():
                i -= 1

            # The identifier candidate starts here. If it isn't a valid
            # identifier, don't eat anything. At this point that is only
            # possible if the first character isn't a valid first
            # character for an identifier.
            if not str[i:pos].isidentifier():
                return 0
        elif i < pos:
            # All characters in str[i:pos] are valid ASCII identifier
            # characters, so it is enough to check that the first is
            # valid as the first character of an identifier.
            if not _IS_ASCII_ID_FIRST_CHAR[ord(str[i])]:
                return 0

        # All keywords are valid identifiers, but should not be
        # considered identifiers here, except for True, False and None.
        if i < pos and (
                iskeyword(str[i:pos]) and
                str[i:pos] not in cls._ID_KEYWORDS
        ):
            return 0

        return pos - i

    # This string includes all chars that may be in a white space
    _whitespace_chars = " \t\n\\"

    def get_expression(self):
        """Return a string with the Python expression which ends at the
        given index, which is empty if there is no real one.
        """
        if not self.is_in_code():
            raise ValueError("get_expression should only be called"
                             "if index is inside a code.")

        rawtext = self.rawtext
        bracketing = self.bracketing

        brck_index = self.indexbracket
        brck_limit = bracketing[brck_index][0]
        pos = self.indexinrawtext

        last_identifier_pos = pos
        postdot_phase = True

        while 1:
            # Eat whitespaces, comments, and if postdot_phase is False - a dot
            while 1:
                if pos>brck_limit and rawtext[pos-1] in self._whitespace_chars:
                    # Eat a whitespace
                    pos -= 1
                elif (not postdot_phase and
                      pos > brck_limit and rawtext[pos-1] == '.'):
                    # Eat a dot
                    pos -= 1
                    postdot_phase = True
                # The next line will fail if we are *inside* a comment,
                # but we shouldn't be.
                elif (pos == brck_limit and brck_index > 0 and
                      rawtext[bracketing[brck_index-1][0]] == '#'):
                    # Eat a comment
                    brck_index -= 2
                    brck_limit = bracketing[brck_index][0]
                    pos = bracketing[brck_index+1][0]
                else:
                    # If we didn't eat anything, quit.
                    break

            if not postdot_phase:
                # We didn't find a dot, so the expression end at the
                # last identifier pos.
                break

            ret = self._eat_identifier(rawtext, brck_limit, pos)
            if ret:
                # There is an identifier to eat
                pos = pos - ret
                last_identifier_pos = pos
                # Now, to continue the search, we must find a dot.
                postdot_phase = False
                # (the loop continues now)

            elif pos == brck_limit:
                # We are at a bracketing limit. If it is a closing
                # bracket, eat the bracket, otherwise, stop the search.
                level = bracketing[brck_index][1]
                while brck_index > 0 and bracketing[brck_index-1][1] > level:
                    brck_index -= 1
                if bracketing[brck_index][0] == brck_limit:
                    # We were not at the end of a closing bracket
                    break
                pos = bracketing[brck_index][0]
                brck_index -= 1
                brck_limit = bracketing[brck_index][0]
                last_identifier_pos = pos
                if rawtext[pos] in "([":
                    # [] and () may be used after an identifier, so we
                    # continue. postdot_phase is True, so we don't allow a dot.
                    pass
                else:
                    # We can't continue after other types of brackets
                    if rawtext[pos] in "'\"":
                        # Scan a string prefix
                        while pos > 0 and rawtext[pos - 1] in "rRbBuU":
                            pos -= 1
                        last_identifier_pos = pos
                    break

            else:
                # We've found an operator or something.
                break

        return rawtext[last_identifier_pos:self.indexinrawtext]


if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_hyperparser', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/IOBinding.py                                                              0100644 0000000 0000000 00000046441 12415221640 016160  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import types
import shlex
import sys
import codecs
import tempfile
import tkinter.filedialog as tkFileDialog
import tkinter.messagebox as tkMessageBox
import re
from tkinter import *
from tkinter.simpledialog import askstring

from idlelib.configHandler import idleConf

from codecs import BOM_UTF8

# Try setting the locale, so that we can find out
# what encoding to use
try:
    import locale
    locale.setlocale(locale.LC_CTYPE, "")
except (ImportError, locale.Error):
    pass

# Encoding for file names
filesystemencoding = sys.getfilesystemencoding()  ### currently unused

locale_encoding = 'ascii'
if sys.platform == 'win32':
    # On Windows, we could use "mbcs". However, to give the user
    # a portable encoding name, we need to find the code page
    try:
        locale_encoding = locale.getdefaultlocale()[1]
        codecs.lookup(locale_encoding)
    except LookupError:
        pass
else:
    try:
        # Different things can fail here: the locale module may not be
        # loaded, it may not offer nl_langinfo, or CODESET, or the
        # resulting codeset may be unknown to Python. We ignore all
        # these problems, falling back to ASCII
        locale_encoding = locale.nl_langinfo(locale.CODESET)
        if locale_encoding is None or locale_encoding is '':
            # situation occurs on Mac OS X
            locale_encoding = 'ascii'
        codecs.lookup(locale_encoding)
    except (NameError, AttributeError, LookupError):
        # Try getdefaultlocale: it parses environment variables,
        # which may give a clue. Unfortunately, getdefaultlocale has
        # bugs that can cause ValueError.
        try:
            locale_encoding = locale.getdefaultlocale()[1]
            if locale_encoding is None or locale_encoding is '':
                # situation occurs on Mac OS X
                locale_encoding = 'ascii'
            codecs.lookup(locale_encoding)
        except (ValueError, LookupError):
            pass

locale_encoding = locale_encoding.lower()

encoding = locale_encoding  ### KBK 07Sep07  This is used all over IDLE, check!
                            ### 'encoding' is used below in encode(), check!

coding_re = re.compile(r'^[ \t\f]*#.*coding[:=][ \t]*([-\w.]+)', re.ASCII)
blank_re = re.compile(r'^[ \t\f]*(?:[#\r\n]|$)', re.ASCII)

def coding_spec(data):
    """Return the encoding declaration according to PEP 263.

    When checking encoded data, only the first two lines should be passed
    in to avoid a UnicodeDecodeError if the rest of the data is not unicode.
    The first two lines would contain the encoding specification.

    Raise a LookupError if the encoding is declared but unknown.
    """
    if isinstance(data, bytes):
        # This encoding might be wrong. However, the coding
        # spec must be ASCII-only, so any non-ASCII characters
        # around here will be ignored. Decoding to Latin-1 should
        # never fail (except for memory outage)
        lines = data.decode('iso-8859-1')
    else:
        lines = data
    # consider only the first two lines
    if '\n' in lines:
        lst = lines.split('\n', 2)[:2]
    elif '\r' in lines:
        lst = lines.split('\r', 2)[:2]
    else:
        lst = [lines]
    for line in lst:
        match = coding_re.match(line)
        if match is not None:
            break
        if not blank_re.match(line):
            return None
    else:
        return None
    name = match.group(1)
    try:
        codecs.lookup(name)
    except LookupError:
        # The standard encoding error does not indicate the encoding
        raise LookupError("Unknown encoding: "+name)
    return name


class IOBinding:

    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        self.__id_open = self.text.bind("<<open-window-from-file>>", self.open)
        self.__id_save = self.text.bind("<<save-window>>", self.save)
        self.__id_saveas = self.text.bind("<<save-window-as-file>>",
                                          self.save_as)
        self.__id_savecopy = self.text.bind("<<save-copy-of-window-as-file>>",
                                            self.save_a_copy)
        self.fileencoding = None
        self.__id_print = self.text.bind("<<print-window>>", self.print_window)

    def close(self):
        # Undo command bindings
        self.text.unbind("<<open-window-from-file>>", self.__id_open)
        self.text.unbind("<<save-window>>", self.__id_save)
        self.text.unbind("<<save-window-as-file>>",self.__id_saveas)
        self.text.unbind("<<save-copy-of-window-as-file>>", self.__id_savecopy)
        self.text.unbind("<<print-window>>", self.__id_print)
        # Break cycles
        self.editwin = None
        self.text = None
        self.filename_change_hook = None

    def get_saved(self):
        return self.editwin.get_saved()

    def set_saved(self, flag):
        self.editwin.set_saved(flag)

    def reset_undo(self):
        self.editwin.reset_undo()

    filename_change_hook = None

    def set_filename_change_hook(self, hook):
        self.filename_change_hook = hook

    filename = None
    dirname = None

    def set_filename(self, filename):
        if filename and os.path.isdir(filename):
            self.filename = None
            self.dirname = filename
        else:
            self.filename = filename
            self.dirname = None
            self.set_saved(1)
            if self.filename_change_hook:
                self.filename_change_hook()

    def open(self, event=None, editFile=None):
        flist = self.editwin.flist
        # Save in case parent window is closed (ie, during askopenfile()).
        if flist:
            if not editFile:
                filename = self.askopenfile()
            else:
                filename=editFile
            if filename:
                # If editFile is valid and already open, flist.open will
                # shift focus to its existing window.
                # If the current window exists and is a fresh unnamed,
                # unmodified editor window (not an interpreter shell),
                # pass self.loadfile to flist.open so it will load the file
                # in the current window (if the file is not already open)
                # instead of a new window.
                if (self.editwin and
                        not getattr(self.editwin, 'interp', None) and
                        not self.filename and
                        self.get_saved()):
                    flist.open(filename, self.loadfile)
                else:
                    flist.open(filename)
            else:
                if self.text:
                    self.text.focus_set()
            return "break"

        # Code for use outside IDLE:
        if self.get_saved():
            reply = self.maybesave()
            if reply == "cancel":
                self.text.focus_set()
                return "break"
        if not editFile:
            filename = self.askopenfile()
        else:
            filename=editFile
        if filename:
            self.loadfile(filename)
        else:
            self.text.focus_set()
        return "break"

    eol = r"(\r\n)|\n|\r"  # \r\n (Windows), \n (UNIX), or \r (Mac)
    eol_re = re.compile(eol)
    eol_convention = os.linesep  # default

    def loadfile(self, filename):
        try:
            # open the file in binary mode so that we can handle
            # end-of-line convention ourselves.
            with open(filename, 'rb') as f:
                two_lines = f.readline() + f.readline()
                f.seek(0)
                bytes = f.read()
        except OSError as msg:
            tkMessageBox.showerror("I/O Error", str(msg), master=self.text)
            return False
        chars, converted = self._decode(two_lines, bytes)
        if chars is None:
            tkMessageBox.showerror("Decoding Error",
                                   "File %s\nFailed to Decode" % filename,
                                   parent=self.text)
            return False
        # We now convert all end-of-lines to '\n's
        firsteol = self.eol_re.search(chars)
        if firsteol:
            self.eol_convention = firsteol.group(0)
            chars = self.eol_re.sub(r"\n", chars)
        self.text.delete("1.0", "end")
        self.set_filename(None)
        self.text.insert("1.0", chars)
        self.reset_undo()
        self.set_filename(filename)
        if converted:
            # We need to save the conversion results first
            # before being able to execute the code
            self.set_saved(False)
        self.text.mark_set("insert", "1.0")
        self.text.yview("insert")
        self.updaterecentfileslist(filename)
        return True

    def _decode(self, two_lines, bytes):
        "Create a Unicode string."
        chars = None
        # Check presence of a UTF-8 signature first
        if bytes.startswith(BOM_UTF8):
            try:
                chars = bytes[3:].decode("utf-8")
            except UnicodeDecodeError:
                # has UTF-8 signature, but fails to decode...
                return None, False
            else:
                # Indicates that this file originally had a BOM
                self.fileencoding = 'BOM'
                return chars, False
        # Next look for coding specification
        try:
            enc = coding_spec(two_lines)
        except LookupError as name:
            tkMessageBox.showerror(
                title="Error loading the file",
                message="The encoding '%s' is not known to this Python "\
                "installation. The file may not display correctly" % name,
                master = self.text)
            enc = None
        except UnicodeDecodeError:
            return None, False
        if enc:
            try:
                chars = str(bytes, enc)
                self.fileencoding = enc
                return chars, False
            except UnicodeDecodeError:
                pass
        # Try ascii:
        try:
            chars = str(bytes, 'ascii')
            self.fileencoding = None
            return chars, False
        except UnicodeDecodeError:
            pass
        # Try utf-8:
        try:
            chars = str(bytes, 'utf-8')
            self.fileencoding = 'utf-8'
            return chars, False
        except UnicodeDecodeError:
            pass
        # Finally, try the locale's encoding. This is deprecated;
        # the user should declare a non-ASCII encoding
        try:
            # Wait for the editor window to appear
            self.editwin.text.update()
            enc = askstring(
                "Specify file encoding",
                "The file's encoding is invalid for Python 3.x.\n"
                "IDLE will convert it to UTF-8.\n"
                "What is the current encoding of the file?",
                initialvalue = locale_encoding,
                parent = self.editwin.text)

            if enc:
                chars = str(bytes, enc)
                self.fileencoding = None
            return chars, True
        except (UnicodeDecodeError, LookupError):
            pass
        return None, False  # None on failure

    def maybesave(self):
        if self.get_saved():
            return "yes"
        message = "Do you want to save %s before closing?" % (
            self.filename or "this untitled document")
        confirm = tkMessageBox.askyesnocancel(
                  title="Save On Close",
                  message=message,
                  default=tkMessageBox.YES,
                  master=self.text)
        if confirm:
            reply = "yes"
            self.save(None)
            if not self.get_saved():
                reply = "cancel"
        elif confirm is None:
            reply = "cancel"
        else:
            reply = "no"
        self.text.focus_set()
        return reply

    def save(self, event):
        if not self.filename:
            self.save_as(event)
        else:
            if self.writefile(self.filename):
                self.set_saved(True)
                try:
                    self.editwin.store_file_breaks()
                except AttributeError:  # may be a PyShell
                    pass
        self.text.focus_set()
        return "break"

    def save_as(self, event):
        filename = self.asksavefile()
        if filename:
            if self.writefile(filename):
                self.set_filename(filename)
                self.set_saved(1)
                try:
                    self.editwin.store_file_breaks()
                except AttributeError:
                    pass
        self.text.focus_set()
        self.updaterecentfileslist(filename)
        return "break"

    def save_a_copy(self, event):
        filename = self.asksavefile()
        if filename:
            self.writefile(filename)
        self.text.focus_set()
        self.updaterecentfileslist(filename)
        return "break"

    def writefile(self, filename):
        self.fixlastline()
        text = self.text.get("1.0", "end-1c")
        if self.eol_convention != "\n":
            text = text.replace("\n", self.eol_convention)
        chars = self.encode(text)
        try:
            with open(filename, "wb") as f:
                f.write(chars)
            return True
        except OSError as msg:
            tkMessageBox.showerror("I/O Error", str(msg),
                                   master=self.text)
            return False

    def encode(self, chars):
        if isinstance(chars, bytes):
            # This is either plain ASCII, or Tk was returning mixed-encoding
            # text to us. Don't try to guess further.
            return chars
        # Preserve a BOM that might have been present on opening
        if self.fileencoding == 'BOM':
            return BOM_UTF8 + chars.encode("utf-8")
        # See whether there is anything non-ASCII in it.
        # If not, no need to figure out the encoding.
        try:
            return chars.encode('ascii')
        except UnicodeError:
            pass
        # Check if there is an encoding declared
        try:
            # a string, let coding_spec slice it to the first two lines
            enc = coding_spec(chars)
            failed = None
        except LookupError as msg:
            failed = msg
            enc = None
        else:
            if not enc:
                # PEP 3120: default source encoding is UTF-8
                enc = 'utf-8'
        if enc:
            try:
                return chars.encode(enc)
            except UnicodeError:
                failed = "Invalid encoding '%s'" % enc
        tkMessageBox.showerror(
            "I/O Error",
            "%s.\nSaving as UTF-8" % failed,
            master = self.text)
        # Fallback: save as UTF-8, with BOM - ignoring the incorrect
        # declared encoding
        return BOM_UTF8 + chars.encode("utf-8")

    def fixlastline(self):
        c = self.text.get("end-2c")
        if c != '\n':
            self.text.insert("end-1c", "\n")

    def print_window(self, event):
        confirm = tkMessageBox.askokcancel(
                  title="Print",
                  message="Print to Default Printer",
                  default=tkMessageBox.OK,
                  master=self.text)
        if not confirm:
            self.text.focus_set()
            return "break"
        tempfilename = None
        saved = self.get_saved()
        if saved:
            filename = self.filename
        # shell undo is reset after every prompt, looks saved, probably isn't
        if not saved or filename is None:
            (tfd, tempfilename) = tempfile.mkstemp(prefix='IDLE_tmp_')
            filename = tempfilename
            os.close(tfd)
            if not self.writefile(tempfilename):
                os.unlink(tempfilename)
                return "break"
        platform = os.name
        printPlatform = True
        if platform == 'posix': #posix platform
            command = idleConf.GetOption('main','General',
                                         'print-command-posix')
            command = command + " 2>&1"
        elif platform == 'nt': #win32 platform
            command = idleConf.GetOption('main','General','print-command-win')
        else: #no printing for this platform
            printPlatform = False
        if printPlatform:  #we can try to print for this platform
            command = command % shlex.quote(filename)
            pipe = os.popen(command, "r")
            # things can get ugly on NT if there is no printer available.
            output = pipe.read().strip()
            status = pipe.close()
            if status:
                output = "Printing failed (exit status 0x%x)\n" % \
                         status + output
            if output:
                output = "Printing command: %s\n" % repr(command) + output
                tkMessageBox.showerror("Print status", output, master=self.text)
        else:  #no printing for this platform
            message = "Printing is not enabled for this platform: %s" % platform
            tkMessageBox.showinfo("Print status", message, master=self.text)
        if tempfilename:
            os.unlink(tempfilename)
        return "break"

    opendialog = None
    savedialog = None

    filetypes = [
        ("Python files", "*.py *.pyw", "TEXT"),
        ("Text files", "*.txt", "TEXT"),
        ("All files", "*"),
        ]

    defaultextension = '.py' if sys.platform == 'darwin' else ''

    def askopenfile(self):
        dir, base = self.defaultfilename("open")
        if not self.opendialog:
            self.opendialog = tkFileDialog.Open(master=self.text,
                                                filetypes=self.filetypes)
        filename = self.opendialog.show(initialdir=dir, initialfile=base)
        return filename

    def defaultfilename(self, mode="open"):
        if self.filename:
            return os.path.split(self.filename)
        elif self.dirname:
            return self.dirname, ""
        else:
            try:
                pwd = os.getcwd()
            except OSError:
                pwd = ""
            return pwd, ""

    def asksavefile(self):
        dir, base = self.defaultfilename("save")
        if not self.savedialog:
            self.savedialog = tkFileDialog.SaveAs(
                    master=self.text,
                    filetypes=self.filetypes,
                    defaultextension=self.defaultextension)
        filename = self.savedialog.show(initialdir=dir, initialfile=base)
        return filename

    def updaterecentfileslist(self,filename):
        "Update recent file list on all editor windows"
        if self.editwin.flist:
            self.editwin.update_recent_files_list(filename)

def _io_binding(parent):
    root = Tk()
    root.title("Test IOBinding")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    class MyEditWin:
        def __init__(self, text):
            self.text = text
            self.flist = None
            self.text.bind("<Control-o>", self.open)
            self.text.bind("<Control-s>", self.save)
        def get_saved(self): return 0
        def set_saved(self, flag): pass
        def reset_undo(self): pass
        def open(self, event):
            self.text.event_generate("<<open-window-from-file>>")
        def save(self, event):
            self.text.event_generate("<<save-window>>")

    text = Text(root)
    text.pack()
    text.focus_set()
    editwin = MyEditWin(text)
    io = IOBinding(editwin)

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_io_binding)
                                                                                                                                                                                                                               usr/lib/python3.4/idlelib/Icons/                                                                    0040755 0000000 0000000 00000000000 13077704266 015070  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/idlelib/Icons/folder.gif                                                          0100644 0000000 0000000 00000000170 12415221640 017006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a   `    !   ,      @=xWPbwdiD,Xie G+)\saYY ;                                                                                                                                                                                                                                                                                                                                                                                                        usr/lib/python3.4/idlelib/Icons/idle.icns                                                           0100644 0000000 0000000 00000160133 12415221640 016645  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        icns  [ics#   H p?? p??is32     cw  N ` N/Vu  G#Ik '->  {   w w   w       ew  L R' Nm  ;k /  mu  xy wq yu m m wmg       7     s # P m   9k  ' -  3w  >u y7 Dw y5 4 w71    s8mk                                   @  @                           @             @       ICN#        ? ??????      0           ? ??????      0     il32  	        #s c)} >w: wk}V  ok   e~i F'%e(' 6]H^s 5zmJ9{ qBi}iT 7oVoou/ y% / 
E 	 dV do X  p  u  ] t             #w c#){ Bw: wk| y  }R{ y{V~ y.Q5Ps {|{[=){ owg ]L s oau we" 
ysC 	ug bRwk b~q] Twg  i_ vmd gc yeb ]m tie  ue  sky          )  =!        J [J  >y s  
N|   .N/Hs 	' }T7){ o   VF  +  Z[s 5'q c>?" 
A9C 	k<E bR=3 bF7R T>3  J/V D41 H1[ B+5 ]fL5 tR/=  DH-  k1P l8mk                     @                                          @             @                                  @       @             @         @   @         @                  @    @                                  ?                                                    ? ?                          @                                             ich#  H        ?                ? ? ? ???            ?   ?      x   p                ?                ? ? ? ???            ?   ?      x   p        ih32  &   	  
     c^^x  R   c9   )N sss ${{1s  `-V    
 {I 1  s	A  _Js9 '0JBWo:u ( :) w{s{9Z91B  W {c9JJA 2Hb#RJ9xk k){{|{RR9  !{{{${ '%-f-=g  59 RRJRR-!  RJos	kN1 w{9  {  
! 
^   Jc
  kx c^ ZZ^{ "|x  c 
s  {  ss Z 
B o ww          	  
     e^^x  N   c9   1L ssss $s1 R-' s kZ ' R(m ( sc%R)!)   kc)J1- B<)kk xxcNB)  s|{{ x{{{b%/_  Vc(  s	s_cZF! w{mcu)  s{kc { 
{s[ 
wwoyR  {sc Jc
ssk  kx{qW cZssg RRZs[ "|ykcv  {kkR 
c{gcs  {cmk w{c_ sscsj Rmo Bkgc osscc wsmgg  ssco  ck      	  
     8   	R    NB    5      	s  5 s J  5^9 
 Q  m 
 ) sZR)!   B c)J1-  B9)gk  [ xZN9)    c s{   b%-_    Z  N1(  RBNs	9%)JF wB3-w!  9B1Z s
B95 
==5uR {B91 Jc
991  kz^B7= cZ991 RRZ9J "|_C1:x  B11J 
)B-1s  {yN)5V BB)- s9N)9b RV35g B1J-1 oEk9-B ws8W-1  9g9)R  k)1  kg h8mk  	                                                                                                                                                                                                                                                                                                                       ?                    @                                                                                                                                                                                                                                                             @                                                                                                                     @                                                                    it32  p    
			#0 ~.u^+J;tC40W'   :}= {Dc ; >'_ Y  : 
c
r   ? e	 a+WW+ ^ O Y	 1ZiVLU_jjYRt
	  ^ ="!sqpp|rp,x1ub>u.wol!  C~/I{q  3xxGRg?d]NI <3 uq&PJ|~2mS v ll{Yy>0K  vXcw_ilb, Q6 1 }|  <#)A 7, vi      *Q6~o  *b6
     K'	3,+ ?lt)8tn{? E$B]?s|~soJ  3R5k7D/ =0zS9LhY5tS 
Gq*  UEH!.H82Sv QnQ{djI+VPM)7J
(knMG;MiN:Z!.%4D]Q FiI [wqiA3UXB8, 589Bvt" ^\~5_u_$VOIF<Obcbaa@XC-I~!SnE
)UFCED=: ^ree^I'	S^RMFDE@9b  X~['irVTLGFC@>Etq`c`?('K~Q&]]VTMJGC>>Az"6~ F"Sm`YRPLD>8:Gxl 6n~x-d|ng[TRKB;79D(cbiw<%yx_"Myod[RKEA=>z

?[R axm]UPHA<4kU B~E%7gZ|i^eK44&M[>}#xW.'Vww\5lnZHn=%QQY?>GDXgY`b	C0
 W  ;}v|V qerE =B [H .|\]}ylF=5!=F,78: :VRSX:\SRW'{.:GCZ@   `'M*=!h
335J2 zuh]Xha'%*q
2HHIQVqw|z33^N~wS4W	){zi17Y 1p/0O	3z7#"C2F,;	 ^Ftl%f}"yi&m
7$}05!v!y!pqyq+x^ib\  !~ojETjMp t[vtOBY!}}q*t]\_	lOhr(ztl_~y	b)|rdVv)ZgZ"|naWNq.a~S|tfYSOKf~sS\UTRNOZ|Q|YUTNNV^[QuWf`Xcnje  Uzxnvwyhq~wYrxp/w{yhj/wcn8fvJzxj||^yrtx~
u	
| 
y$woz&nikaw
j~)x[}}
 to 3 {q6|u2u~c`YyS|LIp%}qX%k_]d$fbp|	'vmz}3|ibcipx2vcfWj~(y~
		  
 !

	#0 ~.u^+J;tC40W'   :}= {Dc ; >'_ Y  : 
c
r   ? e	 a+WW+ ^ O Y	 1ZiVLU_jjYRt
	  ^ =}"!sqpp|rp,xy 1t~ty,[
.~~|>|
~/xrtJwxGRg?dyu{tO tq&OIwNu nP]|gYfu|t@0{E sxu\ 'ucTu|* v xaI  gx 5]s~LZ@ }ut~U\`UX-Yf3 	as~0zB!5Nc<$tb G(Zv~Eo65&
(h H#~~Vs8 	KP{wK;syti9+P!"4QQ}sk~weQ)HQ9/##"",fj
}y5U^D

	E<61&;z*qjtu!Sf=B4232*% dpree^I'	AL@;413/'-aSv['U_DC:651/-/tp}-;pwQ KzKDB<;61-.,zC| FA[NGBB>5/**5xuv{x)Vj\UKDB;5.)+4z	mx_"Mwsng^RHB?71-.z~ ~~[R auof[LEA6..$ji{~E%7gSxqiUKT8$%Mu}}#}}~mvwBW{	}u}ln}utwV@^-{j{uzgU`b7!

  ~~ b`rE =5[gsqgrst}XQlF9#=	'eTY[ay{.:4Cpw|wHwj`bd_fjM*/g
z3kk_^`]cdYa'q	{3qvok_^\^`g^zz3!^N~owlbb`_acwS"W	){}pli__`qi1)Y
4quume`cp/'O	 4z_x}wqmg^7C	 1x|spighF;	w~{olZ`^Fx{wqj_tl%fw|ytohX"wivyvtnZm
7$q|uvqdP05!n{vsrl^s	!u{qqmgdy!o|{spojftpqyq  +zw|unokg\x]ha\
!~nypmngZokFTiNpy{~wqpke_]vuO@Y!vyqpoid}q*t]\^	u}zrml_lOhr(ztl_~yut{}wpkdN)|rdVv)rxwwrlhRZgZ"|naWNq.r|wsqmicD~S|tfYSOKf~q}ppnhf`sS\UTRNOZ|h{woomed_Q|YUTNNV^tv|rooke`USuWf`XcnnxopngaQeVzxnvwyhq~wspookdZWrxp/w{yh|yvlmlh`\wv|llkldVbn 7uoihkjaWv7yyzw}fggmgXh|}mmcekm^Ryi|hdhnedrtx~
vopdfpi]f	
|#iwidkn^i
ywzz~legpdawoz+niurgdmm^fiaw
j~5xwuiehodYK}}
 to3uvngcnl^` {q6|n~pjehpeczu2v{skegmkb\~ckohemkfW`YyszlhkmeuS|otlkngcLkqknjdjIp%}qlssmilf[xqX%k_]dxsp{qjgfdmfbp|
utngffhy	'vmz}pt}{ogdfhe3|ibcilNnxslcdgfs2vbfWj~ko{qidfhg(y}}ttngfjfy{{ogdffnu|rlcdger~{pidfgq
uieekl		redjo|xejurluq  
&	 
	# 0}
 5 u^  t> 
P R Q ;  [/  .\\4  P9  O    [
#r  Z    G	  6\  [g  A      J	 	#f
` "G ! wt g`  =|v! H+ ?{    .q  J| ci zo g6 	4 i9Iw) B kGIMAJp h 0Sz:(@Q0tc * 2wEh2	+ 'g Q 3Mj2 M{ 
(knB 3	i/%Q!1M} , 4rw^BDQ;1$#_i ^c73	 5EOV:
;76.2tqbcbaa Q!Sc9
://11' d .ree^I'	?G>7/-.+!-aSHI" V['
V_B@831-+'(tq-;I AQJxIB@:73-(+'zC 2 F@YLE@?:2,)&/x`YF u`x)TiZSJB@80)%(0 4 "Muqle]RIA;0,++z hLT,% a~uof[KEA3+)!iU ,|V
 jpS  QxqfRHM4#%M J [ Ilts;
V V  bS;X'X qrJ  	cgU`b1
 W hF YbrE =+
[
H n}yi*}lF9== :XX BYO'"$$2P{.:/C K`:'*(.,6DgM*+
g
8 )zug]Xh{%/+$*+8/7ya'q	2HHIC=JVq<.0&%")05Lyz3^N~n-<2+(')0@wS
W){LAF641*,2qi1"Y
 0/LE=6410Pp/"O	o5z+5PC;73367Cg 0}9LIC9424VF;	k X4OEB42&<^F8BKB?820tl%flh1LE?=61;"wix0BE?><5*m
7%N4K@=?9/:05!'CF==942s !E1GA9:55Iz !~*CB:8739spqyq +;:E=4644=x^ib\ !~n%G@84512ojFTjNp8;D<7759Z\uuO@Y!`2F<6799R}q*t]\^	1CC=778;lOhr(ztl_~y83CE;872?)|rdVv)g-A=<877/ZgZ"|naWNq..?@976520~1|tfYSOKf~L.E:68525sS\UTRNOZ|h#A@67753F Q|YUTNNV^2;E<77536USuWf`Xcn^*H@87652;e Dzxnvwyhq~w4IF96
3;Wrxp/w{yh=@O<44575RwN7UE221759bn7k.HU6-,296Lv7yy;7WH,,-96:h|}T&NV4),4<0Iy%DYG-+/82Ertx~
@-UT5*.95-\	
|!o%KWB.+2:/G
y w>>QK1(-:11hoz$niv8RL:+(6:)?iaw
j~)x4GK?/)/=/(A}}
 to3^2Q?5,*:7-I {q6|-LK7/+0=1>zu2@@Y=0+-872K~cz+\S5,,4809`Yy/8EdC1+27.NS|X/_]:..92-L'p.OjJ2-650IIp%~\56fU8..73)\qX%k_]di@-YcA3./32C$fbp||U1IiR62-/47^	'vmz}[5:da>2.+14>3|ibcil1*;hT71(,49S2vbfWj~8+YcA3.,24A(y~K3IiR62-/5;W|4Fh`>2.+13G30\nR61(,4=m/2_bA3.+26I
Hb[=2+-5;		qf<,,3:X_<'4B?|0.AD  t8mk  @                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/idlelib/Icons/idle.ico                                                            0100644 0000000 0000000 00000046516 12415221640 016473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                                   v      (  ^                h  .  00     %             >8       h  H  (       @                                                                    p p        p 33    p3388   33  3333  33 D333338D333333DD333333?DD33333?DDH33?DDDDDD3?DDDDDDH3?DDDDDD3DDDDDD8DD DDDD  DD  HDDH  DD      x               p       p         p           wwwwwwww      ?                                           ?  ?  ?  ?  ?  ?         (                                                                        p     p xpx3 38? 3O3338O333H3DDD3DDDO8OHDO D   wwwwwx  ~                                                     (       @                              ~dF u? w> z= ~; gE kC oA r@ : I b p K k ( , 1 ? 5 < \ C K Q s U [ c b                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        ((&&&&)     2,         &&/..)).($$&),,       )./......)..)),,      .3()/$&&&)(&$&&      .3$&/&()(.).#   .3/////////+,  .3()///.$/	 .3$&////(/	 .3////////1" .3()////&/12 .$&33//)/
	2 .333333//

	 .()3../3)3

	 .$&3).)3)3+
	2  .333333333!   .()3&(3&()3)/3	      .$&)./../3/33
++	      .333333++	      .(.()))/)3/(.+
+       .&&../.33.)33        .33333/.)&        .(./.)(../.33/333/$$&&        .&&.//./3..33(&(&&((        .(3/.).)3        .(.(($/$&/         .$&)//.(3$ .$/          .3&.//./           .()//.)&( ././            .$&3)//).3/.)& /./             .33.&)./              ///////////////3/              ?                                           ?                  ?(                                     ~eG x> iE rC E ~ 7 ? H V b x                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      
  
	  
 
	
			
                   <                                                 (   0   `          %                                                                                                                                                                                                                                           !   !   $   &			&   "                                                                                                                                                    W+<<</            	                                                       &&&#   &                                          [[[?6666   BBB3   "                  
   
                  mmm3   ,                                          !!!4   777&}}___EOpppDP,   )   +3Z2226   DDD(   ,                                          ###55   ,                                             ,                                          222"&&&2                                             4   888&e?4/+.R                                       $$$5D@;73/*&"                                       WGC?;62nf0                                       333"OKGB>:5pi$                                       !!!4   888&SNJFB=950,(                                       %%%5VRNIE                       |Jq?o@ZUQMID@<73/+&"-                   444"w<u=s>q?]YUPLHC?;72.*%!               """4   888&dy<w=u=s>a\XTPKGC>:61-)% O               %%%5A{;y<w=t>s`\WSOJFB>951,($(               9|:z;x<v=s_[WRNJEA=840,'#               555"9~9|:z;x<om83/+'               """4   :::&89~:|;z;w<u=s>q?o@mAkBiCgCdDuZ;73.*               %%%5>89}:{;y<w<u=s>q?o@mAjBhCfD~dEuZ?:625               a789}:{;y<w=u>r>p?n@lAjBhCfD}dEB>:5^               555"7789}:{;x<v=t>r?p@n@lAjBgCeDFA=9               """4   ;;;&C89~9|:z;x<v=t>r?p@mAkAiBgCIEL                   &&&5q?o@mAkBiC                       9~:{;y<w<u=s>q?o@mAkB                                       555"8uvy<w=u=s>p?n@lA                                       ###4   ;;;&Duv{;y<v=t>r?p?xM                                       &&&588~9|:z;x<v=t>r?                                       b@~9|:z;}Cg                                       666"&&&2                                          ###4   <<<&"""4   888&   ,                                          &&&5$$$6   ,                                             *                                          666"@   $                                          """4   ;;;&444]ttt|                                             &&&5                                                                                                   555"                                                         """4   ;;;&                                                             %%%5                                                                                                                                555"                                                                         """4   :::&                                                                             %%%5                                                                                                                                                                                                                                                    
                                                                          ?    ??      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?                                                                                             ?      ?      ?      ?      ?      ?      ?      ?      ?      ?      ?                                          ?                (       @                                                                                                                                     !!!0\\\JeeeQ666D555A   0   $      
       vH<602\                              7qvvvj&&&D   1   "gLF@;5?                           VQKE?9(                           aV[UPJD>82-                           uuun{{{j`ZTO           Vo@lAb_YSMGB<60+%<       aVmt>q?n@bb^XRLFA;5/)$Y       wwwn}}}j~Cv=s>p?bba]WQKE@:4.(+       {;x<v=s>bba[VPJD?93-'       aV~:{;x<u=pr=72,       yyynj9}:z;w<u>r?o@lAiBfD}dE|cE|cEiB<61       ?9}:z;w=t>q?n@kAiCfD}cE|cE}dFGA;=       aVi89|:y<v=s>q?n@kBhCeD|cE|cELF@m       zzznjP8~9{;y<v=s>p?mAjBgCeD|cEPJ\       mAjBgC~dE           aV}:z;x<u=r?o@lAiBfD                           |||nj9w=t>q?n@lAiC                           Py<v=t>q?n@~Y                           aVkA|;y<v=yFp                           ~~~nj                                  6                                  aVlllg|||s   4                                  }}}nj---{bbb   (                                                                         aV                                          |||nj                                                                                                aV                                                      zzznj                                                                                                                                                                                                                                ?                                                ?  ?  ?            ?(                 @                                          C            o    I            S=?        _QF4        aZoEcaXMB70~Iq?c`VK@58z;u=qv>3Ey<t>n@iB~dE}dFGH=x<s>mAhC}dE}eGSgC}cE~>q?kAiG        Gu=xK                                                ~                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/Icons/idle_16.gif                                                         0100644 0000000 0000000 00000002012 12415221640 016753  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a   Ec}Ed}Fd}Ge}Ed~043578?=>@BFGHKMSSQVXZ_`aacv?q>s>t=u=u<x<y;z>~CgChGiBiAkAmEo@nKxI~=GEq                                                                                                                                                                                                                                                                                                                                                                           !   ,         xJ,]Z	6}P@`BrO3mDrPYBVj!eB-j3iB`aP1qsPJj(d`` Oi#k*A}qNS; HP!8!O)0}0LQ3%IQJ$Bf6qnA@P*4XC<$q<z ;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/Icons/idle_16.png                                                         0100644 0000000 0000000 00000002360 12415221640 017000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        PNG

   IHDR         Oc#"   bKGD	X   	pHYs   H   H Fk>  .IDATHU_~_!cm"&P(Z
ef@Upfr!.4E`/NLSyy9=y\.eBAl6fd2L&00|>=KRTjuERT*4fIHt:H$I!(izNh4!ZV=}zZVUBD" h4vn8N	vxx<B!~BPdO$Fp8D"HZV\.x<> Hx<^i;wtTW0bX,@03B,zn/^{, .I
pa	("0z=^3\]z8~|i)VV_O&)YCN"Zzy?Ql:fMLx-P%yg-XXf3{c+|QU
@;L 43dry t P z5:e
@ `!I(r^\?oaEc?N	2 tp8flk: I, Z_~^ EhN9 '0[|>o;}G0eoJ	1 `4
 y=CCvn'=w1 OOSd
<* ,, K?)0LYR	 N	N/`:m^?s2n7IVnjZv(B!bX{t8] Q\_Kd{C*|k!#
r\"A~@&nvF_QLI0y  ]?ujcE/_cT*JR6f_?FP(
/BtBE<|^'+&2   %tEXtdate:create 2014-01-31T09:06:12+02:00w%   %tEXtdate:modify 2014-01-31T09:06:12+02:00"    IENDB`                                                                                                                                                                                                                                                                                usr/lib/python3.4/idlelib/Icons/idle_32.gif                                                         0100644 0000000 0000000 00000002633 12415221640 016762  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a     Ec|Ec}Ed}Fd}Ed~Debbb$%'(+)+,-./201234567<?89:;;=<<=>??@@ABDEFFGHJJKLMOY\P\QRSTUVVWXYZ[]^_mrg`abv?p?q?q?r>s>s>s>t>t>u=u=v=v=v=w<w=w<x<x<y<y;z;z;z;{;{;|:|:}:}:}:~9~99DeDfDfCgCgChCiBiBjBjBkAkAlAlAmAm@n@n@oY~FyC~988iVAmpp?PPki                                       !   ,          	H)TaqZR!;zm+mz4Wh-DO:IJv|.3i{']/ok\)O4	%:twj`{TmCm8k{Vh+VqS@SgS:;45o>qTW/vN{Hn|QDiY9Mfdg(TZvY[!
"@|-*\igM/	}bSQ:<ueN/<s#tQw<F	9 2w  ;7BTnS	#oT + x;a#U`_d7|NycxAI8`D	T A &RH.
([;EEP+|,<m3M)I"FD)F:i@U6z0	"$:j)  A1FK/`RQ(6@J+*A0CeyV04tR,@{Kl/pRJJL0+PH!X1A ;                                                                                                     usr/lib/python3.4/idlelib/Icons/idle_32.png                                                         0100644 0000000 0000000 00000004756 12415221640 017011  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        PNG

   IHDR           #   bKGD	X   	pHYs   H   H Fk>  	,IDAThYKLce>m@-TLI4Q1.\u3A%`H'dyXQ'!11b4C[Zq19?@G*4H5=_&D"p<<[H$DEbqL&$@(
B ;;;;;; 
BP|87}O| x0fhr,-"d0 yyyyyy F0XX,~vZ[[[[[\.`0F| yRV`JRi pD @  T*J%@NNNNNWT:#c RHRT* 4u2&![5'&&&&&zz 
Q_8d2b1jZG@mmmmmKDuaPh>&!&($JJJJJJ `.NN>h 3H}4Ntic*H$Dxz^w:N<LO?sL'ylxxxxxhDrd2L]_x;d'9$yBR{k08zo2i65wwwwww&P 	^cNt00Jf9
0zUUUUU@nnnnn.HJ^|, *,D-TX-Y TlL>Gh4elcccccS( CCCCCCX677777(Y)	OYhQ(	L\YGtq{1f`
iN b|>#T*Jr?d $x4
 RJLN45UWstNb RS|`t7z
@*}rt +*jNjO a/o`(ML *Sy	+=J;;~(:D35O8LVh4<TS%GMn 

NO_AOb:h/@_SKQm*k7okvHokY-{{]!vvV'O{<nO&n vC 3o  8.VtRBy$:Uv<}?p~fNHXLR)d019s  \.j^~YXjA(u<r3]8dP9{V3''''''{zVjlLJ$Xt><$  $~- )98 @e ({c L6egyqd:w{LO'2|s3BcfB@Bz>{(_tR'  |N%h&32Qgg 6 $8>>>>>n4NMMMMM+C6YB%+cB& :y7\=ip]yu( X[@@TG45UUTY\\(I' X^*r8;mDR 7nv{>2 ? R[HyJj.^-+ xi|R55],
 Xqh4 
AG>\m4D} W^S	*A
4%<LDm.ibF)N+W  ?>> N[Vw/cr9>  HX8QBl{_zIp~o_z9! `{dBO}wuuuuu#r9&H=
~ffffff.>gJ$ Zqj=) pErM]]]]]]yy[[[[[[e%~m6fTjqqqqq@5>1 u,FfxK nLR2 @<o&tsIAAS ^" J/)nR4~@_#BN   %tEXtdate:create 2014-01-31T09:06:12+02:00w%   %tEXtdate:modify 2014-01-31T09:06:12+02:00"    IENDB`                  usr/lib/python3.4/idlelib/Icons/idle_48.gif                                                         0100644 0000000 0000000 00000002554 12415221640 016773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a0 0   Ed~$)0,15:>OCGLKRR^TZ]felmp`s?r=v<y:}9DfChBjZu@n@pMxJ|C}8A@go7>Ddbavvu                                                                                                                        !  X ,    0 0  XWWTTTPOMXWIXJTJWKOJOKTOPPKJ<MWWMKMTMJI;=JXOI=WMPI<IOv}D%IJl$P9x[;j=yK&*.%^vTBLPeFa+LUF^
Vb)D(a ,U@Y/(J`ZR%X]V|$(]U	$4TaE#TrUY]Yt>xH"-o$WTVlp6UKtEm(1z!HV_r.h4E=+8E4G^yDKj .Gly`p8t]* `}!h@4
#$(6_/# W,Tp'Qq)]r/Qb.)B pE iPEMWwhrIQi7
R%+PRHP 7>IR-'P@H``'{RiBf,pP)  O%R	,"\Qi'(,G{>D
,2 @Du+(4w:QIj&&
$~(R%4j`LMS+^KafPE&u);mhn\E0$v0c,3 XH,}_%	a*@X#"W50t,~&T0lXZ5B
@l=TuI`BbN9lfU.~H  ;                                                                                                                                                    usr/lib/python3.4/idlelib/Icons/idle_48.png                                                         0100644 0000000 0000000 00000011146 12415221640 017007  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        PNG

   IHDR   0   0   %   bKGD	X   	pHYs   H   H Fk>  IDATx\{LTf@@^(  B*3Ff@m5MdK&.XqX"F)+>x"y#:?sA]{s}s,GF&lqlllllhq5FQC:I$I=c||||||jo6f3zIjZO>=q"<<<<<..hm]./////OO4{YAD|LdX,Qccccc#QOOOOO{GKtL&Duwwwww1?88888Hh4o}644444v`/_\gtuuPm
.]tDzX,X 'O@Q99~wvryM@;{gz^wqE+twwwwwwqO\3g9s:4@Gr<x|  L`@<~xxxxxVxg={&eeW=4=}+W4B@1O^y/<q[#'~~lIk]vmh$!P_EO2m-[nqqJ?yI~%K;wc}-zUP=E-{~
Fl{/#####`x/[69-ry8{W^MDKh-Zh*`X>8B@7ogLRz=s_wsW%-I8a$8\EIhG@ i_H/~/o2WIs$uvvvvvJR}}}}}}N=-[lt:2D$HEX:Gdar(\qD2fGGGGGG"x;;v7nHLLLLL|M79OS  \xII`07oy.\pB"OOOOOO;w\8< (W	/^,$	p]VS+wiwpx/j4UaG/5dP<	= "Vt.fl+EAE(JIPq'jHZyqz6xYLy709^fA>lm]nut:yG(!B`=
Ab0)PXTTTTT>x:dXU/ $.3s@P[' z`l	+@D%=zN] 'hJ	EUSIb$61k]&c`I*QGW_(A	O@I.\ho'jlLLX,99IQH+QBBllH+VWUedddoo}UMu[{8( @	4n9(:p(106C.]%ikc,
$tD~_^Sg={|ZV -[l$k]ved@LB('C ]h4F#bSp(	??hyxCC'h$/I)D|||I[xe
q\}; $`#A~,,,,,,L@+9+_t:\&CgA8+yd:L:^W<?AqqiiW
lhh2@/ mmn]b+/Op W@|^7}YAAi27O~.#,qFu5E8y-H	V3?mmDLlD,!=x13::yzgDDnEFhz&U[zWp8yXiis34<l-(`5=[CCfqy`hzzh~4huq`zJJf{D553n`zz&1-DD &Z= a#@\PD+~`]]yy)y{{{zN1\,{S 4DWWWWWA#_+(5l6-Zta~ooOO77>xhlW$,AHf'%s_~y'NlX"a_c@
jrE"l[6YMt/K O>uW8,?"JQf98hp/clmohE-hUV2lE/H49(	%;9iqd.~/km*-]i|yc;v(s I `lURkJdF{nnaaxZ
MJvq9~ 
R`4`%q9W~D> ZG-
`U	 q~,_}e>n4bMT.n@*fE\vDD Smk|lX2~ppjwq&mS,xdg:uS[r @-|8QGaDSNm[o~CD@/^zN+W\"jA,X((-~+ iX1\.F+3W8GS7ny5TutO'%Yf5..G=z `yy8O<h~rDD11~KD~5?8%hn%"2<NJ[GDl@DT]JD[^NDl )0| Q"?hb9u(Y Q6r4#S*,$"*)""%KoG;Vh=Zz^kp/@#@!
(\4`98	AqXt	Lz"1{RCB==~wEoow{x/yZ j@@@@@ ~!8
wAq #87.900>^<TZojYalz hDt5.'Wub;q=9 y9!*mkerbN@{{E^eA75qm6x_VL=/lz /|6l_!uK.]tIt hD!P5X' y[83gqv`K,YdC:(Vh ''0|xNDkkf68@8pToooooo`o'OrrOc19bdZT
mnNKKKKK|=>1^6e9?hmq^V'$NH]\x}?M e3 iM6""4&1\;;-lpWzIuao_VVVVVrt{d$8 <x'/^)ggv\]' Lp<1,~0L(^/FC`g e=d7(5T   %tEXtdate:create 2014-01-31T09:06:12+02:00w%   %tEXtdate:modify 2014-01-31T09:06:12+02:00"    IENDB`                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/idlelib/Icons/minusnode.gif                                                       0100644 0000000 0000000 00000000140 12415221640 017531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a       !	   ,       2 HP`! 28 h0D/bS                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/Icons/openfolder.gif                                                      0100644 0000000 0000000 00000000175 12415221640 017675  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a   `       !   ,      @BhJ@i ! 8OaM4ka0.g+BCl lV}fl ;                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/Icons/plusnode.gif                                                        0100644 0000000 0000000 00000000117 12415221640 017365  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a      !   ,      @ hp,3(FLDD8 ;                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/Icons/python.gif                                                          0100644 0000000 0000000 00000001111 12415221640 017050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a  d !*#$%&-/./4=0067989:>:EAABBCDJKMNNUWXaabnojl2`6f6g5h6i6i7h7j9l8l9m:o:p;p;p<q=s=s=t>t>u?v@x@xAyB{C|C}C}D}D~EFFFGHHHIJJKLLMLNOPR                                                                                 !  e ,       eeaZRLF@7]dRJD=8WD>85e_WLD9298ca\UPG@<5e'#eb_TPJ51e#WT@4eKGeR4e-/,'&!eLJCe.0,)C>e,3   xW.Be*8,0 A  ;                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/Icons/tk.gif                                                              0100644 0000000 0000000 00000000125 12415221640 016151  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        GIF89a     !   ,      @n&rFcJ ; ;;
D  ;;                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/IdleHistory.py                                                            0100644 0000000 0000000 00000007724 12415221640 016616  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        "Implement Idle Shell history mechanism with History class"

from idlelib.configHandler import idleConf

class History:
    ''' Implement Idle Shell history mechanism.

    store - Store source statement (called from PyShell.resetoutput).
    fetch - Fetch stored statement matching prefix already entered.
    history_next - Bound to <<history-next>> event (default Alt-N).
    history_prev - Bound to <<history-prev>> event (default Alt-P).
    '''
    def __init__(self, text):
        '''Initialize data attributes and bind event methods.

        .text - Idle wrapper of tk Text widget, with .bell().
        .history - source statements, possibly with multiple lines.
        .prefix - source already entered at prompt; filters history list.
        .pointer - index into history.
        .cyclic - wrap around history list (or not).
        '''
        self.text = text
        self.history = []
        self.prefix = None
        self.pointer = None
        self.cyclic = idleConf.GetOption("main", "History", "cyclic", 1, "bool")
        text.bind("<<history-previous>>", self.history_prev)
        text.bind("<<history-next>>", self.history_next)

    def history_next(self, event):
        "Fetch later statement; start with ealiest if cyclic."
        self.fetch(reverse=False)
        return "break"

    def history_prev(self, event):
        "Fetch earlier statement; start with most recent."
        self.fetch(reverse=True)
        return "break"

    def fetch(self, reverse):
        '''Fetch statememt and replace current line in text widget.

        Set prefix and pointer as needed for successive fetches.
        Reset them to None, None when returning to the start line.
        Sound bell when return to start line or cannot leave a line
        because cyclic is False.
        '''
        nhist = len(self.history)
        pointer = self.pointer
        prefix = self.prefix
        if pointer is not None and prefix is not None:
            if self.text.compare("insert", "!=", "end-1c") or \
                    self.text.get("iomark", "end-1c") != self.history[pointer]:
                pointer = prefix = None
                self.text.mark_set("insert", "end-1c")  # != after cursor move
        if pointer is None or prefix is None:
            prefix = self.text.get("iomark", "end-1c")
            if reverse:
                pointer = nhist  # will be decremented
            else:
                if self.cyclic:
                    pointer = -1  # will be incremented
                else:  # abort history_next
                    self.text.bell()
                    return
        nprefix = len(prefix)
        while 1:
            pointer += -1 if reverse else 1
            if pointer < 0 or pointer >= nhist:
                self.text.bell()
                if not self.cyclic and pointer < 0:  # abort history_prev
                    return
                else:
                    if self.text.get("iomark", "end-1c") != prefix:
                        self.text.delete("iomark", "end-1c")
                        self.text.insert("iomark", prefix)
                    pointer = prefix = None
                break
            item = self.history[pointer]
            if item[:nprefix] == prefix and len(item) > nprefix:
                self.text.delete("iomark", "end-1c")
                self.text.insert("iomark", item)
                break
        self.text.see("insert")
        self.text.tag_remove("sel", "1.0", "end")
        self.pointer = pointer
        self.prefix = prefix

    def store(self, source):
        "Store Shell input statement into history list."
        source = source.strip()
        if len(source) > 2:
            # avoid duplicates
            try:
                self.history.remove(source)
            except ValueError:
                pass
            self.history.append(source)
        self.pointer = None
        self.prefix = None

if __name__ == "__main__":
    from unittest import main
    main('idlelib.idle_test.test_idlehistory', verbosity=2, exit=False)
                                            usr/lib/python3.4/idlelib/MultiCall.py                                                              0100644 0000000 0000000 00000044512 12415221640 016241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
MultiCall - a class which inherits its methods from a Tkinter widget (Text, for
example), but enables multiple calls of functions per virtual event - all
matching events will be called, not only the most specific one. This is done
by wrapping the event functions - event_add, event_delete and event_info.
MultiCall recognizes only a subset of legal event sequences. Sequences which
are not recognized are treated by the original Tk handling mechanism. A
more-specific event will be called before a less-specific event.

The recognized sequences are complete one-event sequences (no emacs-style
Ctrl-X Ctrl-C, no shortcuts like <3>), for all types of events.
Key/Button Press/Release events can have modifiers.
The recognized modifiers are Shift, Control, Option and Command for Mac, and
Control, Alt, Shift, Meta/M for other platforms.

For all events which were handled by MultiCall, a new member is added to the
event instance passed to the binded functions - mc_type. This is one of the
event type constants defined in this module (such as MC_KEYPRESS).
For Key/Button events (which are handled by MultiCall and may receive
modifiers), another member is added - mc_state. This member gives the state
of the recognized modifiers, as a combination of the modifier constants
also defined in this module (for example, MC_SHIFT).
Using these members is absolutely portable.

The order by which events are called is defined by these rules:
1. A more-specific event will be called before a less-specific event.
2. A recently-binded event will be called before a previously-binded event,
   unless this conflicts with the first rule.
Each function will be called at most once for each event.
"""

import sys
import re
import tkinter

# the event type constants, which define the meaning of mc_type
MC_KEYPRESS=0; MC_KEYRELEASE=1; MC_BUTTONPRESS=2; MC_BUTTONRELEASE=3;
MC_ACTIVATE=4; MC_CIRCULATE=5; MC_COLORMAP=6; MC_CONFIGURE=7;
MC_DEACTIVATE=8; MC_DESTROY=9; MC_ENTER=10; MC_EXPOSE=11; MC_FOCUSIN=12;
MC_FOCUSOUT=13; MC_GRAVITY=14; MC_LEAVE=15; MC_MAP=16; MC_MOTION=17;
MC_MOUSEWHEEL=18; MC_PROPERTY=19; MC_REPARENT=20; MC_UNMAP=21; MC_VISIBILITY=22;
# the modifier state constants, which define the meaning of mc_state
MC_SHIFT = 1<<0; MC_CONTROL = 1<<2; MC_ALT = 1<<3; MC_META = 1<<5
MC_OPTION = 1<<6; MC_COMMAND = 1<<7

# define the list of modifiers, to be used in complex event types.
if sys.platform == "darwin":
    _modifiers = (("Shift",), ("Control",), ("Option",), ("Command",))
    _modifier_masks = (MC_SHIFT, MC_CONTROL, MC_OPTION, MC_COMMAND)
else:
    _modifiers = (("Control",), ("Alt",), ("Shift",), ("Meta", "M"))
    _modifier_masks = (MC_CONTROL, MC_ALT, MC_SHIFT, MC_META)

# a dictionary to map a modifier name into its number
_modifier_names = dict([(name, number)
                         for number in range(len(_modifiers))
                         for name in _modifiers[number]])

# In 3.4, if no shell window is ever open, the underlying Tk widget is
# destroyed before .__del__ methods here are called.  The following
# is used to selectively ignore shutdown exceptions to avoid
# 'Exception ignored' messages.  See http://bugs.python.org/issue20167
APPLICATION_GONE = '''\
can't invoke "bind" command:  application has been destroyed'''

# A binder is a class which binds functions to one type of event. It has two
# methods: bind and unbind, which get a function and a parsed sequence, as
# returned by _parse_sequence(). There are two types of binders:
# _SimpleBinder handles event types with no modifiers and no detail.
# No Python functions are called when no events are binded.
# _ComplexBinder handles event types with modifiers and a detail.
# A Python function is called each time an event is generated.

class _SimpleBinder:
    def __init__(self, type, widget, widgetinst):
        self.type = type
        self.sequence = '<'+_types[type][0]+'>'
        self.widget = widget
        self.widgetinst = widgetinst
        self.bindedfuncs = []
        self.handlerid = None

    def bind(self, triplet, func):
        if not self.handlerid:
            def handler(event, l = self.bindedfuncs, mc_type = self.type):
                event.mc_type = mc_type
                wascalled = {}
                for i in range(len(l)-1, -1, -1):
                    func = l[i]
                    if func not in wascalled:
                        wascalled[func] = True
                        r = func(event)
                        if r:
                            return r
            self.handlerid = self.widget.bind(self.widgetinst,
                                              self.sequence, handler)
        self.bindedfuncs.append(func)

    def unbind(self, triplet, func):
        self.bindedfuncs.remove(func)
        if not self.bindedfuncs:
            self.widget.unbind(self.widgetinst, self.sequence, self.handlerid)
            self.handlerid = None

    def __del__(self):
        if self.handlerid:
            try:
                self.widget.unbind(self.widgetinst, self.sequence,
                        self.handlerid)
            except tkinter.TclError as e:
                if e.args[0] == APPLICATION_GONE:
                    pass
                else:
                    raise

# An int in range(1 << len(_modifiers)) represents a combination of modifiers
# (if the least significent bit is on, _modifiers[0] is on, and so on).
# _state_subsets gives for each combination of modifiers, or *state*,
# a list of the states which are a subset of it. This list is ordered by the
# number of modifiers is the state - the most specific state comes first.
_states = range(1 << len(_modifiers))
_state_names = [''.join(m[0]+'-'
                        for i, m in enumerate(_modifiers)
                        if (1 << i) & s)
                for s in _states]

def expand_substates(states):
    '''For each item of states return a list containing all combinations of
    that item with individual bits reset, sorted by the number of set bits.
    '''
    def nbits(n):
        "number of bits set in n base 2"
        nb = 0
        while n:
            n, rem = divmod(n, 2)
            nb += rem
        return nb
    statelist = []
    for state in states:
        substates = list(set(state & x for x in states))
        substates.sort(key=nbits, reverse=True)
        statelist.append(substates)
    return statelist

_state_subsets = expand_substates(_states)

# _state_codes gives for each state, the portable code to be passed as mc_state
_state_codes = []
for s in _states:
    r = 0
    for i in range(len(_modifiers)):
        if (1 << i) & s:
            r |= _modifier_masks[i]
    _state_codes.append(r)

class _ComplexBinder:
    # This class binds many functions, and only unbinds them when it is deleted.
    # self.handlerids is the list of seqs and ids of binded handler functions.
    # The binded functions sit in a dictionary of lists of lists, which maps
    # a detail (or None) and a state into a list of functions.
    # When a new detail is discovered, handlers for all the possible states
    # are binded.

    def __create_handler(self, lists, mc_type, mc_state):
        def handler(event, lists = lists,
                    mc_type = mc_type, mc_state = mc_state,
                    ishandlerrunning = self.ishandlerrunning,
                    doafterhandler = self.doafterhandler):
            ishandlerrunning[:] = [True]
            event.mc_type = mc_type
            event.mc_state = mc_state
            wascalled = {}
            r = None
            for l in lists:
                for i in range(len(l)-1, -1, -1):
                    func = l[i]
                    if func not in wascalled:
                        wascalled[func] = True
                        r = l[i](event)
                        if r:
                            break
                if r:
                    break
            ishandlerrunning[:] = []
            # Call all functions in doafterhandler and remove them from list
            for f in doafterhandler:
                f()
            doafterhandler[:] = []
            if r:
                return r
        return handler

    def __init__(self, type, widget, widgetinst):
        self.type = type
        self.typename = _types[type][0]
        self.widget = widget
        self.widgetinst = widgetinst
        self.bindedfuncs = {None: [[] for s in _states]}
        self.handlerids = []
        # we don't want to change the lists of functions while a handler is
        # running - it will mess up the loop and anyway, we usually want the
        # change to happen from the next event. So we have a list of functions
        # for the handler to run after it finishes calling the binded functions.
        # It calls them only once.
        # ishandlerrunning is a list. An empty one means no, otherwise - yes.
        # this is done so that it would be mutable.
        self.ishandlerrunning = []
        self.doafterhandler = []
        for s in _states:
            lists = [self.bindedfuncs[None][i] for i in _state_subsets[s]]
            handler = self.__create_handler(lists, type, _state_codes[s])
            seq = '<'+_state_names[s]+self.typename+'>'
            self.handlerids.append((seq, self.widget.bind(self.widgetinst,
                                                          seq, handler)))

    def bind(self, triplet, func):
        if triplet[2] not in self.bindedfuncs:
            self.bindedfuncs[triplet[2]] = [[] for s in _states]
            for s in _states:
                lists = [ self.bindedfuncs[detail][i]
                          for detail in (triplet[2], None)
                          for i in _state_subsets[s]       ]
                handler = self.__create_handler(lists, self.type,
                                                _state_codes[s])
                seq = "<%s%s-%s>"% (_state_names[s], self.typename, triplet[2])
                self.handlerids.append((seq, self.widget.bind(self.widgetinst,
                                                              seq, handler)))
        doit = lambda: self.bindedfuncs[triplet[2]][triplet[0]].append(func)
        if not self.ishandlerrunning:
            doit()
        else:
            self.doafterhandler.append(doit)

    def unbind(self, triplet, func):
        doit = lambda: self.bindedfuncs[triplet[2]][triplet[0]].remove(func)
        if not self.ishandlerrunning:
            doit()
        else:
            self.doafterhandler.append(doit)

    def __del__(self):
        for seq, id in self.handlerids:
            try:
                self.widget.unbind(self.widgetinst, seq, id)
            except tkinter.TclError as e:
                if e.args[0] == APPLICATION_GONE:
                    break
                else:
                    raise

# define the list of event types to be handled by MultiEvent. the order is
# compatible with the definition of event type constants.
_types = (
    ("KeyPress", "Key"), ("KeyRelease",), ("ButtonPress", "Button"),
    ("ButtonRelease",), ("Activate",), ("Circulate",), ("Colormap",),
    ("Configure",), ("Deactivate",), ("Destroy",), ("Enter",), ("Expose",),
    ("FocusIn",), ("FocusOut",), ("Gravity",), ("Leave",), ("Map",),
    ("Motion",), ("MouseWheel",), ("Property",), ("Reparent",), ("Unmap",),
    ("Visibility",),
)

# which binder should be used for every event type?
_binder_classes = (_ComplexBinder,) * 4 + (_SimpleBinder,) * (len(_types)-4)

# A dictionary to map a type name into its number
_type_names = dict([(name, number)
                     for number in range(len(_types))
                     for name in _types[number]])

_keysym_re = re.compile(r"^\w+$")
_button_re = re.compile(r"^[1-5]$")
def _parse_sequence(sequence):
    """Get a string which should describe an event sequence. If it is
    successfully parsed as one, return a tuple containing the state (as an int),
    the event type (as an index of _types), and the detail - None if none, or a
    string if there is one. If the parsing is unsuccessful, return None.
    """
    if not sequence or sequence[0] != '<' or sequence[-1] != '>':
        return None
    words = sequence[1:-1].split('-')
    modifiers = 0
    while words and words[0] in _modifier_names:
        modifiers |= 1 << _modifier_names[words[0]]
        del words[0]
    if words and words[0] in _type_names:
        type = _type_names[words[0]]
        del words[0]
    else:
        return None
    if _binder_classes[type] is _SimpleBinder:
        if modifiers or words:
            return None
        else:
            detail = None
    else:
        # _ComplexBinder
        if type in [_type_names[s] for s in ("KeyPress", "KeyRelease")]:
            type_re = _keysym_re
        else:
            type_re = _button_re

        if not words:
            detail = None
        elif len(words) == 1 and type_re.match(words[0]):
            detail = words[0]
        else:
            return None

    return modifiers, type, detail

def _triplet_to_sequence(triplet):
    if triplet[2]:
        return '<'+_state_names[triplet[0]]+_types[triplet[1]][0]+'-'+ \
               triplet[2]+'>'
    else:
        return '<'+_state_names[triplet[0]]+_types[triplet[1]][0]+'>'

_multicall_dict = {}
def MultiCallCreator(widget):
    """Return a MultiCall class which inherits its methods from the
    given widget class (for example, Tkinter.Text). This is used
    instead of a templating mechanism.
    """
    if widget in _multicall_dict:
        return _multicall_dict[widget]

    class MultiCall (widget):
        assert issubclass(widget, tkinter.Misc)

        def __init__(self, *args, **kwargs):
            widget.__init__(self, *args, **kwargs)
            # a dictionary which maps a virtual event to a tuple with:
            #  0. the function binded
            #  1. a list of triplets - the sequences it is binded to
            self.__eventinfo = {}
            self.__binders = [_binder_classes[i](i, widget, self)
                              for i in range(len(_types))]

        def bind(self, sequence=None, func=None, add=None):
            #print("bind(%s, %s, %s)" % (sequence, func, add),
            #      file=sys.__stderr__)
            if type(sequence) is str and len(sequence) > 2 and \
               sequence[:2] == "<<" and sequence[-2:] == ">>":
                if sequence in self.__eventinfo:
                    ei = self.__eventinfo[sequence]
                    if ei[0] is not None:
                        for triplet in ei[1]:
                            self.__binders[triplet[1]].unbind(triplet, ei[0])
                    ei[0] = func
                    if ei[0] is not None:
                        for triplet in ei[1]:
                            self.__binders[triplet[1]].bind(triplet, func)
                else:
                    self.__eventinfo[sequence] = [func, []]
            return widget.bind(self, sequence, func, add)

        def unbind(self, sequence, funcid=None):
            if type(sequence) is str and len(sequence) > 2 and \
               sequence[:2] == "<<" and sequence[-2:] == ">>" and \
               sequence in self.__eventinfo:
                func, triplets = self.__eventinfo[sequence]
                if func is not None:
                    for triplet in triplets:
                        self.__binders[triplet[1]].unbind(triplet, func)
                    self.__eventinfo[sequence][0] = None
            return widget.unbind(self, sequence, funcid)

        def event_add(self, virtual, *sequences):
            #print("event_add(%s, %s)" % (repr(virtual), repr(sequences)),
            #      file=sys.__stderr__)
            if virtual not in self.__eventinfo:
                self.__eventinfo[virtual] = [None, []]

            func, triplets = self.__eventinfo[virtual]
            for seq in sequences:
                triplet = _parse_sequence(seq)
                if triplet is None:
                    #print("Tkinter event_add(%s)" % seq, file=sys.__stderr__)
                    widget.event_add(self, virtual, seq)
                else:
                    if func is not None:
                        self.__binders[triplet[1]].bind(triplet, func)
                    triplets.append(triplet)

        def event_delete(self, virtual, *sequences):
            if virtual not in self.__eventinfo:
                return
            func, triplets = self.__eventinfo[virtual]
            for seq in sequences:
                triplet = _parse_sequence(seq)
                if triplet is None:
                    #print("Tkinter event_delete: %s" % seq, file=sys.__stderr__)
                    widget.event_delete(self, virtual, seq)
                else:
                    if func is not None:
                        self.__binders[triplet[1]].unbind(triplet, func)
                    triplets.remove(triplet)

        def event_info(self, virtual=None):
            if virtual is None or virtual not in self.__eventinfo:
                return widget.event_info(self, virtual)
            else:
                return tuple(map(_triplet_to_sequence,
                                 self.__eventinfo[virtual][1])) + \
                       widget.event_info(self, virtual)

        def __del__(self):
            for virtual in self.__eventinfo:
                func, triplets = self.__eventinfo[virtual]
                if func:
                    for triplet in triplets:
                        try:
                            self.__binders[triplet[1]].unbind(triplet, func)
                        except tkinter.TclError as e:
                            if e.args[0] == APPLICATION_GONE:
                                break
                            else:
                                raise

    _multicall_dict[widget] = MultiCall
    return MultiCall


def _multi_call(parent):
    root = tkinter.Tk()
    root.title("Test MultiCall")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    text = MultiCallCreator(tkinter.Text)(root)
    text.pack()
    def bindseq(seq, n=[0]):
        def handler(event):
            print(seq)
        text.bind("<<handler%d>>"%n[0], handler)
        text.event_add("<<handler%d>>"%n[0], seq)
        n[0] += 1
    bindseq("<Key>")
    bindseq("<Control-Key>")
    bindseq("<Alt-Key-a>")
    bindseq("<Control-Key-a>")
    bindseq("<Alt-Control-Key-a>")
    bindseq("<Key-b>")
    bindseq("<Control-Button-1>")
    bindseq("<Button-2>")
    bindseq("<Alt-Button-1>")
    bindseq("<FocusOut>")
    bindseq("<Enter>")
    bindseq("<Leave>")
    root.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_multi_call)
                                                                                                                                                                                      usr/lib/python3.4/idlelib/MultiStatusBar.py                                                         0100644 0000000 0000000 00000002364 12415221640 017275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *

class MultiStatusBar(Frame):

    def __init__(self, master=None, **kw):
        if master is None:
            master = Tk()
        Frame.__init__(self, master, **kw)
        self.labels = {}

    def set_label(self, name, text='', side=LEFT):
        if name not in self.labels:
            label = Label(self, bd=1, relief=SUNKEN, anchor=W)
            label.pack(side=side)
            self.labels[name] = label
        else:
            label = self.labels[name]
        label.config(text=text)

def _multistatus_bar(parent):
    root = Tk()
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d" %(x, y + 150))
    root.title("Test multistatus bar")
    frame = Frame(root)
    text = Text(frame)
    text.pack()
    msb = MultiStatusBar(frame)
    msb.set_label("one", "hello")
    msb.set_label("two", "world")
    msb.pack(side=BOTTOM, fill=X)

    def change():
        msb.set_label("one", "foo")
        msb.set_label("two", "bar")

    button = Button(root, text="Update status", command=change)
    button.pack(side=BOTTOM)
    frame.pack()
    frame.mainloop()
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_multistatus_bar)
                                                                                                                                                                                                                                                                            usr/lib/python3.4/idlelib/NEWS.txt                                                                  0100644 0000000 0000000 00000103031 12415221640 015306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        What's New in IDLE 3.4.2?
=========================

- Issue #17390: Adjust Editor window title; remove 'Python',
  move version to end.

- Issue #14105: Idle debugger breakpoints no longer disappear
  when inseting or deleting lines.

- Issue #17172: Turtledemo can now be run from Idle.
  Currently, the entry is on the Help menu, but it may move to Run.
  Patch by Ramchandra Apt and Lita Cho.

- Issue #21765: Add support for non-ascii identifiers to HyperParser.

- Issue #21940: Add unittest for WidgetRedirector. Initial patch by Saimadhav
  Heblikar.

- Issue #18592: Add unittest for SearchDialogBase. Patch by Phil Webster.

- Issue #21694: Add unittest for ParenMatch. Patch by Saimadhav Heblikar.

- Issue #21686: add unittest for HyperParser. Original patch by Saimadhav
  Heblikar.

- Issue #12387: Add missing upper(lower)case versions of default Windows key
  bindings for Idle so Caps Lock does not disable them. Patch by Roger Serwy.

- Issue #21695: Closing a Find-in-files output window while the search is
  still in progress no longer closes Idle.

- Issue #18910: Add unittest for textView. Patch by Phil Webster.

- Issue #18292: Add unittest for AutoExpand. Patch by Saihadhav Heblikar.

- Issue #18409: Add unittest for AutoComplete. Patch by Phil Webster.

- Issue #18104: Add idlelib/idle_test/htest.py with a few sample tests to begin
  consolidating and improving human-validated tests of Idle. Change other files
  as needed to work with htest.  Running the module as __main__ runs all tests.


What's New in IDLE 3.4.1?
=========================

- Issue #18104: Add idlelib/idle_test/htest.py with a few sample tests to begin
  consolidating and improving human-validated tests of Idle. Change other files
  as needed to work with htest.  Running the module as __main__ runs all tests.

- Issue #21139: Change default paragraph width to 72, the PEP 8 recommendation.

- Issue #21284: Paragraph reformat test passes after user changes reformat width.

- Issue #17654: Ensure IDLE menus are customized properly on OS X for
  non-framework builds and for all variants of Tk.


What's New in IDLE 3.4.0?
=========================

- Issue #17390: Display Python version on Idle title bar.
  Initial patch by Edmond Burnett.

- Issue #5066: Update IDLE docs. Patch by Todd Rovito.

- Issue #17625: Close the replace dialog after it is used.

- Issue #16226: Fix IDLE Path Browser crash.
  (Patch by Roger Serwy)

- Issue #15853: Prevent IDLE crash on OS X when opening Preferences menu
  with certain versions of Tk 8.5.  Initial patch by Kevin Walzer.


What's New in IDLE 3.3.0?
=========================

- Issue #17625: Close the replace dialog after it is used.

- Issue #7163: Propagate return value of sys.stdout.write.

- Issue #15318: Prevent writing to sys.stdin.

- Issue #4832: Modify IDLE to save files with .py extension by
  default on Windows and OS X (Tk 8.5) as it already does with X11 Tk.

- Issue #13532, #15319: Check that arguments to sys.stdout.write are strings.

- Issue # 12510: Attempt to get certain tool tips no longer crashes IDLE.
  Erroneous tool tips have been corrected. Default added for callables.

- Issue10365: File open dialog now works instead of crashing even when
  parent window is closed while dialog is open.

- Issue 14876: use user-selected font for highlight configuration.

- Issue #14937: Perform auto-completion of filenames in strings even for
  non-ASCII filenames. Likewise for identifiers.

- Issue #8515: Set __file__ when run file in IDLE.
  Initial patch by Bruce Frederiksen.

- IDLE can be launched as `python -m idlelib`

- Issue #14409: IDLE now properly executes commands in the Shell window
  when it cannot read the normal config files on startup and
  has to use the built-in default key bindings.
  There was previously a bug in one of the defaults.

- Issue #3573: IDLE hangs when passing invalid command line args
  (directory(ies) instead of file(s)).

- Issue #14018: Update checks for unstable system Tcl/Tk versions on OS X
  to include versions shipped with OS X 10.7 and 10.8 in addition to 10.6.


What's New in IDLE 3.2.1?
=========================

*Release date: 15-May-11*

- Issue #6378: Further adjust idle.bat to start associated Python

- Issue #11896: Save on Close failed despite selecting "Yes" in dialog.

- Issue #1028: Ctrl-space binding to show completions was causing IDLE to exit.
  Tk < 8.5 was sending invalid Unicode null; replaced with valid null.

- <Home> toggle failing on Tk 8.5, causing IDLE exits and strange selection
  behavior. Issue 4676.  Improve selection extension behaviour.

- <Home> toggle non-functional when NumLock set on Windows.  Issue 3851.


What's New in IDLE 3.1b1?
=========================

*Release date: 06-May-09*

- Use of 'filter' in keybindingDialog.py was causing custom key assignment to
  fail.  Patch 5707 amaury.forgeotdarc.


What's New in IDLE 3.1a1?
=========================

*Release date: 07-Mar-09*

- Issue #4815: Offer conversion to UTF-8 if source files have
  no encoding declaration and are not encoded in UTF-8.

- Issue #4008: Fix problems with non-ASCII source files.

- Issue #4323: Always encode source as UTF-8 without asking
  the user (unless a different encoding is declared); remove
  user configuration of source encoding; all according to
  PEP 3120.

- Issue #2665: On Windows, an IDLE installation upgraded from an old version
  would not start if a custom theme was defined.

What's New in IDLE 2.7? (UNRELEASED, but merged into 3.1 releases above.)
=======================

*Release date: XX-XXX-2010*

- idle.py modified and simplified to better support developing experimental
  versions of IDLE which are not installed in the standard location.

- OutputWindow/PyShell right click menu "Go to file/line" wasn't working with
  file paths containing spaces.  Bug 5559.

- Windows: Version string for the .chm help file changed, file not being
  accessed  Patch 5783 Guilherme Polo

- Allow multiple IDLE GUI/subprocess pairs to exist simultaneously. Thanks to
  David Scherer for suggesting the use of an ephemeral port for the GUI.
  Patch 1529142 Weeble.

- Remove port spec from run.py and fix bug where subprocess fails to
  extract port from command line when warnings are present.

- Tk 8.5 Text widget requires 'wordprocessor' tabstyle attr to handle
  mixed space/tab properly. Issue 5129, patch by Guilherme Polo.

- Issue #3549: On MacOS the preferences menu was not present

What's New in IDLE 3.0 final?
=============================

*Release date: 03-Dec-2008*

- IDLE would print a "Unhandled server exception!" message when internal
  debugging is enabled.

- Issue #4455: IDLE failed to display the windows list when two windows have
  the same title.

- Issue #4383: When IDLE cannot make the connection to its subprocess, it would
  fail to properly display the error message.


What's New in IDLE 3.0a3?
=========================

*Release date: 29-Feb-2008*

- help() was not paging to the shell.  Issue1650.

- CodeContext was not importing.

- Corrected two 3.0 compatibility errors reported by Mark Summerfield:
  http://mail.python.org/pipermail/python-3000/2007-December/011491.html

- Shell was not colorizing due to bug introduced at r57998,  Bug 1586.

- Issue #1585: IDLE uses non-existent xrange() function.


What's New in IDLE 3.0a2?
=========================

*Release date: 06-Dec-2007*

- Windows EOL sequence not converted correctly, encoding error.
  Caused file save to fail. Bug 1130.


What's New in IDLE 3.0a1?
=========================

*Release date: 31-Aug-2007*

- IDLE converted to Python 3000 syntax.

- Strings became Unicode.

- CallTips module now uses the inspect module to produce the argspec.

- IDLE modules now use absolute import instead of implied relative import.

- atexit call replaces sys.exitfunc.  The functionality of delete-exitfunc flag
  in config-main.cfg remains unchanged: if set, registered exit functions will
  be cleared before IDLE exits.


What's New in IDLE 2.6 final?
=============================

*Release date: 01-Oct-2008*, merged into 3.0 releases detailed above (3.0rc2)

- Issue #2665: On Windows, an IDLE installation upgraded from an old version
  would not start if a custom theme was defined.

- Home / Control-A toggles between left margin and end of leading white
  space.  issue1196903, patch by Jeff Shute.

- Improved AutoCompleteWindow logic.  issue2062, patch by Tal Einat.

- Autocompletion of filenames now support alternate separators, e.g. the
  '/' char on Windows.  issue2061 Patch by Tal Einat.

- Configured selection highlighting colors were ignored; updating highlighting
  in the config dialog would cause non-Python files to be colored as if they
  were Python source; improve use of ColorDelagator.  Patch 1334. Tal Einat.

- ScriptBinding event handlers weren't returning 'break'. Patch 2050, Tal Einat

- There was an error on exit if no sys.exitfunc was defined. Issue 1647.

- Could not open files in .idlerc directory if latter was hidden on Windows.
  Issue 1743, Issue 1862.

- Configure Dialog: improved layout for keybinding.  Patch 1457 Tal Einat.

- tabpage.py updated: tabbedPages.py now supports multiple dynamic rows
  of tabs.  Patch 1612746 Tal Einat.

- Add confirmation dialog before printing.  Patch 1717170 Tal Einat.

- Show paste position if > 80 col.  Patch 1659326 Tal Einat.

- Update cursor color without restarting.  Patch 1725576 Tal Einat.

- Allow keyboard interrupt only when user code is executing in subprocess.
  Patch 1225 Tal Einat (reworked from IDLE-Spoon).

- configDialog cleanup. Patch 1730217 Tal Einat.

- textView cleanup. Patch 1718043 Tal Einat.

- Clean up EditorWindow close.

- Patch 1693258: Fix for duplicate "preferences" menu-OS X. Backport of r56204.

- OSX: Avoid crash for those versions of Tcl/Tk which don't have a console

- Bug in idlelib.MultiCall: Options dialog was crashing IDLE if there was an
  option in config-extensions w/o a value. Patch #1672481, Tal Einat

- Corrected some bugs in AutoComplete.  Also, Page Up/Down in ACW implemented;
  mouse and cursor selection in ACWindow implemented; double Tab inserts
  current selection and closes ACW (similar to double-click and Return); scroll
  wheel now works in ACW.  Added AutoComplete instructions to IDLE Help.

- AutoCompleteWindow moved below input line, will move above if there
  isn't enough space.  Patch 1621265 Tal Einat

- Calltips now 'handle' tuples in the argument list (display '<tuple>' :)
  Suggested solution by Christos Georgiou, Bug 791968.

- Add 'raw' support to configHandler. Patch 1650174 Tal Einat.

- Avoid hang when encountering a duplicate in a completion list. Bug 1571112.

- Patch #1362975: Rework CodeContext indentation algorithm to
  avoid hard-coding pixel widths.

- Bug #813342: Start the IDLE subprocess with -Qnew if the parent
  is started with that option.

- Honor the "Cancel" action in the save dialog (Debian bug #299092)

- Some syntax errors were being caught by tokenize during the tabnanny
  check, resulting in obscure error messages.  Do the syntax check
  first.  Bug 1562716, 1562719

- IDLE's version number takes a big jump to match the version number of
  the Python release of which it's a part.


What's New in IDLE 1.2?
=======================

*Release date: 19-SEP-2006*


What's New in IDLE 1.2c1?
=========================

*Release date: 17-AUG-2006*

- File menu hotkeys: there were three 'p' assignments.  Reassign the
  'Save Copy As' and 'Print' hotkeys to 'y' and 't'.  Change the
  Shell hotkey from 's' to 'l'.

- IDLE honors new quit() and exit() commands from site.py Quitter() object.
  Patch 1540892, Jim Jewett

- The 'with' statement is now a Code Context block opener.
  Patch 1540851, Jim Jewett

- Retrieval of previous shell command was not always preserving indentation
  (since 1.2a1) Patch 1528468 Tal Einat.

- Changing tokenize (39046) to detect dedent broke tabnanny check (since 1.2a1)

- ToggleTab dialog was setting indent to 8 even if cancelled (since 1.2a1).

- When used w/o subprocess, all exceptions were preceded by an error
  message claiming they were IDLE internal errors (since 1.2a1).

What's New in IDLE 1.2b3?
=========================

*Release date: 03-AUG-2006*

- Bug #1525817: Don't truncate short lines in IDLE's tool tips.

- Bug #1517990: IDLE keybindings on MacOS X now work correctly

- Bug #1517996: IDLE now longer shows the default Tk menu when a
  path browser, class browser or debugger is the frontmost window on MacOS X

- EditorWindow.test() was failing.  Bug 1417598

- EditorWindow failed when used stand-alone if sys.ps1 not set.
  Bug 1010370 Dave Florek

- Tooltips failed on new-syle class __init__ args.  Bug 1027566 Loren Guthrie

- Avoid occasional failure to detect closing paren properly.
  Patch 1407280 Tal Einat

- Rebinding Tab key was inserting 'tab' instead of 'Tab'.  Bug 1179168.

- Colorizer now handles #<builtin> correctly, also unicode strings and
  'as' keyword in comment directly following import command. Closes 1325071.
  Patch 1479219 Tal Einat

What's New in IDLE 1.2b2?
=========================

*Release date: 11-JUL-2006*

What's New in IDLE 1.2b1?
=========================

*Release date: 20-JUN-2006*

What's New in IDLE 1.2a2?
=========================

*Release date: 27-APR-2006*

What's New in IDLE 1.2a1?
=========================

*Release date: 05-APR-2006*

- Patch #1162825: Support non-ASCII characters in IDLE window titles.

- Source file f.flush() after writing; trying to avoid lossage if user
  kills GUI.

- Options / Keys / Advanced dialog made functional.  Also, allow binding
  of 'movement' keys.

- 'syntax' patch adds improved calltips and a new class attribute listbox.
  MultiCall module allows binding multiple actions to an event.
  Patch 906702 Noam Raphael

- Better indentation after first line of string continuation.
  IDLEfork Patch 681992, Noam Raphael

- Fixed CodeContext alignment problem, following suggestion from Tal Einat.

- Increased performance in CodeContext extension  Patch 936169 Noam Raphael

- Mac line endings were incorrect when pasting code from some browsers
  when using X11 and the Fink distribution.  Python Bug 1263656.

- <Enter> when cursor is on a previous command retrieves that command.  Instead
  of replacing the input line, the previous command is now appended to the
  input line. Indentation is preserved, and undo is enabled.
  Patch 1196917  Jeff Shute

- Clarify "tab/space" Error Dialog and "Tab Width" Dialog associated with
  the Untabify command.

- Corrected "tab/space" Error Dialog to show correct menu for Untabify.
  Patch 1196980 Jeff Shute

- New files are colorized by default, and colorizing is removed when
  saving as non-Python files. Patch 1196895 Jeff Shute
  Closes Python Bugs 775012 and 800432, partial fix IDLEfork 763524

- Improve subprocess link error notification.

- run.py: use Queue's blocking feature instead of sleeping in the main
  loop.  Patch # 1190163 Michiel de Hoon

- Add config-main option to make the 'history' feature non-cyclic.
  Default remains cyclic.  Python Patch 914546 Noam Raphael.

- Removed ability to configure tabs indent from Options dialog.  This 'feature'
  has never worked and no one has complained.  It is still possible to set a
  default tabs (v. spaces) indent 'manually' via config-main.def (or to turn on
  tabs for the current EditorWindow via the Format menu) but IDLE will
  encourage indentation via spaces.

- Enable setting the indentation width using the Options dialog.
  Bug # 783877

- Add keybindings for del-word-left and del-word-right.

- Discourage using an indent width other than 8 when using tabs to indent
  Python code.

- Restore use of EditorWindow.set_indentation_params(), was dead code since
  Autoindent was merged into EditorWindow.  This allows IDLE to conform to the
  indentation width of a loaded file.  (But it still will not switch to tabs
  even if the file uses tabs.)  Any change in indent width is local to that
  window.

- Add Tabnanny check before Run/F5, not just when Checking module.

- If an extension can't be loaded, print warning and skip it instead of
  erroring out.

- Improve error handling when .idlerc can't be created (warn and exit).

- The GUI was hanging if the shell window was closed while a raw_input()
  was pending.  Restored the quit() of the readline() mainloop().
  http://mail.python.org/pipermail/idle-dev/2004-December/002307.html

- The remote procedure call module rpc.py can now access data attributes of
  remote registered objects.  Changes to these attributes are local, however.

What's New in IDLE 1.1?
=======================

*Release date: 30-NOV-2004*

- On OpenBSD, terminating IDLE with ctrl-c from the command line caused a
  stuck subprocess MainThread because only the SocketThread was exiting.

What's New in IDLE 1.1b3/rc1?
=============================

*Release date: 18-NOV-2004*

- Saving a Keyset w/o making changes (by using the "Save as New Custom Key Set"
  button) caused IDLE to fail on restart (no new keyset was created in
  config-keys.cfg).  Also true for Theme/highlights.  Python Bug 1064535.

- A change to the linecache.py API caused IDLE to exit when an exception was
  raised while running without the subprocess (-n switch).  Python Bug 1063840.

What's New in IDLE 1.1b2?
=========================

*Release date: 03-NOV-2004*

- When paragraph reformat width was made configurable, a bug was
  introduced that caused reformatting of comment blocks to ignore how
  far the block was indented, effectively adding the indentation width
  to the reformat width.  This has been repaired, and the reformat
  width is again a bound on the total width of reformatted lines.

What's New in IDLE 1.1b1?
=========================

*Release date: 15-OCT-2004*


What's New in IDLE 1.1a3?
=========================

*Release date: 02-SEP-2004*

- Improve keyboard focus binding, especially in Windows menu.  Improve
  window raising, especially in the Windows menu and in the debugger.
  IDLEfork 763524.

- If user passes a non-existent filename on the commandline, just
  open a new file, don't raise a dialog.  IDLEfork 854928.


What's New in IDLE 1.1a2?
=========================

*Release date: 05-AUG-2004*

- EditorWindow.py was not finding the .chm help file on Windows.  Typo
  at Rev 1.54.  Python Bug 990954

- checking sys.platform for substring 'win' was breaking IDLE docs on Mac
  (darwin).  Also, Mac Safari browser requires full file:// URIs.  SF 900580.


What's New in IDLE 1.1a1?
=========================

*Release date: 08-JUL-2004*

- Redirect the warning stream to the shell during the ScriptBinding check of
  user code and format the warning similarly to an exception for both that
  check and for runtime warnings raised in the subprocess.

- CodeContext hint pane visibility state is now persistent across sessions.
  The pane no longer appears in the shell window.  Added capability to limit
  extensions to shell window or editor windows.  Noam Raphael addition
  to Patch 936169.

- Paragraph reformat width is now a configurable parameter in the
  Options GUI.

- New Extension: CodeContext.  Provides block structuring hints for code
  which has scrolled above an edit window. Patch 936169 Noam Raphael.

- If nulls somehow got into the strings in recent-files.lst
  EditorWindow.update_recent_files_list() was failing.  Python Bug 931336.

- If the normal background is changed via Configure/Highlighting, it will
  update immediately, thanks to the previously mentioned patch by Nigel Rowe.

- Add a highlight theme for builtin keywords.  Python Patch 805830 Nigel Rowe
  This also fixed IDLEfork bug [ 693418 ] Normal text background color not
  refreshed and Python bug [897872 ] Unknown color name on HP-UX

- rpc.py:SocketIO - Large modules were generating large pickles when downloaded
  to the execution server.  The return of the OK response from the subprocess
  initialization was interfering and causing the sending socket to be not
  ready.  Add an IO ready test to fix this.  Moved the polling IO ready test
  into pollpacket().

- Fix typo in rpc.py, s/b "pickle.PicklingError" not "pickle.UnpicklingError".

- Added a Tk error dialog to run.py inform the user if the subprocess can't
  connect to the user GUI process.  Added a timeout to the GUI's listening
  socket.  Added Tk error dialogs to PyShell.py to announce a failure to bind
  the port or connect to the subprocess.  Clean up error handling during
  connection initiation phase.  This is an update of Python Patch 778323.

- Print correct exception even if source file changed since shell was
  restarted.  IDLEfork Patch 869012 Noam Raphael

- Keybindings with the Shift modifier now work correctly.  So do bindings which
  use the Space key.  Limit unmodified user keybindings to the function keys.
  Python Bug 775353, IDLEfork Bugs 755647, 761557

- After an exception, run.py was not setting the exception vector. Noam
  Raphael suggested correcting this so pdb's postmortem pm() would work.
  IDLEfork Patch 844675

- IDLE now does not fail to save the file anymore if the Tk buffer is not a
  Unicode string, yet eol_convention is.  Python Bugs 774680, 788378

- IDLE didn't start correctly when Python was installed in "Program Files" on
  W2K and XP.  Python Bugs 780451, 784183

- config-main.def documentation incorrectly referred to idle- instead of
  config-  filenames.  SF 782759  Also added note about .idlerc location.


What's New in IDLE 1.0?
=======================

*Release date: 29-Jul-2003*

- Added a banner to the shell discussing warnings possibly raised by personal
  firewall software.  Added same comment to README.txt.


What's New in IDLE 1.0 release candidate 2?
===========================================

*Release date: 24-Jul-2003*

- Calltip error when docstring was None  Python Bug 775541


What's New in IDLE 1.0 release candidate 1?
===========================================

*Release date: 18-Jul-2003*

- Updated extend.txt, help.txt, and config-extensions.def to correctly
  reflect the current status of the configuration system.  Python Bug 768469

- Fixed: Call Tip Trimming May Loop Forever. Python Patch 769142 (Daniels)

- Replaced apply(f, args, kwds) with f(*args, **kwargs) to improve performance
  Python Patch 768187

- Break or continue statements outside a loop were causing IDLE crash
  Python Bug 767794

- Convert Unicode strings from readline to IOBinding.encoding.  Also set
  sys.std{in|out|err}.encoding, for both the local and the subprocess case.
  SF IDLEfork patch 682347.


What's New in IDLE 1.0b2?
=========================

*Release date: 29-Jun-2003*

- Extend AboutDialog.ViewFile() to support file encodings.  Make the CREDITS
  file Latin-1.

- Updated the About dialog to reflect re-integration into Python.  Provide
  buttons to display Python's NEWS, License, and Credits, plus additional
  buttons for IDLE's README and NEWS.

- TextViewer() now has a third parameter which allows inserting text into the
  viewer instead of reading from a file.

- (Created the .../Lib/idlelib directory in the Python CVS, which is a clone of
  IDLEfork modified to install in the Python environment.  The code in the
  interrupt module has been moved to thread.interrupt_main(). )

- Printing the Shell window was failing if it was not saved first SF 748975

- When using the Search in Files dialog, if the user had a selection
  highlighted in his Editor window, insert it into the dialog search field.

- The Python Shell entry was disappearing from the Windows menu.

- Update the Windows file list when a file name change occurs

- Change to File / Open Module: always pop up the dialog, using the current
  selection as the default value.  This is easier to use habitually.

- Avoided a problem with starting the subprocess when 'localhost' doesn't
  resolve to the user's loopback interface.  SF 747772

- Fixed an issue with highlighted errors never de-colorizing.  SF 747677.  Also
  improved notification of Tabnanny Token Error.

- File / New will by default save in the directory of the Edit window from
  which it was initiated.  SF 748973 Guido van Rossum patch.


What's New in IDLEfork 0.9b1?
=============================

*Release date: 02-Jun-2003*

- The current working directory of the execution environment (and shell
  following completion of execution) is now that of the module being run.

- Added the delete-exitfunc option to config-main.def.  (This option is not
  included in the Options dialog.)  Setting this to True (the default) will
  cause IDLE to not run sys.exitfunc/atexit when the subprocess exits.

- IDLE now preserves the line ending codes when editing a file produced on
  a different platform. SF 661759,  SF 538584

- Reduced default editor font size to 10 point and increased window height
  to provide a better initial impression on Windows.

- Options / Fonts/Tabs / Set Base Editor Font: List box was not highlighting
  the default font when first installed on Windows.  SF 661676

- Added Autosave feature: when user runs code from edit window, if the file
  has been modified IDLE will silently save it if Autosave is enabled.  The
  option is set in the Options dialog, and the default is to prompt the
  user to save the file.   SF 661318 Bruce Sherwood patch.

- Improved the RESTART annotation in the shell window when the user restarts
  the shell while it is generating output.  Also improved annotation when user
  repeatedly hammers the Ctrl-F6 restart.

- Allow IDLE to run when not installed and cwd is not the IDLE directory
  SF Patch 686254 "Run IDLEfork from any directory without set-up" - Raphael

- When a module is run from an EditorWindow: if its directory is not in
  sys.path, prepend it.  This allows the module to import other modules in
  the same directory.  Do the same for a script run from the command line.

- Correctly restart the subprocess if it is running user code and the user
  attempts to run some other module or restarts the shell.  Do the same if
  the link is broken and it is possible to restart the subprocess and re-
  connect to the GUI.   SF RFE 661321.

- Improved exception reporting when running commands or scripts from the
  command line.

- Added a -n command line switch to start IDLE without the subprocess.
  Removed the Shell menu when running in that mode.  Updated help messages.

- Added a comment to the shell startup header to indicate when IDLE is not
  using the subprocess.

- Restore the ability to run without the subprocess.  This can be important for
  some platforms or configurations.  (Running without the subprocess allows the
  debugger to trace through parts of IDLE itself, which may or may not be
  desirable, depending on your point of view.  In addition, the traditional
  reload/import tricks must be use if user source code is changed.)  This is
  helpful for developing IDLE using IDLE, because one instance can be used to
  edit the code and a separate instance run to test changes.  (Multiple
  concurrent IDLE instances with subprocesses is a future feature)

- Improve the error message a user gets when saving a file with non-ASCII
  characters and no source encoding is specified.  Done by adding a dialog
  'EncodingMessage', which contains the line to add in a fixed-font entry
  widget, and which has a button to add that line to the file automatically.
  Also, add a configuration option 'EditorWindow/encoding', which has three
  possible values: none, utf-8, and locale. None is the default: IDLE will show
  this dialog when non-ASCII characters are encountered. utf-8 means that files
  with non-ASCII characters are saved as utf-8-with-bom. locale means that
  files are saved in the locale's encoding; the dialog is only displayed if the
  source contains characters outside the locale's charset.  SF 710733 - Loewis

- Improved I/O response by tweaking the wait parameter in various
  calls to signal.signal().

- Implemented a threaded subprocess which allows interrupting a pass
  loop in user code using the 'interrupt' extension.  User code runs
  in MainThread, while the RPCServer is handled by SockThread.  This is
  necessary because Windows doesn't support signals.

- Implemented the 'interrupt' extension module, which allows a subthread
  to raise a KeyboardInterrupt in the main thread.

- Attempting to save the shell raised an error related to saving
  breakpoints, which are not implemented in the shell

- Provide a correct message when 'exit' or 'quit' are entered at the
  IDLE command prompt  SF 695861

- Eliminate extra blank line in shell output caused by not flushing
  stdout when user code ends with an unterminated print. SF 695861

- Moved responsibility for exception formatting (i.e. pruning IDLE internal
  calls) out of rpc.py into the client and server.

- Exit IDLE cleanly even when doing subprocess I/O

- Handle subprocess interrupt with an RPC message.

- Restart the subprocess if it terminates itself. (VPython programs do that)

- Support subclassing of exceptions, including in the shell, by moving the
  exception formatting to the subprocess.



What's New in IDLEfork 0.9 Alpha 2?
===================================

*Release date: 27-Jan-2003*

- Updated INSTALL.txt to claify use of the python2 rpm.

- Improved formatting in IDLE Help.

- Run menu: Replace "Run Script" with "Run Module".

- Code encountering an unhandled exception under the debugger now shows
  the correct traceback, with IDLE internal levels pruned out.

- If an exception occurs entirely in IDLE, don't prune the IDLE internal
  modules from the traceback displayed.

- Class Browser and Path Browser now use Alt-Key-2 for vertical zoom.

- IDLE icons will now install correctly even when setup.py is run from the
  build directory

- Class Browser now compatible with Python2.3 version of pyclbr.py

- Left cursor move in presence of selected text now moves from left end
  of the selection.

- Add Meta keybindings to "IDLE Classic Windows" to handle reversed
  Alt/Meta on some Linux distros.

- Change default: IDLE now starts with Python Shell.

- Removed the File Path from the Additional Help Sources scrolled list.

- Add capability to access Additional Help Sources on the web if the
  Help File Path begins with //http or www.  (Otherwise local path is
  validated, as before.)

- Additional Help Sources were not being posted on the Help menu in the
  order entered.  Implement sorting the list by [HelpFiles] 'option'
  number.

- Add Browse button to New Help Source dialog.  Arrange to start in
  Python/Doc if platform is Windows, otherwise start in current directory.

- Put the Additional Help Sources directly on the Help menu instead of in
  an Extra Help cascade menu.  Rearrange the Help menu so the Additional
  Help Sources come last.  Update help.txt appropriately.

- Fix Tk root pop-ups in configSectionNameDialog.py  and configDialog.py

- Uniform capitalization in General tab of ConfigDialog, update the doc string.

- Fix bug in ConfigDialog where SaveAllChangedConfig() was unexpectedly
  deleting Additional Help Sources from the user's config file.

- Make configHelpSourceEdit OK button the default and bind <Return>

- Fix Tk root pop-ups in configHelpSourceEdit: error dialogs not attached
  to parents.

- Use os.startfile() to open both Additional Help and Python Help on the
  Windows platform.  The application associated with the file type will act as
  the viewer.  Windows help files (.chm) are now supported via the
  Settings/General/Additional Help facility.

- If Python Help files are installed locally on Linux, use them instead of
  accessing python.org.

- Make the methods for finding the Python help docs more robust, and make
  them work in the installed configuration, also.

- On the Save Before Run dialog, make the OK button the default.  One
  less mouse action!

- Add a method: EditorWindow.get_geometry() for future use in implementing
  window location persistence.

- Removed the "Help/Advice" menu entry.  Thanks, David!  We'll remember!

- Change the "Classic Windows" theme's paste key to be <ctrl-v>.

- Rearrange the Shell menu to put Stack Viewer entries adjacent.

- Add the ability to restart the subprocess interpreter from the shell window;
  add an associated menu entry "Shell/Restart" with binding Control-F6.  Update
  IDLE help.

- Upon a restart, annotate the shell window with a "restart boundary".  Add a
  shell window menu "Shell/View Restart" with binding F6 to jump to the most
  recent restart boundary.

- Add Shell menu to Python Shell; change "Settings" to "Options".

- Remove incorrect comment in setup.py: IDLEfork is now installed as a package.

- Add INSTALL.txt, HISTORY.txt, NEWS.txt to installed configuration.

- In installer text, fix reference to Visual Python, should be VPython.
  Properly credit David Scherer.

- Modified idle, idle.py, idle.pyw to improve exception handling.


What's New in IDLEfork 0.9 Alpha 1?
===================================

*Release date: 31-Dec-2002*

- First release of major new functionality.  For further details refer to
  Idle-dev and/or the Sourceforge CVS.

- Adapted to the Mac platform.

- Overhauled the IDLE startup options and revised the idle -h help message,
  which provides details of command line usage.

- Multiple bug fixes and usability enhancements.

- Introduced the new RPC implementation, which includes a debugger.  The output
  of user code is to the shell, and the shell may be used to inspect the
  environment after the run has finished.  (In version 0.8.1 the shell
  environment was separate from the environment of the user code.)

- Introduced the configuration GUI and a new About dialog.

- Removed David Scherer's Remote Procedure Call code and replaced with Guido
  van Rossum's.  GvR code has support for the IDLE debugger and uses the shell
  to inspect the environment of code Run from an Edit window.  Files removed:
  ExecBinding.py, loader.py, protocol.py, Remote.py, spawn.py

--------------------------------------------------------------------
Refer to HISTORY.txt for additional information on earlier releases.
--------------------------------------------------------------------
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/ObjectBrowser.py                                                          0100644 0000000 0000000 00000007607 12415221640 017131  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # XXX TO DO:
# - popup menu
# - support partial or total redisplay
# - more doc strings
# - tooltips

# object browser

# XXX TO DO:
# - for classes/modules, add "open source" to object browser

import re

from idlelib.TreeWidget import TreeItem, TreeNode, ScrolledCanvas

from reprlib import Repr

myrepr = Repr()
myrepr.maxstring = 100
myrepr.maxother = 100

class ObjectTreeItem(TreeItem):
    def __init__(self, labeltext, object, setfunction=None):
        self.labeltext = labeltext
        self.object = object
        self.setfunction = setfunction
    def GetLabelText(self):
        return self.labeltext
    def GetText(self):
        return myrepr.repr(self.object)
    def GetIconName(self):
        if not self.IsExpandable():
            return "python"
    def IsEditable(self):
        return self.setfunction is not None
    def SetText(self, text):
        try:
            value = eval(text)
            self.setfunction(value)
        except:
            pass
        else:
            self.object = value
    def IsExpandable(self):
        return not not dir(self.object)
    def GetSubList(self):
        keys = dir(self.object)
        sublist = []
        for key in keys:
            try:
                value = getattr(self.object, key)
            except AttributeError:
                continue
            item = make_objecttreeitem(
                str(key) + " =",
                value,
                lambda value, key=key, object=self.object:
                    setattr(object, key, value))
            sublist.append(item)
        return sublist

class ClassTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return True
    def GetSubList(self):
        sublist = ObjectTreeItem.GetSubList(self)
        if len(self.object.__bases__) == 1:
            item = make_objecttreeitem("__bases__[0] =",
                self.object.__bases__[0])
        else:
            item = make_objecttreeitem("__bases__ =", self.object.__bases__)
        sublist.insert(0, item)
        return sublist

class AtomicObjectTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return 0

class SequenceTreeItem(ObjectTreeItem):
    def IsExpandable(self):
        return len(self.object) > 0
    def keys(self):
        return range(len(self.object))
    def GetSubList(self):
        sublist = []
        for key in self.keys():
            try:
                value = self.object[key]
            except KeyError:
                continue
            def setfunction(value, key=key, object=self.object):
                object[key] = value
            item = make_objecttreeitem("%r:" % (key,), value, setfunction)
            sublist.append(item)
        return sublist

class DictTreeItem(SequenceTreeItem):
    def keys(self):
        keys = list(self.object.keys())
        try:
            keys.sort()
        except:
            pass
        return keys

dispatch = {
    int: AtomicObjectTreeItem,
    float: AtomicObjectTreeItem,
    str: AtomicObjectTreeItem,
    tuple: SequenceTreeItem,
    list: SequenceTreeItem,
    dict: DictTreeItem,
    type: ClassTreeItem,
}

def make_objecttreeitem(labeltext, object, setfunction=None):
    t = type(object)
    if t in dispatch:
        c = dispatch[t]
    else:
        c = ObjectTreeItem
    return c(labeltext, object, setfunction)


def _object_browser(parent):
    import sys
    from tkinter import Tk
    root = Tk()
    root.title("Test ObjectBrowser")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    root.configure(bd=0, bg="yellow")
    root.focus_set()
    sc = ScrolledCanvas(root, bg="white", highlightthickness=0, takefocus=1)
    sc.frame.pack(expand=1, fill="both")
    item = make_objecttreeitem("sys", sys)
    node = TreeNode(sc.canvas, None, item)
    node.update()
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_object_browser)
                                                                                                                         usr/lib/python3.4/idlelib/OutputWindow.py                                                           0100644 0000000 0000000 00000010452 12415221640 017037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *
from idlelib.EditorWindow import EditorWindow
import re
import tkinter.messagebox as tkMessageBox
from idlelib import IOBinding

class OutputWindow(EditorWindow):

    """An editor window that can serve as an output file.

    Also the future base class for the Python shell window.
    This class has no input facilities.
    """

    def __init__(self, *args):
        EditorWindow.__init__(self, *args)
        self.text.bind("<<goto-file-line>>", self.goto_file_line)

    # Customize EditorWindow

    def ispythonsource(self, filename):
        # No colorization needed
        return 0

    def short_title(self):
        return "Output"

    def maybesave(self):
        # Override base class method -- don't ask any questions
        if self.get_saved():
            return "yes"
        else:
            return "no"

    # Act as output file

    def write(self, s, tags=(), mark="insert"):
        if isinstance(s, (bytes, bytes)):
            s = s.decode(IOBinding.encoding, "replace")
        self.text.insert(mark, s, tags)
        self.text.see(mark)
        self.text.update()
        return len(s)

    def writelines(self, lines):
        for line in lines:
            self.write(line)

    def flush(self):
        pass

    # Our own right-button menu

    rmenu_specs = [
        ("Cut", "<<cut>>", "rmenu_check_cut"),
        ("Copy", "<<copy>>", "rmenu_check_copy"),
        ("Paste", "<<paste>>", "rmenu_check_paste"),
        (None, None, None),
        ("Go to file/line", "<<goto-file-line>>", None),
    ]

    file_line_pats = [
        # order of patterns matters
        r'file "([^"]*)", line (\d+)',
        r'([^\s]+)\((\d+)\)',
        r'^(\s*\S.*?):\s*(\d+):',  # Win filename, maybe starting with spaces
        r'([^\s]+):\s*(\d+):',     # filename or path, ltrim
        r'^\s*(\S.*?):\s*(\d+):',  # Win abs path with embedded spaces, ltrim
    ]

    file_line_progs = None

    def goto_file_line(self, event=None):
        if self.file_line_progs is None:
            l = []
            for pat in self.file_line_pats:
                l.append(re.compile(pat, re.IGNORECASE))
            self.file_line_progs = l
        # x, y = self.event.x, self.event.y
        # self.text.mark_set("insert", "@%d,%d" % (x, y))
        line = self.text.get("insert linestart", "insert lineend")
        result = self._file_line_helper(line)
        if not result:
            # Try the previous line.  This is handy e.g. in tracebacks,
            # where you tend to right-click on the displayed source line
            line = self.text.get("insert -1line linestart",
                                 "insert -1line lineend")
            result = self._file_line_helper(line)
            if not result:
                tkMessageBox.showerror(
                    "No special line",
                    "The line you point at doesn't look like "
                    "a valid file name followed by a line number.",
                    master=self.text)
                return
        filename, lineno = result
        edit = self.flist.open(filename)
        edit.gotoline(lineno)

    def _file_line_helper(self, line):
        for prog in self.file_line_progs:
            match = prog.search(line)
            if match:
                filename, lineno = match.group(1, 2)
                try:
                    f = open(filename, "r")
                    f.close()
                    break
                except OSError:
                    continue
        else:
            return None
        try:
            return filename, int(lineno)
        except TypeError:
            return None

# These classes are currently not used but might come in handy

class OnDemandOutputWindow:

    tagdefs = {
        # XXX Should use IdlePrefs.ColorPrefs
        "stdout":  {"foreground": "blue"},
        "stderr":  {"foreground": "#007700"},
    }

    def __init__(self, flist):
        self.flist = flist
        self.owin = None

    def write(self, s, tags, mark):
        if not self.owin:
            self.setup()
        self.owin.write(s, tags, mark)

    def setup(self):
        self.owin = owin = OutputWindow(self.flist)
        text = owin.text
        for tag, cnf in self.tagdefs.items():
            if cnf:
                text.tag_configure(tag, **cnf)
        text.tag_raise('sel')
        self.write = self.owin.write
                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/ParenMatch.py                                                             0100644 0000000 0000000 00000015071 12415221640 016373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """ParenMatch -- An IDLE extension for parenthesis matching.

When you hit a right paren, the cursor should move briefly to the left
paren.  Paren here is used generically; the matching applies to
parentheses, square brackets, and curly braces.
"""

from idlelib.HyperParser import HyperParser
from idlelib.configHandler import idleConf

_openers = {')':'(',']':'[','}':'{'}
CHECK_DELAY = 100 # miliseconds

class ParenMatch:
    """Highlight matching parentheses

    There are three supported style of paren matching, based loosely
    on the Emacs options.  The style is select based on the
    HILITE_STYLE attribute; it can be changed used the set_style
    method.

    The supported styles are:

    default -- When a right paren is typed, highlight the matching
        left paren for 1/2 sec.

    expression -- When a right paren is typed, highlight the entire
        expression from the left paren to the right paren.

    TODO:
        - extend IDLE with configuration dialog to change options
        - implement rest of Emacs highlight styles (see below)
        - print mismatch warning in IDLE status window

    Note: In Emacs, there are several styles of highlight where the
    matching paren is highlighted whenever the cursor is immediately
    to the right of a right paren.  I don't know how to do that in Tk,
    so I haven't bothered.
    """
    menudefs = [
        ('edit', [
            ("Show surrounding parens", "<<flash-paren>>"),
        ])
    ]
    STYLE = idleConf.GetOption('extensions','ParenMatch','style',
            default='expression')
    FLASH_DELAY = idleConf.GetOption('extensions','ParenMatch','flash-delay',
            type='int',default=500)
    HILITE_CONFIG = idleConf.GetHighlight(idleConf.CurrentTheme(),'hilite')
    BELL = idleConf.GetOption('extensions','ParenMatch','bell',
            type='bool',default=1)

    RESTORE_VIRTUAL_EVENT_NAME = "<<parenmatch-check-restore>>"
    # We want the restore event be called before the usual return and
    # backspace events.
    RESTORE_SEQUENCES = ("<KeyPress>", "<ButtonPress>",
                         "<Key-Return>", "<Key-BackSpace>")

    def __init__(self, editwin):
        self.editwin = editwin
        self.text = editwin.text
        # Bind the check-restore event to the function restore_event,
        # so that we can then use activate_restore (which calls event_add)
        # and deactivate_restore (which calls event_delete).
        editwin.text.bind(self.RESTORE_VIRTUAL_EVENT_NAME,
                          self.restore_event)
        self.counter = 0
        self.is_restore_active = 0
        self.set_style(self.STYLE)

    def activate_restore(self):
        if not self.is_restore_active:
            for seq in self.RESTORE_SEQUENCES:
                self.text.event_add(self.RESTORE_VIRTUAL_EVENT_NAME, seq)
            self.is_restore_active = True

    def deactivate_restore(self):
        if self.is_restore_active:
            for seq in self.RESTORE_SEQUENCES:
                self.text.event_delete(self.RESTORE_VIRTUAL_EVENT_NAME, seq)
            self.is_restore_active = False

    def set_style(self, style):
        self.STYLE = style
        if style == "default":
            self.create_tag = self.create_tag_default
            self.set_timeout = self.set_timeout_last
        elif style == "expression":
            self.create_tag = self.create_tag_expression
            self.set_timeout = self.set_timeout_none

    def flash_paren_event(self, event):
        indices = (HyperParser(self.editwin, "insert")
                   .get_surrounding_brackets())
        if indices is None:
            self.warn_mismatched()
            return
        self.activate_restore()
        self.create_tag(indices)
        self.set_timeout_last()

    def paren_closed_event(self, event):
        # If it was a shortcut and not really a closing paren, quit.
        closer = self.text.get("insert-1c")
        if closer not in _openers:
            return
        hp = HyperParser(self.editwin, "insert-1c")
        if not hp.is_in_code():
            return
        indices = hp.get_surrounding_brackets(_openers[closer], True)
        if indices is None:
            self.warn_mismatched()
            return
        self.activate_restore()
        self.create_tag(indices)
        self.set_timeout()

    def restore_event(self, event=None):
        self.text.tag_delete("paren")
        self.deactivate_restore()
        self.counter += 1   # disable the last timer, if there is one.

    def handle_restore_timer(self, timer_count):
        if timer_count == self.counter:
            self.restore_event()

    def warn_mismatched(self):
        if self.BELL:
            self.text.bell()

    # any one of the create_tag_XXX methods can be used depending on
    # the style

    def create_tag_default(self, indices):
        """Highlight the single paren that matches"""
        self.text.tag_add("paren", indices[0])
        self.text.tag_config("paren", self.HILITE_CONFIG)

    def create_tag_expression(self, indices):
        """Highlight the entire expression"""
        if self.text.get(indices[1]) in (')', ']', '}'):
            rightindex = indices[1]+"+1c"
        else:
            rightindex = indices[1]
        self.text.tag_add("paren", indices[0], rightindex)
        self.text.tag_config("paren", self.HILITE_CONFIG)

    # any one of the set_timeout_XXX methods can be used depending on
    # the style

    def set_timeout_none(self):
        """Highlight will remain until user input turns it off
        or the insert has moved"""
        # After CHECK_DELAY, call a function which disables the "paren" tag
        # if the event is for the most recent timer and the insert has changed,
        # or schedules another call for itself.
        self.counter += 1
        def callme(callme, self=self, c=self.counter,
                   index=self.text.index("insert")):
            if index != self.text.index("insert"):
                self.handle_restore_timer(c)
            else:
                self.editwin.text_frame.after(CHECK_DELAY, callme, callme)
        self.editwin.text_frame.after(CHECK_DELAY, callme, callme)

    def set_timeout_last(self):
        """The last highlight created will be removed after .5 sec"""
        # associate a counter with an event; only disable the "paren"
        # tag if the event is for the most recent timer.
        self.counter += 1
        self.editwin.text_frame.after(
            self.FLASH_DELAY,
            lambda self=self, c=self.counter: self.handle_restore_timer(c))


if __name__ == '__main__':
    import unittest
    unittest.main('idlelib.idle_test.test_parenmatch', verbosity=2)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/PathBrowser.py                                                            0100644 0000000 0000000 00000006047 12415221640 016614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import sys
import importlib.machinery

from idlelib.TreeWidget import TreeItem
from idlelib.ClassBrowser import ClassBrowser, ModuleBrowserTreeItem
from idlelib.PyShell import PyShellFileList


class PathBrowser(ClassBrowser):

    def __init__(self, flist, _htest=False):
        """
        _htest - bool, change box location when running htest
        """
        self._htest = _htest
        self.init(flist)

    def settitle(self):
        self.top.wm_title("Path Browser")
        self.top.wm_iconname("Path Browser")

    def rootnode(self):
        return PathBrowserTreeItem()

class PathBrowserTreeItem(TreeItem):

    def GetText(self):
        return "sys.path"

    def GetSubList(self):
        sublist = []
        for dir in sys.path:
            item = DirBrowserTreeItem(dir)
            sublist.append(item)
        return sublist

class DirBrowserTreeItem(TreeItem):

    def __init__(self, dir, packages=[]):
        self.dir = dir
        self.packages = packages

    def GetText(self):
        if not self.packages:
            return self.dir
        else:
            return self.packages[-1] + ": package"

    def GetSubList(self):
        try:
            names = os.listdir(self.dir or os.curdir)
        except OSError:
            return []
        packages = []
        for name in names:
            file = os.path.join(self.dir, name)
            if self.ispackagedir(file):
                nn = os.path.normcase(name)
                packages.append((nn, name, file))
        packages.sort()
        sublist = []
        for nn, name, file in packages:
            item = DirBrowserTreeItem(file, self.packages + [name])
            sublist.append(item)
        for nn, name in self.listmodules(names):
            item = ModuleBrowserTreeItem(os.path.join(self.dir, name))
            sublist.append(item)
        return sublist

    def ispackagedir(self, file):
        if not os.path.isdir(file):
            return 0
        init = os.path.join(file, "__init__.py")
        return os.path.exists(init)

    def listmodules(self, allnames):
        modules = {}
        suffixes = importlib.machinery.EXTENSION_SUFFIXES[:]
        suffixes += importlib.machinery.SOURCE_SUFFIXES[:]
        suffixes += importlib.machinery.BYTECODE_SUFFIXES[:]
        sorted = []
        for suff in suffixes:
            i = -len(suff)
            for name in allnames[:]:
                normed_name = os.path.normcase(name)
                if normed_name[i:] == suff:
                    mod_name = name[:i]
                    if mod_name not in modules:
                        modules[mod_name] = None
                        sorted.append((normed_name, name))
                        allnames.remove(name)
        sorted.sort()
        return sorted

def _path_browser(parent):
    flist = PyShellFileList(parent)
    PathBrowser(flist, _htest=True)
    parent.mainloop()

if __name__ == "__main__":
    from unittest import main
    main('idlelib.idle_test.test_pathbrowser', verbosity=2, exit=False)

    from idlelib.idle_test.htest import run
    run(_path_browser)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python3.4/idlelib/Percolator.py                                                             0100644 0000000 0000000 00000006254 12415221640 016466  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from idlelib.WidgetRedirector import WidgetRedirector
from idlelib.Delegator import Delegator

class Percolator:

    def __init__(self, text):
        # XXX would be nice to inherit from Delegator
        self.text = text
        self.redir = WidgetRedirector(text)
        self.top = self.bottom = Delegator(text)
        self.bottom.insert = self.redir.register("insert", self.insert)
        self.bottom.delete = self.redir.register("delete", self.delete)
        self.filters = []

    def close(self):
        while self.top is not self.bottom:
            self.removefilter(self.top)
        self.top = None
        self.bottom.setdelegate(None); self.bottom = None
        self.redir.close(); self.redir = None
        self.text = None

    def insert(self, index, chars, tags=None):
        # Could go away if inheriting from Delegator
        self.top.insert(index, chars, tags)

    def delete(self, index1, index2=None):
        # Could go away if inheriting from Delegator
        self.top.delete(index1, index2)

    def insertfilter(self, filter):
        # Perhaps rename to pushfilter()?
        assert isinstance(filter, Delegator)
        assert filter.delegate is None
        filter.setdelegate(self.top)
        self.top = filter

    def removefilter(self, filter):
        # XXX Perhaps should only support popfilter()?
        assert isinstance(filter, Delegator)
        assert filter.delegate is not None
        f = self.top
        if f is filter:
            self.top = filter.delegate
            filter.setdelegate(None)
        else:
            while f.delegate is not filter:
                assert f is not self.bottom
                f.resetcache()
                f = f.delegate
            f.setdelegate(filter.delegate)
            filter.setdelegate(None)

def _percolator(parent):
    import tkinter as tk
    import re
    class Tracer(Delegator):
        def __init__(self, name):
            self.name = name
            Delegator.__init__(self, None)
        def insert(self, *args):
            print(self.name, ": insert", args)
            self.delegate.insert(*args)
        def delete(self, *args):
            print(self.name, ": delete", args)
            self.delegate.delete(*args)
    root = tk.Tk()
    root.title("Test Percolator")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    text = tk.Text(root)
    p = Percolator(text)
    t1 = Tracer("t1")
    t2 = Tracer("t2")

    def toggle1():
        if var1.get() == 0:
            var1.set(1)
            p.insertfilter(t1)
        elif var1.get() == 1:
            var1.set(0)
            p.removefilter(t1)

    def toggle2():
        if var2.get() == 0:
            var2.set(1)
            p.insertfilter(t2)
        elif var2.get() == 1:
            var2.set(0)
            p.removefilter(t2)

    text.pack()
    var1 = tk.IntVar()
    cb1 = tk.Checkbutton(root, text="Tracer1", command=toggle1, variable=var1)
    cb1.pack()
    var2 = tk.IntVar()
    cb2 = tk.Checkbutton(root, text="Tracer2", command=toggle2, variable=var2)
    cb2.pack()

    root.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_percolator)
                                                                                                                                                                                                                                                                                                                                                    usr/lib/python3.4/idlelib/PyParse.py                                                                0100644 0000000 0000000 00000050013 12415221640 015727  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import re
import sys
from collections import Mapping
from functools import partial

# Reason last stmt is continued (or C_NONE if it's not).
(C_NONE, C_BACKSLASH, C_STRING_FIRST_LINE,
 C_STRING_NEXT_LINES, C_BRACKET) = range(5)

if 0:   # for throwaway debugging output
    def dump(*stuff):
        sys.__stdout__.write(" ".join(map(str, stuff)) + "\n")

# Find what looks like the start of a popular stmt.

_synchre = re.compile(r"""
    ^
    [ \t]*
    (?: while
    |   else
    |   def
    |   return
    |   assert
    |   break
    |   class
    |   continue
    |   elif
    |   try
    |   except
    |   raise
    |   import
    |   yield
    )
    \b
""", re.VERBOSE | re.MULTILINE).search

# Match blank line or non-indenting comment line.

_junkre = re.compile(r"""
    [ \t]*
    (?: \# \S .* )?
    \n
""", re.VERBOSE).match

# Match any flavor of string; the terminating quote is optional
# so that we're robust in the face of incomplete program text.

_match_stringre = re.compile(r"""
    \""" [^"\\]* (?:
                     (?: \\. | "(?!"") )
                     [^"\\]*
                 )*
    (?: \""" )?

|   " [^"\\\n]* (?: \\. [^"\\\n]* )* "?

|   ''' [^'\\]* (?:
                   (?: \\. | '(?!'') )
                   [^'\\]*
                )*
    (?: ''' )?

|   ' [^'\\\n]* (?: \\. [^'\\\n]* )* '?
""", re.VERBOSE | re.DOTALL).match

# Match a line that starts with something interesting;
# used to find the first item of a bracket structure.

_itemre = re.compile(r"""
    [ \t]*
    [^\s#\\]    # if we match, m.end()-1 is the interesting char
""", re.VERBOSE).match

# Match start of stmts that should be followed by a dedent.

_closere = re.compile(r"""
    \s*
    (?: return
    |   break
    |   continue
    |   raise
    |   pass
    )
    \b
""", re.VERBOSE).match

# Chew up non-special chars as quickly as possible.  If match is
# successful, m.end() less 1 is the index of the last boring char
# matched.  If match is unsuccessful, the string starts with an
# interesting char.

_chew_ordinaryre = re.compile(r"""
    [^[\](){}#'"\\]+
""", re.VERBOSE).match


class StringTranslatePseudoMapping(Mapping):
    r"""Utility class to be used with str.translate()

    This Mapping class wraps a given dict. When a value for a key is
    requested via __getitem__() or get(), the key is looked up in the
    given dict. If found there, the value from the dict is returned.
    Otherwise, the default value given upon initialization is returned.

    This allows using str.translate() to make some replacements, and to
    replace all characters for which no replacement was specified with
    a given character instead of leaving them as-is.

    For example, to replace everything except whitespace with 'x':

    >>> whitespace_chars = ' \t\n\r'
    >>> preserve_dict = {ord(c): ord(c) for c in whitespace_chars}
    >>> mapping = StringTranslatePseudoMapping(preserve_dict, ord('x'))
    >>> text = "a + b\tc\nd"
    >>> text.translate(mapping)
    'x x x\tx\nx'
    """
    def __init__(self, non_defaults, default_value):
        self._non_defaults = non_defaults
        self._default_value = default_value

        def _get(key, _get=non_defaults.get, _default=default_value):
            return _get(key, _default)
        self._get = _get

    def __getitem__(self, item):
        return self._get(item)

    def __len__(self):
        return len(self._non_defaults)

    def __iter__(self):
        return iter(self._non_defaults)

    def get(self, key, default=None):
        return self._get(key)


class Parser:

    def __init__(self, indentwidth, tabwidth):
        self.indentwidth = indentwidth
        self.tabwidth = tabwidth

    def set_str(self, s):
        assert len(s) == 0 or s[-1] == '\n'
        self.str = s
        self.study_level = 0

    # Return index of a good place to begin parsing, as close to the
    # end of the string as possible.  This will be the start of some
    # popular stmt like "if" or "def".  Return None if none found:
    # the caller should pass more prior context then, if possible, or
    # if not (the entire program text up until the point of interest
    # has already been tried) pass 0 to set_lo.
    #
    # This will be reliable iff given a reliable is_char_in_string
    # function, meaning that when it says "no", it's absolutely
    # guaranteed that the char is not in a string.

    def find_good_parse_start(self, is_char_in_string=None,
                              _synchre=_synchre):
        str, pos = self.str, None

        if not is_char_in_string:
            # no clue -- make the caller pass everything
            return None

        # Peek back from the end for a good place to start,
        # but don't try too often; pos will be left None, or
        # bumped to a legitimate synch point.
        limit = len(str)
        for tries in range(5):
            i = str.rfind(":\n", 0, limit)
            if i < 0:
                break
            i = str.rfind('\n', 0, i) + 1  # start of colon line
            m = _synchre(str, i, limit)
            if m and not is_char_in_string(m.start()):
                pos = m.start()
                break
            limit = i
        if pos is None:
            # Nothing looks like a block-opener, or stuff does
            # but is_char_in_string keeps returning true; most likely
            # we're in or near a giant string, the colorizer hasn't
            # caught up enough to be helpful, or there simply *aren't*
            # any interesting stmts.  In any of these cases we're
            # going to have to parse the whole thing to be sure, so
            # give it one last try from the start, but stop wasting
            # time here regardless of the outcome.
            m = _synchre(str)
            if m and not is_char_in_string(m.start()):
                pos = m.start()
            return pos

        # Peeking back worked; look forward until _synchre no longer
        # matches.
        i = pos + 1
        while 1:
            m = _synchre(str, i)
            if m:
                s, i = m.span()
                if not is_char_in_string(s):
                    pos = s
            else:
                break
        return pos

    # Throw away the start of the string.  Intended to be called with
    # find_good_parse_start's result.

    def set_lo(self, lo):
        assert lo == 0 or self.str[lo-1] == '\n'
        if lo > 0:
            self.str = self.str[lo:]

    # Build a translation table to map uninteresting chars to 'x', open
    # brackets to '(', close brackets to ')' while preserving quotes,
    # backslashes, newlines and hashes. This is to be passed to
    # str.translate() in _study1().
    _tran = {}
    _tran.update((ord(c), ord('(')) for c in "({[")
    _tran.update((ord(c), ord(')')) for c in ")}]")
    _tran.update((ord(c), ord(c)) for c in "\"'\\\n#")
    _tran = StringTranslatePseudoMapping(_tran, default_value=ord('x'))

    # As quickly as humanly possible <wink>, find the line numbers (0-
    # based) of the non-continuation lines.
    # Creates self.{goodlines, continuation}.

    def _study1(self):
        if self.study_level >= 1:
            return
        self.study_level = 1

        # Map all uninteresting characters to "x", all open brackets
        # to "(", all close brackets to ")", then collapse runs of
        # uninteresting characters.  This can cut the number of chars
        # by a factor of 10-40, and so greatly speed the following loop.
        str = self.str
        str = str.translate(self._tran)
        str = str.replace('xxxxxxxx', 'x')
        str = str.replace('xxxx', 'x')
        str = str.replace('xx', 'x')
        str = str.replace('xx', 'x')
        str = str.replace('\nx', '\n')
        # note that replacing x\n with \n would be incorrect, because
        # x may be preceded by a backslash

        # March over the squashed version of the program, accumulating
        # the line numbers of non-continued stmts, and determining
        # whether & why the last stmt is a continuation.
        continuation = C_NONE
        level = lno = 0     # level is nesting level; lno is line number
        self.goodlines = goodlines = [0]
        push_good = goodlines.append
        i, n = 0, len(str)
        while i < n:
            ch = str[i]
            i = i+1

            # cases are checked in decreasing order of frequency
            if ch == 'x':
                continue

            if ch == '\n':
                lno = lno + 1
                if level == 0:
                    push_good(lno)
                    # else we're in an unclosed bracket structure
                continue

            if ch == '(':
                level = level + 1
                continue

            if ch == ')':
                if level:
                    level = level - 1
                    # else the program is invalid, but we can't complain
                continue

            if ch == '"' or ch == "'":
                # consume the string
                quote = ch
                if str[i-1:i+2] == quote * 3:
                    quote = quote * 3
                firstlno = lno
                w = len(quote) - 1
                i = i+w
                while i < n:
                    ch = str[i]
                    i = i+1

                    if ch == 'x':
                        continue

                    if str[i-1:i+w] == quote:
                        i = i+w
                        break

                    if ch == '\n':
                        lno = lno + 1
                        if w == 0:
                            # unterminated single-quoted string
                            if level == 0:
                                push_good(lno)
                            break
                        continue

                    if ch == '\\':
                        assert i < n
                        if str[i] == '\n':
                            lno = lno + 1
                        i = i+1
                        continue

                    # else comment char or paren inside string

                else:
                    # didn't break out of the loop, so we're still
                    # inside a string
                    if (lno - 1) == firstlno:
                        # before the previous \n in str, we were in the first
                        # line of the string
                        continuation = C_STRING_FIRST_LINE
                    else:
                        continuation = C_STRING_NEXT_LINES
                continue    # with outer loop

            if ch == '#':
                # consume the comment
                i = str.find('\n', i)
                assert i >= 0
                continue

            assert ch == '\\'
            assert i < n
            if str[i] == '\n':
                lno = lno + 1
                if i+1 == n:
                    continuation = C_BACKSLASH
            i = i+1

        # The last stmt may be continued for all 3 reasons.
        # String continuation takes precedence over bracket
        # continuation, which beats backslash continuation.
        if (continuation != C_STRING_FIRST_LINE
            and continuation != C_STRING_NEXT_LINES and level > 0):
            continuation = C_BRACKET
        self.continuation = continuation

        # Push the final line number as a sentinel value, regardless of
        # whether it's continued.
        assert (continuation == C_NONE) == (goodlines[-1] == lno)
        if goodlines[-1] != lno:
            push_good(lno)

    def get_continuation_type(self):
        self._study1()
        return self.continuation

    # study1 was sufficient to determine the continuation status,
    # but doing more requires looking at every character.  study2
    # does this for the last interesting statement in the block.
    # Creates:
    #     self.stmt_start, stmt_end
    #         slice indices of last interesting stmt
    #     self.stmt_bracketing
    #         the bracketing structure of the last interesting stmt;
    #         for example, for the statement "say(boo) or die", stmt_bracketing
    #         will be [(0, 0), (3, 1), (8, 0)]. Strings and comments are
    #         treated as brackets, for the matter.
    #     self.lastch
    #         last non-whitespace character before optional trailing
    #         comment
    #     self.lastopenbracketpos
    #         if continuation is C_BRACKET, index of last open bracket

    def _study2(self):
        if self.study_level >= 2:
            return
        self._study1()
        self.study_level = 2

        # Set p and q to slice indices of last interesting stmt.
        str, goodlines = self.str, self.goodlines
        i = len(goodlines) - 1
        p = len(str)    # index of newest line
        while i:
            assert p
            # p is the index of the stmt at line number goodlines[i].
            # Move p back to the stmt at line number goodlines[i-1].
            q = p
            for nothing in range(goodlines[i-1], goodlines[i]):
                # tricky: sets p to 0 if no preceding newline
                p = str.rfind('\n', 0, p-1) + 1
            # The stmt str[p:q] isn't a continuation, but may be blank
            # or a non-indenting comment line.
            if  _junkre(str, p):
                i = i-1
            else:
                break
        if i == 0:
            # nothing but junk!
            assert p == 0
            q = p
        self.stmt_start, self.stmt_end = p, q

        # Analyze this stmt, to find the last open bracket (if any)
        # and last interesting character (if any).
        lastch = ""
        stack = []  # stack of open bracket indices
        push_stack = stack.append
        bracketing = [(p, 0)]
        while p < q:
            # suck up all except ()[]{}'"#\\
            m = _chew_ordinaryre(str, p, q)
            if m:
                # we skipped at least one boring char
                newp = m.end()
                # back up over totally boring whitespace
                i = newp - 1    # index of last boring char
                while i >= p and str[i] in " \t\n":
                    i = i-1
                if i >= p:
                    lastch = str[i]
                p = newp
                if p >= q:
                    break

            ch = str[p]

            if ch in "([{":
                push_stack(p)
                bracketing.append((p, len(stack)))
                lastch = ch
                p = p+1
                continue

            if ch in ")]}":
                if stack:
                    del stack[-1]
                lastch = ch
                p = p+1
                bracketing.append((p, len(stack)))
                continue

            if ch == '"' or ch == "'":
                # consume string
                # Note that study1 did this with a Python loop, but
                # we use a regexp here; the reason is speed in both
                # cases; the string may be huge, but study1 pre-squashed
                # strings to a couple of characters per line.  study1
                # also needed to keep track of newlines, and we don't
                # have to.
                bracketing.append((p, len(stack)+1))
                lastch = ch
                p = _match_stringre(str, p, q).end()
                bracketing.append((p, len(stack)))
                continue

            if ch == '#':
                # consume comment and trailing newline
                bracketing.append((p, len(stack)+1))
                p = str.find('\n', p, q) + 1
                assert p > 0
                bracketing.append((p, len(stack)))
                continue

            assert ch == '\\'
            p = p+1     # beyond backslash
            assert p < q
            if str[p] != '\n':
                # the program is invalid, but can't complain
                lastch = ch + str[p]
            p = p+1     # beyond escaped char

        # end while p < q:

        self.lastch = lastch
        if stack:
            self.lastopenbracketpos = stack[-1]
        self.stmt_bracketing = tuple(bracketing)

    # Assuming continuation is C_BRACKET, return the number
    # of spaces the next line should be indented.

    def compute_bracket_indent(self):
        self._study2()
        assert self.continuation == C_BRACKET
        j = self.lastopenbracketpos
        str = self.str
        n = len(str)
        origi = i = str.rfind('\n', 0, j) + 1
        j = j+1     # one beyond open bracket
        # find first list item; set i to start of its line
        while j < n:
            m = _itemre(str, j)
            if m:
                j = m.end() - 1     # index of first interesting char
                extra = 0
                break
            else:
                # this line is junk; advance to next line
                i = j = str.find('\n', j) + 1
        else:
            # nothing interesting follows the bracket;
            # reproduce the bracket line's indentation + a level
            j = i = origi
            while str[j] in " \t":
                j = j+1
            extra = self.indentwidth
        return len(str[i:j].expandtabs(self.tabwidth)) + extra

    # Return number of physical lines in last stmt (whether or not
    # it's an interesting stmt!  this is intended to be called when
    # continuation is C_BACKSLASH).

    def get_num_lines_in_stmt(self):
        self._study1()
        goodlines = self.goodlines
        return goodlines[-1] - goodlines[-2]

    # Assuming continuation is C_BACKSLASH, return the number of spaces
    # the next line should be indented.  Also assuming the new line is
    # the first one following the initial line of the stmt.

    def compute_backslash_indent(self):
        self._study2()
        assert self.continuation == C_BACKSLASH
        str = self.str
        i = self.stmt_start
        while str[i] in " \t":
            i = i+1
        startpos = i

        # See whether the initial line starts an assignment stmt; i.e.,
        # look for an = operator
        endpos = str.find('\n', startpos) + 1
        found = level = 0
        while i < endpos:
            ch = str[i]
            if ch in "([{":
                level = level + 1
                i = i+1
            elif ch in ")]}":
                if level:
                    level = level - 1
                i = i+1
            elif ch == '"' or ch == "'":
                i = _match_stringre(str, i, endpos).end()
            elif ch == '#':
                break
            elif level == 0 and ch == '=' and \
                   (i == 0 or str[i-1] not in "=<>!") and \
                   str[i+1] != '=':
                found = 1
                break
            else:
                i = i+1

        if found:
            # found a legit =, but it may be the last interesting
            # thing on the line
            i = i+1     # move beyond the =
            found = re.match(r"\s*\\", str[i:endpos]) is None

        if not found:
            # oh well ... settle for moving beyond the first chunk
            # of non-whitespace chars
            i = startpos
            while str[i] not in " \t\n":
                i = i+1

        return len(str[self.stmt_start:i].expandtabs(\
                                     self.tabwidth)) + 1

    # Return the leading whitespace on the initial line of the last
    # interesting stmt.

    def get_base_indent_string(self):
        self._study2()
        i, n = self.stmt_start, self.stmt_end
        j = i
        str = self.str
        while j < n and str[j] in " \t":
            j = j + 1
        return str[i:j]

    # Did the last interesting stmt open a block?

    def is_block_opener(self):
        self._study2()
        return self.lastch == ':'

    # Did the last interesting stmt close a block?

    def is_block_closer(self):
        self._study2()
        return _closere(self.str, self.stmt_start) is not None

    # index of last open bracket ({[, or None if none
    lastopenbracketpos = None

    def get_last_open_bracket_pos(self):
        self._study2()
        return self.lastopenbracketpos

    # the structure of the bracketing of the last interesting statement,
    # in the format defined in _study2, or None if the text didn't contain
    # anything
    stmt_bracketing = None

    def get_last_stmt_bracketing(self):
        self._study2()
        return self.stmt_bracketing
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/idlelib/PyShell.py                                                                0100755 0000000 0000000 00000162262 12415221651 015743  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        #! /usr/bin/python3.4

import getopt
import os
import os.path
import re
import socket
import subprocess
import sys
import threading
import time
import tokenize
import traceback
import types
import io

import linecache
from code import InteractiveInterpreter
from platform import python_version, system

try:
    from tkinter import *
except ImportError:
    print("** IDLE can't import Tkinter.\n"
          "Your Python may not be configured for Tk. **", file=sys.__stderr__)
    sys.exit(1)
import tkinter.messagebox as tkMessageBox

from idlelib.EditorWindow import EditorWindow, fixwordbreaks
from idlelib.FileList import FileList
from idlelib.ColorDelegator import ColorDelegator
from idlelib.UndoDelegator import UndoDelegator
from idlelib.OutputWindow import OutputWindow
from idlelib.configHandler import idleConf
from idlelib import idlever
from idlelib import rpc
from idlelib import Debugger
from idlelib import RemoteDebugger
from idlelib import macosxSupport

HOST = '127.0.0.1' # python execution server on localhost loopback
PORT = 0  # someday pass in host, port for remote debug capability

# Override warnings module to write to warning_stream.  Initialize to send IDLE
# internal warnings to the console.  ScriptBinding.check_syntax() will
# temporarily redirect the stream to the shell window to display warnings when
# checking user's code.
warning_stream = sys.__stderr__  # None, at least on Windows, if no console.
import warnings

def idle_formatwarning(message, category, filename, lineno, line=None):
    """Format warnings the IDLE way."""

    s = "\nWarning (from warnings module):\n"
    s += '  File \"%s\", line %s\n' % (filename, lineno)
    if line is None:
        line = linecache.getline(filename, lineno)
    line = line.strip()
    if line:
        s += "    %s\n" % line
    s += "%s: %s\n" % (category.__name__, message)
    return s

def idle_showwarning(
        message, category, filename, lineno, file=None, line=None):
    """Show Idle-format warning (after replacing warnings.showwarning).

    The differences are the formatter called, the file=None replacement,
    which can be None, the capture of the consequence AttributeError,
    and the output of a hard-coded prompt.
    """
    if file is None:
        file = warning_stream
    try:
        file.write(idle_formatwarning(
                message, category, filename, lineno, line=line))
        file.write(">>> ")
    except (AttributeError, OSError):
        pass  # if file (probably __stderr__) is invalid, skip warning.

_warnings_showwarning = None

def capture_warnings(capture):
    "Replace warning.showwarning with idle_showwarning, or reverse."

    global _warnings_showwarning
    if capture:
        if _warnings_showwarning is None:
            _warnings_showwarning = warnings.showwarning
            warnings.showwarning = idle_showwarning
    else:
        if _warnings_showwarning is not None:
            warnings.showwarning = _warnings_showwarning
            _warnings_showwarning = None

capture_warnings(True)

def extended_linecache_checkcache(filename=None,
                                  orig_checkcache=linecache.checkcache):
    """Extend linecache.checkcache to preserve the <pyshell#...> entries

    Rather than repeating the linecache code, patch it to save the
    <pyshell#...> entries, call the original linecache.checkcache()
    (skipping them), and then restore the saved entries.

    orig_checkcache is bound at definition time to the original
    method, allowing it to be patched.
    """
    cache = linecache.cache
    save = {}
    for key in list(cache):
        if key[:1] + key[-1:] == '<>':
            save[key] = cache.pop(key)
    orig_checkcache(filename)
    cache.update(save)

# Patch linecache.checkcache():
linecache.checkcache = extended_linecache_checkcache


class PyShellEditorWindow(EditorWindow):
    "Regular text edit window in IDLE, supports breakpoints"

    def __init__(self, *args):
        self.breakpoints = []
        EditorWindow.__init__(self, *args)
        self.text.bind("<<set-breakpoint-here>>", self.set_breakpoint_here)
        self.text.bind("<<clear-breakpoint-here>>", self.clear_breakpoint_here)
        self.text.bind("<<open-python-shell>>", self.flist.open_shell)

        self.breakpointPath = os.path.join(idleConf.GetUserCfgDir(),
                                           'breakpoints.lst')
        # whenever a file is changed, restore breakpoints
        def filename_changed_hook(old_hook=self.io.filename_change_hook,
                                  self=self):
            self.restore_file_breaks()
            old_hook()
        self.io.set_filename_change_hook(filename_changed_hook)
        if self.io.filename:
            self.restore_file_breaks()
        self.color_breakpoint_text()

    rmenu_specs = [
        ("Cut", "<<cut>>", "rmenu_check_cut"),
        ("Copy", "<<copy>>", "rmenu_check_copy"),
        ("Paste", "<<paste>>", "rmenu_check_paste"),
        (None, None, None),
        ("Set Breakpoint", "<<set-breakpoint-here>>", None),
        ("Clear Breakpoint", "<<clear-breakpoint-here>>", None)
    ]

    def color_breakpoint_text(self, color=True):
        "Turn colorizing of breakpoint text on or off"
        if color:
            theme = idleConf.GetOption('main','Theme','name')
            cfg = idleConf.GetHighlight(theme, "break")
        else:
            cfg = {'foreground': '', 'background': ''}
        self.text.tag_config('BREAK', cfg)

    def set_breakpoint(self, lineno):
        text = self.text
        filename = self.io.filename
        text.tag_add("BREAK", "%d.0" % lineno, "%d.0" % (lineno+1))
        try:
            i = self.breakpoints.index(lineno)
        except ValueError:  # only add if missing, i.e. do once
            self.breakpoints.append(lineno)
        try:    # update the subprocess debugger
            debug = self.flist.pyshell.interp.debugger
            debug.set_breakpoint_here(filename, lineno)
        except: # but debugger may not be active right now....
            pass

    def set_breakpoint_here(self, event=None):
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        lineno = int(float(text.index("insert")))
        self.set_breakpoint(lineno)

    def clear_breakpoint_here(self, event=None):
        text = self.text
        filename = self.io.filename
        if not filename:
            text.bell()
            return
        lineno = int(float(text.index("insert")))
        try:
            self.breakpoints.remove(lineno)
        except:
            pass
        text.tag_remove("BREAK", "insert linestart",\
                        "insert lineend +1char")
        try:
            debug = self.flist.pyshell.interp.debugger
            debug.clear_breakpoint_here(filename, lineno)
        except:
            pass

    def clear_file_breaks(self):
        if self.breakpoints:
            text = self.text
            filename = self.io.filename
            if not filename:
                text.bell()
                return
            self.breakpoints = []
            text.tag_remove("BREAK", "1.0", END)
            try:
                debug = self.flist.pyshell.interp.debugger
                debug.clear_file_breaks(filename)
            except:
                pass

    def store_file_breaks(self):
        "Save breakpoints when file is saved"
        # XXX 13 Dec 2002 KBK Currently the file must be saved before it can
        #     be run.  The breaks are saved at that time.  If we introduce
        #     a temporary file save feature the save breaks functionality
        #     needs to be re-verified, since the breaks at the time the
        #     temp file is created may differ from the breaks at the last
        #     permanent save of the file.  Currently, a break introduced
        #     after a save will be effective, but not persistent.
        #     This is necessary to keep the saved breaks synched with the
        #     saved file.
        #
        #     Breakpoints are set as tagged ranges in the text.  Certain
        #     kinds of edits cause these ranges to be deleted: Inserting
        #     or deleting a line just before a breakpoint, and certain
        #     deletions prior to a breakpoint.  These issues need to be
        #     investigated and understood.  It's not clear if they are
        #     Tk issues or IDLE issues, or whether they can actually
        #     be fixed.  Since a modified file has to be saved before it is
        #     run, and since self.breakpoints (from which the subprocess
        #     debugger is loaded) is updated during the save, the visible
        #     breaks stay synched with the subprocess even if one of these
        #     unexpected breakpoint deletions occurs.
        breaks = self.breakpoints
        filename = self.io.filename
        try:
            with open(self.breakpointPath, "r") as fp:
                lines = fp.readlines()
        except OSError:
            lines = []
        try:
            with open(self.breakpointPath, "w") as new_file:
                for line in lines:
                    if not line.startswith(filename + '='):
                        new_file.write(line)
                self.update_breakpoints()
                breaks = self.breakpoints
                if breaks:
                    new_file.write(filename + '=' + str(breaks) + '\n')
        except OSError as err:
            if not getattr(self.root, "breakpoint_error_displayed", False):
                self.root.breakpoint_error_displayed = True
                tkMessageBox.showerror(title='IDLE Error',
                    message='Unable to update breakpoint list:\n%s'
                        % str(err),
                    parent=self.text)

    def restore_file_breaks(self):
        self.text.update()   # this enables setting "BREAK" tags to be visible
        if self.io is None:
            # can happen if IDLE closes due to the .update() call
            return
        filename = self.io.filename
        if filename is None:
            return
        if os.path.isfile(self.breakpointPath):
            with open(self.breakpointPath, "r") as fp:
                lines = fp.readlines()
            for line in lines:
                if line.startswith(filename + '='):
                    breakpoint_linenumbers = eval(line[len(filename)+1:])
                    for breakpoint_linenumber in breakpoint_linenumbers:
                        self.set_breakpoint(breakpoint_linenumber)

    def update_breakpoints(self):
        "Retrieves all the breakpoints in the current window"
        text = self.text
        ranges = text.tag_ranges("BREAK")
        linenumber_list = self.ranges_to_linenumbers(ranges)
        self.breakpoints = linenumber_list

    def ranges_to_linenumbers(self, ranges):
        lines = []
        for index in range(0, len(ranges), 2):
            lineno = int(float(ranges[index].string))
            end = int(float(ranges[index+1].string))
            while lineno < end:
                lines.append(lineno)
                lineno += 1
        return lines

# XXX 13 Dec 2002 KBK Not used currently
#    def saved_change_hook(self):
#        "Extend base method - clear breaks if module is modified"
#        if not self.get_saved():
#            self.clear_file_breaks()
#        EditorWindow.saved_change_hook(self)

    def _close(self):
        "Extend base method - clear breaks when module is closed"
        self.clear_file_breaks()
        EditorWindow._close(self)


class PyShellFileList(FileList):
    "Extend base class: IDLE supports a shell and breakpoints"

    # override FileList's class variable, instances return PyShellEditorWindow
    # instead of EditorWindow when new edit windows are created.
    EditorWindow = PyShellEditorWindow

    pyshell = None

    def open_shell(self, event=None):
        if self.pyshell:
            self.pyshell.top.wakeup()
        else:
            self.pyshell = PyShell(self)
            if self.pyshell:
                if not self.pyshell.begin():
                    return None
        return self.pyshell


class ModifiedColorDelegator(ColorDelegator):
    "Extend base class: colorizer for the shell window itself"

    def __init__(self):
        ColorDelegator.__init__(self)
        self.LoadTagDefs()

    def recolorize_main(self):
        self.tag_remove("TODO", "1.0", "iomark")
        self.tag_add("SYNC", "1.0", "iomark")
        ColorDelegator.recolorize_main(self)

    def LoadTagDefs(self):
        ColorDelegator.LoadTagDefs(self)
        theme = idleConf.GetOption('main','Theme','name')
        self.tagdefs.update({
            "stdin": {'background':None,'foreground':None},
            "stdout": idleConf.GetHighlight(theme, "stdout"),
            "stderr": idleConf.GetHighlight(theme, "stderr"),
            "console": idleConf.GetHighlight(theme, "console"),
        })

    def removecolors(self):
        # Don't remove shell color tags before "iomark"
        for tag in self.tagdefs:
            self.tag_remove(tag, "iomark", "end")

class ModifiedUndoDelegator(UndoDelegator):
    "Extend base class: forbid insert/delete before the I/O mark"

    def insert(self, index, chars, tags=None):
        try:
            if self.delegate.compare(index, "<", "iomark"):
                self.delegate.bell()
                return
        except TclError:
            pass
        UndoDelegator.insert(self, index, chars, tags)

    def delete(self, index1, index2=None):
        try:
            if self.delegate.compare(index1, "<", "iomark"):
                self.delegate.bell()
                return
        except TclError:
            pass
        UndoDelegator.delete(self, index1, index2)


class MyRPCClient(rpc.RPCClient):

    def handle_EOF(self):
        "Override the base class - just re-raise EOFError"
        raise EOFError


class ModifiedInterpreter(InteractiveInterpreter):

    def __init__(self, tkconsole):
        self.tkconsole = tkconsole
        locals = sys.modules['__main__'].__dict__
        InteractiveInterpreter.__init__(self, locals=locals)
        self.save_warnings_filters = None
        self.restarting = False
        self.subprocess_arglist = None
        self.port = PORT
        self.original_compiler_flags = self.compile.compiler.flags

    _afterid = None
    rpcclt = None
    rpcsubproc = None

    def spawn_subprocess(self):
        if self.subprocess_arglist is None:
            self.subprocess_arglist = self.build_subprocess_arglist()
        self.rpcsubproc = subprocess.Popen(self.subprocess_arglist)

    def build_subprocess_arglist(self):
        assert (self.port!=0), (
            "Socket should have been assigned a port number.")
        w = ['-W' + s for s in sys.warnoptions]
        # Maybe IDLE is installed and is being accessed via sys.path,
        # or maybe it's not installed and the idle.py script is being
        # run from the IDLE source directory.
        del_exitf = idleConf.GetOption('main', 'General', 'delete-exitfunc',
                                       default=False, type='bool')
        if __name__ == 'idlelib.PyShell':
            command = "__import__('idlelib.run').run.main(%r)" % (del_exitf,)
        else:
            command = "__import__('run').main(%r)" % (del_exitf,)
        return [sys.executable] + w + ["-c", command, str(self.port)]

    def start_subprocess(self):
        addr = (HOST, self.port)
        # GUI makes several attempts to acquire socket, listens for connection
        for i in range(3):
            time.sleep(i)
            try:
                self.rpcclt = MyRPCClient(addr)
                break
            except OSError as err:
                pass
        else:
            self.display_port_binding_error()
            return None
        # if PORT was 0, system will assign an 'ephemeral' port. Find it out:
        self.port = self.rpcclt.listening_sock.getsockname()[1]
        # if PORT was not 0, probably working with a remote execution server
        if PORT != 0:
            # To allow reconnection within the 2MSL wait (cf. Stevens TCP
            # V1, 18.6),  set SO_REUSEADDR.  Note that this can be problematic
            # on Windows since the implementation allows two active sockets on
            # the same address!
            self.rpcclt.listening_sock.setsockopt(socket.SOL_SOCKET,
                                           socket.SO_REUSEADDR, 1)
        self.spawn_subprocess()
        #time.sleep(20) # test to simulate GUI not accepting connection
        # Accept the connection from the Python execution server
        self.rpcclt.listening_sock.settimeout(10)
        try:
            self.rpcclt.accept()
        except socket.timeout as err:
            self.display_no_subprocess_error()
            return None
        self.rpcclt.register("console", self.tkconsole)
        self.rpcclt.register("stdin", self.tkconsole.stdin)
        self.rpcclt.register("stdout", self.tkconsole.stdout)
        self.rpcclt.register("stderr", self.tkconsole.stderr)
        self.rpcclt.register("flist", self.tkconsole.flist)
        self.rpcclt.register("linecache", linecache)
        self.rpcclt.register("interp", self)
        self.transfer_path(with_cwd=True)
        self.poll_subprocess()
        return self.rpcclt

    def restart_subprocess(self, with_cwd=False):
        if self.restarting:
            return self.rpcclt
        self.restarting = True
        # close only the subprocess debugger
        debug = self.getdebugger()
        if debug:
            try:
                # Only close subprocess debugger, don't unregister gui_adap!
                RemoteDebugger.close_subprocess_debugger(self.rpcclt)
            except:
                pass
        # Kill subprocess, spawn a new one, accept connection.
        self.rpcclt.close()
        self.terminate_subprocess()
        console = self.tkconsole
        was_executing = console.executing
        console.executing = False
        self.spawn_subprocess()
        try:
            self.rpcclt.accept()
        except socket.timeout as err:
            self.display_no_subprocess_error()
            return None
        self.transfer_path(with_cwd=with_cwd)
        console.stop_readline()
        # annotate restart in shell window and mark it
        console.text.delete("iomark", "end-1c")
        if was_executing:
            console.write('\n')
            console.showprompt()
        halfbar = ((int(console.width) - 16) // 2) * '='
        console.write(halfbar + ' RESTART ' + halfbar)
        console.text.mark_set("restart", "end-1c")
        console.text.mark_gravity("restart", "left")
        console.showprompt()
        # restart subprocess debugger
        if debug:
            # Restarted debugger connects to current instance of debug GUI
            gui = RemoteDebugger.restart_subprocess_debugger(self.rpcclt)
            # reload remote debugger breakpoints for all PyShellEditWindows
            debug.load_breakpoints()
        self.compile.compiler.flags = self.original_compiler_flags
        self.restarting = False
        return self.rpcclt

    def __request_interrupt(self):
        self.rpcclt.remotecall("exec", "interrupt_the_server", (), {})

    def interrupt_subprocess(self):
        threading.Thread(target=self.__request_interrupt).start()

    def kill_subprocess(self):
        if self._afterid is not None:
            self.tkconsole.text.after_cancel(self._afterid)
        try:
            self.rpcclt.listening_sock.close()
        except AttributeError:  # no socket
            pass
        try:
            self.rpcclt.close()
        except AttributeError:  # no socket
            pass
        self.terminate_subprocess()
        self.tkconsole.executing = False
        self.rpcclt = None

    def terminate_subprocess(self):
        "Make sure subprocess is terminated"
        try:
            self.rpcsubproc.kill()
        except OSError:
            # process already terminated
            return
        else:
            try:
                self.rpcsubproc.wait()
            except OSError:
                return

    def transfer_path(self, with_cwd=False):
        if with_cwd:        # Issue 13506
            path = ['']     # include Current Working Directory
            path.extend(sys.path)
        else:
            path = sys.path

        self.runcommand("""if 1:
        import sys as _sys
        _sys.path = %r
        del _sys
        \n""" % (path,))

    active_seq = None

    def poll_subprocess(self):
        clt = self.rpcclt
        if clt is None:
            return
        try:
            response = clt.pollresponse(self.active_seq, wait=0.05)
        except (EOFError, OSError, KeyboardInterrupt):
            # lost connection or subprocess terminated itself, restart
            # [the KBI is from rpc.SocketIO.handle_EOF()]
            if self.tkconsole.closing:
                return
            response = None
            self.restart_subprocess()
        if response:
            self.tkconsole.resetoutput()
            self.active_seq = None
            how, what = response
            console = self.tkconsole.console
            if how == "OK":
                if what is not None:
                    print(repr(what), file=console)
            elif how == "EXCEPTION":
                if self.tkconsole.getvar("<<toggle-jit-stack-viewer>>"):
                    self.remote_stack_viewer()
            elif how == "ERROR":
                errmsg = "PyShell.ModifiedInterpreter: Subprocess ERROR:\n"
                print(errmsg, what, file=sys.__stderr__)
                print(errmsg, what, file=console)
            # we received a response to the currently active seq number:
            try:
                self.tkconsole.endexecuting()
            except AttributeError:  # shell may have closed
                pass
        # Reschedule myself
        if not self.tkconsole.closing:
            self._afterid = self.tkconsole.text.after(
                self.tkconsole.pollinterval, self.poll_subprocess)

    debugger = None

    def setdebugger(self, debugger):
        self.debugger = debugger

    def getdebugger(self):
        return self.debugger

    def open_remote_stack_viewer(self):
        """Initiate the remote stack viewer from a separate thread.

        This method is called from the subprocess, and by returning from this
        method we allow the subprocess to unblock.  After a bit the shell
        requests the subprocess to open the remote stack viewer which returns a
        static object looking at the last exception.  It is queried through
        the RPC mechanism.

        """
        self.tkconsole.text.after(300, self.remote_stack_viewer)
        return

    def remote_stack_viewer(self):
        from idlelib import RemoteObjectBrowser
        oid = self.rpcclt.remotequeue("exec", "stackviewer", ("flist",), {})
        if oid is None:
            self.tkconsole.root.bell()
            return
        item = RemoteObjectBrowser.StubObjectTreeItem(self.rpcclt, oid)
        from idlelib.TreeWidget import ScrolledCanvas, TreeNode
        top = Toplevel(self.tkconsole.root)
        theme = idleConf.GetOption('main','Theme','name')
        background = idleConf.GetHighlight(theme, 'normal')['background']
        sc = ScrolledCanvas(top, bg=background, highlightthickness=0)
        sc.frame.pack(expand=1, fill="both")
        node = TreeNode(sc.canvas, None, item)
        node.expand()
        # XXX Should GC the remote tree when closing the window

    gid = 0

    def execsource(self, source):
        "Like runsource() but assumes complete exec source"
        filename = self.stuffsource(source)
        self.execfile(filename, source)

    def execfile(self, filename, source=None):
        "Execute an existing file"
        if source is None:
            with tokenize.open(filename) as fp:
                source = fp.read()
        try:
            code = compile(source, filename, "exec")
        except (OverflowError, SyntaxError):
            self.tkconsole.resetoutput()
            print('*** Error in script or command!\n'
                 'Traceback (most recent call last):',
                  file=self.tkconsole.stderr)
            InteractiveInterpreter.showsyntaxerror(self, filename)
            self.tkconsole.showprompt()
        else:
            self.runcode(code)

    def runsource(self, source):
        "Extend base class method: Stuff the source in the line cache first"
        filename = self.stuffsource(source)
        self.more = 0
        self.save_warnings_filters = warnings.filters[:]
        warnings.filterwarnings(action="error", category=SyntaxWarning)
        # at the moment, InteractiveInterpreter expects str
        assert isinstance(source, str)
        #if isinstance(source, str):
        #    from idlelib import IOBinding
        #    try:
        #        source = source.encode(IOBinding.encoding)
        #    except UnicodeError:
        #        self.tkconsole.resetoutput()
        #        self.write("Unsupported characters in input\n")
        #        return
        try:
            # InteractiveInterpreter.runsource() calls its runcode() method,
            # which is overridden (see below)
            return InteractiveInterpreter.runsource(self, source, filename)
        finally:
            if self.save_warnings_filters is not None:
                warnings.filters[:] = self.save_warnings_filters
                self.save_warnings_filters = None

    def stuffsource(self, source):
        "Stuff source in the filename cache"
        filename = "<pyshell#%d>" % self.gid
        self.gid = self.gid + 1
        lines = source.split("\n")
        linecache.cache[filename] = len(source)+1, 0, lines, filename
        return filename

    def prepend_syspath(self, filename):
        "Prepend sys.path with file's directory if not already included"
        self.runcommand("""if 1:
            _filename = %r
            import sys as _sys
            from os.path import dirname as _dirname
            _dir = _dirname(_filename)
            if not _dir in _sys.path:
                _sys.path.insert(0, _dir)
            del _filename, _sys, _dirname, _dir
            \n""" % (filename,))

    def showsyntaxerror(self, filename=None):
        """Override Interactive Interpreter method: Use Colorizing

        Color the offending position instead of printing it and pointing at it
        with a caret.

        """
        tkconsole = self.tkconsole
        text = tkconsole.text
        text.tag_remove("ERROR", "1.0", "end")
        type, value, tb = sys.exc_info()
        msg = getattr(value, 'msg', '') or value or "<no detail available>"
        lineno = getattr(value, 'lineno', '') or 1
        offset = getattr(value, 'offset', '') or 0
        if offset == 0:
            lineno += 1 #mark end of offending line
        if lineno == 1:
            pos = "iomark + %d chars" % (offset-1)
        else:
            pos = "iomark linestart + %d lines + %d chars" % \
                  (lineno-1, offset-1)
        tkconsole.colorize_syntax_error(text, pos)
        tkconsole.resetoutput()
        self.write("SyntaxError: %s\n" % msg)
        tkconsole.showprompt()

    def showtraceback(self):
        "Extend base class method to reset output properly"
        self.tkconsole.resetoutput()
        self.checklinecache()
        InteractiveInterpreter.showtraceback(self)
        if self.tkconsole.getvar("<<toggle-jit-stack-viewer>>"):
            self.tkconsole.open_stack_viewer()

    def checklinecache(self):
        c = linecache.cache
        for key in list(c.keys()):
            if key[:1] + key[-1:] != "<>":
                del c[key]

    def runcommand(self, code):
        "Run the code without invoking the debugger"
        # The code better not raise an exception!
        if self.tkconsole.executing:
            self.display_executing_dialog()
            return 0
        if self.rpcclt:
            self.rpcclt.remotequeue("exec", "runcode", (code,), {})
        else:
            exec(code, self.locals)
        return 1

    def runcode(self, code):
        "Override base class method"
        if self.tkconsole.executing:
            self.interp.restart_subprocess()
        self.checklinecache()
        if self.save_warnings_filters is not None:
            warnings.filters[:] = self.save_warnings_filters
            self.save_warnings_filters = None
        debugger = self.debugger
        try:
            self.tkconsole.beginexecuting()
            if not debugger and self.rpcclt is not None:
                self.active_seq = self.rpcclt.asyncqueue("exec", "runcode",
                                                        (code,), {})
            elif debugger:
                debugger.run(code, self.locals)
            else:
                exec(code, self.locals)
        except SystemExit:
            if not self.tkconsole.closing:
                if tkMessageBox.askyesno(
                    "Exit?",
                    "Do you want to exit altogether?",
                    default="yes",
                    master=self.tkconsole.text):
                    raise
                else:
                    self.showtraceback()
            else:
                raise
        except:
            if use_subprocess:
                print("IDLE internal error in runcode()",
                      file=self.tkconsole.stderr)
                self.showtraceback()
                self.tkconsole.endexecuting()
            else:
                if self.tkconsole.canceled:
                    self.tkconsole.canceled = False
                    print("KeyboardInterrupt", file=self.tkconsole.stderr)
                else:
                    self.showtraceback()
        finally:
            if not use_subprocess:
                try:
                    self.tkconsole.endexecuting()
                except AttributeError:  # shell may have closed
                    pass

    def write(self, s):
        "Override base class method"
        return self.tkconsole.stderr.write(s)

    def display_port_binding_error(self):
        tkMessageBox.showerror(
            "Port Binding Error",
            "IDLE can't bind to a TCP/IP port, which is necessary to "
            "communicate with its Python execution server.  This might be "
            "because no networking is installed on this computer.  "
            "Run IDLE with the -n command line switch to start without a "
            "subprocess and refer to Help/IDLE Help 'Running without a "
            "subprocess' for further details.",
            master=self.tkconsole.text)

    def display_no_subprocess_error(self):
        tkMessageBox.showerror(
            "Subprocess Startup Error",
            "IDLE's subprocess didn't make connection.  Either IDLE can't "
            "start a subprocess or personal firewall software is blocking "
            "the connection.",
            master=self.tkconsole.text)

    def display_executing_dialog(self):
        tkMessageBox.showerror(
            "Already executing",
            "The Python Shell window is already executing a command; "
            "please wait until it is finished.",
            master=self.tkconsole.text)


class PyShell(OutputWindow):

    shell_title = "Python " + python_version() + " Shell"

    # Override classes
    ColorDelegator = ModifiedColorDelegator
    UndoDelegator = ModifiedUndoDelegator

    # Override menus
    menu_specs = [
        ("file", "_File"),
        ("edit", "_Edit"),
        ("debug", "_Debug"),
        ("options", "_Options"),
        ("windows", "_Windows"),
        ("help", "_Help"),
    ]

    if sys.platform == "darwin":
        menu_specs[-2] = ("windows", "_Window")


    # New classes
    from idlelib.IdleHistory import History

    def __init__(self, flist=None):
        if use_subprocess:
            ms = self.menu_specs
            if ms[2][0] != "shell":
                ms.insert(2, ("shell", "She_ll"))
        self.interp = ModifiedInterpreter(self)
        if flist is None:
            root = Tk()
            fixwordbreaks(root)
            root.withdraw()
            flist = PyShellFileList(root)
        #
        OutputWindow.__init__(self, flist, None, None)
        #
##        self.config(usetabs=1, indentwidth=8, context_use_ps1=1)
        self.usetabs = True
        # indentwidth must be 8 when using tabs.  See note in EditorWindow:
        self.indentwidth = 8
        self.context_use_ps1 = True
        #
        text = self.text
        text.configure(wrap="char")
        text.bind("<<newline-and-indent>>", self.enter_callback)
        text.bind("<<plain-newline-and-indent>>", self.linefeed_callback)
        text.bind("<<interrupt-execution>>", self.cancel_callback)
        text.bind("<<end-of-file>>", self.eof_callback)
        text.bind("<<open-stack-viewer>>", self.open_stack_viewer)
        text.bind("<<toggle-debugger>>", self.toggle_debugger)
        text.bind("<<toggle-jit-stack-viewer>>", self.toggle_jit_stack_viewer)
        if use_subprocess:
            text.bind("<<view-restart>>", self.view_restart_mark)
            text.bind("<<restart-shell>>", self.restart_shell)
        #
        self.save_stdout = sys.stdout
        self.save_stderr = sys.stderr
        self.save_stdin = sys.stdin
        from idlelib import IOBinding
        self.stdin = PseudoInputFile(self, "stdin", IOBinding.encoding)
        self.stdout = PseudoOutputFile(self, "stdout", IOBinding.encoding)
        self.stderr = PseudoOutputFile(self, "stderr", IOBinding.encoding)
        self.console = PseudoOutputFile(self, "console", IOBinding.encoding)
        if not use_subprocess:
            sys.stdout = self.stdout
            sys.stderr = self.stderr
            sys.stdin = self.stdin
        try:
            # page help() text to shell.
            import pydoc # import must be done here to capture i/o rebinding.
            # XXX KBK 27Dec07 use a textView someday, but must work w/o subproc
            pydoc.pager = pydoc.plainpager
        except:
            sys.stderr = sys.__stderr__
            raise
        #
        self.history = self.History(self.text)
        #
        self.pollinterval = 50  # millisec

    def get_standard_extension_names(self):
        return idleConf.GetExtensions(shell_only=True)

    reading = False
    executing = False
    canceled = False
    endoffile = False
    closing = False
    _stop_readline_flag = False

    def set_warning_stream(self, stream):
        global warning_stream
        warning_stream = stream

    def get_warning_stream(self):
        return warning_stream

    def toggle_debugger(self, event=None):
        if self.executing:
            tkMessageBox.showerror("Don't debug now",
                "You can only toggle the debugger when idle",
                master=self.text)
            self.set_debugger_indicator()
            return "break"
        else:
            db = self.interp.getdebugger()
            if db:
                self.close_debugger()
            else:
                self.open_debugger()

    def set_debugger_indicator(self):
        db = self.interp.getdebugger()
        self.setvar("<<toggle-debugger>>", not not db)

    def toggle_jit_stack_viewer(self, event=None):
        pass # All we need is the variable

    def close_debugger(self):
        db = self.interp.getdebugger()
        if db:
            self.interp.setdebugger(None)
            db.close()
            if self.interp.rpcclt:
                RemoteDebugger.close_remote_debugger(self.interp.rpcclt)
            self.resetoutput()
            self.console.write("[DEBUG OFF]\n")
            sys.ps1 = ">>> "
            self.showprompt()
        self.set_debugger_indicator()

    def open_debugger(self):
        if self.interp.rpcclt:
            dbg_gui = RemoteDebugger.start_remote_debugger(self.interp.rpcclt,
                                                           self)
        else:
            dbg_gui = Debugger.Debugger(self)
        self.interp.setdebugger(dbg_gui)
        dbg_gui.load_breakpoints()
        sys.ps1 = "[DEBUG ON]\n>>> "
        self.showprompt()
        self.set_debugger_indicator()

    def beginexecuting(self):
        "Helper for ModifiedInterpreter"
        self.resetoutput()
        self.executing = 1

    def endexecuting(self):
        "Helper for ModifiedInterpreter"
        self.executing = 0
        self.canceled = 0
        self.showprompt()

    def close(self):
        "Extend EditorWindow.close()"
        if self.executing:
            response = tkMessageBox.askokcancel(
                "Kill?",
                "The program is still running!\n Do you want to kill it?",
                default="ok",
                parent=self.text)
            if response is False:
                return "cancel"
        self.stop_readline()
        self.canceled = True
        self.closing = True
        return EditorWindow.close(self)

    def _close(self):
        "Extend EditorWindow._close(), shut down debugger and execution server"
        self.close_debugger()
        if use_subprocess:
            self.interp.kill_subprocess()
        # Restore std streams
        sys.stdout = self.save_stdout
        sys.stderr = self.save_stderr
        sys.stdin = self.save_stdin
        # Break cycles
        self.interp = None
        self.console = None
        self.flist.pyshell = None
        self.history = None
        EditorWindow._close(self)

    def ispythonsource(self, filename):
        "Override EditorWindow method: never remove the colorizer"
        return True

    def short_title(self):
        return self.shell_title

    COPYRIGHT = \
          'Type "copyright", "credits" or "license()" for more information.'

    def begin(self):
        self.text.mark_set("iomark", "insert")
        self.resetoutput()
        if use_subprocess:
            nosub = ''
            client = self.interp.start_subprocess()
            if not client:
                self.close()
                return False
        else:
            nosub = ("==== No Subprocess ====\n\n" +
                    "WARNING: Running IDLE without a Subprocess is deprecated\n" +
                    "and will be removed in a later version. See Help/IDLE Help\n" +
                    "for details.\n\n")
            sys.displayhook = rpc.displayhook

        self.write("Python %s on %s\n%s\n%s" %
                   (sys.version, sys.platform, self.COPYRIGHT, nosub))
        self.showprompt()
        import tkinter
        tkinter._default_root = None # 03Jan04 KBK What's this?
        return True

    def stop_readline(self):
        if not self.reading:  # no nested mainloop to exit.
            return
        self._stop_readline_flag = True
        self.top.quit()

    def readline(self):
        save = self.reading
        try:
            self.reading = 1
            self.top.mainloop()  # nested mainloop()
        finally:
            self.reading = save
        if self._stop_readline_flag:
            self._stop_readline_flag = False
            return ""
        line = self.text.get("iomark", "end-1c")
        if len(line) == 0:  # may be EOF if we quit our mainloop with Ctrl-C
            line = "\n"
        self.resetoutput()
        if self.canceled:
            self.canceled = 0
            if not use_subprocess:
                raise KeyboardInterrupt
        if self.endoffile:
            self.endoffile = 0
            line = ""
        return line

    def isatty(self):
        return True

    def cancel_callback(self, event=None):
        try:
            if self.text.compare("sel.first", "!=", "sel.last"):
                return # Active selection -- always use default binding
        except:
            pass
        if not (self.executing or self.reading):
            self.resetoutput()
            self.interp.write("KeyboardInterrupt\n")
            self.showprompt()
            return "break"
        self.endoffile = 0
        self.canceled = 1
        if (self.executing and self.interp.rpcclt):
            if self.interp.getdebugger():
                self.interp.restart_subprocess()
            else:
                self.interp.interrupt_subprocess()
        if self.reading:
            self.top.quit()  # exit the nested mainloop() in readline()
        return "break"

    def eof_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (delete next char) take over
        if not (self.text.compare("iomark", "==", "insert") and
                self.text.compare("insert", "==", "end-1c")):
            return # Let the default binding (delete next char) take over
        if not self.executing:
            self.resetoutput()
            self.close()
        else:
            self.canceled = 0
            self.endoffile = 1
            self.top.quit()
        return "break"

    def linefeed_callback(self, event):
        # Insert a linefeed without entering anything (still autoindented)
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        return "break"

    def enter_callback(self, event):
        if self.executing and not self.reading:
            return # Let the default binding (insert '\n') take over
        # If some text is selected, recall the selection
        # (but only if this before the I/O mark)
        try:
            sel = self.text.get("sel.first", "sel.last")
            if sel:
                if self.text.compare("sel.last", "<=", "iomark"):
                    self.recall(sel, event)
                    return "break"
        except:
            pass
        # If we're strictly before the line containing iomark, recall
        # the current line, less a leading prompt, less leading or
        # trailing whitespace
        if self.text.compare("insert", "<", "iomark linestart"):
            # Check if there's a relevant stdin range -- if so, use it
            prev = self.text.tag_prevrange("stdin", "insert")
            if prev and self.text.compare("insert", "<", prev[1]):
                self.recall(self.text.get(prev[0], prev[1]), event)
                return "break"
            next = self.text.tag_nextrange("stdin", "insert")
            if next and self.text.compare("insert lineend", ">=", next[0]):
                self.recall(self.text.get(next[0], next[1]), event)
                return "break"
            # No stdin mark -- just get the current line, less any prompt
            indices = self.text.tag_nextrange("console", "insert linestart")
            if indices and \
               self.text.compare(indices[0], "<=", "insert linestart"):
                self.recall(self.text.get(indices[1], "insert lineend"), event)
            else:
                self.recall(self.text.get("insert linestart", "insert lineend"), event)
            return "break"
        # If we're between the beginning of the line and the iomark, i.e.
        # in the prompt area, move to the end of the prompt
        if self.text.compare("insert", "<", "iomark"):
            self.text.mark_set("insert", "iomark")
        # If we're in the current input and there's only whitespace
        # beyond the cursor, erase that whitespace first
        s = self.text.get("insert", "end-1c")
        if s and not s.strip():
            self.text.delete("insert", "end-1c")
        # If we're in the current input before its last line,
        # insert a newline right at the insert point
        if self.text.compare("insert", "<", "end-1c linestart"):
            self.newline_and_indent_event(event)
            return "break"
        # We're in the last line; append a newline and submit it
        self.text.mark_set("insert", "end-1c")
        if self.reading:
            self.text.insert("insert", "\n")
            self.text.see("insert")
        else:
            self.newline_and_indent_event(event)
        self.text.tag_add("stdin", "iomark", "end-1c")
        self.text.update_idletasks()
        if self.reading:
            self.top.quit() # Break out of recursive mainloop()
        else:
            self.runit()
        return "break"

    def recall(self, s, event):
        # remove leading and trailing empty or whitespace lines
        s = re.sub(r'^\s*\n', '' , s)
        s = re.sub(r'\n\s*$', '', s)
        lines = s.split('\n')
        self.text.undo_block_start()
        try:
            self.text.tag_remove("sel", "1.0", "end")
            self.text.mark_set("insert", "end-1c")
            prefix = self.text.get("insert linestart", "insert")
            if prefix.rstrip().endswith(':'):
                self.newline_and_indent_event(event)
                prefix = self.text.get("insert linestart", "insert")
            self.text.insert("insert", lines[0].strip())
            if len(lines) > 1:
                orig_base_indent = re.search(r'^([ \t]*)', lines[0]).group(0)
                new_base_indent  = re.search(r'^([ \t]*)', prefix).group(0)
                for line in lines[1:]:
                    if line.startswith(orig_base_indent):
                        # replace orig base indentation with new indentation
                        line = new_base_indent + line[len(orig_base_indent):]
                    self.text.insert('insert', '\n'+line.rstrip())
        finally:
            self.text.see("insert")
            self.text.undo_block_stop()

    def runit(self):
        line = self.text.get("iomark", "end-1c")
        # Strip off last newline and surrounding whitespace.
        # (To allow you to hit return twice to end a statement.)
        i = len(line)
        while i > 0 and line[i-1] in " \t":
            i = i-1
        if i > 0 and line[i-1] == "\n":
            i = i-1
        while i > 0 and line[i-1] in " \t":
            i = i-1
        line = line[:i]
        more = self.interp.runsource(line)

    def open_stack_viewer(self, event=None):
        if self.interp.rpcclt:
            return self.interp.remote_stack_viewer()
        try:
            sys.last_traceback
        except:
            tkMessageBox.showerror("No stack trace",
                "There is no stack trace yet.\n"
                "(sys.last_traceback is not defined)",
                master=self.text)
            return
        from idlelib.StackViewer import StackBrowser
        sv = StackBrowser(self.root, self.flist)

    def view_restart_mark(self, event=None):
        self.text.see("iomark")
        self.text.see("restart")

    def restart_shell(self, event=None):
        "Callback for Run/Restart Shell Cntl-F6"
        self.interp.restart_subprocess(with_cwd=True)

    def showprompt(self):
        self.resetoutput()
        try:
            s = str(sys.ps1)
        except:
            s = ""
        self.console.write(s)
        self.text.mark_set("insert", "end-1c")
        self.set_line_and_column()
        self.io.reset_undo()

    def resetoutput(self):
        source = self.text.get("iomark", "end-1c")
        if self.history:
            self.history.store(source)
        if self.text.get("end-2c") != "\n":
            self.text.insert("end-1c", "\n")
        self.text.mark_set("iomark", "end-1c")
        self.set_line_and_column()

    def write(self, s, tags=()):
        if isinstance(s, str) and len(s) and max(s) > '\uffff':
            # Tk doesn't support outputting non-BMP characters
            # Let's assume what printed string is not very long,
            # find first non-BMP character and construct informative
            # UnicodeEncodeError exception.
            for start, char in enumerate(s):
                if char > '\uffff':
                    break
            raise UnicodeEncodeError("UCS-2", char, start, start+1,
                                     'Non-BMP character not supported in Tk')
        try:
            self.text.mark_gravity("iomark", "right")
            count = OutputWindow.write(self, s, tags, "iomark")
            self.text.mark_gravity("iomark", "left")
        except:
            raise ###pass  # ### 11Aug07 KBK if we are expecting exceptions
                           # let's find out what they are and be specific.
        if self.canceled:
            self.canceled = 0
            if not use_subprocess:
                raise KeyboardInterrupt
        return count

    def rmenu_check_cut(self):
        try:
            if self.text.compare('sel.first', '<', 'iomark'):
                return 'disabled'
        except TclError: # no selection, so the index 'sel.first' doesn't exist
            return 'disabled'
        return super().rmenu_check_cut()

    def rmenu_check_paste(self):
        if self.text.compare('insert','<','iomark'):
            return 'disabled'
        return super().rmenu_check_paste()

class PseudoFile(io.TextIOBase):

    def __init__(self, shell, tags, encoding=None):
        self.shell = shell
        self.tags = tags
        self._encoding = encoding

    @property
    def encoding(self):
        return self._encoding

    @property
    def name(self):
        return '<%s>' % self.tags

    def isatty(self):
        return True


class PseudoOutputFile(PseudoFile):

    def writable(self):
        return True

    def write(self, s):
        if self.closed:
            raise ValueError("write to closed file")
        if type(s) is not str:
            if not isinstance(s, str):
                raise TypeError('must be str, not ' + type(s).__name__)
            # See issue #19481
            s = str.__str__(s)
        return self.shell.write(s, self.tags)


class PseudoInputFile(PseudoFile):

    def __init__(self, shell, tags, encoding=None):
        PseudoFile.__init__(self, shell, tags, encoding)
        self._line_buffer = ''

    def readable(self):
        return True

    def read(self, size=-1):
        if self.closed:
            raise ValueError("read from closed file")
        if size is None:
            size = -1
        elif not isinstance(size, int):
            raise TypeError('must be int, not ' + type(size).__name__)
        result = self._line_buffer
        self._line_buffer = ''
        if size < 0:
            while True:
                line = self.shell.readline()
                if not line: break
                result += line
        else:
            while len(result) < size:
                line = self.shell.readline()
                if not line: break
                result += line
            self._line_buffer = result[size:]
            result = result[:size]
        return result

    def readline(self, size=-1):
        if self.closed:
            raise ValueError("read from closed file")
        if size is None:
            size = -1
        elif not isinstance(size, int):
            raise TypeError('must be int, not ' + type(size).__name__)
        line = self._line_buffer or self.shell.readline()
        if size < 0:
            size = len(line)
        eol = line.find('\n', 0, size)
        if eol >= 0:
            size = eol + 1
        self._line_buffer = line[size:]
        return line[:size]

    def close(self):
        self.shell.close()


usage_msg = """\

USAGE: idle  [-deins] [-t title] [file]*
       idle  [-dns] [-t title] (-c cmd | -r file) [arg]*
       idle  [-dns] [-t title] - [arg]*

  -h         print this help message and exit
  -n         run IDLE without a subprocess (DEPRECATED,
             see Help/IDLE Help for details)

The following options will override the IDLE 'settings' configuration:

  -e         open an edit window
  -i         open a shell window

The following options imply -i and will open a shell:

  -c cmd     run the command in a shell, or
  -r file    run script from file

  -d         enable the debugger
  -s         run $IDLESTARTUP or $PYTHONSTARTUP before anything else
  -t title   set title of shell window

A default edit window will be bypassed when -c, -r, or - are used.

[arg]* are passed to the command (-c) or script (-r) in sys.argv[1:].

Examples:

idle
        Open an edit window or shell depending on IDLE's configuration.

idle foo.py foobar.py
        Edit the files, also open a shell if configured to start with shell.

idle -est "Baz" foo.py
        Run $IDLESTARTUP or $PYTHONSTARTUP, edit foo.py, and open a shell
        window with the title "Baz".

idle -c "import sys; print(sys.argv)" "foo"
        Open a shell window and run the command, passing "-c" in sys.argv[0]
        and "foo" in sys.argv[1].

idle -d -s -r foo.py "Hello World"
        Open a shell window, run a startup script, enable the debugger, and
        run foo.py, passing "foo.py" in sys.argv[0] and "Hello World" in
        sys.argv[1].

echo "import sys; print(sys.argv)" | idle - "foobar"
        Open a shell window, run the script piped in, passing '' in sys.argv[0]
        and "foobar" in sys.argv[1].
"""

def main():
    global flist, root, use_subprocess

    capture_warnings(True)
    use_subprocess = True
    enable_shell = False
    enable_edit = False
    debug = False
    cmd = None
    script = None
    startup = False
    try:
        opts, args = getopt.getopt(sys.argv[1:], "c:deihnr:st:")
    except getopt.error as msg:
        print("Error: %s\n%s" % (msg, usage_msg), file=sys.stderr)
        sys.exit(2)
    for o, a in opts:
        if o == '-c':
            cmd = a
            enable_shell = True
        if o == '-d':
            debug = True
            enable_shell = True
        if o == '-e':
            enable_edit = True
        if o == '-h':
            sys.stdout.write(usage_msg)
            sys.exit()
        if o == '-i':
            enable_shell = True
        if o == '-n':
            print(" Warning: running IDLE without a subprocess is deprecated.",
                  file=sys.stderr)
            use_subprocess = False
        if o == '-r':
            script = a
            if os.path.isfile(script):
                pass
            else:
                print("No script file: ", script)
                sys.exit()
            enable_shell = True
        if o == '-s':
            startup = True
            enable_shell = True
        if o == '-t':
            PyShell.shell_title = a
            enable_shell = True
    if args and args[0] == '-':
        cmd = sys.stdin.read()
        enable_shell = True
    # process sys.argv and sys.path:
    for i in range(len(sys.path)):
        sys.path[i] = os.path.abspath(sys.path[i])
    if args and args[0] == '-':
        sys.argv = [''] + args[1:]
    elif cmd:
        sys.argv = ['-c'] + args
    elif script:
        sys.argv = [script] + args
    elif args:
        enable_edit = True
        pathx = []
        for filename in args:
            pathx.append(os.path.dirname(filename))
        for dir in pathx:
            dir = os.path.abspath(dir)
            if not dir in sys.path:
                sys.path.insert(0, dir)
    else:
        dir = os.getcwd()
        if dir not in sys.path:
            sys.path.insert(0, dir)
    # check the IDLE settings configuration (but command line overrides)
    edit_start = idleConf.GetOption('main', 'General',
                                    'editor-on-startup', type='bool')
    enable_edit = enable_edit or edit_start
    enable_shell = enable_shell or not enable_edit
    # start editor and/or shell windows:
    root = Tk(className="Idle")

    # set application icon
    icondir = os.path.join(os.path.dirname(__file__), 'Icons')
    if system() == 'Windows':
        iconfile = os.path.join(icondir, 'idle.ico')
        root.wm_iconbitmap(default=iconfile)
    elif TkVersion >= 8.5:
        ext = '.png' if TkVersion >= 8.6 else '.gif'
        iconfiles = [os.path.join(icondir, 'idle_%d%s' % (size, ext))
                     for size in (16, 32, 48)]
        icons = [PhotoImage(file=iconfile) for iconfile in iconfiles]
        root.wm_iconphoto(True, *icons)

    fixwordbreaks(root)
    root.withdraw()
    flist = PyShellFileList(root)
    macosxSupport.setupApp(root, flist)

    if enable_edit:
        if not (cmd or script):
            for filename in args[:]:
                if flist.open(filename) is None:
                    # filename is a directory actually, disconsider it
                    args.remove(filename)
            if not args:
                flist.new()

    if enable_shell:
        shell = flist.open_shell()
        if not shell:
            return # couldn't open shell
        if macosxSupport.isAquaTk() and flist.dict:
            # On OSX: when the user has double-clicked on a file that causes
            # IDLE to be launched the shell window will open just in front of
            # the file she wants to see. Lower the interpreter window when
            # there are open files.
            shell.top.lower()
    else:
        shell = flist.pyshell

    # Handle remaining options. If any of these are set, enable_shell
    # was set also, so shell must be true to reach here.
    if debug:
        shell.open_debugger()
    if startup:
        filename = os.environ.get("IDLESTARTUP") or \
                   os.environ.get("PYTHONSTARTUP")
        if filename and os.path.isfile(filename):
            shell.interp.execfile(filename)
    if cmd or script:
        shell.interp.runcommand("""if 1:
            import sys as _sys
            _sys.argv = %r
            del _sys
            \n""" % (sys.argv,))
        if cmd:
            shell.interp.execsource(cmd)
        elif script:
            shell.interp.prepend_syspath(script)
            shell.interp.execfile(script)
    elif shell:
        # If there is a shell window and no cmd or script in progress,
        # check for problematic OS X Tk versions and print a warning
        # message in the IDLE shell window; this is less intrusive
        # than always opening a separate window.
        tkversionwarning = macosxSupport.tkVersionWarning(root)
        if tkversionwarning:
            shell.interp.runcommand("print('%s')" % tkversionwarning)

    while flist.inversedict:  # keep IDLE running while files are open.
        root.mainloop()
    root.destroy()
    capture_warnings(False)

if __name__ == "__main__":
    sys.modules['PyShell'] = sys.modules['__main__']
    main()

capture_warnings(False)  # Make sure turned off; see issue 18081
                                                                                                                                                                                                                                                                                                                                              usr/lib/python3.4/idlelib/README.txt                                                                0100644 0000000 0000000 00000004706 12415221640 015500  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        IDLE is Python's Tkinter-based Integrated DeveLopment Environment.

IDLE emphasizes a lightweight, clean design with a simple user interface.
Although it is suitable for beginners, even advanced users will find that
IDLE has everything they really need to develop pure Python code.

IDLE features a multi-window text editor with multiple undo, Python colorizing,
and many other capabilities, e.g. smart indent, call tips, and autocompletion.

The editor has comprehensive search functions, including searching through
multiple files.  Class browsers and path browsers provide fast access to
code objects from a top level viewpoint without dealing with code folding.

There is a Python Shell window which features colorizing and command recall.

IDLE executes Python code in a separate process, which is restarted for each
Run (F5) initiated from an editor window.  The environment can also be 
restarted from the Shell window without restarting IDLE.

This enhancement has often been requested, and is now finally available.  The
magic "reload/import *" incantations are no longer required when editing and
testing a module two or three steps down the import chain.

(Personal firewall software may warn about the connection IDLE makes to its
subprocess using this computer's internal loopback interface.  This connection
is not visible on any external interface and no data is sent to or received
from the Internet.)

It is possible to interrupt tightly looping user code, even on Windows.

Applications which cannot support subprocesses and/or sockets can still run
IDLE in a single process.

IDLE has an integrated debugger with stepping, persistent breakpoints, and call
stack visibility.

There is a GUI configuration manager which makes it easy to select fonts,
colors, keybindings, and startup options.  This facility includes a feature
which allows the user to specify additional help sources, either locally or on
the web.

IDLE is coded in 100% pure Python, using the Tkinter GUI toolkit (Tk/Tcl)
and is cross-platform, working on Unix, Mac, and Windows.

IDLE accepts command line arguments.  Try idle -h to see the options.


If you find bugs or have suggestions or patches, let us know about
them by using the Python issue tracker:

http://bugs.python.org

For further details and links, read the Help files and check the IDLE home
page at

http://www.python.org/idle/

There is a mail list for IDLE: idle-dev@python.org.  You can join at

http://mail.python.org/mailman/listinfo/idle-dev
                                                          usr/lib/python3.4/idlelib/RemoteDebugger.py                                                         0100644 0000000 0000000 00000027375 12415221640 017263  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Support for remote Python debugging.

Some ASCII art to describe the structure:

       IN PYTHON SUBPROCESS          #             IN IDLE PROCESS
                                     #
                                     #        oid='gui_adapter'
                 +----------+        #       +------------+          +-----+
                 | GUIProxy |--remote#call-->| GUIAdapter |--calls-->| GUI |
+-----+--calls-->+----------+        #       +------------+          +-----+
| Idb |                               #                             /
+-----+<-calls--+------------+         #      +----------+<--calls-/
                | IdbAdapter |<--remote#call--| IdbProxy |
                +------------+         #      +----------+
                oid='idb_adapter'      #

The purpose of the Proxy and Adapter classes is to translate certain
arguments and return values that cannot be transported through the RPC
barrier, in particular frame and traceback objects.

"""

import types
from idlelib import rpc
from idlelib import Debugger

debugging = 0

idb_adap_oid = "idb_adapter"
gui_adap_oid = "gui_adapter"

#=======================================
#
# In the PYTHON subprocess:

frametable = {}
dicttable = {}
codetable = {}
tracebacktable = {}

def wrap_frame(frame):
    fid = id(frame)
    frametable[fid] = frame
    return fid

def wrap_info(info):
    "replace info[2], a traceback instance, by its ID"
    if info is None:
        return None
    else:
        traceback = info[2]
        assert isinstance(traceback, types.TracebackType)
        traceback_id = id(traceback)
        tracebacktable[traceback_id] = traceback
        modified_info = (info[0], info[1], traceback_id)
        return modified_info

class GUIProxy:

    def __init__(self, conn, gui_adap_oid):
        self.conn = conn
        self.oid = gui_adap_oid

    def interaction(self, message, frame, info=None):
        # calls rpc.SocketIO.remotecall() via run.MyHandler instance
        # pass frame and traceback object IDs instead of the objects themselves
        self.conn.remotecall(self.oid, "interaction",
                             (message, wrap_frame(frame), wrap_info(info)),
                             {})

class IdbAdapter:

    def __init__(self, idb):
        self.idb = idb

    #----------called by an IdbProxy----------

    def set_step(self):
        self.idb.set_step()

    def set_quit(self):
        self.idb.set_quit()

    def set_continue(self):
        self.idb.set_continue()

    def set_next(self, fid):
        frame = frametable[fid]
        self.idb.set_next(frame)

    def set_return(self, fid):
        frame = frametable[fid]
        self.idb.set_return(frame)

    def get_stack(self, fid, tbid):
        frame = frametable[fid]
        if tbid is None:
            tb = None
        else:
            tb = tracebacktable[tbid]
        stack, i = self.idb.get_stack(frame, tb)
        stack = [(wrap_frame(frame), k) for frame, k in stack]
        return stack, i

    def run(self, cmd):
        import __main__
        self.idb.run(cmd, __main__.__dict__)

    def set_break(self, filename, lineno):
        msg = self.idb.set_break(filename, lineno)
        return msg

    def clear_break(self, filename, lineno):
        msg = self.idb.clear_break(filename, lineno)
        return msg

    def clear_all_file_breaks(self, filename):
        msg = self.idb.clear_all_file_breaks(filename)
        return msg

    #----------called by a FrameProxy----------

    def frame_attr(self, fid, name):
        frame = frametable[fid]
        return getattr(frame, name)

    def frame_globals(self, fid):
        frame = frametable[fid]
        dict = frame.f_globals
        did = id(dict)
        dicttable[did] = dict
        return did

    def frame_locals(self, fid):
        frame = frametable[fid]
        dict = frame.f_locals
        did = id(dict)
        dicttable[did] = dict
        return did

    def frame_code(self, fid):
        frame = frametable[fid]
        code = frame.f_code
        cid = id(code)
        codetable[cid] = code
        return cid

    #----------called by a CodeProxy----------

    def code_name(self, cid):
        code = codetable[cid]
        return code.co_name

    def code_filename(self, cid):
        code = codetable[cid]
        return code.co_filename

    #----------called by a DictProxy----------

    def dict_keys(self, did):
        raise NotImplemented("dict_keys not public or pickleable")
##         dict = dicttable[did]
##         return dict.keys()

    ### Needed until dict_keys is type is finished and pickealable.
    ### Will probably need to extend rpc.py:SocketIO._proxify at that time.
    def dict_keys_list(self, did):
        dict = dicttable[did]
        return list(dict.keys())

    def dict_item(self, did, key):
        dict = dicttable[did]
        value = dict[key]
        value = repr(value) ### can't pickle module 'builtins'
        return value

#----------end class IdbAdapter----------


def start_debugger(rpchandler, gui_adap_oid):
    """Start the debugger and its RPC link in the Python subprocess

    Start the subprocess side of the split debugger and set up that side of the
    RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
    objects and linking them together.  Register the IdbAdapter with the
    RPCServer to handle RPC requests from the split debugger GUI via the
    IdbProxy.

    """
    gui_proxy = GUIProxy(rpchandler, gui_adap_oid)
    idb = Debugger.Idb(gui_proxy)
    idb_adap = IdbAdapter(idb)
    rpchandler.register(idb_adap_oid, idb_adap)
    return idb_adap_oid


#=======================================
#
# In the IDLE process:


class FrameProxy:

    def __init__(self, conn, fid):
        self._conn = conn
        self._fid = fid
        self._oid = "idb_adapter"
        self._dictcache = {}

    def __getattr__(self, name):
        if name[:1] == "_":
            raise AttributeError(name)
        if name == "f_code":
            return self._get_f_code()
        if name == "f_globals":
            return self._get_f_globals()
        if name == "f_locals":
            return self._get_f_locals()
        return self._conn.remotecall(self._oid, "frame_attr",
                                     (self._fid, name), {})

    def _get_f_code(self):
        cid = self._conn.remotecall(self._oid, "frame_code", (self._fid,), {})
        return CodeProxy(self._conn, self._oid, cid)

    def _get_f_globals(self):
        did = self._conn.remotecall(self._oid, "frame_globals",
                                    (self._fid,), {})
        return self._get_dict_proxy(did)

    def _get_f_locals(self):
        did = self._conn.remotecall(self._oid, "frame_locals",
                                    (self._fid,), {})
        return self._get_dict_proxy(did)

    def _get_dict_proxy(self, did):
        if did in self._dictcache:
            return self._dictcache[did]
        dp = DictProxy(self._conn, self._oid, did)
        self._dictcache[did] = dp
        return dp


class CodeProxy:

    def __init__(self, conn, oid, cid):
        self._conn = conn
        self._oid = oid
        self._cid = cid

    def __getattr__(self, name):
        if name == "co_name":
            return self._conn.remotecall(self._oid, "code_name",
                                         (self._cid,), {})
        if name == "co_filename":
            return self._conn.remotecall(self._oid, "code_filename",
                                         (self._cid,), {})


class DictProxy:

    def __init__(self, conn, oid, did):
        self._conn = conn
        self._oid = oid
        self._did = did

##    def keys(self):
##        return self._conn.remotecall(self._oid, "dict_keys", (self._did,), {})

    # 'temporary' until dict_keys is a pickleable built-in type
    def keys(self):
        return self._conn.remotecall(self._oid,
                                     "dict_keys_list", (self._did,), {})

    def __getitem__(self, key):
        return self._conn.remotecall(self._oid, "dict_item",
                                     (self._did, key), {})

    def __getattr__(self, name):
        ##print("*** Failed DictProxy.__getattr__:", name)
        raise AttributeError(name)


class GUIAdapter:

    def __init__(self, conn, gui):
        self.conn = conn
        self.gui = gui

    def interaction(self, message, fid, modified_info):
        ##print("*** Interaction: (%s, %s, %s)" % (message, fid, modified_info))
        frame = FrameProxy(self.conn, fid)
        self.gui.interaction(message, frame, modified_info)


class IdbProxy:

    def __init__(self, conn, shell, oid):
        self.oid = oid
        self.conn = conn
        self.shell = shell

    def call(self, methodname, *args, **kwargs):
        ##print("*** IdbProxy.call %s %s %s" % (methodname, args, kwargs))
        value = self.conn.remotecall(self.oid, methodname, args, kwargs)
        ##print("*** IdbProxy.call %s returns %r" % (methodname, value))
        return value

    def run(self, cmd, locals):
        # Ignores locals on purpose!
        seq = self.conn.asyncqueue(self.oid, "run", (cmd,), {})
        self.shell.interp.active_seq = seq

    def get_stack(self, frame, tbid):
        # passing frame and traceback IDs, not the objects themselves
        stack, i = self.call("get_stack", frame._fid, tbid)
        stack = [(FrameProxy(self.conn, fid), k) for fid, k in stack]
        return stack, i

    def set_continue(self):
        self.call("set_continue")

    def set_step(self):
        self.call("set_step")

    def set_next(self, frame):
        self.call("set_next", frame._fid)

    def set_return(self, frame):
        self.call("set_return", frame._fid)

    def set_quit(self):
        self.call("set_quit")

    def set_break(self, filename, lineno):
        msg = self.call("set_break", filename, lineno)
        return msg

    def clear_break(self, filename, lineno):
        msg = self.call("clear_break", filename, lineno)
        return msg

    def clear_all_file_breaks(self, filename):
        msg = self.call("clear_all_file_breaks", filename)
        return msg

def start_remote_debugger(rpcclt, pyshell):
    """Start the subprocess debugger, initialize the debugger GUI and RPC link

    Request the RPCServer start the Python subprocess debugger and link.  Set
    up the Idle side of the split debugger by instantiating the IdbProxy,
    debugger GUI, and debugger GUIAdapter objects and linking them together.

    Register the GUIAdapter with the RPCClient to handle debugger GUI
    interaction requests coming from the subprocess debugger via the GUIProxy.

    The IdbAdapter will pass execution and environment requests coming from the
    Idle debugger GUI to the subprocess debugger via the IdbProxy.

    """
    global idb_adap_oid

    idb_adap_oid = rpcclt.remotecall("exec", "start_the_debugger",\
                                   (gui_adap_oid,), {})
    idb_proxy = IdbProxy(rpcclt, pyshell, idb_adap_oid)
    gui = Debugger.Debugger(pyshell, idb_proxy)
    gui_adap = GUIAdapter(rpcclt, gui)
    rpcclt.register(gui_adap_oid, gui_adap)
    return gui

def close_remote_debugger(rpcclt):
    """Shut down subprocess debugger and Idle side of debugger RPC link

    Request that the RPCServer shut down the subprocess debugger and link.
    Unregister the GUIAdapter, which will cause a GC on the Idle process
    debugger and RPC link objects.  (The second reference to the debugger GUI
    is deleted in PyShell.close_remote_debugger().)

    """
    close_subprocess_debugger(rpcclt)
    rpcclt.unregister(gui_adap_oid)

def close_subprocess_debugger(rpcclt):
    rpcclt.remotecall("exec", "stop_the_debugger", (idb_adap_oid,), {})

def restart_subprocess_debugger(rpcclt):
    idb_adap_oid_ret = rpcclt.remotecall("exec", "start_the_debugger",\
                                         (gui_adap_oid,), {})
    assert idb_adap_oid_ret == idb_adap_oid, 'Idb restarted with different oid'
                                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/RemoteObjectBrowser.py                                                    0100644 0000000 0000000 00000001704 12415221640 020275  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from idlelib import rpc

def remote_object_tree_item(item):
    wrapper = WrappedObjectTreeItem(item)
    oid = id(wrapper)
    rpc.objecttable[oid] = wrapper
    return oid

class WrappedObjectTreeItem:
    # Lives in PYTHON subprocess

    def __init__(self, item):
        self.__item = item

    def __getattr__(self, name):
        value = getattr(self.__item, name)
        return value

    def _GetSubList(self):
        sub_list = self.__item._GetSubList()
        return list(map(remote_object_tree_item, sub_list))

class StubObjectTreeItem:
    # Lives in IDLE process

    def __init__(self, sockio, oid):
        self.sockio = sockio
        self.oid = oid

    def __getattr__(self, name):
        value = rpc.MethodProxy(self.sockio, self.oid, name)
        return value

    def _GetSubList(self):
        sub_list = self.sockio.remotecall(self.oid, "_GetSubList", (), {})
        return [StubObjectTreeItem(self.sockio, oid) for oid in sub_list]
                                                            usr/lib/python3.4/idlelib/ReplaceDialog.py                                                          0100644 0000000 0000000 00000014762 12415221640 017052  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *

from idlelib import SearchEngine
from idlelib.SearchDialogBase import SearchDialogBase
import re


def replace(text):
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_replacedialog"):
        engine._replacedialog = ReplaceDialog(root, engine)
    dialog = engine._replacedialog
    dialog.open(text)


class ReplaceDialog(SearchDialogBase):

    title = "Replace Dialog"
    icon = "Replace"

    def __init__(self, root, engine):
        SearchDialogBase.__init__(self, root, engine)
        self.replvar = StringVar(root)

    def open(self, text):
        SearchDialogBase.open(self, text)
        try:
            first = text.index("sel.first")
        except TclError:
            first = None
        try:
            last = text.index("sel.last")
        except TclError:
            last = None
        first = first or text.index("insert")
        last = last or first
        self.show_hit(first, last)
        self.ok = 1

    def create_entries(self):
        SearchDialogBase.create_entries(self)
        self.replent = self.make_entry("Replace with:", self.replvar)[0]

    def create_command_buttons(self):
        SearchDialogBase.create_command_buttons(self)
        self.make_button("Find", self.find_it)
        self.make_button("Replace", self.replace_it)
        self.make_button("Replace+Find", self.default_command, 1)
        self.make_button("Replace All", self.replace_all)

    def find_it(self, event=None):
        self.do_find(0)

    def replace_it(self, event=None):
        if self.do_find(self.ok):
            self.do_replace()

    def default_command(self, event=None):
        if self.do_find(self.ok):
            if self.do_replace():   # Only find next match if replace succeeded.
                                    # A bad re can cause a it to fail.
                self.do_find(0)

    def _replace_expand(self, m, repl):
        """ Helper function for expanding a regular expression
            in the replace field, if needed. """
        if self.engine.isre():
            try:
                new = m.expand(repl)
            except re.error:
                self.engine.report_error(repl, 'Invalid Replace Expression')
                new = None
        else:
            new = repl

        return new

    def replace_all(self, event=None):
        prog = self.engine.getprog()
        if not prog:
            return
        repl = self.replvar.get()
        text = self.text
        res = self.engine.search_text(text, prog)
        if not res:
            text.bell()
            return
        text.tag_remove("sel", "1.0", "end")
        text.tag_remove("hit", "1.0", "end")
        line = res[0]
        col = res[1].start()
        if self.engine.iswrap():
            line = 1
            col = 0
        ok = 1
        first = last = None
        # XXX ought to replace circular instead of top-to-bottom when wrapping
        text.undo_block_start()
        while 1:
            res = self.engine.search_forward(text, prog, line, col, 0, ok)
            if not res:
                break
            line, m = res
            chars = text.get("%d.0" % line, "%d.0" % (line+1))
            orig = m.group()
            new = self._replace_expand(m, repl)
            if new is None:
                break
            i, j = m.span()
            first = "%d.%d" % (line, i)
            last = "%d.%d" % (line, j)
            if new == orig:
                text.mark_set("insert", last)
            else:
                text.mark_set("insert", first)
                if first != last:
                    text.delete(first, last)
                if new:
                    text.insert(first, new)
            col = i + len(new)
            ok = 0
        text.undo_block_stop()
        if first and last:
            self.show_hit(first, last)
        self.close()

    def do_find(self, ok=0):
        if not self.engine.getprog():
            return False
        text = self.text
        res = self.engine.search_text(text, None, ok)
        if not res:
            text.bell()
            return False
        line, m = res
        i, j = m.span()
        first = "%d.%d" % (line, i)
        last = "%d.%d" % (line, j)
        self.show_hit(first, last)
        self.ok = 1
        return True

    def do_replace(self):
        prog = self.engine.getprog()
        if not prog:
            return False
        text = self.text
        try:
            first = pos = text.index("sel.first")
            last = text.index("sel.last")
        except TclError:
            pos = None
        if not pos:
            first = last = pos = text.index("insert")
        line, col = SearchEngine.get_line_col(pos)
        chars = text.get("%d.0" % line, "%d.0" % (line+1))
        m = prog.match(chars, col)
        if not prog:
            return False
        new = self._replace_expand(m, self.replvar.get())
        if new is None:
            return False
        text.mark_set("insert", first)
        text.undo_block_start()
        if m.group():
            text.delete(first, last)
        if new:
            text.insert(first, new)
        text.undo_block_stop()
        self.show_hit(first, text.index("insert"))
        self.ok = 0
        return True

    def show_hit(self, first, last):
        text = self.text
        text.mark_set("insert", first)
        text.tag_remove("sel", "1.0", "end")
        text.tag_add("sel", first, last)
        text.tag_remove("hit", "1.0", "end")
        if first == last:
            text.tag_add("hit", first)
        else:
            text.tag_add("hit", first, last)
        text.see("insert")
        text.update_idletasks()

    def close(self, event=None):
        SearchDialogBase.close(self, event)
        self.text.tag_remove("hit", "1.0", "end")

def _replace_dialog(parent):
    root = Tk()
    root.title("Test ReplaceDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))

    # mock undo delegator methods
    def undo_block_start():
        pass

    def undo_block_stop():
        pass

    text = Text(root)
    text.undo_block_start = undo_block_start
    text.undo_block_stop = undo_block_stop
    text.pack()
    text.insert("insert","This is a sample string.\n"*10)

    def show_replace():
        text.tag_add(SEL, "1.0", END)
        replace(text)
        text.tag_remove(SEL, "1.0", END)

    button = Button(root, text="Replace", command=show_replace)
    button.pack()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_replace_dialog)
              usr/lib/python3.4/idlelib/RstripExtension.py                                                        0100644 0000000 0000000 00000002032 12415221640 017522  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        'Provides "Strip trailing whitespace" under the "Format" menu.'

class RstripExtension:

    menudefs = [
        ('format', [None, ('Strip trailing whitespace', '<<do-rstrip>>'), ] ), ]

    def __init__(self, editwin):
        self.editwin = editwin
        self.editwin.text.bind("<<do-rstrip>>", self.do_rstrip)

    def do_rstrip(self, event=None):

        text = self.editwin.text
        undo = self.editwin.undo

        undo.undo_block_start()

        end_line = int(float(text.index('end')))
        for cur in range(1, end_line):
            txt = text.get('%i.0' % cur, '%i.end' % cur)
            raw = len(txt)
            cut = len(txt.rstrip())
            # Since text.delete() marks file as changed, even if not,
            # only call it when needed to actually delete something.
            if cut < raw:
                text.delete('%i.%i' % (cur, cut), '%i.end' % cur)

        undo.undo_block_stop()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_rstrip', verbosity=2, exit=False)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/ScriptBinding.py                                                          0100644 0000000 0000000 00000017571 12415221640 017117  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """Extension to execute code outside the Python shell window.

This adds the following commands:

- Check module does a full syntax check of the current module.
  It also runs the tabnanny to catch any inconsistent tabs.

- Run module executes the module's code in the __main__ namespace.  The window
  must have been saved previously. The module is added to sys.modules, and is
  also added to the __main__ namespace.

XXX GvR Redesign this interface (yet again) as follows:

- Present a dialog box for ``Run Module''

- Allow specify command line arguments in the dialog box

"""

import os
import re
import string
import tabnanny
import tokenize
import tkinter.messagebox as tkMessageBox
from idlelib.EditorWindow import EditorWindow
from idlelib import PyShell, IOBinding

from idlelib.configHandler import idleConf
from idlelib import macosxSupport

indent_message = """Error: Inconsistent indentation detected!

1) Your indentation is outright incorrect (easy to fix), OR

2) Your indentation mixes tabs and spaces.

To fix case 2, change all tabs to spaces by using Edit->Select All followed \
by Format->Untabify Region and specify the number of columns used by each tab.
"""

class ScriptBinding:

    menudefs = [
        ('run', [None,
                 ('Check Module', '<<check-module>>'),
                 ('Run Module', '<<run-module>>'), ]), ]

    def __init__(self, editwin):
        self.editwin = editwin
        # Provide instance variables referenced by Debugger
        # XXX This should be done differently
        self.flist = self.editwin.flist
        self.root = self.editwin.root

        if macosxSupport.isCocoaTk():
            self.editwin.text_frame.bind('<<run-module-event-2>>', self._run_module_event)

    def check_module_event(self, event):
        filename = self.getfilename()
        if not filename:
            return 'break'
        if not self.checksyntax(filename):
            return 'break'
        if not self.tabnanny(filename):
            return 'break'

    def tabnanny(self, filename):
        # XXX: tabnanny should work on binary files as well
        with tokenize.open(filename) as f:
            try:
                tabnanny.process_tokens(tokenize.generate_tokens(f.readline))
            except tokenize.TokenError as msg:
                msgtxt, (lineno, start) = msg
                self.editwin.gotoline(lineno)
                self.errorbox("Tabnanny Tokenizing Error",
                              "Token Error: %s" % msgtxt)
                return False
            except tabnanny.NannyNag as nag:
                # The error messages from tabnanny are too confusing...
                self.editwin.gotoline(nag.get_lineno())
                self.errorbox("Tab/space error", indent_message)
                return False
        return True

    def checksyntax(self, filename):
        self.shell = shell = self.flist.open_shell()
        saved_stream = shell.get_warning_stream()
        shell.set_warning_stream(shell.stderr)
        with open(filename, 'rb') as f:
            source = f.read()
        if b'\r' in source:
            source = source.replace(b'\r\n', b'\n')
            source = source.replace(b'\r', b'\n')
        if source and source[-1] != ord(b'\n'):
            source = source + b'\n'
        editwin = self.editwin
        text = editwin.text
        text.tag_remove("ERROR", "1.0", "end")
        try:
            # If successful, return the compiled code
            return compile(source, filename, "exec")
        except (SyntaxError, OverflowError, ValueError) as value:
            msg = getattr(value, 'msg', '') or value or "<no detail available>"
            lineno = getattr(value, 'lineno', '') or 1
            offset = getattr(value, 'offset', '') or 0
            if offset == 0:
                lineno += 1  #mark end of offending line
            pos = "0.0 + %d lines + %d chars" % (lineno-1, offset-1)
            editwin.colorize_syntax_error(text, pos)
            self.errorbox("SyntaxError", "%-20s" % msg)
            return False
        finally:
            shell.set_warning_stream(saved_stream)

    def run_module_event(self, event):
        if macosxSupport.isCocoaTk():
            # Tk-Cocoa in MacOSX is broken until at least
            # Tk 8.5.9, and without this rather
            # crude workaround IDLE would hang when a user
            # tries to run a module using the keyboard shortcut
            # (the menu item works fine).
            self.editwin.text_frame.after(200,
                lambda: self.editwin.text_frame.event_generate('<<run-module-event-2>>'))
            return 'break'
        else:
            return self._run_module_event(event)

    def _run_module_event(self, event):
        """Run the module after setting up the environment.

        First check the syntax.  If OK, make sure the shell is active and
        then transfer the arguments, set the run environment's working
        directory to the directory of the module being executed and also
        add that directory to its sys.path if not already included.
        """

        filename = self.getfilename()
        if not filename:
            return 'break'
        code = self.checksyntax(filename)
        if not code:
            return 'break'
        if not self.tabnanny(filename):
            return 'break'
        interp = self.shell.interp
        if PyShell.use_subprocess:
            interp.restart_subprocess(with_cwd=False)
        dirname = os.path.dirname(filename)
        # XXX Too often this discards arguments the user just set...
        interp.runcommand("""if 1:
            __file__ = {filename!r}
            import sys as _sys
            from os.path import basename as _basename
            if (not _sys.argv or
                _basename(_sys.argv[0]) != _basename(__file__)):
                _sys.argv = [__file__]
            import os as _os
            _os.chdir({dirname!r})
            del _sys, _basename, _os
            \n""".format(filename=filename, dirname=dirname))
        interp.prepend_syspath(filename)
        # XXX KBK 03Jul04 When run w/o subprocess, runtime warnings still
        #         go to __stderr__.  With subprocess, they go to the shell.
        #         Need to change streams in PyShell.ModifiedInterpreter.
        interp.runcode(code)
        return 'break'

    def getfilename(self):
        """Get source filename.  If not saved, offer to save (or create) file

        The debugger requires a source file.  Make sure there is one, and that
        the current version of the source buffer has been saved.  If the user
        declines to save or cancels the Save As dialog, return None.

        If the user has configured IDLE for Autosave, the file will be
        silently saved if it already exists and is dirty.

        """
        filename = self.editwin.io.filename
        if not self.editwin.get_saved():
            autosave = idleConf.GetOption('main', 'General',
                                          'autosave', type='bool')
            if autosave and filename:
                self.editwin.io.save(None)
            else:
                confirm = self.ask_save_dialog()
                self.editwin.text.focus_set()
                if confirm:
                    self.editwin.io.save(None)
                    filename = self.editwin.io.filename
                else:
                    filename = None
        return filename

    def ask_save_dialog(self):
        msg = "Source Must Be Saved\n" + 5*' ' + "OK to Save?"
        confirm = tkMessageBox.askokcancel(title="Save Before Run or Check",
                                           message=msg,
                                           default=tkMessageBox.OK,
                                           master=self.editwin.text)
        return confirm

    def errorbox(self, title, message):
        # XXX This should really be a function of EditorWindow...
        tkMessageBox.showerror(title, message, master=self.editwin.text)
        self.editwin.text.focus_set()
                                                                                                                                       usr/lib/python3.4/idlelib/ScrolledList.py                                                           0100644 0000000 0000000 00000010077 12415221640 016755  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *

class ScrolledList:

    default = "(None)"

    def __init__(self, master, **options):
        # Create top frame, with scrollbar and listbox
        self.master = master
        self.frame = frame = Frame(master)
        self.frame.pack(fill="both", expand=1)
        self.vbar = vbar = Scrollbar(frame, name="vbar")
        self.vbar.pack(side="right", fill="y")
        self.listbox = listbox = Listbox(frame, exportselection=0,
            background="white")
        if options:
            listbox.configure(options)
        listbox.pack(expand=1, fill="both")
        # Tie listbox and scrollbar together
        vbar["command"] = listbox.yview
        listbox["yscrollcommand"] = vbar.set
        # Bind events to the list box
        listbox.bind("<ButtonRelease-1>", self.click_event)
        listbox.bind("<Double-ButtonRelease-1>", self.double_click_event)
        listbox.bind("<ButtonPress-3>", self.popup_event)
        listbox.bind("<Key-Up>", self.up_event)
        listbox.bind("<Key-Down>", self.down_event)
        # Mark as empty
        self.clear()

    def close(self):
        self.frame.destroy()

    def clear(self):
        self.listbox.delete(0, "end")
        self.empty = 1
        self.listbox.insert("end", self.default)

    def append(self, item):
        if self.empty:
            self.listbox.delete(0, "end")
            self.empty = 0
        self.listbox.insert("end", str(item))

    def get(self, index):
        return self.listbox.get(index)

    def click_event(self, event):
        self.listbox.activate("@%d,%d" % (event.x, event.y))
        index = self.listbox.index("active")
        self.select(index)
        self.on_select(index)
        return "break"

    def double_click_event(self, event):
        index = self.listbox.index("active")
        self.select(index)
        self.on_double(index)
        return "break"

    menu = None

    def popup_event(self, event):
        if not self.menu:
            self.make_menu()
        menu = self.menu
        self.listbox.activate("@%d,%d" % (event.x, event.y))
        index = self.listbox.index("active")
        self.select(index)
        menu.tk_popup(event.x_root, event.y_root)

    def make_menu(self):
        menu = Menu(self.listbox, tearoff=0)
        self.menu = menu
        self.fill_menu()

    def up_event(self, event):
        index = self.listbox.index("active")
        if self.listbox.selection_includes(index):
            index = index - 1
        else:
            index = self.listbox.size() - 1
        if index < 0:
            self.listbox.bell()
        else:
            self.select(index)
            self.on_select(index)
        return "break"

    def down_event(self, event):
        index = self.listbox.index("active")
        if self.listbox.selection_includes(index):
            index = index + 1
        else:
            index = 0
        if index >= self.listbox.size():
            self.listbox.bell()
        else:
            self.select(index)
            self.on_select(index)
        return "break"

    def select(self, index):
        self.listbox.focus_set()
        self.listbox.activate(index)
        self.listbox.selection_clear(0, "end")
        self.listbox.selection_set(index)
        self.listbox.see(index)

    # Methods to override for specific actions

    def fill_menu(self):
        pass

    def on_select(self, index):
        pass

    def on_double(self, index):
        pass


def _scrolled_list(parent):
    root = Tk()
    root.title("Test ScrolledList")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    class MyScrolledList(ScrolledList):
        def fill_menu(self): self.menu.add_command(label="right click")
        def on_select(self, index): print("select", self.get(index))
        def on_double(self, index): print("double", self.get(index))

    scrolled_list = MyScrolledList(root)
    for i in range(30):
        scrolled_list.append("Item %02d" % i)

    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_scrolled_list)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/SearchDialog.py                                                           0100644 0000000 0000000 00000005112 12415221640 016671  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *

from idlelib import SearchEngine
from idlelib.SearchDialogBase import SearchDialogBase

def _setup(text):
    root = text._root()
    engine = SearchEngine.get(root)
    if not hasattr(engine, "_searchdialog"):
        engine._searchdialog = SearchDialog(root, engine)
    return engine._searchdialog

def find(text):
    pat = text.get("sel.first", "sel.last")
    return _setup(text).open(text,pat)

def find_again(text):
    return _setup(text).find_again(text)

def find_selection(text):
    return _setup(text).find_selection(text)

class SearchDialog(SearchDialogBase):

    def create_widgets(self):
        f = SearchDialogBase.create_widgets(self)
        self.make_button("Find Next", self.default_command, 1)

    def default_command(self, event=None):
        if not self.engine.getprog():
            return
        self.find_again(self.text)

    def find_again(self, text):
        if not self.engine.getpat():
            self.open(text)
            return False
        if not self.engine.getprog():
            return False
        res = self.engine.search_text(text)
        if res:
            line, m = res
            i, j = m.span()
            first = "%d.%d" % (line, i)
            last = "%d.%d" % (line, j)
            try:
                selfirst = text.index("sel.first")
                sellast = text.index("sel.last")
                if selfirst == first and sellast == last:
                    text.bell()
                    return False
            except TclError:
                pass
            text.tag_remove("sel", "1.0", "end")
            text.tag_add("sel", first, last)
            text.mark_set("insert", self.engine.isback() and first or last)
            text.see("insert")
            return True
        else:
            text.bell()
            return False

    def find_selection(self, text):
        pat = text.get("sel.first", "sel.last")
        if pat:
            self.engine.setcookedpat(pat)
        return self.find_again(text)

def _search_dialog(parent):
    root = Tk()
    root.title("Test SearchDialog")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    text = Text(root)
    text.pack()
    text.insert("insert","This is a sample string.\n"*10)

    def show_find():
        text.tag_add(SEL, "1.0", END)
        s = _setup(text)
        s.open(text)
        text.tag_remove(SEL, "1.0", END)

    button = Button(root, text="Search", command=show_find)
    button.pack()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_search_dialog)
                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/SearchDialogBase.py                                                       0100644 0000000 0000000 00000015541 12415221640 017473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '''Define SearchDialogBase used by Search, Replace, and Grep dialogs.'''

from tkinter import (Toplevel, Frame, Entry, Label, Button,
                     Checkbutton, Radiobutton)

class SearchDialogBase:
    '''Create most of a 3 or 4 row, 3 column search dialog.

    The left and wide middle column contain:
    1 or 2 labeled text entry lines (make_entry, create_entries);
    a row of standard Checkbuttons (make_frame, create_option_buttons),
    each of which corresponds to a search engine Variable;
    a row of dialog-specific Check/Radiobuttons (create_other_buttons).

    The narrow right column contains command buttons
    (make_button, create_command_buttons).
    These are bound to functions that execute the command.

    Except for command buttons, this base class is not limited to items
    common to all three subclasses.  Rather, it is the Find dialog minus
    the "Find Next" command, its execution function, and the
    default_command attribute needed in create_widgets. The other
    dialogs override attributes and methods, the latter to replace and
    add widgets.
    '''

    title = "Search Dialog"  # replace in subclasses
    icon = "Search"
    needwrapbutton = 1  # not in Find in Files

    def __init__(self, root, engine):
        '''Initialize root, engine, and top attributes.

        top (level widget): set in create_widgets() called from open().
        text (Text searched): set in open(), only used in subclasses().
        ent (ry): created in make_entry() called from create_entry().
        row (of grid): 0 in create_widgets(), +1 in make_entry/frame().
        default_command: set in subclasses, used in create_widgers().

        title (of dialog): class attribute, override in subclasses.
        icon (of dialog): ditto, use unclear if cannot minimize dialog.
        '''
        self.root = root
        self.engine = engine
        self.top = None

    def open(self, text, searchphrase=None):
        "Make dialog visible on top of others and ready to use."
        self.text = text
        if not self.top:
            self.create_widgets()
        else:
            self.top.deiconify()
            self.top.tkraise()
        if searchphrase:
            self.ent.delete(0,"end")
            self.ent.insert("end",searchphrase)
        self.ent.focus_set()
        self.ent.selection_range(0, "end")
        self.ent.icursor(0)
        self.top.grab_set()

    def close(self, event=None):
        "Put dialog away for later use."
        if self.top:
            self.top.grab_release()
            self.top.withdraw()

    def create_widgets(self):
        '''Create basic 3 row x 3 col search (find) dialog.

        Other dialogs override subsidiary create_x methods as needed.
        Replace and Find-in-Files add another entry row.
        '''
        top = Toplevel(self.root)
        top.bind("<Return>", self.default_command)
        top.bind("<Escape>", self.close)
        top.protocol("WM_DELETE_WINDOW", self.close)
        top.wm_title(self.title)
        top.wm_iconname(self.icon)
        self.top = top

        self.row = 0
        self.top.grid_columnconfigure(0, pad=2, weight=0)
        self.top.grid_columnconfigure(1, pad=2, minsize=100, weight=100)

        self.create_entries()  # row 0 (and maybe 1), cols 0, 1
        self.create_option_buttons()  # next row, cols 0, 1
        self.create_other_buttons()  # next row, cols 0, 1
        self.create_command_buttons()  # col 2, all rows

    def make_entry(self, label_text, var):
        '''Return (entry, label), .

        entry - gridded labeled Entry for text entry.
        label - Label widget, returned for testing.
        '''
        label = Label(self.top, text=label_text)
        label.grid(row=self.row, column=0, sticky="nw")
        entry = Entry(self.top, textvariable=var, exportselection=0)
        entry.grid(row=self.row, column=1, sticky="nwe")
        self.row = self.row + 1
        return entry, label

    def create_entries(self):
        "Create one or more entry lines with make_entry."
        self.ent = self.make_entry("Find:", self.engine.patvar)[0]

    def make_frame(self,labeltext=None):
        '''Return (frame, label).

        frame - gridded labeled Frame for option or other buttons.
        label - Label widget, returned for testing.
        '''
        if labeltext:
            label = Label(self.top, text=labeltext)
            label.grid(row=self.row, column=0, sticky="nw")
        else:
            label = ''
        frame = Frame(self.top)
        frame.grid(row=self.row, column=1, columnspan=1, sticky="nwe")
        self.row = self.row + 1
        return frame, label

    def create_option_buttons(self):
        '''Return (filled frame, options) for testing.

        Options is a list of SearchEngine booleanvar, label pairs.
        A gridded frame from make_frame is filled with a Checkbutton
        for each pair, bound to the var, with the corresponding label.
        '''
        frame = self.make_frame("Options")[0]
        engine = self.engine
        options = [(engine.revar, "Regular expression"),
                   (engine.casevar, "Match case"),
                   (engine.wordvar, "Whole word")]
        if self.needwrapbutton:
            options.append((engine.wrapvar, "Wrap around"))
        for var, label in options:
            btn = Checkbutton(frame, anchor="w", variable=var, text=label)
            btn.pack(side="left", fill="both")
            if var.get():
                btn.select()
        return frame, options

    def create_other_buttons(self):
        '''Return (frame, others) for testing.

        Others is a list of value, label pairs.
        A gridded frame from make_frame is filled with radio buttons.
        '''
        frame = self.make_frame("Direction")[0]
        var = self.engine.backvar
        others = [(1, 'Up'), (0, 'Down')]
        for val, label in others:
            btn = Radiobutton(frame, anchor="w",
                              variable=var, value=val, text=label)
            btn.pack(side="left", fill="both")
            if var.get() == val:
                btn.select()
        return frame, others

    def make_button(self, label, command, isdef=0):
        "Return command button gridded in command frame."
        b = Button(self.buttonframe,
                   text=label, command=command,
                   default=isdef and "active" or "normal")
        cols,rows=self.buttonframe.grid_size()
        b.grid(pady=1,row=rows,column=0,sticky="ew")
        self.buttonframe.grid(rowspan=rows+1)
        return b

    def create_command_buttons(self):
        "Place buttons in vertical command frame gridded on right."
        f = self.buttonframe = Frame(self.top)
        f.grid(row=0,column=2,padx=2,pady=2,ipadx=2,ipady=2)

        b = self.make_button("close", self.close)
        b.lower()

if __name__ == '__main__':
    import unittest
    unittest.main(
        'idlelib.idle_test.test_searchdialogbase', verbosity=2)
                                                                                                                                                               usr/lib/python3.4/idlelib/SearchEngine.py                                                           0100644 0000000 0000000 00000016473 12415221640 016713  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '''Define SearchEngine for search dialogs.'''
import re
from tkinter import StringVar, BooleanVar, TclError
import tkinter.messagebox as tkMessageBox

def get(root):
    '''Return the singleton SearchEngine instance for the process.

    The single SearchEngine saves settings between dialog instances.
    If there is not a SearchEngine already, make one.
    '''
    if not hasattr(root, "_searchengine"):
        root._searchengine = SearchEngine(root)
        # This creates a cycle that persists until root is deleted.
    return root._searchengine

class SearchEngine:
    """Handles searching a text widget for Find, Replace, and Grep."""

    def __init__(self, root):
        '''Initialize Variables that save search state.

        The dialogs bind these to the UI elements present in the dialogs.
        '''
        self.root = root  # need for report_error()
        self.patvar = StringVar(root, '')   # search pattern
        self.revar = BooleanVar(root, False)   # regular expression?
        self.casevar = BooleanVar(root, False)   # match case?
        self.wordvar = BooleanVar(root, False)   # match whole word?
        self.wrapvar = BooleanVar(root, True)   # wrap around buffer?
        self.backvar = BooleanVar(root, False)   # search backwards?

    # Access methods

    def getpat(self):
        return self.patvar.get()

    def setpat(self, pat):
        self.patvar.set(pat)

    def isre(self):
        return self.revar.get()

    def iscase(self):
        return self.casevar.get()

    def isword(self):
        return self.wordvar.get()

    def iswrap(self):
        return self.wrapvar.get()

    def isback(self):
        return self.backvar.get()

    # Higher level access methods

    def setcookedpat(self, pat):
        "Set pattern after escaping if re."
        # called only in SearchDialog.py: 66
        if self.isre():
            pat = re.escape(pat)
        self.setpat(pat)

    def getcookedpat(self):
        pat = self.getpat()
        if not self.isre():  # if True, see setcookedpat
            pat = re.escape(pat)
        if self.isword():
            pat = r"\b%s\b" % pat
        return pat

    def getprog(self):
        "Return compiled cooked search pattern."
        pat = self.getpat()
        if not pat:
            self.report_error(pat, "Empty regular expression")
            return None
        pat = self.getcookedpat()
        flags = 0
        if not self.iscase():
            flags = flags | re.IGNORECASE
        try:
            prog = re.compile(pat, flags)
        except re.error as what:
            args = what.args
            msg = args[0]
            col = args[1] if len(args) >= 2 else -1
            self.report_error(pat, msg, col)
            return None
        return prog

    def report_error(self, pat, msg, col=-1):
        # Derived class could override this with something fancier
        msg = "Error: " + str(msg)
        if pat:
            msg = msg + "\nPattern: " + str(pat)
        if col >= 0:
            msg = msg + "\nOffset: " + str(col)
        tkMessageBox.showerror("Regular expression error",
                               msg, master=self.root)

    def search_text(self, text, prog=None, ok=0):
        '''Return (lineno, matchobj) or None for forward/backward search.

        This function calls the right function with the right arguments.
        It directly return the result of that call.

        Text is a text widget. Prog is a precompiled pattern.
        The ok parameteris a bit complicated as it has two effects.

        If there is a selection, the search begin at either end,
        depending on the direction setting and ok, with ok meaning that
        the search starts with the selection. Otherwise, search begins
        at the insert mark.

        To aid progress, the search functions do not return an empty
        match at the starting position unless ok is True.
        '''

        if not prog:
            prog = self.getprog()
            if not prog:
                return None # Compilation failed -- stop
        wrap = self.wrapvar.get()
        first, last = get_selection(text)
        if self.isback():
            if ok:
                start = last
            else:
                start = first
            line, col = get_line_col(start)
            res = self.search_backward(text, prog, line, col, wrap, ok)
        else:
            if ok:
                start = first
            else:
                start = last
            line, col = get_line_col(start)
            res = self.search_forward(text, prog, line, col, wrap, ok)
        return res

    def search_forward(self, text, prog, line, col, wrap, ok=0):
        wrapped = 0
        startline = line
        chars = text.get("%d.0" % line, "%d.0" % (line+1))
        while chars:
            m = prog.search(chars[:-1], col)
            if m:
                if ok or m.end() > col:
                    return line, m
            line = line + 1
            if wrapped and line > startline:
                break
            col = 0
            ok = 1
            chars = text.get("%d.0" % line, "%d.0" % (line+1))
            if not chars and wrap:
                wrapped = 1
                wrap = 0
                line = 1
                chars = text.get("1.0", "2.0")
        return None

    def search_backward(self, text, prog, line, col, wrap, ok=0):
        wrapped = 0
        startline = line
        chars = text.get("%d.0" % line, "%d.0" % (line+1))
        while 1:
            m = search_reverse(prog, chars[:-1], col)
            if m:
                if ok or m.start() < col:
                    return line, m
            line = line - 1
            if wrapped and line < startline:
                break
            ok = 1
            if line <= 0:
                if not wrap:
                    break
                wrapped = 1
                wrap = 0
                pos = text.index("end-1c")
                line, col = map(int, pos.split("."))
            chars = text.get("%d.0" % line, "%d.0" % (line+1))
            col = len(chars) - 1
        return None

def search_reverse(prog, chars, col):
    '''Search backwards and return an re match object or None.

    This is done by searching forwards until there is no match.
    Prog: compiled re object with a search method returning a match.
    Chars: line of text, without \n.
    Col: stop index for the search; the limit for match.end().
    '''
    m = prog.search(chars)
    if not m:
        return None
    found = None
    i, j = m.span()  # m.start(), m.end() == match slice indexes
    while i < col and j <= col:
        found = m
        if i == j:
            j = j+1
        m = prog.search(chars, j)
        if not m:
            break
        i, j = m.span()
    return found

def get_selection(text):
    '''Return tuple of 'line.col' indexes from selection or insert mark.
    '''
    try:
        first = text.index("sel.first")
        last = text.index("sel.last")
    except TclError:
        first = last = None
    if not first:
        first = text.index("insert")
    if not last:
        last = first
    return first, last

def get_line_col(index):
    '''Return (line, col) tuple of ints from 'line.col' string.'''
    line, col = map(int, index.split(".")) # Fails on invalid index
    return line, col

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_searchengine', verbosity=2, exit=False)
                                                                                                                                                                                                     usr/lib/python3.4/idlelib/StackViewer.py                                                            0100644 0000000 0000000 00000010472 12415221640 016600  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import os
import sys
import linecache
import re
import tkinter as tk

from idlelib.TreeWidget import TreeNode, TreeItem, ScrolledCanvas
from idlelib.ObjectBrowser import ObjectTreeItem, make_objecttreeitem
from idlelib.PyShell import PyShellFileList

def StackBrowser(root, flist=None, tb=None, top=None):
    if top is None:
        from tkinter import Toplevel
        top = Toplevel(root)
    sc = ScrolledCanvas(top, bg="white", highlightthickness=0)
    sc.frame.pack(expand=1, fill="both")
    item = StackTreeItem(flist, tb)
    node = TreeNode(sc.canvas, None, item)
    node.expand()

class StackTreeItem(TreeItem):

    def __init__(self, flist=None, tb=None):
        self.flist = flist
        self.stack = self.get_stack(tb)
        self.text = self.get_exception()

    def get_stack(self, tb):
        if tb is None:
            tb = sys.last_traceback
        stack = []
        if tb and tb.tb_frame is None:
            tb = tb.tb_next
        while tb is not None:
            stack.append((tb.tb_frame, tb.tb_lineno))
            tb = tb.tb_next
        return stack

    def get_exception(self):
        type = sys.last_type
        value = sys.last_value
        if hasattr(type, "__name__"):
            type = type.__name__
        s = str(type)
        if value is not None:
            s = s + ": " + str(value)
        return s

    def GetText(self):
        return self.text

    def GetSubList(self):
        sublist = []
        for info in self.stack:
            item = FrameTreeItem(info, self.flist)
            sublist.append(item)
        return sublist

class FrameTreeItem(TreeItem):

    def __init__(self, info, flist):
        self.info = info
        self.flist = flist

    def GetText(self):
        frame, lineno = self.info
        try:
            modname = frame.f_globals["__name__"]
        except:
            modname = "?"
        code = frame.f_code
        filename = code.co_filename
        funcname = code.co_name
        sourceline = linecache.getline(filename, lineno)
        sourceline = sourceline.strip()
        if funcname in ("?", "", None):
            item = "%s, line %d: %s" % (modname, lineno, sourceline)
        else:
            item = "%s.%s(...), line %d: %s" % (modname, funcname,
                                             lineno, sourceline)
        return item

    def GetSubList(self):
        frame, lineno = self.info
        sublist = []
        if frame.f_globals is not frame.f_locals:
            item = VariablesTreeItem("<locals>", frame.f_locals, self.flist)
            sublist.append(item)
        item = VariablesTreeItem("<globals>", frame.f_globals, self.flist)
        sublist.append(item)
        return sublist

    def OnDoubleClick(self):
        if self.flist:
            frame, lineno = self.info
            filename = frame.f_code.co_filename
            if os.path.isfile(filename):
                self.flist.gotofileline(filename, lineno)

class VariablesTreeItem(ObjectTreeItem):

    def GetText(self):
        return self.labeltext

    def GetLabelText(self):
        return None

    def IsExpandable(self):
        return len(self.object) > 0

    def keys(self):
        return list(self.object.keys())

    def GetSubList(self):
        sublist = []
        for key in self.keys():
            try:
                value = self.object[key]
            except KeyError:
                continue
            def setfunction(value, key=key, object=self.object):
                object[key] = value
            item = make_objecttreeitem(key + " =", value, setfunction)
            sublist.append(item)
        return sublist

def _stack_viewer(parent):
    root = tk.Tk()
    root.title("Test StackViewer")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    flist = PyShellFileList(root)
    try: # to obtain a traceback object
        intentional_name_error
    except NameError:
        exc_type, exc_value, exc_tb = sys.exc_info()

    # inject stack trace to sys
    sys.last_type = exc_type
    sys.last_value = exc_value
    sys.last_traceback = exc_tb

    StackBrowser(root, flist=flist, top=root, tb=exc_tb)

    # restore sys to original state
    del sys.last_type
    del sys.last_value
    del sys.last_traceback

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_stack_viewer)
                                                                                                                                                                                                      usr/lib/python3.4/idlelib/TODO.txt                                                                  0100644 0000000 0000000 00000020436 12415221640 015306  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Original IDLE todo, much of it now outdated:
============================================
TO DO:

- improve debugger:
    - manage breakpoints globally, allow bp deletion, tbreak, cbreak etc.
    - real object browser
    - help on how to use it (a simple help button will do wonders)
    - performance?  (updates of large sets of locals are slow)
    - better integration of "debug module"
    - debugger should be global resource (attached to flist, not to shell)
    - fix the stupid bug where you need to step twice
    - display class name in stack viewer entries for methods
    - suppress tracing through IDLE internals (e.g. print) DONE
    - add a button to suppress through a specific module or class or method
    - more object inspection to stack viewer, e.g. to view all array items
- insert the initial current directory into sys.path DONE
- default directory attribute for each window instead of only for windows
  that have an associated filename
- command expansion from keywords, module contents, other buffers, etc.
- "Recent documents" menu item DONE
- Filter region command
- Optional horizontal scroll bar
- more Emacsisms:
    - ^K should cut to buffer
    - M-[, M-] to move by paragraphs
    - incremental search?
- search should indicate wrap-around in some way
- restructure state sensitive code to avoid testing flags all the time
- persistent user state (e.g. window and cursor positions, bindings)
- make backups when saving
- check file mtimes at various points
- Pluggable interface with RCS/CVS/Perforce/Clearcase
- better help?
- don't open second class browser on same module (nor second path browser)
- unify class and path browsers
- Need to define a standard way whereby one can determine one is running
  inside IDLE (needed for Tk mainloop, also handy for $PYTHONSTARTUP)
- Add more utility methods for use by extensions (a la get_selection)
- Way to run command in totally separate interpreter (fork+os.system?) DONE
- Way to find definition of fully-qualified name:
  In other words, select "UserDict.UserDict", hit some magic key and
  it loads up UserDict.py and finds the first def or class for UserDict.
- need a way to force colorization on/off
- need a way to force auto-indent on/off

Details:

- ^O (on Unix -- open-line) should honor autoindent
- after paste, show end of pasted text
- on Windows, should turn short filename to long filename (not only in argv!)
  (shouldn't this be done -- or undone -- by ntpath.normpath?)
- new autoindent after colon even indents when the colon is in a comment!
- sometimes forward slashes in pathname remain
- sometimes star in window name remains in Windows menu
- With unix bindings, ESC by itself is ignored
- Sometimes for no apparent reason a selection from the cursor to the
  end of the command buffer appears, which is hard to get rid of
  because it stays when you are typing!
- The Line/Col in the status bar can be wrong initially in PyShell DONE

Structural problems:

- too much knowledge in FileList about EditorWindow (for example)
- should add some primitives for accessing the selection etc.
  to repeat cumbersome code over and over

======================================================================

Jeff Bauer suggests:

- Open Module doesn't appear to handle hierarchical packages.
- Class browser should also allow hierarchical packages.
- Open and Open Module could benefit from a history, DONE
  either command line style, or Microsoft recent-file
  style.
- Add a Smalltalk-style inspector  (i.e. Tkinspect)

The last suggestion is already a reality, but not yet
integrated into IDLE.  I use a module called inspector.py,
that used to be available from python.org(?)  It no longer
appears to be in the contributed section, and the source
has no author attribution.

In any case, the code is useful for visually navigating
an object's attributes, including its container hierarchy.

    >>> from inspector import Tkinspect
    >>> Tkinspect(None, myObject)

Tkinspect could probably be extended and refined to
integrate better into IDLE.

======================================================================

Comparison to PTUI
------------------

+ PTUI's help is better (HTML!)

+ PTUI can attach a shell to any module

+ PTUI has some more I/O commands:
  open multiple
  append
  examine (what's that?)

======================================================================

Notes after trying to run Grail
-------------------------------

- Grail does stuff to sys.path based on sys.argv[0]; you must set
sys.argv[0] to something decent first (it is normally set to the path of
the idle script).

- Grail must be exec'ed in __main__ because that's imported by some
other parts of Grail.

- Grail uses a module called History and so does idle :-(

======================================================================

Robin Friedrich's items:

Things I'd like to see:
    - I'd like support for shift-click extending the selection. There's a
      bug now that it doesn't work the first time you try it.
    - Printing is needed. How hard can that be on Windows? FIRST CUT DONE
    - The python-mode trick of autoindenting a line with <tab> is neat and
      very handy.
    - (someday) a spellchecker for docstrings and comments.
    - a pagedown/up command key which moves to next class/def statement (top
      level)
    - split window capability
    - DnD text relocation/copying

Things I don't want to see.
    - line numbers...  will probably slow things down way too much.
    - Please use another icon for the tree browser leaf. The small snake
      isn't cutting it.

----------------------------------------------------------------------

- Customizable views (multi-window or multi-pane).  (Markus Gritsch)

- Being able to double click (maybe double right click) on a callable
object in the editor which shows the source of the object, if
possible.  (Gerrit Holl)

- Hooks into the guts, like in Emacs.  (Mike Romberg)

- Sharing the editor with a remote tutor.  (Martijn Faassen)

- Multiple views on the same file.  (Tony J Ibbs)

- Store breakpoints in a global (per-project) database (GvR); Dirk
Heise adds: save some space-trimmed context and search around when
reopening a file that might have been edited by someone else.

- Capture menu events in extensions without changing the IDLE source.
(Matthias Barmeier)

- Use overlapping panels (a "notebook" in MFC terms I think) for info
that doesn't need to be accessible simultaneously (e.g. HTML source
and output).  Use multi-pane windows for info that does need to be
shown together (e.g. class browser and source).  (Albert Brandl)

- A project should invisibly track all symbols, for instant search,
replace and cross-ref.  Projects should be allowed to span multiple
directories, hosts, etc.  Project management files are placed in a
directory you specify.  A global mapping between project names and
project directories should exist [not so sure --GvR].  (Tim Peters)

- Merge attr-tips and auto-expand.  (Mark Hammond, Tim Peters)

- Python Shell should behave more like a "shell window" as users know
it -- i.e. you can only edit the current command, and the cursor can't
escape from the command area.  (Albert Brandl)

- Set X11 class to "idle/Idle", set icon and title to something
beginning with "idle" -- for window manangers.  (Randall Hopper)

- Config files editable through a preferences dialog.  (me) DONE

- Config files still editable outside the preferences dialog.
(Randall Hopper) DONE

- When you're editing a command in PyShell, and there are only blank
lines below the cursor, hitting Return should ignore or delete those
blank lines rather than deciding you're not on the last line.  (me)

- Run command (F5 c.s.) should be more like Pythonwin's Run -- a
dialog with options to give command line arguments, run the debugger,
etc.  (me)

- Shouldn't be able to delete part of the prompt (or any text before
it) in the PyShell.  (Martijn Faassen)   DONE

- Emacs style auto-fill (also smart about comments and strings).
(Jeremy Hylton)

- Output of Run Script should go to a separate output window, not to
the shell window.  Output of separate runs should all go to the same
window but clearly delimited.  (David Scherer) REJECT FIRST, LATTER DONE

- GUI form designer to kick VB's butt.  (Robert Geiger) THAT'S NOT IDLE

- Printing!  Possibly via generation of PDF files which the user must
then send to the printer separately.  (Dinu Gherman)  FIRST CUT
                                                                                                                                                                                                                                  usr/lib/python3.4/idlelib/ToolTip.py                                                                0100644 0000000 0000000 00000006145 12415221640 015745  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # general purpose 'tooltip' routines - currently unused in idlefork
# (although the 'calltips' extension is partly based on this code)
# may be useful for some purposes in (or almost in ;) the current project scope
# Ideas gleaned from PySol

from tkinter import *

class ToolTipBase:

    def __init__(self, button):
        self.button = button
        self.tipwindow = None
        self.id = None
        self.x = self.y = 0
        self._id1 = self.button.bind("<Enter>", self.enter)
        self._id2 = self.button.bind("<Leave>", self.leave)
        self._id3 = self.button.bind("<ButtonPress>", self.leave)

    def enter(self, event=None):
        self.schedule()

    def leave(self, event=None):
        self.unschedule()
        self.hidetip()

    def schedule(self):
        self.unschedule()
        self.id = self.button.after(1500, self.showtip)

    def unschedule(self):
        id = self.id
        self.id = None
        if id:
            self.button.after_cancel(id)

    def showtip(self):
        if self.tipwindow:
            return
        # The tip window must be completely outside the button;
        # otherwise when the mouse enters the tip window we get
        # a leave event and it disappears, and then we get an enter
        # event and it reappears, and so on forever :-(
        x = self.button.winfo_rootx() + 20
        y = self.button.winfo_rooty() + self.button.winfo_height() + 1
        self.tipwindow = tw = Toplevel(self.button)
        tw.wm_overrideredirect(1)
        tw.wm_geometry("+%d+%d" % (x, y))
        self.showcontents()

    def showcontents(self, text="Your text here"):
        # Override this in derived class
        label = Label(self.tipwindow, text=text, justify=LEFT,
                      background="#ffffe0", relief=SOLID, borderwidth=1)
        label.pack()

    def hidetip(self):
        tw = self.tipwindow
        self.tipwindow = None
        if tw:
            tw.destroy()

class ToolTip(ToolTipBase):
    def __init__(self, button, text):
        ToolTipBase.__init__(self, button)
        self.text = text
    def showcontents(self):
        ToolTipBase.showcontents(self, self.text)

class ListboxToolTip(ToolTipBase):
    def __init__(self, button, items):
        ToolTipBase.__init__(self, button)
        self.items = items
    def showcontents(self):
        listbox = Listbox(self.tipwindow, background="#ffffe0")
        listbox.pack()
        for item in self.items:
            listbox.insert(END, item)

def _tooltip(parent):
    root = Tk()
    root.title("Test tooltip")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    label = Label(root, text="Place your mouse over buttons")
    label.pack()
    button1 = Button(root, text="Button 1")
    button2 = Button(root, text="Button 2")
    button1.pack()
    button2.pack()
    ToolTip(button1, "This is tooltip text for button1.")
    ListboxToolTip(button2, ["This is","multiple line",
                            "tooltip text","for button2"])
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_tooltip)
                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/TreeWidget.py                                                             0100644 0000000 0000000 00000035266 12415221640 016424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # XXX TO DO:
# - popup menu
# - support partial or total redisplay
# - key bindings (instead of quick-n-dirty bindings on Canvas):
#   - up/down arrow keys to move focus around
#   - ditto for page up/down, home/end
#   - left/right arrows to expand/collapse & move out/in
# - more doc strings
# - add icons for "file", "module", "class", "method"; better "python" icon
# - callback for selection???
# - multiple-item selection
# - tooltips
# - redo geometry without magic numbers
# - keep track of object ids to allow more careful cleaning
# - optimize tree redraw after expand of subnode

import os
from tkinter import *

from idlelib import ZoomHeight
from idlelib.configHandler import idleConf

ICONDIR = "Icons"

# Look for Icons subdirectory in the same directory as this module
try:
    _icondir = os.path.join(os.path.dirname(__file__), ICONDIR)
except NameError:
    _icondir = ICONDIR
if os.path.isdir(_icondir):
    ICONDIR = _icondir
elif not os.path.isdir(ICONDIR):
    raise RuntimeError("can't find icon directory (%r)" % (ICONDIR,))

def listicons(icondir=ICONDIR):
    """Utility to display the available icons."""
    root = Tk()
    import glob
    list = glob.glob(os.path.join(icondir, "*.gif"))
    list.sort()
    images = []
    row = column = 0
    for file in list:
        name = os.path.splitext(os.path.basename(file))[0]
        image = PhotoImage(file=file, master=root)
        images.append(image)
        label = Label(root, image=image, bd=1, relief="raised")
        label.grid(row=row, column=column)
        label = Label(root, text=name)
        label.grid(row=row+1, column=column)
        column = column + 1
        if column >= 10:
            row = row+2
            column = 0
    root.images = images


class TreeNode:

    def __init__(self, canvas, parent, item):
        self.canvas = canvas
        self.parent = parent
        self.item = item
        self.state = 'collapsed'
        self.selected = False
        self.children = []
        self.x = self.y = None
        self.iconimages = {} # cache of PhotoImage instances for icons

    def destroy(self):
        for c in self.children[:]:
            self.children.remove(c)
            c.destroy()
        self.parent = None

    def geticonimage(self, name):
        try:
            return self.iconimages[name]
        except KeyError:
            pass
        file, ext = os.path.splitext(name)
        ext = ext or ".gif"
        fullname = os.path.join(ICONDIR, file + ext)
        image = PhotoImage(master=self.canvas, file=fullname)
        self.iconimages[name] = image
        return image

    def select(self, event=None):
        if self.selected:
            return
        self.deselectall()
        self.selected = True
        self.canvas.delete(self.image_id)
        self.drawicon()
        self.drawtext()

    def deselect(self, event=None):
        if not self.selected:
            return
        self.selected = False
        self.canvas.delete(self.image_id)
        self.drawicon()
        self.drawtext()

    def deselectall(self):
        if self.parent:
            self.parent.deselectall()
        else:
            self.deselecttree()

    def deselecttree(self):
        if self.selected:
            self.deselect()
        for child in self.children:
            child.deselecttree()

    def flip(self, event=None):
        if self.state == 'expanded':
            self.collapse()
        else:
            self.expand()
        self.item.OnDoubleClick()
        return "break"

    def expand(self, event=None):
        if not self.item._IsExpandable():
            return
        if self.state != 'expanded':
            self.state = 'expanded'
            self.update()
            self.view()

    def collapse(self, event=None):
        if self.state != 'collapsed':
            self.state = 'collapsed'
            self.update()

    def view(self):
        top = self.y - 2
        bottom = self.lastvisiblechild().y + 17
        height = bottom - top
        visible_top = self.canvas.canvasy(0)
        visible_height = self.canvas.winfo_height()
        visible_bottom = self.canvas.canvasy(visible_height)
        if visible_top <= top and bottom <= visible_bottom:
            return
        x0, y0, x1, y1 = self.canvas._getints(self.canvas['scrollregion'])
        if top >= visible_top and height <= visible_height:
            fraction = top + height - visible_height
        else:
            fraction = top
        fraction = float(fraction) / y1
        self.canvas.yview_moveto(fraction)

    def lastvisiblechild(self):
        if self.children and self.state == 'expanded':
            return self.children[-1].lastvisiblechild()
        else:
            return self

    def update(self):
        if self.parent:
            self.parent.update()
        else:
            oldcursor = self.canvas['cursor']
            self.canvas['cursor'] = "watch"
            self.canvas.update()
            self.canvas.delete(ALL)     # XXX could be more subtle
            self.draw(7, 2)
            x0, y0, x1, y1 = self.canvas.bbox(ALL)
            self.canvas.configure(scrollregion=(0, 0, x1, y1))
            self.canvas['cursor'] = oldcursor

    def draw(self, x, y):
        # XXX This hard-codes too many geometry constants!
        self.x, self.y = x, y
        self.drawicon()
        self.drawtext()
        if self.state != 'expanded':
            return y+17
        # draw children
        if not self.children:
            sublist = self.item._GetSubList()
            if not sublist:
                # _IsExpandable() was mistaken; that's allowed
                return y+17
            for item in sublist:
                child = self.__class__(self.canvas, self, item)
                self.children.append(child)
        cx = x+20
        cy = y+17
        cylast = 0
        for child in self.children:
            cylast = cy
            self.canvas.create_line(x+9, cy+7, cx, cy+7, fill="gray50")
            cy = child.draw(cx, cy)
            if child.item._IsExpandable():
                if child.state == 'expanded':
                    iconname = "minusnode"
                    callback = child.collapse
                else:
                    iconname = "plusnode"
                    callback = child.expand
                image = self.geticonimage(iconname)
                id = self.canvas.create_image(x+9, cylast+7, image=image)
                # XXX This leaks bindings until canvas is deleted:
                self.canvas.tag_bind(id, "<1>", callback)
                self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
        id = self.canvas.create_line(x+9, y+10, x+9, cylast+7,
            ##stipple="gray50",     # XXX Seems broken in Tk 8.0.x
            fill="gray50")
        self.canvas.tag_lower(id) # XXX .lower(id) before Python 1.5.2
        return cy

    def drawicon(self):
        if self.selected:
            imagename = (self.item.GetSelectedIconName() or
                         self.item.GetIconName() or
                         "openfolder")
        else:
            imagename = self.item.GetIconName() or "folder"
        image = self.geticonimage(imagename)
        id = self.canvas.create_image(self.x, self.y, anchor="nw", image=image)
        self.image_id = id
        self.canvas.tag_bind(id, "<1>", self.select)
        self.canvas.tag_bind(id, "<Double-1>", self.flip)

    def drawtext(self):
        textx = self.x+20-1
        texty = self.y-1
        labeltext = self.item.GetLabelText()
        if labeltext:
            id = self.canvas.create_text(textx, texty, anchor="nw",
                                         text=labeltext)
            self.canvas.tag_bind(id, "<1>", self.select)
            self.canvas.tag_bind(id, "<Double-1>", self.flip)
            x0, y0, x1, y1 = self.canvas.bbox(id)
            textx = max(x1, 200) + 10
        text = self.item.GetText() or "<no text>"
        try:
            self.entry
        except AttributeError:
            pass
        else:
            self.edit_finish()
        try:
            label = self.label
        except AttributeError:
            # padding carefully selected (on Windows) to match Entry widget:
            self.label = Label(self.canvas, text=text, bd=0, padx=2, pady=2)
        theme = idleConf.GetOption('main','Theme','name')
        if self.selected:
            self.label.configure(idleConf.GetHighlight(theme, 'hilite'))
        else:
            self.label.configure(idleConf.GetHighlight(theme, 'normal'))
        id = self.canvas.create_window(textx, texty,
                                       anchor="nw", window=self.label)
        self.label.bind("<1>", self.select_or_edit)
        self.label.bind("<Double-1>", self.flip)
        self.text_id = id

    def select_or_edit(self, event=None):
        if self.selected and self.item.IsEditable():
            self.edit(event)
        else:
            self.select(event)

    def edit(self, event=None):
        self.entry = Entry(self.label, bd=0, highlightthickness=1, width=0)
        self.entry.insert(0, self.label['text'])
        self.entry.selection_range(0, END)
        self.entry.pack(ipadx=5)
        self.entry.focus_set()
        self.entry.bind("<Return>", self.edit_finish)
        self.entry.bind("<Escape>", self.edit_cancel)

    def edit_finish(self, event=None):
        try:
            entry = self.entry
            del self.entry
        except AttributeError:
            return
        text = entry.get()
        entry.destroy()
        if text and text != self.item.GetText():
            self.item.SetText(text)
        text = self.item.GetText()
        self.label['text'] = text
        self.drawtext()
        self.canvas.focus_set()

    def edit_cancel(self, event=None):
        try:
            entry = self.entry
            del self.entry
        except AttributeError:
            return
        entry.destroy()
        self.drawtext()
        self.canvas.focus_set()


class TreeItem:

    """Abstract class representing tree items.

    Methods should typically be overridden, otherwise a default action
    is used.

    """

    def __init__(self):
        """Constructor.  Do whatever you need to do."""

    def GetText(self):
        """Return text string to display."""

    def GetLabelText(self):
        """Return label text string to display in front of text (if any)."""

    expandable = None

    def _IsExpandable(self):
        """Do not override!  Called by TreeNode."""
        if self.expandable is None:
            self.expandable = self.IsExpandable()
        return self.expandable

    def IsExpandable(self):
        """Return whether there are subitems."""
        return 1

    def _GetSubList(self):
        """Do not override!  Called by TreeNode."""
        if not self.IsExpandable():
            return []
        sublist = self.GetSubList()
        if not sublist:
            self.expandable = 0
        return sublist

    def IsEditable(self):
        """Return whether the item's text may be edited."""

    def SetText(self, text):
        """Change the item's text (if it is editable)."""

    def GetIconName(self):
        """Return name of icon to be displayed normally."""

    def GetSelectedIconName(self):
        """Return name of icon to be displayed when selected."""

    def GetSubList(self):
        """Return list of items forming sublist."""

    def OnDoubleClick(self):
        """Called on a double-click on the item."""


# Example application

class FileTreeItem(TreeItem):

    """Example TreeItem subclass -- browse the file system."""

    def __init__(self, path):
        self.path = path

    def GetText(self):
        return os.path.basename(self.path) or self.path

    def IsEditable(self):
        return os.path.basename(self.path) != ""

    def SetText(self, text):
        newpath = os.path.dirname(self.path)
        newpath = os.path.join(newpath, text)
        if os.path.dirname(newpath) != os.path.dirname(self.path):
            return
        try:
            os.rename(self.path, newpath)
            self.path = newpath
        except OSError:
            pass

    def GetIconName(self):
        if not self.IsExpandable():
            return "python" # XXX wish there was a "file" icon

    def IsExpandable(self):
        return os.path.isdir(self.path)

    def GetSubList(self):
        try:
            names = os.listdir(self.path)
        except OSError:
            return []
        names.sort(key = os.path.normcase)
        sublist = []
        for name in names:
            item = FileTreeItem(os.path.join(self.path, name))
            sublist.append(item)
        return sublist


# A canvas widget with scroll bars and some useful bindings

class ScrolledCanvas:
    def __init__(self, master, **opts):
        if 'yscrollincrement' not in opts:
            opts['yscrollincrement'] = 17
        self.master = master
        self.frame = Frame(master)
        self.frame.rowconfigure(0, weight=1)
        self.frame.columnconfigure(0, weight=1)
        self.canvas = Canvas(self.frame, **opts)
        self.canvas.grid(row=0, column=0, sticky="nsew")
        self.vbar = Scrollbar(self.frame, name="vbar")
        self.vbar.grid(row=0, column=1, sticky="nse")
        self.hbar = Scrollbar(self.frame, name="hbar", orient="horizontal")
        self.hbar.grid(row=1, column=0, sticky="ews")
        self.canvas['yscrollcommand'] = self.vbar.set
        self.vbar['command'] = self.canvas.yview
        self.canvas['xscrollcommand'] = self.hbar.set
        self.hbar['command'] = self.canvas.xview
        self.canvas.bind("<Key-Prior>", self.page_up)
        self.canvas.bind("<Key-Next>", self.page_down)
        self.canvas.bind("<Key-Up>", self.unit_up)
        self.canvas.bind("<Key-Down>", self.unit_down)
        #if isinstance(master, Toplevel) or isinstance(master, Tk):
        self.canvas.bind("<Alt-Key-2>", self.zoom_height)
        self.canvas.focus_set()
    def page_up(self, event):
        self.canvas.yview_scroll(-1, "page")
        return "break"
    def page_down(self, event):
        self.canvas.yview_scroll(1, "page")
        return "break"
    def unit_up(self, event):
        self.canvas.yview_scroll(-1, "unit")
        return "break"
    def unit_down(self, event):
        self.canvas.yview_scroll(1, "unit")
        return "break"
    def zoom_height(self, event):
        ZoomHeight.zoom_height(self.master)
        return "break"


def _tree_widget(parent):
    root = Tk()
    root.title("Test TreeWidget")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    sc = ScrolledCanvas(root, bg="white", highlightthickness=0, takefocus=1)
    sc.frame.pack(expand=1, fill="both", side=LEFT)
    item = FileTreeItem(os.getcwd())
    node = TreeNode(sc.canvas, None, item)
    node.expand()
    root.mainloop()

if __name__ == '__main__':
    from idlelib.idle_test.htest import run
    run(_tree_widget)
                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/idlelib/UndoDelegator.py                                                          0100644 0000000 0000000 00000025077 12415221640 017114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        import string
from tkinter import *

from idlelib.Delegator import Delegator

#$ event <<redo>>
#$ win <Control-y>
#$ unix <Alt-z>

#$ event <<undo>>
#$ win <Control-z>
#$ unix <Control-z>

#$ event <<dump-undo-state>>
#$ win <Control-backslash>
#$ unix <Control-backslash>


class UndoDelegator(Delegator):

    max_undo = 1000

    def __init__(self):
        Delegator.__init__(self)
        self.reset_undo()

    def setdelegate(self, delegate):
        if self.delegate is not None:
            self.unbind("<<undo>>")
            self.unbind("<<redo>>")
            self.unbind("<<dump-undo-state>>")
        Delegator.setdelegate(self, delegate)
        if delegate is not None:
            self.bind("<<undo>>", self.undo_event)
            self.bind("<<redo>>", self.redo_event)
            self.bind("<<dump-undo-state>>", self.dump_event)

    def dump_event(self, event):
        from pprint import pprint
        pprint(self.undolist[:self.pointer])
        print("pointer:", self.pointer, end=' ')
        print("saved:", self.saved, end=' ')
        print("can_merge:", self.can_merge, end=' ')
        print("get_saved():", self.get_saved())
        pprint(self.undolist[self.pointer:])
        return "break"

    def reset_undo(self):
        self.was_saved = -1
        self.pointer = 0
        self.undolist = []
        self.undoblock = 0  # or a CommandSequence instance
        self.set_saved(1)

    def set_saved(self, flag):
        if flag:
            self.saved = self.pointer
        else:
            self.saved = -1
        self.can_merge = False
        self.check_saved()

    def get_saved(self):
        return self.saved == self.pointer

    saved_change_hook = None

    def set_saved_change_hook(self, hook):
        self.saved_change_hook = hook

    was_saved = -1

    def check_saved(self):
        is_saved = self.get_saved()
        if is_saved != self.was_saved:
            self.was_saved = is_saved
            if self.saved_change_hook:
                self.saved_change_hook()

    def insert(self, index, chars, tags=None):
        self.addcmd(InsertCommand(index, chars, tags))

    def delete(self, index1, index2=None):
        self.addcmd(DeleteCommand(index1, index2))

    # Clients should call undo_block_start() and undo_block_stop()
    # around a sequence of editing cmds to be treated as a unit by
    # undo & redo.  Nested matching calls are OK, and the inner calls
    # then act like nops.  OK too if no editing cmds, or only one
    # editing cmd, is issued in between:  if no cmds, the whole
    # sequence has no effect; and if only one cmd, that cmd is entered
    # directly into the undo list, as if undo_block_xxx hadn't been
    # called.  The intent of all that is to make this scheme easy
    # to use:  all the client has to worry about is making sure each
    # _start() call is matched by a _stop() call.

    def undo_block_start(self):
        if self.undoblock == 0:
            self.undoblock = CommandSequence()
        self.undoblock.bump_depth()

    def undo_block_stop(self):
        if self.undoblock.bump_depth(-1) == 0:
            cmd = self.undoblock
            self.undoblock = 0
            if len(cmd) > 0:
                if len(cmd) == 1:
                    # no need to wrap a single cmd
                    cmd = cmd.getcmd(0)
                # this blk of cmds, or single cmd, has already
                # been done, so don't execute it again
                self.addcmd(cmd, 0)

    def addcmd(self, cmd, execute=True):
        if execute:
            cmd.do(self.delegate)
        if self.undoblock != 0:
            self.undoblock.append(cmd)
            return
        if self.can_merge and self.pointer > 0:
            lastcmd = self.undolist[self.pointer-1]
            if lastcmd.merge(cmd):
                return
        self.undolist[self.pointer:] = [cmd]
        if self.saved > self.pointer:
            self.saved = -1
        self.pointer = self.pointer + 1
        if len(self.undolist) > self.max_undo:
            ##print "truncating undo list"
            del self.undolist[0]
            self.pointer = self.pointer - 1
            if self.saved >= 0:
                self.saved = self.saved - 1
        self.can_merge = True
        self.check_saved()

    def undo_event(self, event):
        if self.pointer == 0:
            self.bell()
            return "break"
        cmd = self.undolist[self.pointer - 1]
        cmd.undo(self.delegate)
        self.pointer = self.pointer - 1
        self.can_merge = False
        self.check_saved()
        return "break"

    def redo_event(self, event):
        if self.pointer >= len(self.undolist):
            self.bell()
            return "break"
        cmd = self.undolist[self.pointer]
        cmd.redo(self.delegate)
        self.pointer = self.pointer + 1
        self.can_merge = False
        self.check_saved()
        return "break"


class Command:

    # Base class for Undoable commands

    tags = None

    def __init__(self, index1, index2, chars, tags=None):
        self.marks_before = {}
        self.marks_after = {}
        self.index1 = index1
        self.index2 = index2
        self.chars = chars
        if tags:
            self.tags = tags

    def __repr__(self):
        s = self.__class__.__name__
        t = (self.index1, self.index2, self.chars, self.tags)
        if self.tags is None:
            t = t[:-1]
        return s + repr(t)

    def do(self, text):
        pass

    def redo(self, text):
        pass

    def undo(self, text):
        pass

    def merge(self, cmd):
        return 0

    def save_marks(self, text):
        marks = {}
        for name in text.mark_names():
            if name != "insert" and name != "current":
                marks[name] = text.index(name)
        return marks

    def set_marks(self, text, marks):
        for name, index in marks.items():
            text.mark_set(name, index)


class InsertCommand(Command):

    # Undoable insert command

    def __init__(self, index1, chars, tags=None):
        Command.__init__(self, index1, None, chars, tags)

    def do(self, text):
        self.marks_before = self.save_marks(text)
        self.index1 = text.index(self.index1)
        if text.compare(self.index1, ">", "end-1c"):
            # Insert before the final newline
            self.index1 = text.index("end-1c")
        text.insert(self.index1, self.chars, self.tags)
        self.index2 = text.index("%s+%dc" % (self.index1, len(self.chars)))
        self.marks_after = self.save_marks(text)
        ##sys.__stderr__.write("do: %s\n" % self)

    def redo(self, text):
        text.mark_set('insert', self.index1)
        text.insert(self.index1, self.chars, self.tags)
        self.set_marks(text, self.marks_after)
        text.see('insert')
        ##sys.__stderr__.write("redo: %s\n" % self)

    def undo(self, text):
        text.mark_set('insert', self.index1)
        text.delete(self.index1, self.index2)
        self.set_marks(text, self.marks_before)
        text.see('insert')
        ##sys.__stderr__.write("undo: %s\n" % self)

    def merge(self, cmd):
        if self.__class__ is not cmd.__class__:
            return False
        if self.index2 != cmd.index1:
            return False
        if self.tags != cmd.tags:
            return False
        if len(cmd.chars) != 1:
            return False
        if self.chars and \
           self.classify(self.chars[-1]) != self.classify(cmd.chars):
            return False
        self.index2 = cmd.index2
        self.chars = self.chars + cmd.chars
        return True

    alphanumeric = string.ascii_letters + string.digits + "_"

    def classify(self, c):
        if c in self.alphanumeric:
            return "alphanumeric"
        if c == "\n":
            return "newline"
        return "punctuation"


class DeleteCommand(Command):

    # Undoable delete command

    def __init__(self, index1, index2=None):
        Command.__init__(self, index1, index2, None, None)

    def do(self, text):
        self.marks_before = self.save_marks(text)
        self.index1 = text.index(self.index1)
        if self.index2:
            self.index2 = text.index(self.index2)
        else:
            self.index2 = text.index(self.index1 + " +1c")
        if text.compare(self.index2, ">", "end-1c"):
            # Don't delete the final newline
            self.index2 = text.index("end-1c")
        self.chars = text.get(self.index1, self.index2)
        text.delete(self.index1, self.index2)
        self.marks_after = self.save_marks(text)
        ##sys.__stderr__.write("do: %s\n" % self)

    def redo(self, text):
        text.mark_set('insert', self.index1)
        text.delete(self.index1, self.index2)
        self.set_marks(text, self.marks_after)
        text.see('insert')
        ##sys.__stderr__.write("redo: %s\n" % self)

    def undo(self, text):
        text.mark_set('insert', self.index1)
        text.insert(self.index1, self.chars)
        self.set_marks(text, self.marks_before)
        text.see('insert')
        ##sys.__stderr__.write("undo: %s\n" % self)

class CommandSequence(Command):

    # Wrapper for a sequence of undoable cmds to be undone/redone
    # as a unit

    def __init__(self):
        self.cmds = []
        self.depth = 0

    def __repr__(self):
        s = self.__class__.__name__
        strs = []
        for cmd in self.cmds:
            strs.append("    %r" % (cmd,))
        return s + "(\n" + ",\n".join(strs) + "\n)"

    def __len__(self):
        return len(self.cmds)

    def append(self, cmd):
        self.cmds.append(cmd)

    def getcmd(self, i):
        return self.cmds[i]

    def redo(self, text):
        for cmd in self.cmds:
            cmd.redo(text)

    def undo(self, text):
        cmds = self.cmds[:]
        cmds.reverse()
        for cmd in cmds:
            cmd.undo(text)

    def bump_depth(self, incr=1):
        self.depth = self.depth + incr
        return self.depth

def _undo_delegator(parent):
    from idlelib.Percolator import Percolator
    root = Tk()
    root.title("Test UndoDelegator")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))

    text = Text(root)
    text.config(height=10)
    text.pack()
    text.focus_set()
    p = Percolator(text)
    d = UndoDelegator()
    p.insertfilter(d)

    undo = Button(root, text="Undo", command=lambda:d.undo_event(None))
    undo.pack(side='left')
    redo = Button(root, text="Redo", command=lambda:d.redo_event(None))
    redo.pack(side='left')
    dump = Button(root, text="Dump", command=lambda:d.dump_event(None))
    dump.pack(side='left')

    root.mainloop()

if __name__ == "__main__":
    from idlelib.idle_test.htest import run
    run(_undo_delegator)
                                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/WidgetRedirector.py                                                       0100644 0000000 0000000 00000015325 12415221640 017621  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import TclError

class WidgetRedirector:
    """Support for redirecting arbitrary widget subcommands.

    Some Tk operations don't normally pass through tkinter.  For example, if a
    character is inserted into a Text widget by pressing a key, a default Tk
    binding to the widget's 'insert' operation is activated, and the Tk library
    processes the insert without calling back into tkinter.

    Although a binding to <Key> could be made via tkinter, what we really want
    to do is to hook the Tk 'insert' operation itself.  For one thing, we want
    a text.insert call in idle code to have the same effect as a key press.

    When a widget is instantiated, a Tcl command is created whose name is the
    same as the pathname widget._w.  This command is used to invoke the various
    widget operations, e.g. insert (for a Text widget). We are going to hook
    this command and provide a facility ('register') to intercept the widget
    operation.  We will also intercept method calls on the tkinter class
    instance that represents the tk widget.

    In IDLE, WidgetRedirector is used in Percolator to intercept Text
    commands.  The function being registered provides access to the top
    of a Percolator chain.  At the bottom of the chain is a call to the
    original Tk widget operation.
    """
    def __init__(self, widget):
        '''Initialize attributes and setup redirection.

        _operations: dict mapping operation name to new function.
        widget: the widget whose tcl command is to be intercepted.
        tk: widget.tk, a convenience attribute, probably not needed.
        orig: new name of the original tcl command.

        Since renaming to orig fails with TclError when orig already
        exists, only one WidgetDirector can exist for a given widget.
        '''
        self._operations = {}
        self.widget = widget            # widget instance
        self.tk = tk = widget.tk        # widget's root
        w = widget._w                   # widget's (full) Tk pathname
        self.orig = w + "_orig"
        # Rename the Tcl command within Tcl:
        tk.call("rename", w, self.orig)
        # Create a new Tcl command whose name is the widget's pathname, and
        # whose action is to dispatch on the operation passed to the widget:
        tk.createcommand(w, self.dispatch)

    def __repr__(self):
        return "WidgetRedirector(%s<%s>)" % (self.widget.__class__.__name__,
                                             self.widget._w)

    def close(self):
        "Unregister operations and revert redirection created by .__init__."
        for operation in list(self._operations):
            self.unregister(operation)
        widget = self.widget
        tk = widget.tk
        w = widget._w
        # Restore the original widget Tcl command.
        tk.deletecommand(w)
        tk.call("rename", self.orig, w)
        del self.widget, self.tk  # Should not be needed
        # if instance is deleted after close, as in Percolator.

    def register(self, operation, function):
        '''Return OriginalCommand(operation) after registering function.

        Registration adds an operation: function pair to ._operations.
        It also adds an widget function attribute that masks the tkinter
        class instance method.  Method masking operates independently
        from command dispatch.

        If a second function is registered for the same operation, the
        first function is replaced in both places.
        '''
        self._operations[operation] = function
        setattr(self.widget, operation, function)
        return OriginalCommand(self, operation)

    def unregister(self, operation):
        '''Return the function for the operation, or None.

        Deleting the instance attribute unmasks the class attribute.
        '''
        if operation in self._operations:
            function = self._operations[operation]
            del self._operations[operation]
            try:
                delattr(self.widget, operation)
            except AttributeError:
                pass
            return function
        else:
            return None

    def dispatch(self, operation, *args):
        '''Callback from Tcl which runs when the widget is referenced.

        If an operation has been registered in self._operations, apply the
        associated function to the args passed into Tcl. Otherwise, pass the
        operation through to Tk via the original Tcl function.

        Note that if a registered function is called, the operation is not
        passed through to Tk.  Apply the function returned by self.register()
        to *args to accomplish that.  For an example, see ColorDelegator.py.

        '''
        m = self._operations.get(operation)
        try:
            if m:
                return m(*args)
            else:
                return self.tk.call((self.orig, operation) + args)
        except TclError:
            return ""


class OriginalCommand:
    '''Callable for original tk command that has been redirected.

    Returned by .register; can be used in the function registered.
    redir = WidgetRedirector(text)
    def my_insert(*args):
        print("insert", args)
        original_insert(*args)
    original_insert = redir.register("insert", my_insert)
    '''

    def __init__(self, redir, operation):
        '''Create .tk_call and .orig_and_operation for .__call__ method.

        .redir and .operation store the input args for __repr__.
        .tk and .orig copy attributes of .redir (probably not needed).
        '''
        self.redir = redir
        self.operation = operation
        self.tk = redir.tk  # redundant with self.redir
        self.orig = redir.orig  # redundant with self.redir
        # These two could be deleted after checking recipient code.
        self.tk_call = redir.tk.call
        self.orig_and_operation = (redir.orig, operation)

    def __repr__(self):
        return "OriginalCommand(%r, %r)" % (self.redir, self.operation)

    def __call__(self, *args):
        return self.tk_call(self.orig_and_operation + args)


def _widget_redirector(parent):  # htest #
    from tkinter import Tk, Text
    import re

    root = Tk()
    root.title("Test WidgetRedirector")
    width, height, x, y = list(map(int, re.split('[x+]', parent.geometry())))
    root.geometry("+%d+%d"%(x, y + 150))
    text = Text(root)
    text.pack()
    text.focus_set()
    redir = WidgetRedirector(text)
    def my_insert(*args):
        print("insert", args)
        original_insert(*args)
    original_insert = redir.register("insert", my_insert)
    root.mainloop()

if __name__ == "__main__":
    import unittest
    unittest.main('idlelib.idle_test.test_widgetredir',
                  verbosity=2, exit=False)
    from idlelib.idle_test.htest import run
    run(_widget_redirector)
                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/WindowList.py                                                             0100644 0000000 0000000 00000004650 12415221640 016455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        from tkinter import *

class WindowList:

    def __init__(self):
        self.dict = {}
        self.callbacks = []

    def add(self, window):
        window.after_idle(self.call_callbacks)
        self.dict[str(window)] = window

    def delete(self, window):
        try:
            del self.dict[str(window)]
        except KeyError:
            # Sometimes, destroy() is called twice
            pass
        self.call_callbacks()

    def add_windows_to_menu(self,  menu):
        list = []
        for key in self.dict:
            window = self.dict[key]
            try:
                title = window.get_title()
            except TclError:
                continue
            list.append((title, key, window))
        list.sort()
        for title, key, window in list:
            menu.add_command(label=title, command=window.wakeup)

    def register_callback(self, callback):
        self.callbacks.append(callback)

    def unregister_callback(self, callback):
        try:
            self.callbacks.remove(callback)
        except ValueError:
            pass

    def call_callbacks(self):
        for callback in self.callbacks:
            try:
                callback()
            except:
                t, v, tb = sys.exc_info()
                print("warning: callback failed in WindowList", t, ":", v)

registry = WindowList()

add_windows_to_menu = registry.add_windows_to_menu
register_callback = registry.register_callback
unregister_callback = registry.unregister_callback


class ListedToplevel(Toplevel):

    def __init__(self, master, **kw):
        Toplevel.__init__(self, master, kw)
        registry.add(self)
        self.focused_widget = self

    def destroy(self):
        registry.delete(self)
        Toplevel.destroy(self)
        # If this is Idle's last window then quit the mainloop
        # (Needed for clean exit on Windows 98)
        if not registry.dict:
            self.quit()

    def update_windowlist_registry(self, window):
        registry.call_callbacks()

    def get_title(self):
        # Subclass can override
        return self.wm_title()

    def wakeup(self):
        try:
            if self.wm_state() == "iconic":
                self.wm_withdraw()
                self.wm_deiconify()
            self.tkraise()
            self.focused_widget.focus_set()
        except TclError:
            # This can happen when the window menu was torn off.
            # Simply ignore it.
            pass
                                                                                        usr/lib/python3.4/idlelib/ZoomHeight.py                                                             0100644 0000000 0000000 00000002424 12415221640 016424  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Sample extension: zoom a window to maximum height

import re
import sys

from idlelib import macosxSupport

class ZoomHeight:

    menudefs = [
        ('windows', [
            ('_Zoom Height', '<<zoom-height>>'),
         ])
    ]

    def __init__(self, editwin):
        self.editwin = editwin

    def zoom_height_event(self, event):
        top = self.editwin.top
        zoom_height(top)

def zoom_height(top):
    geom = top.wm_geometry()
    m = re.match(r"(\d+)x(\d+)\+(-?\d+)\+(-?\d+)", geom)
    if not m:
        top.bell()
        return
    width, height, x, y = map(int, m.groups())
    newheight = top.winfo_screenheight()
    if sys.platform == 'win32':
        newy = 0
        newheight = newheight - 72

    elif macosxSupport.isAquaTk():
        # The '88' below is a magic number that avoids placing the bottom
        # of the window below the panel on my machine. I don't know how
        # to calculate the correct value for this with tkinter.
        newy = 22
        newheight = newheight - newy - 88

    else:
        #newy = 24
        newy = 0
        #newheight = newheight - 96
        newheight = newheight - 88
    if height >= newheight:
        newgeom = ""
    else:
        newgeom = "%dx%d+%d+%d" % (width, newheight, x, newy)
    top.wm_geometry(newgeom)
                                                                                                                                                                                                                                            usr/lib/python3.4/idlelib/__init__.py                                                               0100644 0000000 0000000 00000000045 12415221640 016103  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        # Dummy file to make this a package.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/__main__.py                                                               0100644 0000000 0000000 00000000155 12415221640 016066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        """
IDLE main entry point

Run IDLE as python -m idlelib
"""


import idlelib.PyShell
idlelib.PyShell.main()
                                                                                                                                                                                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/__pycache__/                                                              0040755 0000000 0000000 00000000000 13077704335 016222  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        usr/lib/python3.4/idlelib/__pycache__/AutoComplete.cpython-34.pyc                                   0100644 0000000 0000000 00000017024 13077704335 023250  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T#                 @   s   d  Z  d d l Z d d l Z d d l Z d d l m Z e j e j d Z e	 d d  \ Z
 Z d d l m Z d d l m Z d d l Z e j Z e j r e e j 7Z n  Gd	 d
   d
  Z e d k r d d l m Z e d d d n  d S)zAutoComplete.py - An IDLE extension for automatically completing names.

This extension can complete either attribute names of file names. It can pop
a window with all available names, for the user to select from.
    N)idleConf_      )AutoCompleteWindow)HyperParserc               @   s   e  Z d  Z d d! g f g Z e j d d  d d d d d	 Z d
 d d  Z d d   Z d
 d d  Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d
 d d  Z d d   Z d d    Z d
 S)"AutoCompleteZeditShow Completions<<force-open-completions>>
extensions	popupwaittypeintdefaultr   Nc             C   sD   | |  _  | d  k r d  S| j |  _ d  |  _ d  |  _ d  |  _ d  S)N)editwintextautocompletewindow_delayed_completion_id_delayed_completion_index)selfr    r   */usr/lib/python3.4/idlelib/AutoComplete.py__init__&   s    			zAutoComplete.__init__c             C   s   t  j  |  j  S)N)r   r   )r   r   r   r   _make_autocomplete_window3   s    z&AutoComplete._make_autocomplete_windowc             C   s&   |  j  r" |  j  j   d  |  _  n  d  S)N)r   Zhide_window)r   eventr   r   r   _remove_autocomplete_window6   s    	z(AutoComplete._remove_autocomplete_windowc             C   s   |  j  d d d  d S)zqHappens when the user really wants to open a completion list, even
        if a function call is needed.
        TFN)open_completions)r   r   r   r   r   force_open_completions_event;   s    z)AutoComplete.force_open_completions_eventc             C   s`   |  j  j d  } | d k r7 |  j d d d t  n% | t k r\ |  j d d d t  n  d S)zHappens when it would be nice to open a completion list, but not
        really necessary, for example after an dot, so function
        calls won't be made.
        z	insert-1c.FN)r   get_open_completions_laterCOMPLETE_ATTRIBUTESSEPSCOMPLETE_FILES)r   r   Zlastcharr   r   r   try_open_completions_eventA   s    
z'AutoComplete.try_open_completions_eventc             C   sh   t  | d  r | j r d S|  j rE |  j j   rE |  j j   d S|  j d d d  } | rd d Sd S)zHappens when the user wants to complete his word, and if necessary,
        open a completion list after that (if there is more than one
        completion)
        mc_stateNbreakFT)hasattrr%   r   Z	is_activecompleter   )r   r   Zopenedr   r   r   autocomplete_eventN   s    zAutoComplete.autocomplete_eventc             G   s_   |  j  j d  |  _ |  j d  k	 r: |  j  j |  j  n  |  j  j |  j |  j |  |  _ d  S)Ninsert)r   indexr   r   after_cancelZafterr   _delayed_open_completions)r   argsr   r   r   r    ^   s
    z$AutoComplete._open_completions_laterc             G   s9   d  |  _  |  j j d  |  j k r( d  S|  j |   d  S)Nr*   )r   r   r+   r   r   )r   r.   r   r   r   r-   f   s    	z&AutoComplete._delayed_open_completionsc             C   s  |  j  d k	 r. |  j j |  j   d |  _  n  t |  j d  } |  j j d d  } t |  } } | j   r| s | t k r|  j	   t } x, | r | | d d t
 k r | d 8} q W| | |  }	 | } x( | r| | d d k r| d 8} q W| | |  }
 n | j   r| s6| t k r|  j	   t } xB | r| | d t k s}t | | d  d k r| d 8} qIW| | |  }	 | r
| | d d k r
| j d t |  | d  | j   }
 |
 s| r|
 j d	  d k rd Sqd
 }
 n d S| r/|
 r/|	 r/d S|  j |
 |  } | d sOd S|  j   |  _ |  j j | d t |	  | | |  S)aX  Find the completions and create the AutoCompleteWindow.
        Return True if successful (no syntax error or so found).
        if complete is True, then if there's nothing to complete and no
        start of completion, won't open completions and return False.
        If mode is given, will open a completion list only in this mode.
        Nr*   zinsert linestartr   z'"   r   z
insert-%dc( r   )r   r   r,   r   r   r   lenZis_in_stringr#   r   r"   Z
is_in_coder!   ID_CHARSordZ	set_indexZget_expressionfindfetch_completionsr   r   Zshow_window)r   Z	evalfuncsr(   ZuserWantsWinmodeZhpZcurlineijZ
comp_startZ	comp_whatZ
comp_listsr   r   r   r   l   sN    
!
7	
	zAutoComplete.open_completionsc       	      C   s  y |  j  j j j j } Wn d } Yn X| rL | j d d | | f i   S| t k rK| d k r t j j	   } | j
 t j j  t d |  } | j   d | k r t t d |   } qHd d   | D } qyZ |  j |  } t |  } | j   d | k rt | j  } n d	 d   | D } Wqg  g  f SYqXn | t k r| d k rld
 } n  yB t j j |  } t j |  } | j   d d   | D } Wqt k
 rg  g  f SYqXn  | s| } n  | | f Sd S)aO  Return a pair of lists of completions for something. The first list
        is a sublist of the second. Both are sorted.

        If there is a Python subprocess, get the comp. list there.  Otherwise,
        either fetch_completions() is running in the subprocess itself or it
        was called in an IDLE EditorWindow before any script had been run.

        The subprocess environment is that of the most recently run script.  If
        two unrelated modules are being edited some calltips in the current
        module may be inoperative if the module was not the last to run.
        NexecZget_the_completion_listr1   zdir()__all__c             S   s,   g  |  ]" } | d  d  d k r |  q S)Nr   r   r   ).0sr   r   r   
<listcomp>   s   	 z2AutoComplete.fetch_completions.<locals>.<listcomp>c             S   s,   g  |  ]" } | d  d  d k r |  q S)Nr   r   r   )r=   r>   r   r   r   r?      s   	 r   c             S   s,   g  |  ]" } | d  d  d k r |  q S)Nr   r   r   )r=   r>   r   r   r   r?      s   	 )r   ZflistZpyshellZinterprpccltZ
remotecallr!   __main____dict__copyupdate__builtins__evalsortsorted
get_entitydirr<   r#   ospath
expanduserlistdirOSError)	r   Zwhatr8   r@   	namespaceZbiglZsmalllZentityZexpandedpathr   r   r   r7      sL    

	
	zAutoComplete.fetch_completionsc             C   s,   t  j j   } | j t j  t | |  S)zALookup name in a namespace spanning sys.modules and __main.dict__)sysmodulesrC   rD   rA   rB   rF   )r   namerP   r   r   r   rI      s    zAutoComplete.get_entity)r	   r
   )__name__
__module____qualname__Zmenudefsr   Z	GetOptionr   r   r   r   r   r$   r)   r    r-   r   r7   rI   r   r   r   r   r      s   ;9r   rA   )mainz#idlelib.idle_test.test_autocomplete	verbosity   )__doc__rK   rQ   stringZidlelib.configHandlerr   Zascii_lettersZdigitsr4   ranger!   r#   Zidlelibr   Zidlelib.HyperParserr   rA   sepr"   altsepr   rT   ZunittestrW   r   r   r   r   <module>   s    		                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            usr/lib/python3.4/idlelib/__pycache__/AutoCompleteWindow.cpython-34.pyc                             0100644 0000000 0000000 00000026362 13077704335 024445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TE              
   @   s   d  Z  d d l Td d l m Z d d l m Z m Z d Z d Z d Z	 d Z
 d Z d Z d Z d Z d Z Gd d   d  Z d S)zH
An auto-completion window for IDLE, used by the AutoComplete extension
    )*)MC_SHIFT)COMPLETE_FILESCOMPLETE_ATTRIBUTESz<<autocompletewindow-hide>>
<FocusOut><ButtonPress>z<<autocompletewindow-keypress>><Key><Key-BackSpace><Key-Return>	<Key-Tab><Key-Up>
<Key-Down>
<Key-Home>	<Key-End><Key-Prior>
<Key-Next>z!<<autocompletewindow-keyrelease>>z<KeyRelease>z<B1-ButtonRelease>z<Configure>z<B1-Double-ButtonRelease>c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S) AutoCompleteWindowc             C   s   | |  _  d  |  _ |  _ |  _ d  |  _ |  _ d  |  _ d  |  _ d  |  _ d  |  _	 d  |  _
 d  |  _ d  |  _ d  |  _ |  _ |  _ |  _ |  _ |  _ d |  _ d  S)NF)widgetautocompletewindowlistbox	scrollbarorigselforegroundorigselbackgroundcompletionsmorecompletionsmodestart
startindexlasttypedstartuserwantswindowhideid
keypressidlistupdateidwinconfigidkeyreleaseiddoubleclickidlastkey_was_tab)selfr    r(   0/usr/lib/python3.4/idlelib/AutoCompleteWindow.py__init__   s    								,zAutoCompleteWindow.__init__c             C   s   t  t |  j  t |   } d } x1 | | k  rW |  j | | | k rW | d 7} q' W| t |  j  k  r |  j j d |  j | f d |  j t |  j  f  n  | t |  k  r |  j j d |  j | f | | d    n  | |  _ d  S)Nr      z%s+%dc)minlenr   r   deleter   insert)r'   newstartmin_lenir(   r(   r)   _change_start8   s    & z AutoCompleteWindow._change_startc             C   sv   d } t  |  j  } xD | | k r[ | | d } |  j | | k rN | } q | d } q Wt | t  |  j  d  S)zFind the first index in self.completions where completions[i] is
        greater or equal to s, or the last index if there is no such
        one.r      r+   )r-   r   r,   )r'   sr2   jmr(   r(   r)   _binary_searchE   s     	z!AutoCompleteWindow._binary_searchc       
      C   sG  |  j  |  } |  j | d t |   | k r6 | S| d } t |  j  } xT | | k r | | d } |  j | d t |   | k r | } qR | d } qR W| d } | | k r |  j | S|  j | } |  j | } t t |  t |   }	 t |  } x. | |	 k  r8| | | | k r8| d 7} qW| d |  S)zAssuming that s is the prefix of a string in self.completions,
        return the longest string which is a prefix of all the strings which
        s is a prefix of them. If s is not a prefix of a string, return s.Nr+   r4   )r8   r   r-   r,   )
r'   r5   firstr2   r6   r7   lastZ
first_compZ	last_compr1   r(   r(   r)   _complete_stringR   s(    #
#	
#z#AutoCompleteWindow._complete_stringc             C   s  t  |  j j   d  } |  j j |  |  j } |  j | } |  j |  | k r] | } nb t t |  t |   } d } x. | | k  r | | | | k r | d 7} q W| d |  } |  j	 |  |  j | d t |  j
   |  j
 k r|  j j d |  j d |  j  n |  j j d |  j j d  d |  j j d   |  j r|  j |  _ d |  _ |  j j d t  x$ |  j D] } |  j j t |  qW|  j j |  j |  j
   |  j   n  d S)z|Should be called when the selection of the Listbox has changed.
        Updates the Listbox display and calls _change_start.r   r+   NselectbackgroundselectforegroundbgZfg)intr   curselectionseer   r   r8   r,   r-   r3   r   Z	configurer   r   cgetr   r.   ENDr/   
select_set_selection_changed)r'   curselZltsZselstartr0   r1   r2   itemr(   r(   r)   rE   q   s2    		#)		z%AutoCompleteWindow._selection_changedc             C   sQ  | \ |  _  |  _ | |  _ |  j j |  |  _ |  j j |  j d  |  _ | r |  j |  j  } |  j } |  j	 |  |  j
 |  } |  j  | | k r | t |  j   d k s |  j  | d d t |   | k r | | k Sn  | |  _ |  j |  _ t |  j  |  _ }	 |	 j d  |	 j d  y# |	 j j d d |	 j d d  Wn t k
 rdYn Xt |	 d	 t |  _ }
 t |	 d
 |
 j d d d d |  _ } x! |  j  D] } | j t |  qW| j d  |  _ | j d  |  _  |
 j! d | j"  |
 j# d t$ d t%  | j# d t& d t' d d  |  j j( |  j
 |  j   |  j)   |  j j* t+ |  j,  |  _- x! t. D] } |  j j/ t+ |  q{W|  j j* t0 |  j1  |  _2 x! t3 D] } |  j j/ t0 |  qW|  j j* t4 |  j5  |  _6 |  j j/ t4 t7  | j* t8 |  j9  |  _: |	 j* t; |  j<  |  _= | j* t> |  j?  |  _@ d S)zShow the autocomplete list, bind events.
        If complete is True, complete the text, and if there is exactly one
        matching completion, don't open a list.r/   r+   Nz+10000+10000z!::tk::unsupported::MacWindowStyleZstylehelpZnoActivatesZorientZyscrollcommandZexportselectionFr>   Zwhiter=   r<   ZcommandZsideZfillexpandT)Ar   r   r   r   indexr   getr   r;   r3   r8   r-   r   r   ZToplevelr   wm_geometryZwm_overrideredirectZtkcallZ_wZTclErrorZ	ScrollbarZVERTICALr   ZListboxsetr   r/   rC   rB   r   r   ZconfigZyviewZpackZRIGHTYZLEFTZBOTHrD   rE   ZbindHIDE_VIRTUAL_EVENT_NAME
hide_eventr    HIDE_SEQUENCESZ	event_addKEYPRESS_VIRTUAL_EVENT_NAMEkeypress_eventr!   KEYPRESS_SEQUENCESKEYRELEASE_VIRTUAL_EVENT_NAMEkeyrelease_eventr$   KEYRELEASE_SEQUENCELISTUPDATE_SEQUENCElistselect_eventr"   WINCONFIG_SEQUENCEwinconfig_eventr#   DOUBLECLICK_SEQUENCEdoubleclick_eventr%   )r'   Z
comp_listsrJ   completer   ZuserWantsWinZ	completedr   r2   acwr   r   rG   seqr(   r(   r)   show_window   sf    		'	
		zAutoCompleteWindow.show_windowc             C   s
  |  j    s d  S|  j } | j |  j  | j |  j  \ } } } } |  j } | j   | j   } }	 | j   | j   }
 } | j   t	 | t
 d |
 |   } | j   | } | | | |	 k s | |	 k  r | | 7} n
 | |	 8} | j d | | f  d  S)Nr   z+%d+%d)	is_activer   rA   r   Zbboxr   Zwinfo_widthwinfo_heightZwinfo_rootxr,   maxZwinfo_rootyrL   )r'   eventtextxyZcxZcyr`   Z	acw_widthZ
acw_heightZ
text_widthZtext_heightZnew_xZnew_yr(   r(   r)   r\      s    		&
z"AutoCompleteWindow.winconfig_eventc             C   s   |  j    s d  S|  j   d  S)N)rc   hide_window)r'   rf   r(   r(   r)   rQ      s    zAutoCompleteWindow.hide_eventc             C   sJ   |  j    s d  Sd |  _ t |  j j   d  } |  j |  j |  d  S)NTr   )rc   r   r?   r   r@   r3   r   )r'   rf   rF   r(   r(   r)   rZ      s
    	z#AutoCompleteWindow.listselect_eventc             C   s;   t  |  j j   d  } |  j |  j |  |  j   d  S)Nr   )r?   r   r@   r3   r   rj   )r'   rf   rF   r(   r(   r)   r^      s    z$AutoCompleteWindow.doubleclick_eventc                s]  |  j    s d  S| j   t | d  r4 | j } n d }   d k rR d |  _ n  t    d k s   d( k s |  j t k r  d) k r| t @rt    d k r |  j	 |  j
    n   d k r |  j	 |  j
 d
  n   d k r|  j	 |  j
 d  n`   d	 k r)|  j	 |  j
 d  n= t |  j
  d k rL|  j   d  S|  j	 |  j
 d  d*   |  j
 |  _ |  j j d t |  j j   d   |  j j |  j |  j
   |  j   d S  d k r|  j   d  S|  j t k r  d+ k s|  j t k r  d, k r| t @rt |  j j   d  } |  j | d  t |  j
   |  j
 k r|  j t k sx|  j
 r|  j	 |  j |  n  |  j   d  S  d- k r-| r-d |  _ t |  j j   d  }   d k rd } n  d k r	t |  j  d } n   d. k r|  j j |  j j    |  j j d  }   d k rbt d | |  } q  d k stt  t t |  j  d | |  } nT   d k rt d | d  } n2   d k st  t t |  j  d | d  } |  j j |  |  j j |  |  j   |  j	 |  j |  d S  d k r| r|  j rt |  j j   d  } |  j	 |  j |  |  j   d Sd |  _ d |  _ d  Sn t   f d d    d/ D  rd  S| j rK| j d' k rK|  j	 |  j
 | j  |  j
 |  _ |  j j d t |  j j   d   |  j j |  j |  j
   |  j   d S|  j   d  Sd  S)0Nmc_stater   ZTabFr+   
underscore	BackSpaceperiodminus_.-breakZReturnspace	parenleft
parenrightbracketleftbracketrightslash	backslashquotedbl
apostropheHomeEndPriorNextUpDownTc             3   s   |  ] } |   k Vq d  S)Nr(   ).0r5   )keysymr(   r)   	<genexpr>a  s    z4AutoCompleteWindow.keypress_event.<locals>.<genexpr>ShiftControlAltMetaCommandOption )rl   rm   )rn   ro   )rn   rt   ru   rv   rw   rx   )ry   rz   r{   r|   )r}   r~   r   r   r   r   )r   r   )r   r   r   r   r   r   )rc   r   hasattrrk   r&   r-   r   r   r   r3   r   rj   r   r   Zselect_clearr?   r@   rD   r8   rE   r   r   r   Znearestrd   re   AssertionErrorr,   anychar)r'   rf   staterF   Znewseljumpr(   )r   r)   rT     s    		
&

 		)
		# 
	
		&

z!AutoCompleteWindow.keypress_eventc             C   s[   |  j    s d  S|  j j d  |  j j d |  j t |  j  f  k rW |  j   n  d  S)Nr/   z%s+%dc)rc   r   rJ   r   r-   r   rj   )r'   rf   r(   r(   r)   rW   t  s
    +z#AutoCompleteWindow.keyrelease_eventc             C   s   |  j  d  k	 S)N)r   )r'   r(   r(   r)   rc   |  s    zAutoCompleteWindow.is_activec             C   s   |  j  |  j |  j   d  S)N)r3   r;   r   )r'   r(   r(   r)   r_     s    zAutoCompleteWindow.completec             C   sL  |  j    s d  Sx! t D] } |  j j t |  q W|  j j t |  j  d  |  _ x! t D] } |  j j t |  qZ W|  j j t |  j	  d  |  _	 |  j j t
 t  |  j j t
 |  j  d  |  _ |  j j t |  j  d  |  _ |  j j t |  j  d  |  _ |  j j   d  |  _ |  j j   d  |  _ |  j j   d  |  _ d  S)N)rc   rR   r   Zevent_deleterP   Zunbindr    rU   rS   r!   rV   rX   r$   r   rY   r"   r   r[   r#   r   Zdestroy)r'   ra   r(   r(   r)   rj     s0    							zAutoCompleteWindow.hide_windowN)__name__
__module____qualname__r*   r3   r8   r;   rE   rb   r\   rQ   rZ   r^   rT   rW   rc   r_   rj   r(   r(   r(   r)   r      s    $Esr   N)r   r   )
r   r	   r
   r   r   r   r   r   r   r   )__doc__ZtkinterZidlelib.MultiCallr   Zidlelib.AutoCompleter   r   rP   rR   rS   rU   rV   rX   rY   r[   r]   r   r(   r(   r(   r)   <module>   s   
                                                                                                                                                                                                                                                                                usr/lib/python3.4/idlelib/__pycache__/AutoExpand.cpython-34.pyc                                     0100644 0000000 0000000 00000006140 13077704335 022714  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TC                 @   sc   d  Z  d d l Z d d l Z Gd d   d  Z e d k r_ d d l Z e j d d d n  d S)	a[  Complete the current word before the cursor with words in the editor.

Each menu selection or shortcut key selection replaces the word with a
different word with the same prefix. The search for matches begins
before the target and moves toward the top of the editor. It then starts
after the cursor and moves down. It then returns to the original word and
the cycle starts again.

Changing the current text line or leaving the cursor in a different
place before requesting the next selection causes AutoExpand to reset
its state.

This is an extension file and there is only one instance of AutoExpand.
    Nc               @   sf   e  Z d  Z d d g f g Z e j e j d Z d d   Z d d   Z	 d	 d
   Z
 d d   Z d S)
AutoExpandZeditE_xpand Word<<expand-word>>_c             C   s   | j  |  _  d  |  _ d  S)N)textstate)selfZeditwin r	   (/usr/lib/python3.4/idlelib/AutoExpand.py__init__    s    zAutoExpand.__init__c       
      C   sT  |  j  j d  } |  j  j d d  } |  j sE |  j   } d } nB |  j \ } } } } | | k sr | | k r |  j   } d } n  | s |  j  j   d S|  j   } |  j  j d t |  d  | | }	 | d t |  } | d k r|  j  j   n  |  j  j	 d |	  |  j  j d  } |  j  j d d  } | | | | f |  _ d S)z1Replace the current word with the next expansion.insertzinsert linestartzinsert lineendr   breakzinsert - %d chars   )
r   indexgetr   getwordsZbellgetprevwordZdeletelenr   )
r   ZeventZ	curinsertZcurlinewordsr   r   linewordZnewwordr	   r	   r
   expand_word_event$   s.    			
zAutoExpand.expand_word_eventc       	      C   s-  |  j    } | s g  S|  j j d d  } t j d | d |  } ~ |  j j d d  } t j d | d |  } ~ | r | r g  Sg  } i  } | j   x: | D]2 } | j |  r q n  | j |  | | | <q Wx: | D]2 } | j |  rq n  | j |  | | | <q W| j |  | S)z?Return a list of words that match the prefix before the cursor.z1.0zinsert wordstartz\bz\w+\bzinsert wordendend)r   r   r   refindallreverseappend)	r   r   ZbeforeZwbeforeZafterZwafterr   dictwr	   r	   r
   r   ?   s4    
zAutoExpand.getwordsc             C   sc   |  j  j d d  } t |  } x1 | d k rT | | d |  j k rT | d } q$ W| | d  S)z)Return the word prefix before the cursor.zinsert linestartr   r   r   N)r   r   r   	wordchars)r   r   ir	   r	   r
   r   ^   s
    &zAutoExpand.getprevwordN)r   r   )__name__
__module____qualname__ZmenudefsstringZascii_lettersZdigitsr   r   r   r   r   r	   r	   r	   r
   r      s   r   __main__z!idlelib.idle_test.test_autoexpand	verbosity   )__doc__r$   r   r   r!   Zunittestmainr	   r	   r	   r
   <module>   s   P                                                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.4/idlelib/__pycache__/Bindings.cpython-34.pyc                                       0100644 0000000 0000000 00000006113 13077704335 022401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s;  d  Z  d d l m Z d d l m Z d de df dg dh di d dj dk dl d dm d dn do g f d dp dq d dr ds dt du d dv dw dx dy dz d{ g f d5 d| d} d~ d d d d d g f dF d g f dI d d g f dN d d d d g f dW d d g f dZ d d d d g f g Z e da  r+e d db j d  n  e j   Z d S)a  Define the menu contents, hotkeys, and event bindings.

There is additional configuration information in the EditorWindow class (and
subclasses): the menus are created there based on the menu_specs (class)
variable, and menus not created are silently skipped in the code here.  This
makes it possible, for example, to define a Debug menu which is only present in
the PythonShell window, and a Format menu which is only present in the Editor
windows.

    )	find_spec)idleConffile	_New File<<open-new-window>>_Open...<<open-window-from-file>>Open _Module...<<open-module>>Class _Browser<<open-class-browser>>_Path Browser<<open-path-browser>>N_Save<<save-window>>Save _As...<<save-window-as-file>>Save Cop_y As...<<save-copy-of-window-as-file>>Prin_t Window<<print-window>>_Close<<close-window>>E_xit<<close-all-windows>>Zedit_Undo<<undo>>_Redo<<redo>>Cu_t<<cut>>_Copy<<copy>>_Paste	<<paste>>Select _All<<select-all>>_Find...<<find>>Find A_gain<<find-again>>Find _Selection<<find-selection>>Find in Files...<<find-in-files>>R_eplace...<<replace>>Go to _Line<<goto-line>>format_Indent Region<<indent-region>>_Dedent Region<<dedent-region>>Comment _Out Region<<comment-region>>U_ncomment Region<<uncomment-region>>Tabify Region<<tabify-region>>Untabify Region<<untabify-region>>Toggle Tabs<<toggle-tabs>>New Indent Width<<change-indentwidth>>ZrunPython Shell<<open-python-shell>>shell_View Last Restart<<view-restart>>_Restart Shell<<restart-shell>>debug_Go to File/Line<<goto-file-line>>
!_Debugger<<toggle-debugger>>_Stack Viewer<<open-stack-viewer>>!_Auto-open Stack Viewer<<toggle-jit-stack-viewer>>Zoptions_Configure IDLE...<<open-config-dialog>>help_About IDLE<<about-idle>>
_IDLE Help<<help>>Python _Docs<<python-docs>>Z
turtledemo   Turtle Demo<<open-turtle-demo>>)r   r   )r   r   )r	   r
   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r   )r   r    )r!   r"   )r#   r$   )r%   r&   )r'   r(   )r)   r*   )r+   r,   )r-   r.   )r/   r0   )r1   r2   )r4   r5   )r6   r7   )r8   r9   )r:   r;   )r<   r=   )r>   r?   )r@   rA   )rB   rC   )rD   rE   )rG   rH   )rI   rJ   )rL   rM   )rN   rO   )rP   rQ   )rR   rS   )rT   rU   )rW   rX   )rY   rZ   )r[   r\   )r^   r_   )	__doc__importlib.utilr   Zidlelib.configHandlerr   ZmenudefsappendZGetCurrentKeySetZdefault_keydefs rd   rd   &/usr/lib/python3.4/idlelib/Bindings.py<module>
   s|   							                                                                                                                                                                                                                                                                                                                                                                                                                                                     usr/lib/python3.4/idlelib/__pycache__/CallTipWindow.cpython-34.pyc                                  0100644 0000000 0000000 00000013365 13077704335 023373  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Tg                 @   s   d  Z  d d l m Z m Z m Z m Z m Z d Z d Z d Z	 d Z
 d	 Z d
 Z Gd d   d  Z d d   Z e d k r d d l m Z e e  n  d S)zA CallTip window class for Tkinter/IDLE.

After ToolTip.py, which uses ideas gleaned from PySol
Used by the CallTips IDLE extension.
    )ToplevelLabelLEFTSOLIDTclErrorz<<calltipwindow-hide>><Key-Escape>
<FocusOut>z<<calltipwindow-checkhide>><KeyRelease><ButtonRelease>d   Zcalltipwindowregion_rightc               @   sg   e  Z d  Z d d   Z d d   Z d d   Z d d d	  Z d
 d   Z d d   Z d d   Z	 d S)CallTipc             C   sO   | |  _  d  |  _ |  _ d  |  _ |  _ d  |  _ d  |  _ |  _ d  |  _ d  S)N)	widget	tipwindowlabel	parenlineparencollastlinehideidcheckhideidcheckhide_after_id)selfr    r   +/usr/lib/python3.4/idlelib/CallTipWindow.py__init__   s    		zCallTip.__init__c             C   s(  t  |  j j d  j d  d  } | |  j k r8 d S| |  _ |  j j d  | |  j k r |  j j d |  j |  j f  } n |  j j d |  } | s t	 |  j j d   } d | d <d | d <n  | d |  j j
   d } | d | d	 |  j j   } |  j j d
 | | f  d S)z;Check if needs to reposition the window, and if so - do it.insert.r   Nz%d.%dz%d.0         z+%d+%d)intr   indexsplitr   Zseer   Zbboxr   listZwinfo_rootxZwinfo_rootyr   Zwm_geometry)r   curlineZboxxyr   r   r   position_window   s     %	
zCallTip.position_windowc             C   s  | |  _  |  j s |  j  r  d S|  j j t |  t t |  j j |  j d   \ |  _	 |  _
 t |  j  |  _ } |  j   | j d  y# | j j d d | j d d  Wn t k
 r Yn Xt | d |  j  d	 t d
 d d t d d d |  j d |  _ |  j j   |  j j t |  j  |  _ x! t D] } |  j j t |  q4W|  j j t |  j  |  j j t |  j   |  _! x! t" D] } |  j j t |  qWd S)zMShow the calltip, bind events which will close it and reposition it.
        Nr   r   z!::tk::unsupported::MacWindowStyleZstylehelpZnoActivatestextZjustifyZ
backgroundz#ffffe0ZreliefZborderwidthZfont)#r(   r   r   Zmark_set
MARK_RIGHTmapr   r    r!   r   r   r   r&   Zwm_overrideredirectZtkcallZ_wr   r   r   r   r   packbindCHECKHIDE_VIRTUAL_EVENT_NAMEcheckhide_eventr   CHECKHIDE_SEQUENCES	event_addafterCHECKHIDE_TIMEHIDE_VIRTUAL_EVENT_NAME
hide_eventr   HIDE_SEQUENCES)r   r(   Z	parenleftZ
parenrightZtwseqr   r   r   showtip/   s6    	-
zCallTip.showtipNc             C   s   |  j  s d  St t |  j j d  j d   \ } } | |  j k  s| | |  j k rd | |  j k s| |  j j d d t	  r |  j
   nJ |  j   |  j d  k	 r |  j j |  j  n  |  j j t |  j  |  _ d  S)Nr   r   >)r   r*   r   r   r    r!   r   r   Zcomparer)   hidetipr&   r   Zafter_cancelr2   r3   r/   )r   eventr#   Zcurcolr   r   r   r/   V   s    	*
zCallTip.checkhide_eventc             C   s   |  j  s d  S|  j   d  S)N)r   r:   )r   r;   r   r   r   r5   h   s    	zCallTip.hide_eventc             C   s   |  j  s d  Sx! t D] } |  j j t |  q W|  j j t |  j  d  |  _ x! t D] } |  j j t |  qW W|  j j t |  j	  d  |  _	 |  j
 j   d  |  _
 |  j  j   d  |  _  |  j j t  d  |  _ |  _ |  _ d  S)N)r   r0   r   Zevent_deleter.   Zunbindr   r6   r4   r   r   ZdestroyZ
mark_unsetr)   r   r   r   )r   r7   r   r   r   r:   n   s     					zCallTip.hidetipc             C   s   t  |  j  S)N)boolr   )r   r   r   r   	is_active   s    zCallTip.is_active)
__name__
__module____qualname__r   r&   r8   r/   r5   r:   r=   r   r   r   r   r      s   'r   c                s   d d  l  } d d l m } m  m  m   |     j d  t t t	 | j
 d |  j      \ } } } }  j d | | d f  G     f d d   d  } |   d  S)	Nr   )TkTextr   BOTHzTest calltipsz[x+]z+%d+%d   c                   sC   e  Z d  Z      f d d   Z d d   Z d d   Z d S)z"_calltip_window.<locals>.MyEditWinc                s      } |  _  | j d  d   d d  | j d d   j   t |  |  _ | j d d  | j d	 d
  | j d |  j  | j d	 |  j	  | j
    j   d  S)NZsideZfillexpandr   r   zstring.splitz<<calltip-show>>(z<<calltip-hide>>))r(   r,   r   updater   calltipr1   r-   calltip_showcalltip_hideZ	focus_setZmainloop)r   r(   )rC   r   rB   rootr   r   r      s    

z+_calltip_window.<locals>.MyEditWin.__init__c             S   s   |  j  j d d d  d  S)NzHello worldr   end)rI   r8   )r   r;   r   r   r   rJ      s    z/_calltip_window.<locals>.MyEditWin.calltip_showc             S   s   |  j  j   d  S)N)rI   r:   )r   r;   r   r   r   rK      s    z/_calltip_window.<locals>.MyEditWin.calltip_hideN)r>   r?   r@   r   rJ   rK   r   )rC   r   rB   rL   r   r   	MyEditWin   s   rN   )retkinterrA   rB   r   rC   titler"   r*   r   r!   Zgeometry)parentrO   rA   widthZheightr$   r%   rN   r   )rC   r   rB   rL   r   _calltip_window   s    "	3"rT   __main__)runN)r   r   )r	   r
   )__doc__rP   r   r   r   r   r   r4   r6   r.   r0   r3   r)   r   rT   r>   Zidlelib.idle_test.htestrV   r   r   r   r   <module>   s   (w!                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/__pycache__/CallTips.cpython-34.pyc                                       0100644 0000000 0000000 00000013460 13077704335 022362  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T,                 @   s   d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l Z d d l m Z d d l	 m
 Z
 Gd d   d  Z d d   Z d	 Z d
 Z d Z e j d  Z d Z d d   Z e d k r d d l m Z e d d d n  d S)a  CallTips.py - An IDLE Extension to Jog Your Memory

Call Tips are floating windows which display function, class, and method
parameter and docstring information when you type an opening parenthesis, and
which disappear when you type a closing parenthesis.

    N)CallTipWindow)HyperParserc               @   s   e  Z d  Z d d g f g Z d d d  Z d d   Z d	 d
   Z d d d  Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)CallTipsZeditShow call tip<<force-open-calltip>>Nc             C   sF   | d  k r d  |  _  n* | |  _  | j |  _ d  |  _ |  j |  _ d  S)N)editwintextactive_calltip_make_tk_calltip_window_calltip_window)selfr    r   &/usr/lib/python3.4/idlelib/CallTips.py__init__   s    		zCallTips.__init__c             C   s   d  |  _  d  S)N)r   )r   r   r   r   close#   s    zCallTips.closec             C   s   t  j |  j  S)N)r   ZCallTipr   )r   r   r   r   r
   &   s    z CallTips._make_tk_calltip_windowc             C   s&   |  j  r" |  j  j   d  |  _  n  d  S)N)r	   Zhidetip)r   eventr   r   r   _remove_calltip_window*   s    	zCallTips._remove_calltip_windowc             C   s   |  j  d  d S)z9The user selected the menu entry or hotkey, open the tip.TN)open_calltip)r   r   r   r   r   force_open_calltip_event/   s    z!CallTips.force_open_calltip_eventc             C   s   |  j  d  d S)zHappens when it would be nice to open a CallTip, but not really
        necessary, for example after an opening bracket, so function calls
        won't be made.
        FN)r   )r   r   r   r   r   try_open_calltip_event3   s    zCallTips.try_open_calltip_eventc             C   s,   |  j  r( |  j  j   r( |  j d  n  d  S)NF)r	   Z	is_activer   )r   r   r   r   r   refresh_calltip_event:   s    zCallTips.refresh_calltip_eventc             C   s   |  j    t |  j d  } | j d  } | s5 d  S| j | d  | j   } | s\ d  S| r| | j d  d k r| d  S|  j |  } | s d  S|  j   |  _	 |  j	 j
 | | d | d  d  S)Ninsert(r      )r   r   r   Zget_surrounding_bracketsZ	set_indexZget_expressionfind	fetch_tipr   r	   Zshowtip)r   Z	evalfuncsZhpZ	sur_paren
expressionargspecr   r   r   r   >   s     
zCallTips.open_calltipc             C   sg   y |  j  j j j j } Wn t k
 r3 d } Yn X| rS | j d d | f i   St t |   Sd S)aD  Return the argument list and docstring of a function or class.

        If there is a Python subprocess, get the calltip there.  Otherwise,
        either this fetch_tip() is running in the subprocess or it was
        called in an IDLE running without the subprocess.

        The subprocess environment is that of the most recently run script.  If
        two unrelated modules are being edited some calltips in the current
        module may be inoperative if the module was not the last to run.

        To find methods, fetch_tip must be fed a fully qualified name.

        NexecZget_the_calltip)	r   ZflistZpyshellZinterprpccltAttributeErrorZ
remotecallget_argspec
get_entity)r   r   r    r   r   r   r   Q   s    zCallTips.fetch_tip)r   r   )__name__
__module____qualname__Zmenudefsr   r   r
   r   r   r   r   r   r   r   r   r   r   r      s   	r   c             C   sV   |  rR t  j j   } | j t j  y t |  |  SWqR t k
 rN d SYqR Xn  d S)zwReturn the object corresponding to expression evaluated
    in a namespace spanning sys.modules and __main.dict__.
    N)sysmodulescopyupdate__main____dict__evalBaseException)r   	namespacer   r   r   r#   i   s    r#   U          z(?<=\()\w*\,?\s*zSee source or docc             C   s  d } y |  j  } Wn t k
 r+ | SYn Xt |  t  rG |  j } n! t | t j  rb | } n |  } t | t j t j f  r t j	 t j
 |    } t |  t t j f  s t | t j  r t j d |  } q n  t |  t k rt j | t d t n | r| g n g  } t | t j  r:| j } n t |  d d  } | rxt | j d t  d t  D]V } | j   } | sPn  t |  t k r| d t d  d } n  | j |  qoWd j |  } n  | st } n  | S)a  Return a string describing the signature of a callable object, or ''.

    For Python-coded functions and methods, the first line is introspected.
    Delete 'self' parameter for classes (.__init__) and bound methods.
    The next lines are the first lines of the doc string up to the first
    empty line or _MAX_LINES.    For builtins, this typically includes
    the arguments in addition to the return value.
     Zsubsequent_indent__doc__
N   z...)__call__r.   
isinstancetyper   types
MethodTypeFunctionTypeinspectZformatargspecZgetfullargspec_first_paramsublen	_MAX_COLStextwrapZwrap_INDENTr5   getattrsplit
_MAX_LINESstripappendjoin_default_callable_argspec)obr   Zob_callZfoblinesdocliner   r   r   r"      s>    			?#	r"   r+   )mainzidlelib.idle_test.test_calltips	verbosity   z    )r5   r+   r>   rer'   rC   r;   Zidlelibr   Zidlelib.HyperParserr   r   r#   rB   rG   rD   compiler?   rK   r"   r$   ZunittestrP   r   r   r   r   <module>   s&   W.                                                                                                                                                                                                                usr/lib/python3.4/idlelib/__pycache__/ClassBrowser.cpython-34.pyc                                   0100644 0000000 0000000 00000020554 13077704335 023262  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s  d  Z  d d l Z d d l Z d d l Z d d l m Z d d l m Z d d l m	 Z	 m
 Z
 m Z d d l m Z Gd d   d  Z Gd	 d
   d
 e
  Z Gd d   d e
  Z Gd d   d e
  Z d d   Z e d k r d d l m Z e e  n  d S)a  Class browser.

XXX TO DO:

- reparse when source changed (maybe just a button would be OK?)
    (or recheck on window popup)
- add popup menu with more options (e.g. doc strings, base classes, imports)
- show function argument list? (have to do pattern matching on source)
- should the classes and methods lists also be in the module's menu bar?
- add base classes to class browser tree
    N)PyShell)ListedToplevel)TreeNodeTreeItemScrolledCanvas)idleConfc               @   sR   e  Z d  Z d d d  Z d d d  Z d d   Z d	 d
   Z d d   Z d S)ClassBrowserFc             C   sF   | |  _  t j j | d |  j  d  |  _ | |  _ |  j |  d S)zH
        _htest - bool, change box when location running htest.
        r   z.pyN)nameospathjoinfile_htestinit)selfflistr	   r   r    r   */usr/lib/python3.4/idlelib/ClassBrowser.py__init__   s    	#	zClassBrowser.__init__Nc             C   s   |  j  j   |  j j   d  S)N)topZdestroynode)r   Zeventr   r   r   close#   s    zClassBrowser.closec             C   sA  | |  _  t j j   t | j  |  _ } | j d |  j  | j	 d |  j  |  j
 r | j d | j j   | j j   d f  n  |  j   | j   t j d d d  } t j | d  d	 } t | d
 | d d d d } | j j d d d d  |  j   } t | j d  |  |  _ } | j   | j   d  S)NZWM_DELETE_WINDOWz<Escape>z+%d+%d   mainZThemer	   Znormal
backgroundZbgZhighlightthicknessr   Z	takefocus   expandZfillZboth)r   pyclbrZ_modulesclearr   rootr   Zprotocolr   Zbindr   ZgeometryZwinfo_rootxZwinfo_rootysettitleZ	focus_setr   Z	GetOptionZGetHighlightr   ZframeZpackrootnoder   Zcanvasr   updater   )r   r   r   Zthemer   Zscitemr   r   r   r   r   '   s$    			'


zClassBrowser.initc             C   s+   |  j  j d |  j  |  j  j d  d  S)NzClass Browser - zClass Browser)r   Zwm_titler	   Zwm_iconname)r   r   r   r   r    >   s    zClassBrowser.settitlec             C   s   t  |  j  S)N)ModuleBrowserTreeItemr   )r   r   r   r   r!   B   s    zClassBrowser.rootnode)__name__
__module____qualname__r   r   r   r    r!   r   r   r   r   r      s
   r   c               @   sd   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d S)r$   c             C   s   | |  _  d  S)N)r   )r   r   r   r   r   r   G   s    zModuleBrowserTreeItem.__init__c             C   s   t  j j |  j  S)N)r
   r   basenamer   )r   r   r   r   GetTextJ   s    zModuleBrowserTreeItem.GetTextc             C   s   d S)Npythonr   )r   r   r   r   GetIconNameM   s    z!ModuleBrowserTreeItem.GetIconNamec             C   sF   g  } x9 |  j    D]+ } t | |  j |  j  } | j |  q W| S)N)listclassesClassBrowserTreeItemclassesr   append)r   sublistr	   r#   r   r   r   
GetSubListP   s
    z ModuleBrowserTreeItem.GetSubListc             C   sY   t  j j |  j d d    d k r) d  St  j j |  j  sB d  St j j |  j  d  S)N   z.py)r
   r   normcaser   existsr   r   open)r   r   r   r   OnDoubleClickW   s
    %z#ModuleBrowserTreeItem.OnDoubleClickc             C   s#   t  j j |  j d d    d k S)Nr2   z.pyr3   )r
   r   r4   r   )r   r   r   r   IsExpandable^   s    z"ModuleBrowserTreeItem.IsExpandablec             C   s  t  j j |  j  \ } } t  j j |  \ } } t  j j |  d k rO g  Sy  t j | | g t j  } Wn t	 k
 r g  SYn Xg  } i  |  _
 x | j   D] \ } } | j | k r | }	 t | d  rp| j rpg  }
 xp | j D]e } t |  t d  k r| } n1 | j } | j | j k rEd | j | f } n  |
 j |  q W|	 d d j |
  }	 n  | j | j |	 f  | |  j
 |	 <q q W| j   g  } x! | D] \ } }	 | j |	  qW| S)Nz.pysuper z%s.%sz(%s)z, )r
   r   splitr   splitextr4   r   Zreadmodule_exsysImportErrorr.   itemsmodulehasattrr9   typer	   r/   r   linenosort)r   dirr   r	   Zextdictr?   keyclsZsupersZsupZsnamelistr#   r   r   r   r,   a   s<     				
z!ModuleBrowserTreeItem.listclassesN)
r%   r&   r'   r   r)   r+   r1   r7   r8   r,   r   r   r   r   r$   E   s   r$   c               @   sd   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d S)r-   c             C   sr   | |  _  | |  _ | |  _ y |  j |  j  |  _ Wn! t t f k
 rU d  |  _ Yn Xt |  j t j  |  _	 d  S)N)
r	   r.   r   rH   
IndexErrorKeyError
isinstancer   ZFunction
isfunction)r   r	   r.   r   r   r   r   r      s    			zClassBrowserTreeItem.__init__c             C   s'   |  j  r d |  j d Sd |  j Sd  S)Nzdef z(...)zclass )rN   r	   )r   r   r   r   r)      s    	zClassBrowserTreeItem.GetTextc             C   s   |  j  r d Sd Sd  S)Nr*   Zfolder)rN   )r   r   r   r   r+      s    	z ClassBrowserTreeItem.GetIconNamec             C   s9   |  j  r5 y |  j  j SWq5 t k
 r1 d SYq5 Xn  d  S)NF)rH   methodsAttributeError)r   r   r   r   r8      s
    	z!ClassBrowserTreeItem.IsExpandablec             C   sS   |  j  s g  Sg  } x9 |  j   D]+ } t | |  j  |  j  } | j |  q  W| S)N)rH   listmethodsMethodBrowserTreeItemr   r/   )r   r0   r	   r#   r   r   r   r1      s    	zClassBrowserTreeItem.GetSubListc             C   s`   t  j j |  j  s d  St j j |  j  } t |  j d  r\ |  j j	 } | j
 |  n  d  S)NrC   )r
   r   r5   r   r   r   r6   rA   rH   rC   gotoline)r   editrC   r   r   r   r7      s    z"ClassBrowserTreeItem.OnDoubleClickc             C   s   |  j  s g  Sg  } x3 |  j  j j   D] \ } } | j | | f  q& W| j   g  } x! | D] \ } } | j |  q` W| S)N)rH   rO   r?   r/   rD   )r   r?   r	   rC   rJ   r#   r   r   r   rQ      s    	
z ClassBrowserTreeItem.listmethodsN)
r%   r&   r'   r   r)   r+   r8   r1   r7   rQ   r   r   r   r   r-      s   
	r-   c               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)rR   c             C   s   | |  _  | |  _ | |  _ d  S)N)r	   rH   r   )r   r	   rH   r   r   r   r   r      s    		zMethodBrowserTreeItem.__init__c             C   s   d |  j  d S)Nzdef z(...))r	   )r   r   r   r   r)      s    zMethodBrowserTreeItem.GetTextc             C   s   d S)Nr*   r   )r   r   r   r   r+      s    z!MethodBrowserTreeItem.GetIconNamec             C   s   d S)Nr   r   )r   r   r   r   r8      s    z"MethodBrowserTreeItem.IsExpandablec             C   sL   t  j j |  j  s d  St j j |  j  } | j |  j j	 |  j
  d  S)N)r
   r   r5   r   r   r   r6   rS   rH   rO   r	   )r   rT   r   r   r   r7      s    z#MethodBrowserTreeItem.OnDoubleClickN)r%   r&   r'   r   r)   r+   r8   r7   r   r   r   r   rR      s
   rR   c             C   s   y
 t  } WnO t k
 r[ t j d } t j d d   rJ t j d } n t j d } Yn Xt j j |  \ } } t j j |  d } t j	 |   } t
 | | | g d d |  j   d  S)Nr   r   r   T)__file__	NameErrorr=   argvr
   r   r;   r<   r   ZPyShellFileListr   Zmainloop)parentr   rE   r	   r   r   r   r   _class_browser   s    
rY   __main__)run)__doc__r
   r=   r   Zidlelibr   Zidlelib.WindowListr   Zidlelib.TreeWidgetr   r   r   Zidlelib.configHandlerr   r   r$   r-   rR   rY   r%   Zidlelib.idle_test.htestr[   r   r   r   r   <module>   s   /=<                                                                                                                                                    usr/lib/python3.4/idlelib/__pycache__/CodeContext.cpython-34.pyc                                    0100644 0000000 0000000 00000014046 13077704335 023067  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                  @   s   d  Z  d d l Z d d l m Z m Z m Z m Z m Z d d l Z d d l	 m
 Z d d l m Z e d d d d	 d
 d d d d d d g  Z d Z d Z e j d  d d  Z Gd d   d  Z d S)aI  CodeContext - Extension to display the block context above the edit window

Once code has scrolled off the top of a window, it can be difficult to
determine which block you are in.  This extension implements a pane at the top
of each IDLE edit window which provides block structure hints.  These hints are
the lines which contain the block opening keywords, e.g. 'if', for the
enclosing block.  The number of hint lines is determined by the numlines
variable in the CodeContext section of config-extensions.def. Lines which do
not open blocks are not shown in the context hints pane.

    N)TOPLEFTXWSUNKEN)maxsize)idleConfclassdefelifelseexceptfinallyforiftrywhilewithd   i  z^(\s*)(\w*)c             C   s   | j  |   j   S)N)matchgroups)sc r   )/usr/lib/python3.4/idlelib/CodeContext.py<lambda>   s    r   c               @   s   e  Z d  Z d d  g f g Z e j d d  d d d d d	 Z e j d d  d
 d d d d Z e j d d  d d d d d Z d d   Z	 d d d  Z
 d d   Z d d d d  Z d d   Z d d   Z d d   Z d S)!CodeContextZoptions!Code Conte_xt<<toggle-code-context>>
extensionsZnumlinestypeintdefault   bgcolorstrZ	LightGrayfgcolorZBlackc             C   s   | |  _  | j |  _ |  j d |  _ d  |  _ d g |  _ d |  _ t j d d d d	 d
 d d } | r |  j   |  j  j	 d d  n  |  j j
 t |  j  |  j j
 t |  j  d  S)Nfontr       Fr   r   visibler    boolr"   z<<toggle-code-context>>T)r   r,   r)   F)editwintexttextfontlabelinfo
topvisibler   	GetOptiontoggle_code_context_eventZsetvarafterUPDATEINTERVALtimer_eventFONTUPDATEINTERVALfont_timer_event)selfr-   r*   r   r   r   __init__"   s    			
zCodeContext.__init__Nc             C   s  |  j  sC|  j j |  j j f } d } xM | D]E } | t t | j   d   7} | t t | j d    7} q. Wd } x- | D]% } | t t | j d    7} q Wt j	 |  j j
 d d |  j d d t d t d	 |  j d
 |  j d |  j d d d | d | d t 
|  _  |  j  j d t d t d d d |  j j  n |  j  j   d  |  _  t j d d d t |  j  d  k	   t j   d  S)Nr   padxborderr.   
r(   ZanchorZjustifyr'   ZbgZfgwidthZreliefZsideZfillexpandFZbeforer   r   r*   )r0   r-   r.   Z
text_framer!   r%   Z	pack_infoZcgettkinterZLabeltopcontext_depthr   r   r/   r$   r&   r   Zpackr   r   Zdestroyr   Z	SetOptionZSaveUserCfgFiles)r:   ZeventZwidgetsr<   Zwidgetr=   r   r   r   r4   7   s0    	 ##		z%CodeContext.toggle_code_context_eventc             C   s   |  j  j d | d |  } t |  \ } } | t k o> | } t |  t |  k so | t |  d k rx t } n t |  } | | | f S)zGet the line indent value, text, and any block start keyword

        If the line does not start a block, the keyword value is False.
        The indentation of empty lines (or comment lines) is INFINITY.

        z%d.0z%d.end#)r.   getgetspacesfirstwordBLOCKOPENERSlenINFINITY)r:   linenumr.   ZspacesZ	firstwordopenerindentr   r   r   get_line_info[   s    .	zCodeContext.get_line_infor(   r   c       
      C   s   | d k s t   g  } t } x t | | d d  D] } |  j |  \ } } }	 | | k  r5 | } |	 d k r~ | d 7} n  |	 r | | k  r | | k r | j | | | |	 f  n  | | k r Pq q5 q5 W| j   | | f S)zGet context lines, starting at new_topvisible and working backwards.

        Stop when stopline or stopindent is reached. Return a tuple of context
        data and the indent level at the top of the region inspected.

        r   r(   r   r   r,   )zelsezelif)AssertionErrorrI   rangerM   appendreverse)
r:   new_topvisibleZstopline
stopindentlines
lastindentrJ   rL   r.   rK   r   r   r   get_contextk   s    
zCodeContext.get_contextc             C   s  t  |  j j d  j d  d  } |  j | k r8 d S|  j | k  r |  j | |  j  \ } } x |  j d d | k r |  j d =qe Wn |  j | k r|  j d d d } x6 |  j d d | k r |  j d d } |  j d =q W|  j | |  j d d d |  \ } } n  |  j j |  | |  _ d g t d |  j	 t
 |  j   } | d d   |  j |  j	 d  D 7} d	 j |  |  j d
 <d S)zKUpdate context information and lines visible in the context pane.

        z@0,0.r   Nr(   r)   c             S   s   g  |  ] } | d   q S)   r   ).0xr   r   r   
<listcomp>   s   	 z3CodeContext.update_code_context.<locals>.<listcomp>r>   r.   r,   r,   r,   r,   r,   r,   r,   )r!   r.   indexsplitr2   rV   r1   extendmaxrC   rH   joinr0   )r:   rR   rT   rU   rS   Zcontext_stringsr   r   r   update_code_context   s*    %			&(zCodeContext.update_code_contextc             C   s0   |  j  r |  j   n  |  j j t |  j  d  S)N)r0   ra   r.   r5   r6   r7   )r:   r   r   r   r7      s    	zCodeContext.timer_eventc             C   s[   |  j  d } |  j rA | |  j k rA | |  _ |  j |  j d <n  |  j  j t |  j  d  S)Nr'   )r.   r0   r/   r5   r8   r9   )r:   Znewtextfontr   r   r   r9      s
    	zCodeContext.font_timer_event)r   r   )__name__
__module____qualname__Zmenudefsr   r3   rC   r$   r&   r;   r4   rM   rV   ra   r7   r9   r   r   r   r   r      s   $ r   )__doc__rA   Ztkinter.constantsr   r   r   r   r   resysr   rI   Zidlelib.configHandlerr   setrG   r6   r8   compilerF   r   r   r   r   r   <module>   s   (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/idlelib/__pycache__/ColorDelegator.cpython-34.pyc                                 0100644 0000000 0000000 00000017556 13077704335 023566  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T%                 @   s   d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Td  d l m Z d  d l m Z d Z	 d d   Z
 d d	   Z e j e   e j  Z e j d
 e j  Z Gd d   d e  Z d d   Z e d k r d  d l m Z e e  n  d S)    N)*)	Delegator)idleConfFc             C   s   d |  d j  |  d S)z9Return a named group pattern matching list of alternates.z(?P<%s>|))join)nameZ
alternates r	   ,/usr/lib/python3.4/idlelib/ColorDelegator.pyany   s    r   c        
      C   s   d t  d t j  d }  d d   t t  D } d t  d |  d } t  d d g  } d	 } | d
 } | d } | d } | d } t  d | | | | g  }	 |  d | d | d |	 d t  d d g  S)Nz\bKEYWORDc             S   s;   g  |  ]1 } | j  d   r | t j k r t |   q S)_)
startswithkeywordkwliststr).0r   r	   r	   r
   
<listcomp>   s   	 zmake_pat.<locals>.<listcomp>z([^.'\"\\#]\b|^)BUILTINCOMMENTz#[^\n]*z4(\br|u|ur|R|U|UR|Ur|uR|b|B|br|Br|bR|BR|rb|rB|Rb|RB)?z'[^'\\\n]*(\\.[^'\\\n]*)*'?z"[^"\\\n]*(\\.[^"\\\n]*)*"?z''''[^'\\]*((\\.|'(?!''))[^'\\]*)*(''')?z'"""[^"\\]*((\\.|"(?!""))[^"\\]*)*(""")?STRINGr   SYNCz\n)r   r   r   dirbuiltins)
kwZbuiltinlistbuiltincommentZstringprefixZsqstringZdqstringZ	sq3stringZ	dq3stringstringr	   r	   r
   make_pat   s    



r   z\s+(\w+)c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
 d  Z d	 d d  Z d	 Z	 d Z
 d Z d	 d d  Z d	 Z d	 d d  Z d d   Z d d   Z d d   Z d d   Z d	 S)ColorDelegatorc             C   s-   t  j |   t |  _ t |  _ |  j   d  S)N)r   __init__progidprogLoadTagDefs)selfr	   r	   r
   r    &   s    		zColorDelegator.__init__c             C   s   |  j  d  k	 r |  j d  n  t j |  |  | d  k	 rk |  j   |  j d |  j  |  j d d  n d |  _ d |  _	 d  S)Nz<<toggle-auto-coloring>>z1.0endTF)
delegateZunbindr   setdelegateconfig_colorsZbindtoggle_colorize_eventnotify_rangestop_colorizingallow_colorizing)r$   r&   r	   r	   r
   r'   ,   s    
	zColorDelegator.setdelegatec             C   sJ   x6 |  j  j   D]% \ } } | r |  j | |  q q W|  j d  d  S)NZsel)tagdefsitemsZtag_configureZ	tag_raise)r$   tagZcnfr	   r	   r
   r(   9   s    zColorDelegator.config_colorsc             C   s   t  j d d d  } i	 t  j | d  d 6t  j | d  d 6t  j | d  d	 6t  j | d
  d 6t  j | d  d 6i d  d 6d  d 6d 6i d  d 6d  d 6d 6t  j | d  d 6t  j | d  d 6|  _ t r t d |  j  n  d  S)NmainZThemer   r   r   r   r   r   r   r   r   Z
definition
DEFINITION
backgroundZ
foregroundr   TODOerrorZERRORZhitr-   )r   Z	GetOptionZGetHighlightr-   DEBUGprint)r$   Zthemer	   r	   r
   r#   ?   s     zColorDelegator.LoadTagDefsNc             C   sG   |  j  |  } |  j j | | |  |  j | | d t |   d  S)Nz+%dc)indexr&   insertr*   len)r$   r7   charsZtagsr	   r	   r
   r8   P   s    zColorDelegator.insertc             C   s3   |  j  |  } |  j j | |  |  j |  d  S)N)r7   r&   deleter*   )r$   index1index2r	   r	   r
   r;   U   s    zColorDelegator.deleteTFc             C   s   |  j  d | |  |  j r3 t r/ t d  n  d  S|  j r[ d |  _ t r[ t d  q[ n  |  j r t rw t d  n  |  j d |  j  |  _ n  d  S)Nr3   zcolorizing already scheduledTzstop colorizingzschedule colorizing   )	tag_addafter_idr5   r6   
colorizingr+   r,   after
recolorize)r$   r<   r=   r	   r	   r
   r*   ^   s    	 		 	 zColorDelegator.notify_rangec             C   s|   |  j  r> |  j  } d  |  _  t r. t d  n  |  j |  n  d |  _ d |  _ | rx |  j sl | j   qx | |  _ n  d  S)Nzcancel scheduled recolorizerFT)	r@   r5   r6   after_cancelr,   r+   rA   destroyclose_when_done)r$   rF   r@   r	   r	   r
   closel   s    			 			zColorDelegator.closec             C   s   |  j  r> |  j  } d  |  _  t r. t d  n  |  j |  n  |  j ro |  j ro t rc t d  n  d |  _ n  |  j |  _ |  j r |  j r |  j d |  j  |  _  n  t r t d |  j r d p d  n  d S)	Nzcancel scheduled recolorizerzstop colorizingTr>   zauto colorizing turnedZonZoffbreak)	r@   r5   r6   rD   r,   rA   r+   rB   rC   )r$   Zeventr@   r	   r	   r
   r)   z   s"    			  z$ColorDelegator.toggle_colorize_eventc             C   sQ  d  |  _  |  j s) t r% t d  n  d  S|  j sI t rE t d  n  d  S|  j ri t re t d  n  d  Szf d |  _ d |  _ t r t d  n  t j   } |  j	   t j   } t r t d | |  n  Wd  d |  _ X|  j r%|  j
 d d	  r%t r
t d
  n  |  j d |  j  |  _  n  |  j rM|  j } d  |  _ | j   n  d  S)Nzno delegatezauto colorizing is offzalready colorizingFTzcolorizing...z%.3f secondsr3   z1.0zreschedule colorizingr>   )r@   r&   r5   r6   r,   rA   r+   timeZperf_counterrecolorize_maintag_nextrangerB   rC   rF   rE   )r$   Zt0Zt1topr	   r	   r
   rC      s@    		 	 	 		 
 
 			zColorDelegator.recolorizec             C   s  d } x|  j  d |  } | s% Pn  | \ } } |  j d | |  |  j d |  } | ri | d } n d } d } | } d } d } x| s| } |  j | d |  } t | d d	  } d |  j | d
  k } |  j | |  }	 |	 s d  Sx$ |  j D] }
 |  j |
 | |  q W| |	 } |  j j	 |  } x | r(x | j
   j   D] \ } } | rT| j |  \ } } |  j | | d | | d |  | d k r|  j j | |  } | r| j d  \ } } |  j d | d | | d |  qqqTqTW|  j j	 | | j    } q;Wd |  j | d
  k rQ| } d } n d } | sp|  j d |  n  |  j   |  j r t rt d  n  d  Sq Wq	 d  S)Nz1.0r3   r   r>    Fz+%d lines linestart   d   z-1cz+%dcdefclassr1   zcolorizing stopped)zdefzclass)rK   
tag_removeZtag_prevranger7   minZ	tag_namesgetr-   r!   search	groupdictr.   spanr?   r"   matchr%   updater+   r5   r6   )r$   nextitemheadtailr:   Zlines_to_getokmarkliner/   mkeyvalueabZm1r	   r	   r
   rJ      sl    	
				
	 zColorDelegator.recolorize_mainc             C   s+   x$ |  j  D] } |  j | d d  q
 Wd  S)Nz1.0r%   )r-   rR   )r$   r/   r	   r	   r
   removecolors   s    zColorDelegator.removecolors)__name__
__module____qualname__r    r'   r(   r#   r8   r;   r@   r,   rA   r*   rF   rG   r)   rC   rJ   rf   r	   r	   r	   r
   r   $   s    Ar   c             C   s   d d l  m } t   } | j d  t t t t j d |  j	      \ } } } } | j	 d | | d f  d } t
 | d d	 } | j d
 |  | j d d d d  | |  }	 t   }
 |	 j |
  | j   d  S)Nr   )
PercolatorzTest ColorDelegatorz[x+]z+%d+%d   z&if somename: x = 'abc' # comment
printr2   Zwhiter8   expandr>   ZfillZboth)Zidlelib.Percolatorrj   ZTktitlelistmapintresplitZgeometryZTextr8   Zpackr   ZinsertfilterZmainloop)parentrj   rootwidthZheightxysourcetextpdr	   r	   r
   _color_delegator   s    	3	r|   __main__)run)rI   rq   r   r   ZtkinterZidlelib.Delegatorr   Zidlelib.configHandlerr   r5   r   r   compileSr!   r"   r   r|   rg   Zidlelib.idle_test.htestr~   r	   r	   r	   r
   <module>   s    
                                                                                                                                                  usr/lib/python3.4/idlelib/__pycache__/Debugger.cpython-34.pyc                                       0100644 0000000 0000000 00000035352 13077704335 022377  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T?                 @   s   d  d l  Z  d  d l Z d  d l Td  d l m Z d  d l m Z d  d l m Z Gd d   d e j	  Z
 Gd d	   d	  Z Gd
 d   d e  Z Gd d   d  Z d S)    N)*)ListedToplevel)ScrolledList)macosxSupportc               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)Idbc             C   s   | |  _  t j j |   d  S)N)guibdbBdb__init__)selfr    r   &/usr/lib/python3.4/idlelib/Debugger.pyr
      s    	zIdb.__init__c             C   sC   |  j  |  r |  j   d  S|  j |  } |  j j | |  d  S)N)in_rpc_codeset_step_Idb__frame2messager   interaction)r   framemessager   r   r   	user_line   s
    
zIdb.user_linec             C   sF   |  j  |  r |  j   d  S|  j |  } |  j j | | |  d  S)N)r   r   r   r   r   )r   r   infor   r   r   r   user_exception   s
    
zIdb.user_exceptionc             C   sL   | j  j j d  r d S| j } | j  j j d  r; d S|  j |  Sd  S)Nzrpc.pyTzDebugger.pyF)f_codeco_filenamecountf_backr   )r   r   Z
prev_framer   r   r   r      s    	zIdb.in_rpc_codec             C   sf   | j  } | j } | j } t j j |  } d | | f } | j d k rb d | | j f } n  | S)Nz%s:%s?z%s: %s())r   r   f_linenoospathbasenameco_name)r   r   codefilenamelinenor   r   r   r   r   Z__frame2message'   s    			zIdb.__frame2messageN)__name__
__module____qualname__r
   r   r   r   r   r   r   r   r   r   	   s
   
r   c               @   sH  e  Z d  Z d Z Z Z Z d d d  Z d d   Z d d d  Z	 d d	   Z
 d d
 d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d Z d d   Z d d   Z d d   Z d Z d Z d  d!   Z d" d#   Z d$ d% d&  Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d S)/DebuggerNc             C   sM   | d  k r t  |   } n  | |  _ | |  _ d  |  _ |  j   d |  _ d  S)Nr   )r   pyshellidbr   make_guiinteracting)r   r(   r)   r   r   r   r
   6   s    			
zDebugger.__init__c             G   s.   z d |  _  |  j j |   SWd  d |  _  Xd  S)N   r   )r+   r)   run)r   argsr   r   r   r-   ?   s    	zDebugger.runc             C   sZ   |  j  r |  j j   d  S|  j r< |  j j   d  |  _ n  |  j j   |  j j   d  S)N)r+   topZbellstackviewercloser(   Zclose_debuggerdestroy)r   eventr   r   r   r1   F   s    		 zDebugger.closec             C   s  |  j  } | j |  _ | j |  _ } t |  |  _ } |  j j d  |  j j d  | j d |  j  |  j j	 d |  j  t
 |  |  _ } |  j j d d  g  |  _ } t | d d d	 |  j |  _ } | j |  t | d d
 d	 |  j |  _ } | j |  t | d d d	 |  j |  _ } | j |  t | d d d	 |  j |  _ } | j |  t | d d d	 |  j |  _ } | j |  x. | D]& } | j d d  | j d d  qWt
 |  |  _ } |  j j d d  |  j s$t |  |  j _ |  j j d  n  t | d d d	 |  j  d |  j |  _! |  j! j" d d d d  |  j# st |  |  j _# n  t | d d d	 |  j$ d |  j# |  _% |  j% j" d d d d  |  j& st |  |  j _& |  j& j d  n  t | d d d	 |  j' d |  j& |  _( |  j( j" d d d d  |  j) sNt |  |  j _) n  t | d d d	 |  j* d |  j) |  _+ |  j+ j" d d d d  t, | d d |  _- |  j- j d d  t, | d d |  _. |  j. j d d d d  |  j. j/ d  |  _0 t
 | d d |  _1 |  j1 j d d d d   t
 |  |  _2 |  j2 j d d d d   t
 | d d |  _3 |  j3 j d d d d   |  j j4   r|  j    n  |  j& j4   r|  j'   n  |  j) j4   r|  j*   n  d  S)!NzDebug ControlZDebugZWM_DELETE_WINDOWz<Escape>anchorwtextZGocommandZStepZOverZOutZQuitstatedisabledsideleftr,   ZStackZvariablerowr   columnZSourceLocalsGlobalsfillx
backgroundheightexpandboth)5r(   flistrootr   r/   Zwm_titleZwm_iconnameZwm_protocolr1   ZbindFramebframepackbuttonsZButtoncontZbcontappendstepZbstepnextZbnextretZbretquit	configurecframevstackZ
BooleanVar	__class__setZCheckbutton
show_stackZbstackgridvsourceshow_sourceZbsourcevlocalsshow_localsZblocalsvglobalsshow_globalsZbglobalsLabelstatuserrorZcgeterrorbgfstackflocalsfglobalsget)r   r(   rG   r/   rI   ZblbrS   r   r   r   r*   S   s    	"""""								zDebugger.make_guic             C   s  | |  _  |  j j d |  | r | \ } } } y | j } Wn" t k
 rb d t |  } Yn X| d  k	 r y d | t |  f } Wq Yq Xn  d } n d } d  } |  j } |  j j d | d |  |  j }	 |	 r|  j	 j
 |  j  |  \ }
 } |	 j |
 |  n  |  j d  |  j j   r7|  j   n  x! |  j D] } | j d d	  qAW|  j j   |  j j   x! |  j D] } | j d d
  qW|  j j d d  |  j j d d d |  j  d  |  _  d  S)Nr6   z%sz%s: %sZyellow rB   r,   r8   Znormalr9   )r   r`   rR   r$   AttributeErrorstrrb   ra   r0   r)   	get_stack
load_stackshow_variablesrY   rf   sync_source_linerK   r/   wakeuprG   Zmainloop)r   r   r   r   typevaluetbZm1Zbgsvstackirg   r   r   r   r      sD    				zDebugger.interactionc             C   sx   |  j  } | s d  S|  j |  \ } } | d  d  | d d   d k rt t j j |  rt |  j j | |  n  d  S)Nr,   z<>)r   _Debugger__frame2fileliner   r   existsrF   Zgotofileline)r   r   r"   r#   r   r   r   rn      s    	6zDebugger.sync_source_linec             C   s%   | j  } | j } | j } | | f S)N)r   r   r   )r   r   r!   r"   r#   r   r   r   Z__frame2fileline   s    			zDebugger.__frame2filelinec             C   s   |  j  j   |  j j   d  S)N)r)   Zset_continuerG   rQ   )r   r   r   r   rL      s    zDebugger.contc             C   s   |  j  j   |  j j   d  S)N)r)   r   rG   rQ   )r   r   r   r   rN      s    zDebugger.stepc             C   s$   |  j  j |  j  |  j j   d  S)N)r)   Zset_nextr   rG   rQ   )r   r   r   r   rO      s    zDebugger.nextc             C   s$   |  j  j |  j  |  j j   d  S)N)r)   Z
set_returnr   rG   rQ   )r   r   r   r   rP      s    zDebugger.retc             C   s   |  j  j   |  j j   d  S)N)r)   Zset_quitrG   rQ   )r   r   r   r   rQ      s    zDebugger.quitc             C   s   |  j  ru |  j j   ru t |  j |  j |   |  _  } |  j r |  j j |  j d   \ } } | j	 | |  q nB |  j  } | r |  j j   r d  |  _  | j
   n  d |  j d <d  S)Nr,   rC   )r0   rT   rf   StackViewerrc   rF   r   r)   rk   rl   r1   )r   rs   rt   ru   r   r   r   rW      s    			zDebugger.show_stackc             C   s    |  j  j   r |  j   n  d  S)N)rY   rf   rn   )r   r   r   r   rZ      s    zDebugger.show_sourcec             C   s   | d |  _  |  j   d  S)Nr   )r   rm   )r   Z	stackitemr   r   r   
show_frame   s    zDebugger.show_framec             C   sp   |  j  } |  j j   r9 | sb t |  j d  |  _  qb n) | rb d  |  _  | j   d |  j d <n  |  j   d  S)Nr>   r,   rC   )localsviewerr[   rf   NamespaceViewerrd   r1   rm   )r   lvr   r   r   r\     s    		
zDebugger.show_localsc             C   sp   |  j  } |  j j   r9 | sb t |  j d  |  _  qb n) | rb d  |  _  | j   d |  j d <n  |  j   d  S)Nr?   r,   rC   )globalsviewerr]   rf   r|   re   r1   rm   )r   gvr   r   r   r^     s    		
zDebugger.show_globalsr   c             C   s   |  j  } |  j } |  j } | s. d  } } n3 | j } | j } | ra | ra | | k ra d  } n  | r | j | | |  j j j  n  | r | j | | |  j j j  n  d  S)N)	r{   r~   r   f_locals	f_globals	load_dictr(   ZinterpZrpcclt)r   forcer}   r   r   ZldictZgdictr   r   r   rm     s    						zDebugger.show_variablesc             C   s   |  j  j | |  d  S)N)r)   Z	set_break)r   r"   r#   r   r   r   set_breakpoint_here.  s    zDebugger.set_breakpoint_herec             C   s   |  j  j | |  d  S)N)r)   Zclear_break)r   r"   r#   r   r   r   clear_breakpoint_here1  s    zDebugger.clear_breakpoint_herec             C   s   |  j  j |  d  S)N)r)   Zclear_all_file_breaks)r   r"   r   r   r   clear_file_breaks4  s    zDebugger.clear_file_breaksc             C   sj   xc |  j  j j D]R } | j j } y( x! | j D] } |  j | |  q/ WWq t k
 ra w Yq Xq Wd S)z=Load PyShellEditorWindow breakpoints into subprocess debuggerN)r(   rF   Zinversedictior"   Zbreakpointsr   ri   )r   Zeditwinr"   r#   r   r   r   load_breakpoints7  s    zDebugger.load_breakpoints) r$   r%   r&   rT   rY   r[   r]   r
   r-   r1   r*   r   rn   rw   rL   rN   rO   rP   rQ   r0   rW   rZ   rz   r{   r~   r\   r^   rm   r   r   r   r   r   r   r   r   r'   2   s4   	K,r'   c               @   s   e  Z d  Z d d   Z d d d  Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d d   Z d S)ry   c             C   sT   t  j   r t j |  |  n t j |  | d d | |  _ | |  _ g  |  _ d  S)NwidthP   )r   ZisAquaTkr   r
   rF   r   rt   )r   masterrF   r   r   r   r   r
   C  s    		zStackViewer.__init__Nc             C   s%  | |  _  |  j   x t t |   D] } | | \ } } y | j d } Wn d } Yn X| j } | j } | j }	 d d  l }
 |
 j	 | |  } | j
   } |	 d k r d | | | f } n d | |	 | | f } | | k r d | } n  |  j |  q& W| d  k	 r!|  j |  n  d  S)	Nr$   r   r   rh   z%s, line %d: %sz%s.%s(), line %d: %sz> )r   rh   N)rt   clearrangelenr   r   r   r    	linecachegetlinestriprM   Zselect)r   rt   indexru   r   r#   modnamer!   r"   Zfuncnamer   Z
sourcelineitemr   r   r   rl   O  s.    	
				zStackViewer.load_stackc             C   s   |  j  r t j |  |  Sd S)zoverride base methodN)rt   r   popup_event)r   r3   r   r   r   r   i  s    	zStackViewer.popup_eventc             C   s?   |  j  } | j d d d |  j  | j d d d |  j  d S)zoverride base methodlabelzGo to source liner7   zShow stack frameN)menuZadd_commandgoto_source_lineshow_stack_frame)r   r   r   r   r   	fill_menun  s
    	
zStackViewer.fill_menuc             C   sC   d | k o  t  |  j  k  n r? |  j j |  j |  n  d S)zoverride base methodr   N)r   rt   r   rz   )r   r   r   r   r   	on_selectv  s    %zStackViewer.on_selectc             C   s   |  j  |  d S)zoverride base methodN)rZ   )r   r   r   r   r   	on_double{  s    zStackViewer.on_doublec             C   s#   |  j  j d  } |  j |  d  S)Nactive)listboxr   rZ   )r   r   r   r   r   r     s    zStackViewer.goto_source_linec             C   sU   |  j  j d  } d | k o2 t |  j  k  n rQ |  j j |  j |  n  d  S)Nr   r   )r   r   r   rt   r   rz   )r   r   r   r   r   r     s    %zStackViewer.show_stack_framec             C   s   d | k o  t  |  j  k  n s) d  S|  j | \ } } | j } | j } t j j |  r |  j j |  } | r | j	 |  q n  d  S)Nr   )
r   rt   r   r   r   r   isfilerF   openZgotoline)r   r   r   r#   r!   r"   Zeditr   r   r   rZ     s    %		zStackViewer.show_source)r$   r%   r&   r
   rl   r   r   r   r   r   r   rZ   r   r   r   r   ry   A  s   ry   c               @   sC   e  Z d  Z d d d  Z d
 Z d d d d  Z d d	   Z d S)r|   Nc          	   C   s  d } d } | r% d t  |  } n  | |  _ | |  _ d d  l } | j   |  _ d |  j _ d |  j _ t |  |  _	 } |  j	 j
 d d d d  t | d	 | d
 d d d |  _ |  j j
 d d  t | d d |  _ } | j
 d d d d  t | d t d t d |   d d d | | f |  _ }	 |	 j
 d d d d d d  |	 j | d <| j |	 d <t |	  |  _ }
 |	 j d d d |
 d d |  _ |  j |  d  S)Nr   (      <   rD   r,   r@   rE   r6   borderwidth   ZreliefZgrooverA   namevbarr:   rightyrC   i,  scrollregionr;   r7   ZyscrollcommandZwindowr4   nw)r   r   titlereprlibReprrepr	maxstringmaxotherrH   r   rJ   r_   r   Z	Scrollbarr   ZCanvasminmaxcanvasZyviewrV   subframeZcreate_windowZsfidr   )r   r   r   dictr   rC   r   r   r   r   r   r   r   r   r
     s2    		!	!zNamespaceViewer.__init__r,   r   c             C   s  | |  j  k r | r d  S|  j } |  j } x' t | j j    D] } | j   qB Wd  |  _  | s t | d d } | j d d d d  n | j	   } t
 |  }	 d }
 x |	 D] } | | } |  j j |  } | r | d d  } n  t | d | } | j d |
 d d d d  t | d	 d d
 d } | j d |  | j d |
 d d d d  |
 d }
 q W| |  _  | j   | j   } | j   } |  j } d d | | f |  j d <| d k rd | d <| j d d  n | | d <| j d d  d  S)Nr6   Noner<   r   r=   r,   Zstickyr   r   r   r   i,  rC   rD   rv   )r   r   r   listZchildrenvaluesr2   r_   rX   keyssortedr   ZEntryinsertZupdate_idletasksZwinfo_reqwidthZwinfo_reqheightr   rJ   )r   r   r   Z
rpc_clientr   r   clZ	keys_listnamesr<   r   rq   Zsvaluer   rC   r   r   r   r   r     sF    			
	
	

zNamespaceViewer.load_dictc             C   s   |  j  j   d  S)N)r   r2   )r   r   r   r   r1     s    zNamespaceViewer.closerv   )r$   r%   r&   r
   r   r   r1   r   r   r   r   r|     s   6r|   )r   r   ZtkinterZidlelib.WindowListr   Zidlelib.ScrolledListr   Zidlelibr   r	   r   r'   ry   r|   r   r   r   r   <module>   s   
) S                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/__pycache__/Delegator.cpython-34.pyc                                      0100644 0000000 0000000 00000002076 13077704335 022556  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   Gd  d   d  Z  d S)c               @   sC   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d S)
	DelegatorNc             C   s   | |  _  t   |  _ d  S)N)delegateset_Delegator__cache)selfr    r   '/usr/lib/python3.4/idlelib/Delegator.py__init__   s    	zDelegator.__init__c             C   s6   t  |  j |  } t |  | |  |  j j |  | S)N)getattrr   setattrr   add)r   nameattrr   r   r   __getattr__	   s    zDelegator.__getattr__c             C   sK   x7 |  j  D], } y t |  |  Wq
 t k
 r5 Yq
 Xq
 W|  j  j   d  S)N)r   delattrAttributeErrorclear)r   keyr   r   r   
resetcache   s    	zDelegator.resetcachec             C   s   |  j    | |  _ d  S)N)r   r   )r   r   r   r   r   setdelegate   s    
zDelegator.setdelegate)__name__
__module____qualname__r   r   r   r   r   r   r   r   r      s   r   N)r   r   r   r   r   <module>   s                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/__pycache__/EditorWindow.cpython-34.pyc                                   0100644 0000000 0000000 00000150503 13077704335 023265  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                @   sm  d  d l  Z  d  d l Z  d  d l Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Td  d l	 j
 Z d  d l j Z d  d l Z d  d l Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d l m Z d  d	 l m Z d  d
 l m Z d  d l m Z m Z m Z d  d l m Z d Z  d e j!   Z" d d   Z# Gd d   d e$  Z% e%   Z& d d   Z' Gd d   d e$  Z( d d   Z) d d   Z* d  d l+ Z+ e+ Z, [+ Gd d   d e$  Z- d d   Z. i d d  6d! d" 6d# d$ 6Z/ d% d&   Z0 d' d(   Z1 d) d*   Z2 e3 d+ k rid  d, l4 m5 Z5 e5 e' e2  n  d S)-    N)*)MultiCallCreator)idlever)
WindowList)SearchDialog)
GrepDialog)ReplaceDialog)PyParse)idleConf)aboutDialogtextViewconfigDialog)macosxSupport   z (%s)c              C   s   t  j \ }  } } } } d |  | f } | d | f 7} | d k rY | d | f 7} n' | d k r | d | d | f 7} n  | S)zYFormat sys.version_info to produce the Sphinx version string used to install the chm docsz%s%sz%s	candidatezrc%sfinalr   )sysversion_info)majorminormicrolevelserialrelease r   */usr/lib/python3.4/idlelib/EditorWindow.py_sphinx_version   s    r   c               @   sR   e  Z d  Z d d   Z d d d  Z d d   Z d d	   Z d d
 d  Z d S)
HelpDialogc             C   s   d  |  _  d  |  _ d  S)N)parentdlg)selfr   r   r   __init__-   s    	zHelpDialog.__init__Nc             C   s9   |  j  d k r |  j |  n  | r5 |  j |  n  d S)z Display the help dialog.

            parent - parent widget for the help window

            near - a Toplevel widget (e.g. EditorWindow or PyShell)
                   to use as a reference for placing the help window
        N)r   show_dialog
nearwindow)r    r   nearr   r   r   display1   s    zHelpDialog.displayc             C   sr   | |  _  t j j t j j t j j t   d  } t j | d | d d |  _	 } | j
 d |  j d  d  S)Nzhelp.txtZHelpZmodalFz	<Destroy>+)r   ospathjoinabspathdirname__file__r   Z	view_filer   binddestroy)r    r   fnr   r   r   r   r"   >   s    	-"zHelpDialog.show_dialogc             C   s\   |  j  } | j   d | j   d f } | j   | j d |  | j   | j   d  S)N
   z=+%d+%d)r   Zwinfo_rootxZwinfo_rootyZwithdrawZgeometry	deiconifylift)r    r$   r   geomr   r   r   r#   D   s    	 

zHelpDialog.nearwindowc             C   s   d  |  _  d  |  _ d  S)N)r   r   )r    evr   r   r   r.   O   s    	zHelpDialog.destroy)__name__
__module____qualname__r!   r%   r"   r#   r.   r   r   r   r   r   +   s
   r   c             C   s   t  j |   d  S)N)
helpDialogr"   )r   r   r   r   _help_dialogT   s    r9   c               @   s  e  Z d  Z d d l m Z d d l m Z d d l m Z d d l	 m
 Z
 m Z m Z d d l m Z d d l m Z d d l m Z d	 Z d	 d	 d	 d	 d
 d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d	 d d  Z d d d d d d d g Z e j d& k r(d e d <n  d) d*   Z d+ d,   Z d	 Z  d- d.   Z! d g Z" d1 d2   Z# d3 d4   Z$ d5 d6   Z% d7 d8   Z& d	 d9 d:  Z' d	 d; d<  Z( d	 d= d>  Z) d	 d? d@  Z* dA dB   Z+ dC dD   Z, dE dF   Z- d	 dG dH  Z. d	 dI dJ  Z/ dK dL   Z0 dM dN   Z1 dO dP   Z2 dQ dR   Z3 dS dT   Z4 dU dV   Z5 dW dX   Z6 dY dZ   Z7 d[ d\   Z8 d	 d] d^  Z9 d	 d_ d`  Z: d	 da db  Z; d	 dc dd  Z< de df   Z= dg dh   Z> di dj   Z? dk dl   Z@ dm dn   ZA do dp   ZB dq dr   ZC ds dt   ZD eE jF eE jG du ZH dv dw   ZI dx dy   ZJ dz d{   ZK d| d}   ZL d~ d   ZM d d   ZN d d   ZO d	 d d  ZP d d   ZQ d d   ZR d d   ZS d d   ZT d d   ZU d d   ZV d d   ZW d d   ZX d d d  ZY d d   ZZ d d d  Z[ d d   Z\ d d   Z] d d   Z^ d d   Z_ d d   Z` d d   Za d d   Zb d d   Zc d d   Zd d d   Ze d	 d d  Zf d	 d	 d d  Zg d d   Zh d	 d d  Zi d	 d d  Zj d d   Zk d d   Zl d d   Zm d d   Zn d d d  Zo d d   Zp d d   Zq d d   Zr d d   Zs d d   Zt d d   Zu d d   Zv d d   Zw d d   Zx d d   Zy d d   Zz d d   Z{ d d   Z| d d   Z} d d   Z~ d d   Z d d   Z d d   Z d	 S)EditorWindowr   )
Percolator)ColorDelegator)UndoDelegator)	IOBindingfilesystemencodingencoding)Bindings)Toplevel)MultiStatusBarNc             C   s
  t  j d  k rt j j t j d d  } t j j d  r d d t j	 d  d  } t j j
 d  rr d } qd	 } t j j | | d d  } n t j d  d  d
 k r t j j t j d d t    } t j j |  r| } qn* t j d k rt j j t j d  } n  t j j |  } t j j |  rk| t  _ t j d k rd t  j t  _ qqd t j	 d  d  t  _ n  t j   }	 | |  _ | p| j } | |  _ y t j Wn t k
 rd t _ Yn Xt |  |  _ t j | d |  j |  _ }
 | r0| j |  _ | j |  j _ n i  |  _ i  |  j _ t j j t j   d  |  _ t |
  |  _  } t! | d d |  _" } t j# d d d d d |  _$ i d d 6d d 6d d 6|  j$ d 6t j# d d d  d d d  6} t% d! k rd" | d# <n  t& t'  | |  |  _( } |  j( |  j _) |  j*   |  j+   |  j j, d$ |  j-  |  j j. d% |  j/  t0 j1   r| j. d% |  j/  | j. d& |  j2  n | j. d' |  j2  | j. d( |  j3  | j. d) |  j4  | j. d* |  j5  | j. d+ |  j6  | j. d, |  j7  | j. d- |  j8  | j. d. |  j9  | j. d/ |  j:  | j. d0 |  j;  | j. d1 d2 d3    | j. d4 |  j<  | j. d5 |  j=  | j. d6 |  j>  | j. d7 |  j?  | j. d8 |  j@  | j. d9 |  jA  | j. d: |  jB  | j. d; |  jC  | j. d< |  jD  | j. d= |  jE  | j. d> |  jF  | j. d? |  jG  | j. d@ |  jH  | j. dA |  jI  | j. dB |  jJ  | j. dC |  jK  | j. dD |  jL  | j. dE |  jM  | j. dF |  jN  | j. dG |  jO dH   | j. dI |  jO dJ   | j. dK |  jP  | j. dL |  jQ  | j. dM |  jR  | r| | j |  <| rx|  | jS | <n  | j. dN |  jT  | j. dO |  j jU  | j. dP |  jV  | j. dQ |  jW  | j. dR |  jX  n  |  jY   | jZ | dS <| j[ dT t\ dU t]  | j^ | dV <dW } t j# d d dX d dY rAdZ } n  | j_ d[ t j# d d d[  t j# d d d\ d d | f  | j[ dT t` dU ta d] dJ  | j[ dT tb dU ta d] dJ  | jc   t j# d d^ d_ d dY } | |  _d d` |  _e |  je |  _f |  jg   da |  _h dh |  _i |  jj |  |  _k } |  jl   |  _m } | jn |  | jo | _o | jp | _p | jq |  jr  |  js |   |  _t } | ju |  jv  da |  _w |  jx da  d  |  _y | r7	t j jz |  r	t j j
 |  r	| j{ |  r4	de |  _w |  j| |  } |  jx |  q4	q7	| j} |  de |  _w n  |  j~   |  jr   |  j   |  j   |  j j df  } | r	| j dg  } | d  k r	di } n  | dH k r	| j   | dJ } n  | |  _ t j |  j  n  t j |  _ t j |  _ t j |  _ |  j   d  S)jNZDocz
index.htmlZlinuxzpython-docs-z%s.%s.%s   z/var/www/html/python/z/var/www/html/python/index.htmlz/usr/share/doc/winzPython%s.chmdarwinz0Resources/English.lproj/Documentation/index.htmlzfile://zhttps://docs.python.org/%d.%d/   z>>> menuzrecent-files.lstnamevbarmainr:   widthtypeinttext   ZpadxZnoneZwrapheightg      !@ZwordprocessorZtabstyleZWM_DELETE_WINDOWz<<close-window>>z<Control-Button-1>z<3>z<<cut>>z<<copy>>z	<<paste>>z<<center-insert>>z<<help>>z<<python-docs>>z<<about-idle>>z<<open-config-dialog>>z<<open-module>>z<<do-nothing>>c             S   s   d S)Nbreakr   )eventr   r   r   <lambda>   s    z'EditorWindow.__init__.<locals>.<lambda>z<<select-all>>z<<remove-selection>>z<<find>>z<<find-again>>z<<find-in-files>>z<<find-selection>>z<<replace>>z<<goto-line>>z<<smart-backspace>>z<<newline-and-indent>>z<<smart-indent>>z<<indent-region>>z<<dedent-region>>z<<comment-region>>z<<uncomment-region>>z<<tabify-region>>z<<untabify-region>>z<<toggle-tabs>>z<<change-indentwidth>>z<Left>r   z<Right>   z<<del-word-left>>z<<del-word-right>>z<<beginning-of-line>>z<<open-new-window>>z<<close-all-windows>>z<<open-class-browser>>z<<open-path-browser>>z<<open-turtle-demo>>commandsidefillZyscrollcommandnormalz	font-boldboolboldfontz	font-sizeexpandIndentz
use-spacesr   F2     @KL Twindowsend)r_   r`   ra   )r:   help_urlr'   r(   r)   r   base_prefixplatformcountr   isdirr   isfilenormpathr
   CurrentThemeflistrootps1AttributeErrorMenumenubarr   ZListedTopleveltopvarstkinter_varsZinversedictinstance_dictZGetUserCfgDirrecent_files_pathZFrame
text_frameZ	ScrollbarrJ   	GetOptionrL   Z	TkVersionr   ZTextrO   Zfocused_widgetcreatemenubarapply_bindingsZprotocolcloser-   close_eventr   ZisAquaTkright_menu_eventcutcopypastecenter_insert_eventhelp_dialogpython_docsabout_dialogconfig_dialogopen_module
select_allremove_selection
find_eventfind_again_eventfind_in_files_eventfind_selection_eventreplace_eventgoto_line_eventsmart_backspace_eventnewline_and_indent_eventsmart_indent_eventindent_region_eventdedent_region_eventcomment_region_eventuncomment_region_eventtabify_region_eventuntabify_region_eventtoggle_tabs_eventchange_indentwidth_eventmove_at_edge_if_selectiondel_word_leftdel_word_righthome_callbackdictnew_callbackZclose_all_callbackopen_class_browseropen_path_browseropen_turtle_demoset_status_baryviewpackRIGHTYsetconfigZLEFTZBOTHZTOP	focus_setusetabstabwidthindentwidthset_notabs_indentwidthcontext_use_ps1num_context_linesr;   perr=   undoinsertfilterundo_block_startundo_block_stopZset_saved_change_hooksaved_change_hookr>   ioZset_filename_change_hookfilename_change_hookZ	good_loadset_indentation_paramscolorexistsloadfileispythonsourceZset_filenameResetColorizerupdate_recent_files_listload_extensionsmenudictgetindexadd_separator	wmenu_endZregister_callbackpostwindowsmenutkMessageBoxaskyesnotkSimpleDialog
askinteger	showerror_highlight_workaround)r    rm   filenamekeyrn   ZdochomeZpyverZbasepathZchmfileZcurrentThemers   rx   rJ   Ztext_optionsrO   
fontWeightZ	usespacesr   r   r   	is_py_srcrH   rc   r   r   r   r!   c   sJ   					



	


	
				%	



	
	zEditorWindow.__init__c                s   t  j j d  s d  S|  j   j d d   j d d   f d d      j d   f d d	     j d   f d
 d	    d  S)NrE   z<<Highlight-FocusOut>>z
<FocusOut>z<<Highlight-FocusIn>>z	<FocusIn>c                s     j  d  } | r |  d k ri t j t j   d  }   j d |    j d    j d |  q |  d k r   j d d d  q n  d  S)NselouthiliteZsel_fixinz1.0rc   )
tag_rangesr
   GetHighlightrl   Z
tag_configZ	tag_raisetag_add
tag_remove)ZfocusZ	sel_rangeZHILITE_CONFIG)rO   r   r   highlight_fixN  s    z9EditorWindow._highlight_workaround.<locals>.highlight_fixc                s
     d  S)Nr   r   )r4   )r   r   r   rT   [  s    z4EditorWindow._highlight_workaround.<locals>.<lambda>c                s
     d  S)Nr   r   )r4   )r   r   r   rT   ]  s    )r   rg   
startswithrO   	event_addr-   )r    r   )r   rO   r   r   D  s    			z"EditorWindow._highlight_workaroundc             C   s}   t  | t  s | r | Sy | j |  j  SWnH t k
 rx y | j |  j  SWn t k
 rs | j d  SYn XYn Xd S)z8convert filename to unicode in order to display it in Tkz	iso8859-1N)
isinstancestrdecoder?   UnicodeDecodeErrorr@   )r    r   r   r   r   _filename_to_unicode`  s    z!EditorWindow._filename_to_unicodec             C   s)   |  j  j   \ } } |  j j |  d S)NrR   )r   Zdefaultfilenamerm   new)r    rS   r+   basenamer   r   r   r   o  s    zEditorWindow.new_callbackc             C   s|  | j  d @d k r& | j d k r& d  S|  j j d  r |  j j d d d  r |  j j d d d  r t |  j j d  j d  d	  } nR |  j j d d  } x: t t	 |   D] } | | d k r Pq q Wt	 |  } t |  j j d  j d  d	  } | | k rd } n  d t
 |  d } | j  d	 @d k r\|  j j d d d  n |  j j d  s|  j j d d  nY |  j j |  j j d  d |  j j d   r|  j j d d  n |  j j d d  |  j j |  } |  j j d  } |  j j | d |  r)| | } } n  |  j j d d d  |  j j d | |  |  j j d |  |  j j d  d S)N   r   ZHomeZiomarkz<=zinsert lineendzinsert linestart.rU    	insertzinsert linestart+cr   z1.0rc   z	sel.firstZ	my_anchor<zsel.last>rR   )r   r   )stateZkeysymrO   r   comparerN   splitr   rangelenr   r   mark_setr   see)r    rS   ZinsertptlineZlineatdestfirstlastr   r   r   r   t  s@    "(%	zEditorWindow.home_callbackc             C   s   |  j  |  j  |  _ t j d k r@ |  j j d d d t n  |  j j d d d t |  j j d d d t |  j j d t d	 t	  |  j
 j d
 |  j  |  j
 j d
 d d  |  j
 j |  j  d  S)NrF   Z	_padding1z    rW   columnzCol: ?r   zLn: ?rX   z<<set-line-and-column>>z<KeyRelease>z<ButtonRelease>)rC   rs   
status_barr   rg   	set_labelr   r   ZBOTTOMXrO   r-   set_line_and_columnr   Z
after_idle)r    r   r   r   r     s    
zEditorWindow.set_status_barc             C   sS   |  j  j t  j d  \ } } |  j j d d |  |  j j d d |  d  S)Nr   r   zCol: %sr   zLn: %s)rO   r   ZINSERTr   r   r   )r    rS   r   r   r   r   r   r     s    !z EditorWindow.set_line_and_columnfile_Fileedit_EditformatF_ormatrun_Runoptions_Optionsrb   _Windowshelp_HelprF   _WindowrG   c             C   s#  |  j  } i  |  _ } x_ |  j D]T \ } } t |  \ } } t | d | | | <} | j d | d | d |  q  Wt j   r t | d d | d <} | j d d d |  n  |  j   t |  j   |  _	 |  j d j
 d	 d d
 d d d |  j	 |  j d j t  |  _ |  j   d  S)NrI   labelrH   	underlineZappleZapplicationZIDLEr   rD   zRecent Filesr   r  )rr   r   
menu_specsprepstrrq   Zadd_cascader   Z
isCarbonTk
fill_menusrecent_files_menuZinsert_cascader   ENDbase_helpmenu_lengthreset_help_menu_entries)r    Zmbarr   rI   r
  r  rH   r   r   r   rz     s     	 

zEditorWindow.createmenubarc             C   sk   |  j  d } | j d  } | d  k r1 d } n  | |  j k rZ | j |  j d |  n  t j |  d  S)Nrb   rc   rU   rd   )r   r   r   deleter   Zadd_windows_to_menu)r    rH   rc   r   r   r   r     s    	zEditorWindow.postwindowsmenuc       	      C   s,  |  j  j d d | j | j f  |  j s9 |  j   n  |  j } | |  _ t j d  d  d k } | r |  j  j	 d d  n  xs |  j
 D]h } y | \ } } } Wn t k
 r w Yn X| d  k r q n  t |  |    } | j | d | q W| j | j | j  | r(|  j  j	 d d  n  d  S)	Nr   z@%d,%drD   rE   cursorZarrowr   Zibeam)rO   r   xyrmenu
make_rmenurS   r   rg   r   rmenu_specs
ValueErrorgetattrZentryconfigureZtk_popupZx_rootZy_root)	r    rS   r  Ziswinitemr
  	eventnameZverify_stater   r   r   r   r~     s(    #			zEditorWindow.right_menu_eventClose<<close-window>>c             C   s   t  |  j d d } xj |  j D]_ } | d | d } } | d  k	 rt |  j | d d  } | j d | d |  q | j   q W| |  _ d  S)NZtearoffr   rU   c             S   s   |  j  |  d  S)N)event_generate)rO   r  r   r   r   rV     s    z(EditorWindow.make_rmenu.<locals>.commandr
  rV   )rq   rO   r  add_commandr   r  )r    r  r  r
  r  rV   r   r   r   r    s    zEditorWindow.make_rmenuc             C   s
   |  j    S)N)rmenu_check_copy)r    r   r   r   rmenu_check_cut
  s    zEditorWindow.rmenu_check_cutc             C   sA   y |  j  j d  } Wn t k
 r. d SYn X| r9 d Sd Sd  S)Nz	sel.firstdisabledrY   )rO   r   TclError)r    Zindxr   r   r   r"    s
    	zEditorWindow.rmenu_check_copyc             C   sA   y  |  j  j j d |  j  d  Wn t k
 r8 d SYn Xd Sd  S)Nztk::GetSelectionZ	CLIPBOARDr$  rY   )rO   tkcallr%  )r    r   r   r   rmenu_check_paste  s
     	zEditorWindow.rmenu_check_pastec             C   s   t  j |  j d  d  S)Nz
About IDLE)r   ZAboutDialogrs   )r    rS   r   r   r   r     s    zEditorWindow.about_dialogc             C   s   t  j |  j d  d  S)NZSettings)r   ZConfigDialogrs   )r    rS   r   r   r   r      s    zEditorWindow.config_dialogc             C   s8   |  j  r |  j  } n	 |  j } t j | d |  j d  S)Nr$   )rn   rs   r8   r%   )r    rS   r   r   r   r   r   #  s    		zEditorWindow.help_dialogc             C   s   t  j d  d  d k r} y t j |  j  Wq t k
 ry } z* t j d d d t |  d |  j	  WYd  d  } ~ Xq Xn t
 j |  j  d S)NrD   rE   titlezDocument Start Failuremessager   rR   )r   rg   r'   	startfilere   OSErrorr   r   r   rO   
webbrowseropen)r    rS   whyr   r   r   r   *  s    ,zEditorWindow.python_docsc             C   s   |  j  j d  d S)Nz<<Cut>>rR   )rO   r   )r    rS   r   r   r   r   5  s    zEditorWindow.cutc             C   s*   |  j  j d  s d  S|  j  j d  d S)Nr   z<<Copy>>rR   )rO   r   r   )r    rS   r   r   r   r   9  s    zEditorWindow.copyc             C   s$   |  j  j d  |  j  j d  d S)Nz	<<Paste>>r   rR   )rO   r   r   )r    rS   r   r   r   r   @  s    zEditorWindow.pastec             C   s=   |  j  j d d d  |  j  j d d  |  j  j d  d S)Nr   z1.0zend-1cr   rR   )rO   r   r   r   )r    rS   r   r   r   r   E  s    zEditorWindow.select_allc             C   s*   |  j  j d d d  |  j  j d  d  S)Nr   z1.0rc   r   )rO   r   r   )r    rS   r   r   r   r   K  s    zEditorWindow.remove_selectionc                s=   |  j  j  |  j  j  d       f d d   } | S)zCursor move begins at start or end of selection

        When a left/right cursor key is pressed create and return to Tkinter a
        function which causes a cursor move from the associated edge of the
        selection.

        sel.first+1csel.last-1cc                sN   |  j  d @d k rJ y  d   d     WqJ t k
 rF YqJ Xn  d  S)NrP   r   z	sel.firstr   )r   r%  )rS   )
edge_indexedges_tableself_text_indexself_text_mark_setr   r   move_at_edgeZ  s    
z<EditorWindow.move_at_edge_if_selection.<locals>.move_at_edge)r0  r1  )rO   r   r   )r    r2  r6  r   )r2  r3  r4  r5  r   r   O  s
    z&EditorWindow.move_at_edge_if_selectionc             C   s   |  j  j d  d S)Nz<Meta-Delete>rR   )rO   r   )r    rS   r   r   r   r   c  s    zEditorWindow.del_word_leftc             C   s   |  j  j d  d S)Nz<Meta-d>rR   )rO   r   )r    rS   r   r   r   r   g  s    zEditorWindow.del_word_rightc             C   s   t  j |  j  d S)NrR   )r   findrO   )r    rS   r   r   r   r   k  s    zEditorWindow.find_eventc             C   s   t  j |  j  d S)NrR   )r   Z
find_againrO   )r    rS   r   r   r   r   o  s    zEditorWindow.find_again_eventc             C   s   t  j |  j  d S)NrR   )r   Zfind_selectionrO   )r    rS   r   r   r   r   s  s    z!EditorWindow.find_selection_eventc             C   s    t  j |  j |  j |  j  d S)NrR   )r   ZgreprO   r   rm   )r    rS   r   r   r   r   w  s    z EditorWindow.find_in_files_eventc             C   s   t  j |  j  d S)NrR   )r   replacerO   )r    rS   r   r   r   r   {  s    zEditorWindow.replace_eventc             C   sp   |  j  } t j d d d | } | d  k r1 d S| d k rK | j   d S| j d d |  | j d  d  S)NZGotozGo to line number:r   rR   r   r   z%d.0)rO   r   r   bellr   r   )r    rS   rO   linenor   r   r   r     s    		
zEditorWindow.goto_line_eventc          !   C   s  y |  j  j d d  } Wn t k
 r3 d } Yn X| j   } t j d d d |  j  d | } | rv | j   } n  | s d  Sy t j j |  } WnN t	 t
 f k
 r } z( t j d t |  d |  j  d  SWYd  d  } ~ Xn X| d  k rt j d d	 d |  j  d  St | j t j j  sEt j d d
 d |  j  d  Sy | j j |  } Wn/ t k
 rt j d d d |  j  d  SYn X|  j r|  j j |  n |  j j |  d  S)Nz	sel.firstzsel.last ZModulezAEnter the name of a Python module
to search on sys.path and open:r   initialvaluezImport errorzmodule not foundznot a source-based modulez$loader does not support get_filename)rO   r   r%  stripr   Z	askstring	importlibutil	find_specr  ImportErrorr   r   r   r   loaderabcSourceLoaderget_filenamerp   rm   r.  r   r   )r    rS   rI   specmsgZ	file_pathr   r   r   r     sF    	

	
		zEditorWindow.open_modulec             C   s   |  j  j } | s< t j d d d |  j |  j j   d  St j j |  \ } } t j j	 |  \ } } d d l
 m } | j |  j | | g  d  S)NzNo filenamez&This buffer has no associated filenamemasterr   )ClassBrowser)r   r   r   r   rO   r   r'   r(   r   splitextidlelibrI  rm   )r    rS   r   headtailbaseextrI  r   r   r   r     s    
zEditorWindow.open_class_browserc             C   s$   d d l  m } | j |  j  d  S)Nr   )PathBrowser)rK  rP  rm   )r    rS   rP  r   r   r   r     s    zEditorWindow.open_path_browserc             C   s7   d d  l  } t j d d g } | j | d d } d  S)Nr   z-cz,from turtledemo.__main__ import main; main()shellF)
subprocessr   
executablePopen)r    rS   rR  cmdpr   r   r   r     s
    	zEditorWindow.open_turtle_democ             C   sl   | d  k	 rh | d k rh |  j  j d d |  |  j  j d d d  |  j  j d d d  |  j   n  d  S)Nr   r   z%d.0r   z1.0rc   z
insert +1l)rO   r   r   r   center)r    r:  r   r   r   gotoline  s
    zEditorWindow.gotolinec             C   s   | s t  j j |  r d St  j j t  j j |   \ } } t  j j |  d k r] d S|  j j d d  } | j d  o d | k S)	NT.py.pywz1.0z1.0 lineendz#!Zpython)rY  rZ  )	r'   r(   ri   rJ  r   normcaserO   r   r   )r    r   rN  rO  r   r   r   r   r     s    $zEditorWindow.ispythonsourcec             C   s)   |  j  r% |  j  j |   d  |  _  n  d  S)N)rm   Zunregister_maybe_terminate)r    r   r   r   
close_hook  s    	zEditorWindow.close_hookc             C   s   | |  _  d  S)N)r\  )r    r\  r   r   r   set_close_hook  s    zEditorWindow.set_close_hookc             C   sD   |  j  r |  j  j |   n  |  j   |  j j |   |  j   d  S)N)rm   Zfilename_changed_editr   rs   Zupdate_windowlist_registryr   )r    r   r   r   r     s
    	
z!EditorWindow.filename_change_hookc             C   s}   |  j  r d  S|  j |  j j  r4 |  j   |  _  n  |  j  ry |  j j |  j  |  j j |  j   |  j j |  j  n  d  S)N)	r   r   r   r   r<   r   removefilterr   r   )r    r   r   r   _addcolorizer  s    		zEditorWindow._addcolorizerc             C   s:   |  j  s d  S|  j  j   |  j j |  j   d  |  _  d  S)N)r   Zremovecolorsr   r^  )r    r   r   r   _rmcolorizer  s
    	zEditorWindow._rmcolorizerc             C   s   |  j    |  j   t j d d d  } t j | d  } t j | d d d } t j | d  } |  j j d	 | d	 d
 | d
 d | d | d	 d | d
  d S)zUpdate the colour themerK   ZThemerI   rY   r  ZfgBgZfgr   Z
foregroundZ
backgroundZinsertbackgroundZselectforegroundZselectbackgroundN)r`  r_  r
   ry   r   rO   r   )r    ZthemeZnormal_colorsZcursor_colorZselect_colorsr   r   r   r      s    




zEditorWindow.ResetColorizer_c             C   s   | j  d |  | j |  } | rN | |  j k rN | j  d | d |  n  d | j |  k rv | j d |  n | j d | d  | j |  d  S)NZERRORz
 wordstart
r   z+1c)r   r   
IDENTCHARSr   r   )r    rO   poscharr   r   r   colorize_syntax_error  s    z"EditorWindow.colorize_syntax_errorc          	   C   sn   d } t  j d d d d d r* d } n  |  j j d t  j d d d  t  j d d d	 d d
 | f  d S)z.Update the text widgets' font if it is changedrY   rK   r:   z	font-boldrM   rZ   r[   r\   z	font-sizerN   N)r
   ry   rO   r   )r    r   r   r   r   	ResetFont  s    	zEditorWindow.ResetFontc             C   s   t  j   |  j _ } x- | j   D] \ } } |  j j | |  q# Wx\ |  j   D]N } t  j |  } | rS x0 | j   D] \ } } |  j j | |  q{ WqS qS Wd S)z/Remove the keybindings before they are changed.N)	r
   GetCurrentKeySetrA   default_keydefsitemsrO   Zevent_deleteget_standard_extension_namesGetExtensionBindings)r    keydefsrS   keylistextensionNamexkeydefsr   r   r   RemoveKeybindings)  s    zEditorWindow.RemoveKeybindingsc             C   s  t  j   |  j _ } |  j   x9 |  j   D]+ } t  j |  } | r- |  j |  q- q- Wi  } xd |  j j D]V } i  | | d <x? | d D]3 } | r | d | | d t | d  d <q q Wqo Wx	|  j	 D] } |  j	 | } | j
 t  } | d k rq n  | d 7} x t d |  D] }	 | j |	  d k r!| j |	 d  }
 |
 r| j |	 d  } d } | | k r| | | k r| | | } qn  | rt | |  }
 | j |	 d |
 qqq!q!Wq Wd S)z-Update the keybindings after they are changedr   rU   NrV   acceleratorr
  r;  )r
   rh  rA   ri  r{   rk  rl  menudefsr  r   r   r  r   rM   Z	entrycgetget_acceleratorZentryconfig)r    rm  ro  rp  ZmenuEventDictrH   r  ZmenubarItemrc   r   ZaccelZitemNamerS   r   r   r   ApplyKeybindings5  s<    
/
zEditorWindow.ApplyKeybindingsc             C   s.   |  j  s* t j d d d d d |  _ n  d S)zCUpdate the indentwidth if changed and not using tabs in this windowrK   r^   z
num-spacesrM   rN   N)r   r
   ry   r   )r    r   r   r   r   Y  s    	z#EditorWindow.set_notabs_indentwidthc             C   s   t  j   } |  j d } | j t  } | |  j k rQ | j |  j d |  n  | r | j   x> | D]3 } |  j | d  } | j	 d | d d |  qh Wn  | |  j d <d S)z3Update the additional help entries on the Help menur  rU   r
  r   rV   N)
r
   ZGetAllExtraHelpSourcesListr   r   r  r  r  r   "_EditorWindow__extra_help_callbackr!  )r    Z	help_listZhelpmenuZhelpmenu_lengthentryrU  r   r   r   r  `  s    
!z$EditorWindow.reset_help_menu_entriesc                s   |   f d d  } | S)zCCreate a callback with the helpfile value frozen at definition timec                s   |  j  d	  s$ t j j |   }  n  t j d  d  d k r y t j |   Wq t k
 r } z* t j	 d d d t
 |  d   j  WYd  d  } ~ Xq Xn t j |   d  S)
NwwwhttprD   rE   r)  zDocument Start Failurer*  r   )rx  ry  )r   r'   r(   rk   r   rg   r+  r,  r   r   r   rO   r-  r.  )helpfiler/  )r    r   r   display_extra_helps  s    ,z>EditorWindow.__extra_help_callback.<locals>.display_extra_helpr   )r    rz  r{  r   )r    r   Z__extra_help_callbackq  s    z"EditorWindow.__extra_help_callbackc                sq  g  } t  j j |  j  rQ t |  j d d d d d  } | j   } Wd QXn  | r t  j j |  d } | | k r | j |  n  | j d |  n  g    xG | D]? } d	 | k s t  j j | d d   r   j	 |  q q W  f d d   | D } d } | d t
 |   } y8 t |  j d d d d d  } | j |  Wd QXWnr t k
 r} zR t |  j d d  sd |  j _ t j d d d d t |  d |  j  n  WYd d } ~ Xn Xx |  j j D] } | j }	 |	 j d t  xl t |  D]^ \ }
 } | j   } |  j |  } | j |  } |	 j d | |
 d | d | d d  qWqWd S)z/Load and update the recent files list and menusrr@   utf_8errorsr8  Nrb  r    rU   c                s"   g  |  ] } |   k r |  q Sr   r   ).0r(   )	bad_pathsr   r   
<listcomp>  s   	 z9EditorWindow.update_recent_files_list.<locals>.<listcomp>Z1234567890ABCDEFGHIJKwrecentfilelist_error_displayedFTr)  z
IDLE Errorr*  z&Unable to update Recent Files list:
%sr   r
  r   rV   r  rd   )r'   r(   r   rw   r.  	readlinesr*   remover   appendr   
writelinesr,  r  rn   r  r   r   r   rO   rs   rv   r  r  r  	enumeraterstripr   #_EditorWindow__recent_file_callbackr!  )r    new_fileZrf_listZrf_list_filer(   ZulcharsZrf_fileerrinstancerH   i	file_nameZ
ufile_namecallbackr   )r  r   r     sL    ) 	z%EditorWindow.update_recent_files_listc                s   |   f d d  } | S)Nc                s     j  j d |   d  S)NZeditFile)r   r.  )Z
fn_closure)r    r   r   open_recent_file  s    z=EditorWindow.__recent_file_callback.<locals>.open_recent_filer   )r    r  r  r   )r    r   Z__recent_file_callback  s    z#EditorWindow.__recent_file_callbackc             C   s   |  j    } |  j   } | r9 | r9 | d | t } n$ | rH | } n | rW | } n d } | pl | pl | } |  j   s d | } d | } n  |  j j |  |  j j |  d  S)Nz - Untitledz*%s*z*%s)short_title
long_title_py_version	get_savedrs   Zwm_titleZwm_iconname)r    ZshortZlongr)  Ziconr   r   r   r     s    		
zEditorWindow.saved_change_hookc             C   s   |  j  j   S)N)r   r  )r    r   r   r   r    s    zEditorWindow.get_savedc             C   s   |  j  j |  d  S)N)r   	set_saved)r    Zflagr   r   r   r    s    zEditorWindow.set_savedc             C   s   |  j  j   d  S)N)r   
reset_undo)r    r   r   r   r    s    zEditorWindow.reset_undoc             C   s:   |  j  j } | r' t j j |  } n d } |  j |  S)Nr  )r   r   r'   r(   r   r   )r    r   r   r   r   r    s
    zEditorWindow.short_titlec             C   s   |  j  |  j j p d  S)Nr;  )r   r   r   )r    r   r   r   r    s    zEditorWindow.long_titlec             C   s   |  j    d  S)N)rW  )r    rS   r   r   r   r     s    z EditorWindow.center_insert_eventr   c             C   sb   |  j  } |  j   \ } } |  j |  } | | } t d | | d  } | j t |   d  S)NrU   rG   )rO   getwindowlines	getlinenomaxr   float)r    markrO   rs   botr:  rQ   Znewtopr   r   r   rW    s    	
zEditorWindow.centerc             C   sp   |  j  } |  j d  } |  j d  } | | k rf | j   d k rf t | d  } | | d } n  | | f S)Nz@0,0z@0,65535rU   rQ   )rO   r  Zwinfo_heightrN   )r    rO   rs   r  rQ   r   r   r   r    s    	zEditorWindow.getwindowlinesc             C   s"   |  j  } t t | j |    S)N)rO   rN   r  r   )r    r  rO   r   r   r   r    s    	zEditorWindow.getlinenoc             C   s:   |  j  j   } t j d |  } t t t | j     S)zReturn (width, height, x, y)z(\d+)x(\d+)\+(-?\d+)\+(-?\d+))rs   Zwm_geometryrematchlistmaprN   groups)r    r3   mr   r   r   get_geometry  s    zEditorWindow.get_geometryc             C   s   |  j    d  S)N)r|   )r    rS   r   r   r   r}     s    zEditorWindow.close_eventc             C   sh   |  j  rd |  j   sW |  j j   d k r: |  j j   n  |  j j   |  j j   n  |  j  j   Sd  S)NrY   )r   r  rs   r   r1   lowerr2   	maybesave)r    r   r   r   r    s    	zEditorWindow.maybesavec             C   s/   |  j    } t |  d k r+ |  j   n  | S)NZcancel)r  r   _close)r    Zreplyr   r   r   r|     s    zEditorWindow.closec             C   s   |  j  j r% |  j d |  j  j  n  t j |  j  |  j   |  j  j   d  |  _  d  |  _ |  j	 r |  j	 j d  d  |  _	 n  d  |  _
 d  |  _ |  j j   d  |  _ |  j j   |  j r |  j   n  d  S)Nr  F)r   r   r   r   Zunregister_callbackr   unload_extensionsr|   r   r   rO   ru   r   rs   r.   r\  )r    r   r   r   r  
  s"    
							zEditorWindow._closec             C   s   i  |  _  |  j   d  S)N)
extensionsload_standard_extensions)r    r   r   r   r     s    	zEditorWindow.load_extensionsc             C   sI   x9 t  |  j j    D]" } t | d  r | j   q q Wi  |  _ d  S)Nr|   )r  r  valueshasattrr|   )r    insr   r   r   r  "  s    zEditorWindow.unload_extensionsc             C   sT   xM |  j    D]? } y |  j |  Wq t d t |   t j   Yq Xq Wd  S)NzFailed to load extension)rk  load_extensionprintrepr	traceback	print_exc)r    rI   r   r   r   r  (  s    z%EditorWindow.load_standard_extensionsc             C   s   t  j d d  S)NZeditor_onlyT)r
   ZGetExtensions)r    r   r   r   rk  0  s    z)EditorWindow.get_standard_extension_namesc             C   s  yK y t  j d | d t } Wn' t t f k
 rI t  j |  } Yn XWn" t k
 ro t d |    Yn Xt | |  } t j |  } t	 | d  r |  j
 | j |  n  | |   } | |  j | <| r|  j |  x | D] } | j d d  } x* | d  d  d k r*| d d   } qWx* | d d   d	 k rW| d  d  } q.W| d
 } t	 | |  r |  j j | t | |   q q Wn  d  S)Nr   packagez
Failed to import extension: rs  -ra  rU   r   r   Z_eventrd   rd   )r>  import_module__package__rA  	TypeErrorr  r  r
   rl  r  r  rs  r  r{   r8  rO   r-   )r    rI   modclsrm  r  ZveventZ
methodnamer   r   r   r  3  s2    
zEditorWindow.load_extensionc             C   sg   | d  k r |  j  j } n  |  j } | | _ x3 | j   D]% \ } } | r: | j | |  q: q: Wd  S)N)rA   ri  rO   rm  rj  r   )r    rm  rO   rS   rn  r   r   r   r{   N  s    		zEditorWindow.apply_bindingsc             C   su  | d k r |  j  j } n  | d k r6 |  j  j } n  |  j } |  j } x&| D]\ } } | j |  } | sv qO n  x | D] } | s | j   q} | \ }	 }
 |	 d d  d k } | r |	 d d  }	 n  t |	  \ } }	 t | |
  } | |
 d d  } | rG|  j	 |
 t
  } | j d |	 d | d | d	 | d
 |  q} | j d |	 d | d | d	 |  q} WqO Wd S)zAdd appropriate entries to the menus and submenus

        Menus that are absent or None in self.menudict are ignored.
        NrU   !c             S   s   |  j  |  d  S)N)r   )rO   r  r   r   r   rV   p  s    z(EditorWindow.fill_menus.<locals>.commandr
  r  rV   rr  Zvariable)rA   rs  ri  r   rO   r   r   r  rt  get_var_objZ
BooleanVarZadd_checkbuttonr!  )r    rs  rm  r   rO   ZmnameZ	entrylistrH   rw  r
  r  Zcheckbuttonr  rr  rV   varr   r   r   r  W  s8    		
zEditorWindow.fill_menusc             C   s5   |  j  |  } | r% | j   } | St |   d  S)N)r  r   	NameError)r    rI   r  valuer   r   r   getvar|  s
    zEditorWindow.getvarc             C   s8   |  j  | |  } | r( | j |  n t |   d  S)N)r  r   r  )r    rI   r  vartyper  r   r   r   setvar  s    zEditorWindow.setvarc             C   s@   |  j  j |  } | r< | r< | |  j  |  j  | <} n  | S)N)ru   r   rO   )r    rI   r  r  r   r   r   r    s    zEditorWindow.get_var_objc             C   s<   |  j  r4 |  j j d |  p3 d |  j j |  k Sd Sd  S)NZTODOSTRINGrU   )r   rO   tag_prevrangeZ	tag_names)r    Z
text_indexr   r   r   is_char_in_string  s    	zEditorWindow.is_char_in_stringc             C   sO   y2 |  j  j d  } |  j  j d  } | | f SWn t k
 rJ d SYn Xd  S)Nz	sel.firstzsel.last)NN)rO   r   r%  )r    r   r   r   r   r   get_selection_indices  s    z"EditorWindow.get_selection_indicesc             C   s   |  j  d p t } t |  S)Ntabs)rO   TK_TABWIDTH_DEFAULTrN   )r    Zcurrentr   r   r   get_tk_tabwidth  s    zEditorWindow.get_tk_tabwidthc             C   s^   |  j  } |  j   | k rZ | j j d d | d d | j d |  } | j d |  n  d  S)Nr\   Zmeasurez
-displayofnr  )rO   r  r&  r'  rH  Z	configure)r    ZnewtabwidthrO   Zpixelsr   r   r   set_tk_tabwidth  s    		zEditorWindow.set_tk_tabwidthTc             C   su   | ra | ra |  j    } d | k o/ d k n r@ | |  _ n  |  j |  j k ra d |  _ qa n  |  j |  j  d  S)NrG   r   F)guess_indentr   r   r   r  )r    r   Zguessr  r   r   r   r     s    z#EditorWindow.set_indentation_paramsc             C   s  |  j  } |  j   \ } } | rK | rK | j | |  | j d |  d S| j d d  } | d k r | j d d d  r | j d  n
 | j   d S| d d	 k r | j d  d S|  j } t | j	 |   } | d
 k s t
  | d |  j |  j } |  j r't j j d  d }	 n d }	 d
 }
 xb | |	 k rFPn  | d  d  } |
 d }
 t | j	 |   } | | k s| d d	 k r6Pq6q6| j   | j d |
 d  | | k  r| j d d | |  n  | j   d S)Nr   rR   zinsert linestartr;  r   z1.0z	insert-1crU   z 	r   rb  z
insert-%dcr   rd   rd   rd   rd   )rO   r  r  r   r   r   r9  r   r   
expandtabsAssertionErrorr   r   r   ro   r   r   r   r   )r    rS   rO   r   r   charsr   ZhaveZwantlast_line_of_promptZncharsdeletedr   r   r   r     sJ    	
		


z"EditorWindow.smart_backspace_eventc       
   
   C   sH  |  j  } |  j   \ } } | j   z| r| | r| t |  t |  k rY |  j |  S| j | |  | j d |  n  | j d d  } t | |  j	  \ } } | t
 |  k r |  j | |  j  nU |  j r d } n3 t
 | j |  j	   } |  j }	 d |	 | |	 } | j d |  | j d  d SWd  | j   Xd  S)Nr   zinsert linestartr   r   rR   )rO   r  r   
index2liner   r  r   r   
classifywsr   r   reindent_tor   r   r  r   r   r   )
r    rS   rO   r   r   prefixraw	effectiveZpadr  r   r   r   r     s,    	
			zEditorWindow.smart_indent_eventc             C   s  |  j  } |  j   \ } } | j   z| rW | rW | j | |  | j d |  n  | j d d  } d t |  } } x* | | k  r | | d k r | d } q W| | k r | j d d  d S| d  |  } d } t j	 j
 d  d }	 x@ | r7| d d k r7| |	 k r7| d  d  } | d } q W| rU| j d | d  n  x& | j d  d k r}| j d  qXW| j d d  t | j d   }
 t j |  j |  j  } |  j sjx |  j D] } t |
 | d  } t |  d	 } | j | d  } | j |  | j |  j |  j |   } | d  k	 sL| d k rPqqW| j | pcd  nW | j d
 d  } | r| d } n d } | j | d  } | j |  | j d  | j   } | t j k r| t j k rn | t j k r| j d |  n | t j k r5|  j | j     nc | t j! k r| j"   d k ri| j d |  q|  j | j#    n d st$ d | f   d S| j%   } | j d |  | j&   r|  j' |  n" | r| j(   r|  j) |  n  d SWd  | j* d  | j+   Xd  S)Nr   zinsert linestartr   z 	rU   rb  rR   zinsert - %d charsz.0Zconsolez1.0zbogus continuation type %rrd   rd   rd   ),rO   r  r   r  r   r   r   r   r   ro   r   r  r   r	   ZParserr   r   r   r   r  r  Zset_strZfind_good_parse_start_build_char_in_string_funcZset_lor  Zget_continuation_typeZC_NONEZC_STRING_FIRST_LINEZC_STRING_NEXT_LINESZ	C_BRACKETr  Zcompute_bracket_indentZC_BACKSLASHZget_num_lines_in_stmtZcompute_backslash_indentr  Zget_base_indent_stringZis_block_openerr   Zis_block_closerr   r   r   )r    rS   rO   r   r   r   r  r  indentr  Zlnor  contextZstartatZstartatindexZrawtextZbodr|  r   r   r   r   r     s    	
%	z%EditorWindow.newline_and_indent_eventc             C   s   | |  j  d d  } | S)Nc             S   s   | | d |   S)Nz+%dcr   )offsetZ_startindexZ_icisr   r   r   inner  s    z6EditorWindow._build_char_in_string_func.<locals>.inner)r  )r    Z
startindexr  r   r   r   r    s    z'EditorWindow._build_char_in_string_funcc       
      C   s   |  j    \ } } } } xs t t |   D]_ } | | } | r+ t | |  j  \ } }	 |	 |  j }	 |  j |	  | | d   | | <q+ q+ W|  j | | | |  d S)NrR   )
get_regionr   r   r  r   r   _make_blanks
set_region)
r    rS   rL  rM  r  linesrd  r   r  r  r   r   r   r     s    
(z EditorWindow.indent_region_eventc       
      C   s   |  j    \ } } } } x| t t |   D]h } | | } | r+ t | |  j  \ } }	 t |	 |  j d  }	 |  j |	  | | d   | | <q+ q+ W|  j | | | |  d S)Nr   rR   )	r  r   r   r  r   r  r   r  r  )
r    rS   rL  rM  r  r  rd  r   r  r  r   r   r   r     s    
(z EditorWindow.dedent_region_eventc             C   sk   |  j    \ } } } } x6 t t |  d  D] } | | } d | | | <q/ W|  j | | | |  d  S)NrU   z##)r  r   r   r  )r    rS   rL  rM  r  r  rd  r   r   r   r   r     s
    
z!EditorWindow.comment_region_eventc             C   s   |  j    \ } } } } x t t |   D]x } | | } | sG q+ n  | d  d  d k rp | d d   } n) | d  d  d k r | d d   } n  | | | <q+ W|  j | | | |  d  S)NrG   z##rU   #)r  r   r   r  )r    rS   rL  rM  r  r  rd  r   r   r   r   r     s    
z#EditorWindow.uncomment_region_eventc             C   s   |  j    \ } } } } |  j   } | d  k r4 d  Sx{ t t |   D]g } | | } | rG t | |  \ }	 }
 t |
 |  \ } } d | d | | |	 d   | | <qG qG W|  j | | | |  d  S)Nr   r   )r  _asktabwidthr   r   r  divmodr  )r    rS   rL  rM  r  r  r   rd  r   r  r  ntabsnspacesr   r   r   r     s     
+z EditorWindow.tabify_region_eventc             C   s   |  j    \ } } } } |  j   } | d  k r4 d  Sx1 t t |   D] } | | j |  | | <qG W|  j | | | |  d  S)N)r  r  r   r   r  r  )r    rS   rL  rM  r  r  r   rd  r   r   r   r     s     z"EditorWindow.untabify_region_eventc             C   sZ   |  j  d d d |  j d d |  j d d	 d
 |  j rV |  j |  _ d |  _ n  d S)NzToggle tabsz
Turn tabs onoffz?
Indent width will be
remains atz 8.z!
 Note: a tab is always 8 columnsr   r   rR   )r  r  )r  r  )r   r   rO   r   )r    rS   r   r   r   r     s    !zEditorWindow.toggle_tabs_eventc             C   s_   |  j  d d d |  j d |  j d d d d } | r[ | |  j k r[ |  j r[ | |  _ n  d	 S)
NzIndent widthz6New indent width (2-16)
(Always use 8 when using tabs)r   r<  minvaluerG   maxvalue   rR   )r   rO   r   r   )r    rS   r   r   r   r   r     s    			z%EditorWindow.change_indentwidth_eventc             C   s   |  j  } |  j   \ } } | rP | rP | j | d  } | j | d  } n | j d  } | j d  } | j | |  } | j d  } | | | | f S)Nz
 linestartz-1c lineend +1czinsert linestartzinsert lineend +1crb  )rO   r  r   r   r   )r    rO   r   r   rL  rM  r  r  r   r   r   r    s    	zEditorWindow.get_regionc             C   s   |  j  } d j |  } | | k r2 | j   d  S| j d d d  | j d |  | j   | j | |  | j | |  | j   | j	 d | d  d  S)Nrb  r   z1.0rc   r   )
rO   r)   r9  r   r   r   r  r   r   r   )r    rL  rM  r  r  rO   newcharsr   r   r   r    s    	


zEditorWindow.set_regionc             C   s=   |  j  r1 t | |  j  \ } } d | d | Sd | Sd  S)Nr   r   )r   r  r   )r    r  r  r  r   r   r   r    s    	zEditorWindow._make_blanksc             C   sk   |  j  } | j   | j d d d  r; | j d d  n  | r] | j d |  j |   n  | j   d  S)Nzinsert linestartz!=r   )rO   r   r   r  r   r  r   )r    r   rO   r   r   r   r    s    	
zEditorWindow.reindent_toc             C   s.   |  j  d d d |  j d |  j d d d d S)	Nz	Tab widthzColumns per tab? (2-16)r   r<  r  rG   r  r  )r   rO   r   )r    r   r   r   r     s    		zEditorWindow._asktabwidthc             C   sr   t  |  j |  j  j   \ } } | r` | r` t | |  j  \ } } t | |  j  \ } } n
 d } } | | S)Nr   )IndentSearcherrO   r   r  r  )r    ZopenerZindentedr  ZindentsmallZindentlarger   r   r   r  .  s    !
zEditorWindow.guess_indent)zfiler   )zeditr   )zformatr  )zrunr  )r  r  )windowsr  )zhelpr  )r  r	  )r  r  N)r5   r6   r7   Zidlelib.Percolatorr;   Zidlelib.ColorDelegatorr<   Zidlelib.UndoDelegatorr=   Zidlelib.IOBindingr>   r?   r@   rK  rA   tkinterrB   Zidlelib.MultiStatusBarrC   re   r!   r   r   r   r   r   r   r  r   rg   rz   r   r  r~   r  r  r#  r"  r(  r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   rX  r   r\  r]  r   r_  r`  r   stringZascii_lettersZdigitsrc  rf  rg  rq  ru  r   r  rv  r   r  r   r  r  r  r  r  r   rW  r  r  r  r}   r  r|   r  r   r  r  rk  r  r{   r  r  r  r  r  r  r  r  r   r   r   r   r  r   r   r   r   r   r   r   r   r  r  r  r  r  r  r   r   r   r   r:   X   s   +	
	*	$,	
		%	0#k
	r:   c             C   s   t  t |    S)N)rN   r  )r   r   r   r   r  8  s    r  c             C   st   d } } x] |  D]U } | d k r: | d } | d } q | d k re | d } | | d | } q Pq W| | f S)Nr   r   rU   r   r   )sr   r  r  Zchr   r   r   r  @  s    


r  c               @   sO   e  Z d  Z d d   Z d d   Z e j e j d d d  Z d d   Z	 d S)r  c             C   s6   | |  _  | |  _ d |  _ |  _ d  |  _ |  _ d  S)Nr   )rO   r   r  finishedblkopenlineindentedline)r    rO   r   r   r   r   r!   X  s    		zIndentSearcher.__init__c             C   sd   |  j  r d S|  j d } |  _ t |  d } |  j j | d d  rM d S|  j j | | d  S)Nr;  rU   z.0z>=rc   z lineend+1c)r  r  r  rO   r   r   )r    r  r  r   r   r   readline^  s    	zIndentSearcher.readlineclassdefforiftrywhilec	       	      C   s^   |  j  r nN | | k r0 | | k r0 | |  _ n* | | k rZ |  j rZ | |  _ d |  _  n  d  S)NrU   )r  r  r  )	r    rM   tokenstartrc   r   INDENTNAMEZOPENERSr   r   r   
tokeneaterg  s    		zIndentSearcher.tokeneaterc             C   s   t  j } |  j t  _ zV y4 t  j |  j  } x | D] } |  j |   q4 WWn t  j t f k
 ri Yn XWd  | t  _ X|  j |  j	 f S)N)
	_tokenizetabsizer   generate_tokensr  r  
TokenErrorSyntaxErrorr  r  )r    Zsave_tabsizetokensr  r   r   r   r  s  s    		
zIndentSearcher.runN)zclasszdefzforzifztryzwhile)
r5   r6   r7   r!   r  r  r   r  r  r  r   r   r   r   r  Q  s   
	r  c             C   sJ   |  j  d  } | d k r@ |  d  |  |  | d d   }  n  | |  f S)Nra  r   rU   )r7  )r  r  r   r   r   r    s    %r  [Zbracketleft]Zbracketright/Zslashc             C   s	  |  j  |  } | s. t j   r2 | d k r2 d S| d } t j d d d   |  } t j d	 d
 d   |  } t j d d |  } t j d d |  } t j d d |  } t j d d |  } t j d d |  } t j d d |  } t j d d |  } | S)N<<open-module>><<goto-line>><<change-indentwidth>>r;  r   z-[a-z]\bc             S   s   |  j    j   S)N)groupupper)r  r   r   r   rT     s    z!get_accelerator.<locals>.<lambda>z\b\w+\bc             S   s   t  j |  j   |  j    S)N)keynamesr   r  )r  r   r   r   rT     s    zKey-ZCancelz
Ctrl-BreakzControl-zCtrl-r  r&   z><r   r   r   >   r  r  r  )r   r   Z	isCocoaTkr  sub)rm  r  rn  r  r   r   r   rt    s"      	
rt  c             C   sF   |  j  } | j d d d  | j d d d  | j d d d  d  S)	NZtcl_wordBreakAfterza br   r   Ztcl_wordcharsz[a-zA-Z0-9_]Ztcl_nonwordcharsz[^a-zA-Z0-9_])r&  r'  )rn   r&  r   r   r   fixwordbreaks  s    	r  c             C   s   |  } t  |  t j d d   r3 t j d } n d  } t j | d   t d | d |  } | j j d | j  |  j	   d  S)NrU   rn   r   z<<close-all-windows>>)
r  r   argvr   ZsetupAppr:   rO   r-   r}   Zmainloop)r   rn   r   r   r   r   r   _editor_window  s    
r  __main__)r  )6r>  Zimportlib.abcimportlib.utilr'   rg   r  r  r   r  Ztkinter.simpledialogZsimpledialogr   Ztkinter.messageboxZ
messageboxr   r  r-  Zidlelib.MultiCallr   rK  r   r   r   r   r   r	   Zidlelib.configHandlerr
   r   r   r   r   r  Zpython_versionr  r   objectr   r8   r9   r:   r  r  tokenizer  r  r  r  rt  r  r  r5   Zidlelib.idle_test.htestr  r   r   r   r   <module>   sf   
(	     4	
	                                                                                                                                                                                             usr/lib/python3.4/idlelib/__pycache__/FileList.cpython-34.pyc                                       0100644 0000000 0000000 00000007051 13077704335 022361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s^   d  d l  Z  d  d l Td  d l j Z Gd d   d  Z d d   Z e d k rZ e   n  d S)    N)*c               @   s   e  Z d  Z d d l m Z d d   Z d d d  Z d d d	  Z d d
 d  Z d d   Z	 d d   Z
 d d   Z d d   Z d S)FileListr   )EditorWindowc             C   s(   | |  _  i  |  _ i  |  _ i  |  _ d  S)N)rootdictinversedictvars)selfr    r
   &/usr/lib/python3.4/idlelib/FileList.py__init__   s    			zFileList.__init__Nc             C   s   | s t   |  j |  } t j j |  rQ t j d d | f d |  j d  St j j |  } | |  j	 k r |  j	 | } | j
 j   | S| r | |  S|  j |  | |  } | j r | S| j   d  Sd  S)Nz
File Errorz%r is a directory.master)AssertionErrorcanonizeospathisdirtkMessageBox	showerrorr   normcaser   topwakeupr   Z	good_loadZ_close)r	   filenameactionkeyeditr
   r
   r   open   s(    

	
zFileList.openc             C   s;   |  j  |  } | d  k	 r7 | d  k	 r7 | j |  n  d  S)N)r   Zgotoline)r	   r   linenor   r
   r
   r   gotofileline+   s    zFileList.gotofilelinec             C   s   |  j  |  |  S)N)r   )r	   r   r
   r
   r   new0   s    zFileList.newc             O   s:   x3 t  |  j  D]" } | j   } | d k r Pq q Wd S)NZcancelbreak)listr   close)r	   argskwdsr   Zreplyr
   r
   r   close_all_callback3   s
    zFileList.close_all_callbackc             C   sn   y |  j  | } Wn  t k
 r3 t d  d  SYn X| rG |  j | =n  |  j  | =|  j  sj |  j j   n  d  S)Nz-Don't know this EditorWindow object.  (close))r   KeyErrorprintr   r   Zquit)r	   r   r   r
   r
   r   unregister_maybe_terminate:   s    
	
	z#FileList.unregister_maybe_terminatec             C   s;  | j    y |  j | } Wn  t k
 r= t d  d  SYn X| j j } | st | rc |  j | =n  d  |  j | <d  S|  j |  } t j	 j
 |  } | | k r d  S| |  j k r |  j | } d  |  j | <t j d d | f d |  j n  | |  j | <| |  j | <| r7y |  j | =Wq7t k
 r3Yq7Xn  d  S)Nz.Don't know this EditorWindow object.  (rename)zName Conflictz.You now have multiple edit windows open for %rr   )Zsaved_change_hookr   r&   r'   ior   r   r   r   r   r   r   r   r   )r	   r   r   r   ZnewkeyZconflictr
   r
   r   filename_changed_editF   s<    

	zFileList.filename_changed_editc             C   s_   t  j j |  sO y t  j   } Wn t k
 r6 YqO Xt  j j | |  } n  t  j j |  S)N)r   r   isabsgetcwdOSErrorjoinnormpath)r	   r   pwdr
   r
   r   r   f   s    zFileList.canonize)__name__
__module____qualname__idlelib.EditorWindowr   r   r   r   r   r%   r(   r*   r   r
   r
   r
   r   r      s    r   c              C   s   d d l  m }  d d  l } t   } |  |  | j   t |  } | j d d   r x5 | j d d   D] } | j |  ql Wn
 | j   | j	 r | j
   n  d  S)Nr   )fixwordbreaks   )r4   r5   sysZTkZwithdrawr   argvr   r   r   Zmainloop)r5   r7   r   Zflistr   r
   r
   r   _testq   s    	


	r9   __main__)r   ZtkinterZtkinter.messageboxZ
messageboxr   r   r9   r1   r
   r
   r
   r   <module>   s   
k                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/__pycache__/FormatParagraph.cpython-34.pyc                                0100644 0000000 0000000 00000014271 13077704335 023726  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  Z  d d l Z d d l m Z Gd d   d  Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 e d k r d d l Z e j d d d d d n  d S)a  Extension to format a paragraph or selection to a max width.

Does basic, standard text formatting, and also understands Python
comment blocks. Thus, for editing Python source code, this
extension is really only suitable for reformatting these comment
blocks or triple-quoted strings.

Known problems with comment reformatting:
* If there is a selection marked, and the first line of the
  selection is not complete, the block will probably not be detected
  as comments, and will have the normal "text formatting" rules
  applied.
* If a comment block has leading whitespace that mixes tabs and
  spaces, they will not be considered part of the same block.
* Fancy comments, like this bulleted list, aren't handled :-)
    N)idleConfc               @   sI   e  Z d  Z d d g f g Z d d   Z d d   Z d d	 d
  Z d S)FormatParagraphformatFormat Paragraph<<format-paragraph>>c             C   s   | |  _  d  S)N)editwin)selfr    r	   -/usr/lib/python3.4/idlelib/FormatParagraph.py__init__   s    zFormatParagraph.__init__c             C   s   d  |  _  d  S)N)r   )r   r	   r	   r
   close    s    zFormatParagraph.closeNc       	      C   sM  | d k r* t  j d d d d d } n  |  j j } |  j j   \ } } | rx | rx | j | |  } t |  } n$ t | | j d   \ } } } } | r t	 | | |  } n t
 | |  } | j d d	 d
  | | k r,| j d |  | j   | j | |  | j | |  | j   n | j d |  | j d  d S)a  Formats paragraph to a max width specified in idleConf.

        If text is selected, format_paragraph_event will start breaking lines
        at the max width, starting from the beginning selection.

        If no text is selected, format_paragraph_event uses the current
        cursor location to determine the paragraph (lines of text surrounded
        by blank lines) and formats it.

        The length limit parameter is for testing with a known value.
        Nmainr   Z	paragraphtypeintinsertZselz1.0endbreak)r   Z	GetOptionr   textZget_selection_indicesgetget_comment_headerfind_paragraphindexreformat_commentreformat_paragraphZ
tag_removeZmark_setZundo_block_startZdeleter   Zundo_block_stopZsee)	r   Zeventlimitr   firstlastdatacomment_headernewdatar	   r	   r
   format_paragraph_event#   s,    $
z&FormatParagraph.format_paragraph_event)r   r   )__name__
__module____qualname__Zmenudefsr   r   r    r	   r	   r	   r
   r      s
   r   c       
      C   s  t  t | j d   \ } } |  j d | d |  } xM |  j d | d d  r t |  r | d } |  j d | d |  } q; W| } t |  } t |  } xQ t |  | k r t | | d   r | d } |  j d | d |  } q Wd | } | d } |  j d | d |  } x] | d k rt |  | k rt | | d   r| d } |  j d | d |  } q+Wd | d }	 |	 | | |  j |	 |  f S)	zReturns the start/stop indices enclosing the paragraph that mark is in.

    Also returns the comment format string, if any, and paragraph of text
    between the start/stop indices.
    .z%d.0z%d.end<r      Nr   )mapr   splitr   Zcompareis_all_whiter   len)
r   marklinenocollineZfirst_linenor   Zcomment_header_lenr   r   r	   r	   r
   r   K   s,    (




r   c             C   s  |  j  d  } d } t |  } x* | | k  rM t | |  rM | d } q$ W| | k r^ |  St | |  } | d | k  r t | | d  r t | | d  } n | } | d |  } | } x| | k  rt | |  rt j  d | |  }	 x t d t |	  d  D] }
 |	 |
 } | s1qn  t | | j    | k ru| | k ru| j | j    | } n  | | d } |
 d t |	  k  r|	 |
 d d k r| d } qqW| d } q W| j | j    | j	 | | d   d j
 |  S)z3Return data reformatted to specified width (limit).
r   r&   Nz(\s+)    )r(   r*   r)   
get_indentrerange
expandtabsappendrstripextendjoin)r   r   linesinZindent1Zindent2newpartialZwordsjZwordr	   r	   r
   r   p   s<    % 
	*r   c                s   t      d j  f d d   |  j d  D  }  t | t     d  } t |  |  } | j d  } d } | d	 s d } | d d
  } n  d j   f d d   | D  | S)z?Return data reformatted to specified width with comment header.r/   c             3   s   |  ] } |   d   Vq d  S)Nr	   ).0r.   )lcr	   r
   	<genexpr>   s    z#reformat_comment.<locals>.<genexpr>    r&   Nc             3   s   |  ] }   | Vq d  S)Nr	   )r@   r.   )r   r	   r
   rB      s    rE   )r*   r9   r(   maxr   )r   r   r   Zformat_widthr   Zblock_suffixr	   )r   rA   r
   r      s    +
r   c             C   s   t  j d |   d k	 S)z/Return True if line is empty or all whitespace.z^\s*$N)r3   match)r.   r	   r	   r
   r)      s    r)   c             C   s   t  j d |   j   S)z/Return the initial space or tab indent of line.z	^([ \t]*))r3   rG   group)r.   r	   r	   r
   r2      s    r2   c             C   s/   t  j d |   } | d k r" d S| j d  S)a  Return string with leading whitespace and '#' from line or ''.

    A null return indicates that the line is not a comment line. A non-
    null return, such as '    #', will be used to find the other lines of
    a comment block with the same  indent.
    z^([ \t]*#*)NrD   r&   )r3   rG   rH   )r.   mr	   r	   r
   r      s     r   __main__z&idlelib.idle_test.test_formatparagraph	verbosityr0   exitF)__doc__r3   Zidlelib.configHandlerr   r   r   r   r   r)   r2   r   r!   Zunittestr   r	   r	   r	   r
   <module>   s   6%$                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/__pycache__/GrepDialog.cpython-34.pyc                                     0100644 0000000 0000000 00000013052 13077704335 022661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s&  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l m Z m Z m Z d  d l m Z m	 Z	 m
 Z
 m Z m Z d  d l m Z d  d l Z d  d l m Z d d d d  Z Gd d	   d	 e  Z d
 d   Z e d k r"d  d l Z e j d d d d d d  d l m Z e e  n  d S)    N)	StringVar
BooleanVarCheckbutton)TkTextButtonSELEND)SearchEngine)SearchDialogBasec             C   st   |  j    } t j |  } t | d  sB t | | |  | _ n  | j } |  j d d  } | j |  | |  d  S)N_grepdialogz	sel.firstzsel.last)Z_rootr
   gethasattr
GrepDialogr   open)textioflistrootengineZdialogsearchphrase r   (/usr/lib/python3.4/idlelib/GrepDialog.pygrep   s    	r   c               @   s   e  Z d  Z d Z d Z d Z d d   Z d d d  Z d	 d
   Z d d   Z	 d d   Z
 d d d  Z d d   Z d d   Z d d d  Z d S)r   zFind in Files DialogZGrepr   c             C   s>   t  j |  | |  | |  _ t |  |  _ t |  |  _ d  S)N)r   __init__r   r   globvarr   recvar)selfr   r   r   r   r   r   r      s    	zGrepDialog.__init__Nc       	      C   s   t  j |  | |  | r+ | j p% d } n d } t j j |  \ } } t j j |  \ } } | sp d } n  |  j j t j j	 | d |   d  S)N z.py*)
r   r   filenameospathsplitsplitextr   setjoin)	r   r   r   r   r"   dirbaseheadtailr   r   r   r   "   s    	zGrepDialog.openc             C   s-   t  j |   |  j d |  j  d |  _ d  S)Nz	In files:r   )r   create_entriesZ
make_entryr   Zglobent)r   r   r   r   r+   .   s    zGrepDialog.create_entriesc             C   sU   |  j    d } t | d d d |  j d d } | j d d d	 d
  | j   d  S)Nr   ZanchorwZvariabler   zRecurse down subdirectoriesZsidetopZfillZboth)Z
make_framer   r   packZselect)r   fZbtnr   r   r   create_other_buttons2   s    		zGrepDialog.create_other_buttonsc             C   s'   t  j |   |  j d |  j d  d  S)NzSearch Files   )r   create_command_buttonsZmake_buttondefault_command)r   r   r   r   r2   ;   s    z!GrepDialog.create_command_buttonsc             C   s   |  j  j   } | s d  S|  j j   } | s? |  j j   d  Sd d l m } t j	 } z& | |  j
  t _	 |  j | |  Wd  | t _	 Xd  S)Nr   )OutputWindow)r   Zgetprogr   r   r-   ZbellZidlelib.OutputWindowr4   sysstdoutr   grep_it)r   eventprogr"   r4   Zsaver   r   r   r3   ?   s    	zGrepDialog.default_commandc             C   s  t  j j |  \ } } |  j | | |  j j    } | j   |  j   |  j j	   } t
 d | | f  d } yx | D] } y t | d d  }	 x t |	 d  D]n \ }
 } | d
 d   d k r | d  d  } n  | j |  r t j j d | |
 | f  | d 7} q q WWd  QXWq} t k
 rU} z t
 |  WYd  d  } ~ Xq} Xq} Wt
 | rmd | n d	  Wn t k
 rYn Xd  S)NzSearching %r in %s ...r   errorsreplacer1   
z%s: %s: %s
z5Hits found: %s
(Hint: right-click to open locations.)zNo hits.r=   )r!   r"   r#   	findfilesr   r   sortcloser   Zgetpatprintr   	enumeratesearchr5   r6   writeOSErrorAttributeError)r   r9   r"   r'   r(   listZpathitsfnr/   linenolinemsgr   r   r   r7   O   s0    

!zGrepDialog.grep_itc             C   s  y t  j | p t  j  } Wn3 t k
 rQ } z t |  g  SWYd  d  } ~ Xn Xg  } g  } xg | D]_ } t  j j | |  }	 t  j j |	  r | j |	  qe t	 j	 | |  re | j |	  qe qe W| r x- | D]" }
 | j
 |  j |
 | |   q Wn  | S)N)r!   listdircurdirrE   rA   r"   r&   isdirappendfnmatchextendr>   )r   r'   r(   ZrecnamesrL   rG   ZsubdirsnamerI   Zsubdirr   r   r   r>   l   s"    
#zGrepDialog.findfilesc             C   s*   |  j  r& |  j  j   |  j  j   n  d  S)N)r-   Zgrab_releaseZwithdraw)r   r8   r   r   r   r@      s    	zGrepDialog.close)__name__
__module____qualname__titleZiconZneedwrapbuttonr   r   r+   r0   r2   r3   r7   r>   r@   r   r   r   r   r      s   	r   c       	         s   d d l  m } t   } | j d  t t t t j d |  j	      \ } } } } | j	 d | | d f  | |    t
 | d d   j      f d	 d
   } t | d d d | } | j   | j   d  S)Nr   )PyShellFileListzTest GrepDialogz[x+]z+%d+%d   height   c                  s:    j  t d t  t  d    j t d t  d  S)Nz1.0r   )Ztag_addr   r	   r   Z
tag_remover   )r   r   r   r   show_grep_dialog   s    z&_grep_dialog.<locals>.show_grep_dialogr   zShow GrepDialogZcommand)Zidlelib.PyShellrY   r   rX   rG   mapintrer#   Zgeometryr   r.   r   Zmainloop)	parentrY   r   widthr[   xyr]   Zbuttonr   )r   r   r   _grep_dialog   s    	3

re   __main__zidlelib.idle_test.test_grep	verbosity   exitF)run)r!   rQ   r`   r5   Ztkinterr   r   r   r   r   r   r   r	   Zidlelibr
   	itertoolsZidlelib.SearchDialogBaser   r   r   re   rU   ZunittestmainZidlelib.idle_test.htestrj   r   r   r   r   <module>   s    (	p                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      usr/lib/python3.4/idlelib/__pycache__/HyperParser.cpython-34.pyc                                    0100644 0000000 0000000 00000016370 13077704335 023116  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TM2                 @   s   d  Z  d d l Z d d l m Z d d l m Z e e j e j d  Z	 e e j d  Z
 d d   e d  D Z d	 d   e d  D Z Gd
 d   d  Z e d k r d d l Z e j d d d n  d S)zProvide advanced parsing abilities for ParenMatch and other extensions.

HyperParser uses PyParser.  PyParser mostly gives information on the
proper indentation of code.  HyperParser gives additional information on
the structure of code.
    N)	iskeyword)PyParse_c             C   s"   g  |  ] } t  |  t k  q S )chr_ASCII_ID_CHARS).0xr   r   )/usr/lib/python3.4/idlelib/HyperParser.py
<listcomp>   s   	 r      c             C   s"   g  |  ] } t  |  t k  q Sr   )r   _ASCII_ID_FIRST_CHARS)r   r	   r   r   r
   r      s   	 c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
 d d  Z e d d d h  Z	 e
 d d    Z d Z d d   Z d S)HyperParserc                s  |   _  | j   _ } t j | j | j  } d d   } | | j |   } | j sx | j D] } t	 | | d  } t
 |  d }	 d | }
 | j | j |	 |
  d  | j | j |	   } | d k	 s | d k re Pqe qe W| j | p d  n_ | j d	 |  } | r(| d }	 n d
 }	 d | }
 | j | j |	 |
  d  | j d  | j d d    _ |
   _ | j     _   f d d   t t   j   D   _   j |  d S)z;To initialize, analyze the surroundings of the given index.c             S   s   t  t |    S)N)intfloat)indexr   r   r
   
index2line#   s    z(HyperParser.__init__.<locals>.index2line   z.0z%d.endz 
Nr   Zconsolez1.0   c                sB   g  |  ]8 } | d  k o;   j  | d   j  | d d k  q S)r   r   )
bracketing)r   i)selfr   r
   r   L   s   	z(HyperParser.__init__.<locals>.<listcomp>)editwintextr   ZParserZindentwidthZtabwidthr   Zcontext_use_ps1Znum_context_linesmaxreprZset_strgetZfind_good_parse_startZ_build_char_in_string_funcZset_loZtag_prevrangestrrawtextstopatindexZget_last_stmt_bracketingr   rangelenisopener	set_index)r   r   r   r   parserr   ZlnocontextZstartatZstartatindexr    Zbodrr   )r   r
   __init__   s:    		

	zHyperParser.__init__c             C   s  t  |  j  t  |  j j | |  j   } | d k  rJ t d |   n  | |  _ d |  _ xP |  j t  |  j  d k  r |  j |  j d d |  j k  r |  j d 7_ q_ W|  j t  |  j  d k  r|  j |  j d d |  j k r|  j	 |  j d r|  j d 7_ n  d S)zgSet the index to which the functions relate.

        The index must be in the same statement.
        r   z(Index %s precedes the analyzed statementr   N)
r"   r   r   r   r    
ValueErrorindexinrawtextindexbracketr   r#   )r   r   r*   r   r   r
   r$   R   s    		!!zHyperParser.set_indexc             C   s/   |  j  |  j o. |  j |  j |  j d d k S)z2Is the index given to the HyperParser in a string?r   "')r,   r-   )r#   r+   r   r   )r   r   r   r
   is_in_stringg   s    zHyperParser.is_in_stringc             C   s0   |  j  |  j p/ |  j |  j |  j d d k S)z5Is the index given to the HyperParser in normal code?r   #r,   r-   )r/   r,   r-   )r#   r+   r   r   )r   r   r   r
   
is_in_codeo   s    zHyperParser.is_in_codez([{Fc             C   s  |  j  |  j d } |  j } x{ |  j | sc |  j |  j  | d | k sc |  j  | d | k r | d 8} | d k  r} d St | |  j  | d  } q  W|  j d } x: | t |  j   k  r |  j  | d | k r | d 7} q W|  j j d |  j t |  j  |  j  | d f  } | t |  j   k sQ|  j  | d t |  j  k rg| r[d S|  j } n; |  j j d |  j t |  j  |  j  | d d f  } | | f S)a  Return bracket indexes or None.

        If the index given to the HyperParser is surrounded by a
        bracket defined in openers (or at least has one before it),
        return the indices of the opening bracket and the closing
        bracket (or the end of line, whichever comes first).

        If it is not surrounded by brackets, or the end of line comes
        before the closing bracket and mustclose is True, returns None.
        r   r   Nz%s-%dc)	r   r+   r#   r   minr"   r   r   r    )r   ZopenersZ	mustcloseZbracketinglevelZbeforeZafterZbeforeindexZ
afterindexr   r   r
   get_surrounding_bracketsu   s0    	
+ 		)z$HyperParser.get_surrounding_bracketsTrueFalseNonec             C   s  t  } | } xL | | k rZ t | | d  d k  rZ | t | | d  rZ | d 8} q W| | k rSt | | d  d k rSx< | d | k r d | | d |  j   r | d 8} q W| d | k r d | | d |  j   r | d 8} n  | d | k r6d | | d |  j   r6| d 8} n  | | |  j   szd Sn' | | k  rzt t | |  szd Sn  | | k  rt | | |   r| | |  |  j k rd S| | S)zGiven a string and pos, return the number of chars in the
        identifier which ends at pos, or 0 if there is no such one.

        This ignores non-identifier eywords are not identifiers.
        r   r      ar   r   )_IS_ASCII_ID_CHARordisidentifier_IS_ASCII_ID_FIRST_CHARr   _ID_KEYWORDS)clsr   limitposZis_ascii_id_charr   r   r   r
   _eat_identifier   s.    &1..zHyperParser._eat_identifierz 	
\c       
      C   su  |  j    s t d   n  |  j } |  j } |  j } | | d } |  j } | } d } xx | | k r | | d |  j k r | d 8} q_ | r | | k r | | d d k r | d 8} d } q_ | | k r*| d k r*| | | d d d k r*| d 8} | | d } | | d d } q_ Pq_ | s8Pn  |  j | | |  } | rl| | } | } d } q\ | | k r`| | d }	 x2 | d k r| | d d |	 k r| d 8} qW| | d | k rPn  | | d } | d 8} | | d } | } | | d	 k rqa| | d
 k r\x. | d k rR| | d d k rR| d 8} q%W| } n  Pq\ Pq\ | | |  j  S)zReturn a string with the Python expression which ends at the
        given index, which is empty if there is no real one.
        z>get_expression should only be calledif index is inside a code.r   Tr   .r/   r   Fz([z'"ZrRbBuU)r0   r)   r   r   r+   r*   _whitespace_charsr@   )
r   r   r   Z
brck_indexZ
brck_limitr?   Zlast_identifier_posZpostdot_phaseZretlevelr   r   r
   get_expression   sb    				# 
	

	'
#	zHyperParser.get_expressionN)__name__
__module____qualname__r(   r$   r.   r0   r2   	frozensetr<   classmethodr@   rB   rD   r   r   r   r
   r      s   7,:r   __main__z"idlelib.idle_test.test_hyperparser	verbosityr   )__doc__stringkeywordr   Zidlelibr   rH   Zascii_lettersZdigitsr   r   r!   r8   r;   r   rE   Zunittestmainr   r   r   r
   <module>   s                                                                                                                                                                                                                                                                            usr/lib/python3.4/idlelib/__pycache__/IOBinding.cpython-34.pyc                                      0100644 0000000 0000000 00000034120 13077704335 022445  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T!M                 @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l j Z d  d l	 j
 Z d  d l Z d  d l Td  d l m Z d  d l m Z d  d l m Z y# d  d l Z e j e j d  Wn e e j f k
 r Yn Xe j   Z d Z e j d k rGy! e j   d	 Z e j e  Wn e k
 rCYn Xn yD e j e j   Z e d k pqe d k r}d Z n  e j e  Wnx e! e" e f k
 ryB e j   d	 Z e d k pe d k rd Z n  e j e  Wn e# e f k
 r Yn XYn Xe j$   Z e Z% e j& d
 e j'  Z( e j& d e j'  Z) d d   Z* Gd d   d  Z+ d d   Z, e- d k rd  d l. m/ Z/ e/ e,  n  d S)    N)*)	askstring)idleConf)BOM_UTF8 asciiZwin32   z%^[ \t\f]*#.*coding[:=][ \t]*([-\w.]+)z^[ \t\f]*(?:[#\r\n]|$)c             C   s  t  |  t  r! |  j d  } n |  } d | k rR | j d d  d d  } n4 d | k r} | j d d  d d  } n	 | g } xD | D]8 } t j |  } | d k	 r Pn  t j |  s d Sq Wd S| j d  } y t j	 |  Wn" t
 k
 rt
 d |   Yn X| S)aV  Return the encoding declaration according to PEP 263.

    When checking encoded data, only the first two lines should be passed
    in to avoid a UnicodeDecodeError if the rest of the data is not unicode.
    The first two lines would contain the encoding specification.

    Raise a LookupError if the encoding is declared but unknown.
    z
iso-8859-1
   Nr   zUnknown encoding: )
isinstancebytesdecodesplit	coding_rematchblank_regroupcodecslookupLookupError)datalinesZlstliner   name r   '/usr/lib/python3.4/idlelib/IOBinding.pycoding_specE   s*    		r   c               @   s  e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d Z d d   Z	 d Z
 d Z d d   Z d d d d  Z d Z e j e  Z e j Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d Z d Z  d: d; d< g Z! e" j# d. k rJd/ n d0 Z$ d1 d2   Z% d3 d4 d5  Z& d6 d7   Z' d8 d9   Z( d S)=	IOBindingc             C   s   | |  _  | j |  _ |  j j d |  j  |  _ |  j j d |  j  |  _ |  j j d |  j  |  _ |  j j d |  j	  |  _
 d  |  _ |  j j d |  j  |  _ d  S)Nz<<open-window-from-file>>z<<save-window>>z<<save-window-as-file>>z<<save-copy-of-window-as-file>>z<<print-window>>)editwintextbindopen_IOBinding__id_opensave_IOBinding__id_savesave_as_IOBinding__id_saveassave_a_copy_IOBinding__id_savecopyfileencodingprint_window_IOBinding__id_print)selfr   r   r   r   __init__p   s    		zIOBinding.__init__c             C   s   |  j  j d |  j  |  j  j d |  j  |  j  j d |  j  |  j  j d |  j  |  j  j d |  j  d  |  _ d  |  _  d  |  _ d  S)Nz<<open-window-from-file>>z<<save-window>>z<<save-window-as-file>>z<<save-copy-of-window-as-file>>z<<print-window>>)	r    Zunbindr#   r%   r'   r)   r,   r   filename_change_hook)r-   r   r   r   close|   s    		zIOBinding.closec             C   s   |  j  j   S)N)r   	get_saved)r-   r   r   r   r1      s    zIOBinding.get_savedc             C   s   |  j  j |  d  S)N)r   	set_saved)r-   flagr   r   r   r2      s    zIOBinding.set_savedc             C   s   |  j  j   d  S)N)r   
reset_undo)r-   r   r   r   r4      s    zIOBinding.reset_undoNc             C   s   | |  _  d  S)N)r/   )r-   hookr   r   r   set_filename_change_hook   s    z"IOBinding.set_filename_change_hookc             C   sf   | r- t  j j |  r- d  |  _ | |  _ n5 | |  _ d  |  _ |  j d  |  j rb |  j   n  d  S)Nr   )ospathisdirfilenamedirnamer2   r/   )r-   r:   r   r   r   set_filename   s    				zIOBinding.set_filenamec             C   s%  |  j  j } | r | s' |  j   } n | } | r |  j  r~ t |  j  d d   r~ |  j r~ |  j   r~ | j | |  j  q | j |  n |  j r |  j j	   n  d S|  j   r |  j
   } | d k r |  j j	   d Sn  | s |  j   } n | } | r|  j |  n |  j j	   d S)NZinterpbreakcancel)r   flistaskopenfilegetattrr:   r1   r"   loadfiler    	focus_set	maybesave)r-   eventZeditFiler?   r:   replyr   r   r   r"      s6    	
	zIOBinding.openz(\r\n)|\n|\rc       	      C   s  yK t  | d  6 } | j   | j   } | j d  | j   } Wd  QXWnH t k
 r } z( t j d t |  d |  j d SWYd  d  } ~ Xn X|  j	 | |  \ } } | d  k r t j d d | d |  j d S|  j
 j |  } | r| j d  |  _ |  j
 j d	 |  } n  |  j j d
 d  |  j d   |  j j d
 |  |  j   |  j |  | r}|  j d  n  |  j j d d
  |  j j d  |  j |  d S)Nrbr   z	I/O ErrormasterFzDecoding ErrorzFile %s
Failed to Decodeparentz\nz1.0endinsertT)r"   readlineseekreadOSErrortkMessageBox	showerrorstrr    _decodeeol_researchr   eol_conventionsubZdeleter<   rK   r4   r2   Zmark_setZyviewupdaterecentfileslist)	r-   r:   f	two_linesr   msgcharsZ	convertedZfirsteolr   r   r   rB      s:    	


zIOBinding.loadfilec          ;   C   s  d } | j  t  ra y | d d  j d  } Wn t k
 rJ d SYqa Xd |  _ | d f Sn  y t |  } Wnc t k
 r } z. t j d d d d	 | d
 |  j	  d } WYd d } ~ Xn t k
 r d SYn X| ry& t
 | |  } | |  _ | d f SWqt k
 rYqXn  y& t
 | d  } d |  _ | d f SWn t k
 rUYn Xy& t
 | d  } d |  _ | d f SWn t k
 rYn Xy` |  j j	 j   t d d d t d |  j j	 } | rt
 | |  } d |  _ n  | d f SWn t t f k
 rYn Xd S)zCreate a Unicode string.N   zutf-8FBOMtitlezError loading the filemessagez^The encoding '%s' is not known to this Python installation. The file may not display correctlyrH   r   zSpecify file encodingzwThe file's encoding is invalid for Python 3.x.
IDLE will convert it to UTF-8.
What is the current encoding of the file?ZinitialvaluerI   T)NF)NF)NF)
startswithr   r   UnicodeDecodeErrorr*   r   r   rP   rQ   r    rR   r   updater   locale_encoding)r-   rZ   r   r\   encr   r   r   r   rS      sh    			
				zIOBinding._decodec          	   C   s   |  j    r d Sd |  j p d } t j d d d | d t j d |  j  } | r~ d } |  j d   |  j    s d	 } q n | d  k r d	 } n d
 } |  j j   | S)NZyesz&Do you want to save %s before closing?zthis untitled documentr_   zSave On Closer`   defaultrH   r>   Zno)r1   r:   rP   ZaskyesnocancelZYESr    r$   rC   )r-   r`   confirmrF   r   r   r   rD   <  s&    			zIOBinding.maybesavec             C   sr   |  j  s |  j |  nH |  j |  j   ra |  j d  y |  j j   Wqa t k
 r] Yqa Xn  |  j j   d S)NTr=   )	r:   r&   	writefiler2   r   store_file_breaksAttributeErrorr    rC   )r-   rE   r   r   r   r$   R  s    	zIOBinding.savec             C   s   |  j    } | rg |  j |  rg |  j |  |  j d  y |  j j   Wqd t k
 r` Yqd Xqg n  |  j j   |  j	 |  d S)Nr   r=   )
asksavefilerh   r<   r2   r   ri   rj   r    rC   rX   )r-   rE   r:   r   r   r   r&   _  s    zIOBinding.save_asc             C   s@   |  j    } | r" |  j |  n  |  j j   |  j |  d S)Nr=   )rk   rh   r    rC   rX   )r-   rE   r:   r   r   r   r(   m  s    zIOBinding.save_a_copyc             C   s   |  j    |  j j d d  } |  j d k rF | j d |  j  } n  |  j |  } y- t | d   } | j |  Wd  QXd SWnH t k
 r } z( t	 j
 d t |  d |  j d SWYd  d  } ~ Xn Xd  S)	Nz1.0zend-1cr	   wbTz	I/O ErrorrH   F)fixlastliner    getrV   replaceencoder"   writerO   rP   rQ   rR   )r-   r:   r    r\   rY   r[   r   r   r   rh   u  s    

zIOBinding.writefilec          #   C   s  t  | t  r | S|  j d k r3 t | j d  Sy | j d  SWn t k
 rX Yn Xy t |  } d  } Wn1 t k
 r } z | } d  } WYd  d  } ~ Xn X| s d } n  | r y | j |  SWq t k
 r d | } Yq Xn  t j	 d d | d |  j
 t | j d  S)Nr^   zutf-8r   zInvalid encoding '%s'z	I/O Errorz%s.
Saving as UTF-8rH   )r   r   r*   r   rp   UnicodeErrorr   r   rP   rQ   r    )r-   r\   re   Zfailedr[   r   r   r   rp     s4    
	

zIOBinding.encodec             C   s8   |  j  j d  } | d k r4 |  j  j d d  n  d  S)Nzend-2cr	   zend-1c)r    rn   rK   )r-   cr   r   r   rm     s    zIOBinding.fixlastlinec          	   C   s  t  j d d d d d t  j d |  j  } | sA |  j j   d Sd  } |  j   } | re |  j } n  | sx | d  k r t j d d	  \ } } | } t	 j
 |  |  j |  s t	 j |  d Sn  t	 j } d
 } | d k rt j d d d  }	 |	 d }	 n* | d k r't j d d d  }	 n d } | r|	 t j |  }	 t	 j |	 d  }
 |
 j   j   } |
 j
   } | rd | | } n  | rd t |	  | } t  j d | d |  j qn# d | } t  j d | d |  j | rt	 j |  n  d S)Nr_   ZPrintr`   zPrint to Default Printerrf   rH   r=   prefixZ	IDLE_tmp_TposixmainZGeneralzprint-command-posixz 2>&1ntzprint-command-winFrz#Printing failed (exit status 0x%x)
zPrinting command: %s
zPrint statusz-Printing is not enabled for this platform: %s)rP   ZaskokcancelZOKr    rC   r1   r:   tempfileZmkstempr7   r0   rh   unlinkr   r   Z	GetOptionshlexZquotepopenrN   stripreprrQ   Zshowinfo)r-   rE   rg   ZtempfilenameZsavedr:   ZtfdplatformZprintPlatformZcommandpipeoutputZstatusr`   r   r   r   r+     sX    				
zIOBinding.print_windowPython files
*.py *.pywTEXT
Text files*.txt	All filesr   darwinz.pyr   c             C   sa   |  j  d  \ } } |  j sB t j d |  j d |  j  |  _ n  |  j j d | d |  } | S)Nr"   rH   	filetypes
initialdirinitialfile)defaultfilename
opendialogtkFileDialogZOpenr    r   show)r-   dirbaser:   r   r   r   r@     s    	zIOBinding.askopenfiler"   c             C   sk   |  j  r t j j |  j   S|  j r2 |  j d f Sy t j   } Wn t k
 r\ d } Yn X| d f Sd  S)Nr   )r:   r7   r8   r   r;   getcwdrO   )r-   modepwdr   r   r   r     s    		zIOBinding.defaultfilenamec             C   sj   |  j  d  \ } } |  j sK t j d |  j d |  j d |  j  |  _ n  |  j j d | d |  } | S)Nr$   rH   r   defaultextensionr   r   )r   
savedialogr   ZSaveAsr    r   r   r   )r-   r   r   r:   r   r   r   rk     s    				zIOBinding.asksavefilec             C   s#   |  j  j r |  j  j |  n  d S)z-Update recent file list on all editor windowsN)r   r?   Zupdate_recent_files_list)r-   r:   r   r   r   rX     s    zIOBinding.updaterecentfileslist)r   r   r   )r   r   r   )r   r   ))__name__
__module____qualname__r.   r0   r1   r2   r4   r/   r6   r:   r;   r<   r"   ZeolrecompilerT   r7   lineseprV   rB   rS   rD   r$   r&   r(   rh   rp   rm   r+   r   r   r   sysr   r   r@   r   rk   rX   r   r   r   r   r   n   sD   ,	$D'2	
r   c       
      C   s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  Gd d   d  } t |  } | j	   | j
   | |  } t |  }	 d  S)NzTest IOBindingz[x+]z+%d+%d   c               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)z_io_binding.<locals>.MyEditWinc             S   sB   | |  _  d  |  _ |  j  j d |  j  |  j  j d |  j  d  S)Nz<Control-o>z<Control-s>)r    r?   r!   r"   r$   )r-   r    r   r   r   r.     s    		z'_io_binding.<locals>.MyEditWin.__init__c             S   s   d S)Nr   r   )r-   r   r   r   r1     s    z(_io_binding.<locals>.MyEditWin.get_savedc             S   s   d  S)Nr   )r-   r3   r   r   r   r2     s    z(_io_binding.<locals>.MyEditWin.set_savedc             S   s   d  S)Nr   )r-   r   r   r   r4     s    z)_io_binding.<locals>.MyEditWin.reset_undoc             S   s   |  j  j d  d  S)Nz<<open-window-from-file>>)r    event_generate)r-   rE   r   r   r   r"     s    z#_io_binding.<locals>.MyEditWin.openc             S   s   |  j  j d  d  S)Nz<<save-window>>)r    r   )r-   rE   r   r   r   r$      s    z#_io_binding.<locals>.MyEditWin.saveN)	r   r   r   r.   r1   r2   r4   r"   r$   r   r   r   r   	MyEditWin  s   r   )ZTkr_   listmapintr   r   ZgeometryZTextZpackrC   r   )
rI   rootwidthZheightxyr   r    r   ior   r   r   _io_binding  s    	3

r   __main__)run)0r7   typesr{   r   r   ry   Ztkinter.filedialogZ
filedialogr   Ztkinter.messageboxZ
messageboxrP   r   ZtkinterZtkinter.simpledialogr   Zidlelib.configHandlerr   r   Zlocale	setlocaleLC_CTYPEImportErrorErrorgetfilesystemencodingZfilesystemencodingrd   r   Zgetdefaultlocaler   r   nl_langinfoCODESET	NameErrorrj   
ValueErrorlowerencodingr   ASCIIr   r   r   r   r   r   Zidlelib.idle_test.htestr   r   r   r   r   <module>   sb   
		
)                                                                                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/__pycache__/IdleHistory.cpython-34.pyc                                    0100644 0000000 0000000 00000007147 13077704335 023113  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sb   d  Z  d d l m Z Gd d   d  Z e d k r^ d d l m Z e d d d	 d
 d n  d S)z9Implement Idle Shell history mechanism with History class    )idleConfc               @   sR   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d S)Historya@   Implement Idle Shell history mechanism.

    store - Store source statement (called from PyShell.resetoutput).
    fetch - Fetch stored statement matching prefix already entered.
    history_next - Bound to <<history-next>> event (default Alt-N).
    history_prev - Bound to <<history-prev>> event (default Alt-P).
    c             C   sl   | |  _  g  |  _ d |  _ d |  _ t j d d d d d  |  _ | j d |  j  | j d |  j	  d S)	ad  Initialize data attributes and bind event methods.

        .text - Idle wrapper of tk Text widget, with .bell().
        .history - source statements, possibly with multiple lines.
        .prefix - source already entered at prompt; filters history list.
        .pointer - index into history.
        .cyclic - wrap around history list (or not).
        Nmainr   cyclic   boolz<<history-previous>>z<<history-next>>)
texthistoryprefixpointerr   Z	GetOptionr   Zbindhistory_prevhistory_next)selfr    r   )/usr/lib/python3.4/idlelib/IdleHistory.py__init__   s    					zHistory.__init__c             C   s   |  j  d d  d S)z4Fetch later statement; start with ealiest if cyclic.reverseFbreak)fetch)r   eventr   r   r   r      s    zHistory.history_nextc             C   s   |  j  d d  d S)z0Fetch earlier statement; start with most recent.r   Tr   )r   )r   r   r   r   r   r   #   s    zHistory.history_prevc             C   sL  t  |  j  } |  j } |  j } | d k	 r | d k	 r |  j j d d d  ss |  j j d d  |  j | k r d } } |  j j d d  q n  | d k s | d k r |  j j d d  } | r | } q |  j r d } q |  j j	   d Sn  t  |  } x	| | rd n d 7} | d k  s5| | k r|  j j	   |  j r\| d k  r\d S|  j j d d  | k r|  j j
 d d  |  j j d |  n  d } } Pn  |  j | } | d |  | k rt  |  | k r|  j j
 d d  |  j j d |  Pqq|  j j d  |  j j d d	 d
  | |  _ | |  _ d S)a+  Fetch statememt and replace current line in text widget.

        Set prefix and pointer as needed for successive fetches.
        Reset them to None, None when returning to the start line.
        Sound bell when return to start line or cannot leave a line
        because cyclic is False.
        Ninsertz!=zend-1cZiomarkr   r   Zselz1.0endr   )lenr	   r   r
   r   ZcomparegetZmark_setr   ZbellZdeleter   ZseeZ
tag_remove)r   r   Znhistr   r
   Znprefixitemr   r   r   r   (   sJ    		"
			
(	zHistory.fetchc             C   sp   | j    } t |  d k rZ y |  j j |  Wn t k
 rF Yn X|  j j |  n  d |  _ d |  _ d S)z.Store Shell input statement into history list.   N)stripr   r	   remove
ValueErrorappendr   r
   )r   sourcer   r   r   storeY   s    	zHistory.storeN)	__name__
__module____qualname____doc__r   r   r   r   r"   r   r   r   r   r      s   1r   __main__)r   z"idlelib.idle_test.test_idlehistory	verbosityr   exitFN)r&   Zidlelib.configHandlerr   r   r#   Zunittestr   r   r   r   r   <module>   s
   a                                                                                                                                                                                                                                                                                                                                                                                                                         usr/lib/python3.4/idlelib/__pycache__/MultiCall.cpython-34.pyc                                      0100644 0000000 0000000 00000040402 13077704335 022531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TJI                 @   s  d  Z  d d l Z d d l Z d d l Z d Z d Z d Z d Z d Z d Z	 d Z
 d	 Z d
 Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z d Z dQ Z dR Z dS Z dT Z dU Z dV Z  e j! d k rd[ Z" e e e e  f Z# n d` Z" e e e e f Z# e$ d! d"   e% e& e"   D  Z' d# Z( Gd$ d%   d%  Z) e% d e& e"  > Z* d& d"   e* D Z+ d' d(   Z, e, e*  Z- g  Z. x] e* D]U Z/ d Z0 x9 e% e& e"   D]% Z1 d e1 >e/ @re0 e# e1 OZ0 qqWe. j2 e0  qWGd) d*   d*  Z3 dx Z4 e3 f d e) f e& e4  d Z5 e$ dD d"   e% e& e4   D  Z6 e j7 dE  Z8 e j7 dF  Z9 dG dH   Z: dI dJ   Z; i  Z< dK dL   Z= dM dN   Z> e? dO k rd dP l@ mA ZA eA e>  n  d S)ya  
MultiCall - a class which inherits its methods from a Tkinter widget (Text, for
example), but enables multiple calls of functions per virtual event - all
matching events will be called, not only the most specific one. This is done
by wrapping the event functions - event_add, event_delete and event_info.
MultiCall recognizes only a subset of legal event sequences. Sequences which
are not recognized are treated by the original Tk handling mechanism. A
more-specific event will be called before a less-specific event.

The recognized sequences are complete one-event sequences (no emacs-style
Ctrl-X Ctrl-C, no shortcuts like <3>), for all types of events.
Key/Button Press/Release events can have modifiers.
The recognized modifiers are Shift, Control, Option and Command for Mac, and
Control, Alt, Shift, Meta/M for other platforms.

For all events which were handled by MultiCall, a new member is added to the
event instance passed to the binded functions - mc_type. This is one of the
event type constants defined in this module (such as MC_KEYPRESS).
For Key/Button events (which are handled by MultiCall and may receive
modifiers), another member is added - mc_state. This member gives the state
of the recognized modifiers, as a combination of the modifier constants
also defined in this module (for example, MC_SHIFT).
Using these members is absolutely portable.

The order by which events are called is defined by these rules:
1. A more-specific event will be called before a less-specific event.
2. A recently-binded event will be called before a previously-binded event,
   unless this conflicts with the first rule.
Each function will be called at most once for each event.
    N                        	   
                                       darwinShiftControlOptionCommandAltMetaMc             C   s-   g  |  ]# } t  | D] } | | f  q q S )
_modifiers).0numbernamer    r    '/usr/lib/python3.4/idlelib/MultiCall.py
<listcomp>7   s   	r&   z<can't invoke "bind" command:  application has been destroyedc               @   s@   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 S)
_SimpleBinderc             C   sJ   | |  _  d t | d d |  _ | |  _ | |  _ g  |  _ d  |  _ d  S)N<r   >)type_typessequencewidget
widgetinstbindedfuncs	handlerid)selfr*   r-   r.   r    r    r%   __init__K   s    				z_SimpleBinder.__init__c             C   sY   |  j  sE |  j |  j d d  } |  j j |  j |  j |  |  _  n  |  j j |  d  S)Nc             S   ss   | |  _  i  } x] t t |  d d d  D]? } | | } | | k r, d | | <| |   } | rk | Sq, q, Wd  S)Nr   Tr3   )mc_typerangelen)eventlr4   	wascalledifuncrr    r    r%   handlerU   s    	#

z#_SimpleBinder.bind.<locals>.handler)r0   r/   r*   r-   bindr.   r,   append)r1   tripletr;   r=   r    r    r%   r>   S   s
    	
z_SimpleBinder.bindc             C   sH   |  j  j |  |  j  sD |  j j |  j |  j |  j  d  |  _ n  d  S)N)r/   remover-   unbindr.   r,   r0   )r1   r@   r;   r    r    r%   rB   c   s    	z_SimpleBinder.unbindc             C   sw   |  j  rs y# |  j j |  j |  j |  j   Wqs t j k
 ro } z | j d t k rZ n   WYd  d  } ~ Xqs Xn  d  S)Nr   )	r0   r-   rB   r.   r,   tkinterTclErrorargsAPPLICATION_GONE)r1   er    r    r%   __del__i   s    	z_SimpleBinder.__del__N)__name__
__module____qualname__r2   r>   rB   rH   r    r    r    r%   r'   J   s   r'   c                s8   g  |  ].   d  j    f d d   t t  D   q S) c             3   s1   |  ]' \ } } d  | >  @r | d d Vq d S)r   r   -Nr    )r"   r:   m)sr    r%   	<genexpr>z   s   	z<listcomp>.<genexpr>)join	enumerater!   )r"   r    )rO   r%   r&   z   s   	c                so   d d   } g  } xV |  D]N   t  t   f d d   |  D   } | j d | d d  | j |  q W| S)zFor each item of states return a list containing all combinations of
    that item with individual bits reset, sorted by the number of set bits.
    c             S   s6   d } x) |  r1 t  |  d  \ }  } | | 7} q	 W| S)znumber of bits set in n base 2r   r   )divmod)nZnbZremr    r    r%   nbits   s
    	zexpand_substates.<locals>.nbitsc             3   s   |  ] }   | @Vq d  S)Nr    )r"   x)stater    r%   rP      s    z#expand_substates.<locals>.<genexpr>keyreverseT)listsetsortr?   )ZstatesrU   Z	statelistZ	substatesr    )rW   r%   expand_substates   s    %r]   c               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)_ComplexBinderc             C   s%   | | | |  j  |  j d d  } | S)Nc             S   s   d g | d  d   <| |  _  | |  _ i  } d  } x| | D]t } xa t t |  d d d  D]C }	 | |	 }
 |
 | k r[ d | |
 <| |	 |   } | r Pq q[ q[ W| r8 Pq8 q8 Wg  | d  d   <x | D] } |   q Wg  | d  d   <| r | Sd  S)NTr   r3   r3   )r4   mc_stater5   r6   )r7   listsr4   r_   ishandlerrunningdoafterhandlerr9   r<   r8   r:   r;   fr    r    r%   r=      s*    		#

z0_ComplexBinder.__create_handler.<locals>.handler)ra   rb   )r1   r`   r4   r_   r=   r    r    r%   Z__create_handler   s
    z_ComplexBinder.__create_handlerc                s   |   _  t | d   _ |   _ |   _ i d d   t D d  6  _ g    _ g    _ g    _	 x t D] }   f d d   t
 | D }   j | | t |  } d t |   j d }   j j |   j j   j | |  f  qk Wd  S)Nr   c             S   s   g  |  ] } g   q Sr    r    )r"   rO   r    r    r%   r&      s   	 z+_ComplexBinder.__init__.<locals>.<listcomp>c                s!   g  |  ] }   j  d  |  q S)N)r/   )r"   r:   )r1   r    r%   r&      s   	 r(   r)   )r*   r+   typenamer-   r.   _statesr/   
handleridsra   rb   _state_subsets_ComplexBinder__create_handler_state_codes_state_namesr?   r>   )r1   r*   r-   r.   rO   r`   r=   seqr    )r1   r%   r2      s    						z_ComplexBinder.__init__c                s   d  j  k r d d   t D  j   d <x t D]    f d d    d d  f D }  j |  j t   } d t   j  d f }  j j |  j	 j
  j | |  f  q8 Wn      f d d   }  j s |   n  j j |  d  S)Nr   c             S   s   g  |  ] } g   q Sr    r    )r"   rO   r    r    r%   r&      s   	 z'_ComplexBinder.bind.<locals>.<listcomp>c                s2   g  |  ]( } t    D] }  j | |  q q Sr    )rg   r/   )r"   detailr:   )rO   r1   r    r%   r&      s   	z	<%s%s-%s>c                  s     j   d  d j    S)Nr   r   )r/   r?   r    )r;   r1   r@   r    r%   <lambda>   s    z%_ComplexBinder.bind.<locals>.<lambda>)r/   re   rh   r*   ri   rj   rd   rf   r?   r-   r>   r.   ra   rb   )r1   r@   r;   r`   r=   rk   doitr    )r;   rO   r1   r@   r%   r>      s    	
z_ComplexBinder.bindc                s?       f d d   }  j  s+ |   n  j j |  d  S)Nc                  s     j   d  d j    S)Nr   r   )r/   rA   r    )r;   r1   r@   r    r%   rm      s    z'_ComplexBinder.unbind.<locals>.<lambda>)ra   rb   r?   )r1   r@   r;   rn   r    )r;   r1   r@   r%   rB      s    	
z_ComplexBinder.unbindc             C   s   xy |  j  D]n \ } } y |  j j |  j | |  Wq
 t j k
 rw } z | j d t k rb Pn   WYd  d  } ~ Xq
 Xq
 Wd  S)Nr   )rf   r-   rB   r.   rC   rD   rE   rF   )r1   rk   idrG   r    r    r%   rH      s    z_ComplexBinder.__del__N)rI   rJ   rK   rh   r2   r>   rB   rH   r    r    r    r%   r^      s
   r^   KeyPressKey
KeyReleaseButtonPressButtonButtonReleaseActivate	CirculateColormap	Configure
DeactivateDestroyEnterExposeFocusInFocusOutGravityLeaveMapMotion
MouseWheelPropertyReparentUnmap
Visibilityc             C   s-   g  |  ]# } t  | D] } | | f  q q Sr    )r+   )r"   r#   r$   r    r    r%   r&   
  s   	z^\w+$z^[1-5]$c             C   sY  |  s' |  d d k s' |  d d k r+ d S|  d d  j  d  } d } x7 | r | d t k r | d t | d >O} | d =qM W| r | d t k r t | d } | d =n d St | t k r | s | r d Sd } nm | d d   d D k rt } n t } | sd } n6 t |  d k rH| j | d  rH| d } n d S| | | f S)a-  Get a string which should describe an event sequence. If it is
    successfully parsed as one, return a tuple containing the state (as an int),
    the event type (as an index of _types), and the detail - None if none, or a
    string if there is one. If the parsing is unsuccessful, return None.
    r   r(   r   r)   NrM   c             S   s   g  |  ] } t  |  q Sr    )_type_names)r"   rO   r    r    r%   r&   )  s   	 z#_parse_sequence.<locals>.<listcomp>rp   rr   r3   r3   )rp   rr   )	split_modifier_namesr   _binder_classesr'   
_keysym_re
_button_rer6   match)r,   ZwordsZ	modifiersr*   rl   Ztype_rer    r    r%   _parse_sequence  s0    '
			%r   c             C   sb   |  d r: d t  |  d t |  d d d |  d d Sd t  |  d t |  d d d Sd  S)Nr   r(   r   r   rM   r)   )rj   r+   )r@   r    r    r%   _triplet_to_sequence7  s    
0r   c                s>     t  k r t    SG  f d d   d    } | t    <| S)zReturn a MultiCall class which inherits its methods from the
    given widget class (for example, Tkinter.Text). This is used
    instead of a templating mechanism.
    c                   s   e  Z d  Z e   e j  s$ t    f d d   Z d d d   f d d  Z d   f d d  Z	   f d d	   Z
   f d
 d   Z d   f d d  Z d d   Z d S)z#MultiCallCreator.<locals>.MultiCallc                sK    j    | |  i    _    f d d   t t t   D   _ d  S)Nc                s&   g  |  ] } t  | |      q Sr    )r   )r"   r:   )r1   r-   r    r%   r&   P  s   	z@MultiCallCreator.<locals>.MultiCall.__init__.<locals>.<listcomp>)r2   _MultiCall__eventinfor5   r6   r+   _MultiCall__binders)r1   rE   kwargs)r-   )r1   r%   r2   J  s    	z,MultiCallCreator.<locals>.MultiCall.__init__Nc                s/  t  |  t k rt |  d k r| d  d  d k r| d d   d k r| |  j k r|  j | } | d d  k	 r x4 | d D]% } |  j | d j | | d  q Wn  | | d <| d d  k	 rx0 | d D]! } |  j | d j | |  q Wqq| g  g |  j | <n    j |  | | |  S)Nr   z<<z>>r   r   )r*   strr6   r   r   rB   r>   )r1   r,   r;   addZeir@   )r-   r    r%   r>   S  s    $,&
%z(MultiCallCreator.<locals>.MultiCall.bindc                s   t  |  t k r t |  d k r | d  d  d k r | d d   d k r | |  j k r |  j | \ } } | d  k	 r x) | D]! } |  j | d j | |  q Wd  |  j | d <q n    j |  | |  S)Nr   z<<z>>r   r   r   )r*   r   r6   r   r   rB   )r1   r,   Zfuncidr;   tripletsr@   )r-   r    r%   rB   e  s    $,z*MultiCallCreator.<locals>.MultiCall.unbindc                s   | |  j  k r% d  g  g |  j  | <n  |  j  | \ } } xs | D]k } t |  } | d  k rs   j |  | |  q? | d  k	 r |  j | d j | |  n  | j |  q? Wd  S)Nr   )r   r   	event_addr   r>   r?   )r1   virtual	sequencesr;   r   rk   r@   )r-   r    r%   r   p  s    z-MultiCallCreator.<locals>.MultiCall.event_addc                s   | |  j  k r d  S|  j  | \ } } xs | D]k } t |  } | d  k ra   j |  | |  q- | d  k	 r |  j | d j | |  n  | j |  q- Wd  S)Nr   )r   r   event_deleter   rB   rA   )r1   r   r   r;   r   rk   r@   )r-   r    r%   r     s    z0MultiCallCreator.<locals>.MultiCall.event_deletec                s]   | d  k s | |  j  k r+   j |  |  St t t |  j  | d     j |  |  Sd  S)Nr   )r   
event_infotuplemapr   )r1   r   )r-   r    r%   r     s
    	z.MultiCallCreator.<locals>.MultiCall.event_infoc             S   s   x |  j  D] } |  j  | \ } } | r
 xu | D]j } y |  j | d j | |  Wq0 t j k
 r } z | j d t k r Pn   WYd  d  } ~ Xq0 Xq0 Wq
 q
 Wd  S)Nr   r   )r   r   rB   rC   rD   rE   rF   )r1   r   r;   r   r@   rG   r    r    r%   rH     s    z+MultiCallCreator.<locals>.MultiCall.__del__)rI   rJ   rK   
issubclassrC   ZMiscAssertionErrorr2   r>   rB   r   r   r   rH   r    )r-   r    r%   	MultiCallG  s   	r   )_multicall_dict)r-   r   r    )r-   r%   MultiCallCreator?  s
    ]
r   c                s$  t  j   } | j d  t t t t j d |  j      \ } } } } | j d | | d f  t	 t  j
  |      j   d g   f d d  } | d  | d	  | d
  | d  | d  | d  | d  | d  | d  | d  | d  | d  | j   d  S)NzTest MultiCallz[x+]z+%d+%d   r   c                sT     f d d   }  j  d | d |   j d | d    | d d 7<d  S)Nc                s   t     d  S)N)print)r7   )rk   r    r%   r=     s    z-_multi_call.<locals>.bindseq.<locals>.handlerz<<handler%d>>r   r   )r>   r   )rk   rT   r=   )text)rk   r%   bindseq  s    z_multi_call.<locals>.bindseqz<Key>z<Control-Key>z<Alt-Key-a>z<Control-Key-a>z<Alt-Control-Key-a>z<Key-b>z<Control-Button-1>z
<Button-2>z<Alt-Button-1>z
<FocusOut>z<Enter>z<Leave>)rC   ZTktitlerZ   r   intrer   Zgeometryr   ZTextZpackZmainloop)parentrootwidthZheightrV   yr   r    )r   r%   _multi_call  s(    3












r   __main__)runr   r   r	       @      r   r   r   r   )r   r   r   r   r   r   r   r   r   )r   r   r   r   zKeyPressrq   z
KeyReleasers   rt   ru   rv   rw   rx   ry   rz   r{   r|   r}   r~   r   r   r   r   r   r   r   r   r   r   )r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   )B__doc__sysr   rC   ZMC_KEYPRESSZMC_KEYRELEASEZMC_BUTTONPRESSZMC_BUTTONRELEASEZMC_ACTIVATEZMC_CIRCULATEZMC_COLORMAPZMC_CONFIGUREZMC_DEACTIVATEZ
MC_DESTROYZMC_ENTERZ	MC_EXPOSEZ
MC_FOCUSINZMC_FOCUSOUTZ
MC_GRAVITYZMC_LEAVEZMC_MAPZ	MC_MOTIONZMC_MOUSEWHEELZMC_PROPERTYZMC_REPARENTZMC_UNMAPZMC_VISIBILITYZMC_SHIFTZ
MC_CONTROLZMC_ALTZMC_METAZ	MC_OPTIONZ
MC_COMMANDplatformr!   Z_modifier_masksdictr5   r6   r   rF   r'   re   rj   r]   rg   ri   rO   r<   r:   r?   r^   r+   r   r   compiler   r   r   r   r   r   r   rI   Zidlelib.idle_test.htestr   r    r    r    r%   <module>   s                         
/	
b     "'i                                                                                                                                                                                                                                                              usr/lib/python3.4/idlelib/__pycache__/MultiStatusBar.cpython-34.pyc                                 0100644 0000000 0000000 00000003504 13077704335 023570  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sY   d  d l  TGd d   d e  Z d d   Z e d k rU d  d l m Z e e  n  d S)	    )*c               @   s1   e  Z d  Z d d d  Z d e d d  Z d S)MultiStatusBarNc             K   s8   | d  k r t    } n  t j |  | |  i  |  _ d  S)N)TkFrame__init__labels)selfZmasterkw r
   ,/usr/lib/python3.4/idlelib/MultiStatusBar.pyr      s    zMultiStatusBar.__init__ c             C   sn   | |  j  k rM t |  d d d t d t } | j d |  | |  j  | <n |  j  | } | j d |  d  S)NZbd   ZreliefZanchorsidetext)r   ZLabelZSUNKENWpackZconfig)r   namer   r   Zlabelr
   r
   r   	set_label   s    zMultiStatusBar.set_label)__name__
__module____qualname__r   ZLEFTr   r
   r
   r
   r   r      s   r   c       
         s$  t    } t t t t j d |  j      \ } } } } | j d | | d f  | j d  t |  } t	 |  } | j
   t |      j d d    j d d    j
 d	 t d
 t    f d d   } t | d d d | }	 |	 j
 d	 t  | j
   | j   | j   d  S)Nz[x+]z+%d+%d   zTest multistatus baroneZhellotwoZworldr   Zfillc                  s$     j  d d    j  d d  d  S)Nr   Zfoor   Zbar)r   r
   )msbr
   r   change!   s    z _multistatus_bar.<locals>.changer   zUpdate statusZcommand)r   listmapintresplitZgeometrytitler   ZTextr   r   r   ZBOTTOMXZButtonZmainloop)
parentrootwidthZheightxyZframer   r   Zbuttonr
   )r   r   _multistatus_bar   s"    	3


r(   __main__)runN)Ztkinterr   r   r(   r   Zidlelib.idle_test.htestr*   r
   r
   r
   r   <module>   s
   
                                                                                                                                                                                            usr/lib/python3.4/idlelib/__pycache__/ObjectBrowser.cpython-34.pyc                                  0100644 0000000 0000000 00000012605 13077704335 023421  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s@  d  d l  Z  d  d l m Z m Z m Z d  d l m Z e   Z d e _ d e _	 Gd d   d e  Z
 Gd d   d e
  Z Gd	 d
   d
 e
  Z Gd d   d e
  Z Gd d   d e  Z i e e 6e e 6e e 6e e 6e e 6e e 6e e 6Z d d d  Z d d   Z e d k r<d  d l m Z e e  n  d S)    N)TreeItemTreeNodeScrolledCanvas)Reprd   c               @   ss   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d S)ObjectTreeItemNc             C   s   | |  _  | |  _ | |  _ d  S)N)	labeltextobjectsetfunction)selfr   r	   r
    r   +/usr/lib/python3.4/idlelib/ObjectBrowser.py__init__   s    		zObjectTreeItem.__init__c             C   s   |  j  S)N)r   )r   r   r   r   GetLabelText   s    zObjectTreeItem.GetLabelTextc             C   s   t  j |  j  S)N)myreprreprr	   )r   r   r   r   GetText   s    zObjectTreeItem.GetTextc             C   s   |  j    s d Sd  S)NZpython)IsExpandable)r   r   r   r   GetIconName   s    zObjectTreeItem.GetIconNamec             C   s   |  j  d  k	 S)N)r
   )r   r   r   r   
IsEditable"   s    zObjectTreeItem.IsEditablec          	   C   s5   y t  |  } |  j |  Wn Yn
 X| |  _ d  S)N)evalr
   r	   )r   textvaluer   r   r   SetText$   s    zObjectTreeItem.SetTextc             C   s   t  |  j  S)N)dirr	   )r   r   r   r   r   ,   s    zObjectTreeItem.IsExpandablec             C   s   t  |  j  } g  } xt | D]l } y t |  j |  } Wn t k
 rO w Yn Xt t |  d | | |  j d d   } | j |  q W| S)Nz =c             S   s   t  | | |   S)N)setattr)r   keyr	   r   r   r   <lambda>9   s    z+ObjectTreeItem.GetSubList.<locals>.<lambda>)r   r	   getattrAttributeErrormake_objecttreeitemstrappend)r   keyssublistr   r   itemr   r   r   
GetSubList.   s    zObjectTreeItem.GetSubList)__name__
__module____qualname__r   r   r   r   r   r   r   r&   r   r   r   r   r      s   r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)ClassTreeItemc             C   s   d S)NTr   )r   r   r   r   r   ?   s    zClassTreeItem.IsExpandablec             C   sl   t  j |   } t |  j j  d k rC t d |  j j d  } n t d |  j j  } | j d |  | S)N   z__bases__[0] =r   z__bases__ =)r   r&   lenr	   	__bases__r    insert)r   r$   r%   r   r   r   r&   A   s    zClassTreeItem.GetSubListN)r'   r(   r)   r   r&   r   r   r   r   r*   >   s   r*   c               @   s   e  Z d  Z d d   Z d S)AtomicObjectTreeItemc             C   s   d S)Nr   r   )r   r   r   r   r   L   s    z!AtomicObjectTreeItem.IsExpandableN)r'   r(   r)   r   r   r   r   r   r/   K   s   r/   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)SequenceTreeItemc             C   s   t  |  j  d k S)Nr   )r,   r	   )r   r   r   r   r   P   s    zSequenceTreeItem.IsExpandablec             C   s   t  t |  j   S)N)ranger,   r	   )r   r   r   r   r#   R   s    zSequenceTreeItem.keysc             C   s   g  } xx |  j    D]j } y |  j | } Wn t k
 rA w Yn X| |  j d d  } t d | f | |  } | j |  q W| S)Nc             S   s   |  | | <d  S)Nr   )r   r   r	   r   r   r   r
   [   s    z0SequenceTreeItem.GetSubList.<locals>.setfunctionz%r:)r#   r	   KeyErrorr    r"   )r   r$   r   r   r
   r%   r   r   r   r&   T   s    zSequenceTreeItem.GetSubListN)r'   r(   r)   r   r#   r&   r   r   r   r   r0   O   s   r0   c               @   s   e  Z d  Z d d   Z d S)DictTreeItemc          	   C   s2   t  |  j j    } y | j   Wn Yn X| S)N)listr	   r#   sort)r   r#   r   r   r   r#   b   s    zDictTreeItem.keysN)r'   r(   r)   r#   r   r   r   r   r3   a   s   r3   c             C   s;   t  |  } | t k r% t | } n t } | |  | |  S)N)typedispatchr   )r   r	   r
   tcr   r   r   r    t   s
    r    c             C   s  d d  l  } d d l m } |   } | j d  t t t t j d |  j	      \ } } } } | j	 d | | d f  | j
 d d d d	  | j   t | d d
 d d d d } | j j d d d d  t d |  }	 t | j d  |	  }
 |
 j   | j   d  S)Nr   )TkzTest ObjectBrowserz[x+]z+%d+%d   ZbdZbgZyellowZwhiteZhighlightthicknessZ	takefocusr+   expandZfillZbothsys)r=   Ztkinterr:   titler4   mapintresplitZgeometryZ	configureZ	focus_setr   ZframeZpackr    r   ZcanvasupdateZmainloop)parentr=   r:   rootwidthZheightxyZscr%   Znoder   r   r   _object_browser}   s    	3

rI   __main__)run)rA   Zidlelib.TreeWidgetr   r   r   reprlibr   r   	maxstringmaxotherr   r*   r/   r0   r3   r@   floatr!   tupler4   dictr6   r7   r    rI   r'   Zidlelib.idle_test.htestrK   r   r   r   r   <module>   s.   			(	
	                                                                                                                           usr/lib/python3.4/idlelib/__pycache__/OutputWindow.cpython-34.pyc                                   0100644 0000000 0000000 00000010664 13077704335 023342  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T*                 @   sr   d  d l  Td  d l m Z d  d l Z d  d l j Z d  d l m Z Gd d   d e  Z	 Gd d   d  Z
 d S)	    )*)EditorWindowN)	IOBindingc               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z f  d
 d d  Z d d   Z	 d d   Z
 d& d' d( d) d* g Z d d d d  d! g Z d Z d d" d#  Z d$ d%   Z d S)+OutputWindowzAn editor window that can serve as an output file.

    Also the future base class for the Python shell window.
    This class has no input facilities.
    c             G   s*   t  j |  |  |  j j d |  j  d  S)Nz<<goto-file-line>>)r   __init__textZbindgoto_file_line)selfargs r   */usr/lib/python3.4/idlelib/OutputWindow.pyr      s    zOutputWindow.__init__c             C   s   d S)Nr   r   )r	   filenamer   r   r   ispythonsource   s    zOutputWindow.ispythonsourcec             C   s   d S)NZOutputr   )r	   r   r   r   short_title   s    zOutputWindow.short_titlec             C   s   |  j    r d Sd Sd  S)NZyesZno)Z	get_saved)r	   r   r   r   	maybesave   s    zOutputWindow.maybesaveinsertc             C   sj   t  | t t f  r- | j t j d  } n  |  j j | | |  |  j j |  |  j j   t	 |  S)Nreplace)

isinstancebytesdecoder   encodingr   r   Zseeupdatelen)r	   stagsmarkr   r   r   write%   s    zOutputWindow.writec             C   s"   x | D] } |  j  |  q Wd  S)N)r   )r	   linesliner   r   r   
writelines-   s    zOutputWindow.writelinesc             C   s   d  S)Nr   )r	   r   r   r   flush1   s    zOutputWindow.flushCut<<cut>>rmenu_check_cutCopy<<copy>>rmenu_check_copyPaste	<<paste>>rmenu_check_pasteNGo to file/line<<goto-file-line>>zfile "([^"]*)", line (\d+)z([^\s]+)\((\d+)\)z^(\s*\S.*?):\s*(\d+):z([^\s]+):\s*(\d+):z^\s*(\S.*?):\s*(\d+):c       	      C   s   |  j  d  k rQ g  } x- |  j D]" } | j t j | t j   q W| |  _  n  |  j j d d  } |  j |  } | s |  j j d d  } |  j |  } | s t	 j
 d d d |  j d  Sn  | \ } } |  j j |  } | j |  d  S)Nzinsert linestartzinsert lineendzinsert -1line linestartzinsert -1line lineendzNo special linezTThe line you point at doesn't look like a valid file name followed by a line number.Zmaster)file_line_progsfile_line_patsappendrecompile
IGNORECASEr   get_file_line_helpertkMessageBoxZ	showerrorflistopenZgotoline)	r	   ZeventlZpatr   resultr   linenoZeditr   r   r   r   I   s(     	
zOutputWindow.goto_file_linec             C   s   x{ |  j  D]l } | j |  } | r
 | j d d  \ } } y t | d  } | j   PWqv t k
 rr w
 Yqv Xq
 q
 Wd  Sy | t |  f SWn t k
 r d  SYn Xd  S)N      r)r,   searchgroupr6   closeOSErrorint	TypeError)r	   r   progmatchr   r9   fr   r   r   r3   d   s    
zOutputWindow._file_line_helper)r!   r"   r#   )r$   r%   r&   )r'   r(   r)   )NNN)r*   r+   N)__name__
__module____qualname____doc__r   r   r   r   r   r   r    Zrmenu_specsr-   r,   r   r3   r   r   r   r   r      s*   			r   c               @   sV   e  Z d  Z i i d d 6d 6i d d 6d 6Z d d   Z d d	   Z d
 d   Z d S)OnDemandOutputWindowZblueZ
foregroundstdoutz#007700stderrc             C   s   | |  _  d  |  _ d  S)N)r5   owin)r	   r5   r   r   r   r      s    	zOnDemandOutputWindow.__init__c             C   s0   |  j  s |  j   n  |  j  j | | |  d  S)N)rM   setupr   )r	   r   r   r   r   r   r   r      s    	zOnDemandOutputWindow.writec             C   sx   t  |  j  |  _ } | j } x6 |  j j   D]% \ } } | r/ | j | |  q/ q/ W| j d  |  j j |  _ d  S)NZsel)	r   r5   rM   r   tagdefsitemsZtag_configureZ	tag_raiser   )r	   rM   r   tagZcnfr   r   r   rN      s    	zOnDemandOutputWindow.setupN)rF   rG   rH   rO   r   r   rN   r   r   r   r   rJ   x   s   rJ   )ZtkinterZidlelib.EditorWindowr   r/   Ztkinter.messageboxZ
messageboxr4   Zidlelibr   r   rJ   r   r   r   r   <module>   s   
q                                                                            usr/lib/python3.4/idlelib/__pycache__/ParenMatch.cpython-34.pyc                                     0100644 0000000 0000000 00000014470 13077704335 022673  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T9                 @   s   d  Z  d d l m Z d d l m Z i d d 6d d 6d d	 6Z d
 Z Gd d   d  Z e d k r d d l	 Z	 e	 j
 d d d n  d S)zParenMatch -- An IDLE extension for parenthesis matching.

When you hit a right paren, the cursor should move briefly to the left
paren.  Paren here is used generically; the matching applies to
parentheses, square brackets, and curly braces.
    )HyperParser)idleConf()[]{}d   c               @   sH  e  Z d  Z d Z d d1 g f g Z e j d d  d d d Z e j d d  d	 d
 d d d Z e j	 e j
   d  Z e j d d  d d
 d d d Z d Z d2 Z d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d# d$  Z d% d&   Z d' d(   Z d) d*   Z d+ d,   Z d- d.   Z d/ d0   Z d" S)3
ParenMatcha  Highlight matching parentheses

    There are three supported style of paren matching, based loosely
    on the Emacs options.  The style is select based on the
    HILITE_STYLE attribute; it can be changed used the set_style
    method.

    The supported styles are:

    default -- When a right paren is typed, highlight the matching
        left paren for 1/2 sec.

    expression -- When a right paren is typed, highlight the entire
        expression from the left paren to the right paren.

    TODO:
        - extend IDLE with configuration dialog to change options
        - implement rest of Emacs highlight styles (see below)
        - print mismatch warning in IDLE status window

    Note: In Emacs, there are several styles of highlight where the
    matching paren is highlighted whenever the cursor is immediately
    to the right of a right paren.  I don't know how to do that in Tk,
    so I haven't bothered.
    ZeditShow surrounding parens<<flash-paren>>
extensionsstyledefault
expressionzflash-delaytypeinti  Zhilitebellbool   z<<parenmatch-check-restore>>
<KeyPress><ButtonPress><Key-Return><Key-BackSpace>c             C   sT   | |  _  | j |  _ | j j |  j |  j  d |  _ d |  _ |  j |  j  d  S)Nr   )	editwintextZbindRESTORE_VIRTUAL_EVENT_NAMErestore_eventcounteris_restore_active	set_styleSTYLE)selfr    r$   (/usr/lib/python3.4/idlelib/ParenMatch.py__init__;   s    	
		zParenMatch.__init__c             C   sC   |  j  s? x' |  j D] } |  j j |  j |  q Wd |  _  n  d  S)NT)r    RESTORE_SEQUENCESr   Z	event_addr   )r#   seqr$   r$   r%   activate_restoreG   s    	zParenMatch.activate_restorec             C   sC   |  j  r? x' |  j D] } |  j j |  j |  q Wd |  _  n  d  S)NF)r    r'   r   Zevent_deleter   )r#   r(   r$   r$   r%   deactivate_restoreM   s    	zParenMatch.deactivate_restorec             C   s[   | |  _  | d k r0 |  j |  _ |  j |  _ n' | d k rW |  j |  _ |  j |  _ n  d  S)Nr   r   )r"   create_tag_default
create_tagset_timeout_lastset_timeoutcreate_tag_expressionset_timeout_none)r#   r   r$   r$   r%   r!   S   s    	zParenMatch.set_stylec             C   sW   t  |  j d  j   } | d  k r2 |  j   d  S|  j   |  j |  |  j   d  S)Ninsert)r   r   get_surrounding_bracketswarn_mismatchedr)   r,   r-   )r#   eventindicesr$   r$   r%   flash_paren_event\   s    

zParenMatch.flash_paren_eventc             C   s   |  j  j d  } | t k r" d  St |  j d  } | j   sD d  S| j t | d  } | d  k rt |  j   d  S|  j   |  j	 |  |  j
   d  S)Nz	insert-1cT)r   get_openersr   r   Z
is_in_coder2   r3   r)   r,   r.   )r#   r4   ZcloserZhpr5   r$   r$   r%   paren_closed_eventf   s    

zParenMatch.paren_closed_eventNc             C   s-   |  j  j d  |  j   |  j d 7_ d  S)Nparenr   )r   Z
tag_deleter*   r   )r#   r4   r$   r$   r%   r   v   s    
zParenMatch.restore_eventc             C   s    | |  j  k r |  j   n  d  S)N)r   r   )r#   Ztimer_countr$   r$   r%   handle_restore_timer{   s    zParenMatch.handle_restore_timerc             C   s   |  j  r |  j j   n  d  S)N)BELLr   r   )r#   r$   r$   r%   r3      s    	zParenMatch.warn_mismatchedc             C   s1   |  j  j d | d  |  j  j d |  j  d S)z'Highlight the single paren that matchesr:   r   N)r   tag_add
tag_configHILITE_CONFIG)r#   r5   r$   r$   r%   r+      s    zParenMatch.create_tag_defaultc             C   sk   |  j  j | d  d	 k r- | d d } n
 | d } |  j  j d | d |  |  j  j d |  j  d S)
zHighlight the entire expressionr   r   r   r	   z+1cr:   r   N)r   r   r	   )r   r7   r=   r>   r?   )r#   r5   Z
rightindexr$   r$   r%   r/      s
    
z ParenMatch.create_tag_expressionc             C   sP   |  j  d 7_  |  |  j  |  j j d  d d  } |  j j j t | |  d S)zSHighlight will remain until user input turns it off
        or the insert has movedr   r1   c             S   sE   | | j  j d  k r( | j |  n | j j j t |  |   d  S)Nr1   )r   indexr;   r   
text_frameafterCHECK_DELAY)callmer#   cr@   r$   r$   r%   rD      s    z+ParenMatch.set_timeout_none.<locals>.callmeN)r   r   r@   r   rA   rB   rC   )r#   rD   r$   r$   r%   r0      s    	zParenMatch.set_timeout_nonec             C   s;   |  j  d 7_  |  j j j |  j |  |  j  d d   d S)z7The last highlight created will be removed after .5 secr   c             S   s   |  j  |  S)N)r;   )r#   rE   r$   r$   r%   <lambda>   s    z-ParenMatch.set_timeout_last.<locals>.<lambda>N)r   r   rA   rB   FLASH_DELAY)r#   r$   r$   r%   r-      s    zParenMatch.set_timeout_last)r   r   )r   r   r   r   )__name__
__module____qualname____doc__Zmenudefsr   Z	GetOptionr"   rG   ZGetHighlightZCurrentThemer?   r<   r   r'   r&   r)   r*   r!   r6   r9   r   r;   r3   r+   r/   r0   r-   r$   r$   r$   r%   r      s4   	 	
r   __main__Nz!idlelib.idle_test.test_parenmatch	verbosity   )rK   Zidlelib.HyperParserr   Zidlelib.configHandlerr   r8   rC   r   rH   Zunittestmainr$   r$   r$   r%   <module>   s                                                                                                                                                                                                           usr/lib/python3.4/idlelib/__pycache__/PathBrowser.cpython-34.pyc                                    0100644 0000000 0000000 00000007733 13077704335 023115  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T'                 @   s   d  d l  Z  d  d l Z d  d l Z d  d l m Z d  d l m Z m Z d  d l	 m
 Z
 Gd d   d e  Z Gd d   d e  Z Gd	 d
   d
 e  Z d d   Z e d k r d  d l m Z e d d d d d d  d l m Z e e  n  d S)    N)TreeItem)ClassBrowserModuleBrowserTreeItem)PyShellFileListc               @   s7   e  Z d  Z d d d  Z d d   Z d d   Z d S)	PathBrowserFc             C   s   | |  _  |  j |  d S)zG
        _htest - bool, change box location when running htest
        N)_htestinit)selfflistr    r   )/usr/lib/python3.4/idlelib/PathBrowser.py__init__   s    	zPathBrowser.__init__c             C   s$   |  j  j d  |  j  j d  d  S)NzPath Browser)topZwm_titleZwm_iconname)r	   r   r   r   settitle   s    zPathBrowser.settitlec             C   s   t    S)N)PathBrowserTreeItem)r	   r   r   r   rootnode   s    zPathBrowser.rootnodeN)__name__
__module____qualname__r   r   r   r   r   r   r   r   
   s   r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)r   c             C   s   d S)Nzsys.pathr   )r	   r   r   r   GetText   s    zPathBrowserTreeItem.GetTextc             C   s7   g  } x* t  j D] } t |  } | j |  q W| S)N)syspathDirBrowserTreeItemappend)r	   sublistdiritemr   r   r   
GetSubList   s
    zPathBrowserTreeItem.GetSubListN)r   r   r   r   r   r   r   r   r   r      s   r   c               @   sO   e  Z d  Z g  d d  Z d d   Z d d   Z d d   Z d	 d
   Z d S)r   c             C   s   | |  _  | |  _ d  S)N)r   packages)r	   r   r   r   r   r   r   (   s    	zDirBrowserTreeItem.__init__c             C   s#   |  j  s |  j S|  j  d d Sd  S)N   z	: package)r   r   )r	   r   r   r   r   ,   s    	zDirBrowserTreeItem.GetTextc             C   s@  y t  j |  j p t  j  } Wn t k
 r7 g  SYn Xg  } x` | D]X } t  j j |  j |  } |  j |  rE t  j j |  } | j	 | | | f  qE qE W| j
   g  } x= | D]5 \ } } } t | |  j | g  } | j	 |  q WxH |  j |  D]7 \ } } t t  j j |  j |   } | j	 |  qW| S)N)oslistdirr   curdirOSErrorr   joinispackagedirnormcaser   sortr   r   listmodulesr   )r	   namesr   namefileZnnr   r   r   r   r   r   2   s&    	
zDirBrowserTreeItem.GetSubListc             C   s;   t  j j |  s d St  j j | d  } t  j j |  S)Nr   z__init__.py)r!   r   isdirr%   exists)r	   r,   r   r   r   r   r&   G   s    zDirBrowserTreeItem.ispackagedirc       
      C   s  i  } t  j j d  d   } | t  j j d  d   7} | t  j j d  d   7} g  } x | D] } t |  } x | d  d   D]z } t j j |  } | | d   | k r | d  |  }	 |	 | k r d  | |	 <| j	 | | f  | j
 |  q q q Wq] W| j   | S)N)	importlib	machineryEXTENSION_SUFFIXESSOURCE_SUFFIXESBYTECODE_SUFFIXESlenr!   r   r'   r   remover(   )
r	   ZallnamesmodulessuffixessortedZsuffir+   Znormed_nameZmod_namer   r   r   r)   M   s"    

zDirBrowserTreeItem.listmodulesN)r   r   r   r   r   r   r&   r)   r   r   r   r   r   &   s
   r   c             C   s*   t  |   } t | d d |  j   d  S)Nr   T)r   r   Zmainloop)parentr
   r   r   r   _path_browser`   s    r;   __main__)mainz"idlelib.idle_test.test_pathbrowser	verbosity   exitF)run)r!   r   importlib.machineryr/   Zidlelib.TreeWidgetr   Zidlelib.ClassBrowserr   r   Zidlelib.PyShellr   r   r   r   r;   r   Zunittestr=   Zidlelib.idle_test.htestrA   r   r   r   r   <module>   s   :                                     usr/lib/python3.4/idlelib/__pycache__/Percolator.cpython-34.pyc                                     0100644 0000000 0000000 00000010020 13077704335 022746  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sl   d  d l  m Z d  d l m Z Gd d   d  Z d d   Z e d k rh d  d l m Z e e  n  d	 S)
    )WidgetRedirector)	Delegatorc               @   s^   e  Z d  Z d d   Z d d   Z d d d  Z d d d	  Z d
 d   Z d d   Z d S)
Percolatorc             C   sw   | |  _  t |  |  _ t |  |  _ |  _ |  j j d |  j  |  j _ |  j j d |  j  |  j _ g  |  _	 d  S)Ninsertdelete)
textr   redirr   topbottomregisterr   r   filters)selfr    r   (/usr/lib/python3.4/idlelib/Percolator.py__init__   s    	zPercolator.__init__c             C   sn   x& |  j  |  j k	 r( |  j |  j   q Wd  |  _  |  j j d   d  |  _ |  j j   d  |  _ d  |  _ d  S)N)r	   r
   removefiltersetdelegater   closer   )r   r   r   r   r      s    	 	 	zPercolator.closeNc             C   s   |  j  j | | |  d  S)N)r	   r   )r   indexcharsZtagsr   r   r   r      s    zPercolator.insertc             C   s   |  j  j | |  d  S)N)r	   r   )r   Zindex1Zindex2r   r   r   r      s    zPercolator.deletec             C   sG   t  | t  s t  | j d  k s* t  | j |  j  | |  _ d  S)N)
isinstancer   AssertionErrordelegater   r	   )r   filterr   r   r   insertfilter   s    zPercolator.insertfilterc             C   s   t  | t  s t  | j d  k	 s* t  |  j } | | k r[ | j |  _ | j d   n[ x; | j | k	 r | |  j k	 s t  | j   | j } q^ W| j | j  | j d   d  S)N)r   r   r   r   r	   r   r
   Z
resetcache)r   r   fr   r   r   r   &   s    	
zPercolator.removefilter)	__name__
__module____qualname__r   r   r   r   r   r   r   r   r   r   r      s   	r   c                s~  d d  l  } d d  l } Gd d   d t  } | j   } | j d  t t t | j d |  j	      \ } } } } | j	 d | | d f  | j
 |  }	 t |	    | d   | d	       f d
 d   }
     f d d   } |	 j   | j    | j | d d d |
 d  } | j   | j    | j | d d d | d  } | j   | j   d  S)Nr   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)z_percolator.<locals>.Tracerc             S   s   | |  _  t j |  d   d  S)N)namer   r   )r   r   r   r   r   r   :   s    	z$_percolator.<locals>.Tracer.__init__c             W   s'   t  |  j d |  |  j j |   d  S)Nz: insert)printr   r   r   )r   argsr   r   r   r   =   s    z"_percolator.<locals>.Tracer.insertc             W   s'   t  |  j d |  |  j j |   d  S)Nz: delete)r    r   r   r   )r   r!   r   r   r   r   @   s    z"_percolator.<locals>.Tracer.deleteN)r   r   r   r   r   r   r   r   r   r   Tracer9   s   r"   zTest Percolatorz[x+]z+%d+%d   t1t2c                  sb    j    d k r/  j d    j   n/  j    d k r^  j d    j   n  d  S)Nr      )getsetr   r   r   )pr$   var1r   r   toggle1L   s    z_percolator.<locals>.toggle1c                  sb    j    d k r/  j d    j   n/  j    d k r^  j d    j   n  d  S)Nr   r&   )r'   r(   r   r   r   )r)   r%   var2r   r   toggle2T   s    z_percolator.<locals>.toggle2r   ZTracer1ZcommandZvariableZTracer2)Ztkinterrer   ZTktitlelistmapintsplitZgeometryZTextr   ZpackZIntVarZCheckbuttonZmainloop)parentZtkr.   r"   rootwidthZheightxyr   r+   r-   Zcb1Zcb2r   )r)   r$   r%   r*   r,   r   _percolator6   s*    
3
!
!
r9   __main__)runN)	Zidlelib.WidgetRedirectorr   Zidlelib.Delegatorr   r   r9   r   Zidlelib.idle_test.htestr;   r   r   r   r   <module>   s   20                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                usr/lib/python3.4/idlelib/__pycache__/PyParse.cpython-34.pyc                                        0100644 0000000 0000000 00000026427 13077704335 022241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TP                 @   s  d  d l  Z  d  d l Z d  d l m Z d  d l m Z e d  \ Z Z Z	 Z
 Z e  j d e  j e  j B j Z e  j d e  j  j Z e  j d e  j e  j B j Z e  j d e  j  j Z e  j d	 e  j  j Z e  j d
 e  j  j Z Gd d   d e  Z Gd d   d  Z d S)    N)Mapping)partial   z
    ^
    [ \t]*
    (?: while
    |   else
    |   def
    |   return
    |   assert
    |   break
    |   class
    |   continue
    |   elif
    |   try
    |   except
    |   raise
    |   import
    |   yield
    )
    \b
z'
    [ \t]*
    (?: \# \S .* )?
    \n
aK  
    \""" [^"\\]* (?:
                     (?: \\. | "(?!"") )
                     [^"\\]*
                 )*
    (?: \""" )?

|   " [^"\\\n]* (?: \\. [^"\\\n]* )* "?

|   ''' [^'\\]* (?:
                   (?: \\. | '(?!'') )
                   [^'\\]*
                )*
    (?: ''' )?

|   ' [^'\\\n]* (?: \\. [^'\\\n]* )* '?
zM
    [ \t]*
    [^\s#\\]    # if we match, m.end()-1 is the interesting char
z_
    \s*
    (?: return
    |   break
    |   continue
    |   raise
    |   pass
    )
    \b
z
    [^[\](){}#'"\\]+
c               @   sU   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d d  Z d
 S)StringTranslatePseudoMappingaT  Utility class to be used with str.translate()

    This Mapping class wraps a given dict. When a value for a key is
    requested via __getitem__() or get(), the key is looked up in the
    given dict. If found there, the value from the dict is returned.
    Otherwise, the default value given upon initialization is returned.

    This allows using str.translate() to make some replacements, and to
    replace all characters for which no replacement was specified with
    a given character instead of leaving them as-is.

    For example, to replace everything except whitespace with 'x':

    >>> whitespace_chars = ' \t\n\r'
    >>> preserve_dict = {ord(c): ord(c) for c in whitespace_chars}
    >>> mapping = StringTranslatePseudoMapping(preserve_dict, ord('x'))
    >>> text = "a + b\tc\nd"
    >>> text.translate(mapping)
    'x x x\tx\nx'
    c             C   s4   | |  _  | |  _ | j | d d  } | |  _ d  S)Nc             S   s   | |  |  S)N )key_getZ_defaultr   r   %/usr/lib/python3.4/idlelib/PyParse.pyr   z   s    z3StringTranslatePseudoMapping.__init__.<locals>._get)_non_defaultsZ_default_valuegetr   )selfZnon_defaultsdefault_valuer   r   r   r	   __init__v   s    		z%StringTranslatePseudoMapping.__init__c             C   s   |  j  |  S)N)r   )r   itemr   r   r	   __getitem__~   s    z(StringTranslatePseudoMapping.__getitem__c             C   s   t  |  j  S)N)lenr
   )r   r   r   r	   __len__   s    z$StringTranslatePseudoMapping.__len__c             C   s   t  |  j  S)N)iterr
   )r   r   r   r	   __iter__   s    z%StringTranslatePseudoMapping.__iter__Nc             C   s   |  j  |  S)N)r   )r   r   defaultr   r   r	   r      s    z StringTranslatePseudoMapping.get)	__name__
__module____qualname____doc__r   r   r   r   r   r   r   r   r	   r   a   s   r   c               @   sB  e  Z d  Z d d   Z d d   Z d e d d  Z d d	   Z i  Z e j	 d
 d   d D  e j	 d d   d D  e j	 d d   d D  e
 e d e d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d Z d% d&   Z d Z d' d(   Z d S))Parserc             C   s   | |  _  | |  _ d  S)N)indentwidthtabwidth)r   r   r   r   r   r	   r      s    	zParser.__init__c             C   s>   t  |  d k s( | d d k s( t  | |  _ d |  _ d  S)Nr      
)r   AssertionErrorstrstudy_level)r   sr   r   r	   set_str   s    (	zParser.set_strNc       
      C   sT  |  j  d  } } | s d  St |  } x t d  D] } | j d d |  } | d k  r^ Pn  | j d d |  d } | | | |  } | r | | j    r | j   } Pn  | } q3 W| d  k r | |  } | r | | j    r | j   } n  | S| d } xC | | |  } | rL| j   \ }	 } | |	  sM|	 } qMqPq| S)Nr   z:
r   r   r   )r!   r   rangerfindstartspan)
r   Zis_char_in_string_synchrer!   poslimitZtriesimr#   r   r   r	   find_good_parse_start   s8    
	
zParser.find_good_parse_startc             C   sR   | d k s) |  j  | d d k s) t  | d k rN |  j  | d   |  _  n  d  S)Nr   r   r   )r!   r    )r   lor   r   r	   set_lo   s    )zParser.set_loc             c   s'   |  ] } t  |  t  d   f Vq d S)(N)ord).0cr   r   r	   	<genexpr>   s    zParser.<genexpr>z({[c             c   s'   |  ] } t  |  t  d   f Vq d S))N)r2   )r3   r4   r   r   r	   r5      s    z)}]c             c   s'   |  ] } t  |  t  |  f Vq d  S)N)r2   )r3   r4   r   r   r	   r5      s    z"'\
#r   xc             C   s  |  j  d k r d  Sd |  _  |  j } | j |  j  } | j d d  } | j d d  } | j d d  } | j d d  } | j d d  } t } d } } d g |  _ } | j } d t |  } } x| | k  r| | }	 | d } |	 d k rq n  |	 d k r7| d } | d k r | |  q q n  |	 d	 k rS| d } q n  |	 d
 k rx| r | d } q q n  |	 d k s|	 d k r|	 }
 | | d | d  |
 d k r|
 d }
 n  | } t |
  d } | | } x| | k  r| | }	 | d } |	 d k rqn  | | d | |  |
 k rF| | } Pn  |	 d k r| d } | d k r| d k r| |  n  Pqqn  |	 d k r| | k  st	  | | d k r| d } n  | d } qqqW| d | k rt
 } q t } q n  |	 d k r5| j d |  } | d k s t	  q n  |	 d k sGt	  | | k  sYt	  | | d k r| d } | d | k rt } qn  | d } q W| t
 k r| t k r| d k rt } n  | |  _ | t k | d | k k st	  | d | k r| |  n  d  S)Nr   Zxxxxxxxxr7   ZxxxxZxxz
xr   r   r1   r6   "'      \#r   r   )r"   r!   	translate_tranreplaceC_NONE	goodlinesappendr   r    C_STRING_FIRST_LINEC_STRING_NEXT_LINESfindC_BACKSLASH	C_BRACKETcontinuation)r   r!   rI   levelZlnorB   Z	push_goodr,   nchZquoteZfirstlnowr   r   r	   _study1   s    		
	



"






	
		"zParser._study1c             C   s   |  j    |  j S)N)rN   rI   )r   r   r   r	   get_continuation_typeh  s    
zParser.get_continuation_typec             C   s  |  j  d k r d  S|  j   d |  _  |  j |  j } } t |  d } t |  } x| | r | sj t  | } x@ t | | d | |  D]# } | j d d | d  d } q Wt | |  r | d } qX PqX W| d k r | d k s t  | } n  | | |  _	 |  _
 d } g  } | j }	 | d f g }
 xu| | k  rt | | |  } | r| j   } | d } x* | | k r| | d k r| d } qrW| | k r| | } n  | } | | k rPqn  | | } | d k r|	 |  |
 j | t |  f  | } | d } q5n  | d k rh| r9| d =n  | } | d } |
 j | t |  f  q5n  | d	 k s| d
 k r|
 j | t |  d f  | } t | | |  j   } |
 j | t |  f  q5n  | d k rM|
 j | t |  d f  | j d | |  d } | d k s.t  |
 j | t |  f  q5n  | d k s_t  | d } | | k  s{t  | | d k r| | | } n  | d } q5W| |  _ | r| d |  _ n  t |
  |  _ d  S)Nr:   r   r   r    z 	
z([{z)]}r8   r9   r=   r<   r   r   )r"   rN   r!   rB   r   r    r%   r&   _junkre
stmt_startstmt_endrC   _chew_ordinaryreend_match_stringrerF   lastchlastopenbracketpostuplestmt_bracketing)r   r!   rB   r,   pqZnothingrW   stackZ
push_stackZ
bracketingr-   ZnewprL   r   r   r	   _study2}  s    
		"!		






	zParser._study2c             C   s  |  j    |  j t k s t  |  j } |  j } t |  } | j d d |  d } } | d } x | | k  r t | |  } | r | j	   d } d } Pqg | j
 d |  d } } qg W| } } x | | d k r | d } q W|  j } t | | |  j |  j   | S)Nr   r   r   z 	)r^   rI   rH   r    rX   r!   r   r&   _itemrerU   rF   r   
expandtabsr   )r   jr!   rK   Zorigir,   r-   Zextrar   r   r	   compute_bracket_indent  s&    
		

	zParser.compute_bracket_indentc             C   s#   |  j    |  j } | d | d S)Nr   r:   r   )rN   rB   )r   rB   r   r   r	   get_num_lines_in_stmt	  s    
	zParser.get_num_lines_in_stmtc             C   s  |  j    |  j t k s t  |  j } |  j } x | | d k rQ | d } q4 W| } | j d |  d } d } } x| | k  r| | } | d k r | d } | d } q{ | d k r | r | d } n  | d } q{ | d k s | d k rt | | |  j   } q{ | d	 k r#Pq{ | d k ry| d
 k ry| d k s[| | d d k ry| | d d
 k ryd } Pq{ | d } q{ W| r| d } t	 j
 d | | |   d  k } n  | s| } x! | | d k r| d } qWn  t | |  j |  j |  j   d S)Nz 	r   r   r   z([{z)]}r8   r9   r=   =z=<>!z\s*\\z 	
)r^   rI   rG   r    r!   rR   rF   rV   rU   rematchr   r`   r   )r   r!   r,   startposendposfoundrJ   rL   r   r   r	   compute_backslash_indent  sJ    
		


 
%zParser.compute_backslash_indentc             C   sg   |  j    |  j |  j } } | } |  j } x* | | k  rX | | d k rX | d } q/ W| | |  S)Nz 	r   )r^   rR   rS   r!   )r   r,   rK   ra   r!   r   r   r	   get_base_indent_stringG  s    
	zParser.get_base_indent_stringc             C   s   |  j    |  j d k S)N:)r^   rW   )r   r   r   r	   is_block_openerR  s    
zParser.is_block_openerc             C   s#   |  j    t |  j |  j  d  k	 S)N)r^   _closerer!   rR   )r   r   r   r	   is_block_closerX  s    
zParser.is_block_closerc             C   s   |  j    |  j S)N)r^   rX   )r   r   r   r	   get_last_open_bracket_pos_  s    
z Parser.get_last_open_bracket_posc             C   s   |  j    |  j S)N)r^   rZ   )r   r   r   r	   get_last_stmt_bracketingh  s    
zParser.get_last_stmt_bracketing)r   r   r   r   r$   r)   r.   r0   r?   updater   r2   rN   rO   r^   rb   rd   rk   rl   rn   rp   rX   rq   rZ   rr   r   r   r   r	   r      s.   3	m	5r   )rf   syscollectionsr   	functoolsr   r%   rA   rG   rD   rE   rH   compileVERBOSE	MULTILINEsearchr)   rg   rQ   DOTALLrV   r_   ro   rT   r   r   r   r   r   r	   <module>   s   	*                                                                                                                                                                                                                                         usr/lib/python3.4/idlelib/__pycache__/PyShell.cpython-34.pyc                                        0100644 0000000 0000000 00000136217 13077704335 022235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s~  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l Z d  d l	 Z	 d  d l
 Z
 d  d l Z d  d l Z d  d l Z d  d l m Z d  d l m Z m Z y d  d l TWn2 e k
 re d d e j e j d  Yn Xd  d l j Z d  d l m Z m Z d  d	 l m Z d  d
 l  m! Z! d  d l" m# Z# d  d l$ m% Z% d  d l& m' Z' d  d l( m) Z) d  d l( m* Z* d  d l( m+ Z+ d  d l( m, Z, d  d l( m- Z- d Z. d  Z/ e j a0 d  d l1 Z1 d d d  Z2 d d d d  Z3 d a4 d d   Z5 e5 d  d e j6 d d  Z7 e7 e _6 Gd d   d e  Z8 Gd d    d  e  Z9 Gd! d"   d" e!  Z: Gd# d$   d$ e#  Z; Gd% d&   d& e* j<  Z= Gd' d(   d( e  Z> Gd) d*   d* e%  Z? Gd+ d,   d, e j@  ZA Gd- d.   d. eA  ZB Gd/ d0   d0 eA  ZC d1 ZD d2 d3   ZE eF d4 k rpe jG d4 e jG d* <eE   n  e5 d5  d S)6    N)InteractiveInterpreter)python_versionsystem)*zJ** IDLE can't import Tkinter.
Your Python may not be configured for Tk. **file   )EditorWindowfixwordbreaks)FileList)ColorDelegator)UndoDelegator)OutputWindow)idleConf)idlever)rpc)Debugger)RemoteDebugger)macosxSupportz	127.0.0.1c             C   sy   d } | d | | f 7} | d k r; t  j | |  } n  | j   } | r^ | d | 7} n  | d | j |  f 7} | S)zFormat warnings the IDLE way.z!
Warning (from warnings module):
z  File "%s", line %s
Nz    %s
z%s: %s
)	linecachegetlinestrip__name__)messagecategoryfilenamelinenolines r   %/usr/lib/python3.4/idlelib/PyShell.pyidle_formatwarning3   s    r    c             C   sg   | d k r t  } n  y3 | j t |  | | | d |  | j d  Wn t t f k
 rb Yn Xd S)a   Show Idle-format warning (after replacing warnings.showwarning).

    The differences are the formatter called, the file=None replacement,
    which can be None, the capture of the consequence AttributeError,
    and the output of a hard-coded prompt.
    Nr   z>>> )warning_streamwriter    AttributeErrorOSError)r   r   r   r   r   r   r   r   r   idle_showwarning@   s    		r%   c             C   sL   |  r* t  d k rH t j a  t t _ qH n t  d k	 rH t  t _ d a  n  d S)z>Replace warning.showwarning with idle_showwarning, or reverse.N)_warnings_showwarningwarningsshowwarningr%   )Zcapturer   r   r   capture_warningsS   s    		r)   Tc             C   s{   t  j } i  } xN t |  D]@ } | d d  | d d  d k r | j |  | | <q q W| |   | j |  d S)ao  Extend linecache.checkcache to preserve the <pyshell#...> entries

    Rather than repeating the linecache code, patch it to save the
    <pyshell#...> entries, call the original linecache.checkcache()
    (skipping them), and then restore the saved entries.

    orig_checkcache is bound at definition time to the original
    method, allowing it to be patched.
    Nr   z<>)r   cachelistpopupdate)r   Zorig_checkcacher+   savekeyr   r   r   extended_linecache_checkcacheb   s    	$
r1   c               @   s   e  Z d  Z d Z d d   Z d' d( d) d* d+ d, g Z d d d  Z d d   Z d d d  Z d d d  Z	 d d   Z
 d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d S)-PyShellEditorWindowz6Regular text edit window in IDLE, supports breakpointsc             G   s   g  |  _  t j |  |  |  j j d |  j  |  j j d |  j  |  j j d |  j j  t	 j
 j t j   d  |  _ |  j j |  d d  } |  j j |  |  j j r |  j   n  |  j   d  S)Nz<<set-breakpoint-here>>z<<clear-breakpoint-here>>z<<open-python-shell>>zbreakpoints.lstc             S   s   | j    |    d  S)N)restore_file_breaks)Zold_hookselfr   r   r   filename_changed_hook   s    
z;PyShellEditorWindow.__init__.<locals>.filename_changed_hook)breakpointsr   __init__textbindset_breakpoint_hereclear_breakpoint_hereflist
open_shellospathjoinr   ZGetUserCfgDirbreakpointPathioZfilename_change_hookZset_filename_change_hookr   r3   color_breakpoint_text)r4   argsr5   r   r   r   r7   |   s    		zPyShellEditorWindow.__init__Cut<<cut>>rmenu_check_cutCopy<<copy>>rmenu_check_copyPaste	<<paste>>rmenu_check_pasteNSet Breakpoint<<set-breakpoint-here>>Clear Breakpoint<<clear-breakpoint-here>>Tc             C   s[   | r0 t  j d d d  } t  j | d  } n i d d 6d d 6} |  j j d |  d	 S)
z,Turn colorizing of breakpoint text on or offmainThemenamebreak 
foreground
backgroundBREAKN)r   	GetOptionGetHighlightr8   Z
tag_config)r4   ZcolorthemeZcfgr   r   r   rC      s
    z)PyShellEditorWindow.color_breakpoint_textc             C   s   |  j  } |  j j } | j d d | d | d  y |  j j |  } Wn" t k
 rn |  j j |  Yn Xy& |  j j	 j
 j } | j | |  Wn Yn Xd  S)NrY   z%d.0r   )r8   rB   r   tag_addr6   index
ValueErrorappendr<   pyshellinterpdebuggerr:   )r4   r   r8   r   idebugr   r   r   set_breakpoint   s    	z"PyShellEditorWindow.set_breakpointc             C   sU   |  j  } |  j j } | s) | j   d  St t | j d    } |  j |  d  S)Ninsert)r8   rB   r   bellintfloatr^   rf   )r4   eventr8   r   r   r   r   r   r:      s    	
z'PyShellEditorWindow.set_breakpoint_herec             C   s   |  j  } |  j j } | s) | j   d  St t | j d    } y |  j j |  Wn Yn X| j	 d d d  y& |  j
 j j j } | j | |  Wn Yn Xd  S)Nrg   rY   zinsert linestartzinsert lineend +1char)r8   rB   r   rh   ri   rj   r^   r6   remove
tag_remover<   ra   rb   rc   r;   )r4   rk   r8   r   r   re   r   r   r   r;      s"    	
z)PyShellEditorWindow.clear_breakpoint_herec          	   C   s   |  j  r |  j } |  j j } | s2 | j   d  Sg  |  _  | j d d t  y# |  j j j	 j
 } | j |  Wq Yq Xn  d  S)NrY   z1.0)r6   r8   rB   r   rh   rm   ZENDr<   ra   rb   rc   clear_file_breaks)r4   r8   r   re   r   r   r   rn      s    		
	z%PyShellEditorWindow.clear_file_breaksc             C   sb  |  j  } |  j j } y+ t |  j d   } | j   } Wd QXWn t k
 rZ g  } Yn Xy t |  j d  v } x1 | D]) } | j | d  sz | j |  qz qz W|  j	   |  j  } | r | j | d t
 |  d  n  Wd QXWnr t k
 r]} zR t |  j d d  sKd |  j _ t j d	 d
 d d t
 |  d |  j  n  WYd d } ~ Xn Xd S)z#Save breakpoints when file is savedrNw=
breakpoint_error_displayedFTtitlez
IDLE Errorr   z$Unable to update breakpoint list:
%sparent)r6   rB   r   openrA   	readlinesr$   
startswithr"   update_breakpointsstrgetattrrootrs   tkMessageBox	showerrorr8   )r4   Zbreaksr   fplinesZnew_filer   errr   r   r   store_file_breaks   s.    	
	,z%PyShellEditorWindow.store_file_breaksc             C   s   |  j  j   |  j d  k r  d  S|  j j } | d  k r< d  St j j |  j  r t |  j d   } | j	   } Wd  QXxe | D]Z } | j
 | d  r t | t |  d d    } x | D] } |  j |  q Wq q Wn  d  S)Nro   rq   r   )r8   r.   rB   r   r>   r?   isfilerA   rv   rw   rx   evallenrf   )r4   r   r   r   r   Zbreakpoint_linenumbersZbreakpoint_linenumberr   r   r   r3   	  s     z'PyShellEditorWindow.restore_file_breaksc             C   s4   |  j  } | j d  } |  j |  } | |  _ d S)z3Retrieves all the breakpoints in the current windowrY   N)r8   Z
tag_rangesranges_to_linenumbersr6   )r4   r8   rangesZlinenumber_listr   r   r   ry     s    	z&PyShellEditorWindow.update_breakpointsc             C   s   g  } x t  d t |  d  D]f } t t | | j   } t t | | d j   } x' | | k  r | j |  | d 7} q^ Wq W| S)Nr      r   )ranger   ri   rj   stringr`   )r4   r   r   r^   r   endr   r   r   r   !  s    z)PyShellEditorWindow.ranges_to_linenumbersc             C   s   |  j    t j |   d S)z7Extend base method - clear breaks when module is closedN)rn   r   _close)r4   r   r   r   r   2  s    
zPyShellEditorWindow._close)rE   rF   zrmenu_check_cut)rH   rI   rJ   )rK   rL   zrmenu_check_paste)NNN)rN   rO   N)rP   rQ   N)r   
__module____qualname____doc__r7   Zrmenu_specsrC   rf   r:   r;   rn   r   r3   ry   r   r   r   r   r   r   r2   y   s$   			/r2   c               @   s1   e  Z d  Z d Z e Z d Z d d d  Z d S)PyShellFileListz8Extend base class: IDLE supports a shell and breakpointsNc             C   sQ   |  j  r |  j  j j   n. t |   |  _  |  j  rJ |  j  j   sJ d  Sn  |  j  S)N)ra   topwakeupPyShellbegin)r4   rk   r   r   r   r=   A  s    		zPyShellFileList.open_shell)r   r   r   r   r2   r   ra   r=   r   r   r   r   r   8  s   r   c               @   sF   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 S)ModifiedColorDelegatorz8Extend base class: colorizer for the shell window itselfc             C   s   t  j |   |  j   d  S)N)r   r7   LoadTagDefs)r4   r   r   r   r7   O  s    zModifiedColorDelegator.__init__c             C   s7   |  j  d d d  |  j d d d  t j |   d  S)NZTODOz1.0iomarkZSYNC)rm   r]   r   recolorize_main)r4   r   r   r   r   S  s    z&ModifiedColorDelegator.recolorize_mainc             C   s   t  j |   t j d d d  } |  j j i i d  d 6d  d 6d 6t j | d  d 6t j | d  d 6t j | d	  d	 6 d  S)
NrR   rS   rT   rX   rW   stdinstdoutstderrconsole)r   r   r   rZ   tagdefsr.   r[   )r4   r\   r   r   r   r   X  s    z"ModifiedColorDelegator.LoadTagDefsc             C   s+   x$ |  j  D] } |  j | d d  q
 Wd  S)Nr   r   )r   rm   )r4   tagr   r   r   removecolorsb  s    z#ModifiedColorDelegator.removecolorsN)r   r   r   r   r7   r   r   r   r   r   r   r   r   L  s
   
r   c               @   s4   e  Z d  Z d Z d d d  Z d d d  Z d S)ModifiedUndoDelegatorz;Extend base class: forbid insert/delete before the I/O markNc             C   s\   y- |  j  j | d d  r, |  j  j   d  SWn t k
 rA Yn Xt j |  | | |  d  S)N<r   )delegatecomparerh   TclErrorr   rg   )r4   r^   charstagsr   r   r   rg   j  s    zModifiedUndoDelegator.insertc             C   sY   y- |  j  j | d d  r, |  j  j   d  SWn t k
 rA Yn Xt j |  | |  d  S)Nr   r   )r   r   rh   r   r   delete)r4   Zindex1Zindex2r   r   r   r   s  s    zModifiedUndoDelegator.delete)r   r   r   r   rg   r   r   r   r   r   r   g  s   	r   c               @   s   e  Z d  Z d d   Z d S)MyRPCClientc             C   s
   t   d S)z0Override the base class - just re-raise EOFErrorN)EOFError)r4   r   r   r   
handle_EOF  s    zMyRPCClient.handle_EOFN)r   r   r   r   r   r   r   r   r   }  s   r   c               @   s  e  Z d  Z d d   Z d Z d Z d Z d d   Z d d   Z d d	   Z	 d
 d d  Z
 d d   Z d d   Z d d   Z d d   Z d
 d d  Z d Z d d   Z d Z d d   Z d d   Z d d   Z d d    Z d! Z d" d#   Z d d$ d%  Z d& d'   Z d( d)   Z d* d+   Z d d, d-  Z d. d/   Z d0 d1   Z d2 d3   Z  d4 d5   Z! d6 d7   Z" d8 d9   Z# d: d;   Z$ d< d=   Z% d S)>ModifiedInterpreterc             C   sf   | |  _  t j d j } t j |  d | d  |  _ d |  _ d  |  _ t	 |  _
 |  j j j |  _ d  S)N__main__localsF)	tkconsolesysmodules__dict__r   r7   save_warnings_filters
restartingsubprocess_arglistPORTportcompilecompilerflagsoriginal_compiler_flags)r4   r   r   r   r   r   r7     s    					zModifiedInterpreter.__init__Nc             C   s:   |  j  d  k r! |  j   |  _  n  t j |  j   |  _ d  S)N)r   build_subprocess_arglist
subprocessPopen
rpcsubproc)r4   r   r   r   spawn_subprocess  s    z$ModifiedInterpreter.spawn_subprocessc             C   s   |  j  d k s t d   d d   t j D } t j d d d d d	 d
 d } t d k rn d | f } n d | f } t j g | d | t |  j   g S)Nr   z/Socket should have been assigned a port number.c             S   s   g  |  ] } d  |  q S)z-Wr   ).0r   r   r   r   
<listcomp>  s   	 z@ModifiedInterpreter.build_subprocess_arglist.<locals>.<listcomp>rR   Generalzdelete-exitfuncdefaultFtypeboolzidlelib.PyShellz&__import__('idlelib.run').run.main(%r)z__import__('run').main(%r)z-c)	r   AssertionErrorr   warnoptionsr   rZ   r   
executablerz   )r4   rp   Z	del_exitfZcommandr   r   r   r     s    	z,ModifiedInterpreter.build_subprocess_arglistc             C   s  t  |  j f } xk t d  D]O } t j |  y t |  |  _ PWq t k
 rj } z WYd  d  } ~ Xq Xq W|  j   d  S|  j j	 j
   d |  _ t d k r |  j j	 j t j t j d  n  |  j   |  j j	 j d  y |  j j   Wn6 t j k
 r*} z |  j   d  SWYd  d  } ~ Xn X|  j j d |  j  |  j j d |  j j  |  j j d |  j j  |  j j d |  j j  |  j j d	 |  j j  |  j j d
 t  |  j j d |   |  j d d  |  j   |  j S)N   r   r   
   r   r   r   r   r<   r   rb   with_cwdT)HOSTr   r   timeZsleepr   rpccltr$   display_port_binding_errorlistening_sockZgetsocknamer   Z
setsockoptsocketZ
SOL_SOCKETZSO_REUSEADDRr   Z
settimeoutaccepttimeoutdisplay_no_subprocess_errorregisterr   r   r   r   r<   r   transfer_pathpoll_subprocess)r4   Zaddrrd   r   r   r   r   start_subprocess  s>    



z$ModifiedInterpreter.start_subprocessFc             C   s  |  j  r |  j Sd |  _  |  j   } | rM y t j |  j  WqM YqM Xn  |  j j   |  j   |  j } | j } d | _ |  j	   y |  j j
   Wn6 t j k
 r } z |  j   d  SWYd  d  } ~ Xn X|  j d |  | j   | j j d d  | r | j d  | j   n  t | j  d d d	 } | j | d
 |  | j j d d  | j j d d  | j   | rt j |  j  } | j   n  |  j |  j j _ d |  _  |  j S)NTFr   r   zend-1crr      r   rq   z	 RESTART restartleft)r   r   getdebuggerr   Zclose_subprocess_debuggercloseterminate_subprocessr   	executingr   r   r   r   r   r   stop_readliner8   r   r"   
showpromptri   widthmark_setmark_gravityZrestart_subprocess_debuggerload_breakpointsr   r   r   r   )r4   r   re   r   Zwas_executingr   ZhalfbarZguir   r   r   restart_subprocess  sJ    		
			



	z&ModifiedInterpreter.restart_subprocessc             C   s   |  j  j d d f  i   d  S)NexecZinterrupt_the_server)r   Z
remotecall)r4   r   r   r   Z__request_interrupt  s    z'ModifiedInterpreter.__request_interruptc             C   s   t  j d |  j  j   d  S)Ntarget)	threadingZThread'_ModifiedInterpreter__request_interruptstart)r4   r   r   r   interrupt_subprocess  s    z(ModifiedInterpreter.interrupt_subprocessc             C   s   |  j  d  k	 r( |  j j j |  j   n  y |  j j j   Wn t k
 rP Yn Xy |  j j   Wn t k
 rv Yn X|  j   d |  j _	 d  |  _ d  S)NF)
_afteridr   r8   Zafter_cancelr   r   r   r#   r   r   )r4   r   r   r   kill_subprocess  s    
z#ModifiedInterpreter.kill_subprocessc             C   sX   y |  j  j   Wn t k
 r) d SYn+ Xy |  j  j   Wn t k
 rS d SYn Xd S)z"Make sure subprocess is terminatedN)r   killr$   wait)r4   r   r   r   r     s    	z(ModifiedInterpreter.terminate_subprocessc             C   sC   | r" d g } | j  t j  n	 t j } |  j d | f  d  S)NrV   zRif 1:
        import sys as _sys
        _sys.path = %r
        del _sys
        
)extendr   r?   
runcommand)r4   r   r?   r   r   r   r   #  s    		z!ModifiedInterpreter.transfer_pathc             C   s  |  j  } | d  k r d  Sy | j |  j d d } Wn; t t t f k
 rr |  j j r^ d  Sd  } |  j   Yn X| rp|  j j	   d  |  _ | \ } } |  j j
 } | d k r | d  k	 rGt t |  d | qGnl | d k r	|  j j d  rG|  j   qGn> | d k rGd } t | | d t j t | | d | n  y |  j j   Wqpt k
 rlYqpXn  |  j j s|  j j j |  j j |  j  |  _ n  d  S)	Nr   g?ZOKr   Z	EXCEPTIONz<<toggle-jit-stack-viewer>>ERRORz/PyShell.ModifiedInterpreter: Subprocess ERROR:
)r   Zpollresponse
active_seqr   r$   KeyboardInterruptr   closingr   resetoutputr   printreprgetvarremote_stack_viewerr   
__stderr__endexecutingr#   r8   afterpollintervalr   r   )r4   ZcltresponseZhowZwhatr   errmsgr   r   r   r   2  s@    		z#ModifiedInterpreter.poll_subprocessc             C   s   | |  _  d  S)N)rc   )r4   rc   r   r   r   setdebuggerZ  s    zModifiedInterpreter.setdebuggerc             C   s   |  j  S)N)rc   )r4   r   r   r   r   ]  s    zModifiedInterpreter.getdebuggerc             C   s   |  j  j j d |  j  d S)a  Initiate the remote stack viewer from a separate thread.

        This method is called from the subprocess, and by returning from this
        method we allow the subprocess to unblock.  After a bit the shell
        requests the subprocess to open the remote stack viewer which returns a
        static object looking at the last exception.  It is queried through
        the RPC mechanism.

        i,  N)r   r8   r   r   )r4   r   r   r   open_remote_stack_viewer`  s    
z,ModifiedInterpreter.open_remote_stack_viewerc             C   s  d d l  m } |  j j d d d i   } | d  k rK |  j j j   d  S| j |  j |  } d d l m	 } m
 } t |  j j  } t j d d d	  } t j | d
  d } | | d | d d }	 |	 j j d d d d  | |	 j d  |  }
 |
 j   d  S)Nr   )RemoteObjectBrowserr   Zstackviewerr<   )ScrolledCanvasTreeNoderR   rS   rT   ZnormalrX   ZbgZhighlightthicknessexpandr   ZfillZboth)zflist)idlelibr  r   remotequeuer   r|   rh   ZStubObjectTreeItemZidlelib.TreeWidgetr  r  ZToplevelr   rZ   r[   ZframeZpackZcanvasr  )r4   r  Zoiditemr  r  r   r\   rX   ZscZnoder   r   r   r   m  s    z'ModifiedInterpreter.remote_stack_viewerr   c             C   s#   |  j  |  } |  j | |  d S)z1Like runsource() but assumes complete exec sourceN)stuffsourceexecfile)r4   sourcer   r   r   r   
execsource  s    zModifiedInterpreter.execsourcec             C   s   | d k r3 t  j |   } | j   } Wd QXn  y t | | d  } WnX t t f k
 r |  j j   t d d |  j j	 t
 j |  |  |  j j   Yn X|  j |  d S)zExecute an existing fileNr   zB*** Error in script or command!
Traceback (most recent call last):r   )tokenizerv   readr   OverflowErrorSyntaxErrorr   r   r   r   r   showsyntaxerrorr   runcode)r4   r   r  r   coder   r   r   r    s    	zModifiedInterpreter.execfilec             C   s   |  j  |  } d |  _ t j d d  |  _ t j d d d t  t | t  sY t	  z t
 j |  | |  SWd |  j d k	 r |  j t j d d  <d |  _ n  Xd S)zBExtend base class method: Stuff the source in the line cache firstr   Nactionerrorr   )r  morer'   filtersr   filterwarningsSyntaxWarning
isinstancerz   r   r   	runsource)r4   r  r   r   r   r   r    s    		zModifiedInterpreter.runsourcec             C   sS   d |  j  } |  j  d |  _  | j d  } t |  d d | | f t j | <| S)z"Stuff source in the filename cachez<pyshell#%d>r   rr   r   )gidsplitr   r   r+   )r4   r  r   r   r   r   r   r    s
    #zModifiedInterpreter.stuffsourcec             C   s   |  j  d | f  d S)z>Prepend sys.path with file's directory if not already includeda(  if 1:
            _filename = %r
            import sys as _sys
            from os.path import dirname as _dirname
            _dir = _dirname(_filename)
            if not _dir in _sys.path:
                _sys.path.insert(0, _dir)
            del _filename, _sys, _dirname, _dir
            
N)r   )r4   r   r   r   r   prepend_syspath  s    z#ModifiedInterpreter.prepend_syspathc             C   s  |  j  } | j } | j d d d  t j   \ } } } t | d d  pU | pU d } t | d d  pm d } t | d	 d  p d
 }	 |	 d
 k r | d 7} n  | d k r d |	 d }
 n d | d |	 d f }
 | j | |
  | j   |  j d |  | j	   d S)zOverride Interactive Interpreter method: Use Colorizing

        Color the offending position instead of printing it and pointing at it
        with a caret.

        r   z1.0r   msgrV   z<no detail available>r   r   offsetr   ziomark + %d charsz&iomark linestart + %d lines + %d charszSyntaxError: %s
N)
r   r8   rm   r   exc_infor{   Zcolorize_syntax_errorr   r"   r   )r4   r   r   r8   r   valuetbr!  r   r"  posr   r   r   r    s"    		
z#ModifiedInterpreter.showsyntaxerrorc             C   sJ   |  j  j   |  j   t j |   |  j  j d  rF |  j  j   n  d S)z1Extend base class method to reset output properlyz<<toggle-jit-stack-viewer>>N)r   r   checklinecacher   showtracebackr   open_stack_viewer)r4   r   r   r   r(    s
    
z!ModifiedInterpreter.showtracebackc             C   sX   t  j } xH t | j    D]4 } | d  d  | d d   d k r | | =q q Wd  S)Nr   z<>r*   )r   r+   r,   keys)r4   cr0   r   r   r   r'    s    	$z"ModifiedInterpreter.checklinecachec             C   sV   |  j  j r |  j   d S|  j rB |  j j d d | f i   n t | |  j  d S)z*Run the code without invoking the debuggerr   r   r  r   )r   r   display_executing_dialogr   r	  r   r   )r4   r  r   r   r   r     s    
	zModifiedInterpreter.runcommandc             C   s  |  j  j r |  j j   n  |  j   |  j d k	 rW |  j t j d d  <d |  _ n  |  j } zNyw |  j  j	   | r |  j
 d k	 r |  j
 j d d | f i   |  _ n, | r | j | |  j  n t | |  j  Wn t k
 r4|  j  j s-t j d d d d d |  j  j r   q0|  j   n   Yny t rmt d	 d
 |  j  j |  j   |  j  j   n; |  j  j rd |  j  _ t d d
 |  j  j n
 |  j   Yn XWd t sy |  j  j   Wqt k
 rYqXn  Xd S)zOverride base class methodNr   r  zExit?zDo you want to exit altogether?r   Zyesmasterz IDLE internal error in runcode()r   Fr   )r   r   rb   r   r'  r   r'   r  rc   beginexecutingr   Z
asyncqueuer   Zrunr   r   
SystemExitr   r}   Zaskyesnor8   r(  use_subprocessr   r   r   canceledr#   )r4   r  rc   r   r   r   r    sP    
		
zModifiedInterpreter.runcodec             C   s   |  j  j j |  S)zOverride base class method)r   r   r"   )r4   r   r   r   r   r"   (  s    zModifiedInterpreter.writec             C   s    t  j d d d |  j j d  S)NzPort Binding ErroraA  IDLE can't bind to a TCP/IP port, which is necessary to communicate with its Python execution server.  This might be because no networking is installed on this computer.  Run IDLE with the -n command line switch to start without a subprocess and refer to Help/IDLE Help 'Running without a subprocess' for further details.r-  )r}   r~   r   r8   )r4   r   r   r   r   ,  s    z.ModifiedInterpreter.display_port_binding_errorc             C   s    t  j d d d |  j j d  S)NzSubprocess Startup ErrorzIDLE's subprocess didn't make connection.  Either IDLE can't start a subprocess or personal firewall software is blocking the connection.r-  )r}   r~   r   r8   )r4   r   r   r   r   7  s    z/ModifiedInterpreter.display_no_subprocess_errorc             C   s    t  j d d d |  j j d  S)NzAlready executingzYThe Python Shell window is already executing a command; please wait until it is finished.r-  )r}   r~   r   r8   )r4   r   r   r   r,  ?  s    z,ModifiedInterpreter.display_executing_dialog)&r   r   r   r7   r   r   r   r   r   r   r   r   r   r   r   r   r   r   rc   r  r   r  r   r  r  r  r  r  r   r  r(  r'  r   r  r"   r   r   r,  r   r   r   r   r     sF   
+.&1r   c                   sK  e  Z d  Z d e   d Z e Z e Z dY dZ d[ d\ d] d^ g Z	 e
 j d k r] d_ e	 d` <n  d d l m Z d d d  Z d d   Z d Z d Z d Z d Z d Z d Z d d   Z d d   Z d d d  Z d  d!   Z d d" d#  Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d. d/   Z  d0 d1   Z! d2 d3   Z" d4 Z# d5 d6   Z$ d7 d8   Z% d9 d:   Z& d; d<   Z' d d= d>  Z( d? d@   Z) dA dB   Z* dC dD   Z+ dE dF   Z, dG dH   Z- d dI dJ  Z. d dK dL  Z/ d dM dN  Z0 dO dP   Z1 dQ dR   Z2 f  dS dT  Z3   f dU dV   Z4   f dW dX   Z5   S)ar   zPython z Shellr   _Fileedit_Editre   _Debugoptions_Optionswindows_Windowshelp_Helpdarwin_Windowr   r   )HistoryNc          	   C   s  t  r9 |  j } | d d d k r9 | j d d  q9 n  t |   |  _ | d  k r t   } t |  | j   t |  } n  t	 j
 |  | d  d   d |  _ d |  _ d |  _ |  j } | j d d  | j d	 |  j  | j d
 |  j  | j d |  j  | j d |  j  | j d |  j  | j d |  j  | j d |  j  t  r~| j d |  j  | j d |  j  n  t j |  _ t j |  _ t j |  _  d d l! m" } t# |  d | j$  |  _ t% |  d | j$  |  _ t% |  d | j$  |  _ t% |  d | j$  |  _& t  s?|  j t _ |  j t _ |  j t _ n  y d d  l' } | j( | _) Wn t j* t _   Yn X|  j+ |  j  |  _, d |  _- d  S)Nr   r   shellShe_llT   Zwrapcharz<<newline-and-indent>>z<<plain-newline-and-indent>>z<<interrupt-execution>>z<<end-of-file>>z<<open-stack-viewer>>z<<toggle-debugger>>z<<toggle-jit-stack-viewer>>z<<view-restart>>z<<restart-shell>>)	IOBindingr   r   r   r   2   )zshellr@  ).r0  
menu_specsrg   r   rb   Tkr	   withdrawr   r   r7   ZusetabsZindentwidthZcontext_use_ps1r8   Z	configurer9   enter_callbacklinefeed_callbackcancel_callbackeof_callbackr)  toggle_debuggertoggle_jit_stack_viewerview_restart_markrestart_shellr   r   save_stdoutr   save_stderrr   
save_stdinr  rC  PseudoInputFileencodingPseudoOutputFiler   pydocZ
plainpagerZpagerr   r>  historyr   )r4   r<   Zmsr|   r8   rC  rV  r   r   r   r7   `  s\    		

				zPyShell.__init__c             C   s   t  j d d  S)NZ
shell_onlyT)r   ZGetExtensions)r4   r   r   r   get_standard_extension_names  s    z$PyShell.get_standard_extension_namesFc             C   s
   | a  d  S)N)r!   )r4   streamr   r   r   set_warning_stream  s    zPyShell.set_warning_streamc             C   s   t  S)N)r!   )r4   r   r   r   get_warning_stream  s    zPyShell.get_warning_streamc             C   s`   |  j  r0 t j d d d |  j |  j   d S|  j j   } | rR |  j   n
 |  j   d  S)NzDon't debug nowz*You can only toggle the debugger when idler-  rU   )	r   r}   r~   r8   set_debugger_indicatorrb   r   close_debuggeropen_debugger)r4   rk   dbr   r   r   rL    s    		

zPyShell.toggle_debuggerc             C   s%   |  j  j   } |  j d |  d  S)Nz<<toggle-debugger>>)rb   r   Zsetvar)r4   r_  r   r   r   r\    s    zPyShell.set_debugger_indicatorc             C   s   d  S)Nr   )r4   rk   r   r   r   rM    s    zPyShell.toggle_jit_stack_viewerc             C   s   |  j  j   } | r |  j  j d   | j   |  j  j rQ t j |  j  j  n  |  j   |  j j	 d  d t
 _ |  j   n  |  j   d  S)Nz[DEBUG OFF]
z>>> )rb   r   r  r   r   r   Zclose_remote_debuggerr   r   r"   r   ps1r   r\  )r4   r_  r   r   r   r]    s    

	zPyShell.close_debuggerc             C   sq   |  j  j r' t j |  j  j |   } n t j |   } |  j  j |  | j   d t _ |  j	   |  j
   d  S)Nz[DEBUG ON]
>>> )rb   r   r   Zstart_remote_debuggerr   r  r   r   r`  r   r\  )r4   Zdbg_guir   r   r   r^    s    
	
zPyShell.open_debuggerc             C   s   |  j    d |  _ d S)zHelper for ModifiedInterpreterr   N)r   r   )r4   r   r   r   r.    s    
zPyShell.beginexecutingc             C   s    d |  _  d |  _ |  j   d S)zHelper for ModifiedInterpreterr   N)r   r1  r   )r4   r   r   r   r     s    		zPyShell.endexecutingc             C   sf   |  j  r= t j d d d d d |  j } | d k r= d Sn  |  j   d |  _ d |  _ t j |   S)	zExtend EditorWindow.close()zKill?z6The program is still running!
 Do you want to kill it?r   okru   FZcancelT)	r   r}   Zaskokcancelr8   r   r1  r   r   r   )r4   r   r   r   r   r     s    	
		zPyShell.closec             C   s|   |  j    t r  |  j j   n  |  j t _ |  j t _ |  j	 t _
 d |  _ d |  _ d |  j _ d |  _ t j |   d S)zEExtend EditorWindow._close(), shut down debugger and execution serverN)r]  r0  rb   r   rP  r   r   rQ  r   rR  r   r   r<   ra   rW  r   r   )r4   r   r   r   r     s    
			zPyShell._closec             C   s   d S)z8Override EditorWindow method: never remove the colorizerTr   )r4   r   r   r   r   ispythonsource  s    zPyShell.ispythonsourcec             C   s   |  j  S)N)shell_title)r4   r   r   r   short_title  s    zPyShell.short_titlez@Type "copyright", "credits" or "license()" for more information.c             C   s   |  j  j d d  |  j   t rO d } |  j j   } | sm |  j   d Sn d d d d } t j t	 _ |  j
 d	 t	 j t	 j |  j | f  |  j   d
 d  l } d  | _ d S)Nr   rg   rV   Fz==== No Subprocess ====

z9WARNING: Running IDLE without a Subprocess is deprecated
z;and will be removed in a later version. See Help/IDLE Help
zfor details.

zPython %s on %s
%s
%sr   T)r8   r   r   r0  rb   r   r   r   displayhookr   r"   versionplatform	COPYRIGHTr   tkinterZ_default_root)r4   ZnosubZclientri  r   r   r   r     s"    

	
	zPyShell.beginc             C   s'   |  j  s d  Sd |  _ |  j j   d  S)NT)reading_stop_readline_flagr   quit)r4   r   r   r   r   $  s    		zPyShell.stop_readlinec             C   s   |  j  } z d |  _  |  j j   Wd  | |  _  X|  j rF d |  _ d S|  j j d d  } t |  d k rv d } n  |  j   |  j r d |  _ t	 s t
  q n  |  j r d |  _ d } n  | S)Nr   FrV   r   zend-1cr   rr   )rj  r   mainlooprk  r8   getr   r   r1  r0  r   	endoffile)r4   r/   r   r   r   r   readline*  s(    		
			
					zPyShell.readlinec             C   s   d S)NTr   )r4   r   r   r   isattyA  s    zPyShell.isattyc          
   C   s   y  |  j  j d d d  r d  SWn Yn X|  j p: |  j se |  j   |  j j d  |  j   d Sd |  _ d |  _	 |  j r |  j j
 r |  j j   r |  j j   q |  j j   n  |  j r |  j j   n  d S)Nz	sel.firstz!=zsel.lastzKeyboardInterrupt
rU   r   r   )r8   r   r   rj  r   rb   r"   r   ro  r1  r   r   r   r   r   rl  )r4   rk   r   r   r   rJ  D  s&    

			zPyShell.cancel_callbackc             C   s   |  j  r |  j r d  S|  j j d d d  oD |  j j d d d  sK d  S|  j  sk |  j   |  j   n d |  _ d |  _ |  j j	   d S)Nr   z==rg   zend-1cr   r   rU   )
r   rj  r8   r   r   r   r1  ro  r   rl  )r4   rk   r   r   r   rK  Z  s    	
		zPyShell.eof_callbackc             C   s@   |  j  r/ |  j j d d  |  j j d  n |  j |  d S)Nrg   rr   rU   )rj  r8   rg   seenewline_and_indent_event)r4   rk   r   r   r   rI  i  s
    	zPyShell.linefeed_callbackc             C   s  |  j  r |  j r d  SyN |  j j d d  } | rd |  j j d d d  rd |  j | |  d Sn  Wn Yn X|  j j d d d  r|  j j d	 d  } | r |  j j d d | d
  r |  j |  j j | d | d
  |  d S|  j j d	 d  } | rL|  j j d d | d  rL|  j |  j j | d | d
  |  d S|  j j d d  } | r|  j j | d d d  r|  j |  j j | d
 d  |  n |  j |  j j d d  |  d S|  j j d d d  r|  j j d d  n  |  j j d d  } | r8| j	   r8|  j j
 d d  n  |  j j d d d  ra|  j |  d S|  j j d d  |  j r|  j j d d  |  j j d  n |  j |  |  j j d	 d d  |  j j   |  j r|  j j   n
 |  j   d S)Nz	sel.firstzsel.lastz<=r   rU   rg   r   ziomark linestartr   r   r   zinsert lineendz>=r   zinsert linestartzend-1czend-1c linestartrr   )r   rj  r8   rn  r   recallZtag_prevrangeZtag_nextranger   r   r   rs  rg   rr  r]   Zupdate_idletasksr   rl  runit)r4   rk   selprevnextindicesr   r   r   r   rH  r  sX    "'"'&		
zPyShell.enter_callbackc             C   s  t  j d d |  } t  j d d |  } | j d  } |  j j   zL|  j j d d d  |  j j d d	  |  j j d
 d  } | j   j	 d  r |  j
 |  |  j j d
 d  } n  |  j j d | d j    t |  d k rt  j d | d  j d  } t  j d |  j d  } xd | d d   D]O } | j |  rm| | t |  d   } n  |  j j d d | j    q;Wn  Wd  |  j j d  |  j j   Xd  S)Nz^\s*\nrV   z\n\s*$rr   rv  z1.0r   rg   zend-1czinsert linestart:r   r   z	^([ \t]*))resubr  r8   Zundo_block_startrm   r   rn  rstripendswithrs  rg   r   r   searchgrouprx   rr  Zundo_block_stop)r4   r   rk   r   prefixZorig_base_indentZnew_base_indentr   r   r   r   rt    s*    (zPyShell.recallc             C   s   |  j  j d d  } t |  } x. | d k rQ | | d d k rQ | d } q$ W| d k r | | d d k r | d } n  x. | d k r | | d d k r | d } q W| d  |  } |  j j |  } d  S)Nr   zend-1cr   r   z 	rr   )r8   rn  r   rb   r  )r4   r   rd   r  r   r   r   ru    s    # #zPyShell.runitc             C   su   |  j  j r |  j  j   Sy t j Wn% t j d d d |  j d  SYn Xd d l m	 } | |  j
 |  j  } d  S)NzNo stack tracez@There is no stack trace yet.
(sys.last_traceback is not defined)r-  r   )StackBrowser)rb   r   r   r   last_tracebackr}   r~   r8   Zidlelib.StackViewerr  r|   r<   )r4   rk   r  Zsvr   r   r   r)    s    	
	zPyShell.open_stack_viewerc             C   s$   |  j  j d  |  j  j d  d  S)Nr   r   )r8   rr  )r4   rk   r   r   r   rN    s    zPyShell.view_restart_markc             C   s   |  j  j d d  d S)z&Callback for Run/Restart Shell Cntl-F6r   TN)rb   r   )r4   rk   r   r   r   rO    s    zPyShell.restart_shellc          	   C   sl   |  j    y t t j  } Wn d } Yn X|  j j |  |  j j d d  |  j   |  j	 j
   d  S)NrV   rg   zend-1c)r   rz   r   r`  r   r"   r8   r   set_line_and_columnrB   Z
reset_undo)r4   r   r   r   r   r     s    

zPyShell.showpromptc             C   s   |  j  j d d  } |  j r1 |  j j |  n  |  j  j d  d k r_ |  j  j d d  n  |  j  j d d  |  j   d  S)Nr   zend-1czend-2crr   )r8   rn  rW  Zstorerg   r   r  )r4   r  r   r   r   r     s    	zPyShell.resetoutputc             C   s   t  | t  ry t |  ry t |  d k ry x* t |  D] \ } } | d k r: Pq: q: Wt d | | | d d   n  yB |  j j d d  t j	 |  | | d  } |  j j d d  Wn   Yn X|  j
 r d |  _
 t s t  q n  | S)	Nu   zUCS-2r   z%Non-BMP character not supported in Tkr   rightr   r   )r  rz   r   max	enumerateUnicodeEncodeErrorr8   r   r   r"   r1  r0  r   )r4   r   r   r   rB  countr   r   r   r"     s"    -		zPyShell.writec                sF   y  |  j  j d d d  r d SWn t k
 r8 d SYn Xt   j   S)Nz	sel.firstr   r   disabled)r8   r   r   superrG   )r4   )	__class__r   r   rG     s    	zPyShell.rmenu_check_cutc                s)   |  j  j d d d  r d St   j   S)Nrg   r   r   r  )r8   r   r  rM   )r4   )r  r   r   rM   #  s    zPyShell.rmenu_check_paste)zfiler2  )r3  r4  )zdebugr5  )r6  r7  )r8  r9  )zhelpr;  )r8  r=  )6r   r   r   r   rc  r   r   r   r   rE  r   rg  Zidlelib.IdleHistoryr>  r7   rX  rj  r   r1  ro  r   rk  rZ  r[  rL  r\  rM  r]  r^  r.  r   r   r   rb  rd  rh  r   r   rp  rq  rJ  rK  rI  rH  rt  ru  r)  rN  rO  r   r   r"   rG   rM   r   r   )r  r   r   G  sh   	:	?	r   c               @   sO   e  Z d  Z d d d  Z e d d    Z e d d    Z d d	   Z d S)

PseudoFileNc             C   s   | |  _  | |  _ | |  _ d  S)N)r?  r   	_encoding)r4   r?  r   rT  r   r   r   r7   *  s    		zPseudoFile.__init__c             C   s   |  j  S)N)r  )r4   r   r   r   rT  /  s    zPseudoFile.encodingc             C   s   d |  j  S)Nz<%s>)r   )r4   r   r   r   rT   3  s    zPseudoFile.namec             C   s   d S)NTr   )r4   r   r   r   rq  7  s    zPseudoFile.isatty)r   r   r   r7   propertyrT  rT   rq  r   r   r   r   r  (  s   r  c               @   s(   e  Z d  Z d d   Z d d   Z d S)rU  c             C   s   d S)NTr   )r4   r   r   r   writable=  s    zPseudoOutputFile.writablec             C   s}   |  j  r t d   n  t |  t k	 rg t | t  sU t d t |  j   n  t j |  } n  |  j j	 | |  j
  S)Nzwrite to closed filezmust be str, not )closedr_   r   rz   r  	TypeErrorr   __str__r?  r"   r   )r4   r   r   r   r   r"   @  s    	zPseudoOutputFile.writeN)r   r   r   r  r"   r   r   r   r   rU  ;  s   rU  c               @   sU   e  Z d  Z d d d  Z d d   Z d d d  Z d d	 d
  Z d d   Z d S)rS  Nc             C   s#   t  j |  | | |  d |  _ d  S)NrV   )r  r7   _line_buffer)r4   r?  r   rT  r   r   r   r7   M  s    zPseudoInputFile.__init__c             C   s   d S)NTr   )r4   r   r   r   readableQ  s    zPseudoInputFile.readabler   c             C   s  |  j  r t d   n  | d  k r- d } n+ t | t  sX t d t |  j   n  |  j } d |  _ | d k  r x |  j j	   } | s Pn  | | 7} qy n_ x9 t
 |  | k  r |  j j	   } | s Pn  | | 7} q W| | d   |  _ | d  |  } | S)Nzread from closed filer   zmust be int, not rV   r   r*   )r  r_   r  ri   r  r   r   r  r?  rp  r   )r4   sizeresultr   r   r   r   r  T  s,    				  zPseudoInputFile.readc             C   s   |  j  r t d   n  | d  k r- d } n+ t | t  sX t d t |  j   n  |  j pm |  j j	   } | d k  r t
 |  } n  | j d d |  } | d k r | d } n  | | d   |  _ | d  |  S)Nzread from closed filer   zmust be int, not r   rr   r*   )r  r_   r  ri   r  r   r   r  r?  rp  r   find)r4   r  r   Zeolr   r   r   rp  k  s    		zPseudoInputFile.readlinec             C   s   |  j  j   d  S)N)r?  r   )r4   r   r   r   r   {  s    zPseudoInputFile.closer*   r*   )r   r   r   r7   r  r  rp  r   r   r   r   r   rS  K  s
   rS  a  
USAGE: idle  [-deins] [-t title] [file]*
       idle  [-dns] [-t title] (-c cmd | -r file) [arg]*
       idle  [-dns] [-t title] - [arg]*

  -h         print this help message and exit
  -n         run IDLE without a subprocess (DEPRECATED,
             see Help/IDLE Help for details)

The following options will override the IDLE 'settings' configuration:

  -e         open an edit window
  -i         open a shell window

The following options imply -i and will open a shell:

  -c cmd     run the command in a shell, or
  -r file    run script from file

  -d         enable the debugger
  -s         run $IDLESTARTUP or $PYTHONSTARTUP before anything else
  -t title   set title of shell window

A default edit window will be bypassed when -c, -r, or - are used.

[arg]* are passed to the command (-c) or script (-r) in sys.argv[1:].

Examples:

idle
        Open an edit window or shell depending on IDLE's configuration.

idle foo.py foobar.py
        Edit the files, also open a shell if configured to start with shell.

idle -est "Baz" foo.py
        Run $IDLESTARTUP or $PYTHONSTARTUP, edit foo.py, and open a shell
        window with the title "Baz".

idle -c "import sys; print(sys.argv)" "foo"
        Open a shell window and run the command, passing "-c" in sys.argv[0]
        and "foo" in sys.argv[1].

idle -d -s -r foo.py "Hello World"
        Open a shell window, run a startup script, enable the debugger, and
        run foo.py, passing "foo.py" in sys.argv[0] and "Hello World" in
        sys.argv[1].

echo "import sys; print(sys.argv)" | idle - "foobar"
        Open a shell window, run the script piped in, passing '' in sys.argv[0]
        and "foobar" in sys.argv[1].
c                 s  t  d  d a d }  d } d } d  } d  } d } y) t j t j d d   d  \ } } WnR t j k
 r } z/ t d | t f d t j t j	 d  WYd  d  } ~ Xn XxE| D]=\ }	 }
 |	 d k r |
 } d }  n  |	 d	 k r d } d }  n  |	 d
 k rd } n  |	 d k r9t j
 j t  t j	   n  |	 d k rNd }  n  |	 d k rvt d d t j d a n  |	 d k r|
 } t j j |  rn t d |  t j	   d }  n  |	 d k rd } d }  n  |	 d k r |
 t _ d }  q q W| r(| d d k r(t j j   } d }  n  x= t t t j   D]& } t j j t j |  t j | <q>W| r| d d k rd g | d d   t _ n | rd g | t _ n | r| g | t _ n | rTd } g  } x' | D] } | j t j j |   qWxy | D]= } t j j |  } | t j k rt j j d |  qqWn1 t j   } | t j k rt j j d |  n  t j d d d d d } | p| } |  p| }  t d d  a t j j t j j t  d   t    d k r t j j  d  } t j! d  |  nf t" d! k rt" d" k r>d# n d$      f d% d&   d/ D } d* d&   | D } t j# d |  n  t$ t  t j%   t& t  a' t( j) t t'  | r!| p| s!x= | d  d   D]+ } t' j* |  d  k r| j+ |  qqW| st' j,   qq!n  |  ret' j-   } | s=d  St( j.   rnt' j/ rn| j0 j1   qnn	 t' j2 } | r| j3   n  | rt j4 j5 d+  pt j4 j5 d,  } | rt j j |  r| j6 j7 |  qn  | s| rD| j6 j8 d- t j f  | r| j6 j9 |  qy| ry| j6 j: |  | j6 j7 |  qyn5 | ryt( j; t  } | ry| j6 j8 d. |  qyn  x t' j< rt j=   q|Wt j>   t  d  d  S)0NTFr   zc:deihnr:st:zError: %s
%sr   r   z-cz-dz-ez-hz-iz-nz: Warning: running IDLE without a subprocess is deprecated.z-rzNo script file: z-sz-tr   -rV   rR   r   zeditor-on-startupr   r   Z	classNameZIdleZIconsZWindowszidle.icor   g      !@g333333!@z.pngz.gifc                s/   g  |  ]% } t  j j  d  |   f   q S)z	idle_%d%s)r>   r?   r@   )r   r  )exticondirr   r   r     s   	zmain.<locals>.<listcomp>r       0   c             S   s   g  |  ] } t  d  |   q S)r   )Z
PhotoImage)r   iconfiler   r   r   r     s   	 ZIDLESTARTUPZPYTHONSTARTUPzbif 1:
            import sys as _sys
            _sys.argv = %r
            del _sys
            
zprint('%s'))r   r  r  )?r)   r0  getoptr   argvr  r   	usage_msgr   exitr   r"   r>   r?   r   r   rc  r   r  r   r   abspathr`   dirnamerg   getcwdr   rZ   rF  r|   r@   __file__r   Zwm_iconbitmapZ	TkVersionZwm_iconphotor	   rG  r   r<   r   ZsetupApprv   rl   newr=   ZisAquaTkdictr   lowerra   r^  environrn  rb   r  r   r  r   ZtkVersionWarningZinversedictrm  Zdestroy)Zenable_shellZenable_editre   cmdZscriptZstartupZoptsrD   r!  oard   Zpathxr   dirZ
edit_startr  Z	iconfilesZiconsr?  Ztkversionwarningr   )r  r  r   rR     s    
) 					
	
				$!


		
rR   r   F)Hr  r>   os.pathr{  r   r   r   r   r   r  	tracebacktypesrB   r   r  r   rg  r   r   ri  ImportErrorr   r   r  Ztkinter.messageboxZ
messageboxr}   Zidlelib.EditorWindowr   r	   Zidlelib.FileListr
   Zidlelib.ColorDelegatorr   Zidlelib.UndoDelegatorr   Zidlelib.OutputWindowr   Zidlelib.configHandlerr   r  r   r   r   r   r   r   r   r!   r'   r    r%   r&   r)   
checkcacher1   r2   r   r   r   Z	RPCClientr   r   r   
TextIOBaser  rU  rS  r  rR   r   r   r   r   r   r   <module>   s~   	
	
	  h
                                                                                                                                                                                                                                                                                                                                                                                 usr/lib/python3.4/idlelib/__pycache__/RemoteDebugger.cpython-34.pyc                                 0100644 0000000 0000000 00000034513 13077704335 023551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T.                 @   s9  d  Z  d d l Z d d l m Z d d l m Z d Z d a d Z i  Z i  Z	 i  Z
 i  Z d d   Z d	 d
   Z Gd d   d  Z Gd d   d  Z d d   Z Gd d   d  Z Gd d   d  Z Gd d   d  Z Gd d   d  Z Gd d   d  Z d d   Z d d   Z d d    Z d! d"   Z d S)#a  Support for remote Python debugging.

Some ASCII art to describe the structure:

       IN PYTHON SUBPROCESS          #             IN IDLE PROCESS
                                     #
                                     #        oid='gui_adapter'
                 +----------+        #       +------------+          +-----+
                 | GUIProxy |--remote#call-->| GUIAdapter |--calls-->| GUI |
+-----+--calls-->+----------+        #       +------------+          +-----+
| Idb |                               #                             /
+-----+<-calls--+------------+         #      +----------+<--calls-/
                | IdbAdapter |<--remote#call--| IdbProxy |
                +------------+         #      +----------+
                oid='idb_adapter'      #

The purpose of the Proxy and Adapter classes is to translate certain
arguments and return values that cannot be transported through the RPC
barrier, in particular frame and traceback objects.

    N)rpc)Debuggeridb_adapterZgui_adapterc             C   s   t  |   } |  t | <| S)N)id
frametable)framefid r	   ,/usr/lib/python3.4/idlelib/RemoteDebugger.py
wrap_frame)   s    
r   c             C   sg   |  d k r d S|  d } t  | t j  s2 t  t |  } | t | <|  d |  d | f } | Sd S)z0replace info[2], a traceback instance, by its IDN   r      )
isinstancetypesTracebackTypeAssertionErrorr   tracebacktable)info	tracebackZtraceback_idmodified_infor	   r	   r
   	wrap_info.   s    

r   c               @   s+   e  Z d  Z d d   Z d d d  Z d S)GUIProxyc             C   s   | |  _  | |  _ d  S)N)connoid)selfr   gui_adap_oidr	   r	   r
   __init__<   s    	zGUIProxy.__init__Nc             C   s5   |  j  j |  j d | t |  t |  f i   d  S)Ninteraction)r   
remotecallr   r   r   )r   messager   r   r	   r	   r
   r   @   s    zGUIProxy.interaction)__name__
__module____qualname__r   r   r	   r	   r	   r
   r   :   s   r   c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d! d"   Z d# d$   Z d% d&   Z d' d(   Z d) S)*
IdbAdapterc             C   s   | |  _  d  S)N)idb)r   r$   r	   r	   r
   r   I   s    zIdbAdapter.__init__c             C   s   |  j  j   d  S)N)r$   set_step)r   r	   r	   r
   r%   N   s    zIdbAdapter.set_stepc             C   s   |  j  j   d  S)N)r$   set_quit)r   r	   r	   r
   r&   Q   s    zIdbAdapter.set_quitc             C   s   |  j  j   d  S)N)r$   set_continue)r   r	   r	   r
   r'   T   s    zIdbAdapter.set_continuec             C   s   t  | } |  j j |  d  S)N)r   r$   set_next)r   r   r   r	   r	   r
   r(   W   s    
zIdbAdapter.set_nextc             C   s   t  | } |  j j |  d  S)N)r   r$   
set_return)r   r   r   r	   r	   r
   r)   [   s    
zIdbAdapter.set_returnc             C   sa   t  | } | d  k r d  } n
 t | } |  j j | |  \ } } d d   | D } | | f S)Nc             S   s(   g  |  ] \ } } t  |  | f  q Sr	   )r   ).0r   kr	   r	   r
   
<listcomp>f   s   	 z(IdbAdapter.get_stack.<locals>.<listcomp>)r   r   r$   	get_stack)r   r   tbidr   tbstackir	   r	   r
   r-   _   s    
	
zIdbAdapter.get_stackc             C   s&   d d  l  } |  j j | | j  d  S)Nr   )__main__r$   run__dict__)r   cmdr2   r	   r	   r
   r3   i   s    zIdbAdapter.runc             C   s   |  j  j | |  } | S)N)r$   	set_break)r   filenamelinenomsgr	   r	   r
   r6   m   s    zIdbAdapter.set_breakc             C   s   |  j  j | |  } | S)N)r$   clear_break)r   r7   r8   r9   r	   r	   r
   r:   q   s    zIdbAdapter.clear_breakc             C   s   |  j  j |  } | S)N)r$   clear_all_file_breaks)r   r7   r9   r	   r	   r
   r;   u   s    z IdbAdapter.clear_all_file_breaksc             C   s   t  | } t | |  S)N)r   getattr)r   r   namer   r	   r	   r
   
frame_attr{   s    
zIdbAdapter.frame_attrc             C   s-   t  | } | j } t |  } | t | <| S)N)r   	f_globalsr   	dicttable)r   r   r   dictdidr	   r	   r
   frame_globals   s
    
	
zIdbAdapter.frame_globalsc             C   s-   t  | } | j } t |  } | t | <| S)N)r   f_localsr   r@   )r   r   r   rA   rB   r	   r	   r
   frame_locals   s
    
	
zIdbAdapter.frame_localsc             C   s-   t  | } | j } t |  } | t | <| S)N)r   f_coder   	codetable)r   r   r   codecidr	   r	   r
   
frame_code   s
    
	
zIdbAdapter.frame_codec             C   s   t  | } | j S)N)rG   co_name)r   rI   rH   r	   r	   r
   	code_name   s    
zIdbAdapter.code_namec             C   s   t  | } | j S)N)rG   co_filename)r   rI   rH   r	   r	   r
   code_filename   s    
zIdbAdapter.code_filenamec             C   s   t  d   d  S)Nz"dict_keys not public or pickleable)NotImplemented)r   rB   r	   r	   r
   	dict_keys   s    zIdbAdapter.dict_keysc             C   s   t  | } t | j    S)N)r@   listkeys)r   rB   rA   r	   r	   r
   dict_keys_list   s    
zIdbAdapter.dict_keys_listc             C   s$   t  | } | | } t |  } | S)N)r@   repr)r   rB   keyrA   valuer	   r	   r
   	dict_item   s    

zIdbAdapter.dict_itemN)r    r!   r"   r   r%   r&   r'   r(   r)   r-   r3   r6   r:   r;   r>   rC   rE   rJ   rL   rN   rP   rS   rW   r	   r	   r	   r
   r#   G   s(   
	r#   c             C   s>   t  |  |  } t j |  } t |  } |  j t |  t S)a|  Start the debugger and its RPC link in the Python subprocess

    Start the subprocess side of the split debugger and set up that side of the
    RPC link by instantiating the GUIProxy, Idb debugger, and IdbAdapter
    objects and linking them together.  Register the IdbAdapter with the
    RPCServer to handle RPC requests from the split debugger GUI via the
    IdbProxy.

    )r   r   ZIdbr#   registeridb_adap_oid)Z
rpchandlerr   Z	gui_proxyr$   Zidb_adapr	   r	   r
   start_debugger   s
    
rZ   c               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)
FrameProxyc             C   s(   | |  _  | |  _ d |  _ i  |  _ d  S)Nr   )_conn_fid_oid
_dictcache)r   r   r   r	   r	   r
   r      s    			zFrameProxy.__init__c             C   s   | d  d  d k r% t  |   n  | d k r; |  j   S| d k rQ |  j   S| d k rg |  j   S|  j j |  j d |  j | f i   S)Nr   _rF   r?   rD   r>   )AttributeError_get_f_code_get_f_globals_get_f_localsr\   r   r^   r]   )r   r=   r	   r	   r
   __getattr__   s    


zFrameProxy.__getattr__c             C   s:   |  j  j |  j d |  j f i   } t |  j  |  j |  S)NrJ   )r\   r   r^   r]   	CodeProxy)r   rI   r	   r	   r
   rb      s    $zFrameProxy._get_f_codec             C   s1   |  j  j |  j d |  j f i   } |  j |  S)NrC   )r\   r   r^   r]   _get_dict_proxy)r   rB   r	   r	   r
   rc      s    zFrameProxy._get_f_globalsc             C   s1   |  j  j |  j d |  j f i   } |  j |  S)NrE   )r\   r   r^   r]   rg   )r   rB   r	   r	   r
   rd      s    zFrameProxy._get_f_localsc             C   sC   | |  j  k r |  j  | St |  j |  j |  } | |  j  | <| S)N)r_   	DictProxyr\   r^   )r   rB   Zdpr	   r	   r
   rg      s
    zFrameProxy._get_dict_proxyN)	r    r!   r"   r   re   rb   rc   rd   rg   r	   r	   r	   r
   r[      s   r[   c               @   s(   e  Z d  Z d d   Z d d   Z d S)rf   c             C   s   | |  _  | |  _ | |  _ d  S)N)r\   r^   _cid)r   r   r   rI   r	   r	   r
   r      s    		zCodeProxy.__init__c             C   s`   | d k r. |  j  j |  j d |  j f i   S| d k r\ |  j  j |  j d |  j f i   Sd  S)NrK   rL   rM   rN   )r\   r   r^   ri   )r   r=   r	   r	   r
   re      s    zCodeProxy.__getattr__N)r    r!   r"   r   re   r	   r	   r	   r
   rf      s   rf   c               @   s@   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 S)
rh   c             C   s   | |  _  | |  _ | |  _ d  S)N)r\   r^   _did)r   r   r   rB   r	   r	   r
   r     s    		zDictProxy.__init__c             C   s"   |  j  j |  j d |  j f i   S)NrS   )r\   r   r^   rj   )r   r	   r	   r
   rR     s    zDictProxy.keysc             C   s%   |  j  j |  j d |  j | f i   S)NrW   )r\   r   r^   rj   )r   rU   r	   r	   r
   __getitem__  s    zDictProxy.__getitem__c             C   s   t  |   d  S)N)ra   )r   r=   r	   r	   r
   re     s    zDictProxy.__getattr__N)r    r!   r"   r   rR   rk   re   r	   r	   r	   r
   rh     s   	rh   c               @   s(   e  Z d  Z d d   Z d d   Z d S)
GUIAdapterc             C   s   | |  _  | |  _ d  S)N)r   gui)r   r   rm   r	   r	   r
   r     s    	zGUIAdapter.__init__c             C   s,   t  |  j |  } |  j j | | |  d  S)N)r[   r   rm   r   )r   r   r   r   r   r	   r	   r
   r   "  s    zGUIAdapter.interactionN)r    r!   r"   r   r   r	   r	   r	   r
   rl     s   rl   c               @   s   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d S)IdbProxyc             C   s   | |  _  | |  _ | |  _ d  S)N)r   r   shell)r   r   ro   r   r	   r	   r
   r   *  s    		zIdbProxy.__init__c             O   s"   |  j  j |  j | | |  } | S)N)r   r   r   )r   Z
methodnameargskwargsrV   r	   r	   r
   call/  s    zIdbProxy.callc             C   s4   |  j  j |  j d | f i   } | |  j j _ d  S)Nr3   )r   Z
asyncqueuer   ro   ZinterpZ
active_seq)r   r5   localsseqr	   r	   r
   r3   5  s    !zIdbProxy.runc                sA     j  d | j |  \ } }   f d d   | D } | | f S)Nr-   c                s.   g  |  ]$ \ } } t    j |  | f  q Sr	   )r[   r   )r*   r   r+   )r   r	   r
   r,   =  s   	 z&IdbProxy.get_stack.<locals>.<listcomp>)rr   r]   )r   r   r.   r0   r1   r	   )r   r
   r-   :  s    zIdbProxy.get_stackc             C   s   |  j  d  d  S)Nr'   )rr   )r   r	   r	   r
   r'   @  s    zIdbProxy.set_continuec             C   s   |  j  d  d  S)Nr%   )rr   )r   r	   r	   r
   r%   C  s    zIdbProxy.set_stepc             C   s   |  j  d | j  d  S)Nr(   )rr   r]   )r   r   r	   r	   r
   r(   F  s    zIdbProxy.set_nextc             C   s   |  j  d | j  d  S)Nr)   )rr   r]   )r   r   r	   r	   r
   r)   I  s    zIdbProxy.set_returnc             C   s   |  j  d  d  S)Nr&   )rr   )r   r	   r	   r
   r&   L  s    zIdbProxy.set_quitc             C   s   |  j  d | |  } | S)Nr6   )rr   )r   r7   r8   r9   r	   r	   r
   r6   O  s    zIdbProxy.set_breakc             C   s   |  j  d | |  } | S)Nr:   )rr   )r   r7   r8   r9   r	   r	   r
   r:   S  s    zIdbProxy.clear_breakc             C   s   |  j  d |  } | S)Nr;   )rr   )r   r7   r9   r	   r	   r
   r;   W  s    zIdbProxy.clear_all_file_breaksN)r    r!   r"   r   rr   r3   r-   r'   r%   r(   r)   r&   r6   r:   r;   r	   r	   r	   r
   rn   (  s   rn   c             C   sb   |  j  d d t f i   a t |  | t  } t j | |  } t |  |  } |  j t |  | S)a]  Start the subprocess debugger, initialize the debugger GUI and RPC link

    Request the RPCServer start the Python subprocess debugger and link.  Set
    up the Idle side of the split debugger by instantiating the IdbProxy,
    debugger GUI, and debugger GUIAdapter objects and linking them together.

    Register the GUIAdapter with the RPCClient to handle debugger GUI
    interaction requests coming from the subprocess debugger via the GUIProxy.

    The IdbAdapter will pass execution and environment requests coming from the
    Idle debugger GUI to the subprocess debugger via the IdbProxy.

    execstart_the_debugger)r   r   rY   rn   r   rl   rX   )rpccltZpyshellZ	idb_proxyrm   Zgui_adapr	   r	   r
   start_remote_debugger[  s    rx   c             C   s   t  |   |  j t  d S)a]  Shut down subprocess debugger and Idle side of debugger RPC link

    Request that the RPCServer shut down the subprocess debugger and link.
    Unregister the GUIAdapter, which will cause a GC on the Idle process
    debugger and RPC link objects.  (The second reference to the debugger GUI
    is deleted in PyShell.close_remote_debugger().)

    N)close_subprocess_debuggerZ
unregisterr   )rw   r	   r	   r
   close_remote_debuggers  s    	
rz   c             C   s   |  j  d d t f i   d  S)Nru   Zstop_the_debugger)r   rY   )rw   r	   r	   r
   ry     s    ry   c             C   s7   |  j  d d t f i   } | t k s3 t d   d  S)Nru   rv   z Idb restarted with different oid)r   r   rY   r   )rw   Zidb_adap_oid_retr	   r	   r
   restart_subprocess_debugger  s    r{   )__doc__r   Zidlelibr   r   Z	debuggingrY   r   r   r@   rG   r   r   r   r   r#   rZ   r[   rf   rh   rl   rn   rx   rz   ry   r{   r	   r	   r	   r
   <module>   s0   m*3                                                                                                                                                                                     usr/lib/python3.4/idlelib/__pycache__/RemoteObjectBrowser.cpython-34.pyc                            0100644 0000000 0000000 00000003712 13077704335 024574  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sF   d  d l  m Z d d   Z Gd d   d  Z Gd d   d  Z d S)	    )rpcc             C   s)   t  |   } t |  } | t j | <| S)N)WrappedObjectTreeItemidr   Zobjecttable)itemwrapperoid r   1/usr/lib/python3.4/idlelib/RemoteObjectBrowser.pyremote_object_tree_item   s    r
   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)r   c             C   s   | |  _  d  S)N)_WrappedObjectTreeItem__item)selfr   r   r   r	   __init__   s    zWrappedObjectTreeItem.__init__c             C   s   t  |  j |  } | S)N)getattrr   )r   namevaluer   r   r	   __getattr__   s    z!WrappedObjectTreeItem.__getattr__c             C   s"   |  j  j   } t t t |   S)N)r   _GetSubListlistmapr
   )r   sub_listr   r   r	   r      s    z!WrappedObjectTreeItem._GetSubListN)__name__
__module____qualname__r   r   r   r   r   r   r	   r   	   s   r   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)StubObjectTreeItemc             C   s   | |  _  | |  _ d  S)N)sockior   )r   r   r   r   r   r	   r      s    	zStubObjectTreeItem.__init__c             C   s   t  j |  j |  j |  } | S)N)r   ZMethodProxyr   r   )r   r   r   r   r   r	   r      s    zStubObjectTreeItem.__getattr__c                s5     j  j   j d f  i   }   f d d   | D S)Nr   c                s"   g  |  ] } t    j |   q Sr   )r   r   ).0r   )r   r   r	   
<listcomp>$   s   	 z2StubObjectTreeItem._GetSubList.<locals>.<listcomp>)r   Z
remotecallr   )r   r   r   )r   r	   r   "   s    zStubObjectTreeItem._GetSubListN)r   r   r   r   r   r   r   r   r   r	   r      s   r   N)Zidlelibr   r
   r   r   r   r   r   r	   <module>   s                                                         usr/lib/python3.4/idlelib/__pycache__/ReplaceDialog.cpython-34.pyc                                  0100644 0000000 0000000 00000015370 13077704335 023344  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  d l  Td  d l m Z d  d l m Z d  d l Z d d   Z Gd d   d e  Z d	 d
   Z e	 d k r d  d l
 m Z e e  n  d S)    )*)SearchEngine)SearchDialogBaseNc             C   sY   |  j    } t j |  } t | d  s? t | |  | _ n  | j } | j |   d  S)N_replacedialog)Z_rootr   gethasattrReplaceDialogr   open)textrootengineZdialog r   +/usr/lib/python3.4/idlelib/ReplaceDialog.pyreplace   s    	r   c               @   s   e  Z d  Z d Z d Z d d   Z d d   Z d d   Z d	 d
   Z d d d  Z	 d d d  Z
 d d d  Z d d   Z d d d  Z d d d  Z d d   Z d d   Z d d d  Z d S)r   zReplace DialogReplacec             C   s&   t  j |  | |  t |  |  _ d  S)N)r   __init__Z	StringVarreplvar)selfr   r   r   r   r   r      s    zReplaceDialog.__init__c             C   s   t  j |  |  y | j d  } Wn t k
 r= d  } Yn Xy | j d  } Wn t k
 rk d  } Yn X| p~ | j d  } | p | } |  j | |  d |  _ d  S)Nz	sel.firstzsel.lastinsert   )r   r	   indexTclErrorshow_hitok)r   r
   firstlastr   r   r   r	      s    zReplaceDialog.openc             C   s-   t  j |   |  j d |  j  d |  _ d  S)NzReplace with:r   )r   create_entriesZ
make_entryr   Zreplent)r   r   r   r   r   )   s    zReplaceDialog.create_entriesc             C   s`   t  j |   |  j d |  j  |  j d |  j  |  j d |  j d  |  j d |  j  d  S)NZFindr   zReplace+Findr   zReplace All)r   create_command_buttonsZmake_buttonfind_it
replace_itdefault_commandreplace_all)r   r   r   r   r   -   s
    z$ReplaceDialog.create_command_buttonsNc             C   s   |  j  d  d  S)Nr   )do_find)r   eventr   r   r   r   4   s    zReplaceDialog.find_itc             C   s#   |  j  |  j  r |  j   n  d  S)N)r"   r   
do_replace)r   r#   r   r   r   r   7   s    zReplaceDialog.replace_itc             C   s5   |  j  |  j  r1 |  j   r1 |  j  d  q1 n  d  S)Nr   )r"   r   r$   )r   r#   r   r   r   r    ;   s    zReplaceDialog.default_commandc             C   s`   |  j  j   rV y | j |  } Wq\ t j k
 rR |  j  j | d  d } Yq\ Xn | } | S)za Helper function for expanding a regular expression
            in the replace field, if needed. zInvalid Replace ExpressionN)r   ZisreexpandreerrorZreport_error)r   mreplnewr   r   r   _replace_expandA   s    zReplaceDialog._replace_expandc             C   sA  |  j  j   } | s d  S|  j j   } |  j } |  j  j | |  } | sZ | j   d  S| j d d d  | j d d d  | d } | d j   } |  j  j	   r d } d } n  d } d  }	 }
 | j
   x5|  j  j | | | | d |  } | s Pn  | \ } } | j d | d | d  } | j   } |  j | |  } | d  k rXPn  | j   \ } } d | | f }	 d | | f }
 | | k r| j d	 |
  nH | j d	 |	  |	 |
 k r| j |	 |
  n  | r| j |	 |  n  | t |  } d } q | j   |	 r3|
 r3|  j |	 |
  n  |  j   d  S)
Nselz1.0endhitr   r   z%d.0z%d.%dr   )r   getprogr   r   r
   search_textbell
tag_removestartZiswrapundo_block_startZsearch_forwardgroupr+   spanmark_setdeleter   lenundo_block_stopr   close)r   r#   progr)   r
   reslinecolr   r   r   r(   charsZorigr*   ijr   r   r   r!   O   sZ    	

	

!	
zReplaceDialog.replace_allr   c       
      C   s   |  j  j   s d S|  j } |  j  j | d  |  } | sH | j   d S| \ } } | j   \ } } d | | f } d | | f }	 |  j | |	  d |  _ d S)NFz%d.%dr   T)r   r/   r
   r0   r1   r6   r   r   )
r   r   r
   r=   r>   r(   rA   rB   r   r   r   r   r   r"      s    	
	zReplaceDialog.do_findc             C   s  |  j  j   } | s d S|  j } y& | j d  } } | j d  } Wn t k
 rb d  } Yn X| s | j d  } } } n  t j |  \ } } | j d | d | d  } | j | |  }	 | s d S|  j	 |	 |  j
 j    }
 |
 d  k r d S| j d |  | j   |	 j   r6| j | |  n  |
 rO| j | |
  n  | j   |  j | | j d   d |  _ d S)	NFz	sel.firstzsel.lastr   z%d.0r   r   T)r   r/   r
   r   r   r   Zget_line_colr   matchr+   r   r7   r4   r5   r8   r   r:   r   r   )r   r<   r
   r   posr   r>   r?   r@   r(   r*   r   r   r   r$      s:    	

	zReplaceDialog.do_replacec             C   s   |  j  } | j d |  | j d d d  | j d | |  | j d d d  | | k rq | j d |  n | j d | |  | j d  | j   d  S)Nr   r,   z1.0r-   r.   )r
   r7   r2   tag_addZseeZupdate_idletasks)r   r   r   r
   r   r   r   r      s    	zReplaceDialog.show_hitc             C   s*   t  j |  |  |  j j d d d  d  S)Nr.   z1.0r-   )r   r;   r
   r2   )r   r#   r   r   r   r;      s    zReplaceDialog.close)__name__
__module____qualname__titleZiconr   r	   r   r   r   r   r    r+   r!   r"   r$   r   r;   r   r   r   r   r      s   1r   c       
         s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  d d   } d d   } t |    |   _	 |   _
   j     j d	 d
 d    f d d   } t | d d d | }	 |	 j   d  S)NzTest ReplaceDialogz[x+]z+%d+%d   c               S   s   d  S)Nr   r   r   r   r   r4      s    z)_replace_dialog.<locals>.undo_block_startc               S   s   d  S)Nr   r   r   r   r   r:      s    z(_replace_dialog.<locals>.undo_block_stopr   zThis is a sample string.

   c                  s4     j  t d t  t      j t d t  d  S)Nz1.0)rE   ZSELZENDr   r2   r   )r
   r   r   show_replace   s    
z%_replace_dialog.<locals>.show_replacer
   r   Zcommand)ZTkrI   listmapintr&   splitZgeometryZTextr4   r:   Zpackr   ZButton)
parentr   widthZheightxyr4   r:   rL   Zbuttonr   )r
   r   _replace_dialog   s    	3		
rU   __main__)run)ZtkinterZidlelibr   Zidlelib.SearchDialogBaser   r&   r   r   rU   rF   Zidlelib.idle_test.htestrW   r   r   r   r   <module>   s   
	                                                                                                                                                                                                                                                                        usr/lib/python3.4/idlelib/__pycache__/RstripExtension.cpython-34.pyc                                0100644 0000000 0000000 00000002500 13077704335 024020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sQ   d  Z  Gd d   d  Z e d k rM d d l Z e j d d d d	 d
 n  d S)z=Provides "Strip trailing whitespace" under the "Format" menu.c               @   s@   e  Z d  Z d d d	 g f g Z d d   Z d d d  Z d S)
RstripExtensionformatNStrip trailing whitespace<<do-rstrip>>c             C   s&   | |  _  |  j  j j d |  j  d  S)Nz<<do-rstrip>>)editwintextZbind	do_rstrip)selfr    r	   -/usr/lib/python3.4/idlelib/RstripExtension.py__init__   s    	zRstripExtension.__init__c       	      C   s   |  j  j } |  j  j } | j   t t | j d    } x| t d |  D]k } | j d | d |  } t	 |  } t	 | j
    } | | k  rM | j d | | f d |  qM qM W| j   d  S)Nend   z%i.0z%i.endz%i.%i)r   r   undoZundo_block_startintfloatindexrangegetlenrstripZdeleteZundo_block_stop)	r   Zeventr   r   Zend_lineZcurZtxtrawZcutr	   r	   r
   r      s    
%zRstripExtension.do_rstrip)r   r   )__name__
__module____qualname__Zmenudefsr   r   r	   r	   r	   r
   r      s   r   __main__    Nzidlelib.idle_test.test_rstrip	verbosity   exitF)__doc__r   r   Zunittestmainr	   r	   r	   r
   <module>   s                                                                                                                                                                                                   usr/lib/python3.4/idlelib/__pycache__/ScriptBinding.cpython-34.pyc                                  0100644 0000000 0000000 00000015736 13077704335 023416  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Ty                 @   s   d  Z  d d l Z d d l Z d d l Z d d l Z d d l Z d d l j Z d d l	 m
 Z
 d d l m Z m Z d d l m Z d d l m Z d Z Gd d	   d	  Z d S)
a?  Extension to execute code outside the Python shell window.

This adds the following commands:

- Check module does a full syntax check of the current module.
  It also runs the tabnanny to catch any inconsistent tabs.

- Run module executes the module's code in the __main__ namespace.  The window
  must have been saved previously. The module is added to sys.modules, and is
  also added to the __main__ namespace.

XXX GvR Redesign this interface (yet again) as follows:

- Present a dialog box for ``Run Module''

- Allow specify command line arguments in the dialog box

    N)EditorWindow)PyShell	IOBinding)idleConf)macosxSupporta/  Error: Inconsistent indentation detected!

1) Your indentation is outright incorrect (easy to fix), OR

2) Your indentation mixes tabs and spaces.

To fix case 2, change all tabs to spaces by using Edit->Select All followed by Format->Untabify Region and specify the number of columns used by each tab.
c               @   s   e  Z d  Z d d d d g f g Z d d   Z d	 d
   Z d d   Z d d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d S)ScriptBindingZrunNCheck Module<<check-module>>
Run Module<<run-module>>c             C   sS   | |  _  |  j  j |  _ |  j  j |  _ t j   rO |  j  j j d |  j  n  d  S)Nz<<run-module-event-2>>)editwinflistrootr   	isCocoaTk
text_frameZbind_run_module_event)selfr    r   +/usr/lib/python3.4/idlelib/ScriptBinding.py__init__1   s
    	zScriptBinding.__init__c             C   s@   |  j    } | s d S|  j |  s) d S|  j |  s< d Sd  S)Nbreak)getfilenamechecksyntaxtabnanny)r   eventfilenamer   r   r   check_module_event;   s    z ScriptBinding.check_module_eventc             C   s   t  j |   } y t j t  j | j   Wn t  j k
 r } z? | \ } \ } } |  j j |  |  j	 d d |  d SWYd  d  } ~ XnR t j
 k
 r } z/ |  j j | j    |  j	 d t  d SWYd  d  } ~ Xn XWd  QXd S)NzTabnanny Tokenizing ErrorzToken Error: %sFzTab/space errorT)tokenizeopenr   Zprocess_tokensgenerate_tokensreadline
TokenErrorr   ZgotolineerrorboxZNannyNagZ
get_linenoindent_message)r   r   fmsgZmsgtxtlinenostartZnagr   r   r   r   D   s    	zScriptBinding.tabnannyc             C   s  |  j  j   |  _ } | j   } | j | j  t | d   } | j   } Wd  QXd | k r | j d d  } | j d d  } n  | r | d t	 d  k r | d } n  |  j
 } | j } | j d d d  z y t | | d	  SWn t t t f k
 r} z t | d
 d  p'| p'd }	 t | d d  p?d }
 t | d d  pWd } | d k rs|
 d 7}
 n  d |
 d | d f } | j | |  |  j d d |	  d SWYd  d  } ~ Xn XWd  | j |  Xd  S)Nrbs   s   
s   
   ZERRORz1.0endexecr%    z<no detail available>r&   offsetr   z0.0 + %d lines + %d charsSyntaxErrorz%-20sF)r   Z
open_shellshellZget_warning_streamZset_warning_streamstderrr   readreplaceordr   textZ
tag_removecompiler.   OverflowError
ValueErrorgetattrZcolorize_syntax_errorr"   )r   r   r0   Zsaved_streamr$   sourcer   r5   valuer%   r&   r-   posr   r   r   r   V   s4    		zScriptBinding.checksyntaxc                sC   t  j   r2   j j j d   f d d    d S  j |  Sd  S)N   c                  s     j  j j d  S)Nz<<run-module-event-2>>)r   r   Zevent_generater   )r   r   r   <lambda>|   s    z0ScriptBinding.run_module_event.<locals>.<lambda>r   )r   r   r   r   Zafterr   )r   r   r   )r   r   run_module_eventt   s
    zScriptBinding.run_module_eventc             C   s   |  j    } | s d S|  j |  } | s/ d S|  j |  sB d S|  j j } t j rj | j d d  n  t j	 j
 |  } | j d j d | d |   | j |  | j |  d S)aX  Run the module after setting up the environment.

        First check the syntax.  If OK, make sure the shell is active and
        then transfer the arguments, set the run environment's working
        directory to the directory of the module being executed and also
        add that directory to its sys.path if not already included.
        r   Zwith_cwdFaz  if 1:
            __file__ = {filename!r}
            import sys as _sys
            from os.path import basename as _basename
            if (not _sys.argv or
                _basename(_sys.argv[0]) != _basename(__file__)):
                _sys.argv = [__file__]
            import os as _os
            _os.chdir({dirname!r})
            del _sys, _basename, _os
            
r   dirname)r   r   r   r0   interpr   Zuse_subprocessZrestart_subprocessospathr@   Z
runcommandformatZprepend_syspathZruncode)r   r   r   coderA   r@   r   r   r   r      s"    		
zScriptBinding._run_module_eventc             C   s   |  j  j j } |  j  j   s t j d d d d d } | r[ | r[ |  j  j j d  q |  j   } |  j  j j	   | r |  j  j j d  |  j  j j } q d } n  | S)a  Get source filename.  If not saved, offer to save (or create) file

        The debugger requires a source file.  Make sure there is one, and that
        the current version of the source buffer has been saved.  If the user
        declines to save or cancels the Save As dialog, return None.

        If the user has configured IDLE for Autosave, the file will be
        silently saved if it already exists and is dirty.

        mainZGeneralautosavetypeboolN)
r   ior   Z	get_savedr   Z	GetOptionZsaveask_save_dialogr5   	focus_set)r   r   rG   confirmr   r   r   r      s    	zScriptBinding.getfilenamec          	   C   s?   d d
 d } t  j d d d | d t  j d	 |  j j  } | S)NzSource Must Be Saved
    zOK to Save?titlezSave Before Run or Checkmessagedefaultmasterz     )tkMessageBoxZaskokcancelZOKr   r5   )r   r%   rM   r   r   r   rK      s    	zScriptBinding.ask_save_dialogc             C   s0   t  j | | d |  j j |  j j j   d  S)NrS   )rT   Z	showerrorr   r5   rL   )r   rP   rQ   r   r   r   r"      s    zScriptBinding.errorbox)r   r	   )r
   r   )__name__
__module____qualname__Zmenudefsr   r   r   r   r?   r   r   rK   r"   r   r   r   r   r   *   s   
	(r   )__doc__rB   restringr   r   Ztkinter.messageboxZ
messageboxrT   Zidlelib.EditorWindowr   Zidlelibr   r   Zidlelib.configHandlerr   r   r#   r   r   r   r   r   <module>   s   
                                  usr/lib/python3.4/idlelib/__pycache__/ScrolledList.cpython-34.pyc                                   0100644 0000000 0000000 00000012734 13077704335 023255  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T?                 @   sV   d  d l  TGd d   d  Z d d   Z e d k rR d  d l m Z e e  n  d S)	    )*c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d    Z d S)!ScrolledListz(None)c             K   s9  | |  _  t |  |  _ } |  j j d d d d  t | d d |  _ } |  j j d d d d	  t | d
 d d d |  _ } | r | j |  n  | j d d d d  | j	 | d <| j
 | d <| j d |  j  | j d |  j  | j d |  j  | j d |  j  | j d |  j  |  j   d  S)NZfillZbothexpand   namevbarZsiderightyZexportselectionr   Z
backgroundZwhiteZcommandZyscrollcommandz<ButtonRelease-1>z<Double-ButtonRelease-1>z<ButtonPress-3>z<Key-Up>z
<Key-Down>)masterZFrameframeZpackZ	Scrollbarr   ZListboxlistboxZ	configureZyviewsetZbindclick_eventdouble_click_eventpopup_eventup_event
down_eventclear)selfr
   Zoptionsr   r   r    r   */usr/lib/python3.4/idlelib/ScrolledList.py__init__   s$    	zScrolledList.__init__c             C   s   |  j  j   d  S)N)r   Zdestroy)r   r   r   r   close   s    zScrolledList.closec             C   s6   |  j  j d d  d |  _ |  j  j d |  j  d  S)Nr   endr   )r   deleteemptyinsertdefault)r   r   r   r   r   "   s    	zScrolledList.clearc             C   sE   |  j  r( |  j j d d  d |  _  n  |  j j d t |   d  S)Nr   r   )r   r   r   r   str)r   itemr   r   r   append'   s    	zScrolledList.appendc             C   s   |  j  j |  S)N)r   get)r   indexr   r   r   r!   -   s    zScrolledList.getc             C   sP   |  j  j d | j | j f  |  j  j d  } |  j |  |  j |  d S)Nz@%d,%dactivebreak)r   activatexr	   r"   select	on_select)r   eventr"   r   r   r   r   0   s
     zScrolledList.click_eventc             C   s0   |  j  j d  } |  j |  |  j |  d S)Nr#   r$   )r   r"   r'   	on_double)r   r)   r"   r   r   r   r   7   s    zScrolledList.double_click_eventNc             C   sx   |  j  s |  j   n  |  j  } |  j j d | j | j f  |  j j d  } |  j |  | j | j	 | j
  d  S)Nz@%d,%dr#   )menu	make_menur   r%   r&   r	   r"   r'   Ztk_popupZx_rootZy_root)r   r)   r+   r"   r   r   r   r   ?   s    		 zScrolledList.popup_eventc             C   s,   t  |  j d d } | |  _ |  j   d  S)NZtearoffr   )ZMenur   r+   	fill_menu)r   r+   r   r   r   r,   H   s    	zScrolledList.make_menuc             C   s~   |  j  j d  } |  j  j |  r1 | d } n |  j  j   d } | d k  r` |  j  j   n |  j |  |  j |  d S)Nr#   r   r   r$   )r   r"   selection_includessizebellr'   r(   )r   r)   r"   r   r   r   r   M   s    zScrolledList.up_eventc             C   sz   |  j  j d  } |  j  j |  r1 | d } n d } | |  j  j   k r\ |  j  j   n |  j |  |  j |  d S)Nr#   r   r   r$   )r   r"   r.   r/   r0   r'   r(   )r   r)   r"   r   r   r   r   Z   s    zScrolledList.down_eventc             C   sT   |  j  j   |  j  j |  |  j  j d d  |  j  j |  |  j  j |  d  S)Nr   r   )r   Z	focus_setr%   Zselection_clearZselection_setZsee)r   r"   r   r   r   r'   g   s
    zScrolledList.selectc             C   s   d  S)Nr   )r   r   r   r   r-   p   s    zScrolledList.fill_menuc             C   s   d  S)Nr   )r   r"   r   r   r   r(   s   s    zScrolledList.on_selectc             C   s   d  S)Nr   )r   r"   r   r   r   r*   v   s    zScrolledList.on_double)__name__
__module____qualname__r   r   r   r   r    r!   r   r   r+   r   r,   r   r   r'   r-   r(   r*   r   r   r   r   r      s"   		r   c       	      C   s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  Gd d   d t  } | |  } x% t	 d  D] } | j
 d |  q W| j   d  S)	NzTest ScrolledListz[x+]z+%d+%d   c               @   s4   e  Z d  Z d d   Z d d   Z d d   Z d S)z&_scrolled_list.<locals>.MyScrolledListc             S   s   |  j  j d d  d  S)NZlabelzright click)r+   Zadd_command)r   r   r   r   r-      s    z0_scrolled_list.<locals>.MyScrolledList.fill_menuc             S   s   t  d |  j |   d  S)Nr'   )printr!   )r   r"   r   r   r   r(      s    z0_scrolled_list.<locals>.MyScrolledList.on_selectc             S   s   t  d |  j |   d  S)NZdouble)r5   r!   )r   r"   r   r   r   r*      s    z0_scrolled_list.<locals>.MyScrolledList.on_doubleN)r1   r2   r3   r-   r(   r*   r   r   r   r   MyScrolledList   s   r6      z	Item %02d)ZTktitlelistmapintresplitZgeometryr   ranger    Zmainloop)	parentrootwidthZheightr&   r	   r6   Zscrolled_listir   r   r   _scrolled_listz   s    	3rC   __main__)runN)Ztkinterr   rC   r1   Zidlelib.idle_test.htestrE   r   r   r   r   <module>   s
   
w                                    usr/lib/python3.4/idlelib/__pycache__/SearchDialog.cpython-34.pyc                                   0100644 0000000 0000000 00000006427 13077704335 023201  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TJ
                 @   s   d  d l  Td  d l m Z d  d l m Z d d   Z d d   Z d d	   Z d
 d   Z Gd d   d e  Z	 d d   Z
 e d k r d  d l m Z e e
  n  d S)    )*)SearchEngine)SearchDialogBasec             C   sF   |  j    } t j |  } t | d  s? t | |  | _ n  | j S)N_searchdialog)Z_rootr   gethasattrSearchDialogr   )textrootengine r   */usr/lib/python3.4/idlelib/SearchDialog.py_setup   s
    r   c             C   s(   |  j  d d  } t |   j |  |  S)Nz	sel.firstzsel.last)r   r   open)r	   patr   r   r   find   s    r   c             C   s   t  |   j |   S)N)r   
find_again)r	   r   r   r   r      s    r   c             C   s   t  |   j |   S)N)r   find_selection)r	   r   r   r   r      s    r   c               @   sC   e  Z d  Z d d   Z d d d  Z d d   Z d d	   Z d S)
r   c             C   s)   t  j |   } |  j d |  j d  d  S)Nz	Find Next   )r   create_widgetsZmake_buttondefault_command)selffr   r   r   r      s    zSearchDialog.create_widgetsNc             C   s'   |  j  j   s d  S|  j |  j  d  S)N)r   getprogr   r	   )r   Zeventr   r   r   r      s    zSearchDialog.default_commandc             C   sT  |  j  j   s  |  j |  d S|  j  j   s3 d S|  j  j |  } | rB| \ } } | j   \ } } d | | f } d | | f } yH | j d  }	 | j d  }
 |	 | k r |
 | k r | j   d SWn t k
 r Yn X| j	 d d d  | j
 d | |  | j d |  j  j   r*| p-|  | j d  d	 S| j   d Sd  S)
NFz%d.%dz	sel.firstzsel.lastZselz1.0endinsertT)r   Zgetpatr   r   Zsearch_textspanindexZbellZTclError
tag_removetag_addZmark_setZisbackZsee)r   r	   ZreslinemijfirstlastZselfirstZsellastr   r   r   r   "   s4    
%
zSearchDialog.find_againc             C   s8   | j  d d  } | r+ |  j j |  n  |  j |  S)Nz	sel.firstzsel.last)r   r   Zsetcookedpatr   )r   r	   r   r   r   r   r   ?   s    zSearchDialog.find_selection)__name__
__module____qualname__r   r   r   r   r   r   r   r   r      s   r   c                s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  t |      j	     j
 d d d    f d d	   } t | d
 d d | } | j	   d  S)NzTest SearchDialogz[x+]z+%d+%d   r   zThis is a sample string.

   c                 sC     j  t d t  t    }  |  j      j t d t  d  S)Nz1.0)r   ZSELZENDr   r   r   )s)r	   r   r   	show_findN   s    z!_search_dialog.<locals>.show_findr	   ZSearchZcommand)ZTktitlelistmapintresplitZgeometryZTextZpackr   ZButton)parentr
   widthZheightxyr,   Zbuttonr   )r	   r   _search_dialogE   s    	3
r7   __main__)runN)ZtkinterZidlelibr   Zidlelib.SearchDialogBaser   r   r   r   r   r   r7   r&   Zidlelib.idle_test.htestr9   r   r   r   r   <module>   s   
.                                                                                                                                                                                                                                         usr/lib/python3.4/idlelib/__pycache__/SearchDialogBase.cpython-34.pyc                               0100644 0000000 0000000 00000017022 13077704335 023765  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Ta                 @   s   d  Z  d d l m Z m Z m Z m Z m Z m Z m Z Gd d   d  Z	 e
 d k r{ d d l Z e j d d d	 n  d S)
zBDefine SearchDialogBase used by Search, Replace, and Grep dialogs.    )ToplevelFrameEntryLabelButtonCheckbuttonRadiobuttonc               @   s   e  Z d  Z d Z d Z d Z d Z d d   Z d d d	  Z d d
 d  Z	 d d   Z
 d d   Z d d   Z d d d  Z d d   Z d d   Z d d d  Z d d   Z d S)SearchDialogBaseay  Create most of a 3 or 4 row, 3 column search dialog.

    The left and wide middle column contain:
    1 or 2 labeled text entry lines (make_entry, create_entries);
    a row of standard Checkbuttons (make_frame, create_option_buttons),
    each of which corresponds to a search engine Variable;
    a row of dialog-specific Check/Radiobuttons (create_other_buttons).

    The narrow right column contains command buttons
    (make_button, create_command_buttons).
    These are bound to functions that execute the command.

    Except for command buttons, this base class is not limited to items
    common to all three subclasses.  Rather, it is the Find dialog minus
    the "Find Next" command, its execution function, and the
    default_command attribute needed in create_widgets. The other
    dialogs override attributes and methods, the latter to replace and
    add widgets.
    zSearch DialogZSearch   c             C   s   | |  _  | |  _ d |  _ d S)a'  Initialize root, engine, and top attributes.

        top (level widget): set in create_widgets() called from open().
        text (Text searched): set in open(), only used in subclasses().
        ent (ry): created in make_entry() called from create_entry().
        row (of grid): 0 in create_widgets(), +1 in make_entry/frame().
        default_command: set in subclasses, used in create_widgers().

        title (of dialog): class attribute, override in subclasses.
        icon (of dialog): ditto, use unclear if cannot minimize dialog.
        N)rootenginetop)selfr   r    r   ./usr/lib/python3.4/idlelib/SearchDialogBase.py__init__   s    		zSearchDialogBase.__init__Nc             C   s   | |  _  |  j s |  j   n |  j j   |  j j   | rh |  j j d d  |  j j d |  n  |  j j   |  j j	 d d  |  j j
 d  |  j j   d S)z6Make dialog visible on top of others and ready to use.r   endN)textr   create_widgetsZ	deiconifyZtkraiseentZdeleteinsertZ	focus_setZselection_rangeZicursorZgrab_set)r   r   Zsearchphraser   r   r   open/   s    		zSearchDialogBase.openc             C   s*   |  j  r& |  j  j   |  j  j   n  d S)zPut dialog away for later use.N)r   Zgrab_releaseZwithdraw)r   Zeventr   r   r   close?   s    	zSearchDialogBase.closec             C   s   t  |  j  } | j d |  j  | j d |  j  | j d |  j  | j |  j  | j |  j	  | |  _
 d |  _ |  j
 j d d d d d |  j
 j d d d d	 d
 d d
 |  j   |  j   |  j   |  j   d S)zCreate basic 3 row x 3 col search (find) dialog.

        Other dialogs override subsidiary create_x methods as needed.
        Replace and Find-in-Files add another entry row.
        z<Return>z<Escape>ZWM_DELETE_WINDOWr   Zpad   Zweightr
   Zminsized   N)r   r   ZbindZdefault_commandr   ZprotocolZwm_titletitleZwm_iconnameiconr   rowZgrid_columnconfigurecreate_entriescreate_option_buttonscreate_other_buttonscreate_command_buttons)r   r   r   r   r   r   E   s    		"


zSearchDialogBase.create_widgetsc             C   s   t  |  j d | } | j d |  j d d d d  t |  j d | d d } | j d |  j d d	 d d
  |  j d	 |  _ | | f S)zReturn (entry, label), .

        entry - gridded labeled Entry for text entry.
        label - Label widget, returned for testing.
        r   r   columnr   stickynwZtextvariableZexportselectionr
   nwe)r   r   gridr   r   )r   Z
label_textvarlabelentryr   r   r   
make_entry\   s    zSearchDialogBase.make_entryc             C   s#   |  j  d |  j j  d |  _ d S)z/Create one or more entry lines with make_entry.zFind:r   N)r*   r   Zpatvarr   )r   r   r   r   r   i   s    zSearchDialogBase.create_entriesc          	   C   s   | r= t  |  j d | } | j d |  j d d d d  n d } t |  j  } | j d |  j d d d	 d d d
  |  j d |  _ | | f S)zReturn (frame, label).

        frame - gridded labeled Frame for option or other buttons.
        label - Label widget, returned for testing.
        r   r   r"   r   r#   r$    r
   Z
columnspanr%   )r   r   r&   r   r   )r   Z	labeltextr(   framer   r   r   
make_framem   s    "%zSearchDialogBase.make_framec          	   C   s   |  j  d  d } |  j } | j d f | j d f | j d f g } |  j rh | j | j d f  n  xa | D]Y \ } } t | d d d	 | d
 | } | j	 d d d d  | j
   ro | j   qo qo W| | f S)a  Return (filled frame, options) for testing.

        Options is a list of SearchEngine booleanvar, label pairs.
        A gridded frame from make_frame is filled with a Checkbutton
        for each pair, bound to the var, with the corresponding label.
        ZOptionsr   zRegular expressionz
Match casez
Whole wordzWrap aroundanchorwvariabler   sideleftfillboth)r-   r   ZrevarZcasevarZwordvarneedwrapbuttonappendZwrapvarr   packgetselect)r   r,   r   Zoptionsr'   r(   btnr   r   r   r   }   s    		z&SearchDialogBase.create_option_buttonsc             C   s   |  j  d  d } |  j j } d d g } xm | D]e \ } } t | d d d | d	 | d
 | } | j d d d d  | j   | k r2 | j   q2 q2 W| | f S)zReturn (frame, others) for testing.

        Others is a list of value, label pairs.
        A gridded frame from make_frame is filled with radio buttons.
        Z	Directionr   r
   UpDownr.   r/   r0   valuer   r1   r2   r3   r4   )r
   r;   )r   r<   )r-   r   Zbackvarr   r7   r8   r9   )r   r,   r'   Zothersvalr(   r:   r   r   r   r       s    z%SearchDialogBase.create_other_buttonsr   c          	   C   s   t  |  j d | d | d | r$ d p' d } |  j j   \ } } | j d d d | d	 d
 d d  |  j j d | d  | S)z/Return command button gridded in command frame.r   commanddefaultZactiveZnormalpadyr
   r   r"   r   r#   ZewZrowspan)r   buttonframeZ	grid_sizer&   )r   r(   r?   ZisdefbZcolsZrowsr   r   r   make_button   s    "zSearchDialogBase.make_buttonc             C   sg   t  |  j  } |  _ | j d d d d d d d d d d d d  |  j d	 |  j  } | j   d
 S)z9Place buttons in vertical command frame gridded on right.r   r   r"   r   ZpadxrA   ZipadxZipadyr   N)r   r   rB   r&   rD   r   lower)r   frC   r   r   r   r!      s    .z'SearchDialogBase.create_command_buttons)__name__
__module____qualname____doc__r   r   r5   r   r   r   r   r*   r   r-   r   r    rD   r!   r   r   r   r   r	      s   
r	   __main__Nz'idlelib.idle_test.test_searchdialogbase	verbosityr   )rJ   Ztkinterr   r   r   r   r   r   r   r	   rG   Zunittestmainr   r   r   r   <module>   s   4                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              usr/lib/python3.4/idlelib/__pycache__/SearchEngine.cpython-34.pyc                                   0100644 0000000 0000000 00000016437 13077704335 023211  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T;                 @   s   d  Z  d d l Z d d l m Z m Z m Z d d l j Z d d   Z	 Gd d   d  Z
 d d	   Z d
 d   Z d d   Z e d k r d d l Z e j d d d d d n  d S)z'Define SearchEngine for search dialogs.    N)	StringVar
BooleanVarTclErrorc             C   s(   t  |  d  s! t |   |  _ n  |  j S)zReturn the singleton SearchEngine instance for the process.

    The single SearchEngine saves settings between dialog instances.
    If there is not a SearchEngine already, make one.
    _searchengine)hasattrSearchEnginer   )root r	   */usr/lib/python3.4/idlelib/SearchEngine.pyget   s    r   c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d# d d  Z d d d d  Z d d d   Z d d! d"  Z d S)$r   z<Handles searching a text widget for Find, Replace, and Grep.c             C   sy   | |  _  t | d  |  _ t | d  |  _ t | d  |  _ t | d  |  _ t | d  |  _ t | d  |  _ d S)zInitialize Variables that save search state.

        The dialogs bind these to the UI elements present in the dialogs.
         FTN)	r   r   patvarr   revarcasevarwordvarwrapvarbackvar)selfr   r	   r	   r
   __init__   s    	zSearchEngine.__init__c             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   getpat#   s    zSearchEngine.getpatc             C   s   |  j  j |  d  S)N)r   set)r   patr	   r	   r
   setpat&   s    zSearchEngine.setpatc             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   isre)   s    zSearchEngine.isrec             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   iscase,   s    zSearchEngine.iscasec             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   isword/   s    zSearchEngine.iswordc             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   iswrap2   s    zSearchEngine.iswrapc             C   s   |  j  j   S)N)r   r   )r   r	   r	   r
   isback5   s    zSearchEngine.isbackc             C   s/   |  j    r t j |  } n  |  j |  d S)z!Set pattern after escaping if re.N)r   reescaper   )r   r   r	   r	   r
   setcookedpat:   s    zSearchEngine.setcookedpatc             C   sG   |  j    } |  j   s* t j |  } n  |  j   rC d | } n  | S)Nz\b%s\b)r   r   r   r   r   )r   r   r	   r	   r
   getcookedpatA   s    zSearchEngine.getcookedpatc             C   s   |  j    } | s& |  j | d  d S|  j   } d } |  j   sT | t j B} n  y t j | |  } Wnt t j k
 r } zQ | j } | d } t	 |  d k r | d n d } |  j | | |  d SWYd d } ~ Xn X| S)z&Return compiled cooked search pattern.zEmpty regular expressionNr         )
r   report_errorr!   r   r   
IGNORECASEcompileerrorargslen)r   r   flagsprogZwhatr)   msgcolr	   r	   r
   getprogI   s"    	
"zSearchEngine.getprogr#   c             C   sm   d t  |  } | r- | d t  |  } n  | d k rP | d t  |  } n  t j d | d |  j d  S)NzError: z

Pattern: r   z	
Offset: zRegular expression errorZmaster)strtkMessageBoxZ	showerrorr   )r   r   r-   r.   r	   r	   r
   r%   ]   s    	zSearchEngine.report_errorNr   c             C   s   | s |  j    } | s d Sn  |  j j   } t |  \ } } |  j   r | r[ | } n | } t |  \ } }	 |  j | | | |	 | |  }
 nE | r | } n | } t |  \ } }	 |  j | | | |	 | |  }
 |
 S)a  Return (lineno, matchobj) or None for forward/backward search.

        This function calls the right function with the right arguments.
        It directly return the result of that call.

        Text is a text widget. Prog is a precompiled pattern.
        The ok parameteris a bit complicated as it has two effects.

        If there is a selection, the search begin at either end,
        depending on the direction setting and ok, with ok meaning that
        the search starts with the selection. Otherwise, search begins
        at the insert mark.

        To aid progress, the search functions do not return an empty
        match at the starting position unless ok is True.
        N)r/   r   r   get_selectionr   get_line_colsearch_backwardsearch_forward)r   textr,   okwrapfirstlaststartliner.   Zresr	   r	   r
   search_textg   s$    	!	zSearchEngine.search_textc             C   s   d } | } | j  d | d | d  }	 x |	 r | j |	 d  d  |  }
 |
 rz | sm |
 j   | k rz | |
 f Sn  | d } | r | | k r Pn  d } d } | j  d | d | d  }	 |	 r- | r- d } d } d } | j  d d  }	 q- q- Wd  S)Nr   z%d.0r#   z1.0z2.0r$   )r   searchend)r   r6   r,   r<   r.   r8   r7   wrapped	startlinecharsmr	   r	   r
   r5      s(    	
zSearchEngine.search_forwardc             C   s!  d } | } | j  d | d | d  }	 x t | |	 d  d  |  }
 |
 rt | sg |
 j   | k  rt | |
 f Sn  | d } | r | | k  r Pn  d } | d k r | s Pn  d } d } | j d  } t t | j d   \ } } n  | j  d | d | d  }	 t |	  d } q- d  S)Nr   z%d.0r#   zend-1c.r$   )r   search_reverser;   indexmapintsplitr*   )r   r6   r,   r<   r.   r8   r7   r@   rA   rB   rC   posr	   r	   r
   r4      s,    
!zSearchEngine.search_backwardr$   )__name__
__module____qualname____doc__r   r   r   r   r   r   r   r   r    r!   r/   r%   r=   r5   r4   r	   r	   r	   r
   r      s    
(r   c             C   s   |  j  |  } | s d Sd } | j   \ } } xi | | k  r | | k r | } | | k rk | d } n  |  j  | |  } | s Pn  | j   \ } } q4 W| S)a%  Search backwards and return an re match object or None.

    This is done by searching forwards until there is no match.
    Prog: compiled re object with a search method returning a match.
    Chars: line of text, without 
.
    Col: stop index for the search; the limit for match.end().
    Nr#   )r>   span)r,   rB   r.   rC   foundijr	   r	   r
   rE      s    rE   c             C   sr   y" |  j  d  } |  j  d  } Wn t k
 r@ d } } Yn X| sY |  j  d  } n  | sh | } n  | | f S)zFReturn tuple of 'line.col' indexes from selection or insert mark.
    z	sel.firstzsel.lastNinsert)rF   r   )r6   r9   r:   r	   r	   r
   r2      s    	r2   c             C   s(   t  t |  j d   \ } } | | f S)z8Return (line, col) tuple of ints from 'line.col' string.rD   )rG   rH   rI   )rF   r<   r.   r	   r	   r
   r3      s    r3   __main__z#idlelib.idle_test.test_searchengine	verbosityr"   exitF)rN   r   Ztkinterr   r   r   Ztkinter.messageboxZ
messageboxr1   r   r   rE   r2   r3   rK   Zunittestmainr	   r	   r	   r
   <module>   s                                                                                                                                                                                                                                    usr/lib/python3.4/idlelib/__pycache__/StackViewer.cpython-34.pyc                                    0100644 0000000 0000000 00000012774 13077704335 023105  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T:                 @   s  d  d l  Z  d  d l Z d  d l Z d  d l Z d  d l Z d  d l m Z m Z m	 Z	 d  d l
 m Z m Z d  d l m Z d d d d d  Z Gd d   d e  Z Gd	 d
   d
 e  Z Gd d   d e  Z d d   Z e d k r
d  d l m Z e e  n  d S)    N)TreeNodeTreeItemScrolledCanvas)ObjectTreeItemmake_objecttreeitem)PyShellFileListc             C   s   | d  k r+ d d l  m } | |   } n  t | d d d d } | j j d d d d	  t | |  } t | j d  |  } | j   d  S)
Nr   )ToplevelZbgZwhiteZhighlightthicknessexpand   ZfillZboth)	tkinterr   r   frameZpackStackTreeItemr   Zcanvasr	   )rootflisttbtopr   ZscitemZnode r   )/usr/lib/python3.4/idlelib/StackViewer.pyStackBrowser   s    r   c               @   sR   e  Z d  Z d d d d  Z d d   Z d d   Z d d	   Z d
 d   Z d S)r   Nc             C   s.   | |  _  |  j |  |  _ |  j   |  _ d  S)N)r   	get_stackstackget_exceptiontext)selfr   r   r   r   r   __init__   s    	zStackTreeItem.__init__c             C   sx   | d  k r t  j } n  g  } | r? | j d  k r? | j } n  x2 | d  k	 rs | j | j | j f  | j } qB W| S)N)syslast_tracebacktb_frametb_nextappend	tb_lineno)r   r   r   r   r   r   r      s    zStackTreeItem.get_stackc             C   s`   t  j } t  j } t | d  r- | j } n  t |  } | d  k	 r\ | d t |  } n  | S)N__name__z: )r   	last_type
last_valuehasattrr"   str)r   typevaluesr   r   r   r   '   s    		zStackTreeItem.get_exceptionc             C   s   |  j  S)N)r   )r   r   r   r   GetText1   s    zStackTreeItem.GetTextc             C   s=   g  } x0 |  j  D]% } t | |  j  } | j |  q W| S)N)r   FrameTreeItemr   r    )r   sublistinfor   r   r   r   
GetSubList4   s
    zStackTreeItem.GetSubList)r"   
__module____qualname__r   r   r   r*   r.   r   r   r   r   r      s
   
r   c               @   s@   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 S)
r+   c             C   s   | |  _  | |  _ d  S)N)r-   r   )r   r-   r   r   r   r   r   =   s    	zFrameTreeItem.__init__c       	      C   s   |  j  \ } } y | j d } Wn d } Yn X| j } | j } | j } t j | |  } | j   } | d k r d | | | f } n d | | | | f } | S)Nr"   ? z%s, line %d: %sz%s.%s(...), line %d: %s)r1   r2   N)r-   	f_globalsf_codeco_filenameco_name	linecachegetlinestrip)	r   r   linenomodnamecodefilenameZfuncnameZ
sourceliner   r   r   r   r*   A   s    				zFrameTreeItem.GetTextc             C   sx   |  j  \ } } g  } | j | j k	 rO t d | j |  j  } | j |  n  t d | j |  j  } | j |  | S)Nz<locals>z	<globals>)r-   r3   f_localsVariablesTreeItemr   r    )r   r   r:   r,   r   r   r   r   r.   S   s    zFrameTreeItem.GetSubListc             C   sS   |  j  rO |  j \ } } | j j } t j j |  rO |  j  j | |  qO n  d  S)N)r   r-   r4   r5   ospathisfileZgotofileline)r   r   r:   r=   r   r   r   OnDoubleClick]   s
    	zFrameTreeItem.OnDoubleClickN)r"   r/   r0   r   r*   r.   rC   r   r   r   r   r+   ;   s   
r+   c               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)r?   c             C   s   |  j  S)N)Z	labeltext)r   r   r   r   r*   f   s    zVariablesTreeItem.GetTextc             C   s   d  S)Nr   )r   r   r   r   GetLabelTexti   s    zVariablesTreeItem.GetLabelTextc             C   s   t  |  j  d k S)Nr   )lenobject)r   r   r   r   IsExpandablel   s    zVariablesTreeItem.IsExpandablec             C   s   t  |  j j    S)N)listrF   keys)r   r   r   r   rI   o   s    zVariablesTreeItem.keysc             C   s   g  } xu |  j    D]g } y |  j | } Wn t k
 rA w Yn X| |  j d d  } t | d | |  } | j |  q W| S)Nc             S   s   |  | | <d  S)Nr   )r(   keyrF   r   r   r   setfunctiony   s    z1VariablesTreeItem.GetSubList.<locals>.setfunctionz =)rI   rF   KeyErrorr   r    )r   r,   rJ   r(   rK   r   r   r   r   r.   r   s    zVariablesTreeItem.GetSubListN)r"   r/   r0   r*   rD   rG   rI   r.   r   r   r   r   r?   d   s
   r?   c       
      C   s   t  j   } | j d  t t t t j d |  j      \ } } } } | j d | | d f  t	 |  } y t
 Wn' t k
 r t j   \ } } }	 Yn X| t _ | t _ |	 t _ t | d | d | d |	 t ` t ` t ` d  S)NzTest StackViewerz[x+]z+%d+%d   r   r   r   )tkZTktitlerH   mapintresplitZgeometryr   Zintentional_name_error	NameErrorr   exc_infor#   r$   r   r   )
parentr   widthZheightxyr   exc_type	exc_valueZexc_tbr   r   r   _stack_viewer   s     3			r\   __main__)run)r@   r   r7   rR   r   rN   Zidlelib.TreeWidgetr   r   r   Zidlelib.ObjectBrowserr   r   Zidlelib.PyShellr   r   r   r+   r?   r\   r"   Zidlelib.idle_test.htestr^   r   r   r   r   <module>   s   
&)    usr/lib/python3.4/idlelib/__pycache__/ToolTip.cpython-34.pyc                                        0100644 0000000 0000000 00000007705 13077704335 022246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Te                 @   s   d  d l  TGd d   d  Z Gd d   d e  Z Gd d   d e  Z d d	   Z e d
 k r~ d  d l m Z e e  n  d S)    )*c               @   sy   e  Z d  Z d d   Z d d d  Z d d d  Z d d	   Z d
 d   Z d d   Z d d d  Z	 d d   Z
 d S)ToolTipBasec             C   s   | |  _  d  |  _ d  |  _ d |  _ |  _ |  j  j d |  j  |  _ |  j  j d |  j  |  _	 |  j  j d |  j  |  _
 d  S)Nr   z<Enter>z<Leave>z<ButtonPress>)button	tipwindowidxyZbindenterZ_id1leaveZ_id2Z_id3)selfr    r   %/usr/lib/python3.4/idlelib/ToolTip.py__init__
   s    			zToolTipBase.__init__Nc             C   s   |  j    d  S)N)schedule)r   eventr   r   r   r	      s    zToolTipBase.enterc             C   s   |  j    |  j   d  S)N)
unschedulehidetip)r   r   r   r   r   r
      s    
zToolTipBase.leavec             C   s)   |  j    |  j j d |  j  |  _ d  S)Ni  )r   r   Zaftershowtipr   )r   r   r   r   r      s    
zToolTipBase.schedulec             C   s/   |  j  } d  |  _  | r+ |  j j |  n  d  S)N)r   r   Zafter_cancel)r   r   r   r   r   r      s    		zToolTipBase.unschedulec             C   s   |  j  r d  S|  j j   d } |  j j   |  j j   d } t |  j  |  _  } | j d  | j d | | f  |  j   d  S)N      z+%d+%d)	r   r   Zwinfo_rootxZwinfo_rootyZwinfo_heightZToplevelZwm_overrideredirectZwm_geometryshowcontents)r   r   r   twr   r   r   r   $   s    	 zToolTipBase.showtipzYour text herec             C   s;   t  |  j d | d t d d d t d d } | j   d  S)NtextZjustify
backgroundz#ffffe0ZreliefZborderwidthr   )Labelr   ZLEFTZSOLIDpack)r   r   labelr   r   r   r   2   s    zToolTipBase.showcontentsc             C   s)   |  j  } d  |  _  | r% | j   n  d  S)N)r   Zdestroy)r   r   r   r   r   r   8   s    		zToolTipBase.hidetip)__name__
__module____qualname__r   r	   r
   r   r   r   r   r   r   r   r   r   r      s   	r   c               @   s(   e  Z d  Z d d   Z d d   Z d S)ToolTipc             C   s   t  j |  |  | |  _ d  S)N)r   r   r   )r   r   r   r   r   r   r   ?   s    zToolTip.__init__c             C   s   t  j |  |  j  d  S)N)r   r   r   )r   r   r   r   r   B   s    zToolTip.showcontentsN)r   r   r   r   r   r   r   r   r   r    >   s   r    c               @   s(   e  Z d  Z d d   Z d d   Z d S)ListboxToolTipc             C   s   t  j |  |  | |  _ d  S)N)r   r   items)r   r   r"   r   r   r   r   F   s    zListboxToolTip.__init__c             C   sG   t  |  j d d } | j   x! |  j D] } | j t |  q) Wd  S)Nr   z#ffffe0)ZListboxr   r   r"   insertZEND)r   Zlistboxitemr   r   r   r   I   s    
zListboxToolTip.showcontentsN)r   r   r   r   r   r   r   r   r   r!   E   s   r!   c       	      C   s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  t | d d } | j	   t
 | d d } t
 | d d } | j	   | j	   t | d	  t | d
 d d d g  | j   d  S)NzTest tooltipz[x+]z+%d+%d   r   zPlace your mouse over buttonszButton 1zButton 2z!This is tooltip text for button1.zThis iszmultiple lineztooltip textzfor button2)ZTktitlelistmapintresplitZgeometryr   r   ZButtonr    r!   Zmainloop)	parentrootwidthZheightr   r   r   Zbutton1Zbutton2r   r   r   _tooltipO   s    	3


r/   __main__)runN)Ztkinterr   r    r!   r/   r   Zidlelib.idle_test.htestr1   r   r   r   r   <module>   s   
6
                                                           usr/lib/python3.4/idlelib/__pycache__/TreeWidget.cpython-34.pyc                                     0100644 0000000 0000000 00000036450 13077704335 022716  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T:                 @   sV  d  d l  Z  d  d l Td  d l m Z d  d l m Z d Z y% e  j j e  j j	 e
  e  Z Wn e k
 r{ e Z Yn Xe  j j e  r e Z n( e  j j e  s e d e f   n  e d d  Z Gd	 d
   d
  Z Gd d   d  Z Gd d   d e  Z Gd d   d  Z d d   Z e d k rRd  d l m Z e e  n  d S)    N)*)
ZoomHeight)idleConfZIconszcan't find icon directory (%r)c          	   C   s8  t    } d d l } | j t j j |  d   } | j   g  } d } } x | D] } t j j t j j |   d } t d | d |  }	 | j	 |	  t
 | d |	 d d d	 d
 }
 |
 j d | d |  t
 | d | }
 |
 j d | d d |  | d } | d k rT | d } d } qT qT W| | _ d S)z'Utility to display the available icons.r   Nz*.giffilemasterimagebd   ZreliefZraisedrowcolumntext
      )Tkglobospathjoinsortsplitextbasename
PhotoImageappendLabelgridimages)Zicondirrootr   listr   r
   r   r   namer   label r    (/usr/lib/python3.4/idlelib/TreeWidget.py	listicons#   s&    	

"

r"   c               @   s  e  Z d  Z d d   Z d d   Z d d   Z d d d	  Z d d
 d  Z d d   Z d d   Z	 d d d  Z
 d d d  Z d d d  Z d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d d" d#  Z d d$ d%  Z d d& d'  Z d d( d)  Z d S)*TreeNodec             C   sS   | |  _  | |  _ | |  _ d |  _ d |  _ g  |  _ d  |  _ |  _ i  |  _ d  S)N	collapsedF)	canvasparentitemstateselectedchildrenxy
iconimages)selfr%   r&   r'   r    r    r!   __init__<   s    						zTreeNode.__init__c             C   sE   x5 |  j  d  d   D]  } |  j  j |  | j   q Wd  |  _ d  S)N)r*   removedestroyr&   )r.   cr    r    r!   r1   F   s    zTreeNode.destroyc             C   s   y |  j  | SWn t k
 r# Yn Xt j j |  \ } } | pE d } t j j t | |  } t d |  j d |  } | |  j  | <| S)Nz.gifr   r   )	r-   KeyErrorr   r   r   r   ICONDIRr   r%   )r.   r   r   Zextfullnamer   r    r    r!   geticonimageL   s    zTreeNode.geticonimageNc             C   sK   |  j  r d  S|  j   d |  _  |  j j |  j  |  j   |  j   d  S)NT)r)   deselectallr%   deleteimage_iddrawicondrawtext)r.   eventr    r    r!   selectX   s    	
	
zTreeNode.selectc             C   sA   |  j  s d  Sd |  _  |  j j |  j  |  j   |  j   d  S)NF)r)   r%   r8   r9   r:   r;   )r.   r<   r    r    r!   deselecta   s    		
zTreeNode.deselectc             C   s'   |  j  r |  j  j   n
 |  j   d  S)N)r&   r7   deselecttree)r.   r    r    r!   r7   i   s    	zTreeNode.deselectallc             C   s8   |  j  r |  j   n  x |  j D] } | j   q  Wd  S)N)r)   r>   r*   r?   )r.   childr    r    r!   r?   o   s    	zTreeNode.deselecttreec             C   s7   |  j  d k r |  j   n
 |  j   |  j j   d S)Nexpandedbreak)r(   collapseexpandr'   OnDoubleClick)r.   r<   r    r    r!   flipu   s
    
zTreeNode.flipc             C   sF   |  j  j   s d  S|  j d k rB d |  _ |  j   |  j   n  d  S)NrA   )r'   _IsExpandabler(   updateview)r.   r<   r    r    r!   rD   }   s    	
zTreeNode.expandc             C   s)   |  j  d k r% d |  _  |  j   n  d  S)Nr$   )r(   rH   )r.   r<   r    r    r!   rC      s    	zTreeNode.collapsec             C   s   |  j  d } |  j   j  d } | | } |  j j d  } |  j j   } |  j j |  } | | k ry | | k ry d  S|  j j |  j d  \ } } }	 }
 | | k r | | k r | | | } n | } t |  |
 } |  j j |  d  S)Nr      r   scrollregion)r,   lastvisiblechildr%   ZcanvasyZwinfo_heightZ_getintsfloatZyview_moveto)r.   topZbottomheightZvisible_topZvisible_heightZvisible_bottomx0y0x1y1Zfractionr    r    r!   rI      s    
%zTreeNode.viewc             C   s1   |  j  r) |  j d k r) |  j  d j   S|  Sd  S)NrA   r	   )r*   r(   rL   )r.   r    r    r!   rL      s    zTreeNode.lastvisiblechildc             C   s   |  j  r |  j  j   n |  j d } d |  j d <|  j j   |  j j t  |  j d d  |  j j t  \ } } } } |  j j d d d | | f  | |  j d <d  S)NZcursorZwatch   r   rK   r   )r&   rH   r%   r8   ZALLdrawbbox	configure)r.   Z	oldcursorrP   rQ   rR   rS   r    r    r!   rH      s    	zTreeNode.updatec             C   s  | | |  _  |  _ |  j   |  j   |  j d k r> | d S|  j s |  j j   } | sd | d Sx9 | D]. } |  j |  j	 |  |  } |  j j
 |  qk Wn  | d } | d } d } x |  j D] } | } |  j	 j | d | d | | d d d | j | |  } | j j   r | j d k r=d	 }	 | j }
 n d
 }	 | j }
 |  j |	  } |  j	 j | d | d d | } |  j	 j | d |
  |  j	 j | d d d    q q W|  j	 j | d | d | d | d d d } |  j	 j |  | S)NrA   rJ      r   	   rU   fillZgray50Z	minusnodeZplusnoder   z<1>z
<Double-1>c             S   s   d  S)Nr    )r+   r    r    r!   <lambda>   s    zTreeNode.draw.<locals>.<lambda>r   )r+   r,   r:   r;   r(   r*   r'   _GetSubList	__class__r%   r   Zcreate_linerV   rG   rC   rD   r6   create_imagetag_bindZ	tag_lower)r.   r+   r,   sublistr'   r@   ZcxZcyZcylastZiconnamecallbackr   idr    r    r!   rV      sB    

	

+	##(	zTreeNode.drawc             C   s   |  j  r0 |  j j   p* |  j j   p* d } n |  j j   pB d } |  j |  } |  j j |  j |  j d d d | } | |  _	 |  j j
 | d |  j  |  j j
 | d |  j  d  S)NZ
openfolderZfolderanchornwr   z<1>z
<Double-1>)r)   r'   GetSelectedIconNameGetIconNamer6   r%   r_   r+   r,   r9   r`   r=   rF   )r.   Z	imagenamer   rc   r    r    r!   r:      s    		'	zTreeNode.drawiconc             C   s  |  j  d d } |  j d } |  j j   } | r |  j j | | d d d | } |  j j | d |  j  |  j j | d |  j  |  j j	 |  \ } } } } t
 | d  d	 } n  |  j j   p d
 }	 y |  j Wn t k
 r Yn X|  j   y |  j }
 Wn< t k
 rDt |  j d |	 d d d d d d |  _ Yn Xt j d d d  } |  j r|  j j t j | d   n |  j j t j | d   |  j j | | d d d |  j } |  j j d |  j  |  j j d |  j  | |  _ d  S)NrY   r	   rd   re   r   z<1>z
<Double-1>   r   z	<no text>r   r   Zpadxr   ZpadymainZThemer   ZhiliteZnormalZwindow)r+   r,   r'   GetLabelTextr%   Zcreate_textr`   r=   rF   rW   maxGetTextentryAttributeErroredit_finishr   r   r   Z	GetOptionr)   rX   ZGetHighlightZcreate_windowbindselect_or_editZtext_id)r.   ZtextxZtextyZ	labeltextrc   rP   rQ   rR   rS   r   r   Zthemer    r    r!   r;      s:    	
/	zTreeNode.drawtextc             C   s9   |  j  r( |  j j   r( |  j |  n |  j |  d  S)N)r)   r'   
IsEditableeditr=   )r.   r<   r    r    r!   rq     s    zTreeNode.select_or_editc             C   s   t  |  j d d d d d d |  _ |  j j d |  j d  |  j j d t  |  j j d d  |  j j   |  j j d	 |  j	  |  j j d
 |  j
  d  S)Nr   r   highlightthicknessr	   widthr   Zipadx   z<Return>z<Escape>)ZEntryr   rm   insertZselection_rangeZENDpack	focus_setrp   ro   edit_cancel)r.   r<   r    r    r!   rs     s    $zTreeNode.editc             C   s   y |  j  } |  `  Wn t k
 r+ d  SYn X| j   } | j   | rp | |  j j   k rp |  j j |  n  |  j j   } | |  j d <|  j   |  j	 j
   d  S)Nr   )rm   rn   getr1   r'   rl   SetTextr   r;   r%   ry   )r.   r<   rm   r   r    r    r!   ro     s    	
	

zTreeNode.edit_finishc             C   sQ   y |  j  } |  `  Wn t k
 r+ d  SYn X| j   |  j   |  j j   d  S)N)rm   rn   r1   r;   r%   ry   )r.   r<   rm   r    r    r!   rz   $  s    	
	

zTreeNode.edit_cancel)__name__
__module____qualname__r/   r1   r6   r=   r>   r7   r?   rF   rD   rC   rI   rL   rH   rV   r:   r;   rq   rs   ro   rz   r    r    r    r!   r#   :   s(   
	)"	r#   c               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d Z d	 d
   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d S)TreeItemzAbstract class representing tree items.

    Methods should typically be overridden, otherwise a default action
    is used.

    c             C   s   d S)z)Constructor.  Do whatever you need to do.Nr    )r.   r    r    r!   r/   8  s    zTreeItem.__init__c             C   s   d S)zReturn text string to display.Nr    )r.   r    r    r!   rl   ;  s    zTreeItem.GetTextc             C   s   d S)z>Return label text string to display in front of text (if any).Nr    )r.   r    r    r!   rj   >  s    zTreeItem.GetLabelTextNc             C   s(   |  j  d k r! |  j   |  _  n  |  j  S)z%Do not override!  Called by TreeNode.N)
expandableIsExpandable)r.   r    r    r!   rG   C  s    zTreeItem._IsExpandablec             C   s   d S)z"Return whether there are subitems.r	   r    )r.   r    r    r!   r   I  s    zTreeItem.IsExpandablec             C   s2   |  j    s g  S|  j   } | s. d |  _ n  | S)z%Do not override!  Called by TreeNode.r   )r   
GetSubListr   )r.   ra   r    r    r!   r]   M  s    zTreeItem._GetSubListc             C   s   d S)z-Return whether the item's text may be edited.Nr    )r.   r    r    r!   rr   V  s    zTreeItem.IsEditablec             C   s   d S)z+Change the item's text (if it is editable).Nr    )r.   r   r    r    r!   r|   Y  s    zTreeItem.SetTextc             C   s   d S)z-Return name of icon to be displayed normally.Nr    )r.   r    r    r!   rg   \  s    zTreeItem.GetIconNamec             C   s   d S)z2Return name of icon to be displayed when selected.Nr    )r.   r    r    r!   rf   _  s    zTreeItem.GetSelectedIconNamec             C   s   d S)z%Return list of items forming sublist.Nr    )r.   r    r    r!   r   b  s    zTreeItem.GetSubListc             C   s   d S)z%Called on a double-click on the item.Nr    )r.   r    r    r!   rE   e  s    zTreeItem.OnDoubleClick)r}   r~   r   __doc__r/   rl   rj   r   rG   r   r]   rr   r|   rg   rf   r   rE   r    r    r    r!   r   /  s   	r   c               @   sj   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d S)FileTreeItemz4Example TreeItem subclass -- browse the file system.c             C   s   | |  _  d  S)N)r   )r.   r   r    r    r!   r/   o  s    zFileTreeItem.__init__c             C   s   t  j j |  j  p |  j S)N)r   r   r   )r.   r    r    r!   rl   r  s    zFileTreeItem.GetTextc             C   s   t  j j |  j  d k S)N )r   r   r   )r.   r    r    r!   rr   u  s    zFileTreeItem.IsEditablec             C   s   t  j j |  j  } t  j j | |  } t  j j |  t  j j |  j  k rU d  Sy  t  j |  j |  | |  _ Wn t k
 r Yn Xd  S)N)r   r   dirnamer   renameOSError)r.   r   newpathr    r    r!   r|   x  s    'zFileTreeItem.SetTextc             C   s   |  j    s d Sd  S)NZpython)r   )r.   r    r    r!   rg     s    zFileTreeItem.GetIconNamec             C   s   t  j j |  j  S)N)r   r   isdir)r.   r    r    r!   r     s    zFileTreeItem.IsExpandablec             C   s   y t  j |  j  } Wn t k
 r. g  SYn X| j d t  j j  g  } x9 | D]1 } t t  j j |  j |   } | j |  qR W| S)Nkey)	r   listdirr   r   r   normcaser   r   r   )r.   namesra   r   r'   r    r    r!   r     s    	zFileTreeItem.GetSubListN)r}   r~   r   r   r/   rl   rr   r|   rg   r   r   r    r    r    r!   r   k  s   r   c               @   sX   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d S)ScrolledCanvasc             K   s  d | k r d | d <n  | |  _  t |  |  _ |  j j d d d |  j j d d d t |  j |  |  _ |  j j d d d d d d	  t |  j d
 d |  _	 |  j	 j d d d d d d  t |  j d
 d d d |  _
 |  j
 j d d d d d d  |  j	 j |  j d <|  j j |  j	 d <|  j
 j |  j d <|  j j |  j
 d <|  j j d |  j  |  j j d |  j  |  j j d |  j  |  j j d |  j  |  j j d |  j  |  j j   d  S)NZyscrollincrementrJ   r   Zweightr	   r
   r   ZstickyZnsewr   vbarZnsehbarZorientZ
horizontalZewsZyscrollcommandZcommandZxscrollcommandz<Key-Prior>z
<Key-Next>z<Key-Up>z
<Key-Down>z<Alt-Key-2>)r   ZFrameframeZrowconfigureZcolumnconfigureZCanvasr%   r   Z	Scrollbarr   r   setZyviewZxviewrp   page_up	page_downunit_up	unit_downzoom_heightry   )r.   r   Zoptsr    r    r!   r/     s,    	zScrolledCanvas.__init__c             C   s   |  j  j d d  d S)Nr	   pagerB   rT   )r%   yview_scroll)r.   r<   r    r    r!   r     s    zScrolledCanvas.page_upc             C   s   |  j  j d d  d S)Nr	   r   rB   )r%   r   )r.   r<   r    r    r!   r     s    zScrolledCanvas.page_downc             C   s   |  j  j d d  d S)Nr	   unitrB   rT   )r%   r   )r.   r<   r    r    r!   r     s    zScrolledCanvas.unit_upc             C   s   |  j  j d d  d S)Nr	   r   rB   )r%   r   )r.   r<   r    r    r!   r     s    zScrolledCanvas.unit_downc             C   s   t  j |  j  d S)NrB   )r   r   r   )r.   r<   r    r    r!   r     s    zScrolledCanvas.zoom_heightN)	r}   r~   r   r/   r   r   r   r   r   r    r    r    r!   r     s   r   c       	      C   s   t    } | j d  t t t t j d |  j      \ } } } } | j d | | d f  t | d d d d d	 d
 } | j	 j
 d d
 d d d t  t t j    } t | j d  |  } | j   | j   d  S)NzTest TreeWidgetz[x+]z+%d+%d   ZbgZwhitert   r   Z	takefocusr	   rD   r[   ZbothZside)r   titler   mapintresplitZgeometryr   r   rx   ZLEFTr   r   getcwdr#   r%   rD   Zmainloop)	r&   r   ru   rO   r+   r,   Zscr'   Znoder    r    r!   _tree_widget  s    	3
r   __main__)run)r   ZtkinterZidlelibr   Zidlelib.configHandlerr   r4   r   r   r   __file__Z_icondir	NameErrorr   RuntimeErrorr"   r#   r   r   r   r   r}   Zidlelib.idle_test.htestr   r    r    r    r!   <module>   s*   
%	<.*                                                                                                                                                                                                                        usr/lib/python3.4/idlelib/__pycache__/UndoDelegator.cpython-34.pyc                                  0100644 0000000 0000000 00000027031 13077704335 023402  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T?*                 @   s   d  d l  Z  d  d l Td  d l m Z Gd d   d e  Z Gd d   d  Z Gd d	   d	 e  Z Gd
 d   d e  Z Gd d   d e  Z d d   Z	 e
 d k r d  d l m Z e e	  n  d S)    N)*)	Delegatorc               @   s   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d Z
 d d   Z d# Z d d   Z d d d  Z d d d  Z d d   Z d d   Z d d d  Z d d    Z d! d"   Z d S)$UndoDelegatori  c             C   s   t  j |   |  j   d  S)N)r   __init__
reset_undo)self r   +/usr/lib/python3.4/idlelib/UndoDelegator.pyr      s    zUndoDelegator.__init__c             C   s   |  j  d  k	 r9 |  j d  |  j d  |  j d  n  t j |  |  | d  k	 r |  j d |  j  |  j d |  j  |  j d |  j  n  d  S)Nz<<undo>>z<<redo>>z<<dump-undo-state>>)delegateZunbindr   setdelegateZbind
undo_event
redo_event
dump_event)r   r
   r   r   r	   r      s    zUndoDelegator.setdelegatec             C   s   d d l  m  } | |  j d  |  j   t d |  j d d t d |  j d d t d |  j d d t d |  j    | |  j |  j d    d	 S)
Nr   )pprintzpointer:end zsaved:z
can_merge:zget_saved():break)r   undolistpointerprintsaved	can_merge	get_saved)r   eventr   r   r   r	   r   &   s    zUndoDelegator.dump_eventc             C   s5   d |  _  d |  _ g  |  _ d |  _ |  j d  d  S)N   r   )	was_savedr   r   	undoblock	set_saved)r   r   r   r	   r   0   s
    				zUndoDelegator.reset_undoc             C   s5   | r |  j  |  _ n	 d |  _ d |  _ |  j   d  S)Nr   Fr   )r   r   r   check_saved)r   Zflagr   r   r	   r   7   s
    		zUndoDelegator.set_savedc             C   s   |  j  |  j k S)N)r   r   )r   r   r   r	   r   ?   s    zUndoDelegator.get_savedNc             C   s   | |  _  d  S)N)saved_change_hook)r   hookr   r   r	   set_saved_change_hookD   s    z#UndoDelegator.set_saved_change_hookr   c             C   sA   |  j    } | |  j k r= | |  _ |  j r= |  j   q= n  d  S)N)r   r   r    )r   Zis_savedr   r   r	   r   I   s
    		zUndoDelegator.check_savedc             C   s   |  j  t | | |   d  S)N)addcmdInsertCommand)r   indexcharstagsr   r   r	   insertP   s    zUndoDelegator.insertc             C   s   |  j  t | |   d  S)N)r#   DeleteCommand)r   index1index2r   r   r	   deleteS   s    zUndoDelegator.deletec             C   s/   |  j  d k r t   |  _  n  |  j  j   d  S)Nr   )r   CommandSequence
bump_depth)r   r   r   r	   undo_block_starta   s    zUndoDelegator.undo_block_startc             C   sz   |  j  j d  d k rv |  j  } d |  _  t |  d k rv t |  d k r` | j d  } n  |  j | d  qv n  d  S)Nr   r   r   )r   r.   lengetcmdr#   )r   cmdr   r   r	   undo_block_stopf   s    		zUndoDelegator.undo_block_stopTc             C   s3  | r | j  |  j  n  |  j d k r< |  j j |  d  S|  j r~ |  j d k r~ |  j |  j d } | j |  r~ d  Sn  | g |  j |  j d   <|  j |  j k r d |  _ n  |  j d |  _ t	 |  j  |  j
 k r|  j d =|  j d |  _ |  j d k r|  j d |  _ qn  d |  _ |  j   d  S)Nr   r   Tr   )dor
   r   appendr   r   r   merger   r0   max_undor   )r   r2   ZexecuteZlastcmdr   r   r	   r#   r   s(    
	zUndoDelegator.addcmdc             C   sh   |  j  d k r |  j   d S|  j |  j  d } | j |  j  |  j  d |  _  d |  _ |  j   d S)Nr   r   r   F)r   bellr   undor
   r   r   )r   r   r2   r   r   r	   r      s    
	
zUndoDelegator.undo_eventc             C   sm   |  j  t |  j  k r& |  j   d S|  j |  j  } | j |  j  |  j  d |  _  d |  _ |  j   d S)Nr   r   F)r   r0   r   r8   redor
   r   r   )r   r   r2   r   r   r	   r      s    
	
zUndoDelegator.redo_eventr   )__name__
__module____qualname__r7   r   r   r   r   r   r   r    r"   r   r   r(   r,   r/   r3   r#   r   r   r   r   r   r	   r      s$   
r   c               @   sy   e  Z d  Z d Z d d d  Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d d   Z
 d d   Z d S)CommandNc             C   sC   i  |  _  i  |  _ | |  _ | |  _ | |  _ | r? | |  _ n  d  S)N)marks_beforemarks_afterr*   r+   r&   r'   )r   r*   r+   r&   r'   r   r   r	   r      s    					zCommand.__init__c             C   sZ   |  j  j } |  j |  j |  j |  j f } |  j d  k rL | d  d  } n  | t |  S)Nr   r   )	__class__r;   r*   r+   r&   r'   repr)r   str   r   r	   __repr__   s
    zCommand.__repr__c             C   s   d  S)Nr   )r   textr   r   r	   r4      s    z
Command.doc             C   s   d  S)Nr   )r   rF   r   r   r	   r:      s    zCommand.redoc             C   s   d  S)Nr   )r   rF   r   r   r	   r9      s    zCommand.undoc             C   s   d S)Nr   r   )r   r2   r   r   r	   r6      s    zCommand.mergec             C   sO   i  } xB | j    D]4 } | d k r | d k r | j |  | | <q q W| S)Nr(   Zcurrent)Z
mark_namesr%   )r   rF   marksnamer   r   r	   
save_marks   s
    zCommand.save_marksc             C   s1   x* | j    D] \ } } | j | |  q Wd  S)N)itemsmark_set)r   rF   rG   rH   r%   r   r   r	   	set_marks   s    zCommand.set_marks)r;   r<   r=   r'   r   rE   r4   r:   r9   r6   rI   rL   r   r   r   r	   r>      s   	r>   c               @   so   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d
 d   Z e j	 e j
 d Z d d   Z d S)r$   Nc             C   s   t  j |  | d  | |  d  S)N)r>   r   )r   r*   r&   r'   r   r   r	   r      s    zInsertCommand.__init__c             C   s   |  j  |  |  _ | j |  j  |  _ | j |  j d d  rT | j d  |  _ n  | j |  j |  j |  j  | j d |  j t |  j  f  |  _	 |  j  |  |  _
 d  S)N>zend-1cz%s+%dc)rI   r?   r%   r*   comparer(   r&   r'   r0   r+   r@   )r   rF   r   r   r	   r4      s    (zInsertCommand.doc             C   sS   | j  d |  j  | j |  j |  j |  j  |  j | |  j  | j d  d  S)Nr(   )rK   r*   r(   r&   r'   rL   r@   see)r   rF   r   r   r	   r:      s    zInsertCommand.redoc             C   sM   | j  d |  j  | j |  j |  j  |  j | |  j  | j d  d  S)Nr(   )rK   r*   r,   r+   rL   r?   rO   )r   rF   r   r   r	   r9      s    zInsertCommand.undoc             C   s   |  j  | j  k	 r d S|  j | j k r, d S|  j | j k rB d St | j  d k r[ d S|  j r |  j |  j d  |  j | j  k r d S| j |  _ |  j | j |  _ d S)NFr   Tr   )rA   r+   r*   r'   r0   r&   classify)r   r2   r   r   r	   r6      s    	(zInsertCommand.merge_c             C   s'   | |  j  k r d S| d k r# d Sd S)Nalphanumeric
newlineZpunctuation)rR   )r   cr   r   r	   rP      s
    zInsertCommand.classify)r;   r<   r=   r   r4   r:   r9   r6   stringZascii_lettersZdigitsrR   rP   r   r   r   r	   r$      s   r$   c               @   sC   e  Z d  Z d d d  Z d d   Z d d   Z d d	   Z d S)
r)   Nc             C   s   t  j |  | | d  d   d  S)N)r>   r   )r   r*   r+   r   r   r	   r     s    zDeleteCommand.__init__c             C   s   |  j  |  |  _ | j |  j  |  _ |  j rH | j |  j  |  _ n | j |  j d  |  _ | j |  j d d  r | j d  |  _ n  | j |  j |  j  |  _ | j |  j |  j  |  j  |  |  _	 d  S)Nz +1crM   zend-1c)
rI   r?   r%   r*   r+   rN   getr&   r,   r@   )r   rF   r   r   r	   r4     s    	zDeleteCommand.doc             C   sM   | j  d |  j  | j |  j |  j  |  j | |  j  | j d  d  S)Nr(   )rK   r*   r,   r+   rL   r@   rO   )r   rF   r   r   r	   r:     s    zDeleteCommand.redoc             C   sM   | j  d |  j  | j |  j |  j  |  j | |  j  | j d  d  S)Nr(   )rK   r*   r(   r&   rL   r?   rO   )r   rF   r   r   r	   r9   %  s    zDeleteCommand.undo)r;   r<   r=   r   r4   r:   r9   r   r   r   r	   r)     s   r)   c               @   ss   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d d  Z
 d S)r-   c             C   s   g  |  _  d |  _ d  S)Nr   )cmdsdepth)r   r   r   r	   r   1  s    	zCommandSequence.__init__c             C   sS   |  j  j } g  } x% |  j D] } | j d | f  q W| d d j |  d S)Nz    %rz(
z,
z
))rA   r;   rX   r5   join)r   rC   Zstrsr2   r   r   r	   rE   5  s
    zCommandSequence.__repr__c             C   s   t  |  j  S)N)r0   rX   )r   r   r   r	   __len__<  s    zCommandSequence.__len__c             C   s   |  j  j |  d  S)N)rX   r5   )r   r2   r   r   r	   r5   ?  s    zCommandSequence.appendc             C   s   |  j  | S)N)rX   )r   ir   r   r	   r1   B  s    zCommandSequence.getcmdc             C   s%   x |  j  D] } | j |  q
 Wd  S)N)rX   r:   )r   rF   r2   r   r   r	   r:   E  s    zCommandSequence.redoc             C   s?   |  j  d  d   } | j   x | D] } | j |  q$ Wd  S)N)rX   reverser9   )r   rF   rX   r2   r   r   r	   r9   I  s    
zCommandSequence.undor   c             C   s   |  j  | |  _  |  j  S)N)rY   )r   Zincrr   r   r	   r.   O  s    zCommandSequence.bump_depthN)r;   r<   r=   r   rE   r[   r5   r1   r:   r9   r.   r   r   r   r	   r-   ,  s   r-   c                sp  d d l  m } t   } | j d  t t t t j d |  j	      \ } } } } | j	 d | | d f  t
 |  } | j d d  | j   | j   | |  } t     | j    t | d	 d
 d   f d d   }	 |	 j d d  t | d	 d d   f d d   }
 |
 j d d  t | d	 d d   f d d   } | j d d  | j   d  S)Nr   )
PercolatorzTest UndoDelegatorz[x+]z+%d+%d   height
   rF   ZUndoZcommandc                  s     j  d   S)N)r   r   )dr   r	   <lambda>b  s    z!_undo_delegator.<locals>.<lambda>ZsideleftZRedoc                  s     j  d   S)N)r   r   )rb   r   r	   rc   d  s    ZDumpc                  s     j  d   S)N)r   r   )rb   r   r	   rc   f  s    )Zidlelib.Percolatorr^   ZTktitlelistmapintresplitZgeometryZTextZconfigZpackZ	focus_setr   ZinsertfilterZButtonZmainloop)parentr^   rootwidthr`   xyrF   pr9   r:   dumpr   )rb   r	   _undo_delegatorS  s&    	3

	$$$rr   __main__)run)rV   ZtkinterZidlelib.Delegatorr   r   r>   r$   r)   r-   rr   r;   Zidlelib.idle_test.htestrt   r   r   r   r	   <module>   s   
.:$'                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       usr/lib/python3.4/idlelib/__pycache__/WidgetRedirector.cpython-34.pyc                               0100644 0000000 0000000 00000015700 13077704335 024114  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  d l  m Z Gd d   d  Z Gd d   d  Z d d   Z e d k r d  d	 l Z e j d
 d d d d d  d l m	 Z	 e	 e  n  d	 S)    )TclErrorc               @   s^   e  Z d  Z d Z d d   Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z	 d S)WidgetRedirectora  Support for redirecting arbitrary widget subcommands.

    Some Tk operations don't normally pass through tkinter.  For example, if a
    character is inserted into a Text widget by pressing a key, a default Tk
    binding to the widget's 'insert' operation is activated, and the Tk library
    processes the insert without calling back into tkinter.

    Although a binding to <Key> could be made via tkinter, what we really want
    to do is to hook the Tk 'insert' operation itself.  For one thing, we want
    a text.insert call in idle code to have the same effect as a key press.

    When a widget is instantiated, a Tcl command is created whose name is the
    same as the pathname widget._w.  This command is used to invoke the various
    widget operations, e.g. insert (for a Text widget). We are going to hook
    this command and provide a facility ('register') to intercept the widget
    operation.  We will also intercept method calls on the tkinter class
    instance that represents the tk widget.

    In IDLE, WidgetRedirector is used in Percolator to intercept Text
    commands.  The function being registered provides access to the top
    of a Percolator chain.  At the bottom of the chain is a call to the
    original Tk widget operation.
    c             C   se   i  |  _  | |  _ | j |  _ } | j } | d |  _ | j d | |  j  | j | |  j  d S)a  Initialize attributes and setup redirection.

        _operations: dict mapping operation name to new function.
        widget: the widget whose tcl command is to be intercepted.
        tk: widget.tk, a convenience attribute, probably not needed.
        orig: new name of the original tcl command.

        Since renaming to orig fails with TclError when orig already
        exists, only one WidgetDirector can exist for a given widget.
        Z_origrenameN)_operationswidgettk_worigcallZcreatecommanddispatch)selfr   r   w r   ./usr/lib/python3.4/idlelib/WidgetRedirector.py__init__   s    			zWidgetRedirector.__init__c             C   s   d |  j  j j |  j  j f S)NzWidgetRedirector(%s<%s>))r   	__class____name__r   )r   r   r   r   __repr__1   s    zWidgetRedirector.__repr__c             C   su   x$ t  |  j  D] } |  j |  q W|  j } | j } | j } | j |  | j d |  j |  |  ` |  ` d S)zBUnregister operations and revert redirection created by .__init__.r   N)	listr   
unregisterr   r   r   Zdeletecommandr
   r	   )r   	operationr   r   r   r   r   r   close5   s    			zWidgetRedirector.closec             C   s-   | |  j  | <t |  j | |  t |  |  S)a  Return OriginalCommand(operation) after registering function.

        Registration adds an operation: function pair to ._operations.
        It also adds an widget function attribute that masks the tkinter
        class instance method.  Method masking operates independently
        from command dispatch.

        If a second function is registered for the same operation, the
        first function is replaced in both places.
        )r   setattrr   OriginalCommand)r   r   functionr   r   r   registerB   s    zWidgetRedirector.registerc             C   s[   | |  j  k rS |  j  | } |  j  | =y t |  j |  Wn t k
 rN Yn X| Sd Sd S)z~Return the function for the operation, or None.

        Deleting the instance attribute unmasks the class attribute.
        N)r   delattrr   AttributeError)r   r   r   r   r   r   r   Q   s    
zWidgetRedirector.unregisterc             G   s`   |  j  j |  } y1 | r% | |   S|  j j |  j | f |  SWn t k
 r[ d SYn Xd S)a  Callback from Tcl which runs when the widget is referenced.

        If an operation has been registered in self._operations, apply the
        associated function to the args passed into Tcl. Otherwise, pass the
        operation through to Tk via the original Tcl function.

        Note that if a registered function is called, the operation is not
        passed through to Tk.  Apply the function returned by self.register()
        to *args to accomplish that.  For an example, see ColorDelegator.py.

         N)r   getr   r
   r	   r   )r   r   argsmr   r   r   r   a   s    
!zWidgetRedirector.dispatchN)
r   
__module____qualname____doc__r   r   r   r   r   r   r   r   r   r   r      s   r   c               @   s:   e  Z d  Z d Z d d   Z d d   Z d d   Z d S)	r   a7  Callable for original tk command that has been redirected.

    Returned by .register; can be used in the function registered.
    redir = WidgetRedirector(text)
    def my_insert(*args):
        print("insert", args)
        original_insert(*args)
    original_insert = redir.register("insert", my_insert)
    c             C   sO   | |  _  | |  _ | j |  _ | j |  _ | j j |  _ | j | f |  _ d S)zCreate .tk_call and .orig_and_operation for .__call__ method.

        .redir and .operation store the input args for __repr__.
        .tk and .orig copy attributes of .redir (probably not needed).
        N)redirr   r   r	   r
   tk_callorig_and_operation)r   r%   r   r   r   r   r      s    		zOriginalCommand.__init__c             C   s   d |  j  |  j f S)NzOriginalCommand(%r, %r))r%   r   )r   r   r   r   r      s    zOriginalCommand.__repr__c             G   s   |  j  |  j |  S)N)r&   r'   )r   r    r   r   r   __call__   s    zOriginalCommand.__call__N)r   r"   r#   r$   r   r   r(   r   r   r   r   r   w   s   	r   c                s   d d l  m } m } d d  l } |   } | j d  t t t | j d |  j	      \ } } } } | j	 d | | d f  | |  }	 |	 j
   |	 j   t |	  }
   f d d   } |
 j d	 |    | j   d  S)
Nr   )TkTextzTest WidgetRedirectorz[x+]z+%d+%d   c                 s   t  d |     |    d  S)Ninsert)print)r    )original_insertr   r   	my_insert   s    z%_widget_redirector.<locals>.my_insertr,   )tkinterr)   r*   retitler   mapintsplitZgeometryZpackZ	focus_setr   r   Zmainloop)parentr)   r*   r1   rootwidthZheightxytextr%   r/   r   )r.   r   _widget_redirector   s    	3

r<   __main__Nz"idlelib.idle_test.test_widgetredir	verbosity   exitF)run)
r0   r   r   r   r<   r   ZunittestmainZidlelib.idle_test.htestrA   r   r   r   r   <module>   s   t                                                                 usr/lib/python3.4/idlelib/__pycache__/WindowList.cpython-34.pyc                                     0100644 0000000 0000000 00000006226 13077704335 022754  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T	                 @   s[   d  d l  TGd d   d  Z e   Z e j Z e j Z e j Z Gd d   d e  Z d S)    )*c               @   sd   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d S)
WindowListc             C   s   i  |  _  g  |  _ d  S)N)dict	callbacks)self r   (/usr/lib/python3.4/idlelib/WindowList.py__init__   s    	zWindowList.__init__c             C   s'   | j  |  j  | |  j t |  <d  S)N)Z
after_idlecall_callbacksr   str)r   windowr   r   r   add	   s    zWindowList.addc             C   s7   y |  j  t |  =Wn t k
 r( Yn X|  j   d  S)N)r   r   KeyErrorr
   )r   r   r   r   r   delete   s
    zWindowList.deletec             C   s   g  } x\ |  j  D]Q } |  j  | } y | j   } Wn t k
 rJ w Yn X| j | | | f  q W| j   x0 | D]( \ } } } | j d | d | j  qv Wd  S)NZlabelZcommand)r   	get_titleTclErrorappendsortZadd_commandwakeup)r   Zmenulistkeyr   titler   r   r   add_windows_to_menu   s    
zWindowList.add_windows_to_menuc             C   s   |  j  j |  d  S)N)r   r   )r   callbackr   r   r   register_callback"   s    zWindowList.register_callbackc             C   s-   y |  j  j |  Wn t k
 r( Yn Xd  S)N)r   remove
ValueError)r   r   r   r   r   unregister_callback%   s    zWindowList.unregister_callbackc             C   sV   xO |  j  D]D } y |   Wq
 t j   \ } } } t d | d |  Yq
 Xq
 Wd  S)Nz&warning: callback failed in WindowList:)r   sysexc_infoprint)r   r   tvtbr   r   r   r
   +   s    zWindowList.call_callbacksN)
__name__
__module____qualname__r	   r   r   r   r   r   r
   r   r   r   r   r      s   r   c               @   sL   e  Z d  Z d d   Z d d   Z d d   Z d d   Z d	 d
   Z d S)ListedToplevelc             K   s-   t  j |  | |  t j |   |  |  _ d  S)N)Toplevelr	   registryr   focused_widget)r   Zmasterkwr   r   r   r	   <   s    zListedToplevel.__init__c             C   s4   t  j |   t j |   t  j s0 |  j   n  d  S)N)r*   r   r)   destroyr   Zquit)r   r   r   r   r-   A   s    	zListedToplevel.destroyc             C   s   t  j   d  S)N)r*   r
   )r   r   r   r   r   update_windowlist_registryI   s    z)ListedToplevel.update_windowlist_registryc             C   s
   |  j    S)N)Zwm_title)r   r   r   r   r   L   s    zListedToplevel.get_titlec             C   s]   yD |  j    d k r, |  j   |  j   n  |  j   |  j j   Wn t k
 rX Yn Xd  S)NZiconic)Zwm_stateZwm_withdrawZwm_deiconifyZtkraiser+   Z	focus_setr   )r   r   r   r   r   P   s    

zListedToplevel.wakeupN)r%   r&   r'   r	   r-   r.   r   r   r   r   r   r   r(   :   s
   r(   N)Ztkinterr   r*   r   r   r   r)   r(   r   r   r   r   <module>   s   
0				                                                                                                                                                                                                                                                                                                                                                                          usr/lib/python3.4/idlelib/__pycache__/ZoomHeight.cpython-34.pyc                                     0100644 0000000 0000000 00000002553 13077704335 022725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   sK   d  d l  Z  d  d l Z d  d l m Z Gd d   d  Z d d   Z d S)    N)macosxSupportc               @   s:   e  Z d  Z d d	 g f g Z d d   Z d d   Z d S)

ZoomHeightZwindows_Zoom Height<<zoom-height>>c             C   s   | |  _  d  S)N)editwin)selfr    r   (/usr/lib/python3.4/idlelib/ZoomHeight.py__init__   s    zZoomHeight.__init__c             C   s   |  j  j } t |  d  S)N)r   topzoom_height)r   Zeventr   r   r   r	   zoom_height_event   s    zZoomHeight.zoom_height_eventN)r   r   )__name__
__module____qualname__Zmenudefsr
   r   r   r   r   r	   r      s   r   c       
      C   s   |  j    } t j d |  } | s2 |  j   d  St t | j    \ } } } } |  j   } t j	 d k r d } | d } n3 t
 j   r d } | | d } n d } | d } | | k r d }	 n d | | | | f }	 |  j  |	  d  S)	Nz(\d+)x(\d+)\+(-?\d+)\+(-?\d+)Zwin32r   H      X    z%dx%d+%d+%d)Zwm_geometryrematchZbellmapintgroupsZwinfo_screenheightsysplatformr   ZisAquaTk)
r   ZgeommwidthZheightxyZ	newheightZnewyZnewgeomr   r   r	   r      s&    
!
	r   )r   r   Zidlelibr   r   r   r   r   r   r	   <module>   s                                                                                                                                                        usr/lib/python3.4/idlelib/__pycache__/__init__.cpython-34.pyc                                       0100644 0000000 0000000 00000000171 13077704335 022401  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T%                  @   s   d  S)N r   r   r   &/usr/lib/python3.4/idlelib/__init__.py<module>   s                                                                                                                                                                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/__pycache__/__main__.cpython-34.pyc                                       0100644 0000000 0000000 00000000410 13077704335 022356  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5Tm                  @   s#   d  Z  d d l Z e j j   d S)z6
IDLE main entry point

Run IDLE as python -m idlelib
    N)__doc__Zidlelib.PyShellZidlelibZPyShellmain r   r   &/usr/lib/python3.4/idlelib/__main__.py<module>   s                                                                                                                                                                                                                                                           usr/lib/python3.4/idlelib/__pycache__/aboutDialog.cpython-34.pyc                                    0100644 0000000 0000000 00000013415 13077704335 023101  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5T                 @   s   d  Z  d d l Td d l Z d d l m Z d d l m Z Gd d   d e  Z e d k r{ d d	 l	 m
 Z
 e
 e  n  d S)
zAbout Dialog for IDLE

    )*N)textView)idleverc               @   s   e  Z d  Z d Z d d d  Z d d   Z d d   Z d	 d
   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d d  Z d d d  Z d S)AboutDialogz!Modal about dialog for idle

    Fc             C   s
  t  j |  |  |  j d d  |  j d | j   d | j   | sK d n d f  d |  _ d |  _ |  j   |  j	 d t
 d	 t
  |  j |  |  j |  |  j   |  j d
 |  j  | |  _ |  j j   |  j d |  j  |  j d |  j  |  j   d S)zG
        _htest - bool, change box location when running htest
        borderwidth   z+%d+%d   d   z#707070z#ffffffheightwidthZWM_DELETE_WINDOWz<Return>z<Escape>N)Toplevel__init__Z	configureZgeometryZwinfo_rootxZwinfo_rootybgfgCreateWidgetsZ	resizableZFALSEtitleZ	transientZgrab_setZprotocolOkparentbuttonOkZ	focus_setZbindZwait_window)selfr   r   Z_htest r   )/usr/lib/python3.4/idlelib/aboutDialog.pyr      s$    	!		

	zAboutDialog.__init__c             C   s  t  |  d d d t } t  |   } | j d t d t  | j d t d t d t  t | d d d	 |  j	 |  _
 |  j
 j d
 d d d  t  | d |  j } | j d t d t  t | d d d |  j d |  j d d5 } | j d d d d d t d
 d d d  d d6 } t | d | d t d |  j d |  j } | j d d d d d t d d d
 d d d  t | d d d t d |  j d |  j } | j d d d d d d d t d
 d d d  t | d d  d t d |  j d |  j } | j d d! d d d d d t d
 d d d  t  | d d" d t d# d d |  j j d d$ d d d t d d d
 d d d  t | d d% t j j   d d |  j d |  j }	 |	 j d d& d d d t d
 d d d  |  j j d' d(  }
 t | d d) |
 d |  j d |  j } | j d d& d d" d t d
 d d d  t  | d |  j } | j d d d d d d d t  t | d d* d+ d$ d, |  j d	 |  j } | j d t d
 d d d  t | d d- d+ d$ d, |  j d	 |  j } | j d t d
 d d d  t | d d. d+ d$ d, |  j d	 |  j } | j d t d
 d d d  t  | d d" d t d# d d |  j j d d/ d d d t d d d
 d d d  t | d d0 t j d |  j d |  j } | j d d1 d d d t d
 d d d  t  | d |  j } | j d d2 d d d d d t  t | d d3 d+ d$ d, |  j d	 |  j } | j d t d
 d d d  t | d d4 d+ d$ d, |  j d	 |  j } | j d t d
 d d d  t | d d. d+ d$ d, |  j d	 |  j } | j d t d
 d d d  d  S)7Nr      ZreliefZsideZfillexpandtextZCloseZcommandZpadxr   Zpadyr   ZIDLEr   Zfontcourier   boldrowr   columnZsticky
   z+Python's Integrated DeveLopment Environment
ZjustifyZ
columnspan   zemail:  idle-dev@python.org   z!www:  http://www.python.org/idle/      r
      zPython version:  	   infoZ
patchlevelzTk version:  ZLicenser   ZhighlightbackgroundZ	CopyrightZCredits   zIDLE version:         ZREADMEZNEWS)r   r   r   z




) ZFrameZSUNKENZpackZBOTTOMXZTOPZTRUEZBOTHZButtonr   r   r   ZLabelr   ZgridWZLEFTZEWsysversionsplitZtkcallZNSEWShowLicenseShowCopyrightShowPythonCreditsr   ZIDLE_VERSIONShowIDLEAboutShowIDLENEWSShowIDLECredits)r   Z	frameMainZframeButtonsZframeBgZ
labelTitleZbylineZ	labelDescZ
labelEmailZlabelWWWZlabelPythonVerZtkVerZ
labelTkVerZpy_button_fZbuttonLicenseZbuttonCopyrightZbuttonCreditsZidle_vZidle_button_fZidle_about_bZidle_news_bZidle_credits_br   r   r   r   '   s    !	(
..<)(("			<("			zAboutDialog.CreateWidgetsc             C   s   |  j  d t  d  S)NzAbout - License)display_printer_textZlicense)r   r   r   r   r2   q   s    zAboutDialog.ShowLicensec             C   s   |  j  d t  d  S)NzAbout - Copyright)r8   	copyright)r   r   r   r   r3   t   s    zAboutDialog.ShowCopyrightc             C   s   |  j  d t  d  S)NzAbout - Python Credits)r8   Zcredits)r   r   r   r   r4   w   s    zAboutDialog.ShowPythonCreditsc             C   s   |  j  d d d  d  S)NzAbout - CreditszCREDITS.txtz
iso-8859-1)display_file_text)r   r   r   r   r7   z   s    zAboutDialog.ShowIDLECreditsc             C   s   |  j  d d  d  S)NzAbout - Readmez
README.txt)r:   )r   r   r   r   r5   }   s    zAboutDialog.ShowIDLEAboutc             C   s   |  j  d d  d  S)NzAbout - NEWSzNEWS.txt)r:   )r   r   r   r   r6      s    zAboutDialog.ShowIDLENEWSc             C   s3   | j    d j | j  } t j |  | |  d  S)Nr!   )Z_Printer__setupjoinZ_Printer__linesr   Z	view_text)r   r   Zprinterr   r   r   r   r8      s    
z AboutDialog.display_printer_textNc             C   sG   t  j j t  j j t  j j t   |  } t j |  | | |  d  S)N)ospathr;   abspathdirname__file__r   Z	view_file)r   r   filenameencodingfnr   r   r   r:      s    -zAboutDialog.display_file_textc             C   s   |  j    d  S)N)Zdestroy)r   Zeventr   r   r   r      s    zAboutDialog.Ok)__name__
__module____qualname____doc__r   r   r2   r3   r4   r7   r5   r6   r8   r:   r   r   r   r   r   r      s   Jr   __main__)run)rG   Ztkinterr<   Zidlelibr   r   r   r   rD   Zidlelib.idle_test.htestrI   r   r   r   r   <module>   s   
                                                                                                                                                                                                                                                   usr/lib/python3.4/idlelib/__pycache__/configDialog.cpython-34.pyc                                   0100644 0000000 0000000 00000120361 13077704335 023233  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        
#5TS                 @   s  d  Z  d d l Td d l j Z d d l j Z d d l j	 Z
 d d l m Z d d l m Z d d l m Z d d l m Z d d l m Z d d	 l m Z d d
 l m Z Gd d   d e  Z e d k rd d l Z e j d d d d d d d l m Z e e  n  d S)a  IDLE Configuration Dialog: support user customization of IDLE by GUI

Customize font faces, sizes, and colorization attributes.  Set indentation
defaults.  Customize keybindings.  Colorization and keybindings can be
saved as user defined sets.  Select startup options including shell/editor
and default window size.  Define additional help sources.

Note that tab width in IDLE is currently fixed at eight due to Tk issues.
Refer to comments in EditorWindow autoindent code for details.

    )*N)idleConf)DynOptionMenu)TabbedPageSet)GetKeysDialog)GetCfgSectionNameDialog)GetHelpSourceDialog)macosxSupportc               @   sy  e  Z d  Z d d d d  Z d d   Z d d   Z d d	   Z d
 d   Z d d   Z d d   Z	 d d   Z
 d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d d   Z d  d!   Z d" d#   Z d$ d%   Z d& d'   Z d( d)   Z d* d+   Z d, d-   Z d. d/   Z d0 d1   Z d2 d3   Z d4 d5   Z d6 d7   Z d8 d9   Z d: d;   Z d< d=   Z  d> d?   Z! d@ dA   Z" dB dC   Z# dD dE   Z$ dF dG   Z% dH dI   Z& dJ dK   Z' dL dM   Z( dN dO   Z) dP dQ   Z* dR dS   Z+ dT dU   Z, dV dW   Z- dX dY   Z. dZ d[   Z/ d\ d] d^  Z0 d_ d`   Z1 da db   Z2 dc dd   Z3 de df   Z4 dg dh   Z5 di dj   Z6 dk dl   Z7 dm dn   Z8 do dp   Z9 dq dr   Z: ds dt   Z; du dv   Z< dw dx   Z= dy dz   Z> d{ d|   Z? d} d~   Z@ d d   ZA d d   ZB d d   ZC d d   ZD d d   ZE d d   ZF d d   ZG d d   ZH d d   ZI d d   ZJ d\ S)ConfigDialogFc             C   s  t  j |  |  | |  _ | r+ i  | _ n  |  j   |  j d d  |  j d  |  j d | j   d | j	   | s} d n d f  i d3 d
 6d4 d 6d5 d 6d6 d 6d7 d 6d8 d 6d9 d 6d: d 6d; d" 6d< d% 6d= d( 6d> d+ 6d? d. 6|  _
 |  j   |  j   |  j d/ t d0 t  |  j |  |  j   |  j d1 |  j  |  j j   |  j   |  j   | s|  j   |  j   n  d2 S)@z
        _htest - bool, change box location when running htest
        _utest - bool, don't wait_window when running unittest
        borderwidth   zIDLE Preferencesz+%d+%d         normal00zNormal Textkeyword01zPython Keywords
definition02zPython Definitionsbuiltin03zPython Builtinscomment04zPython Commentsstring05zPython Stringshilite06zSelected Texthit07z
Found Textcursor08Cursorerror09z
Error Textconsole10zShell Normal Textstdout11zShell Stdout Textstderr12zShell Stderr TextheightwidthZWM_DELETE_WINDOWN)r   r   )zkeywordr   )r   r   )r   r   )r   r   )zstringr   )r   r   )r   r   )zcursorr!   )zerrorr$   )r%   r&   )zstdoutr(   )zstderrr*   )Toplevel__init__parentinstance_dictZwm_withdraw	configuretitleZgeometryZwinfo_rootxZwinfo_rootythemeElementsResetChangedItemsCreateWidgetsZ	resizableFALSEZ	transientZgrab_setZprotocolCanceltabPagesZ	focus_setLoadConfigsAttachVarCallbacksZwm_deiconifyZwait_window)selfr/   r2   Z_htestZ_utest r<   */usr/lib/python3.4/idlelib/configDialog.pyr.      sH    	
!





zConfigDialog.__init__c          	   C   s  t  |  d d d d d g |  _ t |  d d } t j   rH i  } n i d d	 6d
 d 6} t | d d d |  j d t | |  _ t | d d d |  j	 d t | |  _
 t | d d d |  j d t | |  _ |  j   |  j   |  j   |  j   |  j j d t d	 d  |  j
 j d t d	 d  |  j j d t d	 d  | j d t  t |  d d d d j d t  |  j j d t d t d t  d  S)NZ
page_namesz
Fonts/TabsHighlightingKeysGeneralpady      padx   textOkcommand	takefocusApplyr7   sider   r+   r   r   expandfill)r   r8   Framer	   ZisAquaTkButtonrG   r6   ZbuttonOkrJ   ZbuttonApplyr7   ZbuttonCancelCreatePageFontTabCreatePageHighlightCreatePageKeysCreatePageGeneralpackLEFTBOTTOMTOPTRUEBOTH)r;   ZframeActionButtonsZpaddingArgsr<   r<   r=   r5   O   s2    		



"zConfigDialog.CreateWidgetsc             C   s  |  j  } t |  |  _ t |  |  _ t |  |  _ t |  |  _ t j	 | d+  |  _
 |  j j d j } t | d d d t d d	 } t | d d d t d d
 } t |  } t |  } t | d t d d } t | d d d t d t |  _ |  j j d |  j  t |  } | j d |  j j  |  j j d | j  t | d d }	 t | |  j d  d |  j |  _ t | d |  j d d d d d d d |  j }
 t | d t  d d } t | d t d |  j
 d d |  _! t |  } t | d t d d } t" | d |  j d d d  d d! d d" d# |  _# | j$ d$ t d% d d& d d' t% d( t&  | j$ d$ t d% d d& d d( t'  | j$ d$ t( d% d d& d d( t)  | j$ d$ t( d% d d& d d( t)  | j$ d$ t( d) t*  |  j j$ d$ t d' t% d( t)  | j$ d$ t d( t'  |	 j$ d$ t d) t*  |  j j$ d$ t d) t*  |
 j$ d$ t d) t* d% d*  | j$ d$ t( d% d d& d d' t% d( t&  |  j! j$ d' t% d( t&  | j$ d$ t( d( t)  | j$ d$ t( d) t* d% d  |  j# j$ d$ t( d% d d( t)  | S),Ncourier
   r   z
Fonts/Tabsr   rB   reliefrF   z Base Editor Font z Indentation Width ZjustifyzFont Face :r+   r   rI   exportselectionz<ButtonRelease-1>rH   yscrollcommandzSize :variableZonvalue   Zoffvaluer   ZBoldfontz,AaBbCcDdEe
FfGgHhIiJjK
1234567890
#:+=(){}[]zPython Standard: 4 Spaces!orientZ
horizontalZtickintervalZfrom_Zto   rK   rD   rA   rL   rM   anchorr   )rZ   r[   znormal)+r/   	StringVarfontSize
BooleanVarfontBoldfontNameIntVarspaceNumtkFontZFontZeditFontr8   pagesframe
LabelFrameGROOVErN   LabelrU   Listboxr6   listFontNamebindOnListFontButtonRelease	Scrollbarconfigyviewsetr   SetFontSampleoptMenuFontSizeZCheckbuttonSOLIDlabelFontSampleZScaleZscaleSpaceNumrT   rX   rY   YrW   XW)r;   r/   rn   Z	frameFontZframeIndentZframeFontNameZframeFontParamZlabelFontNameTitleZ
scrollFontZlabelFontSizeTitleZcheckFontBoldZframeFontSampleZframeIndentSizeZlabelSpaceNumTitler<   r<   r=   rP   t   sn    			("""(zConfigDialog.CreatePageFontTabc             C   s  |  j  } t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _	 |  j
 j d j } t | d d d t d d } t | d d d t d d } t | d t d d d	 dX d d d d d d d t d d d t 	|  _ |  j } | j d d d    | j d d d    dw } x) | D]! } | j t | d | d  qHWx> |  j D]3 } | d? d@  }	 | j |  j | d dA |	  qwW| j dB t  t | d t d d |  _ t |  }
 t |  j d dC dD |  j d d } t |  j |  j	 d  d d |  _  t! |
 dE |  j dF d d dG dD |  j" |  _# t! |
 dE |  j dF d d dH dD |  j" |  _$ |  j j% d  t | d dI dD |  j& } t' | d dJ } t! | dE |  j dF d dD |  j( d dK |  _) t! | dE |  j dF d dD |  j( d dL |  _* t | |  j d  dD d  |  _+ t | |  j d  dD d  |  _, t | d dM dD |  j- |  _. | j/ dN t0 dO dP dQ dP dR t1 dS t2  | j/ dN t0 dO dP dQ dP dS t3  |  j j/ dN t4 dO dP dQ dP dR t1 dS t5  |
 j/ dN t4 dO dP dQ d  |  j j/ dN t4 dO dP dQ dP dR t1 dS t2  | j/ dN t4 dR t1 dS t5 dO dT dQ dU  |  j  j/ dN t4 dR t1 dS t5 dO dT dQ dV  |  j# j/ dN t0 dW t6  |  j$ j/ dN t7 dW t8  | j/ dN t9 dS t5 dO dP dQ dP  | j/ dN t4 dW t8 dO dP dQ dP  |  j) j/ dN t4 dW t8 dO dP  |  j* j/ dN t4 dW t8 dO dP dQ d  |  j+ j/ dN t4 dS t5 dO dP dQ dP  |  j, j/ dN t4 dS t5 dW t8 dO dP dQ dP  |  j. j/ dN t4 dS t5 dO dP dQ dP  | S)xNr>   r   rB   r\   rF   z Custom Highlighting z Highlighting Theme r`   ra   rZ       r    Zhand2r,      r+      rI   Zhighlightthicknessr   Zwrapz<Double-Button-1>c             S   s   d S)Nbreakr<   )er<   r<   r=   <lambda>   s    z2ConfigDialog.CreatePageHighlight.<locals>.<lambda>z<B1-Motion>c             S   s   d S)Nr   r<   )r   r<   r<   r=   r      s    #you can click herer   
r   #to choose itemsdefr    funcr   (param):
  """string"""r   

  var0 = 'string'

  var1 = 
'selected'r   

  var2 = 'found'r   

  var3 = listr   (None)

 error r#   cursor |
 shellr%   r'   r)   c             S   s   |  j  j   j j |  d  S)N)ZwidgetZwinfo_toplevelhighlightTargetry   )eventelemr<   r<   r=   tem   s    z-ConfigDialog.CreatePageHighlight.<locals>.temz<ButtonPress-1>statezChoose Colour for :rH   r_   valueZ
ForegroundZ
BackgroundzSave as New Custom Themez	Select : za Built-in Themeza Custom ThemezDelete Custom ThemerK   rD   r   rA   rL   rM         rE   rd   )zcourierr   r   r   commentr   normalr   r   r   r   zdefkeywordr   r   zfuncz
definitionr   r   r   stringr   r   r   r   r   r   r   zhiliter   r   r   zhitr   r   zlistzbuiltinr   r   zNoner   r   r   r   zerrorr   r   r   r    r   r   zshellzconsoler   r   stdoutr   r   r   stderrr   r   r   )r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   r   ):r/   re   builtinThemecustomThemerg   fgHilitecolourri   themeIsBuiltinr   r8   rm   rn   ro   rp   ZTextr|   r6   ZNONEtextHighlightSamplert   insertENDr3   Ztag_bindrw   DISABLEDrN   frameColourSetrO   	GetColourr   optMenuHighlightTargetRadiobuttonSetColourSampleBindingradioFgradioBgry   SaveAsNewThemerq   SetThemeTypeZradioThemeBuiltinradioThemeCustomoptMenuThemeBuiltinoptMenuThemeCustomDeleteCustomThemebuttonDeleteCustomThemerT   rU   rX   rY   r~   rW   r   ERIGHTr   rV   )r;   r/   rn   frameCustomZ
frameThemerF   ZtextAndTagsZtxTaelementr   Z	frameFgBgZbuttonSetColourZbuttonSaveCustomThemeZlabelTypeTitler<   r<   r=   rQ      s    				              ("+(""%%+%z ConfigDialog.CreatePageHighlightc       
         s  |  j  } t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _ |  j j	 d j
 } t | d d d t d d } t | d d d t d d   t |  } t | d d } t |  } t | d	 t } t | d
 t d t |  _ |  j j d |  j  | j d |  j j  | j d |  j j  |  j j d | j  |  j j d | j  t | d d d |  j d t |  _   f d d   t d  D } t | d d |  j d d d |  j  d d |  _! t | d d |  j d d d |  j  d d |  _" t# | d |  j d  d d  |  _$ t# | d |  j d  d d  |  _% t | d d d d |  j& |  _' t | d d d d |  j( }	 | j) d t* d d d d d  t+ d! t,    j) d t* d d d d d! t,  |  j j) d t* d! t- d d d d  | j) d t. d d d d d  t+ d! t,  | j/ d d" d | j0 d d" d | j1 d# d d$ d d% d d& t2  |  j j1 d# d d$ d d& t3  | j1 d# d d$ d d& t4  | j1 d# d d$ d d& t5  |  j! j1 d# d d$ d d& t2 t4  |  j" j1 d# d d$ d d& t2 t4  |  j$ j1 d# d d$ d d& t3  |  j% j1 d# d d$ d d& t3  |  j' j) d t. d! t- d  d' d d  |	 j) d t. d! t- d  d' d d  | d j) d t6 d! t, d  d'  | d j) d t6 d! t- d  d' d d  | S)(Nr?   r   rB   r\   rF   z Custom Key Bindings z	 Key Set zAction - Key(s)rb   rI   r]   z<ButtonRelease-1>rH   r^   ZxscrollcommandzGet New Keys for Selectionr   c          
      s.   g  |  ]$ } t    d  d d d d d  q S)rD   rB   rA   r   r   )rN   ).0i)frameKeySetsr<   r=   
<listcomp>E  s   	z/ConfigDialog.CreatePageKeys.<locals>.<listcomp>r   r_   r   r`   zUse a Built-in Key SetzUse a Custom Key SetzDelete Custom Key SetzSave as New Custom Key SetrK   rD   r   rA   rL   rM   ZweightrowcolumnZ
columnspanZstickyT)7r/   re   ZbindingTargetbuiltinKeys
customKeysrg   keysAreBuiltin
keyBindingr8   rm   rn   ro   rp   rN   rq   rv   Z
HORIZONTALrr   r6   listBindingsrt   KeyBindingSelectedrw   rx   Zxviewry   rO   
GetNewKeysr   buttonNewKeysranger   SetKeysTypeZradioKeysBuiltinradioKeysCustomr   optMenuKeysBuiltinoptMenuKeysCustomDeleteCustomKeysbuttonDeleteCustomKeysSaveAsNewKeySetrT   rV   rX   rY   r   rU   ZcolumnconfigureZrowconfigureZgridr   ZNSEWZNSZEWrW   )
r;   r/   rn   r   ZframeTargetZlabelTargetTitleZscrollTargetYZscrollTargetXZframesZbuttonSaveCustomKeysr<   )r   r=   rR   $  s~    		("%("##%" &zConfigDialog.CreatePageKeysc             C   s  |  j  } t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _ t |  |  _ t	 |  |  _
 t |  |  _ |  j j d j } t | d d d t d d } t | d d d t d d } t | d d d t } t | d d d t } t | d d d t d d } t | d d	 } t | d
 |  j d d d |  j d d }	 t | d
 |  j d d d |  j d d }
 t | d d } t | d
 |  j d d d |  j d d } t | d
 |  j d d d |  j d d } t | d d } t | d d } t | d |  j d d } t | d d } t | d |  j d d } t | d d } t | d |  j d d } t |  } t |  } t |  } t | d d d t d t |  _ | j d |  j j  |  j j d | j  |  j j d  |  j  t | d d! d" t  d d# d |  j! |  _" t | d d$ d d# d |  j# |  _$ t | d d% d" t  d d# d |  j% |  _& | j' d& t( d' d d( d d) t)  | j' d& t( d' d d( d d) t)  | j' d& t( d' d d( d d) t)  | j' d& t( d' d d( d d) t)  | j' d& t( d' d d( d d* t* d) t+  | j' d& t, d+ t- d' d d( d  |
 j' d& t. d+ t- d' d d( d  |	 j' d& t. d+ t- d' d d( d  | j' d& t, d+ t- d' d d( d  | j' d& t. d+ t- d' d d( d  | j' d& t. d+ t- d' d d( d  | j' d& t, d+ t- d' d d( d  | j' d& t. d+ t/ d' d, d( d