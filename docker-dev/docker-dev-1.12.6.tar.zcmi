n on the left-hand-side would
use the existing reference that was already there:
.PP
.Vb 1
\&    @{$AoA[3]} = @array;
.Ve
.PP
Of course, this \fIwould\fR have the \*(L"interesting\*(R" effect of clobbering
\&\f(CW@another_array\fR.  (Have you ever noticed how when a programmer says
something is \*(L"interesting\*(R", that rather than meaning \*(L"intriguing\*(R",
they're disturbingly more apt to mean that it's \*(L"annoying\*(R",
\&\*(L"difficult\*(R", or both?  :\-)
.PP
So just remember always to use the array or hash constructors with \f(CW\*(C`[]\*(C'\fR
or \f(CW\*(C`{}\*(C'\fR, and you'll be fine, although it's not always optimally
efficient.
.PP
Surprisingly, the following dangerous-looking construct will
actually work out fine:
.PP
.Vb 4
\&    for $i (1..10) {
\&        my @array = somefunc($i);
\&        $AoA[$i] = \e@array;
\&    }
.Ve
.PP
That's because \fImy()\fR is more of a run-time statement than it is a
compile-time declaration \fIper se\fR.  This means that the \fImy()\fR variable is
remade afresh each time through the loop.  So even though it \fIlooks\fR as
though you stored the same variable reference each time, you actually did
not!  This is a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of programmers.  So I
usually advise against teaching it to beginners.  In fact, except for
passing arguments to functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code.  Instead, I advise
beginners that they (and most of the rest of us) should try to use the
much more easily understood constructors \f(CW\*(C`[]\*(C'\fR and \f(CW\*(C`{}\*(C'\fR instead of
relying upon lexical (or dynamic) scoping and hidden reference-counting to
do the right thing behind the scenes.
.PP
In summary:
.PP
.Vb 3
\&    $AoA[$i] = [ @array ];      # usually best
\&    $AoA[$i] = \e@array;         # perilous; just how my() was that array?
\&    @{ $AoA[$i] } = @array;     # way too tricky for most programmers
.Ve
.SH "CAVEAT ON PRECEDENCE"
.IX Xref "dereference, precedence dereferencing, precedence"
.IX Header "CAVEAT ON PRECEDENCE"
Speaking of things like \f(CW\*(C`@{$AoA[$i]}\*(C'\fR, the following are actually the
same thing:
.IX Xref "->"
.PP
.Vb 2
\&    $aref\->[2][2]       # clear
\&    $$aref[2][2]        # confusing
.Ve
.PP
That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: \f(CW\*(C`$ @ * % &\*(C'\fR) make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or \*(C+ programmer, who is quite
accustomed to using \f(CW*a[i]\fR to mean what's pointed to by the \fIi'th\fR
element of \f(CW\*(C`a\*(C'\fR.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this isn't C.
.PP
The seemingly equivalent construct in Perl, \f(CW$$aref[$i]\fR first does
the deref of \f(CW$aref\fR, making it take \f(CW$aref\fR as a reference to an
array, and then dereference that, and finally tell you the \fIi'th\fR value
of the array pointed to by \f(CW$AoA\fR. If you wanted the C notion, you'd have to
write \f(CW\*(C`${$AoA[$i]}\*(C'\fR to force the \f(CW$AoA[$i]\fR to get evaluated first
before the leading \f(CW\*(C`$\*(C'\fR dereferencer.
.ie n .SH "WHY YOU SHOULD ALWAYS ""use strict"""
.el .SH "WHY YOU SHOULD ALWAYS \f(CWuse strict\fP"
.IX Header "WHY YOU SHOULD ALWAYS use strict"
If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best
way to avoid getting confused is to start every program like this:
.PP
.Vb 2
\&    #!/usr/bin/perl \-w
\&    use strict;
.Ve
.PP
This way, you'll be forced to declare all your variables with \fImy()\fR and
also disallow accidental \*(L"symbolic dereferencing\*(R".  Therefore if you'd done
this:
.PP
.Vb 5
\&    my $aref = [
\&        [ "fred", "barney", "pebbles", "bambam", "dino", ],
\&        [ "homer", "bart", "marge", "maggie", ],
\&        [ "george", "jane", "elroy", "judy", ],
\&    ];
\&
\&    print $aref[2][2];
.Ve
.PP
The compiler would immediately flag that as an error \fIat compile time\fR,
because you were accidentally accessing \f(CW@aref\fR, an undeclared
variable, and it would thereby remind you to write instead:
.PP
.Vb 1
\&    print $aref\->[2][2]
.Ve
.SH "DEBUGGING"
.IX Xref "data structure, debugging complex data structure, debugging AoA, debugging HoA, debugging AoH, debugging HoH, debugging array of arrays, debugging hash of arrays, debugging array of hashes, debugging hash of hashes, debugging"
.IX Header "DEBUGGING"
Before version 5.002, the standard Perl debugger didn't do a very nice job of
printing out complex data structures.  With 5.002 or above, the
debugger includes several new features, including command line editing as
well as the \f(CW\*(C`x\*(C'\fR command to dump out complex data structures.  For
example, given the assignment to \f(CW$AoA\fR above, here's the debugger output:
.PP
.Vb 10
\&    DB<1> x $AoA
\&    $AoA = ARRAY(0x13b5a0)
\&       0  ARRAY(0x1f0a24)
\&          0  \*(Aqfred\*(Aq
\&          1  \*(Aqbarney\*(Aq
\&          2  \*(Aqpebbles\*(Aq
\&          3  \*(Aqbambam\*(Aq
\&          4  \*(Aqdino\*(Aq
\&       1  ARRAY(0x13b558)
\&          0  \*(Aqhomer\*(Aq
\&          1  \*(Aqbart\*(Aq
\&          2  \*(Aqmarge\*(Aq
\&          3  \*(Aqmaggie\*(Aq
\&       2  ARRAY(0x13b540)
\&          0  \*(Aqgeorge\*(Aq
\&          1  \*(Aqjane\*(Aq
\&          2  \*(Aqelroy\*(Aq
\&          3  \*(Aqjudy\*(Aq
.Ve
.SH "CODE EXAMPLES"
.IX Header "CODE EXAMPLES"
Presented with little comment (these will get their own manpages someday)
here are short code examples illustrating access of various
types of data structures.
.SH "ARRAYS OF ARRAYS"
.IX Xref "array of arrays AoA"
.IX Header "ARRAYS OF ARRAYS"
.SS "Declaration of an \s-1ARRAY\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Declaration of an ARRAY OF ARRAYS"
.Vb 5
\& @AoA = (
\&        [ "fred", "barney" ],
\&        [ "george", "jane", "elroy" ],
\&        [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of an \s-1ARRAY\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Generation of an ARRAY OF ARRAYS"
.Vb 4
\& # reading from file
\& while ( <> ) {
\&     push @AoA, [ split ];
\& }
\&
\& # calling a function
\& for $i ( 1 .. 10 ) {
\&     $AoA[$i] = [ somefunc($i) ];
\& }
\&
\& # using temp vars
\& for $i ( 1 .. 10 ) {
\&     @tmp = somefunc($i);
\&     $AoA[$i] = [ @tmp ];
\& }
\&
\& # add to an existing row
\& push @{ $AoA[0] }, "wilma", "betty";
.Ve
.SS "Access and Printing of an \s-1ARRAY\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Access and Printing of an ARRAY OF ARRAYS"
.Vb 2
\& # one element
\& $AoA[0][0] = "Fred";
\&
\& # another element
\& $AoA[1][1] =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing with refs
\& for $aref ( @AoA ) {
\&     print "\et [ @$aref ],\en";
\& }
\&
\& # print the whole thing with indices
\& for $i ( 0 .. $#AoA ) {
\&     print "\et [ @{$AoA[$i]} ],\en";
\& }
\&
\& # print the whole thing one at a time
\& for $i ( 0 .. $#AoA ) {
\&     for $j ( 0 .. $#{ $AoA[$i] } ) {
\&         print "elt $i $j is $AoA[$i][$j]\en";
\&     }
\& }
.Ve
.SH "HASHES OF ARRAYS"
.IX Xref "hash of arrays HoA"
.IX Header "HASHES OF ARRAYS"
.SS "Declaration of a \s-1HASH\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Declaration of a HASH OF ARRAYS"
.Vb 5
\& %HoA = (
\&        flintstones        => [ "fred", "barney" ],
\&        jetsons            => [ "george", "jane", "elroy" ],
\&        simpsons           => [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of a \s-1HASH\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Generation of a HASH OF ARRAYS"
.Vb 6
\& # reading from file
\& # flintstones: fred barney wilma dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $HoA{$1} = [ split ];
\& }
\&
\& # reading from file; more temps
\& # flintstones: fred barney wilma dino
\& while ( $line = <> ) {
\&     ($who, $rest) = split /:\es*/, $line, 2;
\&     @fields = split \*(Aq \*(Aq, $rest;
\&     $HoA{$who} = [ @fields ];
\& }
\&
\& # calling a function that returns a list
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoA{$group} = [ get_family($group) ];
\& }
\&
\& # likewise, but using temps
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     @members = get_family($group);
\&     $HoA{$group} = [ @members ];
\& }
\&
\& # append new members to an existing family
\& push @{ $HoA{"flintstones"} }, "wilma", "betty";
.Ve
.SS "Access and Printing of a \s-1HASH\s0 \s-1OF\s0 \s-1ARRAYS\s0"
.IX Subsection "Access and Printing of a HASH OF ARRAYS"
.Vb 2
\& # one element
\& $HoA{flintstones}[0] = "Fred";
\&
\& # another element
\& $HoA{simpsons}[1] =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing
\& foreach $family ( keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print the whole thing with indices
\& foreach $family ( keys %HoA ) {
\&     print "family: ";
\&     foreach $i ( 0 .. $#{ $HoA{$family} } ) {
\&         print " $i = $HoA{$family}[$i]";
\&     }
\&     print "\en";
\& }
\&
\& # print the whole thing sorted by number of members
\& foreach $family ( sort { @{$HoA{$b}} <=> @{$HoA{$a}} } keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print the whole thing sorted by number of members and name
\& foreach $family ( sort {
\&                            @{$HoA{$b}} <=> @{$HoA{$a}}
\&                                        ||
\&                                    $a cmp $b
\&            } keys %HoA )
\& {
\&     print "$family: ", join(", ", sort @{ $HoA{$family} }), "\en";
\& }
.Ve
.SH "ARRAYS OF HASHES"
.IX Xref "array of hashes AoH"
.IX Header "ARRAYS OF HASHES"
.SS "Declaration of an \s-1ARRAY\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Declaration of an ARRAY OF HASHES"
.Vb 10
\& @AoH = (
\&        {
\&            Lead     => "fred",
\&            Friend   => "barney",
\&        },
\&        {
\&            Lead     => "george",
\&            Wife     => "jane",
\&            Son      => "elroy",
\&        },
\&        {
\&            Lead     => "homer",
\&            Wife     => "marge",
\&            Son      => "bart",
\&        }
\&  );
.Ve
.SS "Generation of an \s-1ARRAY\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Generation of an ARRAY OF HASHES"
.Vb 10
\& # reading from file
\& # format: LEAD=fred FRIEND=barney
\& while ( <> ) {
\&     $rec = {};
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\&     push @AoH, $rec;
\& }
\&
\&
\& # reading from file
\& # format: LEAD=fred FRIEND=barney
\& # no temp
\& while ( <> ) {
\&     push @AoH, { split /[\es+=]/ };
\& }
\&
\& # calling a function  that returns a key/value pair list, like
\& # "lead","fred","daughter","pebbles"
\& while ( %fields = getnextpairset() ) {
\&     push @AoH, { %fields };
\& }
\&
\& # likewise, but using no temp vars
\& while (<>) {
\&     push @AoH, { parsepairs($_) };
\& }
\&
\& # add key/value to an element
\& $AoH[0]{pet} = "dino";
\& $AoH[2]{pet} = "santa\*(Aqs little helper";
.Ve
.SS "Access and Printing of an \s-1ARRAY\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Access and Printing of an ARRAY OF HASHES"
.Vb 2
\& # one element
\& $AoH[0]{lead} = "fred";
\&
\& # another element
\& $AoH[1]{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing with refs
\& for $href ( @AoH ) {
\&     print "{ ";
\&     for $role ( keys %$href ) {
\&         print "$role=$href\->{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing with indices
\& for $i ( 0 .. $#AoH ) {
\&     print "$i is { ";
\&     for $role ( keys %{ $AoH[$i] } ) {
\&         print "$role=$AoH[$i]{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing one at a time
\& for $i ( 0 .. $#AoH ) {
\&     for $role ( keys %{ $AoH[$i] } ) {
\&         print "elt $i $role is $AoH[$i]{$role}\en";
\&     }
\& }
.Ve
.SH "HASHES OF HASHES"
.IX Xref "hash of hashes HoH"
.IX Header "HASHES OF HASHES"
.SS "Declaration of a \s-1HASH\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Declaration of a HASH OF HASHES"
.Vb 10
\& %HoH = (
\&        flintstones => {
\&                lead      => "fred",
\&                pal       => "barney",
\&        },
\&        jetsons     => {
\&                lead      => "george",
\&                wife      => "jane",
\&                "his boy" => "elroy",
\&        },
\&        simpsons    => {
\&                lead      => "homer",
\&                wife      => "marge",
\&                kid       => "bart",
\&        },
\& );
.Ve
.SS "Generation of a \s-1HASH\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Generation of a HASH OF HASHES"
.Vb 9
\& # reading from file
\& # flintstones: lead=fred pal=barney wife=wilma pet=dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $HoH{$who}{$key} = $value;
\&     }
\&
\&
\& # reading from file; more temps
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     $rec = {};
\&     $HoH{$who} = $rec;
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\& }
\&
\& # calling a function  that returns a key,value hash
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoH{$group} = { get_family($group) };
\& }
\&
\& # likewise, but using temps
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     %members = get_family($group);
\&     $HoH{$group} = { %members };
\& }
\&
\& # append new members to an existing family
\& %new_folks = (
\&     wife => "wilma",
\&     pet  => "dino",
\& );
\&
\& for $what (keys %new_folks) {
\&     $HoH{flintstones}{$what} = $new_folks{$what};
\& }
.Ve
.SS "Access and Printing of a \s-1HASH\s0 \s-1OF\s0 \s-1HASHES\s0"
.IX Subsection "Access and Printing of a HASH OF HASHES"
.Vb 2
\& # one element
\& $HoH{flintstones}{wife} = "wilma";
\&
\& # another element
\& $HoH{simpsons}{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing
\& foreach $family ( keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing  somewhat sorted
\& foreach $family ( sort keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\&
\& # print the whole thing sorted by number of members
\& foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # establish a sort order (rank) for each role
\& $i = 0;
\& for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }
\&
\& # now print the whole thing sorted by number of members
\& foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
\&     print "$family: { ";
\&     # and print these according to rank order
\&     for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
.Ve
.SH "MORE ELABORATE RECORDS"
.IX Xref "record structure struct"
.IX Header "MORE ELABORATE RECORDS"
.SS "Declaration of \s-1MORE\s0 \s-1ELABORATE\s0 \s-1RECORDS\s0"
.IX Subsection "Declaration of MORE ELABORATE RECORDS"
Here's a sample showing how to create and use a record whose fields are of
many different sorts:
.PP
.Vb 8
\&     $rec = {
\&         TEXT      => $string,
\&         SEQUENCE  => [ @old_values ],
\&         LOOKUP    => { %some_table },
\&         THATCODE  => \e&some_function,
\&         THISCODE  => sub { $_[0] ** $_[1] },
\&         HANDLE    => \e*STDOUT,
\&     };
\&
\&     print $rec\->{TEXT};
\&
\&     print $rec\->{SEQUENCE}[0];
\&     $last = pop @ { $rec\->{SEQUENCE} };
\&
\&     print $rec\->{LOOKUP}{"key"};
\&     ($first_k, $first_v) = each %{ $rec\->{LOOKUP} };
\&
\&     $answer = $rec\->{THATCODE}\->($arg);
\&     $answer = $rec\->{THISCODE}\->($arg1, $arg2);
\&
\&     # careful of extra block braces on fh ref
\&     print { $rec\->{HANDLE} } "a string\en";
\&
\&     use FileHandle;
\&     $rec\->{HANDLE}\->autoflush(1);
\&     $rec\->{HANDLE}\->print(" a string\en");
.Ve
.SS "Declaration of a \s-1HASH\s0 \s-1OF\s0 \s-1COMPLEX\s0 \s-1RECORDS\s0"
.IX Subsection "Declaration of a HASH OF COMPLEX RECORDS"
.Vb 10
\&     %TV = (
\&        flintstones => {
\&            series   => "flintstones",
\&            nights   => [ qw(monday thursday friday) ],
\&            members  => [
\&                { name => "fred",    role => "lead", age  => 36, },
\&                { name => "wilma",   role => "wife", age  => 31, },
\&                { name => "pebbles", role => "kid",  age  =>  4, },
\&            ],
\&        },
\&
\&        jetsons     => {
\&            series   => "jetsons",
\&            nights   => [ qw(wednesday saturday) ],
\&            members  => [
\&                { name => "george",  role => "lead", age  => 41, },
\&                { name => "jane",    role => "wife", age  => 39, },
\&                { name => "elroy",   role => "kid",  age  =>  9, },
\&            ],
\&         },
\&
\&        simpsons    => {
\&            series   => "simpsons",
\&            nights   => [ qw(monday) ],
\&            members  => [
\&                { name => "homer", role => "lead", age  => 34, },
\&                { name => "marge", role => "wife", age => 37, },
\&                { name => "bart",  role => "kid",  age  =>  11, },
\&            ],
\&         },
\&      );
.Ve
.SS "Generation of a \s-1HASH\s0 \s-1OF\s0 \s-1COMPLEX\s0 \s-1RECORDS\s0"
.IX Subsection "Generation of a HASH OF COMPLEX RECORDS"
.Vb 5
\&     # reading from file
\&     # this is most easily done by having the file itself be
\&     # in the raw data format as shown above.  perl is happy
\&     # to parse complex data structures if declared as data, so
\&     # sometimes it\*(Aqs easiest to do that
\&
\&     # here\*(Aqs a piece by piece build up
\&     $rec = {};
\&     $rec\->{series} = "flintstones";
\&     $rec\->{nights} = [ find_days() ];
\&
\&     @members = ();
\&     # assume this file in field=value syntax
\&     while (<>) {
\&         %fields = split /[\es=]+/;
\&         push @members, { %fields };
\&     }
\&     $rec\->{members} = [ @members ];
\&
\&     # now remember the whole thing
\&     $TV{ $rec\->{series} } = $rec;
\&
\&     ###########################################################
\&     # now, you might want to make interesting extra fields that
\&     # include pointers back into the same data structure so if
\&     # change one piece, it changes everywhere, like for example
\&     # if you wanted a {kids} field that was a reference
\&     # to an array of the kids\*(Aq records without having duplicate
\&     # records and thus update problems.
\&     ###########################################################
\&     foreach $family (keys %TV) {
\&         $rec = $TV{$family}; # temp pointer
\&         @kids = ();
\&         for $person ( @{ $rec\->{members} } ) {
\&             if ($person\->{role} =~ /kid|son|daughter/) {
\&                 push @kids, $person;
\&             }
\&         }
\&         # REMEMBER: $rec and $TV{$family} point to same data!!
\&         $rec\->{kids} = [ @kids ];
\&     }
\&
\&     # you copied the array, but the array itself contains pointers
\&     # to uncopied objects. this means that if you make bart get
\&     # older via
\&
\&     $TV{simpsons}{kids}[0]{age}++;
\&
\&     # then this would also change in
\&     print $TV{simpsons}{members}[2]{age};
\&
\&     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
\&     # both point to the same underlying anonymous hash table
\&
\&     # print the whole thing
\&     foreach $family ( keys %TV ) {
\&         print "the $family";
\&         print " is on during @{ $TV{$family}{nights} }\en";
\&         print "its members are:\en";
\&         for $who ( @{ $TV{$family}{members} } ) {
\&             print " $who\->{name} ($who\->{role}), age $who\->{age}\en";
\&         }
\&         print "it turns out that $TV{$family}{lead} has ";
\&         print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
\&         print join (", ", map { $_\->{name} } @{ $TV{$family}{kids} } );
\&         print "\en";
\&     }
.Ve
.SH "Database Ties"
.IX Header "Database Ties"
You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but \s-1GDBM\s0 and
Berkeley \s-1DB\s0 have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does partially attempt to address this need is the \s-1MLDBM\s0
module.  Check your nearest \s-1CPAN\s0 site as described in perlmodlib for
source code to \s-1MLDBM\s0.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlref, perllol, perldata, perlobj
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen <\fItchrist@perl.com\fR>
.PP
Last update:
Wed Oct 23 04:57:50 \s-1MET\s0 \s-1DST\s0 1996
                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perldsc5.18.1                                0100644 0001750 0001750 00000100021 12566207436 022705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDSC 1"
.TH PERLDSC 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldsc \- Perl Data Structures Cookbook
.IX Xref "data structure complex data structure struct"
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl lets us have complex data structures.  You can write something like
this and all of a sudden, you'd have an array with three dimensions!
.PP
.Vb 8
\&    for $x (1 .. 10) {
\&        for $y (1 .. 10) {
\&            for $z (1 .. 10) {
\&                $AoA[$x][$y][$z] =
\&                    $x ** $y + $z;
\&            }
\&        }
\&    }
.Ve
.PP
Alas, however simple this may appear, underneath it's a much more
elaborate construct than meets the eye!
.PP
How do you print it out?  Why can't you say just \f(CW\*(C`print @AoA\*(C'\fR?  How do
you sort it?  How can you pass it to a function or get one of these back
from a function?  Is it an object?  Can you save it to disk to read
back later?  How do you access whole rows or columns of that matrix?  Do
all the values have to be numeric?
.PP
As you see, it's quite easy to become confused.  While some small portion
of the blame for this can be attributed to the reference-based
implementation, it's really more due to a lack of existing documentation with
examples designed for the beginner.
.PP
This document is meant to be a detailed but understandable treatment of the
many different sorts of data structures you might want to develop.  It
should also serve as a cookbook of examples.  That way, when you need to
create one of these complex data structures, you can just pinch, pilfer, or
purloin a drop-in example from here.
.PP
Let's look at each of these possible constructs in detail.  There are separate
sections on each of the following:
.IP "\(bu" 5
arrays of arrays
.IP "\(bu" 5
hashes of arrays
.IP "\(bu" 5
arrays of hashes
.IP "\(bu" 5
hashes of hashes
.IP "\(bu" 5
more elaborate constructs
.PP
But for now, let's look at general issues common to all
these types of data structures.
.SH "REFERENCES"
.IX Xref "reference dereference dereferencing pointer"
.IX Header "REFERENCES"
The most important thing to understand about all data structures in
Perl\*(--including multidimensional arrays\*(--is that even though they might
appear otherwise, Perl \f(CW@ARRAY\fRs and \f(CW%HASH\fRes are all internally
one-dimensional.  They can hold only scalar values (meaning a string,
number, or a reference).  They cannot directly contain other arrays or
hashes, but instead contain \fIreferences\fR to other arrays or hashes.
.IX Xref "multidimensional array array, multidimensional"
.PP
You can't use a reference to an array or hash in quite the same way that you
would a real array or hash.  For C or \*(C+ programmers unused to
distinguishing between arrays and pointers to the same, this can be
confusing.  If so, just think of it as the difference between a structure
and a pointer to a structure.
.PP
You can (and should) read more about references in perlref.
Briefly, references are rather like pointers that know what they
point to.  (Objects are also a kind of reference, but we won't be needing
them right away\*(--if ever.)  This means that when you have something which
looks to you like an access to a two-or-more-dimensional array and/or hash,
what's really going on is that the base type is
merely a one-dimensional entity that contains references to the next
level.  It's just that you can \fIuse\fR it as though it were a
two-dimensional one.  This is actually the way almost all C
multidimensional arrays work as well.
.PP
.Vb 4
\&    $array[7][12]                       # array of arrays
\&    $array[7]{string}                   # array of hashes
\&    $hash{string}[7]                    # hash of arrays
\&    $hash{string}{\*(Aqanother string\*(Aq}     # hash of hashes
.Ve
.PP
Now, because the top level contains only references, if you try to print
out your array in with a simple \fIprint()\fR function, you'll get something
that doesn't look very nice, like this:
.PP
.Vb 5
\&    @AoA = ( [2, 3], [4, 5, 7], [0] );
\&    print $AoA[1][2];
\&  7
\&    print @AoA;
\&  ARRAY(0x83c38)ARRAY(0x8b194)ARRAY(0x8b1d0)
.Ve
.PP
That's because Perl doesn't (ever) implicitly dereference your variables.
If you want to get at the thing a reference is referring to, then you have
to do this yourself using either prefix typing indicators, like
\&\f(CW\*(C`${$blah}\*(C'\fR, \f(CW\*(C`@{$blah}\*(C'\fR, \f(CW\*(C`@{$blah[$i]}\*(C'\fR, or else postfix pointer arrows,
like \f(CW\*(C`$a\->[3]\*(C'\fR, \f(CW\*(C`$h\->{fred}\*(C'\fR, or even \f(CW\*(C`$ob\->method()\->[3]\*(C'\fR.
.SH "COMMON MISTAKES"
.IX Header "COMMON MISTAKES"
The two most common mistakes made in constructing something like
an array of arrays is either accidentally counting the number of
elements or else taking a reference to the same memory location
repeatedly.  Here's the case where you just get the count instead
of a nested array:
.PP
.Vb 4
\&    for $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = @array;      # WRONG!
\&    }
.Ve
.PP
That's just the simple case of assigning an array to a scalar and getting
its element count.  If that's what you really and truly want, then you
might do well to consider being a tad more explicit about it, like this:
.PP
.Vb 4
\&    for $i (1..10) {
\&        @array = somefunc($i);
\&        $counts[$i] = scalar @array;
\&    }
.Ve
.PP
Here's the case of taking a reference to the same memory location
again and again:
.PP
.Vb 4
\&    for $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = \e@array;     # WRONG!
\&    }
.Ve
.PP
So, what's the big problem with that?  It looks right, doesn't it?
After all, I just told you that you need an array of references, so by
golly, you've made me one!
.PP
Unfortunately, while this is true, it's still broken.  All the references
in \f(CW@AoA\fR refer to the \fIvery same place\fR, and they will therefore all hold
whatever was last in \f(CW@array\fR!  It's similar to the problem demonstrated in
the following C program:
.PP
.Vb 5
\&    #include <pwd.h>
\&    main() {
\&        struct passwd *getpwnam(), *rp, *dp;
\&        rp = getpwnam("root");
\&        dp = getpwnam("daemon");
\&
\&        printf("daemon name is %s\enroot name is %s\en",
\&                dp\->pw_name, rp\->pw_name);
\&    }
.Ve
.PP
Which will print
.PP
.Vb 2
\&    daemon name is daemon
\&    root name is daemon
.Ve
.PP
The problem is that both \f(CW\*(C`rp\*(C'\fR and \f(CW\*(C`dp\*(C'\fR are pointers to the same location
in memory!  In C, you'd have to remember to \fImalloc()\fR yourself some new
memory.  In Perl, you'll want to use the array constructor \f(CW\*(C`[]\*(C'\fR or the
hash constructor \f(CW\*(C`{}\*(C'\fR instead.   Here's the right way to do the preceding
broken code fragments:
.IX Xref "[] {}"
.PP
.Vb 4
\&    for $i (1..10) {
\&        @array = somefunc($i);
\&        $AoA[$i] = [ @array ];
\&    }
.Ve
.PP
The square brackets make a reference to a new array with a \fIcopy\fR
of what's in \f(CW@array\fR at the time of the assignment.  This is what
you want.
.PP
Note that this will produce something similar, but it's
much harder to read:
.PP
.Vb 4
\&    for $i (1..10) {
\&        @array = 0 .. $i;
\&        @{$AoA[$i]} = @array;
\&    }
.Ve
.PP
Is it the same?  Well, maybe so\*(--and maybe not.  The subtle difference
is that when you assign something in square brackets, you know for sure
it's always a brand new reference with a new \fIcopy\fR of the data.
Something else could be going on in this new case with the \f(CW\*(C`@{$AoA[$i]}\*(C'\fR
dereference on the left-hand-side of the assignment.  It all depends on
whether \f(CW$AoA[$i]\fR had been undefined to start with, or whether it
already contained a reference.  If you had already populated \f(CW@AoA\fR with
references, as in
.PP
.Vb 1
\&    $AoA[3] = \e@another_array;
.Ve
.PP
Then the assignment with the indirection on the left-hand-side would
use the existing reference that was already there:
.PP
.Vb 1
\&    @{$AoA[3]} = @array;
.Ve
.PP
Of course, this \fIwould\fR have the \*(L"interesting\*(R" effect of clobbering
\&\f(CW@another_array\fR.  (Have you ever noticed how when a programmer says
something is \*(L"interesting\*(R", that rather than meaning \*(L"intriguing\*(R",
they're disturbingly more apt to mean that it's \*(L"annoying\*(R",
\&\*(L"difficult\*(R", or both?  :\-)
.PP
So just remember always to use the array or hash constructors with \f(CW\*(C`[]\*(C'\fR
or \f(CW\*(C`{}\*(C'\fR, and you'll be fine, although it's not always optimally
efficient.
.PP
Surprisingly, the following dangerous-looking construct will
actually work out fine:
.PP
.Vb 4
\&    for $i (1..10) {
\&        my @array = somefunc($i);
\&        $AoA[$i] = \e@array;
\&    }
.Ve
.PP
That's because \fImy()\fR is more of a run-time statement than it is a
compile-time declaration \fIper se\fR.  This means that the \fImy()\fR variable is
remade afresh each time through the loop.  So even though it \fIlooks\fR as
though you stored the same variable reference each time, you actually did
not!  This is a subtle distinction that can produce more efficient code at
the risk of misleading all but the most experienced of programmers.  So I
usually advise against teaching it to beginners.  In fact, except for
passing arguments to functions, I seldom like to see the gimme-a-reference
operator (backslash) used much at all in code.  Instead, I advise
beginners that they (and most of the rest of us) should try to use the
much more easily understood constructors \f(CW\*(C`[]\*(C'\fR and \f(CW\*(C`{}\*(C'\fR instead of
relying upon lexical (or dynamic) scoping and hidden reference-counting to
do the right thing behind the scenes.
.PP
In summary:
.PP
.Vb 3
\&    $AoA[$i] = [ @array ];      # usually best
\&    $AoA[$i] = \e@array;         # perilous; just how my() was that array?
\&    @{ $AoA[$i] } = @array;     # way too tricky for most programmers
.Ve
.SH "CAVEAT ON PRECEDENCE"
.IX Xref "dereference, precedence dereferencing, precedence"
.IX Header "CAVEAT ON PRECEDENCE"
Speaking of things like \f(CW\*(C`@{$AoA[$i]}\*(C'\fR, the following are actually the
same thing:
.IX Xref "->"
.PP
.Vb 2
\&    $aref\->[2][2]       # clear
\&    $$aref[2][2]        # confusing
.Ve
.PP
That's because Perl's precedence rules on its five prefix dereferencers
(which look like someone swearing: \f(CW\*(C`$ @ * % &\*(C'\fR) make them bind more
tightly than the postfix subscripting brackets or braces!  This will no
doubt come as a great shock to the C or \*(C+ programmer, who is quite
accustomed to using \f(CW*a[i]\fR to mean what's pointed to by the \fIi'th\fR
element of \f(CW\*(C`a\*(C'\fR.  That is, they first take the subscript, and only then
dereference the thing at that subscript.  That's fine in C, but this isn't C.
.PP
The seemingly equivalent construct in Perl, \f(CW$$aref[$i]\fR first does
the deref of \f(CW$aref\fR, making it take \f(CW$aref\fR as a reference to an
array, and then dereference that, and finally tell you the \fIi'th\fR value
of the array pointed to by \f(CW$AoA\fR. If you wanted the C notion, you'd have to
write \f(CW\*(C`${$AoA[$i]}\*(C'\fR to force the \f(CW$AoA[$i]\fR to get evaluated first
before the leading \f(CW\*(C`$\*(C'\fR dereferencer.
.ie n .SH "WHY YOU SHOULD ALWAYS ""use strict"""
.el .SH "WHY YOU SHOULD ALWAYS \f(CWuse strict\fP"
.IX Header "WHY YOU SHOULD ALWAYS use strict"
If this is starting to sound scarier than it's worth, relax.  Perl has
some features to help you avoid its most common pitfalls.  The best
way to avoid getting confused is to start every program like this:
.PP
.Vb 2
\&    #!/usr/bin/perl \-w
\&    use strict;
.Ve
.PP
This way, you'll be forced to declare all your variables with \fImy()\fR and
also disallow accidental \*(L"symbolic dereferencing\*(R".  Therefore if you'd done
this:
.PP
.Vb 5
\&    my $aref = [
\&        [ "fred", "barney", "pebbles", "bambam", "dino", ],
\&        [ "homer", "bart", "marge", "maggie", ],
\&        [ "george", "jane", "elroy", "judy", ],
\&    ];
\&
\&    print $aref[2][2];
.Ve
.PP
The compiler would immediately flag that as an error \fIat compile time\fR,
because you were accidentally accessing \f(CW@aref\fR, an undeclared
variable, and it would thereby remind you to write instead:
.PP
.Vb 1
\&    print $aref\->[2][2]
.Ve
.SH "DEBUGGING"
.IX Xref "data structure, debugging complex data structure, debugging AoA, debugging HoA, debugging AoH, debugging HoH, debugging array of arrays, debugging hash of arrays, debugging array of hashes, debugging hash of hashes, debugging"
.IX Header "DEBUGGING"
You can use the debugger's \f(CW\*(C`x\*(C'\fR command to dump out complex data structures.
For example, given the assignment to \f(CW$AoA\fR above, here's the debugger output:
.PP
.Vb 10
\&    DB<1> x $AoA
\&    $AoA = ARRAY(0x13b5a0)
\&       0  ARRAY(0x1f0a24)
\&          0  \*(Aqfred\*(Aq
\&          1  \*(Aqbarney\*(Aq
\&          2  \*(Aqpebbles\*(Aq
\&          3  \*(Aqbambam\*(Aq
\&          4  \*(Aqdino\*(Aq
\&       1  ARRAY(0x13b558)
\&          0  \*(Aqhomer\*(Aq
\&          1  \*(Aqbart\*(Aq
\&          2  \*(Aqmarge\*(Aq
\&          3  \*(Aqmaggie\*(Aq
\&       2  ARRAY(0x13b540)
\&          0  \*(Aqgeorge\*(Aq
\&          1  \*(Aqjane\*(Aq
\&          2  \*(Aqelroy\*(Aq
\&          3  \*(Aqjudy\*(Aq
.Ve
.SH "CODE EXAMPLES"
.IX Header "CODE EXAMPLES"
Presented with little comment (these will get their own manpages someday)
here are short code examples illustrating access of various
types of data structures.
.SH "ARRAYS OF ARRAYS"
.IX Xref "array of arrays AoA"
.IX Header "ARRAYS OF ARRAYS"
.SS "Declaration of an \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Declaration of an ARRAY OF ARRAYS"
.Vb 5
\& @AoA = (
\&        [ "fred", "barney" ],
\&        [ "george", "jane", "elroy" ],
\&        [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of an \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Generation of an ARRAY OF ARRAYS"
.Vb 4
\& # reading from file
\& while ( <> ) {
\&     push @AoA, [ split ];
\& }
\&
\& # calling a function
\& for $i ( 1 .. 10 ) {
\&     $AoA[$i] = [ somefunc($i) ];
\& }
\&
\& # using temp vars
\& for $i ( 1 .. 10 ) {
\&     @tmp = somefunc($i);
\&     $AoA[$i] = [ @tmp ];
\& }
\&
\& # add to an existing row
\& push @{ $AoA[0] }, "wilma", "betty";
.Ve
.SS "Access and Printing of an \s-1ARRAY OF ARRAYS\s0"
.IX Subsection "Access and Printing of an ARRAY OF ARRAYS"
.Vb 2
\& # one element
\& $AoA[0][0] = "Fred";
\&
\& # another element
\& $AoA[1][1] =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing with refs
\& for $aref ( @AoA ) {
\&     print "\et [ @$aref ],\en";
\& }
\&
\& # print the whole thing with indices
\& for $i ( 0 .. $#AoA ) {
\&     print "\et [ @{$AoA[$i]} ],\en";
\& }
\&
\& # print the whole thing one at a time
\& for $i ( 0 .. $#AoA ) {
\&     for $j ( 0 .. $#{ $AoA[$i] } ) {
\&         print "elt $i $j is $AoA[$i][$j]\en";
\&     }
\& }
.Ve
.SH "HASHES OF ARRAYS"
.IX Xref "hash of arrays HoA"
.IX Header "HASHES OF ARRAYS"
.SS "Declaration of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Declaration of a HASH OF ARRAYS"
.Vb 5
\& %HoA = (
\&        flintstones        => [ "fred", "barney" ],
\&        jetsons            => [ "george", "jane", "elroy" ],
\&        simpsons           => [ "homer", "marge", "bart" ],
\&      );
.Ve
.SS "Generation of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Generation of a HASH OF ARRAYS"
.Vb 6
\& # reading from file
\& # flintstones: fred barney wilma dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $HoA{$1} = [ split ];
\& }
\&
\& # reading from file; more temps
\& # flintstones: fred barney wilma dino
\& while ( $line = <> ) {
\&     ($who, $rest) = split /:\es*/, $line, 2;
\&     @fields = split \*(Aq \*(Aq, $rest;
\&     $HoA{$who} = [ @fields ];
\& }
\&
\& # calling a function that returns a list
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoA{$group} = [ get_family($group) ];
\& }
\&
\& # likewise, but using temps
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     @members = get_family($group);
\&     $HoA{$group} = [ @members ];
\& }
\&
\& # append new members to an existing family
\& push @{ $HoA{"flintstones"} }, "wilma", "betty";
.Ve
.SS "Access and Printing of a \s-1HASH OF ARRAYS\s0"
.IX Subsection "Access and Printing of a HASH OF ARRAYS"
.Vb 2
\& # one element
\& $HoA{flintstones}[0] = "Fred";
\&
\& # another element
\& $HoA{simpsons}[1] =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing
\& foreach $family ( keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print the whole thing with indices
\& foreach $family ( keys %HoA ) {
\&     print "family: ";
\&     foreach $i ( 0 .. $#{ $HoA{$family} } ) {
\&         print " $i = $HoA{$family}[$i]";
\&     }
\&     print "\en";
\& }
\&
\& # print the whole thing sorted by number of members
\& foreach $family ( sort { @{$HoA{$b}} <=> @{$HoA{$a}} } keys %HoA ) {
\&     print "$family: @{ $HoA{$family} }\en"
\& }
\&
\& # print the whole thing sorted by number of members and name
\& foreach $family ( sort {
\&                            @{$HoA{$b}} <=> @{$HoA{$a}}
\&                                        ||
\&                                    $a cmp $b
\&            } keys %HoA )
\& {
\&     print "$family: ", join(", ", sort @{ $HoA{$family} }), "\en";
\& }
.Ve
.SH "ARRAYS OF HASHES"
.IX Xref "array of hashes AoH"
.IX Header "ARRAYS OF HASHES"
.SS "Declaration of an \s-1ARRAY OF HASHES\s0"
.IX Subsection "Declaration of an ARRAY OF HASHES"
.Vb 10
\& @AoH = (
\&        {
\&            Lead     => "fred",
\&            Friend   => "barney",
\&        },
\&        {
\&            Lead     => "george",
\&            Wife     => "jane",
\&            Son      => "elroy",
\&        },
\&        {
\&            Lead     => "homer",
\&            Wife     => "marge",
\&            Son      => "bart",
\&        }
\&  );
.Ve
.SS "Generation of an \s-1ARRAY OF HASHES\s0"
.IX Subsection "Generation of an ARRAY OF HASHES"
.Vb 10
\& # reading from file
\& # format: LEAD=fred FRIEND=barney
\& while ( <> ) {
\&     $rec = {};
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\&     push @AoH, $rec;
\& }
\&
\&
\& # reading from file
\& # format: LEAD=fred FRIEND=barney
\& # no temp
\& while ( <> ) {
\&     push @AoH, { split /[\es+=]/ };
\& }
\&
\& # calling a function  that returns a key/value pair list, like
\& # "lead","fred","daughter","pebbles"
\& while ( %fields = getnextpairset() ) {
\&     push @AoH, { %fields };
\& }
\&
\& # likewise, but using no temp vars
\& while (<>) {
\&     push @AoH, { parsepairs($_) };
\& }
\&
\& # add key/value to an element
\& $AoH[0]{pet} = "dino";
\& $AoH[2]{pet} = "santa\*(Aqs little helper";
.Ve
.SS "Access and Printing of an \s-1ARRAY OF HASHES\s0"
.IX Subsection "Access and Printing of an ARRAY OF HASHES"
.Vb 2
\& # one element
\& $AoH[0]{lead} = "fred";
\&
\& # another element
\& $AoH[1]{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing with refs
\& for $href ( @AoH ) {
\&     print "{ ";
\&     for $role ( keys %$href ) {
\&         print "$role=$href\->{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing with indices
\& for $i ( 0 .. $#AoH ) {
\&     print "$i is { ";
\&     for $role ( keys %{ $AoH[$i] } ) {
\&         print "$role=$AoH[$i]{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing one at a time
\& for $i ( 0 .. $#AoH ) {
\&     for $role ( keys %{ $AoH[$i] } ) {
\&         print "elt $i $role is $AoH[$i]{$role}\en";
\&     }
\& }
.Ve
.SH "HASHES OF HASHES"
.IX Xref "hash of hashes HoH"
.IX Header "HASHES OF HASHES"
.SS "Declaration of a \s-1HASH OF HASHES\s0"
.IX Subsection "Declaration of a HASH OF HASHES"
.Vb 10
\& %HoH = (
\&        flintstones => {
\&                lead      => "fred",
\&                pal       => "barney",
\&        },
\&        jetsons     => {
\&                lead      => "george",
\&                wife      => "jane",
\&                "his boy" => "elroy",
\&        },
\&        simpsons    => {
\&                lead      => "homer",
\&                wife      => "marge",
\&                kid       => "bart",
\&        },
\& );
.Ve
.SS "Generation of a \s-1HASH OF HASHES\s0"
.IX Subsection "Generation of a HASH OF HASHES"
.Vb 9
\& # reading from file
\& # flintstones: lead=fred pal=barney wife=wilma pet=dino
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $HoH{$who}{$key} = $value;
\&     }
\&
\&
\& # reading from file; more temps
\& while ( <> ) {
\&     next unless s/^(.*?):\es*//;
\&     $who = $1;
\&     $rec = {};
\&     $HoH{$who} = $rec;
\&     for $field ( split ) {
\&         ($key, $value) = split /=/, $field;
\&         $rec\->{$key} = $value;
\&     }
\& }
\&
\& # calling a function  that returns a key,value hash
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     $HoH{$group} = { get_family($group) };
\& }
\&
\& # likewise, but using temps
\& for $group ( "simpsons", "jetsons", "flintstones" ) {
\&     %members = get_family($group);
\&     $HoH{$group} = { %members };
\& }
\&
\& # append new members to an existing family
\& %new_folks = (
\&     wife => "wilma",
\&     pet  => "dino",
\& );
\&
\& for $what (keys %new_folks) {
\&     $HoH{flintstones}{$what} = $new_folks{$what};
\& }
.Ve
.SS "Access and Printing of a \s-1HASH OF HASHES\s0"
.IX Subsection "Access and Printing of a HASH OF HASHES"
.Vb 2
\& # one element
\& $HoH{flintstones}{wife} = "wilma";
\&
\& # another element
\& $HoH{simpsons}{lead} =~ s/(\ew)/\eu$1/;
\&
\& # print the whole thing
\& foreach $family ( keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # print the whole thing  somewhat sorted
\& foreach $family ( sort keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\&
\& # print the whole thing sorted by number of members
\& foreach $family ( sort { keys %{$HoH{$b}} <=> keys %{$HoH{$a}} } keys %HoH ) {
\&     print "$family: { ";
\&     for $role ( sort keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
\&
\& # establish a sort order (rank) for each role
\& $i = 0;
\& for ( qw(lead wife son daughter pal pet) ) { $rank{$_} = ++$i }
\&
\& # now print the whole thing sorted by number of members
\& foreach $family ( sort { keys %{ $HoH{$b} } <=> keys %{ $HoH{$a} } } keys %HoH ) {
\&     print "$family: { ";
\&     # and print these according to rank order
\&     for $role ( sort { $rank{$a} <=> $rank{$b} }  keys %{ $HoH{$family} } ) {
\&         print "$role=$HoH{$family}{$role} ";
\&     }
\&     print "}\en";
\& }
.Ve
.SH "MORE ELABORATE RECORDS"
.IX Xref "record structure struct"
.IX Header "MORE ELABORATE RECORDS"
.SS "Declaration of \s-1MORE ELABORATE RECORDS\s0"
.IX Subsection "Declaration of MORE ELABORATE RECORDS"
Here's a sample showing how to create and use a record whose fields are of
many different sorts:
.PP
.Vb 8
\&     $rec = {
\&         TEXT      => $string,
\&         SEQUENCE  => [ @old_values ],
\&         LOOKUP    => { %some_table },
\&         THATCODE  => \e&some_function,
\&         THISCODE  => sub { $_[0] ** $_[1] },
\&         HANDLE    => \e*STDOUT,
\&     };
\&
\&     print $rec\->{TEXT};
\&
\&     print $rec\->{SEQUENCE}[0];
\&     $last = pop @ { $rec\->{SEQUENCE} };
\&
\&     print $rec\->{LOOKUP}{"key"};
\&     ($first_k, $first_v) = each %{ $rec\->{LOOKUP} };
\&
\&     $answer = $rec\->{THATCODE}\->($arg);
\&     $answer = $rec\->{THISCODE}\->($arg1, $arg2);
\&
\&     # careful of extra block braces on fh ref
\&     print { $rec\->{HANDLE} } "a string\en";
\&
\&     use FileHandle;
\&     $rec\->{HANDLE}\->autoflush(1);
\&     $rec\->{HANDLE}\->print(" a string\en");
.Ve
.SS "Declaration of a \s-1HASH OF COMPLEX RECORDS\s0"
.IX Subsection "Declaration of a HASH OF COMPLEX RECORDS"
.Vb 10
\&     %TV = (
\&        flintstones => {
\&            series   => "flintstones",
\&            nights   => [ qw(monday thursday friday) ],
\&            members  => [
\&                { name => "fred",    role => "lead", age  => 36, },
\&                { name => "wilma",   role => "wife", age  => 31, },
\&                { name => "pebbles", role => "kid",  age  =>  4, },
\&            ],
\&        },
\&
\&        jetsons     => {
\&            series   => "jetsons",
\&            nights   => [ qw(wednesday saturday) ],
\&            members  => [
\&                { name => "george",  role => "lead", age  => 41, },
\&                { name => "jane",    role => "wife", age  => 39, },
\&                { name => "elroy",   role => "kid",  age  =>  9, },
\&            ],
\&         },
\&
\&        simpsons    => {
\&            series   => "simpsons",
\&            nights   => [ qw(monday) ],
\&            members  => [
\&                { name => "homer", role => "lead", age  => 34, },
\&                { name => "marge", role => "wife", age => 37, },
\&                { name => "bart",  role => "kid",  age  =>  11, },
\&            ],
\&         },
\&      );
.Ve
.SS "Generation of a \s-1HASH OF COMPLEX RECORDS\s0"
.IX Subsection "Generation of a HASH OF COMPLEX RECORDS"
.Vb 5
\&     # reading from file
\&     # this is most easily done by having the file itself be
\&     # in the raw data format as shown above.  perl is happy
\&     # to parse complex data structures if declared as data, so
\&     # sometimes it\*(Aqs easiest to do that
\&
\&     # here\*(Aqs a piece by piece build up
\&     $rec = {};
\&     $rec\->{series} = "flintstones";
\&     $rec\->{nights} = [ find_days() ];
\&
\&     @members = ();
\&     # assume this file in field=value syntax
\&     while (<>) {
\&         %fields = split /[\es=]+/;
\&         push @members, { %fields };
\&     }
\&     $rec\->{members} = [ @members ];
\&
\&     # now remember the whole thing
\&     $TV{ $rec\->{series} } = $rec;
\&
\&     ###########################################################
\&     # now, you might want to make interesting extra fields that
\&     # include pointers back into the same data structure so if
\&     # change one piece, it changes everywhere, like for example
\&     # if you wanted a {kids} field that was a reference
\&     # to an array of the kids\*(Aq records without having duplicate
\&     # records and thus update problems.
\&     ###########################################################
\&     foreach $family (keys %TV) {
\&         $rec = $TV{$family}; # temp pointer
\&         @kids = ();
\&         for $person ( @{ $rec\->{members} } ) {
\&             if ($person\->{role} =~ /kid|son|daughter/) {
\&                 push @kids, $person;
\&             }
\&         }
\&         # REMEMBER: $rec and $TV{$family} point to same data!!
\&         $rec\->{kids} = [ @kids ];
\&     }
\&
\&     # you copied the array, but the array itself contains pointers
\&     # to uncopied objects. this means that if you make bart get
\&     # older via
\&
\&     $TV{simpsons}{kids}[0]{age}++;
\&
\&     # then this would also change in
\&     print $TV{simpsons}{members}[2]{age};
\&
\&     # because $TV{simpsons}{kids}[0] and $TV{simpsons}{members}[2]
\&     # both point to the same underlying anonymous hash table
\&
\&     # print the whole thing
\&     foreach $family ( keys %TV ) {
\&         print "the $family";
\&         print " is on during @{ $TV{$family}{nights} }\en";
\&         print "its members are:\en";
\&         for $who ( @{ $TV{$family}{members} } ) {
\&             print " $who\->{name} ($who\->{role}), age $who\->{age}\en";
\&         }
\&         print "it turns out that $TV{$family}{lead} has ";
\&         print scalar ( @{ $TV{$family}{kids} } ), " kids named ";
\&         print join (", ", map { $_\->{name} } @{ $TV{$family}{kids} } );
\&         print "\en";
\&     }
.Ve
.SH "Database Ties"
.IX Header "Database Ties"
You cannot easily tie a multilevel data structure (such as a hash of
hashes) to a dbm file.  The first problem is that all but \s-1GDBM\s0 and
Berkeley \s-1DB\s0 have size limitations, but beyond that, you also have problems
with how references are to be represented on disk.  One experimental
module that does partially attempt to address this need is the \s-1MLDBM\s0
module.  Check your nearest \s-1CPAN\s0 site as described in perlmodlib for
source code to \s-1MLDBM.\s0
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perlref, perllol, perldata, perlobj
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen <\fItchrist@perl.com\fR>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perldtrace.1                                 0100644 0001750 0001750 00000033013 12566207436 023070  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDTRACE 1"
.TH PERLDTRACE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldtrace \- Perl's support for DTrace
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # dtrace \-Zn \*(Aqperl::sub\-entry, perl::sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&    dtrace: description \*(Aqperl::sub\-entry, perl::sub\-return \*(Aq matched 10 probes
\&
\&    # perl \-E \*(Aqsub outer { inner(@_) } sub inner { say shift } outer("hello")\*(Aq
\&    hello
\&
\&    (dtrace output)
\&    CPU     ID                    FUNCTION:NAME
\&      0  75915       Perl_pp_entersub:sub\-entry   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   import
\&      0  75922      Perl_pp_leavesub:sub\-return   import
\&      0  75922      Perl_pp_leavesub:sub\-return   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   outer
\&      0  75915       Perl_pp_entersub:sub\-entry   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   outer
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DTrace is a framework for comprehensive system\- and application-level
tracing. Perl is a DTrace \fIprovider\fR, meaning it exposes several
\&\fIprobes\fR for instrumentation. You can use these in conjunction
with kernel-level probes, as well as probes from other providers
such as MySQL, in order to diagnose software defects, or even just
your application's bottlenecks.
.PP
Perl must be compiled with the \f(CW\*(C`\-Dusedtrace\*(C'\fR option in order to
make use of the provided probes. While DTrace aims to have no
overhead when its instrumentation is not active, Perl's support
itself cannot uphold that guarantee, so it is built without DTrace
probes under most systems. One notable exception is that Mac \s-1OS X\s0
ships a \fI/usr/bin/perl\fR with DTrace support enabled.
.SH "HISTORY"
.IX Header "HISTORY"
.IP "5.10.1" 4
.IX Item "5.10.1"
Perl's initial DTrace support was added, providing \f(CW\*(C`sub\-entry\*(C'\fR and
\&\f(CW\*(C`sub\-return\*(C'\fR probes.
.IP "5.14.0" 4
.IX Item "5.14.0"
The \f(CW\*(C`sub\-entry\*(C'\fR and \f(CW\*(C`sub\-return\*(C'\fR probes gain a fourth argument: the
package name of the function.
.IP "5.16.0" 4
.IX Item "5.16.0"
The \f(CW\*(C`phase\-change\*(C'\fR probe was added.
.IP "5.18.0" 4
.IX Item "5.18.0"
The \f(CW\*(C`op\-entry\*(C'\fR, \f(CW\*(C`loading\-file\*(C'\fR, and \f(CW\*(C`loaded\-file\*(C'\fR probes were added.
.SH "PROBES"
.IX Header "PROBES"
.IP "sub\-entry(\s-1SUBNAME, FILE, LINE, PACKAGE\s0)" 4
.IX Item "sub-entry(SUBNAME, FILE, LINE, PACKAGE)"
Traces the entry of any subroutine. Note that all of the variables
refer to the subroutine that is being invoked; there is currently
no way to get ahold of any information about the subroutine's
\&\fIcaller\fR from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-entry {
\&        printf("%s::%s entered at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);
\&    }
.Ve
.IP "sub\-return(\s-1SUBNAME, FILE, LINE, PACKAGE\s0)" 4
.IX Item "sub-return(SUBNAME, FILE, LINE, PACKAGE)"
Traces the exit of any subroutine. Note that all of the variables
refer to the subroutine that is returning; there is currently no
way to get ahold of any information about the subroutine's \fIcaller\fR
from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-return {
\&        printf("%s::%s returned at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);
\&    }
.Ve
.IP "phase\-change(\s-1NEWPHASE, OLDPHASE\s0)" 4
.IX Item "phase-change(NEWPHASE, OLDPHASE)"
Traces changes to Perl's interpreter state. You can internalize this
as tracing changes to Perl's \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR variable, especially
since the values for \f(CW\*(C`NEWPHASE\*(C'\fR and \f(CW\*(C`OLDPHASE\*(C'\fR are the strings that
\&\f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR reports.
.Sp
.Vb 4
\&    :*perl*::phase\-change {
\&        printf("Phase changed from %s to %s\en",
\&            copyinstr(arg1), copyinstr(arg0));
\&    }
.Ve
.IP "op\-entry(\s-1OPNAME\s0)" 4
.IX Item "op-entry(OPNAME)"
Traces the execution of each opcode in the Perl runloop. This probe
is fired before the opcode is executed. When the Perl debugger is
enabled, the DTrace probe is fired \fIafter\fR the debugger hooks (but
still before the opcode itself is executed).
.Sp
.Vb 3
\&    :*perl*::op\-entry {
\&        printf("About to execute opcode %s\en", copyinstr(arg0));
\&    }
.Ve
.IP "loading\-file(\s-1FILENAME\s0)" 4
.IX Item "loading-file(FILENAME)"
Fires when Perl is about to load an individual file, whether from
\&\f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`do\*(C'\fR. This probe fires before the file is
read from disk. The filename argument is converted to local filesystem
paths instead of providing \f(CW\*(C`Module::Name\*(C'\fR\-style names.
.Sp
.Vb 3
\&    :*perl*:loading\-file {
\&        printf("About to load %s\en", copyinstr(arg0));
\&    }
.Ve
.IP "loaded\-file(\s-1FILENAME\s0)" 4
.IX Item "loaded-file(FILENAME)"
Fires when Perl has successfully loaded an individual file, whether
from \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`do\*(C'\fR. This probe fires after the file
is read from disk and its contentss evaluated. The filename argument
is converted to local filesystem paths instead of providing
\&\f(CW\*(C`Module::Name\*(C'\fR\-style names.
.Sp
.Vb 3
\&    :*perl*:loaded\-file {
\&        printf("Successfully loaded %s\en", copyinstr(arg0));
\&    }
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Most frequently called functions" 4
.IX Item "Most frequently called functions"
.Vb 1
\&    # dtrace \-qZn \*(Aqsub\-entry { @[strjoin(strjoin(copyinstr(arg3),"::"),copyinstr(arg0))] = count() } END {trunc(@, 10)}\*(Aq
\&
\&    Class::MOP::Attribute::slots                                    400
\&    Try::Tiny::catch                                                411
\&    Try::Tiny::try                                                  411
\&    Class::MOP::Instance::inline_slot_access                        451
\&    Class::MOP::Class::Immutable::Trait:::around                    472
\&    Class::MOP::Mixin::AttributeCore::has_initializer               496
\&    Class::MOP::Method::Wrapped::_\|_ANON_\|_                           544
\&    Class::MOP::Package::_package_stash                             737
\&    Class::MOP::Class::initialize                                  1128
\&    Class::MOP::get_metaclass_by_name                              1204
.Ve
.IP "Trace function calls" 4
.IX Item "Trace function calls"
.Vb 1
\&    # dtrace \-qFZn \*(Aqsub\-entry, sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      import
\&    0    <\- Perl_pp_leavesub                      import
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      dress
\&    0    <\- Perl_pp_leavesub                      dress
\&    0    \-> Perl_pp_entersub                      dirty
\&    0    <\- Perl_pp_leavesub                      dirty
\&    0    \-> Perl_pp_entersub                      whiten
\&    0    <\- Perl_pp_leavesub                      whiten
\&    0  <\- Perl_dounwind                           BEGIN
.Ve
.IP "Function calls during interpreter cleanup" 4
.IX Item "Function calls during interpreter cleanup"
.Vb 1
\&    # dtrace \-Zn \*(Aqphase\-change /copyinstr(arg0) == "END"/ { self\->ending = 1 } sub\-entry /self\->ending/ { trace(copyinstr(arg0)) }\*(Aq
\&
\&    CPU     ID                    FUNCTION:NAME
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   cleanup
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
.Ve
.IP "System calls at compile time" 4
.IX Item "System calls at compile time"
.Vb 1
\&    # dtrace \-qZn \*(Aqphase\-change /copyinstr(arg0) == "START"/ { self\->interesting = 1 } phase\-change /copyinstr(arg0) == "RUN"/ { self\->interesting = 0 } syscall::: /self\->interesting/ { @[probefunc] = count() } END { trunc(@, 3) }\*(Aq
\&
\&    lseek                                                           310
\&    read                                                            374
\&    stat64                                                         1056
.Ve
.IP "Perl functions that execute the most opcodes" 4
.IX Item "Perl functions that execute the most opcodes"
.Vb 1
\&    # dtrace \-qZn \*(Aqsub\-entry { self\->fqn = strjoin(copyinstr(arg3), strjoin("::", copyinstr(arg0))) } op\-entry /self\->fqn != ""/ { @[self\->fqn] = count() } END { trunc(@, 3) }\*(Aq
\&
\&    warnings::unimport                                             4589
\&    Exporter::Heavy::_rebuild_cache                                5039
\&    Exporter::import                                              14578
.Ve
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "DTrace Dynamic Tracing Guide" 4
.IX Item "DTrace Dynamic Tracing Guide"
<http://dtrace.org/guide/preface.html>
.IP "DTrace: Dynamic Tracing in Oracle Solaris, Mac \s-1OS X\s0 and FreeBSD" 4
.IX Item "DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X and FreeBSD"
<http://www.amazon.com/DTrace\-Dynamic\-Tracing\-Solaris\-FreeBSD/dp/0132091518/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Devel::DTrace::Provider" 4
.IX Item "Devel::DTrace::Provider"
This \s-1CPAN\s0 module lets you create application-level DTrace probes written in
Perl.
.SH "AUTHORS"
.IX Header "AUTHORS"
Shawn M Moore \f(CW\*(C`sartak@gmail.com\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perldtrace5.16.1                             0100644 0001750 0001750 00000026312 12566207416 023404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDTRACE 1"
.TH PERLDTRACE 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldtrace \- Perl's support for DTrace
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # dtrace \-Zn \*(Aqperl::sub\-entry, perl::sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&    dtrace: description \*(Aqperl::sub\-entry, perl::sub\-return \*(Aq matched 10 probes
\&
\&    # perl \-E \*(Aqsub outer { inner(@_) } sub inner { say shift } outer("hello")\*(Aq
\&    hello
\&
\&    (dtrace output)
\&    CPU     ID                    FUNCTION:NAME
\&      0  75915       Perl_pp_entersub:sub\-entry   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   import
\&      0  75922      Perl_pp_leavesub:sub\-return   import
\&      0  75922      Perl_pp_leavesub:sub\-return   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   outer
\&      0  75915       Perl_pp_entersub:sub\-entry   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   outer
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DTrace is a framework for comprehensive system\- and application-level
tracing. Perl is a DTrace \fIprovider\fR, meaning it exposes several
\&\fIprobes\fR for instrumentation. You can use these in conjunction
with kernel-level probes, as well as probes from other providers
such as MySQL, in order to diagnose software defects, or even just
your application's bottlenecks.
.PP
Perl must be compiled with the \f(CW\*(C`\-Dusedtrace\*(C'\fR option in order to
make use of the provided probes. While DTrace aims to have no
overhead when its instrumentation is not active, Perl's support
itself cannot uphold that guarantee, so it is built without DTrace
probes under most systems. One notable exception is that Mac \s-1OS\s0 X
ships a \fI/usr/bin/perl\fR with DTrace support enabled.
.SH "HISTORY"
.IX Header "HISTORY"
.IP "5.10.1" 4
.IX Item "5.10.1"
Perl's initial DTrace support was added, providing \f(CW\*(C`sub\-entry\*(C'\fR and
\&\f(CW\*(C`sub\-return\*(C'\fR probes.
.IP "5.14.0" 4
.IX Item "5.14.0"
The \f(CW\*(C`sub\-entry\*(C'\fR and \f(CW\*(C`sub\-return\*(C'\fR probes gain a fourth argument: the
package name of the function.
.IP "5.16.0" 4
.IX Item "5.16.0"
The \f(CW\*(C`phase\-change\*(C'\fR probe was added.
.SH "PROBES"
.IX Header "PROBES"
.IP "sub\-entry(\s-1SUBNAME\s0, \s-1FILE\s0, \s-1LINE\s0, \s-1PACKAGE\s0)" 4
.IX Item "sub-entry(SUBNAME, FILE, LINE, PACKAGE)"
Traces the entry of any subroutine. Note that all of the variables
refer to the subroutine that is being invoked; there is currently
no way to get ahold of any information about the subroutine's
\&\fIcaller\fR from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-entry {
\&        printf("%s::%s entered at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg0);
\&    }
.Ve
.IP "sub\-return(\s-1SUBNAME\s0, \s-1FILE\s0, \s-1LINE\s0, \s-1PACKAGE\s0)" 4
.IX Item "sub-return(SUBNAME, FILE, LINE, PACKAGE)"
Traces the exit of any subroutine. Note that all of the variables
refer to the subroutine that is returning; there is currently no
way to get ahold of any information about the subroutine's \fIcaller\fR
from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-return {
\&        printf("%s::%s returned at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg0);
\&    }
.Ve
.IP "phase\-change(\s-1NEWPHASE\s0, \s-1OLDPHASE\s0)" 4
.IX Item "phase-change(NEWPHASE, OLDPHASE)"
Traces changes to Perl's interpreter state. You can internalize this
as tracing changes to Perl's \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR variable, especially
since the values for \f(CW\*(C`NEWPHASE\*(C'\fR and \f(CW\*(C`OLDPHASE\*(C'\fR are the strings that
\&\f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR reports.
.Sp
.Vb 4
\&    :*perl*::phase\-change {
\&        printf("Phase changed from %s to %s\en",
\&            copyinstr(arg1), copyinstr(arg0));
\&    }
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Most frequently called functions" 4
.IX Item "Most frequently called functions"
.Vb 1
\&    # dtrace \-qZn \*(Aqsub\-entry { @[strjoin(strjoin(copyinstr(arg3),"::"),copyinstr(arg0))] = count() } END {trunc(@, 10)}\*(Aq
\&
\&    Class::MOP::Attribute::slots                                    400
\&    Try::Tiny::catch                                                411
\&    Try::Tiny::try                                                  411
\&    Class::MOP::Instance::inline_slot_access                        451
\&    Class::MOP::Class::Immutable::Trait:::around                    472
\&    Class::MOP::Mixin::AttributeCore::has_initializer               496
\&    Class::MOP::Method::Wrapped::_\|_ANON_\|_                           544
\&    Class::MOP::Package::_package_stash                             737
\&    Class::MOP::Class::initialize                                  1128
\&    Class::MOP::get_metaclass_by_name                              1204
.Ve
.IP "Trace function calls" 4
.IX Item "Trace function calls"
.Vb 1
\&    # dtrace \-qFZn \*(Aqsub\-entry, sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      import
\&    0    <\- Perl_pp_leavesub                      import
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      dress
\&    0    <\- Perl_pp_leavesub                      dress
\&    0    \-> Perl_pp_entersub                      dirty
\&    0    <\- Perl_pp_leavesub                      dirty
\&    0    \-> Perl_pp_entersub                      whiten
\&    0    <\- Perl_pp_leavesub                      whiten
\&    0  <\- Perl_dounwind                           BEGIN
.Ve
.IP "Function calls during interpreter cleanup" 4
.IX Item "Function calls during interpreter cleanup"
.Vb 1
\&    # dtrace \-Zn \*(Aqphase\-change /copyinstr(arg0) == "END"/ { self\->ending = 1 } sub\-entry /self\->ending/ { trace(copyinstr(arg0)) }\*(Aq
\&
\&    CPU     ID                    FUNCTION:NAME
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   cleanup
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
.Ve
.IP "System calls at compile time" 4
.IX Item "System calls at compile time"
.Vb 1
\&    # dtrace \-qZn \*(Aqphase\-change /copyinstr(arg0) == "START"/ { self\->interesting = 1 } phase\-change /copyinstr(arg0) == "RUN"/ { self\->interesting = 0 } syscall::: /self\->interesting/ { @[probefunc] = count() } END { trunc(@, 3) }\*(Aq
\&
\&    lseek                                                           310
\&    read                                                            374
\&    stat64                                                         1056
.Ve
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "DTrace User Guide" 4
.IX Item "DTrace User Guide"
http://download.oracle.com/docs/cd/E19082\-01/819\-3620/index.html <http://download.oracle.com/docs/cd/E19082-01/819-3620/index.html>
.IP "DTrace: Dynamic Tracing in Oracle Solaris, Mac \s-1OS\s0 X and FreeBSD" 4
.IX Item "DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X and FreeBSD"
http://www.amazon.com/DTrace\-Dynamic\-Tracing\-Solaris\-FreeBSD/dp/0132091518/ <http://www.amazon.com/DTrace-Dynamic-Tracing-Solaris-FreeBSD/dp/0132091518/>
.SH "AUTHORS"
.IX Header "AUTHORS"
Shawn M Moore \f(CW\*(C`sartak@gmail.com\*(C'\fR
                                                                                                                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perldtrace5.18.1                             0100644 0001750 0001750 00000033013 12566207436 023404  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLDTRACE 1"
.TH PERLDTRACE 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perldtrace \- Perl's support for DTrace
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\&    # dtrace \-Zn \*(Aqperl::sub\-entry, perl::sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&    dtrace: description \*(Aqperl::sub\-entry, perl::sub\-return \*(Aq matched 10 probes
\&
\&    # perl \-E \*(Aqsub outer { inner(@_) } sub inner { say shift } outer("hello")\*(Aq
\&    hello
\&
\&    (dtrace output)
\&    CPU     ID                    FUNCTION:NAME
\&      0  75915       Perl_pp_entersub:sub\-entry   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   import
\&      0  75922      Perl_pp_leavesub:sub\-return   import
\&      0  75922      Perl_pp_leavesub:sub\-return   BEGIN
\&      0  75915       Perl_pp_entersub:sub\-entry   outer
\&      0  75915       Perl_pp_entersub:sub\-entry   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   inner
\&      0  75922      Perl_pp_leavesub:sub\-return   outer
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
DTrace is a framework for comprehensive system\- and application-level
tracing. Perl is a DTrace \fIprovider\fR, meaning it exposes several
\&\fIprobes\fR for instrumentation. You can use these in conjunction
with kernel-level probes, as well as probes from other providers
such as MySQL, in order to diagnose software defects, or even just
your application's bottlenecks.
.PP
Perl must be compiled with the \f(CW\*(C`\-Dusedtrace\*(C'\fR option in order to
make use of the provided probes. While DTrace aims to have no
overhead when its instrumentation is not active, Perl's support
itself cannot uphold that guarantee, so it is built without DTrace
probes under most systems. One notable exception is that Mac \s-1OS X\s0
ships a \fI/usr/bin/perl\fR with DTrace support enabled.
.SH "HISTORY"
.IX Header "HISTORY"
.IP "5.10.1" 4
.IX Item "5.10.1"
Perl's initial DTrace support was added, providing \f(CW\*(C`sub\-entry\*(C'\fR and
\&\f(CW\*(C`sub\-return\*(C'\fR probes.
.IP "5.14.0" 4
.IX Item "5.14.0"
The \f(CW\*(C`sub\-entry\*(C'\fR and \f(CW\*(C`sub\-return\*(C'\fR probes gain a fourth argument: the
package name of the function.
.IP "5.16.0" 4
.IX Item "5.16.0"
The \f(CW\*(C`phase\-change\*(C'\fR probe was added.
.IP "5.18.0" 4
.IX Item "5.18.0"
The \f(CW\*(C`op\-entry\*(C'\fR, \f(CW\*(C`loading\-file\*(C'\fR, and \f(CW\*(C`loaded\-file\*(C'\fR probes were added.
.SH "PROBES"
.IX Header "PROBES"
.IP "sub\-entry(\s-1SUBNAME, FILE, LINE, PACKAGE\s0)" 4
.IX Item "sub-entry(SUBNAME, FILE, LINE, PACKAGE)"
Traces the entry of any subroutine. Note that all of the variables
refer to the subroutine that is being invoked; there is currently
no way to get ahold of any information about the subroutine's
\&\fIcaller\fR from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-entry {
\&        printf("%s::%s entered at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);
\&    }
.Ve
.IP "sub\-return(\s-1SUBNAME, FILE, LINE, PACKAGE\s0)" 4
.IX Item "sub-return(SUBNAME, FILE, LINE, PACKAGE)"
Traces the exit of any subroutine. Note that all of the variables
refer to the subroutine that is returning; there is currently no
way to get ahold of any information about the subroutine's \fIcaller\fR
from a DTrace action.
.Sp
.Vb 4
\&    :*perl*::sub\-return {
\&        printf("%s::%s returned at %s line %d\en",
\&               copyinstr(arg3), copyinstr(arg0), copyinstr(arg1), arg2);
\&    }
.Ve
.IP "phase\-change(\s-1NEWPHASE, OLDPHASE\s0)" 4
.IX Item "phase-change(NEWPHASE, OLDPHASE)"
Traces changes to Perl's interpreter state. You can internalize this
as tracing changes to Perl's \f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR variable, especially
since the values for \f(CW\*(C`NEWPHASE\*(C'\fR and \f(CW\*(C`OLDPHASE\*(C'\fR are the strings that
\&\f(CW\*(C`${^GLOBAL_PHASE}\*(C'\fR reports.
.Sp
.Vb 4
\&    :*perl*::phase\-change {
\&        printf("Phase changed from %s to %s\en",
\&            copyinstr(arg1), copyinstr(arg0));
\&    }
.Ve
.IP "op\-entry(\s-1OPNAME\s0)" 4
.IX Item "op-entry(OPNAME)"
Traces the execution of each opcode in the Perl runloop. This probe
is fired before the opcode is executed. When the Perl debugger is
enabled, the DTrace probe is fired \fIafter\fR the debugger hooks (but
still before the opcode itself is executed).
.Sp
.Vb 3
\&    :*perl*::op\-entry {
\&        printf("About to execute opcode %s\en", copyinstr(arg0));
\&    }
.Ve
.IP "loading\-file(\s-1FILENAME\s0)" 4
.IX Item "loading-file(FILENAME)"
Fires when Perl is about to load an individual file, whether from
\&\f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`do\*(C'\fR. This probe fires before the file is
read from disk. The filename argument is converted to local filesystem
paths instead of providing \f(CW\*(C`Module::Name\*(C'\fR\-style names.
.Sp
.Vb 3
\&    :*perl*:loading\-file {
\&        printf("About to load %s\en", copyinstr(arg0));
\&    }
.Ve
.IP "loaded\-file(\s-1FILENAME\s0)" 4
.IX Item "loaded-file(FILENAME)"
Fires when Perl has successfully loaded an individual file, whether
from \f(CW\*(C`use\*(C'\fR, \f(CW\*(C`require\*(C'\fR, or \f(CW\*(C`do\*(C'\fR. This probe fires after the file
is read from disk and its contentss evaluated. The filename argument
is converted to local filesystem paths instead of providing
\&\f(CW\*(C`Module::Name\*(C'\fR\-style names.
.Sp
.Vb 3
\&    :*perl*:loaded\-file {
\&        printf("Successfully loaded %s\en", copyinstr(arg0));
\&    }
.Ve
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.IP "Most frequently called functions" 4
.IX Item "Most frequently called functions"
.Vb 1
\&    # dtrace \-qZn \*(Aqsub\-entry { @[strjoin(strjoin(copyinstr(arg3),"::"),copyinstr(arg0))] = count() } END {trunc(@, 10)}\*(Aq
\&
\&    Class::MOP::Attribute::slots                                    400
\&    Try::Tiny::catch                                                411
\&    Try::Tiny::try                                                  411
\&    Class::MOP::Instance::inline_slot_access                        451
\&    Class::MOP::Class::Immutable::Trait:::around                    472
\&    Class::MOP::Mixin::AttributeCore::has_initializer               496
\&    Class::MOP::Method::Wrapped::_\|_ANON_\|_                           544
\&    Class::MOP::Package::_package_stash                             737
\&    Class::MOP::Class::initialize                                  1128
\&    Class::MOP::get_metaclass_by_name                              1204
.Ve
.IP "Trace function calls" 4
.IX Item "Trace function calls"
.Vb 1
\&    # dtrace \-qFZn \*(Aqsub\-entry, sub\-return { trace(copyinstr(arg0)) }\*(Aq
\&
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      import
\&    0    <\- Perl_pp_leavesub                      import
\&    0  <\- Perl_pp_leavesub                        BEGIN
\&    0  \-> Perl_pp_entersub                        BEGIN
\&    0    \-> Perl_pp_entersub                      dress
\&    0    <\- Perl_pp_leavesub                      dress
\&    0    \-> Perl_pp_entersub                      dirty
\&    0    <\- Perl_pp_leavesub                      dirty
\&    0    \-> Perl_pp_entersub                      whiten
\&    0    <\- Perl_pp_leavesub                      whiten
\&    0  <\- Perl_dounwind                           BEGIN
.Ve
.IP "Function calls during interpreter cleanup" 4
.IX Item "Function calls during interpreter cleanup"
.Vb 1
\&    # dtrace \-Zn \*(Aqphase\-change /copyinstr(arg0) == "END"/ { self\->ending = 1 } sub\-entry /self\->ending/ { trace(copyinstr(arg0)) }\*(Aq
\&
\&    CPU     ID                    FUNCTION:NAME
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   END
\&      1  77214       Perl_pp_entersub:sub\-entry   cleanup
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
\&      1  77214       Perl_pp_entersub:sub\-entry   _force_writable
.Ve
.IP "System calls at compile time" 4
.IX Item "System calls at compile time"
.Vb 1
\&    # dtrace \-qZn \*(Aqphase\-change /copyinstr(arg0) == "START"/ { self\->interesting = 1 } phase\-change /copyinstr(arg0) == "RUN"/ { self\->interesting = 0 } syscall::: /self\->interesting/ { @[probefunc] = count() } END { trunc(@, 3) }\*(Aq
\&
\&    lseek                                                           310
\&    read                                                            374
\&    stat64                                                         1056
.Ve
.IP "Perl functions that execute the most opcodes" 4
.IX Item "Perl functions that execute the most opcodes"
.Vb 1
\&    # dtrace \-qZn \*(Aqsub\-entry { self\->fqn = strjoin(copyinstr(arg3), strjoin("::", copyinstr(arg0))) } op\-entry /self\->fqn != ""/ { @[self\->fqn] = count() } END { trunc(@, 3) }\*(Aq
\&
\&    warnings::unimport                                             4589
\&    Exporter::Heavy::_rebuild_cache                                5039
\&    Exporter::import                                              14578
.Ve
.SH "REFERENCES"
.IX Header "REFERENCES"
.IP "DTrace Dynamic Tracing Guide" 4
.IX Item "DTrace Dynamic Tracing Guide"
<http://dtrace.org/guide/preface.html>
.IP "DTrace: Dynamic Tracing in Oracle Solaris, Mac \s-1OS X\s0 and FreeBSD" 4
.IX Item "DTrace: Dynamic Tracing in Oracle Solaris, Mac OS X and FreeBSD"
<http://www.amazon.com/DTrace\-Dynamic\-Tracing\-Solaris\-FreeBSD/dp/0132091518/>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.IP "Devel::DTrace::Provider" 4
.IX Item "Devel::DTrace::Provider"
This \s-1CPAN\s0 module lets you create application-level DTrace probes written in
Perl.
.SH "AUTHORS"
.IX Header "AUTHORS"
Shawn M Moore \f(CW\*(C`sartak@gmail.com\*(C'\fR
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlebcdic.1                                 0100644 0001750 0001750 00000220313 12566207436 023040  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEBCDIC 1"
.TH PERLEBCDIC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlebcdic \- Considerations for running Perl on EBCDIC platforms
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An exploration of some of the issues facing Perl programmers
on \s-1EBCDIC\s0 based computers.  We do not cover localization,
internationalization, or multi-byte character set issues other
than some discussion of \s-1UTF\-8\s0 and UTF-EBCDIC.
.PP
Portions that are still incomplete are marked with \s-1XXX.\s0
.PP
Perl used to work on \s-1EBCDIC\s0 machines, but there are now areas of the code where
it doesn't.  If you want to use Perl on an \s-1EBCDIC\s0 machine, please let us know
by sending mail to perlbug@perl.org
.SH "COMMON CHARACTER CODE SETS"
.IX Header "COMMON CHARACTER CODE SETS"
.SS "\s-1ASCII\s0"
.IX Subsection "ASCII"
The American Standard Code for Information Interchange (\s-1ASCII\s0 or US-ASCII) is a
set of
integers running from 0 to 127 (decimal) that imply character
interpretation by the display and other systems of computers.
The range 0..127 can be covered by setting the bits in a 7\-bit binary
digit, hence the set is sometimes referred to as \*(L"7\-bit \s-1ASCII\*(R".
ASCII\s0 was described by the American National Standards Institute
document \s-1ANSI X3.4\-1986. \s0 It was also described by \s-1ISO 646:1991
\&\s0(with localization for currency symbols).  The full \s-1ASCII\s0 set is
given in the table below as the first 128 elements.  Languages that
can be written adequately with the characters in \s-1ASCII\s0 include
English, Hawaiian, Indonesian, Swahili and some Native American
languages.
.PP
There are many character sets that extend the range of integers
from 0..2**7\-1 up to 2**8\-1, or 8 bit bytes (octets if you prefer).
One common one is the \s-1ISO 8859\-1\s0 character set.
.SS "\s-1ISO 8859\s0"
.IX Subsection "ISO 8859"
The \s-1ISO\s0 8859\-$n are a collection of character code sets from the
International Organization for Standardization (\s-1ISO\s0), each of which
adds characters to the \s-1ASCII\s0 set that are typically found in European
languages, many of which are based on the Roman, or Latin, alphabet.
.SS "Latin 1 (\s-1ISO 8859\-1\s0)"
.IX Subsection "Latin 1 (ISO 8859-1)"
A particular 8\-bit extension to \s-1ASCII\s0 that includes grave and acute
accented Latin characters.  Languages that can employ \s-1ISO 8859\-1\s0
include all the languages covered by \s-1ASCII\s0 as well as Afrikaans,
Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian,
Portuguese, Spanish, and Swedish.  Dutch is covered albeit without
the ij ligature.  French is covered too but without the oe ligature.
German can use \s-1ISO 8859\-1\s0 but must do so without German-style
quotation marks.  This set is based on Western European extensions
to \s-1ASCII\s0 and is commonly encountered in world wide web work.
In \s-1IBM\s0 character code set identification terminology \s-1ISO 8859\-1\s0 is
also known as \s-1CCSID 819 \s0(or sometimes 0819 or even 00819).
.SS "\s-1EBCDIC\s0"
.IX Subsection "EBCDIC"
The Extended Binary Coded Decimal Interchange Code refers to a
large collection of single\- and multi-byte coded character sets that are
different from \s-1ASCII\s0 or \s-1ISO 8859\-1\s0 and are all slightly different from each
other; they typically run on host computers.  The \s-1EBCDIC\s0 encodings derive from
8\-bit byte extensions of Hollerith punched card encodings.  The layout on the
cards was such that high bits were set for the upper and lower case alphabet
characters [a\-z] and [A\-Z], but there were gaps within each Latin alphabet
range.
.PP
Some \s-1IBM EBCDIC\s0 character sets may be known by character code set
identification numbers (\s-1CCSID\s0 numbers) or code page numbers.
.PP
Perl can be compiled on platforms that run any of three commonly used \s-1EBCDIC\s0
character sets, listed below.
.PP
\fIThe 13 variant characters\fR
.IX Subsection "The 13 variant characters"
.PP
Among \s-1IBM EBCDIC\s0 character code sets there are 13 characters that
are often mapped to different integer values.  Those characters
are known as the 13 \*(L"variant\*(R" characters and are:
.PP
.Vb 1
\&    \e [ ] { } ^ ~ ! # | $ @ \`
.Ve
.PP
When Perl is compiled for a platform, it looks at some of these characters to
guess which \s-1EBCDIC\s0 character set the platform uses, and adapts itself
accordingly to that platform.  If the platform uses a character set that is not
one of the three Perl knows about, Perl will either fail to compile, or
mistakenly and silently choose one of the three.
They are:
.IP "\fB0037\fR" 4
.IX Item "0037"
Character code set \s-1ID 0037\s0 is a mapping of the \s-1ASCII\s0 plus Latin\-1
characters (i.e. \s-1ISO 8859\-1\s0) to an \s-1EBCDIC\s0 set.  0037 is used
in North American English locales on the \s-1OS/400\s0 operating system
that runs on \s-1AS/400\s0 computers.  \s-1CCSID 0037\s0 differs from \s-1ISO 8859\-1\s0
in 237 places, in other words they agree on only 19 code point values.
.IP "\fB1047\fR" 4
.IX Item "1047"
Character code set \s-1ID 1047\s0 is also a mapping of the \s-1ASCII\s0 plus
Latin\-1 characters (i.e. \s-1ISO 8859\-1\s0) to an \s-1EBCDIC\s0 set.  1047 is
used under Unix System Services for \s-1OS/390\s0 or z/OS, and OpenEdition
for \s-1VM/ESA.  CCSID 1047\s0 differs from \s-1CCSID 0037\s0 in eight places.
.IP "\fBPOSIX-BC\fR" 4
.IX Item "POSIX-BC"
The \s-1EBCDIC\s0 code page in use on Siemens' \s-1BS2000\s0 system is distinct from
1047 and 0037.  It is identified below as the POSIX-BC set.
.SS "Unicode code points versus \s-1EBCDIC\s0 code points"
.IX Subsection "Unicode code points versus EBCDIC code points"
In Unicode terminology a \fIcode point\fR is the number assigned to a
character: for example, in \s-1EBCDIC\s0 the character \*(L"A\*(R" is usually assigned
the number 193.  In Unicode the character \*(L"A\*(R" is assigned the number 65.
This causes a problem with the semantics of the pack/unpack \*(L"U\*(R", which
are supposed to pack Unicode code points to characters and back to numbers.
The problem is: which code points to use for code points less than 256?
(for 256 and over there's no problem: Unicode code points are used)
In \s-1EBCDIC,\s0 for the low 256 the \s-1EBCDIC\s0 code points are used.  This
means that the equivalences
.PP
.Vb 2
\&    pack("U", ord($character)) eq $character
\&    unpack("U", $character) == ord $character
.Ve
.PP
will hold.  (If Unicode code points were applied consistently over
all the possible code points, pack(\*(L"U\*(R",ord(\*(L"A\*(R")) would in \s-1EBCDIC\s0
equal \fIA with acute\fR or chr(101), and unpack(\*(L"U\*(R", \*(L"A\*(R") would equal
65, or \fInon-breaking space\fR, not 193, or ord \*(L"A\*(R".)
.SS "Remaining Perl Unicode problems in \s-1EBCDIC\s0"
.IX Subsection "Remaining Perl Unicode problems in EBCDIC"
.IP "\(bu" 4
Many of the remaining problems seem to be related to case-insensitive matching
.IP "\(bu" 4
The extensions Unicode::Collate and Unicode::Normalized are not
supported under \s-1EBCDIC,\s0 likewise for the encoding pragma.
.SS "Unicode and \s-1UTF\s0"
.IX Subsection "Unicode and UTF"
\&\s-1UTF\s0 stands for \f(CW\*(C`Unicode Transformation Format\*(C'\fR.
\&\s-1UTF\-8\s0 is an encoding of Unicode into a sequence of 8\-bit byte chunks, based on
\&\s-1ASCII\s0 and Latin\-1.
The length of a sequence required to represent a Unicode code point
depends on the ordinal number of that code point,
with larger numbers requiring more bytes.
UTF-EBCDIC is like \s-1UTF\-8,\s0 but based on \s-1EBCDIC.\s0
.PP
You may see the term \f(CW\*(C`invariant\*(C'\fR character or code point.
This simply means that the character has the same numeric
value when encoded as when not.
(Note that this is a very different concept from \*(L"The 13 variant characters\*(R"
mentioned above.)
For example, the ordinal value of 'A' is 193 in most \s-1EBCDIC\s0 code pages,
and also is 193 when encoded in UTF-EBCDIC.
All variant code points occupy at least two bytes when encoded.
In \s-1UTF\-8,\s0 the code points corresponding to the lowest 128
ordinal numbers (0 \- 127: the \s-1ASCII\s0 characters) are invariant.
In UTF-EBCDIC, there are 160 invariant characters.
(If you care, the \s-1EBCDIC\s0 invariants are those characters
which have \s-1ASCII\s0 equivalents, plus those that correspond to
the C1 controls (80..9f on \s-1ASCII\s0 platforms).)
.PP
A string encoded in UTF-EBCDIC may be longer (but never shorter) than
one encoded in \s-1UTF\-8.\s0
.SS "Using Encode"
.IX Subsection "Using Encode"
Starting from Perl 5.8 you can use the standard new module Encode
to translate from \s-1EBCDIC\s0 to Latin\-1 code points.
Encode knows about more \s-1EBCDIC\s0 character sets than Perl can currently
be compiled to run on.
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is in EBCDIC code points
\&   from_to($a, $ebcdic{ord \*(Aq^\*(Aq}, \*(Aqlatin1\*(Aq);
\&   # $a is ISO 8859\-1 code points
.Ve
.PP
and from Latin\-1 code points to \s-1EBCDIC\s0 code points
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is ISO 8859\-1 code points
\&   from_to($a, \*(Aqlatin1\*(Aq, $ebcdic{ord \*(Aq^\*(Aq});
\&   # $a is in EBCDIC code points
.Ve
.PP
For doing I/O it is suggested that you use the autotranslating features
of PerlIO, see perluniintro.
.PP
Since version 5.8 Perl uses the new PerlIO I/O library.  This enables
you to use different encodings per \s-1IO\s0 channel.  For example you may use
.PP
.Vb 9
\&    use Encode;
\&    open($f, ">:encoding(ascii)", "test.ascii");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(cp37)", "test.ebcdic");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(latin1)", "test.latin1");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(utf8)", "test.utf8");
\&    print $f "Hello World!\en";
.Ve
.PP
to get four files containing \*(L"Hello World!\en\*(R" in \s-1ASCII, CP 0037 EBCDIC,
ISO 8859\-1 \s0(Latin\-1) (in this example identical to \s-1ASCII\s0 since only \s-1ASCII\s0
characters were printed), and
UTF-EBCDIC (in this example identical to normal \s-1EBCDIC\s0 since only characters
that don't differ between \s-1EBCDIC\s0 and UTF-EBCDIC were printed).  See the
documentation of Encode::PerlIO for details.
.PP
As the PerlIO layer uses raw \s-1IO \s0(bytes) internally, all this totally
ignores things like the type of your filesystem (\s-1ASCII\s0 or \s-1EBCDIC\s0).
.SH "SINGLE OCTET TABLES"
.IX Header "SINGLE OCTET TABLES"
The following tables list the \s-1ASCII\s0 and Latin 1 ordered sets including
the subsets: C0 controls (0..31), \s-1ASCII\s0 graphics (32..7e), delete (7f),
C1 controls (80..9f), and Latin\-1 (a.k.a. \s-1ISO 8859\-1\s0) (a0..ff).  In the
table names of the Latin 1
extensions to \s-1ASCII\s0 have been labelled with character names roughly
corresponding to \fIThe Unicode Standard, Version 6.1\fR albeit with
substitutions such as s/LATIN// and s/VULGAR// in all cases, s/CAPITAL
\&\s-1LETTER//\s0 in some cases, and s/SMALL \s-1LETTER \s0([A\-Z])/\el$1/ in some other
cases.  Controls are listed using their Unicode 6.1 abbreviatons.
The differences between the 0037 and 1047 sets are
flagged with **.  The differences between the 1047 and POSIX-BC sets
are flagged with ##.  All \fIord()\fR numbers listed are decimal.  If you
would rather see this table listing octal values, then run the table
(that is, the pod source text of this document, since this recipe may not
work with a pod2_other_format translation) through:
.IP "recipe 0" 4
.IX Item "recipe 0"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-5.03o%\-5.03o%\-5.03o%.03o\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
If you want to retain the UTF-x code points then in script form you
might want to write:
.IP "recipe 1" 4
.IX Item "recipe 1"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-3o.%\-5o%\-3o.%.03o\en",
\&                                            $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-3o.%\-5o%.03o\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-5.03o%.03o\en",
\&                                                $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
.Ve
.PP
If you would rather see this table listing hexadecimal values then
run the table through:
.IP "recipe 2" 4
.IX Item "recipe 2"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-5.02X%\-5.02X%\-5.02X%.02X\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
Or, in order to retain the UTF-x code points in hexadecimal:
.IP "recipe 3" 4
.IX Item "recipe 3"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-2X.%\-6.02X%02X.%02X\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-2X.%\-6.02X%02X\en",
\&                                              $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-5.02X%02X\en",
\&                                                  $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
\&
\&
\&                          ISO
\&                         8859\-1             POS\-
\&                         CCSID  CCSID CCSID IX\-
\&  chr                     0819   0037 1047  BC  UTF\-8  UTF\-EBCDIC
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& <NUL>                       0    0    0    0    0        0
\& <SOH>                       1    1    1    1    1        1
\& <STX>                       2    2    2    2    2        2
\& <ETX>                       3    3    3    3    3        3
\& <EOT>                       4    55   55   55   4        55
\& <ENQ>                       5    45   45   45   5        45
\& <ACK>                       6    46   46   46   6        46
\& <BEL>                       7    47   47   47   7        47
\& <BS>                        8    22   22   22   8        22
\& <HT>                        9    5    5    5    9        5
\& <LF>                        10   37   21   21   10       21  **
\& <VT>                        11   11   11   11   11       11
\& <FF>                        12   12   12   12   12       12
\& <CR>                        13   13   13   13   13       13
\& <SO>                        14   14   14   14   14       14
\& <SI>                        15   15   15   15   15       15
\& <DLE>                       16   16   16   16   16       16
\& <DC1>                       17   17   17   17   17       17
\& <DC2>                       18   18   18   18   18       18
\& <DC3>                       19   19   19   19   19       19
\& <DC4>                       20   60   60   60   20       60
\& <NAK>                       21   61   61   61   21       61
\& <SYN>                       22   50   50   50   22       50
\& <ETB>                       23   38   38   38   23       38
\& <CAN>                       24   24   24   24   24       24
\& <EOM>                       25   25   25   25   25       25
\& <SUB>                       26   63   63   63   26       63
\& <ESC>                       27   39   39   39   27       39
\& <FS>                        28   28   28   28   28       28
\& <GS>                        29   29   29   29   29       29
\& <RS>                        30   30   30   30   30       30
\& <US>                        31   31   31   31   31       31
\& <SPACE>                     32   64   64   64   32       64
\& !                           33   90   90   90   33       90
\& "                           34   127  127  127  34       127
\& #                           35   123  123  123  35       123
\& $                           36   91   91   91   36       91
\& %                           37   108  108  108  37       108
\& &                           38   80   80   80   38       80
\& \*(Aq                           39   125  125  125  39       125
\& (                           40   77   77   77   40       77
\& )                           41   93   93   93   41       93
\& *                           42   92   92   92   42       92
\& +                           43   78   78   78   43       78
\& ,                           44   107  107  107  44       107
\& \-                           45   96   96   96   45       96
\& .                           46   75   75   75   46       75
\& /                           47   97   97   97   47       97
\& 0                           48   240  240  240  48       240
\& 1                           49   241  241  241  49       241
\& 2                           50   242  242  242  50       242
\& 3                           51   243  243  243  51       243
\& 4                           52   244  244  244  52       244
\& 5                           53   245  245  245  53       245
\& 6                           54   246  246  246  54       246
\& 7                           55   247  247  247  55       247
\& 8                           56   248  248  248  56       248
\& 9                           57   249  249  249  57       249
\& :                           58   122  122  122  58       122
\& ;                           59   94   94   94   59       94
\& <                           60   76   76   76   60       76
\& =                           61   126  126  126  61       126
\& >                           62   110  110  110  62       110
\& ?                           63   111  111  111  63       111
\& @                           64   124  124  124  64       124
\& A                           65   193  193  193  65       193
\& B                           66   194  194  194  66       194
\& C                           67   195  195  195  67       195
\& D                           68   196  196  196  68       196
\& E                           69   197  197  197  69       197
\& F                           70   198  198  198  70       198
\& G                           71   199  199  199  71       199
\& H                           72   200  200  200  72       200
\& I                           73   201  201  201  73       201
\& J                           74   209  209  209  74       209
\& K                           75   210  210  210  75       210
\& L                           76   211  211  211  76       211
\& M                           77   212  212  212  77       212
\& N                           78   213  213  213  78       213
\& O                           79   214  214  214  79       214
\& P                           80   215  215  215  80       215
\& Q                           81   216  216  216  81       216
\& R                           82   217  217  217  82       217
\& S                           83   226  226  226  83       226
\& T                           84   227  227  227  84       227
\& U                           85   228  228  228  85       228
\& V                           86   229  229  229  86       229
\& W                           87   230  230  230  87       230
\& X                           88   231  231  231  88       231
\& Y                           89   232  232  232  89       232
\& Z                           90   233  233  233  90       233
\& [                           91   186  173  187  91       173  ** ##
\& \e                           92   224  224  188  92       224  ##
\& ]                           93   187  189  189  93       189  **
\& ^                           94   176  95   106  94       95   ** ##
\& _                           95   109  109  109  95       109
\& \`                           96   121  121  74   96       121  ##
\& a                           97   129  129  129  97       129
\& b                           98   130  130  130  98       130
\& c                           99   131  131  131  99       131
\& d                           100  132  132  132  100      132
\& e                           101  133  133  133  101      133
\& f                           102  134  134  134  102      134
\& g                           103  135  135  135  103      135
\& h                           104  136  136  136  104      136
\& i                           105  137  137  137  105      137
\& j                           106  145  145  145  106      145
\& k                           107  146  146  146  107      146
\& l                           108  147  147  147  108      147
\& m                           109  148  148  148  109      148
\& n                           110  149  149  149  110      149
\& o                           111  150  150  150  111      150
\& p                           112  151  151  151  112      151
\& q                           113  152  152  152  113      152
\& r                           114  153  153  153  114      153
\& s                           115  162  162  162  115      162
\& t                           116  163  163  163  116      163
\& u                           117  164  164  164  117      164
\& v                           118  165  165  165  118      165
\& w                           119  166  166  166  119      166
\& x                           120  167  167  167  120      167
\& y                           121  168  168  168  121      168
\& z                           122  169  169  169  122      169
\& {                           123  192  192  251  123      192  ##
\& |                           124  79   79   79   124      79
\& }                           125  208  208  253  125      208  ##
\& ~                           126  161  161  255  126      161  ##
\& <DEL>                       127  7    7    7    127      7
\& <PAD>                       128  32   32   32   194.128  32
\& <HOP>                       129  33   33   33   194.129  33
\& <BPH>                       130  34   34   34   194.130  34
\& <NBH>                       131  35   35   35   194.131  35
\& <IND>                       132  36   36   36   194.132  36
\& <NEL>                       133  21   37   37   194.133  37   **
\& <SSA>                       134  6    6    6    194.134  6
\& <ESA>                       135  23   23   23   194.135  23
\& <HTS>                       136  40   40   40   194.136  40
\& <HTJ>                       137  41   41   41   194.137  41
\& <VTS>                       138  42   42   42   194.138  42
\& <PLD>                       139  43   43   43   194.139  43
\& <PLU>                       140  44   44   44   194.140  44
\& <RI>                        141  9    9    9    194.141  9
\& <SS2>                       142  10   10   10   194.142  10
\& <SS3>                       143  27   27   27   194.143  27
\& <DCS>                       144  48   48   48   194.144  48
\& <PU1>                       145  49   49   49   194.145  49
\& <PU2>                       146  26   26   26   194.146  26
\& <STS>                       147  51   51   51   194.147  51
\& <CCH>                       148  52   52   52   194.148  52
\& <MW>                        149  53   53   53   194.149  53
\& <SPA>                       150  54   54   54   194.150  54
\& <EPA>                       151  8    8    8    194.151  8
\& <SOS>                       152  56   56   56   194.152  56
\& <SGC>                       153  57   57   57   194.153  57
\& <SCI>                       154  58   58   58   194.154  58
\& <CSI>                       155  59   59   59   194.155  59
\& <ST>                        156  4    4    4    194.156  4
\& <OSC>                       157  20   20   20   194.157  20
\& <PM>                        158  62   62   62   194.158  62
\& <APC>                       159  255  255  95   194.159  255      ##
\& <NON\-BREAKING SPACE>        160  65   65   65   194.160  128.65
\& <INVERTED "!" >             161  170  170  170  194.161  128.66
\& <CENT SIGN>                 162  74   74   176  194.162  128.67   ##
\& <POUND SIGN>                163  177  177  177  194.163  128.68
\& <CURRENCY SIGN>             164  159  159  159  194.164  128.69
\& <YEN SIGN>                  165  178  178  178  194.165  128.70
\& <BROKEN BAR>                166  106  106  208  194.166  128.71   ##
\& <SECTION SIGN>              167  181  181  181  194.167  128.72
\& <DIAERESIS>                 168  189  187  121  194.168  128.73   ** ##
\& <COPYRIGHT SIGN>            169  180  180  180  194.169  128.74
\& <FEMININE ORDINAL>          170  154  154  154  194.170  128.81
\& <LEFT POINTING GUILLEMET>   171  138  138  138  194.171  128.82
\& <NOT SIGN>                  172  95   176  186  194.172  128.83   ** ##
\& <SOFT HYPHEN>               173  202  202  202  194.173  128.84
\& <REGISTERED TRADE MARK>     174  175  175  175  194.174  128.85
\& <MACRON>                    175  188  188  161  194.175  128.86   ##
\& <DEGREE SIGN>               176  144  144  144  194.176  128.87
\& <PLUS\-OR\-MINUS SIGN>        177  143  143  143  194.177  128.88
\& <SUPERSCRIPT TWO>           178  234  234  234  194.178  128.89
\& <SUPERSCRIPT THREE>         179  250  250  250  194.179  128.98
\& <ACUTE ACCENT>              180  190  190  190  194.180  128.99
\& <MICRO SIGN>                181  160  160  160  194.181  128.100
\& <PARAGRAPH SIGN>            182  182  182  182  194.182  128.101
\& <MIDDLE DOT>                183  179  179  179  194.183  128.102
\& <CEDILLA>                   184  157  157  157  194.184  128.103
\& <SUPERSCRIPT ONE>           185  218  218  218  194.185  128.104
\& <MASC. ORDINAL INDICATOR>   186  155  155  155  194.186  128.105
\& <RIGHT POINTING GUILLEMET>  187  139  139  139  194.187  128.106
\& <FRACTION ONE QUARTER>      188  183  183  183  194.188  128.112
\& <FRACTION ONE HALF>         189  184  184  184  194.189  128.113
\& <FRACTION THREE QUARTERS>   190  185  185  185  194.190  128.114
\& <INVERTED QUESTION MARK>    191  171  171  171  194.191  128.115
\& <A WITH GRAVE>              192  100  100  100  195.128  138.65
\& <A WITH ACUTE>              193  101  101  101  195.129  138.66
\& <A WITH CIRCUMFLEX>         194  98   98   98   195.130  138.67
\& <A WITH TILDE>              195  102  102  102  195.131  138.68
\& <A WITH DIAERESIS>          196  99   99   99   195.132  138.69
\& <A WITH RING ABOVE>         197  103  103  103  195.133  138.70
\& <CAPITAL LIGATURE AE>       198  158  158  158  195.134  138.71
\& <C WITH CEDILLA>            199  104  104  104  195.135  138.72
\& <E WITH GRAVE>              200  116  116  116  195.136  138.73
\& <E WITH ACUTE>              201  113  113  113  195.137  138.74
\& <E WITH CIRCUMFLEX>         202  114  114  114  195.138  138.81
\& <E WITH DIAERESIS>          203  115  115  115  195.139  138.82
\& <I WITH GRAVE>              204  120  120  120  195.140  138.83
\& <I WITH ACUTE>              205  117  117  117  195.141  138.84
\& <I WITH CIRCUMFLEX>         206  118  118  118  195.142  138.85
\& <I WITH DIAERESIS>          207  119  119  119  195.143  138.86
\& <CAPITAL LETTER ETH>        208  172  172  172  195.144  138.87
\& <N WITH TILDE>              209  105  105  105  195.145  138.88
\& <O WITH GRAVE>              210  237  237  237  195.146  138.89
\& <O WITH ACUTE>              211  238  238  238  195.147  138.98
\& <O WITH CIRCUMFLEX>         212  235  235  235  195.148  138.99
\& <O WITH TILDE>              213  239  239  239  195.149  138.100
\& <O WITH DIAERESIS>          214  236  236  236  195.150  138.101
\& <MULTIPLICATION SIGN>       215  191  191  191  195.151  138.102
\& <O WITH STROKE>             216  128  128  128  195.152  138.103
\& <U WITH GRAVE>              217  253  253  224  195.153  138.104  ##
\& <U WITH ACUTE>              218  254  254  254  195.154  138.105
\& <U WITH CIRCUMFLEX>         219  251  251  221  195.155  138.106  ##
\& <U WITH DIAERESIS>          220  252  252  252  195.156  138.112
\& <Y WITH ACUTE>              221  173  186  173  195.157  138.113  ** ##
\& <CAPITAL LETTER THORN>      222  174  174  174  195.158  138.114
\& <SMALL LETTER SHARP S>      223  89   89   89   195.159  138.115
\& <a WITH GRAVE>              224  68   68   68   195.160  139.65
\& <a WITH ACUTE>              225  69   69   69   195.161  139.66
\& <a WITH CIRCUMFLEX>         226  66   66   66   195.162  139.67
\& <a WITH TILDE>              227  70   70   70   195.163  139.68
\& <a WITH DIAERESIS>          228  67   67   67   195.164  139.69
\& <a WITH RING ABOVE>         229  71   71   71   195.165  139.70
\& <SMALL LIGATURE ae>         230  156  156  156  195.166  139.71
\& <c WITH CEDILLA>            231  72   72   72   195.167  139.72
\& <e WITH GRAVE>              232  84   84   84   195.168  139.73
\& <e WITH ACUTE>              233  81   81   81   195.169  139.74
\& <e WITH CIRCUMFLEX>         234  82   82   82   195.170  139.81
\& <e WITH DIAERESIS>          235  83   83   83   195.171  139.82
\& <i WITH GRAVE>              236  88   88   88   195.172  139.83
\& <i WITH ACUTE>              237  85   85   85   195.173  139.84
\& <i WITH CIRCUMFLEX>         238  86   86   86   195.174  139.85
\& <i WITH DIAERESIS>          239  87   87   87   195.175  139.86
\& <SMALL LETTER eth>          240  140  140  140  195.176  139.87
\& <n WITH TILDE>              241  73   73   73   195.177  139.88
\& <o WITH GRAVE>              242  205  205  205  195.178  139.89
\& <o WITH ACUTE>              243  206  206  206  195.179  139.98
\& <o WITH CIRCUMFLEX>         244  203  203  203  195.180  139.99
\& <o WITH TILDE>              245  207  207  207  195.181  139.100
\& <o WITH DIAERESIS>          246  204  204  204  195.182  139.101
\& <DIVISION SIGN>             247  225  225  225  195.183  139.102
\& <o WITH STROKE>             248  112  112  112  195.184  139.103
\& <u WITH GRAVE>              249  221  221  192  195.185  139.104  ##
\& <u WITH ACUTE>              250  222  222  222  195.186  139.105
\& <u WITH CIRCUMFLEX>         251  219  219  219  195.187  139.106
\& <u WITH DIAERESIS>          252  220  220  220  195.188  139.112
\& <y WITH ACUTE>              253  141  141  141  195.189  139.113
\& <SMALL LETTER thorn>        254  142  142  142  195.190  139.114
\& <y WITH DIAERESIS>          255  223  223  223  195.191  139.115
.Ve
.PP
If you would rather see the above table in \s-1CCSID 0037\s0 order rather than
\&\s-1ASCII +\s0 Latin\-1 order then run the table through:
.IP "recipe 4" 4
.IX Item "recipe 4"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,34,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in \s-1CCSID 1047\s0 order then change the number
34 in the last line to 39, like this:
.IP "recipe 5" 4
.IX Item "recipe 5"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&    \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&    \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&    \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&    \-e \*(Aq          map{[$_,substr($_,39,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in POSIX-BC order then change the number
39 in the last line to 44, like this:
.IP "recipe 6" 4
.IX Item "recipe 6"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,44,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.SH "IDENTIFYING CHARACTER CODE SETS"
.IX Header "IDENTIFYING CHARACTER CODE SETS"
To determine the character set you are running under from perl one
could use the return value of \fIord()\fR or \fIchr()\fR to test one or more
character values.  For example:
.PP
.Vb 2
\&    $is_ascii  = "A" eq chr(65);
\&    $is_ebcdic = "A" eq chr(193);
.Ve
.PP
Also, \*(L"\et\*(R" is a \f(CW\*(C`HORIZONTAL TABULATION\*(C'\fR character so that:
.PP
.Vb 2
\&    $is_ascii  = ord("\et") == 9;
\&    $is_ebcdic = ord("\et") == 5;
.Ve
.PP
To distinguish \s-1EBCDIC\s0 code pages try looking at one or more of
the characters that differ between them.  For example:
.PP
.Vb 2
\&    $is_ebcdic_37   = "\en" eq chr(37);
\&    $is_ebcdic_1047 = "\en" eq chr(21);
.Ve
.PP
Or better still choose a character that is uniquely encoded in any
of the code sets, e.g.:
.PP
.Vb 4
\&    $is_ascii           = ord(\*(Aq[\*(Aq) == 91;
\&    $is_ebcdic_37       = ord(\*(Aq[\*(Aq) == 186;
\&    $is_ebcdic_1047     = ord(\*(Aq[\*(Aq) == 173;
\&    $is_ebcdic_POSIX_BC = ord(\*(Aq[\*(Aq) == 187;
.Ve
.PP
However, it would be unwise to write tests such as:
.PP
.Vb 2
\&    $is_ascii = "\er" ne chr(13);  #  WRONG
\&    $is_ascii = "\en" ne chr(10);  #  ILL ADVISED
.Ve
.PP
Obviously the first of these will fail to distinguish most \s-1ASCII\s0 platforms
from either a \s-1CCSID 0037,\s0 a 1047, or a POSIX-BC \s-1EBCDIC\s0 platform since \*(L"\er\*(R" eq
chr(13) under all of those coded character sets.  But note too that
because \*(L"\en\*(R" is chr(13) and \*(L"\er\*(R" is chr(10) on the Macintosh (which is an
\&\s-1ASCII\s0 platform) the second \f(CW$is_ascii\fR test will lead to trouble there.
.PP
To determine whether or not perl was built under an \s-1EBCDIC\s0
code page you can use the Config module like so:
.PP
.Vb 2
\&    use Config;
\&    $is_ebcdic = $Config{\*(Aqebcdic\*(Aq} eq \*(Aqdefine\*(Aq;
.Ve
.SH "CONVERSIONS"
.IX Header "CONVERSIONS"
.ie n .SS """utf8::unicode_to_native()"" and ""utf8::native_to_unicode()"""
.el .SS "\f(CWutf8::unicode_to_native()\fP and \f(CWutf8::native_to_unicode()\fP"
.IX Subsection "utf8::unicode_to_native() and utf8::native_to_unicode()"
These functions take an input numeric code point in one encoding and
return what its equivalent value is in the other.
.SS "tr///"
.IX Subsection "tr///"
In order to convert a string of characters from one character set to
another a simple list of numbers, such as in the right columns in the
above table, along with perl's tr/// operator is all that is needed.
The data in the table are in ASCII/Latin1 order, hence the \s-1EBCDIC\s0 columns
provide easy-to-use ASCII/Latin1 to \s-1EBCDIC\s0 operations that are also easily
reversed.
.PP
For example, to convert ASCII/Latin1 to code page 037 take the output of the
second numbers column from the output of recipe 2 (modified to add '\e'
characters), and use it in tr/// like so:
.PP
.Vb 10
\&    $cp_037 =
\&    \*(Aq\ex00\ex01\ex02\ex03\ex37\ex2D\ex2E\ex2F\ex16\ex05\ex25\ex0B\ex0C\ex0D\ex0E\ex0F\*(Aq .
\&    \*(Aq\ex10\ex11\ex12\ex13\ex3C\ex3D\ex32\ex26\ex18\ex19\ex3F\ex27\ex1C\ex1D\ex1E\ex1F\*(Aq .
\&    \*(Aq\ex40\ex5A\ex7F\ex7B\ex5B\ex6C\ex50\ex7D\ex4D\ex5D\ex5C\ex4E\ex6B\ex60\ex4B\ex61\*(Aq .
\&    \*(Aq\exF0\exF1\exF2\exF3\exF4\exF5\exF6\exF7\exF8\exF9\ex7A\ex5E\ex4C\ex7E\ex6E\ex6F\*(Aq .
\&    \*(Aq\ex7C\exC1\exC2\exC3\exC4\exC5\exC6\exC7\exC8\exC9\exD1\exD2\exD3\exD4\exD5\exD6\*(Aq .
\&    \*(Aq\exD7\exD8\exD9\exE2\exE3\exE4\exE5\exE6\exE7\exE8\exE9\exBA\exE0\exBB\exB0\ex6D\*(Aq .
\&    \*(Aq\ex79\ex81\ex82\ex83\ex84\ex85\ex86\ex87\ex88\ex89\ex91\ex92\ex93\ex94\ex95\ex96\*(Aq .
\&    \*(Aq\ex97\ex98\ex99\exA2\exA3\exA4\exA5\exA6\exA7\exA8\exA9\exC0\ex4F\exD0\exA1\ex07\*(Aq .
\&    \*(Aq\ex20\ex21\ex22\ex23\ex24\ex15\ex06\ex17\ex28\ex29\ex2A\ex2B\ex2C\ex09\ex0A\ex1B\*(Aq .
\&    \*(Aq\ex30\ex31\ex1A\ex33\ex34\ex35\ex36\ex08\ex38\ex39\ex3A\ex3B\ex04\ex14\ex3E\exFF\*(Aq .
\&    \*(Aq\ex41\exAA\ex4A\exB1\ex9F\exB2\ex6A\exB5\exBD\exB4\ex9A\ex8A\ex5F\exCA\exAF\exBC\*(Aq .
\&    \*(Aq\ex90\ex8F\exEA\exFA\exBE\exA0\exB6\exB3\ex9D\exDA\ex9B\ex8B\exB7\exB8\exB9\exAB\*(Aq .
\&    \*(Aq\ex64\ex65\ex62\ex66\ex63\ex67\ex9E\ex68\ex74\ex71\ex72\ex73\ex78\ex75\ex76\ex77\*(Aq .
\&    \*(Aq\exAC\ex69\exED\exEE\exEB\exEF\exEC\exBF\ex80\exFD\exFE\exFB\exFC\exAD\exAE\ex59\*(Aq .
\&    \*(Aq\ex44\ex45\ex42\ex46\ex43\ex47\ex9C\ex48\ex54\ex51\ex52\ex53\ex58\ex55\ex56\ex57\*(Aq .
\&    \*(Aq\ex8C\ex49\exCD\exCE\exCB\exCF\exCC\exE1\ex70\exDD\exDE\exDB\exDC\ex8D\ex8E\exDF\*(Aq;
\&
\&    my $ebcdic_string = $ascii_string;
\&    eval \*(Aq$ebcdic_string =~ tr/\e000\-\e377/\*(Aq . $cp_037 . \*(Aq/\*(Aq;
.Ve
.PP
To convert from \s-1EBCDIC 037\s0 to \s-1ASCII\s0 just reverse the order of the tr///
arguments like so:
.PP
.Vb 2
\&    my $ascii_string = $ebcdic_string;
\&    eval \*(Aq$ascii_string =~ tr/\*(Aq . $cp_037 . \*(Aq/\e000\-\e377/\*(Aq;
.Ve
.PP
Similarly one could take the output of the third numbers column from recipe 2
to obtain a \f(CW$cp_1047\fR table.  The fourth numbers column of the output from
recipe 2 could provide a \f(CW$cp_posix_bc\fR table suitable for transcoding as
well.
.PP
If you wanted to see the inverse tables, you would first have to sort on the
desired numbers column as in recipes 4, 5 or 6, then take the output of the
first numbers column.
.SS "iconv"
.IX Subsection "iconv"
\&\s-1XPG\s0 operability often implies the presence of an \fIiconv\fR utility
available from the shell or from the C library.  Consult your system's
documentation for information on iconv.
.PP
On \s-1OS/390\s0 or z/OS see the \fIiconv\fR\|(1) manpage.  One way to invoke the iconv
shell utility from within perl would be to:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ascii_data = \`echo \*(Aq$ebcdic_data\*(Aq| iconv \-f IBM\-1047 \-t ISO8859\-1\`
.Ve
.PP
or the inverse map:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ebcdic_data = \`echo \*(Aq$ascii_data\*(Aq| iconv \-f ISO8859\-1 \-t IBM\-1047\`
.Ve
.PP
For other perl-based conversion options see the Convert::* modules on \s-1CPAN.\s0
.SS "C \s-1RTL\s0"
.IX Subsection "C RTL"
The \s-1OS/390\s0 and z/OS C run-time libraries provide \fI_atoe()\fR and \fI_etoa()\fR functions.
.SH "OPERATOR DIFFERENCES"
.IX Header "OPERATOR DIFFERENCES"
The \f(CW\*(C`..\*(C'\fR range operator treats certain character ranges with
care on \s-1EBCDIC\s0 platforms.  For example the following array
will have twenty six elements on either an \s-1EBCDIC\s0 platform
or an \s-1ASCII\s0 platform:
.PP
.Vb 1
\&    @alphabet = (\*(AqA\*(Aq..\*(AqZ\*(Aq);   #  $#alphabet == 25
.Ve
.PP
The bitwise operators such as & ^ | may return different results
when operating on string or character data in a perl program running
on an \s-1EBCDIC\s0 platform than when run on an \s-1ASCII\s0 platform.  Here is
an example adapted from the one in perlop:
.PP
.Vb 5
\&    # EBCDIC\-based examples
\&    print "j p \en" ^ " a h";                      # prints "JAPH\en"
\&    print "JA" | "  ph\en";                        # prints "japh\en"
\&    print "JAPH\enJunk" & "\e277\e277\e277\e277\e277";  # prints "japh\en";
\&    print \*(Aqp N$\*(Aq ^ " E<H\en";                      # prints "Perl\en";
.Ve
.PP
An interesting property of the 32 C0 control characters
in the \s-1ASCII\s0 table is that they can \*(L"literally\*(R" be constructed
as control characters in perl, e.g. \f(CW\*(C`(chr(0)\*(C'\fR eq \f(CW\*(C`\ec@\*(C'\fR)>
\&\f(CW\*(C`(chr(1)\*(C'\fR eq \f(CW\*(C`\ecA\*(C'\fR)>, and so on.  Perl on \s-1EBCDIC\s0 platforms has been
ported to take \f(CW\*(C`\ec@\*(C'\fR to \fIchr\fR\|(0) and \f(CW\*(C`\ecA\*(C'\fR to \fIchr\fR\|(1), etc. as well, but the
thirty three characters that result depend on which code page you are
using.  The table below uses the standard acronyms for the controls.
The POSIX-BC and 1047 sets are
identical throughout this range and differ from the 0037 set at only
one spot (21 decimal).  Note that the \f(CW\*(C`LINE FEED\*(C'\fR character
may be generated by \f(CW\*(C`\ecJ\*(C'\fR on \s-1ASCII\s0 platforms but by \f(CW\*(C`\ecU\*(C'\fR on 1047 or POSIX-BC
platforms and cannot be generated as a \f(CW"\ec.letter."\fR control character on
0037 platforms.  Note also that \f(CW\*(C`\ec\e\*(C'\fR cannot be the final element in a string
or regex, as it will absorb the terminator.   But \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR is a \f(CW\*(C`FILE
SEPARATOR\*(C'\fR concatenated with \fIX\fR for all \fIX\fR.
.PP
.Vb 10
\& chr   ord   8859\-1    0037    1047 && POSIX\-BC
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& \ec?   127   <DEL>       "            "
\& \ec@     0   <NUL>     <NUL>        <NUL>
\& \ecA     1   <SOH>     <SOH>        <SOH>
\& \ecB     2   <STX>     <STX>        <STX>
\& \ecC     3   <ETX>     <ETX>        <ETX>
\& \ecD     4   <EOT>     <ST>         <ST>
\& \ecE     5   <ENQ>     <HT>         <HT>
\& \ecF     6   <ACK>     <SSA>        <SSA>
\& \ecG     7   <BEL>     <DEL>        <DEL>
\& \ecH     8   <BS>      <EPA>        <EPA>
\& \ecI     9   <HT>      <RI>         <RI>
\& \ecJ    10   <LF>      <SS2>        <SS2>
\& \ecK    11   <VT>      <VT>         <VT>
\& \ecL    12   <FF>      <FF>         <FF>
\& \ecM    13   <CR>      <CR>         <CR>
\& \ecN    14   <SO>      <SO>         <SO>
\& \ecO    15   <SI>      <SI>         <SI>
\& \ecP    16   <DLE>     <DLE>        <DLE>
\& \ecQ    17   <DC1>     <DC1>        <DC1>
\& \ecR    18   <DC2>     <DC2>        <DC2>
\& \ecS    19   <DC3>     <DC3>        <DC3>
\& \ecT    20   <DC4>     <OSC>        <OSC>
\& \ecU    21   <NAK>     <NEL>        <LF>              **
\& \ecV    22   <SYN>     <BS>         <BS>
\& \ecW    23   <ETB>     <ESA>        <ESA>
\& \ecX    24   <CAN>     <CAN>        <CAN>
\& \ecY    25   <EOM>     <EOM>        <EOM>
\& \ecZ    26   <SUB>     <PU2>        <PU2>
\& \ec[    27   <ESC>     <SS3>        <SS3>
\& \ec\eX   28   <FS>X     <FS>X        <FS>X
\& \ec]    29   <GS>      <GS>         <GS>
\& \ec^    30   <RS>      <RS>         <RS>
\& \ec_    31   <US>      <US>         <US>
.Ve
.SH "FUNCTION DIFFERENCES"
.IX Header "FUNCTION DIFFERENCES"
.IP "\fIchr()\fR" 8
.IX Item "chr()"
\&\fIchr()\fR must be given an \s-1EBCDIC\s0 code number argument to yield a desired
character return value on an \s-1EBCDIC\s0 platform.  For example:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = chr(193);
.Ve
.IP "\fIord()\fR" 8
.IX Item "ord()"
\&\fIord()\fR will return \s-1EBCDIC\s0 code number values on an \s-1EBCDIC\s0 platform.
For example:
.Sp
.Vb 1
\&    $the_number_193 = ord("A");
.Ve
.IP "\fIpack()\fR" 8
.IX Item "pack()"
The c and C templates for \fIpack()\fR are dependent upon character set
encoding.  Examples of usage on \s-1EBCDIC\s0 include:
.Sp
.Vb 4
\&    $foo = pack("CCCC",193,194,195,196);
\&    # $foo eq "ABCD"
\&    $foo = pack("C4",193,194,195,196);
\&    # same thing
\&
\&    $foo = pack("ccxxcc",193,194,195,196);
\&    # $foo eq "AB\e0\e0CD"
.Ve
.IP "\fIprint()\fR" 8
.IX Item "print()"
One must be careful with scalars and strings that are passed to
print that contain \s-1ASCII\s0 encodings.  One common place
for this to occur is in the output of the \s-1MIME\s0 type header for
\&\s-1CGI\s0 script writing.  For example, many perl programming guides
recommend something similar to:
.Sp
.Vb 2
\&    print "Content\-type:\ettext/html\e015\e012\e015\e012";
\&    # this may be wrong on EBCDIC
.Ve
.Sp
Under the \s-1IBM OS/390 USS\s0 Web Server or WebSphere on z/OS for example
you should instead write that as:
.Sp
.Vb 1
\&    print "Content\-type:\ettext/html\er\en\er\en"; # OK for DGW et al
.Ve
.Sp
That is because the translation from \s-1EBCDIC\s0 to \s-1ASCII\s0 is done
by the web server in this case (such code will not be appropriate for
the Macintosh however).  Consult your web server's documentation for
further details.
.IP "\fIprintf()\fR" 8
.IX Item "printf()"
The formats that can convert characters to numbers and vice versa
will be different from their \s-1ASCII\s0 counterparts when executed
on an \s-1EBCDIC\s0 platform.  Examples include:
.Sp
.Vb 1
\&    printf("%c%c%c",193,194,195);  # prints ABC
.Ve
.IP "\fIsort()\fR" 8
.IX Item "sort()"
\&\s-1EBCDIC\s0 sort results may differ from \s-1ASCII\s0 sort results especially for
mixed case strings.  This is discussed in more detail below.
.IP "\fIsprintf()\fR" 8
.IX Item "sprintf()"
See the discussion of \fIprintf()\fR above.  An example of the use
of sprintf would be:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = sprintf("%c",193);
.Ve
.IP "\fIunpack()\fR" 8
.IX Item "unpack()"
See the discussion of \fIpack()\fR above.
.SH "REGULAR EXPRESSION DIFFERENCES"
.IX Header "REGULAR EXPRESSION DIFFERENCES"
As of perl 5.005_03 the letter range regular expressions such as
[A\-Z] and [a\-z] have been especially coded to not pick up gap
characters.  For example, characters such as o\*^ \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR
that lie between I and J would not be matched by the
regular expression range \f(CW\*(C`/[H\-K]/\*(C'\fR.  This works in
the other direction, too, if either of the range end points is
explicitly numeric: \f(CW\*(C`[\ex89\-\ex91]\*(C'\fR will match \f(CW\*(C`\ex8e\*(C'\fR, even
though \f(CW\*(C`\ex89\*(C'\fR is \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`\ex91 \*(C'\fR is \f(CW\*(C`j\*(C'\fR, and \f(CW\*(C`\ex8e\*(C'\fR
is a gap character from the alphabetic viewpoint.
.PP
If you do want to match the alphabet gap characters in a single octet
regular expression try matching the hex or octal code such
as \f(CW\*(C`/\e313/\*(C'\fR on \s-1EBCDIC\s0 or \f(CW\*(C`/\e364/\*(C'\fR on \s-1ASCII\s0 platforms to
have your regular expression match \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR.
.PP
Another construct to be wary of is the inappropriate use of hex or
octal constants in regular expressions.  Consider the following
set of subs:
.PP
.Vb 4
\&    sub is_c0 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e000\-\e037]/;
\&    }
\&
\&    sub is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e040\-\e176]/;
\&    }
\&
\&    sub is_delete {
\&        my $char = substr(shift,0,1);
\&        $char eq "\e177";
\&    }
\&
\&    sub is_c1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e200\-\e237]/;
\&    }
\&
\&    sub is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e240\-\e377]/;
\&    }
.Ve
.PP
The above would be adequate if the concern was only with numeric code points.
However, the concern may be with characters rather than code points
and on an \s-1EBCDIC\s0 platform it may be desirable for constructs such as
\&\f(CW\*(C`if (is_print_ascii("A")) {print "A is a printable character\en";}\*(C'\fR to print
out the expected message.  One way to represent the above collection
of character classification subs that is capable of working across the
four coded character sets discussed in this document is as follows:
.PP
.Vb 12
\&    sub Is_c0 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e000\-\e037]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e045\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95 || ord(\*(Aq^\*(Aq)==106) { # 1047 || posix\-bc
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e025\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&    }
\&
\&    sub Is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<=>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~]/;
\&    }
\&
\&    sub Is_delete {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char eq "\e177";
\&        }
\&        else  {              # ebcdic
\&            return $char eq "\e007";
\&        }
\&    }
\&
\&    sub Is_c1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e200\-\e237]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e040\-\e044\e025\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~ /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~
\&              /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e137]/;
\&        }
\&    }
\&
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e240\-\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e275\e264\e232\e212\e137\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e273\e264\e232\e212\e260\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e272\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~
\&              /[\e101\e252\e260\e261\e237\e262\e320\e265\e171\e264\e232\e212\e272\e312\e257\e241\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e340\e376\e335\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e300\e336\e333\e334\e215\e216\e337]/;
\&        }
\&    }
.Ve
.PP
Note however that only the \f(CW\*(C`Is_ascii_print()\*(C'\fR sub is really independent
of coded character set.  Another way to write \f(CW\*(C`Is_latin_1()\*(C'\fR would be
to use the characters in the range explicitly:
.PP
.Vb 4
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\ XXXXXXXXXXXX\%XXXXXXXXXXXXXXXXXXA\*`A\*'A\*^A\*~A\*:A\*o\*(AeC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:XO\*/U\*`U\*'U\*^U\*:Y\*'\*(Th\*8a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:Xo\*/u\*`u\*'u\*^u\*:y\*'\*(thy\*:]/;
\&    }
.Ve
.PP
Although that form may run into trouble in network transit (due to the
presence of 8 bit characters) or on non ISO-Latin character sets.
.SH "SOCKETS"
.IX Header "SOCKETS"
Most socket programming assumes \s-1ASCII\s0 character encodings in network
byte order.  Exceptions can include \s-1CGI\s0 script writing under a
host web server where the server may take care of translation for you.
Most host web servers convert \s-1EBCDIC\s0 data to \s-1ISO\-8859\-1\s0 or Unicode on
output.
.SH "SORTING"
.IX Header "SORTING"
One big difference between ASCII-based character sets and \s-1EBCDIC\s0 ones
are the relative positions of upper and lower case letters and the
letters compared to the digits.  If sorted on an ASCII-based platform the
two-letter abbreviation for a physician comes before the two letter
abbreviation for drive; that is:
.PP
.Vb 2
\& @sorted = sort(qw(Dr. dr.));  # @sorted holds (\*(AqDr.\*(Aq,\*(Aqdr.\*(Aq) on ASCII,
\&                                  # but (\*(Aqdr.\*(Aq,\*(AqDr.\*(Aq) on EBCDIC
.Ve
.PP
The property of lowercase before uppercase letters in \s-1EBCDIC\s0 is
even carried to the Latin 1 \s-1EBCDIC\s0 pages such as 0037 and 1047.
An example would be that E\*: \f(CW\*(C`E WITH DIAERESIS\*(C'\fR (203) comes
before e\*: \f(CW\*(C`e WITH DIAERESIS\*(C'\fR (235) on an \s-1ASCII\s0 platform, but
the latter (83) comes before the former (115) on an \s-1EBCDIC\s0 platform.
(Astute readers will note that the uppercase version of \*8
\&\f(CW\*(C`SMALL LETTER SHARP S\*(C'\fR is simply \*(L"\s-1SS\*(R"\s0 and that the upper case version of
y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR is not in the 0..255 range but it is
at U+x0178 in Unicode, or \f(CW"\ex{178}"\fR in a Unicode enabled Perl).
.PP
The sort order will cause differences between results obtained on
\&\s-1ASCII\s0 platforms versus \s-1EBCDIC\s0 platforms.  What follows are some suggestions
on how to deal with these differences.
.SS "Ignore \s-1ASCII\s0 vs. \s-1EBCDIC\s0 sort differences."
.IX Subsection "Ignore ASCII vs. EBCDIC sort differences."
This is the least computationally expensive strategy.  It may require
some user education.
.SS "\s-1MONO CASE\s0 then sort data."
.IX Subsection "MONO CASE then sort data."
In order to minimize the expense of mono casing mixed-case text, try to
\&\f(CW\*(C`tr///\*(C'\fR towards the character set case most employed within the data.
If the data are primarily \s-1UPPERCASE\s0 non Latin 1 then apply tr/[a\-z]/[A\-Z]/
then \fIsort()\fR.  If the data are primarily lowercase non Latin 1 then
apply tr/[A\-Z]/[a\-z]/ before sorting.  If the data are primarily \s-1UPPERCASE\s0
and include Latin\-1 characters then apply:
.PP
.Vb 3
\&   tr/[a\-z]/[A\-Z]/;
\&   tr/[a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:o\*/u\*`u\*'u\*^u\*:y\*'\*(th]/[A\*`A\*'A\*^A\*~A\*:A\*o\*(AeC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:O\*/U\*`U\*'U\*^U\*:Y\*'\*(Th/;
\&   s/\*8/SS/g;
.Ve
.PP
then \fIsort()\fR.  Do note however that such Latin\-1 manipulation does not
address the y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR character that will remain at
code point 255 on \s-1ASCII\s0 platforms, but 223 on most \s-1EBCDIC\s0 platforms
where it will sort to a place less than the \s-1EBCDIC\s0 numerals.  With a
Unicode-enabled Perl you might try:
.PP
.Vb 1
\&    tr/^?/\ex{178}/;
.Ve
.PP
The strategy of mono casing data before sorting does not preserve the case
of the data and may not be acceptable for that reason.
.SS "Convert, sort data, then re convert."
.IX Subsection "Convert, sort data, then re convert."
This is the most expensive proposition that does not employ a network
connection.
.SS "Perform sorting on one type of platform only."
.IX Subsection "Perform sorting on one type of platform only."
This strategy can employ a network connection.  As such
it would be computationally expensive.
.SH "TRANSFORMATION FORMATS"
.IX Header "TRANSFORMATION FORMATS"
There are a variety of ways of transforming data with an intra character set
mapping that serve a variety of purposes.  Sorting was discussed in the
previous section and a few of the other more popular mapping techniques are
discussed next.
.SS "\s-1URL\s0 decoding and encoding"
.IX Subsection "URL decoding and encoding"
Note that some URLs have hexadecimal \s-1ASCII\s0 code points in them in an
attempt to overcome character or protocol limitation issues.  For example
the tilde character is not on every keyboard hence a \s-1URL\s0 of the form:
.PP
.Vb 1
\&    http://www.pvhp.com/~pvhp/
.Ve
.PP
may also be expressed as either of:
.PP
.Vb 1
\&    http://www.pvhp.com/%7Epvhp/
\&
\&    http://www.pvhp.com/%7epvhp/
.Ve
.PP
where 7E is the hexadecimal \s-1ASCII\s0 code point for '~'.  Here is an example
of decoding such a \s-1URL\s0 under \s-1CCSID 1047:\s0
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/%7Epvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @a2e_1047 = (
\&          0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
\&         64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
\&        240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
\&        124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
\&        215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
\&        121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
\&        151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,  7,
\&         32, 33, 34, 35, 36, 37,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
\&         48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,255,
\&         65,170, 74,177,159,178,106,181,187,180,154,138,176,202,175,188,
\&        144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
\&        100,101, 98,102, 99,103,158,104,116,113,114,115,120,117,118,119,
\&        172,105,237,238,235,239,236,191,128,253,254,251,252,186,174, 89,
\&         68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86, 87,
\&        140, 73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
\&    );
\&    $url =~ s/%([0\-9a\-fA\-F]{2})/pack("c",$a2e_1047[hex($1)])/ge;
.Ve
.PP
Conversely, here is a partial solution for the task of encoding such
a \s-1URL\s0 under the 1047 code page:
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/~pvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @e2a_1047 = (
\&          0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19,157, 10,  8,135, 24, 25,146,143, 28, 29, 30, 31,
\&        128,129,130,131,132,133, 23, 27,136,137,138,139,140,  5,  6,  7,
\&        144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
\&         32,160,226,228,224,225,227,229,231,241,162, 46, 60, 40, 43,124,
\&         38,233,234,235,232,237,238,239,236,223, 33, 36, 42, 41, 59, 94,
\&         45, 47,194,196,192,193,195,197,199,209,166, 44, 37, 95, 62, 63,
\&        248,201,202,203,200,205,206,207,204, 96, 58, 35, 64, 39, 61, 34,
\&        216, 97, 98, 99,100,101,102,103,104,105,171,187,240,253,254,177,
\&        176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,
\&        181,126,115,116,117,118,119,120,121,122,161,191,208, 91,222,174,
\&        172,163,165,183,169,167,182,188,189,190,221,168,175, 93,180,215,
\&        123, 65, 66, 67, 68, 69, 70, 71, 72, 73,173,244,246,242,243,245,
\&        125, 74, 75, 76, 77, 78, 79, 80, 81, 82,185,251,252,249,250,255,
\&         92,247, 83, 84, 85, 86, 87, 88, 89, 90,178,212,214,210,211,213,
\&         48, 49, 50, 51, 52, 53, 54, 55, 56, 57,179,219,220,217,218,159
\&    );
\&    # The following regular expression does not address the
\&    # mappings for: (\*(Aq.\*(Aq => \*(Aq%2E\*(Aq, \*(Aq/\*(Aq => \*(Aq%2F\*(Aq, \*(Aq:\*(Aq => \*(Aq%3A\*(Aq)
\&    $url =~ s/([\et "#%&\e(\e),;<=>\e?\e@\e[\e\e\e]^\`{|}~])/sprintf("%%%02X",$e2a_1047[ord($1)])/ge;
.Ve
.PP
where a more complete solution would split the \s-1URL\s0 into components
and apply a full s/// substitution only to the appropriate parts.
.PP
In the remaining examples a \f(CW@e2a\fR or \f(CW@a2e\fR array may be employed
but the assignment will not be shown explicitly.  For code page 1047
you could use the \f(CW@a2e_1047\fR or \f(CW@e2a_1047\fR arrays just shown.
.SS "uu encoding and decoding"
.IX Subsection "uu encoding and decoding"
The \f(CW\*(C`u\*(C'\fR template to \fIpack()\fR or \fIunpack()\fR will render \s-1EBCDIC\s0 data in \s-1EBCDIC\s0
characters equivalent to their \s-1ASCII\s0 counterparts.  For example, the
following will print \*(L"Yes indeed\en\*(R" on either an \s-1ASCII\s0 or \s-1EBCDIC\s0 computer:
.PP
.Vb 10
\&    $all_byte_chrs = \*(Aq\*(Aq;
\&    for (0..255) { $all_byte_chrs .= chr($_); }
\&    $uuencode_byte_chrs = pack(\*(Aqu\*(Aq, $all_byte_chrs);
\&    ($uu = <<\*(AqENDOFHEREDOC\*(Aq) =~ s/^\es*//gm;
\&    M\`\`$"\`P0%!@<("0H+#\`T.#Q\`1$A,4%187&!D:&QP=\*(AqA\e@(2(C)"4F)R@I*BLL
\&    M+2XO,#$R,S0U\-C<X.3H[/#T^/T!!0D\-$149\*(Aq2$E*2TQ\-3D]045)35%565UA9
\&    M6EM<75Y?8&%B8V1E9F=H:6IK;&UN;W!Q<G\-T=79W>\*(AqEZ>WQ]?G^\`@8*#A(6&
\&    MAXB)BHN,C8Z/D)&2DY25EI>8F9J;G)V>GZ"AHJ.DI::GJ*FJJZRMKJ^PL;*S
\&    MM+6VM[BYNKN\eO;Z_P,\*(Aq"P\e3%QL?(R<K+S,W.S]#1TM/4U=;7V\-G:V]S=WM_@
\&    ?X>+CY.7FY^CIZNOL[>[O\e/\*(AqR\e_3U]O?X^?K[_/W^_P\`\`
\&    ENDOFHEREDOC
\&    if ($uuencode_byte_chrs eq $uu) {
\&        print "Yes ";
\&    }
\&    $uudecode_byte_chrs = unpack(\*(Aqu\*(Aq, $uuencode_byte_chrs);
\&    if ($uudecode_byte_chrs eq $all_byte_chrs) {
\&        print "indeed\en";
\&    }
.Ve
.PP
Here is a very spartan uudecoder that will work on \s-1EBCDIC\s0 provided
that the \f(CW@e2a\fR array is filled in appropriately:
.PP
.Vb 10
\&    #!/usr/local/bin/perl
\&    @e2a = ( # this must be filled in
\&           );
\&    $_ = <> until ($mode,$file) = /^begin\es*(\ed*)\es*(\eS*)/;
\&    open(OUT, "> $file") if $file ne "";
\&    while(<>) {
\&        last if /^end/;
\&        next if /[a\-z]/;
\&        next unless int(((($e2a[ord()] \- 32 ) & 077) + 2) / 3) ==
\&            int(length() / 4);
\&        print OUT unpack("u", $_);
\&    }
\&    close(OUT);
\&    chmod oct($mode), $file;
.Ve
.SS "Quoted-Printable encoding and decoding"
.IX Subsection "Quoted-Printable encoding and decoding"
On ASCII-encoded platforms it is possible to strip characters outside of
the printable set using:
.PP
.Vb 2
\&    # This QP encoder works on ASCII only
\&    $qp_string =~ s/([=\ex00\-\ex1F\ex80\-\exFF])/sprintf("=%02X",ord($1))/ge;
.Ve
.PP
Whereas a \s-1QP\s0 encoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms
would look somewhat like the following (where the \s-1EBCDIC\s0 branch \f(CW@e2a\fR
array is omitted for brevity):
.PP
.Vb 10
\&    if (ord(\*(AqA\*(Aq) == 65) {    # ASCII
\&        $delete = "\ex7F";    # ASCII
\&        @e2a = (0 .. 255)    # ASCII to ASCII identity map
\&    }
\&    else {                   # EBCDIC
\&        $delete = "\ex07";    # EBCDIC
\&        @e2a =               # EBCDIC to ASCII map (as shown above)
\&    }
\&    $qp_string =~
\&      s/([^ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~$delete])/sprintf("=%02X",$e2a[ord($1)])/ge;
.Ve
.PP
(although in production code the substitutions might be done
in the \s-1EBCDIC\s0 branch with the \f(CW@e2a\fR array and separately in the
\&\s-1ASCII\s0 branch without the expense of the identity map).
.PP
Such \s-1QP\s0 strings can be decoded with:
.PP
.Vb 3
\&    # This QP decoder is limited to ASCII only
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr hex $1/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.PP
Whereas a \s-1QP\s0 decoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms
would look somewhat like the following (where the \f(CW@a2e\fR array is
omitted for brevity):
.PP
.Vb 2
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr $a2e[hex $1]/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.SS "Caesarean ciphers"
.IX Subsection "Caesarean ciphers"
The practice of shifting an alphabet one or more characters for encipherment
dates back thousands of years and was explicitly detailed by Gaius Julius
Caesar in his \fBGallic Wars\fR text.  A single alphabet shift is sometimes
referred to as a rotation and the shift amount is given as a number \f(CW$n\fR after
the string 'rot' or \*(L"rot$n\*(R".  Rot0 and rot26 would designate identity maps
on the 26\-letter English version of the Latin alphabet.  Rot13 has the
interesting property that alternate subsequent invocations are identity maps
(thus rot13 is its own non-trivial inverse in the group of 26 alphabet
rotations).  Hence the following is a rot13 encoder and decoder that will
work on \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms:
.PP
.Vb 1
\&    #!/usr/local/bin/perl
\&
\&    while(<>){
\&        tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;
\&        print;
\&    }
.Ve
.PP
In one-liner form:
.PP
.Vb 1
\&    perl \-ne \*(Aqtr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;print\*(Aq
.Ve
.SH "Hashing order and checksums"
.IX Header "Hashing order and checksums"
To the extent that it is possible to write code that depends on
hashing order there may be differences between hashes as stored
on an ASCII-based platform and hashes stored on an EBCDIC-based platform.
\&\s-1XXX\s0
.SH "I18N AND L10N"
.IX Header "I18N AND L10N"
Internationalization (I18N) and localization (L10N) are supported at least
in principle even on \s-1EBCDIC\s0 platforms.  The details are system-dependent
and discussed under the \*(L"\s-1OS ISSUES\*(R"\s0 in perlebcdic section below.
.SH "MULTI-OCTET CHARACTER SETS"
.IX Header "MULTI-OCTET CHARACTER SETS"
Perl may work with an internal UTF-EBCDIC encoding form for wide characters
on \s-1EBCDIC\s0 platforms in a manner analogous to the way that it works with
the \s-1UTF\-8\s0 internal encoding form on \s-1ASCII\s0 based platforms.
.PP
Legacy multi byte \s-1EBCDIC\s0 code pages \s-1XXX.\s0
.SH "OS ISSUES"
.IX Header "OS ISSUES"
There may be a few system-dependent issues
of concern to \s-1EBCDIC\s0 Perl programmers.
.SS "\s-1OS/400\s0"
.IX Subsection "OS/400"
.IP "\s-1PASE\s0" 8
.IX Item "PASE"
The \s-1PASE\s0 environment is a runtime environment for \s-1OS/400\s0 that can run
executables built for PowerPC \s-1AIX\s0 in \s-1OS/400\s0; see perlos400.  \s-1PASE\s0
is ASCII-based, not EBCDIC-based as the \s-1ILE.\s0
.IP "\s-1IFS\s0 access" 8
.IX Item "IFS access"
\&\s-1XXX.\s0
.SS "\s-1OS/390,\s0 z/OS"
.IX Subsection "OS/390, z/OS"
Perl runs under Unix Systems Services or \s-1USS.\s0
.IP "chcp" 8
.IX Item "chcp"
\&\fBchcp\fR is supported as a shell utility for displaying and changing
one's code page.  See also \fIchcp\fR\|(1).
.IP "dataset access" 8
.IX Item "dataset access"
For sequential data set access try:
.Sp
.Vb 1
\&    my @ds_records = \`cat //DSNAME\`;
.Ve
.Sp
or:
.Sp
.Vb 1
\&    my @ds_records = \`cat //\*(AqHLQ.DSNAME\*(Aq\`;
.Ve
.Sp
See also the OS390::Stdio module on \s-1CPAN.\s0
.IP "\s-1OS/390,\s0 z/OS iconv" 8
.IX Item "OS/390, z/OS iconv"
\&\fBiconv\fR is supported as both a shell utility and a C \s-1RTL\s0 routine.
See also the \fIiconv\fR\|(1) and \fIiconv\fR\|(3) manual pages.
.IP "locales" 8
.IX Item "locales"
On \s-1OS/390\s0 or z/OS see locale for information on locales.  The L10N files
are in \fI/usr/nls/locale\fR.  \f(CW$Config\fR{d_setlocale} is 'define' on \s-1OS/390\s0
or z/OS.
.SS "POSIX-BC?"
.IX Subsection "POSIX-BC?"
\&\s-1XXX.\s0
.SH "BUGS"
.IX Header "BUGS"
This pod document contains literal Latin 1 characters and may encounter
translation difficulties.  In particular one popular nroff implementation
was known to strip accented characters to their unaccented counterparts
while attempting to view this document through the \fBpod2man\fR program
(for example, you may see a plain \f(CW\*(C`y\*(C'\fR rather than one with a diaeresis
as in y\*:).  Another nroff truncated the resultant manpage at
the first occurrence of 8 bit characters.
.PP
Not all shells will allow multiple \f(CW\*(C`\-e\*(C'\fR string arguments to perl to
be concatenated together properly as recipes 0, 2, 4, 5, and 6 might
seem to imply.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perllocale, perlfunc, perlunicode, utf8.
.SH "REFERENCES"
.IX Header "REFERENCES"
<http://anubis.dkuug.dk/i18n/charmaps>
.PP
<http://www.unicode.org/>
.PP
<http://www.unicode.org/unicode/reports/tr16/>
.PP
<http://www.wps.com/projects/codes/>
\&\fB\s-1ASCII:\s0 American Standard Code for Information Infiltration\fR Tom Jennings,
September 1999.
.PP
\&\fBThe Unicode Standard, Version 3.0\fR The Unicode Consortium, Lisa Moore ed.,
\&\s-1ISBN 0\-201\-61633\-5,\s0 Addison Wesley Developers Press, February 2000.
.PP
\&\fB\s-1CDRA: IBM \-\s0 Character Data Representation Architecture \-
Reference and Registry\fR, \s-1IBM SC09\-2190\-00,\s0 December 1996.
.PP
\&\*(L"Demystifying Character Sets\*(R", Andrea Vine, Multilingual Computing
& Technology, \fB#26 Vol. 10 Issue 4\fR, August/September 1999;
\&\s-1ISSN 1523\-0309\s0; Multilingual Computing Inc. Sandpoint \s-1ID, USA.\s0
.PP
\&\fBCodes, Ciphers, and Other Cryptic and Clandestine Communication\fR
Fred B. Wrixon, \s-1ISBN 1\-57912\-040\-7,\s0 Black Dog & Leventhal Publishers,
1998.
.PP
<http://www.bobbemer.com/P\-BIT.HTM>
\&\fB\s-1IBM \- EBCDIC\s0 and the P\-bit; The biggest Computer Goof Ever\fR Robert Bemer.
.SH "HISTORY"
.IX Header "HISTORY"
15 April 2001: added \s-1UTF\-8\s0 and UTF-EBCDIC to main table, pvhp.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer pvhp@best.com wrote this in 1999 and 2000
with \s-1CCSID 0819\s0 and 0037 help from Chris Leach and
Andre\*' Pirard A.Pirard@ulg.ac.be as well as POSIX-BC
help from Thomas Dorner Thomas.Dorner@start.de.
Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and
Joe Smith.  Trademarks, registered trademarks, service marks and
registered service marks used in this document are the property of
their respective owners.
                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlebcdic5.16.1                             0100644 0001750 0001750 00000237537 12566207416 023370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEBCDIC 1"
.TH PERLEBCDIC 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlebcdic \- Considerations for running Perl on EBCDIC platforms
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An exploration of some of the issues facing Perl programmers
on \s-1EBCDIC\s0 based computers.  We do not cover localization, 
internationalization, or multi-byte character set issues other
than some discussion of \s-1UTF\-8\s0 and UTF-EBCDIC.
.PP
Portions that are still incomplete are marked with \s-1XXX\s0.
.PP
Perl used to work on \s-1EBCDIC\s0 machines, but there are now areas of the code where
it doesn't.  If you want to use Perl on an \s-1EBCDIC\s0 machine, please let us know
by sending mail to perlbug@perl.org
.SH "COMMON CHARACTER CODE SETS"
.IX Header "COMMON CHARACTER CODE SETS"
.SS "\s-1ASCII\s0"
.IX Subsection "ASCII"
The American Standard Code for Information Interchange (\s-1ASCII\s0 or US-ASCII) is a
set of
integers running from 0 to 127 (decimal) that imply character 
interpretation by the display and other systems of computers.  
The range 0..127 can be covered by setting the bits in a 7\-bit binary 
digit, hence the set is sometimes referred to as \*(L"7\-bit \s-1ASCII\s0\*(R".  
\&\s-1ASCII\s0 was described by the American National Standards Institute 
document \s-1ANSI\s0 X3.4\-1986.  It was also described by \s-1ISO\s0 646:1991 
(with localization for currency symbols).  The full \s-1ASCII\s0 set is 
given in the table below as the first 128 elements.  Languages that 
can be written adequately with the characters in \s-1ASCII\s0 include 
English, Hawaiian, Indonesian, Swahili and some Native American 
languages.
.PP
There are many character sets that extend the range of integers
from 0..2**7\-1 up to 2**8\-1, or 8 bit bytes (octets if you prefer).
One common one is the \s-1ISO\s0 8859\-1 character set.
.SS "\s-1ISO\s0 8859"
.IX Subsection "ISO 8859"
The \s-1ISO\s0 8859\-$n are a collection of character code sets from the 
International Organization for Standardization (\s-1ISO\s0) each of which 
adds characters to the \s-1ASCII\s0 set that are typically found in European 
languages many of which are based on the Roman, or Latin, alphabet.
.SS "Latin 1 (\s-1ISO\s0 8859\-1)"
.IX Subsection "Latin 1 (ISO 8859-1)"
A particular 8\-bit extension to \s-1ASCII\s0 that includes grave and acute 
accented Latin characters.  Languages that can employ \s-1ISO\s0 8859\-1 
include all the languages covered by \s-1ASCII\s0 as well as Afrikaans, 
Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian, 
Portuguese, Spanish, and Swedish.  Dutch is covered albeit without 
the ij ligature.  French is covered too but without the oe ligature. 
German can use \s-1ISO\s0 8859\-1 but must do so without German-style
quotation marks.  This set is based on Western European extensions 
to \s-1ASCII\s0 and is commonly encountered in world wide web work.
In \s-1IBM\s0 character code set identification terminology \s-1ISO\s0 8859\-1 is
also known as \s-1CCSID\s0 819 (or sometimes 0819 or even 00819).
.SS "\s-1EBCDIC\s0"
.IX Subsection "EBCDIC"
The Extended Binary Coded Decimal Interchange Code refers to a 
large collection of single\- and multi-byte coded character sets that are
different from \s-1ASCII\s0 or \s-1ISO\s0 8859\-1 and are all slightly different from each
other; they typically run on host computers.  The \s-1EBCDIC\s0 encodings derive from
8\-bit byte extensions of Hollerith punched card encodings.  The layout on the
cards was such that high bits were set for the upper and lower case alphabet
characters [a\-z] and [A\-Z], but there were gaps within each Latin alphabet
range.
.PP
Some \s-1IBM\s0 \s-1EBCDIC\s0 character sets may be known by character code set 
identification numbers (\s-1CCSID\s0 numbers) or code page numbers.
.PP
Perl can be compiled on platforms that run any of three commonly used \s-1EBCDIC\s0
character sets, listed below.
.SS "The 13 variant characters"
.IX Subsection "The 13 variant characters"
Among \s-1IBM\s0 \s-1EBCDIC\s0 character code sets there are 13 characters that
are often mapped to different integer values.  Those characters
are known as the 13 \*(L"variant\*(R" characters and are:
.PP
.Vb 1
\&    \e [ ] { } ^ ~ ! # | $ @ \`
.Ve
.PP
When Perl is compiled for a platform, it looks at some of these characters to
guess which \s-1EBCDIC\s0 character set the platform uses, and adapts itself
accordingly to that platform.  If the platform uses a character set that is not
one of the three Perl knows about, Perl will either fail to compile, or
mistakenly and silently choose one of the three.
They are:
.SS "0037"
.IX Subsection "0037"
Character code set \s-1ID\s0 0037 is a mapping of the \s-1ASCII\s0 plus Latin\-1 
characters (i.e. \s-1ISO\s0 8859\-1) to an \s-1EBCDIC\s0 set.  0037 is used 
in North American English locales on the \s-1OS/400\s0 operating system 
that runs on \s-1AS/400\s0 computers.  \s-1CCSID\s0 0037 differs from \s-1ISO\s0 8859\-1 
in 237 places, in other words they agree on only 19 code point values.
.SS "1047"
.IX Subsection "1047"
Character code set \s-1ID\s0 1047 is also a mapping of the \s-1ASCII\s0 plus 
Latin\-1 characters (i.e. \s-1ISO\s0 8859\-1) to an \s-1EBCDIC\s0 set.  1047 is 
used under Unix System Services for \s-1OS/390\s0 or z/OS, and OpenEdition 
for \s-1VM/ESA\s0.  \s-1CCSID\s0 1047 differs from \s-1CCSID\s0 0037 in eight places.
.SS "POSIX-BC"
.IX Subsection "POSIX-BC"
The \s-1EBCDIC\s0 code page in use on Siemens' \s-1BS2000\s0 system is distinct from
1047 and 0037.  It is identified below as the POSIX-BC set.
.SS "Unicode code points versus \s-1EBCDIC\s0 code points"
.IX Subsection "Unicode code points versus EBCDIC code points"
In Unicode terminology a \fIcode point\fR is the number assigned to a
character: for example, in \s-1EBCDIC\s0 the character \*(L"A\*(R" is usually assigned
the number 193.  In Unicode the character \*(L"A\*(R" is assigned the number 65.
This causes a problem with the semantics of the pack/unpack \*(L"U\*(R", which
are supposed to pack Unicode code points to characters and back to numbers.
The problem is: which code points to use for code points less than 256?
(for 256 and over there's no problem: Unicode code points are used)
In \s-1EBCDIC\s0, for the low 256 the \s-1EBCDIC\s0 code points are used.  This
means that the equivalences
.PP
.Vb 2
\&    pack("U", ord($character)) eq $character
\&    unpack("U", $character) == ord $character
.Ve
.PP
will hold.  (If Unicode code points were applied consistently over
all the possible code points, pack(\*(L"U\*(R",ord(\*(L"A\*(R")) would in \s-1EBCDIC\s0
equal \fIA with acute\fR or chr(101), and unpack(\*(L"U\*(R", \*(L"A\*(R") would equal
65, or \fInon-breaking space\fR, not 193, or ord \*(L"A\*(R".)
.SS "Remaining Perl Unicode problems in \s-1EBCDIC\s0"
.IX Subsection "Remaining Perl Unicode problems in EBCDIC"
.IP "\(bu" 4
Many of the remaining problems seem to be related to case-insensitive matching
.IP "\(bu" 4
The extensions Unicode::Collate and Unicode::Normalized are not
supported under \s-1EBCDIC\s0, likewise for the encoding pragma.
.SS "Unicode and \s-1UTF\s0"
.IX Subsection "Unicode and UTF"
\&\s-1UTF\s0 stands for \f(CW\*(C`Unicode Transformation Format\*(C'\fR.
\&\s-1UTF\-8\s0 is an encoding of Unicode into a sequence of 8\-bit byte chunks, based on
\&\s-1ASCII\s0 and Latin\-1.
The length of a sequence required to represent a Unicode code point
depends on the ordinal number of that code point,
with larger numbers requiring more bytes.
UTF-EBCDIC is like \s-1UTF\-8\s0, but based on \s-1EBCDIC\s0.
.PP
You may see the term \f(CW\*(C`invariant\*(C'\fR character or code point.
This simply means that the character has the same numeric
value when encoded as when not.
(Note that this is a very different concept from \*(L"The 13 variant characters\*(R"
mentioned above.)
For example, the ordinal value of 'A' is 193 in most \s-1EBCDIC\s0 code pages,
and also is 193 when encoded in UTF-EBCDIC.
All variant code points occupy at least two bytes when encoded.
In \s-1UTF\-8\s0, the code points corresponding to the lowest 128
ordinal numbers (0 \- 127: the \s-1ASCII\s0 characters) are invariant.
In UTF-EBCDIC, there are 160 invariant characters.
(If you care, the \s-1EBCDIC\s0 invariants are those characters
which have \s-1ASCII\s0 equivalents, plus those that correspond to
the C1 controls (80..9f on \s-1ASCII\s0 platforms).)
.PP
A string encoded in UTF-EBCDIC may be longer (but never shorter) than
one encoded in \s-1UTF\-8\s0.
.SS "Using Encode"
.IX Subsection "Using Encode"
Starting from Perl 5.8 you can use the standard new module Encode
to translate from \s-1EBCDIC\s0 to Latin\-1 code points.
Encode knows about more \s-1EBCDIC\s0 character sets than Perl can currently
be compiled to run on.
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is in EBCDIC code points
\&   from_to($a, $ebcdic{ord \*(Aq^\*(Aq}, \*(Aqlatin1\*(Aq);
\&   # $a is ISO 8859\-1 code points
.Ve
.PP
and from Latin\-1 code points to \s-1EBCDIC\s0 code points
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is ISO 8859\-1 code points
\&   from_to($a, \*(Aqlatin1\*(Aq, $ebcdic{ord \*(Aq^\*(Aq});
\&   # $a is in EBCDIC code points
.Ve
.PP
For doing I/O it is suggested that you use the autotranslating features
of PerlIO, see perluniintro.
.PP
Since version 5.8 Perl uses the new PerlIO I/O library.  This enables
you to use different encodings per \s-1IO\s0 channel.  For example you may use
.PP
.Vb 9
\&    use Encode;
\&    open($f, ">:encoding(ascii)", "test.ascii");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(cp37)", "test.ebcdic");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(latin1)", "test.latin1");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(utf8)", "test.utf8");
\&    print $f "Hello World!\en";
.Ve
.PP
to get four files containing \*(L"Hello World!\en\*(R" in \s-1ASCII\s0, \s-1CP\s0 0037 \s-1EBCDIC\s0,
\&\s-1ISO\s0 8859\-1 (Latin\-1) (in this example identical to \s-1ASCII\s0 since only \s-1ASCII\s0
characters were printed), and 
UTF-EBCDIC (in this example identical to normal \s-1EBCDIC\s0 since only characters
that don't differ between \s-1EBCDIC\s0 and UTF-EBCDIC were printed).  See the
documentation of Encode::PerlIO for details.
.PP
As the PerlIO layer uses raw \s-1IO\s0 (bytes) internally, all this totally
ignores things like the type of your filesystem (\s-1ASCII\s0 or \s-1EBCDIC\s0).
.SH "SINGLE OCTET TABLES"
.IX Header "SINGLE OCTET TABLES"
The following tables list the \s-1ASCII\s0 and Latin 1 ordered sets including
the subsets: C0 controls (0..31), \s-1ASCII\s0 graphics (32..7e), delete (7f),
C1 controls (80..9f), and Latin\-1 (a.k.a. \s-1ISO\s0 8859\-1) (a0..ff).  In the 
table non-printing control character names as well as the Latin 1 
extensions to \s-1ASCII\s0 have been labelled with character names roughly 
corresponding to \fIThe Unicode Standard, Version 3.0\fR albeit with 
substitutions such as s/LATIN// and s/VULGAR// in all cases, 
s/CAPITAL \s-1LETTER//\s0 in some cases, and s/SMALL \s-1LETTER\s0 ([A\-Z])/\el$1/ 
in some other cases.  The \*(L"names\*(R" of the controls listed here are 
the Unicode Version 1 names, except for the few that don't have names, in which
case the names in the Wikipedia article were used
(<http://en.wikipedia.org/wiki/C0_and_C1_control_codes>).
The differences between the 0037 and 1047 sets are 
flagged with ***.  The differences between the 1047 and POSIX-BC sets 
are flagged with ###.  All \fIord()\fR numbers listed are decimal.  If you 
would rather see this table listing octal values then run the table 
(that is, the pod version of this document since this recipe may not 
work with a pod2_other_format translation) through:
.IP "recipe 0" 4
.IX Item "recipe 0"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{43})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-9.03o%\-9.03o%\-9.03o%.03o\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
If you want to retain the UTF-x code points then in script form you
might want to write:
.IP "recipe 1" 4
.IX Item "recipe 1"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{43})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-9.03o%\-9.03o%\-9.03o%\-9.03o%\-3o.%\-5o%\-3o.%.03o\en",
\&                                            $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-9.03o%\-9.03o%\-9.03o%\-9.03o%\-3o.%\-5o%.03o\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-9.03o%\-9.03o%\-9.03o%\-9.03o%\-9.03o%.03o\en",
\&                                                $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
.Ve
.PP
If you would rather see this table listing hexadecimal values then
run the table through:
.IP "recipe 2" 4
.IX Item "recipe 2"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{43})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-9.02X%\-9.02X%\-9.02X%.02X\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
Or, in order to retain the UTF-x code points in hexadecimal:
.IP "recipe 3" 4
.IX Item "recipe 3"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{43})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-9.02X%\-9.02X%\-9.02X%\-9.02X%\-2X.%\-6.02X%02X.%02X\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-9.02X%\-9.02X%\-9.02X%\-9.02X%\-2X.%\-6.02X%02X\en",
\&                                              $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-9.02X%\-9.02X%\-9.02X%\-9.02X%\-9.02X%02X\en",
\&                                                  $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
\&
\&
\&                                      ISO 8859\-1  CCSID    CCSID                    CCSID 1047
\& chr                                  CCSID 0819  0037     1047    POSIX\-BC  UTF\-8  UTF\-EBCDIC
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& <NULL>                                    0        0        0        0        0        0 
\& <START OF HEADING>                        1        1        1        1        1        1
\& <START OF TEXT>                           2        2        2        2        2        2
\& <END OF TEXT>                             3        3        3        3        3        3
\& <END OF TRANSMISSION>                     4        55       55       55       4        55 
\& <ENQUIRY>                                 5        45       45       45       5        45 
\& <ACKNOWLEDGE>                             6        46       46       46       6        46 
\& <BELL>                                    7        47       47       47       7        47 
\& <BACKSPACE>                               8        22       22       22       8        22 
\& <HORIZONTAL TABULATION>                   9        5        5        5        9        5 
\& <LINE FEED>                               10       37       21       21       10       21       ***
\& <VERTICAL TABULATION>                     11       11       11       11       11       11
\& <FORM FEED>                               12       12       12       12       12       12
\& <CARRIAGE RETURN>                         13       13       13       13       13       13
\& <SHIFT OUT>                               14       14       14       14       14       14
\& <SHIFT IN>                                15       15       15       15       15       15
\& <DATA LINK ESCAPE>                        16       16       16       16       16       16
\& <DEVICE CONTROL ONE>                      17       17       17       17       17       17
\& <DEVICE CONTROL TWO>                      18       18       18       18       18       18
\& <DEVICE CONTROL THREE>                    19       19       19       19       19       19
\& <DEVICE CONTROL FOUR>                     20       60       60       60       20       60
\& <NEGATIVE ACKNOWLEDGE>                    21       61       61       61       21       61
\& <SYNCHRONOUS IDLE>                        22       50       50       50       22       50
\& <END OF TRANSMISSION BLOCK>               23       38       38       38       23       38
\& <CANCEL>                                  24       24       24       24       24       24
\& <END OF MEDIUM>                           25       25       25       25       25       25
\& <SUBSTITUTE>                              26       63       63       63       26       63
\& <ESCAPE>                                  27       39       39       39       27       39
\& <FILE SEPARATOR>                          28       28       28       28       28       28
\& <GROUP SEPARATOR>                         29       29       29       29       29       29
\& <RECORD SEPARATOR>                        30       30       30       30       30       30
\& <UNIT SEPARATOR>                          31       31       31       31       31       31
\& <SPACE>                                   32       64       64       64       32       64
\& !                                         33       90       90       90       33       90
\& "                                         34       127      127      127      34       127
\& #                                         35       123      123      123      35       123
\& $                                         36       91       91       91       36       91
\& %                                         37       108      108      108      37       108
\& &                                         38       80       80       80       38       80
\& \*(Aq                                         39       125      125      125      39       125
\& (                                         40       77       77       77       40       77
\& )                                         41       93       93       93       41       93
\& *                                         42       92       92       92       42       92
\& +                                         43       78       78       78       43       78
\& ,                                         44       107      107      107      44       107
\& \-                                         45       96       96       96       45       96
\& .                                         46       75       75       75       46       75
\& /                                         47       97       97       97       47       97
\& 0                                         48       240      240      240      48       240
\& 1                                         49       241      241      241      49       241
\& 2                                         50       242      242      242      50       242
\& 3                                         51       243      243      243      51       243
\& 4                                         52       244      244      244      52       244
\& 5                                         53       245      245      245      53       245
\& 6                                         54       246      246      246      54       246
\& 7                                         55       247      247      247      55       247
\& 8                                         56       248      248      248      56       248
\& 9                                         57       249      249      249      57       249
\& :                                         58       122      122      122      58       122
\& ;                                         59       94       94       94       59       94
\& <                                         60       76       76       76       60       76
\& =                                         61       126      126      126      61       126
\& >                                         62       110      110      110      62       110
\& ?                                         63       111      111      111      63       111
\& @                                         64       124      124      124      64       124
\& A                                         65       193      193      193      65       193
\& B                                         66       194      194      194      66       194
\& C                                         67       195      195      195      67       195
\& D                                         68       196      196      196      68       196
\& E                                         69       197      197      197      69       197
\& F                                         70       198      198      198      70       198
\& G                                         71       199      199      199      71       199
\& H                                         72       200      200      200      72       200
\& I                                         73       201      201      201      73       201
\& J                                         74       209      209      209      74       209
\& K                                         75       210      210      210      75       210
\& L                                         76       211      211      211      76       211
\& M                                         77       212      212      212      77       212
\& N                                         78       213      213      213      78       213
\& O                                         79       214      214      214      79       214
\& P                                         80       215      215      215      80       215
\& Q                                         81       216      216      216      81       216
\& R                                         82       217      217      217      82       217
\& S                                         83       226      226      226      83       226
\& T                                         84       227      227      227      84       227
\& U                                         85       228      228      228      85       228
\& V                                         86       229      229      229      86       229
\& W                                         87       230      230      230      87       230
\& X                                         88       231      231      231      88       231
\& Y                                         89       232      232      232      89       232
\& Z                                         90       233      233      233      90       233
\& [                                         91       186      173      187      91       173      *** ###
\& \e                                         92       224      224      188      92       224      ### 
\& ]                                         93       187      189      189      93       189      ***
\& ^                                         94       176      95       106      94       95       *** ###
\& _                                         95       109      109      109      95       109
\& \`                                         96       121      121      74       96       121      ###
\& a                                         97       129      129      129      97       129
\& b                                         98       130      130      130      98       130
\& c                                         99       131      131      131      99       131
\& d                                         100      132      132      132      100      132
\& e                                         101      133      133      133      101      133
\& f                                         102      134      134      134      102      134
\& g                                         103      135      135      135      103      135
\& h                                         104      136      136      136      104      136
\& i                                         105      137      137      137      105      137
\& j                                         106      145      145      145      106      145
\& k                                         107      146      146      146      107      146
\& l                                         108      147      147      147      108      147
\& m                                         109      148      148      148      109      148
\& n                                         110      149      149      149      110      149
\& o                                         111      150      150      150      111      150
\& p                                         112      151      151      151      112      151
\& q                                         113      152      152      152      113      152
\& r                                         114      153      153      153      114      153
\& s                                         115      162      162      162      115      162
\& t                                         116      163      163      163      116      163
\& u                                         117      164      164      164      117      164
\& v                                         118      165      165      165      118      165
\& w                                         119      166      166      166      119      166
\& x                                         120      167      167      167      120      167
\& y                                         121      168      168      168      121      168
\& z                                         122      169      169      169      122      169
\& {                                         123      192      192      251      123      192      ###
\& |                                         124      79       79       79       124      79
\& }                                         125      208      208      253      125      208      ###
\& ~                                         126      161      161      255      126      161      ###
\& <DELETE>                                  127      7        7        7        127      7
\& <PADDING CHARACTER>                       128      32       32       32       194.128  32
\& <HIGH OCTET PRESET>                       129      33       33       33       194.129  33
\& <BREAK PERMITTED HERE>                    130      34       34       34       194.130  34
\& <NO BREAK HERE>                           131      35       35       35       194.131  35
\& <INDEX>                                   132      36       36       36       194.132  36
\& <NEXT LINE>                               133      21       37       37       194.133  37       ***
\& <START OF SELECTED AREA>                  134      6        6        6        194.134  6
\& <END OF SELECTED AREA>                    135      23       23       23       194.135  23
\& <CHARACTER TABULATION SET>                136      40       40       40       194.136  40
\& <CHARACTER TABULATION WITH JUSTIFICATION> 137      41       41       41       194.137  41
\& <LINE TABULATION SET>                     138      42       42       42       194.138  42
\& <PARTIAL LINE FORWARD>                    139      43       43       43       194.139  43
\& <PARTIAL LINE BACKWARD>                   140      44       44       44       194.140  44
\& <REVERSE LINE FEED>                       141      9        9        9        194.141  9
\& <SINGLE SHIFT TWO>                        142      10       10       10       194.142  10
\& <SINGLE SHIFT THREE>                      143      27       27       27       194.143  27
\& <DEVICE CONTROL STRING>                   144      48       48       48       194.144  48
\& <PRIVATE USE ONE>                         145      49       49       49       194.145  49
\& <PRIVATE USE TWO>                         146      26       26       26       194.146  26
\& <SET TRANSMIT STATE>                      147      51       51       51       194.147  51
\& <CANCEL CHARACTER>                        148      52       52       52       194.148  52
\& <MESSAGE WAITING>                         149      53       53       53       194.149  53
\& <START OF GUARDED AREA>                   150      54       54       54       194.150  54
\& <END OF GUARDED AREA>                     151      8        8        8        194.151  8
\& <START OF STRING>                         152      56       56       56       194.152  56
\& <SINGLE GRAPHIC CHARACTER INTRODUCER>     153      57       57       57       194.153  57
\& <SINGLE CHARACTER INTRODUCER>             154      58       58       58       194.154  58
\& <CONTROL SEQUENCE INTRODUCER>             155      59       59       59       194.155  59
\& <STRING TERMINATOR>                       156      4        4        4        194.156  4
\& <OPERATING SYSTEM COMMAND>                157      20       20       20       194.157  20
\& <PRIVACY MESSAGE>                         158      62       62       62       194.158  62
\& <APPLICATION PROGRAM COMMAND>             159      255      255      95       194.159  255      ###
\& <NON\-BREAKING SPACE>                      160      65       65       65       194.160  128.65
\& <INVERTED EXCLAMATION MARK>               161      170      170      170      194.161  128.66
\& <CENT SIGN>                               162      74       74       176      194.162  128.67   ###
\& <POUND SIGN>                              163      177      177      177      194.163  128.68
\& <CURRENCY SIGN>                           164      159      159      159      194.164  128.69
\& <YEN SIGN>                                165      178      178      178      194.165  128.70
\& <BROKEN BAR>                              166      106      106      208      194.166  128.71   ###
\& <SECTION SIGN>                            167      181      181      181      194.167  128.72
\& <DIAERESIS>                               168      189      187      121      194.168  128.73   *** ###
\& <COPYRIGHT SIGN>                          169      180      180      180      194.169  128.74
\& <FEMININE ORDINAL INDICATOR>              170      154      154      154      194.170  128.81
\& <LEFT POINTING GUILLEMET>                 171      138      138      138      194.171  128.82
\& <NOT SIGN>                                172      95       176      186      194.172  128.83   *** ###
\& <SOFT HYPHEN>                             173      202      202      202      194.173  128.84
\& <REGISTERED TRADE MARK SIGN>              174      175      175      175      194.174  128.85
\& <MACRON>                                  175      188      188      161      194.175  128.86   ###
\& <DEGREE SIGN>                             176      144      144      144      194.176  128.87
\& <PLUS\-OR\-MINUS SIGN>                      177      143      143      143      194.177  128.88
\& <SUPERSCRIPT TWO>                         178      234      234      234      194.178  128.89
\& <SUPERSCRIPT THREE>                       179      250      250      250      194.179  128.98
\& <ACUTE ACCENT>                            180      190      190      190      194.180  128.99
\& <MICRO SIGN>                              181      160      160      160      194.181  128.100
\& <PARAGRAPH SIGN>                          182      182      182      182      194.182  128.101
\& <MIDDLE DOT>                              183      179      179      179      194.183  128.102
\& <CEDILLA>                                 184      157      157      157      194.184  128.103
\& <SUPERSCRIPT ONE>                         185      218      218      218      194.185  128.104
\& <MASC. ORDINAL INDICATOR>                 186      155      155      155      194.186  128.105
\& <RIGHT POINTING GUILLEMET>                187      139      139      139      194.187  128.106
\& <FRACTION ONE QUARTER>                    188      183      183      183      194.188  128.112
\& <FRACTION ONE HALF>                       189      184      184      184      194.189  128.113
\& <FRACTION THREE QUARTERS>                 190      185      185      185      194.190  128.114
\& <INVERTED QUESTION MARK>                  191      171      171      171      194.191  128.115
\& <A WITH GRAVE>                            192      100      100      100      195.128  138.65
\& <A WITH ACUTE>                            193      101      101      101      195.129  138.66
\& <A WITH CIRCUMFLEX>                       194      98       98       98       195.130  138.67
\& <A WITH TILDE>                            195      102      102      102      195.131  138.68
\& <A WITH DIAERESIS>                        196      99       99       99       195.132  138.69
\& <A WITH RING ABOVE>                       197      103      103      103      195.133  138.70
\& <CAPITAL LIGATURE AE>                     198      158      158      158      195.134  138.71
\& <C WITH CEDILLA>                          199      104      104      104      195.135  138.72
\& <E WITH GRAVE>                            200      116      116      116      195.136  138.73
\& <E WITH ACUTE>                            201      113      113      113      195.137  138.74
\& <E WITH CIRCUMFLEX>                       202      114      114      114      195.138  138.81
\& <E WITH DIAERESIS>                        203      115      115      115      195.139  138.82
\& <I WITH GRAVE>                            204      120      120      120      195.140  138.83
\& <I WITH ACUTE>                            205      117      117      117      195.141  138.84
\& <I WITH CIRCUMFLEX>                       206      118      118      118      195.142  138.85
\& <I WITH DIAERESIS>                        207      119      119      119      195.143  138.86
\& <CAPITAL LETTER ETH>                      208      172      172      172      195.144  138.87
\& <N WITH TILDE>                            209      105      105      105      195.145  138.88
\& <O WITH GRAVE>                            210      237      237      237      195.146  138.89
\& <O WITH ACUTE>                            211      238      238      238      195.147  138.98
\& <O WITH CIRCUMFLEX>                       212      235      235      235      195.148  138.99
\& <O WITH TILDE>                            213      239      239      239      195.149  138.100
\& <O WITH DIAERESIS>                        214      236      236      236      195.150  138.101
\& <MULTIPLICATION SIGN>                     215      191      191      191      195.151  138.102
\& <O WITH STROKE>                           216      128      128      128      195.152  138.103
\& <U WITH GRAVE>                            217      253      253      224      195.153  138.104  ###
\& <U WITH ACUTE>                            218      254      254      254      195.154  138.105
\& <U WITH CIRCUMFLEX>                       219      251      251      221      195.155  138.106  ###
\& <U WITH DIAERESIS>                        220      252      252      252      195.156  138.112
\& <Y WITH ACUTE>                            221      173      186      173      195.157  138.113  *** ###
\& <CAPITAL LETTER THORN>                    222      174      174      174      195.158  138.114
\& <SMALL LETTER SHARP S>                    223      89       89       89       195.159  138.115
\& <a WITH GRAVE>                            224      68       68       68       195.160  139.65
\& <a WITH ACUTE>                            225      69       69       69       195.161  139.66
\& <a WITH CIRCUMFLEX>                       226      66       66       66       195.162  139.67
\& <a WITH TILDE>                            227      70       70       70       195.163  139.68
\& <a WITH DIAERESIS>                        228      67       67       67       195.164  139.69
\& <a WITH RING ABOVE>                       229      71       71       71       195.165  139.70
\& <SMALL LIGATURE ae>                       230      156      156      156      195.166  139.71
\& <c WITH CEDILLA>                          231      72       72       72       195.167  139.72
\& <e WITH GRAVE>                            232      84       84       84       195.168  139.73
\& <e WITH ACUTE>                            233      81       81       81       195.169  139.74
\& <e WITH CIRCUMFLEX>                       234      82       82       82       195.170  139.81
\& <e WITH DIAERESIS>                        235      83       83       83       195.171  139.82
\& <i WITH GRAVE>                            236      88       88       88       195.172  139.83
\& <i WITH ACUTE>                            237      85       85       85       195.173  139.84
\& <i WITH CIRCUMFLEX>                       238      86       86       86       195.174  139.85
\& <i WITH DIAERESIS>                        239      87       87       87       195.175  139.86
\& <SMALL LETTER eth>                        240      140      140      140      195.176  139.87
\& <n WITH TILDE>                            241      73       73       73       195.177  139.88
\& <o WITH GRAVE>                            242      205      205      205      195.178  139.89
\& <o WITH ACUTE>                            243      206      206      206      195.179  139.98
\& <o WITH CIRCUMFLEX>                       244      203      203      203      195.180  139.99
\& <o WITH TILDE>                            245      207      207      207      195.181  139.100
\& <o WITH DIAERESIS>                        246      204      204      204      195.182  139.101
\& <DIVISION SIGN>                           247      225      225      225      195.183  139.102
\& <o WITH STROKE>                           248      112      112      112      195.184  139.103
\& <u WITH GRAVE>                            249      221      221      192      195.185  139.104  ###
\& <u WITH ACUTE>                            250      222      222      222      195.186  139.105
\& <u WITH CIRCUMFLEX>                       251      219      219      219      195.187  139.106
\& <u WITH DIAERESIS>                        252      220      220      220      195.188  139.112
\& <y WITH ACUTE>                            253      141      141      141      195.189  139.113
\& <SMALL LETTER thorn>                      254      142      142      142      195.190  139.114
\& <y WITH DIAERESIS>                        255      223      223      223      195.191  139.115
.Ve
.PP
If you would rather see the above table in \s-1CCSID\s0 0037 order rather than
\&\s-1ASCII\s0 + Latin\-1 order then run the table through:
.IP "recipe 4" 4
.IX Item "recipe 4"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{43}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,52,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in \s-1CCSID\s0 1047 order then change the number
52 in the last line to 61, like this:
.IP "recipe 5" 4
.IX Item "recipe 5"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{43}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}/)\*(Aq\e
\&    \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&    \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&    \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&    \-e \*(Aq          map{[$_,substr($_,61,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in POSIX-BC order then change the number
61 in the last line to 70, like this:
.IP "recipe 6" 4
.IX Item "recipe 6"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{43}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}\es{6,8}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,70,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.SH "IDENTIFYING CHARACTER CODE SETS"
.IX Header "IDENTIFYING CHARACTER CODE SETS"
To determine the character set you are running under from perl one 
could use the return value of \fIord()\fR or \fIchr()\fR to test one or more 
character values.  For example:
.PP
.Vb 2
\&    $is_ascii  = "A" eq chr(65);
\&    $is_ebcdic = "A" eq chr(193);
.Ve
.PP
Also, \*(L"\et\*(R" is a \f(CW\*(C`HORIZONTAL TABULATION\*(C'\fR character so that:
.PP
.Vb 2
\&    $is_ascii  = ord("\et") == 9;
\&    $is_ebcdic = ord("\et") == 5;
.Ve
.PP
To distinguish \s-1EBCDIC\s0 code pages try looking at one or more of
the characters that differ between them.  For example:
.PP
.Vb 2
\&    $is_ebcdic_37   = "\en" eq chr(37);
\&    $is_ebcdic_1047 = "\en" eq chr(21);
.Ve
.PP
Or better still choose a character that is uniquely encoded in any
of the code sets, e.g.:
.PP
.Vb 4
\&    $is_ascii           = ord(\*(Aq[\*(Aq) == 91;
\&    $is_ebcdic_37       = ord(\*(Aq[\*(Aq) == 186;
\&    $is_ebcdic_1047     = ord(\*(Aq[\*(Aq) == 173;
\&    $is_ebcdic_POSIX_BC = ord(\*(Aq[\*(Aq) == 187;
.Ve
.PP
However, it would be unwise to write tests such as:
.PP
.Vb 2
\&    $is_ascii = "\er" ne chr(13);  #  WRONG
\&    $is_ascii = "\en" ne chr(10);  #  ILL ADVISED
.Ve
.PP
Obviously the first of these will fail to distinguish most \s-1ASCII\s0 platforms
from either a \s-1CCSID\s0 0037, a 1047, or a POSIX-BC \s-1EBCDIC\s0 platform since \*(L"\er\*(R" eq 
chr(13) under all of those coded character sets.  But note too that 
because \*(L"\en\*(R" is chr(13) and \*(L"\er\*(R" is chr(10) on the Macintosh (which is an 
\&\s-1ASCII\s0 platform) the second \f(CW$is_ascii\fR test will lead to trouble there.
.PP
To determine whether or not perl was built under an \s-1EBCDIC\s0 
code page you can use the Config module like so:
.PP
.Vb 2
\&    use Config;
\&    $is_ebcdic = $Config{\*(Aqebcdic\*(Aq} eq \*(Aqdefine\*(Aq;
.Ve
.SH "CONVERSIONS"
.IX Header "CONVERSIONS"
.SS "tr///"
.IX Subsection "tr///"
In order to convert a string of characters from one character set to 
another a simple list of numbers, such as in the right columns in the
above table, along with perl's tr/// operator is all that is needed.  
The data in the table are in ASCII/Latin1 order, hence the \s-1EBCDIC\s0 columns
provide easy-to-use ASCII/Latin1 to \s-1EBCDIC\s0 operations that are also easily 
reversed.
.PP
For example, to convert ASCII/Latin1 to code page 037 take the output of the
second numbers column from the output of recipe 2 (modified to add '\e'
characters) and use it in tr/// like so:
.PP
.Vb 10
\&    $cp_037 = 
\&    \*(Aq\ex00\ex01\ex02\ex03\ex37\ex2D\ex2E\ex2F\ex16\ex05\ex25\ex0B\ex0C\ex0D\ex0E\ex0F\*(Aq .
\&    \*(Aq\ex10\ex11\ex12\ex13\ex3C\ex3D\ex32\ex26\ex18\ex19\ex3F\ex27\ex1C\ex1D\ex1E\ex1F\*(Aq .
\&    \*(Aq\ex40\ex5A\ex7F\ex7B\ex5B\ex6C\ex50\ex7D\ex4D\ex5D\ex5C\ex4E\ex6B\ex60\ex4B\ex61\*(Aq .
\&    \*(Aq\exF0\exF1\exF2\exF3\exF4\exF5\exF6\exF7\exF8\exF9\ex7A\ex5E\ex4C\ex7E\ex6E\ex6F\*(Aq .
\&    \*(Aq\ex7C\exC1\exC2\exC3\exC4\exC5\exC6\exC7\exC8\exC9\exD1\exD2\exD3\exD4\exD5\exD6\*(Aq .
\&    \*(Aq\exD7\exD8\exD9\exE2\exE3\exE4\exE5\exE6\exE7\exE8\exE9\exBA\exE0\exBB\exB0\ex6D\*(Aq .
\&    \*(Aq\ex79\ex81\ex82\ex83\ex84\ex85\ex86\ex87\ex88\ex89\ex91\ex92\ex93\ex94\ex95\ex96\*(Aq .
\&    \*(Aq\ex97\ex98\ex99\exA2\exA3\exA4\exA5\exA6\exA7\exA8\exA9\exC0\ex4F\exD0\exA1\ex07\*(Aq .
\&    \*(Aq\ex20\ex21\ex22\ex23\ex24\ex15\ex06\ex17\ex28\ex29\ex2A\ex2B\ex2C\ex09\ex0A\ex1B\*(Aq .
\&    \*(Aq\ex30\ex31\ex1A\ex33\ex34\ex35\ex36\ex08\ex38\ex39\ex3A\ex3B\ex04\ex14\ex3E\exFF\*(Aq .
\&    \*(Aq\ex41\exAA\ex4A\exB1\ex9F\exB2\ex6A\exB5\exBD\exB4\ex9A\ex8A\ex5F\exCA\exAF\exBC\*(Aq .
\&    \*(Aq\ex90\ex8F\exEA\exFA\exBE\exA0\exB6\exB3\ex9D\exDA\ex9B\ex8B\exB7\exB8\exB9\exAB\*(Aq .
\&    \*(Aq\ex64\ex65\ex62\ex66\ex63\ex67\ex9E\ex68\ex74\ex71\ex72\ex73\ex78\ex75\ex76\ex77\*(Aq .
\&    \*(Aq\exAC\ex69\exED\exEE\exEB\exEF\exEC\exBF\ex80\exFD\exFE\exFB\exFC\exAD\exAE\ex59\*(Aq .
\&    \*(Aq\ex44\ex45\ex42\ex46\ex43\ex47\ex9C\ex48\ex54\ex51\ex52\ex53\ex58\ex55\ex56\ex57\*(Aq .
\&    \*(Aq\ex8C\ex49\exCD\exCE\exCB\exCF\exCC\exE1\ex70\exDD\exDE\exDB\exDC\ex8D\ex8E\exDF\*(Aq;
\&
\&    my $ebcdic_string = $ascii_string;
\&    eval \*(Aq$ebcdic_string =~ tr/\e000\-\e377/\*(Aq . $cp_037 . \*(Aq/\*(Aq;
.Ve
.PP
To convert from \s-1EBCDIC\s0 037 to \s-1ASCII\s0 just reverse the order of the tr///
arguments like so:
.PP
.Vb 2
\&    my $ascii_string = $ebcdic_string;
\&    eval \*(Aq$ascii_string =~ tr/\*(Aq . $cp_037 . \*(Aq/\e000\-\e377/\*(Aq;
.Ve
.PP
Similarly one could take the output of the third numbers column from recipe 2
to obtain a \f(CW$cp_1047\fR table.  The fourth numbers column of the output from
recipe 2 could provide a \f(CW$cp_posix_bc\fR table suitable for transcoding as
well.
.PP
If you wanted to see the inverse tables, you would first have to sort on the
desired numbers column as in recipes 4, 5 or 6, then take the output of the
first numbers column.
.SS "iconv"
.IX Subsection "iconv"
\&\s-1XPG\s0 operability often implies the presence of an \fIiconv\fR utility
available from the shell or from the C library.  Consult your system's
documentation for information on iconv.
.PP
On \s-1OS/390\s0 or z/OS see the \fIiconv\fR\|(1) manpage.  One way to invoke the iconv 
shell utility from within perl would be to:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ascii_data = \`echo \*(Aq$ebcdic_data\*(Aq| iconv \-f IBM\-1047 \-t ISO8859\-1\`
.Ve
.PP
or the inverse map:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ebcdic_data = \`echo \*(Aq$ascii_data\*(Aq| iconv \-f ISO8859\-1 \-t IBM\-1047\`
.Ve
.PP
For other perl-based conversion options see the Convert::* modules on \s-1CPAN\s0.
.SS "C \s-1RTL\s0"
.IX Subsection "C RTL"
The \s-1OS/390\s0 and z/OS C run-time libraries provide \fI_atoe()\fR and \fI_etoa()\fR functions.
.SH "OPERATOR DIFFERENCES"
.IX Header "OPERATOR DIFFERENCES"
The \f(CW\*(C`..\*(C'\fR range operator treats certain character ranges with 
care on \s-1EBCDIC\s0 platforms.  For example the following array
will have twenty six elements on either an \s-1EBCDIC\s0 platform
or an \s-1ASCII\s0 platform:
.PP
.Vb 1
\&    @alphabet = (\*(AqA\*(Aq..\*(AqZ\*(Aq);   #  $#alphabet == 25
.Ve
.PP
The bitwise operators such as & ^ | may return different results
when operating on string or character data in a perl program running 
on an \s-1EBCDIC\s0 platform than when run on an \s-1ASCII\s0 platform.  Here is
an example adapted from the one in perlop:
.PP
.Vb 5
\&    # EBCDIC\-based examples
\&    print "j p \en" ^ " a h";                      # prints "JAPH\en"
\&    print "JA" | "  ph\en";                        # prints "japh\en" 
\&    print "JAPH\enJunk" & "\e277\e277\e277\e277\e277";  # prints "japh\en";
\&    print \*(Aqp N$\*(Aq ^ " E<H\en";                      # prints "Perl\en";
.Ve
.PP
An interesting property of the 32 C0 control characters
in the \s-1ASCII\s0 table is that they can \*(L"literally\*(R" be constructed
as control characters in perl, e.g. \f(CW\*(C`(chr(0)\*(C'\fR eq \f(CW\*(C`\ec@\*(C'\fR)>
\&\f(CW\*(C`(chr(1)\*(C'\fR eq \f(CW\*(C`\ecA\*(C'\fR)>, and so on.  Perl on \s-1EBCDIC\s0 platforms has been
ported to take \f(CW\*(C`\ec@\*(C'\fR to \fIchr\fR\|(0) and \f(CW\*(C`\ecA\*(C'\fR to \fIchr\fR\|(1), etc. as well, but the
thirty three characters that result depend on which code page you are
using.  The table below uses the standard acronyms for the controls.
The POSIX-BC and 1047 sets are
identical throughout this range and differ from the 0037 set at only 
one spot (21 decimal).  Note that the \f(CW\*(C`LINE FEED\*(C'\fR character
may be generated by \f(CW\*(C`\ecJ\*(C'\fR on \s-1ASCII\s0 platforms but by \f(CW\*(C`\ecU\*(C'\fR on 1047 or POSIX-BC 
platforms and cannot be generated as a \f(CW"\ec.letter."\fR control character on 
0037 platforms.  Note also that \f(CW\*(C`\ec\e\*(C'\fR cannot be the final element in a string
or regex, as it will absorb the terminator.   But \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR is a \f(CW\*(C`FILE
SEPARATOR\*(C'\fR concatenated with \fIX\fR for all \fIX\fR.
.PP
.Vb 10
\& chr   ord   8859\-1    0037    1047 && POSIX\-BC     
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& \ec?   127   <DEL>       "            "    
\& \ec@     0   <NUL>     <NUL>        <NUL>
\& \ecA     1   <SOH>     <SOH>        <SOH> 
\& \ecB     2   <STX>     <STX>        <STX>
\& \ecC     3   <ETX>     <ETX>        <ETX>
\& \ecD     4   <EOT>     <ST>         <ST>    
\& \ecE     5   <ENQ>     <HT>         <HT>    
\& \ecF     6   <ACK>     <SSA>        <SSA>    
\& \ecG     7   <BEL>     <DEL>        <DEL>   
\& \ecH     8   <BS>      <EPA>        <EPA>  
\& \ecI     9   <HT>      <RI>         <RI>   
\& \ecJ    10   <LF>      <SS2>        <SS2>  
\& \ecK    11   <VT>      <VT>         <VT>
\& \ecL    12   <FF>      <FF>         <FF>    
\& \ecM    13   <CR>      <CR>         <CR> 
\& \ecN    14   <SO>      <SO>         <SO>
\& \ecO    15   <SI>      <SI>         <SI>
\& \ecP    16   <DLE>     <DLE>        <DLE> 
\& \ecQ    17   <DC1>     <DC1>        <DC1>
\& \ecR    18   <DC2>     <DC2>        <DC2>
\& \ecS    19   <DC3>     <DC3>        <DC3> 
\& \ecT    20   <DC4>     <OSC>        <OSC>   
\& \ecU    21   <NAK>     <NEL>        <LF>              ***
\& \ecV    22   <SYN>     <BS>         <BS>
\& \ecW    23   <ETB>     <ESA>        <ESA> 
\& \ecX    24   <CAN>     <CAN>        <CAN>
\& \ecY    25   <EOM>     <EOM>        <EOM>
\& \ecZ    26   <SUB>     <PU2>        <PU2>  
\& \ec[    27   <ESC>     <SS3>        <SS3>  
\& \ec\eX   28   <FS>X     <FS>X        <FS>X
\& \ec]    29   <GS>      <GS>         <GS>
\& \ec^    30   <RS>      <RS>         <RS>
\& \ec_    31   <US>      <US>         <US>
.Ve
.SH "FUNCTION DIFFERENCES"
.IX Header "FUNCTION DIFFERENCES"
.IP "\fIchr()\fR" 8
.IX Item "chr()"
\&\fIchr()\fR must be given an \s-1EBCDIC\s0 code number argument to yield a desired 
character return value on an \s-1EBCDIC\s0 platform.  For example:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = chr(193);
.Ve
.IP "\fIord()\fR" 8
.IX Item "ord()"
\&\fIord()\fR will return \s-1EBCDIC\s0 code number values on an \s-1EBCDIC\s0 platform.
For example:
.Sp
.Vb 1
\&    $the_number_193 = ord("A");
.Ve
.IP "\fIpack()\fR" 8
.IX Item "pack()"
The c and C templates for \fIpack()\fR are dependent upon character set 
encoding.  Examples of usage on \s-1EBCDIC\s0 include:
.Sp
.Vb 4
\&    $foo = pack("CCCC",193,194,195,196);
\&    # $foo eq "ABCD"
\&    $foo = pack("C4",193,194,195,196);
\&    # same thing
\&
\&    $foo = pack("ccxxcc",193,194,195,196);
\&    # $foo eq "AB\e0\e0CD"
.Ve
.IP "\fIprint()\fR" 8
.IX Item "print()"
One must be careful with scalars and strings that are passed to
print that contain \s-1ASCII\s0 encodings.  One common place
for this to occur is in the output of the \s-1MIME\s0 type header for
\&\s-1CGI\s0 script writing.  For example, many perl programming guides 
recommend something similar to:
.Sp
.Vb 2
\&    print "Content\-type:\ettext/html\e015\e012\e015\e012"; 
\&    # this may be wrong on EBCDIC
.Ve
.Sp
Under the \s-1IBM\s0 \s-1OS/390\s0 \s-1USS\s0 Web Server or WebSphere on z/OS for example 
you should instead write that as:
.Sp
.Vb 1
\&    print "Content\-type:\ettext/html\er\en\er\en"; # OK for DGW et al
.Ve
.Sp
That is because the translation from \s-1EBCDIC\s0 to \s-1ASCII\s0 is done
by the web server in this case (such code will not be appropriate for
the Macintosh however).  Consult your web server's documentation for 
further details.
.IP "\fIprintf()\fR" 8
.IX Item "printf()"
The formats that can convert characters to numbers and vice versa
will be different from their \s-1ASCII\s0 counterparts when executed
on an \s-1EBCDIC\s0 platform.  Examples include:
.Sp
.Vb 1
\&    printf("%c%c%c",193,194,195);  # prints ABC
.Ve
.IP "\fIsort()\fR" 8
.IX Item "sort()"
\&\s-1EBCDIC\s0 sort results may differ from \s-1ASCII\s0 sort results especially for 
mixed case strings.  This is discussed in more detail below.
.IP "\fIsprintf()\fR" 8
.IX Item "sprintf()"
See the discussion of \fIprintf()\fR above.  An example of the use
of sprintf would be:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = sprintf("%c",193);
.Ve
.IP "\fIunpack()\fR" 8
.IX Item "unpack()"
See the discussion of \fIpack()\fR above.
.SH "REGULAR EXPRESSION DIFFERENCES"
.IX Header "REGULAR EXPRESSION DIFFERENCES"
As of perl 5.005_03 the letter range regular expressions such as 
[A\-Z] and [a\-z] have been especially coded to not pick up gap 
characters.  For example, characters such as o\*^ \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR 
that lie between I and J would not be matched by the 
regular expression range \f(CW\*(C`/[H\-K]/\*(C'\fR.  This works in
the other direction, too, if either of the range end points is
explicitly numeric: \f(CW\*(C`[\ex89\-\ex91]\*(C'\fR will match \f(CW\*(C`\ex8e\*(C'\fR, even
though \f(CW\*(C`\ex89\*(C'\fR is \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`\ex91 \*(C'\fR is \f(CW\*(C`j\*(C'\fR, and \f(CW\*(C`\ex8e\*(C'\fR
is a gap character from the alphabetic viewpoint.
.PP
If you do want to match the alphabet gap characters in a single octet 
regular expression try matching the hex or octal code such 
as \f(CW\*(C`/\e313/\*(C'\fR on \s-1EBCDIC\s0 or \f(CW\*(C`/\e364/\*(C'\fR on \s-1ASCII\s0 platforms to 
have your regular expression match \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR.
.PP
Another construct to be wary of is the inappropriate use of hex or
octal constants in regular expressions.  Consider the following
set of subs:
.PP
.Vb 4
\&    sub is_c0 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e000\-\e037]/;
\&    }
\&
\&    sub is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e040\-\e176]/;
\&    }
\&
\&    sub is_delete {
\&        my $char = substr(shift,0,1);
\&        $char eq "\e177";
\&    }
\&
\&    sub is_c1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e200\-\e237]/;
\&    }
\&
\&    sub is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e240\-\e377]/;
\&    }
.Ve
.PP
The above would be adequate if the concern was only with numeric code points.
However, the concern may be with characters rather than code points 
and on an \s-1EBCDIC\s0 platform it may be desirable for constructs such as 
\&\f(CW\*(C`if (is_print_ascii("A")) {print "A is a printable character\en";}\*(C'\fR to print
out the expected message.  One way to represent the above collection
of character classification subs that is capable of working across the
four coded character sets discussed in this document is as follows:
.PP
.Vb 12
\&    sub Is_c0 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e000\-\e037]/;
\&        } 
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e045\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95 || ord(\*(Aq^\*(Aq)==106) { # 1047 || posix\-bc
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e025\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&    }
\&
\&    sub Is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<=>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~]/;
\&    }
\&
\&    sub Is_delete {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char eq "\e177";
\&        }
\&        else  {              # ebcdic
\&            return $char eq "\e007";
\&        }
\&    }
\&
\&    sub Is_c1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e200\-\e237]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e040\-\e044\e025\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~ /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~ 
\&              /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e137]/;
\&        }
\&    }
\&
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e240\-\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ 
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e275\e264\e232\e212\e137\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e273\e264\e232\e212\e260\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e272\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/; 
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~ 
\&              /[\e101\e252\e260\e261\e237\e262\e320\e265\e171\e264\e232\e212\e272\e312\e257\e241\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e340\e376\e335\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e300\e336\e333\e334\e215\e216\e337]/;
\&        }
\&    }
.Ve
.PP
Note however that only the \f(CW\*(C`Is_ascii_print()\*(C'\fR sub is really independent 
of coded character set.  Another way to write \f(CW\*(C`Is_latin_1()\*(C'\fR would be 
to use the characters in the range explicitly:
.PP
.Vb 4
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\ XXXXXXXXXXXX\%XXXXXXXXXXXXXXXXXXA\*`A\*'A\*^A\*~A\*:A\*o\*(AEC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:XO\*/U\*`U\*'U\*^U\*:Y\*'\*(Th\*8a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:Xo\*/u\*`u\*'u\*^u\*:y\*'\*(thy\*:]/;
\&    }
.Ve
.PP
Although that form may run into trouble in network transit (due to the 
presence of 8 bit characters) or on non ISO-Latin character sets.
.SH "SOCKETS"
.IX Header "SOCKETS"
Most socket programming assumes \s-1ASCII\s0 character encodings in network
byte order.  Exceptions can include \s-1CGI\s0 script writing under a
host web server where the server may take care of translation for you.
Most host web servers convert \s-1EBCDIC\s0 data to \s-1ISO\-8859\-1\s0 or Unicode on
output.
.SH "SORTING"
.IX Header "SORTING"
One big difference between ASCII-based character sets and \s-1EBCDIC\s0 ones
are the relative positions of upper and lower case letters and the
letters compared to the digits.  If sorted on an ASCII-based platform the
two-letter abbreviation for a physician comes before the two letter
abbreviation for drive; that is:
.PP
.Vb 2
\& @sorted = sort(qw(Dr. dr.));  # @sorted holds (\*(AqDr.\*(Aq,\*(Aqdr.\*(Aq) on ASCII,
\&                                  # but (\*(Aqdr.\*(Aq,\*(AqDr.\*(Aq) on EBCDIC
.Ve
.PP
The property of lowercase before uppercase letters in \s-1EBCDIC\s0 is
even carried to the Latin 1 \s-1EBCDIC\s0 pages such as 0037 and 1047.
An example would be that E\*: \f(CW\*(C`E WITH DIAERESIS\*(C'\fR (203) comes 
before e\*: \f(CW\*(C`e WITH DIAERESIS\*(C'\fR (235) on an \s-1ASCII\s0 platform, but 
the latter (83) comes before the former (115) on an \s-1EBCDIC\s0 platform.  
(Astute readers will note that the uppercase version of \*8 
\&\f(CW\*(C`SMALL LETTER SHARP S\*(C'\fR is simply \*(L"\s-1SS\s0\*(R" and that the upper case version of 
y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR is not in the 0..255 range but it is 
at U+x0178 in Unicode, or \f(CW"\ex{178}"\fR in a Unicode enabled Perl).
.PP
The sort order will cause differences between results obtained on
\&\s-1ASCII\s0 platforms versus \s-1EBCDIC\s0 platforms.  What follows are some suggestions
on how to deal with these differences.
.SS "Ignore \s-1ASCII\s0 vs. \s-1EBCDIC\s0 sort differences."
.IX Subsection "Ignore ASCII vs. EBCDIC sort differences."
This is the least computationally expensive strategy.  It may require
some user education.
.SS "\s-1MONO\s0 \s-1CASE\s0 then sort data."
.IX Subsection "MONO CASE then sort data."
In order to minimize the expense of mono casing mixed-case text, try to
\&\f(CW\*(C`tr///\*(C'\fR towards the character set case most employed within the data.
If the data are primarily \s-1UPPERCASE\s0 non Latin 1 then apply tr/[a\-z]/[A\-Z]/
then \fIsort()\fR.  If the data are primarily lowercase non Latin 1 then
apply tr/[A\-Z]/[a\-z]/ before sorting.  If the data are primarily \s-1UPPERCASE\s0
and include Latin\-1 characters then apply:
.PP
.Vb 3
\&    tr/[a\-z]/[A\-Z]/;
\&    tr/[a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:o\*/u\*`u\*'u\*^u\*:y\*'\*(th]/[A\*`A\*'A\*^A\*~A\*:A\*o\*(AEC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:O\*/U\*`U\*'U\*^U\*:Y\*'\*(Th/;
\&    s/\*8/SS/g;
.Ve
.PP
then \fIsort()\fR.  Do note however that such Latin\-1 manipulation does not 
address the y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR character that will remain at 
code point 255 on \s-1ASCII\s0 platforms, but 223 on most \s-1EBCDIC\s0 platforms 
where it will sort to a place less than the \s-1EBCDIC\s0 numerals.  With a 
Unicode-enabled Perl you might try:
.PP
.Vb 1
\&    tr/^?/\ex{178}/;
.Ve
.PP
The strategy of mono casing data before sorting does not preserve the case 
of the data and may not be acceptable for that reason.
.SS "Convert, sort data, then re convert."
.IX Subsection "Convert, sort data, then re convert."
This is the most expensive proposition that does not employ a network
connection.
.SS "Perform sorting on one type of platform only."
.IX Subsection "Perform sorting on one type of platform only."
This strategy can employ a network connection.  As such
it would be computationally expensive.
.SH "TRANSFORMATION FORMATS"
.IX Header "TRANSFORMATION FORMATS"
There are a variety of ways of transforming data with an intra character set 
mapping that serve a variety of purposes.  Sorting was discussed in the 
previous section and a few of the other more popular mapping techniques are 
discussed next.
.SS "\s-1URL\s0 decoding and encoding"
.IX Subsection "URL decoding and encoding"
Note that some URLs have hexadecimal \s-1ASCII\s0 code points in them in an
attempt to overcome character or protocol limitation issues.  For example 
the tilde character is not on every keyboard hence a \s-1URL\s0 of the form:
.PP
.Vb 1
\&    http://www.pvhp.com/~pvhp/
.Ve
.PP
may also be expressed as either of:
.PP
.Vb 1
\&    http://www.pvhp.com/%7Epvhp/
\&
\&    http://www.pvhp.com/%7epvhp/
.Ve
.PP
where 7E is the hexadecimal \s-1ASCII\s0 code point for '~'.  Here is an example
of decoding such a \s-1URL\s0 under \s-1CCSID\s0 1047:
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/%7Epvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @a2e_1047 = (
\&          0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
\&         64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
\&        240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
\&        124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
\&        215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
\&        121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
\&        151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,  7,
\&         32, 33, 34, 35, 36, 37,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
\&         48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,255,
\&         65,170, 74,177,159,178,106,181,187,180,154,138,176,202,175,188,
\&        144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
\&        100,101, 98,102, 99,103,158,104,116,113,114,115,120,117,118,119,
\&        172,105,237,238,235,239,236,191,128,253,254,251,252,186,174, 89,
\&         68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86, 87,
\&        140, 73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
\&    );
\&    $url =~ s/%([0\-9a\-fA\-F]{2})/pack("c",$a2e_1047[hex($1)])/ge;
.Ve
.PP
Conversely, here is a partial solution for the task of encoding such 
a \s-1URL\s0 under the 1047 code page:
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/~pvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @e2a_1047 = (
\&          0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19,157, 10,  8,135, 24, 25,146,143, 28, 29, 30, 31,
\&        128,129,130,131,132,133, 23, 27,136,137,138,139,140,  5,  6,  7,
\&        144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
\&         32,160,226,228,224,225,227,229,231,241,162, 46, 60, 40, 43,124,
\&         38,233,234,235,232,237,238,239,236,223, 33, 36, 42, 41, 59, 94,
\&         45, 47,194,196,192,193,195,197,199,209,166, 44, 37, 95, 62, 63,
\&        248,201,202,203,200,205,206,207,204, 96, 58, 35, 64, 39, 61, 34,
\&        216, 97, 98, 99,100,101,102,103,104,105,171,187,240,253,254,177,
\&        176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,
\&        181,126,115,116,117,118,119,120,121,122,161,191,208, 91,222,174,
\&        172,163,165,183,169,167,182,188,189,190,221,168,175, 93,180,215,
\&        123, 65, 66, 67, 68, 69, 70, 71, 72, 73,173,244,246,242,243,245,
\&        125, 74, 75, 76, 77, 78, 79, 80, 81, 82,185,251,252,249,250,255,
\&         92,247, 83, 84, 85, 86, 87, 88, 89, 90,178,212,214,210,211,213,
\&         48, 49, 50, 51, 52, 53, 54, 55, 56, 57,179,219,220,217,218,159
\&    );
\&    # The following regular expression does not address the 
\&    # mappings for: (\*(Aq.\*(Aq => \*(Aq%2E\*(Aq, \*(Aq/\*(Aq => \*(Aq%2F\*(Aq, \*(Aq:\*(Aq => \*(Aq%3A\*(Aq) 
\&    $url =~ s/([\et "#%&\e(\e),;<=>\e?\e@\e[\e\e\e]^\`{|}~])/sprintf("%%%02X",$e2a_1047[ord($1)])/ge;
.Ve
.PP
where a more complete solution would split the \s-1URL\s0 into components 
and apply a full s/// substitution only to the appropriate parts.
.PP
In the remaining examples a \f(CW@e2a\fR or \f(CW@a2e\fR array may be employed
but the assignment will not be shown explicitly.  For code page 1047
you could use the \f(CW@a2e_1047\fR or \f(CW@e2a_1047\fR arrays just shown.
.SS "uu encoding and decoding"
.IX Subsection "uu encoding and decoding"
The \f(CW\*(C`u\*(C'\fR template to \fIpack()\fR or \fIunpack()\fR will render \s-1EBCDIC\s0 data in \s-1EBCDIC\s0 
characters equivalent to their \s-1ASCII\s0 counterparts.  For example, the 
following will print \*(L"Yes indeed\en\*(R" on either an \s-1ASCII\s0 or \s-1EBCDIC\s0 computer:
.PP
.Vb 10
\&    $all_byte_chrs = \*(Aq\*(Aq;
\&    for (0..255) { $all_byte_chrs .= chr($_); }
\&    $uuencode_byte_chrs = pack(\*(Aqu\*(Aq, $all_byte_chrs);
\&    ($uu = <<\*(AqENDOFHEREDOC\*(Aq) =~ s/^\es*//gm;
\&    M\`\`$"\`P0%!@<("0H+#\`T.#Q\`1$A,4%187&!D:&QP=\*(AqA\e@(2(C)"4F)R@I*BLL
\&    M+2XO,#$R,S0U\-C<X.3H[/#T^/T!!0D\-$149\*(Aq2$E*2TQ\-3D]045)35%565UA9
\&    M6EM<75Y?8&%B8V1E9F=H:6IK;&UN;W!Q<G\-T=79W>\*(AqEZ>WQ]?G^\`@8*#A(6&
\&    MAXB)BHN,C8Z/D)&2DY25EI>8F9J;G)V>GZ"AHJ.DI::GJ*FJJZRMKJ^PL;*S
\&    MM+6VM[BYNKN\eO;Z_P,\*(Aq"P\e3%QL?(R<K+S,W.S]#1TM/4U=;7V\-G:V]S=WM_@
\&    ?X>+CY.7FY^CIZNOL[>[O\e/\*(AqR\e_3U]O?X^?K[_/W^_P\`\`
\&    ENDOFHEREDOC
\&    if ($uuencode_byte_chrs eq $uu) {
\&        print "Yes ";
\&    }
\&    $uudecode_byte_chrs = unpack(\*(Aqu\*(Aq, $uuencode_byte_chrs);
\&    if ($uudecode_byte_chrs eq $all_byte_chrs) {
\&        print "indeed\en";
\&    }
.Ve
.PP
Here is a very spartan uudecoder that will work on \s-1EBCDIC\s0 provided
that the \f(CW@e2a\fR array is filled in appropriately:
.PP
.Vb 10
\&    #!/usr/local/bin/perl
\&    @e2a = ( # this must be filled in
\&           );
\&    $_ = <> until ($mode,$file) = /^begin\es*(\ed*)\es*(\eS*)/;
\&    open(OUT, "> $file") if $file ne "";
\&    while(<>) {
\&        last if /^end/;
\&        next if /[a\-z]/;
\&        next unless int(((($e2a[ord()] \- 32 ) & 077) + 2) / 3) ==
\&            int(length() / 4);
\&        print OUT unpack("u", $_);
\&    }
\&    close(OUT);
\&    chmod oct($mode), $file;
.Ve
.SS "Quoted-Printable encoding and decoding"
.IX Subsection "Quoted-Printable encoding and decoding"
On ASCII-encoded platforms it is possible to strip characters outside of
the printable set using:
.PP
.Vb 2
\&    # This QP encoder works on ASCII only
\&    $qp_string =~ s/([=\ex00\-\ex1F\ex80\-\exFF])/sprintf("=%02X",ord($1))/ge;
.Ve
.PP
Whereas a \s-1QP\s0 encoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms 
would look somewhat like the following (where the \s-1EBCDIC\s0 branch \f(CW@e2a\fR 
array is omitted for brevity):
.PP
.Vb 10
\&    if (ord(\*(AqA\*(Aq) == 65) {    # ASCII
\&        $delete = "\ex7F";    # ASCII
\&        @e2a = (0 .. 255)    # ASCII to ASCII identity map
\&    }
\&    else {                   # EBCDIC
\&        $delete = "\ex07";    # EBCDIC
\&        @e2a =               # EBCDIC to ASCII map (as shown above)
\&    }
\&    $qp_string =~
\&      s/([^ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~$delete])/sprintf("=%02X",$e2a[ord($1)])/ge;
.Ve
.PP
(although in production code the substitutions might be done
in the \s-1EBCDIC\s0 branch with the \f(CW@e2a\fR array and separately in the 
\&\s-1ASCII\s0 branch without the expense of the identity map).
.PP
Such \s-1QP\s0 strings can be decoded with:
.PP
.Vb 3
\&    # This QP decoder is limited to ASCII only
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr hex $1/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.PP
Whereas a \s-1QP\s0 decoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms 
would look somewhat like the following (where the \f(CW@a2e\fR array is
omitted for brevity):
.PP
.Vb 2
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr $a2e[hex $1]/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.SS "Caesarean ciphers"
.IX Subsection "Caesarean ciphers"
The practice of shifting an alphabet one or more characters for encipherment
dates back thousands of years and was explicitly detailed by Gaius Julius
Caesar in his \fBGallic Wars\fR text.  A single alphabet shift is sometimes 
referred to as a rotation and the shift amount is given as a number \f(CW$n\fR after
the string 'rot' or \*(L"rot$n\*(R".  Rot0 and rot26 would designate identity maps 
on the 26\-letter English version of the Latin alphabet.  Rot13 has the 
interesting property that alternate subsequent invocations are identity maps 
(thus rot13 is its own non-trivial inverse in the group of 26 alphabet 
rotations).  Hence the following is a rot13 encoder and decoder that will 
work on \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms:
.PP
.Vb 1
\&    #!/usr/local/bin/perl
\&
\&    while(<>){
\&        tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;
\&        print;
\&    }
.Ve
.PP
In one-liner form:
.PP
.Vb 1
\&    perl \-ne \*(Aqtr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;print\*(Aq
.Ve
.SH "Hashing order and checksums"
.IX Header "Hashing order and checksums"
To the extent that it is possible to write code that depends on 
hashing order there may be differences between hashes as stored
on an ASCII-based platform and hashes stored on an EBCDIC-based platform.
\&\s-1XXX\s0
.SH "I18N AND L10N"
.IX Header "I18N AND L10N"
Internationalization (I18N) and localization (L10N) are supported at least 
in principle even on \s-1EBCDIC\s0 platforms.  The details are system-dependent 
and discussed under the \*(L"\s-1OS\s0 \s-1ISSUES\s0\*(R" in perlebcdic section below.
.SH "MULTI-OCTET CHARACTER SETS"
.IX Header "MULTI-OCTET CHARACTER SETS"
Perl may work with an internal UTF-EBCDIC encoding form for wide characters 
on \s-1EBCDIC\s0 platforms in a manner analogous to the way that it works with 
the \s-1UTF\-8\s0 internal encoding form on \s-1ASCII\s0 based platforms.
.PP
Legacy multi byte \s-1EBCDIC\s0 code pages \s-1XXX\s0.
.SH "OS ISSUES"
.IX Header "OS ISSUES"
There may be a few system-dependent issues 
of concern to \s-1EBCDIC\s0 Perl programmers.
.SS "\s-1OS/400\s0"
.IX Subsection "OS/400"
.IP "\s-1PASE\s0" 8
.IX Item "PASE"
The \s-1PASE\s0 environment is a runtime environment for \s-1OS/400\s0 that can run
executables built for PowerPC \s-1AIX\s0 in \s-1OS/400\s0; see perlos400.  \s-1PASE\s0
is ASCII-based, not EBCDIC-based as the \s-1ILE\s0.
.IP "\s-1IFS\s0 access" 8
.IX Item "IFS access"
\&\s-1XXX\s0.
.SS "\s-1OS/390\s0, z/OS"
.IX Subsection "OS/390, z/OS"
Perl runs under Unix Systems Services or \s-1USS\s0.
.IP "chcp" 8
.IX Item "chcp"
\&\fBchcp\fR is supported as a shell utility for displaying and changing 
one's code page.  See also \fIchcp\fR\|(1).
.IP "dataset access" 8
.IX Item "dataset access"
For sequential data set access try:
.Sp
.Vb 1
\&    my @ds_records = \`cat //DSNAME\`;
.Ve
.Sp
or:
.Sp
.Vb 1
\&    my @ds_records = \`cat //\*(AqHLQ.DSNAME\*(Aq\`;
.Ve
.Sp
See also the OS390::Stdio module on \s-1CPAN\s0.
.IP "\s-1OS/390\s0, z/OS iconv" 8
.IX Item "OS/390, z/OS iconv"
\&\fBiconv\fR is supported as both a shell utility and a C \s-1RTL\s0 routine.
See also the \fIiconv\fR\|(1) and \fIiconv\fR\|(3) manual pages.
.IP "locales" 8
.IX Item "locales"
On \s-1OS/390\s0 or z/OS see locale for information on locales.  The L10N files
are in \fI/usr/nls/locale\fR.  \f(CW$Config\fR{d_setlocale} is 'define' on \s-1OS/390\s0
or z/OS.
.SS "\s-1VM/ESA\s0?"
.IX Subsection "VM/ESA?"
\&\s-1XXX\s0.
.SS "POSIX-BC?"
.IX Subsection "POSIX-BC?"
\&\s-1XXX\s0.
.SH "BUGS"
.IX Header "BUGS"
This pod document contains literal Latin 1 characters and may encounter 
translation difficulties.  In particular one popular nroff implementation 
was known to strip accented characters to their unaccented counterparts 
while attempting to view this document through the \fBpod2man\fR program 
(for example, you may see a plain \f(CW\*(C`y\*(C'\fR rather than one with a diaeresis 
as in y\*:).  Another nroff truncated the resultant manpage at
the first occurrence of 8 bit characters.
.PP
Not all shells will allow multiple \f(CW\*(C`\-e\*(C'\fR string arguments to perl to
be concatenated together properly as recipes 0, 2, 4, 5, and 6 might 
seem to imply.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perllocale, perlfunc, perlunicode, utf8.
.SH "REFERENCES"
.IX Header "REFERENCES"
<http://anubis.dkuug.dk/i18n/charmaps>
.PP
<http://www.unicode.org/>
.PP
<http://www.unicode.org/unicode/reports/tr16/>
.PP
<http://www.wps.com/projects/codes/>
\&\fB\s-1ASCII:\s0 American Standard Code for Information Infiltration\fR Tom Jennings,
September 1999.
.PP
\&\fBThe Unicode Standard, Version 3.0\fR The Unicode Consortium, Lisa Moore ed., 
\&\s-1ISBN\s0 0\-201\-61633\-5, Addison Wesley Developers Press, February 2000.
.PP
\&\fB\s-1CDRA:\s0 \s-1IBM\s0 \- Character Data Representation Architecture \- 
Reference and Registry\fR, \s-1IBM\s0 \s-1SC09\-2190\-00\s0, December 1996.
.PP
\&\*(L"Demystifying Character Sets\*(R", Andrea Vine, Multilingual Computing 
& Technology, \fB#26 Vol. 10 Issue 4\fR, August/September 1999;
\&\s-1ISSN\s0 1523\-0309; Multilingual Computing Inc. Sandpoint \s-1ID\s0, \s-1USA\s0.
.PP
\&\fBCodes, Ciphers, and Other Cryptic and Clandestine Communication\fR
Fred B. Wrixon, \s-1ISBN\s0 1\-57912\-040\-7, Black Dog & Leventhal Publishers,
1998.
.PP
http://www.bobbemer.com/P\-BIT.HTM <http://www.bobbemer.com/P-BIT.HTM>
\&\fB\s-1IBM\s0 \- \s-1EBCDIC\s0 and the P\-bit; The biggest Computer Goof Ever\fR Robert Bemer.
.SH "HISTORY"
.IX Header "HISTORY"
15 April 2001: added \s-1UTF\-8\s0 and UTF-EBCDIC to main table, pvhp.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer pvhp@best.com wrote this in 1999 and 2000 
with \s-1CCSID\s0 0819 and 0037 help from Chris Leach and 
Andre\*' Pirard A.Pirard@ulg.ac.be as well as POSIX-BC 
help from Thomas Dorner Thomas.Dorner@start.de.
Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and 
Joe Smith.  Trademarks, registered trademarks, service marks and 
registered service marks used in this document are the property of 
their respective owners.
                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlebcdic5.18.1                             0100644 0001750 0001750 00000220313 12566207436 023354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEBCDIC 1"
.TH PERLEBCDIC 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlebcdic \- Considerations for running Perl on EBCDIC platforms
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
An exploration of some of the issues facing Perl programmers
on \s-1EBCDIC\s0 based computers.  We do not cover localization,
internationalization, or multi-byte character set issues other
than some discussion of \s-1UTF\-8\s0 and UTF-EBCDIC.
.PP
Portions that are still incomplete are marked with \s-1XXX.\s0
.PP
Perl used to work on \s-1EBCDIC\s0 machines, but there are now areas of the code where
it doesn't.  If you want to use Perl on an \s-1EBCDIC\s0 machine, please let us know
by sending mail to perlbug@perl.org
.SH "COMMON CHARACTER CODE SETS"
.IX Header "COMMON CHARACTER CODE SETS"
.SS "\s-1ASCII\s0"
.IX Subsection "ASCII"
The American Standard Code for Information Interchange (\s-1ASCII\s0 or US-ASCII) is a
set of
integers running from 0 to 127 (decimal) that imply character
interpretation by the display and other systems of computers.
The range 0..127 can be covered by setting the bits in a 7\-bit binary
digit, hence the set is sometimes referred to as \*(L"7\-bit \s-1ASCII\*(R".
ASCII\s0 was described by the American National Standards Institute
document \s-1ANSI X3.4\-1986. \s0 It was also described by \s-1ISO 646:1991
\&\s0(with localization for currency symbols).  The full \s-1ASCII\s0 set is
given in the table below as the first 128 elements.  Languages that
can be written adequately with the characters in \s-1ASCII\s0 include
English, Hawaiian, Indonesian, Swahili and some Native American
languages.
.PP
There are many character sets that extend the range of integers
from 0..2**7\-1 up to 2**8\-1, or 8 bit bytes (octets if you prefer).
One common one is the \s-1ISO 8859\-1\s0 character set.
.SS "\s-1ISO 8859\s0"
.IX Subsection "ISO 8859"
The \s-1ISO\s0 8859\-$n are a collection of character code sets from the
International Organization for Standardization (\s-1ISO\s0), each of which
adds characters to the \s-1ASCII\s0 set that are typically found in European
languages, many of which are based on the Roman, or Latin, alphabet.
.SS "Latin 1 (\s-1ISO 8859\-1\s0)"
.IX Subsection "Latin 1 (ISO 8859-1)"
A particular 8\-bit extension to \s-1ASCII\s0 that includes grave and acute
accented Latin characters.  Languages that can employ \s-1ISO 8859\-1\s0
include all the languages covered by \s-1ASCII\s0 as well as Afrikaans,
Albanian, Basque, Catalan, Danish, Faroese, Finnish, Norwegian,
Portuguese, Spanish, and Swedish.  Dutch is covered albeit without
the ij ligature.  French is covered too but without the oe ligature.
German can use \s-1ISO 8859\-1\s0 but must do so without German-style
quotation marks.  This set is based on Western European extensions
to \s-1ASCII\s0 and is commonly encountered in world wide web work.
In \s-1IBM\s0 character code set identification terminology \s-1ISO 8859\-1\s0 is
also known as \s-1CCSID 819 \s0(or sometimes 0819 or even 00819).
.SS "\s-1EBCDIC\s0"
.IX Subsection "EBCDIC"
The Extended Binary Coded Decimal Interchange Code refers to a
large collection of single\- and multi-byte coded character sets that are
different from \s-1ASCII\s0 or \s-1ISO 8859\-1\s0 and are all slightly different from each
other; they typically run on host computers.  The \s-1EBCDIC\s0 encodings derive from
8\-bit byte extensions of Hollerith punched card encodings.  The layout on the
cards was such that high bits were set for the upper and lower case alphabet
characters [a\-z] and [A\-Z], but there were gaps within each Latin alphabet
range.
.PP
Some \s-1IBM EBCDIC\s0 character sets may be known by character code set
identification numbers (\s-1CCSID\s0 numbers) or code page numbers.
.PP
Perl can be compiled on platforms that run any of three commonly used \s-1EBCDIC\s0
character sets, listed below.
.PP
\fIThe 13 variant characters\fR
.IX Subsection "The 13 variant characters"
.PP
Among \s-1IBM EBCDIC\s0 character code sets there are 13 characters that
are often mapped to different integer values.  Those characters
are known as the 13 \*(L"variant\*(R" characters and are:
.PP
.Vb 1
\&    \e [ ] { } ^ ~ ! # | $ @ \`
.Ve
.PP
When Perl is compiled for a platform, it looks at some of these characters to
guess which \s-1EBCDIC\s0 character set the platform uses, and adapts itself
accordingly to that platform.  If the platform uses a character set that is not
one of the three Perl knows about, Perl will either fail to compile, or
mistakenly and silently choose one of the three.
They are:
.IP "\fB0037\fR" 4
.IX Item "0037"
Character code set \s-1ID 0037\s0 is a mapping of the \s-1ASCII\s0 plus Latin\-1
characters (i.e. \s-1ISO 8859\-1\s0) to an \s-1EBCDIC\s0 set.  0037 is used
in North American English locales on the \s-1OS/400\s0 operating system
that runs on \s-1AS/400\s0 computers.  \s-1CCSID 0037\s0 differs from \s-1ISO 8859\-1\s0
in 237 places, in other words they agree on only 19 code point values.
.IP "\fB1047\fR" 4
.IX Item "1047"
Character code set \s-1ID 1047\s0 is also a mapping of the \s-1ASCII\s0 plus
Latin\-1 characters (i.e. \s-1ISO 8859\-1\s0) to an \s-1EBCDIC\s0 set.  1047 is
used under Unix System Services for \s-1OS/390\s0 or z/OS, and OpenEdition
for \s-1VM/ESA.  CCSID 1047\s0 differs from \s-1CCSID 0037\s0 in eight places.
.IP "\fBPOSIX-BC\fR" 4
.IX Item "POSIX-BC"
The \s-1EBCDIC\s0 code page in use on Siemens' \s-1BS2000\s0 system is distinct from
1047 and 0037.  It is identified below as the POSIX-BC set.
.SS "Unicode code points versus \s-1EBCDIC\s0 code points"
.IX Subsection "Unicode code points versus EBCDIC code points"
In Unicode terminology a \fIcode point\fR is the number assigned to a
character: for example, in \s-1EBCDIC\s0 the character \*(L"A\*(R" is usually assigned
the number 193.  In Unicode the character \*(L"A\*(R" is assigned the number 65.
This causes a problem with the semantics of the pack/unpack \*(L"U\*(R", which
are supposed to pack Unicode code points to characters and back to numbers.
The problem is: which code points to use for code points less than 256?
(for 256 and over there's no problem: Unicode code points are used)
In \s-1EBCDIC,\s0 for the low 256 the \s-1EBCDIC\s0 code points are used.  This
means that the equivalences
.PP
.Vb 2
\&    pack("U", ord($character)) eq $character
\&    unpack("U", $character) == ord $character
.Ve
.PP
will hold.  (If Unicode code points were applied consistently over
all the possible code points, pack(\*(L"U\*(R",ord(\*(L"A\*(R")) would in \s-1EBCDIC\s0
equal \fIA with acute\fR or chr(101), and unpack(\*(L"U\*(R", \*(L"A\*(R") would equal
65, or \fInon-breaking space\fR, not 193, or ord \*(L"A\*(R".)
.SS "Remaining Perl Unicode problems in \s-1EBCDIC\s0"
.IX Subsection "Remaining Perl Unicode problems in EBCDIC"
.IP "\(bu" 4
Many of the remaining problems seem to be related to case-insensitive matching
.IP "\(bu" 4
The extensions Unicode::Collate and Unicode::Normalized are not
supported under \s-1EBCDIC,\s0 likewise for the encoding pragma.
.SS "Unicode and \s-1UTF\s0"
.IX Subsection "Unicode and UTF"
\&\s-1UTF\s0 stands for \f(CW\*(C`Unicode Transformation Format\*(C'\fR.
\&\s-1UTF\-8\s0 is an encoding of Unicode into a sequence of 8\-bit byte chunks, based on
\&\s-1ASCII\s0 and Latin\-1.
The length of a sequence required to represent a Unicode code point
depends on the ordinal number of that code point,
with larger numbers requiring more bytes.
UTF-EBCDIC is like \s-1UTF\-8,\s0 but based on \s-1EBCDIC.\s0
.PP
You may see the term \f(CW\*(C`invariant\*(C'\fR character or code point.
This simply means that the character has the same numeric
value when encoded as when not.
(Note that this is a very different concept from \*(L"The 13 variant characters\*(R"
mentioned above.)
For example, the ordinal value of 'A' is 193 in most \s-1EBCDIC\s0 code pages,
and also is 193 when encoded in UTF-EBCDIC.
All variant code points occupy at least two bytes when encoded.
In \s-1UTF\-8,\s0 the code points corresponding to the lowest 128
ordinal numbers (0 \- 127: the \s-1ASCII\s0 characters) are invariant.
In UTF-EBCDIC, there are 160 invariant characters.
(If you care, the \s-1EBCDIC\s0 invariants are those characters
which have \s-1ASCII\s0 equivalents, plus those that correspond to
the C1 controls (80..9f on \s-1ASCII\s0 platforms).)
.PP
A string encoded in UTF-EBCDIC may be longer (but never shorter) than
one encoded in \s-1UTF\-8.\s0
.SS "Using Encode"
.IX Subsection "Using Encode"
Starting from Perl 5.8 you can use the standard new module Encode
to translate from \s-1EBCDIC\s0 to Latin\-1 code points.
Encode knows about more \s-1EBCDIC\s0 character sets than Perl can currently
be compiled to run on.
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is in EBCDIC code points
\&   from_to($a, $ebcdic{ord \*(Aq^\*(Aq}, \*(Aqlatin1\*(Aq);
\&   # $a is ISO 8859\-1 code points
.Ve
.PP
and from Latin\-1 code points to \s-1EBCDIC\s0 code points
.PP
.Vb 1
\&   use Encode \*(Aqfrom_to\*(Aq;
\&
\&   my %ebcdic = ( 176 => \*(Aqcp37\*(Aq, 95 => \*(Aqcp1047\*(Aq, 106 => \*(Aqposix\-bc\*(Aq );
\&
\&   # $a is ISO 8859\-1 code points
\&   from_to($a, \*(Aqlatin1\*(Aq, $ebcdic{ord \*(Aq^\*(Aq});
\&   # $a is in EBCDIC code points
.Ve
.PP
For doing I/O it is suggested that you use the autotranslating features
of PerlIO, see perluniintro.
.PP
Since version 5.8 Perl uses the new PerlIO I/O library.  This enables
you to use different encodings per \s-1IO\s0 channel.  For example you may use
.PP
.Vb 9
\&    use Encode;
\&    open($f, ">:encoding(ascii)", "test.ascii");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(cp37)", "test.ebcdic");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(latin1)", "test.latin1");
\&    print $f "Hello World!\en";
\&    open($f, ">:encoding(utf8)", "test.utf8");
\&    print $f "Hello World!\en";
.Ve
.PP
to get four files containing \*(L"Hello World!\en\*(R" in \s-1ASCII, CP 0037 EBCDIC,
ISO 8859\-1 \s0(Latin\-1) (in this example identical to \s-1ASCII\s0 since only \s-1ASCII\s0
characters were printed), and
UTF-EBCDIC (in this example identical to normal \s-1EBCDIC\s0 since only characters
that don't differ between \s-1EBCDIC\s0 and UTF-EBCDIC were printed).  See the
documentation of Encode::PerlIO for details.
.PP
As the PerlIO layer uses raw \s-1IO \s0(bytes) internally, all this totally
ignores things like the type of your filesystem (\s-1ASCII\s0 or \s-1EBCDIC\s0).
.SH "SINGLE OCTET TABLES"
.IX Header "SINGLE OCTET TABLES"
The following tables list the \s-1ASCII\s0 and Latin 1 ordered sets including
the subsets: C0 controls (0..31), \s-1ASCII\s0 graphics (32..7e), delete (7f),
C1 controls (80..9f), and Latin\-1 (a.k.a. \s-1ISO 8859\-1\s0) (a0..ff).  In the
table names of the Latin 1
extensions to \s-1ASCII\s0 have been labelled with character names roughly
corresponding to \fIThe Unicode Standard, Version 6.1\fR albeit with
substitutions such as s/LATIN// and s/VULGAR// in all cases, s/CAPITAL
\&\s-1LETTER//\s0 in some cases, and s/SMALL \s-1LETTER \s0([A\-Z])/\el$1/ in some other
cases.  Controls are listed using their Unicode 6.1 abbreviatons.
The differences between the 0037 and 1047 sets are
flagged with **.  The differences between the 1047 and POSIX-BC sets
are flagged with ##.  All \fIord()\fR numbers listed are decimal.  If you
would rather see this table listing octal values, then run the table
(that is, the pod source text of this document, since this recipe may not
work with a pod2_other_format translation) through:
.IP "recipe 0" 4
.IX Item "recipe 0"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-5.03o%\-5.03o%\-5.03o%.03o\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
If you want to retain the UTF-x code points then in script form you
might want to write:
.IP "recipe 1" 4
.IX Item "recipe 1"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-3o.%\-5o%\-3o.%.03o\en",
\&                                            $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-3o.%\-5o%.03o\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-5.03o%\-5.03o%\-5.03o%\-5.03o%\-5.03o%.03o\en",
\&                                                $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
.Ve
.PP
If you would rather see this table listing hexadecimal values then
run the table through:
.IP "recipe 2" 4
.IX Item "recipe 2"
.PP
.Vb 3
\&    perl \-ne \*(Aqif(/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)/)\*(Aq \e
\&     \-e \*(Aq{printf("%s%\-5.02X%\-5.02X%\-5.02X%.02X\en",$1,$2,$3,$4,$5)}\*(Aq \e
\&     perlebcdic.pod
.Ve
.PP
Or, in order to retain the UTF-x code points in hexadecimal:
.IP "recipe 3" 4
.IX Item "recipe 3"
.PP
.Vb 10
\& open(FH,"<perlebcdic.pod") or die "Could not open perlebcdic.pod: $!";
\& while (<FH>) {
\&     if (/(.{29})(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\es+(\ed+)\e.?(\ed*)\es+(\ed+)\e.?(\ed*)/)
\&     {
\&         if ($7 ne \*(Aq\*(Aq && $9 ne \*(Aq\*(Aq) {
\&             printf(
\&                "%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-2X.%\-6.02X%02X.%02X\en",
\&                                           $1,$2,$3,$4,$5,$6,$7,$8,$9);
\&         }
\&         elsif ($7 ne \*(Aq\*(Aq) {
\&             printf("%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-2X.%\-6.02X%02X\en",
\&                                              $1,$2,$3,$4,$5,$6,$7,$8);
\&         }
\&         else {
\&             printf("%s%\-5.02X%\-5.02X%\-5.02X%\-5.02X%\-5.02X%02X\en",
\&                                                  $1,$2,$3,$4,$5,$6,$8);
\&         }
\&     }
\& }
\&
\&
\&                          ISO
\&                         8859\-1             POS\-
\&                         CCSID  CCSID CCSID IX\-
\&  chr                     0819   0037 1047  BC  UTF\-8  UTF\-EBCDIC
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& <NUL>                       0    0    0    0    0        0
\& <SOH>                       1    1    1    1    1        1
\& <STX>                       2    2    2    2    2        2
\& <ETX>                       3    3    3    3    3        3
\& <EOT>                       4    55   55   55   4        55
\& <ENQ>                       5    45   45   45   5        45
\& <ACK>                       6    46   46   46   6        46
\& <BEL>                       7    47   47   47   7        47
\& <BS>                        8    22   22   22   8        22
\& <HT>                        9    5    5    5    9        5
\& <LF>                        10   37   21   21   10       21  **
\& <VT>                        11   11   11   11   11       11
\& <FF>                        12   12   12   12   12       12
\& <CR>                        13   13   13   13   13       13
\& <SO>                        14   14   14   14   14       14
\& <SI>                        15   15   15   15   15       15
\& <DLE>                       16   16   16   16   16       16
\& <DC1>                       17   17   17   17   17       17
\& <DC2>                       18   18   18   18   18       18
\& <DC3>                       19   19   19   19   19       19
\& <DC4>                       20   60   60   60   20       60
\& <NAK>                       21   61   61   61   21       61
\& <SYN>                       22   50   50   50   22       50
\& <ETB>                       23   38   38   38   23       38
\& <CAN>                       24   24   24   24   24       24
\& <EOM>                       25   25   25   25   25       25
\& <SUB>                       26   63   63   63   26       63
\& <ESC>                       27   39   39   39   27       39
\& <FS>                        28   28   28   28   28       28
\& <GS>                        29   29   29   29   29       29
\& <RS>                        30   30   30   30   30       30
\& <US>                        31   31   31   31   31       31
\& <SPACE>                     32   64   64   64   32       64
\& !                           33   90   90   90   33       90
\& "                           34   127  127  127  34       127
\& #                           35   123  123  123  35       123
\& $                           36   91   91   91   36       91
\& %                           37   108  108  108  37       108
\& &                           38   80   80   80   38       80
\& \*(Aq                           39   125  125  125  39       125
\& (                           40   77   77   77   40       77
\& )                           41   93   93   93   41       93
\& *                           42   92   92   92   42       92
\& +                           43   78   78   78   43       78
\& ,                           44   107  107  107  44       107
\& \-                           45   96   96   96   45       96
\& .                           46   75   75   75   46       75
\& /                           47   97   97   97   47       97
\& 0                           48   240  240  240  48       240
\& 1                           49   241  241  241  49       241
\& 2                           50   242  242  242  50       242
\& 3                           51   243  243  243  51       243
\& 4                           52   244  244  244  52       244
\& 5                           53   245  245  245  53       245
\& 6                           54   246  246  246  54       246
\& 7                           55   247  247  247  55       247
\& 8                           56   248  248  248  56       248
\& 9                           57   249  249  249  57       249
\& :                           58   122  122  122  58       122
\& ;                           59   94   94   94   59       94
\& <                           60   76   76   76   60       76
\& =                           61   126  126  126  61       126
\& >                           62   110  110  110  62       110
\& ?                           63   111  111  111  63       111
\& @                           64   124  124  124  64       124
\& A                           65   193  193  193  65       193
\& B                           66   194  194  194  66       194
\& C                           67   195  195  195  67       195
\& D                           68   196  196  196  68       196
\& E                           69   197  197  197  69       197
\& F                           70   198  198  198  70       198
\& G                           71   199  199  199  71       199
\& H                           72   200  200  200  72       200
\& I                           73   201  201  201  73       201
\& J                           74   209  209  209  74       209
\& K                           75   210  210  210  75       210
\& L                           76   211  211  211  76       211
\& M                           77   212  212  212  77       212
\& N                           78   213  213  213  78       213
\& O                           79   214  214  214  79       214
\& P                           80   215  215  215  80       215
\& Q                           81   216  216  216  81       216
\& R                           82   217  217  217  82       217
\& S                           83   226  226  226  83       226
\& T                           84   227  227  227  84       227
\& U                           85   228  228  228  85       228
\& V                           86   229  229  229  86       229
\& W                           87   230  230  230  87       230
\& X                           88   231  231  231  88       231
\& Y                           89   232  232  232  89       232
\& Z                           90   233  233  233  90       233
\& [                           91   186  173  187  91       173  ** ##
\& \e                           92   224  224  188  92       224  ##
\& ]                           93   187  189  189  93       189  **
\& ^                           94   176  95   106  94       95   ** ##
\& _                           95   109  109  109  95       109
\& \`                           96   121  121  74   96       121  ##
\& a                           97   129  129  129  97       129
\& b                           98   130  130  130  98       130
\& c                           99   131  131  131  99       131
\& d                           100  132  132  132  100      132
\& e                           101  133  133  133  101      133
\& f                           102  134  134  134  102      134
\& g                           103  135  135  135  103      135
\& h                           104  136  136  136  104      136
\& i                           105  137  137  137  105      137
\& j                           106  145  145  145  106      145
\& k                           107  146  146  146  107      146
\& l                           108  147  147  147  108      147
\& m                           109  148  148  148  109      148
\& n                           110  149  149  149  110      149
\& o                           111  150  150  150  111      150
\& p                           112  151  151  151  112      151
\& q                           113  152  152  152  113      152
\& r                           114  153  153  153  114      153
\& s                           115  162  162  162  115      162
\& t                           116  163  163  163  116      163
\& u                           117  164  164  164  117      164
\& v                           118  165  165  165  118      165
\& w                           119  166  166  166  119      166
\& x                           120  167  167  167  120      167
\& y                           121  168  168  168  121      168
\& z                           122  169  169  169  122      169
\& {                           123  192  192  251  123      192  ##
\& |                           124  79   79   79   124      79
\& }                           125  208  208  253  125      208  ##
\& ~                           126  161  161  255  126      161  ##
\& <DEL>                       127  7    7    7    127      7
\& <PAD>                       128  32   32   32   194.128  32
\& <HOP>                       129  33   33   33   194.129  33
\& <BPH>                       130  34   34   34   194.130  34
\& <NBH>                       131  35   35   35   194.131  35
\& <IND>                       132  36   36   36   194.132  36
\& <NEL>                       133  21   37   37   194.133  37   **
\& <SSA>                       134  6    6    6    194.134  6
\& <ESA>                       135  23   23   23   194.135  23
\& <HTS>                       136  40   40   40   194.136  40
\& <HTJ>                       137  41   41   41   194.137  41
\& <VTS>                       138  42   42   42   194.138  42
\& <PLD>                       139  43   43   43   194.139  43
\& <PLU>                       140  44   44   44   194.140  44
\& <RI>                        141  9    9    9    194.141  9
\& <SS2>                       142  10   10   10   194.142  10
\& <SS3>                       143  27   27   27   194.143  27
\& <DCS>                       144  48   48   48   194.144  48
\& <PU1>                       145  49   49   49   194.145  49
\& <PU2>                       146  26   26   26   194.146  26
\& <STS>                       147  51   51   51   194.147  51
\& <CCH>                       148  52   52   52   194.148  52
\& <MW>                        149  53   53   53   194.149  53
\& <SPA>                       150  54   54   54   194.150  54
\& <EPA>                       151  8    8    8    194.151  8
\& <SOS>                       152  56   56   56   194.152  56
\& <SGC>                       153  57   57   57   194.153  57
\& <SCI>                       154  58   58   58   194.154  58
\& <CSI>                       155  59   59   59   194.155  59
\& <ST>                        156  4    4    4    194.156  4
\& <OSC>                       157  20   20   20   194.157  20
\& <PM>                        158  62   62   62   194.158  62
\& <APC>                       159  255  255  95   194.159  255      ##
\& <NON\-BREAKING SPACE>        160  65   65   65   194.160  128.65
\& <INVERTED "!" >             161  170  170  170  194.161  128.66
\& <CENT SIGN>                 162  74   74   176  194.162  128.67   ##
\& <POUND SIGN>                163  177  177  177  194.163  128.68
\& <CURRENCY SIGN>             164  159  159  159  194.164  128.69
\& <YEN SIGN>                  165  178  178  178  194.165  128.70
\& <BROKEN BAR>                166  106  106  208  194.166  128.71   ##
\& <SECTION SIGN>              167  181  181  181  194.167  128.72
\& <DIAERESIS>                 168  189  187  121  194.168  128.73   ** ##
\& <COPYRIGHT SIGN>            169  180  180  180  194.169  128.74
\& <FEMININE ORDINAL>          170  154  154  154  194.170  128.81
\& <LEFT POINTING GUILLEMET>   171  138  138  138  194.171  128.82
\& <NOT SIGN>                  172  95   176  186  194.172  128.83   ** ##
\& <SOFT HYPHEN>               173  202  202  202  194.173  128.84
\& <REGISTERED TRADE MARK>     174  175  175  175  194.174  128.85
\& <MACRON>                    175  188  188  161  194.175  128.86   ##
\& <DEGREE SIGN>               176  144  144  144  194.176  128.87
\& <PLUS\-OR\-MINUS SIGN>        177  143  143  143  194.177  128.88
\& <SUPERSCRIPT TWO>           178  234  234  234  194.178  128.89
\& <SUPERSCRIPT THREE>         179  250  250  250  194.179  128.98
\& <ACUTE ACCENT>              180  190  190  190  194.180  128.99
\& <MICRO SIGN>                181  160  160  160  194.181  128.100
\& <PARAGRAPH SIGN>            182  182  182  182  194.182  128.101
\& <MIDDLE DOT>                183  179  179  179  194.183  128.102
\& <CEDILLA>                   184  157  157  157  194.184  128.103
\& <SUPERSCRIPT ONE>           185  218  218  218  194.185  128.104
\& <MASC. ORDINAL INDICATOR>   186  155  155  155  194.186  128.105
\& <RIGHT POINTING GUILLEMET>  187  139  139  139  194.187  128.106
\& <FRACTION ONE QUARTER>      188  183  183  183  194.188  128.112
\& <FRACTION ONE HALF>         189  184  184  184  194.189  128.113
\& <FRACTION THREE QUARTERS>   190  185  185  185  194.190  128.114
\& <INVERTED QUESTION MARK>    191  171  171  171  194.191  128.115
\& <A WITH GRAVE>              192  100  100  100  195.128  138.65
\& <A WITH ACUTE>              193  101  101  101  195.129  138.66
\& <A WITH CIRCUMFLEX>         194  98   98   98   195.130  138.67
\& <A WITH TILDE>              195  102  102  102  195.131  138.68
\& <A WITH DIAERESIS>          196  99   99   99   195.132  138.69
\& <A WITH RING ABOVE>         197  103  103  103  195.133  138.70
\& <CAPITAL LIGATURE AE>       198  158  158  158  195.134  138.71
\& <C WITH CEDILLA>            199  104  104  104  195.135  138.72
\& <E WITH GRAVE>              200  116  116  116  195.136  138.73
\& <E WITH ACUTE>              201  113  113  113  195.137  138.74
\& <E WITH CIRCUMFLEX>         202  114  114  114  195.138  138.81
\& <E WITH DIAERESIS>          203  115  115  115  195.139  138.82
\& <I WITH GRAVE>              204  120  120  120  195.140  138.83
\& <I WITH ACUTE>              205  117  117  117  195.141  138.84
\& <I WITH CIRCUMFLEX>         206  118  118  118  195.142  138.85
\& <I WITH DIAERESIS>          207  119  119  119  195.143  138.86
\& <CAPITAL LETTER ETH>        208  172  172  172  195.144  138.87
\& <N WITH TILDE>              209  105  105  105  195.145  138.88
\& <O WITH GRAVE>              210  237  237  237  195.146  138.89
\& <O WITH ACUTE>              211  238  238  238  195.147  138.98
\& <O WITH CIRCUMFLEX>         212  235  235  235  195.148  138.99
\& <O WITH TILDE>              213  239  239  239  195.149  138.100
\& <O WITH DIAERESIS>          214  236  236  236  195.150  138.101
\& <MULTIPLICATION SIGN>       215  191  191  191  195.151  138.102
\& <O WITH STROKE>             216  128  128  128  195.152  138.103
\& <U WITH GRAVE>              217  253  253  224  195.153  138.104  ##
\& <U WITH ACUTE>              218  254  254  254  195.154  138.105
\& <U WITH CIRCUMFLEX>         219  251  251  221  195.155  138.106  ##
\& <U WITH DIAERESIS>          220  252  252  252  195.156  138.112
\& <Y WITH ACUTE>              221  173  186  173  195.157  138.113  ** ##
\& <CAPITAL LETTER THORN>      222  174  174  174  195.158  138.114
\& <SMALL LETTER SHARP S>      223  89   89   89   195.159  138.115
\& <a WITH GRAVE>              224  68   68   68   195.160  139.65
\& <a WITH ACUTE>              225  69   69   69   195.161  139.66
\& <a WITH CIRCUMFLEX>         226  66   66   66   195.162  139.67
\& <a WITH TILDE>              227  70   70   70   195.163  139.68
\& <a WITH DIAERESIS>          228  67   67   67   195.164  139.69
\& <a WITH RING ABOVE>         229  71   71   71   195.165  139.70
\& <SMALL LIGATURE ae>         230  156  156  156  195.166  139.71
\& <c WITH CEDILLA>            231  72   72   72   195.167  139.72
\& <e WITH GRAVE>              232  84   84   84   195.168  139.73
\& <e WITH ACUTE>              233  81   81   81   195.169  139.74
\& <e WITH CIRCUMFLEX>         234  82   82   82   195.170  139.81
\& <e WITH DIAERESIS>          235  83   83   83   195.171  139.82
\& <i WITH GRAVE>              236  88   88   88   195.172  139.83
\& <i WITH ACUTE>              237  85   85   85   195.173  139.84
\& <i WITH CIRCUMFLEX>         238  86   86   86   195.174  139.85
\& <i WITH DIAERESIS>          239  87   87   87   195.175  139.86
\& <SMALL LETTER eth>          240  140  140  140  195.176  139.87
\& <n WITH TILDE>              241  73   73   73   195.177  139.88
\& <o WITH GRAVE>              242  205  205  205  195.178  139.89
\& <o WITH ACUTE>              243  206  206  206  195.179  139.98
\& <o WITH CIRCUMFLEX>         244  203  203  203  195.180  139.99
\& <o WITH TILDE>              245  207  207  207  195.181  139.100
\& <o WITH DIAERESIS>          246  204  204  204  195.182  139.101
\& <DIVISION SIGN>             247  225  225  225  195.183  139.102
\& <o WITH STROKE>             248  112  112  112  195.184  139.103
\& <u WITH GRAVE>              249  221  221  192  195.185  139.104  ##
\& <u WITH ACUTE>              250  222  222  222  195.186  139.105
\& <u WITH CIRCUMFLEX>         251  219  219  219  195.187  139.106
\& <u WITH DIAERESIS>          252  220  220  220  195.188  139.112
\& <y WITH ACUTE>              253  141  141  141  195.189  139.113
\& <SMALL LETTER thorn>        254  142  142  142  195.190  139.114
\& <y WITH DIAERESIS>          255  223  223  223  195.191  139.115
.Ve
.PP
If you would rather see the above table in \s-1CCSID 0037\s0 order rather than
\&\s-1ASCII +\s0 Latin\-1 order then run the table through:
.IP "recipe 4" 4
.IX Item "recipe 4"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,34,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in \s-1CCSID 1047\s0 order then change the number
34 in the last line to 39, like this:
.IP "recipe 5" 4
.IX Item "recipe 5"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&    \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&    \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&    \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&    \-e \*(Aq          map{[$_,substr($_,39,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.PP
If you would rather see it in POSIX-BC order then change the number
39 in the last line to 44, like this:
.IP "recipe 6" 4
.IX Item "recipe 6"
.PP
.Vb 6
\& perl \e
\&    \-ne \*(Aqif(/.{29}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}\es{2,4}\ed{1,3}/)\*(Aq\e
\&     \-e \*(Aq{push(@l,$_)}\*(Aq \e
\&     \-e \*(AqEND{print map{$_\->[0]}\*(Aq \e
\&     \-e \*(Aq          sort{$a\->[1] <=> $b\->[1]}\*(Aq \e
\&     \-e \*(Aq          map{[$_,substr($_,44,3)]}@l;}\*(Aq perlebcdic.pod
.Ve
.SH "IDENTIFYING CHARACTER CODE SETS"
.IX Header "IDENTIFYING CHARACTER CODE SETS"
To determine the character set you are running under from perl one
could use the return value of \fIord()\fR or \fIchr()\fR to test one or more
character values.  For example:
.PP
.Vb 2
\&    $is_ascii  = "A" eq chr(65);
\&    $is_ebcdic = "A" eq chr(193);
.Ve
.PP
Also, \*(L"\et\*(R" is a \f(CW\*(C`HORIZONTAL TABULATION\*(C'\fR character so that:
.PP
.Vb 2
\&    $is_ascii  = ord("\et") == 9;
\&    $is_ebcdic = ord("\et") == 5;
.Ve
.PP
To distinguish \s-1EBCDIC\s0 code pages try looking at one or more of
the characters that differ between them.  For example:
.PP
.Vb 2
\&    $is_ebcdic_37   = "\en" eq chr(37);
\&    $is_ebcdic_1047 = "\en" eq chr(21);
.Ve
.PP
Or better still choose a character that is uniquely encoded in any
of the code sets, e.g.:
.PP
.Vb 4
\&    $is_ascii           = ord(\*(Aq[\*(Aq) == 91;
\&    $is_ebcdic_37       = ord(\*(Aq[\*(Aq) == 186;
\&    $is_ebcdic_1047     = ord(\*(Aq[\*(Aq) == 173;
\&    $is_ebcdic_POSIX_BC = ord(\*(Aq[\*(Aq) == 187;
.Ve
.PP
However, it would be unwise to write tests such as:
.PP
.Vb 2
\&    $is_ascii = "\er" ne chr(13);  #  WRONG
\&    $is_ascii = "\en" ne chr(10);  #  ILL ADVISED
.Ve
.PP
Obviously the first of these will fail to distinguish most \s-1ASCII\s0 platforms
from either a \s-1CCSID 0037,\s0 a 1047, or a POSIX-BC \s-1EBCDIC\s0 platform since \*(L"\er\*(R" eq
chr(13) under all of those coded character sets.  But note too that
because \*(L"\en\*(R" is chr(13) and \*(L"\er\*(R" is chr(10) on the Macintosh (which is an
\&\s-1ASCII\s0 platform) the second \f(CW$is_ascii\fR test will lead to trouble there.
.PP
To determine whether or not perl was built under an \s-1EBCDIC\s0
code page you can use the Config module like so:
.PP
.Vb 2
\&    use Config;
\&    $is_ebcdic = $Config{\*(Aqebcdic\*(Aq} eq \*(Aqdefine\*(Aq;
.Ve
.SH "CONVERSIONS"
.IX Header "CONVERSIONS"
.ie n .SS """utf8::unicode_to_native()"" and ""utf8::native_to_unicode()"""
.el .SS "\f(CWutf8::unicode_to_native()\fP and \f(CWutf8::native_to_unicode()\fP"
.IX Subsection "utf8::unicode_to_native() and utf8::native_to_unicode()"
These functions take an input numeric code point in one encoding and
return what its equivalent value is in the other.
.SS "tr///"
.IX Subsection "tr///"
In order to convert a string of characters from one character set to
another a simple list of numbers, such as in the right columns in the
above table, along with perl's tr/// operator is all that is needed.
The data in the table are in ASCII/Latin1 order, hence the \s-1EBCDIC\s0 columns
provide easy-to-use ASCII/Latin1 to \s-1EBCDIC\s0 operations that are also easily
reversed.
.PP
For example, to convert ASCII/Latin1 to code page 037 take the output of the
second numbers column from the output of recipe 2 (modified to add '\e'
characters), and use it in tr/// like so:
.PP
.Vb 10
\&    $cp_037 =
\&    \*(Aq\ex00\ex01\ex02\ex03\ex37\ex2D\ex2E\ex2F\ex16\ex05\ex25\ex0B\ex0C\ex0D\ex0E\ex0F\*(Aq .
\&    \*(Aq\ex10\ex11\ex12\ex13\ex3C\ex3D\ex32\ex26\ex18\ex19\ex3F\ex27\ex1C\ex1D\ex1E\ex1F\*(Aq .
\&    \*(Aq\ex40\ex5A\ex7F\ex7B\ex5B\ex6C\ex50\ex7D\ex4D\ex5D\ex5C\ex4E\ex6B\ex60\ex4B\ex61\*(Aq .
\&    \*(Aq\exF0\exF1\exF2\exF3\exF4\exF5\exF6\exF7\exF8\exF9\ex7A\ex5E\ex4C\ex7E\ex6E\ex6F\*(Aq .
\&    \*(Aq\ex7C\exC1\exC2\exC3\exC4\exC5\exC6\exC7\exC8\exC9\exD1\exD2\exD3\exD4\exD5\exD6\*(Aq .
\&    \*(Aq\exD7\exD8\exD9\exE2\exE3\exE4\exE5\exE6\exE7\exE8\exE9\exBA\exE0\exBB\exB0\ex6D\*(Aq .
\&    \*(Aq\ex79\ex81\ex82\ex83\ex84\ex85\ex86\ex87\ex88\ex89\ex91\ex92\ex93\ex94\ex95\ex96\*(Aq .
\&    \*(Aq\ex97\ex98\ex99\exA2\exA3\exA4\exA5\exA6\exA7\exA8\exA9\exC0\ex4F\exD0\exA1\ex07\*(Aq .
\&    \*(Aq\ex20\ex21\ex22\ex23\ex24\ex15\ex06\ex17\ex28\ex29\ex2A\ex2B\ex2C\ex09\ex0A\ex1B\*(Aq .
\&    \*(Aq\ex30\ex31\ex1A\ex33\ex34\ex35\ex36\ex08\ex38\ex39\ex3A\ex3B\ex04\ex14\ex3E\exFF\*(Aq .
\&    \*(Aq\ex41\exAA\ex4A\exB1\ex9F\exB2\ex6A\exB5\exBD\exB4\ex9A\ex8A\ex5F\exCA\exAF\exBC\*(Aq .
\&    \*(Aq\ex90\ex8F\exEA\exFA\exBE\exA0\exB6\exB3\ex9D\exDA\ex9B\ex8B\exB7\exB8\exB9\exAB\*(Aq .
\&    \*(Aq\ex64\ex65\ex62\ex66\ex63\ex67\ex9E\ex68\ex74\ex71\ex72\ex73\ex78\ex75\ex76\ex77\*(Aq .
\&    \*(Aq\exAC\ex69\exED\exEE\exEB\exEF\exEC\exBF\ex80\exFD\exFE\exFB\exFC\exAD\exAE\ex59\*(Aq .
\&    \*(Aq\ex44\ex45\ex42\ex46\ex43\ex47\ex9C\ex48\ex54\ex51\ex52\ex53\ex58\ex55\ex56\ex57\*(Aq .
\&    \*(Aq\ex8C\ex49\exCD\exCE\exCB\exCF\exCC\exE1\ex70\exDD\exDE\exDB\exDC\ex8D\ex8E\exDF\*(Aq;
\&
\&    my $ebcdic_string = $ascii_string;
\&    eval \*(Aq$ebcdic_string =~ tr/\e000\-\e377/\*(Aq . $cp_037 . \*(Aq/\*(Aq;
.Ve
.PP
To convert from \s-1EBCDIC 037\s0 to \s-1ASCII\s0 just reverse the order of the tr///
arguments like so:
.PP
.Vb 2
\&    my $ascii_string = $ebcdic_string;
\&    eval \*(Aq$ascii_string =~ tr/\*(Aq . $cp_037 . \*(Aq/\e000\-\e377/\*(Aq;
.Ve
.PP
Similarly one could take the output of the third numbers column from recipe 2
to obtain a \f(CW$cp_1047\fR table.  The fourth numbers column of the output from
recipe 2 could provide a \f(CW$cp_posix_bc\fR table suitable for transcoding as
well.
.PP
If you wanted to see the inverse tables, you would first have to sort on the
desired numbers column as in recipes 4, 5 or 6, then take the output of the
first numbers column.
.SS "iconv"
.IX Subsection "iconv"
\&\s-1XPG\s0 operability often implies the presence of an \fIiconv\fR utility
available from the shell or from the C library.  Consult your system's
documentation for information on iconv.
.PP
On \s-1OS/390\s0 or z/OS see the \fIiconv\fR\|(1) manpage.  One way to invoke the iconv
shell utility from within perl would be to:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ascii_data = \`echo \*(Aq$ebcdic_data\*(Aq| iconv \-f IBM\-1047 \-t ISO8859\-1\`
.Ve
.PP
or the inverse map:
.PP
.Vb 2
\&    # OS/390 or z/OS example
\&    $ebcdic_data = \`echo \*(Aq$ascii_data\*(Aq| iconv \-f ISO8859\-1 \-t IBM\-1047\`
.Ve
.PP
For other perl-based conversion options see the Convert::* modules on \s-1CPAN.\s0
.SS "C \s-1RTL\s0"
.IX Subsection "C RTL"
The \s-1OS/390\s0 and z/OS C run-time libraries provide \fI_atoe()\fR and \fI_etoa()\fR functions.
.SH "OPERATOR DIFFERENCES"
.IX Header "OPERATOR DIFFERENCES"
The \f(CW\*(C`..\*(C'\fR range operator treats certain character ranges with
care on \s-1EBCDIC\s0 platforms.  For example the following array
will have twenty six elements on either an \s-1EBCDIC\s0 platform
or an \s-1ASCII\s0 platform:
.PP
.Vb 1
\&    @alphabet = (\*(AqA\*(Aq..\*(AqZ\*(Aq);   #  $#alphabet == 25
.Ve
.PP
The bitwise operators such as & ^ | may return different results
when operating on string or character data in a perl program running
on an \s-1EBCDIC\s0 platform than when run on an \s-1ASCII\s0 platform.  Here is
an example adapted from the one in perlop:
.PP
.Vb 5
\&    # EBCDIC\-based examples
\&    print "j p \en" ^ " a h";                      # prints "JAPH\en"
\&    print "JA" | "  ph\en";                        # prints "japh\en"
\&    print "JAPH\enJunk" & "\e277\e277\e277\e277\e277";  # prints "japh\en";
\&    print \*(Aqp N$\*(Aq ^ " E<H\en";                      # prints "Perl\en";
.Ve
.PP
An interesting property of the 32 C0 control characters
in the \s-1ASCII\s0 table is that they can \*(L"literally\*(R" be constructed
as control characters in perl, e.g. \f(CW\*(C`(chr(0)\*(C'\fR eq \f(CW\*(C`\ec@\*(C'\fR)>
\&\f(CW\*(C`(chr(1)\*(C'\fR eq \f(CW\*(C`\ecA\*(C'\fR)>, and so on.  Perl on \s-1EBCDIC\s0 platforms has been
ported to take \f(CW\*(C`\ec@\*(C'\fR to \fIchr\fR\|(0) and \f(CW\*(C`\ecA\*(C'\fR to \fIchr\fR\|(1), etc. as well, but the
thirty three characters that result depend on which code page you are
using.  The table below uses the standard acronyms for the controls.
The POSIX-BC and 1047 sets are
identical throughout this range and differ from the 0037 set at only
one spot (21 decimal).  Note that the \f(CW\*(C`LINE FEED\*(C'\fR character
may be generated by \f(CW\*(C`\ecJ\*(C'\fR on \s-1ASCII\s0 platforms but by \f(CW\*(C`\ecU\*(C'\fR on 1047 or POSIX-BC
platforms and cannot be generated as a \f(CW"\ec.letter."\fR control character on
0037 platforms.  Note also that \f(CW\*(C`\ec\e\*(C'\fR cannot be the final element in a string
or regex, as it will absorb the terminator.   But \f(CW\*(C`\ec\e\f(CIX\f(CW\*(C'\fR is a \f(CW\*(C`FILE
SEPARATOR\*(C'\fR concatenated with \fIX\fR for all \fIX\fR.
.PP
.Vb 10
\& chr   ord   8859\-1    0037    1047 && POSIX\-BC
\& \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\& \ec?   127   <DEL>       "            "
\& \ec@     0   <NUL>     <NUL>        <NUL>
\& \ecA     1   <SOH>     <SOH>        <SOH>
\& \ecB     2   <STX>     <STX>        <STX>
\& \ecC     3   <ETX>     <ETX>        <ETX>
\& \ecD     4   <EOT>     <ST>         <ST>
\& \ecE     5   <ENQ>     <HT>         <HT>
\& \ecF     6   <ACK>     <SSA>        <SSA>
\& \ecG     7   <BEL>     <DEL>        <DEL>
\& \ecH     8   <BS>      <EPA>        <EPA>
\& \ecI     9   <HT>      <RI>         <RI>
\& \ecJ    10   <LF>      <SS2>        <SS2>
\& \ecK    11   <VT>      <VT>         <VT>
\& \ecL    12   <FF>      <FF>         <FF>
\& \ecM    13   <CR>      <CR>         <CR>
\& \ecN    14   <SO>      <SO>         <SO>
\& \ecO    15   <SI>      <SI>         <SI>
\& \ecP    16   <DLE>     <DLE>        <DLE>
\& \ecQ    17   <DC1>     <DC1>        <DC1>
\& \ecR    18   <DC2>     <DC2>        <DC2>
\& \ecS    19   <DC3>     <DC3>        <DC3>
\& \ecT    20   <DC4>     <OSC>        <OSC>
\& \ecU    21   <NAK>     <NEL>        <LF>              **
\& \ecV    22   <SYN>     <BS>         <BS>
\& \ecW    23   <ETB>     <ESA>        <ESA>
\& \ecX    24   <CAN>     <CAN>        <CAN>
\& \ecY    25   <EOM>     <EOM>        <EOM>
\& \ecZ    26   <SUB>     <PU2>        <PU2>
\& \ec[    27   <ESC>     <SS3>        <SS3>
\& \ec\eX   28   <FS>X     <FS>X        <FS>X
\& \ec]    29   <GS>      <GS>         <GS>
\& \ec^    30   <RS>      <RS>         <RS>
\& \ec_    31   <US>      <US>         <US>
.Ve
.SH "FUNCTION DIFFERENCES"
.IX Header "FUNCTION DIFFERENCES"
.IP "\fIchr()\fR" 8
.IX Item "chr()"
\&\fIchr()\fR must be given an \s-1EBCDIC\s0 code number argument to yield a desired
character return value on an \s-1EBCDIC\s0 platform.  For example:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = chr(193);
.Ve
.IP "\fIord()\fR" 8
.IX Item "ord()"
\&\fIord()\fR will return \s-1EBCDIC\s0 code number values on an \s-1EBCDIC\s0 platform.
For example:
.Sp
.Vb 1
\&    $the_number_193 = ord("A");
.Ve
.IP "\fIpack()\fR" 8
.IX Item "pack()"
The c and C templates for \fIpack()\fR are dependent upon character set
encoding.  Examples of usage on \s-1EBCDIC\s0 include:
.Sp
.Vb 4
\&    $foo = pack("CCCC",193,194,195,196);
\&    # $foo eq "ABCD"
\&    $foo = pack("C4",193,194,195,196);
\&    # same thing
\&
\&    $foo = pack("ccxxcc",193,194,195,196);
\&    # $foo eq "AB\e0\e0CD"
.Ve
.IP "\fIprint()\fR" 8
.IX Item "print()"
One must be careful with scalars and strings that are passed to
print that contain \s-1ASCII\s0 encodings.  One common place
for this to occur is in the output of the \s-1MIME\s0 type header for
\&\s-1CGI\s0 script writing.  For example, many perl programming guides
recommend something similar to:
.Sp
.Vb 2
\&    print "Content\-type:\ettext/html\e015\e012\e015\e012";
\&    # this may be wrong on EBCDIC
.Ve
.Sp
Under the \s-1IBM OS/390 USS\s0 Web Server or WebSphere on z/OS for example
you should instead write that as:
.Sp
.Vb 1
\&    print "Content\-type:\ettext/html\er\en\er\en"; # OK for DGW et al
.Ve
.Sp
That is because the translation from \s-1EBCDIC\s0 to \s-1ASCII\s0 is done
by the web server in this case (such code will not be appropriate for
the Macintosh however).  Consult your web server's documentation for
further details.
.IP "\fIprintf()\fR" 8
.IX Item "printf()"
The formats that can convert characters to numbers and vice versa
will be different from their \s-1ASCII\s0 counterparts when executed
on an \s-1EBCDIC\s0 platform.  Examples include:
.Sp
.Vb 1
\&    printf("%c%c%c",193,194,195);  # prints ABC
.Ve
.IP "\fIsort()\fR" 8
.IX Item "sort()"
\&\s-1EBCDIC\s0 sort results may differ from \s-1ASCII\s0 sort results especially for
mixed case strings.  This is discussed in more detail below.
.IP "\fIsprintf()\fR" 8
.IX Item "sprintf()"
See the discussion of \fIprintf()\fR above.  An example of the use
of sprintf would be:
.Sp
.Vb 1
\&    $CAPITAL_LETTER_A = sprintf("%c",193);
.Ve
.IP "\fIunpack()\fR" 8
.IX Item "unpack()"
See the discussion of \fIpack()\fR above.
.SH "REGULAR EXPRESSION DIFFERENCES"
.IX Header "REGULAR EXPRESSION DIFFERENCES"
As of perl 5.005_03 the letter range regular expressions such as
[A\-Z] and [a\-z] have been especially coded to not pick up gap
characters.  For example, characters such as o\*^ \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR
that lie between I and J would not be matched by the
regular expression range \f(CW\*(C`/[H\-K]/\*(C'\fR.  This works in
the other direction, too, if either of the range end points is
explicitly numeric: \f(CW\*(C`[\ex89\-\ex91]\*(C'\fR will match \f(CW\*(C`\ex8e\*(C'\fR, even
though \f(CW\*(C`\ex89\*(C'\fR is \f(CW\*(C`i\*(C'\fR and \f(CW\*(C`\ex91 \*(C'\fR is \f(CW\*(C`j\*(C'\fR, and \f(CW\*(C`\ex8e\*(C'\fR
is a gap character from the alphabetic viewpoint.
.PP
If you do want to match the alphabet gap characters in a single octet
regular expression try matching the hex or octal code such
as \f(CW\*(C`/\e313/\*(C'\fR on \s-1EBCDIC\s0 or \f(CW\*(C`/\e364/\*(C'\fR on \s-1ASCII\s0 platforms to
have your regular expression match \f(CW\*(C`o WITH CIRCUMFLEX\*(C'\fR.
.PP
Another construct to be wary of is the inappropriate use of hex or
octal constants in regular expressions.  Consider the following
set of subs:
.PP
.Vb 4
\&    sub is_c0 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e000\-\e037]/;
\&    }
\&
\&    sub is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e040\-\e176]/;
\&    }
\&
\&    sub is_delete {
\&        my $char = substr(shift,0,1);
\&        $char eq "\e177";
\&    }
\&
\&    sub is_c1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e200\-\e237]/;
\&    }
\&
\&    sub is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\e240\-\e377]/;
\&    }
.Ve
.PP
The above would be adequate if the concern was only with numeric code points.
However, the concern may be with characters rather than code points
and on an \s-1EBCDIC\s0 platform it may be desirable for constructs such as
\&\f(CW\*(C`if (is_print_ascii("A")) {print "A is a printable character\en";}\*(C'\fR to print
out the expected message.  One way to represent the above collection
of character classification subs that is capable of working across the
four coded character sets discussed in this document is as follows:
.PP
.Vb 12
\&    sub Is_c0 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e000\-\e037]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e045\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95 || ord(\*(Aq^\*(Aq)==106) { # 1047 || posix\-bc
\&            return $char =~ /[\e000\-\e003\e067\e055\-\e057\e026\e005\e025\e013\-\e023\e074\e075\e062\e046\e030\e031\e077\e047\e034\-\e037]/;
\&        }
\&    }
\&
\&    sub Is_print_ascii {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<=>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~]/;
\&    }
\&
\&    sub Is_delete {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char eq "\e177";
\&        }
\&        else  {              # ebcdic
\&            return $char eq "\e007";
\&        }
\&    }
\&
\&    sub Is_c1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e200\-\e237]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~ /[\e040\-\e044\e025\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~ /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~
\&              /[\e040\-\e045\e006\e027\e050\-\e054\e011\e012\e033\e060\e061\e032\e063\-\e066\e010\e070\-\e073\e040\e024\e076\e137]/;
\&        }
\&    }
\&
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        if (ord(\*(Aq^\*(Aq)==94)  { # ascii
\&            return $char =~ /[\e240\-\e377]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==176) { # 0037
\&            return $char =~
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e275\e264\e232\e212\e137\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==95)  { # 1047
\&            return $char =~
\&              /[\e101\e252\e112\e261\e237\e262\e152\e265\e273\e264\e232\e212\e260\e312\e257\e274\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e375\e376\e373\e374\e272\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e335\e336\e333\e334\e215\e216\e337]/;
\&        }
\&        if (ord(\*(Aq^\*(Aq)==106) { # posix\-bc
\&            return $char =~
\&              /[\e101\e252\e260\e261\e237\e262\e320\e265\e171\e264\e232\e212\e272\e312\e257\e241\e220\e217\e352\e372\e276\e240\e266\e263\e235\e332\e233\e213\e267\e270\e271\e253\e144\e145\e142\e146\e143\e147\e236\e150\e164\e161\-\e163\e170\e165\-\e167\e254\e151\e355\e356\e353\e357\e354\e277\e200\e340\e376\e335\e374\e255\e256\e131\e104\e105\e102\e106\e103\e107\e234\e110\e124\e121\-\e123\e130\e125\-\e127\e214\e111\e315\e316\e313\e317\e314\e341\e160\e300\e336\e333\e334\e215\e216\e337]/;
\&        }
\&    }
.Ve
.PP
Note however that only the \f(CW\*(C`Is_ascii_print()\*(C'\fR sub is really independent
of coded character set.  Another way to write \f(CW\*(C`Is_latin_1()\*(C'\fR would be
to use the characters in the range explicitly:
.PP
.Vb 4
\&    sub Is_latin_1 {
\&        my $char = substr(shift,0,1);
\&        $char =~ /[\ XXXXXXXXXXXX\%XXXXXXXXXXXXXXXXXXA\*`A\*'A\*^A\*~A\*:A\*o\*(AeC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:XO\*/U\*`U\*'U\*^U\*:Y\*'\*(Th\*8a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:Xo\*/u\*`u\*'u\*^u\*:y\*'\*(thy\*:]/;
\&    }
.Ve
.PP
Although that form may run into trouble in network transit (due to the
presence of 8 bit characters) or on non ISO-Latin character sets.
.SH "SOCKETS"
.IX Header "SOCKETS"
Most socket programming assumes \s-1ASCII\s0 character encodings in network
byte order.  Exceptions can include \s-1CGI\s0 script writing under a
host web server where the server may take care of translation for you.
Most host web servers convert \s-1EBCDIC\s0 data to \s-1ISO\-8859\-1\s0 or Unicode on
output.
.SH "SORTING"
.IX Header "SORTING"
One big difference between ASCII-based character sets and \s-1EBCDIC\s0 ones
are the relative positions of upper and lower case letters and the
letters compared to the digits.  If sorted on an ASCII-based platform the
two-letter abbreviation for a physician comes before the two letter
abbreviation for drive; that is:
.PP
.Vb 2
\& @sorted = sort(qw(Dr. dr.));  # @sorted holds (\*(AqDr.\*(Aq,\*(Aqdr.\*(Aq) on ASCII,
\&                                  # but (\*(Aqdr.\*(Aq,\*(AqDr.\*(Aq) on EBCDIC
.Ve
.PP
The property of lowercase before uppercase letters in \s-1EBCDIC\s0 is
even carried to the Latin 1 \s-1EBCDIC\s0 pages such as 0037 and 1047.
An example would be that E\*: \f(CW\*(C`E WITH DIAERESIS\*(C'\fR (203) comes
before e\*: \f(CW\*(C`e WITH DIAERESIS\*(C'\fR (235) on an \s-1ASCII\s0 platform, but
the latter (83) comes before the former (115) on an \s-1EBCDIC\s0 platform.
(Astute readers will note that the uppercase version of \*8
\&\f(CW\*(C`SMALL LETTER SHARP S\*(C'\fR is simply \*(L"\s-1SS\*(R"\s0 and that the upper case version of
y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR is not in the 0..255 range but it is
at U+x0178 in Unicode, or \f(CW"\ex{178}"\fR in a Unicode enabled Perl).
.PP
The sort order will cause differences between results obtained on
\&\s-1ASCII\s0 platforms versus \s-1EBCDIC\s0 platforms.  What follows are some suggestions
on how to deal with these differences.
.SS "Ignore \s-1ASCII\s0 vs. \s-1EBCDIC\s0 sort differences."
.IX Subsection "Ignore ASCII vs. EBCDIC sort differences."
This is the least computationally expensive strategy.  It may require
some user education.
.SS "\s-1MONO CASE\s0 then sort data."
.IX Subsection "MONO CASE then sort data."
In order to minimize the expense of mono casing mixed-case text, try to
\&\f(CW\*(C`tr///\*(C'\fR towards the character set case most employed within the data.
If the data are primarily \s-1UPPERCASE\s0 non Latin 1 then apply tr/[a\-z]/[A\-Z]/
then \fIsort()\fR.  If the data are primarily lowercase non Latin 1 then
apply tr/[A\-Z]/[a\-z]/ before sorting.  If the data are primarily \s-1UPPERCASE\s0
and include Latin\-1 characters then apply:
.PP
.Vb 3
\&   tr/[a\-z]/[A\-Z]/;
\&   tr/[a\*`a\*'a\*^a\*~a\*:a\*o\*(aec\*,e\*`e\*'e\*^e\*:i\*`i\*'i\*^i\*:\*(d-n\*~o\*`o\*'o\*^o\*~o\*:o\*/u\*`u\*'u\*^u\*:y\*'\*(th]/[A\*`A\*'A\*^A\*~A\*:A\*o\*(AeC\*,E\*`E\*'E\*^E\*:I\*`I\*'I\*^I\*:\*(D-N\*~O\*`O\*'O\*^O\*~O\*:O\*/U\*`U\*'U\*^U\*:Y\*'\*(Th/;
\&   s/\*8/SS/g;
.Ve
.PP
then \fIsort()\fR.  Do note however that such Latin\-1 manipulation does not
address the y\*: \f(CW\*(C`y WITH DIAERESIS\*(C'\fR character that will remain at
code point 255 on \s-1ASCII\s0 platforms, but 223 on most \s-1EBCDIC\s0 platforms
where it will sort to a place less than the \s-1EBCDIC\s0 numerals.  With a
Unicode-enabled Perl you might try:
.PP
.Vb 1
\&    tr/^?/\ex{178}/;
.Ve
.PP
The strategy of mono casing data before sorting does not preserve the case
of the data and may not be acceptable for that reason.
.SS "Convert, sort data, then re convert."
.IX Subsection "Convert, sort data, then re convert."
This is the most expensive proposition that does not employ a network
connection.
.SS "Perform sorting on one type of platform only."
.IX Subsection "Perform sorting on one type of platform only."
This strategy can employ a network connection.  As such
it would be computationally expensive.
.SH "TRANSFORMATION FORMATS"
.IX Header "TRANSFORMATION FORMATS"
There are a variety of ways of transforming data with an intra character set
mapping that serve a variety of purposes.  Sorting was discussed in the
previous section and a few of the other more popular mapping techniques are
discussed next.
.SS "\s-1URL\s0 decoding and encoding"
.IX Subsection "URL decoding and encoding"
Note that some URLs have hexadecimal \s-1ASCII\s0 code points in them in an
attempt to overcome character or protocol limitation issues.  For example
the tilde character is not on every keyboard hence a \s-1URL\s0 of the form:
.PP
.Vb 1
\&    http://www.pvhp.com/~pvhp/
.Ve
.PP
may also be expressed as either of:
.PP
.Vb 1
\&    http://www.pvhp.com/%7Epvhp/
\&
\&    http://www.pvhp.com/%7epvhp/
.Ve
.PP
where 7E is the hexadecimal \s-1ASCII\s0 code point for '~'.  Here is an example
of decoding such a \s-1URL\s0 under \s-1CCSID 1047:\s0
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/%7Epvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @a2e_1047 = (
\&          0,  1,  2,  3, 55, 45, 46, 47, 22,  5, 21, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19, 60, 61, 50, 38, 24, 25, 63, 39, 28, 29, 30, 31,
\&         64, 90,127,123, 91,108, 80,125, 77, 93, 92, 78,107, 96, 75, 97,
\&        240,241,242,243,244,245,246,247,248,249,122, 94, 76,126,110,111,
\&        124,193,194,195,196,197,198,199,200,201,209,210,211,212,213,214,
\&        215,216,217,226,227,228,229,230,231,232,233,173,224,189, 95,109,
\&        121,129,130,131,132,133,134,135,136,137,145,146,147,148,149,150,
\&        151,152,153,162,163,164,165,166,167,168,169,192, 79,208,161,  7,
\&         32, 33, 34, 35, 36, 37,  6, 23, 40, 41, 42, 43, 44,  9, 10, 27,
\&         48, 49, 26, 51, 52, 53, 54,  8, 56, 57, 58, 59,  4, 20, 62,255,
\&         65,170, 74,177,159,178,106,181,187,180,154,138,176,202,175,188,
\&        144,143,234,250,190,160,182,179,157,218,155,139,183,184,185,171,
\&        100,101, 98,102, 99,103,158,104,116,113,114,115,120,117,118,119,
\&        172,105,237,238,235,239,236,191,128,253,254,251,252,186,174, 89,
\&         68, 69, 66, 70, 67, 71,156, 72, 84, 81, 82, 83, 88, 85, 86, 87,
\&        140, 73,205,206,203,207,204,225,112,221,222,219,220,141,142,223
\&    );
\&    $url =~ s/%([0\-9a\-fA\-F]{2})/pack("c",$a2e_1047[hex($1)])/ge;
.Ve
.PP
Conversely, here is a partial solution for the task of encoding such
a \s-1URL\s0 under the 1047 code page:
.PP
.Vb 10
\&    $url = \*(Aqhttp://www.pvhp.com/~pvhp/\*(Aq;
\&    # this array assumes code page 1047
\&    my @e2a_1047 = (
\&          0,  1,  2,  3,156,  9,134,127,151,141,142, 11, 12, 13, 14, 15,
\&         16, 17, 18, 19,157, 10,  8,135, 24, 25,146,143, 28, 29, 30, 31,
\&        128,129,130,131,132,133, 23, 27,136,137,138,139,140,  5,  6,  7,
\&        144,145, 22,147,148,149,150,  4,152,153,154,155, 20, 21,158, 26,
\&         32,160,226,228,224,225,227,229,231,241,162, 46, 60, 40, 43,124,
\&         38,233,234,235,232,237,238,239,236,223, 33, 36, 42, 41, 59, 94,
\&         45, 47,194,196,192,193,195,197,199,209,166, 44, 37, 95, 62, 63,
\&        248,201,202,203,200,205,206,207,204, 96, 58, 35, 64, 39, 61, 34,
\&        216, 97, 98, 99,100,101,102,103,104,105,171,187,240,253,254,177,
\&        176,106,107,108,109,110,111,112,113,114,170,186,230,184,198,164,
\&        181,126,115,116,117,118,119,120,121,122,161,191,208, 91,222,174,
\&        172,163,165,183,169,167,182,188,189,190,221,168,175, 93,180,215,
\&        123, 65, 66, 67, 68, 69, 70, 71, 72, 73,173,244,246,242,243,245,
\&        125, 74, 75, 76, 77, 78, 79, 80, 81, 82,185,251,252,249,250,255,
\&         92,247, 83, 84, 85, 86, 87, 88, 89, 90,178,212,214,210,211,213,
\&         48, 49, 50, 51, 52, 53, 54, 55, 56, 57,179,219,220,217,218,159
\&    );
\&    # The following regular expression does not address the
\&    # mappings for: (\*(Aq.\*(Aq => \*(Aq%2E\*(Aq, \*(Aq/\*(Aq => \*(Aq%2F\*(Aq, \*(Aq:\*(Aq => \*(Aq%3A\*(Aq)
\&    $url =~ s/([\et "#%&\e(\e),;<=>\e?\e@\e[\e\e\e]^\`{|}~])/sprintf("%%%02X",$e2a_1047[ord($1)])/ge;
.Ve
.PP
where a more complete solution would split the \s-1URL\s0 into components
and apply a full s/// substitution only to the appropriate parts.
.PP
In the remaining examples a \f(CW@e2a\fR or \f(CW@a2e\fR array may be employed
but the assignment will not be shown explicitly.  For code page 1047
you could use the \f(CW@a2e_1047\fR or \f(CW@e2a_1047\fR arrays just shown.
.SS "uu encoding and decoding"
.IX Subsection "uu encoding and decoding"
The \f(CW\*(C`u\*(C'\fR template to \fIpack()\fR or \fIunpack()\fR will render \s-1EBCDIC\s0 data in \s-1EBCDIC\s0
characters equivalent to their \s-1ASCII\s0 counterparts.  For example, the
following will print \*(L"Yes indeed\en\*(R" on either an \s-1ASCII\s0 or \s-1EBCDIC\s0 computer:
.PP
.Vb 10
\&    $all_byte_chrs = \*(Aq\*(Aq;
\&    for (0..255) { $all_byte_chrs .= chr($_); }
\&    $uuencode_byte_chrs = pack(\*(Aqu\*(Aq, $all_byte_chrs);
\&    ($uu = <<\*(AqENDOFHEREDOC\*(Aq) =~ s/^\es*//gm;
\&    M\`\`$"\`P0%!@<("0H+#\`T.#Q\`1$A,4%187&!D:&QP=\*(AqA\e@(2(C)"4F)R@I*BLL
\&    M+2XO,#$R,S0U\-C<X.3H[/#T^/T!!0D\-$149\*(Aq2$E*2TQ\-3D]045)35%565UA9
\&    M6EM<75Y?8&%B8V1E9F=H:6IK;&UN;W!Q<G\-T=79W>\*(AqEZ>WQ]?G^\`@8*#A(6&
\&    MAXB)BHN,C8Z/D)&2DY25EI>8F9J;G)V>GZ"AHJ.DI::GJ*FJJZRMKJ^PL;*S
\&    MM+6VM[BYNKN\eO;Z_P,\*(Aq"P\e3%QL?(R<K+S,W.S]#1TM/4U=;7V\-G:V]S=WM_@
\&    ?X>+CY.7FY^CIZNOL[>[O\e/\*(AqR\e_3U]O?X^?K[_/W^_P\`\`
\&    ENDOFHEREDOC
\&    if ($uuencode_byte_chrs eq $uu) {
\&        print "Yes ";
\&    }
\&    $uudecode_byte_chrs = unpack(\*(Aqu\*(Aq, $uuencode_byte_chrs);
\&    if ($uudecode_byte_chrs eq $all_byte_chrs) {
\&        print "indeed\en";
\&    }
.Ve
.PP
Here is a very spartan uudecoder that will work on \s-1EBCDIC\s0 provided
that the \f(CW@e2a\fR array is filled in appropriately:
.PP
.Vb 10
\&    #!/usr/local/bin/perl
\&    @e2a = ( # this must be filled in
\&           );
\&    $_ = <> until ($mode,$file) = /^begin\es*(\ed*)\es*(\eS*)/;
\&    open(OUT, "> $file") if $file ne "";
\&    while(<>) {
\&        last if /^end/;
\&        next if /[a\-z]/;
\&        next unless int(((($e2a[ord()] \- 32 ) & 077) + 2) / 3) ==
\&            int(length() / 4);
\&        print OUT unpack("u", $_);
\&    }
\&    close(OUT);
\&    chmod oct($mode), $file;
.Ve
.SS "Quoted-Printable encoding and decoding"
.IX Subsection "Quoted-Printable encoding and decoding"
On ASCII-encoded platforms it is possible to strip characters outside of
the printable set using:
.PP
.Vb 2
\&    # This QP encoder works on ASCII only
\&    $qp_string =~ s/([=\ex00\-\ex1F\ex80\-\exFF])/sprintf("=%02X",ord($1))/ge;
.Ve
.PP
Whereas a \s-1QP\s0 encoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms
would look somewhat like the following (where the \s-1EBCDIC\s0 branch \f(CW@e2a\fR
array is omitted for brevity):
.PP
.Vb 10
\&    if (ord(\*(AqA\*(Aq) == 65) {    # ASCII
\&        $delete = "\ex7F";    # ASCII
\&        @e2a = (0 .. 255)    # ASCII to ASCII identity map
\&    }
\&    else {                   # EBCDIC
\&        $delete = "\ex07";    # EBCDIC
\&        @e2a =               # EBCDIC to ASCII map (as shown above)
\&    }
\&    $qp_string =~
\&      s/([^ !"\e#\e$%&\*(Aq()*+,\e\-.\e/0\-9:;<>?\e@A\-Z[\e\e\e]^_\`a\-z{|}~$delete])/sprintf("=%02X",$e2a[ord($1)])/ge;
.Ve
.PP
(although in production code the substitutions might be done
in the \s-1EBCDIC\s0 branch with the \f(CW@e2a\fR array and separately in the
\&\s-1ASCII\s0 branch without the expense of the identity map).
.PP
Such \s-1QP\s0 strings can be decoded with:
.PP
.Vb 3
\&    # This QP decoder is limited to ASCII only
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr hex $1/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.PP
Whereas a \s-1QP\s0 decoder that works on both \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms
would look somewhat like the following (where the \f(CW@a2e\fR array is
omitted for brevity):
.PP
.Vb 2
\&    $string =~ s/=([0\-9A\-Fa\-f][0\-9A\-Fa\-f])/chr $a2e[hex $1]/ge;
\&    $string =~ s/=[\en\er]+$//;
.Ve
.SS "Caesarean ciphers"
.IX Subsection "Caesarean ciphers"
The practice of shifting an alphabet one or more characters for encipherment
dates back thousands of years and was explicitly detailed by Gaius Julius
Caesar in his \fBGallic Wars\fR text.  A single alphabet shift is sometimes
referred to as a rotation and the shift amount is given as a number \f(CW$n\fR after
the string 'rot' or \*(L"rot$n\*(R".  Rot0 and rot26 would designate identity maps
on the 26\-letter English version of the Latin alphabet.  Rot13 has the
interesting property that alternate subsequent invocations are identity maps
(thus rot13 is its own non-trivial inverse in the group of 26 alphabet
rotations).  Hence the following is a rot13 encoder and decoder that will
work on \s-1ASCII\s0 and \s-1EBCDIC\s0 platforms:
.PP
.Vb 1
\&    #!/usr/local/bin/perl
\&
\&    while(<>){
\&        tr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;
\&        print;
\&    }
.Ve
.PP
In one-liner form:
.PP
.Vb 1
\&    perl \-ne \*(Aqtr/n\-za\-mN\-ZA\-M/a\-zA\-Z/;print\*(Aq
.Ve
.SH "Hashing order and checksums"
.IX Header "Hashing order and checksums"
To the extent that it is possible to write code that depends on
hashing order there may be differences between hashes as stored
on an ASCII-based platform and hashes stored on an EBCDIC-based platform.
\&\s-1XXX\s0
.SH "I18N AND L10N"
.IX Header "I18N AND L10N"
Internationalization (I18N) and localization (L10N) are supported at least
in principle even on \s-1EBCDIC\s0 platforms.  The details are system-dependent
and discussed under the \*(L"\s-1OS ISSUES\*(R"\s0 in perlebcdic section below.
.SH "MULTI-OCTET CHARACTER SETS"
.IX Header "MULTI-OCTET CHARACTER SETS"
Perl may work with an internal UTF-EBCDIC encoding form for wide characters
on \s-1EBCDIC\s0 platforms in a manner analogous to the way that it works with
the \s-1UTF\-8\s0 internal encoding form on \s-1ASCII\s0 based platforms.
.PP
Legacy multi byte \s-1EBCDIC\s0 code pages \s-1XXX.\s0
.SH "OS ISSUES"
.IX Header "OS ISSUES"
There may be a few system-dependent issues
of concern to \s-1EBCDIC\s0 Perl programmers.
.SS "\s-1OS/400\s0"
.IX Subsection "OS/400"
.IP "\s-1PASE\s0" 8
.IX Item "PASE"
The \s-1PASE\s0 environment is a runtime environment for \s-1OS/400\s0 that can run
executables built for PowerPC \s-1AIX\s0 in \s-1OS/400\s0; see perlos400.  \s-1PASE\s0
is ASCII-based, not EBCDIC-based as the \s-1ILE.\s0
.IP "\s-1IFS\s0 access" 8
.IX Item "IFS access"
\&\s-1XXX.\s0
.SS "\s-1OS/390,\s0 z/OS"
.IX Subsection "OS/390, z/OS"
Perl runs under Unix Systems Services or \s-1USS.\s0
.IP "chcp" 8
.IX Item "chcp"
\&\fBchcp\fR is supported as a shell utility for displaying and changing
one's code page.  See also \fIchcp\fR\|(1).
.IP "dataset access" 8
.IX Item "dataset access"
For sequential data set access try:
.Sp
.Vb 1
\&    my @ds_records = \`cat //DSNAME\`;
.Ve
.Sp
or:
.Sp
.Vb 1
\&    my @ds_records = \`cat //\*(AqHLQ.DSNAME\*(Aq\`;
.Ve
.Sp
See also the OS390::Stdio module on \s-1CPAN.\s0
.IP "\s-1OS/390,\s0 z/OS iconv" 8
.IX Item "OS/390, z/OS iconv"
\&\fBiconv\fR is supported as both a shell utility and a C \s-1RTL\s0 routine.
See also the \fIiconv\fR\|(1) and \fIiconv\fR\|(3) manual pages.
.IP "locales" 8
.IX Item "locales"
On \s-1OS/390\s0 or z/OS see locale for information on locales.  The L10N files
are in \fI/usr/nls/locale\fR.  \f(CW$Config\fR{d_setlocale} is 'define' on \s-1OS/390\s0
or z/OS.
.SS "POSIX-BC?"
.IX Subsection "POSIX-BC?"
\&\s-1XXX.\s0
.SH "BUGS"
.IX Header "BUGS"
This pod document contains literal Latin 1 characters and may encounter
translation difficulties.  In particular one popular nroff implementation
was known to strip accented characters to their unaccented counterparts
while attempting to view this document through the \fBpod2man\fR program
(for example, you may see a plain \f(CW\*(C`y\*(C'\fR rather than one with a diaeresis
as in y\*:).  Another nroff truncated the resultant manpage at
the first occurrence of 8 bit characters.
.PP
Not all shells will allow multiple \f(CW\*(C`\-e\*(C'\fR string arguments to perl to
be concatenated together properly as recipes 0, 2, 4, 5, and 6 might
seem to imply.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perllocale, perlfunc, perlunicode, utf8.
.SH "REFERENCES"
.IX Header "REFERENCES"
<http://anubis.dkuug.dk/i18n/charmaps>
.PP
<http://www.unicode.org/>
.PP
<http://www.unicode.org/unicode/reports/tr16/>
.PP
<http://www.wps.com/projects/codes/>
\&\fB\s-1ASCII:\s0 American Standard Code for Information Infiltration\fR Tom Jennings,
September 1999.
.PP
\&\fBThe Unicode Standard, Version 3.0\fR The Unicode Consortium, Lisa Moore ed.,
\&\s-1ISBN 0\-201\-61633\-5,\s0 Addison Wesley Developers Press, February 2000.
.PP
\&\fB\s-1CDRA: IBM \-\s0 Character Data Representation Architecture \-
Reference and Registry\fR, \s-1IBM SC09\-2190\-00,\s0 December 1996.
.PP
\&\*(L"Demystifying Character Sets\*(R", Andrea Vine, Multilingual Computing
& Technology, \fB#26 Vol. 10 Issue 4\fR, August/September 1999;
\&\s-1ISSN 1523\-0309\s0; Multilingual Computing Inc. Sandpoint \s-1ID, USA.\s0
.PP
\&\fBCodes, Ciphers, and Other Cryptic and Clandestine Communication\fR
Fred B. Wrixon, \s-1ISBN 1\-57912\-040\-7,\s0 Black Dog & Leventhal Publishers,
1998.
.PP
<http://www.bobbemer.com/P\-BIT.HTM>
\&\fB\s-1IBM \- EBCDIC\s0 and the P\-bit; The biggest Computer Goof Ever\fR Robert Bemer.
.SH "HISTORY"
.IX Header "HISTORY"
15 April 2001: added \s-1UTF\-8\s0 and UTF-EBCDIC to main table, pvhp.
.SH "AUTHOR"
.IX Header "AUTHOR"
Peter Prymmer pvhp@best.com wrote this in 1999 and 2000
with \s-1CCSID 0819\s0 and 0037 help from Chris Leach and
Andre\*' Pirard A.Pirard@ulg.ac.be as well as POSIX-BC
help from Thomas Dorner Thomas.Dorner@start.de.
Thanks also to Vickie Cooper, Philip Newton, William Raffloer, and
Joe Smith.  Trademarks, registered trademarks, service marks and
registered service marks used in this document are the property of
their respective owners.
                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlembed.1                                  0100644 0001750 0001750 00000130234 12566207436 022705  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEMBED 1"
.TH PERLEMBED 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlembed \- how to embed perl in your C program
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1PREAMBLE\s0"
.IX Subsection "PREAMBLE"
Do you want to:
.IP "\fBUse C from Perl?\fR" 5
.IX Item "Use C from Perl?"
Read perlxstut, perlxs, h2xs, perlguts, and perlapi.
.IP "\fBUse a Unix program from Perl?\fR" 5
.IX Item "Use a Unix program from Perl?"
Read about back-quotes and about \f(CW\*(C`system\*(C'\fR and \f(CW\*(C`exec\*(C'\fR in perlfunc.
.IP "\fBUse Perl from Perl?\fR" 5
.IX Item "Use Perl from Perl?"
Read about \*(L"do\*(R" in perlfunc and \*(L"eval\*(R" in perlfunc and \*(L"require\*(R" in perlfunc 
and \*(L"use\*(R" in perlfunc.
.IP "\fBUse C from C?\fR" 5
.IX Item "Use C from C?"
Rethink your design.
.IP "\fBUse Perl from C?\fR" 5
.IX Item "Use Perl from C?"
Read on...
.SS "\s-1ROADMAP\s0"
.IX Subsection "ROADMAP"
.IP "\(bu" 5
Compiling your C program
.IP "\(bu" 5
Adding a Perl interpreter to your C program
.IP "\(bu" 5
Calling a Perl subroutine from your C program
.IP "\(bu" 5
Evaluating a Perl statement from your C program
.IP "\(bu" 5
Performing Perl pattern matches and substitutions from your C program
.IP "\(bu" 5
Fiddling with the Perl stack from your C program
.IP "\(bu" 5
Maintaining a persistent interpreter
.IP "\(bu" 5
Maintaining multiple interpreter instances
.IP "\(bu" 5
Using Perl modules, which themselves use C libraries, from your C program
.IP "\(bu" 5
Embedding Perl under Win32
.SS "Compiling your C program"
.IX Subsection "Compiling your C program"
If you have trouble compiling the scripts in this documentation,
you're not alone.  The cardinal rule: \s-1COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  \s0(Sorry for yelling.)
.PP
Also, every C program that uses Perl must link in the \fIperl library\fR.
What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (\fI/usr/bin/perl\fR or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly\*(--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
\&\fIlib\fR directory.)
.PP
When you use Perl from C, your C program will\*(--usually\-\-allocate,
\&\*(L"run\*(R", and deallocate a \fIPerlInterpreter\fR object, which is defined by
the perl library.
.PP
If your copy of Perl is recent enough to contain this documentation
(version 5.002 or later), then the perl library (and \fI\s-1EXTERN\s0.h\fR and
\&\fIperl.h\fR, which you'll also need) will reside in a directory
that looks like this:
.PP
.Vb 1
\&    /usr/local/lib/perl5/your_architecture_here/CORE
.Ve
.PP
or perhaps just
.PP
.Vb 1
\&    /usr/local/lib/perl5/CORE
.Ve
.PP
or maybe something like
.PP
.Vb 1
\&    /usr/opt/perl5/CORE
.Ve
.PP
Execute this statement for a hint about where to find \s-1CORE:\s0
.PP
.Vb 1
\&    perl \-MConfig \-e \*(Aqprint $Config{archlib}\*(Aq
.Ve
.PP
Here's how you'd compile the example in the next section,
\&\*(L"Adding a Perl interpreter to your C program\*(R", on my Linux box:
.PP
.Vb 4
\&    % gcc \-O2 \-Dbool=char \-DHAS_BOOL \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-L/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-o interp interp.c \-lperl \-lm
.Ve
.PP
(That's all one line.)  On my \s-1DEC\s0 Alpha running old 5.003_05, the 
incantation is a bit different:
.PP
.Vb 4
\&    % cc \-O2 \-Olimit 2900 \-DSTANDARD_C \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE
\&    \-L/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE \-L/usr/local/lib
\&    \-D_\|_LANGUAGE_C_\|_ \-D_NO_PROTO \-o interp interp.c \-lperl \-lm
.Ve
.PP
How can you figure out what to add?  Assuming your Perl is post\-5.001,
execute a \f(CW\*(C`perl \-V\*(C'\fR command and pay special attention to the \*(L"cc\*(R" and
\&\*(L"ccflags\*(R" information.
.PP
You'll have to choose the appropriate compiler (\fIcc\fR, \fIgcc\fR, et al.) for
your machine: \f(CW\*(C`perl \-MConfig \-e \*(Aqprint $Config{cc}\*(Aq\*(C'\fR will tell you what
to use.
.PP
You'll also have to choose the appropriate library directory
(\fI/usr/local/lib/...\fR) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
\&\fI\-lperl\fR, then you need to change the path following the \f(CW\*(C`\-L\*(C'\fR.  If it
complains that it can't find \fI\s-1EXTERN\s0.h\fR and \fIperl.h\fR, you need to
change the path following the \f(CW\*(C`\-I\*(C'\fR.
.PP
You may have to add extra libraries as well.  Which ones?
Perhaps those printed by
.PP
.Vb 1
\&   perl \-MConfig \-e \*(Aqprint $Config{libs}\*(Aq
.Ve
.PP
Provided your perl binary was properly configured and installed the
\&\fBExtUtils::Embed\fR module will determine all of this information for
you:
.PP
.Vb 1
\&   % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
If the \fBExtUtils::Embed\fR module isn't part of your Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by\-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)
.PP
The \fBExtUtils::Embed\fR kit on \s-1CPAN\s0 also contains all source code for
the examples in this document, tests, additional examples and other
information you may find useful.
.SS "Adding a Perl interpreter to your C program"
.IX Subsection "Adding a Perl interpreter to your C program"
In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with \fIminiperlmain.c\fR,
included in the source distribution.  Here's a bastardized, non-portable
version of \fIminiperlmain.c\fR containing the essentials of embedding:
.PP
.Vb 2
\&    #include <EXTERN.h>               /* from the Perl distribution     */
\&    #include <perl.h>                 /* from the Perl distribution     */
\&
\&    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
\&        perl_run(my_perl);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
Notice that we don't use the \f(CW\*(C`env\*(C'\fR pointer.  Normally handed to
\&\f(CW\*(C`perl_parse\*(C'\fR as its final argument, \f(CW\*(C`env\*(C'\fR here is replaced by
\&\f(CW\*(C`NULL\*(C'\fR, which means that the current environment will be used.
.PP
The macros \s-1\fIPERL_SYS_INIT3\s0()\fR and \s-1\fIPERL_SYS_TERM\s0()\fR provide system-specific
tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call \s-1\fIPERL_SYS_INIT3\s0()\fR before you create your first
interpreter, and \s-1\fIPERL_SYS_TERM\s0()\fR after you free your last interpreter.
.PP
Since \s-1\fIPERL_SYS_INIT3\s0()\fR may change \f(CW\*(C`env\*(C'\fR, it may be more appropriate to
provide \f(CW\*(C`env\*(C'\fR as an argument to \fIperl_parse()\fR.
.PP
Also notice that no matter what arguments you pass to \fIperl_parse()\fR,
\&\s-1\fIPERL_SYS_INIT3\s0()\fR must be invoked on the C \fImain()\fR argc, argv and env and
only once.
.PP
Now compile this program (I'll call it \fIinterp.c\fR) into an executable:
.PP
.Vb 1
\&    % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
After a successful compilation, you'll be able to use \fIinterp\fR just
like perl itself:
.PP
.Vb 6
\&    % interp
\&    print "Pretty Good Perl \en";
\&    print "10890 \- 9801 is ", 10890 \- 9801;
\&    <CTRL\-D>
\&    Pretty Good Perl
\&    10890 \- 9801 is 1089
.Ve
.PP
or
.PP
.Vb 2
\&    % interp \-e \*(Aqprintf("%x", 3735928559)\*(Aq
\&    deadbeef
.Ve
.PP
You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in \fIargv[1]\fR before
calling \fIperl_run\fR.
.SS "Calling a Perl subroutine from your C program"
.IX Subsection "Calling a Perl subroutine from your C program"
To call individual Perl subroutines, you can use any of the \fBcall_*\fR
functions documented in perlcall.
In this example we'll use \f(CW\*(C`call_argv\*(C'\fR.
.PP
That's shown below, in a program I'll call \fIshowtime.c\fR.
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        char *args[] = { NULL };
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&
\&        perl_parse(my_perl, NULL, argc, argv, NULL);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&        /*** skipping perl_run() ***/
\&
\&        call_argv("showtime", G_DISCARD | G_NOARGS, args);
\&
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
where \fIshowtime\fR is a Perl subroutine that takes no arguments (that's the
\&\fIG_NOARGS\fR) and for which I'll ignore the return value (that's the
\&\fIG_DISCARD\fR).  Those flags, and others, are discussed in perlcall.
.PP
I'll define the \fIshowtime\fR subroutine in a file called \fIshowtime.pl\fR:
.PP
.Vb 1
\&    print "I shan\*(Aqt be printed.";
\&
\&    sub showtime {
\&        print time;
\&    }
.Ve
.PP
Simple enough.  Now compile and run:
.PP
.Vb 1
\&    % cc \-o showtime showtime.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % showtime showtime.pl
\&    818284590
.Ve
.PP
yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the Unix epoch), and the moment I began writing this
sentence.
.PP
In this particular case we don't have to call \fIperl_run\fR, as we set 
the PL_exit_flag \s-1PERL_EXIT_DESTRUCT_END\s0 which executes \s-1END\s0 blocks in
perl_destruct.
.PP
If you want to pass arguments to the Perl subroutine, you can add
strings to the \f(CW\*(C`NULL\*(C'\fR\-terminated \f(CW\*(C`args\*(C'\fR list passed to
\&\fIcall_argv\fR.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in
\&\*(L"Fiddling with the Perl stack from your C program\*(R".
.SS "Evaluating a Perl statement from your C program"
.IX Subsection "Evaluating a Perl statement from your C program"
Perl provides two \s-1API\s0 functions to evaluate pieces of Perl code.
These are \*(L"eval_sv\*(R" in perlapi and \*(L"eval_pv\*(R" in perlapi.
.PP
Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
\&\*(L"use\*(R" in perlfunc, \*(L"require\*(R" in perlfunc, and \*(L"do\*(R" in perlfunc to
include external Perl files.
.PP
\&\fIeval_pv\fR lets us evaluate individual Perl strings, and then
extract variables for coercion into C types.  The following program,
\&\fIstring.c\fR, executes three Perl strings, extracting an \f(CW\*(C`int\*(C'\fR from
the first, a \f(CW\*(C`float\*(C'\fR from the second, and a \f(CW\*(C`char *\*(C'\fR from the third.
.PP
.Vb 2
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&
\&   static PerlInterpreter *my_perl;
\&
\&   main (int argc, char **argv, char **env)
\&   {
\&       char *embedding[] = { "", "\-e", "0" };
\&
\&       PERL_SYS_INIT3(&argc,&argv,&env);
\&       my_perl = perl_alloc();
\&       perl_construct( my_perl );
\&
\&       perl_parse(my_perl, NULL, 3, embedding, NULL);
\&       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&       perl_run(my_perl);
\&
\&       /** Treat $a as an integer **/
\&       eval_pv("$a = 3; $a **= 2", TRUE);
\&       printf("a = %d\en", SvIV(get_sv("a", 0)));
\&
\&       /** Treat $a as a float **/
\&       eval_pv("$a = 3.14; $a **= 2", TRUE);
\&       printf("a = %f\en", SvNV(get_sv("a", 0)));
\&
\&       /** Treat $a as a string **/
\&       eval_pv("$a = \*(AqrekcaH lreP rehtonA tsuJ\*(Aq; $a = reverse($a);", TRUE);
\&       printf("a = %s\en", SvPV_nolen(get_sv("a", 0)));
\&
\&       perl_destruct(my_perl);
\&       perl_free(my_perl);
\&       PERL_SYS_TERM();
\&   }
.Ve
.PP
All of those strange functions with \fIsv\fR in their names help convert Perl scalars to C types.  They're described in perlguts and perlapi.
.PP
If you compile and run \fIstring.c\fR, you'll see the results of using
\&\fI\fISvIV()\fI\fR to create an \f(CW\*(C`int\*(C'\fR, \fI\fISvNV()\fI\fR to create a \f(CW\*(C`float\*(C'\fR, and
\&\fI\fISvPV()\fI\fR to create a string:
.PP
.Vb 3
\&   a = 9
\&   a = 9.859600
\&   a = Just Another Perl Hacker
.Ve
.PP
In the example above, we've created a global variable to temporarily
store the computed value of our eval'ed expression.  It is also
possible and in most cases a better strategy to fetch the return value
from \fI\fIeval_pv()\fI\fR instead.  Example:
.PP
.Vb 4
\&   ...
\&   SV *val = eval_pv("reverse \*(AqrekcaH lreP rehtonA tsuJ\*(Aq", TRUE);
\&   printf("%s\en", SvPV_nolen(val));
\&   ...
.Ve
.PP
This way, we avoid namespace pollution by not creating global
variables and we've simplified our code as well.
.SS "Performing Perl pattern matches and substitutions from your C program"
.IX Subsection "Performing Perl pattern matches and substitutions from your C program"
The \fI\fIeval_sv()\fI\fR function lets us evaluate strings of Perl code, so we can
define some functions that use it to \*(L"specialize\*(R" in matches and
substitutions: \fI\fImatch()\fI\fR, \fI\fIsubstitute()\fI\fR, and \fI\fImatches()\fI\fR.
.PP
.Vb 1
\&   I32 match(SV *string, char *pattern);
.Ve
.PP
Given a string and a pattern (e.g., \f(CW\*(C`m/clasp/\*(C'\fR or \f(CW\*(C`/\eb\ew*\eb/\*(C'\fR, which
in your C program might appear as \*(L"/\e\eb\e\ew*\e\eb/\*(R"), \fImatch()\fR
returns 1 if the string matches the pattern and 0 otherwise.
.PP
.Vb 1
\&   int substitute(SV **string, char *pattern);
.Ve
.PP
Given a pointer to an \f(CW\*(C`SV\*(C'\fR and an \f(CW\*(C`=~\*(C'\fR operation (e.g.,
\&\f(CW\*(C`s/bob/robert/g\*(C'\fR or \f(CW\*(C`tr[A\-Z][a\-z]\*(C'\fR), \fIsubstitute()\fR modifies the string
within the \f(CW\*(C`SV\*(C'\fR as according to the operation, returning the number of substitutions
made.
.PP
.Vb 1
\&   int matches(SV *string, char *pattern, AV **matches);
.Ve
.PP
Given an \f(CW\*(C`SV\*(C'\fR, a pattern, and a pointer to an empty \f(CW\*(C`AV\*(C'\fR,
\&\fImatches()\fR evaluates \f(CW\*(C`$string =~ $pattern\*(C'\fR in a list context, and
fills in \fImatches\fR with the array elements, returning the number of matches found.
.PP
Here's a sample program, \fImatch.c\fR, that uses all three (long lines have
been wrapped here):
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& static PerlInterpreter *my_perl;
\&
\& /** my_eval_sv(code, error_check)
\& ** kinda like eval_sv(), 
\& ** but we pop the return value off the stack 
\& **/
\& SV* my_eval_sv(SV *sv, I32 croak_on_error)
\& {
\&     dSP;
\&     SV* retval;
\&
\&
\&     PUSHMARK(SP);
\&     eval_sv(sv, G_SCALAR);
\&
\&     SPAGAIN;
\&     retval = POPs;
\&     PUTBACK;
\&
\&     if (croak_on_error && SvTRUE(ERRSV))
\&        croak(SvPVx_nolen(ERRSV));
\&
\&     return retval;
\& }
\&
\& /** match(string, pattern)
\& **
\& ** Used for matches in a scalar context.
\& **
\& ** Returns 1 if the match was successful; 0 otherwise.
\& **/
\&
\& I32 match(SV *string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; $string =~ %s",
\&              SvPV_nolen(string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     return SvIV(retval);
\& }
\&
\& /** substitute(string, pattern)
\& **
\& ** Used for =~ operations that modify their left\-hand side (s/// and tr///)
\& **
\& ** Returns the number of successful matches, and
\& ** modifies the input string if there were any.
\& **/
\&
\& I32 substitute(SV **string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "$string = \*(Aq%s\*(Aq; ($string =~ %s)",
\&              SvPV_nolen(*string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *string = get_sv("string", 0);
\&     return SvIV(retval);
\& }
\&
\& /** matches(string, pattern, matches)
\& **
\& ** Used for matches in a list context.
\& **
\& ** Returns the number of matches,
\& ** and fills in **matches with the matching substrings
\& **/
\&
\& I32 matches(SV *string, char *pattern, AV **match_list)
\& {
\&     SV *command = newSV(0);
\&     I32 num_matches;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; @array = ($string =~ %s)",
\&              SvPV_nolen(string), pattern);
\&
\&     my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *match_list = get_av("array", 0);
\&     num_matches = av_top_index(*match_list) + 1;
\&
\&     return num_matches;
\& }
\&
\& main (int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "\-e", "0" };
\&     AV *match_list;
\&     I32 num_matches, i;
\&     SV *text;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     my_perl = perl_alloc();
\&     perl_construct(my_perl);
\&     perl_parse(my_perl, NULL, 3, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&     text = newSV(0);
\&     sv_setpv(text, "When he is at a convenience store and the "
\&        "bill comes to some amount like 76 cents, Maynard is "
\&        "aware that there is something he *should* do, something "
\&        "that will enable him to get back a quarter, but he has "
\&        "no idea *what*.  He fumbles through his red squeezey "
\&        "changepurse and gives the boy three extra pennies with "
\&        "his dollar, hoping that he might luck into the correct "
\&        "amount.  The boy gives him back two of his own pennies "
\&        "and then the big shiny quarter that is his prize. "
\&        "\-RICHH");
\&
\&     if (match(text, "m/quarter/")) /** Does text contain \*(Aqquarter\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqquarter\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqquarter\*(Aq.\en\en");
\&
\&     if (match(text, "m/eighth/")) /** Does text contain \*(Aqeighth\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqeighth\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.\en\en");
\&
\&     /** Match all occurrences of /wi../ **/
\&     num_matches = matches(text, "m/(wi..)/g", &match_list);
\&     printf("matches: m/(wi..)/g found %d matches...\en", num_matches);
\&
\&     for (i = 0; i < num_matches; i++)
\&        printf("match: %s\en", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
\&     printf("\en");
\&
\&     /** Remove all vowels from text **/
\&     num_matches = substitute(&text, "s/[aeiou]//gi");
\&     if (num_matches) {
\&        printf("substitute: s/[aeiou]//gi...%d substitutions made.\en",
\&               num_matches);
\&        printf("Now text is: %s\en\en", SvPV_nolen(text));
\&     }
\&
\&     /** Attempt a substitution **/
\&     if (!substitute(&text, "s/Perl/C/")) {
\&        printf("substitute: s/Perl/C...No substitution made.\en\en");
\&     }
\&
\&     SvREFCNT_dec(text);
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
which produces the output (again, long lines have been wrapped here)
.PP
.Vb 1
\&   match: Text contains the word \*(Aqquarter\*(Aq.
\&
\&   match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.
\&
\&   matches: m/(wi..)/g found 2 matches...
\&   match: will
\&   match: with
\&
\&   substitute: s/[aeiou]//gi...139 substitutions made.
\&   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
\&   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
\&   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
\&   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
\&   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. \-RCHH
\&
\&   substitute: s/Perl/C...No substitution made.
.Ve
.SS "Fiddling with the Perl stack from your C program"
.IX Subsection "Fiddling with the Perl stack from your C program"
When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto \*(L"the Perl
stack\*(R", shut its eyes while some magic happens, and then pop the
results\*(--the return value of your Perl subroutine\*(--off the stack.
.PP
First you'll need to know how to convert between C types and Perl
types, with \fInewSViv()\fR and \fIsv_setnv()\fR and \fInewAV()\fR and all their
friends.  They're described in perlguts and perlapi.
.PP
Then you'll need to know how to manipulate the Perl stack.  That's
described in perlcall.
.PP
Once you've understood those, embedding Perl in C is easy.
.PP
Because C has no builtin function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's \fI\fIpow()\fI\fR function).  First
I'll create a stub exponentiation function in \fIpower.pl\fR:
.PP
.Vb 4
\&    sub expo {
\&        my ($a, $b) = @_;
\&        return $a ** $b;
\&    }
.Ve
.PP
Now I'll create a C program, \fIpower.c\fR, with a function
\&\fI\fIPerlPower()\fI\fR that contains all the perlguts necessary to push the
two arguments into \fI\fIexpo()\fI\fR and to pop the return value out.  Take a
deep breath...
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    static void
\&    PerlPower(int a, int b)
\&    {
\&      dSP;                            /* initialize stack pointer      */
\&      ENTER;                          /* everything created after here */
\&      SAVETMPS;                       /* ...is a temporary variable.   */
\&      PUSHMARK(SP);                   /* remember the stack pointer    */
\&      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
\&      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
\&      PUTBACK;                      /* make local stack pointer global */
\&      call_pv("expo", G_SCALAR);      /* call the function             */
\&      SPAGAIN;                        /* refresh stack pointer         */
\&                                    /* pop the return value from stack */
\&      printf ("%d to the %dth power is %d.\en", a, b, POPi);
\&      PUTBACK;
\&      FREETMPS;                       /* free that return value        */
\&      LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
\&    }
\&
\&    int main (int argc, char **argv, char **env)
\&    {
\&      char *my_argv[] = { "", "power.pl" };
\&
\&      PERL_SYS_INIT3(&argc,&argv,&env);
\&      my_perl = perl_alloc();
\&      perl_construct( my_perl );
\&
\&      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
\&      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&      perl_run(my_perl);
\&
\&      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
\&
\&      perl_destruct(my_perl);
\&      perl_free(my_perl);
\&      PERL_SYS_TERM();
\&    }
.Ve
.PP
Compile and run:
.PP
.Vb 1
\&    % cc \-o power power.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % power
\&    3 to the 4th power is 81.
.Ve
.SS "Maintaining a persistent interpreter"
.IX Subsection "Maintaining a persistent interpreter"
When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.
.PP
However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package \f(CW\*(C`main\*(C'\fR.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.
.PP
Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.
.PP
If the file is pulled in by \f(CW\*(C`perl_parse()\*(C'\fR, compiled into a newly
constructed interpreter, and subsequently cleaned out with
\&\f(CW\*(C`perl_destruct()\*(C'\fR afterwards, you're shielded from most namespace
troubles.
.PP
One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile
the code into that package using \*(L"eval\*(R" in perlfunc.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using \*(L"call_argv\*(R" in perlapi, We'll
call the subroutine \f(CW\*(C`Embed::Persistent::eval_file\*(C'\fR which lives in the
file \f(CW\*(C`persistent.pl\*(C'\fR and pass the filename and boolean cleanup/cache
flag as arguments.
.PP
Note that the process will continue to grow for each file that it
uses.  In addition, there might be \f(CW\*(C`AUTOLOAD\*(C'\fRed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with \*(L"my\*(R" in perlfunc whenever possible.
.PP
.Vb 2
\& package Embed::Persistent;
\& #persistent.pl
\&
\& use strict;
\& our %Cache;
\& use Symbol qw(delete_package);
\&
\& sub valid_package_name {
\&     my($string) = @_;
\&     $string =~ s/([^A\-Za\-z0\-9\e/])/sprintf("_%2x",unpack("C",$1))/eg;
\&     # second pass only for words starting with a digit
\&     $string =~ s|/(\ed)|sprintf("/_%2x",unpack("C",$1))|eg;
\&
\&     # Dress it up as a real package name
\&     $string =~ s|/|::|g;
\&     return "Embed" . $string;
\& }
\&
\& sub eval_file {
\&     my($filename, $delete) = @_;
\&     my $package = valid_package_name($filename);
\&     my $mtime = \-M $filename;
\&     if(defined $Cache{$package}{mtime}
\&        &&
\&        $Cache{$package}{mtime} <= $mtime)
\&     {
\&        # we have compiled this subroutine already,
\&        # it has not been updated on disk, nothing left to do
\&        print STDERR "already compiled $package\->handler\en";
\&     }
\&     else {
\&        local *FH;
\&        open FH, $filename or die "open \*(Aq$filename\*(Aq $!";
\&        local($/) = undef;
\&        my $sub = <FH>;
\&        close FH;
\&
\&        #wrap the code into a subroutine inside our unique package
\&        my $eval = qq{package $package; sub handler { $sub; }};
\&        {
\&            # hide our variables within this block
\&            my($filename,$mtime,$package,$sub);
\&            eval $eval;
\&        }
\&        die $@ if $@;
\&
\&        #cache it unless we\*(Aqre cleaning out each time
\&        $Cache{$package}{mtime} = $mtime unless $delete;
\&     }
\&
\&     eval {$package\->handler;};
\&     die $@ if $@;
\&
\&     delete_package($package) if $delete;
\&
\&     #take a look if you want
\&     #print Devel::Symdump\->rnew($package)\->as_string, $/;
\& }
\&
\& 1;
\&
\& _\|_END_\|_
\&
\& /* persistent.c */
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* 1 = clean out filename\*(Aqs symbol table after each request, 0 = don\*(Aqt */
\& #ifndef DO_CLEAN
\& #define DO_CLEAN 0
\& #endif
\&
\& #define BUFFER_SIZE 1024
\&
\& static PerlInterpreter *my_perl = NULL;
\&
\& int
\& main(int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "persistent.pl" };
\&     char *args[] = { "", DO_CLEAN, NULL };
\&     char filename[BUFFER_SIZE];
\&     int exitstatus = 0;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     if((my_perl = perl_alloc()) == NULL) {
\&        fprintf(stderr, "no memory!");
\&        exit(1);
\&     }
\&     perl_construct(my_perl);
\&
\&     PL_origalen = 1; /* don\*(Aqt let $0 assignment update the proctitle or embedding[0] */
\&     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&     if(!exitstatus) {
\&        exitstatus = perl_run(my_perl);
\&
\&        while(printf("Enter file name: ") &&
\&              fgets(filename, BUFFER_SIZE, stdin)) {
\&
\&            filename[strlen(filename)\-1] = \*(Aq\e0\*(Aq; /* strip \en */
\&            /* call the subroutine, passing it the filename as an argument */
\&            args[0] = filename;
\&            call_argv("Embed::Persistent::eval_file",
\&                           G_DISCARD | G_EVAL, args);
\&
\&            /* check $@ */
\&            if(SvTRUE(ERRSV))
\&                fprintf(stderr, "eval error: %s\en", SvPV_nolen(ERRSV));
\&        }
\&     }
\&
\&     PL_perl_destruct_level = 0;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\&     exit(exitstatus);
\& }
.Ve
.PP
Now compile:
.PP
.Vb 1
\& % cc \-o persistent persistent.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Here's an example script file:
.PP
.Vb 3
\& #test.pl
\& my $string = "hello";
\& foo($string);
\&
\& sub foo {
\&     print "foo says: @_\en";
\& }
.Ve
.PP
Now run:
.PP
.Vb 7
\& % persistent
\& Enter file name: test.pl
\& foo says: hello
\& Enter file name: test.pl
\& already compiled Embed::test_2epl\->handler
\& foo says: hello
\& Enter file name: ^C
.Ve
.SS "Execution of \s-1END\s0 blocks"
.IX Subsection "Execution of END blocks"
Traditionally \s-1END\s0 blocks have been executed at the end of the perl_run.
This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify \f(CW\*(C`PL_exit_flags |= PERL_EXIT_DESTRUCT_END\*(C'\fR
to get the new behaviour. This also enables the running of \s-1END\s0 blocks if
the perl_parse fails and \f(CW\*(C`perl_destruct\*(C'\fR will return the exit value.
.ie n .SS "$0 assignments"
.el .SS "\f(CW$0\fP assignments"
.IX Subsection "$0 assignments"
When a perl script assigns a value to \f(CW$0\fR then the perl runtime will
try to make this value show up as the program name reported by \*(L"ps\*(R" by
updating the memory pointed to by the argv passed to \fIperl_parse()\fR and
also calling \s-1API\s0 functions like \fIsetproctitle()\fR where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value \f(CW1\fR to the variable \f(CW\*(C`PL_origalen\*(C'\fR
before \fIperl_parse()\fR is called.
.PP
The \fIpersistent.c\fR example above is for instance likely to segfault
when \f(CW$0\fR is assigned to if the \f(CW\*(C`PL_origalen = 1;\*(C'\fR assignment is
removed.  This because perl will try to write to the read only memory
of the \f(CW\*(C`embedding[]\*(C'\fR strings.
.SS "Maintaining multiple interpreter instances"
.IX Subsection "Maintaining multiple interpreter instances"
Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.
.PP
The program must take care to ensure that this takes place \fIbefore\fR
the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
\&\f(CW\*(C`PL_perl_destruct_level\*(C'\fR is set to \f(CW0\fR, since extra cleaning isn't
usually needed when a program only ever creates a single interpreter
in its entire lifetime.
.PP
Setting \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to \f(CW1\fR makes everything squeaky clean:
.PP
.Vb 10
\& while(1) {
\&     ...
\&     /* reset global variables here with PL_perl_destruct_level = 1 */
\&     PL_perl_destruct_level = 1;
\&     perl_construct(my_perl);
\&     ...
\&     /* clean and reset _everything_ during perl_destruct */
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     ...
\&     /* let\*(Aqs go do it again! */
\& }
.Ve
.PP
When \fI\fIperl_destruct()\fI\fR is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.  The
second assignment to \f(CW\*(C`PL_perl_destruct_level\*(C'\fR is needed because
perl_construct resets it to \f(CW0\fR.
.PP
Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the Configure option
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR or the options \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR when
building perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to
\&\f(CW1\fR, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.
.PP
See also \*(L"Thread-aware system interfaces\*(R" in perlxs.
.PP
Using \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR rather than \f(CW\*(C`\-Dusemultiplicity\*(C'\fR
is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.
.PP
Let's give it a try:
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* we\*(Aqre going to embed two interpreters */
\&
\& #define SAY_HELLO "\-e", "print qq(Hi, I\*(Aqm $^X\en)"
\&
\& int main(int argc, char **argv, char **env)
\& {
\&     PerlInterpreter *one_perl, *two_perl;
\&     char *one_args[] = { "one_perl", SAY_HELLO };
\&     char *two_args[] = { "two_perl", SAY_HELLO };
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     one_perl = perl_alloc();
\&     two_perl = perl_alloc();
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_construct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_construct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_run(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_run(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_destruct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_destruct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_free(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_free(two_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
Note the calls to \s-1\fIPERL_SET_CONTEXT\s0()\fR.  These are necessary to initialize
the global state that tracks which interpreter is the \*(L"current\*(R" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl \s-1API\s0 calls on both interpreters in an interleaved fashion.
.PP
\&\s-1PERL_SET_CONTEXT\s0(interp) should also be called whenever \f(CW\*(C`interp\*(C'\fR is
used by a thread that did not create it (using either \fIperl_alloc()\fR, or
the more esoteric \fIperl_clone()\fR).
.PP
Compile as usual:
.PP
.Vb 1
\& % cc \-o multiplicity multiplicity.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Run it, Run it:
.PP
.Vb 3
\& % multiplicity
\& Hi, I\*(Aqm one_perl
\& Hi, I\*(Aqm two_perl
.Ve
.SS "Using Perl modules, which themselves use C libraries, from your C program"
.IX Subsection "Using Perl modules, which themselves use C libraries, from your C program"
If you've played with the examples above and tried to embed a script
that \fI\fIuse()\fI\fRs a Perl module (such as \fISocket\fR) which itself uses a C or \*(C+ library,
this probably happened:
.PP
.Vb 3
\& Can\*(Aqt load module Socket, dynamic loading not available in this perl.
\&  (You may need to build a new perl executable which either supports
\&  dynamic loading or has the Socket module statically linked into it.)
.Ve
.PP
What's wrong?
.PP
Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been
calling \fI\fIperl_parse()\fI\fR, handing it \s-1NULL\s0 for the second argument:
.PP
.Vb 1
\& perl_parse(my_perl, NULL, argc, my_argv, NULL);
.Ve
.PP
That's where the glue code can be inserted to create the initial contact between
Perl and linked C/\*(C+ routines.  Let's take a look some pieces of \fIperlmain.c\fR
to see how Perl does this:
.PP
.Vb 1
\& static void xs_init (pTHX);
\&
\& EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
\& EXTERN_C void boot_Socket (pTHX_ CV* cv);
\&
\&
\& EXTERN_C void
\& xs_init(pTHX)
\& {
\&        char *file = _\|_FILE_\|_;
\&        /* DynaLoader is a special case */
\&        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
\&        newXS("Socket::bootstrap", boot_Socket, file);
\& }
.Ve
.PP
Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
\&\fI\fIModule::bootstrap()\fI\fR and is invoked when you say \fIuse Module\fR.  In
turn, this hooks into an \s-1XSUB, \s0\fIboot_Module\fR, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the \fIxsubpp\fR and extension authors.  If your
extension is dynamically loaded, DynaLoader creates \fI\fIModule::bootstrap()\fI\fR
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.
.PP
Once you have this code, slap it into the second argument of \fI\fIperl_parse()\fI\fR:
.PP
.Vb 1
\& perl_parse(my_perl, xs_init, argc, my_argv, NULL);
.Ve
.PP
Then compile:
.PP
.Vb 1
\& % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\& % interp
\&   use Socket;
\&   use SomeDynamicallyLoadedModule;
\&
\&   print "Now I can use extensions!\en"\*(Aq
.Ve
.PP
\&\fBExtUtils::Embed\fR can also automate writing the \fIxs_init\fR glue code.
.PP
.Vb 4
\& % perl \-MExtUtils::Embed \-e xsinit \-\- \-o perlxsi.c
\& % cc \-c perlxsi.c \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-c interp.c  \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-o interp perlxsi.o interp.o \`perl \-MExtUtils::Embed \-e ldopts\`
.Ve
.PP
Consult perlxs, perlguts, and perlapi for more details.
.SH "Hiding Perl_"
.IX Header "Hiding Perl_"
If you completely hide the short forms of the Perl public \s-1API,\s0
add \-DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing
.PP
.Vb 1
\&    warn("%d bottles of beer on the wall", bottlecount);
.Ve
.PP
you will have to write the explicit full form
.PP
.Vb 1
\&    Perl_warn(aTHX_ "%d bottles of beer on the wall", bottlecount);
.Ve
.PP
(See \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 in perlguts for the explanation
of the \f(CW\*(C`aTHX_\*(C'\fR. )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)
.SH "MORAL"
.IX Header "MORAL"
You can sometimes \fIwrite faster code\fR in C, but
you can always \fIwrite code faster\fR in Perl.  Because you can use
each from the other, combine them as you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jon Orwant <\fIorwant@media.mit.edu\fR> and Doug MacEachern
<\fIdougm@covalent.net\fR>, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.
.PP
Doug MacEachern has an article on embedding in Volume 1, Issue 4 of
The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.  All
Rights Reserved.
.PP
This document may be distributed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlembed5.16.1                              0100644 0001750 0001750 00000130033 12566207416 023212  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEMBED 1"
.TH PERLEMBED 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlembed \- how to embed perl in your C program
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1PREAMBLE\s0"
.IX Subsection "PREAMBLE"
Do you want to:
.IP "\fBUse C from Perl?\fR" 5
.IX Item "Use C from Perl?"
Read perlxstut, perlxs, h2xs, perlguts, and perlapi.
.IP "\fBUse a Unix program from Perl?\fR" 5
.IX Item "Use a Unix program from Perl?"
Read about back-quotes and about \f(CW\*(C`system\*(C'\fR and \f(CW\*(C`exec\*(C'\fR in perlfunc.
.IP "\fBUse Perl from Perl?\fR" 5
.IX Item "Use Perl from Perl?"
Read about \*(L"do\*(R" in perlfunc and \*(L"eval\*(R" in perlfunc and \*(L"require\*(R" in perlfunc 
and \*(L"use\*(R" in perlfunc.
.IP "\fBUse C from C?\fR" 5
.IX Item "Use C from C?"
Rethink your design.
.IP "\fBUse Perl from C?\fR" 5
.IX Item "Use Perl from C?"
Read on...
.SS "\s-1ROADMAP\s0"
.IX Subsection "ROADMAP"
.IP "\(bu" 5
Compiling your C program
.IP "\(bu" 5
Adding a Perl interpreter to your C program
.IP "\(bu" 5
Calling a Perl subroutine from your C program
.IP "\(bu" 5
Evaluating a Perl statement from your C program
.IP "\(bu" 5
Performing Perl pattern matches and substitutions from your C program
.IP "\(bu" 5
Fiddling with the Perl stack from your C program
.IP "\(bu" 5
Maintaining a persistent interpreter
.IP "\(bu" 5
Maintaining multiple interpreter instances
.IP "\(bu" 5
Using Perl modules, which themselves use C libraries, from your C program
.IP "\(bu" 5
Embedding Perl under Win32
.SS "Compiling your C program"
.IX Subsection "Compiling your C program"
If you have trouble compiling the scripts in this documentation,
you're not alone.  The cardinal rule: \s-1COMPILE\s0 \s-1THE\s0 \s-1PROGRAMS\s0 \s-1IN\s0 \s-1EXACTLY\s0
\&\s-1THE\s0 \s-1SAME\s0 \s-1WAY\s0 \s-1THAT\s0 \s-1YOUR\s0 \s-1PERL\s0 \s-1WAS\s0 \s-1COMPILED\s0.  (Sorry for yelling.)
.PP
Also, every C program that uses Perl must link in the \fIperl library\fR.
What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (\fI/usr/bin/perl\fR or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly\*(--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
\&\fIlib\fR directory.)
.PP
When you use Perl from C, your C program will\*(--usually\-\-allocate,
\&\*(L"run\*(R", and deallocate a \fIPerlInterpreter\fR object, which is defined by
the perl library.
.PP
If your copy of Perl is recent enough to contain this documentation
(version 5.002 or later), then the perl library (and \fI\s-1EXTERN\s0.h\fR and
\&\fIperl.h\fR, which you'll also need) will reside in a directory
that looks like this:
.PP
.Vb 1
\&    /usr/local/lib/perl5/your_architecture_here/CORE
.Ve
.PP
or perhaps just
.PP
.Vb 1
\&    /usr/local/lib/perl5/CORE
.Ve
.PP
or maybe something like
.PP
.Vb 1
\&    /usr/opt/perl5/CORE
.Ve
.PP
Execute this statement for a hint about where to find \s-1CORE:\s0
.PP
.Vb 1
\&    perl \-MConfig \-e \*(Aqprint $Config{archlib}\*(Aq
.Ve
.PP
Here's how you'd compile the example in the next section,
\&\*(L"Adding a Perl interpreter to your C program\*(R", on my Linux box:
.PP
.Vb 4
\&    % gcc \-O2 \-Dbool=char \-DHAS_BOOL \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-L/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-o interp interp.c \-lperl \-lm
.Ve
.PP
(That's all one line.)  On my \s-1DEC\s0 Alpha running old 5.003_05, the 
incantation is a bit different:
.PP
.Vb 4
\&    % cc \-O2 \-Olimit 2900 \-DSTANDARD_C \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE
\&    \-L/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE \-L/usr/local/lib
\&    \-D_\|_LANGUAGE_C_\|_ \-D_NO_PROTO \-o interp interp.c \-lperl \-lm
.Ve
.PP
How can you figure out what to add?  Assuming your Perl is post\-5.001,
execute a \f(CW\*(C`perl \-V\*(C'\fR command and pay special attention to the \*(L"cc\*(R" and
\&\*(L"ccflags\*(R" information.
.PP
You'll have to choose the appropriate compiler (\fIcc\fR, \fIgcc\fR, et al.) for
your machine: \f(CW\*(C`perl \-MConfig \-e \*(Aqprint $Config{cc}\*(Aq\*(C'\fR will tell you what
to use.
.PP
You'll also have to choose the appropriate library directory
(\fI/usr/local/lib/...\fR) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
\&\fI\-lperl\fR, then you need to change the path following the \f(CW\*(C`\-L\*(C'\fR.  If it
complains that it can't find \fI\s-1EXTERN\s0.h\fR and \fIperl.h\fR, you need to
change the path following the \f(CW\*(C`\-I\*(C'\fR.
.PP
You may have to add extra libraries as well.  Which ones?
Perhaps those printed by
.PP
.Vb 1
\&   perl \-MConfig \-e \*(Aqprint $Config{libs}\*(Aq
.Ve
.PP
Provided your perl binary was properly configured and installed the
\&\fBExtUtils::Embed\fR module will determine all of this information for
you:
.PP
.Vb 1
\&   % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
If the \fBExtUtils::Embed\fR module isn't part of your Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by\-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)
.PP
The \fBExtUtils::Embed\fR kit on \s-1CPAN\s0 also contains all source code for
the examples in this document, tests, additional examples and other
information you may find useful.
.SS "Adding a Perl interpreter to your C program"
.IX Subsection "Adding a Perl interpreter to your C program"
In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with \fIminiperlmain.c\fR,
included in the source distribution.  Here's a bastardized, non-portable
version of \fIminiperlmain.c\fR containing the essentials of embedding:
.PP
.Vb 2
\&    #include <EXTERN.h>               /* from the Perl distribution     */
\&    #include <perl.h>                 /* from the Perl distribution     */
\&
\&    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
\&        perl_run(my_perl);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
Notice that we don't use the \f(CW\*(C`env\*(C'\fR pointer.  Normally handed to
\&\f(CW\*(C`perl_parse\*(C'\fR as its final argument, \f(CW\*(C`env\*(C'\fR here is replaced by
\&\f(CW\*(C`NULL\*(C'\fR, which means that the current environment will be used.
.PP
The macros \s-1\fIPERL_SYS_INIT3\s0()\fR and \s-1\fIPERL_SYS_TERM\s0()\fR provide system-specific
tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call \s-1\fIPERL_SYS_INIT3\s0()\fR before you create your first
interpreter, and \s-1\fIPERL_SYS_TERM\s0()\fR after you free your last interpreter.
.PP
Since \s-1\fIPERL_SYS_INIT3\s0()\fR may change \f(CW\*(C`env\*(C'\fR, it may be more appropriate to
provide \f(CW\*(C`env\*(C'\fR as an argument to \fIperl_parse()\fR.
.PP
Also notice that no matter what arguments you pass to \fIperl_parse()\fR,
\&\s-1\fIPERL_SYS_INIT3\s0()\fR must be invoked on the C \fImain()\fR argc, argv and env and
only once.
.PP
Now compile this program (I'll call it \fIinterp.c\fR) into an executable:
.PP
.Vb 1
\&    % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
After a successful compilation, you'll be able to use \fIinterp\fR just
like perl itself:
.PP
.Vb 6
\&    % interp
\&    print "Pretty Good Perl \en";
\&    print "10890 \- 9801 is ", 10890 \- 9801;
\&    <CTRL\-D>
\&    Pretty Good Perl
\&    10890 \- 9801 is 1089
.Ve
.PP
or
.PP
.Vb 2
\&    % interp \-e \*(Aqprintf("%x", 3735928559)\*(Aq
\&    deadbeef
.Ve
.PP
You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in \fIargv[1]\fR before
calling \fIperl_run\fR.
.SS "Calling a Perl subroutine from your C program"
.IX Subsection "Calling a Perl subroutine from your C program"
To call individual Perl subroutines, you can use any of the \fBcall_*\fR
functions documented in perlcall.
In this example we'll use \f(CW\*(C`call_argv\*(C'\fR.
.PP
That's shown below, in a program I'll call \fIshowtime.c\fR.
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        char *args[] = { NULL };
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&
\&        perl_parse(my_perl, NULL, argc, argv, NULL);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&        /*** skipping perl_run() ***/
\&
\&        call_argv("showtime", G_DISCARD | G_NOARGS, args);
\&
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
where \fIshowtime\fR is a Perl subroutine that takes no arguments (that's the
\&\fIG_NOARGS\fR) and for which I'll ignore the return value (that's the
\&\fIG_DISCARD\fR).  Those flags, and others, are discussed in perlcall.
.PP
I'll define the \fIshowtime\fR subroutine in a file called \fIshowtime.pl\fR:
.PP
.Vb 1
\&    print "I shan\*(Aqt be printed.";
\&
\&    sub showtime {
\&        print time;
\&    }
.Ve
.PP
Simple enough.  Now compile and run:
.PP
.Vb 1
\&    % cc \-o showtime showtime.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % showtime showtime.pl
\&    818284590
.Ve
.PP
yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the Unix epoch), and the moment I began writing this
sentence.
.PP
In this particular case we don't have to call \fIperl_run\fR, as we set 
the PL_exit_flag \s-1PERL_EXIT_DESTRUCT_END\s0 which executes \s-1END\s0 blocks in
perl_destruct.
.PP
If you want to pass arguments to the Perl subroutine, you can add
strings to the \f(CW\*(C`NULL\*(C'\fR\-terminated \f(CW\*(C`args\*(C'\fR list passed to
\&\fIcall_argv\fR.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in
\&\*(L"Fiddling with the Perl stack from your C program\*(R".
.SS "Evaluating a Perl statement from your C program"
.IX Subsection "Evaluating a Perl statement from your C program"
Perl provides two \s-1API\s0 functions to evaluate pieces of Perl code.
These are \*(L"eval_sv\*(R" in perlapi and \*(L"eval_pv\*(R" in perlapi.
.PP
Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
\&\*(L"use\*(R" in perlfunc, \*(L"require\*(R" in perlfunc, and \*(L"do\*(R" in perlfunc to
include external Perl files.
.PP
\&\fIeval_pv\fR lets us evaluate individual Perl strings, and then
extract variables for coercion into C types.  The following program,
\&\fIstring.c\fR, executes three Perl strings, extracting an \f(CW\*(C`int\*(C'\fR from
the first, a \f(CW\*(C`float\*(C'\fR from the second, and a \f(CW\*(C`char *\*(C'\fR from the third.
.PP
.Vb 2
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&
\&   static PerlInterpreter *my_perl;
\&
\&   main (int argc, char **argv, char **env)
\&   {
\&       char *embedding[] = { "", "\-e", "0" };
\&
\&       PERL_SYS_INIT3(&argc,&argv,&env);
\&       my_perl = perl_alloc();
\&       perl_construct( my_perl );
\&
\&       perl_parse(my_perl, NULL, 3, embedding, NULL);
\&       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&       perl_run(my_perl);
\&
\&       /** Treat $a as an integer **/
\&       eval_pv("$a = 3; $a **= 2", TRUE);
\&       printf("a = %d\en", SvIV(get_sv("a", 0)));
\&
\&       /** Treat $a as a float **/
\&       eval_pv("$a = 3.14; $a **= 2", TRUE);
\&       printf("a = %f\en", SvNV(get_sv("a", 0)));
\&
\&       /** Treat $a as a string **/
\&       eval_pv("$a = \*(AqrekcaH lreP rehtonA tsuJ\*(Aq; $a = reverse($a);", TRUE);
\&       printf("a = %s\en", SvPV_nolen(get_sv("a", 0)));
\&
\&       perl_destruct(my_perl);
\&       perl_free(my_perl);
\&       PERL_SYS_TERM();
\&   }
.Ve
.PP
All of those strange functions with \fIsv\fR in their names help convert Perl scalars to C types.  They're described in perlguts and perlapi.
.PP
If you compile and run \fIstring.c\fR, you'll see the results of using
\&\fI\fISvIV()\fI\fR to create an \f(CW\*(C`int\*(C'\fR, \fI\fISvNV()\fI\fR to create a \f(CW\*(C`float\*(C'\fR, and
\&\fI\fISvPV()\fI\fR to create a string:
.PP
.Vb 3
\&   a = 9
\&   a = 9.859600
\&   a = Just Another Perl Hacker
.Ve
.PP
In the example above, we've created a global variable to temporarily
store the computed value of our eval'ed expression.  It is also
possible and in most cases a better strategy to fetch the return value
from \fI\fIeval_pv()\fI\fR instead.  Example:
.PP
.Vb 4
\&   ...
\&   SV *val = eval_pv("reverse \*(AqrekcaH lreP rehtonA tsuJ\*(Aq", TRUE);
\&   printf("%s\en", SvPV_nolen(val));
\&   ...
.Ve
.PP
This way, we avoid namespace pollution by not creating global
variables and we've simplified our code as well.
.SS "Performing Perl pattern matches and substitutions from your C program"
.IX Subsection "Performing Perl pattern matches and substitutions from your C program"
The \fI\fIeval_sv()\fI\fR function lets us evaluate strings of Perl code, so we can
define some functions that use it to \*(L"specialize\*(R" in matches and
substitutions: \fI\fImatch()\fI\fR, \fI\fIsubstitute()\fI\fR, and \fI\fImatches()\fI\fR.
.PP
.Vb 1
\&   I32 match(SV *string, char *pattern);
.Ve
.PP
Given a string and a pattern (e.g., \f(CW\*(C`m/clasp/\*(C'\fR or \f(CW\*(C`/\eb\ew*\eb/\*(C'\fR, which
in your C program might appear as \*(L"/\e\eb\e\ew*\e\eb/\*(R"), \fImatch()\fR
returns 1 if the string matches the pattern and 0 otherwise.
.PP
.Vb 1
\&   int substitute(SV **string, char *pattern);
.Ve
.PP
Given a pointer to an \f(CW\*(C`SV\*(C'\fR and an \f(CW\*(C`=~\*(C'\fR operation (e.g.,
\&\f(CW\*(C`s/bob/robert/g\*(C'\fR or \f(CW\*(C`tr[A\-Z][a\-z]\*(C'\fR), \fIsubstitute()\fR modifies the string
within the \f(CW\*(C`SV\*(C'\fR as according to the operation, returning the number of substitutions
made.
.PP
.Vb 1
\&   int matches(SV *string, char *pattern, AV **matches);
.Ve
.PP
Given an \f(CW\*(C`SV\*(C'\fR, a pattern, and a pointer to an empty \f(CW\*(C`AV\*(C'\fR,
\&\fImatches()\fR evaluates \f(CW\*(C`$string =~ $pattern\*(C'\fR in a list context, and
fills in \fImatches\fR with the array elements, returning the number of matches found.
.PP
Here's a sample program, \fImatch.c\fR, that uses all three (long lines have
been wrapped here):
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& static PerlInterpreter *my_perl;
\&
\& /** my_eval_sv(code, error_check)
\& ** kinda like eval_sv(), 
\& ** but we pop the return value off the stack 
\& **/
\& SV* my_eval_sv(SV *sv, I32 croak_on_error)
\& {
\&     dSP;
\&     SV* retval;
\&
\&
\&     PUSHMARK(SP);
\&     eval_sv(sv, G_SCALAR);
\&
\&     SPAGAIN;
\&     retval = POPs;
\&     PUTBACK;
\&
\&     if (croak_on_error && SvTRUE(ERRSV))
\&        croak(SvPVx_nolen(ERRSV));
\&
\&     return retval;
\& }
\&
\& /** match(string, pattern)
\& **
\& ** Used for matches in a scalar context.
\& **
\& ** Returns 1 if the match was successful; 0 otherwise.
\& **/
\&
\& I32 match(SV *string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; $string =~ %s",
\&              SvPV_nolen(string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     return SvIV(retval);
\& }
\&
\& /** substitute(string, pattern)
\& **
\& ** Used for =~ operations that modify their left\-hand side (s/// and tr///)
\& **
\& ** Returns the number of successful matches, and
\& ** modifies the input string if there were any.
\& **/
\&
\& I32 substitute(SV **string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "$string = \*(Aq%s\*(Aq; ($string =~ %s)",
\&              SvPV_nolen(*string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *string = get_sv("string", 0);
\&     return SvIV(retval);
\& }
\&
\& /** matches(string, pattern, matches)
\& **
\& ** Used for matches in a list context.
\& **
\& ** Returns the number of matches,
\& ** and fills in **matches with the matching substrings
\& **/
\&
\& I32 matches(SV *string, char *pattern, AV **match_list)
\& {
\&     SV *command = newSV(0);
\&     I32 num_matches;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; @array = ($string =~ %s)",
\&              SvPV_nolen(string), pattern);
\&
\&     my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *match_list = get_av("array", 0);
\&     num_matches = av_len(*match_list) + 1;
\&
\&     return num_matches;
\& }
\&
\& main (int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "\-e", "0" };
\&     AV *match_list;
\&     I32 num_matches, i;
\&     SV *text;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     my_perl = perl_alloc();
\&     perl_construct(my_perl);
\&     perl_parse(my_perl, NULL, 3, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&     text = newSV(0);
\&     sv_setpv(text, "When he is at a convenience store and the "
\&        "bill comes to some amount like 76 cents, Maynard is "
\&        "aware that there is something he *should* do, something "
\&        "that will enable him to get back a quarter, but he has "
\&        "no idea *what*.  He fumbles through his red squeezey "
\&        "changepurse and gives the boy three extra pennies with "
\&        "his dollar, hoping that he might luck into the correct "
\&        "amount.  The boy gives him back two of his own pennies "
\&        "and then the big shiny quarter that is his prize. "
\&        "\-RICHH");
\&
\&     if (match(text, "m/quarter/")) /** Does text contain \*(Aqquarter\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqquarter\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqquarter\*(Aq.\en\en");
\&
\&     if (match(text, "m/eighth/")) /** Does text contain \*(Aqeighth\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqeighth\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.\en\en");
\&
\&     /** Match all occurrences of /wi../ **/
\&     num_matches = matches(text, "m/(wi..)/g", &match_list);
\&     printf("matches: m/(wi..)/g found %d matches...\en", num_matches);
\&
\&     for (i = 0; i < num_matches; i++)
\&        printf("match: %s\en", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
\&     printf("\en");
\&
\&     /** Remove all vowels from text **/
\&     num_matches = substitute(&text, "s/[aeiou]//gi");
\&     if (num_matches) {
\&        printf("substitute: s/[aeiou]//gi...%d substitutions made.\en",
\&               num_matches);
\&        printf("Now text is: %s\en\en", SvPV_nolen(text));
\&     }
\&
\&     /** Attempt a substitution **/
\&     if (!substitute(&text, "s/Perl/C/")) {
\&        printf("substitute: s/Perl/C...No substitution made.\en\en");
\&     }
\&
\&     SvREFCNT_dec(text);
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
which produces the output (again, long lines have been wrapped here)
.PP
.Vb 1
\&   match: Text contains the word \*(Aqquarter\*(Aq.
\&
\&   match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.
\&
\&   matches: m/(wi..)/g found 2 matches...
\&   match: will
\&   match: with
\&
\&   substitute: s/[aeiou]//gi...139 substitutions made.
\&   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
\&   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
\&   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
\&   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
\&   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. \-RCHH
\&
\&   substitute: s/Perl/C...No substitution made.
.Ve
.SS "Fiddling with the Perl stack from your C program"
.IX Subsection "Fiddling with the Perl stack from your C program"
When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto \*(L"the Perl
stack\*(R", shut its eyes while some magic happens, and then pop the
results\*(--the return value of your Perl subroutine\*(--off the stack.
.PP
First you'll need to know how to convert between C types and Perl
types, with \fInewSViv()\fR and \fIsv_setnv()\fR and \fInewAV()\fR and all their
friends.  They're described in perlguts and perlapi.
.PP
Then you'll need to know how to manipulate the Perl stack.  That's
described in perlcall.
.PP
Once you've understood those, embedding Perl in C is easy.
.PP
Because C has no builtin function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's \fI\fIpow()\fI\fR function).  First
I'll create a stub exponentiation function in \fIpower.pl\fR:
.PP
.Vb 4
\&    sub expo {
\&        my ($a, $b) = @_;
\&        return $a ** $b;
\&    }
.Ve
.PP
Now I'll create a C program, \fIpower.c\fR, with a function
\&\fI\fIPerlPower()\fI\fR that contains all the perlguts necessary to push the
two arguments into \fI\fIexpo()\fI\fR and to pop the return value out.  Take a
deep breath...
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    static void
\&    PerlPower(int a, int b)
\&    {
\&      dSP;                            /* initialize stack pointer      */
\&      ENTER;                          /* everything created after here */
\&      SAVETMPS;                       /* ...is a temporary variable.   */
\&      PUSHMARK(SP);                   /* remember the stack pointer    */
\&      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
\&      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
\&      PUTBACK;                      /* make local stack pointer global */
\&      call_pv("expo", G_SCALAR);      /* call the function             */
\&      SPAGAIN;                        /* refresh stack pointer         */
\&                                    /* pop the return value from stack */
\&      printf ("%d to the %dth power is %d.\en", a, b, POPi);
\&      PUTBACK;
\&      FREETMPS;                       /* free that return value        */
\&      LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
\&    }
\&
\&    int main (int argc, char **argv, char **env)
\&    {
\&      char *my_argv[] = { "", "power.pl" };
\&
\&      PERL_SYS_INIT3(&argc,&argv,&env);
\&      my_perl = perl_alloc();
\&      perl_construct( my_perl );
\&
\&      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
\&      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&      perl_run(my_perl);
\&
\&      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
\&
\&      perl_destruct(my_perl);
\&      perl_free(my_perl);
\&      PERL_SYS_TERM();
\&    }
.Ve
.PP
Compile and run:
.PP
.Vb 1
\&    % cc \-o power power.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % power
\&    3 to the 4th power is 81.
.Ve
.SS "Maintaining a persistent interpreter"
.IX Subsection "Maintaining a persistent interpreter"
When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.
.PP
However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package \f(CW\*(C`main\*(C'\fR.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.
.PP
Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.
.PP
If the file is pulled in by \f(CW\*(C`perl_parse()\*(C'\fR, compiled into a newly
constructed interpreter, and subsequently cleaned out with
\&\f(CW\*(C`perl_destruct()\*(C'\fR afterwards, you're shielded from most namespace
troubles.
.PP
One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile
the code into that package using \*(L"eval\*(R" in perlfunc.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using \*(L"call_argv\*(R" in perlapi, We'll
call the subroutine \f(CW\*(C`Embed::Persistent::eval_file\*(C'\fR which lives in the
file \f(CW\*(C`persistent.pl\*(C'\fR and pass the filename and boolean cleanup/cache
flag as arguments.
.PP
Note that the process will continue to grow for each file that it
uses.  In addition, there might be \f(CW\*(C`AUTOLOAD\*(C'\fRed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with \*(L"my\*(R" in perlfunc whenever possible.
.PP
.Vb 2
\& package Embed::Persistent;
\& #persistent.pl
\&
\& use strict;
\& our %Cache;
\& use Symbol qw(delete_package);
\&
\& sub valid_package_name {
\&     my($string) = @_;
\&     $string =~ s/([^A\-Za\-z0\-9\e/])/sprintf("_%2x",unpack("C",$1))/eg;
\&     # second pass only for words starting with a digit
\&     $string =~ s|/(\ed)|sprintf("/_%2x",unpack("C",$1))|eg;
\&
\&     # Dress it up as a real package name
\&     $string =~ s|/|::|g;
\&     return "Embed" . $string;
\& }
\&
\& sub eval_file {
\&     my($filename, $delete) = @_;
\&     my $package = valid_package_name($filename);
\&     my $mtime = \-M $filename;
\&     if(defined $Cache{$package}{mtime}
\&        &&
\&        $Cache{$package}{mtime} <= $mtime)
\&     {
\&        # we have compiled this subroutine already,
\&        # it has not been updated on disk, nothing left to do
\&        print STDERR "already compiled $package\->handler\en";
\&     }
\&     else {
\&        local *FH;
\&        open FH, $filename or die "open \*(Aq$filename\*(Aq $!";
\&        local($/) = undef;
\&        my $sub = <FH>;
\&        close FH;
\&
\&        #wrap the code into a subroutine inside our unique package
\&        my $eval = qq{package $package; sub handler { $sub; }};
\&        {
\&            # hide our variables within this block
\&            my($filename,$mtime,$package,$sub);
\&            eval $eval;
\&        }
\&        die $@ if $@;
\&
\&        #cache it unless we\*(Aqre cleaning out each time
\&        $Cache{$package}{mtime} = $mtime unless $delete;
\&     }
\&
\&     eval {$package\->handler;};
\&     die $@ if $@;
\&
\&     delete_package($package) if $delete;
\&
\&     #take a look if you want
\&     #print Devel::Symdump\->rnew($package)\->as_string, $/;
\& }
\&
\& 1;
\&
\& _\|_END_\|_
\&
\& /* persistent.c */
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* 1 = clean out filename\*(Aqs symbol table after each request, 0 = don\*(Aqt */
\& #ifndef DO_CLEAN
\& #define DO_CLEAN 0
\& #endif
\&
\& #define BUFFER_SIZE 1024
\&
\& static PerlInterpreter *my_perl = NULL;
\&
\& int
\& main(int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "persistent.pl" };
\&     char *args[] = { "", DO_CLEAN, NULL };
\&     char filename[BUFFER_SIZE];
\&     int exitstatus = 0;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     if((my_perl = perl_alloc()) == NULL) {
\&        fprintf(stderr, "no memory!");
\&        exit(1);
\&     }
\&     perl_construct(my_perl);
\&
\&     PL_origalen = 1; /* don\*(Aqt let $0 assignment update the proctitle or embedding[0] */
\&     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&     if(!exitstatus) {
\&        exitstatus = perl_run(my_perl);
\&
\&        while(printf("Enter file name: ") &&
\&              fgets(filename, BUFFER_SIZE, stdin)) {
\&
\&            filename[strlen(filename)\-1] = \*(Aq\e0\*(Aq; /* strip \en */
\&            /* call the subroutine, passing it the filename as an argument */
\&            args[0] = filename;
\&            call_argv("Embed::Persistent::eval_file",
\&                           G_DISCARD | G_EVAL, args);
\&
\&            /* check $@ */
\&            if(SvTRUE(ERRSV))
\&                fprintf(stderr, "eval error: %s\en", SvPV_nolen(ERRSV));
\&        }
\&     }
\&
\&     PL_perl_destruct_level = 0;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\&     exit(exitstatus);
\& }
.Ve
.PP
Now compile:
.PP
.Vb 1
\& % cc \-o persistent persistent.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Here's an example script file:
.PP
.Vb 3
\& #test.pl
\& my $string = "hello";
\& foo($string);
\&
\& sub foo {
\&     print "foo says: @_\en";
\& }
.Ve
.PP
Now run:
.PP
.Vb 7
\& % persistent
\& Enter file name: test.pl
\& foo says: hello
\& Enter file name: test.pl
\& already compiled Embed::test_2epl\->handler
\& foo says: hello
\& Enter file name: ^C
.Ve
.SS "Execution of \s-1END\s0 blocks"
.IX Subsection "Execution of END blocks"
Traditionally \s-1END\s0 blocks have been executed at the end of the perl_run.
This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify \f(CW\*(C`PL_exit_flags |= PERL_EXIT_DESTRUCT_END\*(C'\fR
to get the new behaviour. This also enables the running of \s-1END\s0 blocks if
the perl_parse fails and \f(CW\*(C`perl_destruct\*(C'\fR will return the exit value.
.ie n .SS "$0 assignments"
.el .SS "\f(CW$0\fP assignments"
.IX Subsection "$0 assignments"
When a perl script assigns a value to \f(CW$0\fR then the perl runtime will
try to make this value show up as the program name reported by \*(L"ps\*(R" by
updating the memory pointed to by the argv passed to \fIperl_parse()\fR and
also calling \s-1API\s0 functions like \fIsetproctitle()\fR where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value \f(CW1\fR to the variable \f(CW\*(C`PL_origalen\*(C'\fR
before \fIperl_parse()\fR is called.
.PP
The \fIpersistent.c\fR example above is for instance likely to segfault
when \f(CW$0\fR is assigned to if the \f(CW\*(C`PL_origalen = 1;\*(C'\fR assignment is
removed.  This because perl will try to write to the read only memory
of the \f(CW\*(C`embedding[]\*(C'\fR strings.
.SS "Maintaining multiple interpreter instances"
.IX Subsection "Maintaining multiple interpreter instances"
Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.
.PP
The program must take care to ensure that this takes place \fIbefore\fR
the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
\&\f(CW\*(C`PL_perl_destruct_level\*(C'\fR is set to \f(CW0\fR, since extra cleaning isn't
usually needed when a program only ever creates a single interpreter
in its entire lifetime.
.PP
Setting \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to \f(CW1\fR makes everything squeaky clean:
.PP
.Vb 10
\& while(1) {
\&     ...
\&     /* reset global variables here with PL_perl_destruct_level = 1 */
\&     PL_perl_destruct_level = 1;
\&     perl_construct(my_perl);
\&     ...
\&     /* clean and reset _everything_ during perl_destruct */
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     ...
\&     /* let\*(Aqs go do it again! */
\& }
.Ve
.PP
When \fI\fIperl_destruct()\fI\fR is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.  The
second assignment to \f(CW\*(C`PL_perl_destruct_level\*(C'\fR is needed because
perl_construct resets it to \f(CW0\fR.
.PP
Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the Configure option
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR or the options \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR when
building perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to
\&\f(CW1\fR, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.
.PP
See also \*(L"Thread-aware system interfaces\*(R" in perlxs.
.PP
Using \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR rather than \f(CW\*(C`\-Dusemultiplicity\*(C'\fR
is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.
.PP
Let's give it a try:
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* we\*(Aqre going to embed two interpreters */
\&
\& #define SAY_HELLO "\-e", "print qq(Hi, I\*(Aqm $^X\en)"
\&
\& int main(int argc, char **argv, char **env)
\& {
\&     PerlInterpreter *one_perl, *two_perl;
\&     char *one_args[] = { "one_perl", SAY_HELLO };
\&     char *two_args[] = { "two_perl", SAY_HELLO };
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     one_perl = perl_alloc();
\&     two_perl = perl_alloc();
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_construct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_construct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_run(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_run(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_destruct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_destruct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_free(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_free(two_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
Note the calls to \s-1\fIPERL_SET_CONTEXT\s0()\fR.  These are necessary to initialize
the global state that tracks which interpreter is the \*(L"current\*(R" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl \s-1API\s0 calls on both interpreters in an interleaved fashion.
.PP
\&\s-1PERL_SET_CONTEXT\s0(interp) should also be called whenever \f(CW\*(C`interp\*(C'\fR is
used by a thread that did not create it (using either \fIperl_alloc()\fR, or
the more esoteric \fIperl_clone()\fR).
.PP
Compile as usual:
.PP
.Vb 1
\& % cc \-o multiplicity multiplicity.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Run it, Run it:
.PP
.Vb 3
\& % multiplicity
\& Hi, I\*(Aqm one_perl
\& Hi, I\*(Aqm two_perl
.Ve
.SS "Using Perl modules, which themselves use C libraries, from your C program"
.IX Subsection "Using Perl modules, which themselves use C libraries, from your C program"
If you've played with the examples above and tried to embed a script
that \fI\fIuse()\fI\fRs a Perl module (such as \fISocket\fR) which itself uses a C or \*(C+ library,
this probably happened:
.PP
.Vb 3
\& Can\*(Aqt load module Socket, dynamic loading not available in this perl.
\&  (You may need to build a new perl executable which either supports
\&  dynamic loading or has the Socket module statically linked into it.)
.Ve
.PP
What's wrong?
.PP
Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been
calling \fI\fIperl_parse()\fI\fR, handing it \s-1NULL\s0 for the second argument:
.PP
.Vb 1
\& perl_parse(my_perl, NULL, argc, my_argv, NULL);
.Ve
.PP
That's where the glue code can be inserted to create the initial contact between
Perl and linked C/\*(C+ routines.  Let's take a look some pieces of \fIperlmain.c\fR
to see how Perl does this:
.PP
.Vb 1
\& static void xs_init (pTHX);
\&
\& EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
\& EXTERN_C void boot_Socket (pTHX_ CV* cv);
\&
\&
\& EXTERN_C void
\& xs_init(pTHX)
\& {
\&        char *file = _\|_FILE_\|_;
\&        /* DynaLoader is a special case */
\&        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
\&        newXS("Socket::bootstrap", boot_Socket, file);
\& }
.Ve
.PP
Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
\&\fI\fIModule::bootstrap()\fI\fR and is invoked when you say \fIuse Module\fR.  In
turn, this hooks into an \s-1XSUB\s0, \fIboot_Module\fR, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the \fIxsubpp\fR and extension authors.  If your
extension is dynamically loaded, DynaLoader creates \fI\fIModule::bootstrap()\fI\fR
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.
.PP
Once you have this code, slap it into the second argument of \fI\fIperl_parse()\fI\fR:
.PP
.Vb 1
\& perl_parse(my_perl, xs_init, argc, my_argv, NULL);
.Ve
.PP
Then compile:
.PP
.Vb 1
\& % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\& % interp
\&   use Socket;
\&   use SomeDynamicallyLoadedModule;
\&
\&   print "Now I can use extensions!\en"\*(Aq
.Ve
.PP
\&\fBExtUtils::Embed\fR can also automate writing the \fIxs_init\fR glue code.
.PP
.Vb 4
\& % perl \-MExtUtils::Embed \-e xsinit \-\- \-o perlxsi.c
\& % cc \-c perlxsi.c \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-c interp.c  \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-o interp perlxsi.o interp.o \`perl \-MExtUtils::Embed \-e ldopts\`
.Ve
.PP
Consult perlxs, perlguts, and perlapi for more details.
.SH "Hiding Perl_"
.IX Header "Hiding Perl_"
If you completely hide the short forms of the Perl public \s-1API\s0,
add \-DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing
.PP
.Vb 1
\&    warn("%d bottles of beer on the wall", bottlecount);
.Ve
.PP
you will have to write the explicit full form
.PP
.Vb 1
\&    Perl_warn(aTHX_ "%d bottles of beer on the wall", bottlecount);
.Ve
.PP
(See \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\s0\*(R" in perlguts for the explanation
of the \f(CW\*(C`aTHX_\*(C'\fR. )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)
.SH "MORAL"
.IX Header "MORAL"
You can sometimes \fIwrite faster code\fR in C, but
you can always \fIwrite code faster\fR in Perl.  Because you can use
each from the other, combine them as you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jon Orwant <\fIorwant@media.mit.edu\fR> and Doug MacEachern
<\fIdougm@covalent.net\fR>, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.
.PP
Doug MacEachern has an article on embedding in Volume 1, Issue 4 of
The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.  All
Rights Reserved.
.PP
This document may be distributed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlembed5.18.1                              0100644 0001750 0001750 00000130234 12566207436 023221  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEMBED 1"
.TH PERLEMBED 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlembed \- how to embed perl in your C program
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "\s-1PREAMBLE\s0"
.IX Subsection "PREAMBLE"
Do you want to:
.IP "\fBUse C from Perl?\fR" 5
.IX Item "Use C from Perl?"
Read perlxstut, perlxs, h2xs, perlguts, and perlapi.
.IP "\fBUse a Unix program from Perl?\fR" 5
.IX Item "Use a Unix program from Perl?"
Read about back-quotes and about \f(CW\*(C`system\*(C'\fR and \f(CW\*(C`exec\*(C'\fR in perlfunc.
.IP "\fBUse Perl from Perl?\fR" 5
.IX Item "Use Perl from Perl?"
Read about \*(L"do\*(R" in perlfunc and \*(L"eval\*(R" in perlfunc and \*(L"require\*(R" in perlfunc 
and \*(L"use\*(R" in perlfunc.
.IP "\fBUse C from C?\fR" 5
.IX Item "Use C from C?"
Rethink your design.
.IP "\fBUse Perl from C?\fR" 5
.IX Item "Use Perl from C?"
Read on...
.SS "\s-1ROADMAP\s0"
.IX Subsection "ROADMAP"
.IP "\(bu" 5
Compiling your C program
.IP "\(bu" 5
Adding a Perl interpreter to your C program
.IP "\(bu" 5
Calling a Perl subroutine from your C program
.IP "\(bu" 5
Evaluating a Perl statement from your C program
.IP "\(bu" 5
Performing Perl pattern matches and substitutions from your C program
.IP "\(bu" 5
Fiddling with the Perl stack from your C program
.IP "\(bu" 5
Maintaining a persistent interpreter
.IP "\(bu" 5
Maintaining multiple interpreter instances
.IP "\(bu" 5
Using Perl modules, which themselves use C libraries, from your C program
.IP "\(bu" 5
Embedding Perl under Win32
.SS "Compiling your C program"
.IX Subsection "Compiling your C program"
If you have trouble compiling the scripts in this documentation,
you're not alone.  The cardinal rule: \s-1COMPILE THE PROGRAMS IN EXACTLY
THE SAME WAY THAT YOUR PERL WAS COMPILED.  \s0(Sorry for yelling.)
.PP
Also, every C program that uses Perl must link in the \fIperl library\fR.
What's that, you ask?  Perl is itself written in C; the perl library
is the collection of compiled C programs that were used to create your
perl executable (\fI/usr/bin/perl\fR or equivalent).  (Corollary: you
can't use Perl from your C program unless Perl has been compiled on
your machine, or installed properly\*(--that's why you shouldn't blithely
copy Perl executables from machine to machine without also copying the
\&\fIlib\fR directory.)
.PP
When you use Perl from C, your C program will\*(--usually\-\-allocate,
\&\*(L"run\*(R", and deallocate a \fIPerlInterpreter\fR object, which is defined by
the perl library.
.PP
If your copy of Perl is recent enough to contain this documentation
(version 5.002 or later), then the perl library (and \fI\s-1EXTERN\s0.h\fR and
\&\fIperl.h\fR, which you'll also need) will reside in a directory
that looks like this:
.PP
.Vb 1
\&    /usr/local/lib/perl5/your_architecture_here/CORE
.Ve
.PP
or perhaps just
.PP
.Vb 1
\&    /usr/local/lib/perl5/CORE
.Ve
.PP
or maybe something like
.PP
.Vb 1
\&    /usr/opt/perl5/CORE
.Ve
.PP
Execute this statement for a hint about where to find \s-1CORE:\s0
.PP
.Vb 1
\&    perl \-MConfig \-e \*(Aqprint $Config{archlib}\*(Aq
.Ve
.PP
Here's how you'd compile the example in the next section,
\&\*(L"Adding a Perl interpreter to your C program\*(R", on my Linux box:
.PP
.Vb 4
\&    % gcc \-O2 \-Dbool=char \-DHAS_BOOL \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-L/usr/local/lib/perl5/i586\-linux/5.003/CORE
\&    \-o interp interp.c \-lperl \-lm
.Ve
.PP
(That's all one line.)  On my \s-1DEC\s0 Alpha running old 5.003_05, the 
incantation is a bit different:
.PP
.Vb 4
\&    % cc \-O2 \-Olimit 2900 \-DSTANDARD_C \-I/usr/local/include
\&    \-I/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE
\&    \-L/usr/local/lib/perl5/alpha\-dec_osf/5.00305/CORE \-L/usr/local/lib
\&    \-D_\|_LANGUAGE_C_\|_ \-D_NO_PROTO \-o interp interp.c \-lperl \-lm
.Ve
.PP
How can you figure out what to add?  Assuming your Perl is post\-5.001,
execute a \f(CW\*(C`perl \-V\*(C'\fR command and pay special attention to the \*(L"cc\*(R" and
\&\*(L"ccflags\*(R" information.
.PP
You'll have to choose the appropriate compiler (\fIcc\fR, \fIgcc\fR, et al.) for
your machine: \f(CW\*(C`perl \-MConfig \-e \*(Aqprint $Config{cc}\*(Aq\*(C'\fR will tell you what
to use.
.PP
You'll also have to choose the appropriate library directory
(\fI/usr/local/lib/...\fR) for your machine.  If your compiler complains
that certain functions are undefined, or that it can't locate
\&\fI\-lperl\fR, then you need to change the path following the \f(CW\*(C`\-L\*(C'\fR.  If it
complains that it can't find \fI\s-1EXTERN\s0.h\fR and \fIperl.h\fR, you need to
change the path following the \f(CW\*(C`\-I\*(C'\fR.
.PP
You may have to add extra libraries as well.  Which ones?
Perhaps those printed by
.PP
.Vb 1
\&   perl \-MConfig \-e \*(Aqprint $Config{libs}\*(Aq
.Ve
.PP
Provided your perl binary was properly configured and installed the
\&\fBExtUtils::Embed\fR module will determine all of this information for
you:
.PP
.Vb 1
\&   % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
If the \fBExtUtils::Embed\fR module isn't part of your Perl distribution,
you can retrieve it from
http://www.perl.com/perl/CPAN/modules/by\-module/ExtUtils/
(If this documentation came from your Perl distribution, then you're
running 5.004 or better and you already have it.)
.PP
The \fBExtUtils::Embed\fR kit on \s-1CPAN\s0 also contains all source code for
the examples in this document, tests, additional examples and other
information you may find useful.
.SS "Adding a Perl interpreter to your C program"
.IX Subsection "Adding a Perl interpreter to your C program"
In a sense, perl (the C program) is a good example of embedding Perl
(the language), so I'll demonstrate embedding with \fIminiperlmain.c\fR,
included in the source distribution.  Here's a bastardized, non-portable
version of \fIminiperlmain.c\fR containing the essentials of embedding:
.PP
.Vb 2
\&    #include <EXTERN.h>               /* from the Perl distribution     */
\&    #include <perl.h>                 /* from the Perl distribution     */
\&
\&    static PerlInterpreter *my_perl;  /***    The Perl interpreter    ***/
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&        perl_parse(my_perl, NULL, argc, argv, (char **)NULL);
\&        perl_run(my_perl);
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
Notice that we don't use the \f(CW\*(C`env\*(C'\fR pointer.  Normally handed to
\&\f(CW\*(C`perl_parse\*(C'\fR as its final argument, \f(CW\*(C`env\*(C'\fR here is replaced by
\&\f(CW\*(C`NULL\*(C'\fR, which means that the current environment will be used.
.PP
The macros \s-1\fIPERL_SYS_INIT3\s0()\fR and \s-1\fIPERL_SYS_TERM\s0()\fR provide system-specific
tune up of the C runtime environment necessary to run Perl interpreters;
they should only be called once regardless of how many interpreters you
create or destroy. Call \s-1\fIPERL_SYS_INIT3\s0()\fR before you create your first
interpreter, and \s-1\fIPERL_SYS_TERM\s0()\fR after you free your last interpreter.
.PP
Since \s-1\fIPERL_SYS_INIT3\s0()\fR may change \f(CW\*(C`env\*(C'\fR, it may be more appropriate to
provide \f(CW\*(C`env\*(C'\fR as an argument to \fIperl_parse()\fR.
.PP
Also notice that no matter what arguments you pass to \fIperl_parse()\fR,
\&\s-1\fIPERL_SYS_INIT3\s0()\fR must be invoked on the C \fImain()\fR argc, argv and env and
only once.
.PP
Now compile this program (I'll call it \fIinterp.c\fR) into an executable:
.PP
.Vb 1
\&    % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
After a successful compilation, you'll be able to use \fIinterp\fR just
like perl itself:
.PP
.Vb 6
\&    % interp
\&    print "Pretty Good Perl \en";
\&    print "10890 \- 9801 is ", 10890 \- 9801;
\&    <CTRL\-D>
\&    Pretty Good Perl
\&    10890 \- 9801 is 1089
.Ve
.PP
or
.PP
.Vb 2
\&    % interp \-e \*(Aqprintf("%x", 3735928559)\*(Aq
\&    deadbeef
.Ve
.PP
You can also read and execute Perl statements from a file while in the
midst of your C program, by placing the filename in \fIargv[1]\fR before
calling \fIperl_run\fR.
.SS "Calling a Perl subroutine from your C program"
.IX Subsection "Calling a Perl subroutine from your C program"
To call individual Perl subroutines, you can use any of the \fBcall_*\fR
functions documented in perlcall.
In this example we'll use \f(CW\*(C`call_argv\*(C'\fR.
.PP
That's shown below, in a program I'll call \fIshowtime.c\fR.
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    int main(int argc, char **argv, char **env)
\&    {
\&        char *args[] = { NULL };
\&        PERL_SYS_INIT3(&argc,&argv,&env);
\&        my_perl = perl_alloc();
\&        perl_construct(my_perl);
\&
\&        perl_parse(my_perl, NULL, argc, argv, NULL);
\&        PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&        /*** skipping perl_run() ***/
\&
\&        call_argv("showtime", G_DISCARD | G_NOARGS, args);
\&
\&        perl_destruct(my_perl);
\&        perl_free(my_perl);
\&        PERL_SYS_TERM();
\&    }
.Ve
.PP
where \fIshowtime\fR is a Perl subroutine that takes no arguments (that's the
\&\fIG_NOARGS\fR) and for which I'll ignore the return value (that's the
\&\fIG_DISCARD\fR).  Those flags, and others, are discussed in perlcall.
.PP
I'll define the \fIshowtime\fR subroutine in a file called \fIshowtime.pl\fR:
.PP
.Vb 1
\&    print "I shan\*(Aqt be printed.";
\&
\&    sub showtime {
\&        print time;
\&    }
.Ve
.PP
Simple enough.  Now compile and run:
.PP
.Vb 1
\&    % cc \-o showtime showtime.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % showtime showtime.pl
\&    818284590
.Ve
.PP
yielding the number of seconds that elapsed between January 1, 1970
(the beginning of the Unix epoch), and the moment I began writing this
sentence.
.PP
In this particular case we don't have to call \fIperl_run\fR, as we set 
the PL_exit_flag \s-1PERL_EXIT_DESTRUCT_END\s0 which executes \s-1END\s0 blocks in
perl_destruct.
.PP
If you want to pass arguments to the Perl subroutine, you can add
strings to the \f(CW\*(C`NULL\*(C'\fR\-terminated \f(CW\*(C`args\*(C'\fR list passed to
\&\fIcall_argv\fR.  For other data types, or to examine return values,
you'll need to manipulate the Perl stack.  That's demonstrated in
\&\*(L"Fiddling with the Perl stack from your C program\*(R".
.SS "Evaluating a Perl statement from your C program"
.IX Subsection "Evaluating a Perl statement from your C program"
Perl provides two \s-1API\s0 functions to evaluate pieces of Perl code.
These are \*(L"eval_sv\*(R" in perlapi and \*(L"eval_pv\*(R" in perlapi.
.PP
Arguably, these are the only routines you'll ever need to execute
snippets of Perl code from within your C program.  Your code can be as
long as you wish; it can contain multiple statements; it can employ
\&\*(L"use\*(R" in perlfunc, \*(L"require\*(R" in perlfunc, and \*(L"do\*(R" in perlfunc to
include external Perl files.
.PP
\&\fIeval_pv\fR lets us evaluate individual Perl strings, and then
extract variables for coercion into C types.  The following program,
\&\fIstring.c\fR, executes three Perl strings, extracting an \f(CW\*(C`int\*(C'\fR from
the first, a \f(CW\*(C`float\*(C'\fR from the second, and a \f(CW\*(C`char *\*(C'\fR from the third.
.PP
.Vb 2
\&   #include <EXTERN.h>
\&   #include <perl.h>
\&
\&   static PerlInterpreter *my_perl;
\&
\&   main (int argc, char **argv, char **env)
\&   {
\&       char *embedding[] = { "", "\-e", "0" };
\&
\&       PERL_SYS_INIT3(&argc,&argv,&env);
\&       my_perl = perl_alloc();
\&       perl_construct( my_perl );
\&
\&       perl_parse(my_perl, NULL, 3, embedding, NULL);
\&       PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&       perl_run(my_perl);
\&
\&       /** Treat $a as an integer **/
\&       eval_pv("$a = 3; $a **= 2", TRUE);
\&       printf("a = %d\en", SvIV(get_sv("a", 0)));
\&
\&       /** Treat $a as a float **/
\&       eval_pv("$a = 3.14; $a **= 2", TRUE);
\&       printf("a = %f\en", SvNV(get_sv("a", 0)));
\&
\&       /** Treat $a as a string **/
\&       eval_pv("$a = \*(AqrekcaH lreP rehtonA tsuJ\*(Aq; $a = reverse($a);", TRUE);
\&       printf("a = %s\en", SvPV_nolen(get_sv("a", 0)));
\&
\&       perl_destruct(my_perl);
\&       perl_free(my_perl);
\&       PERL_SYS_TERM();
\&   }
.Ve
.PP
All of those strange functions with \fIsv\fR in their names help convert Perl scalars to C types.  They're described in perlguts and perlapi.
.PP
If you compile and run \fIstring.c\fR, you'll see the results of using
\&\fI\fISvIV()\fI\fR to create an \f(CW\*(C`int\*(C'\fR, \fI\fISvNV()\fI\fR to create a \f(CW\*(C`float\*(C'\fR, and
\&\fI\fISvPV()\fI\fR to create a string:
.PP
.Vb 3
\&   a = 9
\&   a = 9.859600
\&   a = Just Another Perl Hacker
.Ve
.PP
In the example above, we've created a global variable to temporarily
store the computed value of our eval'ed expression.  It is also
possible and in most cases a better strategy to fetch the return value
from \fI\fIeval_pv()\fI\fR instead.  Example:
.PP
.Vb 4
\&   ...
\&   SV *val = eval_pv("reverse \*(AqrekcaH lreP rehtonA tsuJ\*(Aq", TRUE);
\&   printf("%s\en", SvPV_nolen(val));
\&   ...
.Ve
.PP
This way, we avoid namespace pollution by not creating global
variables and we've simplified our code as well.
.SS "Performing Perl pattern matches and substitutions from your C program"
.IX Subsection "Performing Perl pattern matches and substitutions from your C program"
The \fI\fIeval_sv()\fI\fR function lets us evaluate strings of Perl code, so we can
define some functions that use it to \*(L"specialize\*(R" in matches and
substitutions: \fI\fImatch()\fI\fR, \fI\fIsubstitute()\fI\fR, and \fI\fImatches()\fI\fR.
.PP
.Vb 1
\&   I32 match(SV *string, char *pattern);
.Ve
.PP
Given a string and a pattern (e.g., \f(CW\*(C`m/clasp/\*(C'\fR or \f(CW\*(C`/\eb\ew*\eb/\*(C'\fR, which
in your C program might appear as \*(L"/\e\eb\e\ew*\e\eb/\*(R"), \fImatch()\fR
returns 1 if the string matches the pattern and 0 otherwise.
.PP
.Vb 1
\&   int substitute(SV **string, char *pattern);
.Ve
.PP
Given a pointer to an \f(CW\*(C`SV\*(C'\fR and an \f(CW\*(C`=~\*(C'\fR operation (e.g.,
\&\f(CW\*(C`s/bob/robert/g\*(C'\fR or \f(CW\*(C`tr[A\-Z][a\-z]\*(C'\fR), \fIsubstitute()\fR modifies the string
within the \f(CW\*(C`SV\*(C'\fR as according to the operation, returning the number of substitutions
made.
.PP
.Vb 1
\&   int matches(SV *string, char *pattern, AV **matches);
.Ve
.PP
Given an \f(CW\*(C`SV\*(C'\fR, a pattern, and a pointer to an empty \f(CW\*(C`AV\*(C'\fR,
\&\fImatches()\fR evaluates \f(CW\*(C`$string =~ $pattern\*(C'\fR in a list context, and
fills in \fImatches\fR with the array elements, returning the number of matches found.
.PP
Here's a sample program, \fImatch.c\fR, that uses all three (long lines have
been wrapped here):
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& static PerlInterpreter *my_perl;
\&
\& /** my_eval_sv(code, error_check)
\& ** kinda like eval_sv(), 
\& ** but we pop the return value off the stack 
\& **/
\& SV* my_eval_sv(SV *sv, I32 croak_on_error)
\& {
\&     dSP;
\&     SV* retval;
\&
\&
\&     PUSHMARK(SP);
\&     eval_sv(sv, G_SCALAR);
\&
\&     SPAGAIN;
\&     retval = POPs;
\&     PUTBACK;
\&
\&     if (croak_on_error && SvTRUE(ERRSV))
\&        croak(SvPVx_nolen(ERRSV));
\&
\&     return retval;
\& }
\&
\& /** match(string, pattern)
\& **
\& ** Used for matches in a scalar context.
\& **
\& ** Returns 1 if the match was successful; 0 otherwise.
\& **/
\&
\& I32 match(SV *string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; $string =~ %s",
\&              SvPV_nolen(string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     return SvIV(retval);
\& }
\&
\& /** substitute(string, pattern)
\& **
\& ** Used for =~ operations that modify their left\-hand side (s/// and tr///)
\& **
\& ** Returns the number of successful matches, and
\& ** modifies the input string if there were any.
\& **/
\&
\& I32 substitute(SV **string, char *pattern)
\& {
\&     SV *command = newSV(0), *retval;
\&
\&     sv_setpvf(command, "$string = \*(Aq%s\*(Aq; ($string =~ %s)",
\&              SvPV_nolen(*string), pattern);
\&
\&     retval = my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *string = get_sv("string", 0);
\&     return SvIV(retval);
\& }
\&
\& /** matches(string, pattern, matches)
\& **
\& ** Used for matches in a list context.
\& **
\& ** Returns the number of matches,
\& ** and fills in **matches with the matching substrings
\& **/
\&
\& I32 matches(SV *string, char *pattern, AV **match_list)
\& {
\&     SV *command = newSV(0);
\&     I32 num_matches;
\&
\&     sv_setpvf(command, "my $string = \*(Aq%s\*(Aq; @array = ($string =~ %s)",
\&              SvPV_nolen(string), pattern);
\&
\&     my_eval_sv(command, TRUE);
\&     SvREFCNT_dec(command);
\&
\&     *match_list = get_av("array", 0);
\&     num_matches = av_top_index(*match_list) + 1;
\&
\&     return num_matches;
\& }
\&
\& main (int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "\-e", "0" };
\&     AV *match_list;
\&     I32 num_matches, i;
\&     SV *text;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     my_perl = perl_alloc();
\&     perl_construct(my_perl);
\&     perl_parse(my_perl, NULL, 3, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&
\&     text = newSV(0);
\&     sv_setpv(text, "When he is at a convenience store and the "
\&        "bill comes to some amount like 76 cents, Maynard is "
\&        "aware that there is something he *should* do, something "
\&        "that will enable him to get back a quarter, but he has "
\&        "no idea *what*.  He fumbles through his red squeezey "
\&        "changepurse and gives the boy three extra pennies with "
\&        "his dollar, hoping that he might luck into the correct "
\&        "amount.  The boy gives him back two of his own pennies "
\&        "and then the big shiny quarter that is his prize. "
\&        "\-RICHH");
\&
\&     if (match(text, "m/quarter/")) /** Does text contain \*(Aqquarter\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqquarter\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqquarter\*(Aq.\en\en");
\&
\&     if (match(text, "m/eighth/")) /** Does text contain \*(Aqeighth\*(Aq? **/
\&        printf("match: Text contains the word \*(Aqeighth\*(Aq.\en\en");
\&     else
\&        printf("match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.\en\en");
\&
\&     /** Match all occurrences of /wi../ **/
\&     num_matches = matches(text, "m/(wi..)/g", &match_list);
\&     printf("matches: m/(wi..)/g found %d matches...\en", num_matches);
\&
\&     for (i = 0; i < num_matches; i++)
\&        printf("match: %s\en", SvPV_nolen(*av_fetch(match_list, i, FALSE)));
\&     printf("\en");
\&
\&     /** Remove all vowels from text **/
\&     num_matches = substitute(&text, "s/[aeiou]//gi");
\&     if (num_matches) {
\&        printf("substitute: s/[aeiou]//gi...%d substitutions made.\en",
\&               num_matches);
\&        printf("Now text is: %s\en\en", SvPV_nolen(text));
\&     }
\&
\&     /** Attempt a substitution **/
\&     if (!substitute(&text, "s/Perl/C/")) {
\&        printf("substitute: s/Perl/C...No substitution made.\en\en");
\&     }
\&
\&     SvREFCNT_dec(text);
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
which produces the output (again, long lines have been wrapped here)
.PP
.Vb 1
\&   match: Text contains the word \*(Aqquarter\*(Aq.
\&
\&   match: Text doesn\*(Aqt contain the word \*(Aqeighth\*(Aq.
\&
\&   matches: m/(wi..)/g found 2 matches...
\&   match: will
\&   match: with
\&
\&   substitute: s/[aeiou]//gi...139 substitutions made.
\&   Now text is: Whn h s t  cnvnnc str nd th bll cms t sm mnt lk 76 cnts,
\&   Mynrd s wr tht thr s smthng h *shld* d, smthng tht wll nbl hm t gt bck
\&   qrtr, bt h hs n d *wht*.  H fmbls thrgh hs rd sqzy chngprs nd gvs th by
\&   thr xtr pnns wth hs dllr, hpng tht h mght lck nt th crrct mnt.  Th by gvs
\&   hm bck tw f hs wn pnns nd thn th bg shny qrtr tht s hs prz. \-RCHH
\&
\&   substitute: s/Perl/C...No substitution made.
.Ve
.SS "Fiddling with the Perl stack from your C program"
.IX Subsection "Fiddling with the Perl stack from your C program"
When trying to explain stacks, most computer science textbooks mumble
something about spring-loaded columns of cafeteria plates: the last
thing you pushed on the stack is the first thing you pop off.  That'll
do for our purposes: your C program will push some arguments onto \*(L"the Perl
stack\*(R", shut its eyes while some magic happens, and then pop the
results\*(--the return value of your Perl subroutine\*(--off the stack.
.PP
First you'll need to know how to convert between C types and Perl
types, with \fInewSViv()\fR and \fIsv_setnv()\fR and \fInewAV()\fR and all their
friends.  They're described in perlguts and perlapi.
.PP
Then you'll need to know how to manipulate the Perl stack.  That's
described in perlcall.
.PP
Once you've understood those, embedding Perl in C is easy.
.PP
Because C has no builtin function for integer exponentiation, let's
make Perl's ** operator available to it (this is less useful than it
sounds, because Perl implements ** with C's \fI\fIpow()\fI\fR function).  First
I'll create a stub exponentiation function in \fIpower.pl\fR:
.PP
.Vb 4
\&    sub expo {
\&        my ($a, $b) = @_;
\&        return $a ** $b;
\&    }
.Ve
.PP
Now I'll create a C program, \fIpower.c\fR, with a function
\&\fI\fIPerlPower()\fI\fR that contains all the perlguts necessary to push the
two arguments into \fI\fIexpo()\fI\fR and to pop the return value out.  Take a
deep breath...
.PP
.Vb 2
\&    #include <EXTERN.h>
\&    #include <perl.h>
\&
\&    static PerlInterpreter *my_perl;
\&
\&    static void
\&    PerlPower(int a, int b)
\&    {
\&      dSP;                            /* initialize stack pointer      */
\&      ENTER;                          /* everything created after here */
\&      SAVETMPS;                       /* ...is a temporary variable.   */
\&      PUSHMARK(SP);                   /* remember the stack pointer    */
\&      XPUSHs(sv_2mortal(newSViv(a))); /* push the base onto the stack  */
\&      XPUSHs(sv_2mortal(newSViv(b))); /* push the exponent onto stack  */
\&      PUTBACK;                      /* make local stack pointer global */
\&      call_pv("expo", G_SCALAR);      /* call the function             */
\&      SPAGAIN;                        /* refresh stack pointer         */
\&                                    /* pop the return value from stack */
\&      printf ("%d to the %dth power is %d.\en", a, b, POPi);
\&      PUTBACK;
\&      FREETMPS;                       /* free that return value        */
\&      LEAVE;                       /* ...and the XPUSHed "mortal" args.*/
\&    }
\&
\&    int main (int argc, char **argv, char **env)
\&    {
\&      char *my_argv[] = { "", "power.pl" };
\&
\&      PERL_SYS_INIT3(&argc,&argv,&env);
\&      my_perl = perl_alloc();
\&      perl_construct( my_perl );
\&
\&      perl_parse(my_perl, NULL, 2, my_argv, (char **)NULL);
\&      PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&      perl_run(my_perl);
\&
\&      PerlPower(3, 4);                      /*** Compute 3 ** 4 ***/
\&
\&      perl_destruct(my_perl);
\&      perl_free(my_perl);
\&      PERL_SYS_TERM();
\&    }
.Ve
.PP
Compile and run:
.PP
.Vb 1
\&    % cc \-o power power.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\&    % power
\&    3 to the 4th power is 81.
.Ve
.SS "Maintaining a persistent interpreter"
.IX Subsection "Maintaining a persistent interpreter"
When developing interactive and/or potentially long-running
applications, it's a good idea to maintain a persistent interpreter
rather than allocating and constructing a new interpreter multiple
times.  The major reason is speed: since Perl will only be loaded into
memory once.
.PP
However, you have to be more cautious with namespace and variable
scoping when using a persistent interpreter.  In previous examples
we've been using global variables in the default package \f(CW\*(C`main\*(C'\fR.  We
knew exactly what code would be run, and assumed we could avoid
variable collisions and outrageous symbol table growth.
.PP
Let's say your application is a server that will occasionally run Perl
code from some arbitrary file.  Your server has no way of knowing what
code it's going to run.  Very dangerous.
.PP
If the file is pulled in by \f(CW\*(C`perl_parse()\*(C'\fR, compiled into a newly
constructed interpreter, and subsequently cleaned out with
\&\f(CW\*(C`perl_destruct()\*(C'\fR afterwards, you're shielded from most namespace
troubles.
.PP
One way to avoid namespace collisions in this scenario is to translate
the filename into a guaranteed-unique package name, and then compile
the code into that package using \*(L"eval\*(R" in perlfunc.  In the example
below, each file will only be compiled once.  Or, the application
might choose to clean out the symbol table associated with the file
after it's no longer needed.  Using \*(L"call_argv\*(R" in perlapi, We'll
call the subroutine \f(CW\*(C`Embed::Persistent::eval_file\*(C'\fR which lives in the
file \f(CW\*(C`persistent.pl\*(C'\fR and pass the filename and boolean cleanup/cache
flag as arguments.
.PP
Note that the process will continue to grow for each file that it
uses.  In addition, there might be \f(CW\*(C`AUTOLOAD\*(C'\fRed subroutines and other
conditions that cause Perl's symbol table to grow.  You might want to
add some logic that keeps track of the process size, or restarts
itself after a certain number of requests, to ensure that memory
consumption is minimized.  You'll also want to scope your variables
with \*(L"my\*(R" in perlfunc whenever possible.
.PP
.Vb 2
\& package Embed::Persistent;
\& #persistent.pl
\&
\& use strict;
\& our %Cache;
\& use Symbol qw(delete_package);
\&
\& sub valid_package_name {
\&     my($string) = @_;
\&     $string =~ s/([^A\-Za\-z0\-9\e/])/sprintf("_%2x",unpack("C",$1))/eg;
\&     # second pass only for words starting with a digit
\&     $string =~ s|/(\ed)|sprintf("/_%2x",unpack("C",$1))|eg;
\&
\&     # Dress it up as a real package name
\&     $string =~ s|/|::|g;
\&     return "Embed" . $string;
\& }
\&
\& sub eval_file {
\&     my($filename, $delete) = @_;
\&     my $package = valid_package_name($filename);
\&     my $mtime = \-M $filename;
\&     if(defined $Cache{$package}{mtime}
\&        &&
\&        $Cache{$package}{mtime} <= $mtime)
\&     {
\&        # we have compiled this subroutine already,
\&        # it has not been updated on disk, nothing left to do
\&        print STDERR "already compiled $package\->handler\en";
\&     }
\&     else {
\&        local *FH;
\&        open FH, $filename or die "open \*(Aq$filename\*(Aq $!";
\&        local($/) = undef;
\&        my $sub = <FH>;
\&        close FH;
\&
\&        #wrap the code into a subroutine inside our unique package
\&        my $eval = qq{package $package; sub handler { $sub; }};
\&        {
\&            # hide our variables within this block
\&            my($filename,$mtime,$package,$sub);
\&            eval $eval;
\&        }
\&        die $@ if $@;
\&
\&        #cache it unless we\*(Aqre cleaning out each time
\&        $Cache{$package}{mtime} = $mtime unless $delete;
\&     }
\&
\&     eval {$package\->handler;};
\&     die $@ if $@;
\&
\&     delete_package($package) if $delete;
\&
\&     #take a look if you want
\&     #print Devel::Symdump\->rnew($package)\->as_string, $/;
\& }
\&
\& 1;
\&
\& _\|_END_\|_
\&
\& /* persistent.c */
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* 1 = clean out filename\*(Aqs symbol table after each request, 0 = don\*(Aqt */
\& #ifndef DO_CLEAN
\& #define DO_CLEAN 0
\& #endif
\&
\& #define BUFFER_SIZE 1024
\&
\& static PerlInterpreter *my_perl = NULL;
\&
\& int
\& main(int argc, char **argv, char **env)
\& {
\&     char *embedding[] = { "", "persistent.pl" };
\&     char *args[] = { "", DO_CLEAN, NULL };
\&     char filename[BUFFER_SIZE];
\&     int exitstatus = 0;
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     if((my_perl = perl_alloc()) == NULL) {
\&        fprintf(stderr, "no memory!");
\&        exit(1);
\&     }
\&     perl_construct(my_perl);
\&
\&     PL_origalen = 1; /* don\*(Aqt let $0 assignment update the proctitle or embedding[0] */
\&     exitstatus = perl_parse(my_perl, NULL, 2, embedding, NULL);
\&     PL_exit_flags |= PERL_EXIT_DESTRUCT_END;
\&     if(!exitstatus) {
\&        exitstatus = perl_run(my_perl);
\&
\&        while(printf("Enter file name: ") &&
\&              fgets(filename, BUFFER_SIZE, stdin)) {
\&
\&            filename[strlen(filename)\-1] = \*(Aq\e0\*(Aq; /* strip \en */
\&            /* call the subroutine, passing it the filename as an argument */
\&            args[0] = filename;
\&            call_argv("Embed::Persistent::eval_file",
\&                           G_DISCARD | G_EVAL, args);
\&
\&            /* check $@ */
\&            if(SvTRUE(ERRSV))
\&                fprintf(stderr, "eval error: %s\en", SvPV_nolen(ERRSV));
\&        }
\&     }
\&
\&     PL_perl_destruct_level = 0;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     PERL_SYS_TERM();
\&     exit(exitstatus);
\& }
.Ve
.PP
Now compile:
.PP
.Vb 1
\& % cc \-o persistent persistent.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Here's an example script file:
.PP
.Vb 3
\& #test.pl
\& my $string = "hello";
\& foo($string);
\&
\& sub foo {
\&     print "foo says: @_\en";
\& }
.Ve
.PP
Now run:
.PP
.Vb 7
\& % persistent
\& Enter file name: test.pl
\& foo says: hello
\& Enter file name: test.pl
\& already compiled Embed::test_2epl\->handler
\& foo says: hello
\& Enter file name: ^C
.Ve
.SS "Execution of \s-1END\s0 blocks"
.IX Subsection "Execution of END blocks"
Traditionally \s-1END\s0 blocks have been executed at the end of the perl_run.
This causes problems for applications that never call perl_run. Since
perl 5.7.2 you can specify \f(CW\*(C`PL_exit_flags |= PERL_EXIT_DESTRUCT_END\*(C'\fR
to get the new behaviour. This also enables the running of \s-1END\s0 blocks if
the perl_parse fails and \f(CW\*(C`perl_destruct\*(C'\fR will return the exit value.
.ie n .SS "$0 assignments"
.el .SS "\f(CW$0\fP assignments"
.IX Subsection "$0 assignments"
When a perl script assigns a value to \f(CW$0\fR then the perl runtime will
try to make this value show up as the program name reported by \*(L"ps\*(R" by
updating the memory pointed to by the argv passed to \fIperl_parse()\fR and
also calling \s-1API\s0 functions like \fIsetproctitle()\fR where available.  This
behaviour might not be appropriate when embedding perl and can be
disabled by assigning the value \f(CW1\fR to the variable \f(CW\*(C`PL_origalen\*(C'\fR
before \fIperl_parse()\fR is called.
.PP
The \fIpersistent.c\fR example above is for instance likely to segfault
when \f(CW$0\fR is assigned to if the \f(CW\*(C`PL_origalen = 1;\*(C'\fR assignment is
removed.  This because perl will try to write to the read only memory
of the \f(CW\*(C`embedding[]\*(C'\fR strings.
.SS "Maintaining multiple interpreter instances"
.IX Subsection "Maintaining multiple interpreter instances"
Some rare applications will need to create more than one interpreter
during a session.  Such an application might sporadically decide to
release any resources associated with the interpreter.
.PP
The program must take care to ensure that this takes place \fIbefore\fR
the next interpreter is constructed.  By default, when perl is not
built with any special options, the global variable
\&\f(CW\*(C`PL_perl_destruct_level\*(C'\fR is set to \f(CW0\fR, since extra cleaning isn't
usually needed when a program only ever creates a single interpreter
in its entire lifetime.
.PP
Setting \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to \f(CW1\fR makes everything squeaky clean:
.PP
.Vb 10
\& while(1) {
\&     ...
\&     /* reset global variables here with PL_perl_destruct_level = 1 */
\&     PL_perl_destruct_level = 1;
\&     perl_construct(my_perl);
\&     ...
\&     /* clean and reset _everything_ during perl_destruct */
\&     PL_perl_destruct_level = 1;
\&     perl_destruct(my_perl);
\&     perl_free(my_perl);
\&     ...
\&     /* let\*(Aqs go do it again! */
\& }
.Ve
.PP
When \fI\fIperl_destruct()\fI\fR is called, the interpreter's syntax parse tree
and symbol tables are cleaned up, and global variables are reset.  The
second assignment to \f(CW\*(C`PL_perl_destruct_level\*(C'\fR is needed because
perl_construct resets it to \f(CW0\fR.
.PP
Now suppose we have more than one interpreter instance running at the
same time.  This is feasible, but only if you used the Configure option
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR or the options \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR when
building perl.  By default, enabling one of these Configure options
sets the per-interpreter global variable \f(CW\*(C`PL_perl_destruct_level\*(C'\fR to
\&\f(CW1\fR, so that thorough cleaning is automatic and interpreter variables
are initialized correctly.  Even if you don't intend to run two or
more interpreters at the same time, but to run them sequentially, like
in the above example, it is recommended to build perl with the
\&\f(CW\*(C`\-Dusemultiplicity\*(C'\fR option otherwise some interpreter variables may
not be initialized correctly between consecutive runs and your
application may crash.
.PP
See also \*(L"Thread-aware system interfaces\*(R" in perlxs.
.PP
Using \f(CW\*(C`\-Dusethreads \-Duseithreads\*(C'\fR rather than \f(CW\*(C`\-Dusemultiplicity\*(C'\fR
is more appropriate if you intend to run multiple interpreters
concurrently in different threads, because it enables support for
linking in the thread libraries of your system with the interpreter.
.PP
Let's give it a try:
.PP
.Vb 2
\& #include <EXTERN.h>
\& #include <perl.h>
\&
\& /* we\*(Aqre going to embed two interpreters */
\&
\& #define SAY_HELLO "\-e", "print qq(Hi, I\*(Aqm $^X\en)"
\&
\& int main(int argc, char **argv, char **env)
\& {
\&     PerlInterpreter *one_perl, *two_perl;
\&     char *one_args[] = { "one_perl", SAY_HELLO };
\&     char *two_args[] = { "two_perl", SAY_HELLO };
\&
\&     PERL_SYS_INIT3(&argc,&argv,&env);
\&     one_perl = perl_alloc();
\&     two_perl = perl_alloc();
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_construct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_construct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_parse(one_perl, NULL, 3, one_args, (char **)NULL);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_parse(two_perl, NULL, 3, two_args, (char **)NULL);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_run(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_run(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_destruct(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_destruct(two_perl);
\&
\&     PERL_SET_CONTEXT(one_perl);
\&     perl_free(one_perl);
\&     PERL_SET_CONTEXT(two_perl);
\&     perl_free(two_perl);
\&     PERL_SYS_TERM();
\& }
.Ve
.PP
Note the calls to \s-1\fIPERL_SET_CONTEXT\s0()\fR.  These are necessary to initialize
the global state that tracks which interpreter is the \*(L"current\*(R" one on
the particular process or thread that may be running it.  It should
always be used if you have more than one interpreter and are making
perl \s-1API\s0 calls on both interpreters in an interleaved fashion.
.PP
\&\s-1PERL_SET_CONTEXT\s0(interp) should also be called whenever \f(CW\*(C`interp\*(C'\fR is
used by a thread that did not create it (using either \fIperl_alloc()\fR, or
the more esoteric \fIperl_clone()\fR).
.PP
Compile as usual:
.PP
.Vb 1
\& % cc \-o multiplicity multiplicity.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
.Ve
.PP
Run it, Run it:
.PP
.Vb 3
\& % multiplicity
\& Hi, I\*(Aqm one_perl
\& Hi, I\*(Aqm two_perl
.Ve
.SS "Using Perl modules, which themselves use C libraries, from your C program"
.IX Subsection "Using Perl modules, which themselves use C libraries, from your C program"
If you've played with the examples above and tried to embed a script
that \fI\fIuse()\fI\fRs a Perl module (such as \fISocket\fR) which itself uses a C or \*(C+ library,
this probably happened:
.PP
.Vb 3
\& Can\*(Aqt load module Socket, dynamic loading not available in this perl.
\&  (You may need to build a new perl executable which either supports
\&  dynamic loading or has the Socket module statically linked into it.)
.Ve
.PP
What's wrong?
.PP
Your interpreter doesn't know how to communicate with these extensions
on its own.  A little glue will help.  Up until now you've been
calling \fI\fIperl_parse()\fI\fR, handing it \s-1NULL\s0 for the second argument:
.PP
.Vb 1
\& perl_parse(my_perl, NULL, argc, my_argv, NULL);
.Ve
.PP
That's where the glue code can be inserted to create the initial contact between
Perl and linked C/\*(C+ routines.  Let's take a look some pieces of \fIperlmain.c\fR
to see how Perl does this:
.PP
.Vb 1
\& static void xs_init (pTHX);
\&
\& EXTERN_C void boot_DynaLoader (pTHX_ CV* cv);
\& EXTERN_C void boot_Socket (pTHX_ CV* cv);
\&
\&
\& EXTERN_C void
\& xs_init(pTHX)
\& {
\&        char *file = _\|_FILE_\|_;
\&        /* DynaLoader is a special case */
\&        newXS("DynaLoader::boot_DynaLoader", boot_DynaLoader, file);
\&        newXS("Socket::bootstrap", boot_Socket, file);
\& }
.Ve
.PP
Simply put: for each extension linked with your Perl executable
(determined during its initial configuration on your
computer or when adding a new extension),
a Perl subroutine is created to incorporate the extension's
routines.  Normally, that subroutine is named
\&\fI\fIModule::bootstrap()\fI\fR and is invoked when you say \fIuse Module\fR.  In
turn, this hooks into an \s-1XSUB, \s0\fIboot_Module\fR, which creates a Perl
counterpart for each of the extension's XSUBs.  Don't worry about this
part; leave that to the \fIxsubpp\fR and extension authors.  If your
extension is dynamically loaded, DynaLoader creates \fI\fIModule::bootstrap()\fI\fR
for you on the fly.  In fact, if you have a working DynaLoader then there
is rarely any need to link in any other extensions statically.
.PP
Once you have this code, slap it into the second argument of \fI\fIperl_parse()\fI\fR:
.PP
.Vb 1
\& perl_parse(my_perl, xs_init, argc, my_argv, NULL);
.Ve
.PP
Then compile:
.PP
.Vb 1
\& % cc \-o interp interp.c \`perl \-MExtUtils::Embed \-e ccopts \-e ldopts\`
\&
\& % interp
\&   use Socket;
\&   use SomeDynamicallyLoadedModule;
\&
\&   print "Now I can use extensions!\en"\*(Aq
.Ve
.PP
\&\fBExtUtils::Embed\fR can also automate writing the \fIxs_init\fR glue code.
.PP
.Vb 4
\& % perl \-MExtUtils::Embed \-e xsinit \-\- \-o perlxsi.c
\& % cc \-c perlxsi.c \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-c interp.c  \`perl \-MExtUtils::Embed \-e ccopts\`
\& % cc \-o interp perlxsi.o interp.o \`perl \-MExtUtils::Embed \-e ldopts\`
.Ve
.PP
Consult perlxs, perlguts, and perlapi for more details.
.SH "Hiding Perl_"
.IX Header "Hiding Perl_"
If you completely hide the short forms of the Perl public \s-1API,\s0
add \-DPERL_NO_SHORT_NAMES to the compilation flags.  This means that
for example instead of writing
.PP
.Vb 1
\&    warn("%d bottles of beer on the wall", bottlecount);
.Ve
.PP
you will have to write the explicit full form
.PP
.Vb 1
\&    Perl_warn(aTHX_ "%d bottles of beer on the wall", bottlecount);
.Ve
.PP
(See \*(L"Background and \s-1PERL_IMPLICIT_CONTEXT\*(R"\s0 in perlguts for the explanation
of the \f(CW\*(C`aTHX_\*(C'\fR. )  Hiding the short forms is very useful for avoiding
all sorts of nasty (C preprocessor or otherwise) conflicts with other
software packages (Perl defines about 2400 APIs with these short names,
take or leave few hundred, so there certainly is room for conflict.)
.SH "MORAL"
.IX Header "MORAL"
You can sometimes \fIwrite faster code\fR in C, but
you can always \fIwrite code faster\fR in Perl.  Because you can use
each from the other, combine them as you wish.
.SH "AUTHOR"
.IX Header "AUTHOR"
Jon Orwant <\fIorwant@media.mit.edu\fR> and Doug MacEachern
<\fIdougm@covalent.net\fR>, with small contributions from Tim Bunce, Tom
Christiansen, Guy Decoux, Hallvard Furuseth, Dov Grobgeld, and Ilya
Zakharevich.
.PP
Doug MacEachern has an article on embedding in Volume 1, Issue 4 of
The Perl Journal ( http://www.tpj.com/ ).  Doug is also the developer of the
most widely-used Perl embedding: the mod_perl system
(perl.apache.org), which embeds Perl in the Apache web server.
Oracle, Binary Evolution, ActiveState, and Ben Sugars's nsapi_perl
have used this model for Oracle, Netscape and Internet Information
Server Perl plugins.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 1995, 1996, 1997, 1998 Doug MacEachern and Jon Orwant.  All
Rights Reserved.
.PP
This document may be distributed under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlepoc.1                                   0100644 0001750 0001750 00000017227 12566207416 022563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEPOC 1"
.TH PERLEPOC 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlepoc \- Perl for EPOC
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Perl 5 \s-1README\s0 file for the \s-1EPOC\s0 Release 5 operating system.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\s-1EPOC\s0 is an \s-1OS\s0 for palmtops and mobile phones. For more information look
at: <http://www.symbian.com/>
.PP
This is a port of perl to the epocemx \s-1SDK\s0 by Eberhard Mattes, which
itself uses the \s-1SDK\s0 by symbian. Essentially epocemx it is a \s-1POSIX\s0
look alike environment for the \s-1EPOC\s0 \s-1OS\s0.  For more information look at: 
<http://epocemx.sourceforge.net/>
.PP
perl and epocemx runs on Epoc Release 5 machines: Psion 5mx, 5mx Pro,
Psion Revo, Psion Netbook and on the Ericsson M128. It may run on Epoc
Release 3 Hardware (Series 5 classic), too. For more information about
this hardware please refer to <http://www.psion.com/>
.PP
Vendors which like to have support for their devices are free to send
me a sample.
.SH "INSTALLING PERL ON EPOC"
.IX Header "INSTALLING PERL ON EPOC"
You can download a ready-to-install version from
<http://www.oflebbe.de/perl/perl5.html>
.PP
You will need at least ~6MB free space in order to install and run perl.
.PP
Please install the emxusr.sis package from
<http://epocemx.sourceforge.net/> first.
.PP
Install perl.sis on the \s-1EPOC\s0 machine. If you do not know how to do
that, consult your PsiWin documentation.
.PP
Perl itself and its standard library is using 4 \s-1MB\s0 disk space.
Unicode support and some other modules are left out. (For details,
please look into epoc/createpkg.pl). If you like to use these modules,
you are free to copy them from a current perl release.
.SH "STARTING PERL ON EPOC"
.IX Header "STARTING PERL ON EPOC"
Please use the epocemx shell to start perl. perl integrates with the
conventions of epocemx.
.SS "Features of Perl on Epoc"
.IX Subsection "Features of Perl on Epoc"
The built-in function EPOC::getcwd returns the current directory.
.SS "Restrictions of Perl on Epoc"
.IX Subsection "Restrictions of Perl on Epoc"
Features are left out, because of restrictions of the \s-1POSIX\s0 support in
\&\s-1EPOC:\s0
.IP "\(bu" 4
socket \s-1IO\s0 is only implemented poorly. You can only use sysread and
syswrite on them. The commands read, write, print, <> do not work for
sockets. This may change iff epocemx supports sockets.
.IP "\(bu" 4
kill, alarm and signals. Do not try to use them. This may be
impossible to implement on \s-1EPOC\s0.
.IP "\(bu" 4
select is missing.
.IP "\(bu" 4
binmode does not exist. (No \s-1CR\s0 \s-1LF\s0 to \s-1LF\s0 translation for text files)
.IP "\(bu" 4
\&\s-1EPOC\s0 does not handle the notion of current drive and current
directory very well (i.e. not at all, but it tries hard to emulate
one). See \s-1PATH\s0.
.IP "\(bu" 4
Heap is limited to 4MB.
.IP "\(bu" 4
Dynamic loading is not implemented.
.SS "Compiling Perl 5 on the \s-1EPOC\s0 cross compiling environment"
.IX Subsection "Compiling Perl 5 on the EPOC cross compiling environment"
Sorry, this is far too short.
.IP "\(bu" 4
You will need the epocemx \s-1SDK\s0 from Eberhard Mattes.
.IP "\(bu" 4
Get the Perl sources from your nearest \s-1CPAN\s0 site.
.IP "\(bu" 4
Unpack the sources.
.IP "\(bu" 4
Build a native perl from this sources... Make sure to save the
miniperl executable as miniperl.native.
.Sp
Start again from scratch
.Sp
.Vb 7
\&      cp epoc/* .
\&      ./Configure \-S
\&      make 
\&      cp miniperl.native miniperl
\&      touch miniperl.exe
\&      make
\&      perl createpkg.pl 
\&
\&      emxsis perl.pkg perl.sis
.Ve
.SH "SUPPORT STATUS OF PERL ON EPOC"
.IX Header "SUPPORT STATUS OF PERL ON EPOC"
I'm offering this port \*(L"as is\*(R". You can ask me questions, but I can't
guarantee I'll be able to answer them. Since the port to epocemx is
quite new, please check the web for updates first.
.PP
Very special thanks to Eberhard Mattes for epocemx.
.SH "AUTHOR"
.IX Header "AUTHOR"
Olaf Flebbe <olaf@oflebbe.de>
<http://www.oflebbe.de/perl/perl5.html>
.SH "LAST UPDATE"
.IX Header "LAST UPDATE"
2003\-01\-18
                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlepoc5.16.1                               0100644 0001750 0001750 00000017227 12566207416 023075  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEPOC 1"
.TH PERLEPOC 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlepoc \- Perl for EPOC
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Perl 5 \s-1README\s0 file for the \s-1EPOC\s0 Release 5 operating system.
.SH "INTRODUCTION"
.IX Header "INTRODUCTION"
\&\s-1EPOC\s0 is an \s-1OS\s0 for palmtops and mobile phones. For more information look
at: <http://www.symbian.com/>
.PP
This is a port of perl to the epocemx \s-1SDK\s0 by Eberhard Mattes, which
itself uses the \s-1SDK\s0 by symbian. Essentially epocemx it is a \s-1POSIX\s0
look alike environment for the \s-1EPOC\s0 \s-1OS\s0.  For more information look at: 
<http://epocemx.sourceforge.net/>
.PP
perl and epocemx runs on Epoc Release 5 machines: Psion 5mx, 5mx Pro,
Psion Revo, Psion Netbook and on the Ericsson M128. It may run on Epoc
Release 3 Hardware (Series 5 classic), too. For more information about
this hardware please refer to <http://www.psion.com/>
.PP
Vendors which like to have support for their devices are free to send
me a sample.
.SH "INSTALLING PERL ON EPOC"
.IX Header "INSTALLING PERL ON EPOC"
You can download a ready-to-install version from
<http://www.oflebbe.de/perl/perl5.html>
.PP
You will need at least ~6MB free space in order to install and run perl.
.PP
Please install the emxusr.sis package from
<http://epocemx.sourceforge.net/> first.
.PP
Install perl.sis on the \s-1EPOC\s0 machine. If you do not know how to do
that, consult your PsiWin documentation.
.PP
Perl itself and its standard library is using 4 \s-1MB\s0 disk space.
Unicode support and some other modules are left out. (For details,
please look into epoc/createpkg.pl). If you like to use these modules,
you are free to copy them from a current perl release.
.SH "STARTING PERL ON EPOC"
.IX Header "STARTING PERL ON EPOC"
Please use the epocemx shell to start perl. perl integrates with the
conventions of epocemx.
.SS "Features of Perl on Epoc"
.IX Subsection "Features of Perl on Epoc"
The built-in function EPOC::getcwd returns the current directory.
.SS "Restrictions of Perl on Epoc"
.IX Subsection "Restrictions of Perl on Epoc"
Features are left out, because of restrictions of the \s-1POSIX\s0 support in
\&\s-1EPOC:\s0
.IP "\(bu" 4
socket \s-1IO\s0 is only implemented poorly. You can only use sysread and
syswrite on them. The commands read, write, print, <> do not work for
sockets. This may change iff epocemx supports sockets.
.IP "\(bu" 4
kill, alarm and signals. Do not try to use them. This may be
impossible to implement on \s-1EPOC\s0.
.IP "\(bu" 4
select is missing.
.IP "\(bu" 4
binmode does not exist. (No \s-1CR\s0 \s-1LF\s0 to \s-1LF\s0 translation for text files)
.IP "\(bu" 4
\&\s-1EPOC\s0 does not handle the notion of current drive and current
directory very well (i.e. not at all, but it tries hard to emulate
one). See \s-1PATH\s0.
.IP "\(bu" 4
Heap is limited to 4MB.
.IP "\(bu" 4
Dynamic loading is not implemented.
.SS "Compiling Perl 5 on the \s-1EPOC\s0 cross compiling environment"
.IX Subsection "Compiling Perl 5 on the EPOC cross compiling environment"
Sorry, this is far too short.
.IP "\(bu" 4
You will need the epocemx \s-1SDK\s0 from Eberhard Mattes.
.IP "\(bu" 4
Get the Perl sources from your nearest \s-1CPAN\s0 site.
.IP "\(bu" 4
Unpack the sources.
.IP "\(bu" 4
Build a native perl from this sources... Make sure to save the
miniperl executable as miniperl.native.
.Sp
Start again from scratch
.Sp
.Vb 7
\&      cp epoc/* .
\&      ./Configure \-S
\&      make 
\&      cp miniperl.native miniperl
\&      touch miniperl.exe
\&      make
\&      perl createpkg.pl 
\&
\&      emxsis perl.pkg perl.sis
.Ve
.SH "SUPPORT STATUS OF PERL ON EPOC"
.IX Header "SUPPORT STATUS OF PERL ON EPOC"
I'm offering this port \*(L"as is\*(R". You can ask me questions, but I can't
guarantee I'll be able to answer them. Since the port to epocemx is
quite new, please check the web for updates first.
.PP
Very special thanks to Eberhard Mattes for epocemx.
.SH "AUTHOR"
.IX Header "AUTHOR"
Olaf Flebbe <olaf@oflebbe.de>
<http://www.oflebbe.de/perl/perl5.html>
.SH "LAST UPDATE"
.IX Header "LAST UPDATE"
2003\-01\-18
                                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlexperiment.1                             0100644 0001750 0001750 00000031230 12566207436 024005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEXPERIMENT 1"
.TH PERLEXPERIMENT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlexperiment \- A listing of experimental features in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document lists the current and past experimental features in the perl
core. Although all of these are documented with their appropriate topics,
this succinct listing gives you an overview and basic facts about their
status.
.PP
So far we've merely tried to find and list the experimental features and infer
their inception, versions, etc. There's a lot of speculation here.
.SS "Current experiments"
.IX Subsection "Current experiments"
.IP "\-Dusemultiplicity \-Duseithreads" 8
.IX Item "-Dusemultiplicity -Duseithreads"
Introduced in Perl 5.6.0
.IP "Long Doubles Still Don't Work In Solaris" 8
.IX Item "Long Doubles Still Don't Work In Solaris"
Introduced in Perl 5.7.0
.ie n .IP """our"" can now have an experimental optional attribute ""unique""" 8
.el .IP "\f(CWour\fR can now have an experimental optional attribute \f(CWunique\fR" 8
.IX Item "our can now have an experimental optional attribute unique"
Introduced in Perl 5.8.0
.Sp
Deprecated in Perl 5.10.0
.IP "Linux abstract Unix domain sockets" 8
.IX Item "Linux abstract Unix domain sockets"
Introduced in Perl 5.9.2
.Sp
See also Socket
.IP "Pod::HTML2Pod" 8
.IX Item "Pod::HTML2Pod"
.PD 0
.IP "Pod::PXML" 8
.IX Item "Pod::PXML"
.IP "The <:pop> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:pop> IO pseudolayer"
.PD
See also perlrun
.IP "The <:win32> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:win32> IO pseudolayer"
See also perlrun
.IP "\s-1MLDBM\s0" 8
.IX Item "MLDBM"
See also perldsc
.IP "internal functions with M flag" 8
.IX Item "internal functions with M flag"
See also perlguts
.IP "lex_start \s-1API\s0" 8
.IX Item "lex_start API"
Introduced in Perl 5.13.7
.ie n .IP "internal \s-1API\s0 for ""%^H""" 8
.el .IP "internal \s-1API\s0 for \f(CW%^H\fR" 8
.IX Item "internal API for %^H"
Introduced in Perl 5.13.7
.Sp
See also \f(CW\*(C`cophh_\*(C'\fR in perlapi.
.IP "alloccopstash" 8
.IX Item "alloccopstash"
Introduced in Perl 5.18.0
.IP "av_create_and_push" 8
.IX Item "av_create_and_push"
.PD 0
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "cop_store_label" 8
.IX Item "cop_store_label"
.PD
Introduced in Perl 5.16.0
.IP "PL_keyword_plugin" 8
.IX Item "PL_keyword_plugin"
.PD 0
.IP "gv_fetchmethod_*_flags" 8
.IX Item "gv_fetchmethod_*_flags"
.PD
Introduced in Perl 5.16.0
.IP "hv_iternext_flags" 8
.IX Item "hv_iternext_flags"
.PD 0
.IP "lex_bufutf8" 8
.IX Item "lex_bufutf8"
.IP "lex_discard_to" 8
.IX Item "lex_discard_to"
.IP "lex_grow_linestr" 8
.IX Item "lex_grow_linestr"
.IP "lex_next_chunk" 8
.IX Item "lex_next_chunk"
.IP "lex_peek_unichar" 8
.IX Item "lex_peek_unichar"
.IP "lex_read_space" 8
.IX Item "lex_read_space"
.IP "lex_read_to" 8
.IX Item "lex_read_to"
.IP "lex_read_unichar" 8
.IX Item "lex_read_unichar"
.IP "lex_stuff_pv" 8
.IX Item "lex_stuff_pv"
.IP "lex_stuff_pvn" 8
.IX Item "lex_stuff_pvn"
.IP "lex_stuff_pvs" 8
.IX Item "lex_stuff_pvs"
.IP "lex_stuff_sv" 8
.IX Item "lex_stuff_sv"
.IP "lex_unstuff" 8
.IX Item "lex_unstuff"
.IP "op_scope" 8
.IX Item "op_scope"
.IP "op_lvalue" 8
.IX Item "op_lvalue"
.IP "parse_fullstmt" 8
.IX Item "parse_fullstmt"
.IP "parse_stmtseq" 8
.IX Item "parse_stmtseq"
.IP "PL_parser\->bufend" 8
.IX Item "PL_parser->bufend"
.IP "PL_parser\->bufptr" 8
.IX Item "PL_parser->bufptr"
.IP "PL_parser\->linestart" 8
.IX Item "PL_parser->linestart"
.IP "PL_parser\->linestr" 8
.IX Item "PL_parser->linestr"
.IP "Perl_signbit" 8
.IX Item "Perl_signbit"
.IP "pad_findmy" 8
.IX Item "pad_findmy"
.IP "sv_utf8_decode" 8
.IX Item "sv_utf8_decode"
.IP "sv_utf8_downgrade" 8
.IX Item "sv_utf8_downgrade"
.IP "bytes_from_utf8" 8
.IX Item "bytes_from_utf8"
.IP "bytes_to_utf8" 8
.IX Item "bytes_to_utf8"
.IP "utf8_to_bytes" 8
.IX Item "utf8_to_bytes"
.IP "Lvalue subroutines" 8
.IX Item "Lvalue subroutines"
.PD
Introduced in Perl 5.6.0
.Sp
See also perlsub
.ie n .IP "There is an ""installhtml"" target in the Makefile." 8
.el .IP "There is an \f(CWinstallhtml\fR target in the Makefile." 8
.IX Item "There is an installhtml target in the Makefile."
.PD 0
.IP "Unicode in Perl on \s-1EBCDIC\s0" 8
.IX Item "Unicode in Perl on EBCDIC"
.ie n .IP """(?{code})""" 8
.el .IP "\f(CW(?{code})\fR" 8
.IX Item "(?{code})"
.PD
See also perlre
.ie n .IP """(??{ code })""" 8
.el .IP "\f(CW(??{ code })\fR" 8
.IX Item "(??{ code })"
See also perlre
.ie n .IP "Smart match (""~~"")" 8
.el .IP "Smart match (\f(CW~~\fR)" 8
.IX Item "Smart match (~~)"
Introduced in Perl 5.10.0
.Sp
Modified in Perl 5.10.1, 5.12.0
.ie n .IP "Lexical $_" 8
.el .IP "Lexical \f(CW$_\fR" 8
.IX Item "Lexical $_"
Introduced in Perl 5.10.0
.IP "Backtracking control verbs" 8
.IX Item "Backtracking control verbs"
\&\f(CW\*(C`(*ACCEPT)\*(C'\fR
.Sp
Introduced in: Perl 5.10
.Sp
See also: \*(L"Special Backtracking Control Verbs\*(R" in perlre
.IP "Code expressions, conditional expressions, and independent expressions in regexes" 8
.IX Item "Code expressions, conditional expressions, and independent expressions in regexes"
.PD 0
.IP "gv_try_downgrade" 8
.IX Item "gv_try_downgrade"
.PD
See also perlintern
.IP "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0" 8
.IX Item "Experimental Support for Sun Studio Compilers for Linux OS"
See also perllinux
.IP "Pluggable keywords" 8
.IX Item "Pluggable keywords"
See \*(L"PL_keyword_plugin\*(R" in perlapi for the mechanism.
.Sp
Introduced in: Perl 5.11.2
.IP "Array and hash container functions accept references" 8
.IX Item "Array and hash container functions accept references"
Introduced in Perl 5.14.0
.IP "Lexical subroutines" 8
.IX Item "Lexical subroutines"
Introduced in: Perl 5.18
.Sp
See also: \*(L"Lexical Subroutines\*(R" in perlsub
.IP "Regular Expression Set Operations" 8
.IX Item "Regular Expression Set Operations"
Introduced in: Perl 5.18
.Sp
See also: \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass
.SS "Accepted features"
.IX Subsection "Accepted features"
These features were so wildly successful and played so well with others that
we decided to remove their experimental status and admit them as full, stable
features in the world of Perl, lavishing all the benefits and luxuries thereof. 
They are also awarded +5 Stability and +3 Charisma.
.ie n .IP "The ""\eN"" regex character class" 8
.el .IP "The \f(CW\eN\fR regex character class" 8
.IX Item "The N regex character class"
The \f(CW\*(C`\eN\*(C'\fR character class, not to be confused with the named character
sequence \f(CW\*(C`\eN{NAME}\*(C'\fR, denotes any non-newline character in a regular
expression.
.Sp
Introduced in: Perl 5.12
.IP "\fIfork()\fR emulation" 8
.IX Item "fork() emulation"
Introduced in Perl 5.6.1
.Sp
See also perlfork
.IP "\s-1DB\s0 module" 8
.IX Item "DB module"
Introduced in Perl 5.6.0
.Sp
See also perldebug, perldebtut
.IP "Weak references" 8
.IX Item "Weak references"
Introduced in Perl 5.6.0
.IP "Internal file glob" 8
.IX Item "Internal file glob"
Introduced in Perl 5.6.0
.IP "die accepts a reference" 8
.IX Item "die accepts a reference"
Introduced in Perl 5.005
.IP "64\-bit support" 8
.IX Item "64-bit support"
Introduced in Perl 5.005
.SS "Removed features"
.IX Subsection "Removed features"
These features are no longer considered experimental and their functionality
has disappeared. It's your own fault if you wrote production programs using
these features after we explicitly told you not to (see perlpolicy).
.ie n .IP """legacy""" 8
.el .IP "\f(CWlegacy\fR" 8
.IX Item "legacy"
The experimental \f(CW\*(C`legacy\*(C'\fR pragma was swallowed by the \f(CW\*(C`feature\*(C'\fR pragma.
.Sp
Introduced in: 5.11.2
.Sp
Removed in: 5.11.3
.IP "Assertions" 8
.IX Item "Assertions"
The \f(CW\*(C`\-A\*(C'\fR command line switch
.Sp
Introduced in Perl 5.9.0
.Sp
Removed in Perl 5.9.5
.IP "Test::Harness::Straps" 8
.IX Item "Test::Harness::Straps"
Moved from Perl 5.10.1 to \s-1CPAN\s0
.IP "GetOpt::Long Options can now take multiple values at once (experimental)" 8
.IX Item "GetOpt::Long Options can now take multiple values at once (experimental)"
\&\f(CW\*(C`Getopt::Long\*(C'\fR upgraded to version 2.35
.Sp
Removed in Perl 5.8.8
.IP "The pseudo-hash data type" 8
.IX Item "The pseudo-hash data type"
Introduced in Perl 5.6.0
.Sp
Removed in Perl 5.9.0
.IP "5.005\-style threading" 8
.IX Item "5.005-style threading"
Introduced in Perl 5.005
.Sp
Removed in Perl 5.10
.IP "perlcc" 8
.IX Item "perlcc"
Introduced in Perl 5.005
.Sp
Moved from Perl 5.9.0 to \s-1CPAN\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.PP
Se\*'bastien Aperghis-Tramoni \f(CW\*(C`<saper@cpan.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010, brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
You can use and redistribute this document under the same terms as Perl
itself.
                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlexperiment5.16.1                         0100644 0001750 0001750 00000027106 12566207416 024324  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEXPERIMENT 1"
.TH PERLEXPERIMENT 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlexperiment \- A listing of experimental features in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document lists the current and past experimental features in the perl
core. Although all of these are documented with their appropriate topics,
this succinct listing gives you an overview and basic facts about their
status.
.PP
So far I've merely tried to find and list the experimental features and infer
their inception, versions, etc. There's a lot of speculation here.
.SS "Current experiments"
.IX Subsection "Current experiments"
.IP "\fIfork()\fR emulation" 8
.IX Item "fork() emulation"
Introduced in Perl 5.6.1
.Sp
See also perlfork
.IP "Weak references" 8
.IX Item "Weak references"
Introduced in Perl 5.6.0
.IP "Internal file glob" 8
.IX Item "Internal file glob"
Introduced in Perl 5.6.0
.Sp
Accepted in \s-1XXX\s0
.IP "64\-bit support" 8
.IX Item "64-bit support"
Introduced in Perl 5.005
.Sp
Accepted in \s-1XXX\s0
.IP "die accepts a reference" 8
.IX Item "die accepts a reference"
Introduced in Perl 5.005
.Sp
Accepted in Perl \s-1XXX\s0
.IP "Unicode support" 8
.IX Item "Unicode support"
Introduced in Perl 5.6.0
.Sp
Accepted in Perl 5.8.0 \s-1XXX\s0
.IP "\-Dusemultiplicity \-Dusethreads" 8
.IX Item "-Dusemultiplicity -Dusethreads"
Introduced in Perl 5.6.0
.IP "Long Doubles Still Don't Work In Solaris" 8
.IX Item "Long Doubles Still Don't Work In Solaris"
Introduced in Perl 5.7.0
.IP "GetOpt::Long Options can now take multiple values at once (experimental)" 8
.IX Item "GetOpt::Long Options can now take multiple values at once (experimental)"
\&\f(CW\*(C`Getopt::Long\*(C'\fR upgraded to version 2.35
.Sp
Removed in Perl 5.8.8
.IP "5.005\-style threading" 8
.IX Item "5.005-style threading"
Introduced in Perl 5.005
.Sp
Removed in Perl 5.10 \s-1XXX\s0
.IP "Test::Harness::Straps" 8
.IX Item "Test::Harness::Straps"
Removed in Perl 5.10.1
.IP "perlcc" 8
.IX Item "perlcc"
Introduced in Perl 5.005
.Sp
Removed in Perl 5.9.0
.ie n .IP """our"" can now have an experimental optional attribute ""unique""" 8
.el .IP "\f(CWour\fR can now have an experimental optional attribute \f(CWunique\fR" 8
.IX Item "our can now have an experimental optional attribute unique"
Introduced in Perl 5.8.0
.Sp
Deprecated in Perl 5.10.0
.IP "Assertions" 8
.IX Item "Assertions"
The \f(CW\*(C`\-A\*(C'\fR command line switch
.Sp
Introduced in Perl 5.9.0
.Sp
Removed in Perl 5.9.5
.IP "Linux abstract Unix domain sockets" 8
.IX Item "Linux abstract Unix domain sockets"
Introduced in Perl 5.9.2
.Sp
See also Socket
.IP "Pod::HTML2Pod" 8
.IX Item "Pod::HTML2Pod"
.PD 0
.IP "Pod::PXML" 8
.IX Item "Pod::PXML"
.IP "threads" 8
.IX Item "threads"
.IP "The <:pop> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:pop> IO pseudolayer"
.PD
See also perlrun
.IP "The <:win32> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:win32> IO pseudolayer"
See also perlrun
.IP "\s-1MLDBM\s0" 8
.IX Item "MLDBM"
See also perldsc
.IP "internal functions with M flag" 8
.IX Item "internal functions with M flag"
See also perlguts
.IP "lex_start \s-1API\s0" 8
.IX Item "lex_start API"
Introduced in Perl 5.13.7
.ie n .IP "internal \s-1API\s0 for %H" 8
.el .IP "internal \s-1API\s0 for \f(CW%H\fR" 8
.IX Item "internal API for %H"
Introduced in Perl 5.13.7
.Sp
See also \f(CW\*(C`cophh_\*(C'\fR in perlapi.
.IP "av_create_and_push" 8
.IX Item "av_create_and_push"
.PD 0
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "PL_keyword_plugin" 8
.IX Item "PL_keyword_plugin"
.IP "hv_iternext_flags" 8
.IX Item "hv_iternext_flags"
.IP "lex_bufutf8" 8
.IX Item "lex_bufutf8"
.IP "lex_discard_to" 8
.IX Item "lex_discard_to"
.IP "lex_grow_linestr" 8
.IX Item "lex_grow_linestr"
.IP "lex_next_chunk" 8
.IX Item "lex_next_chunk"
.IP "lex_peek_unichar" 8
.IX Item "lex_peek_unichar"
.IP "lex_read_space" 8
.IX Item "lex_read_space"
.IP "lex_read_to" 8
.IX Item "lex_read_to"
.IP "lex_read_unichar" 8
.IX Item "lex_read_unichar"
.IP "lex_stuff_pv" 8
.IX Item "lex_stuff_pv"
.IP "lex_stuff_pvn" 8
.IX Item "lex_stuff_pvn"
.IP "lex_stuff_pvs" 8
.IX Item "lex_stuff_pvs"
.IP "lex_stuff_sv" 8
.IX Item "lex_stuff_sv"
.IP "lex_unstuff" 8
.IX Item "lex_unstuff"
.IP "parse_fullstmt" 8
.IX Item "parse_fullstmt"
.IP "parse_stmtseq" 8
.IX Item "parse_stmtseq"
.IP "PL_parser\->bufend" 8
.IX Item "PL_parser->bufend"
.IP "PL_parser\->bufptr" 8
.IX Item "PL_parser->bufptr"
.IP "PL_parser\->linestart" 8
.IX Item "PL_parser->linestart"
.IP "PL_parser\->linestr" 8
.IX Item "PL_parser->linestr"
.IP "Perl_signbit" 8
.IX Item "Perl_signbit"
.IP "pad_findmy" 8
.IX Item "pad_findmy"
.IP "sv_utf8_decode" 8
.IX Item "sv_utf8_decode"
.IP "sv_utf8_downgrade" 8
.IX Item "sv_utf8_downgrade"
.IP "bytes_from_utf8" 8
.IX Item "bytes_from_utf8"
.IP "bytes_to_utf8" 8
.IX Item "bytes_to_utf8"
.IP "utf8_to_bytes" 8
.IX Item "utf8_to_bytes"
.IP "\s-1DB\s0 module" 8
.IX Item "DB module"
.PD
Introduced in Perl 5.6.0
.Sp
See also perldebug, perldebtut
.IP "The pseudo-hash data type" 8
.IX Item "The pseudo-hash data type"
Introduced in Perl 5.6.0
.IP "Lvalue subroutines" 8
.IX Item "Lvalue subroutines"
Introduced in Perl 5.6.0
.Sp
See also perlsub
.ie n .IP "There is an ""installhtml"" target in the Makefile." 8
.el .IP "There is an \f(CWinstallhtml\fR target in the Makefile." 8
.IX Item "There is an installhtml target in the Makefile."
.PD 0
.IP "Unicode in Perl on \s-1EBCDIC\s0" 8
.IX Item "Unicode in Perl on EBCDIC"
.ie n .IP """(?{code})""" 8
.el .IP "\f(CW(?{code})\fR" 8
.IX Item "(?{code})"
.PD
See also perlre
.ie n .IP """(??{ code })""" 8
.el .IP "\f(CW(??{ code })\fR" 8
.IX Item "(??{ code })"
See also perlre
.IP "Backtracking control verbs" 8
.IX Item "Backtracking control verbs"
\&\f(CW\*(C`(*ACCEPT)\*(C'\fR
.Sp
Introduced in: Perl 5.10
.Sp
See also: \*(L"Special Backtracking Control Verbs\*(R" in perlre
.IP "Code expressions, conditional expressions, and independent expressions in regexes" 8
.IX Item "Code expressions, conditional expressions, and independent expressions in regexes"
.PD 0
.ie n .IP "The ""\eN"" regex character class" 8
.el .IP "The \f(CW\eN\fR regex character class" 8
.IX Item "The N regex character class"
.PD
The \f(CW\*(C`\eN\*(C'\fR character class, not to be confused with the named character
sequence \f(CW\*(C`\eN{NAME}\*(C'\fR, denotes any non-newline character in a regular
expression.
.Sp
Introduced in: Perl 5.12
.Sp
See also:
.IP "gv_try_downgrade" 8
.IX Item "gv_try_downgrade"
See also perlintern
.IP "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0" 8
.IX Item "Experimental Support for Sun Studio Compilers for Linux OS"
See also perllinux
.IP "Pluggable keywords" 8
.IX Item "Pluggable keywords"
See \*(L"PL_keyword_plugin\*(R" in perlapi for the mechanism.
.Sp
Introduced in: Perl 5.11.2
.SS "Accepted features"
.IX Subsection "Accepted features"
These features were so wildly successful and played so well with others that
we decided to remove their experimental status and admit them as full, stable
features in the world of Perl, lavishing all the benefits and luxuries thereof. 
They are also awarded +5 Stability and +3 Charisma.
.IP "(none yet identified)" 8
.IX Item "(none yet identified)"
.SS "Removed features"
.IX Subsection "Removed features"
These features are no longer considered experimental and their functionality
has disappeared. It's your own fault if you wrote production programs using
these features after we explicitly told you not to (see perlpolicy).
.ie n .IP """legacy""" 8
.el .IP "\f(CWlegacy\fR" 8
.IX Item "legacy"
The experimental \f(CW\*(C`legacy\*(C'\fR pragma was swallowed by the \f(CW\*(C`feature\*(C'\fR pragma.
.Sp
Introduced in: 5.11.2
.Sp
Removed in: 5.11.3
.SH "AUTHORS"
.IX Header "AUTHORS"
brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010, brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
You can use and redistribute this document under the same terms as Perl
itself.
                                                                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlexperiment5.18.1                         0100644 0001750 0001750 00000031230 12566207436 024321  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLEXPERIMENT 1"
.TH PERLEXPERIMENT 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlexperiment \- A listing of experimental features in Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This document lists the current and past experimental features in the perl
core. Although all of these are documented with their appropriate topics,
this succinct listing gives you an overview and basic facts about their
status.
.PP
So far we've merely tried to find and list the experimental features and infer
their inception, versions, etc. There's a lot of speculation here.
.SS "Current experiments"
.IX Subsection "Current experiments"
.IP "\-Dusemultiplicity \-Duseithreads" 8
.IX Item "-Dusemultiplicity -Duseithreads"
Introduced in Perl 5.6.0
.IP "Long Doubles Still Don't Work In Solaris" 8
.IX Item "Long Doubles Still Don't Work In Solaris"
Introduced in Perl 5.7.0
.ie n .IP """our"" can now have an experimental optional attribute ""unique""" 8
.el .IP "\f(CWour\fR can now have an experimental optional attribute \f(CWunique\fR" 8
.IX Item "our can now have an experimental optional attribute unique"
Introduced in Perl 5.8.0
.Sp
Deprecated in Perl 5.10.0
.IP "Linux abstract Unix domain sockets" 8
.IX Item "Linux abstract Unix domain sockets"
Introduced in Perl 5.9.2
.Sp
See also Socket
.IP "Pod::HTML2Pod" 8
.IX Item "Pod::HTML2Pod"
.PD 0
.IP "Pod::PXML" 8
.IX Item "Pod::PXML"
.IP "The <:pop> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:pop> IO pseudolayer"
.PD
See also perlrun
.IP "The <:win32> \s-1IO\s0 pseudolayer" 8
.IX Item "The <:win32> IO pseudolayer"
See also perlrun
.IP "\s-1MLDBM\s0" 8
.IX Item "MLDBM"
See also perldsc
.IP "internal functions with M flag" 8
.IX Item "internal functions with M flag"
See also perlguts
.IP "lex_start \s-1API\s0" 8
.IX Item "lex_start API"
Introduced in Perl 5.13.7
.ie n .IP "internal \s-1API\s0 for ""%^H""" 8
.el .IP "internal \s-1API\s0 for \f(CW%^H\fR" 8
.IX Item "internal API for %^H"
Introduced in Perl 5.13.7
.Sp
See also \f(CW\*(C`cophh_\*(C'\fR in perlapi.
.IP "alloccopstash" 8
.IX Item "alloccopstash"
Introduced in Perl 5.18.0
.IP "av_create_and_push" 8
.IX Item "av_create_and_push"
.PD 0
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "av_create_and_unshift_one" 8
.IX Item "av_create_and_unshift_one"
.IP "cop_store_label" 8
.IX Item "cop_store_label"
.PD
Introduced in Perl 5.16.0
.IP "PL_keyword_plugin" 8
.IX Item "PL_keyword_plugin"
.PD 0
.IP "gv_fetchmethod_*_flags" 8
.IX Item "gv_fetchmethod_*_flags"
.PD
Introduced in Perl 5.16.0
.IP "hv_iternext_flags" 8
.IX Item "hv_iternext_flags"
.PD 0
.IP "lex_bufutf8" 8
.IX Item "lex_bufutf8"
.IP "lex_discard_to" 8
.IX Item "lex_discard_to"
.IP "lex_grow_linestr" 8
.IX Item "lex_grow_linestr"
.IP "lex_next_chunk" 8
.IX Item "lex_next_chunk"
.IP "lex_peek_unichar" 8
.IX Item "lex_peek_unichar"
.IP "lex_read_space" 8
.IX Item "lex_read_space"
.IP "lex_read_to" 8
.IX Item "lex_read_to"
.IP "lex_read_unichar" 8
.IX Item "lex_read_unichar"
.IP "lex_stuff_pv" 8
.IX Item "lex_stuff_pv"
.IP "lex_stuff_pvn" 8
.IX Item "lex_stuff_pvn"
.IP "lex_stuff_pvs" 8
.IX Item "lex_stuff_pvs"
.IP "lex_stuff_sv" 8
.IX Item "lex_stuff_sv"
.IP "lex_unstuff" 8
.IX Item "lex_unstuff"
.IP "op_scope" 8
.IX Item "op_scope"
.IP "op_lvalue" 8
.IX Item "op_lvalue"
.IP "parse_fullstmt" 8
.IX Item "parse_fullstmt"
.IP "parse_stmtseq" 8
.IX Item "parse_stmtseq"
.IP "PL_parser\->bufend" 8
.IX Item "PL_parser->bufend"
.IP "PL_parser\->bufptr" 8
.IX Item "PL_parser->bufptr"
.IP "PL_parser\->linestart" 8
.IX Item "PL_parser->linestart"
.IP "PL_parser\->linestr" 8
.IX Item "PL_parser->linestr"
.IP "Perl_signbit" 8
.IX Item "Perl_signbit"
.IP "pad_findmy" 8
.IX Item "pad_findmy"
.IP "sv_utf8_decode" 8
.IX Item "sv_utf8_decode"
.IP "sv_utf8_downgrade" 8
.IX Item "sv_utf8_downgrade"
.IP "bytes_from_utf8" 8
.IX Item "bytes_from_utf8"
.IP "bytes_to_utf8" 8
.IX Item "bytes_to_utf8"
.IP "utf8_to_bytes" 8
.IX Item "utf8_to_bytes"
.IP "Lvalue subroutines" 8
.IX Item "Lvalue subroutines"
.PD
Introduced in Perl 5.6.0
.Sp
See also perlsub
.ie n .IP "There is an ""installhtml"" target in the Makefile." 8
.el .IP "There is an \f(CWinstallhtml\fR target in the Makefile." 8
.IX Item "There is an installhtml target in the Makefile."
.PD 0
.IP "Unicode in Perl on \s-1EBCDIC\s0" 8
.IX Item "Unicode in Perl on EBCDIC"
.ie n .IP """(?{code})""" 8
.el .IP "\f(CW(?{code})\fR" 8
.IX Item "(?{code})"
.PD
See also perlre
.ie n .IP """(??{ code })""" 8
.el .IP "\f(CW(??{ code })\fR" 8
.IX Item "(??{ code })"
See also perlre
.ie n .IP "Smart match (""~~"")" 8
.el .IP "Smart match (\f(CW~~\fR)" 8
.IX Item "Smart match (~~)"
Introduced in Perl 5.10.0
.Sp
Modified in Perl 5.10.1, 5.12.0
.ie n .IP "Lexical $_" 8
.el .IP "Lexical \f(CW$_\fR" 8
.IX Item "Lexical $_"
Introduced in Perl 5.10.0
.IP "Backtracking control verbs" 8
.IX Item "Backtracking control verbs"
\&\f(CW\*(C`(*ACCEPT)\*(C'\fR
.Sp
Introduced in: Perl 5.10
.Sp
See also: \*(L"Special Backtracking Control Verbs\*(R" in perlre
.IP "Code expressions, conditional expressions, and independent expressions in regexes" 8
.IX Item "Code expressions, conditional expressions, and independent expressions in regexes"
.PD 0
.IP "gv_try_downgrade" 8
.IX Item "gv_try_downgrade"
.PD
See also perlintern
.IP "Experimental Support for Sun Studio Compilers for Linux \s-1OS\s0" 8
.IX Item "Experimental Support for Sun Studio Compilers for Linux OS"
See also perllinux
.IP "Pluggable keywords" 8
.IX Item "Pluggable keywords"
See \*(L"PL_keyword_plugin\*(R" in perlapi for the mechanism.
.Sp
Introduced in: Perl 5.11.2
.IP "Array and hash container functions accept references" 8
.IX Item "Array and hash container functions accept references"
Introduced in Perl 5.14.0
.IP "Lexical subroutines" 8
.IX Item "Lexical subroutines"
Introduced in: Perl 5.18
.Sp
See also: \*(L"Lexical Subroutines\*(R" in perlsub
.IP "Regular Expression Set Operations" 8
.IX Item "Regular Expression Set Operations"
Introduced in: Perl 5.18
.Sp
See also: \*(L"Extended Bracketed Character Classes\*(R" in perlrecharclass
.SS "Accepted features"
.IX Subsection "Accepted features"
These features were so wildly successful and played so well with others that
we decided to remove their experimental status and admit them as full, stable
features in the world of Perl, lavishing all the benefits and luxuries thereof. 
They are also awarded +5 Stability and +3 Charisma.
.ie n .IP "The ""\eN"" regex character class" 8
.el .IP "The \f(CW\eN\fR regex character class" 8
.IX Item "The N regex character class"
The \f(CW\*(C`\eN\*(C'\fR character class, not to be confused with the named character
sequence \f(CW\*(C`\eN{NAME}\*(C'\fR, denotes any non-newline character in a regular
expression.
.Sp
Introduced in: Perl 5.12
.IP "\fIfork()\fR emulation" 8
.IX Item "fork() emulation"
Introduced in Perl 5.6.1
.Sp
See also perlfork
.IP "\s-1DB\s0 module" 8
.IX Item "DB module"
Introduced in Perl 5.6.0
.Sp
See also perldebug, perldebtut
.IP "Weak references" 8
.IX Item "Weak references"
Introduced in Perl 5.6.0
.IP "Internal file glob" 8
.IX Item "Internal file glob"
Introduced in Perl 5.6.0
.IP "die accepts a reference" 8
.IX Item "die accepts a reference"
Introduced in Perl 5.005
.IP "64\-bit support" 8
.IX Item "64-bit support"
Introduced in Perl 5.005
.SS "Removed features"
.IX Subsection "Removed features"
These features are no longer considered experimental and their functionality
has disappeared. It's your own fault if you wrote production programs using
these features after we explicitly told you not to (see perlpolicy).
.ie n .IP """legacy""" 8
.el .IP "\f(CWlegacy\fR" 8
.IX Item "legacy"
The experimental \f(CW\*(C`legacy\*(C'\fR pragma was swallowed by the \f(CW\*(C`feature\*(C'\fR pragma.
.Sp
Introduced in: 5.11.2
.Sp
Removed in: 5.11.3
.IP "Assertions" 8
.IX Item "Assertions"
The \f(CW\*(C`\-A\*(C'\fR command line switch
.Sp
Introduced in Perl 5.9.0
.Sp
Removed in Perl 5.9.5
.IP "Test::Harness::Straps" 8
.IX Item "Test::Harness::Straps"
Moved from Perl 5.10.1 to \s-1CPAN\s0
.IP "GetOpt::Long Options can now take multiple values at once (experimental)" 8
.IX Item "GetOpt::Long Options can now take multiple values at once (experimental)"
\&\f(CW\*(C`Getopt::Long\*(C'\fR upgraded to version 2.35
.Sp
Removed in Perl 5.8.8
.IP "The pseudo-hash data type" 8
.IX Item "The pseudo-hash data type"
Introduced in Perl 5.6.0
.Sp
Removed in Perl 5.9.0
.IP "5.005\-style threading" 8
.IX Item "5.005-style threading"
Introduced in Perl 5.005
.Sp
Removed in Perl 5.10
.IP "perlcc" 8
.IX Item "perlcc"
Introduced in Perl 5.005
.Sp
Moved from Perl 5.9.0 to \s-1CPAN\s0
.SH "AUTHORS"
.IX Header "AUTHORS"
brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.PP
Se\*'bastien Aperghis-Tramoni \f(CW\*(C`<saper@cpan.org>\*(C'\fR
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2010, brian d foy \f(CW\*(C`<brian.d.foy@gmail.com>\*(C'\fR
.SH "LICENSE"
.IX Header "LICENSE"
You can use and redistribute this document under the same terms as Perl
itself.
                                                                                                                                                                                                                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq.1                                    0100644 0001750 0001750 00000070777 12566207436 022417  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ 1"
.TH PERLFAQ 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq \- frequently asked questions about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The perlfaq comprises several documents that answer the most commonly
asked questions about Perl and Perl programming. It's divided by topic
into nine major sections outlined in this document.
.SS "Where to find the perlfaq"
.IX Subsection "Where to find the perlfaq"
The perlfaq is an evolving document.  Read the latest version at
<http://learn.perl.org/faq/>.  It is also included in the standard Perl
distribution.
.SS "How to use the perlfaq"
.IX Subsection "How to use the perlfaq"
The \f(CW\*(C`perldoc\*(C'\fR command line tool is part of the standard Perl distribution. To
read the perlfaq:
.PP
.Vb 1
\&    $ perldoc perlfaq
.Ve
.PP
To search the perlfaq question headings:
.PP
.Vb 1
\&    $ perldoc \-q open
.Ve
.SS "How to contribute to the perlfaq"
.IX Subsection "How to contribute to the perlfaq"
Review <https://github.com/perl\-doc\-cats/perlfaq/wiki>.  If you don't find
your suggestion create an issue or pull request against
<https://github.com/perl\-doc\-cats/perlfaq>.
.PP
Once approved, changes are merged into <https://github.com/tpf/perlfaq>, the
repository which drives <http://learn.perl.org/faq/>, and they are
distributed with the next Perl 5 release.
.SS "What if my question isn't answered in the \s-1FAQ\s0?"
.IX Subsection "What if my question isn't answered in the FAQ?"
Try the resources in perlfaq2.
.SH "TABLE OF CONTENTS"
.IX Header "TABLE OF CONTENTS"
.IP "perlfaq1 \- General Questions About Perl" 4
.IX Item "perlfaq1 - General Questions About Perl"
.PD 0
.IP "perlfaq2 \- Obtaining and Learning about Perl" 4
.IX Item "perlfaq2 - Obtaining and Learning about Perl"
.IP "perlfaq3 \- Programming Tools" 4
.IX Item "perlfaq3 - Programming Tools"
.IP "perlfaq4 \- Data Manipulation" 4
.IX Item "perlfaq4 - Data Manipulation"
.IP "perlfaq5 \- Files and Formats" 4
.IX Item "perlfaq5 - Files and Formats"
.IP "perlfaq6 \- Regular Expressions" 4
.IX Item "perlfaq6 - Regular Expressions"
.IP "perlfaq7 \- General Perl Language Issues" 4
.IX Item "perlfaq7 - General Perl Language Issues"
.IP "perlfaq8 \- System Interaction" 4
.IX Item "perlfaq8 - System Interaction"
.IP "perlfaq9 \- Web, Email and Networking" 4
.IX Item "perlfaq9 - Web, Email and Networking"
.PD
.SH "THE QUESTIONS"
.IX Header "THE QUESTIONS"
.SS "perlfaq1: General Questions About Perl"
.IX Subsection "perlfaq1: General Questions About Perl"
This section of the \s-1FAQ\s0 answers very general, high-level questions about Perl.
.IP "\(bu" 4
What is Perl?
.IP "\(bu" 4
Who supports Perl? Who develops it? Why is it free?
.IP "\(bu" 4
Which version of Perl should I use?
.IP "\(bu" 4
What are Perl 4, Perl 5, or Perl 6?
.IP "\(bu" 4
What is Perl 6?
.IP "\(bu" 4
How stable is Perl?
.IP "\(bu" 4
Is Perl difficult to learn?
.IP "\(bu" 4
How does Perl compare with other languages like Java, Python, \s-1REXX,\s0 Scheme, or Tcl?
.IP "\(bu" 4
Can I do [task] in Perl?
.IP "\(bu" 4
When shouldn't I program in Perl?
.IP "\(bu" 4
What's the difference between \*(L"perl\*(R" and \*(L"Perl\*(R"?
.IP "\(bu" 4
What is a \s-1JAPH\s0?
.IP "\(bu" 4
How can I convince others to use Perl?
.SS "perlfaq2: Obtaining and Learning about Perl"
.IX Subsection "perlfaq2: Obtaining and Learning about Perl"
This section of the \s-1FAQ\s0 answers questions about where to find source and documentation for Perl, support, and related matters.
.IP "\(bu" 4
What machines support Perl? Where do I get it?
.IP "\(bu" 4
How can I get a binary version of Perl?
.IP "\(bu" 4
I don't have a C compiler. How can I build my own Perl interpreter?
.IP "\(bu" 4
I copied the Perl binary from one machine to another, but scripts don't work.
.IP "\(bu" 4
I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?
.IP "\(bu" 4
What modules and extensions are available for Perl? What is \s-1CPAN\s0?
.IP "\(bu" 4
Where can I get information on Perl?
.IP "\(bu" 4
What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?
.IP "\(bu" 4
Where can I post questions?
.IP "\(bu" 4
Perl Books
.IP "\(bu" 4
Which magazines have Perl content?
.IP "\(bu" 4
Which Perl blogs should I read?
.IP "\(bu" 4
What mailing lists are there for Perl?
.IP "\(bu" 4
Where can I buy a commercial version of Perl?
.IP "\(bu" 4
Where do I send bug reports?
.SS "perlfaq3: Programming Tools"
.IX Subsection "perlfaq3: Programming Tools"
This section of the \s-1FAQ\s0 answers questions related to programmer tools and programming support.
.IP "\(bu" 4
How do I do (anything)?
.IP "\(bu" 4
How can I use Perl interactively?
.IP "\(bu" 4
How do I find which modules are installed on my system?
.IP "\(bu" 4
How do I debug my Perl programs?
.IP "\(bu" 4
How do I profile my Perl programs?
.IP "\(bu" 4
How do I cross-reference my Perl programs?
.IP "\(bu" 4
Is there a pretty-printer (formatter) for Perl?
.IP "\(bu" 4
Is there an \s-1IDE\s0 or Windows Perl Editor?
.IP "\(bu" 4
Where can I get Perl macros for vi?
.IP "\(bu" 4
Where can I get perl-mode or cperl-mode for emacs?
.IP "\(bu" 4
How can I use curses with Perl?
.IP "\(bu" 4
How can I write a \s-1GUI \s0(X, Tk, Gtk, etc.) in Perl?
.IP "\(bu" 4
How can I make my Perl program run faster?
.IP "\(bu" 4
How can I make my Perl program take less memory?
.IP "\(bu" 4
Is it safe to return a reference to local or lexical data?
.IP "\(bu" 4
How can I free an array or hash so my program shrinks?
.IP "\(bu" 4
How can I make my \s-1CGI\s0 script more efficient?
.IP "\(bu" 4
How can I hide the source for my Perl program?
.IP "\(bu" 4
How can I compile my Perl program into byte code or C?
.IP "\(bu" 4
How can I get \f(CW\*(C`#!perl\*(C'\fR to work on [\s-1MS\-DOS,NT,...\s0]?
.IP "\(bu" 4
Can I write useful Perl programs on the command line?
.IP "\(bu" 4
Why don't Perl one-liners work on my DOS/Mac/VMS system?
.IP "\(bu" 4
Where can I learn about \s-1CGI\s0 or Web programming in Perl?
.IP "\(bu" 4
Where can I learn about object-oriented Perl programming?
.IP "\(bu" 4
Where can I learn about linking C with Perl?
.IP "\(bu" 4
I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?
.IP "\(bu" 4
When I tried to run my script, I got this message. What does it mean?
.IP "\(bu" 4
What's MakeMaker?
.SS "perlfaq4: Data Manipulation"
.IX Subsection "perlfaq4: Data Manipulation"
This section of the \s-1FAQ\s0 answers questions related to manipulating numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.IP "\(bu" 4
Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?
.IP "\(bu" 4
Why is \fIint()\fR broken?
.IP "\(bu" 4
Why isn't my octal data interpreted correctly?
.IP "\(bu" 4
Does Perl have a \fIround()\fR function? What about \fIceil()\fR and \fIfloor()\fR? Trig functions?
.IP "\(bu" 4
How do I convert between numeric representations/bases/radixes?
.IP "\(bu" 4
Why doesn't & work the way I want it to?
.IP "\(bu" 4
How do I multiply matrices?
.IP "\(bu" 4
How do I perform an operation on a series of integers?
.IP "\(bu" 4
How can I output Roman numerals?
.IP "\(bu" 4
Why aren't my random numbers random?
.IP "\(bu" 4
How do I get a random number between X and Y?
.IP "\(bu" 4
How do I find the day or week of the year?
.IP "\(bu" 4
How do I find the current century or millennium?
.IP "\(bu" 4
How can I compare two dates and find the difference?
.IP "\(bu" 4
How can I take a string and turn it into epoch seconds?
.IP "\(bu" 4
How can I find the Julian Day?
.IP "\(bu" 4
How do I find yesterday's date?
.IP "\(bu" 4
Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?
.IP "\(bu" 4
How do I validate input?
.IP "\(bu" 4
How do I unescape a string?
.IP "\(bu" 4
How do I remove consecutive pairs of characters?
.IP "\(bu" 4
How do I expand function calls in a string?
.IP "\(bu" 4
How do I find matching/nesting anything?
.IP "\(bu" 4
How do I reverse a string?
.IP "\(bu" 4
How do I expand tabs in a string?
.IP "\(bu" 4
How do I reformat a paragraph?
.IP "\(bu" 4
How can I access or change N characters of a string?
.IP "\(bu" 4
How do I change the Nth occurrence of something?
.IP "\(bu" 4
How can I count the number of occurrences of a substring within a string?
.IP "\(bu" 4
How do I capitalize all the words on one line?
.IP "\(bu" 4
How can I split a [character]\-delimited string except when inside [character]?
.IP "\(bu" 4
How do I strip blank space from the beginning/end of a string?
.IP "\(bu" 4
How do I pad a string with blanks or pad a number with zeroes?
.IP "\(bu" 4
How do I extract selected columns from a string?
.IP "\(bu" 4
How do I find the soundex value of a string?
.IP "\(bu" 4
How can I expand variables in text strings?
.IP "\(bu" 4
What's wrong with always quoting \*(L"$vars\*(R"?
.IP "\(bu" 4
Why don't my <<\s-1HERE\s0 documents work?
.IP "\(bu" 4
What is the difference between a list and an array?
.IP "\(bu" 4
What is the difference between \f(CW$array\fR[1] and \f(CW@array\fR[1]?
.IP "\(bu" 4
How can I remove duplicate elements from a list or array?
.IP "\(bu" 4
How can I tell whether a certain element is contained in a list or array?
.IP "\(bu" 4
How do I compute the difference of two arrays? How do I compute the intersection of two arrays?
.IP "\(bu" 4
How do I test whether two arrays or hashes are equal?
.IP "\(bu" 4
How do I find the first array element for which a condition is true?
.IP "\(bu" 4
How do I handle linked lists?
.IP "\(bu" 4
How do I handle circular lists?
.IP "\(bu" 4
How do I shuffle an array randomly?
.IP "\(bu" 4
How do I process/modify each element of an array?
.IP "\(bu" 4
How do I select a random element from an array?
.IP "\(bu" 4
How do I permute N elements of a list?
.IP "\(bu" 4
How do I sort an array by (anything)?
.IP "\(bu" 4
How do I manipulate arrays of bits?
.IP "\(bu" 4
Why does \fIdefined()\fR return true on empty arrays and hashes?
.IP "\(bu" 4
How do I process an entire hash?
.IP "\(bu" 4
How do I merge two hashes?
.IP "\(bu" 4
What happens if I add or remove keys from a hash while iterating over it?
.IP "\(bu" 4
How do I look up a hash element by value?
.IP "\(bu" 4
How can I know how many entries are in a hash?
.IP "\(bu" 4
How do I sort a hash (optionally by value instead of key)?
.IP "\(bu" 4
How can I always keep my hash sorted?
.IP "\(bu" 4
What's the difference between \*(L"delete\*(R" and \*(L"undef\*(R" with hashes?
.IP "\(bu" 4
Why don't my tied hashes make the defined/exists distinction?
.IP "\(bu" 4
How do I reset an \fIeach()\fR operation part-way through?
.IP "\(bu" 4
How can I get the unique keys from two hashes?
.IP "\(bu" 4
How can I store a multidimensional array in a \s-1DBM\s0 file?
.IP "\(bu" 4
How can I make my hash remember the order I put elements into it?
.IP "\(bu" 4
Why does passing a subroutine an undefined element in a hash create it?
.IP "\(bu" 4
How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?
.IP "\(bu" 4
How can I use a reference as a hash key?
.IP "\(bu" 4
How can I check if a key exists in a multilevel hash?
.IP "\(bu" 4
How can I prevent addition of unwanted keys into a hash?
.IP "\(bu" 4
How do I handle binary data correctly?
.IP "\(bu" 4
How do I determine whether a scalar is a number/whole/integer/float?
.IP "\(bu" 4
How do I keep persistent data across program calls?
.IP "\(bu" 4
How do I print out or copy a recursive data structure?
.IP "\(bu" 4
How do I define methods for every class/object?
.IP "\(bu" 4
How do I verify a credit card checksum?
.IP "\(bu" 4
How do I pack arrays of doubles or floats for \s-1XS\s0 code?
.SS "perlfaq5: Files and Formats"
.IX Subsection "perlfaq5: Files and Formats"
This section deals with I/O and the \*(L"f\*(R" issues: filehandles, flushing, formats, and footers.
.IP "\(bu" 4
How do I flush/unbuffer an output filehandle? Why must I do this?
.IP "\(bu" 4
How do I change, delete, or insert a line in a file, or append to the beginning of a file?
.IP "\(bu" 4
How do I count the number of lines in a file?
.IP "\(bu" 4
How do I delete the last N lines from a file?
.IP "\(bu" 4
How can I use Perl's \f(CW\*(C`\-i\*(C'\fR option from within a program?
.IP "\(bu" 4
How can I copy a file?
.IP "\(bu" 4
How do I make a temporary file name?
.IP "\(bu" 4
How can I manipulate fixed-record-length files?
.IP "\(bu" 4
How can I make a filehandle local to a subroutine? How do I pass filehandles between subroutines? How do I make an array of filehandles?
.IP "\(bu" 4
How can I use a filehandle indirectly?
.IP "\(bu" 4
How can I set up a footer format to be used with \fIwrite()\fR?
.IP "\(bu" 4
How can I \fIwrite()\fR into a string?
.IP "\(bu" 4
How can I open a filehandle to a string?
.IP "\(bu" 4
How can I output my numbers with commas added?
.IP "\(bu" 4
How can I translate tildes (~) in a filename?
.IP "\(bu" 4
How come when I open a file read-write it wipes it out?
.IP "\(bu" 4
Why do I sometimes get an \*(L"Argument list too long\*(R" when I use <*>?
.IP "\(bu" 4
How can I open a file with a leading \*(L">\*(R" or trailing blanks?
.IP "\(bu" 4
How can I reliably rename a file?
.IP "\(bu" 4
How can I lock a file?
.IP "\(bu" 4
Why can't I just open(\s-1FH, \*(L"\s0>file.lock\*(R")?
.IP "\(bu" 4
I still don't get locking. I just want to increment the number in the file. How can I do this?
.IP "\(bu" 4
All I want to do is append a small amount of text to the end of a file. Do I still have to use locking?
.IP "\(bu" 4
How do I randomly update a binary file?
.IP "\(bu" 4
How do I get a file's timestamp in perl?
.IP "\(bu" 4
How do I set a file's timestamp in perl?
.IP "\(bu" 4
How do I print to more than one file at once?
.IP "\(bu" 4
How can I read in an entire file all at once?
.IP "\(bu" 4
How can I read in a file by paragraphs?
.IP "\(bu" 4
How can I read a single character from a file? From the keyboard?
.IP "\(bu" 4
How can I tell whether there's a character waiting on a filehandle?
.IP "\(bu" 4
How do I do a \f(CW\*(C`tail \-f\*(C'\fR in perl?
.IP "\(bu" 4
How do I \fIdup()\fR a filehandle in Perl?
.IP "\(bu" 4
How do I close a file descriptor by number?
.IP "\(bu" 4
Why can't I use \*(L"C:\etemp\efoo\*(R" in \s-1DOS\s0 paths? Why doesn't `C:\etemp\efoo.exe` work?
.IP "\(bu" 4
Why doesn't glob(\*(L"*.*\*(R") get all the files?
.IP "\(bu" 4
Why does Perl let me delete read-only files? Why does \f(CW\*(C`\-i\*(C'\fR clobber protected files? Isn't this a bug in Perl?
.IP "\(bu" 4
How do I select a random line from a file?
.IP "\(bu" 4
Why do I get weird spaces when I print an array of lines?
.IP "\(bu" 4
How do I traverse a directory tree?
.IP "\(bu" 4
How do I delete a directory tree?
.IP "\(bu" 4
How do I copy an entire directory?
.SS "perlfaq6: Regular Expressions"
.IX Subsection "perlfaq6: Regular Expressions"
This section is surprisingly small because the rest of the \s-1FAQ\s0 is littered with answers involving regular expressions. For example, decoding a \s-1URL\s0 and checking whether something is a number can be handled with regular expressions, but those answers are found elsewhere in this document (in perlfaq9 : \*(L"How do I decode or create those %\-encodings on the web\*(R" and perlfaq4 : \*(L"How do I determine whether a scalar is a number/whole/integer/float\*(R", to be precise).
.IP "\(bu" 4
How can I hope to use regular expressions without creating illegible and unmaintainable code?
.IP "\(bu" 4
I'm having trouble matching over more than one line. What's wrong?
.IP "\(bu" 4
How can I pull out lines between two patterns that are themselves on different lines?
.IP "\(bu" 4
How do I match \s-1XML, HTML,\s0 or other nasty, ugly things with a regex?
.IP "\(bu" 4
I put a regular expression into $/ but it didn't work. What's wrong?
.IP "\(bu" 4
How do I substitute case-insensitively on the \s-1LHS\s0 while preserving case on the \s-1RHS\s0?
.IP "\(bu" 4
How can I make \f(CW\*(C`\ew\*(C'\fR match national character sets?
.IP "\(bu" 4
How can I match a locale-smart version of \f(CW\*(C`/[a\-zA\-Z]/\*(C'\fR ?
.IP "\(bu" 4
How can I quote a variable to use in a regex?
.IP "\(bu" 4
What is \f(CW\*(C`/o\*(C'\fR really for?
.IP "\(bu" 4
How do I use a regular expression to strip C\-style comments from a file?
.IP "\(bu" 4
Can I use Perl regular expressions to match balanced text?
.IP "\(bu" 4
What does it mean that regexes are greedy? How can I get around it?
.IP "\(bu" 4
How do I process each word on each line?
.IP "\(bu" 4
How can I print out a word-frequency or line-frequency summary?
.IP "\(bu" 4
How can I do approximate matching?
.IP "\(bu" 4
How do I efficiently match many regular expressions at once?
.IP "\(bu" 4
Why don't word-boundary searches with \f(CW\*(C`\eb\*(C'\fR work for me?
.IP "\(bu" 4
Why does using $&, $`, or $' slow my program down?
.IP "\(bu" 4
What good is \f(CW\*(C`\eG\*(C'\fR in a regular expression?
.IP "\(bu" 4
Are Perl regexes DFAs or NFAs? Are they \s-1POSIX\s0 compliant?
.IP "\(bu" 4
What's wrong with using grep in a void context?
.IP "\(bu" 4
How can I match strings with multibyte characters?
.IP "\(bu" 4
How do I match a regular expression that's in a variable?
.SS "perlfaq7: General Perl Language Issues"
.IX Subsection "perlfaq7: General Perl Language Issues"
This section deals with general Perl language issues that don't clearly fit into any of the other sections.
.IP "\(bu" 4
Can I get a BNF/yacc/RE for the Perl language?
.IP "\(bu" 4
What are all these $@%&* punctuation signs, and how do I know when to use them?
.IP "\(bu" 4
Do I always/never have to quote my strings or use semicolons and commas?
.IP "\(bu" 4
How do I skip some return values?
.IP "\(bu" 4
How do I temporarily block warnings?
.IP "\(bu" 4
What's an extension?
.IP "\(bu" 4
Why do Perl operators have different precedence than C operators?
.IP "\(bu" 4
How do I declare/create a structure?
.IP "\(bu" 4
How do I create a module?
.IP "\(bu" 4
How do I adopt or take over a module already on \s-1CPAN\s0?
.IP "\(bu" 4
How do I create a class?
.IP "\(bu" 4
How can I tell if a variable is tainted?
.IP "\(bu" 4
What's a closure?
.IP "\(bu" 4
What is variable suicide and how can I prevent it?
.IP "\(bu" 4
How can I pass/return a {Function, FileHandle, Array, Hash, Method, Regex}?
.IP "\(bu" 4
How do I create a static variable?
.IP "\(bu" 4
What's the difference between dynamic and lexical (static) scoping? Between \fIlocal()\fR and \fImy()\fR?
.IP "\(bu" 4
How can I access a dynamic variable while a similarly named lexical is in scope?
.IP "\(bu" 4
What's the difference between deep and shallow binding?
.IP "\(bu" 4
Why doesn't \*(L"my($foo) = <$fh>;\*(R" work right?
.IP "\(bu" 4
How do I redefine a builtin function, operator, or method?
.IP "\(bu" 4
What's the difference between calling a function as &foo and \fIfoo()\fR?
.IP "\(bu" 4
How do I create a switch or case statement?
.IP "\(bu" 4
How can I catch accesses to undefined variables, functions, or methods?
.IP "\(bu" 4
Why can't a method included in this same file be found?
.IP "\(bu" 4
How can I find out my current or calling package?
.IP "\(bu" 4
How can I comment out a large block of Perl code?
.IP "\(bu" 4
How do I clear a package?
.IP "\(bu" 4
How can I use a variable as a variable name?
.IP "\(bu" 4
What does \*(L"bad interpreter\*(R" mean?
.SS "perlfaq8: System Interaction"
.IX Subsection "perlfaq8: System Interaction"
This section of the Perl \s-1FAQ\s0 covers questions involving operating system interaction. Topics include interprocess communication (\s-1IPC\s0), control over the user-interface (keyboard, screen and pointing devices), and most anything else not related to data manipulation.
.IP "\(bu" 4
How do I find out which operating system I'm running under?
.IP "\(bu" 4
How come \fIexec()\fR doesn't return?
.IP "\(bu" 4
How do I do fancy stuff with the keyboard/screen/mouse?
.IP "\(bu" 4
How do I print something out in color?
.IP "\(bu" 4
How do I read just one key without waiting for a return key?
.IP "\(bu" 4
How do I check whether input is ready on the keyboard?
.IP "\(bu" 4
How do I clear the screen?
.IP "\(bu" 4
How do I get the screen size?
.IP "\(bu" 4
How do I ask the user for a password?
.IP "\(bu" 4
How do I read and write the serial port?
.IP "\(bu" 4
How do I decode encrypted password files?
.IP "\(bu" 4
How do I start a process in the background?
.IP "\(bu" 4
How do I trap control characters/signals?
.IP "\(bu" 4
How do I modify the shadow password file on a Unix system?
.IP "\(bu" 4
How do I set the time and date?
.IP "\(bu" 4
How can I \fIsleep()\fR or \fIalarm()\fR for under a second?
.IP "\(bu" 4
How can I measure time under a second?
.IP "\(bu" 4
How can I do an \fIatexit()\fR or \fIsetjmp()\fR/\fIlongjmp()\fR? (Exception handling)
.IP "\(bu" 4
Why doesn't my sockets program work under System V (Solaris)? What does the error message \*(L"Protocol not supported\*(R" mean?
.IP "\(bu" 4
How can I call my system's unique C functions from Perl?
.IP "\(bu" 4
Where do I get the include files to do \fIioctl()\fR or \fIsyscall()\fR?
.IP "\(bu" 4
Why do setuid perl scripts complain about kernel problems?
.IP "\(bu" 4
How can I open a pipe both to and from a command?
.IP "\(bu" 4
Why can't I get the output of a command with \fIsystem()\fR?
.IP "\(bu" 4
How can I capture \s-1STDERR\s0 from an external command?
.IP "\(bu" 4
Why doesn't \fIopen()\fR return an error when a pipe open fails?
.IP "\(bu" 4
What's wrong with using backticks in a void context?
.IP "\(bu" 4
How can I call backticks without shell processing?
.IP "\(bu" 4
Why can't my script read from \s-1STDIN\s0 after I gave it \s-1EOF \s0(^D on Unix, ^Z on MS-DOS)?
.IP "\(bu" 4
How can I convert my shell script to perl?
.IP "\(bu" 4
Can I use perl to run a telnet or ftp session?
.IP "\(bu" 4
How can I write expect in Perl?
.IP "\(bu" 4
Is there a way to hide perl's command line from programs such as \*(L"ps\*(R"?
.IP "\(bu" 4
I {changed directory, modified my environment} in a perl script. How come the change disappeared when I exited the script? How do I get my changes to be visible?
.IP "\(bu" 4
How do I close a process's filehandle without waiting for it to complete?
.IP "\(bu" 4
How do I fork a daemon process?
.IP "\(bu" 4
How do I find out if I'm running interactively or not?
.IP "\(bu" 4
How do I timeout a slow event?
.IP "\(bu" 4
How do I set \s-1CPU\s0 limits?
.IP "\(bu" 4
How do I avoid zombies on a Unix system?
.IP "\(bu" 4
How do I use an \s-1SQL\s0 database?
.IP "\(bu" 4
How do I make a \fIsystem()\fR exit on control-C?
.IP "\(bu" 4
How do I open a file without blocking?
.IP "\(bu" 4
How do I tell the difference between errors from the shell and perl?
.IP "\(bu" 4
How do I install a module from \s-1CPAN\s0?
.IP "\(bu" 4
What's the difference between require and use?
.IP "\(bu" 4
How do I keep my own module/library directory?
.IP "\(bu" 4
How do I add the directory my program lives in to the module/library search path?
.IP "\(bu" 4
How do I add a directory to my include path (@INC) at runtime?
.IP "\(bu" 4
What is socket.ph and where do I get it?
.SS "perlfaq9: Web, Email and Networking"
.IX Subsection "perlfaq9: Web, Email and Networking"
This section deals with questions related to running web sites, sending and receiving email as well as general networking.
.IP "\(bu" 4
Should I use a web framework?
.IP "\(bu" 4
Which web framework should I use?
.IP "\(bu" 4
What is Plack and \s-1PSGI\s0?
.IP "\(bu" 4
How do I remove \s-1HTML\s0 from a string?
.IP "\(bu" 4
How do I extract URLs?
.IP "\(bu" 4
How do I fetch an \s-1HTML\s0 file?
.IP "\(bu" 4
How do I automate an \s-1HTML\s0 form submission?
.IP "\(bu" 4
How do I decode or create those %\-encodings on the web?
.IP "\(bu" 4
How do I redirect to another page?
.IP "\(bu" 4
How do I put a password on my web pages?
.IP "\(bu" 4
How do I make sure users can't enter values into a form that causes my \s-1CGI\s0 script to do bad things?
.IP "\(bu" 4
How do I parse a mail header?
.IP "\(bu" 4
How do I check a valid mail address?
.IP "\(bu" 4
How do I decode a \s-1MIME/BASE64\s0 string?
.IP "\(bu" 4
How do I find the user's mail address?
.IP "\(bu" 4
How do I send email?
.IP "\(bu" 4
How do I use \s-1MIME\s0 to make an attachment to a mail message?
.IP "\(bu" 4
How do I read email?
.IP "\(bu" 4
How do I find out my hostname, domainname, or \s-1IP\s0 address?
.IP "\(bu" 4
How do I fetch/put an (S)FTP file?
.IP "\(bu" 4
How can I do \s-1RPC\s0 in Perl?
.SH "CREDITS"
.IX Header "CREDITS"
Tom Christiansen wrote the original perlfaq then expanded it with the
help of Nat Torkington. brian d foy substantialy edited and expanded
the perlfaq. perlfaq-workers and others have also supplied feedback,
patches and corrections over the years.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Tom Christiansen wrote the original version of this document.
brian d foy \f(CW\*(C`<bdfoy@cpan.org>\*(C'\fR wrote this version. See the
individual perlfaq documents for additional copyright information.
.PP
This document is available under the same terms as Perl itself. Code
examples in all the perlfaq documents are in the public domain. Use
them as you see fit (and at your own risk with no warranty from anyone).
 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq1.1                                   0100644 0001750 0001750 00000045014 12566207436 022462  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ1 1"
.TH PERLFAQ1 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq1 \- General Questions About Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers very general, high-level questions
about Perl.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a high-level programming language with an eclectic heritage
written by Larry Wall and a cast of thousands.
.PP
Perl's process, file, and text manipulation facilities make it
particularly well-suited for tasks involving quick prototyping, system
utilities, software tools, system management tasks, database access,
graphical programming, networking, and web programming.
.PP
Perl derives from the ubiquitous C programming language and to a
lesser extent from sed, awk, the Unix shell, and many other tools
and languages.
.PP
These strengths make it especially popular with web developers
and system administrators. Mathematicians, geneticists, journalists,
managers and many other people also use Perl.
.SS "Who supports Perl? Who develops it? Why is it free?"
.IX Subsection "Who supports Perl? Who develops it? Why is it free?"
The original culture of the pre-populist Internet and the deeply-held
beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of Perl. Perl is supported by its users. The
core, the standard Perl library, the optional modules, and the
documentation you're reading now were all written by volunteers.
.PP
The core development team (known as the Perl Porters)
are a group of highly altruistic individuals committed to
producing better software for free than you could hope to purchase for
money. You may snoop on pending developments via the
archives <http://www.nntp.perl.org/group/perl.perl5.porters/>
or read the faq <http://dev.perl.org/perl5/docs/p5p-faq.html>,
or you can subscribe to the mailing list by sending
perl5\-porters\-subscribe@perl.org a subscription request
(an empty message with no subject is fine).
.PP
While the \s-1GNU\s0 project includes Perl in its distributions, there's no
such thing as \*(L"\s-1GNU\s0 Perl\*(R". Perl is not produced nor maintained by the
Free Software Foundation. Perl's licensing terms are also more open
than \s-1GNU\s0 software's tend to be.
.PP
You can get commercial support of Perl if you wish, although for most
users the informal support will more than suffice. See the answer to
\&\*(L"Where can I buy a commercial version of Perl?\*(R" for more information.
.SS "Which version of Perl should I use?"
.IX Subsection "Which version of Perl should I use?"
(contributed by brian d foy)
.PP
There is often a matter of opinion and taste, and there isn't any one
answer that fits everyone. In general, you want to use either the current
stable release, or the stable release immediately prior to that one.
Currently, those are perl5.14.x and perl5.12.x, respectively.
.PP
Beyond that, you have to consider several things and decide which is best
for you.
.IP "\(bu" 4
If things aren't broken, upgrading perl may break them (or at least issue
new warnings).
.IP "\(bu" 4
The latest versions of perl have more bug fixes.
.IP "\(bu" 4
The Perl community is geared toward supporting the most recent releases,
so you'll have an easier time finding help for those.
.IP "\(bu" 4
Versions prior to perl5.004 had serious security problems with buffer
overflows, and in some cases have \s-1CERT\s0 advisories (for instance,
<http://www.cert.org/advisories/CA\-1997\-17.html> ).
.IP "\(bu" 4
The latest versions are probably the least deployed and widely tested, so
you may want to wait a few months after their release and see what
problems others have if you are risk averse.
.IP "\(bu" 4
The immediate, previous releases (i.e. perl5.8.x ) are usually maintained
for a while, although not at the same level as the current releases.
.IP "\(bu" 4
No one is actively supporting Perl 4. Ten years ago it was a dead
camel carcass (according to this document). Now it's barely a skeleton
as its whitewashed bones have fractured or eroded.
.IP "\(bu" 4
The current leading implementation of Perl 6, Rakudo, released a \*(L"useful,
usable, 'early adopter'\*(R" distribution of Perl 6 (called Rakudo Star) in July of
2010. Please see <http://rakudo.org/> for more information.
.IP "\(bu" 4
There are really two tracks of perl development: a maintenance version
and an experimental version. The maintenance versions are stable, and
have an even number as the minor release (i.e. perl5.10.x, where 10 is the
minor release). The experimental versions may include features that
don't make it into the stable versions, and have an odd number as the
minor release (i.e. perl5.9.x, where 9 is the minor release).
.SS "What are Perl 4, Perl 5, or Perl 6?"
.IX Subsection "What are Perl 4, Perl 5, or Perl 6?"
In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older
sibling, and though they are different languages, someone who knows one will
spot many similarities in the other.
.PP
The number after Perl (i.e. the 5 after Perl 5) is the major release
of the perl interpreter as well as the version of the language. Each
major version has significant differences that earlier versions cannot
support.
.PP
The current major release of Perl is Perl 5, first released in
1994. It can run scripts from the previous major release, Perl 4
(March 1991), but has significant differences.
.PP
Perl 6 is a reinvention of Perl, it is a language in the same lineage but
not compatible. The two are complementary, not mutually exclusive. Perl 6 is
not meant to replace Perl 5, and vice versa. See \*(L"What is Perl 6?\*(R" below
to find out more.
.PP
See perlhist for a history of Perl revisions.
.SS "What is Perl 6?"
.IX Subsection "What is Perl 6?"
Perl 6 was \fIoriginally\fR described as the community's rewrite of Perl 5.
Development started in 2002; syntax and design work continue to this day.
As the language has evolved, it has become clear that it is a separate
language, incompatible with Perl 5 but in the same language family.
.PP
Contrary to popular belief, Perl 6 and Perl 5 peacefully coexist with one
another. Perl 6 has proven to be a fascinating source of ideas for those
using Perl 5 (the Moose object system is a well-known example). There is
overlap in the communities, and this overlap fosters the tradition of sharing
and borrowing that have been instrumental to Perl's success. The current
leading implementation of Perl 6 is Rakudo, and you can learn more about
it at <http://rakudo.org>.
.PP
If you want to learn more about Perl 6, or have a desire to help in
the crusade to make Perl a better place then read the Perl 6 developers
page at <http://www.perl6.org/> and get involved.
.PP
\&\*(L"We're really serious about reinventing everything that needs reinventing.\*(R"
\&\-\-Larry Wall
.SS "How stable is Perl?"
.IX Subsection "How stable is Perl?"
Production releases, which incorporate bug fixes and new functionality,
are widely tested before release. Since the 5.000 release, we have
averaged about one production release per year.
.PP
The Perl development team occasionally make changes to the
internal core of the language, but all possible efforts are made toward
backward compatibility.
.SS "Is Perl difficult to learn?"
.IX Subsection "Is Perl difficult to learn?"
No, Perl is easy to start learning <http://learn.perl.org/> \-\-and easy to keep learning. It looks
like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a \s-1BASIC\s0 program, you're already partway there.
.PP
Most tasks only require a small subset of the Perl language. One of
the guiding mottos for Perl development is \*(L"there's more than one way
to do it\*(R" (\s-1TMTOWTDI,\s0 sometimes pronounced \*(L"tim toady\*(R"). Perl's
learning curve is therefore shallow (easy to learn) and long (there's
a whole lot you can do if you really want).
.PP
Finally, because Perl is frequently (but not always, and certainly not by
definition) an interpreted language, you can write your programs and test
them without an intermediate compilation step, allowing you to experiment
and test/debug quickly and easily. This ease of experimentation flattens
the learning curve even more.
.PP
Things that make Perl easier to learn: Unix experience, almost any kind
of programming experience, an understanding of regular expressions, and
the ability to understand other people's code. If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free. Don't forget Perl modules, either.
They're discussed in Part 3 of this \s-1FAQ,\s0 along with \s-1CPAN\s0 <http://www.cpan.org/>, which is
discussed in Part 2.
.SS "How does Perl compare with other languages like Java, Python, \s-1REXX,\s0 Scheme, or Tcl?"
.IX Subsection "How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?"
Perl can be used for almost any coding problem, even ones which require
integrating specialist C code for extra speed. As with any tool it can
be used well or badly. Perl has many strengths, and a few weaknesses,
precisely which areas are good and bad is often a personal choice.
.PP
When choosing a language you should also be influenced by the
resources <http://www.cpan.org/>, testing culture <http://www.cpantesters.org/>
and community <http://www.perl.org/community.html> which surrounds it.
.PP
For comparisons to a specific language it is often best to create
a small project in both languages and compare the results, make sure
to use all the resources <http://www.cpan.org/> of each language,
as a language is far more than just it's syntax.
.SS "Can I do [task] in Perl?"
.IX Subsection "Can I do [task] in Perl?"
Perl is flexible and extensible enough for you to use on virtually any
task, from one-line file-processing tasks to large, elaborate systems.
.PP
For many people, Perl serves as a great replacement for shell scripting.
For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or \*(C+. It's ultimately
up to you (and possibly your management) which tasks you'll use Perl
for and which you won't.
.PP
If you have a library that provides an \s-1API,\s0 you can make any component
of it available as just another Perl function or variable using a Perl
extension written in C or \*(C+ and dynamically linked into your main
perl interpreter. You can also go the other direction, and write your
main program in C or \*(C+, and then link in some Perl code on the fly,
to create a powerful application. See perlembed.
.PP
That said, there will always be small, focused, special-purpose
languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems. Perl tries to be all things
to all people, but nothing special to anyone. Examples of specialized
languages that come to mind include prolog and matlab.
.SS "When shouldn't I program in Perl?"
.IX Subsection "When shouldn't I program in Perl?"
One good reason is when you already have an existing
application written in another language that's all done (and done
well), or you have an application language specifically designed for a
certain task (e.g. prolog, make).
.PP
If you find that you need to speed up a specific part of a Perl
application (not something you often need) you may want to use C,
but you can access this from your Perl code with perlxs.
.ie n .SS "What's the difference between ""perl"" and ""Perl""?"
.el .SS "What's the difference between ``perl'' and ``Perl''?"
.IX Subsection "What's the difference between perl and Perl?"
\&\*(L"Perl\*(R" is the name of the language. Only the \*(L"P\*(R" is capitalized.
The name of the interpreter (the program which runs the Perl script)
is \*(L"perl\*(R" with a lowercase \*(L"p\*(R".
.PP
You may or may not choose to follow this usage. But never write \*(L"\s-1PERL\*(R",\s0
because perl is not an acronym.
.SS "What is a \s-1JAPH\s0?"
.IX Subsection "What is a JAPH?"
(contributed by brian d foy)
.PP
\&\s-1JAPH\s0 stands for \*(L"Just another Perl hacker,\*(R", which Randal Schwartz used
to sign email and usenet messages starting in the late 1980s. He
previously used the phrase with many subjects (\*(L"Just another x hacker,\*(R"),
so to distinguish his \s-1JAPH,\s0 he started to write them as Perl programs:
.PP
.Vb 1
\&    print "Just another Perl hacker,";
.Ve
.PP
Other people picked up on this and started to write clever or obfuscated
programs to produce the same output, spinning things quickly out of
control while still providing hours of amusement for their creators and
readers.
.PP
\&\s-1CPAN\s0 has several \s-1JAPH\s0 programs at <http://www.cpan.org/misc/japh>.
.SS "How can I convince others to use Perl?"
.IX Subsection "How can I convince others to use Perl?"
(contributed by brian d foy)
.PP
Appeal to their self interest! If Perl is new (and thus scary) to them,
find something that Perl can do to solve one of their problems. That
might mean that Perl either saves them something (time, headaches, money)
or gives them something (flexibility, power, testability).
.PP
In general, the benefit of a language is closely related to the skill of
the people using that language. If you or your team can be faster,
better, and stronger through Perl, you'll deliver more value. Remember,
people often respond better to what they get out of it. If you run
into resistance, figure out what those people get out of the other
choice and how Perl might satisfy that requirement.
.PP
You don't have to worry about finding or paying for Perl; it's freely
available and several popular operating systems come with Perl. Community
support in places such as Perlmonks ( <http://www.perlmonks.com> )
and the various Perl mailing lists ( <http://lists.perl.org> ) means that
you can usually get quick answers to your problems.
.PP
Finally, keep in mind that Perl might not be the right tool for every
job. You're a much better advocate if your claims are reasonable and
grounded in reality. Dogmatically advocating anything tends to make
people discount your message. Be honest about possible disadvantages
to your choice of Perl since any choice has trade-offs.
.PP
You might find these links useful:
.IP "\(bu" 4
<http://www.perl.org/about.html>
.IP "\(bu" 4
<http://perltraining.com.au/whyperl.html>
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq15.16.1                               0100644 0001750 0001750 00000044552 12566207416 023000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ1 1"
.TH PERLFAQ1 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq1 \- General Questions About Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers very general, high-level questions
about Perl.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a high-level programming language with an eclectic heritage
written by Larry Wall and a cast of thousands.
.PP
Perl's process, file, and text manipulation facilities make it
particularly well-suited for tasks involving quick prototyping, system
utilities, software tools, system management tasks, database access,
graphical programming, networking, and web programming.
.PP
Perl derives from the ubiquitous C programming language and to a
lesser extent from sed, awk, the Unix shell, and many other tools
and languages.
.PP
These strengths make it especially popular with web developers
and system administrators. Mathematicians, geneticists, journalists,
managers and many other people also use Perl.
.SS "Who supports Perl? Who develops it? Why is it free?"
.IX Subsection "Who supports Perl? Who develops it? Why is it free?"
The original culture of the pre-populist Internet and the deeply-held
beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of Perl. Perl is supported by its users. The
core, the standard Perl library, the optional modules, and the
documentation you're reading now were all written by volunteers.
.PP
The core development team (known as the Perl Porters)
are a group of highly altruistic individuals committed to
producing better software for free than you could hope to purchase for
money. You may snoop on pending developments via the
archives <http://www.nntp.perl.org/group/perl.perl5.porters/>
or read the faq <http://dev.perl.org/perl5/docs/p5p-faq.html>,
or you can subscribe to the mailing list by sending
perl5\-porters\-subscribe@perl.org a subscription request
(an empty message with no subject is fine).
.PP
While the \s-1GNU\s0 project includes Perl in its distributions, there's no
such thing as \*(L"\s-1GNU\s0 Perl\*(R". Perl is not produced nor maintained by the
Free Software Foundation. Perl's licensing terms are also more open
than \s-1GNU\s0 software's tend to be.
.PP
You can get commercial support of Perl if you wish, although for most
users the informal support will more than suffice. See the answer to
\&\*(L"Where can I buy a commercial version of Perl?\*(R" for more information.
.SS "Which version of Perl should I use?"
.IX Subsection "Which version of Perl should I use?"
(contributed by brian d foy)
.PP
There is often a matter of opinion and taste, and there isn't any one
answer that fits everyone. In general, you want to use either the current
stable release, or the stable release immediately prior to that one.
Currently, those are perl5.14.x and perl5.12.x, respectively.
.PP
Beyond that, you have to consider several things and decide which is best
for you.
.IP "\(bu" 4
If things aren't broken, upgrading perl may break them (or at least issue
new warnings).
.IP "\(bu" 4
The latest versions of perl have more bug fixes.
.IP "\(bu" 4
The Perl community is geared toward supporting the most recent releases,
so you'll have an easier time finding help for those.
.IP "\(bu" 4
Versions prior to perl5.004 had serious security problems with buffer
overflows, and in some cases have \s-1CERT\s0 advisories (for instance,
http://www.cert.org/advisories/CA\-1997\-17.html <http://www.cert.org/advisories/CA-1997-17.html> ).
.IP "\(bu" 4
The latest versions are probably the least deployed and widely tested, so
you may want to wait a few months after their release and see what
problems others have if you are risk averse.
.IP "\(bu" 4
The immediate, previous releases (i.e. perl5.8.x ) are usually maintained
for a while, although not at the same level as the current releases.
.IP "\(bu" 4
No one is actively supporting Perl 4. Ten years ago it was a dead
camel carcass (according to this document). Now it's barely a skeleton
as its whitewashed bones have fractured or eroded.
.IP "\(bu" 4
The current leading implementation of Perl 6, Rakudo, released a \*(L"useful,
usable, 'early adopter'\*(R" distribution of Perl 6 (called Rakudo Star) in July of
2010. Please see <http://rakudo.org/> for more information.
.IP "\(bu" 4
There are really two tracks of perl development: a maintenance version
and an experimental version. The maintenance versions are stable, and
have an even number as the minor release (i.e. perl5.10.x, where 10 is the
minor release). The experimental versions may include features that
don't make it into the stable versions, and have an odd number as the
minor release (i.e. perl5.9.x, where 9 is the minor release).
.SS "What are Perl 4, Perl 5, or Perl 6?"
.IX Subsection "What are Perl 4, Perl 5, or Perl 6?"
In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older
sibling, and though they are different languages, someone who knows one will
spot many similarities in the other.
.PP
The number after Perl (i.e. the 5 after Perl 5) is the major release
of the perl interpreter as well as the version of the language. Each
major version has significant differences that earlier versions cannot
support.
.PP
The current major release of Perl is Perl 5, first released in
1994. It can run scripts from the previous major release, Perl 4
(March 1991), but has significant differences.
.PP
Perl 6 is a reinvention of Perl, it is a language in the same lineage but
not compatible. The two are complementary, not mutually exclusive. Perl 6 is
not meant to replace Perl 5, and vice versa. See \*(L"What is Perl 6?\*(R" below
to find out more.
.PP
See perlhist for a history of Perl revisions.
.SS "What is Perl 6?"
.IX Subsection "What is Perl 6?"
Perl 6 was \fIoriginally\fR described as the community's rewrite of Perl 5.
Development started in 2002; syntax and design work continue to this day.
As the language has evolved, it has become clear that it is a separate
language, incompatible with Perl 5 but in the same language family.
.PP
Contrary to popular belief, Perl 6 and Perl 5 peacefully coexist with one
another. Perl 6 has proven to be a fascinating source of ideas for those
using Perl 5 (the Moose object system is a well-known example). There is
overlap in the communities, and this overlap fosters the tradition of sharing
and borrowing that have been instrumental to Perl's success. The current
leading implementation of Perl 6 is Rakudo, and you can learn more about
it at <http://rakudo.org>.
.PP
If you want to learn more about Perl 6, or have a desire to help in
the crusade to make Perl a better place then read the Perl 6 developers
page at <http://www.perl6.org/> and get involved.
.PP
\&\*(L"We're really serious about reinventing everything that needs reinventing.\*(R"
\&\-\-Larry Wall
.SS "How stable is Perl?"
.IX Subsection "How stable is Perl?"
Production releases, which incorporate bug fixes and new functionality,
are widely tested before release. Since the 5.000 release, we have
averaged about one production release per year.
.PP
The Perl development team occasionally make changes to the
internal core of the language, but all possible efforts are made toward
backward compatibility.
.SS "Is Perl difficult to learn?"
.IX Subsection "Is Perl difficult to learn?"
No, Perl is easy to start learning <http://learn.perl.org/> \-\-and easy to keep learning. It looks
like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a \s-1BASIC\s0 program, you're already partway there.
.PP
Most tasks only require a small subset of the Perl language. One of
the guiding mottos for Perl development is \*(L"there's more than one way
to do it\*(R" (\s-1TMTOWTDI\s0, sometimes pronounced \*(L"tim toady\*(R"). Perl's
learning curve is therefore shallow (easy to learn) and long (there's
a whole lot you can do if you really want).
.PP
Finally, because Perl is frequently (but not always, and certainly not by
definition) an interpreted language, you can write your programs and test
them without an intermediate compilation step, allowing you to experiment
and test/debug quickly and easily. This ease of experimentation flattens
the learning curve even more.
.PP
Things that make Perl easier to learn: Unix experience, almost any kind
of programming experience, an understanding of regular expressions, and
the ability to understand other people's code. If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free. Don't forget Perl modules, either.
They're discussed in Part 3 of this \s-1FAQ\s0, along with \s-1CPAN\s0 <http://www.cpan.org/>, which is
discussed in Part 2.
.SS "How does Perl compare with other languages like Java, Python, \s-1REXX\s0, Scheme, or Tcl?"
.IX Subsection "How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?"
Perl can be used for almost any coding problem, even ones which require
integrating specialist C code for extra speed. As with any tool it can
be used well or badly. Perl has many strengths, and a few weaknesses,
precisely which areas are good and bad is often a personal choice.
.PP
When choosing a language you should also be influenced by the
resources <http://www.cpan.org/>, testing culture <http://www.cpantesters.org/>
and community <http://www.perl.org/community.html> which surrounds it.
.PP
For comparisons to a specific language it is often best to create
a small project in both languages and compare the results, make sure
to use all the resources <http://www.cpan.org/> of each language,
as a language is far more than just it's syntax.
.SS "Can I do [task] in Perl?"
.IX Subsection "Can I do [task] in Perl?"
Perl is flexible and extensible enough for you to use on virtually any
task, from one-line file-processing tasks to large, elaborate systems.
.PP
For many people, Perl serves as a great replacement for shell scripting.
For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or \*(C+. It's ultimately
up to you (and possibly your management) which tasks you'll use Perl
for and which you won't.
.PP
If you have a library that provides an \s-1API\s0, you can make any component
of it available as just another Perl function or variable using a Perl
extension written in C or \*(C+ and dynamically linked into your main
perl interpreter. You can also go the other direction, and write your
main program in C or \*(C+, and then link in some Perl code on the fly,
to create a powerful application. See perlembed.
.PP
That said, there will always be small, focused, special-purpose
languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems. Perl tries to be all things
to all people, but nothing special to anyone. Examples of specialized
languages that come to mind include prolog and matlab.
.SS "When shouldn't I program in Perl?"
.IX Subsection "When shouldn't I program in Perl?"
One good reason is when you already have an existing
application written in another language that's all done (and done
well), or you have an application language specifically designed for a
certain task (e.g. prolog, make).
.PP
If you find that you need to speed up a specific part of a Perl
application (not something you often need) you may want to use C,
but you can access this from your Perl code with perlxs.
.ie n .SS "What's the difference between ""perl"" and ""Perl""?"
.el .SS "What's the difference between ``perl'' and ``Perl''?"
.IX Subsection "What's the difference between perl and Perl?"
\&\*(L"Perl\*(R" is the name of the language. Only the \*(L"P\*(R" is capitalized.
The name of the interpreter (the program which runs the Perl script)
is \*(L"perl\*(R" with a lowercase \*(L"p\*(R".
.PP
You may or may not choose to follow this usage. But never write \*(L"\s-1PERL\s0\*(R",
because perl is not an acronym.
.SS "What is a \s-1JAPH\s0?"
.IX Subsection "What is a JAPH?"
(contributed by brian d foy)
.PP
\&\s-1JAPH\s0 stands for \*(L"Just another Perl hacker,\*(R", which Randal Schwartz used
to sign email and usenet messages starting in the late 1980s. He
previously used the phrase with many subjects (\*(L"Just another x hacker,\*(R"),
so to distinguish his \s-1JAPH\s0, he started to write them as Perl programs:
.PP
.Vb 1
\&    print "Just another Perl hacker,";
.Ve
.PP
Other people picked up on this and started to write clever or obfuscated
programs to produce the same output, spinning things quickly out of
control while still providing hours of amusement for their creators and
readers.
.PP
\&\s-1CPAN\s0 has several \s-1JAPH\s0 programs at <http://www.cpan.org/misc/japh>.
.SS "How can I convince others to use Perl?"
.IX Subsection "How can I convince others to use Perl?"
(contributed by brian d foy)
.PP
Appeal to their self interest! If Perl is new (and thus scary) to them,
find something that Perl can do to solve one of their problems. That
might mean that Perl either saves them something (time, headaches, money)
or gives them something (flexibility, power, testability).
.PP
In general, the benefit of a language is closely related to the skill of
the people using that language. If you or your team can be faster,
better, and stronger through Perl, you'll deliver more value. Remember,
people often respond better to what they get out of it. If you run
into resistance, figure out what those people get out of the other
choice and how Perl might satisfy that requirement.
.PP
You don't have to worry about finding or paying for Perl; it's freely
available and several popular operating systems come with Perl. Community
support in places such as Perlmonks ( <http://www.perlmonks.com> )
and the various Perl mailing lists ( <http://lists.perl.org> ) means that
you can usually get quick answers to your problems.
.PP
Finally, keep in mind that Perl might not be the right tool for every
job. You're a much better advocate if your claims are reasonable and
grounded in reality. Dogmatically advocating anything tends to make
people discount your message. Be honest about possible disadvantages
to your choice of Perl since any choice has trade-offs.
.PP
You might find these links useful:
.IP "\(bu" 4
<http://www.perl.org/about.html>
.IP "\(bu" 4
<http://perltraining.com.au/whyperl.html>
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq15.18.1                               0100644 0001750 0001750 00000045014 12566207436 022776  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ1 1"
.TH PERLFAQ1 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq1 \- General Questions About Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers very general, high-level questions
about Perl.
.SS "What is Perl?"
.IX Subsection "What is Perl?"
Perl is a high-level programming language with an eclectic heritage
written by Larry Wall and a cast of thousands.
.PP
Perl's process, file, and text manipulation facilities make it
particularly well-suited for tasks involving quick prototyping, system
utilities, software tools, system management tasks, database access,
graphical programming, networking, and web programming.
.PP
Perl derives from the ubiquitous C programming language and to a
lesser extent from sed, awk, the Unix shell, and many other tools
and languages.
.PP
These strengths make it especially popular with web developers
and system administrators. Mathematicians, geneticists, journalists,
managers and many other people also use Perl.
.SS "Who supports Perl? Who develops it? Why is it free?"
.IX Subsection "Who supports Perl? Who develops it? Why is it free?"
The original culture of the pre-populist Internet and the deeply-held
beliefs of Perl's author, Larry Wall, gave rise to the free and open
distribution policy of Perl. Perl is supported by its users. The
core, the standard Perl library, the optional modules, and the
documentation you're reading now were all written by volunteers.
.PP
The core development team (known as the Perl Porters)
are a group of highly altruistic individuals committed to
producing better software for free than you could hope to purchase for
money. You may snoop on pending developments via the
archives <http://www.nntp.perl.org/group/perl.perl5.porters/>
or read the faq <http://dev.perl.org/perl5/docs/p5p-faq.html>,
or you can subscribe to the mailing list by sending
perl5\-porters\-subscribe@perl.org a subscription request
(an empty message with no subject is fine).
.PP
While the \s-1GNU\s0 project includes Perl in its distributions, there's no
such thing as \*(L"\s-1GNU\s0 Perl\*(R". Perl is not produced nor maintained by the
Free Software Foundation. Perl's licensing terms are also more open
than \s-1GNU\s0 software's tend to be.
.PP
You can get commercial support of Perl if you wish, although for most
users the informal support will more than suffice. See the answer to
\&\*(L"Where can I buy a commercial version of Perl?\*(R" for more information.
.SS "Which version of Perl should I use?"
.IX Subsection "Which version of Perl should I use?"
(contributed by brian d foy)
.PP
There is often a matter of opinion and taste, and there isn't any one
answer that fits everyone. In general, you want to use either the current
stable release, or the stable release immediately prior to that one.
Currently, those are perl5.14.x and perl5.12.x, respectively.
.PP
Beyond that, you have to consider several things and decide which is best
for you.
.IP "\(bu" 4
If things aren't broken, upgrading perl may break them (or at least issue
new warnings).
.IP "\(bu" 4
The latest versions of perl have more bug fixes.
.IP "\(bu" 4
The Perl community is geared toward supporting the most recent releases,
so you'll have an easier time finding help for those.
.IP "\(bu" 4
Versions prior to perl5.004 had serious security problems with buffer
overflows, and in some cases have \s-1CERT\s0 advisories (for instance,
<http://www.cert.org/advisories/CA\-1997\-17.html> ).
.IP "\(bu" 4
The latest versions are probably the least deployed and widely tested, so
you may want to wait a few months after their release and see what
problems others have if you are risk averse.
.IP "\(bu" 4
The immediate, previous releases (i.e. perl5.8.x ) are usually maintained
for a while, although not at the same level as the current releases.
.IP "\(bu" 4
No one is actively supporting Perl 4. Ten years ago it was a dead
camel carcass (according to this document). Now it's barely a skeleton
as its whitewashed bones have fractured or eroded.
.IP "\(bu" 4
The current leading implementation of Perl 6, Rakudo, released a \*(L"useful,
usable, 'early adopter'\*(R" distribution of Perl 6 (called Rakudo Star) in July of
2010. Please see <http://rakudo.org/> for more information.
.IP "\(bu" 4
There are really two tracks of perl development: a maintenance version
and an experimental version. The maintenance versions are stable, and
have an even number as the minor release (i.e. perl5.10.x, where 10 is the
minor release). The experimental versions may include features that
don't make it into the stable versions, and have an odd number as the
minor release (i.e. perl5.9.x, where 9 is the minor release).
.SS "What are Perl 4, Perl 5, or Perl 6?"
.IX Subsection "What are Perl 4, Perl 5, or Perl 6?"
In short, Perl 4 is the parent to both Perl 5 and Perl 6. Perl 5 is the older
sibling, and though they are different languages, someone who knows one will
spot many similarities in the other.
.PP
The number after Perl (i.e. the 5 after Perl 5) is the major release
of the perl interpreter as well as the version of the language. Each
major version has significant differences that earlier versions cannot
support.
.PP
The current major release of Perl is Perl 5, first released in
1994. It can run scripts from the previous major release, Perl 4
(March 1991), but has significant differences.
.PP
Perl 6 is a reinvention of Perl, it is a language in the same lineage but
not compatible. The two are complementary, not mutually exclusive. Perl 6 is
not meant to replace Perl 5, and vice versa. See \*(L"What is Perl 6?\*(R" below
to find out more.
.PP
See perlhist for a history of Perl revisions.
.SS "What is Perl 6?"
.IX Subsection "What is Perl 6?"
Perl 6 was \fIoriginally\fR described as the community's rewrite of Perl 5.
Development started in 2002; syntax and design work continue to this day.
As the language has evolved, it has become clear that it is a separate
language, incompatible with Perl 5 but in the same language family.
.PP
Contrary to popular belief, Perl 6 and Perl 5 peacefully coexist with one
another. Perl 6 has proven to be a fascinating source of ideas for those
using Perl 5 (the Moose object system is a well-known example). There is
overlap in the communities, and this overlap fosters the tradition of sharing
and borrowing that have been instrumental to Perl's success. The current
leading implementation of Perl 6 is Rakudo, and you can learn more about
it at <http://rakudo.org>.
.PP
If you want to learn more about Perl 6, or have a desire to help in
the crusade to make Perl a better place then read the Perl 6 developers
page at <http://www.perl6.org/> and get involved.
.PP
\&\*(L"We're really serious about reinventing everything that needs reinventing.\*(R"
\&\-\-Larry Wall
.SS "How stable is Perl?"
.IX Subsection "How stable is Perl?"
Production releases, which incorporate bug fixes and new functionality,
are widely tested before release. Since the 5.000 release, we have
averaged about one production release per year.
.PP
The Perl development team occasionally make changes to the
internal core of the language, but all possible efforts are made toward
backward compatibility.
.SS "Is Perl difficult to learn?"
.IX Subsection "Is Perl difficult to learn?"
No, Perl is easy to start learning <http://learn.perl.org/> \-\-and easy to keep learning. It looks
like most programming languages you're likely to have experience
with, so if you've ever written a C program, an awk script, a shell
script, or even a \s-1BASIC\s0 program, you're already partway there.
.PP
Most tasks only require a small subset of the Perl language. One of
the guiding mottos for Perl development is \*(L"there's more than one way
to do it\*(R" (\s-1TMTOWTDI,\s0 sometimes pronounced \*(L"tim toady\*(R"). Perl's
learning curve is therefore shallow (easy to learn) and long (there's
a whole lot you can do if you really want).
.PP
Finally, because Perl is frequently (but not always, and certainly not by
definition) an interpreted language, you can write your programs and test
them without an intermediate compilation step, allowing you to experiment
and test/debug quickly and easily. This ease of experimentation flattens
the learning curve even more.
.PP
Things that make Perl easier to learn: Unix experience, almost any kind
of programming experience, an understanding of regular expressions, and
the ability to understand other people's code. If there's something you
need to do, then it's probably already been done, and a working example is
usually available for free. Don't forget Perl modules, either.
They're discussed in Part 3 of this \s-1FAQ,\s0 along with \s-1CPAN\s0 <http://www.cpan.org/>, which is
discussed in Part 2.
.SS "How does Perl compare with other languages like Java, Python, \s-1REXX,\s0 Scheme, or Tcl?"
.IX Subsection "How does Perl compare with other languages like Java, Python, REXX, Scheme, or Tcl?"
Perl can be used for almost any coding problem, even ones which require
integrating specialist C code for extra speed. As with any tool it can
be used well or badly. Perl has many strengths, and a few weaknesses,
precisely which areas are good and bad is often a personal choice.
.PP
When choosing a language you should also be influenced by the
resources <http://www.cpan.org/>, testing culture <http://www.cpantesters.org/>
and community <http://www.perl.org/community.html> which surrounds it.
.PP
For comparisons to a specific language it is often best to create
a small project in both languages and compare the results, make sure
to use all the resources <http://www.cpan.org/> of each language,
as a language is far more than just it's syntax.
.SS "Can I do [task] in Perl?"
.IX Subsection "Can I do [task] in Perl?"
Perl is flexible and extensible enough for you to use on virtually any
task, from one-line file-processing tasks to large, elaborate systems.
.PP
For many people, Perl serves as a great replacement for shell scripting.
For others, it serves as a convenient, high-level replacement for most of
what they'd program in low-level languages like C or \*(C+. It's ultimately
up to you (and possibly your management) which tasks you'll use Perl
for and which you won't.
.PP
If you have a library that provides an \s-1API,\s0 you can make any component
of it available as just another Perl function or variable using a Perl
extension written in C or \*(C+ and dynamically linked into your main
perl interpreter. You can also go the other direction, and write your
main program in C or \*(C+, and then link in some Perl code on the fly,
to create a powerful application. See perlembed.
.PP
That said, there will always be small, focused, special-purpose
languages dedicated to a specific problem domain that are simply more
convenient for certain kinds of problems. Perl tries to be all things
to all people, but nothing special to anyone. Examples of specialized
languages that come to mind include prolog and matlab.
.SS "When shouldn't I program in Perl?"
.IX Subsection "When shouldn't I program in Perl?"
One good reason is when you already have an existing
application written in another language that's all done (and done
well), or you have an application language specifically designed for a
certain task (e.g. prolog, make).
.PP
If you find that you need to speed up a specific part of a Perl
application (not something you often need) you may want to use C,
but you can access this from your Perl code with perlxs.
.ie n .SS "What's the difference between ""perl"" and ""Perl""?"
.el .SS "What's the difference between ``perl'' and ``Perl''?"
.IX Subsection "What's the difference between perl and Perl?"
\&\*(L"Perl\*(R" is the name of the language. Only the \*(L"P\*(R" is capitalized.
The name of the interpreter (the program which runs the Perl script)
is \*(L"perl\*(R" with a lowercase \*(L"p\*(R".
.PP
You may or may not choose to follow this usage. But never write \*(L"\s-1PERL\*(R",\s0
because perl is not an acronym.
.SS "What is a \s-1JAPH\s0?"
.IX Subsection "What is a JAPH?"
(contributed by brian d foy)
.PP
\&\s-1JAPH\s0 stands for \*(L"Just another Perl hacker,\*(R", which Randal Schwartz used
to sign email and usenet messages starting in the late 1980s. He
previously used the phrase with many subjects (\*(L"Just another x hacker,\*(R"),
so to distinguish his \s-1JAPH,\s0 he started to write them as Perl programs:
.PP
.Vb 1
\&    print "Just another Perl hacker,";
.Ve
.PP
Other people picked up on this and started to write clever or obfuscated
programs to produce the same output, spinning things quickly out of
control while still providing hours of amusement for their creators and
readers.
.PP
\&\s-1CPAN\s0 has several \s-1JAPH\s0 programs at <http://www.cpan.org/misc/japh>.
.SS "How can I convince others to use Perl?"
.IX Subsection "How can I convince others to use Perl?"
(contributed by brian d foy)
.PP
Appeal to their self interest! If Perl is new (and thus scary) to them,
find something that Perl can do to solve one of their problems. That
might mean that Perl either saves them something (time, headaches, money)
or gives them something (flexibility, power, testability).
.PP
In general, the benefit of a language is closely related to the skill of
the people using that language. If you or your team can be faster,
better, and stronger through Perl, you'll deliver more value. Remember,
people often respond better to what they get out of it. If you run
into resistance, figure out what those people get out of the other
choice and how Perl might satisfy that requirement.
.PP
You don't have to worry about finding or paying for Perl; it's freely
available and several popular operating systems come with Perl. Community
support in places such as Perlmonks ( <http://www.perlmonks.com> )
and the various Perl mailing lists ( <http://lists.perl.org> ) means that
you can usually get quick answers to your problems.
.PP
Finally, keep in mind that Perl might not be the right tool for every
job. You're a much better advocate if your claims are reasonable and
grounded in reality. Dogmatically advocating anything tends to make
people discount your message. Be honest about possible disadvantages
to your choice of Perl since any choice has trade-offs.
.PP
You might find these links useful:
.IP "\(bu" 4
<http://www.perl.org/about.html>
.IP "\(bu" 4
<http://perltraining.com.au/whyperl.html>
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq2.1                                   0100644 0001750 0001750 00000034560 12566207436 022467  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ2 1"
.TH PERLFAQ2 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq2 \- Obtaining and Learning about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions about where to find
source and documentation for Perl, support, and
related matters.
.SS "What machines support Perl? Where do I get it?"
.IX Subsection "What machines support Perl? Where do I get it?"
The standard release of Perl (the one maintained by the Perl
development team) is distributed only in source code form. You
can find the latest releases at <http://www.cpan.org/src/>.
.PP
Perl builds and runs on a bewildering number of platforms. Virtually
all known and current Unix derivatives are supported (perl's native
platform), as are other systems like \s-1VMS, DOS, OS/2,\s0 Windows,
\&\s-1QNX,\s0 BeOS, \s-1OS X,\s0 MPE/iX and the Amiga.
.PP
Binary distributions for some proprietary platforms can be found
<http://www.cpan.org/ports/> directory. Because these are not part of
the standard distribution, they may and in fact do differ from the
base perl port in a variety of ways. You'll have to check their
respective release notes to see just what the differences are. These
differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source
release of perl) or negative (e.g. might be based upon a less current
source release of perl).
.SS "How can I get a binary version of Perl?"
.IX Subsection "How can I get a binary version of Perl?"
See \s-1CPAN\s0 Ports <http://www.cpan.org/ports/>
.SS "I don't have a C compiler. How can I build my own Perl interpreter?"
.IX Subsection "I don't have a C compiler. How can I build my own Perl interpreter?"
For Windows, use a binary version of Perl,
Strawberry Perl <http://strawberryperl.com/> and
ActivePerl <http://www.activestate.com/activeperl> come with a
bundled C compiler.
.PP
Otherwise if you really do want to build Perl, you need to get a
binary version of \f(CW\*(C`gcc\*(C'\fR for your system first. Use a search
engine to find out how to do this for your operating system.
.SS "I copied the Perl binary from one machine to another, but scripts don't work."
.IX Subsection "I copied the Perl binary from one machine to another, but scripts don't work."
That's probably because you forgot libraries, or library paths differ.
You really should build the whole distribution on the machine it will
eventually live on, and then type \f(CW\*(C`make install\*(C'\fR. Most other
approaches are doomed to failure.
.PP
One simple way to check that things are in the right place is to print out
the hard-coded \f(CW@INC\fR that perl looks through for libraries:
.PP
.Vb 1
\&    % perl \-le \*(Aqprint for @INC\*(Aq
.Ve
.PP
If this command lists any paths that don't exist on your system, then you
may need to move the appropriate libraries to these locations, or create
symbolic links, aliases, or shortcuts appropriately. \f(CW@INC\fR is also printed as
part of the output of
.PP
.Vb 1
\&    % perl \-V
.Ve
.PP
You might also want to check out
\&\*(L"How do I keep my own module/library directory?\*(R" in perlfaq8.
.SS "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
.IX Subsection "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
Read the \fI\s-1INSTALL\s0\fR file, which is part of the source distribution.
It describes in detail how to cope with most idiosyncrasies that the
\&\f(CW\*(C`Configure\*(C'\fR script can't work around for any given system or
architecture.
.SS "What modules and extensions are available for Perl? What is \s-1CPAN\s0?"
.IX Subsection "What modules and extensions are available for Perl? What is CPAN?"
\&\s-1CPAN\s0 stands for Comprehensive Perl Archive Network, a multi-gigabyte
archive replicated on hundreds of machines all over the world. \s-1CPAN\s0
contains tens of thousands of modules and extensions, source code
and documentation, designed for \fIeverything\fR from commercial
database interfaces to keyboard/screen control and running large web sites.
.PP
You can search \s-1CPAN\s0 on <http://metacpan.org> or
<http://search.cpan.org/>.
.PP
The master web site for \s-1CPAN\s0 is <http://www.cpan.org/>,
<http://www.cpan.org/SITES.html> lists all mirrors.
.PP
See the \s-1CPAN FAQ\s0 at <http://www.cpan.org/misc/cpan\-faq.html> for answers
to the most frequently asked questions about \s-1CPAN.\s0
.PP
The Task::Kensho module has a list of recommended modules which
you should review as a good starting point.
.SS "Where can I get information on Perl?"
.IX Subsection "Where can I get information on Perl?"
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://perldoc.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.PP
The complete Perl documentation is available with the Perl distribution.
If you have Perl installed locally, you probably have the documentation
installed as well: type \f(CW\*(C`perldoc perl\*(C'\fR in a terminal or
view online <http://perldoc.perl.org/perl.html>.
.PP
(Some operating system distributions may ship the documentation in a different
package; for instance, on Debian, you need to install the \f(CW\*(C`perl\-doc\*(C'\fR package.)
.PP
Many good books have been written about Perl\*(--see the section later in
perlfaq2 for more details.
.SS "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
.IX Subsection "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
Perl.com <http://www.perl.com/> used to be part of the O'Reilly
Network, a subsidiary of O'Reilly Media. Although it retains most of
the original content from its O'Reilly Network, it is now hosted by
The Perl Foundation <http://www.perlfoundation.org/>.
.PP
The Perl Foundation is an advocacy organization for the Perl language
which maintains the web site <http://www.perl.org/> as a general
advocacy site for the Perl language. It uses the domain to provide
general support services to the Perl community, including the hosting
of mailing lists, web sites, and other services. There are also many
other sub-domains for special topics like learning Perl and jobs in Perl,
such as:
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.IP "\(bu" 4
<http://jobs.perl.org/>
.IP "\(bu" 4
<http://lists.perl.org/>
.PP
Perl Mongers <http://www.pm.org/> uses the pm.org domain for services
related to local Perl user groups, including the hosting of mailing lists
and web sites. See the Perl Mongers web site <http://www.pm.org/> for more
information about joining, starting, or requesting services for a
Perl user group.
.PP
\&\s-1CPAN,\s0 or the Comprehensive Perl Archive Network <http://www.cpan.org/>,
is a replicated, worldwide repository of Perl software.
See What is \s-1CPAN\s0?.
.SS "Where can I post questions?"
.IX Subsection "Where can I post questions?"
There are many Perl mailing lists for various
topics, specifically the beginners list <http://lists.perl.org/list/beginners.html>
may be of use.
.PP
Other places to ask questions are on the
PerlMonks site <http://www.perlmonks.org/> or
stackoverflow <http://stackoverflow.com/questions/tagged/perl>.
.SS "Perl Books"
.IX Subsection "Perl Books"
There are many good books on Perl <http://www.perl.org/books/library.html>.
.SS "Which magazines have Perl content?"
.IX Subsection "Which magazines have Perl content?"
There's also \fI\f(CI$foo\fI Magazin\fR, a German magazine dedicated to Perl, at
( <http://www.foo\-magazin.de> ). The \fIPerl-Zeitung\fR is another
German-speaking magazine for Perl beginners (see
<http://perl\-zeitung.at.tf> ).
.PP
Several unix/linux releated magazines frequently includes articles on Perl.
.SS "Which Perl blogs should I read?"
.IX Subsection "Which Perl blogs should I read?"
Perl News <http://perlnews.org/> covers some of the major events in the Perl
world, Perl Weekly <http://perlweekly.com/> is a weekly e\-mail
(and \s-1RSS\s0 feed) of hand-picked Perl articles.
.PP
<http://blogs.perl.org/> hosts many Perl blogs, there are also
several blog aggregators: Perlsphere <http://perlsphere.net/> and
IronMan <http://ironman.enlightenedperl.org/> are two of them.
.SS "What mailing lists are there for Perl?"
.IX Subsection "What mailing lists are there for Perl?"
A comprehensive list of Perl-related mailing lists can be found at
<http://lists.perl.org/>
.SS "Where can I buy a commercial version of Perl?"
.IX Subsection "Where can I buy a commercial version of Perl?"
Perl already \fIis\fR commercial software: it has a license
that you can grab and carefully read to your manager. It is distributed
in releases and comes in well-defined packages. There is a very large
and supportive user community and an extensive literature.
.PP
If you still need commercial support
ActiveState <http://www.activestate.com/activeperl> offers
this.
.SS "Where do I send bug reports?"
.IX Subsection "Where do I send bug reports?"
(contributed by brian d foy)
.PP
First, ensure that you've found an actual bug. Second, ensure you've
found an actual bug.
.PP
If you've found a bug with the perl interpreter or one of the modules
in the standard library (those that come with Perl), you can use the
perlbug utility that comes with Perl (>= 5.004). It collects
information about your installation to include with your message, then
sends the message to the right place.
.PP
To determine if a module came with your version of Perl, you can
install and use the Module::CoreList module. It has the information
about the modules (with their versions) included with each release
of Perl.
.PP
Every \s-1CPAN\s0 module has a bug tracker set up in \s-1RT, \s0<http://rt.cpan.org>.
You can submit bugs to \s-1RT\s0 either through its web interface or by
email. To email a bug report, send it to
bug\-<distribution\-name>@rt.cpan.org . For example, if you
wanted to report a bug in Business::ISBN, you could send a message to
bug\-Business\-ISBN@rt.cpan.org .
.PP
Some modules might have special reporting requirements, such as a
Github or Google Code tracking system, so you should check the
module documentation too.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq25.16.1                               0100644 0001750 0001750 00000034417 12566207416 023000  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ2 1"
.TH PERLFAQ2 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq2 \- Obtaining and Learning about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions about where to find
source and documentation for Perl, support, and
related matters.
.SS "What machines support Perl? Where do I get it?"
.IX Subsection "What machines support Perl? Where do I get it?"
The standard release of Perl (the one maintained by the Perl
development team) is distributed only in source code form. You
can find the latest releases at <http://www.cpan.org/src/>.
.PP
Perl builds and runs on a bewildering number of platforms. Virtually
all known and current Unix derivatives are supported (perl's native
platform), as are other systems like \s-1VMS\s0, \s-1DOS\s0, \s-1OS/2\s0, Windows,
\&\s-1QNX\s0, BeOS, \s-1OS\s0 X, MPE/iX and the Amiga.
.PP
Binary distributions for some proprietary platforms can be found
<http://www.cpan.org/ports/> directory. Because these are not part of
the standard distribution, they may and in fact do differ from the
base perl port in a variety of ways. You'll have to check their
respective release notes to see just what the differences are. These
differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source
release of perl) or negative (e.g. might be based upon a less current
source release of perl).
.SS "How can I get a binary version of Perl?"
.IX Subsection "How can I get a binary version of Perl?"
See \s-1CPAN\s0 Ports <http://www.cpan.org/ports/>
.SS "I don't have a C compiler. How can I build my own Perl interpreter?"
.IX Subsection "I don't have a C compiler. How can I build my own Perl interpreter?"
For Windows, use a binary version of Perl,
Strawberry Perl <http://strawberryperl.com/> and
ActivePerl <http://www.activestate.com/activeperl> come with a
bundled C compiler.
.PP
Otherwise if you really do want to build Perl, you need to get a
binary version of \f(CW\*(C`gcc\*(C'\fR for your system first. Use a search
engine to find out how to do this for your operating system.
.SS "I copied the Perl binary from one machine to another, but scripts don't work."
.IX Subsection "I copied the Perl binary from one machine to another, but scripts don't work."
That's probably because you forgot libraries, or library paths differ.
You really should build the whole distribution on the machine it will
eventually live on, and then type \f(CW\*(C`make install\*(C'\fR. Most other
approaches are doomed to failure.
.PP
One simple way to check that things are in the right place is to print out
the hard-coded \f(CW@INC\fR that perl looks through for libraries:
.PP
.Vb 1
\&    % perl \-le \*(Aqprint for @INC\*(Aq
.Ve
.PP
If this command lists any paths that don't exist on your system, then you
may need to move the appropriate libraries to these locations, or create
symbolic links, aliases, or shortcuts appropriately. \f(CW@INC\fR is also printed as
part of the output of
.PP
.Vb 1
\&    % perl \-V
.Ve
.PP
You might also want to check out
\&\*(L"How do I keep my own module/library directory?\*(R" in perlfaq8.
.SS "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
.IX Subsection "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
Read the \fI\s-1INSTALL\s0\fR file, which is part of the source distribution.
It describes in detail how to cope with most idiosyncrasies that the
\&\f(CW\*(C`Configure\*(C'\fR script can't work around for any given system or
architecture.
.SS "What modules and extensions are available for Perl? What is \s-1CPAN\s0?"
.IX Subsection "What modules and extensions are available for Perl? What is CPAN?"
\&\s-1CPAN\s0 stands for Comprehensive Perl Archive Network, a multi-gigabyte
archive replicated on hundreds of machines all over the world. \s-1CPAN\s0
contains tens of thousands of modules and extensions, source code
and documentation, designed for \fIeverything\fR from commercial
database interfaces to keyboard/screen control and running large web sites.
.PP
You can search \s-1CPAN\s0 on <http://metacpan.org> or
<http://search.cpan.org/>.
.PP
The master web site for \s-1CPAN\s0 is <http://www.cpan.org/>,
<http://www.cpan.org/SITES.html> lists all mirrors.
.PP
See the \s-1CPAN\s0 \s-1FAQ\s0 at http://www.cpan.org/misc/cpan\-faq.html <http://www.cpan.org/misc/cpan-faq.html> for answers
to the most frequently asked questions about \s-1CPAN\s0.
.PP
The Task::Kensho module has a list of recommended modules which
you should review as a good starting point.
.SS "Where can I get information on Perl?"
.IX Subsection "Where can I get information on Perl?"
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://perldoc.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.PP
The complete Perl documentation is available with the Perl distribution.
If you have Perl installed locally, you probably have the documentation
installed as well: type \f(CW\*(C`perldoc perl\*(C'\fR in a terminal or
view online <http://perldoc.perl.org/perl.html>.
.PP
(Some operating system distributions may ship the documentation in a different
package; for instance, on Debian, you need to install the \f(CW\*(C`perl\-doc\*(C'\fR package.)
.PP
Many good books have been written about Perl\*(--see the section later in
perlfaq2 for more details.
.SS "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
.IX Subsection "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
Perl.com <http://www.perl.com/> used to be part of the O'Reilly
Network, a subsidiary of O'Reilly Media. Although it retains most of
the original content from its O'Reilly Network, it is now hosted by
The Perl Foundation <http://www.perlfoundation.org/>.
.PP
The Perl Foundation is an advocacy organization for the Perl language
which maintains the web site <http://www.perl.org/> as a general
advocacy site for the Perl language. It uses the domain to provide
general support services to the Perl community, including the hosting
of mailing lists, web sites, and other services. There are also many
other sub-domains for special topics like learning Perl and jobs in Perl,
such as:
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.IP "\(bu" 4
<http://jobs.perl.org/>
.IP "\(bu" 4
<http://lists.perl.org/>
.PP
Perl Mongers <http://www.pm.org/> uses the pm.org domain for services
related to local Perl user groups, including the hosting of mailing lists
and web sites. See the Perl Mongers web site <http://www.pm.org/> for more
information about joining, starting, or requesting services for a
Perl user group.
.PP
\&\s-1CPAN\s0, or the Comprehensive Perl Archive Network <http://www.cpan.org/>,
is a replicated, worldwide repository of Perl software.
See What is \s-1CPAN\s0?.
.SS "Where can I post questions?"
.IX Subsection "Where can I post questions?"
There are many Perl mailing lists for various
topics, specifically the beginners list <http://lists.perl.org/list/beginners.html>
may be of use.
.PP
Other places to ask questions are on the
PerlMonks site <http://www.perlmonks.org/> or
stackoverflow <http://stackoverflow.com/questions/tagged/perl>.
.SS "Perl Books"
.IX Subsection "Perl Books"
There are many good books on Perl <http://www.perl.org/books/library.html>.
.SS "Which magazines have Perl content?"
.IX Subsection "Which magazines have Perl content?"
There's also \fI\f(CI$foo\fI Magazin\fR, a German magazine dedicated to Perl, at
( http://www.foo\-magazin.de <http://www.foo-magazin.de> ). The \fIPerl-Zeitung\fR is another
German-speaking magazine for Perl beginners (see
http://perl\-zeitung.at.tf <http://perl-zeitung.at.tf> ).
.PP
Several unix/linux releated magazines frequently includes articles on Perl.
.SS "Which Perl blogs should I read?"
.IX Subsection "Which Perl blogs should I read?"
Perl News <http://perlnews.org/> covers some of the major events in the Perl
world, Perl Weekly <http://perlweekly.com/> is a weekly e\-mail
(and \s-1RSS\s0 feed) of hand-picked Perl articles.
.PP
<http://blogs.perl.org/> hosts many Perl blogs, there are also
several blog aggregators: Perlsphere <http://perlsphere.net/> and
IronMan <http://ironman.enlightenedperl.org/> are two of them.
.SS "What mailing lists are there for Perl?"
.IX Subsection "What mailing lists are there for Perl?"
A comprehensive list of Perl-related mailing lists can be found at
<http://lists.perl.org/>
.SS "Where can I buy a commercial version of Perl?"
.IX Subsection "Where can I buy a commercial version of Perl?"
Perl already \fIis\fR commercial software: it has a license
that you can grab and carefully read to your manager. It is distributed
in releases and comes in well-defined packages. There is a very large
and supportive user community and an extensive literature.
.PP
If you still need commercial support
ActiveState <http://www.activestate.com/activeperl> offers
this.
.SS "Where do I send bug reports?"
.IX Subsection "Where do I send bug reports?"
(contributed by brian d foy)
.PP
First, ensure that you've found an actual bug. Second, ensure you've
found an actual bug.
.PP
If you've found a bug with the perl interpreter or one of the modules
in the standard library (those that come with Perl), you can use the
perlbug utility that comes with Perl (>= 5.004). It collects
information about your installation to include with your message, then
sends the message to the right place.
.PP
To determine if a module came with your version of Perl, you can
install and use the Module::CoreList module. It has the information
about the modules (with their versions) included with each release
of Perl.
.PP
Every \s-1CPAN\s0 module has a bug tracker set up in \s-1RT\s0, <http://rt.cpan.org>.
You can submit bugs to \s-1RT\s0 either through its web interface or by
email. To email a bug report, send it to
bug\-<distribution\-name>@rt.cpan.org . For example, if you
wanted to report a bug in Business::ISBN, you could send a message to
bug\-Business\-ISBN@rt.cpan.org .
.PP
Some modules might have special reporting requirements, such as a
Github or Google Code tracking system, so you should check the
module documentation too.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq25.18.1                               0100644 0001750 0001750 00000034560 12566207436 023003  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ2 1"
.TH PERLFAQ2 1 "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq2 \- Obtaining and Learning about Perl
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions about where to find
source and documentation for Perl, support, and
related matters.
.SS "What machines support Perl? Where do I get it?"
.IX Subsection "What machines support Perl? Where do I get it?"
The standard release of Perl (the one maintained by the Perl
development team) is distributed only in source code form. You
can find the latest releases at <http://www.cpan.org/src/>.
.PP
Perl builds and runs on a bewildering number of platforms. Virtually
all known and current Unix derivatives are supported (perl's native
platform), as are other systems like \s-1VMS, DOS, OS/2,\s0 Windows,
\&\s-1QNX,\s0 BeOS, \s-1OS X,\s0 MPE/iX and the Amiga.
.PP
Binary distributions for some proprietary platforms can be found
<http://www.cpan.org/ports/> directory. Because these are not part of
the standard distribution, they may and in fact do differ from the
base perl port in a variety of ways. You'll have to check their
respective release notes to see just what the differences are. These
differences can be either positive (e.g. extensions for the features
of the particular platform that are not supported in the source
release of perl) or negative (e.g. might be based upon a less current
source release of perl).
.SS "How can I get a binary version of Perl?"
.IX Subsection "How can I get a binary version of Perl?"
See \s-1CPAN\s0 Ports <http://www.cpan.org/ports/>
.SS "I don't have a C compiler. How can I build my own Perl interpreter?"
.IX Subsection "I don't have a C compiler. How can I build my own Perl interpreter?"
For Windows, use a binary version of Perl,
Strawberry Perl <http://strawberryperl.com/> and
ActivePerl <http://www.activestate.com/activeperl> come with a
bundled C compiler.
.PP
Otherwise if you really do want to build Perl, you need to get a
binary version of \f(CW\*(C`gcc\*(C'\fR for your system first. Use a search
engine to find out how to do this for your operating system.
.SS "I copied the Perl binary from one machine to another, but scripts don't work."
.IX Subsection "I copied the Perl binary from one machine to another, but scripts don't work."
That's probably because you forgot libraries, or library paths differ.
You really should build the whole distribution on the machine it will
eventually live on, and then type \f(CW\*(C`make install\*(C'\fR. Most other
approaches are doomed to failure.
.PP
One simple way to check that things are in the right place is to print out
the hard-coded \f(CW@INC\fR that perl looks through for libraries:
.PP
.Vb 1
\&    % perl \-le \*(Aqprint for @INC\*(Aq
.Ve
.PP
If this command lists any paths that don't exist on your system, then you
may need to move the appropriate libraries to these locations, or create
symbolic links, aliases, or shortcuts appropriately. \f(CW@INC\fR is also printed as
part of the output of
.PP
.Vb 1
\&    % perl \-V
.Ve
.PP
You might also want to check out
\&\*(L"How do I keep my own module/library directory?\*(R" in perlfaq8.
.SS "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
.IX Subsection "I grabbed the sources and tried to compile but gdbm/dynamic loading/malloc/linking/... failed. How do I make it work?"
Read the \fI\s-1INSTALL\s0\fR file, which is part of the source distribution.
It describes in detail how to cope with most idiosyncrasies that the
\&\f(CW\*(C`Configure\*(C'\fR script can't work around for any given system or
architecture.
.SS "What modules and extensions are available for Perl? What is \s-1CPAN\s0?"
.IX Subsection "What modules and extensions are available for Perl? What is CPAN?"
\&\s-1CPAN\s0 stands for Comprehensive Perl Archive Network, a multi-gigabyte
archive replicated on hundreds of machines all over the world. \s-1CPAN\s0
contains tens of thousands of modules and extensions, source code
and documentation, designed for \fIeverything\fR from commercial
database interfaces to keyboard/screen control and running large web sites.
.PP
You can search \s-1CPAN\s0 on <http://metacpan.org> or
<http://search.cpan.org/>.
.PP
The master web site for \s-1CPAN\s0 is <http://www.cpan.org/>,
<http://www.cpan.org/SITES.html> lists all mirrors.
.PP
See the \s-1CPAN FAQ\s0 at <http://www.cpan.org/misc/cpan\-faq.html> for answers
to the most frequently asked questions about \s-1CPAN.\s0
.PP
The Task::Kensho module has a list of recommended modules which
you should review as a good starting point.
.SS "Where can I get information on Perl?"
.IX Subsection "Where can I get information on Perl?"
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://perldoc.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.PP
The complete Perl documentation is available with the Perl distribution.
If you have Perl installed locally, you probably have the documentation
installed as well: type \f(CW\*(C`perldoc perl\*(C'\fR in a terminal or
view online <http://perldoc.perl.org/perl.html>.
.PP
(Some operating system distributions may ship the documentation in a different
package; for instance, on Debian, you need to install the \f(CW\*(C`perl\-doc\*(C'\fR package.)
.PP
Many good books have been written about Perl\*(--see the section later in
perlfaq2 for more details.
.SS "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
.IX Subsection "What is perl.com? Perl Mongers? pm.org? perl.org? cpan.org?"
Perl.com <http://www.perl.com/> used to be part of the O'Reilly
Network, a subsidiary of O'Reilly Media. Although it retains most of
the original content from its O'Reilly Network, it is now hosted by
The Perl Foundation <http://www.perlfoundation.org/>.
.PP
The Perl Foundation is an advocacy organization for the Perl language
which maintains the web site <http://www.perl.org/> as a general
advocacy site for the Perl language. It uses the domain to provide
general support services to the Perl community, including the hosting
of mailing lists, web sites, and other services. There are also many
other sub-domains for special topics like learning Perl and jobs in Perl,
such as:
.IP "\(bu" 4
<http://www.perl.org/>
.IP "\(bu" 4
<http://learn.perl.org/>
.IP "\(bu" 4
<http://jobs.perl.org/>
.IP "\(bu" 4
<http://lists.perl.org/>
.PP
Perl Mongers <http://www.pm.org/> uses the pm.org domain for services
related to local Perl user groups, including the hosting of mailing lists
and web sites. See the Perl Mongers web site <http://www.pm.org/> for more
information about joining, starting, or requesting services for a
Perl user group.
.PP
\&\s-1CPAN,\s0 or the Comprehensive Perl Archive Network <http://www.cpan.org/>,
is a replicated, worldwide repository of Perl software.
See What is \s-1CPAN\s0?.
.SS "Where can I post questions?"
.IX Subsection "Where can I post questions?"
There are many Perl mailing lists for various
topics, specifically the beginners list <http://lists.perl.org/list/beginners.html>
may be of use.
.PP
Other places to ask questions are on the
PerlMonks site <http://www.perlmonks.org/> or
stackoverflow <http://stackoverflow.com/questions/tagged/perl>.
.SS "Perl Books"
.IX Subsection "Perl Books"
There are many good books on Perl <http://www.perl.org/books/library.html>.
.SS "Which magazines have Perl content?"
.IX Subsection "Which magazines have Perl content?"
There's also \fI\f(CI$foo\fI Magazin\fR, a German magazine dedicated to Perl, at
( <http://www.foo\-magazin.de> ). The \fIPerl-Zeitung\fR is another
German-speaking magazine for Perl beginners (see
<http://perl\-zeitung.at.tf> ).
.PP
Several unix/linux releated magazines frequently includes articles on Perl.
.SS "Which Perl blogs should I read?"
.IX Subsection "Which Perl blogs should I read?"
Perl News <http://perlnews.org/> covers some of the major events in the Perl
world, Perl Weekly <http://perlweekly.com/> is a weekly e\-mail
(and \s-1RSS\s0 feed) of hand-picked Perl articles.
.PP
<http://blogs.perl.org/> hosts many Perl blogs, there are also
several blog aggregators: Perlsphere <http://perlsphere.net/> and
IronMan <http://ironman.enlightenedperl.org/> are two of them.
.SS "What mailing lists are there for Perl?"
.IX Subsection "What mailing lists are there for Perl?"
A comprehensive list of Perl-related mailing lists can be found at
<http://lists.perl.org/>
.SS "Where can I buy a commercial version of Perl?"
.IX Subsection "Where can I buy a commercial version of Perl?"
Perl already \fIis\fR commercial software: it has a license
that you can grab and carefully read to your manager. It is distributed
in releases and comes in well-defined packages. There is a very large
and supportive user community and an extensive literature.
.PP
If you still need commercial support
ActiveState <http://www.activestate.com/activeperl> offers
this.
.SS "Where do I send bug reports?"
.IX Subsection "Where do I send bug reports?"
(contributed by brian d foy)
.PP
First, ensure that you've found an actual bug. Second, ensure you've
found an actual bug.
.PP
If you've found a bug with the perl interpreter or one of the modules
in the standard library (those that come with Perl), you can use the
perlbug utility that comes with Perl (>= 5.004). It collects
information about your installation to include with your message, then
sends the message to the right place.
.PP
To determine if a module came with your version of Perl, you can
install and use the Module::CoreList module. It has the information
about the modules (with their versions) included with each release
of Perl.
.PP
Every \s-1CPAN\s0 module has a bug tracker set up in \s-1RT, \s0<http://rt.cpan.org>.
You can submit bugs to \s-1RT\s0 either through its web interface or by
email. To email a bug report, send it to
bug\-<distribution\-name>@rt.cpan.org . For example, if you
wanted to report a bug in Business::ISBN, you could send a message to
bug\-Business\-ISBN@rt.cpan.org .
.PP
Some modules might have special reporting requirements, such as a
Github or Google Code tracking system, so you should check the
module documentation too.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq3.1                                   0100644 0001750 0001750 00000140334 12566207436 022465  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ3 1"
.TH PERLFAQ3 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq3 \- Programming Tools
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to programmer tools
and programming support.
.SS "How do I do (anything)?"
.IX Subsection "How do I do (anything)?"
Have you looked at \s-1CPAN \s0(see perlfaq2)? The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate manpages? Here's a brief index:
.IP "Basics" 4
.IX Item "Basics"
.RS 4
.PD 0
.IP "perldata \- Perl data types" 4
.IX Item "perldata - Perl data types"
.IP "perlvar \- Perl pre-defined variables" 4
.IX Item "perlvar - Perl pre-defined variables"
.IP "perlsyn \- Perl syntax" 4
.IX Item "perlsyn - Perl syntax"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perlsub \- Perl subroutines" 4
.IX Item "perlsub - Perl subroutines"
.RE
.RS 4
.RE
.IP "Execution" 4
.IX Item "Execution"
.RS 4
.IP "perlrun \- how to execute the Perl interpreter" 4
.IX Item "perlrun - how to execute the Perl interpreter"
.IP "perldebug \- Perl debugging" 4
.IX Item "perldebug - Perl debugging"
.RE
.RS 4
.RE
.IP "Functions" 4
.IX Item "Functions"
.RS 4
.IP "perlfunc \- Perl builtin functions" 4
.IX Item "perlfunc - Perl builtin functions"
.RE
.RS 4
.RE
.IP "Objects" 4
.IX Item "Objects"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlobj \- Perl objects" 4
.IX Item "perlobj - Perl objects"
.IP "perltie \- how to hide an object class in a simple variable" 4
.IX Item "perltie - how to hide an object class in a simple variable"
.RE
.RS 4
.RE
.IP "Data Structures" 4
.IX Item "Data Structures"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perllol \- Manipulating arrays of arrays in Perl" 4
.IX Item "perllol - Manipulating arrays of arrays in Perl"
.IP "perldsc \- Perl Data Structures Cookbook" 4
.IX Item "perldsc - Perl Data Structures Cookbook"
.RE
.RS 4
.RE
.IP "Modules" 4
.IX Item "Modules"
.RS 4
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlmodlib \- constructing new Perl modules and finding existing ones" 4
.IX Item "perlmodlib - constructing new Perl modules and finding existing ones"
.RE
.RS 4
.RE
.IP "Regexes" 4
.IX Item "Regexes"
.RS 4
.IP "perlre \- Perl regular expressions" 4
.IX Item "perlre - Perl regular expressions"
.IP "perlfunc \- Perl builtin functions>" 4
.IX Item "perlfunc - Perl builtin functions>"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perllocale \- Perl locale handling (internationalization and localization)" 4
.IX Item "perllocale - Perl locale handling (internationalization and localization)"
.RE
.RS 4
.RE
.IP "Moving to perl5" 4
.IX Item "Moving to perl5"
.RS 4
.IP "perltrap \- Perl traps for the unwary" 4
.IX Item "perltrap - Perl traps for the unwary"
.IP "perl" 4
.IX Item "perl"
.RE
.RS 4
.RE
.IP "Linking with C" 4
.IX Item "Linking with C"
.RS 4
.IP "perlxstut \- Tutorial for writing XSUBs" 4
.IX Item "perlxstut - Tutorial for writing XSUBs"
.IP "perlxs \- \s-1XS\s0 language reference manual" 4
.IX Item "perlxs - XS language reference manual"
.IP "perlcall \- Perl calling conventions from C" 4
.IX Item "perlcall - Perl calling conventions from C"
.IP "perlguts \- Introduction to the Perl \s-1API\s0" 4
.IX Item "perlguts - Introduction to the Perl API"
.IP "perlembed \- how to embed perl in your C program" 4
.IX Item "perlembed - how to embed perl in your C program"
.RE
.RS 4
.RE
.IP "Various" 4
.IX Item "Various"
.PD
<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>
(not a man-page but still useful, a collection of various essays on
Perl techniques)
.PP
A crude table of contents for the Perl manpage set is found in perltoc.
.SS "How can I use Perl interactively?"
.IX Subsection "How can I use Perl interactively?"
The typical approach uses the Perl debugger, described in the
\&\fIperldebug\fR\|(1) manpage, on an \*(L"empty\*(R" program, like this:
.PP
.Vb 1
\&    perl \-de 42
.Ve
.PP
Now just type in any legal Perl code, and it will be immediately
evaluated. You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.
.PP
You can also use Devel::REPL which is an interactive shell for Perl,
commonly known as a \s-1REPL \-\s0 Read, Evaluate, Print, Loop. It provides
various handy features.
.SS "How do I find which modules are installed on my system?"
.IX Subsection "How do I find which modules are installed on my system?"
From the command line, you can use the \f(CW\*(C`cpan\*(C'\fR command's \f(CW\*(C`\-l\*(C'\fR switch:
.PP
.Vb 1
\&    $ cpan \-l
.Ve
.PP
You can also use \f(CW\*(C`cpan\*(C'\fR's \f(CW\*(C`\-a\*(C'\fR switch to create an autobundle file
that \f(CW\*(C`CPAN.pm\*(C'\fR understands and can use to re-install every module:
.PP
.Vb 1
\&    $ cpan \-a
.Ve
.PP
Inside a Perl program, you can use the ExtUtils::Installed module to
show all installed distributions, although it can take awhile to do
its magic. The standard library which comes with Perl just shows up
as \*(L"Perl\*(R" (although you can get those with Module::CoreList).
.PP
.Vb 1
\&    use ExtUtils::Installed;
\&
\&    my $inst    = ExtUtils::Installed\->new();
\&    my @modules = $inst\->modules();
.Ve
.PP
If you want a list of all of the Perl module filenames, you
can use File::Find::Rule:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->
\&        extras({follow => 1})\->
\&        file()\->
\&        name( \*(Aq*.pm\*(Aq )\->
\&        in( @INC )
\&        ;
.Ve
.PP
If you do not have that module, you can do the same thing
with File::Find which is part of the standard library:
.PP
.Vb 2
\&    use File::Find;
\&    my @files;
\&
\&    find(
\&        {
\&        wanted => sub {
\&            push @files, $File::Find::fullname
\&            if \-f $File::Find::fullname && /\e.pm$/
\&        },
\&        follow => 1,
\&        follow_skip => 2,
\&        },
\&        @INC
\&    );
\&
\&    print join "\en", @files;
.Ve
.PP
If you simply need to check quickly to see if a module is
available, you can check for its documentation. If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases):
.PP
.Vb 1
\&    $ perldoc Module::Name
.Ve
.PP
You can also try to include the module in a one-liner to see if
perl finds it:
.PP
.Vb 1
\&    $ perl \-MModule::Name \-e1
.Ve
.PP
(If you don't receive a \*(L"Can't locate ... in \f(CW@INC\fR\*(R" error message, then Perl
found the module name you asked for.)
.SS "How do I debug my Perl programs?"
.IX Subsection "How do I debug my Perl programs?"
(contributed by brian d foy)
.PP
Before you do anything else, you can help yourself by ensuring that
you let Perl tell you about problem areas in your code. By turning
on warnings and strictures, you can head off many problems before
they get too big. You can find out more about these in strict
and warnings.
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.PP
Beyond that, the simplest debugger is the \f(CW\*(C`print\*(C'\fR function. Use it
to look at values as you run your program:
.PP
.Vb 1
\&    print STDERR "The value is [$value]\en";
.Ve
.PP
The Data::Dumper module can pretty-print Perl data structures:
.PP
.Vb 2
\&    use Data::Dumper qw( Dumper );
\&    print STDERR "The hash is " . Dumper( \e%hash ) . "\en";
.Ve
.PP
Perl comes with an interactive debugger, which you can start with the
\&\f(CW\*(C`\-d\*(C'\fR switch. It's fully explained in perldebug.
.PP
If you'd like a graphical user interface and you have Tk, you can use
\&\f(CW\*(C`ptkdb\*(C'\fR. It's on \s-1CPAN\s0 and available for free.
.PP
If you need something much more sophisticated and controllable, Leon
Brocard's Devel::ebug (which you can call with the \f(CW\*(C`\-D\*(C'\fR switch as \f(CW\*(C`\-Debug\*(C'\fR)
gives you the programmatic hooks into everything you need to write your
own (without too much pain and suffering).
.PP
You can also use a commercial debugger such as Affrus (Mac \s-1OS X\s0), Komodo
from Activestate (Windows and Mac \s-1OS X\s0), or \s-1EPIC \s0(most platforms).
.SS "How do I profile my Perl programs?"
.IX Subsection "How do I profile my Perl programs?"
(contributed by brian d foy, updated Fri Jul 25 12:22:26 \s-1PDT 2008\s0)
.PP
The \f(CW\*(C`Devel\*(C'\fR namespace has several modules which you can use to
profile your Perl programs.
.PP
The Devel::NYTProf (New York Times Profiler) does both statement
and subroutine profiling. It's available from \s-1CPAN\s0 and you also invoke
it with the \f(CW\*(C`\-d\*(C'\fR switch:
.PP
.Vb 1
\&    perl \-d:NYTProf some_perl.pl
.Ve
.PP
It creates a database of the profile information that you can turn into
reports. The \f(CW\*(C`nytprofhtml\*(C'\fR command turns the data into an \s-1HTML\s0 report
similar to the Devel::Cover report:
.PP
.Vb 1
\&    nytprofhtml
.Ve
.PP
You might also be interested in using the Benchmark to
measure and compare code snippets.
.PP
You can read more about profiling in \fIProgramming Perl\fR, chapter 20,
or \fIMastering Perl\fR, chapter 5.
.PP
perldebguts documents creating a custom debugger if you need to
create a special sort of profiler. brian d foy describes the process
in \fIThe Perl Journal\fR, \*(L"Creating a Perl Debugger\*(R",
<http://www.ddj.com/184404522> , and \*(L"Profiling in Perl\*(R"
<http://www.ddj.com/184404580> .
.PP
Perl.com has two interesting articles on profiling: \*(L"Profiling Perl\*(R",
by Simon Cozens, <http://www.perl.com/lpt/a/850> and \*(L"Debugging and
Profiling mod_perl Applications\*(R", by Frank Wiles,
<http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html> .
.PP
Randal L. Schwartz writes about profiling in \*(L"Speeding up Your Perl
Programs\*(R" for \fIUnix Review\fR,
<http://www.stonehenge.com/merlyn/UnixReview/col49.html> , and \*(L"Profiling
in Template Toolkit via Overriding\*(R" for \fILinux Magazine\fR,
<http://www.stonehenge.com/merlyn/LinuxMag/col75.html> .
.SS "How do I cross-reference my Perl programs?"
.IX Subsection "How do I cross-reference my Perl programs?"
The B::Xref module can be used to generate cross-reference reports
for Perl programs.
.PP
.Vb 1
\&    perl \-MO=Xref[,OPTIONS] scriptname.plx
.Ve
.SS "Is there a pretty-printer (formatter) for Perl?"
.IX Subsection "Is there a pretty-printer (formatter) for Perl?"
Perl::Tidy comes with a perl script perltidy which indents and
reformats Perl scripts to make them easier to read by trying to follow
the rules of the perlstyle. If you write Perl, or spend much time reading
Perl, you will probably find it useful.
.PP
Of course, if you simply follow the guidelines in perlstyle,
you shouldn't need to reformat. The habit of formatting your code
as you write it will help prevent bugs. Your editor can and should
help you with this. The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance. Tom Christiansen and many other \s-1VI\s0 users swear by
the following settings in vi and its clones:
.PP
.Vb 2
\&    set ai sw=4
\&    map! ^O {^M}^[O^T
.Ve
.PP
Put that in your \fI.exrc\fR file (replacing the caret characters
with control characters) and away you go. In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting\*(--as
it were. A more complete example, with comments, can be found at
<http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz>
.SS "Is there an \s-1IDE\s0 or Windows Perl Editor?"
.IX Subsection "Is there an IDE or Windows Perl Editor?"
Perl programs are just plain text, so any editor will do.
.PP
If you're on Unix, you already have an IDE\*(--Unix itself. The Unix
philosophy is the philosophy of several small tools that each do one
thing and do it well. It's like a carpenter's toolbox.
.PP
If you want an \s-1IDE,\s0 check the following (in alphabetical order, not
order of preference):
.IP "Eclipse" 4
.IX Item "Eclipse"
<http://e\-p\-i\-c.sf.net/>
.Sp
The Eclipse Perl Integration Project integrates Perl
editing/debugging with Eclipse.
.IP "Enginsite" 4
.IX Item "Enginsite"
<http://www.enginsite.com/>
.Sp
Perl Editor by EngInSite is a complete integrated development
environment (\s-1IDE\s0) for creating, testing, and  debugging  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.
.IP "Kephra" 4
.IX Item "Kephra"
<http://kephra.sf.net>
.Sp
\&\s-1GUI\s0 Editor written in Perl using wxWidgets and Scintilla with lots of smaller features.
Aims for an \s-1UI\s0 based on Perls principles like \s-1TIMTWTDI\s0 and \*(L"easy thinkd should be ..\*(R".
.IP "Komodo" 4
.IX Item "Komodo"
<http://www.ActiveState.com/Products/Komodo/>
.Sp
ActiveState's cross-platform (as of October 2004, that's Windows, Linux,
and Solaris), multi-language \s-1IDE\s0 has Perl support, including a regular expression
debugger and remote debugging.
.IP "Notepad++" 4
.IX Item "Notepad++"
<http://notepad\-plus.sourceforge.net/>
.IP "Open Perl \s-1IDE\s0" 4
.IX Item "Open Perl IDE"
<http://open\-perl\-ide.sourceforge.net/>
.Sp
Open Perl \s-1IDE\s0 is an integrated development environment for writing
and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.
.IP "OptiPerl" 4
.IX Item "OptiPerl"
<http://www.optiperl.com/>
.Sp
OptiPerl is a Windows \s-1IDE\s0 with simulated \s-1CGI\s0 environment, including
debugger and syntax-highlighting editor.
.IP "Padre" 4
.IX Item "Padre"
<http://padre.perlide.org/>
.Sp
Padre is cross-platform \s-1IDE\s0 for Perl written in Perl using wxWidgets to provide
a native look and feel. It's open source under the Artistic License. It
is one of the newer Perl IDEs.
.IP "PerlBuilder" 4
.IX Item "PerlBuilder"
<http://www.solutionsoft.com/perl.htm>
.Sp
PerlBuilder is an integrated development environment for Windows that
supports Perl development.
.IP "visiPerl+" 4
.IX Item "visiPerl+"
<http://helpconsulting.net/visiperl/index.html>
.Sp
From Help Consulting, for Windows.
.IP "Visual Perl" 4
.IX Item "Visual Perl"
<http://www.activestate.com/Products/Visual_Perl/>
.Sp
Visual Perl is a Visual Studio.NET plug-in from ActiveState.
.IP "Zeus" 4
.IX Item "Zeus"
<http://www.zeusedit.com/lookmain.html>
.Sp
Zeus for Windows is another Win32 multi-language editor/IDE
that comes with support for Perl.
.PP
For editors: if you're on Unix you probably have vi or a vi clone
already, and possibly an emacs too, so you may not need to download
anything. In any emacs the cperl-mode (M\-x cperl-mode) gives you
perhaps the best available Perl editing mode in any editor.
.PP
If you are using Windows, you can use any editor that lets you work
with plain text, such as NotePad or WordPad. Word processors, such as
Microsoft Word or WordPerfect, typically do not work since they insert
all sorts of behind-the-scenes information, although some allow you to
save files as \*(L"Text Only\*(R". You can also download text editors designed
specifically for programming, such as Textpad (
<http://www.textpad.com/> ) and UltraEdit ( <http://www.ultraedit.com/> ),
among others.
.PP
If you are using MacOS, the same concerns apply. MacPerl (for Classic
environments) comes with a simple editor. Popular external editors are
BBEdit ( <http://www.bbedit.com/> ) or Alpha (
<http://www.his.com/~jguyer/Alpha/Alpha8.html> ). MacOS X users can use
Unix editors as well.
.IP "\s-1GNU\s0 Emacs" 4
.IX Item "GNU Emacs"
<http://www.gnu.org/software/emacs/windows/ntemacs.html>
.IP "MicroEMACS" 4
.IX Item "MicroEMACS"
<http://www.microemacs.de/>
.IP "XEmacs" 4
.IX Item "XEmacs"
<http://www.xemacs.org/Download/index.html>
.IP "Jed" 4
.IX Item "Jed"
<http://space.mit.edu/~davis/jed/>
.PP
or a vi clone such as
.IP "Vim" 4
.IX Item "Vim"
<http://www.vim.org/>
.IP "Vile" 4
.IX Item "Vile"
<http://dickey.his.com/vile/vile.html>
.PP
The following are Win32 multilanguage editor/IDEs that support Perl:
.IP "Codewright" 4
.IX Item "Codewright"
<http://www.borland.com/codewright/>
.IP "MultiEdit" 4
.IX Item "MultiEdit"
<http://www.MultiEdit.com/>
.IP "SlickEdit" 4
.IX Item "SlickEdit"
<http://www.slickedit.com/>
.IP "ConTEXT" 4
.IX Item "ConTEXT"
<http://www.contexteditor.org/>
.PP
There is also a toyedit Text widget based editor written in Perl
that is distributed with the Tk module on \s-1CPAN.\s0 The ptkdb
( <http://ptkdb.sourceforge.net/> ) is a Perl/Tk\-based debugger that
acts as a development environment of sorts. Perl Composer
( <http://perlcomposer.sourceforge.net/> ) is an \s-1IDE\s0 for Perl/Tk
\&\s-1GUI\s0 creation.
.PP
In addition to an editor/IDE you might be interested in a more
powerful shell environment for Win32. Your options include
.IP "Bash" 4
.IX Item "Bash"
from the Cygwin package ( <http://sources.redhat.com/cygwin/> )
.IP "Ksh" 4
.IX Item "Ksh"
from the \s-1MKS\s0 Toolkit ( <http://www.mkssoftware.com/> ), or the Bourne shell of
the U/WIN environment ( <http://www.research.att.com/sw/tools/uwin/> )
.IP "Tcsh" 4
.IX Item "Tcsh"
<ftp://ftp.astron.com/pub/tcsh/> , see also
<http://www.primate.wisc.edu/software/csh\-tcsh\-book/>
.IP "Zsh" 4
.IX Item "Zsh"
<http://www.zsh.org/>
.PP
\&\s-1MKS\s0 and U/WIN are commercial (U/WIN is free for educational and
research purposes), Cygwin is covered by the \s-1GNU\s0 General Public
License (but that shouldn't matter for Perl use). The Cygwin, \s-1MKS,\s0
and U/WIN all contain (in addition to the shells) a comprehensive set
of standard Unix toolkit utilities.
.PP
If you're transferring text files between Unix and Windows using \s-1FTP\s0
be sure to transfer them in \s-1ASCII\s0 mode so the ends of lines are
appropriately converted.
.PP
On Mac \s-1OS\s0 the MacPerl Application comes with a simple 32k text editor
that behaves like a rudimentary \s-1IDE.\s0 In contrast to the MacPerl Application
the \s-1MPW\s0 Perl tool can make use of the \s-1MPW\s0 Shell itself as an editor (with
no 32k limit).
.IP "Affrus" 4
.IX Item "Affrus"
is a full Perl development environment with full debugger support
( <http://www.latenightsw.com> ).
.IP "Alpha" 4
.IX Item "Alpha"
is an editor, written and extensible in Tcl, that nonetheless has
built-in support for several popular markup and programming languages,
including Perl and \s-1HTML \s0( <http://www.his.com/~jguyer/Alpha/Alpha8.html> ).
.IP "BBEdit and BBEdit Lite" 4
.IX Item "BBEdit and BBEdit Lite"
are text editors for Mac \s-1OS\s0 that have a Perl sensitivity mode
( <http://web.barebones.com/> ).
.SS "Where can I get Perl macros for vi?"
.IX Subsection "Where can I get Perl macros for vi?"
For a complete version of Tom Christiansen's vi configuration file,
see <http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz> ,
the standard benchmark file for vi emulators. The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter\*(--see <http://www.cpan.org/src/misc/> .
.SS "Where can I get perl-mode or cperl-mode for emacs?"
.IX Xref "emacs"
.IX Subsection "Where can I get perl-mode or cperl-mode for emacs?"
Since Emacs version 19 patchlevel 22 or so, there have been both a
perl\-mode.el and support for the Perl debugger built in. These should
come with the standard Emacs 19 distribution.
.PP
Note that the perl-mode of emacs will have fits with \f(CW"main\*(Aqfoo"\fR
(single quote), and mess up the indentation and highlighting. You
are probably using \f(CW"main::foo"\fR in new Perl code anyway, so this
shouldn't be an issue.
.PP
For CPerlMode, see <http://www.emacswiki.org/cgi\-bin/wiki/CPerlMode>
.SS "How can I use curses with Perl?"
.IX Subsection "How can I use curses with Perl?"
The Curses module from \s-1CPAN\s0 provides a dynamically loadable object
module interface to a curses library. A small demo can be found at the
directory <http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz> ;
this program repeats a command and updates the screen as needed, rendering
\&\fBrep ps axu\fR similar to \fBtop\fR.
.SS "How can I write a \s-1GUI \s0(X, Tk, Gtk, etc.) in Perl?"
.IX Xref "GUI Tk Wx WxWidgets Gtk Gtk2 CamelBones Qt"
.IX Subsection "How can I write a GUI (X, Tk, Gtk, etc.) in Perl?"
(contributed by Ben Morrow)
.PP
There are a number of modules which let you write GUIs in Perl. Most
\&\s-1GUI\s0 toolkits have a perl interface: an incomplete list follows.
.IP "Tk" 4
.IX Item "Tk"
This works under Unix and Windows, and the current version doesn't
look half as bad under Windows as it used to. Some of the gui elements
still don't 'feel' quite right, though. The interface is very natural
and 'perlish', making it easy to use in small scripts that just need a
simple gui. It hasn't been updated in a while.
.IP "Wx" 4
.IX Item "Wx"
This is a Perl binding for the cross-platform wxWidgets toolkit
( <http://www.wxwidgets.org> ). It works under Unix, Win32 and Mac \s-1OS X,\s0
using native widgets (Gtk under Unix). The interface follows the \*(C+
interface closely, but the documentation is a little sparse for someone
who doesn't know the library, mostly just referring you to the \*(C+
documentation.
.IP "Gtk and Gtk2" 4
.IX Item "Gtk and Gtk2"
These are Perl bindings for the Gtk toolkit ( <http://www.gtk.org> ). The
interface changed significantly between versions 1 and 2 so they have
separate Perl modules. It runs under Unix, Win32 and Mac \s-1OS X \s0(currently
it requires an X server on Mac \s-1OS,\s0 but a 'native' port is underway), and
the widgets look the same on every platform: i.e., they don't match the
native widgets. As with Wx, the Perl bindings follow the C \s-1API\s0 closely,
and the documentation requires you to read the C documentation to
understand it.
.IP "Win32::GUI" 4
.IX Item "Win32::GUI"
This provides access to most of the Win32 \s-1GUI\s0 widgets from Perl.
Obviously, it only runs under Win32, and uses native widgets. The Perl
interface doesn't really follow the C interface: it's been made more
Perlish, and the documentation is pretty good. More advanced stuff may
require familiarity with the C Win32 APIs, or reference to \s-1MSDN.\s0
.IP "CamelBones" 4
.IX Item "CamelBones"
CamelBones ( <http://camelbones.sourceforge.net> ) is a Perl interface to
Mac \s-1OS X\s0's Cocoa \s-1GUI\s0 toolkit, and as such can be used to produce native
GUIs on Mac \s-1OS X.\s0 It's not on \s-1CPAN,\s0 as it requires frameworks that
\&\s-1CPAN\s0.pm doesn't know how to install, but installation is via the
standard \s-1OSX\s0 package installer. The Perl \s-1API\s0 is, again, very close to
the ObjC \s-1API\s0 it's wrapping, and the documentation just tells you how to
translate from one to the other.
.IP "Qt" 4
.IX Item "Qt"
There is a Perl interface to TrollTech's Qt toolkit, but it does not
appear to be maintained.
.IP "Athena" 4
.IX Item "Athena"
Sx is an interface to the Athena widget set which comes with X, but
again it appears not to be much used nowadays.
.SS "How can I make my Perl program run faster?"
.IX Subsection "How can I make my Perl program run faster?"
The best way to do this is to come up with a better algorithm. This
can often make a dramatic difference. Jon Bentley's book
\&\fIProgramming Pearls\fR (that's not a misspelling!)  has some good tips
on optimization, too. Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware. You will probably want to
read the answer to the earlier question \*(L"How do I profile my Perl
programs?\*(R" if you haven't done so already.
.PP
A different approach is to autoload seldom-used Perl code. See the
AutoSplit and AutoLoader modules in the standard distribution for
that. Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler. Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the \s-1PDL\s0 module
from \s-1CPAN\s0).
.PP
If you're currently linking your perl executable to a shared
\&\fIlibc.so\fR, you can often gain a 10\-25% performance benefit by
rebuilding it to link with a static libc.a instead. This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it. See the \fI\s-1INSTALL\s0\fR file in the source distribution
for more information.
.PP
The undump program was an ancient attempt to speed up Perl program by
storing the already-compiled form to disk. This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.
.SS "How can I make my Perl program take less memory?"
.IX Subsection "How can I make my Perl program take less memory?"
When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem. Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more. While
there's still a lot to be done, recent releases have been addressing
these issues. For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.
.PP
In some cases, using \fIsubstr()\fR or \fIvec()\fR to simulate arrays can be
highly beneficial. For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125\-byte bit vector\*(--a considerable memory savings. The standard
Tie::SubstrHash module can also help for certain types of data
structure. If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.
.PP
Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc. Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the \fI\s-1INSTALL\s0\fR file in the source
distribution. You can find out whether you are using perl's malloc by
typing \f(CW\*(C`perl \-V:usemymalloc\*(C'\fR.
.PP
Of course, the best way to save memory is to not do anything to waste
it in the first place. Good programming practices can go a long way
toward this:
.IP "Don't slurp!" 4
.IX Item "Don't slurp!"
Don't read an entire file into memory if you can process it line
by line. Or more concretely, use a loop like this:
.Sp
.Vb 6
\&    #
\&    # Good Idea
\&    #
\&    while (my $line = <$file_handle>) {
\&       # ...
\&    }
.Ve
.Sp
instead of this:
.Sp
.Vb 7
\&    #
\&    # Bad Idea
\&    #
\&    my @data = <$file_handle>;
\&    foreach (@data) {
\&        # ...
\&    }
.Ve
.Sp
When the files you're processing are small, it doesn't much matter which
way you do it, but it makes a huge difference when they start getting
larger.
.IP "Use map and grep selectively" 4
.IX Item "Use map and grep selectively"
Remember that both map and grep expect a \s-1LIST\s0 argument, so doing this:
.Sp
.Vb 1
\&        @wanted = grep {/pattern/} <$file_handle>;
.Ve
.Sp
will cause the entire file to be slurped. For large files, it's better
to loop:
.Sp
.Vb 3
\&        while (<$file_handle>) {
\&                push(@wanted, $_) if /pattern/;
\&        }
.Ve
.IP "Avoid unnecessary quotes and stringification" 4
.IX Item "Avoid unnecessary quotes and stringification"
Don't quote large strings unless absolutely necessary:
.Sp
.Vb 1
\&        my $copy = "$large_string";
.Ve
.Sp
makes 2 copies of \f(CW$large_string\fR (one for \f(CW$copy\fR and another for the
quotes), whereas
.Sp
.Vb 1
\&        my $copy = $large_string;
.Ve
.Sp
only makes one copy.
.Sp
Ditto for stringifying large arrays:
.Sp
.Vb 4
\&    {
\&    local $, = "\en";
\&    print @big_array;
\&    }
.Ve
.Sp
is much more memory-efficient than either
.Sp
.Vb 1
\&    print join "\en", @big_array;
.Ve
.Sp
or
.Sp
.Vb 4
\&    {
\&    local $" = "\en";
\&    print "@big_array";
\&    }
.Ve
.IP "Pass by reference" 4
.IX Item "Pass by reference"
Pass arrays and hashes by reference, not by value. For one thing, it's
the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgement, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.
.IP "Tie large variables to disk" 4
.IX Item "Tie large variables to disk"
For \*(L"big\*(R" data stores (i.e. ones that exceed available memory) consider
using one of the \s-1DB\s0 modules to store it on disk instead of in \s-1RAM.\s0 This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.
.SS "Is it safe to return a reference to local or lexical data?"
.IX Subsection "Is it safe to return a reference to local or lexical data?"
Yes. Perl's garbage collection system takes care of this so
everything works out right.
.PP
.Vb 4
\&    sub makeone {
\&        my @a = ( 1 .. 10 );
\&        return \e@a;
\&    }
\&
\&    for ( 1 .. 10 ) {
\&        push @many, makeone();
\&    }
\&
\&    print $many[4][5], "\en";
\&
\&    print "@many\en";
.Ve
.SS "How can I free an array or hash so my program shrinks?"
.IX Subsection "How can I free an array or hash so my program shrinks?"
(contributed by Michael Carman)
.PP
You usually can't. Memory allocated to lexicals (i.e. \fImy()\fR variables)
cannot be reclaimed or reused even if they go out of scope. It is
reserved in case the variables come back into scope. Memory allocated
to global variables can be reused (within your program) by using
\&\fIundef()\fR and/or \fIdelete()\fR.
.PP
On most operating systems, memory allocated to a program can never be
returned to the system. That's why long-running programs sometimes re\-
exec themselves. Some operating systems (notably, systems that use
\&\fImmap\fR\|(2) for allocating large chunks of memory) can reclaim memory that
is no longer used, but on such systems, perl must be configured and
compiled to use the \s-1OS\s0's malloc, not perl's.
.PP
In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl.
.PP
See also \*(L"How can I make my Perl program take less memory?\*(R"
.SS "How can I make my \s-1CGI\s0 script more efficient?"
.IX Subsection "How can I make my CGI script more efficient?"
Beyond the normal measures described to make general Perl programs
faster or smaller, a \s-1CGI\s0 program has additional issues. It may be run
several times per second. Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer. Compiling into C \fBisn't going to help
you\fR because the process start-up overhead is where the bottleneck is.
.PP
There are three popular ways to avoid this overhead. One solution
involves running the Apache \s-1HTTP\s0 server (available from
<http://www.apache.org/> ) with either of the mod_perl or mod_fastcgi
plugin modules.
.PP
With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking. The Apache extension also gives Perl access to
the internal server \s-1API,\s0 so modules written in Perl can do just about
anything a module written in C can. For more on mod_perl, see
<http://perl.apache.org/>
.PP
With the \s-1FCGI\s0 module (from \s-1CPAN\s0) and the mod_fastcgi
module (available from <http://www.fastcgi.com/> ) each of your Perl
programs becomes a permanent \s-1CGI\s0 daemon process.
.PP
Finally, Plack is a Perl module and toolkit that contains \s-1PSGI\s0 middleware,
helpers and adapters to web servers, allowing you to easily deploy scripts which
can continue running, and provides flexibility with regards to which web server
you use. It can allow existing \s-1CGI\s0 scripts to enjoy this flexibility and
performance with minimal changes, or can be used along with modern Perl web
frameworks to make writing and deploying web services with Perl a breeze.
.PP
These solutions can have far-reaching effects on your system and on the way you
write your \s-1CGI\s0 programs, so investigate them with care.
.PP
See also
<http://www.cpan.org/modules/by\-category/15_World_Wide_Web_HTML_HTTP_CGI/> .
.SS "How can I hide the source for my Perl program?"
.IX Subsection "How can I hide the source for my Perl program?"
Delete it. :\-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, because
the source code has to be readable in order to be compiled and
interpreted. (That doesn't mean that a \s-1CGI\s0 script's source is
readable by people on the web, though\*(--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.
.PP
Some people regard this as a security problem. If your program does
insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure. It is often possible for someone to
determine the insecure things and exploit them without viewing the
source. Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.
.PP
You can try using encryption via source filters (Starting from Perl
5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it. You can try using the byte code compiler and interpreter
described later in perlfaq3, but the curious might still be able to
de-compile it. You can try using the native-code compiler described
later, but crackers might be able to disassemble it. These pose
varying degrees of difficulty to people wanting to get at your code,
but none can definitively conceal it (true of every language, not just
Perl).
.PP
It is very easy to recover the source of Perl programs. You simply
feed the program to the perl interpreter and use the modules in
the B:: hierarchy. The B::Deparse module should be able to
defeat most attempts to hide source. Again, this is not
unique to Perl.
.PP
If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security. License your software and pepper it with threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Your access to it does not give you permission to use it blah blah
blah.\*(R"  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.
.SS "How can I compile my Perl program into byte code or C?"
.IX Subsection "How can I compile my Perl program into byte code or C?"
(contributed by brian d foy)
.PP
In general, you can't do this. There are some things that may work
for your situation though. People usually ask this question
because they want to distribute their works without giving away
the source code, and most solutions trade disk space for convenience.
You probably won't see much of a speed increase either, since most
solutions simply bundle a Perl interpreter in the final product
(but see \*(L"How can I make my Perl program run faster?\*(R").
.PP
The Perl Archive Toolkit ( <http://par.perl.org/> ) is Perl's
analog to Java's \s-1JAR.\s0 It's freely available and on \s-1CPAN \s0(
<http://search.cpan.org/dist/PAR/> ).
.PP
There are also some commercial products that may work for you, although
you have to buy a license for them.
.PP
The Perl Dev Kit ( <http://www.activestate.com/Products/Perl_Dev_Kit/> )
from ActiveState can \*(L"Turn your Perl programs into ready-to-run
executables for HP-UX, Linux, Solaris and Windows.\*(R"
.PP
Perl2Exe ( <http://www.indigostar.com/perl2exe.htm> ) is a command line
program for converting perl scripts to executable files. It targets both
Windows and Unix platforms.
.ie n .SS "How can I get ""#!perl"" to work on [\s-1MS\-DOS,NT,...\s0]?"
.el .SS "How can I get \f(CW#!perl\fP to work on [\s-1MS\-DOS,NT,...\s0]?"
.IX Subsection "How can I get #!perl to work on [MS-DOS,NT,...]?"
For \s-1OS/2\s0 just use
.PP
.Vb 1
\&    extproc perl \-S \-your_switches
.Ve
.PP
as the first line in \f(CW\*(C`*.cmd\*(C'\fR file (\f(CW\*(C`\-S\*(C'\fR due to a bug in cmd.exe's
\&\*(L"extproc\*(R" handling). For \s-1DOS\s0 one should first invent a corresponding
batch file and codify it in \f(CW\*(C`ALTERNATE_SHEBANG\*(C'\fR (see the
\&\fIdosish.h\fR file in the source distribution for more information).
.PP
The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the \f(CW\*(C`.pl\*(C'\fR extension with the
perl interpreter. If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself. In addition to associating \f(CW\*(C`.pl\*(C'\fR with the
interpreter, \s-1NT\s0 people can use: \f(CW\*(C`SET PATHEXT=%PATHEXT%;.PL\*(C'\fR to let them
run the program \f(CW\*(C`install\-linux.pl\*(C'\fR merely by typing \f(CW\*(C`install\-linux\*(C'\fR.
.PP
Under \*(L"Classic\*(R" MacOS, a perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the MacPerl application.
Under Mac \s-1OS X,\s0 clickable apps can be made from any \f(CW\*(C`#!\*(C'\fR script using Wil
Sanchez' DropScript utility: <http://www.wsanchez.net/software/> .
.PP
\&\fI\s-1IMPORTANT\s0!\fR: Whatever you do, \s-1PLEASE\s0 don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server. This is an \s-1EXTREMELY\s0 big
security risk. Take the time to figure out how to do it correctly.
.SS "Can I write useful Perl programs on the command line?"
.IX Subsection "Can I write useful Perl programs on the command line?"
Yes. Read perlrun for more information. Some examples follow.
(These assume standard Unix shell quoting rules.)
.PP
.Vb 2
\&    # sum first and last fields
\&    perl \-lane \*(Aqprint $F[0] + $F[\-1]\*(Aq *
\&
\&    # identify text files
\&    perl \-le \*(Aqfor(@ARGV) {print if \-f && \-T _}\*(Aq *
\&
\&    # remove (most) comments from C program
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
\&
\&    # make file a month younger than today, defeating reaper daemons
\&    perl \-e \*(Aq$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)\*(Aq *
\&
\&    # find first unused uid
\&    perl \-le \*(Aq$i++ while getpwuid($i); print $i\*(Aq
\&
\&    # display reasonable manpath
\&    echo $PATH | perl \-nl \-072 \-e \*(Aq
\&    s![^/+]*$!man!&&\-d&&!$s{$_}++&&push@m,$_;END{print"@m"}\*(Aq
.Ve
.PP
\&\s-1OK,\s0 the last one was actually an Obfuscated Perl Contest entry. :\-)
.SS "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
.IX Subsection "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created. On some systems, you may have to
change single-quotes to double ones, which you must \fI\s-1NOT\s0\fR do on Unix
or Plan9 systems. You might also have to change a single % to a %%.
.PP
For example:
.PP
.Vb 2
\&    # Unix (including Mac OS X)
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # DOS, etc.
\&    perl \-e "print \e"Hello world\en\e""
\&
\&    # Mac Classic
\&    print "Hello world\en"
\&     (then Run "Myscript" or Shift\-Command\-R)
\&
\&    # MPW
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # VMS
\&    perl \-e "print ""Hello world\en"""
.Ve
.PP
The problem is that none of these examples are reliable: they depend on the
command interpreter. Under Unix, the first two often work. Under \s-1DOS,\s0
it's entirely possible that neither works. If 4DOS was the command shell,
you'd probably have better luck like this:
.PP
.Vb 1
\&  perl \-e "print <Ctrl\-x>"Hello world\en<Ctrl\-x>""
.Ve
.PP
Under the Mac, it depends which environment you are using. The MacPerl
shell, or \s-1MPW,\s0 is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.
.PP
Using \fIqq()\fR, q(), and \fIqx()\fR, instead of \*(L"double quotes\*(R", 'single
quotes', and `backticks`, may make one-liners easier to write.
.PP
There is no general solution to all of this. It is a mess.
.PP
[Some of this answer was contributed by Kenneth Albanowski.]
.SS "Where can I learn about \s-1CGI\s0 or Web programming in Perl?"
.IX Subsection "Where can I learn about CGI or Web programming in Perl?"
For modules, get the \s-1CGI\s0 or \s-1LWP\s0 modules from \s-1CPAN.\s0 For textbooks,
see the two especially dedicated to web stuff in the question on
books. For problems and questions related to the web, like \*(L"Why
do I get 500 Errors\*(R" or \*(L"Why doesn't it run from the browser right
when it runs fine on the command line\*(R", see the troubleshooting
guides and references in perlfaq9 or in the \s-1CGI\s0 MetaFAQ:
.PP
.Vb 1
\&    L<http://www.perl.org/CGI_MetaFAQ.html>
.Ve
.PP
Looking in to Plack and modern Perl web frameworks is highly recommended,
though; web programming in Perl has evolved a long way from the old days of
simple \s-1CGI\s0 scripts.
.SS "Where can I learn about object-oriented Perl programming?"
.IX Subsection "Where can I learn about object-oriented Perl programming?"
A good place to start is perltoot, and you can use perlobj,
perlboot, perltoot, perltooc, and perlbot for reference.
.PP
A good book on \s-1OO\s0 on Perl is the \*(L"Object-Oriented Perl\*(R"
by Damian Conway from Manning Publications, or \*(L"Intermediate Perl\*(R"
by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.
.SS "Where can I learn about linking C with Perl?"
.IX Subsection "Where can I learn about linking C with Perl?"
If you want to call C from Perl, start with perlxstut,
moving on to perlxs, xsubpp, and perlguts. If you want to
call Perl from C, then read perlembed, perlcall, and
perlguts. Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.
.PP
You might not need all the power of \s-1XS.\s0 The Inline::C module lets
you put C code directly in your Perl source. It handles all the
magic to make it work. You still have to learn at least some of
the perl \s-1API\s0 but you won't have to deal with the complexity of the
\&\s-1XS\s0 support files.
.SS "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
.IX Subsection "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
Download the ExtUtils::Embed kit from \s-1CPAN\s0 and run `make test'. If
the tests pass, read the pods again and again and again. If they
fail, see perlbug and send a bug report with the output of
\&\f(CW\*(C`make test TEST_VERBOSE=1\*(C'\fR along with \f(CW\*(C`perl \-V\*(C'\fR.
.SS "When I tried to run my script, I got this message. What does it mean?"
.IX Subsection "When I tried to run my script, I got this message. What does it mean?"
A complete list of Perl's error messages and warnings with explanatory
text can be found in perldiag. You can also use the splain program
(distributed with Perl) to explain the error messages:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [\-v] [\-p] diag.out
.Ve
.PP
or change your program to explain the messages for you:
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
or
.PP
.Vb 1
\&    use diagnostics \-verbose;
.Ve
.SS "What's MakeMaker?"
.IX Subsection "What's MakeMaker?"
(contributed by brian d foy)
.PP
The ExtUtils::MakeMaker module, better known simply as \*(L"MakeMaker\*(R",
turns a Perl script, typically called \f(CW\*(C`Makefile.PL\*(C'\fR, into a Makefile.
The Unix tool \f(CW\*(C`make\*(C'\fR uses this file to manage dependencies and actions
to process and install a Perl distribution.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq35.16.1                               0100644 0001750 0001750 00000140017 12566207416 022773  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ3 1"
.TH PERLFAQ3 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq3 \- Programming Tools
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to programmer tools
and programming support.
.SS "How do I do (anything)?"
.IX Subsection "How do I do (anything)?"
Have you looked at \s-1CPAN\s0 (see perlfaq2)? The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate manpages? Here's a brief index:
.IP "Basics" 4
.IX Item "Basics"
.RS 4
.PD 0
.IP "perldata \- Perl data types" 4
.IX Item "perldata - Perl data types"
.IP "perlvar \- Perl pre-defined variables" 4
.IX Item "perlvar - Perl pre-defined variables"
.IP "perlsyn \- Perl syntax" 4
.IX Item "perlsyn - Perl syntax"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perlsub \- Perl subroutines" 4
.IX Item "perlsub - Perl subroutines"
.RE
.RS 4
.RE
.IP "Execution" 4
.IX Item "Execution"
.RS 4
.IP "perlrun \- how to execute the Perl interpreter" 4
.IX Item "perlrun - how to execute the Perl interpreter"
.IP "perldebug \- Perl debugging" 4
.IX Item "perldebug - Perl debugging"
.RE
.RS 4
.RE
.IP "Functions" 4
.IX Item "Functions"
.RS 4
.IP "perlfunc \- Perl builtin functions" 4
.IX Item "perlfunc - Perl builtin functions"
.RE
.RS 4
.RE
.IP "Objects" 4
.IX Item "Objects"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlobj \- Perl objects" 4
.IX Item "perlobj - Perl objects"
.IP "perltie \- how to hide an object class in a simple variable" 4
.IX Item "perltie - how to hide an object class in a simple variable"
.RE
.RS 4
.RE
.IP "Data Structures" 4
.IX Item "Data Structures"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perllol \- Manipulating arrays of arrays in Perl" 4
.IX Item "perllol - Manipulating arrays of arrays in Perl"
.IP "perldsc \- Perl Data Structures Cookbook" 4
.IX Item "perldsc - Perl Data Structures Cookbook"
.RE
.RS 4
.RE
.IP "Modules" 4
.IX Item "Modules"
.RS 4
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlmodlib \- constructing new Perl modules and finding existing ones" 4
.IX Item "perlmodlib - constructing new Perl modules and finding existing ones"
.RE
.RS 4
.RE
.IP "Regexes" 4
.IX Item "Regexes"
.RS 4
.IP "perlre \- Perl regular expressions" 4
.IX Item "perlre - Perl regular expressions"
.IP "perlfunc \- Perl builtin functions>" 4
.IX Item "perlfunc - Perl builtin functions>"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perllocale \- Perl locale handling (internationalization and localization)" 4
.IX Item "perllocale - Perl locale handling (internationalization and localization)"
.RE
.RS 4
.RE
.IP "Moving to perl5" 4
.IX Item "Moving to perl5"
.RS 4
.IP "perltrap \- Perl traps for the unwary" 4
.IX Item "perltrap - Perl traps for the unwary"
.IP "perl" 4
.IX Item "perl"
.RE
.RS 4
.RE
.IP "Linking with C" 4
.IX Item "Linking with C"
.RS 4
.IP "perlxstut \- Tutorial for writing XSUBs" 4
.IX Item "perlxstut - Tutorial for writing XSUBs"
.IP "perlxs \- \s-1XS\s0 language reference manual" 4
.IX Item "perlxs - XS language reference manual"
.IP "perlcall \- Perl calling conventions from C" 4
.IX Item "perlcall - Perl calling conventions from C"
.IP "perlguts \- Introduction to the Perl \s-1API\s0" 4
.IX Item "perlguts - Introduction to the Perl API"
.IP "perlembed \- how to embed perl in your C program" 4
.IX Item "perlembed - how to embed perl in your C program"
.RE
.RS 4
.RE
.IP "Various" 4
.IX Item "Various"
.PD
<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>
(not a man-page but still useful, a collection of various essays on
Perl techniques)
.PP
A crude table of contents for the Perl manpage set is found in perltoc.
.SS "How can I use Perl interactively?"
.IX Subsection "How can I use Perl interactively?"
The typical approach uses the Perl debugger, described in the
\&\fIperldebug\fR\|(1) manpage, on an \*(L"empty\*(R" program, like this:
.PP
.Vb 1
\&    perl \-de 42
.Ve
.PP
Now just type in any legal Perl code, and it will be immediately
evaluated. You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.
.PP
You can also use Devel::REPL which is an interactive shell for Perl,
commonly known as a \s-1REPL\s0 \- Read, Evaluate, Print, Loop. It provides
various handy features.
.SS "How do I find which modules are installed on my system?"
.IX Subsection "How do I find which modules are installed on my system?"
From the command line, you can use the \f(CW\*(C`cpan\*(C'\fR command's \f(CW\*(C`\-l\*(C'\fR switch:
.PP
.Vb 1
\&    $ cpan \-l
.Ve
.PP
You can also use \f(CW\*(C`cpan\*(C'\fR's \f(CW\*(C`\-a\*(C'\fR switch to create an autobundle file
that \f(CW\*(C`CPAN.pm\*(C'\fR understands and can use to re-install every module:
.PP
.Vb 1
\&    $ cpan \-a
.Ve
.PP
Inside a Perl program, you can use the ExtUtils::Installed module to
show all installed distributions, although it can take awhile to do
its magic. The standard library which comes with Perl just shows up
as \*(L"Perl\*(R" (although you can get those with Module::CoreList).
.PP
.Vb 1
\&    use ExtUtils::Installed;
\&
\&    my $inst    = ExtUtils::Installed\->new();
\&    my @modules = $inst\->modules();
.Ve
.PP
If you want a list of all of the Perl module filenames, you
can use File::Find::Rule:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->
\&        extras({follow => 1})\->
\&        file()\->
\&        name( \*(Aq*.pm\*(Aq )\->
\&        in( @INC )
\&        ;
.Ve
.PP
If you do not have that module, you can do the same thing
with File::Find which is part of the standard library:
.PP
.Vb 2
\&    use File::Find;
\&    my @files;
\&
\&    find(
\&        {
\&        wanted => sub {
\&            push @files, $File::Find::fullname
\&            if \-f $File::Find::fullname && /\e.pm$/
\&        },
\&        follow => 1,
\&        follow_skip => 2,
\&        },
\&        @INC
\&    );
\&
\&    print join "\en", @files;
.Ve
.PP
If you simply need to check quickly to see if a module is
available, you can check for its documentation. If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases):
.PP
.Vb 1
\&    $ perldoc Module::Name
.Ve
.PP
You can also try to include the module in a one-liner to see if
perl finds it:
.PP
.Vb 1
\&    $ perl \-MModule::Name \-e1
.Ve
.PP
(If you don't receive a \*(L"Can't locate ... in \f(CW@INC\fR\*(R" error message, then Perl
found the module name you asked for.)
.SS "How do I debug my Perl programs?"
.IX Subsection "How do I debug my Perl programs?"
(contributed by brian d foy)
.PP
Before you do anything else, you can help yourself by ensuring that
you let Perl tell you about problem areas in your code. By turning
on warnings and strictures, you can head off many problems before
they get too big. You can find out more about these in strict
and warnings.
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.PP
Beyond that, the simplest debugger is the \f(CW\*(C`print\*(C'\fR function. Use it
to look at values as you run your program:
.PP
.Vb 1
\&    print STDERR "The value is [$value]\en";
.Ve
.PP
The Data::Dumper module can pretty-print Perl data structures:
.PP
.Vb 2
\&    use Data::Dumper qw( Dumper );
\&    print STDERR "The hash is " . Dumper( \e%hash ) . "\en";
.Ve
.PP
Perl comes with an interactive debugger, which you can start with the
\&\f(CW\*(C`\-d\*(C'\fR switch. It's fully explained in perldebug.
.PP
If you'd like a graphical user interface and you have Tk, you can use
\&\f(CW\*(C`ptkdb\*(C'\fR. It's on \s-1CPAN\s0 and available for free.
.PP
If you need something much more sophisticated and controllable, Leon
Brocard's Devel::ebug (which you can call with the \f(CW\*(C`\-D\*(C'\fR switch as \f(CW\*(C`\-Debug\*(C'\fR)
gives you the programmatic hooks into everything you need to write your
own (without too much pain and suffering).
.PP
You can also use a commercial debugger such as Affrus (Mac \s-1OS\s0 X), Komodo
from Activestate (Windows and Mac \s-1OS\s0 X), or \s-1EPIC\s0 (most platforms).
.SS "How do I profile my Perl programs?"
.IX Subsection "How do I profile my Perl programs?"
(contributed by brian d foy, updated Fri Jul 25 12:22:26 \s-1PDT\s0 2008)
.PP
The \f(CW\*(C`Devel\*(C'\fR namespace has several modules which you can use to
profile your Perl programs.
.PP
The Devel::NYTProf (New York Times Profiler) does both statement
and subroutine profiling. It's available from \s-1CPAN\s0 and you also invoke
it with the \f(CW\*(C`\-d\*(C'\fR switch:
.PP
.Vb 1
\&    perl \-d:NYTProf some_perl.pl
.Ve
.PP
It creates a database of the profile information that you can turn into
reports. The \f(CW\*(C`nytprofhtml\*(C'\fR command turns the data into an \s-1HTML\s0 report
similar to the Devel::Cover report:
.PP
.Vb 1
\&    nytprofhtml
.Ve
.PP
You might also be interested in using the Benchmark to
measure and compare code snippets.
.PP
You can read more about profiling in \fIProgramming Perl\fR, chapter 20,
or \fIMastering Perl\fR, chapter 5.
.PP
perldebguts documents creating a custom debugger if you need to
create a special sort of profiler. brian d foy describes the process
in \fIThe Perl Journal\fR, \*(L"Creating a Perl Debugger\*(R",
<http://www.ddj.com/184404522> , and \*(L"Profiling in Perl\*(R"
<http://www.ddj.com/184404580> .
.PP
Perl.com has two interesting articles on profiling: \*(L"Profiling Perl\*(R",
by Simon Cozens, <http://www.perl.com/lpt/a/850> and \*(L"Debugging and
Profiling mod_perl Applications\*(R", by Frank Wiles,
<http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html> .
.PP
Randal L. Schwartz writes about profiling in \*(L"Speeding up Your Perl
Programs\*(R" for \fIUnix Review\fR,
<http://www.stonehenge.com/merlyn/UnixReview/col49.html> , and \*(L"Profiling
in Template Toolkit via Overriding\*(R" for \fILinux Magazine\fR,
<http://www.stonehenge.com/merlyn/LinuxMag/col75.html> .
.SS "How do I cross-reference my Perl programs?"
.IX Subsection "How do I cross-reference my Perl programs?"
The B::Xref module can be used to generate cross-reference reports
for Perl programs.
.PP
.Vb 1
\&    perl \-MO=Xref[,OPTIONS] scriptname.plx
.Ve
.SS "Is there a pretty-printer (formatter) for Perl?"
.IX Subsection "Is there a pretty-printer (formatter) for Perl?"
Perl::Tidy comes with a perl script perltidy which indents and
reformats Perl scripts to make them easier to read by trying to follow
the rules of the perlstyle. If you write Perl, or spend much time reading
Perl, you will probably find it useful.
.PP
Of course, if you simply follow the guidelines in perlstyle,
you shouldn't need to reformat. The habit of formatting your code
as you write it will help prevent bugs. Your editor can and should
help you with this. The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance. Tom Christiansen and many other \s-1VI\s0 users swear by
the following settings in vi and its clones:
.PP
.Vb 2
\&    set ai sw=4
\&    map! ^O {^M}^[O^T
.Ve
.PP
Put that in your \fI.exrc\fR file (replacing the caret characters
with control characters) and away you go. In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting\*(--as
it were. A more complete example, with comments, can be found at
<http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz>
.SS "Is there an \s-1IDE\s0 or Windows Perl Editor?"
.IX Subsection "Is there an IDE or Windows Perl Editor?"
Perl programs are just plain text, so any editor will do.
.PP
If you're on Unix, you already have an IDE\*(--Unix itself. The Unix
philosophy is the philosophy of several small tools that each do one
thing and do it well. It's like a carpenter's toolbox.
.PP
If you want an \s-1IDE\s0, check the following (in alphabetical order, not
order of preference):
.IP "Eclipse" 4
.IX Item "Eclipse"
http://e\-p\-i\-c.sf.net/ <http://e-p-i-c.sf.net/>
.Sp
The Eclipse Perl Integration Project integrates Perl
editing/debugging with Eclipse.
.IP "Enginsite" 4
.IX Item "Enginsite"
<http://www.enginsite.com/>
.Sp
Perl Editor by EngInSite is a complete integrated development
environment (\s-1IDE\s0) for creating, testing, and  debugging  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.
.IP "Komodo" 4
.IX Item "Komodo"
<http://www.ActiveState.com/Products/Komodo/>
.Sp
ActiveState's cross-platform (as of October 2004, that's Windows, Linux,
and Solaris), multi-language \s-1IDE\s0 has Perl support, including a regular expression
debugger and remote debugging.
.IP "Notepad++" 4
.IX Item "Notepad++"
http://notepad\-plus.sourceforge.net/ <http://notepad-plus.sourceforge.net/>
.IP "Open Perl \s-1IDE\s0" 4
.IX Item "Open Perl IDE"
http://open\-perl\-ide.sourceforge.net/ <http://open-perl-ide.sourceforge.net/>
.Sp
Open Perl \s-1IDE\s0 is an integrated development environment for writing
and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.
.IP "OptiPerl" 4
.IX Item "OptiPerl"
<http://www.optiperl.com/>
.Sp
OptiPerl is a Windows \s-1IDE\s0 with simulated \s-1CGI\s0 environment, including
debugger and syntax-highlighting editor.
.IP "Padre" 4
.IX Item "Padre"
<http://padre.perlide.org/>
.Sp
Padre is cross-platform \s-1IDE\s0 for Perl written in Perl using wxWidgets to provide
a native look and feel. It's open source under the Artistic License. It
is one of the newer Perl IDEs.
.IP "PerlBuilder" 4
.IX Item "PerlBuilder"
<http://www.solutionsoft.com/perl.htm>
.Sp
PerlBuilder is an integrated development environment for Windows that
supports Perl development.
.IP "visiPerl+" 4
.IX Item "visiPerl+"
<http://helpconsulting.net/visiperl/index.html>
.Sp
From Help Consulting, for Windows.
.IP "Visual Perl" 4
.IX Item "Visual Perl"
<http://www.activestate.com/Products/Visual_Perl/>
.Sp
Visual Perl is a Visual Studio.NET plug-in from ActiveState.
.IP "Zeus" 4
.IX Item "Zeus"
<http://www.zeusedit.com/lookmain.html>
.Sp
Zeus for Window is another Win32 multi-language editor/IDE
that comes with support for Perl.
.PP
For editors: if you're on Unix you probably have vi or a vi clone
already, and possibly an emacs too, so you may not need to download
anything. In any emacs the cperl-mode (M\-x cperl-mode) gives you
perhaps the best available Perl editing mode in any editor.
.PP
If you are using Windows, you can use any editor that lets you work
with plain text, such as NotePad or WordPad. Word processors, such as
Microsoft Word or WordPerfect, typically do not work since they insert
all sorts of behind-the-scenes information, although some allow you to
save files as \*(L"Text Only\*(R". You can also download text editors designed
specifically for programming, such as Textpad (
<http://www.textpad.com/> ) and UltraEdit ( <http://www.ultraedit.com/> ),
among others.
.PP
If you are using MacOS, the same concerns apply. MacPerl (for Classic
environments) comes with a simple editor. Popular external editors are
BBEdit ( <http://www.bbedit.com/> ) or Alpha (
<http://www.his.com/~jguyer/Alpha/Alpha8.html> ). MacOS X users can use
Unix editors as well.
.IP "\s-1GNU\s0 Emacs" 4
.IX Item "GNU Emacs"
<http://www.gnu.org/software/emacs/windows/ntemacs.html>
.IP "MicroEMACS" 4
.IX Item "MicroEMACS"
<http://www.microemacs.de/>
.IP "XEmacs" 4
.IX Item "XEmacs"
<http://www.xemacs.org/Download/index.html>
.IP "Jed" 4
.IX Item "Jed"
<http://space.mit.edu/~davis/jed/>
.PP
or a vi clone such as
.IP "Vim" 4
.IX Item "Vim"
<http://www.vim.org/>
.IP "Vile" 4
.IX Item "Vile"
<http://dickey.his.com/vile/vile.html>
.PP
The following are Win32 multilanguage editor/IDEs that support Perl:
.IP "Codewright" 4
.IX Item "Codewright"
<http://www.borland.com/codewright/>
.IP "MultiEdit" 4
.IX Item "MultiEdit"
<http://www.MultiEdit.com/>
.IP "SlickEdit" 4
.IX Item "SlickEdit"
<http://www.slickedit.com/>
.IP "ConTEXT" 4
.IX Item "ConTEXT"
<http://www.contexteditor.org/>
.PP
There is also a toyedit Text widget based editor written in Perl
that is distributed with the Tk module on \s-1CPAN\s0. The ptkdb
( <http://ptkdb.sourceforge.net/> ) is a Perl/Tk\-based debugger that
acts as a development environment of sorts. Perl Composer
( <http://perlcomposer.sourceforge.net/> ) is an \s-1IDE\s0 for Perl/Tk
\&\s-1GUI\s0 creation.
.PP
In addition to an editor/IDE you might be interested in a more
powerful shell environment for Win32. Your options include
.IP "Bash" 4
.IX Item "Bash"
from the Cygwin package ( <http://sources.redhat.com/cygwin/> )
.IP "Ksh" 4
.IX Item "Ksh"
from the \s-1MKS\s0 Toolkit ( <http://www.mkssoftware.com/> ), or the Bourne shell of
the U/WIN environment ( <http://www.research.att.com/sw/tools/uwin/> )
.IP "Tcsh" 4
.IX Item "Tcsh"
<ftp://ftp.astron.com/pub/tcsh/> , see also
http://www.primate.wisc.edu/software/csh\-tcsh\-book/ <http://www.primate.wisc.edu/software/csh-tcsh-book/>
.IP "Zsh" 4
.IX Item "Zsh"
<http://www.zsh.org/>
.PP
\&\s-1MKS\s0 and U/WIN are commercial (U/WIN is free for educational and
research purposes), Cygwin is covered by the \s-1GNU\s0 General Public
License (but that shouldn't matter for Perl use). The Cygwin, \s-1MKS\s0,
and U/WIN all contain (in addition to the shells) a comprehensive set
of standard Unix toolkit utilities.
.PP
If you're transferring text files between Unix and Windows using \s-1FTP\s0
be sure to transfer them in \s-1ASCII\s0 mode so the ends of lines are
appropriately converted.
.PP
On Mac \s-1OS\s0 the MacPerl Application comes with a simple 32k text editor
that behaves like a rudimentary \s-1IDE\s0. In contrast to the MacPerl Application
the \s-1MPW\s0 Perl tool can make use of the \s-1MPW\s0 Shell itself as an editor (with
no 32k limit).
.IP "Affrus" 4
.IX Item "Affrus"
is a full Perl development environment with full debugger support
( <http://www.latenightsw.com> ).
.IP "Alpha" 4
.IX Item "Alpha"
is an editor, written and extensible in Tcl, that nonetheless has
built-in support for several popular markup and programming languages,
including Perl and \s-1HTML\s0 ( <http://www.his.com/~jguyer/Alpha/Alpha8.html> ).
.IP "BBEdit and BBEdit Lite" 4
.IX Item "BBEdit and BBEdit Lite"
are text editors for Mac \s-1OS\s0 that have a Perl sensitivity mode
( <http://web.barebones.com/> ).
.SS "Where can I get Perl macros for vi?"
.IX Subsection "Where can I get Perl macros for vi?"
For a complete version of Tom Christiansen's vi configuration file,
see <http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz> ,
the standard benchmark file for vi emulators. The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter\*(--see <http://www.cpan.org/src/misc/> .
.SS "Where can I get perl-mode or cperl-mode for emacs?"
.IX Xref "emacs"
.IX Subsection "Where can I get perl-mode or cperl-mode for emacs?"
Since Emacs version 19 patchlevel 22 or so, there have been both a
perl\-mode.el and support for the Perl debugger built in. These should
come with the standard Emacs 19 distribution.
.PP
Note that the perl-mode of emacs will have fits with \f(CW"main\*(Aqfoo"\fR
(single quote), and mess up the indentation and highlighting. You
are probably using \f(CW"main::foo"\fR in new Perl code anyway, so this
shouldn't be an issue.
.PP
For CPerlMode, see http://www.emacswiki.org/cgi\-bin/wiki/CPerlMode <http://www.emacswiki.org/cgi-bin/wiki/CPerlMode>
.SS "How can I use curses with Perl?"
.IX Subsection "How can I use curses with Perl?"
The Curses module from \s-1CPAN\s0 provides a dynamically loadable object
module interface to a curses library. A small demo can be found at the
directory <http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz> ;
this program repeats a command and updates the screen as needed, rendering
\&\fBrep ps axu\fR similar to \fBtop\fR.
.SS "How can I write a \s-1GUI\s0 (X, Tk, Gtk, etc.) in Perl?"
.IX Xref "GUI Tk Wx WxWidgets Gtk Gtk2 CamelBones Qt"
.IX Subsection "How can I write a GUI (X, Tk, Gtk, etc.) in Perl?"
(contributed by Ben Morrow)
.PP
There are a number of modules which let you write GUIs in Perl. Most
\&\s-1GUI\s0 toolkits have a perl interface: an incomplete list follows.
.IP "Tk" 4
.IX Item "Tk"
This works under Unix and Windows, and the current version doesn't
look half as bad under Windows as it used to. Some of the gui elements
still don't 'feel' quite right, though. The interface is very natural
and 'perlish', making it easy to use in small scripts that just need a
simple gui. It hasn't been updated in a while.
.IP "Wx" 4
.IX Item "Wx"
This is a Perl binding for the cross-platform wxWidgets toolkit
( <http://www.wxwidgets.org> ). It works under Unix, Win32 and Mac \s-1OS\s0 X,
using native widgets (Gtk under Unix). The interface follows the \*(C+
interface closely, but the documentation is a little sparse for someone
who doesn't know the library, mostly just referring you to the \*(C+
documentation.
.IP "Gtk and Gtk2" 4
.IX Item "Gtk and Gtk2"
These are Perl bindings for the Gtk toolkit ( <http://www.gtk.org> ). The
interface changed significantly between versions 1 and 2 so they have
separate Perl modules. It runs under Unix, Win32 and Mac \s-1OS\s0 X (currently
it requires an X server on Mac \s-1OS\s0, but a 'native' port is underway), and
the widgets look the same on every platform: i.e., they don't match the
native widgets. As with Wx, the Perl bindings follow the C \s-1API\s0 closely,
and the documentation requires you to read the C documentation to
understand it.
.IP "Win32::GUI" 4
.IX Item "Win32::GUI"
This provides access to most of the Win32 \s-1GUI\s0 widgets from Perl.
Obviously, it only runs under Win32, and uses native widgets. The Perl
interface doesn't really follow the C interface: it's been made more
Perlish, and the documentation is pretty good. More advanced stuff may
require familiarity with the C Win32 APIs, or reference to \s-1MSDN\s0.
.IP "CamelBones" 4
.IX Item "CamelBones"
CamelBones ( <http://camelbones.sourceforge.net> ) is a Perl interface to
Mac \s-1OS\s0 X's Cocoa \s-1GUI\s0 toolkit, and as such can be used to produce native
GUIs on Mac \s-1OS\s0 X. It's not on \s-1CPAN\s0, as it requires frameworks that
\&\s-1CPAN\s0.pm doesn't know how to install, but installation is via the
standard \s-1OSX\s0 package installer. The Perl \s-1API\s0 is, again, very close to
the ObjC \s-1API\s0 it's wrapping, and the documentation just tells you how to
translate from one to the other.
.IP "Qt" 4
.IX Item "Qt"
There is a Perl interface to TrollTech's Qt toolkit, but it does not
appear to be maintained.
.IP "Athena" 4
.IX Item "Athena"
Sx is an interface to the Athena widget set which comes with X, but
again it appears not to be much used nowadays.
.SS "How can I make my Perl program run faster?"
.IX Subsection "How can I make my Perl program run faster?"
The best way to do this is to come up with a better algorithm. This
can often make a dramatic difference. Jon Bentley's book
\&\fIProgramming Pearls\fR (that's not a misspelling!)  has some good tips
on optimization, too. Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware. You will probably want to
read the answer to the earlier question \*(L"How do I profile my Perl
programs?\*(R" if you haven't done so already.
.PP
A different approach is to autoload seldom-used Perl code. See the
AutoSplit and AutoLoader modules in the standard distribution for
that. Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler. Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the \s-1PDL\s0 module
from \s-1CPAN\s0).
.PP
If you're currently linking your perl executable to a shared
\&\fIlibc.so\fR, you can often gain a 10\-25% performance benefit by
rebuilding it to link with a static libc.a instead. This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it. See the \fI\s-1INSTALL\s0\fR file in the source distribution
for more information.
.PP
The undump program was an ancient attempt to speed up Perl program by
storing the already-compiled form to disk. This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.
.SS "How can I make my Perl program take less memory?"
.IX Subsection "How can I make my Perl program take less memory?"
When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem. Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more. While
there's still a lot to be done, recent releases have been addressing
these issues. For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.
.PP
In some cases, using \fIsubstr()\fR or \fIvec()\fR to simulate arrays can be
highly beneficial. For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125\-byte bit vector\*(--a considerable memory savings. The standard
Tie::SubstrHash module can also help for certain types of data
structure. If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.
.PP
Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc. Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the \fI\s-1INSTALL\s0\fR file in the source
distribution. You can find out whether you are using perl's malloc by
typing \f(CW\*(C`perl \-V:usemymalloc\*(C'\fR.
.PP
Of course, the best way to save memory is to not do anything to waste
it in the first place. Good programming practices can go a long way
toward this:
.IP "Don't slurp!" 4
.IX Item "Don't slurp!"
Don't read an entire file into memory if you can process it line
by line. Or more concretely, use a loop like this:
.Sp
.Vb 6
\&    #
\&    # Good Idea
\&    #
\&    while (my $line = <$file_handle>) {
\&       # ...
\&    }
.Ve
.Sp
instead of this:
.Sp
.Vb 7
\&    #
\&    # Bad Idea
\&    #
\&    my @data = <$file_handle>;
\&    foreach (@data) {
\&        # ...
\&    }
.Ve
.Sp
When the files you're processing are small, it doesn't much matter which
way you do it, but it makes a huge difference when they start getting
larger.
.IP "Use map and grep selectively" 4
.IX Item "Use map and grep selectively"
Remember that both map and grep expect a \s-1LIST\s0 argument, so doing this:
.Sp
.Vb 1
\&        @wanted = grep {/pattern/} <$file_handle>;
.Ve
.Sp
will cause the entire file to be slurped. For large files, it's better
to loop:
.Sp
.Vb 3
\&        while (<$file_handle>) {
\&                push(@wanted, $_) if /pattern/;
\&        }
.Ve
.IP "Avoid unnecessary quotes and stringification" 4
.IX Item "Avoid unnecessary quotes and stringification"
Don't quote large strings unless absolutely necessary:
.Sp
.Vb 1
\&        my $copy = "$large_string";
.Ve
.Sp
makes 2 copies of \f(CW$large_string\fR (one for \f(CW$copy\fR and another for the
quotes), whereas
.Sp
.Vb 1
\&        my $copy = $large_string;
.Ve
.Sp
only makes one copy.
.Sp
Ditto for stringifying large arrays:
.Sp
.Vb 4
\&    {
\&    local $, = "\en";
\&    print @big_array;
\&    }
.Ve
.Sp
is much more memory-efficient than either
.Sp
.Vb 1
\&    print join "\en", @big_array;
.Ve
.Sp
or
.Sp
.Vb 4
\&    {
\&    local $" = "\en";
\&    print "@big_array";
\&    }
.Ve
.IP "Pass by reference" 4
.IX Item "Pass by reference"
Pass arrays and hashes by reference, not by value. For one thing, it's
the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgement, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.
.IP "Tie large variables to disk" 4
.IX Item "Tie large variables to disk"
For \*(L"big\*(R" data stores (i.e. ones that exceed available memory) consider
using one of the \s-1DB\s0 modules to store it on disk instead of in \s-1RAM\s0. This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.
.SS "Is it safe to return a reference to local or lexical data?"
.IX Subsection "Is it safe to return a reference to local or lexical data?"
Yes. Perl's garbage collection system takes care of this so
everything works out right.
.PP
.Vb 4
\&    sub makeone {
\&        my @a = ( 1 .. 10 );
\&        return \e@a;
\&    }
\&
\&    for ( 1 .. 10 ) {
\&        push @many, makeone();
\&    }
\&
\&    print $many[4][5], "\en";
\&
\&    print "@many\en";
.Ve
.SS "How can I free an array or hash so my program shrinks?"
.IX Subsection "How can I free an array or hash so my program shrinks?"
(contributed by Michael Carman)
.PP
You usually can't. Memory allocated to lexicals (i.e. \fImy()\fR variables)
cannot be reclaimed or reused even if they go out of scope. It is
reserved in case the variables come back into scope. Memory allocated
to global variables can be reused (within your program) by using
\&\fIundef()\fR and/or \fIdelete()\fR.
.PP
On most operating systems, memory allocated to a program can never be
returned to the system. That's why long-running programs sometimes re\-
exec themselves. Some operating systems (notably, systems that use
\&\fImmap\fR\|(2) for allocating large chunks of memory) can reclaim memory that
is no longer used, but on such systems, perl must be configured and
compiled to use the \s-1OS\s0's malloc, not perl's.
.PP
In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl.
.PP
See also \*(L"How can I make my Perl program take less memory?\*(R"
.SS "How can I make my \s-1CGI\s0 script more efficient?"
.IX Subsection "How can I make my CGI script more efficient?"
Beyond the normal measures described to make general Perl programs
faster or smaller, a \s-1CGI\s0 program has additional issues. It may be run
several times per second. Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer. Compiling into C \fBisn't going to help
you\fR because the process start-up overhead is where the bottleneck is.
.PP
There are three popular ways to avoid this overhead. One solution
involves running the Apache \s-1HTTP\s0 server (available from
<http://www.apache.org/> ) with either of the mod_perl or mod_fastcgi
plugin modules.
.PP
With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking. The Apache extension also gives Perl access to
the internal server \s-1API\s0, so modules written in Perl can do just about
anything a module written in C can. For more on mod_perl, see
<http://perl.apache.org/>
.PP
With the \s-1FCGI\s0 module (from \s-1CPAN\s0) and the mod_fastcgi
module (available from <http://www.fastcgi.com/> ) each of your Perl
programs becomes a permanent \s-1CGI\s0 daemon process.
.PP
Finally, Plack is a Perl module and toolkit that contains \s-1PSGI\s0 middleware,
helpers and adapters to web servers, allowing you to easily deploy scripts which
can continue running, and provides flexibility with regards to which web server
you use. It can allow existing \s-1CGI\s0 scripts to enjoy this flexibility and
performance with minimal changes, or can be used along with modern Perl web
frameworks to make writing and deploying web services with Perl a breeze.
.PP
These solutions can have far-reaching effects on your system and on the way you
write your \s-1CGI\s0 programs, so investigate them with care.
.PP
See also
http://www.cpan.org/modules/by\-category/15_World_Wide_Web_HTML_HTTP_CGI/ <http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/> .
.SS "How can I hide the source for my Perl program?"
.IX Subsection "How can I hide the source for my Perl program?"
Delete it. :\-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, because
the source code has to be readable in order to be compiled and
interpreted. (That doesn't mean that a \s-1CGI\s0 script's source is
readable by people on the web, though\*(--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.
.PP
Some people regard this as a security problem. If your program does
insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure. It is often possible for someone to
determine the insecure things and exploit them without viewing the
source. Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.
.PP
You can try using encryption via source filters (Starting from Perl
5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it. You can try using the byte code compiler and interpreter
described later in perlfaq3, but the curious might still be able to
de-compile it. You can try using the native-code compiler described
later, but crackers might be able to disassemble it. These pose
varying degrees of difficulty to people wanting to get at your code,
but none can definitively conceal it (true of every language, not just
Perl).
.PP
It is very easy to recover the source of Perl programs. You simply
feed the program to the perl interpreter and use the modules in
the B:: hierarchy. The B::Deparse module should be able to
defeat most attempts to hide source. Again, this is not
unique to Perl.
.PP
If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security. License your software and pepper it with threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Your access to it does not give you permission to use it blah blah
blah.\*(R"  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.
.SS "How can I compile my Perl program into byte code or C?"
.IX Subsection "How can I compile my Perl program into byte code or C?"
(contributed by brian d foy)
.PP
In general, you can't do this. There are some things that may work
for your situation though. People usually ask this question
because they want to distribute their works without giving away
the source code, and most solutions trade disk space for convenience.
You probably won't see much of a speed increase either, since most
solutions simply bundle a Perl interpreter in the final product
(but see \*(L"How can I make my Perl program run faster?\*(R").
.PP
The Perl Archive Toolkit ( <http://par.perl.org/> ) is Perl's
analog to Java's \s-1JAR\s0. It's freely available and on \s-1CPAN\s0 (
<http://search.cpan.org/dist/PAR/> ).
.PP
There are also some commercial products that may work for you, although
you have to buy a license for them.
.PP
The Perl Dev Kit ( <http://www.activestate.com/Products/Perl_Dev_Kit/> )
from ActiveState can \*(L"Turn your Perl programs into ready-to-run
executables for HP-UX, Linux, Solaris and Windows.\*(R"
.PP
Perl2Exe ( <http://www.indigostar.com/perl2exe.htm> ) is a command line
program for converting perl scripts to executable files. It targets both
Windows and Unix platforms.
.ie n .SS "How can I get ""#!perl"" to work on [\s-1MS\-DOS\s0,NT,...]?"
.el .SS "How can I get \f(CW#!perl\fP to work on [\s-1MS\-DOS\s0,NT,...]?"
.IX Subsection "How can I get #!perl to work on [MS-DOS,NT,...]?"
For \s-1OS/2\s0 just use
.PP
.Vb 1
\&    extproc perl \-S \-your_switches
.Ve
.PP
as the first line in \f(CW\*(C`*.cmd\*(C'\fR file (\f(CW\*(C`\-S\*(C'\fR due to a bug in cmd.exe's
\&\*(L"extproc\*(R" handling). For \s-1DOS\s0 one should first invent a corresponding
batch file and codify it in \f(CW\*(C`ALTERNATE_SHEBANG\*(C'\fR (see the
\&\fIdosish.h\fR file in the source distribution for more information).
.PP
The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the \f(CW\*(C`.pl\*(C'\fR extension with the
perl interpreter. If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself. In addition to associating \f(CW\*(C`.pl\*(C'\fR with the
interpreter, \s-1NT\s0 people can use: \f(CW\*(C`SET PATHEXT=%PATHEXT%;.PL\*(C'\fR to let them
run the program \f(CW\*(C`install\-linux.pl\*(C'\fR merely by typing \f(CW\*(C`install\-linux\*(C'\fR.
.PP
Under \*(L"Classic\*(R" MacOS, a perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the MacPerl application.
Under Mac \s-1OS\s0 X, clickable apps can be made from any \f(CW\*(C`#!\*(C'\fR script using Wil
Sanchez' DropScript utility: <http://www.wsanchez.net/software/> .
.PP
\&\fI\s-1IMPORTANT\s0!\fR: Whatever you do, \s-1PLEASE\s0 don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server. This is an \s-1EXTREMELY\s0 big
security risk. Take the time to figure out how to do it correctly.
.SS "Can I write useful Perl programs on the command line?"
.IX Subsection "Can I write useful Perl programs on the command line?"
Yes. Read perlrun for more information. Some examples follow.
(These assume standard Unix shell quoting rules.)
.PP
.Vb 2
\&    # sum first and last fields
\&    perl \-lane \*(Aqprint $F[0] + $F[\-1]\*(Aq *
\&
\&    # identify text files
\&    perl \-le \*(Aqfor(@ARGV) {print if \-f && \-T _}\*(Aq *
\&
\&    # remove (most) comments from C program
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
\&
\&    # make file a month younger than today, defeating reaper daemons
\&    perl \-e \*(Aq$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)\*(Aq *
\&
\&    # find first unused uid
\&    perl \-le \*(Aq$i++ while getpwuid($i); print $i\*(Aq
\&
\&    # display reasonable manpath
\&    echo $PATH | perl \-nl \-072 \-e \*(Aq
\&    s![^/+]*$!man!&&\-d&&!$s{$_}++&&push@m,$_;END{print"@m"}\*(Aq
.Ve
.PP
\&\s-1OK\s0, the last one was actually an Obfuscated Perl Contest entry. :\-)
.SS "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
.IX Subsection "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created. On some systems, you may have to
change single-quotes to double ones, which you must \fI\s-1NOT\s0\fR do on Unix
or Plan9 systems. You might also have to change a single % to a %%.
.PP
For example:
.PP
.Vb 2
\&    # Unix (including Mac OS X)
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # DOS, etc.
\&    perl \-e "print \e"Hello world\en\e""
\&
\&    # Mac Classic
\&    print "Hello world\en"
\&     (then Run "Myscript" or Shift\-Command\-R)
\&
\&    # MPW
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # VMS
\&    perl \-e "print ""Hello world\en"""
.Ve
.PP
The problem is that none of these examples are reliable: they depend on the
command interpreter. Under Unix, the first two often work. Under \s-1DOS\s0,
it's entirely possible that neither works. If 4DOS was the command shell,
you'd probably have better luck like this:
.PP
.Vb 1
\&  perl \-e "print <Ctrl\-x>"Hello world\en<Ctrl\-x>""
.Ve
.PP
Under the Mac, it depends which environment you are using. The MacPerl
shell, or \s-1MPW\s0, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.
.PP
Using \fIqq()\fR, q(), and \fIqx()\fR, instead of \*(L"double quotes\*(R", 'single
quotes', and `backticks`, may make one-liners easier to write.
.PP
There is no general solution to all of this. It is a mess.
.PP
[Some of this answer was contributed by Kenneth Albanowski.]
.SS "Where can I learn about \s-1CGI\s0 or Web programming in Perl?"
.IX Subsection "Where can I learn about CGI or Web programming in Perl?"
For modules, get the \s-1CGI\s0 or \s-1LWP\s0 modules from \s-1CPAN\s0. For textbooks,
see the two especially dedicated to web stuff in the question on
books. For problems and questions related to the web, like \*(L"Why
do I get 500 Errors\*(R" or \*(L"Why doesn't it run from the browser right
when it runs fine on the command line\*(R", see the troubleshooting
guides and references in perlfaq9 or in the \s-1CGI\s0 MetaFAQ:
.PP
.Vb 1
\&    L<http://www.perl.org/CGI_MetaFAQ.html>
.Ve
.PP
Looking in to Plack and modern Perl web frameworks is highly recommended,
though; web programming in Perl has evolved a long way from the old days of
simple \s-1CGI\s0 scripts.
.SS "Where can I learn about object-oriented Perl programming?"
.IX Subsection "Where can I learn about object-oriented Perl programming?"
A good place to start is perltoot, and you can use perlobj,
perlboot, perltoot, perltooc, and perlbot for reference.
.PP
A good book on \s-1OO\s0 on Perl is the \*(L"Object-Oriented Perl\*(R"
by Damian Conway from Manning Publications, or \*(L"Intermediate Perl\*(R"
by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.
.SS "Where can I learn about linking C with Perl?"
.IX Subsection "Where can I learn about linking C with Perl?"
If you want to call C from Perl, start with perlxstut,
moving on to perlxs, xsubpp, and perlguts. If you want to
call Perl from C, then read perlembed, perlcall, and
perlguts. Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.
.PP
You might not need all the power of \s-1XS\s0. The Inline::C module lets
you put C code directly in your Perl source. It handles all the
magic to make it work. You still have to learn at least some of
the perl \s-1API\s0 but you won't have to deal with the complexity of the
\&\s-1XS\s0 support files.
.SS "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
.IX Subsection "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
Download the ExtUtils::Embed kit from \s-1CPAN\s0 and run `make test'. If
the tests pass, read the pods again and again and again. If they
fail, see perlbug and send a bug report with the output of
\&\f(CW\*(C`make test TEST_VERBOSE=1\*(C'\fR along with \f(CW\*(C`perl \-V\*(C'\fR.
.SS "When I tried to run my script, I got this message. What does it mean?"
.IX Subsection "When I tried to run my script, I got this message. What does it mean?"
A complete list of Perl's error messages and warnings with explanatory
text can be found in perldiag. You can also use the splain program
(distributed with Perl) to explain the error messages:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [\-v] [\-p] diag.out
.Ve
.PP
or change your program to explain the messages for you:
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
or
.PP
.Vb 1
\&    use diagnostics \-verbose;
.Ve
.SS "What's MakeMaker?"
.IX Subsection "What's MakeMaker?"
(contributed by brian d foy)
.PP
The ExtUtils::MakeMaker module, better known simply as \*(L"MakeMaker\*(R",
turns a Perl script, typically called \f(CW\*(C`Makefile.PL\*(C'\fR, into a Makefile.
The Unix tool \f(CW\*(C`make\*(C'\fR uses this file to manage dependencies and actions
to process and install a Perl distribution.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq35.18.1                               0100644 0001750 0001750 00000140334 12566207436 023001  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ3 1"
.TH PERLFAQ3 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq3 \- Programming Tools
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to programmer tools
and programming support.
.SS "How do I do (anything)?"
.IX Subsection "How do I do (anything)?"
Have you looked at \s-1CPAN \s0(see perlfaq2)? The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate manpages? Here's a brief index:
.IP "Basics" 4
.IX Item "Basics"
.RS 4
.PD 0
.IP "perldata \- Perl data types" 4
.IX Item "perldata - Perl data types"
.IP "perlvar \- Perl pre-defined variables" 4
.IX Item "perlvar - Perl pre-defined variables"
.IP "perlsyn \- Perl syntax" 4
.IX Item "perlsyn - Perl syntax"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perlsub \- Perl subroutines" 4
.IX Item "perlsub - Perl subroutines"
.RE
.RS 4
.RE
.IP "Execution" 4
.IX Item "Execution"
.RS 4
.IP "perlrun \- how to execute the Perl interpreter" 4
.IX Item "perlrun - how to execute the Perl interpreter"
.IP "perldebug \- Perl debugging" 4
.IX Item "perldebug - Perl debugging"
.RE
.RS 4
.RE
.IP "Functions" 4
.IX Item "Functions"
.RS 4
.IP "perlfunc \- Perl builtin functions" 4
.IX Item "perlfunc - Perl builtin functions"
.RE
.RS 4
.RE
.IP "Objects" 4
.IX Item "Objects"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlobj \- Perl objects" 4
.IX Item "perlobj - Perl objects"
.IP "perltie \- how to hide an object class in a simple variable" 4
.IX Item "perltie - how to hide an object class in a simple variable"
.RE
.RS 4
.RE
.IP "Data Structures" 4
.IX Item "Data Structures"
.RS 4
.IP "perlref \- Perl references and nested data structures" 4
.IX Item "perlref - Perl references and nested data structures"
.IP "perllol \- Manipulating arrays of arrays in Perl" 4
.IX Item "perllol - Manipulating arrays of arrays in Perl"
.IP "perldsc \- Perl Data Structures Cookbook" 4
.IX Item "perldsc - Perl Data Structures Cookbook"
.RE
.RS 4
.RE
.IP "Modules" 4
.IX Item "Modules"
.RS 4
.IP "perlmod \- Perl modules (packages and symbol tables)" 4
.IX Item "perlmod - Perl modules (packages and symbol tables)"
.IP "perlmodlib \- constructing new Perl modules and finding existing ones" 4
.IX Item "perlmodlib - constructing new Perl modules and finding existing ones"
.RE
.RS 4
.RE
.IP "Regexes" 4
.IX Item "Regexes"
.RS 4
.IP "perlre \- Perl regular expressions" 4
.IX Item "perlre - Perl regular expressions"
.IP "perlfunc \- Perl builtin functions>" 4
.IX Item "perlfunc - Perl builtin functions>"
.IP "perlop \- Perl operators and precedence" 4
.IX Item "perlop - Perl operators and precedence"
.IP "perllocale \- Perl locale handling (internationalization and localization)" 4
.IX Item "perllocale - Perl locale handling (internationalization and localization)"
.RE
.RS 4
.RE
.IP "Moving to perl5" 4
.IX Item "Moving to perl5"
.RS 4
.IP "perltrap \- Perl traps for the unwary" 4
.IX Item "perltrap - Perl traps for the unwary"
.IP "perl" 4
.IX Item "perl"
.RE
.RS 4
.RE
.IP "Linking with C" 4
.IX Item "Linking with C"
.RS 4
.IP "perlxstut \- Tutorial for writing XSUBs" 4
.IX Item "perlxstut - Tutorial for writing XSUBs"
.IP "perlxs \- \s-1XS\s0 language reference manual" 4
.IX Item "perlxs - XS language reference manual"
.IP "perlcall \- Perl calling conventions from C" 4
.IX Item "perlcall - Perl calling conventions from C"
.IP "perlguts \- Introduction to the Perl \s-1API\s0" 4
.IX Item "perlguts - Introduction to the Perl API"
.IP "perlembed \- how to embed perl in your C program" 4
.IX Item "perlembed - how to embed perl in your C program"
.RE
.RS 4
.RE
.IP "Various" 4
.IX Item "Various"
.PD
<http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>
(not a man-page but still useful, a collection of various essays on
Perl techniques)
.PP
A crude table of contents for the Perl manpage set is found in perltoc.
.SS "How can I use Perl interactively?"
.IX Subsection "How can I use Perl interactively?"
The typical approach uses the Perl debugger, described in the
\&\fIperldebug\fR\|(1) manpage, on an \*(L"empty\*(R" program, like this:
.PP
.Vb 1
\&    perl \-de 42
.Ve
.PP
Now just type in any legal Perl code, and it will be immediately
evaluated. You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.
.PP
You can also use Devel::REPL which is an interactive shell for Perl,
commonly known as a \s-1REPL \-\s0 Read, Evaluate, Print, Loop. It provides
various handy features.
.SS "How do I find which modules are installed on my system?"
.IX Subsection "How do I find which modules are installed on my system?"
From the command line, you can use the \f(CW\*(C`cpan\*(C'\fR command's \f(CW\*(C`\-l\*(C'\fR switch:
.PP
.Vb 1
\&    $ cpan \-l
.Ve
.PP
You can also use \f(CW\*(C`cpan\*(C'\fR's \f(CW\*(C`\-a\*(C'\fR switch to create an autobundle file
that \f(CW\*(C`CPAN.pm\*(C'\fR understands and can use to re-install every module:
.PP
.Vb 1
\&    $ cpan \-a
.Ve
.PP
Inside a Perl program, you can use the ExtUtils::Installed module to
show all installed distributions, although it can take awhile to do
its magic. The standard library which comes with Perl just shows up
as \*(L"Perl\*(R" (although you can get those with Module::CoreList).
.PP
.Vb 1
\&    use ExtUtils::Installed;
\&
\&    my $inst    = ExtUtils::Installed\->new();
\&    my @modules = $inst\->modules();
.Ve
.PP
If you want a list of all of the Perl module filenames, you
can use File::Find::Rule:
.PP
.Vb 1
\&    use File::Find::Rule;
\&
\&    my @files = File::Find::Rule\->
\&        extras({follow => 1})\->
\&        file()\->
\&        name( \*(Aq*.pm\*(Aq )\->
\&        in( @INC )
\&        ;
.Ve
.PP
If you do not have that module, you can do the same thing
with File::Find which is part of the standard library:
.PP
.Vb 2
\&    use File::Find;
\&    my @files;
\&
\&    find(
\&        {
\&        wanted => sub {
\&            push @files, $File::Find::fullname
\&            if \-f $File::Find::fullname && /\e.pm$/
\&        },
\&        follow => 1,
\&        follow_skip => 2,
\&        },
\&        @INC
\&    );
\&
\&    print join "\en", @files;
.Ve
.PP
If you simply need to check quickly to see if a module is
available, you can check for its documentation. If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases):
.PP
.Vb 1
\&    $ perldoc Module::Name
.Ve
.PP
You can also try to include the module in a one-liner to see if
perl finds it:
.PP
.Vb 1
\&    $ perl \-MModule::Name \-e1
.Ve
.PP
(If you don't receive a \*(L"Can't locate ... in \f(CW@INC\fR\*(R" error message, then Perl
found the module name you asked for.)
.SS "How do I debug my Perl programs?"
.IX Subsection "How do I debug my Perl programs?"
(contributed by brian d foy)
.PP
Before you do anything else, you can help yourself by ensuring that
you let Perl tell you about problem areas in your code. By turning
on warnings and strictures, you can head off many problems before
they get too big. You can find out more about these in strict
and warnings.
.PP
.Vb 3
\&    #!/usr/bin/perl
\&    use strict;
\&    use warnings;
.Ve
.PP
Beyond that, the simplest debugger is the \f(CW\*(C`print\*(C'\fR function. Use it
to look at values as you run your program:
.PP
.Vb 1
\&    print STDERR "The value is [$value]\en";
.Ve
.PP
The Data::Dumper module can pretty-print Perl data structures:
.PP
.Vb 2
\&    use Data::Dumper qw( Dumper );
\&    print STDERR "The hash is " . Dumper( \e%hash ) . "\en";
.Ve
.PP
Perl comes with an interactive debugger, which you can start with the
\&\f(CW\*(C`\-d\*(C'\fR switch. It's fully explained in perldebug.
.PP
If you'd like a graphical user interface and you have Tk, you can use
\&\f(CW\*(C`ptkdb\*(C'\fR. It's on \s-1CPAN\s0 and available for free.
.PP
If you need something much more sophisticated and controllable, Leon
Brocard's Devel::ebug (which you can call with the \f(CW\*(C`\-D\*(C'\fR switch as \f(CW\*(C`\-Debug\*(C'\fR)
gives you the programmatic hooks into everything you need to write your
own (without too much pain and suffering).
.PP
You can also use a commercial debugger such as Affrus (Mac \s-1OS X\s0), Komodo
from Activestate (Windows and Mac \s-1OS X\s0), or \s-1EPIC \s0(most platforms).
.SS "How do I profile my Perl programs?"
.IX Subsection "How do I profile my Perl programs?"
(contributed by brian d foy, updated Fri Jul 25 12:22:26 \s-1PDT 2008\s0)
.PP
The \f(CW\*(C`Devel\*(C'\fR namespace has several modules which you can use to
profile your Perl programs.
.PP
The Devel::NYTProf (New York Times Profiler) does both statement
and subroutine profiling. It's available from \s-1CPAN\s0 and you also invoke
it with the \f(CW\*(C`\-d\*(C'\fR switch:
.PP
.Vb 1
\&    perl \-d:NYTProf some_perl.pl
.Ve
.PP
It creates a database of the profile information that you can turn into
reports. The \f(CW\*(C`nytprofhtml\*(C'\fR command turns the data into an \s-1HTML\s0 report
similar to the Devel::Cover report:
.PP
.Vb 1
\&    nytprofhtml
.Ve
.PP
You might also be interested in using the Benchmark to
measure and compare code snippets.
.PP
You can read more about profiling in \fIProgramming Perl\fR, chapter 20,
or \fIMastering Perl\fR, chapter 5.
.PP
perldebguts documents creating a custom debugger if you need to
create a special sort of profiler. brian d foy describes the process
in \fIThe Perl Journal\fR, \*(L"Creating a Perl Debugger\*(R",
<http://www.ddj.com/184404522> , and \*(L"Profiling in Perl\*(R"
<http://www.ddj.com/184404580> .
.PP
Perl.com has two interesting articles on profiling: \*(L"Profiling Perl\*(R",
by Simon Cozens, <http://www.perl.com/lpt/a/850> and \*(L"Debugging and
Profiling mod_perl Applications\*(R", by Frank Wiles,
<http://www.perl.com/pub/a/2006/02/09/debug_mod_perl.html> .
.PP
Randal L. Schwartz writes about profiling in \*(L"Speeding up Your Perl
Programs\*(R" for \fIUnix Review\fR,
<http://www.stonehenge.com/merlyn/UnixReview/col49.html> , and \*(L"Profiling
in Template Toolkit via Overriding\*(R" for \fILinux Magazine\fR,
<http://www.stonehenge.com/merlyn/LinuxMag/col75.html> .
.SS "How do I cross-reference my Perl programs?"
.IX Subsection "How do I cross-reference my Perl programs?"
The B::Xref module can be used to generate cross-reference reports
for Perl programs.
.PP
.Vb 1
\&    perl \-MO=Xref[,OPTIONS] scriptname.plx
.Ve
.SS "Is there a pretty-printer (formatter) for Perl?"
.IX Subsection "Is there a pretty-printer (formatter) for Perl?"
Perl::Tidy comes with a perl script perltidy which indents and
reformats Perl scripts to make them easier to read by trying to follow
the rules of the perlstyle. If you write Perl, or spend much time reading
Perl, you will probably find it useful.
.PP
Of course, if you simply follow the guidelines in perlstyle,
you shouldn't need to reformat. The habit of formatting your code
as you write it will help prevent bugs. Your editor can and should
help you with this. The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance. Tom Christiansen and many other \s-1VI\s0 users swear by
the following settings in vi and its clones:
.PP
.Vb 2
\&    set ai sw=4
\&    map! ^O {^M}^[O^T
.Ve
.PP
Put that in your \fI.exrc\fR file (replacing the caret characters
with control characters) and away you go. In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting\*(--as
it were. A more complete example, with comments, can be found at
<http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz>
.SS "Is there an \s-1IDE\s0 or Windows Perl Editor?"
.IX Subsection "Is there an IDE or Windows Perl Editor?"
Perl programs are just plain text, so any editor will do.
.PP
If you're on Unix, you already have an IDE\*(--Unix itself. The Unix
philosophy is the philosophy of several small tools that each do one
thing and do it well. It's like a carpenter's toolbox.
.PP
If you want an \s-1IDE,\s0 check the following (in alphabetical order, not
order of preference):
.IP "Eclipse" 4
.IX Item "Eclipse"
<http://e\-p\-i\-c.sf.net/>
.Sp
The Eclipse Perl Integration Project integrates Perl
editing/debugging with Eclipse.
.IP "Enginsite" 4
.IX Item "Enginsite"
<http://www.enginsite.com/>
.Sp
Perl Editor by EngInSite is a complete integrated development
environment (\s-1IDE\s0) for creating, testing, and  debugging  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.
.IP "Kephra" 4
.IX Item "Kephra"
<http://kephra.sf.net>
.Sp
\&\s-1GUI\s0 Editor written in Perl using wxWidgets and Scintilla with lots of smaller features.
Aims for an \s-1UI\s0 based on Perls principles like \s-1TIMTWTDI\s0 and \*(L"easy thinkd should be ..\*(R".
.IP "Komodo" 4
.IX Item "Komodo"
<http://www.ActiveState.com/Products/Komodo/>
.Sp
ActiveState's cross-platform (as of October 2004, that's Windows, Linux,
and Solaris), multi-language \s-1IDE\s0 has Perl support, including a regular expression
debugger and remote debugging.
.IP "Notepad++" 4
.IX Item "Notepad++"
<http://notepad\-plus.sourceforge.net/>
.IP "Open Perl \s-1IDE\s0" 4
.IX Item "Open Perl IDE"
<http://open\-perl\-ide.sourceforge.net/>
.Sp
Open Perl \s-1IDE\s0 is an integrated development environment for writing
and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.
.IP "OptiPerl" 4
.IX Item "OptiPerl"
<http://www.optiperl.com/>
.Sp
OptiPerl is a Windows \s-1IDE\s0 with simulated \s-1CGI\s0 environment, including
debugger and syntax-highlighting editor.
.IP "Padre" 4
.IX Item "Padre"
<http://padre.perlide.org/>
.Sp
Padre is cross-platform \s-1IDE\s0 for Perl written in Perl using wxWidgets to provide
a native look and feel. It's open source under the Artistic License. It
is one of the newer Perl IDEs.
.IP "PerlBuilder" 4
.IX Item "PerlBuilder"
<http://www.solutionsoft.com/perl.htm>
.Sp
PerlBuilder is an integrated development environment for Windows that
supports Perl development.
.IP "visiPerl+" 4
.IX Item "visiPerl+"
<http://helpconsulting.net/visiperl/index.html>
.Sp
From Help Consulting, for Windows.
.IP "Visual Perl" 4
.IX Item "Visual Perl"
<http://www.activestate.com/Products/Visual_Perl/>
.Sp
Visual Perl is a Visual Studio.NET plug-in from ActiveState.
.IP "Zeus" 4
.IX Item "Zeus"
<http://www.zeusedit.com/lookmain.html>
.Sp
Zeus for Windows is another Win32 multi-language editor/IDE
that comes with support for Perl.
.PP
For editors: if you're on Unix you probably have vi or a vi clone
already, and possibly an emacs too, so you may not need to download
anything. In any emacs the cperl-mode (M\-x cperl-mode) gives you
perhaps the best available Perl editing mode in any editor.
.PP
If you are using Windows, you can use any editor that lets you work
with plain text, such as NotePad or WordPad. Word processors, such as
Microsoft Word or WordPerfect, typically do not work since they insert
all sorts of behind-the-scenes information, although some allow you to
save files as \*(L"Text Only\*(R". You can also download text editors designed
specifically for programming, such as Textpad (
<http://www.textpad.com/> ) and UltraEdit ( <http://www.ultraedit.com/> ),
among others.
.PP
If you are using MacOS, the same concerns apply. MacPerl (for Classic
environments) comes with a simple editor. Popular external editors are
BBEdit ( <http://www.bbedit.com/> ) or Alpha (
<http://www.his.com/~jguyer/Alpha/Alpha8.html> ). MacOS X users can use
Unix editors as well.
.IP "\s-1GNU\s0 Emacs" 4
.IX Item "GNU Emacs"
<http://www.gnu.org/software/emacs/windows/ntemacs.html>
.IP "MicroEMACS" 4
.IX Item "MicroEMACS"
<http://www.microemacs.de/>
.IP "XEmacs" 4
.IX Item "XEmacs"
<http://www.xemacs.org/Download/index.html>
.IP "Jed" 4
.IX Item "Jed"
<http://space.mit.edu/~davis/jed/>
.PP
or a vi clone such as
.IP "Vim" 4
.IX Item "Vim"
<http://www.vim.org/>
.IP "Vile" 4
.IX Item "Vile"
<http://dickey.his.com/vile/vile.html>
.PP
The following are Win32 multilanguage editor/IDEs that support Perl:
.IP "Codewright" 4
.IX Item "Codewright"
<http://www.borland.com/codewright/>
.IP "MultiEdit" 4
.IX Item "MultiEdit"
<http://www.MultiEdit.com/>
.IP "SlickEdit" 4
.IX Item "SlickEdit"
<http://www.slickedit.com/>
.IP "ConTEXT" 4
.IX Item "ConTEXT"
<http://www.contexteditor.org/>
.PP
There is also a toyedit Text widget based editor written in Perl
that is distributed with the Tk module on \s-1CPAN.\s0 The ptkdb
( <http://ptkdb.sourceforge.net/> ) is a Perl/Tk\-based debugger that
acts as a development environment of sorts. Perl Composer
( <http://perlcomposer.sourceforge.net/> ) is an \s-1IDE\s0 for Perl/Tk
\&\s-1GUI\s0 creation.
.PP
In addition to an editor/IDE you might be interested in a more
powerful shell environment for Win32. Your options include
.IP "Bash" 4
.IX Item "Bash"
from the Cygwin package ( <http://sources.redhat.com/cygwin/> )
.IP "Ksh" 4
.IX Item "Ksh"
from the \s-1MKS\s0 Toolkit ( <http://www.mkssoftware.com/> ), or the Bourne shell of
the U/WIN environment ( <http://www.research.att.com/sw/tools/uwin/> )
.IP "Tcsh" 4
.IX Item "Tcsh"
<ftp://ftp.astron.com/pub/tcsh/> , see also
<http://www.primate.wisc.edu/software/csh\-tcsh\-book/>
.IP "Zsh" 4
.IX Item "Zsh"
<http://www.zsh.org/>
.PP
\&\s-1MKS\s0 and U/WIN are commercial (U/WIN is free for educational and
research purposes), Cygwin is covered by the \s-1GNU\s0 General Public
License (but that shouldn't matter for Perl use). The Cygwin, \s-1MKS,\s0
and U/WIN all contain (in addition to the shells) a comprehensive set
of standard Unix toolkit utilities.
.PP
If you're transferring text files between Unix and Windows using \s-1FTP\s0
be sure to transfer them in \s-1ASCII\s0 mode so the ends of lines are
appropriately converted.
.PP
On Mac \s-1OS\s0 the MacPerl Application comes with a simple 32k text editor
that behaves like a rudimentary \s-1IDE.\s0 In contrast to the MacPerl Application
the \s-1MPW\s0 Perl tool can make use of the \s-1MPW\s0 Shell itself as an editor (with
no 32k limit).
.IP "Affrus" 4
.IX Item "Affrus"
is a full Perl development environment with full debugger support
( <http://www.latenightsw.com> ).
.IP "Alpha" 4
.IX Item "Alpha"
is an editor, written and extensible in Tcl, that nonetheless has
built-in support for several popular markup and programming languages,
including Perl and \s-1HTML \s0( <http://www.his.com/~jguyer/Alpha/Alpha8.html> ).
.IP "BBEdit and BBEdit Lite" 4
.IX Item "BBEdit and BBEdit Lite"
are text editors for Mac \s-1OS\s0 that have a Perl sensitivity mode
( <http://web.barebones.com/> ).
.SS "Where can I get Perl macros for vi?"
.IX Subsection "Where can I get Perl macros for vi?"
For a complete version of Tom Christiansen's vi configuration file,
see <http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz> ,
the standard benchmark file for vi emulators. The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter\*(--see <http://www.cpan.org/src/misc/> .
.SS "Where can I get perl-mode or cperl-mode for emacs?"
.IX Xref "emacs"
.IX Subsection "Where can I get perl-mode or cperl-mode for emacs?"
Since Emacs version 19 patchlevel 22 or so, there have been both a
perl\-mode.el and support for the Perl debugger built in. These should
come with the standard Emacs 19 distribution.
.PP
Note that the perl-mode of emacs will have fits with \f(CW"main\*(Aqfoo"\fR
(single quote), and mess up the indentation and highlighting. You
are probably using \f(CW"main::foo"\fR in new Perl code anyway, so this
shouldn't be an issue.
.PP
For CPerlMode, see <http://www.emacswiki.org/cgi\-bin/wiki/CPerlMode>
.SS "How can I use curses with Perl?"
.IX Subsection "How can I use curses with Perl?"
The Curses module from \s-1CPAN\s0 provides a dynamically loadable object
module interface to a curses library. A small demo can be found at the
directory <http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz> ;
this program repeats a command and updates the screen as needed, rendering
\&\fBrep ps axu\fR similar to \fBtop\fR.
.SS "How can I write a \s-1GUI \s0(X, Tk, Gtk, etc.) in Perl?"
.IX Xref "GUI Tk Wx WxWidgets Gtk Gtk2 CamelBones Qt"
.IX Subsection "How can I write a GUI (X, Tk, Gtk, etc.) in Perl?"
(contributed by Ben Morrow)
.PP
There are a number of modules which let you write GUIs in Perl. Most
\&\s-1GUI\s0 toolkits have a perl interface: an incomplete list follows.
.IP "Tk" 4
.IX Item "Tk"
This works under Unix and Windows, and the current version doesn't
look half as bad under Windows as it used to. Some of the gui elements
still don't 'feel' quite right, though. The interface is very natural
and 'perlish', making it easy to use in small scripts that just need a
simple gui. It hasn't been updated in a while.
.IP "Wx" 4
.IX Item "Wx"
This is a Perl binding for the cross-platform wxWidgets toolkit
( <http://www.wxwidgets.org> ). It works under Unix, Win32 and Mac \s-1OS X,\s0
using native widgets (Gtk under Unix). The interface follows the \*(C+
interface closely, but the documentation is a little sparse for someone
who doesn't know the library, mostly just referring you to the \*(C+
documentation.
.IP "Gtk and Gtk2" 4
.IX Item "Gtk and Gtk2"
These are Perl bindings for the Gtk toolkit ( <http://www.gtk.org> ). The
interface changed significantly between versions 1 and 2 so they have
separate Perl modules. It runs under Unix, Win32 and Mac \s-1OS X \s0(currently
it requires an X server on Mac \s-1OS,\s0 but a 'native' port is underway), and
the widgets look the same on every platform: i.e., they don't match the
native widgets. As with Wx, the Perl bindings follow the C \s-1API\s0 closely,
and the documentation requires you to read the C documentation to
understand it.
.IP "Win32::GUI" 4
.IX Item "Win32::GUI"
This provides access to most of the Win32 \s-1GUI\s0 widgets from Perl.
Obviously, it only runs under Win32, and uses native widgets. The Perl
interface doesn't really follow the C interface: it's been made more
Perlish, and the documentation is pretty good. More advanced stuff may
require familiarity with the C Win32 APIs, or reference to \s-1MSDN.\s0
.IP "CamelBones" 4
.IX Item "CamelBones"
CamelBones ( <http://camelbones.sourceforge.net> ) is a Perl interface to
Mac \s-1OS X\s0's Cocoa \s-1GUI\s0 toolkit, and as such can be used to produce native
GUIs on Mac \s-1OS X.\s0 It's not on \s-1CPAN,\s0 as it requires frameworks that
\&\s-1CPAN\s0.pm doesn't know how to install, but installation is via the
standard \s-1OSX\s0 package installer. The Perl \s-1API\s0 is, again, very close to
the ObjC \s-1API\s0 it's wrapping, and the documentation just tells you how to
translate from one to the other.
.IP "Qt" 4
.IX Item "Qt"
There is a Perl interface to TrollTech's Qt toolkit, but it does not
appear to be maintained.
.IP "Athena" 4
.IX Item "Athena"
Sx is an interface to the Athena widget set which comes with X, but
again it appears not to be much used nowadays.
.SS "How can I make my Perl program run faster?"
.IX Subsection "How can I make my Perl program run faster?"
The best way to do this is to come up with a better algorithm. This
can often make a dramatic difference. Jon Bentley's book
\&\fIProgramming Pearls\fR (that's not a misspelling!)  has some good tips
on optimization, too. Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware. You will probably want to
read the answer to the earlier question \*(L"How do I profile my Perl
programs?\*(R" if you haven't done so already.
.PP
A different approach is to autoload seldom-used Perl code. See the
AutoSplit and AutoLoader modules in the standard distribution for
that. Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler. Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the \s-1PDL\s0 module
from \s-1CPAN\s0).
.PP
If you're currently linking your perl executable to a shared
\&\fIlibc.so\fR, you can often gain a 10\-25% performance benefit by
rebuilding it to link with a static libc.a instead. This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it. See the \fI\s-1INSTALL\s0\fR file in the source distribution
for more information.
.PP
The undump program was an ancient attempt to speed up Perl program by
storing the already-compiled form to disk. This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.
.SS "How can I make my Perl program take less memory?"
.IX Subsection "How can I make my Perl program take less memory?"
When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem. Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more. While
there's still a lot to be done, recent releases have been addressing
these issues. For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.
.PP
In some cases, using \fIsubstr()\fR or \fIvec()\fR to simulate arrays can be
highly beneficial. For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125\-byte bit vector\*(--a considerable memory savings. The standard
Tie::SubstrHash module can also help for certain types of data
structure. If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.
.PP
Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc. Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the \fI\s-1INSTALL\s0\fR file in the source
distribution. You can find out whether you are using perl's malloc by
typing \f(CW\*(C`perl \-V:usemymalloc\*(C'\fR.
.PP
Of course, the best way to save memory is to not do anything to waste
it in the first place. Good programming practices can go a long way
toward this:
.IP "Don't slurp!" 4
.IX Item "Don't slurp!"
Don't read an entire file into memory if you can process it line
by line. Or more concretely, use a loop like this:
.Sp
.Vb 6
\&    #
\&    # Good Idea
\&    #
\&    while (my $line = <$file_handle>) {
\&       # ...
\&    }
.Ve
.Sp
instead of this:
.Sp
.Vb 7
\&    #
\&    # Bad Idea
\&    #
\&    my @data = <$file_handle>;
\&    foreach (@data) {
\&        # ...
\&    }
.Ve
.Sp
When the files you're processing are small, it doesn't much matter which
way you do it, but it makes a huge difference when they start getting
larger.
.IP "Use map and grep selectively" 4
.IX Item "Use map and grep selectively"
Remember that both map and grep expect a \s-1LIST\s0 argument, so doing this:
.Sp
.Vb 1
\&        @wanted = grep {/pattern/} <$file_handle>;
.Ve
.Sp
will cause the entire file to be slurped. For large files, it's better
to loop:
.Sp
.Vb 3
\&        while (<$file_handle>) {
\&                push(@wanted, $_) if /pattern/;
\&        }
.Ve
.IP "Avoid unnecessary quotes and stringification" 4
.IX Item "Avoid unnecessary quotes and stringification"
Don't quote large strings unless absolutely necessary:
.Sp
.Vb 1
\&        my $copy = "$large_string";
.Ve
.Sp
makes 2 copies of \f(CW$large_string\fR (one for \f(CW$copy\fR and another for the
quotes), whereas
.Sp
.Vb 1
\&        my $copy = $large_string;
.Ve
.Sp
only makes one copy.
.Sp
Ditto for stringifying large arrays:
.Sp
.Vb 4
\&    {
\&    local $, = "\en";
\&    print @big_array;
\&    }
.Ve
.Sp
is much more memory-efficient than either
.Sp
.Vb 1
\&    print join "\en", @big_array;
.Ve
.Sp
or
.Sp
.Vb 4
\&    {
\&    local $" = "\en";
\&    print "@big_array";
\&    }
.Ve
.IP "Pass by reference" 4
.IX Item "Pass by reference"
Pass arrays and hashes by reference, not by value. For one thing, it's
the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgement, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.
.IP "Tie large variables to disk" 4
.IX Item "Tie large variables to disk"
For \*(L"big\*(R" data stores (i.e. ones that exceed available memory) consider
using one of the \s-1DB\s0 modules to store it on disk instead of in \s-1RAM.\s0 This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.
.SS "Is it safe to return a reference to local or lexical data?"
.IX Subsection "Is it safe to return a reference to local or lexical data?"
Yes. Perl's garbage collection system takes care of this so
everything works out right.
.PP
.Vb 4
\&    sub makeone {
\&        my @a = ( 1 .. 10 );
\&        return \e@a;
\&    }
\&
\&    for ( 1 .. 10 ) {
\&        push @many, makeone();
\&    }
\&
\&    print $many[4][5], "\en";
\&
\&    print "@many\en";
.Ve
.SS "How can I free an array or hash so my program shrinks?"
.IX Subsection "How can I free an array or hash so my program shrinks?"
(contributed by Michael Carman)
.PP
You usually can't. Memory allocated to lexicals (i.e. \fImy()\fR variables)
cannot be reclaimed or reused even if they go out of scope. It is
reserved in case the variables come back into scope. Memory allocated
to global variables can be reused (within your program) by using
\&\fIundef()\fR and/or \fIdelete()\fR.
.PP
On most operating systems, memory allocated to a program can never be
returned to the system. That's why long-running programs sometimes re\-
exec themselves. Some operating systems (notably, systems that use
\&\fImmap\fR\|(2) for allocating large chunks of memory) can reclaim memory that
is no longer used, but on such systems, perl must be configured and
compiled to use the \s-1OS\s0's malloc, not perl's.
.PP
In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl.
.PP
See also \*(L"How can I make my Perl program take less memory?\*(R"
.SS "How can I make my \s-1CGI\s0 script more efficient?"
.IX Subsection "How can I make my CGI script more efficient?"
Beyond the normal measures described to make general Perl programs
faster or smaller, a \s-1CGI\s0 program has additional issues. It may be run
several times per second. Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer. Compiling into C \fBisn't going to help
you\fR because the process start-up overhead is where the bottleneck is.
.PP
There are three popular ways to avoid this overhead. One solution
involves running the Apache \s-1HTTP\s0 server (available from
<http://www.apache.org/> ) with either of the mod_perl or mod_fastcgi
plugin modules.
.PP
With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking. The Apache extension also gives Perl access to
the internal server \s-1API,\s0 so modules written in Perl can do just about
anything a module written in C can. For more on mod_perl, see
<http://perl.apache.org/>
.PP
With the \s-1FCGI\s0 module (from \s-1CPAN\s0) and the mod_fastcgi
module (available from <http://www.fastcgi.com/> ) each of your Perl
programs becomes a permanent \s-1CGI\s0 daemon process.
.PP
Finally, Plack is a Perl module and toolkit that contains \s-1PSGI\s0 middleware,
helpers and adapters to web servers, allowing you to easily deploy scripts which
can continue running, and provides flexibility with regards to which web server
you use. It can allow existing \s-1CGI\s0 scripts to enjoy this flexibility and
performance with minimal changes, or can be used along with modern Perl web
frameworks to make writing and deploying web services with Perl a breeze.
.PP
These solutions can have far-reaching effects on your system and on the way you
write your \s-1CGI\s0 programs, so investigate them with care.
.PP
See also
<http://www.cpan.org/modules/by\-category/15_World_Wide_Web_HTML_HTTP_CGI/> .
.SS "How can I hide the source for my Perl program?"
.IX Subsection "How can I hide the source for my Perl program?"
Delete it. :\-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of \*(L"security\*(R".
.PP
First of all, however, you \fIcan't\fR take away read permission, because
the source code has to be readable in order to be compiled and
interpreted. (That doesn't mean that a \s-1CGI\s0 script's source is
readable by people on the web, though\*(--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.
.PP
Some people regard this as a security problem. If your program does
insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure. It is often possible for someone to
determine the insecure things and exploit them without viewing the
source. Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.
.PP
You can try using encryption via source filters (Starting from Perl
5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it. You can try using the byte code compiler and interpreter
described later in perlfaq3, but the curious might still be able to
de-compile it. You can try using the native-code compiler described
later, but crackers might be able to disassemble it. These pose
varying degrees of difficulty to people wanting to get at your code,
but none can definitively conceal it (true of every language, not just
Perl).
.PP
It is very easy to recover the source of Perl programs. You simply
feed the program to the perl interpreter and use the modules in
the B:: hierarchy. The B::Deparse module should be able to
defeat most attempts to hide source. Again, this is not
unique to Perl.
.PP
If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security. License your software and pepper it with threatening
statements like \*(L"This is unpublished proprietary software of \s-1XYZ\s0 Corp.
Your access to it does not give you permission to use it blah blah
blah.\*(R"  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.
.SS "How can I compile my Perl program into byte code or C?"
.IX Subsection "How can I compile my Perl program into byte code or C?"
(contributed by brian d foy)
.PP
In general, you can't do this. There are some things that may work
for your situation though. People usually ask this question
because they want to distribute their works without giving away
the source code, and most solutions trade disk space for convenience.
You probably won't see much of a speed increase either, since most
solutions simply bundle a Perl interpreter in the final product
(but see \*(L"How can I make my Perl program run faster?\*(R").
.PP
The Perl Archive Toolkit ( <http://par.perl.org/> ) is Perl's
analog to Java's \s-1JAR.\s0 It's freely available and on \s-1CPAN \s0(
<http://search.cpan.org/dist/PAR/> ).
.PP
There are also some commercial products that may work for you, although
you have to buy a license for them.
.PP
The Perl Dev Kit ( <http://www.activestate.com/Products/Perl_Dev_Kit/> )
from ActiveState can \*(L"Turn your Perl programs into ready-to-run
executables for HP-UX, Linux, Solaris and Windows.\*(R"
.PP
Perl2Exe ( <http://www.indigostar.com/perl2exe.htm> ) is a command line
program for converting perl scripts to executable files. It targets both
Windows and Unix platforms.
.ie n .SS "How can I get ""#!perl"" to work on [\s-1MS\-DOS,NT,...\s0]?"
.el .SS "How can I get \f(CW#!perl\fP to work on [\s-1MS\-DOS,NT,...\s0]?"
.IX Subsection "How can I get #!perl to work on [MS-DOS,NT,...]?"
For \s-1OS/2\s0 just use
.PP
.Vb 1
\&    extproc perl \-S \-your_switches
.Ve
.PP
as the first line in \f(CW\*(C`*.cmd\*(C'\fR file (\f(CW\*(C`\-S\*(C'\fR due to a bug in cmd.exe's
\&\*(L"extproc\*(R" handling). For \s-1DOS\s0 one should first invent a corresponding
batch file and codify it in \f(CW\*(C`ALTERNATE_SHEBANG\*(C'\fR (see the
\&\fIdosish.h\fR file in the source distribution for more information).
.PP
The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the \f(CW\*(C`.pl\*(C'\fR extension with the
perl interpreter. If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself. In addition to associating \f(CW\*(C`.pl\*(C'\fR with the
interpreter, \s-1NT\s0 people can use: \f(CW\*(C`SET PATHEXT=%PATHEXT%;.PL\*(C'\fR to let them
run the program \f(CW\*(C`install\-linux.pl\*(C'\fR merely by typing \f(CW\*(C`install\-linux\*(C'\fR.
.PP
Under \*(L"Classic\*(R" MacOS, a perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the MacPerl application.
Under Mac \s-1OS X,\s0 clickable apps can be made from any \f(CW\*(C`#!\*(C'\fR script using Wil
Sanchez' DropScript utility: <http://www.wsanchez.net/software/> .
.PP
\&\fI\s-1IMPORTANT\s0!\fR: Whatever you do, \s-1PLEASE\s0 don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server. This is an \s-1EXTREMELY\s0 big
security risk. Take the time to figure out how to do it correctly.
.SS "Can I write useful Perl programs on the command line?"
.IX Subsection "Can I write useful Perl programs on the command line?"
Yes. Read perlrun for more information. Some examples follow.
(These assume standard Unix shell quoting rules.)
.PP
.Vb 2
\&    # sum first and last fields
\&    perl \-lane \*(Aqprint $F[0] + $F[\-1]\*(Aq *
\&
\&    # identify text files
\&    perl \-le \*(Aqfor(@ARGV) {print if \-f && \-T _}\*(Aq *
\&
\&    # remove (most) comments from C program
\&    perl \-0777 \-pe \*(Aqs{/\e*.*?\e*/}{}gs\*(Aq foo.c
\&
\&    # make file a month younger than today, defeating reaper daemons
\&    perl \-e \*(Aq$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)\*(Aq *
\&
\&    # find first unused uid
\&    perl \-le \*(Aq$i++ while getpwuid($i); print $i\*(Aq
\&
\&    # display reasonable manpath
\&    echo $PATH | perl \-nl \-072 \-e \*(Aq
\&    s![^/+]*$!man!&&\-d&&!$s{$_}++&&push@m,$_;END{print"@m"}\*(Aq
.Ve
.PP
\&\s-1OK,\s0 the last one was actually an Obfuscated Perl Contest entry. :\-)
.SS "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
.IX Subsection "Why don't Perl one-liners work on my DOS/Mac/VMS system?"
The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created. On some systems, you may have to
change single-quotes to double ones, which you must \fI\s-1NOT\s0\fR do on Unix
or Plan9 systems. You might also have to change a single % to a %%.
.PP
For example:
.PP
.Vb 2
\&    # Unix (including Mac OS X)
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # DOS, etc.
\&    perl \-e "print \e"Hello world\en\e""
\&
\&    # Mac Classic
\&    print "Hello world\en"
\&     (then Run "Myscript" or Shift\-Command\-R)
\&
\&    # MPW
\&    perl \-e \*(Aqprint "Hello world\en"\*(Aq
\&
\&    # VMS
\&    perl \-e "print ""Hello world\en"""
.Ve
.PP
The problem is that none of these examples are reliable: they depend on the
command interpreter. Under Unix, the first two often work. Under \s-1DOS,\s0
it's entirely possible that neither works. If 4DOS was the command shell,
you'd probably have better luck like this:
.PP
.Vb 1
\&  perl \-e "print <Ctrl\-x>"Hello world\en<Ctrl\-x>""
.Ve
.PP
Under the Mac, it depends which environment you are using. The MacPerl
shell, or \s-1MPW,\s0 is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.
.PP
Using \fIqq()\fR, q(), and \fIqx()\fR, instead of \*(L"double quotes\*(R", 'single
quotes', and `backticks`, may make one-liners easier to write.
.PP
There is no general solution to all of this. It is a mess.
.PP
[Some of this answer was contributed by Kenneth Albanowski.]
.SS "Where can I learn about \s-1CGI\s0 or Web programming in Perl?"
.IX Subsection "Where can I learn about CGI or Web programming in Perl?"
For modules, get the \s-1CGI\s0 or \s-1LWP\s0 modules from \s-1CPAN.\s0 For textbooks,
see the two especially dedicated to web stuff in the question on
books. For problems and questions related to the web, like \*(L"Why
do I get 500 Errors\*(R" or \*(L"Why doesn't it run from the browser right
when it runs fine on the command line\*(R", see the troubleshooting
guides and references in perlfaq9 or in the \s-1CGI\s0 MetaFAQ:
.PP
.Vb 1
\&    L<http://www.perl.org/CGI_MetaFAQ.html>
.Ve
.PP
Looking in to Plack and modern Perl web frameworks is highly recommended,
though; web programming in Perl has evolved a long way from the old days of
simple \s-1CGI\s0 scripts.
.SS "Where can I learn about object-oriented Perl programming?"
.IX Subsection "Where can I learn about object-oriented Perl programming?"
A good place to start is perltoot, and you can use perlobj,
perlboot, perltoot, perltooc, and perlbot for reference.
.PP
A good book on \s-1OO\s0 on Perl is the \*(L"Object-Oriented Perl\*(R"
by Damian Conway from Manning Publications, or \*(L"Intermediate Perl\*(R"
by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.
.SS "Where can I learn about linking C with Perl?"
.IX Subsection "Where can I learn about linking C with Perl?"
If you want to call C from Perl, start with perlxstut,
moving on to perlxs, xsubpp, and perlguts. If you want to
call Perl from C, then read perlembed, perlcall, and
perlguts. Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.
.PP
You might not need all the power of \s-1XS.\s0 The Inline::C module lets
you put C code directly in your Perl source. It handles all the
magic to make it work. You still have to learn at least some of
the perl \s-1API\s0 but you won't have to deal with the complexity of the
\&\s-1XS\s0 support files.
.SS "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
.IX Subsection "I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?"
Download the ExtUtils::Embed kit from \s-1CPAN\s0 and run `make test'. If
the tests pass, read the pods again and again and again. If they
fail, see perlbug and send a bug report with the output of
\&\f(CW\*(C`make test TEST_VERBOSE=1\*(C'\fR along with \f(CW\*(C`perl \-V\*(C'\fR.
.SS "When I tried to run my script, I got this message. What does it mean?"
.IX Subsection "When I tried to run my script, I got this message. What does it mean?"
A complete list of Perl's error messages and warnings with explanatory
text can be found in perldiag. You can also use the splain program
(distributed with Perl) to explain the error messages:
.PP
.Vb 2
\&    perl program 2>diag.out
\&    splain [\-v] [\-p] diag.out
.Ve
.PP
or change your program to explain the messages for you:
.PP
.Vb 1
\&    use diagnostics;
.Ve
.PP
or
.PP
.Vb 1
\&    use diagnostics \-verbose;
.Ve
.SS "What's MakeMaker?"
.IX Subsection "What's MakeMaker?"
(contributed by brian d foy)
.PP
The ExtUtils::MakeMaker module, better known simply as \*(L"MakeMaker\*(R",
turns a Perl script, typically called \f(CW\*(C`Makefile.PL\*(C'\fR, into a Makefile.
The Unix tool \f(CW\*(C`make\*(C'\fR uses this file to manage dependencies and actions
to process and install a Perl distribution.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples here are in the public
domain. You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit. A simple comment in the code giving credit to the \s-1FAQ\s0 would
be courteous but is not required.
                                                                                                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq4.1                                   0100644 0001750 0001750 00000327041 12566207437 022471  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ4 1"
.TH PERLFAQ4 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq4 \- Data Manipulation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.SH "Data: Numbers"
.IX Header "Data: Numbers"
.SS "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
.IX Subsection "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
For the long explanation, see David Goldberg's \*(L"What Every Computer
Scientist Should Know About Floating-Point Arithmetic\*(R"
(<http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf>).
.PP
Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly. Some real numbers lose precision in the process. This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.
.PP
perlnumber shows the gory details of number representations and
conversions.
.PP
To limit the number of decimal places in your numbers, you can use the
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`sprintf\*(C'\fR function. See
\&\*(L"Floating-point Arithmetic\*(R" in perlop for more details.
.PP
.Vb 1
\&    printf "%.2f", 10/3;
\&
\&    my $number = sprintf "%.2f", 10/3;
.Ve
.SS "Why is \fIint()\fP broken?"
.IX Subsection "Why is int() broken?"
Your \f(CW\*(C`int()\*(C'\fR is most probably working just fine. It's the numbers that
aren't quite what you think.
.PP
First, see the answer to \*(L"Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?\*(R".
.PP
For example, this
.PP
.Vb 1
\&    print int(0.6/0.2\-2), "\en";
.Ve
.PP
will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers. What you think in the above as 'three' is really more like
2.9999999999999995559.
.SS "Why isn't my octal data interpreted correctly?"
.IX Subsection "Why isn't my octal data interpreted correctly?"
(contributed by brian d foy)
.PP
You're probably trying to convert a string to a number, which Perl only
converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:
.PP
.Vb 1
\&    my $string = \*(Aq0644\*(Aq;
\&
\&    print $string + 0;  # prints 644
\&
\&    print $string + 44; # prints 688, certainly not octal!
.Ve
.PP
This problem usually involves one of the Perl built-ins that has the
same name a Unix command that uses octal numbers as arguments on the
command line. In this example, \f(CW\*(C`chmod\*(C'\fR on the command line knows that
its first argument is octal because that's what it does:
.PP
.Vb 1
\&    %prompt> chmod 644 file
.Ve
.PP
If you want to use the same literal digits (644) in Perl, you have to tell
Perl to treat them as octal numbers either by prefixing the digits with
a \f(CW0\fR or using \f(CW\*(C`oct\*(C'\fR:
.PP
.Vb 2
\&    chmod(     0644, $filename );  # right, has leading zero
\&    chmod( oct(644), $filename );  # also correct
.Ve
.PP
The problem comes in when you take your numbers from something that Perl
thinks is a string, such as a command line argument in \f(CW@ARGV\fR:
.PP
.Vb 1
\&    chmod( $ARGV[0],      $filename );  # wrong, even if "0644"
\&
\&    chmod( oct($ARGV[0]), $filename );  # correct, treat string as octal
.Ve
.PP
You can always check the value you're using by printing it in octal
notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:
.PP
.Vb 1
\&    printf "0%o %d", $number, $number;
.Ve
.SS "Does Perl have a \fIround()\fP function? What about \fIceil()\fP and \fIfloor()\fP? Trig functions?"
.IX Subsection "Does Perl have a round() function? What about ceil() and floor()? Trig functions?"
Remember that \f(CW\*(C`int()\*(C'\fR merely truncates toward 0. For rounding to a
certain number of digits, \f(CW\*(C`sprintf()\*(C'\fR or \f(CW\*(C`printf()\*(C'\fR is usually the
easiest route.
.PP
.Vb 1
\&    printf("%.3f", 3.1415926535);   # prints 3.142
.Ve
.PP
The \s-1POSIX\s0 module (part of the standard Perl distribution)
implements \f(CW\*(C`ceil()\*(C'\fR, \f(CW\*(C`floor()\*(C'\fR, and a number of other mathematical
and trigonometric functions.
.PP
.Vb 3
\&    use POSIX;
\&    my $ceil   = ceil(3.5);   # 4
\&    my $floor  = floor(3.5);  # 3
.Ve
.PP
In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex
module. With 5.004, the Math::Trig module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the Math::Complex module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.
.PP
Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely. In these
cases, it probably pays not to trust whichever system of rounding is
being used by Perl, but instead to implement the rounding function you
need yourself.
.PP
To see why, notice how you'll still have an issue on half-way-point
alternation:
.PP
.Vb 1
\&    for (my $i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
\&
\&    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
\&    0.8 0.8 0.9 0.9 1.0 1.0
.Ve
.PP
Don't blame Perl. It's the same as in C. \s-1IEEE\s0 says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32\-bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.
.SS "How do I convert between numeric representations/bases/radixes?"
.IX Subsection "How do I convert between numeric representations/bases/radixes?"
As always with Perl there is more than one way to do it. Below are a
few examples of approaches to making common conversions between number
representations. This is intended to be representational rather than
exhaustive.
.PP
Some of the examples later in perlfaq4 use the Bit::Vector
module from \s-1CPAN.\s0 The reason you might choose Bit::Vector over the
perl built-in functions is that it works with numbers of \s-1ANY\s0 size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.
.IP "How do I convert hexadecimal into decimal" 4
.IX Item "How do I convert hexadecimal into decimal"
Using perl's built in conversion of \f(CW\*(C`0x\*(C'\fR notation:
.Sp
.Vb 1
\&    my $dec = 0xDEADBEEF;
.Ve
.Sp
Using the \f(CW\*(C`hex\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = hex("DEADBEEF");
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR:
.Sp
.Vb 1
\&    my $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", \-8)));
.Ve
.Sp
Using the \s-1CPAN\s0 module \f(CW\*(C`Bit::Vector\*(C'\fR:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Hex(32, "DEADBEEF");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to hexadecimal" 4
.IX Item "How do I convert from decimal to hexadecimal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 2
\&    my $hex = sprintf("%X", 3735928559); # upper case A\-F
\&    my $hex = sprintf("%x", 3735928559); # lower case a\-f
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $hex = unpack("H*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $hex = $vec\->to_Hex();
.Ve
.Sp
And Bit::Vector supports odd bit counts:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(33, 3735928559);
\&    $vec\->Resize(32); # suppress leading 0 if unwanted
\&    my $hex = $vec\->to_Hex();
.Ve
.IP "How do I convert from octal to decimal" 4
.IX Item "How do I convert from octal to decimal"
Using Perl's built in conversion of numbers with leading zeros:
.Sp
.Vb 1
\&    my $dec = 033653337357; # note the leading 0!
.Ve
.Sp
Using the \f(CW\*(C`oct\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = oct("33653337357");
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new(32);
\&    $vec\->Chunk_List_Store(3, split(//, reverse "33653337357"));
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to octal" 4
.IX Item "How do I convert from decimal to octal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 1
\&    my $oct = sprintf("%o", 3735928559);
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $oct = reverse join(\*(Aq\*(Aq, $vec\->Chunk_List_Read(3));
.Ve
.IP "How do I convert from binary to decimal" 4
.IX Item "How do I convert from binary to decimal"
Perl 5.6 lets you write binary numbers directly with
the \f(CW\*(C`0b\*(C'\fR notation:
.Sp
.Vb 1
\&    my $number = 0b10110110;
.Ve
.Sp
Using \f(CW\*(C`oct\*(C'\fR:
.Sp
.Vb 2
\&    my $input = "10110110";
\&    my $decimal = oct( "0b$input" );
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.Sp
.Vb 1
\&    my $decimal = ord(pack(\*(AqB8\*(Aq, \*(Aq10110110\*(Aq));
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR for larger strings:
.Sp
.Vb 3
\&    my $int = unpack("N", pack("B32",
\&    substr("0" x 32 . "11110101011011011111011101111", \-32)));
\&    my $dec = sprintf("%d", $int);
\&
\&    # substr() is used to left\-pad a 32\-character string with zeros.
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 2
\&    my $vec = Bit::Vector\->new_Bin(32, "11011110101011011011111011101111");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to binary" 4
.IX Item "How do I convert from decimal to binary"
Using \f(CW\*(C`sprintf\*(C'\fR (perl 5.6+):
.Sp
.Vb 1
\&    my $bin = sprintf("%b", 3735928559);
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $bin = unpack("B*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $bin = $vec\->to_Bin();
.Ve
.Sp
The remaining transformations (e.g. hex \-> oct, bin \-> hex, etc.)
are left as an exercise to the inclined reader.
.SS "Why doesn't & work the way I want it to?"
.IX Subsection "Why doesn't & work the way I want it to?"
The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings. The operators treat a string as a series
of bits and work with that (the string \f(CW"3"\fR is the bit pattern
\&\f(CW00110011\fR). The operators work with the binary form of a number
(the number \f(CW3\fR is treated as the bit pattern \f(CW00000011\fR).
.PP
So, saying \f(CW\*(C`11 & 3\*(C'\fR performs the \*(L"and\*(R" operation on numbers (yielding
\&\f(CW3\fR). Saying \f(CW"11" & "3"\fR performs the \*(L"and\*(R" operation on strings
(yielding \f(CW"1"\fR).
.PP
Most problems with \f(CW\*(C`&\*(C'\fR and \f(CW\*(C`|\*(C'\fR arise because the programmer thinks
they have a number but really it's a string or vice versa. To avoid this,
stringify the arguments explicitly (using \f(CW""\fR or \f(CW\*(C`qq()\*(C'\fR) or convert them
to numbers explicitly (using \f(CW\*(C`0+$arg\*(C'\fR). The rest arise because
the programmer says:
.PP
.Vb 3
\&    if ("\e020\e020" & "\e101\e101") {
\&        # ...
\&    }
.Ve
.PP
but a string consisting of two null bytes (the result of \f(CW"\e020\e020"
& "\e101\e101"\fR) is not a false value in Perl. You need:
.PP
.Vb 3
\&    if ( ("\e020\e020" & "\e101\e101") !~ /[^\e000]/) {
\&        # ...
\&    }
.Ve
.SS "How do I multiply matrices?"
.IX Subsection "How do I multiply matrices?"
Use the Math::Matrix or Math::MatrixReal modules (available from \s-1CPAN\s0)
or the \s-1PDL\s0 extension (also available from \s-1CPAN\s0).
.SS "How do I perform an operation on a series of integers?"
.IX Subsection "How do I perform an operation on a series of integers?"
To call a function on each element in an array, and collect the
results, use:
.PP
.Vb 1
\&    my @results = map { my_func($_) } @array;
.Ve
.PP
For example:
.PP
.Vb 1
\&    my @triple = map { 3 * $_ } @single;
.Ve
.PP
To call a function on each element of an array, but ignore the
results:
.PP
.Vb 3
\&    foreach my $iterator (@array) {
\&        some_func($iterator);
\&    }
.Ve
.PP
To call a function on each integer in a (small) range, you \fBcan\fR use:
.PP
.Vb 1
\&    my @results = map { some_func($_) } (5 .. 25);
.Ve
.PP
but you should be aware that in this form, the \f(CW\*(C`..\*(C'\fR operator
creates a list of all integers in the range, which can take a lot of
memory for large ranges. However, the problem does not occur when
using \f(CW\*(C`..\*(C'\fR within a \f(CW\*(C`for\*(C'\fR loop, because in that case the range
operator is optimized to \fIiterate\fR over the range, without creating
the entire list. So
.PP
.Vb 4
\&    my @results = ();
\&    for my $i (5 .. 500_005) {
\&        push(@results, some_func($i));
\&    }
.Ve
.PP
or even
.PP
.Vb 1
\&   push(@results, some_func($_)) for 5 .. 500_005;
.Ve
.PP
will not create an intermediate list of 500,000 integers.
.SS "How can I output Roman numerals?"
.IX Subsection "How can I output Roman numerals?"
Get the <http://www.cpan.org/modules/by\-module/Roman> module.
.SS "Why aren't my random numbers random?"
.IX Subsection "Why aren't my random numbers random?"
If you're using a version of Perl before 5.004, you must call \f(CW\*(C`srand\*(C'\fR
once at the start of your program to seed the random number generator.
.PP
.Vb 1
\&     BEGIN { srand() if $] < 5.004 }
.Ve
.PP
5.004 and later automatically call \f(CW\*(C`srand\*(C'\fR at the beginning. Don't
call \f(CW\*(C`srand\*(C'\fR more than once\*(--you make your numbers less random,
rather than more.
.PP
Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :\-). The
\&\fIrandom\fR article in the \*(L"Far More Than You Ever Wanted To Know\*(R"
collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
of Tom Phoenix, talks more about this. John von Neumann said, \*(L"Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin.\*(R"
.PP
Perl relies on the underlying system for the implementation of
\&\f(CW\*(C`rand\*(C'\fR and \f(CW\*(C`srand\*(C'\fR; on some systems, the generated numbers are
not random enough (especially on Windows : see
<http://www.perlmonks.org/?node_id=803632>).
Several \s-1CPAN\s0 modules in the \f(CW\*(C`Math\*(C'\fR namespace implement better
pseudorandom generators; see for example
Math::Random::MT (\*(L"Mersenne Twister\*(R", fast), or
Math::TrulyRandom (uses the imperfections in the system's
timer to generate random numbers, which is rather slow).
More algorithms for random numbers are described in
\&\*(L"Numerical Recipes in C\*(R" at <http://www.nr.com/>
.SS "How do I get a random number between X and Y?"
.IX Subsection "How do I get a random number between X and Y?"
To get a random number between two values, you can use the \f(CW\*(C`rand()\*(C'\fR
built-in to get a random number between 0 and 1. From there, you shift
that into the range that you want.
.PP
\&\f(CW\*(C`rand($x)\*(C'\fR returns a number such that \f(CW\*(C`0 <= rand($x) < $x\*(C'\fR. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your \fIX\fR and \fIY\fR.
.PP
That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.
.PP
.Vb 1
\&    my $number = 10 + int rand( 15\-10+1 ); # ( 10,11,12,13,14, or 15 )
.Ve
.PP
Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: \f(CW\*(C`random_int_between(50,120)\*(C'\fR.
.PP
.Vb 7
\&    sub random_int_between {
\&        my($min, $max) = @_;
\&        # Assumes that the two arguments are integers themselves!
\&        return $min if $min == $max;
\&        ($min, $max) = ($max, $min)  if  $min > $max;
\&        return $min + int rand(1 + $max \- $min);
\&    }
.Ve
.SH "Data: Dates"
.IX Header "Data: Dates"
.SS "How do I find the day or week of the year?"
.IX Subsection "How do I find the day or week of the year?"
The day of the year is in the list returned
by the \f(CW\*(C`localtime\*(C'\fR function. Without an
argument \f(CW\*(C`localtime\*(C'\fR uses the current time.
.PP
.Vb 1
\&    my $day_of_year = (localtime)[7];
.Ve
.PP
The \s-1POSIX\s0 module can also format a date as the day of the year or
week of the year.
.PP
.Vb 3
\&    use POSIX qw/strftime/;
\&    my $day_of_year  = strftime "%j", localtime;
\&    my $week_of_year = strftime "%W", localtime;
.Ve
.PP
To get the day of year for any date, use \s-1POSIX\s0's \f(CW\*(C`mktime\*(C'\fR to get
a time in epoch seconds for the argument to \f(CW\*(C`localtime\*(C'\fR.
.PP
.Vb 3
\&    use POSIX qw/mktime strftime/;
\&    my $week_of_year = strftime "%W",
\&        localtime( mktime( 0, 0, 0, 18, 11, 87 ) );
.Ve
.PP
You can also use Time::Piece, which comes with Perl and provides a
\&\f(CW\*(C`localtime\*(C'\fR that returns an object:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $day_of_year  = localtime\->yday;
\&    my $week_of_year = localtime\->week;
.Ve
.PP
The Date::Calc module provides two functions to calculate these, too:
.PP
.Vb 3
\&    use Date::Calc;
\&    my $day_of_year  = Day_of_Year(  1987, 12, 18 );
\&    my $week_of_year = Week_of_Year( 1987, 12, 18 );
.Ve
.SS "How do I find the current century or millennium?"
.IX Subsection "How do I find the current century or millennium?"
Use the following simple functions:
.PP
.Vb 3
\&    sub get_century    {
\&        return int((((localtime(shift || time))[5] + 1999))/100);
\&    }
\&
\&    sub get_millennium {
\&        return 1+int((((localtime(shift || time))[5] + 1899))/1000);
\&    }
.Ve
.PP
On some systems, the \s-1POSIX\s0 module's \f(CW\*(C`strftime()\*(C'\fR function has been
extended in a non-standard way to use a \f(CW%C\fR format, which they
sometimes claim is the \*(L"century\*(R". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to determine reliably the current century or
millennium.
.SS "How can I compare two dates and find the difference?"
.IX Subsection "How can I compare two dates and find the difference?"
(contributed by brian d foy)
.PP
You could just store all your dates as a number and then subtract.
Life isn't always that simple though.
.PP
The Time::Piece module, which comes with Perl, replaces localtime
with a version that returns an object. It also overloads the comparison
operators so you can compare them directly:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $date1 = localtime( $some_time );
\&    my $date2 = localtime( $some_other_time );
\&
\&    if( $date1 < $date2 ) {
\&        print "The date was in the past\en";
\&    }
.Ve
.PP
You can also get differences with a subtraction, which returns a
Time::Seconds object:
.PP
.Vb 2
\&    my $diff = $date1 \- $date2;
\&    print "The difference is ", $date_diff\->days, " days\en";
.Ve
.PP
If you want to work with formatted dates, the Date::Manip,
Date::Calc, or DateTime modules can help you.
.SS "How can I take a string and turn it into epoch seconds?"
.IX Subsection "How can I take a string and turn it into epoch seconds?"
If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to \f(CW\*(C`timelocal\*(C'\fR in the standard
Time::Local module. Otherwise, you should look into the Date::Calc,
Date::Parse, and Date::Manip modules from \s-1CPAN.\s0
.SS "How can I find the Julian Day?"
.IX Subsection "How can I find the Julian Day?"
(contributed by brian d foy and Dave Cross)
.PP
You can use the Time::Piece module, part of the Standard Library,
which can convert a date/time to a Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->julian_day\*(Aq
\&    2455607.7959375
.Ve
.PP
Or the modified Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->mjd\*(Aq
\&    55607.2961226851
.Ve
.PP
Or even the day of the year (which is what some people think of as a
Julian day):
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->yday\*(Aq
\&    45
.Ve
.PP
You can also do the same things with the DateTime module:
.PP
.Vb 6
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->jd\*(Aq
\&    2453401.5
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->mjd\*(Aq
\&    53401
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->doy\*(Aq
\&    31
.Ve
.PP
You can use the Time::JulianDay module available on \s-1CPAN.\s0 Ensure
that you really want to find a Julian day, though, as many people have
different ideas about Julian days (see <http://www.hermetic.ch/cal_stud/jdn.htm>
for instance):
.PP
.Vb 2
\&    $  perl \-MTime::JulianDay \-le \*(Aqprint local_julian_day( time )\*(Aq
\&    55608
.Ve
.SS "How do I find yesterday's date?"
.IX Xref "date yesterday DateTime Date::Calc Time::Local daylight saving time day Today_and_Now localtime timelocal"
.IX Subsection "How do I find yesterday's date?"
(contributed by brian d foy)
.PP
To do it correctly, you can use one of the \f(CW\*(C`Date\*(C'\fR modules since they
work with calendars instead of times. The DateTime module makes it
simple, and give you the same time of day, only the day before,
despite daylight saving time changes:
.PP
.Vb 1
\&    use DateTime;
\&
\&    my $yesterday = DateTime\->now\->subtract( days => 1 );
\&
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
You can also use the Date::Calc module using its \f(CW\*(C`Today_and_Now\*(C'\fR
function.
.PP
.Vb 1
\&    use Date::Calc qw( Today_and_Now Add_Delta_DHMS );
\&
\&    my @date_time = Add_Delta_DHMS( Today_and_Now(), \-1, 0, 0, 0 );
\&
\&    print "@date_time\en";
.Ve
.PP
Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each. For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. For example, the rest of the
suggestions will be wrong sometimes:
.PP
Starting with Perl 5.10, Time::Piece and Time::Seconds are part
of the standard distribution, so you might think that you could do
something like this:
.PP
.Vb 2
\&    use Time::Piece;
\&    use Time::Seconds;
\&
\&    my $yesterday = localtime() \- ONE_DAY; # WRONG
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
The Time::Piece module exports a new \f(CW\*(C`localtime\*(C'\fR that returns an
object, and Time::Seconds exports the \f(CW\*(C`ONE_DAY\*(C'\fR constant that is a
set number of seconds. This means that it always gives the time 24
hours ago, which is not always yesterday. This can cause problems
around the end of daylight saving time when there's one day that is 25
hours long.
.PP
You have the same problem with Time::Local, which will give the wrong
answer for those same special cases:
.PP
.Vb 5
\&    # contributed by Gunnar Hjalmarsson
\&     use Time::Local;
\&     my $today = timelocal 0, 0, 12, ( localtime )[3..5];
\&     my ($d, $m, $y) = ( localtime $today\-86400 )[3..5]; # WRONG
\&     printf "Yesterday: %d\-%02d\-%02d\en", $y+1900, $m+1, $d;
.Ve
.SS "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
.IX Subsection "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
(contributed by brian d foy)
.PP
Perl itself never had a Y2K problem, although that never stopped people
from creating Y2K problems on their own. See the documentation for
\&\f(CW\*(C`localtime\*(C'\fR for its proper use.
.PP
Starting with Perl 5.12, \f(CW\*(C`localtime\*(C'\fR and \f(CW\*(C`gmtime\*(C'\fR can handle dates past
03:14:08 January 19, 2038, when a 32\-bit based time would overflow. You
still might get a warning on a 32\-bit \f(CW\*(C`perl\*(C'\fR:
.PP
.Vb 3
\&    % perl5.12 \-E \*(Aqsay scalar localtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Integer overflow in hexadecimal number at \-e line 1.
\&    Wed Nov  1 19:42:39 5576711
.Ve
.PP
On a 64\-bit \f(CW\*(C`perl\*(C'\fR, you can get even larger dates for those really long
running projects:
.PP
.Vb 2
\&    % perl5.12 \-E \*(Aqsay scalar gmtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Thu Nov  2 00:42:39 5576711
.Ve
.PP
You're still out of luck if you need to keep track of decaying protons
though.
.SH "Data: Strings"
.IX Header "Data: Strings"
.SS "How do I validate input?"
.IX Subsection "How do I validate input?"
(contributed by brian d foy)
.PP
There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with \*(L"Assert\*(R" and \*(L"Validate\*(R"
in their names, along with other modules such as Regexp::Common.
.PP
Some modules have validation for particular types of input, such
as Business::ISBN, Business::CreditCard, Email::Valid,
and Data::Validate::IP.
.SS "How do I unescape a string?"
.IX Subsection "How do I unescape a string?"
It depends just what you mean by \*(L"escape\*(R". \s-1URL\s0 escapes are dealt
with in perlfaq9. Shell escapes with the backslash (\f(CW\*(C`\e\*(C'\fR)
character are removed with
.PP
.Vb 1
\&    s/\e\e(.)/$1/g;
.Ve
.PP
This won't expand \f(CW"\en"\fR or \f(CW"\et"\fR or any other special escapes.
.SS "How do I remove consecutive pairs of characters?"
.IX Subsection "How do I remove consecutive pairs of characters?"
(contributed by brian d foy)
.PP
You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in \f(CW\*(C`(.)\*(C'\fR. The memory parentheses
store the matched character in the back-reference \f(CW\*(C`\eg1\*(C'\fR and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in \f(CW$1\fR.
.PP
.Vb 1
\&    s/(.)\eg1/$1/g;
.Ve
.PP
We can also use the transliteration operator, \f(CW\*(C`tr///\*(C'\fR. In this
example, the search list side of our \f(CW\*(C`tr///\*(C'\fR contains nothing, but
the \f(CW\*(C`c\*(C'\fR option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the \f(CW\*(C`s\*(C'\fR option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself
.PP
.Vb 2
\&    my $str = \*(AqHaarlem\*(Aq;   # in the Netherlands
\&    $str =~ tr///cs;       # Now Harlem, like in New York
.Ve
.SS "How do I expand function calls in a string?"
.IX Subsection "How do I expand function calls in a string?"
(contributed by brian d foy)
.PP
This is documented in perlref, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.
.PP
.Vb 1
\&    print "The time values are @{ [localtime] }.\en";
.Ve
.PP
If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need \f(CW\*(C`scalar\*(C'\fR to
force the scalar context on the function:
.PP
.Vb 1
\&    print "The time is ${\e(scalar localtime)}.\en"
\&
\&    print "The time is ${ my $x = localtime; \e$x }.\en";
.Ve
.PP
If your function already returns a reference, you don't need to create
the reference yourself.
.PP
.Vb 1
\&    sub timestamp { my $t = localtime; \e$t }
\&
\&    print "The time is ${ timestamp() }.\en";
.Ve
.PP
The \f(CW\*(C`Interpolation\*(C'\fR module can also do a lot of magic for you. You can
specify a variable name, in this case \f(CW\*(C`E\*(C'\fR, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.
.PP
.Vb 2
\&    use Interpolation E => \*(Aqeval\*(Aq;
\&    print "The time values are $E{localtime()}.\en";
.Ve
.PP
In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.
.PP
.Vb 1
\&    print "The time is " . localtime() . ".\en";
.Ve
.SS "How do I find matching/nesting anything?"
.IX Subsection "How do I find matching/nesting anything?"
To find something between two single
characters, a pattern like \f(CW\*(C`/x([^x]*)x/\*(C'\fR will get the intervening
bits in \f(CW$1\fR. For multiple ones, then something more like
\&\f(CW\*(C`/alpha(.*?)omega/\*(C'\fR would be needed. For nested patterns
and/or balanced expressions, see the so-called
(?PARNO)
construct (available since perl 5.10).
The \s-1CPAN\s0 module Regexp::Common can help to build such
regular expressions (see in particular
Regexp::Common::balanced and Regexp::Common::delimited).
.PP
More complex cases will require to write a parser, probably
using a parsing module from \s-1CPAN,\s0 like
Regexp::Grammars, Parse::RecDescent, Parse::Yapp,
Text::Balanced, or Marpa::XS.
.SS "How do I reverse a string?"
.IX Subsection "How do I reverse a string?"
Use \f(CW\*(C`reverse()\*(C'\fR in scalar context, as documented in
\&\*(L"reverse\*(R" in perlfunc.
.PP
.Vb 1
\&    my $reversed = reverse $string;
.Ve
.SS "How do I expand tabs in a string?"
.IX Subsection "How do I expand tabs in a string?"
You can do it yourself:
.PP
.Vb 1
\&    1 while $string =~ s/\et+/\*(Aq \*(Aq x (length($&) * 8 \- length($\`) % 8)/e;
.Ve
.PP
Or you can just use the Text::Tabs module (part of the standard Perl
distribution).
.PP
.Vb 2
\&    use Text::Tabs;
\&    my @expanded_lines = expand(@lines_with_tabs);
.Ve
.SS "How do I reformat a paragraph?"
.IX Subsection "How do I reformat a paragraph?"
Use Text::Wrap (part of the standard Perl distribution):
.PP
.Vb 2
\&    use Text::Wrap;
\&    print wrap("\et", \*(Aq  \*(Aq, @paragraphs);
.Ve
.PP
The paragraphs you give to Text::Wrap should not contain embedded
newlines. Text::Wrap doesn't justify the lines (flush-right).
.PP
Or use the \s-1CPAN\s0 module Text::Autoformat. Formatting files can be
easily done by making a shell alias, like so:
.PP
.Vb 2
\&    alias fmt="perl \-i \-MText::Autoformat \-n0777 \e
\&        \-e \*(Aqprint autoformat $_, {all=>1}\*(Aq $*"
.Ve
.PP
See the documentation for Text::Autoformat to appreciate its many
capabilities.
.SS "How can I access or change N characters of a string?"
.IX Subsection "How can I access or change N characters of a string?"
You can access the first characters of a string with \fIsubstr()\fR.
To get the first character, for example, start at position 0
and grab the string of length 1.
.PP
.Vb 2
\&    my $string = "Just another Perl Hacker";
\&    my $first_char = substr( $string, 0, 1 );  #  \*(AqJ\*(Aq
.Ve
.PP
To change part of a string, you can use the optional fourth
argument which is the replacement string.
.PP
.Vb 1
\&    substr( $string, 13, 4, "Perl 5.8.0" );
.Ve
.PP
You can also use \fIsubstr()\fR as an lvalue.
.PP
.Vb 1
\&    substr( $string, 13, 4 ) =  "Perl 5.8.0";
.Ve
.SS "How do I change the Nth occurrence of something?"
.IX Subsection "How do I change the Nth occurrence of something?"
You have to keep track of N yourself. For example, let's say you want
to change the fifth occurrence of \f(CW"whoever"\fR or \f(CW"whomever"\fR into
\&\f(CW"whosoever"\fR or \f(CW"whomsoever"\fR, case insensitively. These
all assume that \f(CW$_\fR contains the string to be altered.
.PP
.Vb 6
\&    $count = 0;
\&    s{((whom?)ever)}{
\&    ++$count == 5       # is it the 5th?
\&        ? "${2}soever"  # yes, swap
\&        : $1            # renege and leave it there
\&        }ige;
.Ve
.PP
In the more general case, you can use the \f(CW\*(C`/g\*(C'\fR modifier in a \f(CW\*(C`while\*(C'\fR
loop, keeping count of matches.
.PP
.Vb 8
\&    $WANT = 3;
\&    $count = 0;
\&    $_ = "One fish two fish red fish blue fish";
\&    while (/(\ew+)\es+fish\eb/gi) {
\&        if (++$count == $WANT) {
\&            print "The third fish is a $1 one.\en";
\&        }
\&    }
.Ve
.PP
That prints out: \f(CW"The third fish is a red one."\fR  You can also use a
repetition count and repeated pattern like this:
.PP
.Vb 1
\&    /(?:\ew+\es+fish\es+){2}(\ew+)\es+fish/i;
.Ve
.SS "How can I count the number of occurrences of a substring within a string?"
.IX Subsection "How can I count the number of occurrences of a substring within a string?"
There are a number of ways, with varying efficiency. If you want a
count of a certain single character (X) within a string, you can use the
\&\f(CW\*(C`tr///\*(C'\fR function like so:
.PP
.Vb 3
\&    my $string = "ThisXlineXhasXsomeXx\*(AqsXinXit";
\&    my $count = ($string =~ tr/X//);
\&    print "There are $count X characters in the string";
.Ve
.PP
This is fine if you are just looking for a single character. However,
if you are trying to count multiple character substrings within a
larger string, \f(CW\*(C`tr///\*(C'\fR won't work. What you can do is wrap a \fIwhile()\fR
loop around a global pattern match. For example, let's count negative
integers:
.PP
.Vb 4
\&    my $string = "\-9 55 48 \-2 23 \-76 4 14 \-44";
\&    my $count = 0;
\&    while ($string =~ /\-\ed+/g) { $count++ }
\&    print "There are $count negative numbers in the string";
.Ve
.PP
Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.
.PP
.Vb 1
\&    my $count = () = $string =~ /\-\ed+/g;
.Ve
.SS "How do I capitalize all the words on one line?"
.IX Xref "Text::Autoformat capitalize case, title case, sentence"
.IX Subsection "How do I capitalize all the words on one line?"
(contributed by brian d foy)
.PP
Damian Conway's Text::Autoformat handles all of the thinking
for you.
.PP
.Vb 3
\&    use Text::Autoformat;
\&    my $x = "Dr. Strangelove or: How I Learned to Stop ".
\&      "Worrying and Love the Bomb";
\&
\&    print $x, "\en";
\&    for my $style (qw( sentence title highlight )) {
\&        print autoformat($x, { case => $style }), "\en";
\&    }
.Ve
.PP
How do you want to capitalize those words?
.PP
.Vb 3
\&    FRED AND BARNEY\*(AqS LODGE        # all uppercase
\&    Fred And Barney\*(Aqs Lodge        # title case
\&    Fred and Barney\*(Aqs Lodge        # highlight case
.Ve
.PP
It's not as easy a problem as it looks. How many words do you think
are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of \f(CW\*(C`\ew+\*(C'\fR, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that \f(CW\*(C`s\*(C'\fR after the apostrophe? You could try a regular expression:
.PP
.Vb 6
\&    $string =~ s/ (
\&                 (^\ew)    #at the beginning of the line
\&                   |      # or
\&                 (\es\ew)   #preceded by whitespace
\&                   )
\&                /\eU$1/xg;
\&
\&    $string =~ s/([\ew\*(Aq]+)/\eu\eL$1/g;
.Ve
.PP
Now, what if you don't want to capitalize that \*(L"and\*(R"? Just use
Text::Autoformat and get on with the next problem. :)
.SS "How can I split a [character]\-delimited string except when inside [character]?"
.IX Subsection "How can I split a [character]-delimited string except when inside [character]?"
Several modules can handle this sort of parsing\*(--Text::Balanced,
Text::CSV, Text::CSV_XS, and Text::ParseWords, among others.
.PP
Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use \f(CW\*(C`split(/,/)\*(C'\fR
because you shouldn't split if the comma is inside quotes. For
example, take a data line like this:
.PP
.Vb 1
\&    SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
.Ve
.PP
Due to the restriction of the quotes, this is a fairly complex
problem. Thankfully, we have Jeffrey Friedl, author of
\&\fIMastering Regular Expressions\fR, to handle these for us. He
suggests (assuming your string is contained in \f(CW$text\fR):
.PP
.Vb 7
\&     my @new = ();
\&     push(@new, $+) while $text =~ m{
\&         "([^\e"\e\e]*(?:\e\e.[^\e"\e\e]*)*)",? # groups the phrase inside the quotes
\&        | ([^,]+),?
\&        | ,
\&     }gx;
\&     push(@new, undef) if substr($text,\-1,1) eq \*(Aq,\*(Aq;
.Ve
.PP
If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
\&\f(CW"like \e"this\e""\fR.
.PP
Alternatively, the Text::ParseWords module (part of the standard
Perl distribution) lets you say:
.PP
.Vb 2
\&    use Text::ParseWords;
\&    @new = quotewords(",", 0, $text);
.Ve
.PP
For parsing or generating \s-1CSV,\s0 though, using Text::CSV rather than
implementing it yourself is highly recommended; you'll save yourself odd bugs
popping up later by just using code which has already been tried and tested in
production for years.
.SS "How do I strip blank space from the beginning/end of a string?"
.IX Subsection "How do I strip blank space from the beginning/end of a string?"
(contributed by brian d foy)
.PP
A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions:
.PP
.Vb 2
\&    s/^\es+//;
\&    s/\es+$//;
.Ve
.PP
You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though:
.PP
.Vb 1
\&    s/^\es+|\es+$//g;
.Ve
.PP
In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the \f(CW\*(C`/g\*(C'\fR flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the \f(CW\*(C`\es+\*(C'\fR, and  the \f(CW\*(C`$\*(C'\fR anchor can match to the
absolute end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
\&\*(L"blank\*(R" (consisting entirely of whitespace) lines which the \f(CW\*(C`^\es+\*(C'\fR
would remove all by itself:
.PP
.Vb 4
\&    while( <> ) {
\&        s/^\es+|\es+$//g;
\&        print "$_\en";
\&    }
.Ve
.PP
For a multi-line string, you can apply the regular expression to each
logical line in the string by adding the \f(CW\*(C`/m\*(C'\fR flag (for
\&\*(L"multi-line\*(R"). With the \f(CW\*(C`/m\*(C'\fR flag, the \f(CW\*(C`$\*(C'\fR matches \fIbefore\fR an
embedded newline, so it doesn't remove it. This pattern still removes
the newline at the end of the string:
.PP
.Vb 1
\&    $string =~ s/^\es+|\es+$//gm;
.Ve
.PP
Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If you need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace:
.PP
.Vb 1
\&    $string =~ s/^[\et\ef ]+|[\et\ef ]+$//mg;
.Ve
.SS "How do I pad a string with blanks or pad a number with zeroes?"
.IX Subsection "How do I pad a string with blanks or pad a number with zeroes?"
In the following examples, \f(CW$pad_len\fR is the length to which you wish
to pad the string, \f(CW$text\fR or \f(CW$num\fR contains the string to be padded,
and \f(CW$pad_char\fR contains the padding character. You can use a single
character string constant instead of the \f(CW$pad_char\fR variable if you
know what it is in advance. And in the same way you can use an integer in
place of \f(CW$pad_len\fR if you know the pad length in advance.
.PP
The simplest method uses the \f(CW\*(C`sprintf\*(C'\fR function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The \f(CW\*(C`pack\*(C'\fR function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
\&\f(CW$pad_len\fR.
.PP
.Vb 3
\&    # Left padding a string with blanks (no truncation):
\&    my $padded = sprintf("%${pad_len}s", $text);
\&    my $padded = sprintf("%*s", $pad_len, $text);  # same thing
\&
\&    # Right padding a string with blanks (no truncation):
\&    my $padded = sprintf("%\-${pad_len}s", $text);
\&    my $padded = sprintf("%\-*s", $pad_len, $text); # same thing
\&
\&    # Left padding a number with 0 (no truncation):
\&    my $padded = sprintf("%0${pad_len}d", $num);
\&    my $padded = sprintf("%0*d", $pad_len, $num); # same thing
\&
\&    # Right padding a string with blanks using pack (will truncate):
\&    my $padded = pack("A$pad_len",$text);
.Ve
.PP
If you need to pad with a character other than blank or zero you can use
one of the following methods. They all generate a pad string with the
\&\f(CW\*(C`x\*(C'\fR operator and combine that with \f(CW$text\fR. These methods do
not truncate \f(CW$text\fR.
.PP
Left and right padding with any character, creating a new string:
.PP
.Vb 2
\&    my $padded = $pad_char x ( $pad_len \- length( $text ) ) . $text;
\&    my $padded = $text . $pad_char x ( $pad_len \- length( $text ) );
.Ve
.PP
Left and right padding with any character, modifying \f(CW$text\fR directly:
.PP
.Vb 2
\&    substr( $text, 0, 0 ) = $pad_char x ( $pad_len \- length( $text ) );
\&    $text .= $pad_char x ( $pad_len \- length( $text ) );
.Ve
.SS "How do I extract selected columns from a string?"
.IX Subsection "How do I extract selected columns from a string?"
(contributed by brian d foy)
.PP
If you know the columns that contain the data, you can
use \f(CW\*(C`substr\*(C'\fR to extract a single column.
.PP
.Vb 1
\&    my $column = substr( $line, $start_column, $length );
.Ve
.PP
You can use \f(CW\*(C`split\*(C'\fR if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.
.PP
.Vb 3
\&    my $line    = \*(Aq fred barney   betty   \*(Aq;
\&    my @columns = split /\es+/, $line;
\&        # ( \*(Aq\*(Aq, \*(Aqfred\*(Aq, \*(Aqbarney\*(Aq, \*(Aqbetty\*(Aq );
\&
\&    my $line    = \*(Aqfred||barney||betty\*(Aq;
\&    my @columns = split /\e|/, $line;
\&        # ( \*(Aqfred\*(Aq, \*(Aq\*(Aq, \*(Aqbarney\*(Aq, \*(Aq\*(Aq, \*(Aqbetty\*(Aq );
.Ve
.PP
If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that format, such as Text::CSV, Text::CSV_XS, or
Text::CSV_PP.
.PP
If you want to break apart an entire line of fixed columns, you can use
\&\f(CW\*(C`unpack\*(C'\fR with the A (\s-1ASCII\s0) format. By using a number after the format
specifier, you can denote the column width. See the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
entries in perlfunc for more details.
.PP
.Vb 1
\&    my @fields = unpack( $line, "A8 A8 A8 A16 A4" );
.Ve
.PP
Note that spaces in the format argument to \f(CW\*(C`unpack\*(C'\fR do not denote literal
spaces. If you have space separated data, you may want \f(CW\*(C`split\*(C'\fR instead.
.SS "How do I find the soundex value of a string?"
.IX Subsection "How do I find the soundex value of a string?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`Text::Soundex\*(C'\fR module. If you want to do fuzzy or close
matching, you might also try the String::Approx, and
Text::Metaphone, and Text::DoubleMetaphone modules.
.SS "How can I expand variables in text strings?"
.IX Subsection "How can I expand variables in text strings?"
(contributed by brian d foy)
.PP
If you can avoid it, don't, or if you can use a templating system,
such as Text::Template or Template Toolkit, do that instead. You
might even be able to get the job done with \f(CW\*(C`sprintf\*(C'\fR or \f(CW\*(C`printf\*(C'\fR:
.PP
.Vb 1
\&    my $string = sprintf \*(AqSay hello to %s and %s\*(Aq, $foo, $bar;
.Ve
.PP
However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand \f(CW$foo\fR and \f(CW$bar\fR
to their variable's values:
.PP
.Vb 3
\&    my $foo = \*(AqFred\*(Aq;
\&    my $bar = \*(AqBarney\*(Aq;
\&    $string = \*(AqSay hello to $foo and $bar\*(Aq;
.Ve
.PP
One way I can do this involves the substitution operator and a double
\&\f(CW\*(C`/e\*(C'\fR flag. The first \f(CW\*(C`/e\*(C'\fR evaluates \f(CW$1\fR on the replacement side and
turns it into \f(CW$foo\fR. The second /e starts with \f(CW$foo\fR and replaces
it with its value. \f(CW$foo\fR, then, turns into 'Fred', and that's finally
what's left in the string:
.PP
.Vb 1
\&    $string =~ s/(\e$\ew+)/$1/eeg; # \*(AqSay hello to Fred and Barney\*(Aq
.Ve
.PP
The \f(CW\*(C`/e\*(C'\fR will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
\&\f(CW\*(C`/e\*(C'\fR flag (twice even!), I have all of the same security problems I
have with \f(CW\*(C`eval\*(C'\fR in its string form. If there's something odd in
\&\f(CW$foo\fR, perhaps something like \f(CW\*(C`@{[ system "rm \-rf /" ]}\*(C'\fR, then
I could get myself in trouble.
.PP
To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single \f(CW\*(C`/e\*(C'\fR, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case \f(CW\*(C`???\*(C'\fR to
signal that I missed something:
.PP
.Vb 1
\&    my $string = \*(AqThis has $foo and $bar\*(Aq;
\&
\&    my %Replacements = (
\&        foo  => \*(AqFred\*(Aq,
\&        );
\&
\&    # $string =~ s/\e$(\ew+)/$Replacements{$1}/g;
\&    $string =~ s/\e$(\ew+)/
\&        exists $Replacements{$1} ? $Replacements{$1} : \*(Aq???\*(Aq
\&        /eg;
\&
\&    print $string;
.Ve
.ie n .SS "What's wrong with always quoting ""$vars""?"
.el .SS "What's wrong with always quoting ``$vars''?"
.IX Subsection "What's wrong with always quoting $vars?"
The problem is that those double-quotes force
stringification\*(--coercing numbers and references into strings\*(--even
when you don't want them to be strings. Think of it this way:
double-quote expansion is used to produce new strings. If you already
have a string, why do you need more?
.PP
If you get used to writing odd things like these:
.PP
.Vb 3
\&    print "$var";       # BAD
\&    my $new = "$old";       # BAD
\&    somefunc("$var");    # BAD
.Ve
.PP
You'll be in trouble. Those should (in 99.8% of the cases) be
the simpler and more direct:
.PP
.Vb 3
\&    print $var;
\&    my $new = $old;
\&    somefunc($var);
.Ve
.PP
Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:
.PP
.Vb 5
\&    func(\e@array);
\&    sub func {
\&        my $aref = shift;
\&        my $oref = "$aref";  # WRONG
\&    }
.Ve
.PP
You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical \f(CW\*(C`++\*(C'\fR autoincrement operator or the
\&\fIsyscall()\fR function.
.PP
Stringification also destroys arrays.
.PP
.Vb 3
\&    my @lines = \`command\`;
\&    print "@lines";     # WRONG \- extra blanks
\&    print @lines;       # right
.Ve
.SS "Why don't my <<\s-1HERE\s0 documents work?"
.IX Subsection "Why don't my <<HERE documents work?"
Here documents are found in perlop. Check for these three things:
.IP "There must be no space after the << part." 4
.IX Item "There must be no space after the << part."
.PD 0
.IP "There (probably) should be a semicolon at the end of the opening token" 4
.IX Item "There (probably) should be a semicolon at the end of the opening token"
.IP "You can't (easily) have any space in front of the tag." 4
.IX Item "You can't (easily) have any space in front of the tag."
.IP "There needs to be at least a line separator after the end token." 4
.IX Item "There needs to be at least a line separator after the end token."
.PD
.PP
If you want to indent the text in the here document, you
can do this:
.PP
.Vb 5
\&    # all in one
\&    (my $VAR = <<HERE_TARGET) =~ s/^\es+//gm;
\&        your text
\&        goes here
\&    HERE_TARGET
.Ve
.PP
But the \s-1HERE_TARGET\s0 must still be flush against the margin.
If you want that indented also, you'll have to quote
in the indentation.
.PP
.Vb 7
\&    (my $quote = <<\*(Aq    FINIS\*(Aq) =~ s/^\es+//gm;
\&            ...we will have peace, when you and all your works have
\&            perished\-\-and the works of your dark master to whom you
\&            would deliver us. You are a liar, Saruman, and a corrupter
\&            of men\*(Aqs hearts. \-\-Theoden in /usr/src/perl/taint.c
\&        FINIS
\&    $quote =~ s/\es+\-\-/\en\-\-/;
.Ve
.PP
A nice general-purpose fixer-upper function for indented here documents
follows. It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off. Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.
.PP
.Vb 11
\&    sub fix {
\&        local $_ = shift;
\&        my ($white, $leader);  # common whitespace and common leading string
\&        if (/^\es*(?:([^\ew\es]+)(\es*).*\en)(?:\es*\eg1\eg2?.*\en)+$/) {
\&            ($white, $leader) = ($2, quotemeta($1));
\&        } else {
\&            ($white, $leader) = (/^(\es+)/, \*(Aq\*(Aq);
\&        }
\&        s/^\es*?$leader(?:$white)?//gm;
\&        return $_;
\&    }
.Ve
.PP
This works with leading special strings, dynamically determined:
.PP
.Vb 10
\&    my $remember_the_main = fix<<\*(Aq    MAIN_INTERPRETER_LOOP\*(Aq;
\&    @@@ int
\&    @@@ runops() {
\&    @@@     SAVEI32(runlevel);
\&    @@@     runlevel++;
\&    @@@     while ( op = (*op\->op_ppaddr)() );
\&    @@@     TAINT_NOT;
\&    @@@     return 0;
\&    @@@ }
\&    MAIN_INTERPRETER_LOOP
.Ve
.PP
Or with a fixed amount of leading whitespace, with remaining
indentation correctly preserved:
.PP
.Vb 9
\&    my $poem = fix<<EVER_ON_AND_ON;
\&       Now far ahead the Road has gone,
\&      And I must follow, if I can,
\&       Pursuing it with eager feet,
\&      Until it joins some larger way
\&       Where many paths and errands meet.
\&      And whither then? I cannot say.
\&        \-\-Bilbo in /usr/src/perl/pp_ctl.c
\&    EVER_ON_AND_ON
.Ve
.SH "Data: Arrays"
.IX Header "Data: Arrays"
.SS "What is the difference between a list and an array?"
.IX Subsection "What is the difference between a list and an array?"
(contributed by brian d foy)
.PP
A list is a fixed collection of scalars. An array is a variable that
holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:
.PP
.Vb 3
\&    # slices
\&    ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq )[2,3];
\&    @animals[2,3];
\&
\&    # iteration
\&    foreach ( qw( dog cat bird ) ) { ... }
\&    foreach ( @animals ) { ... }
\&
\&    my @three = grep { length == 3 } qw( dog cat bird );
\&    my @three = grep { length == 3 } @animals;
\&
\&    # supply an argument list
\&    wash_animals( qw( dog cat bird ) );
\&    wash_animals( @animals );
.Ve
.PP
Array operations, which change the scalars, rearrange them, or add
or subtract some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR,
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, and \f(CW\*(C`splice\*(C'\fR.
.PP
An array can also change its length:
.PP
.Vb 2
\&    $#animals = 1;  # truncate to two elements
\&    $#animals = 10000; # pre\-extend to 10,001 elements
.Ve
.PP
You can change an array element, but you can't change a list element:
.PP
.Vb 2
\&    $animals[0] = \*(AqRottweiler\*(Aq;
\&    qw( dog cat bird )[0] = \*(AqRottweiler\*(Aq; # syntax error!
\&
\&    foreach ( @animals ) {
\&        s/^d/fr/;  # works fine
\&    }
\&
\&    foreach ( qw( dog cat bird ) ) {
\&        s/^d/fr/;  # Error! Modification of read only value!
\&    }
.Ve
.PP
However, if the list element is itself a variable, it appears that you
can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.
.PP
You also have to be careful about context. You can assign an array to
a scalar to get the number of elements in the array. This only works
for arrays, though:
.PP
.Vb 1
\&    my $count = @animals;  # only works with arrays
.Ve
.PP
If you try to do the same thing with what you think is a list, you
get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:
.PP
.Vb 1
\&    my $scalar = ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq );  # $scalar gets bird
.Ve
.PP
Since you're assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to \f(CW$scalar\fR it's rightmost value. Many
people mess this up because they choose a list-lookalike whose
last element is also the count they expect:
.PP
.Vb 1
\&    my $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally
.Ve
.ie n .SS "What is the difference between $array[1] and @array[1]?"
.el .SS "What is the difference between \f(CW$array\fP[1] and \f(CW@array\fP[1]?"
.IX Subsection "What is the difference between $array[1] and @array[1]?"
(contributed by brian d foy)
.PP
The difference is the sigil, that special character in front of the
array name. The \f(CW\*(C`$\*(C'\fR sigil means \*(L"exactly one item\*(R", while the \f(CW\*(C`@\*(C'\fR
sigil means \*(L"zero or more items\*(R". The \f(CW\*(C`$\*(C'\fR gets you a single scalar,
while the \f(CW\*(C`@\*(C'\fR gets you a list.
.PP
The confusion arises because people incorrectly assume that the sigil
denotes the variable type.
.PP
The \f(CW$array[1]\fR is a single-element access to the array. It's going
to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.
.PP
The \f(CW@array[1]\fR is an array slice, although it has only one index.
You can pull out multiple elements simultaneously by specifying
additional indices as a list, like \f(CW@array[1,4,3,0]\fR.
.PP
Using a slice on the lefthand side of the assignment supplies list
context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:
.PP
.Vb 1
\&    $array[1] = <STDIN>;
.Ve
.PP
However, in list context, the line input operator returns all of the
lines as a list. The first line goes into \f(CW@array[1]\fR and the rest
of the lines mysteriously disappear:
.PP
.Vb 1
\&    @array[1] = <STDIN>;  # most likely not what you want
.Ve
.PP
Either the \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR flag will warn you when
you use an array slice with a single index.
.SS "How can I remove duplicate elements from a list or array?"
.IX Subsection "How can I remove duplicate elements from a list or array?"
(contributed by brian d foy)
.PP
Use a hash. When you think the words \*(L"unique\*(R" or \*(L"duplicated\*(R", think
\&\*(L"hash keys\*(R".
.PP
If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use \f(CW\*(C`keys\*(C'\fR to get the unique
elements.
.PP
.Vb 3
\&    my %hash   = map { $_, 1 } @array;
\&    # or a hash slice: @hash{ @array } = ();
\&    # or a foreach: $hash{$_} = 1 foreach ( @array );
\&
\&    my @unique = keys %hash;
.Ve
.PP
If you want to use a module, try the \f(CW\*(C`uniq\*(C'\fR function from
List::MoreUtils. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.
.PP
.Vb 1
\&    use List::MoreUtils qw(uniq);
\&
\&    my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
\&    my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7
.Ve
.PP
You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in \f(CW%Seen\fR. The \f(CW\*(C`next\*(C'\fR statement
creates the key and immediately uses its value, which is \f(CW\*(C`undef\*(C'\fR, so
the loop continues to the \f(CW\*(C`push\*(C'\fR and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash \fIand\fR the value for that key is true (since it's not 0 or
\&\f(CW\*(C`undef\*(C'\fR), so the next skips that iteration and the loop goes to the
next element.
.PP
.Vb 2
\&    my @unique = ();
\&    my %seen   = ();
\&
\&    foreach my $elem ( @array ) {
\&        next if $seen{ $elem }++;
\&        push @unique, $elem;
\&    }
.Ve
.PP
You can write this more briefly using a grep, which does the
same thing.
.PP
.Vb 2
\&    my %seen = ();
\&    my @unique = grep { ! $seen{ $_ }++ } @array;
.Ve
.SS "How can I tell whether a certain element is contained in a list or array?"
.IX Subsection "How can I tell whether a certain element is contained in a list or array?"
(portions of this answer contributed by Anno Siegel and brian d foy)
.PP
Hearing the word \*(L"in\*(R" is an \fIin\fRdication that you probably should have
used a hash, not a list or array, to store your data. Hashes are
designed to answer this question quickly and efficiently. Arrays aren't.
.PP
That being said, there are several ways to approach this. In Perl 5.10
and later, you can use the smart match operator to check that an item is
contained in an array or a hash:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( $item ~~ @array ) {
\&        say "The array contains $item"
\&    }
\&
\&    if( $item ~~ %hash ) {
\&        say "The hash contains $item"
\&    }
.Ve
.PP
With earlier versions of Perl, you have to do a bit more work. If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values:
.PP
.Vb 3
\&    my @blues = qw/azure cerulean teal turquoise lapis\-lazuli/;
\&    my %is_blue = ();
\&    for (@blues) { $is_blue{$_} = 1 }
.Ve
.PP
Now you can check whether \f(CW$is_blue{$some_color}\fR. It might have
been a good idea to keep the blues all in a hash in the first place.
.PP
If the values are all small integers, you could use a simple indexed
array. This kind of an array will take up less space:
.PP
.Vb 4
\&    my @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
\&    my @is_tiny_prime = ();
\&    for (@primes) { $is_tiny_prime[$_] = 1 }
\&    # or simply  @istiny_prime[@primes] = (1) x @primes;
.Ve
.PP
Now you check whether \f(CW$is_tiny_prime\fR[$some_number].
.PP
If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:
.PP
.Vb 3
\&    my @articles = ( 1..10, 150..2000, 2017 );
\&    undef $read;
\&    for (@articles) { vec($read,$_,1) = 1 }
.Ve
.PP
Now check whether \f(CW\*(C`vec($read,$n,1)\*(C'\fR is true for some \f(CW$n\fR.
.PP
These methods guarantee fast individual tests but require a re-organization
of the original list or array. They only pay off if you have to test
multiple values against the same array.
.PP
If you are testing only once, the standard module List::Util exports
the function \f(CW\*(C`first\*(C'\fR for this purpose. It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:
.PP
.Vb 7
\&    sub first (&@) {
\&        my $code = shift;
\&        foreach (@_) {
\&            return $_ if &{$code}();
\&        }
\&        undef;
\&    }
.Ve
.PP
If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.
.PP
.Vb 1
\&    my $is_there = grep $_ eq $whatever, @array;
.Ve
.PP
If you want to actually extract the matching elements, simply use grep in
list context.
.PP
.Vb 1
\&    my @matches = grep $_ eq $whatever, @array;
.Ve
.SS "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
.IX Subsection "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
Use a hash. Here's code to do both and more. It assumes that each
element is unique in a given array:
.PP
.Vb 7
\&    my (@union, @intersection, @difference);
\&    my %count = ();
\&    foreach my $element (@array1, @array2) { $count{$element}++ }
\&    foreach my $element (keys %count) {
\&        push @union, $element;
\&        push @{ $count{$element} > 1 ? \e@intersection : \e@difference }, $element;
\&    }
.Ve
.PP
Note that this is the \fIsymmetric difference\fR, that is, all elements
in either A or in B but not in both. Think of it as an xor operation.
.SS "How do I test whether two arrays or hashes are equal?"
.IX Subsection "How do I test whether two arrays or hashes are equal?"
With Perl 5.10 and later, the smart match operator can give you the answer
with the least amount of work:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( @array1 ~~ @array2 ) {
\&        say "The arrays are the same";
\&    }
\&
\&    if( %hash1 ~~ %hash2 ) # doesn\*(Aqt check values!  {
\&        say "The hash keys are the same";
\&    }
.Ve
.PP
The following code works for single-level arrays. It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings. Modify if you have other needs.
.PP
.Vb 1
\&    $are_equal = compare_arrays(\e@frogs, \e@toads);
\&
\&    sub compare_arrays {
\&        my ($first, $second) = @_;
\&        no warnings;  # silence spurious \-w undef complaints
\&        return 0 unless @$first == @$second;
\&        for (my $i = 0; $i < @$first; $i++) {
\&            return 0 if $first\->[$i] ne $second\->[$i];
\&        }
\&        return 1;
\&    }
.Ve
.PP
For multilevel structures, you may wish to use an approach more
like this one. It uses the \s-1CPAN\s0 module FreezeThaw:
.PP
.Vb 2
\&    use FreezeThaw qw(cmpStr);
\&    my @a = my @b = ( "this", "that", [ "more", "stuff" ] );
\&
\&    printf "a and b contain %s arrays\en",
\&        cmpStr(\e@a, \e@b) == 0
\&        ? "the same"
\&        : "different";
.Ve
.PP
This approach also works for comparing hashes. Here we'll demonstrate
two different answers:
.PP
.Vb 1
\&    use FreezeThaw qw(cmpStr cmpStrHard);
\&
\&    my %a = my %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
\&    $a{EXTRA} = \e%b;
\&    $b{EXTRA} = \e%a;
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStr(\e%a, \e%b) == 0 ? "the same" : "different";
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStrHard(\e%a, \e%b) == 0 ? "the same" : "different";
.Ve
.PP
The first reports that both those the hashes contain the same data,
while the second reports that they do not. Which you prefer is left as
an exercise to the reader.
.SS "How do I find the first array element for which a condition is true?"
.IX Subsection "How do I find the first array element for which a condition is true?"
To find the first array element which satisfies a condition, you can
use the \f(CW\*(C`first()\*(C'\fR function in the List::Util module, which comes
with Perl 5.8. This example finds the first element that contains
\&\*(L"Perl\*(R".
.PP
.Vb 1
\&    use List::Util qw(first);
\&
\&    my $element = first { /Perl/ } @array;
.Ve
.PP
If you cannot use List::Util, you can make your own loop to do the
same thing. Once you find the element, you stop the loop with last.
.PP
.Vb 4
\&    my $found;
\&    foreach ( @array ) {
\&        if( /Perl/ ) { $found = $_; last }
\&    }
.Ve
.PP
If you want the array index, use the \f(CW\*(C`firstidx()\*(C'\fR function from
\&\f(CW\*(C`List::MoreUtils\*(C'\fR:
.PP
.Vb 2
\&    use List::MoreUtils qw(firstidx);
\&    my $index = firstidx { /Perl/ } @array;
.Ve
.PP
Or write it yourself, iterating through the indices
and checking the array element at each index until you find one
that satisfies the condition:
.PP
.Vb 8
\&    my( $found, $index ) = ( undef, \-1 );
\&    for( $i = 0; $i < @array; $i++ ) {
\&        if( $array[$i] =~ /Perl/ ) {
\&            $found = $array[$i];
\&            $index = $i;
\&            last;
\&        }
\&    }
.Ve
.SS "How do I handle linked lists?"
.IX Subsection "How do I handle linked lists?"
(contributed by brian d foy)
.PP
Perl's arrays do not have a fixed size, so you don't need linked lists
if you just want to add or remove items. You can use array operations
such as \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, or \f(CW\*(C`splice\*(C'\fR to do
that.
.PP
Sometimes, however, linked lists can be useful in situations where you
want to \*(L"shard\*(R" an array so you have have many small arrays instead of
a single big array. You can keep arrays longer than Perl's largest
array index, lock smaller arrays separately in threaded programs,
reallocate less memory, or quickly insert elements in the middle of
the chain.
.PP
Steve Lembark goes through the details in his \s-1YAPC::NA 2009\s0 talk \*(L"Perly
Linked Lists\*(R" ( <http://www.slideshare.net/lembark/perly\-linked\-lists> ),
although you can just use his LinkedList::Single module.
.SS "How do I handle circular lists?"
.IX Xref "circular array Tie::Cycle Array::Iterator::Circular cycle modulus"
.IX Subsection "How do I handle circular lists?"
(contributed by brian d foy)
.PP
If you want to cycle through an array endlessly, you can increment the
index modulo the number of elements in the array:
.PP
.Vb 2
\&    my @array = qw( a b c );
\&    my $i = 0;
\&
\&    while( 1 ) {
\&        print $array[ $i++ % @array ], "\en";
\&        last if $i > 20;
\&    }
.Ve
.PP
You can also use Tie::Cycle to use a scalar that always has the
next element of the circular array:
.PP
.Vb 1
\&    use Tie::Cycle;
\&
\&    tie my $cycle, \*(AqTie::Cycle\*(Aq, [ qw( FFFFFF 000000 FFFF00 ) ];
\&
\&    print $cycle; # FFFFFF
\&    print $cycle; # 000000
\&    print $cycle; # FFFF00
.Ve
.PP
The Array::Iterator::Circular creates an iterator object for
circular arrays:
.PP
.Vb 1
\&    use Array::Iterator::Circular;
\&
\&    my $color_iterator = Array::Iterator::Circular\->new(
\&        qw(red green blue orange)
\&        );
\&
\&    foreach ( 1 .. 20 ) {
\&        print $color_iterator\->next, "\en";
\&    }
.Ve
.SS "How do I shuffle an array randomly?"
.IX Subsection "How do I shuffle an array randomly?"
If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:
.PP
.Vb 1
\&    use List::Util \*(Aqshuffle\*(Aq;
\&
\&    @shuffled = shuffle(@list);
.Ve
.PP
If not, you can use a Fisher-Yates shuffle.
.PP
.Vb 3
\&    sub fisher_yates_shuffle {
\&        my $deck = shift;  # $deck is a reference to an array
\&        return unless @$deck; # must not be empty!
\&
\&        my $i = @$deck;
\&        while (\-\-$i) {
\&            my $j = int rand ($i+1);
\&            @$deck[$i,$j] = @$deck[$j,$i];
\&        }
\&    }
\&
\&    # shuffle my mpeg collection
\&    #
\&    my @mpeg = <audio/*/*.mp3>;
\&    fisher_yates_shuffle( \e@mpeg );    # randomize @mpeg in place
\&    print @mpeg;
.Ve
.PP
Note that the above implementation shuffles an array in place,
unlike the \f(CW\*(C`List::Util::shuffle()\*(C'\fR which takes a list and returns
a new shuffled list.
.PP
You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with
.PP
.Vb 6
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10;  # just a demo
\&    while (@old) {
\&        push(@new, splice(@old, rand @old, 1));
\&    }
.Ve
.PP
This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.
.SS "How do I process/modify each element of an array?"
.IX Subsection "How do I process/modify each element of an array?"
Use \f(CW\*(C`for\*(C'\fR/\f(CW\*(C`foreach\*(C'\fR:
.PP
.Vb 4
\&    for (@lines) {
\&        s/foo/bar/;    # change that word
\&        tr/XZ/ZX/;    # swap those letters
\&    }
.Ve
.PP
Here's another; let's compute spherical volumes:
.PP
.Vb 5
\&    my @volumes = @radii;
\&    for (@volumes) {   # @volumes has changed parts
\&        $_ **= 3;
\&        $_ *= (4/3) * 3.14159;  # this will be constant folded
\&    }
.Ve
.PP
which can also be done with \f(CW\*(C`map()\*(C'\fR which is made to transform
one list into another:
.PP
.Vb 1
\&    my @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;
.Ve
.PP
If you want to do the same thing to modify the values of the
hash, you can use the \f(CW\*(C`values\*(C'\fR function. As of Perl 5.6
the values are not copied, so if you modify \f(CW$orbit\fR (in this
case), you modify the value.
.PP
.Vb 3
\&    for my $orbit ( values %orbits ) {
\&        ($orbit **= 3) *= (4/3) * 3.14159;
\&    }
.Ve
.PP
Prior to perl 5.6 \f(CW\*(C`values\*(C'\fR returned copies of the values,
so older perl code often contains constructions such as
\&\f(CW@orbits{keys %orbits}\fR instead of \f(CW\*(C`values %orbits\*(C'\fR where
the hash is to be modified.
.SS "How do I select a random element from an array?"
.IX Subsection "How do I select a random element from an array?"
Use the \f(CW\*(C`rand()\*(C'\fR function (see \*(L"rand\*(R" in perlfunc):
.PP
.Vb 2
\&    my $index   = rand @array;
\&    my $element = $array[$index];
.Ve
.PP
Or, simply:
.PP
.Vb 1
\&    my $element = $array[ rand @array ];
.Ve
.SS "How do I permute N elements of a list?"
.IX Xref "List::Permutor permute Algorithm::Loops Knuth The Art of Computer Programming Fischer-Krause"
.IX Subsection "How do I permute N elements of a list?"
Use the List::Permutor module on \s-1CPAN.\s0 If the list is actually an
array, try the Algorithm::Permute module (also on \s-1CPAN\s0). It's
written in \s-1XS\s0 code and is very efficient:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&    my $p_iterator = Algorithm::Permute\->new ( \e@array );
\&
\&    while (my @perm = $p_iterator\->next) {
\&       print "next permutation: (@perm)\en";
\&    }
.Ve
.PP
For even faster execution, you could do:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&
\&    Algorithm::Permute::permute {
\&        print "next permutation: (@array)\en";
\&    } @array;
.Ve
.PP
Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
\&\f(CW\*(C`permute()\*(C'\fR function is discussed in Volume 4 (still unpublished) of
Knuth's \fIThe Art of Computer Programming\fR and will work on any list:
.PP
.Vb 2
\&    #!/usr/bin/perl \-n
\&    # Fischer\-Krause ordered permutation generator
\&
\&    sub permute (&@) {
\&        my $code = shift;
\&        my @idx = 0..$#_;
\&        while ( $code\->(@_[@idx]) ) {
\&            my $p = $#idx;
\&            \-\-$p while $idx[$p\-1] > $idx[$p];
\&            my $q = $p or return;
\&            push @idx, reverse splice @idx, $p;
\&            ++$q while $idx[$p\-1] > $idx[$q];
\&            @idx[$p\-1,$q]=@idx[$q,$p\-1];
\&        }
\&    }
\&
\&    permute { print "@_\en" } split;
.Ve
.PP
The Algorithm::Loops module also provides the \f(CW\*(C`NextPermute\*(C'\fR and
\&\f(CW\*(C`NextPermuteNum\*(C'\fR functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.
.PP
\&\f(CW\*(C`NextPermute\*(C'\fR uses string order and \f(CW\*(C`NextPermuteNum\*(C'\fR numeric order, so
you can enumerate all the permutations of \f(CW0..9\fR like this:
.PP
.Vb 1
\&    use Algorithm::Loops qw(NextPermuteNum);
\&
\&    my @list= 0..9;
\&    do { print "@list\en" } while NextPermuteNum @list;
.Ve
.SS "How do I sort an array by (anything)?"
.IX Subsection "How do I sort an array by (anything)?"
Supply a comparison function to \fIsort()\fR (described in \*(L"sort\*(R" in perlfunc):
.PP
.Vb 1
\&    @list = sort { $a <=> $b } @list;
.Ve
.PP
The default sort function is cmp, string comparison, which would
sort \f(CW\*(C`(1, 2, 10)\*(C'\fR into \f(CW\*(C`(1, 10, 2)\*(C'\fR. \f(CW\*(C`<=>\*(C'\fR, used above, is
the numerical comparison operator.
.PP
If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function. Pull it
out first, because the sort \s-1BLOCK\s0 can be called many times for the
same element. Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.
.PP
.Vb 7
\&    my @idx;
\&    for (@data) {
\&        my $item;
\&        ($item) = /\ed+\es*(\eS+)/;
\&        push @idx, uc($item);
\&    }
\&    my @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
.Ve
.PP
which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:
.PP
.Vb 3
\&    my @sorted = map  { $_\->[0] }
\&        sort { $a\->[1] cmp $b\->[1] }
\&        map  { [ $_, uc( (/\ed+\es*(\eS+)/)[0]) ] } @data;
.Ve
.PP
If you need to sort on several fields, the following paradigm is useful.
.PP
.Vb 5
\&    my @sorted = sort {
\&        field1($a) <=> field1($b) ||
\&        field2($a) cmp field2($b) ||
\&        field3($a) cmp field3($b)
\&    } @data;
.Ve
.PP
This can be conveniently combined with precalculation of keys as given
above.
.PP
See the \fIsort\fR article in the \*(L"Far More Than You Ever Wanted
To Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> for
more about this approach.
.PP
See also the question later in perlfaq4 on sorting hashes.
.SS "How do I manipulate arrays of bits?"
.IX Subsection "How do I manipulate arrays of bits?"
Use \f(CW\*(C`pack()\*(C'\fR and \f(CW\*(C`unpack()\*(C'\fR, or else \f(CW\*(C`vec()\*(C'\fR and the bitwise
operations.
.PP
For example, you don't have to store individual bits in an array
(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use \f(CW\*(C`vec()\*(C'\fR to set the right bits. This
sets \f(CW$vec\fR to have bit N set only if \f(CW$ints[N]\fR was set:
.PP
.Vb 5
\&    my @ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
\&    my $vec = \*(Aq\*(Aq;
\&    foreach( 0 .. $#ints ) {
\&        vec($vec,$_,1) = 1 if $ints[$_];
\&    }
.Ve
.PP
The string \f(CW$vec\fR only takes up as many bits as it needs. For
instance, if you had 16 entries in \f(CW@ints\fR, \f(CW$vec\fR only needs two
bytes to store them (not counting the scalar variable overhead).
.PP
Here's how, given a vector in \f(CW$vec\fR, you can get those bits into
your \f(CW@ints\fR array:
.PP
.Vb 7
\&    sub bitvec_to_list {
\&        my $vec = shift;
\&        my @ints;
\&        # Find null\-byte density then select best algorithm
\&        if ($vec =~ tr/\e0// / length $vec > 0.95) {
\&            use integer;
\&            my $i;
\&
\&            # This method is faster with mostly null\-bytes
\&            while($vec =~ /[^\e0]/g ) {
\&                $i = \-9 + 8 * pos $vec;
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&            }
\&        }
\&        else {
\&            # This method is a fast general algorithm
\&            use integer;
\&            my $bits = unpack "b*", $vec;
\&            push @ints, 0 if $bits =~ s/^(\ed)// && $1;
\&            push @ints, pos $bits while($bits =~ /1/g);
\&        }
\&
\&        return \e@ints;
\&    }
.Ve
.PP
This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)
.PP
You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:
.PP
.Vb 3
\&    while($vec =~ /[^\e0]+/g ) {
\&        push @ints, grep vec($vec, $_, 1), $\-[0] * 8 .. $+[0] * 8;
\&    }
.Ve
.PP
Or use the \s-1CPAN\s0 module Bit::Vector:
.PP
.Vb 3
\&    my $vector = Bit::Vector\->new($num_of_bits);
\&    $vector\->Index_List_Store(@ints);
\&    my @ints = $vector\->Index_List_Read();
.Ve
.PP
Bit::Vector provides efficient methods for bit vector, sets of
small integers and \*(L"big int\*(R" math.
.PP
Here's a more extensive illustration using \fIvec()\fR:
.PP
.Vb 7
\&    # vec demo
\&    my $vector = "\exff\ex0f\exef\exfe";
\&    print "Ilya\*(Aqs string \e\exff\e\ex0f\e\exef\e\exfe represents the number ",
\&    unpack("N", $vector), "\en";
\&    my $is_set = vec($vector, 23, 1);
\&    print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\en";
\&    pvec($vector);
\&
\&    set_vec(1,1,1);
\&    set_vec(3,1,1);
\&    set_vec(23,1,1);
\&
\&    set_vec(3,1,3);
\&    set_vec(3,2,3);
\&    set_vec(3,4,3);
\&    set_vec(3,4,7);
\&    set_vec(3,8,3);
\&    set_vec(3,8,7);
\&
\&    set_vec(0,32,17);
\&    set_vec(1,32,17);
\&
\&    sub set_vec {
\&        my ($offset, $width, $value) = @_;
\&        my $vector = \*(Aq\*(Aq;
\&        vec($vector, $offset, $width) = $value;
\&        print "offset=$offset width=$width value=$value\en";
\&        pvec($vector);
\&    }
\&
\&    sub pvec {
\&        my $vector = shift;
\&        my $bits = unpack("b*", $vector);
\&        my $i = 0;
\&        my $BASE = 8;
\&
\&        print "vector length in bytes: ", length($vector), "\en";
\&        @bytes = unpack("A8" x length($vector), $bits);
\&        print "bits are: @bytes\en\en";
\&    }
.Ve
.SS "Why does \fIdefined()\fP return true on empty arrays and hashes?"
.IX Subsection "Why does defined() return true on empty arrays and hashes?"
The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes). See \*(L"defined\*(R" in perlfunc
in the 5.004 release or later of Perl for more detail.
.SH "Data: Hashes (Associative Arrays)"
.IX Header "Data: Hashes (Associative Arrays)"
.SS "How do I process an entire hash?"
.IX Subsection "How do I process an entire hash?"
(contributed by brian d foy)
.PP
There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.
.PP
To go through all of the keys, use the \f(CW\*(C`keys\*(C'\fR function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:
.PP
.Vb 4
\&    foreach my $key ( keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Once you have the list of keys, you can process that list before you
process the hash elements. For instance, you can sort the keys so you
can process them in lexical order:
.PP
.Vb 4
\&    foreach my $key ( sort keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Or, you might want to only process some of the items. If you only want
to deal with the keys that start with \f(CW\*(C`text:\*(C'\fR, you can select just
those using \f(CW\*(C`grep\*(C'\fR:
.PP
.Vb 4
\&    foreach my $key ( grep /^text:/, keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab one key-value pair at a time using
\&\f(CW\*(C`each()\*(C'\fR, which returns a pair you haven't seen yet:
.PP
.Vb 3
\&    while( my( $key, $value ) = each( %hash ) ) {
\&        ...
\&    }
.Ve
.PP
The \f(CW\*(C`each\*(C'\fR operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the \f(CW\*(C`keys\*(C'\fR method.
.PP
The \f(CW\*(C`each()\*(C'\fR operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you mix \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR on the same hash, you risk resetting
the iterator and messing up your processing. See the \f(CW\*(C`each\*(C'\fR entry in
perlfunc for more details.
.SS "How do I merge two hashes?"
.IX Xref "hash merge slice, hash"
.IX Subsection "How do I merge two hashes?"
(contributed by brian d foy)
.PP
Before you decide to merge two hashes, you have to decide what to do
if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.
.PP
If you want to preserve the original hashes, copy one hash (\f(CW%hash1\fR)
to a new hash (\f(CW%new_hash\fR), then add the keys from the other hash
(\f(CW%hash2\fR to the new hash. Checking that the key already exists in
\&\f(CW%new_hash\fR gives you a chance to decide what to do with the
duplicates:
.PP
.Vb 1
\&    my %new_hash = %hash1; # make a copy; leave %hash1 alone
\&
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $new_hash{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $new_hash{$key2} = $hash2{$key2};
\&        }
\&    }
.Ve
.PP
If you don't want to create a new hash, you can still use this looping
technique; just change the \f(CW%new_hash\fR to \f(CW%hash1\fR.
.PP
.Vb 11
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $hash1{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $hash1{$key2} = $hash2{$key2};
\&        }
\&      }
.Ve
.PP
If you don't care that one hash overwrites keys and values from the other, you
could just use a hash slice to add one hash to another. In this case, values
from \f(CW%hash2\fR replace values from \f(CW%hash1\fR when they have keys in common:
.PP
.Vb 1
\&    @hash1{ keys %hash2 } = values %hash2;
.Ve
.SS "What happens if I add or remove keys from a hash while iterating over it?"
.IX Subsection "What happens if I add or remove keys from a hash while iterating over it?"
(contributed by brian d foy)
.PP
The easy answer is \*(L"Don't do that!\*(R"
.PP
If you iterate through the hash with \fIeach()\fR, you can delete the key
most recently returned without worrying about it. If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table. See the
entry for \f(CW\*(C`each()\*(C'\fR in perlfunc.
.SS "How do I look up a hash element by value?"
.IX Subsection "How do I look up a hash element by value?"
Create a reverse hash:
.PP
.Vb 2
\&    my %by_value = reverse %by_key;
\&    my $key = $by_value{$value};
.Ve
.PP
That's not particularly efficient. It would be more space-efficient
to use:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&        $by_value{$value} = $key;
\&    }
.Ve
.PP
If your hash could have repeated values, the methods above will only find
one of the associated keys.  This may or may not worry you. If it does
worry you, you can always reverse the hash into a hash of arrays instead:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&         push @{$key_list_by_value{$value}}, $key;
\&    }
.Ve
.SS "How can I know how many entries are in a hash?"
.IX Subsection "How can I know how many entries are in a hash?"
(contributed by brian d foy)
.PP
This is very similar to \*(L"How do I process an entire hash?\*(R", also in
perlfaq4, but a bit simpler in the common cases.
.PP
You can use the \f(CW\*(C`keys()\*(C'\fR built-in function in scalar context to find out
have many entries you have in a hash:
.PP
.Vb 1
\&    my $key_count = keys %hash; # must be scalar context!
.Ve
.PP
If you want to find out how many entries have a defined value, that's
a bit different. You have to check each value. A \f(CW\*(C`grep\*(C'\fR is handy:
.PP
.Vb 1
\&    my $defined_value_count = grep { defined } values %hash;
.Ve
.PP
You can use that same structure to count the entries any way that
you like. If you want the count of the keys with vowels in them,
you just test for that instead:
.PP
.Vb 1
\&    my $vowel_count = grep { /[aeiou]/ } keys %hash;
.Ve
.PP
The \f(CW\*(C`grep\*(C'\fR in scalar context returns the count. If you want the list
of matching items, just use it in list context instead:
.PP
.Vb 1
\&    my @defined_values = grep { defined } values %hash;
.Ve
.PP
The \f(CW\*(C`keys()\*(C'\fR function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
such as \f(CW\*(C`each()\*(C'\fR.
.SS "How do I sort a hash (optionally by value instead of key)?"
.IX Subsection "How do I sort a hash (optionally by value instead of key)?"
(contributed by brian d foy)
.PP
To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.
.PP
.Vb 1
\&    my @keys = sort { $a cmp $b } keys %hash;
\&
\&    foreach my $key ( @keys ) {
\&        printf "%\-20s %6d\en", $key, $hash{$key};
\&    }
.Ve
.PP
We could get more fancy in the \f(CW\*(C`sort()\*(C'\fR block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.
.PP
For instance, to make our report order case-insensitive, we use
\&\f(CW\*(C`lc\*(C'\fR to lowercase the keys before comparing them:
.PP
.Vb 1
\&    my @keys = sort { lc $a cmp lc $b } keys %hash;
.Ve
.PP
Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.
.PP
If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.
.PP
.Vb 1
\&    my @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;
.Ve
.PP
From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.
.PP
.Vb 5
\&    my @keys = sort {
\&        $hash{$a} <=> $hash{$b}
\&            or
\&        "\eL$a" cmp "\eL$b"
\&    } keys %hash;
.Ve
.SS "How can I always keep my hash sorted?"
.IX Xref "hash tie sort DB_File Tie::IxHash"
.IX Subsection "How can I always keep my hash sorted?"
You can look into using the \f(CW\*(C`DB_File\*(C'\fR module and \f(CW\*(C`tie()\*(C'\fR using the
\&\f(CW$DB_BTREE\fR hash bindings as documented in \*(L"In Memory
Databases\*(R" in DB_File. The Tie::IxHash module from \s-1CPAN\s0 might also be
instructive. Although this does keep your hash sorted, you might not
like the slowdown you suffer from the tie interface. Are you sure you
need to do this? :)
.ie n .SS "What's the difference between ""delete"" and ""undef"" with hashes?"
.el .SS "What's the difference between ``delete'' and ``undef'' with hashes?"
.IX Subsection "What's the difference between delete and undef with hashes?"
Hashes contain pairs of scalars: the first is the key, the
second is the value. The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference. If a key \f(CW$key\fR is present in
\&\f(CW%hash\fR, \f(CW\*(C`exists($hash{$key})\*(C'\fR will return true. The value
for a given key can be \f(CW\*(C`undef\*(C'\fR, in which case
\&\f(CW$hash{$key}\fR will be \f(CW\*(C`undef\*(C'\fR while \f(CW\*(C`exists $hash{$key}\*(C'\fR
will return true. This corresponds to (\f(CW$key\fR, \f(CW\*(C`undef\*(C'\fR)
being in the hash.
.PP
Pictures help... Here's the \f(CW%hash\fR table:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   |  3   |
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
And these conditions hold
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is true
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is true
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
If you now say
.PP
.Vb 1
\&    undef $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   | undef|
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is FALSE
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is FALSE
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
Notice the last two: you have an undef value, but a defined key!
.PP
Now, consider this:
.PP
.Vb 1
\&    delete $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 6
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is false
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is false
\&    exists $hash{\*(Aqa\*(Aq}                is FALSE (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is FALSE
.Ve
.PP
See, the whole entry is gone!
.SS "Why don't my tied hashes make the defined/exists distinction?"
.IX Subsection "Why don't my tied hashes make the defined/exists distinction?"
This depends on the tied hash's implementation of \s-1\fIEXISTS\s0()\fR.
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that \fIexists()\fR and
\&\fIdefined()\fR do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.
.SS "How do I reset an \fIeach()\fP operation part-way through?"
.IX Subsection "How do I reset an each() operation part-way through?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR functions to reset \f(CW\*(C`each\*(C'\fR. To
simply reset the iterator used by \f(CW\*(C`each\*(C'\fR without doing anything else,
use one of them in void context:
.PP
.Vb 2
\&    keys %hash; # resets iterator, nothing else.
\&    values %hash; # resets iterator, nothing else.
.Ve
.PP
See the documentation for \f(CW\*(C`each\*(C'\fR in perlfunc.
.SS "How can I get the unique keys from two hashes?"
.IX Subsection "How can I get the unique keys from two hashes?"
First you extract the keys from the hashes into lists, then solve
the \*(L"removing duplicates\*(R" problem described above. For example:
.PP
.Vb 5
\&    my %seen = ();
\&    for my $element (keys(%foo), keys(%bar)) {
\&        $seen{$element}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.PP
Or more succinctly:
.PP
.Vb 1
\&    my @uniq = keys %{{%foo,%bar}};
.Ve
.PP
Or if you really want to save space:
.PP
.Vb 8
\&    my %seen = ();
\&    while (defined ($key = each %foo)) {
\&        $seen{$key}++;
\&    }
\&    while (defined ($key = each %bar)) {
\&        $seen{$key}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.SS "How can I store a multidimensional array in a \s-1DBM\s0 file?"
.IX Subsection "How can I store a multidimensional array in a DBM file?"
Either stringify the structure yourself (no fun), or else
get the \s-1MLDBM \s0(which uses Data::Dumper) module from \s-1CPAN\s0 and layer
it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but
it can be a bit slow.
.SS "How can I make my hash remember the order I put elements into it?"
.IX Subsection "How can I make my hash remember the order I put elements into it?"
Use the Tie::IxHash from \s-1CPAN.\s0
.PP
.Vb 1
\&    use Tie::IxHash;
\&
\&    tie my %myhash, \*(AqTie::IxHash\*(Aq;
\&
\&    for (my $i=0; $i<20; $i++) {
\&        $myhash{$i} = 2*$i;
\&    }
\&
\&    my @keys = keys %myhash;
\&    # @keys = (0,1,2,3,...)
.Ve
.SS "Why does passing a subroutine an undefined element in a hash create it?"
.IX Subsection "Why does passing a subroutine an undefined element in a hash create it?"
(contributed by brian d foy)
.PP
Are you using a really old version of Perl?
.PP
Normally, accessing a hash key's value for a nonexistent key will
\&\fInot\fR create the key.
.PP
.Vb 3
\&    my %hash  = ();
\&    my $value = $hash{ \*(Aqfoo\*(Aq };
\&    print "This won\*(Aqt print\en" if exists $hash{ \*(Aqfoo\*(Aq };
.Ve
.PP
Passing \f(CW$hash{ \*(Aqfoo\*(Aq }\fR to a subroutine used to be a special case, though.
Since you could assign directly to \f(CW$_[0]\fR, Perl had to be ready to
make that assignment so it created the hash key ahead of time:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print before 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        # $_[0] = \*(Aqbar\*(Aq; # create hash key in case you do this
\&        1;
\&    }
.Ve
.PP
Since Perl 5.004, however, this situation is a special case and Perl
creates the hash key only when you make the assignment:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print, even after 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        $_[0] = \*(Aqbar\*(Aq;
\&    }
.Ve
.PP
However, if you want the old behavior (and think carefully about that
because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:
.PP
.Vb 1
\&    my_sub( @hash{ qw/foo/ } );
.Ve
.SS "How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"
.IX Subsection "How can I make the Perl equivalent of a C structure/ class/hash or array of hashes or arrays?"
Usually a hash ref, perhaps like this:
.PP
.Vb 8
\&    $record = {
\&        NAME   => "Jason",
\&        EMPNO  => 132,
\&        TITLE  => "deputy peon",
\&        AGE    => 23,
\&        SALARY => 37_000,
\&        PALS   => [ "Norbert", "Rhys", "Phineas"],
\&    };
.Ve
.PP
References are documented in perlref and perlreftut.
Examples of complex data structures are given in perldsc and
perllol. Examples of structures and object-oriented classes are
in perltoot.
.SS "How can I use a reference as a hash key?"
.IX Subsection "How can I use a reference as a hash key?"
(contributed by brian d foy and Ben Morrow)
.PP
Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, \f(CW\*(C`HASH(0xDEADBEEF)\*(C'\fR). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own.
.PP
Remember that the entry in the hash will still be there even if
the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.
.PP
If you have Perl 5.10 or later, and you just want to store a value
against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.
.PP
If you actually need to be able to get a real reference back from
each hash entry, you can use the Tie::RefHash module, which does the
required work for you.
.SS "How can I check if a key exists in a multilevel hash?"
.IX Subsection "How can I check if a key exists in a multilevel hash?"
(contributed by brian d foy)
.PP
The trick to this problem is avoiding accidental autovivification. If
you want to check three keys deep, you might nai\*:vely try this:
.PP
.Vb 4
\&    my %hash;
\&    if( exists $hash{key1}{key2}{key3} ) {
\&        ...;
\&    }
.Ve
.PP
Even though you started with a completely empty hash, after that call to
\&\f(CW\*(C`exists\*(C'\fR you've created the structure you needed to check for \f(CW\*(C`key3\*(C'\fR:
.PP
.Vb 5
\&    %hash = (
\&              \*(Aqkey1\*(Aq => {
\&                          \*(Aqkey2\*(Aq => {}
\&                        }
\&            );
.Ve
.PP
That's autovivification. You can get around this in a few ways. The
easiest way is to just turn it off. The lexical \f(CW\*(C`autovivification\*(C'\fR
pragma is available on \s-1CPAN.\s0 Now you don't add to the hash:
.PP
.Vb 7
\&    {
\&        no autovivification;
\&        my %hash;
\&        if( exists $hash{key1}{key2}{key3} ) {
\&            ...;
\&        }
\&    }
.Ve
.PP
The Data::Diver module on \s-1CPAN\s0 can do it for you too. Its \f(CW\*(C`Dive\*(C'\fR
subroutine can tell you not only if the keys exist but also get the
value:
.PP
.Vb 1
\&    use Data::Diver qw(Dive);
\&
\&    my @exists = Dive( \e%hash, qw(key1 key2 key3) );
\&    if(  ! @exists  ) {
\&        ...; # keys do not exist
\&    }
\&    elsif(  ! defined $exists[0]  ) {
\&        ...; # keys exist but value is undef
\&    }
.Ve
.PP
You can easily do this yourself too by checking each level of the hash
before you move onto the next level. This is essentially what
Data::Diver does for you:
.PP
.Vb 3
\&    if( check_hash( \e%hash, qw(key1 key2 key3) ) ) {
\&        ...;
\&    }
\&
\&    sub check_hash {
\&       my( $hash, @keys ) = @_;
\&
\&       return unless @keys;
\&
\&       foreach my $key ( @keys ) {
\&           return unless eval { exists $hash\->{$key} };
\&           $hash = $hash\->{$key};
\&        }
\&
\&       return 1;
\&    }
.Ve
.SS "How can I prevent addition of unwanted keys into a hash?"
.IX Subsection "How can I prevent addition of unwanted keys into a hash?"
Since version 5.8.0, hashes can be \fIrestricted\fR to a fixed number
of given keys. Methods for creating and dealing with restricted hashes
are exported by the Hash::Util module.
.SH "Data: Misc"
.IX Header "Data: Misc"
.SS "How do I handle binary data correctly?"
.IX Subsection "How do I handle binary data correctly?"
Perl is binary-clean, so it can handle binary data just fine.
On Windows or \s-1DOS,\s0 however, you have to use \f(CW\*(C`binmode\*(C'\fR for binary
files to avoid conversions for line endings. In general, you should
use \f(CW\*(C`binmode\*(C'\fR any time you want to work with binary data.
.PP
Also see \*(L"binmode\*(R" in perlfunc or perlopentut.
.PP
If you're concerned about 8\-bit textual data then see perllocale.
If you want to deal with multibyte characters, however, there are
some gotchas. See the section on Regular Expressions.
.SS "How do I determine whether a scalar is a number/whole/integer/float?"
.IX Subsection "How do I determine whether a scalar is a number/whole/integer/float?"
Assuming that you don't care about \s-1IEEE\s0 notations like \*(L"NaN\*(R" or
\&\*(L"Infinity\*(R", you probably just want to use a regular expression:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given( $number ) {
\&        when( /\eD/ )
\&            { say "\ethas nondigits"; continue }
\&        when( /^\ed+\ez/ )
\&            { say "\etis a whole number"; continue }
\&        when( /^\-?\ed+\ez/ )
\&            { say "\etis an integer"; continue }
\&        when( /^[+\-]?\ed+\ez/ )
\&            { say "\etis a +/\- integer"; continue }
\&        when( /^\-?(?:\ed+\e.?|\e.\ed)\ed*\ez/ )
\&            { say "\etis a real number"; continue }
\&        when( /^[+\-]?(?=\e.?\ed)\ed*\e.?\ed*(?:e[+\-]?\ed+)?\ez/i)
\&            { say "\etis a C float" }
\&    }
.Ve
.PP
There are also some commonly used modules for the task.
Scalar::Util (distributed with 5.8) provides access to perl's
internal function \f(CW\*(C`looks_like_number\*(C'\fR for determining whether a
variable looks like a number. Data::Types exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is Regexp::Common which has regular
expressions to match various types of numbers. Those three modules are
available from the \s-1CPAN.\s0
.PP
If you're on a \s-1POSIX\s0 system, Perl supports the \f(CW\*(C`POSIX::strtod\*(C'\fR
function for converting strings to doubles (and also \f(CW\*(C`POSIX::strtol\*(C'\fR
for longs). Its semantics are somewhat cumbersome, so here's a
\&\f(CW\*(C`getnum\*(C'\fR wrapper function for more convenient access. This function
takes a string and returns the number it found, or \f(CW\*(C`undef\*(C'\fR for input
that isn't a C float. The \f(CW\*(C`is_numeric\*(C'\fR function is a front end to
\&\f(CW\*(C`getnum\*(C'\fR if you just want to say, \*(L"Is this a float?\*(R"
.PP
.Vb 10
\&    sub getnum {
\&        use POSIX qw(strtod);
\&        my $str = shift;
\&        $str =~ s/^\es+//;
\&        $str =~ s/\es+$//;
\&        $! = 0;
\&        my($num, $unparsed) = strtod($str);
\&        if (($str eq \*(Aq\*(Aq) || ($unparsed != 0) || $!) {
\&                return undef;
\&        }
\&        else {
\&            return $num;
\&        }
\&    }
\&
\&    sub is_numeric { defined getnum($_[0]) }
.Ve
.PP
Or you could check out the String::Scanf module on the \s-1CPAN\s0
instead.
.SS "How do I keep persistent data across program calls?"
.IX Subsection "How do I keep persistent data across program calls?"
For some specific applications, you can use one of the \s-1DBM\s0 modules.
See AnyDBM_File. More generically, you should consult the FreezeThaw
or Storable modules from \s-1CPAN.\s0 Starting from Perl 5.8, Storable is part
of the standard distribution. Here's one example using Storable's \f(CW\*(C`store\*(C'\fR
and \f(CW\*(C`retrieve\*(C'\fR functions:
.PP
.Vb 2
\&    use Storable;
\&    store(\e%hash, "filename");
\&
\&    # later on...
\&    $href = retrieve("filename");        # by ref
\&    %hash = %{ retrieve("filename") };   # direct to hash
.Ve
.SS "How do I print out or copy a recursive data structure?"
.IX Subsection "How do I print out or copy a recursive data structure?"
The Data::Dumper module on \s-1CPAN \s0(or the 5.005 release of Perl) is great
for printing out data structures. The Storable module on \s-1CPAN \s0(or the
5.8 release of Perl), provides a function called \f(CW\*(C`dclone\*(C'\fR that recursively
copies its argument.
.PP
.Vb 2
\&    use Storable qw(dclone);
\&    $r2 = dclone($r1);
.Ve
.PP
Where \f(CW$r1\fR can be a reference to any kind of data structure you'd like.
It will be deeply copied. Because \f(CW\*(C`dclone\*(C'\fR takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.
.PP
.Vb 1
\&    %newhash = %{ dclone(\e%oldhash) };
.Ve
.SS "How do I define methods for every class/object?"
.IX Subsection "How do I define methods for every class/object?"
(contributed by Ben Morrow)
.PP
You can use the \f(CW\*(C`UNIVERSAL\*(C'\fR class (see \s-1UNIVERSAL\s0). However, please
be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.
.SS "How do I verify a credit card checksum?"
.IX Subsection "How do I verify a credit card checksum?"
Get the Business::CreditCard module from \s-1CPAN.\s0
.SS "How do I pack arrays of doubles or floats for \s-1XS\s0 code?"
.IX Subsection "How do I pack arrays of doubles or floats for XS code?"
The arrays.h/arrays.c code in the \s-1PGPLOT\s0 module on \s-1CPAN\s0 does just this.
If you're doing a lot of float or double processing, consider using
the \s-1PDL\s0 module from \s-1CPAN\s0 instead\*(--it makes number-crunching easy.
.PP
See <http://search.cpan.org/dist/PGPLOT> for the code.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq45.16.1                               0100644 0001750 0001750 00000326664 12566207416 023012  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ4 1"
.TH PERLFAQ4 1 "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq4 \- Data Manipulation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.SH "Data: Numbers"
.IX Header "Data: Numbers"
.SS "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
.IX Subsection "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
For the long explanation, see David Goldberg's \*(L"What Every Computer
Scientist Should Know About Floating-Point Arithmetic\*(R"
(<http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf>).
.PP
Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly. Some real numbers lose precision in the process. This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.
.PP
perlnumber shows the gory details of number representations and
conversions.
.PP
To limit the number of decimal places in your numbers, you can use the
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`sprintf\*(C'\fR function. See
\&\*(L"Floating-point Arithmetic\*(R" in perlop for more details.
.PP
.Vb 1
\&    printf "%.2f", 10/3;
\&
\&    my $number = sprintf "%.2f", 10/3;
.Ve
.SS "Why is \fIint()\fP broken?"
.IX Subsection "Why is int() broken?"
Your \f(CW\*(C`int()\*(C'\fR is most probably working just fine. It's the numbers that
aren't quite what you think.
.PP
First, see the answer to \*(L"Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?\*(R".
.PP
For example, this
.PP
.Vb 1
\&    print int(0.6/0.2\-2), "\en";
.Ve
.PP
will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers. What you think in the above as 'three' is really more like
2.9999999999999995559.
.SS "Why isn't my octal data interpreted correctly?"
.IX Subsection "Why isn't my octal data interpreted correctly?"
(contributed by brian d foy)
.PP
You're probably trying to convert a string to a number, which Perl only
converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:
.PP
.Vb 1
\&    my $string = \*(Aq0644\*(Aq;
\&
\&    print $string + 0;  # prints 644
\&
\&    print $string + 44; # prints 688, certainly not octal!
.Ve
.PP
This problem usually involves one of the Perl built-ins that has the
same name a Unix command that uses octal numbers as arguments on the
command line. In this example, \f(CW\*(C`chmod\*(C'\fR on the command line knows that
its first argument is octal because that's what it does:
.PP
.Vb 1
\&    %prompt> chmod 644 file
.Ve
.PP
If you want to use the same literal digits (644) in Perl, you have to tell
Perl to treat them as octal numbers either by prefixing the digits with
a \f(CW0\fR or using \f(CW\*(C`oct\*(C'\fR:
.PP
.Vb 2
\&    chmod(     0644, $filename );  # right, has leading zero
\&    chmod( oct(644), $filename );  # also correct
.Ve
.PP
The problem comes in when you take your numbers from something that Perl
thinks is a string, such as a command line argument in \f(CW@ARGV\fR:
.PP
.Vb 1
\&    chmod( $ARGV[0],      $filename );  # wrong, even if "0644"
\&
\&    chmod( oct($ARGV[0]), $filename );  # correct, treat string as octal
.Ve
.PP
You can always check the value you're using by printing it in octal
notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:
.PP
.Vb 1
\&    printf "0%o %d", $number, $number;
.Ve
.SS "Does Perl have a \fIround()\fP function? What about \fIceil()\fP and \fIfloor()\fP? Trig functions?"
.IX Subsection "Does Perl have a round() function? What about ceil() and floor()? Trig functions?"
Remember that \f(CW\*(C`int()\*(C'\fR merely truncates toward 0. For rounding to a
certain number of digits, \f(CW\*(C`sprintf()\*(C'\fR or \f(CW\*(C`printf()\*(C'\fR is usually the
easiest route.
.PP
.Vb 1
\&    printf("%.3f", 3.1415926535);   # prints 3.142
.Ve
.PP
The \s-1POSIX\s0 module (part of the standard Perl distribution)
implements \f(CW\*(C`ceil()\*(C'\fR, \f(CW\*(C`floor()\*(C'\fR, and a number of other mathematical
and trigonometric functions.
.PP
.Vb 3
\&    use POSIX;
\&    my $ceil   = ceil(3.5);   # 4
\&    my $floor  = floor(3.5);  # 3
.Ve
.PP
In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex
module. With 5.004, the Math::Trig module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the Math::Complex module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.
.PP
Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely. In these
cases, it probably pays not to trust whichever system of rounding is
being used by Perl, but instead to implement the rounding function you
need yourself.
.PP
To see why, notice how you'll still have an issue on half-way-point
alternation:
.PP
.Vb 1
\&    for (my $i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
\&
\&    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
\&    0.8 0.8 0.9 0.9 1.0 1.0
.Ve
.PP
Don't blame Perl. It's the same as in C. \s-1IEEE\s0 says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32\-bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.
.SS "How do I convert between numeric representations/bases/radixes?"
.IX Subsection "How do I convert between numeric representations/bases/radixes?"
As always with Perl there is more than one way to do it. Below are a
few examples of approaches to making common conversions between number
representations. This is intended to be representational rather than
exhaustive.
.PP
Some of the examples later in perlfaq4 use the Bit::Vector
module from \s-1CPAN\s0. The reason you might choose Bit::Vector over the
perl built-in functions is that it works with numbers of \s-1ANY\s0 size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.
.IP "How do I convert hexadecimal into decimal" 4
.IX Item "How do I convert hexadecimal into decimal"
Using perl's built in conversion of \f(CW\*(C`0x\*(C'\fR notation:
.Sp
.Vb 1
\&    my $dec = 0xDEADBEEF;
.Ve
.Sp
Using the \f(CW\*(C`hex\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = hex("DEADBEEF");
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR:
.Sp
.Vb 1
\&    my $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", \-8)));
.Ve
.Sp
Using the \s-1CPAN\s0 module \f(CW\*(C`Bit::Vector\*(C'\fR:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Hex(32, "DEADBEEF");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to hexadecimal" 4
.IX Item "How do I convert from decimal to hexadecimal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 2
\&    my $hex = sprintf("%X", 3735928559); # upper case A\-F
\&    my $hex = sprintf("%x", 3735928559); # lower case a\-f
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $hex = unpack("H*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $hex = $vec\->to_Hex();
.Ve
.Sp
And Bit::Vector supports odd bit counts:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(33, 3735928559);
\&    $vec\->Resize(32); # suppress leading 0 if unwanted
\&    my $hex = $vec\->to_Hex();
.Ve
.IP "How do I convert from octal to decimal" 4
.IX Item "How do I convert from octal to decimal"
Using Perl's built in conversion of numbers with leading zeros:
.Sp
.Vb 1
\&    my $dec = 033653337357; # note the leading 0!
.Ve
.Sp
Using the \f(CW\*(C`oct\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = oct("33653337357");
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new(32);
\&    $vec\->Chunk_List_Store(3, split(//, reverse "33653337357"));
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to octal" 4
.IX Item "How do I convert from decimal to octal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 1
\&    my $oct = sprintf("%o", 3735928559);
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $oct = reverse join(\*(Aq\*(Aq, $vec\->Chunk_List_Read(3));
.Ve
.IP "How do I convert from binary to decimal" 4
.IX Item "How do I convert from binary to decimal"
Perl 5.6 lets you write binary numbers directly with
the \f(CW\*(C`0b\*(C'\fR notation:
.Sp
.Vb 1
\&    my $number = 0b10110110;
.Ve
.Sp
Using \f(CW\*(C`oct\*(C'\fR:
.Sp
.Vb 2
\&    my $input = "10110110";
\&    my $decimal = oct( "0b$input" );
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.Sp
.Vb 1
\&    my $decimal = ord(pack(\*(AqB8\*(Aq, \*(Aq10110110\*(Aq));
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR for larger strings:
.Sp
.Vb 3
\&    my $int = unpack("N", pack("B32",
\&    substr("0" x 32 . "11110101011011011111011101111", \-32)));
\&    my $dec = sprintf("%d", $int);
\&
\&    # substr() is used to left\-pad a 32\-character string with zeros.
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 2
\&    my $vec = Bit::Vector\->new_Bin(32, "11011110101011011011111011101111");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to binary" 4
.IX Item "How do I convert from decimal to binary"
Using \f(CW\*(C`sprintf\*(C'\fR (perl 5.6+):
.Sp
.Vb 1
\&    my $bin = sprintf("%b", 3735928559);
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $bin = unpack("B*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $bin = $vec\->to_Bin();
.Ve
.Sp
The remaining transformations (e.g. hex \-> oct, bin \-> hex, etc.)
are left as an exercise to the inclined reader.
.SS "Why doesn't & work the way I want it to?"
.IX Subsection "Why doesn't & work the way I want it to?"
The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings. The operators treat a string as a series
of bits and work with that (the string \f(CW"3"\fR is the bit pattern
\&\f(CW00110011\fR). The operators work with the binary form of a number
(the number \f(CW3\fR is treated as the bit pattern \f(CW00000011\fR).
.PP
So, saying \f(CW\*(C`11 & 3\*(C'\fR performs the \*(L"and\*(R" operation on numbers (yielding
\&\f(CW3\fR). Saying \f(CW"11" & "3"\fR performs the \*(L"and\*(R" operation on strings
(yielding \f(CW"1"\fR).
.PP
Most problems with \f(CW\*(C`&\*(C'\fR and \f(CW\*(C`|\*(C'\fR arise because the programmer thinks
they have a number but really it's a string or vice versa. To avoid this,
stringify the arguments explicitly (using \f(CW""\fR or \f(CW\*(C`qq()\*(C'\fR) or convert them
to numbers explicitly (using \f(CW\*(C`0+$arg\*(C'\fR). The rest arise because
the programmer says:
.PP
.Vb 3
\&    if ("\e020\e020" & "\e101\e101") {
\&        # ...
\&    }
.Ve
.PP
but a string consisting of two null bytes (the result of \f(CW"\e020\e020"
& "\e101\e101"\fR) is not a false value in Perl. You need:
.PP
.Vb 3
\&    if ( ("\e020\e020" & "\e101\e101") !~ /[^\e000]/) {
\&        # ...
\&    }
.Ve
.SS "How do I multiply matrices?"
.IX Subsection "How do I multiply matrices?"
Use the Math::Matrix or Math::MatrixReal modules (available from \s-1CPAN\s0)
or the \s-1PDL\s0 extension (also available from \s-1CPAN\s0).
.SS "How do I perform an operation on a series of integers?"
.IX Subsection "How do I perform an operation on a series of integers?"
To call a function on each element in an array, and collect the
results, use:
.PP
.Vb 1
\&    my @results = map { my_func($_) } @array;
.Ve
.PP
For example:
.PP
.Vb 1
\&    my @triple = map { 3 * $_ } @single;
.Ve
.PP
To call a function on each element of an array, but ignore the
results:
.PP
.Vb 3
\&    foreach my $iterator (@array) {
\&        some_func($iterator);
\&    }
.Ve
.PP
To call a function on each integer in a (small) range, you \fBcan\fR use:
.PP
.Vb 1
\&    my @results = map { some_func($_) } (5 .. 25);
.Ve
.PP
but you should be aware that in this form, the \f(CW\*(C`..\*(C'\fR operator
creates a list of all integers in the range, which can take a lot of
memory for large ranges. However, the problem does not occur when
using \f(CW\*(C`..\*(C'\fR within a \f(CW\*(C`for\*(C'\fR loop, because in that case the range
operator is optimized to \fIiterate\fR over the range, without creating
the entire list. So
.PP
.Vb 4
\&    my @results = ();
\&    for my $i (5 .. 500_005) {
\&        push(@results, some_func($i));
\&    }
.Ve
.PP
or even
.PP
.Vb 1
\&   push(@results, some_func($_)) for 5 .. 500_005;
.Ve
.PP
will not create an intermediate list of 500,000 integers.
.SS "How can I output Roman numerals?"
.IX Subsection "How can I output Roman numerals?"
Get the http://www.cpan.org/modules/by\-module/Roman <http://www.cpan.org/modules/by-module/Roman> module.
.SS "Why aren't my random numbers random?"
.IX Subsection "Why aren't my random numbers random?"
If you're using a version of Perl before 5.004, you must call \f(CW\*(C`srand\*(C'\fR
once at the start of your program to seed the random number generator.
.PP
.Vb 1
\&     BEGIN { srand() if $] < 5.004 }
.Ve
.PP
5.004 and later automatically call \f(CW\*(C`srand\*(C'\fR at the beginning. Don't
call \f(CW\*(C`srand\*(C'\fR more than once\*(--you make your numbers less random,
rather than more.
.PP
Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :\-). The
\&\fIrandom\fR article in the \*(L"Far More Than You Ever Wanted To Know\*(R"
collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz>, courtesy
of Tom Phoenix, talks more about this. John von Neumann said, \*(L"Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin.\*(R"
.PP
Perl relies on the underlying system for the implementation of
\&\f(CW\*(C`rand\*(C'\fR and \f(CW\*(C`srand\*(C'\fR; on some systems, the generated numbers are
not random enough (especially on Windows : see
<http://www.perlmonks.org/?node_id=803632>).
Several \s-1CPAN\s0 modules in the \f(CW\*(C`Math\*(C'\fR namespace implement better
pseudorandom generators; see for example
Math::Random::MT (\*(L"Mersenne Twister\*(R", fast), or
Math::TrulyRandom (uses the imperfections in the system's
timer to generate random numbers, which is rather slow).
More algorithms for random numbers are described in
\&\*(L"Numerical Recipes in C\*(R" at <http://www.nr.com/>
.SS "How do I get a random number between X and Y?"
.IX Subsection "How do I get a random number between X and Y?"
To get a random number between two values, you can use the \f(CW\*(C`rand()\*(C'\fR
built-in to get a random number between 0 and 1. From there, you shift
that into the range that you want.
.PP
\&\f(CW\*(C`rand($x)\*(C'\fR returns a number such that \f(CW\*(C`0 <= rand($x) < $x\*(C'\fR. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your \fIX\fR and \fIY\fR.
.PP
That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.
.PP
.Vb 1
\&    my $number = 10 + int rand( 15\-10+1 ); # ( 10,11,12,13,14, or 15 )
.Ve
.PP
Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: \f(CW\*(C`random_int_between(50,120)\*(C'\fR.
.PP
.Vb 7
\&    sub random_int_between {
\&        my($min, $max) = @_;
\&        # Assumes that the two arguments are integers themselves!
\&        return $min if $min == $max;
\&        ($min, $max) = ($max, $min)  if  $min > $max;
\&        return $min + int rand(1 + $max \- $min);
\&    }
.Ve
.SH "Data: Dates"
.IX Header "Data: Dates"
.SS "How do I find the day or week of the year?"
.IX Subsection "How do I find the day or week of the year?"
The day of the year is in the list returned
by the \f(CW\*(C`localtime\*(C'\fR function. Without an
argument \f(CW\*(C`localtime\*(C'\fR uses the current time.
.PP
.Vb 1
\&    my $day_of_year = (localtime)[7];
.Ve
.PP
The \s-1POSIX\s0 module can also format a date as the day of the year or
week of the year.
.PP
.Vb 3
\&    use POSIX qw/strftime/;
\&    my $day_of_year  = strftime "%j", localtime;
\&    my $week_of_year = strftime "%W", localtime;
.Ve
.PP
To get the day of year for any date, use \s-1POSIX\s0's \f(CW\*(C`mktime\*(C'\fR to get
a time in epoch seconds for the argument to \f(CW\*(C`localtime\*(C'\fR.
.PP
.Vb 3
\&    use POSIX qw/mktime strftime/;
\&    my $week_of_year = strftime "%W",
\&        localtime( mktime( 0, 0, 0, 18, 11, 87 ) );
.Ve
.PP
You can also use Time::Piece, which comes with Perl and provides a
\&\f(CW\*(C`localtime\*(C'\fR that returns an object:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $day_of_year  = localtime\->yday;
\&    my $week_of_year = localtime\->week;
.Ve
.PP
The Date::Calc module provides two functions to calculate these, too:
.PP
.Vb 3
\&    use Date::Calc;
\&    my $day_of_year  = Day_of_Year(  1987, 12, 18 );
\&    my $week_of_year = Week_of_Year( 1987, 12, 18 );
.Ve
.SS "How do I find the current century or millennium?"
.IX Subsection "How do I find the current century or millennium?"
Use the following simple functions:
.PP
.Vb 3
\&    sub get_century    {
\&        return int((((localtime(shift || time))[5] + 1999))/100);
\&    }
\&
\&    sub get_millennium {
\&        return 1+int((((localtime(shift || time))[5] + 1899))/1000);
\&    }
.Ve
.PP
On some systems, the \s-1POSIX\s0 module's \f(CW\*(C`strftime()\*(C'\fR function has been
extended in a non-standard way to use a \f(CW%C\fR format, which they
sometimes claim is the \*(L"century\*(R". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to determine reliably the current century or
millennium.
.SS "How can I compare two dates and find the difference?"
.IX Subsection "How can I compare two dates and find the difference?"
(contributed by brian d foy)
.PP
You could just store all your dates as a number and then subtract.
Life isn't always that simple though.
.PP
The Time::Piece module, which comes with Perl, replaces localtime
with a version that returns an object. It also overloads the comparison
operators so you can compare them directly:
.PP
.Vb 3
\&    use Time::Piece;
\&    my $date1 = localtime( $some_time );
\&    my $date2 = localtime( $some_other_time );
\&
\&    if( $date1 < $date2 ) {
\&        print "The date was in the past\en";
\&    }
.Ve
.PP
You can also get differences with a subtraction, which returns a
Time::Seconds object:
.PP
.Vb 2
\&    my $diff = $date1 \- $date2;
\&    print "The difference is ", $date_diff\->days, " days\en";
.Ve
.PP
If you want to work with formatted dates, the Date::Manip,
Date::Calc, or DateTime modules can help you.
.SS "How can I take a string and turn it into epoch seconds?"
.IX Subsection "How can I take a string and turn it into epoch seconds?"
If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to \f(CW\*(C`timelocal\*(C'\fR in the standard
Time::Local module. Otherwise, you should look into the Date::Calc,
Date::Parse, and Date::Manip modules from \s-1CPAN\s0.
.SS "How can I find the Julian Day?"
.IX Subsection "How can I find the Julian Day?"
(contributed by brian d foy and Dave Cross)
.PP
You can use the Time::Piece module, part of the Standard Library,
which can convert a date/time to a Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->julian_day\*(Aq
\&    2455607.7959375
.Ve
.PP
Or the modified Julian Day:
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->mjd\*(Aq
\&    55607.2961226851
.Ve
.PP
Or even the day of the year (which is what some people think of as a
Julian day):
.PP
.Vb 2
\&    $ perl \-MTime::Piece \-le \*(Aqprint localtime\->yday\*(Aq
\&    45
.Ve
.PP
You can also do the same things with the DateTime module:
.PP
.Vb 6
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->jd\*(Aq
\&    2453401.5
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->mjd\*(Aq
\&    53401
\&    $ perl \-MDateTime \-le\*(Aqprint DateTime\->today\->doy\*(Aq
\&    31
.Ve
.PP
You can use the Time::JulianDay module available on \s-1CPAN\s0. Ensure
that you really want to find a Julian day, though, as many people have
different ideas about Julian days (see <http://www.hermetic.ch/cal_stud/jdn.htm>
for instance):
.PP
.Vb 2
\&    $  perl \-MTime::JulianDay \-le \*(Aqprint local_julian_day( time )\*(Aq
\&    55608
.Ve
.SS "How do I find yesterday's date?"
.IX Xref "date yesterday DateTime Date::Calc Time::Local daylight saving time day Today_and_Now localtime timelocal"
.IX Subsection "How do I find yesterday's date?"
(contributed by brian d foy)
.PP
To do it correctly, you can use one of the \f(CW\*(C`Date\*(C'\fR modules since they
work with calendars instead of times. The DateTime module makes it
simple, and give you the same time of day, only the day before,
despite daylight saving time changes:
.PP
.Vb 1
\&    use DateTime;
\&
\&    my $yesterday = DateTime\->now\->subtract( days => 1 );
\&
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
You can also use the Date::Calc module using its \f(CW\*(C`Today_and_Now\*(C'\fR
function.
.PP
.Vb 1
\&    use Date::Calc qw( Today_and_Now Add_Delta_DHMS );
\&
\&    my @date_time = Add_Delta_DHMS( Today_and_Now(), \-1, 0, 0, 0 );
\&
\&    print "@date_time\en";
.Ve
.PP
Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each. For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. For example, the rest of the
suggestions will be wrong sometimes:
.PP
Starting with Perl 5.10, Time::Piece and Time::Seconds are part
of the standard distribution, so you might think that you could do
something like this:
.PP
.Vb 2
\&    use Time::Piece;
\&    use Time::Seconds;
\&
\&    my $yesterday = localtime() \- ONE_DAY; # WRONG
\&    print "Yesterday was $yesterday\en";
.Ve
.PP
The Time::Piece module exports a new \f(CW\*(C`localtime\*(C'\fR that returns an
object, and Time::Seconds exports the \f(CW\*(C`ONE_DAY\*(C'\fR constant that is a
set number of seconds. This means that it always gives the time 24
hours ago, which is not always yesterday. This can cause problems
around the end of daylight saving time when there's one day that is 25
hours long.
.PP
You have the same problem with Time::Local, which will give the wrong
answer for those same special cases:
.PP
.Vb 5
\&    # contributed by Gunnar Hjalmarsson
\&     use Time::Local;
\&     my $today = timelocal 0, 0, 12, ( localtime )[3..5];
\&     my ($d, $m, $y) = ( localtime $today\-86400 )[3..5]; # WRONG
\&     printf "Yesterday: %d\-%02d\-%02d\en", $y+1900, $m+1, $d;
.Ve
.SS "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
.IX Subsection "Does Perl have a Year 2000 or 2038 problem? Is Perl Y2K compliant?"
(contributed by brian d foy)
.PP
Perl itself never had a Y2K problem, although that never stopped people
from creating Y2K problems on their own. See the documentation for
\&\f(CW\*(C`localtime\*(C'\fR for its proper use.
.PP
Starting with Perl 5.12, \f(CW\*(C`localtime\*(C'\fR and \f(CW\*(C`gmtime\*(C'\fR can handle dates past
03:14:08 January 19, 2038, when a 32\-bit based time would overflow. You
still might get a warning on a 32\-bit \f(CW\*(C`perl\*(C'\fR:
.PP
.Vb 3
\&    % perl5.12 \-E \*(Aqsay scalar localtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Integer overflow in hexadecimal number at \-e line 1.
\&    Wed Nov  1 19:42:39 5576711
.Ve
.PP
On a 64\-bit \f(CW\*(C`perl\*(C'\fR, you can get even larger dates for those really long
running projects:
.PP
.Vb 2
\&    % perl5.12 \-E \*(Aqsay scalar gmtime( 0x9FFF_FFFFFFFF )\*(Aq
\&    Thu Nov  2 00:42:39 5576711
.Ve
.PP
You're still out of luck if you need to keep track of decaying protons
though.
.SH "Data: Strings"
.IX Header "Data: Strings"
.SS "How do I validate input?"
.IX Subsection "How do I validate input?"
(contributed by brian d foy)
.PP
There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with \*(L"Assert\*(R" and \*(L"Validate\*(R"
in their names, along with other modules such as Regexp::Common.
.PP
Some modules have validation for particular types of input, such
as Business::ISBN, Business::CreditCard, Email::Valid,
and Data::Validate::IP.
.SS "How do I unescape a string?"
.IX Subsection "How do I unescape a string?"
It depends just what you mean by \*(L"escape\*(R". \s-1URL\s0 escapes are dealt
with in perlfaq9. Shell escapes with the backslash (\f(CW\*(C`\e\*(C'\fR)
character are removed with
.PP
.Vb 1
\&    s/\e\e(.)/$1/g;
.Ve
.PP
This won't expand \f(CW"\en"\fR or \f(CW"\et"\fR or any other special escapes.
.SS "How do I remove consecutive pairs of characters?"
.IX Subsection "How do I remove consecutive pairs of characters?"
(contributed by brian d foy)
.PP
You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in \f(CW\*(C`(.)\*(C'\fR. The memory parentheses
store the matched character in the back-reference \f(CW\*(C`\eg1\*(C'\fR and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in \f(CW$1\fR.
.PP
.Vb 1
\&    s/(.)\eg1/$1/g;
.Ve
.PP
We can also use the transliteration operator, \f(CW\*(C`tr///\*(C'\fR. In this
example, the search list side of our \f(CW\*(C`tr///\*(C'\fR contains nothing, but
the \f(CW\*(C`c\*(C'\fR option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the \f(CW\*(C`s\*(C'\fR option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself
.PP
.Vb 2
\&    my $str = \*(AqHaarlem\*(Aq;   # in the Netherlands
\&    $str =~ tr///cs;       # Now Harlem, like in New York
.Ve
.SS "How do I expand function calls in a string?"
.IX Subsection "How do I expand function calls in a string?"
(contributed by brian d foy)
.PP
This is documented in perlref, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.
.PP
.Vb 1
\&    print "The time values are @{ [localtime] }.\en";
.Ve
.PP
If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need \f(CW\*(C`scalar\*(C'\fR to
force the scalar context on the function:
.PP
.Vb 1
\&    print "The time is ${\e(scalar localtime)}.\en"
\&
\&    print "The time is ${ my $x = localtime; \e$x }.\en";
.Ve
.PP
If your function already returns a reference, you don't need to create
the reference yourself.
.PP
.Vb 1
\&    sub timestamp { my $t = localtime; \e$t }
\&
\&    print "The time is ${ timestamp() }.\en";
.Ve
.PP
The \f(CW\*(C`Interpolation\*(C'\fR module can also do a lot of magic for you. You can
specify a variable name, in this case \f(CW\*(C`E\*(C'\fR, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.
.PP
.Vb 2
\&    use Interpolation E => \*(Aqeval\*(Aq;
\&    print "The time values are $E{localtime()}.\en";
.Ve
.PP
In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.
.PP
.Vb 1
\&    print "The time is " . localtime() . ".\en";
.Ve
.SS "How do I find matching/nesting anything?"
.IX Subsection "How do I find matching/nesting anything?"
To find something between two single
characters, a pattern like \f(CW\*(C`/x([^x]*)x/\*(C'\fR will get the intervening
bits in \f(CW$1\fR. For multiple ones, then something more like
\&\f(CW\*(C`/alpha(.*?)omega/\*(C'\fR would be needed. For nested patterns
and/or balanced expressions, see the so-called
(?PARNO)
construct (available since perl 5.10).
The \s-1CPAN\s0 module Regexp::Common can help to build such
regular expressions (see in particular
Regexp::Common::balanced and Regexp::Common::delimited).
.PP
More complex cases will require to write a parser, probably
using a parsing module from \s-1CPAN\s0, like
Regexp::Grammars, Parse::RecDescent, Parse::Yapp,
Text::Balanced, or Marpa::XS.
.SS "How do I reverse a string?"
.IX Subsection "How do I reverse a string?"
Use \f(CW\*(C`reverse()\*(C'\fR in scalar context, as documented in
\&\*(L"reverse\*(R" in perlfunc.
.PP
.Vb 1
\&    my $reversed = reverse $string;
.Ve
.SS "How do I expand tabs in a string?"
.IX Subsection "How do I expand tabs in a string?"
You can do it yourself:
.PP
.Vb 1
\&    1 while $string =~ s/\et+/\*(Aq \*(Aq x (length($&) * 8 \- length($\`) % 8)/e;
.Ve
.PP
Or you can just use the Text::Tabs module (part of the standard Perl
distribution).
.PP
.Vb 2
\&    use Text::Tabs;
\&    my @expanded_lines = expand(@lines_with_tabs);
.Ve
.SS "How do I reformat a paragraph?"
.IX Subsection "How do I reformat a paragraph?"
Use Text::Wrap (part of the standard Perl distribution):
.PP
.Vb 2
\&    use Text::Wrap;
\&    print wrap("\et", \*(Aq  \*(Aq, @paragraphs);
.Ve
.PP
The paragraphs you give to Text::Wrap should not contain embedded
newlines. Text::Wrap doesn't justify the lines (flush-right).
.PP
Or use the \s-1CPAN\s0 module Text::Autoformat. Formatting files can be
easily done by making a shell alias, like so:
.PP
.Vb 2
\&    alias fmt="perl \-i \-MText::Autoformat \-n0777 \e
\&        \-e \*(Aqprint autoformat $_, {all=>1}\*(Aq $*"
.Ve
.PP
See the documentation for Text::Autoformat to appreciate its many
capabilities.
.SS "How can I access or change N characters of a string?"
.IX Subsection "How can I access or change N characters of a string?"
You can access the first characters of a string with \fIsubstr()\fR.
To get the first character, for example, start at position 0
and grab the string of length 1.
.PP
.Vb 2
\&    my $string = "Just another Perl Hacker";
\&    my $first_char = substr( $string, 0, 1 );  #  \*(AqJ\*(Aq
.Ve
.PP
To change part of a string, you can use the optional fourth
argument which is the replacement string.
.PP
.Vb 1
\&    substr( $string, 13, 4, "Perl 5.8.0" );
.Ve
.PP
You can also use \fIsubstr()\fR as an lvalue.
.PP
.Vb 1
\&    substr( $string, 13, 4 ) =  "Perl 5.8.0";
.Ve
.SS "How do I change the Nth occurrence of something?"
.IX Subsection "How do I change the Nth occurrence of something?"
You have to keep track of N yourself. For example, let's say you want
to change the fifth occurrence of \f(CW"whoever"\fR or \f(CW"whomever"\fR into
\&\f(CW"whosoever"\fR or \f(CW"whomsoever"\fR, case insensitively. These
all assume that \f(CW$_\fR contains the string to be altered.
.PP
.Vb 6
\&    $count = 0;
\&    s{((whom?)ever)}{
\&    ++$count == 5       # is it the 5th?
\&        ? "${2}soever"  # yes, swap
\&        : $1            # renege and leave it there
\&        }ige;
.Ve
.PP
In the more general case, you can use the \f(CW\*(C`/g\*(C'\fR modifier in a \f(CW\*(C`while\*(C'\fR
loop, keeping count of matches.
.PP
.Vb 8
\&    $WANT = 3;
\&    $count = 0;
\&    $_ = "One fish two fish red fish blue fish";
\&    while (/(\ew+)\es+fish\eb/gi) {
\&        if (++$count == $WANT) {
\&            print "The third fish is a $1 one.\en";
\&        }
\&    }
.Ve
.PP
That prints out: \f(CW"The third fish is a red one."\fR  You can also use a
repetition count and repeated pattern like this:
.PP
.Vb 1
\&    /(?:\ew+\es+fish\es+){2}(\ew+)\es+fish/i;
.Ve
.SS "How can I count the number of occurrences of a substring within a string?"
.IX Subsection "How can I count the number of occurrences of a substring within a string?"
There are a number of ways, with varying efficiency. If you want a
count of a certain single character (X) within a string, you can use the
\&\f(CW\*(C`tr///\*(C'\fR function like so:
.PP
.Vb 3
\&    my $string = "ThisXlineXhasXsomeXx\*(AqsXinXit";
\&    my $count = ($string =~ tr/X//);
\&    print "There are $count X characters in the string";
.Ve
.PP
This is fine if you are just looking for a single character. However,
if you are trying to count multiple character substrings within a
larger string, \f(CW\*(C`tr///\*(C'\fR won't work. What you can do is wrap a \fIwhile()\fR
loop around a global pattern match. For example, let's count negative
integers:
.PP
.Vb 4
\&    my $string = "\-9 55 48 \-2 23 \-76 4 14 \-44";
\&    my $count = 0;
\&    while ($string =~ /\-\ed+/g) { $count++ }
\&    print "There are $count negative numbers in the string";
.Ve
.PP
Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.
.PP
.Vb 1
\&    my $count = () = $string =~ /\-\ed+/g;
.Ve
.SS "How do I capitalize all the words on one line?"
.IX Xref "Text::Autoformat capitalize case, title case, sentence"
.IX Subsection "How do I capitalize all the words on one line?"
(contributed by brian d foy)
.PP
Damian Conway's Text::Autoformat handles all of the thinking
for you.
.PP
.Vb 3
\&    use Text::Autoformat;
\&    my $x = "Dr. Strangelove or: How I Learned to Stop ".
\&      "Worrying and Love the Bomb";
\&
\&    print $x, "\en";
\&    for my $style (qw( sentence title highlight )) {
\&        print autoformat($x, { case => $style }), "\en";
\&    }
.Ve
.PP
How do you want to capitalize those words?
.PP
.Vb 3
\&    FRED AND BARNEY\*(AqS LODGE        # all uppercase
\&    Fred And Barney\*(Aqs Lodge        # title case
\&    Fred and Barney\*(Aqs Lodge        # highlight case
.Ve
.PP
It's not as easy a problem as it looks. How many words do you think
are in there? Wait for it... wait for it.... If you answered 5
you're right. Perl words are groups of \f(CW\*(C`\ew+\*(C'\fR, but that's not what
you want to capitalize. How is Perl supposed to know not to capitalize
that \f(CW\*(C`s\*(C'\fR after the apostrophe? You could try a regular expression:
.PP
.Vb 6
\&    $string =~ s/ (
\&                 (^\ew)    #at the beginning of the line
\&                   |      # or
\&                 (\es\ew)   #preceded by whitespace
\&                   )
\&                /\eU$1/xg;
\&
\&    $string =~ s/([\ew\*(Aq]+)/\eu\eL$1/g;
.Ve
.PP
Now, what if you don't want to capitalize that \*(L"and\*(R"? Just use
Text::Autoformat and get on with the next problem. :)
.SS "How can I split a [character]\-delimited string except when inside [character]?"
.IX Subsection "How can I split a [character]-delimited string except when inside [character]?"
Several modules can handle this sort of parsing\*(--Text::Balanced,
Text::CSV, Text::CSV_XS, and Text::ParseWords, among others.
.PP
Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use \f(CW\*(C`split(/,/)\*(C'\fR
because you shouldn't split if the comma is inside quotes. For
example, take a data line like this:
.PP
.Vb 1
\&    SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"
.Ve
.PP
Due to the restriction of the quotes, this is a fairly complex
problem. Thankfully, we have Jeffrey Friedl, author of
\&\fIMastering Regular Expressions\fR, to handle these for us. He
suggests (assuming your string is contained in \f(CW$text\fR):
.PP
.Vb 7
\&     my @new = ();
\&     push(@new, $+) while $text =~ m{
\&         "([^\e"\e\e]*(?:\e\e.[^\e"\e\e]*)*)",? # groups the phrase inside the quotes
\&        | ([^,]+),?
\&        | ,
\&     }gx;
\&     push(@new, undef) if substr($text,\-1,1) eq \*(Aq,\*(Aq;
.Ve
.PP
If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
\&\f(CW"like \e"this\e""\fR.
.PP
Alternatively, the Text::ParseWords module (part of the standard
Perl distribution) lets you say:
.PP
.Vb 2
\&    use Text::ParseWords;
\&    @new = quotewords(",", 0, $text);
.Ve
.PP
For parsing or generating \s-1CSV\s0, though, using Text::CSV rather than
implementing it yourself is highly recommended; you'll save yourself odd bugs
popping up later by just using code which has already been tried and tested in
production for years.
.SS "How do I strip blank space from the beginning/end of a string?"
.IX Subsection "How do I strip blank space from the beginning/end of a string?"
(contributed by brian d foy)
.PP
A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions:
.PP
.Vb 2
\&    s/^\es+//;
\&    s/\es+$//;
.Ve
.PP
You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though:
.PP
.Vb 1
\&    s/^\es+|\es+$//g;
.Ve
.PP
In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the \f(CW\*(C`/g\*(C'\fR flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the \f(CW\*(C`\es+\*(C'\fR, and  the \f(CW\*(C`$\*(C'\fR anchor can match to the
absolute end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
\&\*(L"blank\*(R" (consisting entirely of whitespace) lines which the \f(CW\*(C`^\es+\*(C'\fR
would remove all by itself:
.PP
.Vb 4
\&    while( <> ) {
\&        s/^\es+|\es+$//g;
\&        print "$_\en";
\&    }
.Ve
.PP
For a multi-line string, you can apply the regular expression to each
logical line in the string by adding the \f(CW\*(C`/m\*(C'\fR flag (for
\&\*(L"multi-line\*(R"). With the \f(CW\*(C`/m\*(C'\fR flag, the \f(CW\*(C`$\*(C'\fR matches \fIbefore\fR an
embedded newline, so it doesn't remove it. This pattern still removes
the newline at the end of the string:
.PP
.Vb 1
\&    $string =~ s/^\es+|\es+$//gm;
.Ve
.PP
Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If you need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace:
.PP
.Vb 1
\&    $string =~ s/^[\et\ef ]+|[\et\ef ]+$//mg;
.Ve
.SS "How do I pad a string with blanks or pad a number with zeroes?"
.IX Subsection "How do I pad a string with blanks or pad a number with zeroes?"
In the following examples, \f(CW$pad_len\fR is the length to which you wish
to pad the string, \f(CW$text\fR or \f(CW$num\fR contains the string to be padded,
and \f(CW$pad_char\fR contains the padding character. You can use a single
character string constant instead of the \f(CW$pad_char\fR variable if you
know what it is in advance. And in the same way you can use an integer in
place of \f(CW$pad_len\fR if you know the pad length in advance.
.PP
The simplest method uses the \f(CW\*(C`sprintf\*(C'\fR function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The \f(CW\*(C`pack\*(C'\fR function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
\&\f(CW$pad_len\fR.
.PP
.Vb 3
\&    # Left padding a string with blanks (no truncation):
\&    my $padded = sprintf("%${pad_len}s", $text);
\&    my $padded = sprintf("%*s", $pad_len, $text);  # same thing
\&
\&    # Right padding a string with blanks (no truncation):
\&    my $padded = sprintf("%\-${pad_len}s", $text);
\&    my $padded = sprintf("%\-*s", $pad_len, $text); # same thing
\&
\&    # Left padding a number with 0 (no truncation):
\&    my $padded = sprintf("%0${pad_len}d", $num);
\&    my $padded = sprintf("%0*d", $pad_len, $num); # same thing
\&
\&    # Right padding a string with blanks using pack (will truncate):
\&    my $padded = pack("A$pad_len",$text);
.Ve
.PP
If you need to pad with a character other than blank or zero you can use
one of the following methods. They all generate a pad string with the
\&\f(CW\*(C`x\*(C'\fR operator and combine that with \f(CW$text\fR. These methods do
not truncate \f(CW$text\fR.
.PP
Left and right padding with any character, creating a new string:
.PP
.Vb 2
\&    my $padded = $pad_char x ( $pad_len \- length( $text ) ) . $text;
\&    my $padded = $text . $pad_char x ( $pad_len \- length( $text ) );
.Ve
.PP
Left and right padding with any character, modifying \f(CW$text\fR directly:
.PP
.Vb 2
\&    substr( $text, 0, 0 ) = $pad_char x ( $pad_len \- length( $text ) );
\&    $text .= $pad_char x ( $pad_len \- length( $text ) );
.Ve
.SS "How do I extract selected columns from a string?"
.IX Subsection "How do I extract selected columns from a string?"
(contributed by brian d foy)
.PP
If you know the columns that contain the data, you can
use \f(CW\*(C`substr\*(C'\fR to extract a single column.
.PP
.Vb 1
\&    my $column = substr( $line, $start_column, $length );
.Ve
.PP
You can use \f(CW\*(C`split\*(C'\fR if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.
.PP
.Vb 3
\&    my $line    = \*(Aq fred barney   betty   \*(Aq;
\&    my @columns = split /\es+/, $line;
\&        # ( \*(Aq\*(Aq, \*(Aqfred\*(Aq, \*(Aqbarney\*(Aq, \*(Aqbetty\*(Aq );
\&
\&    my $line    = \*(Aqfred||barney||betty\*(Aq;
\&    my @columns = split /\e|/, $line;
\&        # ( \*(Aqfred\*(Aq, \*(Aq\*(Aq, \*(Aqbarney\*(Aq, \*(Aq\*(Aq, \*(Aqbetty\*(Aq );
.Ve
.PP
If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that format, such as Text::CSV, Text::CSV_XS, or
Text::CSV_PP.
.PP
If you want to break apart an entire line of fixed columns, you can use
\&\f(CW\*(C`unpack\*(C'\fR with the A (\s-1ASCII\s0) format. By using a number after the format
specifier, you can denote the column width. See the \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR
entries in perlfunc for more details.
.PP
.Vb 1
\&    my @fields = unpack( $line, "A8 A8 A8 A16 A4" );
.Ve
.PP
Note that spaces in the format argument to \f(CW\*(C`unpack\*(C'\fR do not denote literal
spaces. If you have space separated data, you may want \f(CW\*(C`split\*(C'\fR instead.
.SS "How do I find the soundex value of a string?"
.IX Subsection "How do I find the soundex value of a string?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`Text::Soundex\*(C'\fR module. If you want to do fuzzy or close
matching, you might also try the String::Approx, and
Text::Metaphone, and Text::DoubleMetaphone modules.
.SS "How can I expand variables in text strings?"
.IX Subsection "How can I expand variables in text strings?"
(contributed by brian d foy)
.PP
If you can avoid it, don't, or if you can use a templating system,
such as Text::Template or Template Toolkit, do that instead. You
might even be able to get the job done with \f(CW\*(C`sprintf\*(C'\fR or \f(CW\*(C`printf\*(C'\fR:
.PP
.Vb 1
\&    my $string = sprintf \*(AqSay hello to %s and %s\*(Aq, $foo, $bar;
.Ve
.PP
However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand \f(CW$foo\fR and \f(CW$bar\fR
to their variable's values:
.PP
.Vb 3
\&    my $foo = \*(AqFred\*(Aq;
\&    my $bar = \*(AqBarney\*(Aq;
\&    $string = \*(AqSay hello to $foo and $bar\*(Aq;
.Ve
.PP
One way I can do this involves the substitution operator and a double
\&\f(CW\*(C`/e\*(C'\fR flag. The first \f(CW\*(C`/e\*(C'\fR evaluates \f(CW$1\fR on the replacement side and
turns it into \f(CW$foo\fR. The second /e starts with \f(CW$foo\fR and replaces
it with its value. \f(CW$foo\fR, then, turns into 'Fred', and that's finally
what's left in the string:
.PP
.Vb 1
\&    $string =~ s/(\e$\ew+)/$1/eeg; # \*(AqSay hello to Fred and Barney\*(Aq
.Ve
.PP
The \f(CW\*(C`/e\*(C'\fR will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
\&\f(CW\*(C`/e\*(C'\fR flag (twice even!), I have all of the same security problems I
have with \f(CW\*(C`eval\*(C'\fR in its string form. If there's something odd in
\&\f(CW$foo\fR, perhaps something like \f(CW\*(C`@{[ system "rm \-rf /" ]}\*(C'\fR, then
I could get myself in trouble.
.PP
To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single \f(CW\*(C`/e\*(C'\fR, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case \f(CW\*(C`???\*(C'\fR to
signal that I missed something:
.PP
.Vb 1
\&    my $string = \*(AqThis has $foo and $bar\*(Aq;
\&
\&    my %Replacements = (
\&        foo  => \*(AqFred\*(Aq,
\&        );
\&
\&    # $string =~ s/\e$(\ew+)/$Replacements{$1}/g;
\&    $string =~ s/\e$(\ew+)/
\&        exists $Replacements{$1} ? $Replacements{$1} : \*(Aq???\*(Aq
\&        /eg;
\&
\&    print $string;
.Ve
.ie n .SS "What's wrong with always quoting ""$vars""?"
.el .SS "What's wrong with always quoting ``$vars''?"
.IX Subsection "What's wrong with always quoting $vars?"
The problem is that those double-quotes force
stringification\*(--coercing numbers and references into strings\*(--even
when you don't want them to be strings. Think of it this way:
double-quote expansion is used to produce new strings. If you already
have a string, why do you need more?
.PP
If you get used to writing odd things like these:
.PP
.Vb 3
\&    print "$var";       # BAD
\&    my $new = "$old";       # BAD
\&    somefunc("$var");    # BAD
.Ve
.PP
You'll be in trouble. Those should (in 99.8% of the cases) be
the simpler and more direct:
.PP
.Vb 3
\&    print $var;
\&    my $new = $old;
\&    somefunc($var);
.Ve
.PP
Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:
.PP
.Vb 5
\&    func(\e@array);
\&    sub func {
\&        my $aref = shift;
\&        my $oref = "$aref";  # WRONG
\&    }
.Ve
.PP
You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical \f(CW\*(C`++\*(C'\fR autoincrement operator or the
\&\fIsyscall()\fR function.
.PP
Stringification also destroys arrays.
.PP
.Vb 3
\&    my @lines = \`command\`;
\&    print "@lines";     # WRONG \- extra blanks
\&    print @lines;       # right
.Ve
.SS "Why don't my <<\s-1HERE\s0 documents work?"
.IX Subsection "Why don't my <<HERE documents work?"
Here documents are found in perlop. Check for these three things:
.IP "There must be no space after the << part." 4
.IX Item "There must be no space after the << part."
.PD 0
.IP "There (probably) should be a semicolon at the end of the opening token" 4
.IX Item "There (probably) should be a semicolon at the end of the opening token"
.IP "You can't (easily) have any space in front of the tag." 4
.IX Item "You can't (easily) have any space in front of the tag."
.IP "There needs to be at least a line separator after the end token." 4
.IX Item "There needs to be at least a line separator after the end token."
.PD
.PP
If you want to indent the text in the here document, you
can do this:
.PP
.Vb 5
\&    # all in one
\&    (my $VAR = <<HERE_TARGET) =~ s/^\es+//gm;
\&        your text
\&        goes here
\&    HERE_TARGET
.Ve
.PP
But the \s-1HERE_TARGET\s0 must still be flush against the margin.
If you want that indented also, you'll have to quote
in the indentation.
.PP
.Vb 7
\&    (my $quote = <<\*(Aq    FINIS\*(Aq) =~ s/^\es+//gm;
\&            ...we will have peace, when you and all your works have
\&            perished\-\-and the works of your dark master to whom you
\&            would deliver us. You are a liar, Saruman, and a corrupter
\&            of men\*(Aqs hearts. \-\-Theoden in /usr/src/perl/taint.c
\&        FINIS
\&    $quote =~ s/\es+\-\-/\en\-\-/;
.Ve
.PP
A nice general-purpose fixer-upper function for indented here documents
follows. It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off. Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.
.PP
.Vb 11
\&    sub fix {
\&        local $_ = shift;
\&        my ($white, $leader);  # common whitespace and common leading string
\&        if (/^\es*(?:([^\ew\es]+)(\es*).*\en)(?:\es*\eg1\eg2?.*\en)+$/) {
\&            ($white, $leader) = ($2, quotemeta($1));
\&        } else {
\&            ($white, $leader) = (/^(\es+)/, \*(Aq\*(Aq);
\&        }
\&        s/^\es*?$leader(?:$white)?//gm;
\&        return $_;
\&    }
.Ve
.PP
This works with leading special strings, dynamically determined:
.PP
.Vb 10
\&    my $remember_the_main = fix<<\*(Aq    MAIN_INTERPRETER_LOOP\*(Aq;
\&    @@@ int
\&    @@@ runops() {
\&    @@@     SAVEI32(runlevel);
\&    @@@     runlevel++;
\&    @@@     while ( op = (*op\->op_ppaddr)() );
\&    @@@     TAINT_NOT;
\&    @@@     return 0;
\&    @@@ }
\&    MAIN_INTERPRETER_LOOP
.Ve
.PP
Or with a fixed amount of leading whitespace, with remaining
indentation correctly preserved:
.PP
.Vb 9
\&    my $poem = fix<<EVER_ON_AND_ON;
\&       Now far ahead the Road has gone,
\&      And I must follow, if I can,
\&       Pursuing it with eager feet,
\&      Until it joins some larger way
\&       Where many paths and errands meet.
\&      And whither then? I cannot say.
\&        \-\-Bilbo in /usr/src/perl/pp_ctl.c
\&    EVER_ON_AND_ON
.Ve
.SH "Data: Arrays"
.IX Header "Data: Arrays"
.SS "What is the difference between a list and an array?"
.IX Subsection "What is the difference between a list and an array?"
(contributed by brian d foy)
.PP
A list is a fixed collection of scalars. An array is a variable that
holds a variable collection of scalars. An array can supply its collection
for list operations, so list operations also work on arrays:
.PP
.Vb 3
\&    # slices
\&    ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq )[2,3];
\&    @animals[2,3];
\&
\&    # iteration
\&    foreach ( qw( dog cat bird ) ) { ... }
\&    foreach ( @animals ) { ... }
\&
\&    my @three = grep { length == 3 } qw( dog cat bird );
\&    my @three = grep { length == 3 } @animals;
\&
\&    # supply an argument list
\&    wash_animals( qw( dog cat bird ) );
\&    wash_animals( @animals );
.Ve
.PP
Array operations, which change the scalars, rearranges them, or adds
or subtracts some scalars, only work on arrays. These can't work on a
list, which is fixed. Array operations include \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR,
\&\f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, and \f(CW\*(C`splice\*(C'\fR.
.PP
An array can also change its length:
.PP
.Vb 2
\&    $#animals = 1;  # truncate to two elements
\&    $#animals = 10000; # pre\-extend to 10,001 elements
.Ve
.PP
You can change an array element, but you can't change a list element:
.PP
.Vb 2
\&    $animals[0] = \*(AqRottweiler\*(Aq;
\&    qw( dog cat bird )[0] = \*(AqRottweiler\*(Aq; # syntax error!
\&
\&    foreach ( @animals ) {
\&        s/^d/fr/;  # works fine
\&    }
\&
\&    foreach ( qw( dog cat bird ) ) {
\&        s/^d/fr/;  # Error! Modification of read only value!
\&    }
.Ve
.PP
However, if the list element is itself a variable, it appears that you
can change a list element. However, the list element is the variable, not
the data. You're not changing the list element, but something the list
element refers to. The list element itself doesn't change: it's still
the same variable.
.PP
You also have to be careful about context. You can assign an array to
a scalar to get the number of elements in the array. This only works
for arrays, though:
.PP
.Vb 1
\&    my $count = @animals;  # only works with arrays
.Ve
.PP
If you try to do the same thing with what you think is a list, you
get a quite different result. Although it looks like you have a list
on the righthand side, Perl actually sees a bunch of scalars separated
by a comma:
.PP
.Vb 1
\&    my $scalar = ( \*(Aqdog\*(Aq, \*(Aqcat\*(Aq, \*(Aqbird\*(Aq );  # $scalar gets bird
.Ve
.PP
Since you're assigning to a scalar, the righthand side is in scalar
context. The comma operator (yes, it's an operator!) in scalar
context evaluates its lefthand side, throws away the result, and
evaluates it's righthand side and returns the result. In effect,
that list-lookalike assigns to \f(CW$scalar\fR it's rightmost value. Many
people mess this up because they choose a list-lookalike whose
last element is also the count they expect:
.PP
.Vb 1
\&    my $scalar = ( 1, 2, 3 );  # $scalar gets 3, accidentally
.Ve
.ie n .SS "What is the difference between $array[1] and @array[1]?"
.el .SS "What is the difference between \f(CW$array\fP[1] and \f(CW@array\fP[1]?"
.IX Subsection "What is the difference between $array[1] and @array[1]?"
(contributed by brian d foy)
.PP
The difference is the sigil, that special character in front of the
array name. The \f(CW\*(C`$\*(C'\fR sigil means \*(L"exactly one item\*(R", while the \f(CW\*(C`@\*(C'\fR
sigil means \*(L"zero or more items\*(R". The \f(CW\*(C`$\*(C'\fR gets you a single scalar,
while the \f(CW\*(C`@\*(C'\fR gets you a list.
.PP
The confusion arises because people incorrectly assume that the sigil
denotes the variable type.
.PP
The \f(CW$array[1]\fR is a single-element access to the array. It's going
to return the item in index 1 (or undef if there is no item there).
If you intend to get exactly one element from the array, this is the
form you should use.
.PP
The \f(CW@array[1]\fR is an array slice, although it has only one index.
You can pull out multiple elements simultaneously by specifying
additional indices as a list, like \f(CW@array[1,4,3,0]\fR.
.PP
Using a slice on the lefthand side of the assignment supplies list
context to the righthand side. This can lead to unexpected results.
For instance, if you want to read a single line from a filehandle,
assigning to a scalar value is fine:
.PP
.Vb 1
\&    $array[1] = <STDIN>;
.Ve
.PP
However, in list context, the line input operator returns all of the
lines as a list. The first line goes into \f(CW@array[1]\fR and the rest
of the lines mysteriously disappear:
.PP
.Vb 1
\&    @array[1] = <STDIN>;  # most likely not what you want
.Ve
.PP
Either the \f(CW\*(C`use warnings\*(C'\fR pragma or the \fB\-w\fR flag will warn you when
you use an array slice with a single index.
.SS "How can I remove duplicate elements from a list or array?"
.IX Subsection "How can I remove duplicate elements from a list or array?"
(contributed by brian d foy)
.PP
Use a hash. When you think the words \*(L"unique\*(R" or \*(L"duplicated\*(R", think
\&\*(L"hash keys\*(R".
.PP
If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use \f(CW\*(C`keys\*(C'\fR to get the unique
elements.
.PP
.Vb 3
\&    my %hash   = map { $_, 1 } @array;
\&    # or a hash slice: @hash{ @array } = ();
\&    # or a foreach: $hash{$_} = 1 foreach ( @array );
\&
\&    my @unique = keys %hash;
.Ve
.PP
If you want to use a module, try the \f(CW\*(C`uniq\*(C'\fR function from
List::MoreUtils. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.
.PP
.Vb 1
\&    use List::MoreUtils qw(uniq);
\&
\&    my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
\&    my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7
.Ve
.PP
You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in \f(CW%Seen\fR. The \f(CW\*(C`next\*(C'\fR statement
creates the key and immediately uses its value, which is \f(CW\*(C`undef\*(C'\fR, so
the loop continues to the \f(CW\*(C`push\*(C'\fR and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash \fIand\fR the value for that key is true (since it's not 0 or
\&\f(CW\*(C`undef\*(C'\fR), so the next skips that iteration and the loop goes to the
next element.
.PP
.Vb 2
\&    my @unique = ();
\&    my %seen   = ();
\&
\&    foreach my $elem ( @array ) {
\&        next if $seen{ $elem }++;
\&        push @unique, $elem;
\&    }
.Ve
.PP
You can write this more briefly using a grep, which does the
same thing.
.PP
.Vb 2
\&    my %seen = ();
\&    my @unique = grep { ! $seen{ $_ }++ } @array;
.Ve
.SS "How can I tell whether a certain element is contained in a list or array?"
.IX Subsection "How can I tell whether a certain element is contained in a list or array?"
(portions of this answer contributed by Anno Siegel and brian d foy)
.PP
Hearing the word \*(L"in\*(R" is an \fIin\fRdication that you probably should have
used a hash, not a list or array, to store your data. Hashes are
designed to answer this question quickly and efficiently. Arrays aren't.
.PP
That being said, there are several ways to approach this. In Perl 5.10
and later, you can use the smart match operator to check that an item is
contained in an array or a hash:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( $item ~~ @array ) {
\&        say "The array contains $item"
\&    }
\&
\&    if( $item ~~ %hash ) {
\&        say "The hash contains $item"
\&    }
.Ve
.PP
With earlier versions of Perl, you have to do a bit more work. If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values:
.PP
.Vb 3
\&    my @blues = qw/azure cerulean teal turquoise lapis\-lazuli/;
\&    my %is_blue = ();
\&    for (@blues) { $is_blue{$_} = 1 }
.Ve
.PP
Now you can check whether \f(CW$is_blue{$some_color}\fR. It might have
been a good idea to keep the blues all in a hash in the first place.
.PP
If the values are all small integers, you could use a simple indexed
array. This kind of an array will take up less space:
.PP
.Vb 4
\&    my @primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
\&    my @is_tiny_prime = ();
\&    for (@primes) { $is_tiny_prime[$_] = 1 }
\&    # or simply  @istiny_prime[@primes] = (1) x @primes;
.Ve
.PP
Now you check whether \f(CW$is_tiny_prime\fR[$some_number].
.PP
If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:
.PP
.Vb 3
\&    my @articles = ( 1..10, 150..2000, 2017 );
\&    undef $read;
\&    for (@articles) { vec($read,$_,1) = 1 }
.Ve
.PP
Now check whether \f(CW\*(C`vec($read,$n,1)\*(C'\fR is true for some \f(CW$n\fR.
.PP
These methods guarantee fast individual tests but require a re-organization
of the original list or array. They only pay off if you have to test
multiple values against the same array.
.PP
If you are testing only once, the standard module List::Util exports
the function \f(CW\*(C`first\*(C'\fR for this purpose. It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:
.PP
.Vb 7
\&    sub first (&@) {
\&        my $code = shift;
\&        foreach (@_) {
\&            return $_ if &{$code}();
\&        }
\&        undef;
\&    }
.Ve
.PP
If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.
.PP
.Vb 1
\&    my $is_there = grep $_ eq $whatever, @array;
.Ve
.PP
If you want to actually extract the matching elements, simply use grep in
list context.
.PP
.Vb 1
\&    my @matches = grep $_ eq $whatever, @array;
.Ve
.SS "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
.IX Subsection "How do I compute the difference of two arrays? How do I compute the intersection of two arrays?"
Use a hash. Here's code to do both and more. It assumes that each
element is unique in a given array:
.PP
.Vb 7
\&    my (@union, @intersection, @difference);
\&    my %count = ();
\&    foreach my $element (@array1, @array2) { $count{$element}++ }
\&    foreach my $element (keys %count) {
\&        push @union, $element;
\&        push @{ $count{$element} > 1 ? \e@intersection : \e@difference }, $element;
\&    }
.Ve
.PP
Note that this is the \fIsymmetric difference\fR, that is, all elements
in either A or in B but not in both. Think of it as an xor operation.
.SS "How do I test whether two arrays or hashes are equal?"
.IX Subsection "How do I test whether two arrays or hashes are equal?"
With Perl 5.10 and later, the smart match operator can give you the answer
with the least amount of work:
.PP
.Vb 1
\&    use 5.010;
\&
\&    if( @array1 ~~ @array2 ) {
\&        say "The arrays are the same";
\&    }
\&
\&    if( %hash1 ~~ %hash2 ) # doesn\*(Aqt check values!  {
\&        say "The hash keys are the same";
\&    }
.Ve
.PP
The following code works for single-level arrays. It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings. Modify if you have other needs.
.PP
.Vb 1
\&    $are_equal = compare_arrays(\e@frogs, \e@toads);
\&
\&    sub compare_arrays {
\&        my ($first, $second) = @_;
\&        no warnings;  # silence spurious \-w undef complaints
\&        return 0 unless @$first == @$second;
\&        for (my $i = 0; $i < @$first; $i++) {
\&            return 0 if $first\->[$i] ne $second\->[$i];
\&        }
\&        return 1;
\&    }
.Ve
.PP
For multilevel structures, you may wish to use an approach more
like this one. It uses the \s-1CPAN\s0 module FreezeThaw:
.PP
.Vb 2
\&    use FreezeThaw qw(cmpStr);
\&    my @a = my @b = ( "this", "that", [ "more", "stuff" ] );
\&
\&    printf "a and b contain %s arrays\en",
\&        cmpStr(\e@a, \e@b) == 0
\&        ? "the same"
\&        : "different";
.Ve
.PP
This approach also works for comparing hashes. Here we'll demonstrate
two different answers:
.PP
.Vb 1
\&    use FreezeThaw qw(cmpStr cmpStrHard);
\&
\&    my %a = my %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
\&    $a{EXTRA} = \e%b;
\&    $b{EXTRA} = \e%a;
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStr(\e%a, \e%b) == 0 ? "the same" : "different";
\&
\&    printf "a and b contain %s hashes\en",
\&    cmpStrHard(\e%a, \e%b) == 0 ? "the same" : "different";
.Ve
.PP
The first reports that both those the hashes contain the same data,
while the second reports that they do not. Which you prefer is left as
an exercise to the reader.
.SS "How do I find the first array element for which a condition is true?"
.IX Subsection "How do I find the first array element for which a condition is true?"
To find the first array element which satisfies a condition, you can
use the \f(CW\*(C`first()\*(C'\fR function in the List::Util module, which comes
with Perl 5.8. This example finds the first element that contains
\&\*(L"Perl\*(R".
.PP
.Vb 1
\&    use List::Util qw(first);
\&
\&    my $element = first { /Perl/ } @array;
.Ve
.PP
If you cannot use List::Util, you can make your own loop to do the
same thing. Once you find the element, you stop the loop with last.
.PP
.Vb 4
\&    my $found;
\&    foreach ( @array ) {
\&        if( /Perl/ ) { $found = $_; last }
\&    }
.Ve
.PP
If you want the array index, use the \f(CW\*(C`firstidx()\*(C'\fR function from
\&\f(CW\*(C`List::MoreUtils\*(C'\fR:
.PP
.Vb 2
\&    use List::MoreUtils qw(firstidx);
\&    my $index = firstidx { /Perl/ } @array;
.Ve
.PP
Or write it yourself, iterating through the indices
and checking the array element at each index until you find one
that satisfies the condition:
.PP
.Vb 8
\&    my( $found, $index ) = ( undef, \-1 );
\&    for( $i = 0; $i < @array; $i++ ) {
\&        if( $array[$i] =~ /Perl/ ) {
\&            $found = $array[$i];
\&            $index = $i;
\&            last;
\&        }
\&    }
.Ve
.SS "How do I handle linked lists?"
.IX Subsection "How do I handle linked lists?"
(contributed by brian d foy)
.PP
Perl's arrays do not have a fixed size, so you don't need linked lists
if you just want to add or remove items. You can use array operations
such as \f(CW\*(C`push\*(C'\fR, \f(CW\*(C`pop\*(C'\fR, \f(CW\*(C`shift\*(C'\fR, \f(CW\*(C`unshift\*(C'\fR, or \f(CW\*(C`splice\*(C'\fR to do
that.
.PP
Sometimes, however, linked lists can be useful in situations where you
want to \*(L"shard\*(R" an array so you have have many small arrays instead of
a single big array. You can keep arrays longer than Perl's largest
array index, lock smaller arrays separately in threaded programs,
reallocate less memory, or quickly insert elements in the middle of
the chain.
.PP
Steve Lembark goes through the details in his \s-1YAPC::NA\s0 2009 talk \*(L"Perly
Linked Lists\*(R" ( http://www.slideshare.net/lembark/perly\-linked\-lists <http://www.slideshare.net/lembark/perly-linked-lists> ),
although you can just use his LinkedList::Single module.
.SS "How do I handle circular lists?"
.IX Xref "circular array Tie::Cycle Array::Iterator::Circular cycle modulus"
.IX Subsection "How do I handle circular lists?"
(contributed by brian d foy)
.PP
If you want to cycle through an array endlessly, you can increment the
index modulo the number of elements in the array:
.PP
.Vb 2
\&    my @array = qw( a b c );
\&    my $i = 0;
\&
\&    while( 1 ) {
\&        print $array[ $i++ % @array ], "\en";
\&        last if $i > 20;
\&    }
.Ve
.PP
You can also use Tie::Cycle to use a scalar that always has the
next element of the circular array:
.PP
.Vb 1
\&    use Tie::Cycle;
\&
\&    tie my $cycle, \*(AqTie::Cycle\*(Aq, [ qw( FFFFFF 000000 FFFF00 ) ];
\&
\&    print $cycle; # FFFFFF
\&    print $cycle; # 000000
\&    print $cycle; # FFFF00
.Ve
.PP
The Array::Iterator::Circular creates an iterator object for
circular arrays:
.PP
.Vb 1
\&    use Array::Iterator::Circular;
\&
\&    my $color_iterator = Array::Iterator::Circular\->new(
\&        qw(red green blue orange)
\&        );
\&
\&    foreach ( 1 .. 20 ) {
\&        print $color_iterator\->next, "\en";
\&    }
.Ve
.SS "How do I shuffle an array randomly?"
.IX Subsection "How do I shuffle an array randomly?"
If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:
.PP
.Vb 1
\&    use List::Util \*(Aqshuffle\*(Aq;
\&
\&    @shuffled = shuffle(@list);
.Ve
.PP
If not, you can use a Fisher-Yates shuffle.
.PP
.Vb 3
\&    sub fisher_yates_shuffle {
\&        my $deck = shift;  # $deck is a reference to an array
\&        return unless @$deck; # must not be empty!
\&
\&        my $i = @$deck;
\&        while (\-\-$i) {
\&            my $j = int rand ($i+1);
\&            @$deck[$i,$j] = @$deck[$j,$i];
\&        }
\&    }
\&
\&    # shuffle my mpeg collection
\&    #
\&    my @mpeg = <audio/*/*.mp3>;
\&    fisher_yates_shuffle( \e@mpeg );    # randomize @mpeg in place
\&    print @mpeg;
.Ve
.PP
Note that the above implementation shuffles an array in place,
unlike the \f(CW\*(C`List::Util::shuffle()\*(C'\fR which takes a list and returns
a new shuffled list.
.PP
You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with
.PP
.Vb 6
\&    srand;
\&    @new = ();
\&    @old = 1 .. 10;  # just a demo
\&    while (@old) {
\&        push(@new, splice(@old, rand @old, 1));
\&    }
.Ve
.PP
This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.
.SS "How do I process/modify each element of an array?"
.IX Subsection "How do I process/modify each element of an array?"
Use \f(CW\*(C`for\*(C'\fR/\f(CW\*(C`foreach\*(C'\fR:
.PP
.Vb 4
\&    for (@lines) {
\&        s/foo/bar/;    # change that word
\&        tr/XZ/ZX/;    # swap those letters
\&    }
.Ve
.PP
Here's another; let's compute spherical volumes:
.PP
.Vb 5
\&    my @volumes = @radii;
\&    for (@volumes) {   # @volumes has changed parts
\&        $_ **= 3;
\&        $_ *= (4/3) * 3.14159;  # this will be constant folded
\&    }
.Ve
.PP
which can also be done with \f(CW\*(C`map()\*(C'\fR which is made to transform
one list into another:
.PP
.Vb 1
\&    my @volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;
.Ve
.PP
If you want to do the same thing to modify the values of the
hash, you can use the \f(CW\*(C`values\*(C'\fR function. As of Perl 5.6
the values are not copied, so if you modify \f(CW$orbit\fR (in this
case), you modify the value.
.PP
.Vb 3
\&    for my $orbit ( values %orbits ) {
\&        ($orbit **= 3) *= (4/3) * 3.14159;
\&    }
.Ve
.PP
Prior to perl 5.6 \f(CW\*(C`values\*(C'\fR returned copies of the values,
so older perl code often contains constructions such as
\&\f(CW@orbits{keys %orbits}\fR instead of \f(CW\*(C`values %orbits\*(C'\fR where
the hash is to be modified.
.SS "How do I select a random element from an array?"
.IX Subsection "How do I select a random element from an array?"
Use the \f(CW\*(C`rand()\*(C'\fR function (see \*(L"rand\*(R" in perlfunc):
.PP
.Vb 2
\&    my $index   = rand @array;
\&    my $element = $array[$index];
.Ve
.PP
Or, simply:
.PP
.Vb 1
\&    my $element = $array[ rand @array ];
.Ve
.SS "How do I permute N elements of a list?"
.IX Xref "List::Permutor permute Algorithm::Loops Knuth The Art of Computer Programming Fischer-Krause"
.IX Subsection "How do I permute N elements of a list?"
Use the List::Permutor module on \s-1CPAN\s0. If the list is actually an
array, try the Algorithm::Permute module (also on \s-1CPAN\s0). It's
written in \s-1XS\s0 code and is very efficient:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&    my $p_iterator = Algorithm::Permute\->new ( \e@array );
\&
\&    while (my @perm = $p_iterator\->next) {
\&       print "next permutation: (@perm)\en";
\&    }
.Ve
.PP
For even faster execution, you could do:
.PP
.Vb 1
\&    use Algorithm::Permute;
\&
\&    my @array = \*(Aqa\*(Aq..\*(Aqd\*(Aq;
\&
\&    Algorithm::Permute::permute {
\&        print "next permutation: (@array)\en";
\&    } @array;
.Ve
.PP
Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
\&\f(CW\*(C`permute()\*(C'\fR function is discussed in Volume 4 (still unpublished) of
Knuth's \fIThe Art of Computer Programming\fR and will work on any list:
.PP
.Vb 2
\&    #!/usr/bin/perl \-n
\&    # Fischer\-Krause ordered permutation generator
\&
\&    sub permute (&@) {
\&        my $code = shift;
\&        my @idx = 0..$#_;
\&        while ( $code\->(@_[@idx]) ) {
\&            my $p = $#idx;
\&            \-\-$p while $idx[$p\-1] > $idx[$p];
\&            my $q = $p or return;
\&            push @idx, reverse splice @idx, $p;
\&            ++$q while $idx[$p\-1] > $idx[$q];
\&            @idx[$p\-1,$q]=@idx[$q,$p\-1];
\&        }
\&    }
\&
\&    permute { print "@_\en" } split;
.Ve
.PP
The Algorithm::Loops module also provides the \f(CW\*(C`NextPermute\*(C'\fR and
\&\f(CW\*(C`NextPermuteNum\*(C'\fR functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.
.PP
\&\f(CW\*(C`NextPermute\*(C'\fR uses string order and \f(CW\*(C`NextPermuteNum\*(C'\fR numeric order, so
you can enumerate all the permutations of \f(CW0..9\fR like this:
.PP
.Vb 1
\&    use Algorithm::Loops qw(NextPermuteNum);
\&
\&    my @list= 0..9;
\&    do { print "@list\en" } while NextPermuteNum @list;
.Ve
.SS "How do I sort an array by (anything)?"
.IX Subsection "How do I sort an array by (anything)?"
Supply a comparison function to \fIsort()\fR (described in \*(L"sort\*(R" in perlfunc):
.PP
.Vb 1
\&    @list = sort { $a <=> $b } @list;
.Ve
.PP
The default sort function is cmp, string comparison, which would
sort \f(CW\*(C`(1, 2, 10)\*(C'\fR into \f(CW\*(C`(1, 10, 2)\*(C'\fR. \f(CW\*(C`<=>\*(C'\fR, used above, is
the numerical comparison operator.
.PP
If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function. Pull it
out first, because the sort \s-1BLOCK\s0 can be called many times for the
same element. Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.
.PP
.Vb 7
\&    my @idx;
\&    for (@data) {
\&        my $item;
\&        ($item) = /\ed+\es*(\eS+)/;
\&        push @idx, uc($item);
\&    }
\&    my @sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];
.Ve
.PP
which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:
.PP
.Vb 3
\&    my @sorted = map  { $_\->[0] }
\&        sort { $a\->[1] cmp $b\->[1] }
\&        map  { [ $_, uc( (/\ed+\es*(\eS+)/)[0]) ] } @data;
.Ve
.PP
If you need to sort on several fields, the following paradigm is useful.
.PP
.Vb 5
\&    my @sorted = sort {
\&        field1($a) <=> field1($b) ||
\&        field2($a) cmp field2($b) ||
\&        field3($a) cmp field3($b)
\&    } @data;
.Ve
.PP
This can be conveniently combined with precalculation of keys as given
above.
.PP
See the \fIsort\fR article in the \*(L"Far More Than You Ever Wanted
To Know\*(R" collection in <http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz> for
more about this approach.
.PP
See also the question later in perlfaq4 on sorting hashes.
.SS "How do I manipulate arrays of bits?"
.IX Subsection "How do I manipulate arrays of bits?"
Use \f(CW\*(C`pack()\*(C'\fR and \f(CW\*(C`unpack()\*(C'\fR, or else \f(CW\*(C`vec()\*(C'\fR and the bitwise
operations.
.PP
For example, you don't have to store individual bits in an array
(which would mean that you're wasting a lot of space). To convert an
array of bits to a string, use \f(CW\*(C`vec()\*(C'\fR to set the right bits. This
sets \f(CW$vec\fR to have bit N set only if \f(CW$ints[N]\fR was set:
.PP
.Vb 5
\&    my @ints = (...); # array of bits, e.g. ( 1, 0, 0, 1, 1, 0 ... )
\&    my $vec = \*(Aq\*(Aq;
\&    foreach( 0 .. $#ints ) {
\&        vec($vec,$_,1) = 1 if $ints[$_];
\&    }
.Ve
.PP
The string \f(CW$vec\fR only takes up as many bits as it needs. For
instance, if you had 16 entries in \f(CW@ints\fR, \f(CW$vec\fR only needs two
bytes to store them (not counting the scalar variable overhead).
.PP
Here's how, given a vector in \f(CW$vec\fR, you can get those bits into
your \f(CW@ints\fR array:
.PP
.Vb 7
\&    sub bitvec_to_list {
\&        my $vec = shift;
\&        my @ints;
\&        # Find null\-byte density then select best algorithm
\&        if ($vec =~ tr/\e0// / length $vec > 0.95) {
\&            use integer;
\&            my $i;
\&
\&            # This method is faster with mostly null\-bytes
\&            while($vec =~ /[^\e0]/g ) {
\&                $i = \-9 + 8 * pos $vec;
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&                push @ints, $i if vec($vec, ++$i, 1);
\&            }
\&        }
\&        else {
\&            # This method is a fast general algorithm
\&            use integer;
\&            my $bits = unpack "b*", $vec;
\&            push @ints, 0 if $bits =~ s/^(\ed)// && $1;
\&            push @ints, pos $bits while($bits =~ /1/g);
\&        }
\&
\&        return \e@ints;
\&    }
.Ve
.PP
This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)
.PP
You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:
.PP
.Vb 3
\&    while($vec =~ /[^\e0]+/g ) {
\&        push @ints, grep vec($vec, $_, 1), $\-[0] * 8 .. $+[0] * 8;
\&    }
.Ve
.PP
Or use the \s-1CPAN\s0 module Bit::Vector:
.PP
.Vb 3
\&    my $vector = Bit::Vector\->new($num_of_bits);
\&    $vector\->Index_List_Store(@ints);
\&    my @ints = $vector\->Index_List_Read();
.Ve
.PP
Bit::Vector provides efficient methods for bit vector, sets of
small integers and \*(L"big int\*(R" math.
.PP
Here's a more extensive illustration using \fIvec()\fR:
.PP
.Vb 7
\&    # vec demo
\&    my $vector = "\exff\ex0f\exef\exfe";
\&    print "Ilya\*(Aqs string \e\exff\e\ex0f\e\exef\e\exfe represents the number ",
\&    unpack("N", $vector), "\en";
\&    my $is_set = vec($vector, 23, 1);
\&    print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\en";
\&    pvec($vector);
\&
\&    set_vec(1,1,1);
\&    set_vec(3,1,1);
\&    set_vec(23,1,1);
\&
\&    set_vec(3,1,3);
\&    set_vec(3,2,3);
\&    set_vec(3,4,3);
\&    set_vec(3,4,7);
\&    set_vec(3,8,3);
\&    set_vec(3,8,7);
\&
\&    set_vec(0,32,17);
\&    set_vec(1,32,17);
\&
\&    sub set_vec {
\&        my ($offset, $width, $value) = @_;
\&        my $vector = \*(Aq\*(Aq;
\&        vec($vector, $offset, $width) = $value;
\&        print "offset=$offset width=$width value=$value\en";
\&        pvec($vector);
\&    }
\&
\&    sub pvec {
\&        my $vector = shift;
\&        my $bits = unpack("b*", $vector);
\&        my $i = 0;
\&        my $BASE = 8;
\&
\&        print "vector length in bytes: ", length($vector), "\en";
\&        @bytes = unpack("A8" x length($vector), $bits);
\&        print "bits are: @bytes\en\en";
\&    }
.Ve
.SS "Why does \fIdefined()\fP return true on empty arrays and hashes?"
.IX Subsection "Why does defined() return true on empty arrays and hashes?"
The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes). See \*(L"defined\*(R" in perlfunc
in the 5.004 release or later of Perl for more detail.
.SH "Data: Hashes (Associative Arrays)"
.IX Header "Data: Hashes (Associative Arrays)"
.SS "How do I process an entire hash?"
.IX Subsection "How do I process an entire hash?"
(contributed by brian d foy)
.PP
There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.
.PP
To go through all of the keys, use the \f(CW\*(C`keys\*(C'\fR function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:
.PP
.Vb 4
\&    foreach my $key ( keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Once you have the list of keys, you can process that list before you
process the hash elements. For instance, you can sort the keys so you
can process them in lexical order:
.PP
.Vb 4
\&    foreach my $key ( sort keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
Or, you might want to only process some of the items. If you only want
to deal with the keys that start with \f(CW\*(C`text:\*(C'\fR, you can select just
those using \f(CW\*(C`grep\*(C'\fR:
.PP
.Vb 4
\&    foreach my $key ( grep /^text:/, keys %hash ) {
\&        my $value = $hash{$key}
\&        ...
\&    }
.Ve
.PP
If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab one key-value pair at a time using
\&\f(CW\*(C`each()\*(C'\fR, which returns a pair you haven't seen yet:
.PP
.Vb 3
\&    while( my( $key, $value ) = each( %hash ) ) {
\&        ...
\&    }
.Ve
.PP
The \f(CW\*(C`each\*(C'\fR operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the \f(CW\*(C`keys\*(C'\fR method.
.PP
The \f(CW\*(C`each()\*(C'\fR operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you mix \f(CW\*(C`keys\*(C'\fR, \f(CW\*(C`values\*(C'\fR, or \f(CW\*(C`each\*(C'\fR on the same hash, you risk resetting
the iterator and messing up your processing. See the \f(CW\*(C`each\*(C'\fR entry in
perlfunc for more details.
.SS "How do I merge two hashes?"
.IX Xref "hash merge slice, hash"
.IX Subsection "How do I merge two hashes?"
(contributed by brian d foy)
.PP
Before you decide to merge two hashes, you have to decide what to do
if both hashes contain keys that are the same and if you want to leave
the original hashes as they were.
.PP
If you want to preserve the original hashes, copy one hash (\f(CW%hash1\fR)
to a new hash (\f(CW%new_hash\fR), then add the keys from the other hash
(\f(CW%hash2\fR to the new hash. Checking that the key already exists in
\&\f(CW%new_hash\fR gives you a chance to decide what to do with the
duplicates:
.PP
.Vb 1
\&    my %new_hash = %hash1; # make a copy; leave %hash1 alone
\&
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $new_hash{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $new_hash{$key2} = $hash2{$key2};
\&        }
\&    }
.Ve
.PP
If you don't want to create a new hash, you can still use this looping
technique; just change the \f(CW%new_hash\fR to \f(CW%hash1\fR.
.PP
.Vb 11
\&    foreach my $key2 ( keys %hash2 ) {
\&        if( exists $hash1{$key2} ) {
\&            warn "Key [$key2] is in both hashes!";
\&            # handle the duplicate (perhaps only warning)
\&            ...
\&            next;
\&        }
\&        else {
\&            $hash1{$key2} = $hash2{$key2};
\&        }
\&      }
.Ve
.PP
If you don't care that one hash overwrites keys and values from the other, you
could just use a hash slice to add one hash to another. In this case, values
from \f(CW%hash2\fR replace values from \f(CW%hash1\fR when they have keys in common:
.PP
.Vb 1
\&    @hash1{ keys %hash2 } = values %hash2;
.Ve
.SS "What happens if I add or remove keys from a hash while iterating over it?"
.IX Subsection "What happens if I add or remove keys from a hash while iterating over it?"
(contributed by brian d foy)
.PP
The easy answer is \*(L"Don't do that!\*(R"
.PP
If you iterate through the hash with \fIeach()\fR, you can delete the key
most recently returned without worrying about it. If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table. See the
entry for \f(CW\*(C`each()\*(C'\fR in perlfunc.
.SS "How do I look up a hash element by value?"
.IX Subsection "How do I look up a hash element by value?"
Create a reverse hash:
.PP
.Vb 2
\&    my %by_value = reverse %by_key;
\&    my $key = $by_value{$value};
.Ve
.PP
That's not particularly efficient. It would be more space-efficient
to use:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&        $by_value{$value} = $key;
\&    }
.Ve
.PP
If your hash could have repeated values, the methods above will only find
one of the associated keys.  This may or may not worry you. If it does
worry you, you can always reverse the hash into a hash of arrays instead:
.PP
.Vb 3
\&    while (my ($key, $value) = each %by_key) {
\&         push @{$key_list_by_value{$value}}, $key;
\&    }
.Ve
.SS "How can I know how many entries are in a hash?"
.IX Subsection "How can I know how many entries are in a hash?"
(contributed by brian d foy)
.PP
This is very similar to \*(L"How do I process an entire hash?\*(R", also in
perlfaq4, but a bit simpler in the common cases.
.PP
You can use the \f(CW\*(C`keys()\*(C'\fR built-in function in scalar context to find out
have many entries you have in a hash:
.PP
.Vb 1
\&    my $key_count = keys %hash; # must be scalar context!
.Ve
.PP
If you want to find out how many entries have a defined value, that's
a bit different. You have to check each value. A \f(CW\*(C`grep\*(C'\fR is handy:
.PP
.Vb 1
\&    my $defined_value_count = grep { defined } values %hash;
.Ve
.PP
You can use that same structure to count the entries any way that
you like. If you want the count of the keys with vowels in them,
you just test for that instead:
.PP
.Vb 1
\&    my $vowel_count = grep { /[aeiou]/ } keys %hash;
.Ve
.PP
The \f(CW\*(C`grep\*(C'\fR in scalar context returns the count. If you want the list
of matching items, just use it in list context instead:
.PP
.Vb 1
\&    my @defined_values = grep { defined } values %hash;
.Ve
.PP
The \f(CW\*(C`keys()\*(C'\fR function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
such as \f(CW\*(C`each()\*(C'\fR.
.SS "How do I sort a hash (optionally by value instead of key)?"
.IX Subsection "How do I sort a hash (optionally by value instead of key)?"
(contributed by brian d foy)
.PP
To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.
.PP
.Vb 1
\&    my @keys = sort { $a cmp $b } keys %hash;
\&
\&    foreach my $key ( @keys ) {
\&        printf "%\-20s %6d\en", $key, $hash{$key};
\&    }
.Ve
.PP
We could get more fancy in the \f(CW\*(C`sort()\*(C'\fR block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.
.PP
For instance, to make our report order case-insensitive, we use
\&\f(CW\*(C`lc\*(C'\fR to lowercase the keys before comparing them:
.PP
.Vb 1
\&    my @keys = sort { lc $a cmp lc $b } keys %hash;
.Ve
.PP
Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.
.PP
If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.
.PP
.Vb 1
\&    my @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;
.Ve
.PP
From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.
.PP
.Vb 5
\&    my @keys = sort {
\&        $hash{$a} <=> $hash{$b}
\&            or
\&        "\eL$a" cmp "\eL$b"
\&    } keys %hash;
.Ve
.SS "How can I always keep my hash sorted?"
.IX Xref "hash tie sort DB_File Tie::IxHash"
.IX Subsection "How can I always keep my hash sorted?"
You can look into using the \f(CW\*(C`DB_File\*(C'\fR module and \f(CW\*(C`tie()\*(C'\fR using the
\&\f(CW$DB_BTREE\fR hash bindings as documented in \*(L"In Memory
Databases\*(R" in DB_File. The Tie::IxHash module from \s-1CPAN\s0 might also be
instructive. Although this does keep your hash sorted, you might not
like the slowdown you suffer from the tie interface. Are you sure you
need to do this? :)
.ie n .SS "What's the difference between ""delete"" and ""undef"" with hashes?"
.el .SS "What's the difference between ``delete'' and ``undef'' with hashes?"
.IX Subsection "What's the difference between delete and undef with hashes?"
Hashes contain pairs of scalars: the first is the key, the
second is the value. The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference. If a key \f(CW$key\fR is present in
\&\f(CW%hash\fR, \f(CW\*(C`exists($hash{$key})\*(C'\fR will return true. The value
for a given key can be \f(CW\*(C`undef\*(C'\fR, in which case
\&\f(CW$hash{$key}\fR will be \f(CW\*(C`undef\*(C'\fR while \f(CW\*(C`exists $hash{$key}\*(C'\fR
will return true. This corresponds to (\f(CW$key\fR, \f(CW\*(C`undef\*(C'\fR)
being in the hash.
.PP
Pictures help... Here's the \f(CW%hash\fR table:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   |  3   |
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
And these conditions hold
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is true
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is true
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
If you now say
.PP
.Vb 1
\&    undef $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 7
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  a   | undef|
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is FALSE
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is FALSE
\&    exists $hash{\*(Aqa\*(Aq}                is true (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is true
.Ve
.PP
Notice the last two: you have an undef value, but a defined key!
.PP
Now, consider this:
.PP
.Vb 1
\&    delete $hash{\*(Aqa\*(Aq}
.Ve
.PP
your table now reads:
.PP
.Vb 6
\&      keys  values
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
\&    |  x   |  7   |
\&    |  d   |  0   |
\&    |  e   |  2   |
\&    +\-\-\-\-\-\-+\-\-\-\-\-\-+
.Ve
.PP
and these conditions now hold; changes in caps:
.PP
.Vb 6
\&    $hash{\*(Aqa\*(Aq}                       is false
\&    $hash{\*(Aqd\*(Aq}                       is false
\&    defined $hash{\*(Aqd\*(Aq}               is true
\&    defined $hash{\*(Aqa\*(Aq}               is false
\&    exists $hash{\*(Aqa\*(Aq}                is FALSE (Perl 5 only)
\&    grep ($_ eq \*(Aqa\*(Aq, keys %hash)     is FALSE
.Ve
.PP
See, the whole entry is gone!
.SS "Why don't my tied hashes make the defined/exists distinction?"
.IX Subsection "Why don't my tied hashes make the defined/exists distinction?"
This depends on the tied hash's implementation of \s-1\fIEXISTS\s0()\fR.
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that \fIexists()\fR and
\&\fIdefined()\fR do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.
.SS "How do I reset an \fIeach()\fP operation part-way through?"
.IX Subsection "How do I reset an each() operation part-way through?"
(contributed by brian d foy)
.PP
You can use the \f(CW\*(C`keys\*(C'\fR or \f(CW\*(C`values\*(C'\fR functions to reset \f(CW\*(C`each\*(C'\fR. To
simply reset the iterator used by \f(CW\*(C`each\*(C'\fR without doing anything else,
use one of them in void context:
.PP
.Vb 2
\&    keys %hash; # resets iterator, nothing else.
\&    values %hash; # resets iterator, nothing else.
.Ve
.PP
See the documentation for \f(CW\*(C`each\*(C'\fR in perlfunc.
.SS "How can I get the unique keys from two hashes?"
.IX Subsection "How can I get the unique keys from two hashes?"
First you extract the keys from the hashes into lists, then solve
the \*(L"removing duplicates\*(R" problem described above. For example:
.PP
.Vb 5
\&    my %seen = ();
\&    for my $element (keys(%foo), keys(%bar)) {
\&        $seen{$element}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.PP
Or more succinctly:
.PP
.Vb 1
\&    my @uniq = keys %{{%foo,%bar}};
.Ve
.PP
Or if you really want to save space:
.PP
.Vb 8
\&    my %seen = ();
\&    while (defined ($key = each %foo)) {
\&        $seen{$key}++;
\&    }
\&    while (defined ($key = each %bar)) {
\&        $seen{$key}++;
\&    }
\&    my @uniq = keys %seen;
.Ve
.SS "How can I store a multidimensional array in a \s-1DBM\s0 file?"
.IX Subsection "How can I store a multidimensional array in a DBM file?"
Either stringify the structure yourself (no fun), or else
get the \s-1MLDBM\s0 (which uses Data::Dumper) module from \s-1CPAN\s0 and layer
it on top of either DB_File or GDBM_File. You might also try DBM::Deep, but
it can be a bit slow.
.SS "How can I make my hash remember the order I put elements into it?"
.IX Subsection "How can I make my hash remember the order I put elements into it?"
Use the Tie::IxHash from \s-1CPAN\s0.
.PP
.Vb 1
\&    use Tie::IxHash;
\&
\&    tie my %myhash, \*(AqTie::IxHash\*(Aq;
\&
\&    for (my $i=0; $i<20; $i++) {
\&        $myhash{$i} = 2*$i;
\&    }
\&
\&    my @keys = keys %myhash;
\&    # @keys = (0,1,2,3,...)
.Ve
.SS "Why does passing a subroutine an undefined element in a hash create it?"
.IX Subsection "Why does passing a subroutine an undefined element in a hash create it?"
(contributed by brian d foy)
.PP
Are you using a really old version of Perl?
.PP
Normally, accessing a hash key's value for a nonexistent key will
\&\fInot\fR create the key.
.PP
.Vb 3
\&    my %hash  = ();
\&    my $value = $hash{ \*(Aqfoo\*(Aq };
\&    print "This won\*(Aqt print\en" if exists $hash{ \*(Aqfoo\*(Aq };
.Ve
.PP
Passing \f(CW$hash{ \*(Aqfoo\*(Aq }\fR to a subroutine used to be a special case, though.
Since you could assign directly to \f(CW$_[0]\fR, Perl had to be ready to
make that assignment so it created the hash key ahead of time:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print before 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        # $_[0] = \*(Aqbar\*(Aq; # create hash key in case you do this
\&        1;
\&    }
.Ve
.PP
Since Perl 5.004, however, this situation is a special case and Perl
creates the hash key only when you make the assignment:
.PP
.Vb 2
\&    my_sub( $hash{ \*(Aqfoo\*(Aq } );
\&    print "This will print, even after 5.004\en" if exists $hash{ \*(Aqfoo\*(Aq };
\&
\&    sub my_sub {
\&        $_[0] = \*(Aqbar\*(Aq;
\&    }
.Ve
.PP
However, if you want the old behavior (and think carefully about that
because it's a weird side effect), you can pass a hash slice instead.
Perl 5.004 didn't make this a special case:
.PP
.Vb 1
\&    my_sub( @hash{ qw/foo/ } );
.Ve
.SS "How can I make the Perl equivalent of a C structure/\*(C+ class/hash or array of hashes or arrays?"
.IX Subsection "How can I make the Perl equivalent of a C structure/ class/hash or array of hashes or arrays?"
Usually a hash ref, perhaps like this:
.PP
.Vb 8
\&    $record = {
\&        NAME   => "Jason",
\&        EMPNO  => 132,
\&        TITLE  => "deputy peon",
\&        AGE    => 23,
\&        SALARY => 37_000,
\&        PALS   => [ "Norbert", "Rhys", "Phineas"],
\&    };
.Ve
.PP
References are documented in perlref and perlreftut.
Examples of complex data structures are given in perldsc and
perllol. Examples of structures and object-oriented classes are
in perltoot.
.SS "How can I use a reference as a hash key?"
.IX Subsection "How can I use a reference as a hash key?"
(contributed by brian d foy and Ben Morrow)
.PP
Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, \f(CW\*(C`HASH(0xDEADBEEF)\*(C'\fR). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own.
.PP
Remember that the entry in the hash will still be there even if
the referenced variable  goes out of scope, and that it is entirely
possible for Perl to subsequently allocate a different variable at
the same address. This will mean a new variable might accidentally
be associated with the value for an old.
.PP
If you have Perl 5.10 or later, and you just want to store a value
against the reference for lookup later, you can use the core
Hash::Util::Fieldhash module. This will also handle renaming the
keys if you use multiple threads (which causes all variables to be
reallocated at new addresses, changing their stringification), and
garbage-collecting the entries when the referenced variable goes out
of scope.
.PP
If you actually need to be able to get a real reference back from
each hash entry, you can use the Tie::RefHash module, which does the
required work for you.
.SS "How can I check if a key exists in a multilevel hash?"
.IX Subsection "How can I check if a key exists in a multilevel hash?"
(contributed by brian d foy)
.PP
The trick to this problem is avoiding accidental autovivification. If
you want to check three keys deep, you might nai\*:vely try this:
.PP
.Vb 4
\&    my %hash;
\&    if( exists $hash{key1}{key2}{key3} ) {
\&        ...;
\&    }
.Ve
.PP
Even though you started with a completely empty hash, after that call to
\&\f(CW\*(C`exists\*(C'\fR you've created the structure you needed to check for \f(CW\*(C`key3\*(C'\fR:
.PP
.Vb 5
\&    %hash = (
\&              \*(Aqkey1\*(Aq => {
\&                          \*(Aqkey2\*(Aq => {}
\&                        }
\&            );
.Ve
.PP
That's autovivification. You can get around this in a few ways. The
easiest way is to just turn it off. The lexical \f(CW\*(C`autovivification\*(C'\fR
pragma is available on \s-1CPAN\s0. Now you don't add to the hash:
.PP
.Vb 7
\&    {
\&        no autovivification;
\&        my %hash;
\&        if( exists $hash{key1}{key2}{key3} ) {
\&            ...;
\&        }
\&    }
.Ve
.PP
The Data::Diver module on \s-1CPAN\s0 can do it for you too. Its \f(CW\*(C`Dive\*(C'\fR
subroutine can tell you not only if the keys exist but also get the
value:
.PP
.Vb 1
\&    use Data::Diver qw(Dive);
\&
\&    my @exists = Dive( \e%hash, qw(key1 key2 key3) );
\&    if(  ! @exists  ) {
\&        ...; # keys do not exist
\&    }
\&    elsif(  ! defined $exists[0]  ) {
\&        ...; # keys exist but value is undef
\&    }
.Ve
.PP
You can easily do this yourself too by checking each level of the hash
before you move onto the next level. This is essentially what
Data::Diver does for you:
.PP
.Vb 3
\&    if( check_hash( \e%hash, qw(key1 key2 key3) ) ) {
\&        ...;
\&    }
\&
\&    sub check_hash {
\&       my( $hash, @keys ) = @_;
\&
\&       return unless @keys;
\&
\&       foreach my $key ( @keys ) {
\&           return unless eval { exists $hash\->{$key} };
\&           $hash = $hash\->{$key};
\&        }
\&
\&       return 1;
\&    }
.Ve
.SS "How can I prevent addition of unwanted keys into a hash?"
.IX Subsection "How can I prevent addition of unwanted keys into a hash?"
Since version 5.8.0, hashes can be \fIrestricted\fR to a fixed number
of given keys. Methods for creating and dealing with restricted hashes
are exported by the Hash::Util module.
.SH "Data: Misc"
.IX Header "Data: Misc"
.SS "How do I handle binary data correctly?"
.IX Subsection "How do I handle binary data correctly?"
Perl is binary-clean, so it can handle binary data just fine.
On Windows or \s-1DOS\s0, however, you have to use \f(CW\*(C`binmode\*(C'\fR for binary
files to avoid conversions for line endings. In general, you should
use \f(CW\*(C`binmode\*(C'\fR any time you want to work with binary data.
.PP
Also see \*(L"binmode\*(R" in perlfunc or perlopentut.
.PP
If you're concerned about 8\-bit textual data then see perllocale.
If you want to deal with multibyte characters, however, there are
some gotchas. See the section on Regular Expressions.
.SS "How do I determine whether a scalar is a number/whole/integer/float?"
.IX Subsection "How do I determine whether a scalar is a number/whole/integer/float?"
Assuming that you don't care about \s-1IEEE\s0 notations like \*(L"NaN\*(R" or
\&\*(L"Infinity\*(R", you probably just want to use a regular expression:
.PP
.Vb 1
\&    use 5.010;
\&
\&    given( $number ) {
\&        when( /\eD/ )
\&            { say "\ethas nondigits"; continue }
\&        when( /^\ed+\ez/ )
\&            { say "\etis a whole number"; continue }
\&        when( /^\-?\ed+\ez/ )
\&            { say "\etis an integer"; continue }
\&        when( /^[+\-]?\ed+\ez/ )
\&            { say "\etis a +/\- integer"; continue }
\&        when( /^\-?(?:\ed+\e.?|\e.\ed)\ed*\ez/ )
\&            { say "\etis a real number"; continue }
\&        when( /^[+\-]?(?=\e.?\ed)\ed*\e.?\ed*(?:e[+\-]?\ed+)?\ez/i)
\&            { say "\etis a C float" }
\&    }
.Ve
.PP
There are also some commonly used modules for the task.
Scalar::Util (distributed with 5.8) provides access to perl's
internal function \f(CW\*(C`looks_like_number\*(C'\fR for determining whether a
variable looks like a number. Data::Types exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is Regexp::Common which has regular
expressions to match various types of numbers. Those three modules are
available from the \s-1CPAN\s0.
.PP
If you're on a \s-1POSIX\s0 system, Perl supports the \f(CW\*(C`POSIX::strtod\*(C'\fR
function for converting strings to doubles (and also \f(CW\*(C`POSIX::strtol\*(C'\fR
for longs). Its semantics are somewhat cumbersome, so here's a
\&\f(CW\*(C`getnum\*(C'\fR wrapper function for more convenient access. This function
takes a string and returns the number it found, or \f(CW\*(C`undef\*(C'\fR for input
that isn't a C float. The \f(CW\*(C`is_numeric\*(C'\fR function is a front end to
\&\f(CW\*(C`getnum\*(C'\fR if you just want to say, \*(L"Is this a float?\*(R"
.PP
.Vb 10
\&    sub getnum {
\&        use POSIX qw(strtod);
\&        my $str = shift;
\&        $str =~ s/^\es+//;
\&        $str =~ s/\es+$//;
\&        $! = 0;
\&        my($num, $unparsed) = strtod($str);
\&        if (($str eq \*(Aq\*(Aq) || ($unparsed != 0) || $!) {
\&                return undef;
\&        }
\&        else {
\&            return $num;
\&        }
\&    }
\&
\&    sub is_numeric { defined getnum($_[0]) }
.Ve
.PP
Or you could check out the String::Scanf module on the \s-1CPAN\s0
instead.
.SS "How do I keep persistent data across program calls?"
.IX Subsection "How do I keep persistent data across program calls?"
For some specific applications, you can use one of the \s-1DBM\s0 modules.
See AnyDBM_File. More generically, you should consult the FreezeThaw
or Storable modules from \s-1CPAN\s0. Starting from Perl 5.8, Storable is part
of the standard distribution. Here's one example using Storable's \f(CW\*(C`store\*(C'\fR
and \f(CW\*(C`retrieve\*(C'\fR functions:
.PP
.Vb 2
\&    use Storable;
\&    store(\e%hash, "filename");
\&
\&    # later on...
\&    $href = retrieve("filename");        # by ref
\&    %hash = %{ retrieve("filename") };   # direct to hash
.Ve
.SS "How do I print out or copy a recursive data structure?"
.IX Subsection "How do I print out or copy a recursive data structure?"
The Data::Dumper module on \s-1CPAN\s0 (or the 5.005 release of Perl) is great
for printing out data structures. The Storable module on \s-1CPAN\s0 (or the
5.8 release of Perl), provides a function called \f(CW\*(C`dclone\*(C'\fR that recursively
copies its argument.
.PP
.Vb 2
\&    use Storable qw(dclone);
\&    $r2 = dclone($r1);
.Ve
.PP
Where \f(CW$r1\fR can be a reference to any kind of data structure you'd like.
It will be deeply copied. Because \f(CW\*(C`dclone\*(C'\fR takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.
.PP
.Vb 1
\&    %newhash = %{ dclone(\e%oldhash) };
.Ve
.SS "How do I define methods for every class/object?"
.IX Subsection "How do I define methods for every class/object?"
(contributed by Ben Morrow)
.PP
You can use the \f(CW\*(C`UNIVERSAL\*(C'\fR class (see \s-1UNIVERSAL\s0). However, please
be very careful to consider the consequences of doing this: adding
methods to every object is very likely to have unintended
consequences. If possible, it would be better to have all your object
inherit from some common base class, or to use an object system like
Moose that supports roles.
.SS "How do I verify a credit card checksum?"
.IX Subsection "How do I verify a credit card checksum?"
Get the Business::CreditCard module from \s-1CPAN\s0.
.SS "How do I pack arrays of doubles or floats for \s-1XS\s0 code?"
.IX Subsection "How do I pack arrays of doubles or floats for XS code?"
The arrays.h/arrays.c code in the \s-1PGPLOT\s0 module on \s-1CPAN\s0 does just this.
If you're doing a lot of float or double processing, consider using
the \s-1PDL\s0 module from \s-1CPAN\s0 instead\*(--it makes number-crunching easy.
.PP
See <http://search.cpan.org/dist/PGPLOT> for the code.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997\-2010 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.
.PP
This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain. You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit. A simple comment in the code giving
credit would be courteous but is not required.
                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man1/perlfaq45.18.1                               0100644 0001750 0001750 00000327041 12566207437 023005  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PERLFAQ4 1"
.TH PERLFAQ4 1 "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
perlfaq4 \- Data Manipulation
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This section of the \s-1FAQ\s0 answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.
.SH "Data: Numbers"
.IX Header "Data: Numbers"
.SS "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
.IX Subsection "Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?"
For the long explanation, see David Goldberg's \*(L"What Every Computer
Scientist Should Know About Floating-Point Arithmetic\*(R"
(<http://web.cse.msu.edu/~cse320/Documents/FloatingPoint.pdf>).
.PP
Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly. Some real numbers lose precision in the process. This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.
.PP
perlnumber shows the gory details of number representations and
conversions.
.PP
To limit the number of decimal places in your numbers, you can use the
\&\f(CW\*(C`printf\*(C'\fR or \f(CW\*(C`sprintf\*(C'\fR function. See
\&\*(L"Floating-point Arithmetic\*(R" in perlop for more details.
.PP
.Vb 1
\&    printf "%.2f", 10/3;
\&
\&    my $number = sprintf "%.2f", 10/3;
.Ve
.SS "Why is \fIint()\fP broken?"
.IX Subsection "Why is int() broken?"
Your \f(CW\*(C`int()\*(C'\fR is most probably working just fine. It's the numbers that
aren't quite what you think.
.PP
First, see the answer to \*(L"Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?\*(R".
.PP
For example, this
.PP
.Vb 1
\&    print int(0.6/0.2\-2), "\en";
.Ve
.PP
will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers. What you think in the above as 'three' is really more like
2.9999999999999995559.
.SS "Why isn't my octal data interpreted correctly?"
.IX Subsection "Why isn't my octal data interpreted correctly?"
(contributed by brian d foy)
.PP
You're probably trying to convert a string to a number, which Perl only
converts as a decimal number. When Perl converts a string to a number, it
ignores leading spaces and zeroes, then assumes the rest of the digits
are in base 10:
.PP
.Vb 1
\&    my $string = \*(Aq0644\*(Aq;
\&
\&    print $string + 0;  # prints 644
\&
\&    print $string + 44; # prints 688, certainly not octal!
.Ve
.PP
This problem usually involves one of the Perl built-ins that has the
same name a Unix command that uses octal numbers as arguments on the
command line. In this example, \f(CW\*(C`chmod\*(C'\fR on the command line knows that
its first argument is octal because that's what it does:
.PP
.Vb 1
\&    %prompt> chmod 644 file
.Ve
.PP
If you want to use the same literal digits (644) in Perl, you have to tell
Perl to treat them as octal numbers either by prefixing the digits with
a \f(CW0\fR or using \f(CW\*(C`oct\*(C'\fR:
.PP
.Vb 2
\&    chmod(     0644, $filename );  # right, has leading zero
\&    chmod( oct(644), $filename );  # also correct
.Ve
.PP
The problem comes in when you take your numbers from something that Perl
thinks is a string, such as a command line argument in \f(CW@ARGV\fR:
.PP
.Vb 1
\&    chmod( $ARGV[0],      $filename );  # wrong, even if "0644"
\&
\&    chmod( oct($ARGV[0]), $filename );  # correct, treat string as octal
.Ve
.PP
You can always check the value you're using by printing it in octal
notation to ensure it matches what you think it should be. Print it
in octal  and decimal format:
.PP
.Vb 1
\&    printf "0%o %d", $number, $number;
.Ve
.SS "Does Perl have a \fIround()\fP function? What about \fIceil()\fP and \fIfloor()\fP? Trig functions?"
.IX Subsection "Does Perl have a round() function? What about ceil() and floor()? Trig functions?"
Remember that \f(CW\*(C`int()\*(C'\fR merely truncates toward 0. For rounding to a
certain number of digits, \f(CW\*(C`sprintf()\*(C'\fR or \f(CW\*(C`printf()\*(C'\fR is usually the
easiest route.
.PP
.Vb 1
\&    printf("%.3f", 3.1415926535);   # prints 3.142
.Ve
.PP
The \s-1POSIX\s0 module (part of the standard Perl distribution)
implements \f(CW\*(C`ceil()\*(C'\fR, \f(CW\*(C`floor()\*(C'\fR, and a number of other mathematical
and trigonometric functions.
.PP
.Vb 3
\&    use POSIX;
\&    my $ceil   = ceil(3.5);   # 4
\&    my $floor  = floor(3.5);  # 3
.Ve
.PP
In 5.000 to 5.003 perls, trigonometry was done in the Math::Complex
module. With 5.004, the Math::Trig module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the Math::Complex module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.
.PP
Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely. In these
cases, it probably pays not to trust whichever system of rounding is
being used by Perl, but instead to implement the rounding function you
need yourself.
.PP
To see why, notice how you'll still have an issue on half-way-point
alternation:
.PP
.Vb 1
\&    for (my $i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}
\&
\&    0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
\&    0.8 0.8 0.9 0.9 1.0 1.0
.Ve
.PP
Don't blame Perl. It's the same as in C. \s-1IEEE\s0 says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32\-bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.
.SS "How do I convert between numeric representations/bases/radixes?"
.IX Subsection "How do I convert between numeric representations/bases/radixes?"
As always with Perl there is more than one way to do it. Below are a
few examples of approaches to making common conversions between number
representations. This is intended to be representational rather than
exhaustive.
.PP
Some of the examples later in perlfaq4 use the Bit::Vector
module from \s-1CPAN.\s0 The reason you might choose Bit::Vector over the
perl built-in functions is that it works with numbers of \s-1ANY\s0 size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.
.IP "How do I convert hexadecimal into decimal" 4
.IX Item "How do I convert hexadecimal into decimal"
Using perl's built in conversion of \f(CW\*(C`0x\*(C'\fR notation:
.Sp
.Vb 1
\&    my $dec = 0xDEADBEEF;
.Ve
.Sp
Using the \f(CW\*(C`hex\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = hex("DEADBEEF");
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR:
.Sp
.Vb 1
\&    my $dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", \-8)));
.Ve
.Sp
Using the \s-1CPAN\s0 module \f(CW\*(C`Bit::Vector\*(C'\fR:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Hex(32, "DEADBEEF");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to hexadecimal" 4
.IX Item "How do I convert from decimal to hexadecimal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 2
\&    my $hex = sprintf("%X", 3735928559); # upper case A\-F
\&    my $hex = sprintf("%x", 3735928559); # lower case a\-f
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $hex = unpack("H*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $hex = $vec\->to_Hex();
.Ve
.Sp
And Bit::Vector supports odd bit counts:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(33, 3735928559);
\&    $vec\->Resize(32); # suppress leading 0 if unwanted
\&    my $hex = $vec\->to_Hex();
.Ve
.IP "How do I convert from octal to decimal" 4
.IX Item "How do I convert from octal to decimal"
Using Perl's built in conversion of numbers with leading zeros:
.Sp
.Vb 1
\&    my $dec = 033653337357; # note the leading 0!
.Ve
.Sp
Using the \f(CW\*(C`oct\*(C'\fR function:
.Sp
.Vb 1
\&    my $dec = oct("33653337357");
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 4
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new(32);
\&    $vec\->Chunk_List_Store(3, split(//, reverse "33653337357"));
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to octal" 4
.IX Item "How do I convert from decimal to octal"
Using \f(CW\*(C`sprintf\*(C'\fR:
.Sp
.Vb 1
\&    my $oct = sprintf("%o", 3735928559);
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $oct = reverse join(\*(Aq\*(Aq, $vec\->Chunk_List_Read(3));
.Ve
.IP "How do I convert from binary to decimal" 4
.IX Item "How do I convert from binary to decimal"
Perl 5.6 lets you write binary numbers directly with
the \f(CW\*(C`0b\*(C'\fR notation:
.Sp
.Vb 1
\&    my $number = 0b10110110;
.Ve
.Sp
Using \f(CW\*(C`oct\*(C'\fR:
.Sp
.Vb 2
\&    my $input = "10110110";
\&    my $decimal = oct( "0b$input" );
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`ord\*(C'\fR:
.Sp
.Vb 1
\&    my $decimal = ord(pack(\*(AqB8\*(Aq, \*(Aq10110110\*(Aq));
.Ve
.Sp
Using \f(CW\*(C`pack\*(C'\fR and \f(CW\*(C`unpack\*(C'\fR for larger strings:
.Sp
.Vb 3
\&    my $int = unpack("N", pack("B32",
\&    substr("0" x 32 . "11110101011011011111011101111", \-32)));
\&    my $dec = sprintf("%d", $int);
\&
\&    # substr() is used to left\-pad a 32\-character string with zeros.
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 2
\&    my $vec = Bit::Vector\->new_Bin(32, "11011110101011011011111011101111");
\&    my $dec = $vec\->to_Dec();
.Ve
.IP "How do I convert from decimal to binary" 4
.IX Item "How do I convert from decimal to binary"
Using \f(CW\*(C`sprintf\*(C'\fR (perl 5.6+):
.Sp
.Vb 1
\&    my $bin = sprintf("%b", 3735928559);
.Ve
.Sp
Using \f(CW\*(C`unpack\*(C'\fR:
.Sp
.Vb 1
\&    my $bin = unpack("B*", pack("N", 3735928559));
.Ve
.Sp
Using Bit::Vector:
.Sp
.Vb 3
\&    use Bit::Vector;
\&    my $vec = Bit::Vector\->new_Dec(32, \-559038737);
\&    my $bin = $vec\->to_Bin();
.Ve
.Sp
The remaining transformations (e.g. hex \-> oct, bin \-> hex, etc.)
are left as an exercise to the inclined reader.
.SS "Why doesn't & work the way I want it to?"
.IX Subsection "Why doesn't & work the way I want it to?"
The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings. The operators treat a string as a series
of bits and work with that (the string \f(CW"3"\fR is the bit pattern
\&\f(CW00110011\fR). The operators work with the binary form of a number
(the number \f(CW3\fR is treated as the bit pattern \f(CW00000011\fR).
.PP
So, saying \f(CW\*(C`11 & 3\*(C'\fR performs the \*(L"and\*(R" operation on numbers (yielding
\&\f(CW3\fR). Saying \f(CW"11" & "3"\fR performs the \*(L"and\*(R" operation on strings
(yielding \f(CW"1"\fR).
.PP
Most problems with \f(CW\*(C`&\*(C'\fR and \f(CW\*(C`|\*(C'\fR arise because the programmer thinks
they have a number but really it's a string or vice versa. To avoid this,
stringify the arguments explicitly (using \f(CW""\fR or \f(CW\*(C`qq()\*(C'\fR) or convert them
to numbers explicitly (using \f(CW\*(C`0+$arg\*(C'\fR). The rest arise because
the programmer says:
.PP
.Vb 3
\&    if ("\e020\e020" & "\e101\e101") {
\&        # ...
\&    }
.Ve
.PP
but a string consisting of two null bytes (the result of \f(CW"\e0