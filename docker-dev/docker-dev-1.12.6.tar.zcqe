M\s0
across an \s-1INET\s0 socket.  \s-1UDP\s0 is an implementation of \s-1SOCK_DGRAM\s0 across
an \s-1INET\s0 socket.  \s-1UNIX\s0 uses a unix style socket file with the
\&\s-1SOCK_STREAM\s0 protocol.  \s-1UNIXGRAM\s0 uses a unix style socket file with the
\&\s-1SOCK_DGRAM\s0 protocol.  \s-1SSLEAY\s0 is actually just a layer on top of \s-1TCP\s0
but uses Net::SSLeay to read and write from the stream.
.PP
The protocol that is passed to Net::Server can be the name of another
module which contains the protocol bindings.  If a protocol of
MyServer::MyTCP was passed, the socket would be blessed into that
class.  If Net::Server::Proto::TCP was passed, it would get that
class.  If a bareword, such as tcp, udp, unix, unixdgram or ssleay, is
passed, the word is uppercased, and post pended to
\&\*(L"Net::Server::Proto::\*(R" (ie tcp = Net::Server::Proto::TCP).
.SH "METHODS"
.IX Header "METHODS"
Protocol names used by the Net::Server::Proto should be sub classes of
IO::Socket.  These classes should also contain, as a minimum, the
following methods should be provided:
.IP "object" 4
.IX Item "object"
Return an object which is a sub class of IO::Socket At this point the
object is not connected.  The method can gather any other information
that it needs from the server object.  Arguments are default_host,
port, and a Net::Server style server object.
.IP "log_connect" 4
.IX Item "log_connect"
Log that a connection is about to occur.  Use the facilities of the
passed Net::Server object.  This should be an informative string
explaining which properties are being used.
.IP "connect" 4
.IX Item "connect"
Actually bind to port or socket file.  This is typically done
internally by calling the configure method of the IO::Socket super
class.
.IP "reconnect" 4
.IX Item "reconnect"
Allow for rebinding to an already open fileno.  Typically will just do
an fdopen using the IO::Socket super class.
.IP "hup_string" 4
.IX Item "hup_string"
Return a unique identifying string for this sock that can be used when
reconnecting.  This is done to allow information including the file
descriptor of the open sockets to be passed via \f(CW%ENV\fR during an exec.
This string should always be the same based upon the configuration
parameters.
.IP "NS_port" 4
.IX Item "NS_port"
Net::Server protocol.  Return the port that is being used by this
module.  If the underlying type is \s-1UNIX\s0 then port will actually be
the path to the unix socket file.
.IP "NS_host" 4
.IX Item "NS_host"
Net::Server protocol.  Return the protocol that is being used by this
module.  This does not have to be a registered or known protocol.
.IP "NS_proto" 4
.IX Item "NS_proto"
Net::Server protocol.  Return the protocol that is being used by this
module.  This does not have to be a registered or known protocol.
.IP "show" 4
.IX Item "show"
Similar to log_connect, but simply shows a listing of which
properties were found.  Can be used at any time.
.SH "HOST"
.IX Header "HOST"
The hostname may be either blank, '*', be an IPv4 address, an IPv6 address,
a bare hostname, or a hostname with IPv* specifications.
.PP
.Vb 1
\&    host => "127.0.0.1",  # an IPv4 address
\&
\&    host => "::1",        # an IPv6 address
\&
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (default IPv* \- IPv4 and/or IPv6)
\&
\&    host => \*(Aqlocalhost/IPv*\*(Aq,  # same
\&
\&    ipv  => \*(Aq*\*(Aq,
\&    host => \*(Aqlocalhost\*(Aq,  # same
\&
\&    ipv  => 6,
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (IPv6)
\&
\&    ipv  => \*(AqIPv4 IPv6\*(Aq,
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (requires IPv6 and IPv4)
\&
\&
\&    host => \*(Aq*\*(Aq,          # any local interfaces (default IPv*)
\&
\&    ipv  => \*(Aq*\*(Aq,
\&    host => \*(Aq*\*(Aq,          # any local interfaces (any IPv6 or IPv4)
\&
\&    host => \*(Aq*/IPv*\*(Aq,     # same
.Ve
.SH "IPV"
.IX Header "IPV"
In addition to being able to specify \s-1IPV\s0 as a separate parameter, ipv may
also be passed as a part of the host, as part of the port, as part of the protocol
or may be specified via \f(CW$ENV\fR{'\s-1IPV\s0'}.  The order of precidence is as follows:
.PP
.Vb 7
\&     1) Explicit IPv4 or IPv6 address \- wins
\&     2) ipv specified in port
\&     3) ipv specified in host
\&     4) ipv specified in proto
\&     5) ipv specified in default settings
\&     6) ipv specified in $ENV{\*(AqIPV\*(Aq}
\&     7) default to IPv*
.Ve
.SH "PORT"
.IX Header "PORT"
The port is the most important argument passed to the sub
module classes and to Net::Server::Proto itself.  For tcp,
udp, and ssleay style ports, the form is generally host:port/protocol,
[host]:port/protocol, host|port|protocol, host/port, or port.
If \fIhost\fR is a numerical IPv6 address it should be enclosed in square
brackets to avoid ambiguity in parsing a port number, e.g.: \*(L"[::1]:80\*(R".
Separating with spaces, commas, or pipes is also allowed, e.g. \*(L"::1, 80\*(R".
For unix sockets the form is generally socket_file|unix or socket_file.
.PP
To help overcome parsing ambiguity, it is also possible to pass port as
a hashref (or as an array of hashrefs) of information such as:
.PP
.Vb 6
\&    port => {
\&        host  => "localhost",
\&        ipv   => 6, # could also pass IPv6 (* is default)
\&        port  => 20203,
\&        proto => \*(Aqtcp\*(Aq,
\&    }
.Ve
.PP
If a hashref does not include host, ipv, or proto \- it will use the default
value supplied by the general configuration.
.PP
A socket protocol family \s-1PF_INET\s0 or \s-1PF_INET6\s0 is derived from a specified
address family of the binding address. A \s-1PF_INET\s0 socket can only accept
IPv4 connections. A \s-1PF_INET6\s0 socket accepts IPv6 connections, but may also
accept IPv4 connections, depending on \s-1OS\s0 and its settings. For example,
on FreeBSD systems setting a sysctl net.inet6.ip6.v6only to 0 will allow
IPv4 connections to a \s-1PF_INET6\s0 socket.  By default on linux, binding to
host [::] will accept IPv4 or IPv6 connections.
.PP
The Net::Server::Proto::object method returns a list of objects corresponding
to created sockets. For Unix and \s-1INET\s0 sockets the list typically contains
just one element, but may return multiple objects when multiple protocol
families are allowed or when a host name resolves to multiple local
binding addresses.  This is particularly true when an ipv value of '*' is
passed in allowing hostname resolution.
.PP
You can see what Net::Server::Proto parsed out by looking at
the logs to see what log_connect said.  You could also include
a post_bind_hook similar to the following to debug what happened:
.PP
.Vb 6
\&    sub post_bind_hook {
\&        my $self = shift;
\&        foreach my $sock ( @{ $self\->{server}\->{sock} } ){
\&            $self\->log(2,$sock\->show);
\&        }
\&    }
.Ve
.PP
Rather than try to explain further, please look at the following
examples:
.PP
.Vb 1
\&    # example 1 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = undef;
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqdefault\-domain.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => *, # IPv*
\&    # };
\&
\&    # example 2 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => *,
\&    # };
\&
\&    # example 3 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/udp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqudp\*(Aq, # will use Net::Server::Proto::UDP
\&    #     ipv   => *,
\&    # };
\&
\&    # example 4 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/Net::Server::Proto::UDP";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "TCP";
\&    $def_ipv   = 4;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(AqNet::Server::Proto::UDP\*(Aq,
\&    #     ipv   => 4,
\&    # };
\&
\&    # example 5 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/MyObject::TCP";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(AqMyObject::TCP\*(Aq,
\&    # };
\&
\&    # example 6 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|unix";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIX
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 7 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|unixdgram";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunixdgram\*(Aq, # will use Net::Server::Proto::UNIXDGRAM
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 8 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|SOCK_STREAM|unix"; # legacy
\&    $def_host  = "";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIX
\&    #     unix_type => \*(AqSOCK_STREAM\*(Aq,
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 9 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|SOCK_DGRAM|unix"; # legacy
\&    $def_host  = "";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIXDGRAM
\&    #     unix_type => \*(AqSOCK_DGRAM\*(Aq,
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 10 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "someother.com:20203/ssleay";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqssleay\*(Aq, # will use Net::Server::Proto::SSLEAY
\&    #     ipv   => *,
\&    # };
\&
\&    # example 11 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[::1]:20203 ipv6 tcp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # };
\&
\&    # example 12 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[::1]:20203 tcp";
\&    $def_host  = "default\-domain.com/IPv6";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # };
\&
\&    # example 13 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[someother.com]:20203 ipv6 ipv4 tcp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4,
\&    # }, {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # });
\&
\&    # example 14 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # }, {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6, # IPv6
\&    # });
\&
\&    # example 15 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com IPv*";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # }, {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6, # IPv6
\&    # });
\&
\&    # example 16 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $ENV{\*(AqIPV\*(Aq} = \*(Aq4\*(Aq;
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # });
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto5.18.3pm                   0100644 0001750 0001750 00000056235 12566241464 025143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto 3"
.TH Net::Server::Proto 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto \- Net::Server Protocol compatibility layer
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 6
\&    NOTE: beginning in Net::Server 2.005, the default value for
\&          ipv is IPv* meaning that if no host is passed, or
\&          a hostname is past, all available socket types will be
\&          bound.  You can force IPv4 only by adding an ipv => 4
\&          configuration in any of the half dozen ways we let you
\&          specify it.
\&
\&    # Net::Server::Proto and its accompanying modules are not
\&    # intended to be used outside the scope of Net::Server.
\&
\&    # That being said, here is how you use them.  This is
\&    # only intended for anybody wishing to extend the
\&    # protocols to include some other set (ie maybe a
\&    # database connection protocol)
\&
\&    use Net::Server::Proto;
\&
\&    my @info = Net::Server::Proto\->parse_info(
\&        $port,            # port to connect to
\&        $default_host,    # host to use if none found in port
\&        $default_proto,   # proto to use if none found in port
\&        $default_ipv,     # default of IPv6 or IPv4 if none found in port
\&        $server_obj,      # Net::Server object
\&    );
\&
\&    my @raw_info = Net::Server::Proto\->get_addr_info($host, $port, $proto);
\&    # returns arrayref of resolved ips, ports, and ipv values
\&
\&    my $sock = Net::Server::Proto\->object({
\&        port  => $port,
\&        host  => $host,
\&        proto => $proto,
\&        ipv   => $ipv, # * (IPv*) if false (default false)
\&    }, $server);
\&
\&    # Net::Server::Proto will attempt to interface with
\&    # sub modules named similar to Net::Server::Proto::TCP
\&    # Individual sub modules will be loaded by
\&    # Net::Server::Proto as they are needed.
\&
\&    use Net::Server::Proto::TCP; # or UDP or UNIX etc
\&
\&    # Return an object which is a sub class of IO::Socket
\&    # At this point the object is not connected.
\&    # The method can gather any other information that it
\&    # needs from the server object.
\&    my $sock = Net::Server::Proto::TCP\->object({
\&        port  => $port,
\&        host  => $host,
\&        proto => $proto,
\&        ipv   => 6, # IPv6 \- default is * \- can also be \*(Aq4\*(Aq
\&    }, $server);
\&
\&
\&    # Log that a connection is about to occur.
\&    # Use the facilities of the passed Net::Server object.
\&    $sock\->log_connect( $server );
\&
\&    # Actually bind to port or socket file.  This
\&    # is typically done by calling the configure method.
\&    $sock\->connect();
\&
\&    # Allow for rebinding to an already open fileno.
\&    # Typically will just do an fdopen.
\&    $sock\->reconnect();
\&
\&    ### Return a unique identifying string for this sock that
\&    # can be used when reconnecting.
\&    my $str = $sock\->hup_string();
\&
\&    # Return the proto that is being used by this module.
\&    my $proto = $sock\->NS_proto();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Net::Server::Proto is an intermediate module which returns IO::Socket
style objects blessed into its own set of classes (ie
Net::Server::Proto::TCP, Net::Server::Proto::UNIX).
.PP
Only three or four protocols come bundled with Net::Server.  \s-1TCP, UDP,
UNIX, UNIXDGRAM,\s0 and \s-1SSLEAY.  TCP\s0 is an implementation of \s-1SOCK_STREAM\s0
across an \s-1INET\s0 socket.  \s-1UDP\s0 is an implementation of \s-1SOCK_DGRAM\s0 across
an \s-1INET\s0 socket.  \s-1UNIX\s0 uses a unix style socket file with the
\&\s-1SOCK_STREAM\s0 protocol.  \s-1UNIXGRAM\s0 uses a unix style socket file with the
\&\s-1SOCK_DGRAM\s0 protocol.  \s-1SSLEAY\s0 is actually just a layer on top of \s-1TCP\s0
but uses Net::SSLeay to read and write from the stream.
.PP
The protocol that is passed to Net::Server can be the name of another
module which contains the protocol bindings.  If a protocol of
MyServer::MyTCP was passed, the socket would be blessed into that
class.  If Net::Server::Proto::TCP was passed, it would get that
class.  If a bareword, such as tcp, udp, unix, unixdgram or ssleay, is
passed, the word is uppercased, and post pended to
\&\*(L"Net::Server::Proto::\*(R" (ie tcp = Net::Server::Proto::TCP).
.SH "METHODS"
.IX Header "METHODS"
Protocol names used by the Net::Server::Proto should be sub classes of
IO::Socket.  These classes should also contain, as a minimum, the
following methods should be provided:
.IP "object" 4
.IX Item "object"
Return an object which is a sub class of IO::Socket At this point the
object is not connected.  The method can gather any other information
that it needs from the server object.  Arguments are default_host,
port, and a Net::Server style server object.
.IP "log_connect" 4
.IX Item "log_connect"
Log that a connection is about to occur.  Use the facilities of the
passed Net::Server object.  This should be an informative string
explaining which properties are being used.
.IP "connect" 4
.IX Item "connect"
Actually bind to port or socket file.  This is typically done
internally by calling the configure method of the IO::Socket super
class.
.IP "reconnect" 4
.IX Item "reconnect"
Allow for rebinding to an already open fileno.  Typically will just do
an fdopen using the IO::Socket super class.
.IP "hup_string" 4
.IX Item "hup_string"
Return a unique identifying string for this sock that can be used when
reconnecting.  This is done to allow information including the file
descriptor of the open sockets to be passed via \f(CW%ENV\fR during an exec.
This string should always be the same based upon the configuration
parameters.
.IP "NS_port" 4
.IX Item "NS_port"
Net::Server protocol.  Return the port that is being used by this
module.  If the underlying type is \s-1UNIX\s0 then port will actually be
the path to the unix socket file.
.IP "NS_host" 4
.IX Item "NS_host"
Net::Server protocol.  Return the protocol that is being used by this
module.  This does not have to be a registered or known protocol.
.IP "NS_proto" 4
.IX Item "NS_proto"
Net::Server protocol.  Return the protocol that is being used by this
module.  This does not have to be a registered or known protocol.
.IP "show" 4
.IX Item "show"
Similar to log_connect, but simply shows a listing of which
properties were found.  Can be used at any time.
.SH "HOST"
.IX Header "HOST"
The hostname may be either blank, '*', be an IPv4 address, an IPv6 address,
a bare hostname, or a hostname with IPv* specifications.
.PP
.Vb 1
\&    host => "127.0.0.1",  # an IPv4 address
\&
\&    host => "::1",        # an IPv6 address
\&
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (default IPv* \- IPv4 and/or IPv6)
\&
\&    host => \*(Aqlocalhost/IPv*\*(Aq,  # same
\&
\&    ipv  => \*(Aq*\*(Aq,
\&    host => \*(Aqlocalhost\*(Aq,  # same
\&
\&    ipv  => 6,
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (IPv6)
\&
\&    ipv  => \*(AqIPv4 IPv6\*(Aq,
\&    host => \*(Aqlocalhost\*(Aq,  # addresses returned by localhost (requires IPv6 and IPv4)
\&
\&
\&    host => \*(Aq*\*(Aq,          # any local interfaces (default IPv*)
\&
\&    ipv  => \*(Aq*\*(Aq,
\&    host => \*(Aq*\*(Aq,          # any local interfaces (any IPv6 or IPv4)
\&
\&    host => \*(Aq*/IPv*\*(Aq,     # same
.Ve
.SH "IPV"
.IX Header "IPV"
In addition to being able to specify \s-1IPV\s0 as a separate parameter, ipv may
also be passed as a part of the host, as part of the port, as part of the protocol
or may be specified via \f(CW$ENV\fR{'\s-1IPV\s0'}.  The order of precidence is as follows:
.PP
.Vb 7
\&     1) Explicit IPv4 or IPv6 address \- wins
\&     2) ipv specified in port
\&     3) ipv specified in host
\&     4) ipv specified in proto
\&     5) ipv specified in default settings
\&     6) ipv specified in $ENV{\*(AqIPV\*(Aq}
\&     7) default to IPv*
.Ve
.SH "PORT"
.IX Header "PORT"
The port is the most important argument passed to the sub
module classes and to Net::Server::Proto itself.  For tcp,
udp, and ssleay style ports, the form is generally host:port/protocol,
[host]:port/protocol, host|port|protocol, host/port, or port.
If \fIhost\fR is a numerical IPv6 address it should be enclosed in square
brackets to avoid ambiguity in parsing a port number, e.g.: \*(L"[::1]:80\*(R".
Separating with spaces, commas, or pipes is also allowed, e.g. \*(L"::1, 80\*(R".
For unix sockets the form is generally socket_file|unix or socket_file.
.PP
To help overcome parsing ambiguity, it is also possible to pass port as
a hashref (or as an array of hashrefs) of information such as:
.PP
.Vb 6
\&    port => {
\&        host  => "localhost",
\&        ipv   => 6, # could also pass IPv6 (* is default)
\&        port  => 20203,
\&        proto => \*(Aqtcp\*(Aq,
\&    }
.Ve
.PP
If a hashref does not include host, ipv, or proto \- it will use the default
value supplied by the general configuration.
.PP
A socket protocol family \s-1PF_INET\s0 or \s-1PF_INET6\s0 is derived from a specified
address family of the binding address. A \s-1PF_INET\s0 socket can only accept
IPv4 connections. A \s-1PF_INET6\s0 socket accepts IPv6 connections, but may also
accept IPv4 connections, depending on \s-1OS\s0 and its settings. For example,
on FreeBSD systems setting a sysctl net.inet6.ip6.v6only to 0 will allow
IPv4 connections to a \s-1PF_INET6\s0 socket.  By default on linux, binding to
host [::] will accept IPv4 or IPv6 connections.
.PP
The Net::Server::Proto::object method returns a list of objects corresponding
to created sockets. For Unix and \s-1INET\s0 sockets the list typically contains
just one element, but may return multiple objects when multiple protocol
families are allowed or when a host name resolves to multiple local
binding addresses.  This is particularly true when an ipv value of '*' is
passed in allowing hostname resolution.
.PP
You can see what Net::Server::Proto parsed out by looking at
the logs to see what log_connect said.  You could also include
a post_bind_hook similar to the following to debug what happened:
.PP
.Vb 6
\&    sub post_bind_hook {
\&        my $self = shift;
\&        foreach my $sock ( @{ $self\->{server}\->{sock} } ){
\&            $self\->log(2,$sock\->show);
\&        }
\&    }
.Ve
.PP
Rather than try to explain further, please look at the following
examples:
.PP
.Vb 1
\&    # example 1 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = undef;
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqdefault\-domain.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => *, # IPv*
\&    # };
\&
\&    # example 2 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => *,
\&    # };
\&
\&    # example 3 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/udp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqudp\*(Aq, # will use Net::Server::Proto::UDP
\&    #     ipv   => *,
\&    # };
\&
\&    # example 4 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/Net::Server::Proto::UDP";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "TCP";
\&    $def_ipv   = 4;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(AqNet::Server::Proto::UDP\*(Aq,
\&    #     ipv   => 4,
\&    # };
\&
\&    # example 5 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "someother.com:20203/MyObject::TCP";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(AqMyObject::TCP\*(Aq,
\&    # };
\&
\&    # example 6 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|unix";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIX
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 7 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|unixdgram";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunixdgram\*(Aq, # will use Net::Server::Proto::UNIXDGRAM
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 8 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|SOCK_STREAM|unix"; # legacy
\&    $def_host  = "";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIX
\&    #     unix_type => \*(AqSOCK_STREAM\*(Aq,
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 9 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port      = "/tmp/mysock.file|SOCK_DGRAM|unix"; # legacy
\&    $def_host  = "";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    #     port  => \*(Aq/tmp/mysock.file\*(Aq, # not really a port
\&    #     proto => \*(Aqunix\*(Aq, # will use Net::Server::Proto::UNIXDGRAM
\&    #     unix_type => \*(AqSOCK_DGRAM\*(Aq,
\&    #     ipv   => \*(Aq*\*(Aq, # irrelevant for UNIX socket
\&    # };
\&
\&    # example 10 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "someother.com:20203/ssleay";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqssleay\*(Aq, # will use Net::Server::Proto::SSLEAY
\&    #     ipv   => *,
\&    # };
\&
\&    # example 11 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[::1]:20203 ipv6 tcp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # };
\&
\&    # example 12 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[::1]:20203 tcp";
\&    $def_host  = "default\-domain.com/IPv6";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # };
\&
\&    # example 13 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    $port = "[someother.com]:20203 ipv6 ipv4 tcp";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4,
\&    # }, {
\&    #     host  => \*(Aqsomeother.com\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6,
\&    # });
\&
\&    # example 14 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # }, {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6, # IPv6
\&    # });
\&
\&    # example 15 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com IPv*";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # }, {
\&    #     host  => \*(Aq::1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 6, # IPv6
\&    # });
\&
\&    # example 16 #\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&
\&    # depending upon your configuration
\&    $ENV{\*(AqIPV\*(Aq} = \*(Aq4\*(Aq;
\&    $port = "localhost:20203";
\&    $def_host  = "default\-domain.com";
\&    $def_proto = "tcp";
\&    $def_ipv   = undef;
\&    @info = Net::Server::Proto\->parse_info($port,$def_host,$def_proto,$def_ipv);
\&    # @info = ({
\&    #     host  => \*(Aq127.0.0.1\*(Aq,
\&    #     port  => 20203,
\&    #     proto => \*(Aqtcp\*(Aq, # will use Net::Server::Proto::TCP
\&    #     ipv   => 4, # IPv4
\&    # });
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSL.3pm                  0100644 0001750 0001750 00000016701 12566241464 025367  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSL 3"
.TH Net::Server::Proto::SSL 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSL \- Net::Server SSL protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Until this release, it was preferrable to use the Net::Server::Proto::SSLEAY
module.  Recent versions include code that overcomes original limitations.
.PP
See Net::Server::Proto.
See Net::Server::Proto::SSLEAY.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssl\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto = \*(Aqssl\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssl ports and one tcp
\&        proto => "ssl",       # use ssl as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssl",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssl",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&
\&        SSL_foo => 1, # Any key prefixed with SSL_ passed as a port hashref
\&                      # key/value will automatically be passed to IO::Socket::SSL
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server based on IO::Socket::SSL.  This module
implements a secure socket layer over tcp (also known as \s-1SSL\s0) via the
IO::Socket::SSL module.  If this module does not work in your
situation, please also consider using the \s-1SSLEAY\s0 protocol
(Net::Server::Proto::SSLEAY) which interfaces directly with
Net::SSLeay.  See Net::Server::Proto.
.PP
If you know that your server will only need IPv4 (which is the default
for Net::Server), you can load IO::Socket::SSL in inet4 mode which
will prevent it from using Socket6 and IO::Socket::INET6 since they
would represent additional and unsued overhead.
.PP
.Vb 2
\&    use IO::Socket::SSL qw(inet4);
\&    use base qw(Net::Server::Fork);
\&
\&    _\|_PACKAGE_\|_\->run(proto => "ssl");
.Ve
.SH "PARAMETERS"
.IX Header "PARAMETERS"
In addition to the normal Net::Server parameters, any of the \s-1SSL\s0
parameters from IO::Socket::SSL may also be specified.  See
IO::Socket::SSL for information on setting this up.  All arguments
prefixed with \s-1SSL_\s0 will be passed to the IO::Socket::SSL\->configure
method.
.SH "BUGS"
.IX Header "BUGS"
Until version Net::Server version 2, Net::Server::Proto::SSL used the
default IO::Socket::SSL::accept method.  This old approach introduces a
\&\s-1DDOS\s0 vulnerability into the server, where the socket is accepted, but
the parent server then has to block until the client negotiates the
\&\s-1SSL\s0 connection.  This has now been overcome by overriding the accept
method and accepting the \s-1SSL\s0 negotiation after the parent socket has
had the chance to go back to listening.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Vadim for pointing out the IO::Socket::SSL accept
was returning objects blessed into the wrong class.
                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSL5.16.3pm              0100644 0001750 0001750 00000016360 12566241464 025702  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSL 3"
.TH Net::Server::Proto::SSL 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSL \- Net::Server SSL protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Until this release, it was preferrable to use the Net::Server::Proto::SSLEAY
module.  Recent versions include code that overcomes original limitations.
.PP
See Net::Server::Proto.
See Net::Server::Proto::SSLEAY.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssl\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto = \*(Aqssl\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssl ports and one tcp
\&        proto => "ssl",       # use ssl as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssl",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssl",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&
\&        SSL_foo => 1, # Any key prefixed with SSL_ passed as a port hashref
\&                      # key/value will automatically be passed to IO::Socket::SSL
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server based on IO::Socket::SSL.  This module
implements a secure socket layer over tcp (also known as \s-1SSL\s0) via the
IO::Socket::SSL module.  If this module does not work in your
situation, please also consider using the \s-1SSLEAY\s0 protocol
(Net::Server::Proto::SSLEAY) which interfaces directly with
Net::SSLeay.  See Net::Server::Proto.
.PP
If you know that your server will only need IPv4 (which is the default
for Net::Server), you can load IO::Socket::SSL in inet4 mode which
will prevent it from using Socket6 and IO::Socket::INET6 since they
would represent additional and unsued overhead.
.PP
.Vb 2
\&    use IO::Socket::SSL qw(inet4);
\&    use base qw(Net::Server::Fork);
\&
\&    _\|_PACKAGE_\|_\->run(proto => "ssl");
.Ve
.SH "PARAMETERS"
.IX Header "PARAMETERS"
In addition to the normal Net::Server parameters, any of the \s-1SSL\s0
parameters from IO::Socket::SSL may also be specified.  See
IO::Socket::SSL for information on setting this up.  All arguments
prefixed with \s-1SSL_\s0 will be passed to the IO::Socket::SSL\->configure
method.
.SH "BUGS"
.IX Header "BUGS"
Until version Net::Server version 2, Net::Server::Proto::SSL used the
default IO::Socket::SSL::accept method.  This old approach introduces a
\&\s-1DDOS\s0 vulnerability into the server, where the socket is accepted, but
the parent server then has to block until the client negotiates the
\&\s-1SSL\s0 connection.  This has now been overcome by overriding the accept
method and accepting the \s-1SSL\s0 negotiation after the parent socket has
had the chance to go back to listening.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Vadim for pointing out the IO::Socket::SSL accept
was returning objects blessed into the wrong class.
                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSL5.18.3pm              0100644 0001750 0001750 00000016701 12566241464 025703  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSL 3"
.TH Net::Server::Proto::SSL 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSL \- Net::Server SSL protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
Until this release, it was preferrable to use the Net::Server::Proto::SSLEAY
module.  Recent versions include code that overcomes original limitations.
.PP
See Net::Server::Proto.
See Net::Server::Proto::SSLEAY.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssl\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto = \*(Aqssl\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssl ports and one tcp
\&        proto => "ssl",       # use ssl as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssl",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssl",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&
\&        SSL_foo => 1, # Any key prefixed with SSL_ passed as a port hashref
\&                      # key/value will automatically be passed to IO::Socket::SSL
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server based on IO::Socket::SSL.  This module
implements a secure socket layer over tcp (also known as \s-1SSL\s0) via the
IO::Socket::SSL module.  If this module does not work in your
situation, please also consider using the \s-1SSLEAY\s0 protocol
(Net::Server::Proto::SSLEAY) which interfaces directly with
Net::SSLeay.  See Net::Server::Proto.
.PP
If you know that your server will only need IPv4 (which is the default
for Net::Server), you can load IO::Socket::SSL in inet4 mode which
will prevent it from using Socket6 and IO::Socket::INET6 since they
would represent additional and unsued overhead.
.PP
.Vb 2
\&    use IO::Socket::SSL qw(inet4);
\&    use base qw(Net::Server::Fork);
\&
\&    _\|_PACKAGE_\|_\->run(proto => "ssl");
.Ve
.SH "PARAMETERS"
.IX Header "PARAMETERS"
In addition to the normal Net::Server parameters, any of the \s-1SSL\s0
parameters from IO::Socket::SSL may also be specified.  See
IO::Socket::SSL for information on setting this up.  All arguments
prefixed with \s-1SSL_\s0 will be passed to the IO::Socket::SSL\->configure
method.
.SH "BUGS"
.IX Header "BUGS"
Until version Net::Server version 2, Net::Server::Proto::SSL used the
default IO::Socket::SSL::accept method.  This old approach introduces a
\&\s-1DDOS\s0 vulnerability into the server, where the socket is accepted, but
the parent server then has to block until the client negotiates the
\&\s-1SSL\s0 connection.  This has now been overcome by overriding the accept
method and accepting the \s-1SSL\s0 negotiation after the parent socket has
had the chance to go back to listening.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Vadim for pointing out the IO::Socket::SSL accept
was returning objects blessed into the wrong class.
                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSLEAY.3pm               0100644 0001750 0001750 00000017324 12566241464 025730  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSLEAY 3"
.TH Net::Server::Proto::SSLEAY 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSLEAY \- Custom Net::Server SSL protocol handler based on Net::SSLeay.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssleay\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto => \*(Aqssleay\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssleay ports and one tcp
\&        proto => "ssleay",    # use ssleay as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssleay",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssleay",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has reliably been used in situations receiving millions of
hits on a single box per day.  If anybody has any successes or ideas
for improvment under \s-1SSLEAY,\s0 please email <paul@seamons.com>.
.PP
Protocol module for Net::Server.  This module implements a secure
socket layer over tcp (also known as \s-1SSL\s0).  See Net::Server::Proto.
.PP
If you need more customization of the \s-1SSL\s0 layer, you may want to
investigate using \s-1SSL\s0 rather than \s-1SSLEAY\s0 as it uses the venerable(ish)
IO::Socket::SSL.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
Currently there is support for the following:
.ie n .IP """SSL_cert_file""" 4
.el .IP "\f(CWSSL_cert_file\fR" 4
.IX Item "SSL_cert_file"
Full path to the certificate file to be used for this server.  Should
be in \s-1PEM\s0 format.
.ie n .IP """SSL_key_file""" 4
.el .IP "\f(CWSSL_key_file\fR" 4
.IX Item "SSL_key_file"
Full path to the key file to be used for this server.  Should be in
\&\s-1PEM\s0 format.
.ie n .IP """SSL_max_getline_length""" 4
.el .IP "\f(CWSSL_max_getline_length\fR" 4
.IX Item "SSL_max_getline_length"
Used during getline to only read until this many bytes are found.
Default is undef which means unlimited.
.ie n .IP """SSL_error_callback""" 4
.el .IP "\f(CWSSL_error_callback\fR" 4
.IX Item "SSL_error_callback"
Should be a code ref that will be called whenever error conditions are
encountered.  It passes a source message and an arrayref of the
errors.
.SH "METHODS"
.IX Header "METHODS"
This module implements most of the common file handle operations.
There are some additions though:
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes bytes and match qr.  If bytes is defined \- it will read until
that many bytes are found.  If match qr is defined, it will read until
the buffer matches that qr.  If both are undefined, it will read until
there is nothing left to read.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
If an error occurred while writing, this method will return that error.
.SH "BUGS"
.IX Header "BUGS"
There are probably many.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Bilbo at
http://devpit.org/wiki/OpenSSL_with_nonblocking_sockets_%28in_Perl%29
for documenting a more reliable way of accepting and reading \s-1SSL\s0
connections.
                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSLEAY5.16.3pm           0100644 0001750 0001750 00000017003 12566241464 026234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSLEAY 3"
.TH Net::Server::Proto::SSLEAY 3 "2012-05-30" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSLEAY \- Custom Net::Server SSL protocol handler based on Net::SSLeay.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssleay\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto => \*(Aqssleay\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssleay ports and one tcp
\&        proto => "ssleay",    # use ssleay as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssleay",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssleay",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has reliably been used in situations receiving millions of
hits on a single box per day.  If anybody has any successes or ideas
for improvment under \s-1SSLEAY\s0, please email <paul@seamons.com>.
.PP
Protocol module for Net::Server.  This module implements a secure
socket layer over tcp (also known as \s-1SSL\s0).  See Net::Server::Proto.
.PP
If you need more customization of the \s-1SSL\s0 layer, you may want to
investigate using \s-1SSL\s0 rather than \s-1SSLEAY\s0 as it uses the venerable(ish)
IO::Socket::SSL.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
Currently there is support for the following:
.ie n .IP """SSL_cert_file""" 4
.el .IP "\f(CWSSL_cert_file\fR" 4
.IX Item "SSL_cert_file"
Full path to the certificate file to be used for this server.  Should
be in \s-1PEM\s0 format.
.ie n .IP """SSL_key_file""" 4
.el .IP "\f(CWSSL_key_file\fR" 4
.IX Item "SSL_key_file"
Full path to the key file to be used for this server.  Should be in
\&\s-1PEM\s0 format.
.ie n .IP """SSL_max_getline_length""" 4
.el .IP "\f(CWSSL_max_getline_length\fR" 4
.IX Item "SSL_max_getline_length"
Used during getline to only read until this many bytes are found.
Default is undef which means unlimited.
.ie n .IP """SSL_error_callback""" 4
.el .IP "\f(CWSSL_error_callback\fR" 4
.IX Item "SSL_error_callback"
Should be a code ref that will be called whenever error conditions are
encountered.  It passes a source message and an arrayref of the
errors.
.SH "METHODS"
.IX Header "METHODS"
This module implements most of the common file handle operations.
There are some additions though:
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes bytes and match qr.  If bytes is defined \- it will read until
that many bytes are found.  If match qr is defined, it will read until
the buffer matches that qr.  If both are undefined, it will read until
there is nothing left to read.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
If an error occurred while writing, this method will return that error.
.SH "BUGS"
.IX Header "BUGS"
There are probably many.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Bilbo at
http://devpit.org/wiki/OpenSSL_with_nonblocking_sockets_%28in_Perl%29
for documenting a more reliable way of accepting and reading \s-1SSL\s0
connections.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::SSLEAY5.18.3pm           0100644 0001750 0001750 00000017324 12566241464 026244  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::SSLEAY 3"
.TH Net::Server::Proto::SSLEAY 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::SSLEAY \- Custom Net::Server SSL protocol handler based on Net::SSLeay.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.PP
.Vb 6
\&    use base qw(Net::Server::HTTP);
\&    main\->run(
\&        proto => \*(Aqssleay\*(Aq,
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    sub SSL_key_file  { "/path/to/my/file.key" }
\&    sub SSL_cert_file { "/path/to/my/file.crt" }
\&    main\->run(proto => \*(Aqssleay\*(Aq);
\&
\&
\&    # OR
\&
\&    main\->run(
\&        port => [443, 8443, "80/tcp"],  # bind to two ssleay ports and one tcp
\&        proto => "ssleay",    # use ssleay as the default
\&        ipv  => "*",          # bind both IPv4 and IPv6 interfaces
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    );
\&
\&
\&    # OR
\&
\&    main\->run(port => [{
\&        port  => "443",
\&        proto => "ssleay",
\&        # ipv => 4, # default \- only do IPv4
\&        SSL_key_file  => "/path/to/my/file.key",
\&        SSL_cert_file => "/path/to/my/file.crt",
\&    }, {
\&        port  => "8443",
\&        proto => "ssleay",
\&        ipv   => "*", # IPv4 and IPv6
\&        SSL_key_file  => "/path/to/my/file2.key", # separate key
\&        SSL_cert_file => "/path/to/my/file2.crt", # separate cert
\&    }]);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module has reliably been used in situations receiving millions of
hits on a single box per day.  If anybody has any successes or ideas
for improvment under \s-1SSLEAY,\s0 please email <paul@seamons.com>.
.PP
Protocol module for Net::Server.  This module implements a secure
socket layer over tcp (also known as \s-1SSL\s0).  See Net::Server::Proto.
.PP
If you need more customization of the \s-1SSL\s0 layer, you may want to
investigate using \s-1SSL\s0 rather than \s-1SSLEAY\s0 as it uses the venerable(ish)
IO::Socket::SSL.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
Currently there is support for the following:
.ie n .IP """SSL_cert_file""" 4
.el .IP "\f(CWSSL_cert_file\fR" 4
.IX Item "SSL_cert_file"
Full path to the certificate file to be used for this server.  Should
be in \s-1PEM\s0 format.
.ie n .IP """SSL_key_file""" 4
.el .IP "\f(CWSSL_key_file\fR" 4
.IX Item "SSL_key_file"
Full path to the key file to be used for this server.  Should be in
\&\s-1PEM\s0 format.
.ie n .IP """SSL_max_getline_length""" 4
.el .IP "\f(CWSSL_max_getline_length\fR" 4
.IX Item "SSL_max_getline_length"
Used during getline to only read until this many bytes are found.
Default is undef which means unlimited.
.ie n .IP """SSL_error_callback""" 4
.el .IP "\f(CWSSL_error_callback\fR" 4
.IX Item "SSL_error_callback"
Should be a code ref that will be called whenever error conditions are
encountered.  It passes a source message and an arrayref of the
errors.
.SH "METHODS"
.IX Header "METHODS"
This module implements most of the common file handle operations.
There are some additions though:
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes bytes and match qr.  If bytes is defined \- it will read until
that many bytes are found.  If match qr is defined, it will read until
the buffer matches that qr.  If both are undefined, it will read until
there is nothing left to read.
.ie n .IP """error""" 4
.el .IP "\f(CWerror\fR" 4
.IX Item "error"
If an error occurred while writing, this method will return that error.
.SH "BUGS"
.IX Header "BUGS"
There are probably many.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "THANKS"
.IX Header "THANKS"
Thanks to Bilbo at
http://devpit.org/wiki/OpenSSL_with_nonblocking_sockets_%28in_Perl%29
for documenting a more reliable way of accepting and reading \s-1SSL\s0
connections.
                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::TCP.3pm                  0100644 0001750 0001750 00000014055 12566241464 025354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::TCP 3"
.TH Net::Server::Proto::TCP 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Net::Server::Proto::TCP \- Net::Server TCP protocol.
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_STREAM\s0 socket type under \s-1INET \s0(also known as \s-1TCP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
There are no additional parameters that can be specified.
See Net::Server for more information on reading arguments.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP.\s0
.ie n .IP """log_connect""" 4
.el .IP "\f(CWlog_connect\fR" 4
.IX Item "log_connect"
Called before binding the socket to provide useful information to the logs.
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.ie n .IP """reconnect""" 4
.el .IP "\f(CWreconnect\fR" 4
.IX Item "reconnect"
Called instead of connect method during a server hup.
.ie n .IP """accept""" 4
.el .IP "\f(CWaccept\fR" 4
.IX Item "accept"
Override of the parent class to make sure necessary parameters are passed down to client sockets.
.ie n .IP """poll_cb""" 4
.el .IP "\f(CWpoll_cb\fR" 4
.IX Item "poll_cb"
Allow for psgi compatible interface during \s-1HTTP\s0 server.
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes a regular expression, reads from the socket until the regular expression is matched.
.ie n .IP """hup_string""" 4
.el .IP "\f(CWhup_string\fR" 4
.IX Item "hup_string"
Returns a unique identifier that can be passed to the re-exec'ed process during \s-1HUP.\s0
.ie n .IP """show""" 4
.el .IP "\f(CWshow\fR" 4
.IX Item "show"
Basic dumper of properties stored in the glob.
.ie n .IP """AUTOLOAD""" 4
.el .IP "\f(CWAUTOLOAD\fR" 4
.IX Item "AUTOLOAD"
Handle accessor methods.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::TCP5.16.3pm              0100644 0001750 0001750 00000014060 12566241464 025662  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::TCP 3"
.TH Net::Server::Proto::TCP 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Net::Server::Proto::TCP \- Net::Server TCP protocol.
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_STREAM\s0 socket type under \s-1INET\s0 (also known as \s-1TCP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
There are no additional parameters that can be specified.
See Net::Server for more information on reading arguments.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP\s0.
.ie n .IP """log_connect""" 4
.el .IP "\f(CWlog_connect\fR" 4
.IX Item "log_connect"
Called before binding the socket to provide useful information to the logs.
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.ie n .IP """reconnect""" 4
.el .IP "\f(CWreconnect\fR" 4
.IX Item "reconnect"
Called instead of connect method during a server hup.
.ie n .IP """accept""" 4
.el .IP "\f(CWaccept\fR" 4
.IX Item "accept"
Override of the parent class to make sure necessary parameters are passed down to client sockets.
.ie n .IP """poll_cb""" 4
.el .IP "\f(CWpoll_cb\fR" 4
.IX Item "poll_cb"
Allow for psgi compatible interface during \s-1HTTP\s0 server.
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes a regular expression, reads from the socket until the regular expression is matched.
.ie n .IP """hup_string""" 4
.el .IP "\f(CWhup_string\fR" 4
.IX Item "hup_string"
Returns a unique identifier that can be passed to the re-exec'ed process during \s-1HUP\s0.
.ie n .IP """show""" 4
.el .IP "\f(CWshow\fR" 4
.IX Item "show"
Basic dumper of properties stored in the glob.
.ie n .IP """AUTOLOAD""" 4
.el .IP "\f(CWAUTOLOAD\fR" 4
.IX Item "AUTOLOAD"
Handle accessor methods.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 229:" 4
.IX Item "Around line 229:"
You forgot a '=back' before '=head1'
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::TCP5.18.3pm              0100644 0001750 0001750 00000014055 12566241464 025670  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::TCP 3"
.TH Net::Server::Proto::TCP 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
.Vb 1
\&  Net::Server::Proto::TCP \- Net::Server TCP protocol.
.Ve
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_STREAM\s0 socket type under \s-1INET \s0(also known as \s-1TCP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
There are no additional parameters that can be specified.
See Net::Server for more information on reading arguments.
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP.\s0
.ie n .IP """log_connect""" 4
.el .IP "\f(CWlog_connect\fR" 4
.IX Item "log_connect"
Called before binding the socket to provide useful information to the logs.
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.ie n .IP """reconnect""" 4
.el .IP "\f(CWreconnect\fR" 4
.IX Item "reconnect"
Called instead of connect method during a server hup.
.ie n .IP """accept""" 4
.el .IP "\f(CWaccept\fR" 4
.IX Item "accept"
Override of the parent class to make sure necessary parameters are passed down to client sockets.
.ie n .IP """poll_cb""" 4
.el .IP "\f(CWpoll_cb\fR" 4
.IX Item "poll_cb"
Allow for psgi compatible interface during \s-1HTTP\s0 server.
.ie n .IP """read_until""" 4
.el .IP "\f(CWread_until\fR" 4
.IX Item "read_until"
Takes a regular expression, reads from the socket until the regular expression is matched.
.ie n .IP """hup_string""" 4
.el .IP "\f(CWhup_string\fR" 4
.IX Item "hup_string"
Returns a unique identifier that can be passed to the re-exec'ed process during \s-1HUP.\s0
.ie n .IP """show""" 4
.el .IP "\f(CWshow\fR" 4
.IX Item "show"
Basic dumper of properties stored in the glob.
.ie n .IP """AUTOLOAD""" 4
.el .IP "\f(CWAUTOLOAD\fR" 4
.IX Item "AUTOLOAD"
Handle accessor methods.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UDP.3pm                  0100644 0001750 0001750 00000013200 12566241464 025345  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UDP 3"
.TH Net::Server::Proto::UDP 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UDP \- Net::Server UDP protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_DGRAM\s0 socket type under \s-1INET \s0(also known as \s-1UDP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to
normal command line parameters for a Net::Server.  See
Net::Server for more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1UDP\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.IP "udp_broadcast" 4
.IX Item "udp_broadcast"
Default is undef.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UDP protocol parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
\&  udp_broadcast     bool                     undef
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP.\s0
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UDP5.16.3pm              0100644 0001750 0001750 00000012657 12566241464 025676  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UDP 3"
.TH Net::Server::Proto::UDP 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UDP \- Net::Server UDP protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_DGRAM\s0 socket type under \s-1INET\s0 (also known as \s-1UDP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to
normal command line parameters for a Net::Server.  See
Net::Server for more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1UDP\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.IP "udp_broadcast" 4
.IX Item "udp_broadcast"
Default is undef.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UDP protocol parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
\&  udp_broadcast     bool                     undef
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP\s0.
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UDP5.18.3pm              0100644 0001750 0001750 00000013200 12566241464 025661  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UDP 3"
.TH Net::Server::Proto::UDP 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UDP \- Net::Server UDP protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the
\&\s-1SOCK_DGRAM\s0 socket type under \s-1INET \s0(also known as \s-1UDP\s0).
See Net::Server::Proto.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to
normal command line parameters for a Net::Server.  See
Net::Server for more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1UDP\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.IP "udp_broadcast" 4
.IX Item "udp_broadcast"
Default is undef.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UDP protocol parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
\&  udp_broadcast     bool                     undef
.Ve
.SH "INTERNAL METHODS"
.IX Header "INTERNAL METHODS"
.ie n .IP """object""" 4
.el .IP "\f(CWobject\fR" 4
.IX Item "object"
Returns an object with parameters suitable for eventual creation of
a IO::Socket::INET object listining on \s-1UDP.\s0
.ie n .IP """connect""" 4
.el .IP "\f(CWconnect\fR" 4
.IX Item "connect"
Called when actually binding the port.  Handles default parameters
before calling parent method.
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIX.3pm                 0100644 0001750 0001750 00000013561 12566241464 025512  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIX 3"
.TH Net::Server::Proto::UNIX 3 "2012-06-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIX \- Net::Server UNIX protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX
SOCK_STREAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "unix_type" 4
.IX Item "unix_type"
Can be either \s-1SOCK_STREAM\s0 or \s-1SOCK_DGRAM \s0(default is \s-1SOCK_STREAM\s0).
This can also be passed on the port line (see Net::Server::Proto).
.Sp
However, this method is deprecated.  If you want \s-1SOCK_STREAM \-\s0 just
use proto \s-1UNIX\s0 without any other arguments.  If you'd like \s-1SOCK_DGRAM,\s0
use the new proto \s-1UNIXDGRAM.\s0
.SH "METHODS"
.IX Header "METHODS"
.IP "NS_unix_path/NS_unix_type" 4
.IX Item "NS_unix_path/NS_unix_type"
In addition to the standard \s-1NS_\s0 methods of Net::Server::Proto classes,
the \s-1UNIX\s0 types also have legacy calls to NS_unix_path and
NS_unix_type.
.Sp
Since version 2.000, NS_unix_path is simply an alias to NS_port.
NS_unix_type is now redundant with NS_proto.
.Sp
These methods were missing between version 2.000 and 2.003 but have
been returned as legacy bridges.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  # deprecated UNIX socket parameters
\&  unix_type         (SOCK_STREAM|SOCK_DGRAM) SOCK_STREAM
\&  port              "filename"               undef
\&
\&  # more recent usage
\&  port              "filename / UNIX"
\&  port              "filename / UNIXDGRAM"
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIX5.16.3pm             0100644 0001750 0001750 00000013251 12566241464 026020  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIX 3"
.TH Net::Server::Proto::UNIX 3 "2012-06-06" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIX \- Net::Server UNIX protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX\s0
\&\s-1SOCK_STREAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "unix_type" 4
.IX Item "unix_type"
Can be either \s-1SOCK_STREAM\s0 or \s-1SOCK_DGRAM\s0 (default is \s-1SOCK_STREAM\s0).
This can also be passed on the port line (see Net::Server::Proto).
.Sp
However, this method is deprecated.  If you want \s-1SOCK_STREAM\s0 \- just
use proto \s-1UNIX\s0 without any other arguments.  If you'd like \s-1SOCK_DGRAM\s0,
use the new proto \s-1UNIXDGRAM\s0.
.SH "METHODS"
.IX Header "METHODS"
.IP "NS_unix_path/NS_unix_type" 4
.IX Item "NS_unix_path/NS_unix_type"
In addition to the standard \s-1NS_\s0 methods of Net::Server::Proto classes,
the \s-1UNIX\s0 types also have legacy calls to NS_unix_path and
NS_unix_type.
.Sp
Since version 2.000, NS_unix_path is simply an alias to NS_port.
NS_unix_type is now redundant with NS_proto.
.Sp
These methods were missing between version 2.000 and 2.003 but have
been returned as legacy bridges.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  # deprecated UNIX socket parameters
\&  unix_type         (SOCK_STREAM|SOCK_DGRAM) SOCK_STREAM
\&  port              "filename"               undef
\&
\&  # more recent usage
\&  port              "filename / UNIX"
\&  port              "filename / UNIXDGRAM"
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIX5.18.3pm             0100644 0001750 0001750 00000013561 12566241464 026026  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIX 3"
.TH Net::Server::Proto::UNIX 3 "2012-06-06" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIX \- Net::Server UNIX protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX
SOCK_STREAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "unix_type" 4
.IX Item "unix_type"
Can be either \s-1SOCK_STREAM\s0 or \s-1SOCK_DGRAM \s0(default is \s-1SOCK_STREAM\s0).
This can also be passed on the port line (see Net::Server::Proto).
.Sp
However, this method is deprecated.  If you want \s-1SOCK_STREAM \-\s0 just
use proto \s-1UNIX\s0 without any other arguments.  If you'd like \s-1SOCK_DGRAM,\s0
use the new proto \s-1UNIXDGRAM.\s0
.SH "METHODS"
.IX Header "METHODS"
.IP "NS_unix_path/NS_unix_type" 4
.IX Item "NS_unix_path/NS_unix_type"
In addition to the standard \s-1NS_\s0 methods of Net::Server::Proto classes,
the \s-1UNIX\s0 types also have legacy calls to NS_unix_path and
NS_unix_type.
.Sp
Since version 2.000, NS_unix_path is simply an alias to NS_port.
NS_unix_type is now redundant with NS_proto.
.Sp
These methods were missing between version 2.000 and 2.003 but have
been returned as legacy bridges.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  # deprecated UNIX socket parameters
\&  unix_type         (SOCK_STREAM|SOCK_DGRAM) SOCK_STREAM
\&  port              "filename"               undef
\&
\&  # more recent usage
\&  port              "filename / UNIX"
\&  port              "filename / UNIXDGRAM"
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIXDGRAM.3pm            0100644 0001750 0001750 00000012331 12566241464 026257  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIXDGRAM 3"
.TH Net::Server::Proto::UNIXDGRAM 3 "2012-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIXDGRAM \- Net::Server UNIXDGRAM protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX
SOCK_DGRAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1SOCK_DGRAM\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UNIXDGRAM socket parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIXDGRAM5.16.3pm        0100644 0001750 0001750 00000012021 12566241464 026565  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIXDGRAM 3"
.TH Net::Server::Proto::UNIXDGRAM 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIXDGRAM \- Net::Server UNIXDGRAM protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX\s0
\&\s-1SOCK_DGRAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1SOCK_DGRAM\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UNIXDGRAM socket parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Proto::UNIXDGRAM5.18.3pm        0100644 0001750 0001750 00000012331 12566241464 026573  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Proto::UNIXDGRAM 3"
.TH Net::Server::Proto::UNIXDGRAM 3 "2012-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Proto::UNIXDGRAM \- Net::Server UNIXDGRAM protocol.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
See Net::Server::Proto.
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Protocol module for Net::Server.  This module implements the \s-1UNIX
SOCK_DGRAM\s0 socket type.  See Net::Server::Proto.
.PP
Any sockets created during startup will be chown'ed to the user and
group specified in the starup arguments.
.SH "PARAMETERS"
.IX Header "PARAMETERS"
The following paramaters may be specified in addition to normal
command line parameters for a Net::Server.  See Net::Server for
more information on reading arguments.
.IP "udp_recv_len" 4
.IX Item "udp_recv_len"
Specifies the number of bytes to read from the \s-1SOCK_DGRAM\s0 connection
handle.  Data will be read into \f(CW$self\fR\->{'server'}\->{'udp_data'}.
Default is 4096.  See IO::Socket::INET and recv.
.IP "udp_recv_flags" 4
.IX Item "udp_recv_flags"
See recv.  Default is 0.
.SH "QUICK PARAMETER LIST"
.IX Header "QUICK PARAMETER LIST"
.Vb 1
\&  Key               Value                    Default
\&
\&  ## UNIXDGRAM socket parameters
\&  udp_recv_len      \ed+                      4096
\&  udp_recv_flags    \ed+                      0
.Ve
.SH "LICENCE"
.IX Header "LICENCE"
Distributed under the same terms as Net::Server
                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::SIG.3pm                         0100644 0001750 0001750 00000017035 12566241464 024141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::SIG 3"
.TH Net::Server::SIG 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::SIG \- adpf \- Safer signal handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Net::Server::SIG qw(register_sig check_sigs);
\&    use IO::Select ();
\&    use POSIX qw(WNOHANG);
\&
\&    my $select = IO::Select\->new();
\&
\&    register_sig(PIPE => \*(AqIGNORE\*(Aq,
\&                 HUP  => \*(AqDEFAULT\*(Aq,
\&                 USR1 => sub { print "I got a SIG $_[0]\en"; },
\&                 USR2 => sub { print "I got a SIG $_[0]\en"; },
\&                 CHLD => sub { 1 while waitpid(\-1, WNOHANG) > 0; },
\&                 );
\&
\&    # add some handles to the select
\&    $select\->add(\e*STDIN);
\&
\&    # loop forever trying to stay alive
\&    while (1) {
\&
\&        # do a timeout to see if any signals got passed us
\&        # while we were processing another signal
\&        my @fh = $select\->can_read(10);
\&
\&        my $key;
\&        my $val;
\&
\&        # this is the handler for safe (fine under unsafe also)
\&        if (check_sigs()) {
\&          # or my @sigs = check_sigs();
\&          next unless @fh;
\&        }
\&
\&        my $handle = $fh[@fh];
\&
\&        # do something with the handle
\&
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Signals prior in Perl prior to 5.7 were unsafe.  Since then signals
have been implemented in a more safe algorithm.  Net::Server::SIG
provides backwards compatibility, while still working reliably with
newer releases.
.PP
Using a property of the \fIselect()\fR function, Net::Server::SIG attempts
to fix the unsafe problem.  If a process is blocking on \fIselect()\fR any
signal will short circuit the select.  Using this concept,
Net::Server::SIG does the least work possible (changing one bit from 0
to 1).  And depends upon the actual processing of the signals to take
place immediately after the the select call via the \*(L"check_sigs\*(R"
function.  See the example shown above and also see the sigtest.pl
script located in the examples directory of this distribution.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """register_sig($SIG => \e&code_ref)""" 4
.el .IP "\f(CWregister_sig($SIG => \e&code_ref)\fR" 4
.IX Item "register_sig($SIG => &code_ref)"
Takes key/value pairs where the key is the signal name, and the
argument is either a code ref, or the words '\s-1DEFAULT\s0' or '\s-1IGNORE\s0'.
The function register_sig must be used in conjunction with check_sigs,
and with a blocking \fIselect()\fR function call \*(-- otherwise, you will
observe the registered signal mysteriously vanish.
.ie n .IP """unregister_sig($SIG)""" 4
.el .IP "\f(CWunregister_sig($SIG)\fR" 4
.IX Item "unregister_sig($SIG)"
Takes the name of a signal as an argument.  Calls register_sig with a
this signal name and '\s-1DEFAULT\s0' as arguments (same as
register_sig(\s-1SIG,\s0'\s-1DEFAULT\s0')
.ie n .IP """check_sigs()""" 4
.el .IP "\f(CWcheck_sigs()\fR" 4
.IX Item "check_sigs()"
Checks to see if any registered signals have occured.  If so, it will
play the registered code ref for that signal.  Return value is array
containing any \s-1SIGNAL\s0 names that had occured.
.ie n .IP """sig_is_registered($SIG)""" 4
.el .IP "\f(CWsig_is_registered($SIG)\fR" 4
.IX Item "sig_is_registered($SIG)"
Takes a signal name and returns any registered code_ref for that signal.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Seamons (paul@seamons.com)
.PP
Rob B Brown (rob@roobik.com) \- Provided a sounding board and feedback
in creating Net::Server::SIG and sigtest.pl.
.SH "LICENSE"
.IX Header "LICENSE"
.Vb 4
\&  This package may be distributed under the terms of either the
\&  GNU General Public License
\&    or the
\&  Perl Artistic License
\&
\&  All rights reserved.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::SIG5.16.3pm                     0100644 0001750 0001750 00000016513 12566241464 024453  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::SIG 3"
.TH Net::Server::SIG 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::SIG \- adpf \- Safer signal handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Net::Server::SIG qw(register_sig check_sigs);
\&    use IO::Select ();
\&    use POSIX qw(WNOHANG);
\&
\&    my $select = IO::Select\->new();
\&
\&    register_sig(PIPE => \*(AqIGNORE\*(Aq,
\&                 HUP  => \*(AqDEFAULT\*(Aq,
\&                 USR1 => sub { print "I got a SIG $_[0]\en"; },
\&                 USR2 => sub { print "I got a SIG $_[0]\en"; },
\&                 CHLD => sub { 1 while waitpid(\-1, WNOHANG) > 0; },
\&                 );
\&
\&    # add some handles to the select
\&    $select\->add(\e*STDIN);
\&
\&    # loop forever trying to stay alive
\&    while (1) {
\&
\&        # do a timeout to see if any signals got passed us
\&        # while we were processing another signal
\&        my @fh = $select\->can_read(10);
\&
\&        my $key;
\&        my $val;
\&
\&        # this is the handler for safe (fine under unsafe also)
\&        if (check_sigs()) {
\&          # or my @sigs = check_sigs();
\&          next unless @fh;
\&        }
\&
\&        my $handle = $fh[@fh];
\&
\&        # do something with the handle
\&
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Signals prior in Perl prior to 5.7 were unsafe.  Since then signals
have been implemented in a more safe algorithm.  Net::Server::SIG
provides backwards compatibility, while still working reliably with
newer releases.
.PP
Using a property of the \fIselect()\fR function, Net::Server::SIG attempts
to fix the unsafe problem.  If a process is blocking on \fIselect()\fR any
signal will short circuit the select.  Using this concept,
Net::Server::SIG does the least work possible (changing one bit from 0
to 1).  And depends upon the actual processing of the signals to take
place immediately after the the select call via the \*(L"check_sigs\*(R"
function.  See the example shown above and also see the sigtest.pl
script located in the examples directory of this distribution.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """register_sig($SIG => \e&code_ref)""" 4
.el .IP "\f(CWregister_sig($SIG => \e&code_ref)\fR" 4
.IX Item "register_sig($SIG => &code_ref)"
Takes key/value pairs where the key is the signal name, and the
argument is either a code ref, or the words '\s-1DEFAULT\s0' or '\s-1IGNORE\s0'.
The function register_sig must be used in conjuction with check_sigs,
and with a blocking \fIselect()\fR function call \*(-- otherwise, you will
observe the registered signal mysteriously vanish.
.ie n .IP """unregister_sig($SIG)""" 4
.el .IP "\f(CWunregister_sig($SIG)\fR" 4
.IX Item "unregister_sig($SIG)"
Takes the name of a signal as an argument.  Calls register_sig with a
this signal name and '\s-1DEFAULT\s0' as arguments (same as
register_sig(\s-1SIG\s0,'\s-1DEFAULT\s0')
.ie n .IP """check_sigs()""" 4
.el .IP "\f(CWcheck_sigs()\fR" 4
.IX Item "check_sigs()"
Checks to see if any registered signals have occured.  If so, it will
play the registered code ref for that signal.  Return value is array
containing any \s-1SIGNAL\s0 names that had occured.
.ie n .IP """sig_is_registered($SIG)""" 4
.el .IP "\f(CWsig_is_registered($SIG)\fR" 4
.IX Item "sig_is_registered($SIG)"
Takes a signal name and returns any registered code_ref for that signal.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Seamons (paul@seamons.com)
.PP
Rob B Brown (rob@roobik.com) \- Provided a sounding board and feedback
in creating Net::Server::SIG and sigtest.pl.
.SH "LICENSE"
.IX Header "LICENSE"
.Vb 4
\&  This package may be distributed under the terms of either the
\&  GNU General Public License
\&    or the
\&  Perl Artistic License
\&
\&  All rights reserved.
.Ve
                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::SIG5.18.3pm                     0100644 0001750 0001750 00000017035 12566241464 024455  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::SIG 3"
.TH Net::Server::SIG 3 "2013-01-09" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::SIG \- adpf \- Safer signal handling
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\&    use Net::Server::SIG qw(register_sig check_sigs);
\&    use IO::Select ();
\&    use POSIX qw(WNOHANG);
\&
\&    my $select = IO::Select\->new();
\&
\&    register_sig(PIPE => \*(AqIGNORE\*(Aq,
\&                 HUP  => \*(AqDEFAULT\*(Aq,
\&                 USR1 => sub { print "I got a SIG $_[0]\en"; },
\&                 USR2 => sub { print "I got a SIG $_[0]\en"; },
\&                 CHLD => sub { 1 while waitpid(\-1, WNOHANG) > 0; },
\&                 );
\&
\&    # add some handles to the select
\&    $select\->add(\e*STDIN);
\&
\&    # loop forever trying to stay alive
\&    while (1) {
\&
\&        # do a timeout to see if any signals got passed us
\&        # while we were processing another signal
\&        my @fh = $select\->can_read(10);
\&
\&        my $key;
\&        my $val;
\&
\&        # this is the handler for safe (fine under unsafe also)
\&        if (check_sigs()) {
\&          # or my @sigs = check_sigs();
\&          next unless @fh;
\&        }
\&
\&        my $handle = $fh[@fh];
\&
\&        # do something with the handle
\&
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Signals prior in Perl prior to 5.7 were unsafe.  Since then signals
have been implemented in a more safe algorithm.  Net::Server::SIG
provides backwards compatibility, while still working reliably with
newer releases.
.PP
Using a property of the \fIselect()\fR function, Net::Server::SIG attempts
to fix the unsafe problem.  If a process is blocking on \fIselect()\fR any
signal will short circuit the select.  Using this concept,
Net::Server::SIG does the least work possible (changing one bit from 0
to 1).  And depends upon the actual processing of the signals to take
place immediately after the the select call via the \*(L"check_sigs\*(R"
function.  See the example shown above and also see the sigtest.pl
script located in the examples directory of this distribution.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
.ie n .IP """register_sig($SIG => \e&code_ref)""" 4
.el .IP "\f(CWregister_sig($SIG => \e&code_ref)\fR" 4
.IX Item "register_sig($SIG => &code_ref)"
Takes key/value pairs where the key is the signal name, and the
argument is either a code ref, or the words '\s-1DEFAULT\s0' or '\s-1IGNORE\s0'.
The function register_sig must be used in conjunction with check_sigs,
and with a blocking \fIselect()\fR function call \*(-- otherwise, you will
observe the registered signal mysteriously vanish.
.ie n .IP """unregister_sig($SIG)""" 4
.el .IP "\f(CWunregister_sig($SIG)\fR" 4
.IX Item "unregister_sig($SIG)"
Takes the name of a signal as an argument.  Calls register_sig with a
this signal name and '\s-1DEFAULT\s0' as arguments (same as
register_sig(\s-1SIG,\s0'\s-1DEFAULT\s0')
.ie n .IP """check_sigs()""" 4
.el .IP "\f(CWcheck_sigs()\fR" 4
.IX Item "check_sigs()"
Checks to see if any registered signals have occured.  If so, it will
play the registered code ref for that signal.  Return value is array
containing any \s-1SIGNAL\s0 names that had occured.
.ie n .IP """sig_is_registered($SIG)""" 4
.el .IP "\f(CWsig_is_registered($SIG)\fR" 4
.IX Item "sig_is_registered($SIG)"
Takes a signal name and returns any registered code_ref for that signal.
.SH "AUTHORS"
.IX Header "AUTHORS"
Paul Seamons (paul@seamons.com)
.PP
Rob B Brown (rob@roobik.com) \- Provided a sounding board and feedback
in creating Net::Server::SIG and sigtest.pl.
.SH "LICENSE"
.IX Header "LICENSE"
.Vb 4
\&  This package may be distributed under the terms of either the
\&  GNU General Public License
\&    or the
\&  Perl Artistic License
\&
\&  All rights reserved.
.Ve
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Single.3pm                      0100644 0001750 0001750 00000010541 12566241464 024733  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Single 3"
.TH Net::Server::Single 3 "2012-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Single \- Net::Server personality
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base qw(Net::Server::Single);
\&
\&    sub process_request {
\&        #...code...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers no functionality beyond the Net::Server
base class.  This modules only purpose is to provide
parallelism for the MultiType personality.
.PP
See Net::Server
                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Single5.16.3pm                  0100644 0001750 0001750 00000010220 12566241464 025237  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Single 3"
.TH Net::Server::Single 3 "2012-05-29" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Single \- Net::Server personality
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base qw(Net::Server::Single);
\&
\&    sub process_request {
\&        #...code...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers no functionality beyond the Net::Server
base class.  This modules only purpose is to provide
parallelism for the MultiType personality.
.PP
See Net::Server
                                                                                                                                                                                                                                                                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Server::Single5.18.3pm                  0100644 0001750 0001750 00000010541 12566241464 025247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Server::Single 3"
.TH Net::Server::Single 3 "2012-05-29" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Server::Single \- Net::Server personality
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use base qw(Net::Server::Single);
\&
\&    sub process_request {
\&        #...code...
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module offers no functionality beyond the Net::Server
base class.  This modules only purpose is to provide
parallelism for the MultiType personality.
.PP
See Net::Server
                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Time.3pm                                0100644 0001750 0001750 00000013547 12566207461 023045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Time 3pm"
.TH Net::Time 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Time \- time and daytime network client interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::Time qw(inet_time inet_daytime);
\&
\&    print inet_time();          # use default host from Net::Config
\&    print inet_time(\*(Aqlocalhost\*(Aq);
\&    print inet_time(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
\&
\&    print inet_daytime();       # use default host from Net::Config
\&    print inet_daytime(\*(Aqlocalhost\*(Aq);
\&    print inet_daytime(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::Time\*(C'\fR provides subroutines that obtain the time on a remote machine.
.IP "inet_time ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_time ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC868.\s0 The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be a time value in the same units as returned
by \fItime()\fR or \fIundef\fR upon failure.
.IP "inet_daytime ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_daytime ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC867.\s0 The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be an \s-1ASCII\s0 string or \fIundef\fR upon failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Time5.16.3pm                            0100644 0001750 0001750 00000013226 12566207437 023354  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Time 3pm"
.TH Net::Time 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Time \- time and daytime network client interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::Time qw(inet_time inet_daytime);
\&
\&    print inet_time();          # use default host from Net::Config
\&    print inet_time(\*(Aqlocalhost\*(Aq);
\&    print inet_time(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
\&
\&    print inet_daytime();       # use default host from Net::Config
\&    print inet_daytime(\*(Aqlocalhost\*(Aq);
\&    print inet_daytime(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::Time\*(C'\fR provides subroutines that obtain the time on a remote machine.
.IP "inet_time ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_time ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC868\s0. The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be a time value in the same units as returned
by \fItime()\fR or \fIundef\fR upon failure.
.IP "inet_daytime ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_daytime ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC867\s0. The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be an \s-1ASCII\s0 string or \fIundef\fR upon failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::Time5.18.3pm                            0100644 0001750 0001750 00000013547 12566207461 023361  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::Time 3pm"
.TH Net::Time 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::Time \- time and daytime network client interface
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&    use Net::Time qw(inet_time inet_daytime);
\&
\&    print inet_time();          # use default host from Net::Config
\&    print inet_time(\*(Aqlocalhost\*(Aq);
\&    print inet_time(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
\&
\&    print inet_daytime();       # use default host from Net::Config
\&    print inet_daytime(\*(Aqlocalhost\*(Aq);
\&    print inet_daytime(\*(Aqlocalhost\*(Aq, \*(Aqtcp\*(Aq);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Net::Time\*(C'\fR provides subroutines that obtain the time on a remote machine.
.IP "inet_time ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_time ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC868.\s0 The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be a time value in the same units as returned
by \fItime()\fR or \fIundef\fR upon failure.
.IP "inet_daytime ( [\s-1HOST\s0 [, \s-1PROTOCOL\s0 [, \s-1TIMEOUT\s0]]])" 4
.IX Item "inet_daytime ( [HOST [, PROTOCOL [, TIMEOUT]]])"
Obtain the time on \f(CW\*(C`HOST\*(C'\fR, or some default host if \f(CW\*(C`HOST\*(C'\fR is not given
or not defined, using the protocol as defined in \s-1RFC867.\s0 The optional
argument \f(CW\*(C`PROTOCOL\*(C'\fR should define the protocol to use, either \f(CW\*(C`tcp\*(C'\fR or
\&\f(CW\*(C`udp\*(C'\fR. The result will be an \s-1ASCII\s0 string or \fIundef\fR upon failure.
.SH "AUTHOR"
.IX Header "AUTHOR"
Graham Barr <gbarr@pobox.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (c) 1995\-2004 Graham Barr. All rights reserved.
This program is free software; you can redistribute it and/or modify
it under the same terms as Perl itself.
                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::hostent.3pm                             0100644 0001750 0001750 00000015512 12566207461 023625  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::hostent 3pm"
.TH Net::hostent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::hostent \- by\-name interface to Perl's built\-in gethost*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Net::hostent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgethostbyname()\fR and
\&\fIgethostbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::hostent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`h_\*(C'\fR.  Thus, \f(CW\*(C`$host_obj\->name()\*(C'\fR corresponds to
\&\f(CW$h_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $host_obj\->aliases()
}\*(C'\fR would be simply \f(CW@h_aliases\fR.
.PP
The \fIgethost()\fR function is a simple front-end that forwards a numeric
argument to \fIgethostbyaddr()\fR by way of Socket::inet_aton, and the rest
to \fIgethostbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\& use Net::hostent;
\& use Socket;
\&
\& @ARGV = (\*(Aqnetscape.com\*(Aq) unless @ARGV;
\&
\& for $host ( @ARGV ) {
\&
\&    unless ($h = gethost($host)) {
\&        warn "$0: no such host: $host\en";
\&        next;
\&    }
\&
\&    printf "\en%s is %s%s\en", 
\&            $host, 
\&            lc($h\->name) eq lc($host) ? "" : "*really* ",
\&            $h\->name;
\&
\&    print "\etaliases are ", join(", ", @{$h\->aliases}), "\en"
\&                if @{$h\->aliases};     
\&
\&    if ( @{$h\->addr_list} > 1 ) { 
\&        my $i;
\&        for $addr ( @{$h\->addr_list} ) {
\&            printf "\etaddr #%d is [%s]\en", $i++, inet_ntoa($addr);
\&        } 
\&    } else {
\&        printf "\etaddress is [%s]\en", inet_ntoa($h\->addr);
\&    } 
\&
\&    if ($h = gethostbyaddr($h\->addr)) {
\&        if (lc($h\->name) ne lc($host)) {
\&            printf "\etThat addr reverses to host %s!\en", $h\->name;
\&            $host = $h\->name;
\&            redo;
\&        } 
\&    }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::hostent5.16.3pm                         0100644 0001750 0001750 00000015171 12566207437 024143  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::hostent 3pm"
.TH Net::hostent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::hostent \- by\-name interface to Perl's built\-in gethost*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Net::hostent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgethostbyname()\fR and
\&\fIgethostbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::hostent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`h_\*(C'\fR.  Thus, \f(CW\*(C`$host_obj\->name()\*(C'\fR corresponds to
\&\f(CW$h_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $host_obj\->aliases()
}\*(C'\fR would be simply \f(CW@h_aliases\fR.
.PP
The \fIgethost()\fR function is a simple front-end that forwards a numeric
argument to \fIgethostbyaddr()\fR by way of Socket::inet_aton, and the rest
to \fIgethostbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\& use Net::hostent;
\& use Socket;
\&
\& @ARGV = (\*(Aqnetscape.com\*(Aq) unless @ARGV;
\&
\& for $host ( @ARGV ) {
\&
\&    unless ($h = gethost($host)) {
\&        warn "$0: no such host: $host\en";
\&        next;
\&    }
\&
\&    printf "\en%s is %s%s\en", 
\&            $host, 
\&            lc($h\->name) eq lc($host) ? "" : "*really* ",
\&            $h\->name;
\&
\&    print "\etaliases are ", join(", ", @{$h\->aliases}), "\en"
\&                if @{$h\->aliases};     
\&
\&    if ( @{$h\->addr_list} > 1 ) { 
\&        my $i;
\&        for $addr ( @{$h\->addr_list} ) {
\&            printf "\etaddr #%d is [%s]\en", $i++, inet_ntoa($addr);
\&        } 
\&    } else {
\&        printf "\etaddress is [%s]\en", inet_ntoa($h\->addr);
\&    } 
\&
\&    if ($h = gethostbyaddr($h\->addr)) {
\&        if (lc($h\->name) ne lc($host)) {
\&            printf "\etThat addr reverses to host %s!\en", $h\->name;
\&            $host = $h\->name;
\&            redo;
\&        } 
\&    }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::hostent5.18.3pm                         0100644 0001750 0001750 00000015512 12566207461 024141  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::hostent 3pm"
.TH Net::hostent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::hostent \- by\-name interface to Perl's built\-in gethost*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Net::hostent;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgethostbyname()\fR and
\&\fIgethostbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::hostent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's hostent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, length, and addr_list.  The aliases and
addr_list methods return array reference, the rest scalars.  The addr
method is equivalent to the zeroth element in the addr_list array
reference.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`h_\*(C'\fR.  Thus, \f(CW\*(C`$host_obj\->name()\*(C'\fR corresponds to
\&\f(CW$h_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $host_obj\->aliases()
}\*(C'\fR would be simply \f(CW@h_aliases\fR.
.PP
The \fIgethost()\fR function is a simple front-end that forwards a numeric
argument to \fIgethostbyaddr()\fR by way of Socket::inet_aton, and the rest
to \fIgethostbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 2
\& use Net::hostent;
\& use Socket;
\&
\& @ARGV = (\*(Aqnetscape.com\*(Aq) unless @ARGV;
\&
\& for $host ( @ARGV ) {
\&
\&    unless ($h = gethost($host)) {
\&        warn "$0: no such host: $host\en";
\&        next;
\&    }
\&
\&    printf "\en%s is %s%s\en", 
\&            $host, 
\&            lc($h\->name) eq lc($host) ? "" : "*really* ",
\&            $h\->name;
\&
\&    print "\etaliases are ", join(", ", @{$h\->aliases}), "\en"
\&                if @{$h\->aliases};     
\&
\&    if ( @{$h\->addr_list} > 1 ) { 
\&        my $i;
\&        for $addr ( @{$h\->addr_list} ) {
\&            printf "\etaddr #%d is [%s]\en", $i++, inet_ntoa($addr);
\&        } 
\&    } else {
\&        printf "\etaddress is [%s]\en", inet_ntoa($h\->addr);
\&    } 
\&
\&    if ($h = gethostbyaddr($h\->addr)) {
\&        if (lc($h\->name) ne lc($host)) {
\&            printf "\etThat addr reverses to host %s!\en", $h\->name;
\&            $host = $h\->name;
\&            redo;
\&        } 
\&    }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::libnetFAQ.3pm                           0100644 0001750 0001750 00000040671 12566207461 023752  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::libnetFAQ 3pm"
.TH Net::libnetFAQ 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libnetFAQ \- libnet Frequently Asked Questions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Where to get this document"
.IX Subsection "Where to get this document"
This document is distributed with the libnet distribution, and is also
available on the libnet web page at
.PP
.Vb 1
\&    http://search.cpan.org/~gbarr/libnet/
.Ve
.SS "How to contribute to this document"
.IX Subsection "How to contribute to this document"
You may mail corrections, additions, and suggestions to me
gbarr@pobox.com.
.SH "Author and Copyright Information"
.IX Header "Author and Copyright Information"
Copyright (c) 1997\-1998 Graham Barr. All rights reserved.
This document is free; you can redistribute it and/or modify it
under the terms of the Artistic License.
.SS "Disclaimer"
.IX Subsection "Disclaimer"
This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability
in respect of this information or its use.
.SH "Obtaining and installing libnet"
.IX Header "Obtaining and installing libnet"
.SS "What is libnet ?"
.IX Subsection "What is libnet ?"
libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules available provided the
client side of popular server-client protocols that are used in
the internet community.
.SS "Which version of perl do I need ?"
.IX Subsection "Which version of perl do I need ?"
libnet has been know to work with versions of perl from 5.002 onwards. However
if your release of perl is prior to perl5.004 then you will need to
obtain and install the \s-1IO\s0 distribution from \s-1CPAN.\s0 If you have perl5.004
or later then you will have the \s-1IO\s0 modules in your installation already,
but \s-1CPAN\s0 may contain updates.
.SS "What other modules do I need ?"
.IX Subsection "What other modules do I need ?"
The only modules you will need installed are the modules from the \s-1IO\s0
distribution. If you have perl5.004 or later you will already have
these modules.
.SS "What machines support libnet ?"
.IX Subsection "What machines support libnet ?"
libnet itself is an entirely perl-code distribution so it should work
on any machine that perl runs on. However \s-1IO\s0 may not work
with some machines and earlier releases of perl. But this
should not be the case with perl version 5.004 or later.
.SS "Where can I get the latest libnet release"
.IX Subsection "Where can I get the latest libnet release"
The latest libnet release is always on \s-1CPAN,\s0 you will find it
in
.PP
.Vb 1
\& http://www.cpan.org/modules/by\-module/Net/
.Ve
.PP
The latest release and information is also available on the libnet web page
at
.PP
.Vb 1
\& http://search.cpan.org/~gbarr/libnet/
.Ve
.SH "Using Net::FTP"
.IX Header "Using Net::FTP"
.SS "How do I download files from an \s-1FTP\s0 server ?"
.IX Subsection "How do I download files from an FTP server ?"
An example taken from an article posted to comp.lang.perl.misc
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    # a module making life easier
\&
\&    use Net::FTP;
\&
\&    # for debugging: $ftp = Net::FTP\->new(\*(Aqsite\*(Aq,\*(AqDebug\*(Aq,10);
\&    # open a connection and log in!
\&
\&    $ftp = Net::FTP\->new(\*(Aqtarget_site.somewhere.xxx\*(Aq);
\&    $ftp\->login(\*(Aqusername\*(Aq,\*(Aqpassword\*(Aq);
\&
\&    # set transfer mode to binary
\&
\&    $ftp\->binary();
\&
\&    # change the directory on the ftp site
\&
\&    $ftp\->cwd(\*(Aq/some/path/to/somewhere/\*(Aq);
\&
\&    foreach $name (\*(Aqfile1\*(Aq, \*(Aqfile2\*(Aq, \*(Aqfile3\*(Aq) {
\&
\&    # get\*(Aqs arguments are in the following order:
\&    # ftp server\*(Aqs filename
\&    # filename to save the transfer to on the local machine
\&    # can be simply used as get($name) if you want the same name
\&
\&      $ftp\->get($name,$name);
\&    }
\&
\&    # ftp done!
\&
\&    $ftp\->quit;
.Ve
.SS "How do I transfer files in binary mode ?"
.IX Subsection "How do I transfer files in binary mode ?"
To transfer files without <\s-1LF\s0><\s-1CR\s0> translation Net::FTP provides
the \f(CW\*(C`binary\*(C'\fR method
.PP
.Vb 1
\&    $ftp\->binary;
.Ve
.SS "How can I get the size of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the size of a file on a remote FTP server ?"
.SS "How can I get the modification time of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the modification time of a file on a remote FTP server ?"
.SS "How can I change the permissions of a file on a remote server ?"
.IX Subsection "How can I change the permissions of a file on a remote server ?"
The \s-1FTP\s0 protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a \s-1SITE\s0 command, eg
.PP
.Vb 1
\&    $ftp\->quot(\*(Aqsite chmod 0777\*(Aq,$filename);
.Ve
.PP
But this is not guaranteed to work.
.SS "Can I do a reget operation like the ftp command ?"
.IX Subsection "Can I do a reget operation like the ftp command ?"
.SS "How do I get a directory listing from an \s-1FTP\s0 server ?"
.IX Subsection "How do I get a directory listing from an FTP server ?"
.ie n .SS "Changing directory to """" does not fail ?"
.el .SS "Changing directory to ``'' does not fail ?"
.IX Subsection "Changing directory to """" does not fail ?"
Passing an argument of "" to \->\fIcwd()\fR has the same affect of calling \->\fIcwd()\fR
without any arguments. Turn on Debug (\fISee below\fR) and you will see what is
happening
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($host, Debug => 1);
\&    $ftp\->login;
\&    $ftp\->cwd("");
.Ve
.PP
gives
.PP
.Vb 2
\&    Net::FTP=GLOB(0x82196d8)>>> CWD /
\&    Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.
.Ve
.SS "I am behind a \s-1SOCKS\s0 firewall, but the Firewall option does not work ?"
.IX Subsection "I am behind a SOCKS firewall, but the Firewall option does not work ?"
The Firewall option is only for support of one type of firewall. The type
supported is an ftp proxy.
.PP
To use Net::FTP, or any other module in the libnet distribution,
through a \s-1SOCKS\s0 firewall you must create a socks-ified perl executable
by compiling perl with the socks library.
.SS "I am behind an \s-1FTP\s0 proxy firewall, but cannot access machines outside ?"
.IX Subsection "I am behind an FTP proxy firewall, but cannot access machines outside ?"
Net::FTP implements the most popular ftp proxy firewall approach. The scheme
implemented is that where you log in to the firewall with \f(CW\*(C`user@hostname\*(C'\fR
.PP
I have heard of one other type of firewall which requires a login to the
firewall with an account, then a second login with \f(CW\*(C`user@hostname\*(C'\fR. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($firewall) or die $@;
\&    $ftp\->login($firewall_user, $firewall_passwd) or die $ftp\->message;
\&    $ftp\->login($ext_user . \*(Aq@\*(Aq . $ext_host, $ext_passwd) or die $ftp\->message.
.Ve
.SS "My ftp proxy firewall does not listen on port 21"
.IX Subsection "My ftp proxy firewall does not listen on port 21"
\&\s-1FTP\s0 servers usually listen on the same port number, port 21, as any other
\&\s-1FTP\s0 server. But there is no reason why this has to be the case.
.PP
If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try
to connect to the firewall on port 21.
.PP
Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like \f(CW"hostname:1234"\fR
or by setting the \f(CW\*(C`ftp_firewall\*(C'\fR option in Net::Config to be a string
in in the same form.
.SS "Is it possible to change the file permissions of a file on an \s-1FTP\s0 server ?"
.IX Subsection "Is it possible to change the file permissions of a file on an FTP server ?"
The answer to this is \*(L"maybe\*(R". The \s-1FTP\s0 protocol does not specify a command to change
file permissions on a remote host. However many servers do allow you to run the
chmod command via the \f(CW\*(C`SITE\*(C'\fR command. This can be done with
.PP
.Vb 1
\&  $ftp\->site(\*(Aqchmod\*(Aq,\*(Aq0775\*(Aq,$file);
.Ve
.SS "I have seen scripts call a method message, but cannot find it documented ?"
.IX Subsection "I have seen scripts call a method message, but cannot find it documented ?"
Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so
all the methods described in Net::Cmd are also available on Net::FTP
objects.
.SS "Why does Net::FTP not implement mput and mget methods"
.IX Subsection "Why does Net::FTP not implement mput and mget methods"
The quick answer is because they are easy to implement yourself. The long
answer is that to write these in such a way that multiple platforms are
supported correctly would just require too much code. Below are
some examples how you can implement these yourself.
.PP
sub mput {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR (glob($pattern)) {
    \f(CW$ftp\fR\->put($file) or warn \f(CW$ftp\fR\->message;
  }
}
.PP
sub mget {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR ($ftp\->ls($pattern)) {
    \f(CW$ftp\fR\->get($file) or warn \f(CW$ftp\fR\->message;
  }
}
.SH "Using Net::SMTP"
.IX Header "Using Net::SMTP"
.SS "Why can't the part of an Email address after the @ be used as the hostname ?"
.IX Subsection "Why can't the part of an Email address after the @ be used as the hostname ?"
The part of an Email address which follows the @ is not necessarily a hostname,
it is a mail domain. To find the name of a host to connect for a mail domain
you need to do a \s-1DNS MX\s0 lookup
.SS "Why does Net::SMTP not do \s-1DNS MX\s0 lookups ?"
.IX Subsection "Why does Net::SMTP not do DNS MX lookups ?"
Net::SMTP implements the \s-1SMTP\s0 protocol. The \s-1DNS MX\s0 lookup is not part
of this protocol.
.SS "The verify method always returns true ?"
.IX Subsection "The verify method always returns true ?"
Well it may seem that way, but it does not. The verify method returns true
if the command succeeded. If you pass verify an address which the
server would normally have to forward to another machine, the command
will succeed with something like
.PP
.Vb 1
\&    252 Couldn\*(Aqt verify <someone@there> but will attempt delivery anyway
.Ve
.PP
This command will fail only if you pass it an address in a domain
the server directly delivers for, and that address does not exist.
.SH "Debugging scripts"
.IX Header "Debugging scripts"
.SS "How can I debug my scripts that use Net::* modules ?"
.IX Subsection "How can I debug my scripts that use Net::* modules ?"
Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called \f(CW\*(C`Debug\*(C'\fR. Passing
this option with a non-zero value will turn on a protocol trace, which
will be sent to \s-1STDERR.\s0 This trace can be useful to see what commands
are being sent to the remote server and what responses are being
received back.
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    use Net::FTP;
\&
\&    my $ftp = new Net::FTP($host, Debug => 1);
\&    $ftp\->login(\*(Aqgbarr\*(Aq,\*(Aqpassword\*(Aq);
\&    $ftp\->quit;
.Ve
.PP
this script would output something like
.PP
.Vb 6
\& Net::FTP: Net::FTP(2.22)
\& Net::FTP:   Exporter
\& Net::FTP:   Net::Cmd(2.0801)
\& Net::FTP:   IO::Socket::INET
\& Net::FTP:     IO::Socket(1.1603)
\& Net::FTP:       IO::Handle(1.1504)
\&
\& Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu\-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
\& Net::FTP=GLOB(0x8152974)>>> user gbarr
\& Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
\& Net::FTP=GLOB(0x8152974)>>> PASS ....
\& Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
\& Net::FTP=GLOB(0x8152974)>>> QUIT
\& Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.
.Ve
.PP
The first few lines tell you the modules that Net::FTP uses and their versions,
this is useful data to me when a user reports a bug. The last seven lines
show the communication with the server. Each line has three parts. The first
part is the object itself, this is useful for separating the output
if you are using multiple objects. The second part is either \f(CW\*(C`<<<<\*(C'\fR to
show data coming from the server or \f(CW\*(C`&gt&gt&gt&gt\*(C'\fR to show data
going to the server. The remainder of the line is the command
being sent or response being received.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997 Graham Barr.
All rights reserved.
                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::libnetFAQ5.16.3pm                       0100644 0001750 0001750 00000040375 12566207437 024270  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::libnetFAQ 3pm"
.TH Net::libnetFAQ 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libnetFAQ \- libnet Frequently Asked Questions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Where to get this document"
.IX Subsection "Where to get this document"
This document is distributed with the libnet distribution, and is also
available on the libnet web page at
.PP
.Vb 1
\&    http://search.cpan.org/~gbarr/libnet/
.Ve
.SS "How to contribute to this document"
.IX Subsection "How to contribute to this document"
You may mail corrections, additions, and suggestions to me
gbarr@pobox.com.
.SH "Author and Copyright Information"
.IX Header "Author and Copyright Information"
Copyright (c) 1997\-1998 Graham Barr. All rights reserved.
This document is free; you can redistribute it and/or modify it
under the terms of the Artistic License.
.SS "Disclaimer"
.IX Subsection "Disclaimer"
This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability
in respect of this information or its use.
.SH "Obtaining and installing libnet"
.IX Header "Obtaining and installing libnet"
.SS "What is libnet ?"
.IX Subsection "What is libnet ?"
libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules available provided the
client side of popular server-client protocols that are used in
the internet community.
.SS "Which version of perl do I need ?"
.IX Subsection "Which version of perl do I need ?"
libnet has been know to work with versions of perl from 5.002 onwards. However
if your release of perl is prior to perl5.004 then you will need to
obtain and install the \s-1IO\s0 distribution from \s-1CPAN\s0. If you have perl5.004
or later then you will have the \s-1IO\s0 modules in your installation already,
but \s-1CPAN\s0 may contain updates.
.SS "What other modules do I need ?"
.IX Subsection "What other modules do I need ?"
The only modules you will need installed are the modules from the \s-1IO\s0
distribution. If you have perl5.004 or later you will already have
these modules.
.SS "What machines support libnet ?"
.IX Subsection "What machines support libnet ?"
libnet itself is an entirely perl-code distribution so it should work
on any machine that perl runs on. However \s-1IO\s0 may not work
with some machines and earlier releases of perl. But this
should not be the case with perl version 5.004 or later.
.SS "Where can I get the latest libnet release"
.IX Subsection "Where can I get the latest libnet release"
The latest libnet release is always on \s-1CPAN\s0, you will find it
in
.PP
.Vb 1
\& http://www.cpan.org/modules/by\-module/Net/
.Ve
.PP
The latest release and information is also available on the libnet web page
at
.PP
.Vb 1
\& http://search.cpan.org/~gbarr/libnet/
.Ve
.SH "Using Net::FTP"
.IX Header "Using Net::FTP"
.SS "How do I download files from an \s-1FTP\s0 server ?"
.IX Subsection "How do I download files from an FTP server ?"
An example taken from an article posted to comp.lang.perl.misc
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    # a module making life easier
\&
\&    use Net::FTP;
\&
\&    # for debugging: $ftp = Net::FTP\->new(\*(Aqsite\*(Aq,\*(AqDebug\*(Aq,10);
\&    # open a connection and log in!
\&
\&    $ftp = Net::FTP\->new(\*(Aqtarget_site.somewhere.xxx\*(Aq);
\&    $ftp\->login(\*(Aqusername\*(Aq,\*(Aqpassword\*(Aq);
\&
\&    # set transfer mode to binary
\&
\&    $ftp\->binary();
\&
\&    # change the directory on the ftp site
\&
\&    $ftp\->cwd(\*(Aq/some/path/to/somewhere/\*(Aq);
\&
\&    foreach $name (\*(Aqfile1\*(Aq, \*(Aqfile2\*(Aq, \*(Aqfile3\*(Aq) {
\&
\&    # get\*(Aqs arguments are in the following order:
\&    # ftp server\*(Aqs filename
\&    # filename to save the transfer to on the local machine
\&    # can be simply used as get($name) if you want the same name
\&
\&      $ftp\->get($name,$name);
\&    }
\&
\&    # ftp done!
\&
\&    $ftp\->quit;
.Ve
.SS "How do I transfer files in binary mode ?"
.IX Subsection "How do I transfer files in binary mode ?"
To transfer files without <\s-1LF\s0><\s-1CR\s0> translation Net::FTP provides
the \f(CW\*(C`binary\*(C'\fR method
.PP
.Vb 1
\&    $ftp\->binary;
.Ve
.SS "How can I get the size of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the size of a file on a remote FTP server ?"
.SS "How can I get the modification time of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the modification time of a file on a remote FTP server ?"
.SS "How can I change the permissions of a file on a remote server ?"
.IX Subsection "How can I change the permissions of a file on a remote server ?"
The \s-1FTP\s0 protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a \s-1SITE\s0 command, eg
.PP
.Vb 1
\&    $ftp\->quot(\*(Aqsite chmod 0777\*(Aq,$filename);
.Ve
.PP
But this is not guaranteed to work.
.SS "Can I do a reget operation like the ftp command ?"
.IX Subsection "Can I do a reget operation like the ftp command ?"
.SS "How do I get a directory listing from an \s-1FTP\s0 server ?"
.IX Subsection "How do I get a directory listing from an FTP server ?"
.ie n .SS "Changing directory to """" does not fail ?"
.el .SS "Changing directory to ``'' does not fail ?"
.IX Subsection "Changing directory to """" does not fail ?"
Passing an argument of "" to \->\fIcwd()\fR has the same affect of calling \->\fIcwd()\fR
without any arguments. Turn on Debug (\fISee below\fR) and you will see what is
happening
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($host, Debug => 1);
\&    $ftp\->login;
\&    $ftp\->cwd("");
.Ve
.PP
gives
.PP
.Vb 2
\&    Net::FTP=GLOB(0x82196d8)>>> CWD /
\&    Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.
.Ve
.SS "I am behind a \s-1SOCKS\s0 firewall, but the Firewall option does not work ?"
.IX Subsection "I am behind a SOCKS firewall, but the Firewall option does not work ?"
The Firewall option is only for support of one type of firewall. The type
supported is an ftp proxy.
.PP
To use Net::FTP, or any other module in the libnet distribution,
through a \s-1SOCKS\s0 firewall you must create a socks-ified perl executable
by compiling perl with the socks library.
.SS "I am behind an \s-1FTP\s0 proxy firewall, but cannot access machines outside ?"
.IX Subsection "I am behind an FTP proxy firewall, but cannot access machines outside ?"
Net::FTP implements the most popular ftp proxy firewall approach. The scheme
implemented is that where you log in to the firewall with \f(CW\*(C`user@hostname\*(C'\fR
.PP
I have heard of one other type of firewall which requires a login to the
firewall with an account, then a second login with \f(CW\*(C`user@hostname\*(C'\fR. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($firewall) or die $@;
\&    $ftp\->login($firewall_user, $firewall_passwd) or die $ftp\->message;
\&    $ftp\->login($ext_user . \*(Aq@\*(Aq . $ext_host, $ext_passwd) or die $ftp\->message.
.Ve
.SS "My ftp proxy firewall does not listen on port 21"
.IX Subsection "My ftp proxy firewall does not listen on port 21"
\&\s-1FTP\s0 servers usually listen on the same port number, port 21, as any other
\&\s-1FTP\s0 server. But there is no reason why this has to be the case.
.PP
If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try
to connect to the firewall on port 21.
.PP
Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like \f(CW"hostname:1234"\fR
or by setting the \f(CW\*(C`ftp_firewall\*(C'\fR option in Net::Config to be a string
in in the same form.
.SS "Is it possible to change the file permissions of a file on an \s-1FTP\s0 server ?"
.IX Subsection "Is it possible to change the file permissions of a file on an FTP server ?"
The answer to this is \*(L"maybe\*(R". The \s-1FTP\s0 protocol does not specify a command to change
file permissions on a remote host. However many servers do allow you to run the
chmod command via the \f(CW\*(C`SITE\*(C'\fR command. This can be done with
.PP
.Vb 1
\&  $ftp\->site(\*(Aqchmod\*(Aq,\*(Aq0775\*(Aq,$file);
.Ve
.SS "I have seen scripts call a method message, but cannot find it documented ?"
.IX Subsection "I have seen scripts call a method message, but cannot find it documented ?"
Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so
all the methods described in Net::Cmd are also available on Net::FTP
objects.
.SS "Why does Net::FTP not implement mput and mget methods"
.IX Subsection "Why does Net::FTP not implement mput and mget methods"
The quick answer is because they are easy to implement yourself. The long
answer is that to write these in such a way that multiple platforms are
supported correctly would just require too much code. Below are
some examples how you can implement these yourself.
.PP
sub mput {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR (glob($pattern)) {
    \f(CW$ftp\fR\->put($file) or warn \f(CW$ftp\fR\->message;
  }
}
.PP
sub mget {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR ($ftp\->ls($pattern)) {
    \f(CW$ftp\fR\->get($file) or warn \f(CW$ftp\fR\->message;
  }
}
.SH "Using Net::SMTP"
.IX Header "Using Net::SMTP"
.SS "Why can't the part of an Email address after the @ be used as the hostname ?"
.IX Subsection "Why can't the part of an Email address after the @ be used as the hostname ?"
The part of an Email address which follows the @ is not necessarily a hostname,
it is a mail domain. To find the name of a host to connect for a mail domain
you need to do a \s-1DNS\s0 \s-1MX\s0 lookup
.SS "Why does Net::SMTP not do \s-1DNS\s0 \s-1MX\s0 lookups ?"
.IX Subsection "Why does Net::SMTP not do DNS MX lookups ?"
Net::SMTP implements the \s-1SMTP\s0 protocol. The \s-1DNS\s0 \s-1MX\s0 lookup is not part
of this protocol.
.SS "The verify method always returns true ?"
.IX Subsection "The verify method always returns true ?"
Well it may seem that way, but it does not. The verify method returns true
if the command succeeded. If you pass verify an address which the
server would normally have to forward to another machine, the command
will succeed with something like
.PP
.Vb 1
\&    252 Couldn\*(Aqt verify <someone@there> but will attempt delivery anyway
.Ve
.PP
This command will fail only if you pass it an address in a domain
the server directly delivers for, and that address does not exist.
.SH "Debugging scripts"
.IX Header "Debugging scripts"
.SS "How can I debug my scripts that use Net::* modules ?"
.IX Subsection "How can I debug my scripts that use Net::* modules ?"
Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called \f(CW\*(C`Debug\*(C'\fR. Passing
this option with a non-zero value will turn on a protocol trace, which
will be sent to \s-1STDERR\s0. This trace can be useful to see what commands
are being sent to the remote server and what responses are being
received back.
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    use Net::FTP;
\&
\&    my $ftp = new Net::FTP($host, Debug => 1);
\&    $ftp\->login(\*(Aqgbarr\*(Aq,\*(Aqpassword\*(Aq);
\&    $ftp\->quit;
.Ve
.PP
this script would output something like
.PP
.Vb 6
\& Net::FTP: Net::FTP(2.22)
\& Net::FTP:   Exporter
\& Net::FTP:   Net::Cmd(2.0801)
\& Net::FTP:   IO::Socket::INET
\& Net::FTP:     IO::Socket(1.1603)
\& Net::FTP:       IO::Handle(1.1504)
\&
\& Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu\-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
\& Net::FTP=GLOB(0x8152974)>>> user gbarr
\& Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
\& Net::FTP=GLOB(0x8152974)>>> PASS ....
\& Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
\& Net::FTP=GLOB(0x8152974)>>> QUIT
\& Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.
.Ve
.PP
The first few lines tell you the modules that Net::FTP uses and their versions,
this is useful data to me when a user reports a bug. The last seven lines
show the communication with the server. Each line has three parts. The first
part is the object itself, this is useful for separating the output
if you are using multiple objects. The second part is either \f(CW\*(C`<<<<\*(C'\fR to
show data coming from the server or \f(CW\*(C`&gt&gt&gt&gt\*(C'\fR to show data
going to the server. The remainder of the line is the command
being sent or response being received.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997 Graham Barr.
All rights reserved.
                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::libnetFAQ5.18.3pm                       0100644 0001750 0001750 00000040671 12566207461 024266  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::libnetFAQ 3pm"
.TH Net::libnetFAQ 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
libnetFAQ \- libnet Frequently Asked Questions
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.SS "Where to get this document"
.IX Subsection "Where to get this document"
This document is distributed with the libnet distribution, and is also
available on the libnet web page at
.PP
.Vb 1
\&    http://search.cpan.org/~gbarr/libnet/
.Ve
.SS "How to contribute to this document"
.IX Subsection "How to contribute to this document"
You may mail corrections, additions, and suggestions to me
gbarr@pobox.com.
.SH "Author and Copyright Information"
.IX Header "Author and Copyright Information"
Copyright (c) 1997\-1998 Graham Barr. All rights reserved.
This document is free; you can redistribute it and/or modify it
under the terms of the Artistic License.
.SS "Disclaimer"
.IX Subsection "Disclaimer"
This information is offered in good faith and in the hope that it may
be of use, but is not guaranteed to be correct, up to date, or suitable
for any particular purpose whatsoever.  The authors accept no liability
in respect of this information or its use.
.SH "Obtaining and installing libnet"
.IX Header "Obtaining and installing libnet"
.SS "What is libnet ?"
.IX Subsection "What is libnet ?"
libnet is a collection of perl5 modules which all related to network
programming. The majority of the modules available provided the
client side of popular server-client protocols that are used in
the internet community.
.SS "Which version of perl do I need ?"
.IX Subsection "Which version of perl do I need ?"
libnet has been know to work with versions of perl from 5.002 onwards. However
if your release of perl is prior to perl5.004 then you will need to
obtain and install the \s-1IO\s0 distribution from \s-1CPAN.\s0 If you have perl5.004
or later then you will have the \s-1IO\s0 modules in your installation already,
but \s-1CPAN\s0 may contain updates.
.SS "What other modules do I need ?"
.IX Subsection "What other modules do I need ?"
The only modules you will need installed are the modules from the \s-1IO\s0
distribution. If you have perl5.004 or later you will already have
these modules.
.SS "What machines support libnet ?"
.IX Subsection "What machines support libnet ?"
libnet itself is an entirely perl-code distribution so it should work
on any machine that perl runs on. However \s-1IO\s0 may not work
with some machines and earlier releases of perl. But this
should not be the case with perl version 5.004 or later.
.SS "Where can I get the latest libnet release"
.IX Subsection "Where can I get the latest libnet release"
The latest libnet release is always on \s-1CPAN,\s0 you will find it
in
.PP
.Vb 1
\& http://www.cpan.org/modules/by\-module/Net/
.Ve
.PP
The latest release and information is also available on the libnet web page
at
.PP
.Vb 1
\& http://search.cpan.org/~gbarr/libnet/
.Ve
.SH "Using Net::FTP"
.IX Header "Using Net::FTP"
.SS "How do I download files from an \s-1FTP\s0 server ?"
.IX Subsection "How do I download files from an FTP server ?"
An example taken from an article posted to comp.lang.perl.misc
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    # a module making life easier
\&
\&    use Net::FTP;
\&
\&    # for debugging: $ftp = Net::FTP\->new(\*(Aqsite\*(Aq,\*(AqDebug\*(Aq,10);
\&    # open a connection and log in!
\&
\&    $ftp = Net::FTP\->new(\*(Aqtarget_site.somewhere.xxx\*(Aq);
\&    $ftp\->login(\*(Aqusername\*(Aq,\*(Aqpassword\*(Aq);
\&
\&    # set transfer mode to binary
\&
\&    $ftp\->binary();
\&
\&    # change the directory on the ftp site
\&
\&    $ftp\->cwd(\*(Aq/some/path/to/somewhere/\*(Aq);
\&
\&    foreach $name (\*(Aqfile1\*(Aq, \*(Aqfile2\*(Aq, \*(Aqfile3\*(Aq) {
\&
\&    # get\*(Aqs arguments are in the following order:
\&    # ftp server\*(Aqs filename
\&    # filename to save the transfer to on the local machine
\&    # can be simply used as get($name) if you want the same name
\&
\&      $ftp\->get($name,$name);
\&    }
\&
\&    # ftp done!
\&
\&    $ftp\->quit;
.Ve
.SS "How do I transfer files in binary mode ?"
.IX Subsection "How do I transfer files in binary mode ?"
To transfer files without <\s-1LF\s0><\s-1CR\s0> translation Net::FTP provides
the \f(CW\*(C`binary\*(C'\fR method
.PP
.Vb 1
\&    $ftp\->binary;
.Ve
.SS "How can I get the size of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the size of a file on a remote FTP server ?"
.SS "How can I get the modification time of a file on a remote \s-1FTP\s0 server ?"
.IX Subsection "How can I get the modification time of a file on a remote FTP server ?"
.SS "How can I change the permissions of a file on a remote server ?"
.IX Subsection "How can I change the permissions of a file on a remote server ?"
The \s-1FTP\s0 protocol does not have a command for changing the permissions
of a file on the remote server. But some ftp servers may allow a chmod
command to be issued via a \s-1SITE\s0 command, eg
.PP
.Vb 1
\&    $ftp\->quot(\*(Aqsite chmod 0777\*(Aq,$filename);
.Ve
.PP
But this is not guaranteed to work.
.SS "Can I do a reget operation like the ftp command ?"
.IX Subsection "Can I do a reget operation like the ftp command ?"
.SS "How do I get a directory listing from an \s-1FTP\s0 server ?"
.IX Subsection "How do I get a directory listing from an FTP server ?"
.ie n .SS "Changing directory to """" does not fail ?"
.el .SS "Changing directory to ``'' does not fail ?"
.IX Subsection "Changing directory to """" does not fail ?"
Passing an argument of "" to \->\fIcwd()\fR has the same affect of calling \->\fIcwd()\fR
without any arguments. Turn on Debug (\fISee below\fR) and you will see what is
happening
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($host, Debug => 1);
\&    $ftp\->login;
\&    $ftp\->cwd("");
.Ve
.PP
gives
.PP
.Vb 2
\&    Net::FTP=GLOB(0x82196d8)>>> CWD /
\&    Net::FTP=GLOB(0x82196d8)<<< 250 CWD command successful.
.Ve
.SS "I am behind a \s-1SOCKS\s0 firewall, but the Firewall option does not work ?"
.IX Subsection "I am behind a SOCKS firewall, but the Firewall option does not work ?"
The Firewall option is only for support of one type of firewall. The type
supported is an ftp proxy.
.PP
To use Net::FTP, or any other module in the libnet distribution,
through a \s-1SOCKS\s0 firewall you must create a socks-ified perl executable
by compiling perl with the socks library.
.SS "I am behind an \s-1FTP\s0 proxy firewall, but cannot access machines outside ?"
.IX Subsection "I am behind an FTP proxy firewall, but cannot access machines outside ?"
Net::FTP implements the most popular ftp proxy firewall approach. The scheme
implemented is that where you log in to the firewall with \f(CW\*(C`user@hostname\*(C'\fR
.PP
I have heard of one other type of firewall which requires a login to the
firewall with an account, then a second login with \f(CW\*(C`user@hostname\*(C'\fR. You can
still use Net::FTP to traverse these firewalls, but a more manual approach
must be taken, eg
.PP
.Vb 3
\&    $ftp = Net::FTP\->new($firewall) or die $@;
\&    $ftp\->login($firewall_user, $firewall_passwd) or die $ftp\->message;
\&    $ftp\->login($ext_user . \*(Aq@\*(Aq . $ext_host, $ext_passwd) or die $ftp\->message.
.Ve
.SS "My ftp proxy firewall does not listen on port 21"
.IX Subsection "My ftp proxy firewall does not listen on port 21"
\&\s-1FTP\s0 servers usually listen on the same port number, port 21, as any other
\&\s-1FTP\s0 server. But there is no reason why this has to be the case.
.PP
If you pass a port number to Net::FTP then it assumes this is the port
number of the final destination. By default Net::FTP will always try
to connect to the firewall on port 21.
.PP
Net::FTP uses IO::Socket to open the connection and IO::Socket allows
the port number to be specified as part of the hostname. So this problem
can be resolved by either passing a Firewall option like \f(CW"hostname:1234"\fR
or by setting the \f(CW\*(C`ftp_firewall\*(C'\fR option in Net::Config to be a string
in in the same form.
.SS "Is it possible to change the file permissions of a file on an \s-1FTP\s0 server ?"
.IX Subsection "Is it possible to change the file permissions of a file on an FTP server ?"
The answer to this is \*(L"maybe\*(R". The \s-1FTP\s0 protocol does not specify a command to change
file permissions on a remote host. However many servers do allow you to run the
chmod command via the \f(CW\*(C`SITE\*(C'\fR command. This can be done with
.PP
.Vb 1
\&  $ftp\->site(\*(Aqchmod\*(Aq,\*(Aq0775\*(Aq,$file);
.Ve
.SS "I have seen scripts call a method message, but cannot find it documented ?"
.IX Subsection "I have seen scripts call a method message, but cannot find it documented ?"
Net::FTP, like several other packages in libnet, inherits from Net::Cmd, so
all the methods described in Net::Cmd are also available on Net::FTP
objects.
.SS "Why does Net::FTP not implement mput and mget methods"
.IX Subsection "Why does Net::FTP not implement mput and mget methods"
The quick answer is because they are easy to implement yourself. The long
answer is that to write these in such a way that multiple platforms are
supported correctly would just require too much code. Below are
some examples how you can implement these yourself.
.PP
sub mput {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR (glob($pattern)) {
    \f(CW$ftp\fR\->put($file) or warn \f(CW$ftp\fR\->message;
  }
}
.PP
sub mget {
  my($ftp,$pattern) = \f(CW@_\fR;
  foreach my \f(CW$file\fR ($ftp\->ls($pattern)) {
    \f(CW$ftp\fR\->get($file) or warn \f(CW$ftp\fR\->message;
  }
}
.SH "Using Net::SMTP"
.IX Header "Using Net::SMTP"
.SS "Why can't the part of an Email address after the @ be used as the hostname ?"
.IX Subsection "Why can't the part of an Email address after the @ be used as the hostname ?"
The part of an Email address which follows the @ is not necessarily a hostname,
it is a mail domain. To find the name of a host to connect for a mail domain
you need to do a \s-1DNS MX\s0 lookup
.SS "Why does Net::SMTP not do \s-1DNS MX\s0 lookups ?"
.IX Subsection "Why does Net::SMTP not do DNS MX lookups ?"
Net::SMTP implements the \s-1SMTP\s0 protocol. The \s-1DNS MX\s0 lookup is not part
of this protocol.
.SS "The verify method always returns true ?"
.IX Subsection "The verify method always returns true ?"
Well it may seem that way, but it does not. The verify method returns true
if the command succeeded. If you pass verify an address which the
server would normally have to forward to another machine, the command
will succeed with something like
.PP
.Vb 1
\&    252 Couldn\*(Aqt verify <someone@there> but will attempt delivery anyway
.Ve
.PP
This command will fail only if you pass it an address in a domain
the server directly delivers for, and that address does not exist.
.SH "Debugging scripts"
.IX Header "Debugging scripts"
.SS "How can I debug my scripts that use Net::* modules ?"
.IX Subsection "How can I debug my scripts that use Net::* modules ?"
Most of the libnet client classes allow options to be passed to the
constructor, in most cases one option is called \f(CW\*(C`Debug\*(C'\fR. Passing
this option with a non-zero value will turn on a protocol trace, which
will be sent to \s-1STDERR.\s0 This trace can be useful to see what commands
are being sent to the remote server and what responses are being
received back.
.PP
.Vb 1
\&    #!/your/path/to/perl
\&
\&    use Net::FTP;
\&
\&    my $ftp = new Net::FTP($host, Debug => 1);
\&    $ftp\->login(\*(Aqgbarr\*(Aq,\*(Aqpassword\*(Aq);
\&    $ftp\->quit;
.Ve
.PP
this script would output something like
.PP
.Vb 6
\& Net::FTP: Net::FTP(2.22)
\& Net::FTP:   Exporter
\& Net::FTP:   Net::Cmd(2.0801)
\& Net::FTP:   IO::Socket::INET
\& Net::FTP:     IO::Socket(1.1603)
\& Net::FTP:       IO::Handle(1.1504)
\&
\& Net::FTP=GLOB(0x8152974)<<< 220 imagine FTP server (Version wu\-2.4(5) Tue Jul 29 11:17:18 CDT 1997) ready.
\& Net::FTP=GLOB(0x8152974)>>> user gbarr
\& Net::FTP=GLOB(0x8152974)<<< 331 Password required for gbarr.
\& Net::FTP=GLOB(0x8152974)>>> PASS ....
\& Net::FTP=GLOB(0x8152974)<<< 230 User gbarr logged in.  Access restrictions apply.
\& Net::FTP=GLOB(0x8152974)>>> QUIT
\& Net::FTP=GLOB(0x8152974)<<< 221 Goodbye.
.Ve
.PP
The first few lines tell you the modules that Net::FTP uses and their versions,
this is useful data to me when a user reports a bug. The last seven lines
show the communication with the server. Each line has three parts. The first
part is the object itself, this is useful for separating the output
if you are using multiple objects. The second part is either \f(CW\*(C`<<<<\*(C'\fR to
show data coming from the server or \f(CW\*(C`&gt&gt&gt&gt\*(C'\fR to show data
going to the server. The remainder of the line is the command
being sent or response being received.
.SH "AUTHOR AND COPYRIGHT"
.IX Header "AUTHOR AND COPYRIGHT"
Copyright (c) 1997 Graham Barr.
All rights reserved.
                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::netent.3pm                              0100644 0001750 0001750 00000017105 12566207461 023436  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::netent 3pm"
.TH Net::netent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::netent \- by\-name interface to Perl's built\-in getnet*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Net::netent qw(:FIELDS);
\& getnetbyname("loopback")               or die "bad net";
\& printf "%s is %08X\en", $n_name, $n_net;
\&
\& use Net::netent;
\&
\& $n = getnetbyname("loopback")          or die "bad net";
\& { # there\*(Aqs gotta be a better way, eh?
\&     @bytes = unpack("C4", pack("N", $n\->net));
\&     shift @bytes while @bytes && $bytes[0] == 0;
\& }
\& printf "%s is %08X [%d.%d.%d.%d]\en", $n\->name, $n\->net, @bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetnetbyname()\fR and
\&\fIgetnetbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::netent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's netent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, and net.  The aliases 
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`n_\*(C'\fR.  Thus, \f(CW\*(C`$net_obj\->name()\*(C'\fR corresponds to
\&\f(CW$n_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $net_obj\->aliases()
}\*(C'\fR would be simply \f(CW@n_aliases\fR.
.PP
The \fIgetnet()\fR function is a simple front-end that forwards a numeric
argument to \fIgetnetbyaddr()\fR, and the rest
to \fIgetnetbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The \fIgetnet()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setiv(sv, (I32)nent\->n_net);
.Ve
.PP
The \fIgethost()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setpvn(sv, hent\->h_addr, len);
.Ve
.PP
That means that the address comes back in binary for the
host functions, and as a regular perl integer for the net ones.
This seems a bug, but here's how to deal with it:
.PP
.Vb 3
\& use strict;
\& use Socket;
\& use Net::netent;
\&
\& @ARGV = (\*(Aqloopback\*(Aq) unless @ARGV;
\&
\& my($n, $net);
\&
\& for $net ( @ARGV ) {
\&
\&     unless ($n = getnetbyname($net)) {
\&        warn "$0: no such net: $net\en";
\&        next;
\&     }
\&
\&     printf "\en%s is %s%s\en", 
\&            $net, 
\&            lc($n\->name) eq lc($net) ? "" : "*really* ",
\&            $n\->name;
\&
\&     print "\etaliases are ", join(", ", @{$n\->aliases}), "\en"
\&                if @{$n\->aliases};     
\&
\&     # this is stupid; first, why is this not in binary?
\&     # second, why am i going through these convolutions
\&     # to make it looks right
\&     {
\&        my @a = unpack("C4", pack("N", $n\->net));
\&        shift @a while @a && $a[0] == 0;
\&        printf "\etaddr is %s [%d.%d.%d.%d]\en", $n\->net, @a;
\&     }
\&
\&     if ($n = getnetbyaddr($n\->net)) {
\&        if (lc($n\->name) ne lc($net)) {
\&            printf "\etThat addr reverses to net %s!\en", $n\->name;
\&            $net = $n\->name;
\&            redo;
\&        } 
\&     }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::netent5.16.3pm                          0100644 0001750 0001750 00000016564 12566207437 023763  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::netent 3pm"
.TH Net::netent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::netent \- by\-name interface to Perl's built\-in getnet*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Net::netent qw(:FIELDS);
\& getnetbyname("loopback")               or die "bad net";
\& printf "%s is %08X\en", $n_name, $n_net;
\&
\& use Net::netent;
\&
\& $n = getnetbyname("loopback")          or die "bad net";
\& { # there\*(Aqs gotta be a better way, eh?
\&     @bytes = unpack("C4", pack("N", $n\->net));
\&     shift @bytes while @bytes && $bytes[0] == 0;
\& }
\& printf "%s is %08X [%d.%d.%d.%d]\en", $n\->name, $n\->net, @bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetnetbyname()\fR and
\&\fIgetnetbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::netent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's netent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, and net.  The aliases 
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`n_\*(C'\fR.  Thus, \f(CW\*(C`$net_obj\->name()\*(C'\fR corresponds to
\&\f(CW$n_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $net_obj\->aliases()
}\*(C'\fR would be simply \f(CW@n_aliases\fR.
.PP
The \fIgetnet()\fR function is a simple front-end that forwards a numeric
argument to \fIgetnetbyaddr()\fR, and the rest
to \fIgetnetbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The \fIgetnet()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setiv(sv, (I32)nent\->n_net);
.Ve
.PP
The \fIgethost()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setpvn(sv, hent\->h_addr, len);
.Ve
.PP
That means that the address comes back in binary for the
host functions, and as a regular perl integer for the net ones.
This seems a bug, but here's how to deal with it:
.PP
.Vb 3
\& use strict;
\& use Socket;
\& use Net::netent;
\&
\& @ARGV = (\*(Aqloopback\*(Aq) unless @ARGV;
\&
\& my($n, $net);
\&
\& for $net ( @ARGV ) {
\&
\&     unless ($n = getnetbyname($net)) {
\&        warn "$0: no such net: $net\en";
\&        next;
\&     }
\&
\&     printf "\en%s is %s%s\en", 
\&            $net, 
\&            lc($n\->name) eq lc($net) ? "" : "*really* ",
\&            $n\->name;
\&
\&     print "\etaliases are ", join(", ", @{$n\->aliases}), "\en"
\&                if @{$n\->aliases};     
\&
\&     # this is stupid; first, why is this not in binary?
\&     # second, why am i going through these convolutions
\&     # to make it looks right
\&     {
\&        my @a = unpack("C4", pack("N", $n\->net));
\&        shift @a while @a && $a[0] == 0;
\&        printf "\etaddr is %s [%d.%d.%d.%d]\en", $n\->net, @a;
\&     }
\&
\&     if ($n = getnetbyaddr($n\->net)) {
\&        if (lc($n\->name) ne lc($net)) {
\&            printf "\etThat addr reverses to net %s!\en", $n\->name;
\&            $net = $n\->name;
\&            redo;
\&        } 
\&     }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::netent5.18.3pm                          0100644 0001750 0001750 00000017105 12566207461 023752  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::netent 3pm"
.TH Net::netent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::netent \- by\-name interface to Perl's built\-in getnet*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 3
\& use Net::netent qw(:FIELDS);
\& getnetbyname("loopback")               or die "bad net";
\& printf "%s is %08X\en", $n_name, $n_net;
\&
\& use Net::netent;
\&
\& $n = getnetbyname("loopback")          or die "bad net";
\& { # there\*(Aqs gotta be a better way, eh?
\&     @bytes = unpack("C4", pack("N", $n\->net));
\&     shift @bytes while @bytes && $bytes[0] == 0;
\& }
\& printf "%s is %08X [%d.%d.%d.%d]\en", $n\->name, $n\->net, @bytes;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetnetbyname()\fR and
\&\fIgetnetbyaddr()\fR functions, replacing them with versions that return
\&\*(L"Net::netent\*(R" objects.  This object has methods that return the similarly
named structure field name from the C's netent structure from \fInetdb.h\fR;
namely name, aliases, addrtype, and net.  The aliases 
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`n_\*(C'\fR.  Thus, \f(CW\*(C`$net_obj\->name()\*(C'\fR corresponds to
\&\f(CW$n_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $net_obj\->aliases()
}\*(C'\fR would be simply \f(CW@n_aliases\fR.
.PP
The \fIgetnet()\fR function is a simple front-end that forwards a numeric
argument to \fIgetnetbyaddr()\fR, and the rest
to \fIgetnetbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
The \fIgetnet()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setiv(sv, (I32)nent\->n_net);
.Ve
.PP
The \fIgethost()\fR functions do this in the Perl core:
.PP
.Vb 1
\&    sv_setpvn(sv, hent\->h_addr, len);
.Ve
.PP
That means that the address comes back in binary for the
host functions, and as a regular perl integer for the net ones.
This seems a bug, but here's how to deal with it:
.PP
.Vb 3
\& use strict;
\& use Socket;
\& use Net::netent;
\&
\& @ARGV = (\*(Aqloopback\*(Aq) unless @ARGV;
\&
\& my($n, $net);
\&
\& for $net ( @ARGV ) {
\&
\&     unless ($n = getnetbyname($net)) {
\&        warn "$0: no such net: $net\en";
\&        next;
\&     }
\&
\&     printf "\en%s is %s%s\en", 
\&            $net, 
\&            lc($n\->name) eq lc($net) ? "" : "*really* ",
\&            $n\->name;
\&
\&     print "\etaliases are ", join(", ", @{$n\->aliases}), "\en"
\&                if @{$n\->aliases};     
\&
\&     # this is stupid; first, why is this not in binary?
\&     # second, why am i going through these convolutions
\&     # to make it looks right
\&     {
\&        my @a = unpack("C4", pack("N", $n\->net));
\&        shift @a while @a && $a[0] == 0;
\&        printf "\etaddr is %s [%d.%d.%d.%d]\en", $n\->net, @a;
\&     }
\&
\&     if ($n = getnetbyaddr($n\->net)) {
\&        if (lc($n\->name) ne lc($net)) {
\&            printf "\etThat addr reverses to net %s!\en", $n\->name;
\&            $net = $n\->name;
\&            redo;
\&        } 
\&     }
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::protoent.3pm                            0100644 0001750 0001750 00000014103 12566207461 024006  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::protoent 3pm"
.TH Net::protoent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::protoent \- by\-name interface to Perl's built\-in getproto*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::protoent;
\& $p = getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& printf "proto for %s is %d, aliases are %s\en",
\&    $p\->name, $p\->proto, "@{$p\->aliases}";
\&
\& use Net::protoent qw(:FIELDS);
\& getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& print "proto for $p_name is $p_proto, aliases are @p_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetprotoent()\fR,
\&\fIgetprotobyname()\fR, and \fIgetnetbyport()\fR functions, replacing them with
versions that return \*(L"Net::protoent\*(R" objects.  They take default
second arguments of \*(L"tcp\*(R".  This object has methods that return the
similarly named structure field name from the C's protoent structure
from \fInetdb.h\fR; namely name, aliases, and proto.  The aliases method
returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`p_\*(C'\fR.  Thus, \f(CW\*(C`$proto_obj\->name()\*(C'\fR corresponds to
\&\f(CW$p_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $proto_obj\->aliases()
}\*(C'\fR would be simply \f(CW@p_aliases\fR.
.PP
The \fIgetproto()\fR function is a simple front-end that forwards a numeric
argument to \fIgetprotobyport()\fR, and the rest to \fIgetprotobyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::protoent5.16.3pm                        0100644 0001750 0001750 00000013562 12566207437 024333  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::protoent 3pm"
.TH Net::protoent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::protoent \- by\-name interface to Perl's built\-in getproto*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::protoent;
\& $p = getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& printf "proto for %s is %d, aliases are %s\en",
\&    $p\->name, $p\->proto, "@{$p\->aliases}";
\&
\& use Net::protoent qw(:FIELDS);
\& getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& print "proto for $p_name is $p_proto, aliases are @p_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetprotoent()\fR,
\&\fIgetprotobyname()\fR, and \fIgetnetbyport()\fR functions, replacing them with
versions that return \*(L"Net::protoent\*(R" objects.  They take default
second arguments of \*(L"tcp\*(R".  This object has methods that return the
similarly named structure field name from the C's protoent structure
from \fInetdb.h\fR; namely name, aliases, and proto.  The aliases method
returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`p_\*(C'\fR.  Thus, \f(CW\*(C`$proto_obj\->name()\*(C'\fR corresponds to
\&\f(CW$p_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $proto_obj\->aliases()
}\*(C'\fR would be simply \f(CW@p_aliases\fR.
.PP
The \fIgetproto()\fR function is a simple front-end that forwards a numeric
argument to \fIgetprotobyport()\fR, and the rest to \fIgetprotobyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::protoent5.18.3pm                        0100644 0001750 0001750 00000014103 12566207461 024322  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::protoent 3pm"
.TH Net::protoent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::protoent \- by\-name interface to Perl's built\-in getproto*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::protoent;
\& $p = getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& printf "proto for %s is %d, aliases are %s\en",
\&    $p\->name, $p\->proto, "@{$p\->aliases}";
\&
\& use Net::protoent qw(:FIELDS);
\& getprotobyname(shift || \*(Aqtcp\*(Aq) || die "no proto";
\& print "proto for $p_name is $p_proto, aliases are @p_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetprotoent()\fR,
\&\fIgetprotobyname()\fR, and \fIgetnetbyport()\fR functions, replacing them with
versions that return \*(L"Net::protoent\*(R" objects.  They take default
second arguments of \*(L"tcp\*(R".  This object has methods that return the
similarly named structure field name from the C's protoent structure
from \fInetdb.h\fR; namely name, aliases, and proto.  The aliases method
returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`p_\*(C'\fR.  Thus, \f(CW\*(C`$proto_obj\->name()\*(C'\fR corresponds to
\&\f(CW$p_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $proto_obj\->aliases()
}\*(C'\fR would be simply \f(CW@p_aliases\fR.
.PP
The \fIgetproto()\fR function is a simple front-end that forwards a numeric
argument to \fIgetprotobyport()\fR, and the rest to \fIgetprotobyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                                                                                                                                                                                                                                                             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::servent.3pm                             0100644 0001750 0001750 00000014775 12566207461 023641  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::servent 3pm"
.TH Net::servent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::servent \- by\-name interface to Perl's built\-in getserv*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::servent;
\& $s = getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& printf "port for %s is %s, aliases are %s\en",
\&    $s\->name, $s\->port, "@{$s\->aliases}";
\&
\& use Net::servent qw(:FIELDS);
\& getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& print "port for $s_name is $s_port, aliases are @s_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetservent()\fR,
\&\fIgetservbyname()\fR, and
\&\fIgetnetbyport()\fR functions, replacing them with versions that return
\&\*(L"Net::servent\*(R" objects.  They take default second arguments of \*(L"tcp\*(R".  This object has methods that return the similarly
named structure field name from the C's servent structure from \fInetdb.h\fR;
namely name, aliases, port, and proto.  The aliases
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`s_\*(C'\fR.  Thus, \f(CW\*(C`$serv_obj\->name()\*(C'\fR corresponds to
\&\f(CW$s_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $serv_obj\->aliases()}\*(C'\fR
would be simply \f(CW@s_aliases\fR.
.PP
The \fIgetserv()\fR function is a simple front-end that forwards a numeric
argument to \fIgetservbyport()\fR, and the rest to \fIgetservbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& use Net::servent qw(:FIELDS);
\&
\& while (@ARGV) {
\&     my ($service, $proto) = ((split m!/!, shift), \*(Aqtcp\*(Aq);
\&     my $valet = getserv($service, $proto);
\&     unless ($valet) {
\&         warn "$0: No service: $service/$proto\en"
\&         next;
\&     }
\&     printf "service $service/$proto is port %d\en", $valet\->port;
\&     print "alias are @s_aliases\en" if @s_aliases;
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::servent5.16.3pm                         0100644 0001750 0001750 00000014454 12566207437 024150  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::servent 3pm"
.TH Net::servent 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::servent \- by\-name interface to Perl's built\-in getserv*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::servent;
\& $s = getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& printf "port for %s is %s, aliases are %s\en",
\&    $s\->name, $s\->port, "@{$s\->aliases}";
\&
\& use Net::servent qw(:FIELDS);
\& getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& print "port for $s_name is $s_port, aliases are @s_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetservent()\fR,
\&\fIgetservbyname()\fR, and
\&\fIgetnetbyport()\fR functions, replacing them with versions that return
\&\*(L"Net::servent\*(R" objects.  They take default second arguments of \*(L"tcp\*(R".  This object has methods that return the similarly
named structure field name from the C's servent structure from \fInetdb.h\fR;
namely name, aliases, port, and proto.  The aliases
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`s_\*(C'\fR.  Thus, \f(CW\*(C`$serv_obj\->name()\*(C'\fR corresponds to
\&\f(CW$s_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $serv_obj\->aliases()}\*(C'\fR
would be simply \f(CW@s_aliases\fR.
.PP
The \fIgetserv()\fR function is a simple front-end that forwards a numeric
argument to \fIgetservbyport()\fR, and the rest to \fIgetservbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& use Net::servent qw(:FIELDS);
\&
\& while (@ARGV) {
\&     my ($service, $proto) = ((split m!/!, shift), \*(Aqtcp\*(Aq);
\&     my $valet = getserv($service, $proto);
\&     unless ($valet) {
\&         warn "$0: No service: $service/$proto\en"
\&         next;
\&     }
\&     printf "service $service/$proto is port %d\en", $valet\->port;
\&     print "alias are @s_aliases\en" if @s_aliases;
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
                                                                                                                                                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Net::servent5.18.3pm                         0100644 0001750 0001750 00000014775 12566207461 024155  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Net::servent 3pm"
.TH Net::servent 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Net::servent \- by\-name interface to Perl's built\-in getserv*() functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 4
\& use Net::servent;
\& $s = getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& printf "port for %s is %s, aliases are %s\en",
\&    $s\->name, $s\->port, "@{$s\->aliases}";
\&
\& use Net::servent qw(:FIELDS);
\& getservbyname(shift || \*(Aqftp\*(Aq) || die "no service";
\& print "port for $s_name is $s_port, aliases are @s_aliases\en";
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module's default exports override the core \fIgetservent()\fR,
\&\fIgetservbyname()\fR, and
\&\fIgetnetbyport()\fR functions, replacing them with versions that return
\&\*(L"Net::servent\*(R" objects.  They take default second arguments of \*(L"tcp\*(R".  This object has methods that return the similarly
named structure field name from the C's servent structure from \fInetdb.h\fR;
namely name, aliases, port, and proto.  The aliases
method returns an array reference, the rest scalars.
.PP
You may also import all the structure fields directly into your namespace
as regular variables using the :FIELDS import tag.  (Note that this still
overrides your core functions.)  Access these fields as variables named
with a preceding \f(CW\*(C`s_\*(C'\fR.  Thus, \f(CW\*(C`$serv_obj\->name()\*(C'\fR corresponds to
\&\f(CW$s_name\fR if you import the fields.  Array references are available as
regular array variables, so for example \f(CW\*(C`@{ $serv_obj\->aliases()}\*(C'\fR
would be simply \f(CW@s_aliases\fR.
.PP
The \fIgetserv()\fR function is a simple front-end that forwards a numeric
argument to \fIgetservbyport()\fR, and the rest to \fIgetservbyname()\fR.
.PP
To access this functionality without the core overrides,
pass the \f(CW\*(C`use\*(C'\fR an empty import list, and then access
function functions with their full qualified names.
On the other hand, the built-ins are still available
via the \f(CW\*(C`CORE::\*(C'\fR pseudo-package.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 1
\& use Net::servent qw(:FIELDS);
\&
\& while (@ARGV) {
\&     my ($service, $proto) = ((split m!/!, shift), \*(Aqtcp\*(Aq);
\&     my $valet = getserv($service, $proto);
\&     unless ($valet) {
\&         warn "$0: No service: $service/$proto\en"
\&         next;
\&     }
\&     printf "service $service/$proto is port %d\en", $valet\->port;
\&     print "alias are @s_aliases\en" if @s_aliases;
\& }
.Ve
.SH "NOTE"
.IX Header "NOTE"
While this class is currently implemented using the Class::Struct
module to build a struct-like class, you shouldn't rely upon this.
.SH "AUTHOR"
.IX Header "AUTHOR"
Tom Christiansen
   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP.3pm                              0100644 0001750 0001750 00000112654 12566242045 023246  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IP 3"
.TH IP 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP qw(
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
\&        :aton           DEPRECATED
\&        :lower
\&        :upper
\&        :old_storable
\&        :old_nth
\&        :rfc3021
\&  );
\&
\&  NOTE: NetAddr::IP::Util has a full complement of network address
\&        utilities to convert back and forth between binary and text.
\&
\&        inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa 
\&        ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx, 
\&        inet_n2ad, inetanyto6, ipv6to4
.Ve
.PP
See NetAddr::IP::Util
.PP
.Vb 7
\&  my $ip = new NetAddr::IP \*(Aq127.0.0.1\*(Aq;
\&         or if you prefer
\&  my $ip = NetAddr::IP\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
.Ve
.PP
* The following four functions return ipV6 representations of:
.PP
.Vb 4
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.PP
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
.PP
.Vb 2
\&  * To accept addresses in the format as returned by
\&  inet_aton, invoke the module as:
\&
\&  use NetAddr::IP qw(:aton);
.Ve
.PP
###### \s-1USE\s0 new_from_aton instead ##########################
.PP
* To enable usage of legacy data files containing NetAddr::IP
objects stored using the Storable module.
.PP
.Vb 1
\&  use NetAddr::IP qw(:old_storable);
.Ve
.PP
* To compact many smaller subnets (see: \f(CW\*(C`$me\->compact($addr1,$addr2,...)\*(C'\fR
.PP
.Vb 1
\&  @compacted_object_list = Compact(@object_list)
.Ve
.PP
* Return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.PP
.Vb 1
\&  $arrayref = Coalesce($masklen, $number, @list_of_subnets)
.Ve
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP qw(:upper);
.Ve
.PP
* To set a limit on the size of \fBnets\fR processed or returned by NetAddr::IP.
.PP
Set the maximum number of nets beyond which NetAddr::IP will return
an error as a power of 2 (default 16 or 65536 nets). Each 2**16
consumes approximately 4 megs of memory. A 2**20 consumes 64 megs of
memory, A 2**24 consumes 1 gigabyte of memory.
.PP
.Vb 2
\&  use NetAddr::IP qw(netlimit);
\&  netlimit 20;
.Ve
.PP
The maximum \fBnetlimit\fR allowed is 2**24. Attempts to set limits below
the default of 16 or above the maximum of 24 are ignored.
.PP
Returns true on success, otherwise \f(CW\*(C`undef\*(C'\fR.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP\fR depends on \fBNetAddr::IP::Util\fR which installs by
default with its primary functions compiled using Perl's \s-1XS\s0 extensions
to build a C library. If you do not have a C complier available or
would like the slower Pure Perl version for some other reason, then
type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets that allows for easy manipulations.  Version
4.xx of NetAddr::IP will work with older versions of Perl and is
compatible with Math::BigInt.
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
Many operators have been overloaded, as described below:
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR \s0\*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`==\*(C'\fR. \f(CW\*(C`eq\*(C'\fR allows
comparison with arbitrary strings as well as NetAddr::IP objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR requires both operands to be NetAddr::IP objects.
.Sp
In both cases, a true value is returned if the \s-1CIDR\s0 representation of
the operands is equal.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
\&
\&    outputs 10.0.0.0/24.
.Ve
.Sp
Returns the the unchanged object when the constant is missing or out of
range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.Sp
(See range restrictions on Addition above)
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Serializing and Deserializing"
.IX Subsection "Serializing and Deserializing"
This module defines hooks to collaborate with Storable for
serializing \f(CW\*(C`NetAddr::IP\*(C'\fR objects, through compact and human readable
strings. You can revert to the old format by invoking this module as
.PP
.Vb 1
\&  use NetAddr::IP \*(Aq:old_storable\*(Aq;
.Ve
.PP
You must do this if you have legacy data files containing NetAddr::IP
objects stored using the Storable module.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED \s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED "
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first two methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP \*(Aq:aton\*(Aq
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 11
\&  n.n
\&  n.n/mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n/m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the
address part of the NetAddr::IP object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->prefix()""" 4
.el .IP "\f(CW\->prefix()\fR" 4
.IX Item "->prefix()"
Returns a scalar with the address and mask in ipV4 prefix
representation. This is useful for some programs, which expect its
input to be in this format. This method will include the broadcast
address in the encoding.
.ie n .IP """\->nprefix()""" 4
.el .IP "\f(CW\->nprefix()\fR" 4
.IX Item "->nprefix()"
Just as \f(CW\*(C`\->prefix()\*(C'\fR, but does not include the broadcast address.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in scalar context, will return a Math::BigInt
representation of the address part of the \s-1IP\s0 address. When called in
an array context, it returns a list of two elements, The first
element is as described, the second element is the Math::BigInt
representation of the netmask.
.ie n .IP """\->wildcard()""" 4
.el .IP "\f(CW\->wildcard()\fR" 4
.IX Item "->wildcard()"
When called in a scalar context, returns the wildcard bits
corresponding to the mask, in dotted-quad or ipV6 format as applicable.
.Sp
When called in an array context, returns a two-element array. The
first element, is the address part. The second element, is the
wildcard translation of the mask.
.ie n .IP """\->short()""" 4
.el .IP "\f(CW\->short()\fR" 4
.IX Item "->short()"
Returns the address part in a short or compact notation.
.Sp
.Vb 1
\&  (ie, 127.0.0.1 becomes 127.1).
.Ve
.Sp
Works with both, V4 and V6.
.ie n .IP """\->canon()""" 4
.el .IP "\f(CW\->canon()\fR" 4
.IX Item "->canon()"
Returns the address part in canonical notation as a string.  For
ipV4, this is dotted quad, and is the same as the return value from 
\&\*(L"\->\fIaddr()\fR\*(R".  For ipV6 it is as per \s-1RFC5952,\s0 and is the same as the \s-1LOWER CASE\s0 value
returned by \*(L"\->\fIshort()\fR\*(R".
.ie n .IP """\->full()""" 4
.el .IP "\f(CW\->full()\fR" 4
.IX Item "->full()"
Returns the address part in \s-1FULL\s0 notation for
ipV4 and ipV6 respectively.
.Sp
.Vb 2
\&  i.e. for ipV4
\&    0000:0000:0000:0000:0000:0000:127.0.0.1
\&
\&       for ipV6
\&    0000:0000:0000:0000:0000:0000:0000:0000
.Ve
.Sp
To force ipV4 addresses into full ipV6 format use:
.ie n .IP """\->full6()""" 4
.el .IP "\f(CW\->full6()\fR" 4
.IX Item "->full6()"
Returns the address part in \s-1FULL\s0 ipV6 notation
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR.
.Sp
Note that \f(CW$me\fR and \f(CW$other\fR must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&  10.0.0.0      \-   10.255.255.255  (10/8 prefix)
\&  172.16.0.0    \-   172.31.255.255  (172.16/12 prefix)
\&  192.168.0.0   \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->splitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->splitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->splitref($bits,[optional $bits1,$bits2,...])"
Returns a reference to a list of objects, representing subnets of \f(CW\*(C`bits\*(C'\fR mask
produced by splitting the original object, which is left
unchanged. Note that \f(CW$bits\fR must be longer than the original
mask in order for it to be splittable.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->splitref will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
\&
\&  \->splitref returns undef when C<bits> or the (bits list)
\&    will not fit within the original object.
\&
\&  \->splitref returns undef if a supplied ipV4, ipV6, or NetAddr
\&    mask in inappropriately formatted,
.Ve
.Sp
\&\fBbits\fR may be a \s-1CIDR\s0 mask, a dot quad or ipV6 string or a NetAddr::IP object.
If \f(CW\*(C`bits\*(C'\fR is missing, the object is split for into all available addresses
within the ipV4 or ipV6 object ( auto-mask of \s-1CIDR 32, 128\s0 respectively ).
.Sp
With optional additional \f(CW\*(C`bits\*(C'\fR list, the original object is split into
parts sized based on the list. \s-1NOTE:\s0 a short list will replicate the last
item. If the last item is too large to for what remains of the object after
splitting off the first parts of the list, a \*(L"best fits\*(R" list of remaining
objects will be returned based on an increasing sort of the \s-1CIDR\s0 values of
the \f(CW\*(C`bits\*(C'\fR list.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my $objptr = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 29 28 29 26 26 26 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/29
\&        192.168.0.24/28
\&        192.168.0.40/29
\&        192.168.0.48/26
\&        192.168.0.112/26
\&        192.168.0.176/26
\&        192.168.0.240/28
.Ve
.Sp
\&\s-1NOTE:\s0 that /26 replicates twice beyond the original request and /28 fills
the remaining return object requirement.
.ie n .IP """\->rsplitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplitref($bits,[optional $bits1,$bits2,...])"
\&\f(CW\*(C`\->rsplitref\*(C'\fR is the same as \f(CW\*(C`\->splitref\*(C'\fR above except that the split plan is
applied to the original object in reverse order.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my @objects = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 26 26 26 29 28 29 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/26
\&        192.168.0.80/26
\&        192.168.0.144/26
\&        192.168.0.208/29
\&        192.168.0.216/28
\&        192.168.0.232/29
\&        192.168.0.240/28
.Ve
.ie n .IP """\->split($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->split($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->split($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->splitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->rsplit($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplit($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplit($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->rsplitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->hostenum()""" 4
.el .IP "\f(CW\->hostenum()\fR" 4
.IX Item "->hostenum()"
Returns the list of hosts within a subnet.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->hostenum will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
.Ve
.ie n .IP """\->hostenumref()""" 4
.el .IP "\f(CW\->hostenumref()\fR" 4
.IX Item "->hostenumref()"
Faster version of \f(CW\*(C`\->hostenum()\*(C'\fR, returning a reference to a list.
.Sp
\&\s-1NOTE:\s0 hostenum and hostenumref report zero (0) useable hosts in a /31
network. This is the behavior expected prior to \s-1RFC 3021.\s0 To report 2
useable hosts for use in point-to-point networks, use \fB:rfc3021\fR tag.
.Sp
.Vb 1
\&        use NetAddr::IP qw(:rfc3021);
.Ve
.Sp
This will cause hostenum and hostenumref to return two (2) useable hosts in
a /31 network.
.ie n .IP """$me\->compact($addr1, $addr2, ...)""" 4
.el .IP "\f(CW$me\->compact($addr1, $addr2, ...)\fR" 4
.IX Item "$me->compact($addr1, $addr2, ...)"
.PD 0
.ie n .IP """@compacted_object_list = Compact(@object_list)""" 4
.el .IP "\f(CW@compacted_object_list = Compact(@object_list)\fR" 4
.IX Item "@compacted_object_list = Compact(@object_list)"
.PD
Given a list of objects (including \f(CW$me\fR), this method will compact
all the addresses and subnets into the largest (ie, least specific)
subnets possible that contain exactly all of the given objects.
.Sp
Note that in versions prior to 3.02, if fed with the same \s-1IP\s0 subnets
multiple times, these subnets would be returned. From 3.02 on, a more
\&\*(L"correct\*(R" approach has been adopted and only one address would be
returned.
.Sp
Note that \f(CW$me\fR and all \f(CW$addr\fR's must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->compactref(\e@list)""" 4
.el .IP "\f(CW$me\->compactref(\e@list)\fR" 4
.IX Item "$me->compactref(@list)"
.PD 0
.ie n .IP """$compacted_object_list = Compact(\e@list)""" 4
.el .IP "\f(CW$compacted_object_list = Compact(\e@list)\fR" 4
.IX Item "$compacted_object_list = Compact(@list)"
.PD
As usual, a faster version of \f(CW\*(C`\->compact()\*(C'\fR that returns a
reference to a list. Note that this method takes a reference to a list
instead.
.Sp
Note that \f(CW$me\fR must be a \f(CW\*(C`NetAddr::IP\*(C'\fR object.
.ie n .IP """$me\->coalesce($masklen, $number, @list_of_subnets)""" 4
.el .IP "\f(CW$me\->coalesce($masklen, $number, @list_of_subnets)\fR" 4
.IX Item "$me->coalesce($masklen, $number, @list_of_subnets)"
.PD 0
.ie n .IP """$arrayref = Coalesce($masklen,$number,@list_of_subnets)""" 4
.el .IP "\f(CW$arrayref = Coalesce($masklen,$number,@list_of_subnets)\fR" 4
.IX Item "$arrayref = Coalesce($masklen,$number,@list_of_subnets)"
.PD
Will return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask shorter than \f(CW$masklen\fR
are passed \*(L"as is\*(R" to the return list.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask longer than \f(CW$masklen\fR
will be counted (actually, the number of \s-1IP\s0 addresses is counted)
towards \f(CW$number\fR.
.Sp
Called as a method, the array will include \f(CW$me\fR.
.Sp
\&\s-1WARNING:\s0 the list of subnet must be the same type. i.e ipV4 or ipV6
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner. See the \s-1README\s0 file for details.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for   
a point-to-point /31 or /127 network where there are exactly two   
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/31
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero) 
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses
not counting the broadcast address.
        (one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl 
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load
additional modules such as Math::BigInt, bignum or some similar  
package to do the integer math.
.ie n .IP """\->re()""" 4
.el .IP "\f(CW\->re()\fR" 4
.IX Item "->re()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Defaults to ipV4 notation. Will return an ipV6 regex
if the address in not in ipV4 space.
.ie n .IP """\->re6()""" 4
.el .IP "\f(CW\->re6()\fR" 4
.IX Item "->re6()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Always returns an ipV6 regex.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 7
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
.Ve
.SH "NOTES / BUGS ... FEATURES"
.IX Header "NOTES / BUGS ... FEATURES"
NetAddr::IP only runs in Pure Perl mode on Windows boxes because I don't
have the resources or know how to get the \*(L"configure\*(R" stuff working in the
Windows environment. Volunteers \s-1WELCOME\s0 to port the \*(L"C\*(R" portion of this
module to Windows.
.SH "HISTORY"
.IX Header "HISTORY"
.RS 4
See the Changes file
.RE
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the same warranty as Perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This software is (c) Luis E. Mun\*~oz, 1999 \- 2007, and (c) Michael
Robinton, 2006 \- 2014.
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&  perl(1) L<NetAddr::IP::Lite>, L<NetAddr::IP::Util>,
\&L<NetAddr::IP::InetBase>
.Ve
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP5.16.3pm                          0100644 0001750 0001750 00000111637 12566242057 023563  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IP 3"
.TH IP 3 "2012-10-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP qw(
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
\&        :aton           DEPRECATED
\&        :lower
\&        :upper
\&        :old_storable
\&        :old_nth
\&        :rfc3021
\&  );
\&
\&  NOTE: NetAddr::IP::Util has a full complement of network address
\&        utilities to convert back and forth between binary and text.
\&
\&        inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa 
\&        ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx, 
\&        inet_n2ad, inetanyto6, ipv6to4
.Ve
.PP
See NetAddr::IP::Util
.PP
.Vb 7
\&  my $ip = new NetAddr::IP \*(Aq127.0.0.1\*(Aq;
\&         or if you prefer
\&  my $ip = NetAddr::IP\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
.Ve
.PP
* The following four functions return ipV6 representations of:
.PP
.Vb 4
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.PP
###### \s-1DEPRECATED\s0, will be remove in version 5 ############
.PP
.Vb 2
\&  * To accept addresses in the format as returned by
\&  inet_aton, invoke the module as:
\&
\&  use NetAddr::IP qw(:aton);
.Ve
.PP
###### \s-1USE\s0 new_from_aton instead ##########################
.PP
* To enable usage of legacy data files containing NetAddr::IP
objects stored using the Storable module.
.PP
.Vb 1
\&  use NetAddr::IP qw(:old_storable);
.Ve
.PP
* To compact many smaller subnets (see: \f(CW\*(C`$me\->compact($addr1,$addr2,...)\*(C'\fR
.PP
.Vb 1
\&  @compacted_object_list = Compact(@object_list)
.Ve
.PP
* Return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.PP
.Vb 1
\&  $arrayref = Coalesce($masklen, $number, @list_of_subnets)
.Ve
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST\s0 2010 \s-1RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP qw(:upper);
.Ve
.PP
* To set a limit on the size of \fBnets\fR processed or returned by NetAddr::IP.
.PP
Set the maximum number of nets beyond which NetAddr::IP will return
an error as a power of 2 (default 16 or 65536 nets). Each 2**16
consumes approximately 4 megs of memory. A 2**20 consumes 64 megs of
memory, A 2**24 consumes 1 gigabyte of memory.
.PP
.Vb 2
\&  use NetAddr::IP qw(netlimit);
\&  netlimit 20;
.Ve
.PP
The maximum \fBnetlimit\fR allowed is 2**24. Attempts to set limits below
the default of 16 or above the maximum of 24 are ignored.
.PP
Returns true on success, otherwise \f(CW\*(C`undef\*(C'\fR.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP\fR depends on \fBNetAddr::IP::Util\fR which installs by
default with its primary functions compiled using Perl's \s-1XS\s0 extensions
to build a C library. If you do not have a C complier available or
would like the slower Pure Perl version for some other reason, then
type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets that allows for easy manipulations.  Version
4.xx of NetAddr::IP will work with older versions of Perl and is
compatible with Math::BigInt.
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
Many operators have been overloaded, as described below:
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL\s0 \s-1SYMBOLS\s0 \s-1FOR\s0 \*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`==\*(C'\fR. \f(CW\*(C`eq\*(C'\fR allows
comparison with arbitrary strings as well as NetAddr::IP objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR requires both operands to be NetAddr::IP objects.
.Sp
In both cases, a true value is returned if the \s-1CIDR\s0 representation of
the operands is equal.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
\&
\&    outputs 10.0.0.0/24.
.Ve
.Sp
Returns the the unchanged object when the constant is missing or out of
range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.Sp
(See range restrictions on Addition above)
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Serializing and Deserializing"
.IX Subsection "Serializing and Deserializing"
This module defines hooks to collaborate with Storable for
serializing \f(CW\*(C`NetAddr::IP\*(C'\fR objects, through compact and human readable
strings. You can revert to the old format by invoking this module as
.PP
.Vb 1
\&  use NetAddr::IP \*(Aq:old_storable\*(Aq;
.Ve
.PP
You must do this if you have legacy data files containing NetAddr::IP
objects stored using the Storable module.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED\s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED"
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first two methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP \*(Aq:aton\*(Aq
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 11
\&  n.n
\&  n.n/mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n/m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the
address part of the NetAddr::IP object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->prefix()""" 4
.el .IP "\f(CW\->prefix()\fR" 4
.IX Item "->prefix()"
Returns a scalar with the address and mask in ipV4 prefix
representation. This is useful for some programs, which expect its
input to be in this format. This method will include the broadcast
address in the encoding.
.ie n .IP """\->nprefix()""" 4
.el .IP "\f(CW\->nprefix()\fR" 4
.IX Item "->nprefix()"
Just as \f(CW\*(C`\->prefix()\*(C'\fR, but does not include the broadcast address.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in scalar context, will return a Math::BigInt
representation of the address part of the \s-1IP\s0 address. When called in
an array context, it returns a list of two elements, The first
element is as described, the second element is the Math::BigInt
representation of the netmask.
.ie n .IP """\->wildcard()""" 4
.el .IP "\f(CW\->wildcard()\fR" 4
.IX Item "->wildcard()"
When called in a scalar context, returns the wildcard bits
corresponding to the mask, in dotted-quad or ipV6 format as applicable.
.Sp
When called in an array context, returns a two-element array. The
first element, is the address part. The second element, is the
wildcard translation of the mask.
.ie n .IP """\->short()""" 4
.el .IP "\f(CW\->short()\fR" 4
.IX Item "->short()"
Returns the address part in a short or compact notation.
.Sp
.Vb 1
\&  (ie, 127.0.0.1 becomes 127.1).
.Ve
.Sp
Works with both, V4 and V6.
.ie n .IP """\->full()""" 4
.el .IP "\f(CW\->full()\fR" 4
.IX Item "->full()"
Returns the address part in \s-1FULL\s0 notation for
ipV4 and ipV6 respectively.
.Sp
.Vb 2
\&  i.e. for ipV4
\&    0000:0000:0000:0000:0000:0000:127.0.0.1
\&
\&       for ipV6
\&    0000:0000:0000:0000:0000:0000:0000:0000
.Ve
.Sp
To force ipV4 addresses into full ipV6 format use:
.ie n .IP """\->full6()""" 4
.el .IP "\f(CW\->full6()\fR" 4
.IX Item "->full6()"
Returns the address part in \s-1FULL\s0 ipV6 notation
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR.
.Sp
Note that \f(CW$me\fR and \f(CW$other\fR must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC\s0 1918 address.
.Sp
.Vb 3
\&  10.0.0.0      \-   10.255.255.255  (10/8 prefix)
\&  172.16.0.0    \-   172.31.255.255  (172.16/12 prefix)
\&  192.168.0.0   \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->splitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->splitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->splitref($bits,[optional $bits1,$bits2,...])"
Returns a reference to a list of objects, representing subnets of \f(CW\*(C`bits\*(C'\fR mask
produced by splitting the original object, which is left
unchanged. Note that \f(CW$bits\fR must be longer than the original
mask in order for it to be splittable.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->splitref will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
\&
\&  \->splitref returns undef when C<bits> or the (bits list)
\&    will not fit within the original object.
\&
\&  \->splitref returns undef if a supplied ipV4, ipV6, or NetAddr
\&    mask in inappropriately formatted,
.Ve
.Sp
\&\fBbits\fR may be a \s-1CIDR\s0 mask, a dot quad or ipV6 string or a NetAddr::IP object.
If \f(CW\*(C`bits\*(C'\fR is missing, the object is split for into all available addresses
within the ipV4 or ipV6 object ( auto-mask of \s-1CIDR\s0 32, 128 respectively ).
.Sp
With optional additional \f(CW\*(C`bits\*(C'\fR list, the original object is split into
parts sized based on the list. \s-1NOTE:\s0 a short list will replicate the last
item. If the last item is too large to for what remains of the object after
splitting off the first parts of the list, a \*(L"best fits\*(R" list of remaining
objects will be returned based on an increasing sort of the \s-1CIDR\s0 values of
the \f(CW\*(C`bits\*(C'\fR list.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my $objptr = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 29 28 29 26 26 26 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/29
\&        192.168.0.24/28
\&        192.168.0.40/29
\&        192.168.0.48/26
\&        192.168.0.112/26
\&        192.168.0.176/26
\&        192.168.0.240/28
.Ve
.Sp
\&\s-1NOTE:\s0 that /26 replicates twice beyond the original request and /28 fills
the remaining return object requirement.
.ie n .IP """\->rsplitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplitref($bits,[optional $bits1,$bits2,...])"
\&\f(CW\*(C`\->rsplitref\*(C'\fR is the same as \f(CW\*(C`\->splitref\*(C'\fR above except that the split plan is
applied to the original object in reverse order.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my @objects = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 26 26 26 29 28 29 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/26
\&        192.168.0.80/26
\&        192.168.0.144/26
\&        192.168.0.208/29
\&        192.168.0.216/28
\&        192.168.0.232/29
\&        192.168.0.240/28
.Ve
.ie n .IP """\->split($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->split($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->split($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->splitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->rsplit($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplit($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplit($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->rsplitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->hostenum()""" 4
.el .IP "\f(CW\->hostenum()\fR" 4
.IX Item "->hostenum()"
Returns the list of hosts within a subnet.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->hostenum will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
.Ve
.ie n .IP """\->hostenumref()""" 4
.el .IP "\f(CW\->hostenumref()\fR" 4
.IX Item "->hostenumref()"
Faster version of \f(CW\*(C`\->hostenum()\*(C'\fR, returning a reference to a list.
.Sp
\&\s-1NOTE:\s0 hostenum and hostenumref report zero (0) useable hosts in a /31
network. This is the behavior expected prior to \s-1RFC\s0 3021. To report 2
useable hosts for use in point-to-point networks, use \fB:rfc3021\fR tag.
.Sp
.Vb 1
\&        use NetAddr::IP qw(:rfc3021);
.Ve
.Sp
This will cause hostenum and hostenumref to return two (2) useable hosts in
a /31 network.
.ie n .IP """$me\->compact($addr1, $addr2, ...)""" 4
.el .IP "\f(CW$me\->compact($addr1, $addr2, ...)\fR" 4
.IX Item "$me->compact($addr1, $addr2, ...)"
.PD 0
.ie n .IP """@compacted_object_list = Compact(@object_list)""" 4
.el .IP "\f(CW@compacted_object_list = Compact(@object_list)\fR" 4
.IX Item "@compacted_object_list = Compact(@object_list)"
.PD
Given a list of objects (including \f(CW$me\fR), this method will compact
all the addresses and subnets into the largest (ie, least specific)
subnets possible that contain exactly all of the given objects.
.Sp
Note that in versions prior to 3.02, if fed with the same \s-1IP\s0 subnets
multiple times, these subnets would be returned. From 3.02 on, a more
\&\*(L"correct\*(R" approach has been adopted and only one address would be
returned.
.Sp
Note that \f(CW$me\fR and all \f(CW$addr\fR's must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->compactref(\e@list)""" 4
.el .IP "\f(CW$me\->compactref(\e@list)\fR" 4
.IX Item "$me->compactref(@list)"
.PD 0
.ie n .IP """$compacted_object_list = Compact(\e@list)""" 4
.el .IP "\f(CW$compacted_object_list = Compact(\e@list)\fR" 4
.IX Item "$compacted_object_list = Compact(@list)"
.PD
As usual, a faster version of \f(CW\*(C`\->compact()\*(C'\fR that returns a
reference to a list. Note that this method takes a reference to a list
instead.
.Sp
Note that \f(CW$me\fR must be a \f(CW\*(C`NetAddr::IP\*(C'\fR object.
.ie n .IP """$me\->coalesce($masklen, $number, @list_of_subnets)""" 4
.el .IP "\f(CW$me\->coalesce($masklen, $number, @list_of_subnets)\fR" 4
.IX Item "$me->coalesce($masklen, $number, @list_of_subnets)"
.PD 0
.ie n .IP """$arrayref = Coalesce($masklen,$number,@list_of_subnets)""" 4
.el .IP "\f(CW$arrayref = Coalesce($masklen,$number,@list_of_subnets)\fR" 4
.IX Item "$arrayref = Coalesce($masklen,$number,@list_of_subnets)"
.PD
Will return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask shorter than \f(CW$masklen\fR
are passed \*(L"as is\*(R" to the return list.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask longer than \f(CW$masklen\fR
will be counted (actually, the number of \s-1IP\s0 addresses is counted)
towards \f(CW$number\fR.
.Sp
Called as a method, the array will include \f(CW$me\fR.
.Sp
\&\s-1WARNING:\s0 the list of subnet must be the same type. i.e ipV4 or ipV6
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner. See the \s-1README\s0 file for details.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for   
a point-to-point /31 or /127 network where there are exactly two   
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero) 
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses
not counting the broadcast address.
        (one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl 
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load
additional modules such as Math::BigInt, bignum or some similar  
package to do the integer math.
.ie n .IP """\->re()""" 4
.el .IP "\f(CW\->re()\fR" 4
.IX Item "->re()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Defaults to ipV4 notation. Will return an ipV6 regex
if the address in not in ipV4 space.
.ie n .IP """\->re6()""" 4
.el .IP "\f(CW\->re6()\fR" 4
.IX Item "->re6()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Always returns an ipV6 regex.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 7
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
.Ve
.SH "NOTES / BUGS ... FEATURES"
.IX Header "NOTES / BUGS ... FEATURES"
NetAddr::IP only runs in Pure Perl mode on Windows boxes because I don't
have the resources or know how to get the \*(L"configure\*(R" stuff working in the
Windows environment. Volunteers \s-1WELCOME\s0 to port the \*(L"C\*(R" portion of this
module to Windows.
.SH "HISTORY"
.IX Header "HISTORY"
.RS 4
See the Changes file
.RE
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the same warranty as Perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This software is (c) Luis E. Mun\*~oz, 1999 \- 2007, and (c) Michael
Robinton, 2006 \- 2012.
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&  perl(1) L<NetAddr::IP::Lite>, L<NetAddr::IP::Util>,
\&L<NetAddr::IP::InetBase>
.Ve
                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP5.18.3pm                          0100644 0001750 0001750 00000112654 12566242045 023562  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "IP 3"
.TH IP 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP qw(
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
\&        :aton           DEPRECATED
\&        :lower
\&        :upper
\&        :old_storable
\&        :old_nth
\&        :rfc3021
\&  );
\&
\&  NOTE: NetAddr::IP::Util has a full complement of network address
\&        utilities to convert back and forth between binary and text.
\&
\&        inet_aton, inet_ntoa, ipv6_aton, ipv6_ntoa 
\&        ipv6_n2x, ipv6_n2d inet_any2d, inet_n2dx, 
\&        inet_n2ad, inetanyto6, ipv6to4
.Ve
.PP
See NetAddr::IP::Util
.PP
.Vb 7
\&  my $ip = new NetAddr::IP \*(Aq127.0.0.1\*(Aq;
\&         or if you prefer
\&  my $ip = NetAddr::IP\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
.Ve
.PP
* The following four functions return ipV6 representations of:
.PP
.Vb 4
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.PP
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
.PP
.Vb 2
\&  * To accept addresses in the format as returned by
\&  inet_aton, invoke the module as:
\&
\&  use NetAddr::IP qw(:aton);
.Ve
.PP
###### \s-1USE\s0 new_from_aton instead ##########################
.PP
* To enable usage of legacy data files containing NetAddr::IP
objects stored using the Storable module.
.PP
.Vb 1
\&  use NetAddr::IP qw(:old_storable);
.Ve
.PP
* To compact many smaller subnets (see: \f(CW\*(C`$me\->compact($addr1,$addr2,...)\*(C'\fR
.PP
.Vb 1
\&  @compacted_object_list = Compact(@object_list)
.Ve
.PP
* Return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.PP
.Vb 1
\&  $arrayref = Coalesce($masklen, $number, @list_of_subnets)
.Ve
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP qw(:upper);
.Ve
.PP
* To set a limit on the size of \fBnets\fR processed or returned by NetAddr::IP.
.PP
Set the maximum number of nets beyond which NetAddr::IP will return
an error as a power of 2 (default 16 or 65536 nets). Each 2**16
consumes approximately 4 megs of memory. A 2**20 consumes 64 megs of
memory, A 2**24 consumes 1 gigabyte of memory.
.PP
.Vb 2
\&  use NetAddr::IP qw(netlimit);
\&  netlimit 20;
.Ve
.PP
The maximum \fBnetlimit\fR allowed is 2**24. Attempts to set limits below
the default of 16 or above the maximum of 24 are ignored.
.PP
Returns true on success, otherwise \f(CW\*(C`undef\*(C'\fR.
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP\fR depends on \fBNetAddr::IP::Util\fR which installs by
default with its primary functions compiled using Perl's \s-1XS\s0 extensions
to build a C library. If you do not have a C complier available or
would like the slower Pure Perl version for some other reason, then
type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets that allows for easy manipulations.  Version
4.xx of NetAddr::IP will work with older versions of Perl and is
compatible with Math::BigInt.
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
Many operators have been overloaded, as described below:
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR \s0\*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR or \f(CW\*(C`==\*(C'\fR. \f(CW\*(C`eq\*(C'\fR allows
comparison with arbitrary strings as well as NetAddr::IP objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR requires both operands to be NetAddr::IP objects.
.Sp
In both cases, a true value is returned if the \s-1CIDR\s0 representation of
the operands is equal.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
\&
\&    outputs 10.0.0.0/24.
.Ve
.Sp
Returns the the unchanged object when the constant is missing or out of
range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.Sp
(See range restrictions on Addition above)
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Serializing and Deserializing"
.IX Subsection "Serializing and Deserializing"
This module defines hooks to collaborate with Storable for
serializing \f(CW\*(C`NetAddr::IP\*(C'\fR objects, through compact and human readable
strings. You can revert to the old format by invoking this module as
.PP
.Vb 1
\&  use NetAddr::IP \*(Aq:old_storable\*(Aq;
.Ve
.PP
You must do this if you have legacy data files containing NetAddr::IP
objects stored using the Storable module.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED \s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED "
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first two methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP \*(Aq:aton\*(Aq
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 11
\&  n.n
\&  n.n/mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n/m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the
address part of the NetAddr::IP object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->prefix()""" 4
.el .IP "\f(CW\->prefix()\fR" 4
.IX Item "->prefix()"
Returns a scalar with the address and mask in ipV4 prefix
representation. This is useful for some programs, which expect its
input to be in this format. This method will include the broadcast
address in the encoding.
.ie n .IP """\->nprefix()""" 4
.el .IP "\f(CW\->nprefix()\fR" 4
.IX Item "->nprefix()"
Just as \f(CW\*(C`\->prefix()\*(C'\fR, but does not include the broadcast address.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in scalar context, will return a Math::BigInt
representation of the address part of the \s-1IP\s0 address. When called in
an array context, it returns a list of two elements, The first
element is as described, the second element is the Math::BigInt
representation of the netmask.
.ie n .IP """\->wildcard()""" 4
.el .IP "\f(CW\->wildcard()\fR" 4
.IX Item "->wildcard()"
When called in a scalar context, returns the wildcard bits
corresponding to the mask, in dotted-quad or ipV6 format as applicable.
.Sp
When called in an array context, returns a two-element array. The
first element, is the address part. The second element, is the
wildcard translation of the mask.
.ie n .IP """\->short()""" 4
.el .IP "\f(CW\->short()\fR" 4
.IX Item "->short()"
Returns the address part in a short or compact notation.
.Sp
.Vb 1
\&  (ie, 127.0.0.1 becomes 127.1).
.Ve
.Sp
Works with both, V4 and V6.
.ie n .IP """\->canon()""" 4
.el .IP "\f(CW\->canon()\fR" 4
.IX Item "->canon()"
Returns the address part in canonical notation as a string.  For
ipV4, this is dotted quad, and is the same as the return value from 
\&\*(L"\->\fIaddr()\fR\*(R".  For ipV6 it is as per \s-1RFC5952,\s0 and is the same as the \s-1LOWER CASE\s0 value
returned by \*(L"\->\fIshort()\fR\*(R".
.ie n .IP """\->full()""" 4
.el .IP "\f(CW\->full()\fR" 4
.IX Item "->full()"
Returns the address part in \s-1FULL\s0 notation for
ipV4 and ipV6 respectively.
.Sp
.Vb 2
\&  i.e. for ipV4
\&    0000:0000:0000:0000:0000:0000:127.0.0.1
\&
\&       for ipV6
\&    0000:0000:0000:0000:0000:0000:0000:0000
.Ve
.Sp
To force ipV4 addresses into full ipV6 format use:
.ie n .IP """\->full6()""" 4
.el .IP "\f(CW\->full6()\fR" 4
.IX Item "->full6()"
Returns the address part in \s-1FULL\s0 ipV6 notation
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR.
.Sp
Note that \f(CW$me\fR and \f(CW$other\fR must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&  10.0.0.0      \-   10.255.255.255  (10/8 prefix)
\&  172.16.0.0    \-   172.31.255.255  (172.16/12 prefix)
\&  192.168.0.0   \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->splitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->splitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->splitref($bits,[optional $bits1,$bits2,...])"
Returns a reference to a list of objects, representing subnets of \f(CW\*(C`bits\*(C'\fR mask
produced by splitting the original object, which is left
unchanged. Note that \f(CW$bits\fR must be longer than the original
mask in order for it to be splittable.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->splitref will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
\&
\&  \->splitref returns undef when C<bits> or the (bits list)
\&    will not fit within the original object.
\&
\&  \->splitref returns undef if a supplied ipV4, ipV6, or NetAddr
\&    mask in inappropriately formatted,
.Ve
.Sp
\&\fBbits\fR may be a \s-1CIDR\s0 mask, a dot quad or ipV6 string or a NetAddr::IP object.
If \f(CW\*(C`bits\*(C'\fR is missing, the object is split for into all available addresses
within the ipV4 or ipV6 object ( auto-mask of \s-1CIDR 32, 128\s0 respectively ).
.Sp
With optional additional \f(CW\*(C`bits\*(C'\fR list, the original object is split into
parts sized based on the list. \s-1NOTE:\s0 a short list will replicate the last
item. If the last item is too large to for what remains of the object after
splitting off the first parts of the list, a \*(L"best fits\*(R" list of remaining
objects will be returned based on an increasing sort of the \s-1CIDR\s0 values of
the \f(CW\*(C`bits\*(C'\fR list.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my $objptr = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 29 28 29 26 26 26 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/29
\&        192.168.0.24/28
\&        192.168.0.40/29
\&        192.168.0.48/26
\&        192.168.0.112/26
\&        192.168.0.176/26
\&        192.168.0.240/28
.Ve
.Sp
\&\s-1NOTE:\s0 that /26 replicates twice beyond the original request and /28 fills
the remaining return object requirement.
.ie n .IP """\->rsplitref($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplitref($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplitref($bits,[optional $bits1,$bits2,...])"
\&\f(CW\*(C`\->rsplitref\*(C'\fR is the same as \f(CW\*(C`\->splitref\*(C'\fR above except that the split plan is
applied to the original object in reverse order.
.Sp
.Vb 2
\&  i.e.  my $ip = new NetAddr::IP(\*(Aq192.168.0.0/24\*(Aq);
\&        my @objects = $ip\->split(28, 29, 28, 29, 26);
\&
\&   has split plan 28 26 26 26 29 28 29 28
\&   and returns this list of objects
\&
\&        192.168.0.0/28
\&        192.168.0.16/26
\&        192.168.0.80/26
\&        192.168.0.144/26
\&        192.168.0.208/29
\&        192.168.0.216/28
\&        192.168.0.232/29
\&        192.168.0.240/28
.Ve
.ie n .IP """\->split($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->split($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->split($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->splitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->rsplit($bits,[optional $bits1,$bits2,...])""" 4
.el .IP "\f(CW\->rsplit($bits,[optional $bits1,$bits2,...])\fR" 4
.IX Item "->rsplit($bits,[optional $bits1,$bits2,...])"
Similar to \f(CW\*(C`\->rsplitref\*(C'\fR above but returns the list rather than a list
reference. You may not want to use this if a large number of objects is
expected.
.ie n .IP """\->hostenum()""" 4
.el .IP "\f(CW\->hostenum()\fR" 4
.IX Item "->hostenum()"
Returns the list of hosts within a subnet.
.Sp
\&\s-1ERROR\s0 conditions:
.Sp
.Vb 3
\&  \->hostenum will DIE with the message \*(Aqnetlimit exceeded\*(Aq
\&    if the number of return objects exceeds \*(Aqnetlimit\*(Aq.
\&    See function \*(Aqnetlimit\*(Aq above (default 2**16 or 65536 nets).
.Ve
.ie n .IP """\->hostenumref()""" 4
.el .IP "\f(CW\->hostenumref()\fR" 4
.IX Item "->hostenumref()"
Faster version of \f(CW\*(C`\->hostenum()\*(C'\fR, returning a reference to a list.
.Sp
\&\s-1NOTE:\s0 hostenum and hostenumref report zero (0) useable hosts in a /31
network. This is the behavior expected prior to \s-1RFC 3021.\s0 To report 2
useable hosts for use in point-to-point networks, use \fB:rfc3021\fR tag.
.Sp
.Vb 1
\&        use NetAddr::IP qw(:rfc3021);
.Ve
.Sp
This will cause hostenum and hostenumref to return two (2) useable hosts in
a /31 network.
.ie n .IP """$me\->compact($addr1, $addr2, ...)""" 4
.el .IP "\f(CW$me\->compact($addr1, $addr2, ...)\fR" 4
.IX Item "$me->compact($addr1, $addr2, ...)"
.PD 0
.ie n .IP """@compacted_object_list = Compact(@object_list)""" 4
.el .IP "\f(CW@compacted_object_list = Compact(@object_list)\fR" 4
.IX Item "@compacted_object_list = Compact(@object_list)"
.PD
Given a list of objects (including \f(CW$me\fR), this method will compact
all the addresses and subnets into the largest (ie, least specific)
subnets possible that contain exactly all of the given objects.
.Sp
Note that in versions prior to 3.02, if fed with the same \s-1IP\s0 subnets
multiple times, these subnets would be returned. From 3.02 on, a more
\&\*(L"correct\*(R" approach has been adopted and only one address would be
returned.
.Sp
Note that \f(CW$me\fR and all \f(CW$addr\fR's must be \f(CW\*(C`NetAddr::IP\*(C'\fR objects.
.ie n .IP """$me\->compactref(\e@list)""" 4
.el .IP "\f(CW$me\->compactref(\e@list)\fR" 4
.IX Item "$me->compactref(@list)"
.PD 0
.ie n .IP """$compacted_object_list = Compact(\e@list)""" 4
.el .IP "\f(CW$compacted_object_list = Compact(\e@list)\fR" 4
.IX Item "$compacted_object_list = Compact(@list)"
.PD
As usual, a faster version of \f(CW\*(C`\->compact()\*(C'\fR that returns a
reference to a list. Note that this method takes a reference to a list
instead.
.Sp
Note that \f(CW$me\fR must be a \f(CW\*(C`NetAddr::IP\*(C'\fR object.
.ie n .IP """$me\->coalesce($masklen, $number, @list_of_subnets)""" 4
.el .IP "\f(CW$me\->coalesce($masklen, $number, @list_of_subnets)\fR" 4
.IX Item "$me->coalesce($masklen, $number, @list_of_subnets)"
.PD 0
.ie n .IP """$arrayref = Coalesce($masklen,$number,@list_of_subnets)""" 4
.el .IP "\f(CW$arrayref = Coalesce($masklen,$number,@list_of_subnets)\fR" 4
.IX Item "$arrayref = Coalesce($masklen,$number,@list_of_subnets)"
.PD
Will return a reference to list of \f(CW\*(C`NetAddr::IP\*(C'\fR subnets of
\&\f(CW$masklen\fR mask length, when \f(CW$number\fR or more addresses from
\&\f(CW@list_of_subnets\fR are found to be contained in said subnet.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask shorter than \f(CW$masklen\fR
are passed \*(L"as is\*(R" to the return list.
.Sp
Subnets from \f(CW@list_of_subnets\fR with a mask longer than \f(CW$masklen\fR
will be counted (actually, the number of \s-1IP\s0 addresses is counted)
towards \f(CW$number\fR.
.Sp
Called as a method, the array will include \f(CW$me\fR.
.Sp
\&\s-1WARNING:\s0 the list of subnet must be the same type. i.e ipV4 or ipV6
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner. See the \s-1README\s0 file for details.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for   
a point-to-point /31 or /127 network where there are exactly two   
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/31
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30 
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero) 
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses
not counting the broadcast address.
        (one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl 
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load
additional modules such as Math::BigInt, bignum or some similar  
package to do the integer math.
.ie n .IP """\->re()""" 4
.el .IP "\f(CW\->re()\fR" 4
.IX Item "->re()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Defaults to ipV4 notation. Will return an ipV6 regex
if the address in not in ipV4 space.
.ie n .IP """\->re6()""" 4
.el .IP "\f(CW\->re6()\fR" 4
.IX Item "->re6()"
Returns a Perl regular expression that will match an \s-1IP\s0 address within
the given subnet. Always returns an ipV6 regex.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 7
\&        Compact
\&        Coalesce
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        netlimit
.Ve
.SH "NOTES / BUGS ... FEATURES"
.IX Header "NOTES / BUGS ... FEATURES"
NetAddr::IP only runs in Pure Perl mode on Windows boxes because I don't
have the resources or know how to get the \*(L"configure\*(R" stuff working in the
Windows environment. Volunteers \s-1WELCOME\s0 to port the \*(L"C\*(R" portion of this
module to Windows.
.SH "HISTORY"
.IX Header "HISTORY"
.RS 4
See the Changes file
.RE
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the same warranty as Perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This software is (c) Luis E. Mun\*~oz, 1999 \- 2007, and (c) Michael
Robinton, 2006 \- 2014.
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
.Vb 2
\&  perl(1) L<NetAddr::IP::Lite>, L<NetAddr::IP::Util>,
\&L<NetAddr::IP::InetBase>
.Ve
                                                                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::InetBase.3pm                    0100644 0001750 0001750 00000035235 12566242045 025044  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::InetBase 3"
.TH NetAddr::IP::InetBase 3 "2012-10-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::InetBase \-\- IPv4 and IPV6 utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Base qw(
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :ipv4   =>    inet_aton, inet_ntoa, fillIPv4
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa,ipv6_n2x, ipv6_n2d,
\&                inet_any2n, inet_n2dx, inet_n2ad
\&                inet_pton, inet_ntop, packzeros
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipv6_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$text_addr);
\&  $text_addr = inet_ntop($AF_family,$netaddr);
\&  $hex_text = packzeros($hex_text);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $constant = AF_INET();
\&  $constant = AF_INET6();
\&  $trueif   = fake_AF_INET6();
\&  $ip_filled = fillIPv4($shortIP);
\&
\&  NetAddr::IP::InetBase::lower();
\&  NetAddr::IP::InetBase::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::InetBase\fR provides a suite network of conversion functions 
written in pure Perl for converting both IPv4 and IPv6 addresses to
and from network address format and text format.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$text_addr);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$text_addr\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY \s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::lower()\fR;
.Sp
Return IPv6 strings in lowercase. This is the default.
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::upper()\fR;
.Sp
Return IPv6 strings in uppercase.
.Sp
The default may be set to uppercase when the module is loaded by invoking
the \s-1TAG\s0 :upper. i.e.
.Sp
.Vb 1
\&        use NetAddr::IP::InetBase qw( :upper );
.Ve
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET\s0;
.Sp
This function returns the system value for \s-1AF_INET. \s0
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET6\s0;
.Sp
\&\s-1AF_INET6\s0 is sometimes present in the Socket library and always present in the Socket6 library. When the Socket 
library does not contain \s-1AF_INET6\s0 and when Socket6 is not present, a place holder value is \f(CW\*(C`guessed\*(C'\fR based on
the underlying host operating system. See \fBfake_AF_INET6\fR below.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$trueif\fR = fake_AF_INET6;
.Sp
This function return \s-1FALSE\s0 if \s-1AF_INET6\s0 is provided by Socket or Socket6. Otherwise, it returns the best guess
value based on name of the host operating system.
.IP "\(bu" 4
\&\f(CW$ip_filled\fR = fillIPv4($shortIP);
.Sp
This function converts IPv4 addresses of the form 127.1 to the long form
127.0.0.1
.Sp
If the function is passed an argument that does not match the form of an \s-1IP\s0
address, the original argument is returned. i.e. pass it a hostname or a
short \s-1IP\s0 and it will return a hostname or a filled \s-1IP.\s0
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
.Ve
.ie n .SH "%EXPORT_TAGS"
.el .SH "\f(CW%EXPORT_TAGS\fP"
.IX Header "%EXPORT_TAGS"
.Vb 4
\&        :all
\&        :ipv4
\&        :ipv6
\&        :upper
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::Util\fR\|(3)
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::InetBase5.16.3pm                0100644 0001750 0001750 00000034756 12566242057 025370  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::InetBase 3"
.TH NetAddr::IP::InetBase 3 "2012-10-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::InetBase \-\- IPv4 and IPV6 utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Base qw(
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :ipv4   =>    inet_aton, inet_ntoa, fillIPv4
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa,ipv6_n2x, ipv6_n2d,
\&                inet_any2n, inet_n2dx, inet_n2ad
\&                inet_pton, inet_ntop, packzeros
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipv6_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$text_addr);
\&  $text_addr = inet_ntop($AF_family,$netaddr);
\&  $hex_text = packzeros($hex_text);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $constant = AF_INET();
\&  $constant = AF_INET6();
\&  $trueif   = fake_AF_INET6();
\&  $ip_filled = fillIPv4($shortIP);
\&
\&  NetAddr::IP::InetBase::lower();
\&  NetAddr::IP::InetBase::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::InetBase\fR provides a suite network of conversion functions 
written in pure Perl for converting both IPv4 and IPv6 addresses to
and from network address format and text format.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$text_addr);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$text_addr\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0 
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::lower()\fR;
.Sp
Return IPv6 strings in lowercase. This is the default.
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::upper()\fR;
.Sp
Return IPv6 strings in uppercase.
.Sp
The default may be set to uppercase when the module is loaded by invoking
the \s-1TAG\s0 :upper. i.e.
.Sp
.Vb 1
\&        use NetAddr::IP::InetBase qw( :upper );
.Ve
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET\s0;
.Sp
This function returns the system value for \s-1AF_INET\s0.
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET6\s0;
.Sp
\&\s-1AF_INET6\s0 is sometimes present in the Socket library and always present in the Socket6 library. When the Socket 
library does not contain \s-1AF_INET6\s0 and when Socket6 is not present, a place holder value is \f(CW\*(C`guessed\*(C'\fR based on
the underlying host operating system. See \fBfake_AF_INET6\fR below.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$trueif\fR = fake_AF_INET6;
.Sp
This function return \s-1FALSE\s0 if \s-1AF_INET6\s0 is provided by Socket or Socket6. Otherwise, it returns the best guess
value based on name of the host operating system.
.IP "\(bu" 4
\&\f(CW$ip_filled\fR = fillIPv4($shortIP);
.Sp
This function converts IPv4 addresses of the form 127.1 to the long form
127.0.0.1
.Sp
If the function is passed an argument that does not match the form of an \s-1IP\s0
address, the original argument is returned. i.e. pass it a hostname or a
short \s-1IP\s0 and it will return a hostname or a filled \s-1IP\s0.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
.Ve
.ie n .SH "%EXPORT_TAGS"
.el .SH "\f(CW%EXPORT_TAGS\fP"
.IX Header "%EXPORT_TAGS"
.Vb 4
\&        :all
\&        :ipv4
\&        :ipv6
\&        :upper
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::Util\fR\|(3)
                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::InetBase5.18.3pm                0100644 0001750 0001750 00000035235 12566242045 025360  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::InetBase 3"
.TH NetAddr::IP::InetBase 3 "2012-10-02" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::InetBase \-\- IPv4 and IPV6 utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Base qw(
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :ipv4   =>    inet_aton, inet_ntoa, fillIPv4
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa,ipv6_n2x, ipv6_n2d,
\&                inet_any2n, inet_n2dx, inet_n2ad
\&                inet_pton, inet_ntop, packzeros
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipv6_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$text_addr);
\&  $text_addr = inet_ntop($AF_family,$netaddr);
\&  $hex_text = packzeros($hex_text);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $constant = AF_INET();
\&  $constant = AF_INET6();
\&  $trueif   = fake_AF_INET6();
\&  $ip_filled = fillIPv4($shortIP);
\&
\&  NetAddr::IP::InetBase::lower();
\&  NetAddr::IP::InetBase::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::InetBase\fR provides a suite network of conversion functions 
written in pure Perl for converting both IPv4 and IPv6 addresses to
and from network address format and text format.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
\&
\&  Note: this function does NOT compress adjacent
\&  strings of 0:0:0:0 into the :: format
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$text_addr);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$text_addr\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY \s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff:d.d.d.d
.Ve
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::lower()\fR;
.Sp
Return IPv6 strings in lowercase. This is the default.
.IP "\(bu" 4
\&\fINetAddr::IP::InetBase::upper()\fR;
.Sp
Return IPv6 strings in uppercase.
.Sp
The default may be set to uppercase when the module is loaded by invoking
the \s-1TAG\s0 :upper. i.e.
.Sp
.Vb 1
\&        use NetAddr::IP::InetBase qw( :upper );
.Ve
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET\s0;
.Sp
This function returns the system value for \s-1AF_INET. \s0
.IP "\(bu" 4
\&\f(CW$constant\fR = \s-1AF_INET6\s0;
.Sp
\&\s-1AF_INET6\s0 is sometimes present in the Socket library and always present in the Socket6 library. When the Socket 
library does not contain \s-1AF_INET6\s0 and when Socket6 is not present, a place holder value is \f(CW\*(C`guessed\*(C'\fR based on
the underlying host operating system. See \fBfake_AF_INET6\fR below.
.Sp
\&\s-1NOTE:\s0 inet_pton, inet_ntop and \s-1AF_INET6\s0 come from the Socket6 library if it
is present on this host.
.IP "\(bu" 4
\&\f(CW$trueif\fR = fake_AF_INET6;
.Sp
This function return \s-1FALSE\s0 if \s-1AF_INET6\s0 is provided by Socket or Socket6. Otherwise, it returns the best guess
value based on name of the host operating system.
.IP "\(bu" 4
\&\f(CW$ip_filled\fR = fillIPv4($shortIP);
.Sp
This function converts IPv4 addresses of the form 127.1 to the long form
127.0.0.1
.Sp
If the function is passed an argument that does not match the form of an \s-1IP\s0
address, the original argument is returned. i.e. pass it a hostname or a
short \s-1IP\s0 and it will return a hostname or a filled \s-1IP.\s0
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        :upper
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        packzeros
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        AF_INET
\&        AF_INET6
\&        fake_AF_INET6
\&        fillIPv4
.Ve
.ie n .SH "%EXPORT_TAGS"
.el .SH "\f(CW%EXPORT_TAGS\fP"
.IX Header "%EXPORT_TAGS"
.Vb 4
\&        :all
\&        :ipv4
\&        :ipv6
\&        :upper
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::Util\fR\|(3)
                                                                                                                                                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Lite.3pm                        0100644 0001750 0001750 00000064435 12566242045 024253  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Lite \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Lite qw(
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED !
\&        :old_nth
\&        :upper
\&        :lower
\&  );
\&
\&  my $ip = new NetAddr::IP::Lite \*(Aq127.0.0.1\*(Aq;
\&        or if your prefer
\&  my $ip = NetAddr::IP::Lite\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP::Lite (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP::Lite \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP::Lite "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
\&
\&  The following four functions return ipV6 representations of:
\&
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Lite\fR depends on \fBNetAddr::IP::Util\fR which installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets, that allows for easy manipulations. Most of the
operations of NetAddr::IP are supported. This module will work with older
versions of Perl and is compatible with Math::BigInt.
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP::Lite be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:upper);
.Ve
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.PP
The supported operations are described below:
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP::Lite object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR \s0\*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.Sp
.Vb 2
\&        my $ip = new6 NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 0:0:0:0:0:0:C0A8:17B/128
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR allows the
comparison with arbitrary strings as well as NetAddr::IP::Lite objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
Will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR and \f(CW\*(C`!=\*(C'\fR requires both operands to be NetAddr::IP::Lite objects.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
.Ve
.Sp
outputs 10.0.0.0/24.
.Sp
Returns the the unchanged object when the constant is missing or out of range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP::Lite
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP::Lite object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP::Lite object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new6FFFF([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6FFFF([$addr, [ $mask]])\fR" 4
.IX Item "->new6FFFF([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED\s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED"
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first three methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
new6FFFF specifically returns an IPv4 address in IPv6 format according to \s-1RFC4291\s0
.Sp
.Vb 2
\&  new6               ::xxxx:xxxx
\&  new6FFFF      ::FFFF:xxxx:xxxx
.Ve
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation. If the \s-1OPTIONAL\s0 perl module Socket6 is
available in the local library it will autoload and ipV6 host6 
names will be resolved as well as ipV4 hostnames.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP::Lite \*(Aq:aton\*(Aq
.Ve
.Sp
###### \s-1USE\s0 new_from_aton instead ##########################
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 10
\&  n.n
\&  n.n/mm
\&  n.n mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n mm
\&  n.n.n.n/m.m.m.m
\&  n.n.n.n m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (or a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with and empty string as the argument, 'undef' is returned;
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the address
part of the NetAddr::IP::Lite object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP::Lite object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP::Lite object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
context, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in a scalar context, will return a Math::BigInt representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the Math::BigInt  representation of the
netmask.
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR, undef if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&     10.0.0.0        \-   10.255.255.255  (10/8 prefix)
\&     172.16.0.0      \-   172.31.255.255  (172.16/12 prefix)
\&     192.168.0.0     \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for
a point-to-point /31 or /127 network where there are exactly two
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address 
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero)
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a    
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses 
not counting the broadcast address.
	(one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network 
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32 
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load 
additional modules such as Math::BigInt, bignum or some similar 
package to do the integer math.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 8
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED
\&        :old_nth
\&        :upper
\&        :lower
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the  same warranty as perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\& This software is (c) Luis E. Mun\*~oz, 1999 \- 2005
\& and (c) Michael Robinton, 2006 \- 2014.
.Ve
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Util\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Lite5.16.3pm                    0100644 0001750 0001750 00000063504 12566242057 024564  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "2012-10-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Lite \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Lite qw(
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED !
\&        :old_nth
\&        :upper
\&        :lower
\&  );
\&
\&  my $ip = new NetAddr::IP::Lite \*(Aq127.0.0.1\*(Aq;
\&        or if your prefer
\&  my $ip = NetAddr::IP::Lite\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP::Lite (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP::Lite \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP::Lite "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
\&
\&  The following four functions return ipV6 representations of:
\&
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Lite\fR depends on \fBNetAddr::IP::Util\fR which installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets, that allows for easy manipulations. Most of the
operations of NetAddr::IP are supported. This module will work with older
versions of Perl and is compatible with Math::BigInt.
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST\s0 2010 \s-1RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP::Lite be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:upper);
.Ve
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.PP
The supported operations are described below:
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP::Lite object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL\s0 \s-1SYMBOLS\s0 \s-1FOR\s0 \*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.Sp
.Vb 2
\&        my $ip = new6 NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 0:0:0:0:0:0:C0A8:17B/128
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR allows the
comparison with arbitrary strings as well as NetAddr::IP::Lite objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
Will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR and \f(CW\*(C`!=\*(C'\fR requires both operands to be NetAddr::IP::Lite objects.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
.Ve
.Sp
outputs 10.0.0.0/24.
.Sp
Returns the the unchanged object when the constant is missing or out of range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP::Lite
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP::Lite object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP::Lite object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED\s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED"
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first two methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation. If the \s-1OPTIONAL\s0 perl module Socket6 is
available in the local library it will autoload and ipV6 host6 
names will be resolved as well as ipV4 hostnames.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
###### \s-1DEPRECATED\s0, will be remove in version 5 ############
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP::Lite \*(Aq:aton\*(Aq
.Ve
.Sp
###### \s-1USE\s0 new_from_aton instead ##########################
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 10
\&  n.n
\&  n.n/mm
\&  n.n mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n mm
\&  n.n.n.n/m.m.m.m
\&  n.n.n.n m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (or a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with and empty string as the argument, 'undef' is returned;
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the address
part of the NetAddr::IP::Lite object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP::Lite object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP::Lite object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
context, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in a scalar context, will return a Math::BigInt representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the Math::BigInt  representation of the
netmask.
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR, undef if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC\s0 1918 address.
.Sp
.Vb 3
\&     10.0.0.0        \-   10.255.255.255  (10/8 prefix)
\&     172.16.0.0      \-   172.31.255.255  (172.16/12 prefix)
\&     192.168.0.0     \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for
a point-to-point /31 or /127 network where there are exactly two
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address 
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero)
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a    
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses 
not counting the broadcast address.
	(one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network 
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32 
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load 
additional modules such as Math::BigInt, bignum or some similar 
package to do the integer math.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 8
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED
\&        :old_nth
\&        :upper
\&        :lower
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the  same warranty as perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\& This software is (c) Luis E. Mun\*~oz, 1999 \- 2005
\& and (c) Michael Robinton, 2006 \- 2012.
.Ve
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Util\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Lite5.18.3pm                    0100644 0001750 0001750 00000064435 12566242045 024567  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Lite 3"
.TH Lite 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Lite \- Manages IPv4 and IPv6 addresses and subnets
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Lite qw(
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED !
\&        :old_nth
\&        :upper
\&        :lower
\&  );
\&
\&  my $ip = new NetAddr::IP::Lite \*(Aq127.0.0.1\*(Aq;
\&        or if your prefer
\&  my $ip = NetAddr::IP::Lite\->new(\*(Aq127.0.0.1);
\&        or from a packed IPv4 address
\&  my $ip = new_from_aton NetAddr::IP::Lite (inet_aton(\*(Aq127.0.0.1\*(Aq));
\&        or from an octal filtered IPv4 address
\&  my $ip = new_no NetAddr::IP::Lite \*(Aq127.012.0.0\*(Aq;
\&
\&  print "The address is ", $ip\->addr, " with mask ", $ip\->mask, "\en" ;
\&
\&  if ($ip\->within(new NetAddr::IP::Lite "127.0.0.0", "255.0.0.0")) {
\&      print "Is a loopback address\en";
\&  }
\&
\&                                # This prints 127.0.0.1/32
\&  print "You can also say $ip...\en";
\&
\&  The following four functions return ipV6 representations of:
\&
\&  ::                                       = Zeros();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF:FFFF  = Ones();
\&  FFFF:FFFF:FFFF:FFFF:FFFF:FFFF::          = V4mask();
\&  ::FFFF:FFFF                              = V4net();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Lite\fR depends on \fBNetAddr::IP::Util\fR which installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module provides an object-oriented abstraction on top of \s-1IP\s0
addresses or \s-1IP\s0 subnets, that allows for easy manipulations. Most of the
operations of NetAddr::IP are supported. This module will work with older
versions of Perl and is compatible with Math::BigInt.
.PP
* By default \fBNetAddr::IP\fR functions and methods return string IPv6
addresses in uppercase.  To change that to lowercase:
.PP
\&\s-1NOTE:\s0 the \s-1AUGUST 2010 RFC5952\s0 states:
.PP
.Vb 1
\&    4.3. Lowercase
\&
\&      The characters "a", "b", "c", "d", "e", and "f" in an IPv6
\&      address MUST be represented in lowercase.
.Ve
.PP
It is recommended that all \s-1NEW\s0 applications using NetAddr::IP::Lite be
invoked as shown on the next line.
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:lower);
.Ve
.PP
* To ensure the current IPv6 string case behavior even if the default changes:
.PP
.Vb 1
\&  use NetAddr::IP::Lite qw(:upper);
.Ve
.PP
The internal representation of all \s-1IP\s0 objects is in 128 bit IPv6 notation.
IPv4 and IPv6 objects may be freely mixed.
.PP
The supported operations are described below:
.SS "Overloaded Operators"
.IX Subsection "Overloaded Operators"
.ie n .IP "\fBAssignment (\fB""=""\fB)\fR" 4
.el .IP "\fBAssignment (\f(CB=\fB)\fR" 4
.IX Item "Assignment (=)"
Has been optimized to copy one NetAddr::IP::Lite object to another very quickly.
.ie n .IP "\fB\fB""\->copy()""\fB\fR" 4
.el .IP "\fB\f(CB\->copy()\fB\fR" 4
.IX Item "->copy()"
The \fBassignment (\f(CB\*(C`=\*(C'\fB)\fR operation is only put in to operation when the
copied object is further mutated by another overloaded operation. See
overload \fB\s-1SPECIAL SYMBOLS FOR \s0\*(L"use overload\*(R"\fR for details.
.Sp
\&\fB\f(CB\*(C`\->copy()\*(C'\fB\fR actually creates a new object when called.
.IP "\fBStringification\fR" 4
.IX Item "Stringification"
An object can be used just as a string. For instance, the following code
.Sp
.Vb 2
\&        my $ip = new NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 192.168.1.123/32.
.Sp
.Vb 2
\&        my $ip = new6 NetAddr::IP::Lite \*(Aq192.168.1.123\*(Aq;
\&        print "$ip\en";
.Ve
.Sp
Will print the string 0:0:0:0:0:0:C0A8:17B/128
.IP "\fBEquality\fR" 4
.IX Item "Equality"
You can test for equality with either \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR, \f(CW\*(C`==\*(C'\fR or \f(CW\*(C`!=\*(C'\fR. \f(CW\*(C`eq\*(C'\fR, \f(CW\*(C`ne\*(C'\fR allows the
comparison with arbitrary strings as well as NetAddr::IP::Lite objects. The
following example:
.Sp
.Vb 2
\&    if (NetAddr::IP::Lite\->new(\*(Aq127.0.0.1\*(Aq,\*(Aq255.0.0.0\*(Aq) eq \*(Aq127.0.0.1/8\*(Aq)
\&       { print "Yes\en"; }
.Ve
.Sp
Will print out \*(L"Yes\*(R".
.Sp
Comparison with \f(CW\*(C`==\*(C'\fR and \f(CW\*(C`!=\*(C'\fR requires both operands to be NetAddr::IP::Lite objects.
.ie n .IP "\fBComparison via >, <, >=, <=, <=> and \fB""cmp""\fB\fR" 4
.el .IP "\fBComparison via >, <, >=, <=, <=> and \f(CBcmp\fB\fR" 4
.IX Item "Comparison via >, <, >=, <=, <=> and cmp"
Internally, all network objects are represented in 128 bit format.
The numeric representation of the network is compared through the
corresponding operation. Comparisons are tried first on the address portion
of the object and if that is equal then the \s-1NUMERIC\s0 cidr portion of the
masks are compared. This leads to the counterintuitive result that
.Sp
.Vb 1
\&        /24 > /16
.Ve
.Sp
Comparison should not be done on netaddr objects with different \s-1CIDR\s0 as
this may produce indeterminate \- unexpected results,
rather the determination of which netblock is larger or smaller should be
done by comparing
.Sp
.Vb 1
\&        $ip1\->masklen <=> $ip2\->masklen
.Ve
.ie n .IP "\fBAddition of a constant (\fB""+""\fB)\fR" 4
.el .IP "\fBAddition of a constant (\f(CB+\fB)\fR" 4
.IX Item "Addition of a constant (+)"
Add a 32 bit signed constant to the address part of a NetAddr object.
This operation changes the address part to point so many hosts above the
current objects start address. For instance, this code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq127.0.0.1/8\*(Aq) + 5;
.Ve
.Sp
will output 127.0.0.6/8. The address will wrap around at the broadcast
back to the network address. This code:
.Sp
.Vb 1
\&    print NetAddr::IP::Lite\->new(\*(Aq10.0.0.1/24\*(Aq) + 255;
.Ve
.Sp
outputs 10.0.0.0/24.
.Sp
Returns the the unchanged object when the constant is missing or out of range.
.Sp
.Vb 1
\&    2147483647 <= constant >= \-2147483648
.Ve
.ie n .IP "\fBSubtraction of a constant (\fB""\-""\fB)\fR" 4
.el .IP "\fBSubtraction of a constant (\f(CB\-\fB)\fR" 4
.IX Item "Subtraction of a constant (-)"
The complement of the addition of a constant.
.ie n .IP "\fBDifference (\fB""\-""\fB)\fR" 4
.el .IP "\fBDifference (\f(CB\-\fB)\fR" 4
.IX Item "Difference (-)"
Returns the difference between the address parts of two NetAddr::IP::Lite
objects address parts as a 32 bit signed number.
.Sp
Returns \fBundef\fR if the difference is out of range.
.IP "\fBAuto-increment\fR" 4
.IX Item "Auto-increment"
Auto-incrementing a NetAddr::IP::Lite object causes the address part to be
adjusted to the next host address within the subnet. It will wrap at
the broadcast address and start again from the network address.
.IP "\fBAuto-decrement\fR" 4
.IX Item "Auto-decrement"
Auto-decrementing a NetAddr::IP::Lite object performs exactly the opposite
of auto-incrementing it, as you would expect.
.SS "Methods"
.IX Subsection "Methods"
.ie n .IP """\->new([$addr, [ $mask|IPv6 ]])""" 4
.el .IP "\f(CW\->new([$addr, [ $mask|IPv6 ]])\fR" 4
.IX Item "->new([$addr, [ $mask|IPv6 ]])"
.PD 0
.ie n .IP """\->new6([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6([$addr, [ $mask]])\fR" 4
.IX Item "->new6([$addr, [ $mask]])"
.ie n .IP """\->new6FFFF([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new6FFFF([$addr, [ $mask]])\fR" 4
.IX Item "->new6FFFF([$addr, [ $mask]])"
.ie n .IP """\->new_no([$addr, [ $mask]])""" 4
.el .IP "\f(CW\->new_no([$addr, [ $mask]])\fR" 4
.IX Item "->new_no([$addr, [ $mask]])"
.ie n .IP """\->new_from_aton($netaddr)""" 4
.el .IP "\f(CW\->new_from_aton($netaddr)\fR" 4
.IX Item "->new_from_aton($netaddr)"
.IP "new_cis and new_cis6 are \s-1DEPRECATED\s0" 4
.IX Item "new_cis and new_cis6 are DEPRECATED"
.ie n .IP """\->new_cis(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis(""$addr $mask)\fR" 4
.IX Item "->new_cis(""$addr $mask)"
.ie n .IP """\->new_cis6(""$addr $mask)""" 4
.el .IP "\f(CW\->new_cis6(""$addr $mask)\fR" 4
.IX Item "->new_cis6(""$addr $mask)"
.PD
The first three methods create a new address with the supplied address in
\&\f(CW$addr\fR and an optional netmask \f(CW$mask\fR, which can be omitted to get 
a /32 or /128 netmask for IPv4 / IPv6 addresses respectively.
.Sp
new6FFFF specifically returns an IPv4 address in IPv6 format according to \s-1RFC4291\s0
.Sp
.Vb 2
\&  new6               ::xxxx:xxxx
\&  new6FFFF      ::FFFF:xxxx:xxxx
.Ve
.Sp
The third method \f(CW\*(C`new_no\*(C'\fR is exclusively for IPv4 addresses and filters
improperly formatted
dot quad strings for leading 0's that would normally be interpreted as octal
format by NetAddr per the specifications for inet_aton.
.Sp
\&\fBnew_from_aton\fR takes a packed IPv4 address and assumes a /32 mask. This
function replaces the \s-1DEPRECATED\s0 :aton functionality which is fundamentally
broken.
.Sp
The last two methods \fBnew_cis\fR and \fBnew_cis6\fR differ from \fBnew\fR and
\&\fBnew6\fR only in that they except the common Cisco address notation for
address/mask pairs with a \fBspace\fR as a separator instead of a slash (/)
.Sp
These methods are \s-1DEPRECATED\s0 because the functionality is now included
in the other \*(L"new\*(R" methods
.Sp
.Vb 3
\&  i.e.  \->new_cis(\*(Aq1.2.3.0 24\*(Aq)
\&        or
\&        \->new_cis6(\*(Aq::1.2.3.0 120\*(Aq)
.Ve
.Sp
\&\f(CW\*(C`\->new6\*(C'\fR and
\&\f(CW\*(C`\->new_cis6\*(C'\fR mark the address as being in ipV6 address space even
if the format would suggest otherwise.
.Sp
.Vb 1
\&  i.e.  \->new6(\*(Aq1.2.3.4\*(Aq) will result in ::102:304
\&
\&  addresses submitted to \->new in ipV6 notation will
\&  remain in that notation permanently. i.e.
\&        \->new(\*(Aq::1.2.3.4\*(Aq) will result in ::102:304
\&  whereas new(\*(Aq1.2.3.4\*(Aq) would print out as 1.2.3.4
\&
\&  See "STRINGIFICATION" below.
.Ve
.Sp
\&\f(CW$addr\fR can be almost anything that can be resolved to an \s-1IP\s0 address
in all the notations I have seen over time. It can optionally contain
the mask in \s-1CIDR\s0 notation. If the \s-1OPTIONAL\s0 perl module Socket6 is
available in the local library it will autoload and ipV6 host6 
names will be resolved as well as ipV4 hostnames.
.Sp
\&\fBprefix\fR notation is understood, with the limitation that the range
specified by the prefix must match with a valid subnet.
.Sp
Addresses in the same format returned by \f(CW\*(C`inet_aton\*(C'\fR or
\&\f(CW\*(C`gethostbyname\*(C'\fR can also be understood, although no mask can be
specified for them. The default is to not attempt to recognize this
format, as it seems to be seldom used.
.Sp
###### \s-1DEPRECATED,\s0 will be remove in version 5 ############
To accept addresses in that format, invoke the module as in
.Sp
.Vb 1
\&  use NetAddr::IP::Lite \*(Aq:aton\*(Aq
.Ve
.Sp
###### \s-1USE\s0 new_from_aton instead ##########################
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with an empty string as the argument, returns 'undef'
.Sp
\&\f(CW$addr\fR can be any of the following and possibly more...
.Sp
.Vb 10
\&  n.n
\&  n.n/mm
\&  n.n mm
\&  n.n.n
\&  n.n.n/mm
\&  n.n.n mm
\&  n.n.n.n
\&  n.n.n.n/mm            32 bit cidr notation
\&  n.n.n.n mm
\&  n.n.n.n/m.m.m.m
\&  n.n.n.n m.m.m.m
\&  loopback, localhost, broadcast, any, default
\&  x.x.x.x/host
\&  0xABCDEF, 0b111111000101011110, (or a bcd number)
\&  a netaddr as returned by \*(Aqinet_aton\*(Aq
.Ve
.Sp
Any \s-1RFC1884\s0 notation
.Sp
.Vb 10
\&  ::n.n.n.n
\&  ::n.n.n.n/mmm         128 bit cidr notation
\&  ::n.n.n.n/::m.m.m.m
\&  ::x:x
\&  ::x:x/mmm
\&  x:x:x:x:x:x:x:x
\&  x:x:x:x:x:x:x:x/mmm
\&  x:x:x:x:x:x:x:x/m:m:m:m:m:m:m:m any RFC1884 notation
\&  loopback, localhost, unspecified, any, default
\&  ::x:x/host
\&  0xABCDEF, 0b111111000101011110 within the limits
\&  of perl\*(Aqs number resolution
\&  123456789012  a \*(Aqbig\*(Aq bcd number (bigger than perl likes)
\&  and Math::BigInt
.Ve
.Sp
If called with no arguments, 'default' is assumed.
.Sp
If called with and empty string as the argument, 'undef' is returned;
.ie n .IP """\->broadcast()""" 4
.el .IP "\f(CW\->broadcast()\fR" 4
.IX Item "->broadcast()"
Returns a new object referring to the broadcast address of a given
subnet. The broadcast address has all ones in all the bit positions
where the netmask has zero bits. This is normally used to address all
the hosts in a given subnet.
.ie n .IP """\->network()""" 4
.el .IP "\f(CW\->network()\fR" 4
.IX Item "->network()"
Returns a new object referring to the network address of a given
subnet. A network address has all zero bits where the bits of the
netmask are zero. Normally this is used to refer to a subnet.
.ie n .IP """\->addr()""" 4
.el .IP "\f(CW\->addr()\fR" 4
.IX Item "->addr()"
Returns a scalar with the address part of the object as an IPv4 or IPv6 text
string as appropriate. This is useful for printing or for passing the address
part of the NetAddr::IP::Lite object to other components that expect an \s-1IP\s0
address. If the object is an ipV6 address or was created using \->new6($ip)
it will be reported in ipV6 hex format otherwise it will be reported in dot
quad format only if it resides in ipV4 address space.
.ie n .IP """\->mask()""" 4
.el .IP "\f(CW\->mask()\fR" 4
.IX Item "->mask()"
Returns a scalar with the mask as an IPv4 or IPv6 text string as
described above.
.ie n .IP """\->masklen()""" 4
.el .IP "\f(CW\->masklen()\fR" 4
.IX Item "->masklen()"
Returns a scalar the number of one bits in the mask.
.ie n .IP """\->bits()""" 4
.el .IP "\f(CW\->bits()\fR" 4
.IX Item "->bits()"
Returns the width of the address in bits. Normally 32 for v4 and 128 for v6.
.ie n .IP """\->version()""" 4
.el .IP "\f(CW\->version()\fR" 4
.IX Item "->version()"
Returns the version of the address or subnet. Currently this can be
either 4 or 6.
.ie n .IP """\->cidr()""" 4
.el .IP "\f(CW\->cidr()\fR" 4
.IX Item "->cidr()"
Returns a scalar with the address and mask in \s-1CIDR\s0 notation. A
NetAddr::IP::Lite object \fIstringifies\fR to the result of this function.
(see comments about \->\fInew6()\fR and \->\fIaddr()\fR for output formats)
.ie n .IP """\->aton()""" 4
.el .IP "\f(CW\->aton()\fR" 4
.IX Item "->aton()"
Returns the address part of the NetAddr::IP::Lite object in the same format
as the \f(CW\*(C`inet_aton()\*(C'\fR or \f(CW\*(C`ipv6_aton\*(C'\fR function respectively. If the object
was created using \->new6($ip), the address returned will always be in ipV6
format, even for addresses in ipV4 address space.
.ie n .IP """\->range()""" 4
.el .IP "\f(CW\->range()\fR" 4
.IX Item "->range()"
Returns a scalar with the base address and the broadcast address
separated by a dash and spaces. This is called range notation.
.ie n .IP """\->numeric()""" 4
.el .IP "\f(CW\->numeric()\fR" 4
.IX Item "->numeric()"
When called in a scalar context, will return a numeric representation
of the address part of the \s-1IP\s0 address. When called in an array
context, it returns a list of two elements. The first element is as
described, the second element is the numeric representation of the
netmask.
.Sp
This method is essential for serializing the representation of a
subnet.
.ie n .IP """\->bigint()""" 4
.el .IP "\f(CW\->bigint()\fR" 4
.IX Item "->bigint()"
When called in a scalar context, will return a Math::BigInt representation
of the address part of the \s-1IP\s0 address. When called in an array
contest, it returns a list of two elements. The first element is as
described, the second element is the Math::BigInt  representation of the
netmask.
.ie n .IP """$me\->contains($other)""" 4
.el .IP "\f(CW$me\->contains($other)\fR" 4
.IX Item "$me->contains($other)"
Returns true when \f(CW$me\fR completely contains \f(CW$other\fR. False is
returned otherwise and \f(CW\*(C`undef\*(C'\fR is returned if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.ie n .IP """$me\->within($other)""" 4
.el .IP "\f(CW$me\->within($other)\fR" 4
.IX Item "$me->within($other)"
The complement of \f(CW\*(C`\->contains()\*(C'\fR. Returns true when \f(CW$me\fR is
completely contained within \f(CW$other\fR, undef if \f(CW$me\fR and \f(CW$other\fR
are not both \f(CW\*(C`NetAddr::IP::Lite\*(C'\fR objects.
.IP "C\->\fIis_rfc1918()\fR>" 4
.IX Item "C->is_rfc1918()>"
Returns true when \f(CW$me\fR is an \s-1RFC 1918\s0 address.
.Sp
.Vb 3
\&     10.0.0.0        \-   10.255.255.255  (10/8 prefix)
\&     172.16.0.0      \-   172.31.255.255  (172.16/12 prefix)
\&     192.168.0.0     \-   192.168.255.255 (192.168/16 prefix)
.Ve
.ie n .IP """\->first()""" 4
.el .IP "\f(CW\->first()\fR" 4
.IX Item "->first()"
Returns a new object representing the first usable \s-1IP\s0 address within
the subnet (ie, the first host address).
.ie n .IP """\->last()""" 4
.el .IP "\f(CW\->last()\fR" 4
.IX Item "->last()"
Returns a new object representing the last usable \s-1IP\s0 address within
the subnet (ie, one less than the broadcast address).
.ie n .IP """\->nth($index)""" 4
.el .IP "\f(CW\->nth($index)\fR" 4
.IX Item "->nth($index)"
Returns a new object representing the \fIn\fR\-th usable \s-1IP\s0 address within
the subnet (ie, the \fIn\fR\-th host address).  If no address is available
(for example, when the network is too small for \f(CW$index\fR hosts),
\&\f(CW\*(C`undef\*(C'\fR is returned.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite implements
\&\f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR exactly as the documentation states.
Previous versions behaved slightly differently and not in a consistent
manner.
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
\&
\&  old behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(1) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1) == 10.0.0.1/31
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == undef
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(3) == 10.0.0.3/30
.Ve
.Sp
Note that in each case, the broadcast address is represented in the
output set and that the 'zero'th index is alway undef except for
a point-to-point /31 or /127 network where there are exactly two
addresses in the network.
.Sp
.Vb 8
\&  new behavior:
\&  NetAddr::IP\->new(\*(Aq10/32\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10.1/32\*(Aq\->nth(0) == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(0)  == 10.0.0.0/32
\&  NetAddr::IP\->new(\*(Aq10/31\*(Aq)\->nth(1)  == 10.0.0.1/32
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(0) == 10.0.0.1/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(1) == 10.0.0.2/30
\&  NetAddr::IP\->new(\*(Aq10/30\*(Aq)\->nth(2) == undef
.Ve
.Sp
Note that a /32 net always has 1 usable address while a /31 has exactly 
two usable addresses for point-to-point addressing. The first
index (0) returns the address immediately following the network address 
except for a /31 or /127 when it return the network address.
.ie n .IP """\->num()""" 4
.el .IP "\f(CW\->num()\fR" 4
.IX Item "->num()"
As of version 4.42 of NetAddr::IP and version 1.27 of NetAddr::IP::Lite
a /31 and /127 with return a net \fBnum\fR value of 2 instead of 0 (zero)
for point-to-point networks.
.Sp
Version 4.00 of NetAddr::IP and version 1.00 of NetAddr::IP::Lite
return the number of usable \s-1IP\s0 addresses within the subnet, 
not counting the broadcast or network address.
.Sp
Previous versions worked only for ipV4 addresses, returned a    
maximum span of 2**32 and returned the number of \s-1IP\s0 addresses 
not counting the broadcast address.
	(one greater than the new behavior)
.Sp
To use the old behavior for \f(CW\*(C`\->nth($index)\*(C'\fR and \f(CW\*(C`\->num()\*(C'\fR:
.Sp
.Vb 1
\&  use NetAddr::IP::Lite qw(:old_nth);
.Ve
.Sp
\&\s-1WARNING:\s0
.Sp
NetAddr::IP will calculate and return a numeric string for network 
ranges as large as 2**128. These values are \s-1TEXT\s0 strings and perl
can treat them as integers for numeric calculations.
.Sp
Perl on 32 bit platforms only handles integer numbers up to 2**32 
and on 64 bit platforms to 2**64.
.Sp
If you wish to manipulate numeric strings returned by NetAddr::IP
that are larger than 2**32 or 2**64, respectively,  you must load 
additional modules such as Math::BigInt, bignum or some similar 
package to do the integer math.
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 8
\&        Zeros
\&        Ones
\&        V4mask
\&        V4net
\&        :aton           DEPRECATED
\&        :old_nth
\&        :upper
\&        :lower
.Ve
.SH "AUTHORS"
.IX Header "AUTHORS"
Luis E. Mun\*~oz <luismunoz@cpan.org>,
Michael Robinton <michael@bizsystems.com>
.SH "WARRANTY"
.IX Header "WARRANTY"
This software comes with the  same warranty as perl itself (ie, none),
so by using it you accept any and all the liability.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
.Vb 2
\& This software is (c) Luis E. Mun\*~oz, 1999 \- 2005
\& and (c) Michael Robinton, 2006 \- 2014.
.Ve
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Util\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
                                                                                                                                                                                                                                   osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Util.3pm                        0100644 0001750 0001750 00000056763 12566242045 024300  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Util \-\- IPv4/6 and 128 bit number utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Util qw(
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        AF_INET
\&        AF_INET6
\&        naip_gethostbyname
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :inet   =>    inet_aton, inet_ntoa, ipv6_aton
\&                ipv6_ntoa, ipv6_n2x, ipv6_n2d, 
\&                inet_any2n, inet_n2dx, inet_n2ad, 
\&                inet_pton, inet_ntop, inet_4map6, 
\&                ipv4to6, mask4to6, ipanyto6, packzeros
\&                maskanyto6, ipv6to4, naip_gethostbyname
\&
\&  :ipv4   =>    inet_aton, inet_ntoa
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa, ipv6_n2x, 
\&                ipv6_n2d, inet_any2n, inet_n2dx, 
\&                inet_n2ad, inet_pton, inet_ntop,
\&                inet_4map6, ipv4to6, mask4to6,
\&                ipanyto6, maskanyto6, ipv6to4,
\&                packzeros, naip_gethostbyname
\&
\&  :math   =>    hasbits, isIPv4, isNewIPv4, isAnyIPv4,
\&                addconst, add128, sub128, notcontiguous,
\&                bin2bcd, bcd2bin, shiftleft
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipvt_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $hex_text = packzeros($hex_text);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
\&  $rv = hasbits($bits128);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$hex_text);
\&  $hex_text = inet_ntop($AF_family,$netaddr);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
\&  $modetext = mode;
\&  ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
\&  $trueif = havegethostbyname2();
\&
\&  NetAddr::IP::Util::lower();
\&  NetAddr::IP::Util::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Util\fR installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::Util\fR provides a suite of tools for manipulating and
converting IPv4 and IPv6 addresses into 128 bit string context and back to
text. The strings can be manipulated with Perl's logical operators:
.PP
.Vb 4
\&        and     &
\&        or      |
\&        xor     ^
\&                ~       compliment
.Ve
.PP
in the same manner as 'vec' strings.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6_text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_4map6($netaddr or \f(CW$ipv6naddr\fR
.Sp
This function returns an ipV6 network address with the first 80 bits
set to zero and the next 16 bits set to one, while the last 32 bits
are filled with the ipV4 address.
.Sp
.Vb 3
\&  input:        ipV4 netaddr
\&            or  ipV6 netaddr
\&  returns:      ipV6 netaddr
\&
\&  returns: undef on error
.Ve
.Sp
An ipV6 network address must be in one of the two compatible ipV4
mapped address spaces. i.e.
.Sp
.Vb 1
\&        ::ffff::d.d.d.d    or    ::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$hex_text);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY \s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an IPv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 network address/mask into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: a single shift is performed
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2 +1\s0 to the \s-1ARG1.\s0 It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr number
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.IP "\(bu" 4
\&\f(CW$modetext\fR = mode;
.Sp
Returns the operating mode of this module.
.Sp
.Vb 3
\&        input:          none
\&        returns:        "Pure Perl"
\&                   or   "CC XS"
.Ve
.IP "\(bu" 4
($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(\s-1NAME\s0);
.Sp
Replacement for Perl's gethostbyname if Socket6 is available
.Sp
In \s-1ARRAY\s0 context, returns a list of five elements, the hostname or \s-1NAME,\s0
a space separated list of C_NAMES, \s-1AF\s0 family, length of the address
structure, and an array of one or more netaddr's
.Sp
In \s-1SCALAR\s0 context, returns the first netaddr.
.Sp
This function \s-1ALWAYS\s0 returns an IPv6 address, even on IPv4 only systems.
IPv4 addresses are mapped into IPv6 space in the form:
.Sp
.Vb 1
\&        ::FFFF:FFFF:d.d.d.d
.Ve
.Sp
This is \s-1NOT\s0 the expected result from Perl's gethostbyname2. It is instead equivalent to:
.Sp
.Vb 2
\&  On an IPv4 only system:
\&    $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
\&
\&  On a system with Socket6 and a working gethostbyname2:
\&    $ipv6naddr = gethostbyname2( name, AF_INET6 );
\&  and if that fails, the IPv4 conversion above.
.Ve
.Sp
For a gethostbyname2 emulator that behave like Socket6, see:
Net::DNS::Dig
.IP "\(bu" 4
\&\f(CW$trueif\fR = \fIhavegethostbyname2()\fR;
.Sp
This function returns \s-1TRUE\s0 if Socket6 has a functioning \fBgethostbyname2\fR,
otherwise it returns \s-1FALSE.\s0 See the comments above about the behavior of
\&\fBnaip_gethostbyname\fR.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::lower()\fR;
.Sp
Return IPv6 strings in lowercase.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::upper()\fR;
.Sp
Return IPv6 strings in uppercase.  This is the default.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\&  # convert any textual IP address into a 128 bit vector
\&  #
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    unless (hasbits($mask & $notiv4)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&  ... alternate implementation, a little faster
\&
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    if (isIPv4($mask)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&
\&  ... elsewhere
\&    $nip = {
\&        addr    => $vecip,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&
\&  # return network and broadcast addresses from IP and Mask
\&  #
\&  sub netbroad {
\&    my($nip) = shift;
\&    my $notmask = ~ $nip\->{mask};
\&    my $bcast   = $nip\->{addr} | $notmask;
\&    my $network = $nip\->{addr} & $nip\->{mask};
\&    return ($network, $broadcast);
\&  }
\&
\&  # check if address is within a network
\&  #
\&  sub within {
\&    my($nip,$net) = @_;
\&    my $addr = $nip\->{addr}
\&    my($nw,$bc) = netbroad($net);
\&  # arg1 >= arg2, sub128 returns true
\&    return (sub128($addr,$nw) && sub128($bc,$addr))
\&        ? 1 : 0;
\&  }
\&
\&  # truely hard way to do $ip++
\&  # add a constant, wrapping at netblock boundaries
\&  # to subtract the constant, negate it before calling
\&  # \*(Aqaddwrap\*(Aq since \*(Aqaddconst\*(Aq will extend the sign bits
\&  #
\&  sub addwrap {
\&    my($nip,$const) = @_;
\&    my $addr    = $nip\->{addr};
\&    my $mask    = $nip\->{mask};
\&    my $bits    = $nip\->{bits};
\&    my $notmask = ~ $mask;
\&    my $hibits  = $addr & $mask;
\&    $addr = addconst($addr,$const);
\&    my $wraponly = $addr & $notmask;
\&    my $newip = {
\&        addr    => $hibits | $wraponly,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&    # bless $newip as appropriate
\&    return $newip;
\&  }
\&
\&  # something more useful
\&  # increment a /24 net to the NEXT net at the boundry
\&
\&  my $nextnet = 256;    # for /24
\&  LOOP:
\&  while (...continuing) {
\&    your code....
\&    ...
\&    my $lastip = $ip\-copy();
\&    $ip++;
\&    if ($ip < $lastip) {        # host part wrapped?
\&  # discard carry
\&      (undef, $ip\->{addr} = addconst($ip\->{addr}, $nextnet);
\&    }
\&    next LOOP;
\&  }
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        naip_gethostbyname
\&        havegethostbyname2
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2014, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Util5.16.3pm                    0100644 0001750 0001750 00000056505 12566242057 024607  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2012-10-02" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Util \-\- IPv4/6 and 128 bit number utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Util qw(
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        AF_INET
\&        AF_INET6
\&        naip_gethostbyname
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :inet   =>    inet_aton, inet_ntoa, ipv6_aton
\&                ipv6_ntoa, ipv6_n2x, ipv6_n2d, 
\&                inet_any2n, inet_n2dx, inet_n2ad, 
\&                inet_pton, inet_ntop, inet_4map6, 
\&                ipv4to6, mask4to6, ipanyto6, packzeros
\&                maskanyto6, ipv6to4, naip_gethostbyname
\&
\&  :ipv4   =>    inet_aton, inet_ntoa
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa, ipv6_n2x, 
\&                ipv6_n2d, inet_any2n, inet_n2dx, 
\&                inet_n2ad, inet_pton, inet_ntop,
\&                inet_4map6, ipv4to6, mask4to6,
\&                ipanyto6, maskanyto6, ipv6to4,
\&                packzeros, naip_gethostbyname
\&
\&  :math   =>    hasbits, isIPv4, isNewIPv4, isAnyIPv4,
\&                addconst, add128, sub128, notcontiguous,
\&                bin2bcd, bcd2bin, shiftleft
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipvt_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $hex_text = packzeros($hex_text);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
\&  $rv = hasbits($bits128);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$hex_text);
\&  $hex_text = inet_ntop($AF_family,$netaddr);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
\&  $modetext = mode;
\&  ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
\&  $trueif = havegethostbyname2();
\&
\&  NetAddr::IP::Util::lower();
\&  NetAddr::IP::Util::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Util\fR installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::Util\fR provides a suite of tools for manipulating and
converting IPv4 and IPv6 addresses into 128 bit string context and back to
text. The strings can be manipulated with Perl's logical operators:
.PP
.Vb 4
\&        and     &
\&        or      |
\&        xor     ^
\&                ~       compliment
.Ve
.PP
in the same manner as 'vec' strings.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6_text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_4map6($netaddr or \f(CW$ipv6naddr\fR
.Sp
This function returns an ipV6 network address with the first 80 bits
set to zero and the next 16 bits set to one, while the last 32 bits
are filled with the ipV4 address.
.Sp
.Vb 3
\&  input:        ipV4 netaddr
\&            or  ipV6 netaddr
\&  returns:      ipV6 netaddr
\&
\&  returns: undef on error
.Ve
.Sp
An ipV6 network address must be in one of the two compatible ipV4
mapped address spaces. i.e.
.Sp
.Vb 1
\&        ::ffff::d.d.d.d    or    ::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$hex_text);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0 
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an IPv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 network address/mask into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: a single shift is performed
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2\s0 +1 to the \s-1ARG1\s0. It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr number
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.IP "\(bu" 4
\&\f(CW$modetext\fR = mode;
.Sp
Returns the operating mode of this module.
.Sp
.Vb 3
\&        input:          none
\&        returns:        "Pure Perl"
\&                   or   "CC XS"
.Ve
.IP "\(bu" 4
($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(\s-1NAME\s0);
.Sp
Replacement for Perl's gethostbyname if Socket6 is available
.Sp
In \s-1ARRAY\s0 context, returns a list of five elements, the hostname or \s-1NAME\s0,
a space separated list of C_NAMES, \s-1AF\s0 family, length of the address
structure, and an array of one or more netaddr's
.Sp
In \s-1SCALAR\s0 context, returns the first netaddr.
.Sp
This function \s-1ALWAYS\s0 returns an IPv6 address, even on IPv4 only systems.
IPv4 addresses are mapped into IPv6 space in the form:
.Sp
.Vb 1
\&        ::FFFF:FFFF:d.d.d.d
.Ve
.Sp
This is \s-1NOT\s0 the expected result from Perl's gethostbyname2. It is instead equivalent to:
.Sp
.Vb 2
\&  On an IPv4 only system:
\&    $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
\&
\&  On a system with Socket6 and a working gethostbyname2:
\&    $ipv6naddr = gethostbyname2( name, AF_INET6 );
\&  and if that fails, the IPv4 conversion above.
.Ve
.Sp
For a gethostbyname2 emulator that behave like Socket6, see:
Net::DNS::Dig
.IP "\(bu" 4
\&\f(CW$trueif\fR = \fIhavegethostbyname2()\fR;
.Sp
This function returns \s-1TRUE\s0 if Socket6 has a functioning \fBgethostbyname2\fR,
otherwise it returns \s-1FALSE\s0. See the comments above about the behavior of
\&\fBnaip_gethostbyname\fR.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::lower()\fR;
.Sp
Return IPv6 strings in lowercase.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::upper()\fR;
.Sp
Return IPv6 strings in uppercase.  This is the default.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\&  # convert any textual IP address into a 128 bit vector
\&  #
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    unless (hasbits($mask & $notiv4)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&  ... alternate implementation, a little faster
\&
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    if (isIPv4($mask)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&
\&  ... elsewhere
\&    $nip = {
\&        addr    => $vecip,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&
\&  # return network and broadcast addresses from IP and Mask
\&  #
\&  sub netbroad {
\&    my($nip) = shift;
\&    my $notmask = ~ $nip\->{mask};
\&    my $bcast   = $nip\->{addr} | $notmask;
\&    my $network = $nip\->{addr} & $nip\->{mask};
\&    return ($network, $broadcast);
\&  }
\&
\&  # check if address is within a network
\&  #
\&  sub within {
\&    my($nip,$net) = @_;
\&    my $addr = $nip\->{addr}
\&    my($nw,$bc) = netbroad($net);
\&  # arg1 >= arg2, sub128 returns true
\&    return (sub128($addr,$nw) && sub128($bc,$addr))
\&        ? 1 : 0;
\&  }
\&
\&  # truely hard way to do $ip++
\&  # add a constant, wrapping at netblock boundaries
\&  # to subtract the constant, negate it before calling
\&  # \*(Aqaddwrap\*(Aq since \*(Aqaddconst\*(Aq will extend the sign bits
\&  #
\&  sub addwrap {
\&    my($nip,$const) = @_;
\&    my $addr    = $nip\->{addr};
\&    my $mask    = $nip\->{mask};
\&    my $bits    = $nip\->{bits};
\&    my $notmask = ~ $mask;
\&    my $hibits  = $addr & $mask;
\&    $addr = addconst($addr,$const);
\&    my $wraponly = $addr & $notmask;
\&    my $newip = {
\&        addr    => $hibits | $wraponly,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&    # bless $newip as appropriate
\&    return $newip;
\&  }
\&
\&  # something more useful
\&  # increment a /24 net to the NEXT net at the boundry
\&
\&  my $nextnet = 256;    # for /24
\&  LOOP:
\&  while (...continuing) {
\&    your code....
\&    ...
\&    my $lastip = $ip\-copy();
\&    $ip++;
\&    if ($ip < $lastip) {        # host part wrapped?
\&  # discard carry
\&      (undef, $ip\->{addr} = addconst($ip\->{addr}, $nextnet);
\&    }
\&    next LOOP;
\&  }
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        naip_gethostbyname
\&        havegethostbyname2
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::Util5.18.3pm                    0100644 0001750 0001750 00000056763 12566242045 024614  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Util 3"
.TH Util 3 "2014-01-27" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::Util \-\- IPv4/6 and 128 bit number utilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::Util qw(
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        AF_INET
\&        AF_INET6
\&        naip_gethostbyname
\&  );
\&
\&  use NetAddr::IP::Util qw(:all :inet :ipv4 :ipv6 :math)
\&
\&  :inet   =>    inet_aton, inet_ntoa, ipv6_aton
\&                ipv6_ntoa, ipv6_n2x, ipv6_n2d, 
\&                inet_any2n, inet_n2dx, inet_n2ad, 
\&                inet_pton, inet_ntop, inet_4map6, 
\&                ipv4to6, mask4to6, ipanyto6, packzeros
\&                maskanyto6, ipv6to4, naip_gethostbyname
\&
\&  :ipv4   =>    inet_aton, inet_ntoa
\&
\&  :ipv6   =>    ipv6_aton, ipv6_ntoa, ipv6_n2x, 
\&                ipv6_n2d, inet_any2n, inet_n2dx, 
\&                inet_n2ad, inet_pton, inet_ntop,
\&                inet_4map6, ipv4to6, mask4to6,
\&                ipanyto6, maskanyto6, ipv6to4,
\&                packzeros, naip_gethostbyname
\&
\&  :math   =>    hasbits, isIPv4, isNewIPv4, isAnyIPv4,
\&                addconst, add128, sub128, notcontiguous,
\&                bin2bcd, bcd2bin, shiftleft
\&
\&  $dotquad = inet_ntoa($netaddr);
\&  $netaddr = inet_aton($dotquad);
\&  $ipv6naddr = ipv6_aton($ipv6_text);
\&  $ipv6_text = ipvt_ntoa($ipv6naddr);
\&  $hex_text = ipv6_n2x($ipv6naddr);
\&  $dec_text = ipv6_n2d($ipv6naddr);
\&  $hex_text = packzeros($hex_text);
\&  $ipv6naddr = inet_any2n($dotquad or $ipv6_text);
\&  $ipv6naddr = inet_4map6($netaddr or $ipv6naddr);
\&  $rv = hasbits($bits128);
\&  $rv = isIPv4($bits128);
\&  $rv = isNewIPv4($bits128);
\&  $rv = isAnyIPv4($bits128);
\&  $dotquad or $hex_text = inet_n2dx($ipv6naddr);
\&  $dotquad or $dec_text = inet_n2ad($ipv6naddr);
\&  $netaddr = inet_pton($AF_family,$hex_text);
\&  $hex_text = inet_ntop($AF_family,$netaddr);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
\&  $modetext = mode;
\&  ($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(NAME);
\&  $trueif = havegethostbyname2();
\&
\&  NetAddr::IP::Util::lower();
\&  NetAddr::IP::Util::upper();
.Ve
.SH "INSTALLATION"
.IX Header "INSTALLATION"
Un-tar the distribution in an appropriate directory and type:
.PP
.Vb 4
\&        perl Makefile.PL
\&        make
\&        make test
\&        make install
.Ve
.PP
\&\fBNetAddr::IP::Util\fR installs by default with its primary functions compiled
using Perl's \s-1XS\s0 extensions to build a 'C' library. If you do not have a 'C'
complier available or would like the slower Pure Perl version for some other
reason, then type:
.PP
.Vb 4
\&        perl Makefile.PL \-noxs
\&        make
\&        make test
\&        make install
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::Util\fR provides a suite of tools for manipulating and
converting IPv4 and IPv6 addresses into 128 bit string context and back to
text. The strings can be manipulated with Perl's logical operators:
.PP
.Vb 4
\&        and     &
\&        or      |
\&        xor     ^
\&                ~       compliment
.Ve
.PP
in the same manner as 'vec' strings.
.PP
The IPv6 functions support all rfc1884 formats.
.PP
.Vb 5
\&  i.e.  x:x:x:x:x:x:x:x:x
\&        x:x:x:x:x:x:x:d.d.d.d
\&        ::x:x:x
\&        ::x:d.d.d.d
\&  and so on...
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR = inet_ntoa($netaddr);
.Sp
Convert a packed IPv4 network address to a dot-quad \s-1IP\s0 address.
.Sp
.Vb 2
\&  input:        packed network address
\&  returns:      IP address i.e. 10.4.12.123
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_aton($dotquad);
.Sp
Convert a dot-quad \s-1IP\s0 address into an IPv4 packed network address.
.Sp
.Vb 2
\&  input:        IP address i.e. 192.5.16.32
\&  returns:      packed network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6addr\fR = ipv6_aton($ipv6_text);
.Sp
Takes an IPv6 address of the form described in rfc1884
and returns a 128 bit binary \s-1RDATA\s0 string.
.Sp
.Vb 2
\&  input:        ipv6 text
\&  returns:      128 bit RDATA string
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6_text\fR = ipv6_ntoa($ipv6naddr);
.Sp
Convert a 128 bit binary IPv6 address to compressed rfc 1884
text representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      ipv6 text
.Ve
.IP "\(bu" 4
\&\f(CW$hex_text\fR = ipv6_n2x($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns an 8 segment IPv6 hex address
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dec_text\fR = ipv6_n2d($ipv6addr);
.Sp
Takes an IPv6 \s-1RDATA\s0 string and returns a mixed hex \- decimal IPv6 address
with the 6 uppermost chunks in hex and the lower 32 bits in dot-quad
representation.
.Sp
.Vb 2
\&  input:        128 bit RDATA string
\&  returns:      x:x:x:x:x:x:d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_any2n($dotquad or \f(CW$ipv6_text\fR);
.Sp
This function converts a text IPv4 or IPv6 address in text format in any
standard notation into a 128 bit IPv6 string address. It prefixes any
dot-quad address (if found) with '::' and passes it to \fBipv6_aton\fR.
.Sp
.Vb 2
\&  input:        dot\-quad or rfc1844 address
\&  returns:      128 bit IPv6 string
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = inet_4map6($netaddr or \f(CW$ipv6naddr\fR
.Sp
This function returns an ipV6 network address with the first 80 bits
set to zero and the next 16 bits set to one, while the last 32 bits
are filled with the ipV4 address.
.Sp
.Vb 3
\&  input:        ipV4 netaddr
\&            or  ipV6 netaddr
\&  returns:      ipV6 netaddr
\&
\&  returns: undef on error
.Ve
.Sp
An ipV6 network address must be in one of the two compatible ipV4
mapped address spaces. i.e.
.Sp
.Vb 1
\&        ::ffff::d.d.d.d    or    ::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isIPv4($bits128);
.Sp
This function returns true if there are no on bits present in the IPv6
portion of the 128 bit string and false otherwise.
.Sp
.Vb 1
\&  i.e.  the address must be of the form \- ::d.d.d.d
.Ve
.Sp
Note: this is an old and deprecated ipV4 compatible ipV6 address
.IP "\(bu" 4
\&\f(CW$rv\fR = isNewIPv4($bits128);
.Sp
This function return true if the IPv6 128 bit string is of the form
.Sp
.Vb 1
\&        ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$rv\fR = isAnyIPv4($bits128);
.Sp
This function return true if the IPv6 bit string is of the form
.Sp
.Vb 1
\&        ::d.d.d.d       or      ::ffff::d.d.d.d
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$hex_text\fR = inet_n2dx($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:x:x
.Ve
.IP "\(bu" 4
\&\f(CW$dotquad\fR or \f(CW$dec_text\fR = inet_n2ad($ipv6naddr);
.Sp
This function \fBdoes the right thing\fR and returns the text for either a
dot-quad IPv4 or a hex::decimal notation IPv6 address.
.Sp
.Vb 3
\&  input:        128 bit IPv6 string
\&  returns:      ddd.ddd.ddd.ddd
\&            or  x:x:x:x:x:x:ddd.ddd.ddd.dd
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = inet_pton($AF_family,$hex_text);
.Sp
This function takes an \s-1IP\s0 address in IPv4 or IPv6 text format and converts it into
binary format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY\s0
argument.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = inet_ntop($AF_family,$netaddr);
.Sp
This function takes and \s-1IP\s0 address in binary format and converts it into
text format. The type of \s-1IP\s0 address conversion is controlled by the \s-1FAMILY \s0
argument.
.Sp
\&\s-1NOTE:\s0 inet_ntop \s-1ALWAYS\s0 returns lowercase characters.
.IP "\(bu" 4
\&\f(CW$hex_text\fR = packzeros($hex_text);
.Sp
This function optimizes and rfc 1884 IPv6 hex address to reduce the number of
long strings of zero bits as specified in rfc 1884, 2.2 (2) by substituting
\&\fB::\fR for the first occurence of the longest string of zeros in the address.
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an IPv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 network address/mask into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: a single shift is performed
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2 +1\s0 to the \s-1ARG1.\s0 It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr number
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.IP "\(bu" 4
\&\f(CW$modetext\fR = mode;
.Sp
Returns the operating mode of this module.
.Sp
.Vb 3
\&        input:          none
\&        returns:        "Pure Perl"
\&                   or   "CC XS"
.Ve
.IP "\(bu" 4
($name,$aliases,$addrtype,$length,@addrs)=naip_gethostbyname(\s-1NAME\s0);
.Sp
Replacement for Perl's gethostbyname if Socket6 is available
.Sp
In \s-1ARRAY\s0 context, returns a list of five elements, the hostname or \s-1NAME,\s0
a space separated list of C_NAMES, \s-1AF\s0 family, length of the address
structure, and an array of one or more netaddr's
.Sp
In \s-1SCALAR\s0 context, returns the first netaddr.
.Sp
This function \s-1ALWAYS\s0 returns an IPv6 address, even on IPv4 only systems.
IPv4 addresses are mapped into IPv6 space in the form:
.Sp
.Vb 1
\&        ::FFFF:FFFF:d.d.d.d
.Ve
.Sp
This is \s-1NOT\s0 the expected result from Perl's gethostbyname2. It is instead equivalent to:
.Sp
.Vb 2
\&  On an IPv4 only system:
\&    $ipv6naddr = ipv4to6 scalar ( gethostbyname( name ));
\&
\&  On a system with Socket6 and a working gethostbyname2:
\&    $ipv6naddr = gethostbyname2( name, AF_INET6 );
\&  and if that fails, the IPv4 conversion above.
.Ve
.Sp
For a gethostbyname2 emulator that behave like Socket6, see:
Net::DNS::Dig
.IP "\(bu" 4
\&\f(CW$trueif\fR = \fIhavegethostbyname2()\fR;
.Sp
This function returns \s-1TRUE\s0 if Socket6 has a functioning \fBgethostbyname2\fR,
otherwise it returns \s-1FALSE.\s0 See the comments above about the behavior of
\&\fBnaip_gethostbyname\fR.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::lower()\fR;
.Sp
Return IPv6 strings in lowercase.
.IP "\(bu" 4
\&\fINetAddr::IP::Util::upper()\fR;
.Sp
Return IPv6 strings in uppercase.  This is the default.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
.Vb 4
\&  # convert any textual IP address into a 128 bit vector
\&  #
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    unless (hasbits($mask & $notiv4)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&  ... alternate implementation, a little faster
\&
\&  sub text2vec {
\&    my($anyIP,$anyMask) = @_;
\&
\&  # not IPv4 bit mask
\&    my $notiv4 = ipv6_aton(\*(AqFFFF:FFFF:FFFF:FFFF:FFFF:FFFF::\*(Aq);
\&
\&    my $vecip   = inet_any2n($anyIP);
\&    my $mask    = inet_any2n($anyMask);
\&
\&  # extend mask bits for IPv4
\&    my $bits = 128;     # default
\&    if (isIPv4($mask)) {
\&      $mask |= $notiv4;
\&      $bits = 32;
\&    }
\&    return ($vecip, $mask, $bits);
\&  }
\&
\&
\&  ... elsewhere
\&    $nip = {
\&        addr    => $vecip,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&
\&  # return network and broadcast addresses from IP and Mask
\&  #
\&  sub netbroad {
\&    my($nip) = shift;
\&    my $notmask = ~ $nip\->{mask};
\&    my $bcast   = $nip\->{addr} | $notmask;
\&    my $network = $nip\->{addr} & $nip\->{mask};
\&    return ($network, $broadcast);
\&  }
\&
\&  # check if address is within a network
\&  #
\&  sub within {
\&    my($nip,$net) = @_;
\&    my $addr = $nip\->{addr}
\&    my($nw,$bc) = netbroad($net);
\&  # arg1 >= arg2, sub128 returns true
\&    return (sub128($addr,$nw) && sub128($bc,$addr))
\&        ? 1 : 0;
\&  }
\&
\&  # truely hard way to do $ip++
\&  # add a constant, wrapping at netblock boundaries
\&  # to subtract the constant, negate it before calling
\&  # \*(Aqaddwrap\*(Aq since \*(Aqaddconst\*(Aq will extend the sign bits
\&  #
\&  sub addwrap {
\&    my($nip,$const) = @_;
\&    my $addr    = $nip\->{addr};
\&    my $mask    = $nip\->{mask};
\&    my $bits    = $nip\->{bits};
\&    my $notmask = ~ $mask;
\&    my $hibits  = $addr & $mask;
\&    $addr = addconst($addr,$const);
\&    my $wraponly = $addr & $notmask;
\&    my $newip = {
\&        addr    => $hibits | $wraponly,
\&        mask    => $mask,
\&        bits    => $bits,
\&    };
\&    # bless $newip as appropriate
\&    return $newip;
\&  }
\&
\&  # something more useful
\&  # increment a /24 net to the NEXT net at the boundry
\&
\&  my $nextnet = 256;    # for /24
\&  LOOP:
\&  while (...continuing) {
\&    your code....
\&    ...
\&    my $lastip = $ip\-copy();
\&    $ip++;
\&    if ($ip < $lastip) {        # host part wrapped?
\&  # discard carry
\&      (undef, $ip\->{addr} = addconst($ip\->{addr}, $nextnet);
\&    }
\&    next LOOP;
\&  }
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        inet_aton
\&        inet_ntoa
\&        ipv6_aton
\&        ipv6_ntoa
\&        ipv6_n2x
\&        ipv6_n2d
\&        inet_any2n
\&        hasbits
\&        isIPv4
\&        isNewIPv4
\&        isAnyIPv4
\&        inet_n2dx
\&        inet_n2ad
\&        inet_pton
\&        inet_ntop
\&        inet_4map6
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        packzeros
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        bin2bcd
\&        bcd2bin
\&        mode
\&        naip_gethostbyname
\&        havegethostbyname2
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2014, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA.
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fINetAddr::IP\fR\|(3), \fINetAddr::IP::Lite\fR\|(3), \fINetAddr::IP::InetBase\fR\|(3)
             osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::UtilPP.3pm                      0100644 0001750 0001750 00000026051 12566242045 024523  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::UtilPP 3"
.TH NetAddr::IP::UtilPP 3 "2012-08-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::UtilPP \-\- pure Perl functions for NetAddr::IP::Util
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::UtilPP qw(
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&  );
\&
\&  use NetAddr::IP::UtilPP qw(:all)
\&
\&  $rv = hasbits($bits128);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::UtilPP\fR provides pure Perl functions for \fBNetAddr::IP::Util\fR
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: input bits are returned
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2 +1\s0 to the \s-1ARG1.\s0 It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 netowrk address into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&        comp128
\&        bin2bcdn
\&        bcdn2txt
\&        bcdn2bin
\&        simple_pack
\&        threads
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::UtilPP5.16.3pm                  0100644 0001750 0001750 00000025573 12566242057 025050  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::UtilPP 3"
.TH NetAddr::IP::UtilPP 3 "2012-08-10" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::UtilPP \-\- pure Perl functions for NetAddr::IP::Util
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::UtilPP qw(
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&  );
\&
\&  use NetAddr::IP::UtilPP qw(:all)
\&
\&  $rv = hasbits($bits128);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::UtilPP\fR provides pure Perl functions for \fBNetAddr::IP::Util\fR
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: input bits are returned
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2\s0 +1 to the \s-1ARG1\s0. It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 netowrk address into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&        comp128
\&        bin2bcdn
\&        bcdn2txt
\&        bcdn2bin
\&        simple_pack
\&        threads
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT\s0 \s-1ANY\s0 \s-1WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS\s0 \s-1FOR\s0 A \s-1PARTICULAR\s0 \s-1PURPOSE\s0.  See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/NetAddr::IP::UtilPP5.18.3pm                  0100644 0001750 0001750 00000026051 12566242045 025037  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "NetAddr::IP::UtilPP 3"
.TH NetAddr::IP::UtilPP 3 "2012-08-10" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
NetAddr::IP::UtilPP \-\- pure Perl functions for NetAddr::IP::Util
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 10
\&  use NetAddr::IP::UtilPP qw(
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&  );
\&
\&  use NetAddr::IP::UtilPP qw(:all)
\&
\&  $rv = hasbits($bits128);
\&  $bitsX2 = shiftleft($bits128,$n);
\&  $carry = addconst($ipv6naddr,$signed_32con);
\&  ($carry,$ipv6naddr)=addconst($ipv6naddr,$signed_32con);
\&  $carry = add128($ipv6naddr1,$ipv6naddr2);
\&  ($carry,$ipv6naddr)=add128($ipv6naddr1,$ipv6naddr2);
\&  $carry = sub128($ipv6naddr1,$ipv6naddr2);
\&  ($spurious,$cidr) = notcontiguous($mask128);
\&  ($carry,$ipv6naddr)=sub128($ipv6naddr1,$ipv6naddr2);
\&  $ipv6naddr = ipv4to6($netaddr);
\&  $ipv6naddr = mask4to6($netaddr);
\&  $ipv6naddr = ipanyto6($netaddr);
\&  $ipv6naddr = maskanyto6($netaddr);
\&  $netaddr = ipv6to4($pv6naddr);
\&  $bcdtext = bin2bcd($bits128);
\&  $bits128 = bcd2bin($bcdtxt);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fBNetAddr::IP::UtilPP\fR provides pure Perl functions for \fBNetAddr::IP::Util\fR
.IP "\(bu" 4
\&\f(CW$rv\fR = hasbits($bits128);
.Sp
This function returns true if there are one's present in the 128 bit string
and false if all the bits are zero.
.Sp
.Vb 3
\&  i.e.  if (hasbits($bits128)) {
\&          &do_something;
\&        }
\&
\&  or    if (hasbits($bits128 & $mask128) {
\&          &do_something;
\&        }
.Ve
.Sp
This allows the implementation of logical functions of the form of:
.Sp
.Vb 2
\&        if ($bits128 & $mask128) {
\&            ...
\&
\&  input:        128 bit IPv6 string
\&  returns:      true if any bits are present
.Ve
.IP "\(bu" 4
\&\f(CW$bitsXn\fR = shiftleft($bits128,$n);
.Sp
.Vb 3
\&  input:        128 bit string variable,
\&                number of shifts [optional]
\&  returns:      bits X n shifts
\&
\&  NOTE: input bits are returned
\&        if $n is not specified
.Ve
.IP "\(bu" 4
addconst($ipv6naddr,$signed_32con);
.Sp
Add a signed constant to a 128 bit string variable.
.Sp
.Vb 4
\&  input:        128 bit IPv6 string,
\&                signed 32 bit integer
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
add128($ipv6naddr1,$ipv6naddr2);
.Sp
Add two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.IP "\(bu" 4
sub128($ipv6naddr1,$ipv6naddr2);
.Sp
Subtract two 128 bit string variables.
.Sp
.Vb 4
\&  input:        128 bit string var1,
\&                128 bit string var2
\&  returns:  scalar      carry
\&            array       (carry, result)
.Ve
.Sp
Note: The carry from this operation is the result of adding the one's
complement of \s-1ARG2 +1\s0 to the \s-1ARG1.\s0 It is logically
\&\fB\s-1NOT\s0 borrow\fR.
.Sp
.Vb 2
\&        i.e.    if ARG1 >= ARG2 then carry = 1
\&        or      if ARG1  < ARG2 then carry = 0
.Ve
.IP "\(bu" 4
($spurious,$cidr) = notcontiguous($mask128);
.Sp
This function counts the bit positions remaining in the mask when the
rightmost '0's are removed.
.Sp
.Vb 6
\&        input:  128 bit netmask
\&        returns true if there are spurious
\&                    zero bits remaining in the
\&                    mask, false if the mask is
\&                    contiguous one\*(Aqs,
\&                128 bit cidr
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipv4to6($netaddr);
.Sp
Convert an ipv4 network address into an ipv6 network address.
.Sp
.Vb 2
\&  input:        32 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = mask4to6($netaddr);
.Sp
Convert an ipv4 netowrk address into an ipv6 network mask.
.Sp
.Vb 2
\&  input:        32 bit network/mask address
\&  returns:      128 bit network/mask address
.Ve
.Sp
\&\s-1NOTE:\s0 returns the high 96 bits as one's
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = ipanyto6($netaddr);
.Sp
Similar to ipv4to6 except that this function takes either an IPv4 or IPv6
input and always returns a 128 bit IPv6 network address.
.Sp
.Vb 2
\&  input:        32 or 128 bit network address
\&  returns:      128 bit network address
.Ve
.IP "\(bu" 4
\&\f(CW$ipv6naddr\fR = maskanyto6($netaddr);
.Sp
Similar to mask4to6 except that this function takes either an IPv4 or IPv6
netmask and always returns a 128 bit IPv6 netmask.
.Sp
.Vb 2
\&  input:        32 or 128 bit network mask
\&  returns:      128 bit network mask
.Ve
.IP "\(bu" 4
\&\f(CW$netaddr\fR = ipv6to4($pv6naddr);
.Sp
Truncate the upper 96 bits of a 128 bit address and return the lower
32 bits. Returns an IPv4 address as returned by inet_aton.
.Sp
.Vb 2
\&  input:        128 bit network address
\&  returns:      32 bit inet_aton network address
.Ve
.IP "\(bu" 4
\&\f(CW$bcdtext\fR = bin2bcd($bits128);
.Sp
Convert a 128 bit binary string into binary coded decimal text digits.
.Sp
.Vb 2
\&  input:        128 bit string variable
\&  returns:      string of bcd text digits
.Ve
.IP "\(bu" 4
\&\f(CW$bits128\fR = bcd2bin($bcdtxt);
.Sp
Convert a bcd text string to 128 bit string variable
.Sp
.Vb 2
\&  input:        string of bcd text digits
\&  returns:      128 bit string variable
.Ve
.SH "EXPORT_OK"
.IX Header "EXPORT_OK"
.Vb 10
\&        hasbits
\&        shiftleft
\&        addconst
\&        add128
\&        sub128
\&        notcontiguous
\&        ipv4to6
\&        mask4to6
\&        ipanyto6
\&        maskanyto6
\&        ipv6to4
\&        bin2bcd
\&        bcd2bin
\&        comp128
\&        bin2bcdn
\&        bcdn2txt
\&        bcdn2bin
\&        simple_pack
\&        threads
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2003 \- 2012, Michael Robinton <michael@bizsystems.com>
.PP
All rights reserved.
.PP
This program is free software; you can redistribute it and/or modify
it under the terms of either:
.PP
.Vb 3
\&  a) the GNU General Public License as published by the Free
\&  Software Foundation; either version 2, or (at your option) any
\&  later version, or
\&
\&  b) the "Artistic License" which comes with this distribution.
.Ve
.PP
This program is distributed in the hope that it will be useful,
but \s-1WITHOUT ANY WARRANTY\s0; without even the implied warranty of
\&\s-1MERCHANTABILITY\s0 or \s-1FITNESS FOR A PARTICULAR PURPOSE. \s0 See either
the \s-1GNU\s0 General Public License or the Artistic License for more details.
.PP
You should have received a copy of the Artistic License with this
distribution, in the file named \*(L"Artistic\*(R".  If not, I'll be glad to provide
one.
.PP
You should also have received a copy of the \s-1GNU\s0 General Public License
along with this program in the file named \*(L"Copying\*(R". If not, write to the
.PP
.Vb 3
\&        Free Software Foundation, Inc.,
\&        51 Franklin Street, Fifth Floor
\&        Boston, MA 02110\-1301 USA
.Ve
.PP
or visit their web page on the internet at:
.PP
.Vb 1
\&        http://www.gnu.org/copyleft/gpl.html.
.Ve
.SH "AUTHOR"
.IX Header "AUTHOR"
Michael Robinton <michael@bizsystems.com>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Number::Compare.3pm                          0100644 0001750 0001750 00000013366 12566242335 024235  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Number::Compare 3"
.TH Number::Compare 3 "2011-09-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Number::Compare \- numeric comparisons
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& Number::Compare\->new(">1Ki")\->test(1025); # is 1025 > 1024
\&
\& my $c = Number::Compare\->new(">1M");
\& $c\->(1_200_000);                          # slightly terser invocation
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Number::Compare compiles a simple comparison to an anonymous
subroutine, which you can call with a value to be tested again.
.PP
Now this would be very pointless, if Number::Compare didn't understand
magnitudes.
.PP
The target value may use magnitudes of kilobytes (\f(CW\*(C`k\*(C'\fR, \f(CW\*(C`ki\*(C'\fR),
megabytes (\f(CW\*(C`m\*(C'\fR, \f(CW\*(C`mi\*(C'\fR), or gigabytes (\f(CW\*(C`g\*(C'\fR, \f(CW\*(C`gi\*(C'\fR).  Those suffixed
with an \f(CW\*(C`i\*(C'\fR use the appropriate 2**n version in accordance with the
\&\s-1IEC\s0 standard: http://physics.nist.gov/cuu/Units/binary.html
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "\->new( $test )"
.el .SS "\->new( \f(CW$test\fP )"
.IX Subsection "->new( $test )"
Returns a new object that compares the specified test.
.ie n .SS "\->test( $value )"
.el .SS "\->test( \f(CW$value\fP )"
.IX Subsection "->test( $value )"
A longhanded version of \f(CW$compare\fR\->( \f(CW$value\fR ).  Predates blessed
subroutine reference implementation.
.ie n .SS "\->parse_to_perl( $test )"
.el .SS "\->parse_to_perl( \f(CW$test\fP )"
.IX Subsection "->parse_to_perl( $test )"
Returns a perl code fragment equivalent to the test.
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Clamp <richardc@unixbeard.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://physics.nist.gov/cuu/Units/binary.html
                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Number::Compare5.16.3pm                      0100644 0001750 0001750 00000013045 12566242336 024542  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Number::Compare 3"
.TH Number::Compare 3 "2011-09-21" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Number::Compare \- numeric comparisons
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& Number::Compare\->new(">1Ki")\->test(1025); # is 1025 > 1024
\&
\& my $c = Number::Compare\->new(">1M");
\& $c\->(1_200_000);                          # slightly terser invocation
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Number::Compare compiles a simple comparison to an anonymous
subroutine, which you can call with a value to be tested again.
.PP
Now this would be very pointless, if Number::Compare didn't understand
magnitudes.
.PP
The target value may use magnitudes of kilobytes (\f(CW\*(C`k\*(C'\fR, \f(CW\*(C`ki\*(C'\fR),
megabytes (\f(CW\*(C`m\*(C'\fR, \f(CW\*(C`mi\*(C'\fR), or gigabytes (\f(CW\*(C`g\*(C'\fR, \f(CW\*(C`gi\*(C'\fR).  Those suffixed
with an \f(CW\*(C`i\*(C'\fR use the appropriate 2**n version in accordance with the
\&\s-1IEC\s0 standard: http://physics.nist.gov/cuu/Units/binary.html
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "\->new( $test )"
.el .SS "\->new( \f(CW$test\fP )"
.IX Subsection "->new( $test )"
Returns a new object that compares the specified test.
.ie n .SS "\->test( $value )"
.el .SS "\->test( \f(CW$value\fP )"
.IX Subsection "->test( $value )"
A longhanded version of \f(CW$compare\fR\->( \f(CW$value\fR ).  Predates blessed
subroutine reference implementation.
.ie n .SS "\->parse_to_perl( $test )"
.el .SS "\->parse_to_perl( \f(CW$test\fP )"
.IX Subsection "->parse_to_perl( $test )"
Returns a perl code fragment equivalent to the test.
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Clamp <richardc@unixbeard.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://physics.nist.gov/cuu/Units/binary.html
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Number::Compare5.18.3pm                      0100644 0001750 0001750 00000013366 12566242335 024551  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Number::Compare 3"
.TH Number::Compare 3 "2011-09-21" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Number::Compare \- numeric comparisons
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& Number::Compare\->new(">1Ki")\->test(1025); # is 1025 > 1024
\&
\& my $c = Number::Compare\->new(">1M");
\& $c\->(1_200_000);                          # slightly terser invocation
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Number::Compare compiles a simple comparison to an anonymous
subroutine, which you can call with a value to be tested again.
.PP
Now this would be very pointless, if Number::Compare didn't understand
magnitudes.
.PP
The target value may use magnitudes of kilobytes (\f(CW\*(C`k\*(C'\fR, \f(CW\*(C`ki\*(C'\fR),
megabytes (\f(CW\*(C`m\*(C'\fR, \f(CW\*(C`mi\*(C'\fR), or gigabytes (\f(CW\*(C`g\*(C'\fR, \f(CW\*(C`gi\*(C'\fR).  Those suffixed
with an \f(CW\*(C`i\*(C'\fR use the appropriate 2**n version in accordance with the
\&\s-1IEC\s0 standard: http://physics.nist.gov/cuu/Units/binary.html
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "\->new( $test )"
.el .SS "\->new( \f(CW$test\fP )"
.IX Subsection "->new( $test )"
Returns a new object that compares the specified test.
.ie n .SS "\->test( $value )"
.el .SS "\->test( \f(CW$value\fP )"
.IX Subsection "->test( $value )"
A longhanded version of \f(CW$compare\fR\->( \f(CW$value\fR ).  Predates blessed
subroutine reference implementation.
.ie n .SS "\->parse_to_perl( $test )"
.el .SS "\->parse_to_perl( \f(CW$test\fP )"
.IX Subsection "->parse_to_perl( $test )"
Returns a perl code fragment equivalent to the test.
.SH "AUTHOR"
.IX Header "AUTHOR"
Richard Clamp <richardc@unixbeard.net>
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2002,2011 Richard Clamp.  All Rights Reserved.
.PP
This module is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
http://physics.nist.gov/cuu/Units/binary.html
                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/O.3pm                                        0100644 0001750 0001750 00000016734 12566207461 021513  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "O 3pm"
.TH O 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
O \- Generic interface to Perl Compiler backends
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        perl \-MO=[\-q,]Backend[,OPTIONS] foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that is used as a frontend to the Perl Compiler.
.PP
If you pass the \f(CW\*(C`\-q\*(C'\fR option to the module, then the \s-1STDOUT\s0
filehandle will be redirected into the variable \f(CW$O::BEGIN_output\fR
during compilation.  This has the effect that any output printed
to \s-1STDOUT\s0 by \s-1BEGIN\s0 blocks or use'd modules will be stored in this
variable rather than printed. It's useful with those backends which
produce output themselves (\f(CW\*(C`Deparse\*(C'\fR, \f(CW\*(C`Concise\*(C'\fR etc), so that
their output is not confused with that generated by the code
being compiled.
.PP
The \f(CW\*(C`\-qq\*(C'\fR option behaves like \f(CW\*(C`\-q\*(C'\fR, except that it also closes
\&\s-1STDERR\s0 after deparsing has finished. This suppresses the \*(L"Syntax \s-1OK\*(R"\s0
message normally produced by perl.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
Most compiler backends use the following conventions: \s-1OPTIONS\s0
consists of a comma-separated list of words (no white-space).
The \f(CW\*(C`\-v\*(C'\fR option usually puts the backend into verbose mode.
The \f(CW\*(C`\-ofile\*(C'\fR option generates output to \fBfile\fR instead of
stdout. The \f(CW\*(C`\-D\*(C'\fR option followed by various letters turns on
various internal debugging flags. See the documentation for the
desired backend (named \f(CW\*(C`B::Backend\*(C'\fR for the example above) to
find out about that backend.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This section is only necessary for those who want to write a
compiler backend module that can be used via this module.
.PP
The command-line mentioned in the \s-1SYNOPSIS\s0 section corresponds to
the Perl code
.PP
.Vb 1
\&    use O ("Backend", OPTIONS);
.Ve
.PP
The \f(CW\*(C`O::import\*(C'\fR function loads the appropriate \f(CW\*(C`B::Backend\*(C'\fR module
and calls its \f(CW\*(C`compile\*(C'\fR function, passing it \s-1OPTIONS.\s0 That function
is expected to return a sub reference which we'll call \s-1CALLBACK.\s0 Next,
the \*(L"compile-only\*(R" flag is switched on (equivalent to the command-line
option \f(CW\*(C`\-c\*(C'\fR) and a \s-1CHECK\s0 block is registered which calls
\&\s-1CALLBACK.\s0 Thus the main Perl program mentioned on the command-line is
read in, parsed and compiled into internal syntax tree form. Since the
\&\f(CW\*(C`\-c\*(C'\fR flag is set, the program does not start running (excepting \s-1BEGIN\s0
blocks of course) but the \s-1CALLBACK\s0 function registered by the compiler
backend is called.
.PP
In summary, a compiler backend module should be called \*(L"B::Foo\*(R"
for some foo and live in the appropriate directory for that name.
It should define a function called \f(CW\*(C`compile\*(C'\fR. When the user types
.PP
.Vb 1
\&    perl \-MO=Foo,OPTIONS foo.pl
.Ve
.PP
that function is called and is passed those \s-1OPTIONS \s0(split on
commas). It should return a sub ref to the main compilation function.
After the user's program is loaded and parsed, that returned sub ref
is invoked which can then go ahead and do the compilation, usually by
making use of the \f(CW\*(C`B\*(C'\fR module's functionality.
.SH "BUGS"
.IX Header "BUGS"
The \f(CW\*(C`\-q\*(C'\fR and \f(CW\*(C`\-qq\*(C'\fR options don't work correctly if perl isn't
compiled with PerlIO support : \s-1STDOUT\s0 will be closed instead of being
redirected to \f(CW$O::BEGIN_output\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/O5.16.3pm                                    0100644 0001750 0001750 00000016413 12566207437 022022  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "O 3pm"
.TH O 3pm "2013-02-26" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
O \- Generic interface to Perl Compiler backends
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        perl \-MO=[\-q,]Backend[,OPTIONS] foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that is used as a frontend to the Perl Compiler.
.PP
If you pass the \f(CW\*(C`\-q\*(C'\fR option to the module, then the \s-1STDOUT\s0
filehandle will be redirected into the variable \f(CW$O::BEGIN_output\fR
during compilation.  This has the effect that any output printed
to \s-1STDOUT\s0 by \s-1BEGIN\s0 blocks or use'd modules will be stored in this
variable rather than printed. It's useful with those backends which
produce output themselves (\f(CW\*(C`Deparse\*(C'\fR, \f(CW\*(C`Concise\*(C'\fR etc), so that
their output is not confused with that generated by the code
being compiled.
.PP
The \f(CW\*(C`\-qq\*(C'\fR option behaves like \f(CW\*(C`\-q\*(C'\fR, except that it also closes
\&\s-1STDERR\s0 after deparsing has finished. This suppresses the \*(L"Syntax \s-1OK\s0\*(R"
message normally produced by perl.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
Most compiler backends use the following conventions: \s-1OPTIONS\s0
consists of a comma-separated list of words (no white-space).
The \f(CW\*(C`\-v\*(C'\fR option usually puts the backend into verbose mode.
The \f(CW\*(C`\-ofile\*(C'\fR option generates output to \fBfile\fR instead of
stdout. The \f(CW\*(C`\-D\*(C'\fR option followed by various letters turns on
various internal debugging flags. See the documentation for the
desired backend (named \f(CW\*(C`B::Backend\*(C'\fR for the example above) to
find out about that backend.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This section is only necessary for those who want to write a
compiler backend module that can be used via this module.
.PP
The command-line mentioned in the \s-1SYNOPSIS\s0 section corresponds to
the Perl code
.PP
.Vb 1
\&    use O ("Backend", OPTIONS);
.Ve
.PP
The \f(CW\*(C`O::import\*(C'\fR function loads the appropriate \f(CW\*(C`B::Backend\*(C'\fR module
and calls its \f(CW\*(C`compile\*(C'\fR function, passing it \s-1OPTIONS\s0. That function
is expected to return a sub reference which we'll call \s-1CALLBACK\s0. Next,
the \*(L"compile-only\*(R" flag is switched on (equivalent to the command-line
option \f(CW\*(C`\-c\*(C'\fR) and a \s-1CHECK\s0 block is registered which calls
\&\s-1CALLBACK\s0. Thus the main Perl program mentioned on the command-line is
read in, parsed and compiled into internal syntax tree form. Since the
\&\f(CW\*(C`\-c\*(C'\fR flag is set, the program does not start running (excepting \s-1BEGIN\s0
blocks of course) but the \s-1CALLBACK\s0 function registered by the compiler
backend is called.
.PP
In summary, a compiler backend module should be called \*(L"B::Foo\*(R"
for some foo and live in the appropriate directory for that name.
It should define a function called \f(CW\*(C`compile\*(C'\fR. When the user types
.PP
.Vb 1
\&    perl \-MO=Foo,OPTIONS foo.pl
.Ve
.PP
that function is called and is passed those \s-1OPTIONS\s0 (split on
commas). It should return a sub ref to the main compilation function.
After the user's program is loaded and parsed, that returned sub ref
is invoked which can then go ahead and do the compilation, usually by
making use of the \f(CW\*(C`B\*(C'\fR module's functionality.
.SH "BUGS"
.IX Header "BUGS"
The \f(CW\*(C`\-q\*(C'\fR and \f(CW\*(C`\-qq\*(C'\fR options don't work correctly if perl isn't
compiled with PerlIO support : \s-1STDOUT\s0 will be closed instead of being
redirected to \f(CW$O::BEGIN_output\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/O5.18.3pm                                    0100644 0001750 0001750 00000016734 12566207461 022027  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "O 3pm"
.TH O 3pm "2013-11-04" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
O \- Generic interface to Perl Compiler backends
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&        perl \-MO=[\-q,]Backend[,OPTIONS] foo.pl
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This is the module that is used as a frontend to the Perl Compiler.
.PP
If you pass the \f(CW\*(C`\-q\*(C'\fR option to the module, then the \s-1STDOUT\s0
filehandle will be redirected into the variable \f(CW$O::BEGIN_output\fR
during compilation.  This has the effect that any output printed
to \s-1STDOUT\s0 by \s-1BEGIN\s0 blocks or use'd modules will be stored in this
variable rather than printed. It's useful with those backends which
produce output themselves (\f(CW\*(C`Deparse\*(C'\fR, \f(CW\*(C`Concise\*(C'\fR etc), so that
their output is not confused with that generated by the code
being compiled.
.PP
The \f(CW\*(C`\-qq\*(C'\fR option behaves like \f(CW\*(C`\-q\*(C'\fR, except that it also closes
\&\s-1STDERR\s0 after deparsing has finished. This suppresses the \*(L"Syntax \s-1OK\*(R"\s0
message normally produced by perl.
.SH "CONVENTIONS"
.IX Header "CONVENTIONS"
Most compiler backends use the following conventions: \s-1OPTIONS\s0
consists of a comma-separated list of words (no white-space).
The \f(CW\*(C`\-v\*(C'\fR option usually puts the backend into verbose mode.
The \f(CW\*(C`\-ofile\*(C'\fR option generates output to \fBfile\fR instead of
stdout. The \f(CW\*(C`\-D\*(C'\fR option followed by various letters turns on
various internal debugging flags. See the documentation for the
desired backend (named \f(CW\*(C`B::Backend\*(C'\fR for the example above) to
find out about that backend.
.SH "IMPLEMENTATION"
.IX Header "IMPLEMENTATION"
This section is only necessary for those who want to write a
compiler backend module that can be used via this module.
.PP
The command-line mentioned in the \s-1SYNOPSIS\s0 section corresponds to
the Perl code
.PP
.Vb 1
\&    use O ("Backend", OPTIONS);
.Ve
.PP
The \f(CW\*(C`O::import\*(C'\fR function loads the appropriate \f(CW\*(C`B::Backend\*(C'\fR module
and calls its \f(CW\*(C`compile\*(C'\fR function, passing it \s-1OPTIONS.\s0 That function
is expected to return a sub reference which we'll call \s-1CALLBACK.\s0 Next,
the \*(L"compile-only\*(R" flag is switched on (equivalent to the command-line
option \f(CW\*(C`\-c\*(C'\fR) and a \s-1CHECK\s0 block is registered which calls
\&\s-1CALLBACK.\s0 Thus the main Perl program mentioned on the command-line is
read in, parsed and compiled into internal syntax tree form. Since the
\&\f(CW\*(C`\-c\*(C'\fR flag is set, the program does not start running (excepting \s-1BEGIN\s0
blocks of course) but the \s-1CALLBACK\s0 function registered by the compiler
backend is called.
.PP
In summary, a compiler backend module should be called \*(L"B::Foo\*(R"
for some foo and live in the appropriate directory for that name.
It should define a function called \f(CW\*(C`compile\*(C'\fR. When the user types
.PP
.Vb 1
\&    perl \-MO=Foo,OPTIONS foo.pl
.Ve
.PP
that function is called and is passed those \s-1OPTIONS \s0(split on
commas). It should return a sub ref to the main compilation function.
After the user's program is loaded and parsed, that returned sub ref
is invoked which can then go ahead and do the compilation, usually by
making use of the \f(CW\*(C`B\*(C'\fR module's functionality.
.SH "BUGS"
.IX Header "BUGS"
The \f(CW\*(C`\-q\*(C'\fR and \f(CW\*(C`\-qq\*(C'\fR options don't work correctly if perl isn't
compiled with PerlIO support : \s-1STDOUT\s0 will be closed instead of being
redirected to \f(CW$O::BEGIN_output\fR.
.SH "AUTHOR"
.IX Header "AUTHOR"
Malcolm Beattie, \f(CW\*(C`mbeattie@sable.ox.ac.uk\*(C'\fR
                                    osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_cleanup.3ssl                             0120777 0001750 0001750 00000000000 12620245063 026425  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_cmp.3ssl                                 0120777 0001750 0001750 00000000000 12620245063 025555  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_create.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026241  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_dup.3ssl                                 0120777 0001750 0001750 00000000000 12620245063 025566  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_ln2nid.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026164  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_nid2ln.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026164  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_nid2obj.3ssl                             0100644 0001750 0001750 00000022600 12566201130 023473  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OBJ_nid2obj 3"
.TH OBJ_nid2obj 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OBJ_nid2obj, OBJ_nid2ln, OBJ_nid2sn, OBJ_obj2nid, OBJ_txt2nid, OBJ_ln2nid, OBJ_sn2nid,
OBJ_cmp, OBJ_dup, OBJ_txt2obj, OBJ_obj2txt, OBJ_create, OBJ_cleanup \- ASN1 object utility
functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/objects.h>
\&
\& ASN1_OBJECT * OBJ_nid2obj(int n);
\& const char *  OBJ_nid2ln(int n);
\& const char *  OBJ_nid2sn(int n);
\&
\& int OBJ_obj2nid(const ASN1_OBJECT *o);
\& int OBJ_ln2nid(const char *ln);
\& int OBJ_sn2nid(const char *sn);
\&
\& int OBJ_txt2nid(const char *s);
\&
\& ASN1_OBJECT * OBJ_txt2obj(const char *s, int no_name);
\& int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);
\&
\& int OBJ_cmp(const ASN1_OBJECT *a,const ASN1_OBJECT *b);
\& ASN1_OBJECT * OBJ_dup(const ASN1_OBJECT *o);
\&
\& int OBJ_create(const char *oid,const char *sn,const char *ln);
\& void OBJ_cleanup(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The \s-1ASN1\s0 object utility functions process \s-1ASN1_OBJECT\s0 structures which are
a representation of the \s-1ASN1 OBJECT IDENTIFIER \s0(\s-1OID\s0) type.
.PP
\&\fIOBJ_nid2obj()\fR, \fIOBJ_nid2ln()\fR and \fIOBJ_nid2sn()\fR convert the \s-1NID \s0\fBn\fR to 
an \s-1ASN1_OBJECT\s0 structure, its long name and its short name respectively,
or \fB\s-1NULL\s0\fR is an error occurred.
.PP
\&\fIOBJ_obj2nid()\fR, \fIOBJ_ln2nid()\fR, \fIOBJ_sn2nid()\fR return the corresponding \s-1NID\s0
for the object \fBo\fR, the long name <ln> or the short name <sn> respectively
or NID_undef if an error occurred.
.PP
\&\fIOBJ_txt2nid()\fR returns \s-1NID\s0 corresponding to text string <s>. \fBs\fR can be
a long name, a short name or the numerical respresentation of an object.
.PP
\&\fIOBJ_txt2obj()\fR converts the text string \fBs\fR into an \s-1ASN1_OBJECT\s0 structure.
If \fBno_name\fR is 0 then long names and short names will be interpreted
as well as numerical forms. If \fBno_name\fR is 1 only the numerical form
is acceptable.
.PP
\&\fIOBJ_obj2txt()\fR converts the \fB\s-1ASN1_OBJECT\s0\fR \fBa\fR into a textual representation.
The representation is written as a null terminated string to \fBbuf\fR
at most \fBbuf_len\fR bytes are written, truncating the result if necessary.
The total amount of space required is returned. If \fBno_name\fR is 0 then
if the object has a long or short name then that will be used, otherwise
the numerical form will be used. If \fBno_name\fR is 1 then the numerical
form will always be used.
.PP
\&\fIOBJ_cmp()\fR compares \fBa\fR to \fBb\fR. If the two are identical 0 is returned.
.PP
\&\fIOBJ_dup()\fR returns a copy of \fBo\fR.
.PP
\&\fIOBJ_create()\fR adds a new object to the internal table. \fBoid\fR is the 
numerical form of the object, \fBsn\fR the short name and \fBln\fR the
long name. A new \s-1NID\s0 is returned for the created object.
.PP
\&\fIOBJ_cleanup()\fR cleans up OpenSSLs internal object table: this should
be called before an application exits if any new objects were added
using \fIOBJ_create()\fR.
.SH "NOTES"
.IX Header "NOTES"
Objects in OpenSSL can have a short name, a long name and a numerical
identifier (\s-1NID\s0) associated with them. A standard set of objects is
represented in an internal table. The appropriate values are defined
in the header file \fBobjects.h\fR.
.PP
For example the \s-1OID\s0 for commonName has the following definitions:
.PP
.Vb 3
\& #define SN_commonName                   "CN"
\& #define LN_commonName                   "commonName"
\& #define NID_commonName                  13
.Ve
.PP
New objects can be added by calling \fIOBJ_create()\fR.
.PP
Table objects have certain advantages over other objects: for example
their NIDs can be used in a C language switch statement. They are
also static constant structures which are shared: that is there
is only a single constant structure for each table object.
.PP
Objects which are not in the table have the \s-1NID\s0 value NID_undef.
.PP
Objects do not need to be in the internal tables to be processed,
the functions \fIOBJ_txt2obj()\fR and \fIOBJ_obj2txt()\fR can process the numerical
form of an \s-1OID.\s0
.SH "EXAMPLES"
.IX Header "EXAMPLES"
Create an object for \fBcommonName\fR:
.PP
.Vb 2
\& ASN1_OBJECT *o;
\& o = OBJ_nid2obj(NID_commonName);
.Ve
.PP
Check if an object is \fBcommonName\fR
.PP
.Vb 2
\& if (OBJ_obj2nid(obj) == NID_commonName)
\&        /* Do something */
.Ve
.PP
Create a new \s-1NID\s0 and initialize an object from it:
.PP
.Vb 3
\& int new_nid;
\& ASN1_OBJECT *obj;
\& new_nid = OBJ_create("1.2.3.4", "NewOID", "New Object Identifier");
\&
\& obj = OBJ_nid2obj(new_nid);
.Ve
.PP
Create a new object directly:
.PP
.Vb 1
\& obj = OBJ_txt2obj("1.2.3.4", 1);
.Ve
.SH "BUGS"
.IX Header "BUGS"
\&\fIOBJ_obj2txt()\fR is awkward and messy to use: it doesn't follow the 
convention of other OpenSSL functions where the buffer can be set
to \fB\s-1NULL\s0\fR to determine the amount of data that should be written.
Instead \fBbuf\fR must point to a valid buffer and \fBbuf_len\fR should
be set to a positive value. A buffer length of 80 should be more
than enough to handle any \s-1OID\s0 encountered in practice.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
\&\fIOBJ_nid2obj()\fR returns an \fB\s-1ASN1_OBJECT\s0\fR structure or \fB\s-1NULL\s0\fR is an
error occurred.
.PP
\&\fIOBJ_nid2ln()\fR and \fIOBJ_nid2sn()\fR returns a valid string or \fB\s-1NULL\s0\fR
on error.
.PP
\&\fIOBJ_obj2nid()\fR, \fIOBJ_ln2nid()\fR, \fIOBJ_sn2nid()\fR and \fIOBJ_txt2nid()\fR return
a \s-1NID\s0 or \fBNID_undef\fR on error.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIERR_get_error\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\s-1TBA\s0
                                                                                                                                osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_nid2sn.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026173  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_obj2nid.3ssl                             0120777 0001750 0001750 00000000000 12620245063 026325  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_obj2txt.3ssl                             0120777 0001750 0001750 00000000000 12620245063 026372  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_sn2nid.3ssl                              0120777 0001750 0001750 00000000000 12620245063 026173  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_txt2nid.3ssl                             0120777 0001750 0001750 00000000000 12620245063 026372  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OBJ_txt2obj.3ssl                             0120777 0001750 0001750 00000000000 12620245063 026372  2OBJ_nid2obj.3ssl                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_Applink.3ssl                         0100644 0001750 0001750 00000011102 12566201131 024247  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_Applink 3"
.TH OPENSSL_Applink 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_Applink \- glue between OpenSSL BIO and Win32 compiler run\-time
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& _\|_declspec(dllexport) void **OPENSSL_Applink();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OPENSSL_Applink is application-side interface which provides a glue
between OpenSSL \s-1BIO\s0 layer and Win32 compiler run-time environment.
Even though it appears at application side, it's essentially OpenSSL
private interface. For this reason application developers are not
expected to implement it, but to compile provided module with
compiler of their choice and link it into the target application.
The referred module is available as <openssl>/ms/applink.c.
                                                                                                                                                                                                                                                                                                                                                                                                                                                              osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_VERSION_NUMBER.3ssl                  0100644 0001750 0001750 00000015550 12566201131 025061  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_VERSION_NUMBER 3"
.TH OPENSSL_VERSION_NUMBER 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_VERSION_NUMBER, SSLeay, SSLeay_version \- get OpenSSL version number
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& #include <openssl/opensslv.h>
\& #define OPENSSL_VERSION_NUMBER 0xnnnnnnnnnL
\&
\& #include <openssl/crypto.h>
\& long SSLeay(void);
\& const char *SSLeay_version(int t);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\s-1OPENSSL_VERSION_NUMBER\s0 is a numeric release version identifier:
.PP
.Vb 1
\& MMNNFFPPS: major minor fix patch status
.Ve
.PP
The status nibble has one of the values 0 for development, 1 to e for betas
1 to 14, and f for release.
.PP
for example
.PP
.Vb 3
\& 0x000906000 == 0.9.6 dev
\& 0x000906023 == 0.9.6b beta 3
\& 0x00090605f == 0.9.6e release
.Ve
.PP
Versions prior to 0.9.3 have identifiers < 0x0930.
Versions between 0.9.3 and 0.9.5 had a version identifier with this
interpretation:
.PP
.Vb 1
\& MMNNFFRBB major minor fix final beta/patch
.Ve
.PP
for example
.PP
.Vb 2
\& 0x000904100 == 0.9.4 release
\& 0x000905000 == 0.9.5 dev
.Ve
.PP
Version 0.9.5a had an interim interpretation that is like the current one,
except the patch level got the highest bit set, to keep continuity.  The
number was therefore 0x0090581f.
.PP
For backward compatibility, \s-1SSLEAY_VERSION_NUMBER\s0 is also defined.
.PP
\&\fISSLeay()\fR returns this number. The return value can be compared to the
macro to make sure that the correct version of the library has been
loaded, especially when using DLLs on Windows systems.
.PP
\&\fISSLeay_version()\fR returns different strings depending on \fBt\fR:
.IP "\s-1SSLEAY_VERSION\s0" 4
.IX Item "SSLEAY_VERSION"
The text variant of the version number and the release date.  For example,
\&\*(L"OpenSSL 0.9.5a 1 Apr 2000\*(R".
.IP "\s-1SSLEAY_CFLAGS\s0" 4
.IX Item "SSLEAY_CFLAGS"
The compiler flags set for the compilation process in the form
\&\*(L"compiler: ...\*(R"  if available or \*(L"compiler: information not available\*(R"
otherwise.
.IP "\s-1SSLEAY_BUILT_ON\s0" 4
.IX Item "SSLEAY_BUILT_ON"
The date of the build process in the form \*(L"built on: ...\*(R" if available
or \*(L"built on: date not available\*(R" otherwise.
.IP "\s-1SSLEAY_PLATFORM\s0" 4
.IX Item "SSLEAY_PLATFORM"
The \*(L"Configure\*(R" target of the library build in the form \*(L"platform: ...\*(R"
if available or \*(L"platform: information not available\*(R" otherwise.
.IP "\s-1SSLEAY_DIR\s0" 4
.IX Item "SSLEAY_DIR"
The \*(L"\s-1OPENSSLDIR\*(R"\s0 setting of the library build in the form \*(L"\s-1OPENSSLDIR: \*(R"..."\*(L"\s0
if available or \*(R"\s-1OPENSSLDIR: N/A"\s0 otherwise.
.PP
For an unknown \fBt\fR, the text \*(L"not available\*(R" is returned.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
The version number.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIcrypto\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fISSLeay()\fR and \s-1SSLEAY_VERSION_NUMBER\s0 are available in all versions of SSLeay and OpenSSL.
\&\s-1OPENSSL_VERSION_NUMBER\s0 is available in all versions of OpenSSL.
\&\fB\s-1SSLEAY_DIR\s0\fR was added in OpenSSL 0.9.7.
                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_config.3ssl                          0100644 0001750 0001750 00000016452 12566201131 024133  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_config 3"
.TH OPENSSL_config 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_config, OPENSSL_no_config \- simple OpenSSL configuration functions
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/conf.h>
\&
\& void OPENSSL_config(const char *config_name);
\& void OPENSSL_no_config(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fIOPENSSL_config()\fR configures OpenSSL using the standard \fBopenssl.cnf\fR
configuration file name using \fBconfig_name\fR. If \fBconfig_name\fR is \s-1NULL\s0 then
the default name \fBopenssl_conf\fR will be used. Any errors are ignored. Further
calls to \fIOPENSSL_config()\fR will have no effect. The configuration file format
is documented in the \fIconf\fR\|(5) manual page.
.PP
\&\fIOPENSSL_no_config()\fR disables configuration. If called before \fIOPENSSL_config()\fR
no configuration takes place.
.SH "NOTES"
.IX Header "NOTES"
It is \fBstrongly\fR recommended that \fBall\fR new applications call \fIOPENSSL_config()\fR
or the more sophisticated functions such as \fICONF_modules_load()\fR during
initialization (that is before starting any threads). By doing this
an application does not need to keep track of all configuration options
and some new functionality can be supported automatically.
.PP
It is also possible to automatically call \fIOPENSSL_config()\fR when an application
calls \fIOPENSSL_add_all_algorithms()\fR by compiling an application with the
preprocessor symbol \fB\s-1OPENSSL_LOAD_CONF\s0\fR #define'd. In this way configuration
can be added without source changes.
.PP
The environment variable \fB\s-1OPENSSL_CONF\s0\fR can be set to specify the location
of the configuration file.
.PP
Currently \s-1ASN1\s0 OBJECTs and \s-1ENGINE\s0 configuration can be performed future
versions of OpenSSL will add new configuration options.
.PP
There are several reasons why calling the OpenSSL configuration routines is
advisable. For example new \s-1ENGINE\s0 functionality was added to OpenSSL 0.9.7.
In OpenSSL 0.9.7 control functions can be supported by ENGINEs, this can be
used (among other things) to load dynamic ENGINEs from shared libraries (DSOs).
However very few applications currently support the control interface and so
very few can load and use dynamic ENGINEs. Equally in future more sophisticated
ENGINEs will require certain control operations to customize them. If an
application calls \fIOPENSSL_config()\fR it doesn't need to know or care about
\&\s-1ENGINE\s0 control operations because they can be performed by editing a
configuration file.
.PP
Applications should free up configuration at application closedown by calling
\&\fICONF_modules_free()\fR.
.SH "RESTRICTIONS"
.IX Header "RESTRICTIONS"
The \fIOPENSSL_config()\fR function is designed to be a very simple \*(L"call it and
forget it\*(R" function. As a result its behaviour is somewhat limited. It ignores
all errors silently and it can only load from the standard configuration file
location for example.
.PP
It is however \fBmuch\fR better than nothing. Applications which need finer
control over their configuration functionality should use the configuration
functions such as \fICONF_load_modules()\fR directly.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
Neither \fIOPENSSL_config()\fR nor \fIOPENSSL_no_config()\fR return a value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIconf\fR\|(5), \fICONF_load_modules_file\fR\|(3),
\&\fICONF_modules_free\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
\&\fIOPENSSL_config()\fR and \fIOPENSSL_no_config()\fR first appeared in OpenSSL 0.9.7
                                                                                                                                                                                                                      osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_ia32cap.3ssl                         0100644 0001750 0001750 00000013333 12566201132 024104  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_ia32cap 3"
.TH OPENSSL_ia32cap 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_ia32cap \- finding the IA\-32 processor capabilities
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 2
\& unsigned long *OPENSSL_ia32cap_loc(void);
\& #define OPENSSL_ia32cap (*(OPENSSL_ia32cap_loc()))
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Value returned by \fIOPENSSL_ia32cap_loc()\fR is address of a variable
containing \s-1IA\-32\s0 processor capabilities bit vector as it appears in \s-1EDX\s0
register after executing \s-1CPUID\s0 instruction with EAX=1 input value (see
Intel Application Note #241618). Naturally it's meaningful on IA\-32[E]
platforms only. The variable is normally set up automatically upon
toolkit initialization, but can be manipulated afterwards to modify
crypto library behaviour. For the moment of this writing six bits are
significant, namely:
.PP
1. bit #28 denoting Hyperthreading, which is used to distiguish
   cores with shared cache;
2. bit #26 denoting \s-1SSE2\s0 support;
3. bit #25 denoting \s-1SSE\s0 support;
4. bit #23 denoting \s-1MMX\s0 support;
5. bit #20, reserved by Intel, is used to choose between \s-1RC4\s0 code
   pathes;
6. bit #4 denoting presence of Time-Stamp Counter.
.PP
For example, clearing bit #26 at run-time disables high-performance
\&\s-1SSE2\s0 code present in the crypto library. You might have to do this if
target OpenSSL application is executed on \s-1SSE2\s0 capable \s-1CPU,\s0 but under
control of \s-1OS\s0 which does not support \s-1SSE2\s0 extentions. Even though you
can manipulate the value programmatically, you most likely will find it
more appropriate to set up an environment variable with the same name
prior starting target application, e.g. on Intel P4 processor 'env
OPENSSL_ia32cap=0x12900010 apps/openssl', to achieve same effect
without modifying the application source code. Alternatively you can
reconfigure the toolkit with no\-sse2 option and recompile.
                                                                                                                                                                                                                                                                                                     osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_load_builtin_modules.3ssl            0100644 0001750 0001750 00000012557 12566201132 027066  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OPENSSL_load_builtin_modules 3"
.TH OPENSSL_load_builtin_modules 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OPENSSL_load_builtin_modules \- add standard configuration modules
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/conf.h>
\&
\& void OPENSSL_load_builtin_modules(void);
\& void ASN1_add_oid_module(void);
\& ENGINE_add_conf_module();
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The function \fIOPENSSL_load_builtin_modules()\fR adds all the standard OpenSSL
configuration modules to the internal list. They can then be used by the
OpenSSL configuration code.
.PP
\&\fIASN1_add_oid_module()\fR adds just the \s-1ASN1 OBJECT\s0 module.
.PP
\&\fIENGINE_add_conf_module()\fR adds just the \s-1ENGINE\s0 configuration module.
.SH "NOTES"
.IX Header "NOTES"
If the simple configuration function \fIOPENSSL_config()\fR is called then 
\&\fIOPENSSL_load_builtin_modules()\fR is called automatically.
.PP
Applications which use the configuration functions directly will need to
call \fIOPENSSL_load_builtin_modules()\fR themselves \fIbefore\fR any other 
configuration code.
.PP
Applications should call \fIOPENSSL_load_builtin_modules()\fR to load all
configuration modules instead of adding modules selectively: otherwise 
functionality may be missing from the application if an when new
modules are added.
.SH "RETURN VALUE"
.IX Header "RETURN VALUE"
None of the functions return a value.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIconf\fR\|(3), \fIOPENSSL_config\fR\|(3)
.SH "HISTORY"
.IX Header "HISTORY"
These functions first appeared in OpenSSL 0.9.7.
                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OPENSSL_no_config.3ssl                       0120777 0001750 0001750 00000000000 12620245063 030077  2OPENSSL_config.3ssl                                                                                 ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAdd32.3                              0120777 0001750 0001750 00000000000 12620245063 024527  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAdd32Barrier.3                       0120777 0001750 0001750 00000000000 12620245063 026036  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAdd64.3                              0120777 0001750 0001750 00000000000 12620245063 024534  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAdd64Barrier.3                       0120777 0001750 0001750 00000000000 12620245063 026043  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAnd32.3                              0120777 0001750 0001750 00000000000 12620245063 024541  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAnd32Barrier.3                       0120777 0001750 0001750 00000000000 12620245063 026050  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAnd32Orig.3                          0120777 0001750 0001750 00000000000 12620245063 025362  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicAnd32OrigBarrier.3                   0120777 0001750 0001750 00000000000 12620245063 026671  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwap32.3                   0120777 0001750 0001750 00000000000 12620245063 026703  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwap32Barrier.3            0120777 0001750 0001750 00000000000 12620245063 030212  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwap64.3                   0120777 0001750 0001750 00000000000 12620245063 026710  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwap64Barrier.3            0120777 0001750 0001750 00000000000 12620245063 030217  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapInt.3                  0120777 0001750 0001750 00000000000 12620245063 027211  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapIntBarrier.3           0120777 0001750 0001750 00000000000 12620245063 030520  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapLong.3                 0120777 0001750 0001750 00000000000 12620245063 027356  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapLongBarrier.3          0120777 0001750 0001750 00000000000 12620245063 030665  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapPtr.3                  0120777 0001750 0001750 00000000000 12620245063 027224  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicCompareAndSwapPtrBarrier.3           0120777 0001750 0001750 00000000000 12620245063 030533  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicDecrement32.3                        0120777 0001750 0001750 00000000000 12620245063 025745  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicDecrement32Barrier.3                 0120777 0001750 0001750 00000000000 12620245063 027254  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicDecrement64.3                        0120777 0001750 0001750 00000000000 12620245063 025752  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicDecrement64Barrier.3                 0120777 0001750 0001750 00000000000 12620245063 027261  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicDequeue.3                            0120777 0001750 0001750 00000000000 12620245063 025267  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicEnqueue.3                            0120777 0001750 0001750 00000000000 12620245063 025301  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicIncrement32.3                        0120777 0001750 0001750 00000000000 12620245063 025763  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicIncrement32Barrier.3                 0120777 0001750 0001750 00000000000 12620245063 027272  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicIncrement64.3                        0120777 0001750 0001750 00000000000 12620245063 025770  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicIncrement64Barrier.3                 0120777 0001750 0001750 00000000000 12620245063 027277  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicOr32.3                               0120777 0001750 0001750 00000000000 12620245063 024417  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicOr32Barrier.3                        0120777 0001750 0001750 00000000000 12620245063 025726  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicOr32Orig.3                           0120777 0001750 0001750 00000000000 12620245063 025240  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicOr32OrigBarrier.3                    0120777 0001750 0001750 00000000000 12620245063 026547  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicTestAndClear.3                       0120777 0001750 0001750 00000000000 12620245063 026203  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicTestAndClearBarrier.3                0120777 0001750 0001750 00000000000 12620245063 027512  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicTestAndSet.3                         0120777 0001750 0001750 00000000000 12620245063 025710  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicTestAndSetBarrier.3                  0120777 0001750 0001750 00000000000 12620245063 027217  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicXor32.3                              0120777 0001750 0001750 00000000000 12620245063 024607  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicXor32Barrier.3                       0120777 0001750 0001750 00000000000 12620245063 026116  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicXor32Orig.3                          0120777 0001750 0001750 00000000000 12620245063 025430  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSAtomicXor32OrigBarrier.3                   0120777 0001750 0001750 00000000000 12620245063 026737  2atomic.3                                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSMemoryBarrier.3                            0120777 0001750 0001750 00000000000 12620245063 025466  2barrier.3                                                                                           ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSSpinLockLock.3                             0120777 0001750 0001750 00000000000 12620245063 025436  2spinlock.3                                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSSpinLockTry.3                              0120777 0001750 0001750 00000000000 12620245063 025324  2spinlock.3                                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OSSpinLockUnlock.3                           0120777 0001750 0001750 00000000000 12620245063 026001  2spinlock.3                                                                                          ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Object::Accessor.3pm                         0100644 0001750 0001750 00000047577 12566207461 024403  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Accessor 3pm"
.TH Object::Accessor 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Accessor \- interface to create per object accessors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    ### using the object
\&    $obj = Object::Accessor\->new;        # create object
\&    $obj = Object::Accessor\->new(@list); # create object with accessors
\&    $obj = Object::Accessor\->new(\e%h);   # create object with accessors
\&                                         # and their allow handlers
\&
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq); # create accessors
\&    $bool   = $obj\->mk_accessors(        # create accessors with input
\&               {foo => ALLOW_HANDLER} ); # validation
\&
\&    $bool   = $obj\->mk_aliases(          # create an alias to an existing
\&                alias_name => \*(Aqmethod\*(Aq); # method name
\&
\&    $clone  = $obj\->mk_clone;            # create a clone of original
\&                                         # object without data
\&    $bool   = $obj\->mk_flush;            # clean out all data
\&
\&    @list   = $obj\->ls_accessors;        # retrieves a list of all
\&                                         # accessors for this object
\&
\&    $bar    = $obj\->foo(\*(Aqbar\*(Aq);          # set \*(Aqfoo\*(Aq to \*(Aqbar\*(Aq
\&    $bar    = $obj\->foo();               # retrieve \*(Aqbar\*(Aq again
\&
\&    $sub    = $obj\->can(\*(Aqfoo\*(Aq);          # retrieve coderef for
\&                                         # \*(Aqfoo\*(Aq accessor
\&    $bar    = $sub\->(\*(Aqbar\*(Aq);             # set \*(Aqfoo\*(Aq via coderef
\&    $bar    = $sub\->();                  # retrieve \*(Aqbar\*(Aq by coderef
\&
\&    ### using the object as base class
\&    package My::Class;
\&    use base \*(AqObject::Accessor\*(Aq;
\&
\&    $obj    = My::Class\->new;               # create base object
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq);    # create accessors, etc...
\&
\&    ### make all attempted access to non\-existent accessors fatal
\&    ### (defaults to false)
\&    $Object::Accessor::FATAL = 1;
\&
\&    ### enable debugging
\&    $Object::Accessor::DEBUG = 1;
\&
\&    ### advanced usage \-\- callbacks
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&        $obj\->register_callback( sub { ... } );
\&
\&        $obj\->foo( 1 ); # these calls invoke the callback you registered
\&        $obj\->foo()     # which allows you to change the get/set
\&                        # behaviour and what is returned to the caller.
\&    }
\&
\&    ### advanced usage \-\- lvalue attributes
\&    {   my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&        print $obj\->foo = 1;            # will print 1
\&    }
\&
\&    ### advanced usage \-\- scoped attribute values
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&
\&        $obj\->foo( 1 );
\&        print $obj\->foo;                # will print 1
\&
\&        ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&        ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&        ### scope, \*(Aqfoo\*(Aqs previous value will be restored
\&        {   $obj\->foo( 2 => \emy $x );
\&            print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&        }
\&        print $obj\->foo;                # will print 1
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Object::Accessor\*(C'\fR provides an interface to create per object
accessors (as opposed to per \f(CW\*(C`Class\*(C'\fR accessors, as, for example,
\&\f(CW\*(C`Class::Accessor\*(C'\fR provides).
.PP
You can choose to either subclass this module, and thus using its
accessors on your own module, or to store an \f(CW\*(C`Object::Accessor\*(C'\fR
object inside your own object, and access the accessors from there.
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for examples.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$object = Object::Accessor\->new( [\s-1ARGS\s0] );"
.el .SS "\f(CW$object\fP = Object::Accessor\->new( [\s-1ARGS\s0] );"
.IX Subsection "$object = Object::Accessor->new( [ARGS] );"
Creates a new (and empty) \f(CW\*(C`Object::Accessor\*(C'\fR object. This method is
inheritable.
.PP
Any arguments given to \f(CW\*(C`new\*(C'\fR are passed straight to \f(CW\*(C`mk_accessors\*(C'\fR.
.PP
If you want to be able to assign to your accessors as if they
were \f(CW\*(C`lvalue\*(C'\fRs, you should create your object in the
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR namespace instead. See the section
on \f(CW\*(C`LVALUE ACCESSORS\*(C'\fR below.
.ie n .SS "$bool = $object\->mk_accessors( @ACCESSORS | \e%ACCESSOR_MAP );"
.el .SS "\f(CW$bool\fP = \f(CW$object\fP\->mk_accessors( \f(CW@ACCESSORS\fP | \e%ACCESSOR_MAP );"
.IX Subsection "$bool = $object->mk_accessors( @ACCESSORS | %ACCESSOR_MAP );"
Creates a list of accessors for this object (and \f(CW\*(C`NOT\*(C'\fR for other ones
in the same class!).
Will not clobber existing data, so if an accessor already exists,
requesting to create again is effectively a \f(CW\*(C`no\-op\*(C'\fR.
.PP
When providing a \f(CW\*(C`hashref\*(C'\fR as argument, rather than a normal list,
you can specify a list of key/value pairs of accessors and their
respective input validators. The validators can be anything that
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function accepts. Please see its manpage
for details.
.PP
For example:
.PP
.Vb 5
\&    $object\->mk_accessors( {
\&        foo     => qr/^\ed+$/,       # digits only
\&        bar     => [0,1],           # booleans
\&        zot     => \e&my_sub         # a custom verification sub
\&    } );
.Ve
.PP
Returns true on success, false on failure.
.PP
Accessors that are called on an object, that do not exist return
\&\f(CW\*(C`undef\*(C'\fR by default, but you can make this a fatal error by setting the
global variable \f(CW$FATAL\fR to true. See the section on \f(CW\*(C`GLOBAL
VARIABLES\*(C'\fR for details.
.PP
Note that you can bind the values of attributes to a scope. This allows
you to \f(CW\*(C`temporarily\*(C'\fR change a value of an attribute, and have it's
original value restored up on the end of it's bound variable's scope;
.PP
For example, in this snippet of code, the attribute \f(CW\*(C`foo\*(C'\fR will
temporarily be set to \f(CW2\fR, until the end of the scope of \f(CW$x\fR, at
which point the original value of \f(CW1\fR will be restored.
.PP
.Vb 1
\&    my $obj = Object::Accessor\->new;
\&
\&    $obj\->mk_accessors(\*(Aqfoo\*(Aq);
\&    $obj\->foo( 1 );
\&    print $obj\->foo;                # will print 1
\&
\&    ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&    ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&    ### scope, \*(Aqfoo\*(Aq previous value will be restored
\&    {   $obj\->foo( 2 => \emy $x );
\&        print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&    }
\&    print $obj\->foo;                # will print 1
.Ve
.PP
Note that all accessors are read/write for everyone. See the \f(CW\*(C`TODO\*(C'\fR
section for details.
.ie n .SS "@list = $self\->ls_accessors;"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->ls_accessors;"
.IX Subsection "@list = $self->ls_accessors;"
Returns a list of accessors that are supported by the current object.
The corresponding coderefs can be retrieved by passing this list one
by one to the \f(CW\*(C`can\*(C'\fR method.
.ie n .SS "$ref = $self\->ls_allow(\s-1KEY\s0)"
.el .SS "\f(CW$ref\fP = \f(CW$self\fP\->ls_allow(\s-1KEY\s0)"
.IX Subsection "$ref = $self->ls_allow(KEY)"
Returns the allow handler for the given key, which can be used with
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow()\*(C'\fR handler. If there was no allow handler
specified, an allow handler that always returns true will be returned.
.ie n .SS "$bool = $self\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.IX Subsection "$bool = $self->mk_aliases( alias => method, [alias2 => method2, ...] );"
Creates an alias for a given method name. For all intents and purposes,
these two accessors are now identical for this object. This is akin to
doing the following on the symbol table level:
.PP
.Vb 1
\&  *alias = *method
.Ve
.PP
This allows you to do the following:
.PP
.Vb 2
\&  $self\->mk_accessors(\*(Aqfoo\*(Aq);
\&  $self\->mk_aliases( bar => \*(Aqfoo\*(Aq );
\&
\&  $self\->bar( 42 );
\&  print $self\->foo;     # will print 42
.Ve
.ie n .SS "$clone = $self\->mk_clone;"
.el .SS "\f(CW$clone\fP = \f(CW$self\fP\->mk_clone;"
.IX Subsection "$clone = $self->mk_clone;"
Makes a clone of the current object, which will have the exact same
accessors as the current object, but without the data stored in them.
.ie n .SS "$bool = $self\->mk_flush;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_flush;"
.IX Subsection "$bool = $self->mk_flush;"
Flushes all the data from the current object; all accessors will be
set back to their default state of \f(CW\*(C`undef\*(C'\fR.
.PP
Returns true on success and false on failure.
.ie n .SS "$bool = $self\->mk_verify;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_verify;"
.IX Subsection "$bool = $self->mk_verify;"
Checks if all values in the current object are in accordance with their
own allow handler. Specifically useful to check if an empty initialised
object has been filled with values satisfying their own allow criteria.
.ie n .SS "$bool = $self\->register_callback( sub { ... } );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->register_callback( sub { ... } );"
.IX Subsection "$bool = $self->register_callback( sub { ... } );"
This method allows you to register a callback, that is invoked
every time an accessor is called. This allows you to munge input
data, access external data stores, etc.
.PP
You are free to return whatever you wish. On a \f(CW\*(C`set\*(C'\fR call, the
data is even stored in the object.
.PP
Below is an example of the use of a callback.
.PP
.Vb 1
\&    $object\->some_method( "some_value" );
\&
\&    my $callback = sub {
\&        my $self    = shift; # the object
\&        my $meth    = shift; # "some_method"
\&        my $val     = shift; # ["some_value"]
\&                             # could be undef \-\- check \*(Aqexists\*(Aq;
\&                             # if scalar @$val is empty, it was a \*(Aqget\*(Aq
\&
\&        # your code here
\&
\&        return $new_val;     # the value you want to be set/returned
\&    }
.Ve
.PP
To access the values stored in the object, circumventing the
callback structure, you should use the \f(CW\*(C`_\|_\|_get\*(C'\fR and \f(CW\*(C`_\|_\|_set\*(C'\fR methods
documented further down.
.ie n .SS "$bool = $self\->can( \s-1METHOD_NAME \s0)"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->can( \s-1METHOD_NAME \s0)"
.IX Subsection "$bool = $self->can( METHOD_NAME )"
This method overrides \f(CW\*(C`UNIVERAL::can\*(C'\fR in order to provide coderefs to
accessors which are loaded on demand. It will behave just like
\&\f(CW\*(C`UNIVERSAL::can\*(C'\fR where it can \*(-- returning a class method if it exists,
or a closure pointing to a valid accessor of this particular object.
.PP
You can use it as follows:
.PP
.Vb 5
\&    $sub = $object\->can(\*(Aqsome_accessor\*(Aq);   # retrieve the coderef
\&    $sub\->(\*(Aqfoo\*(Aq);                          # \*(Aqsome_accessor\*(Aq now set
\&                                            # to \*(Aqfoo\*(Aq for $object
\&    $foo = $sub\->();                        # retrieve the contents
\&                                            # of \*(Aqsome_accessor\*(Aq
.Ve
.PP
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for more examples.
.ie n .SS "$val = $self\->_\|_\|_get( \s-1METHOD_NAME \s0);"
.el .SS "\f(CW$val\fP = \f(CW$self\fP\->_\|_\|_get( \s-1METHOD_NAME \s0);"
.IX Subsection "$val = $self->___get( METHOD_NAME );"
Method to directly access the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE \s0);"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE \s0);"
.IX Subsection "$bool = $self->___set( METHOD_NAME => VALUE );"
Method to directly set the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD \s0);"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD \s0);"
.IX Subsection "$bool = $self->___alias( ALIAS => METHOD );"
Method to directly alias one accessor to another for
this object. It circumvents all sanity checks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR!
.SH "LVALUE ACCESSORS"
.IX Header "LVALUE ACCESSORS"
\&\f(CW\*(C`Object::Accessor\*(C'\fR supports \f(CW\*(C`lvalue\*(C'\fR attributes as well. To enable
these, you should create your objects in the designated namespace,
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR. For example:
.PP
.Vb 3
\&    my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&    print $obj\->foo;
.Ve
.PP
will actually print \f(CW1\fR and work as expected. Since this is an
optional feature, that's not desirable in all cases, we require
you to explicitly use the \f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR class.
.PP
Doing the same on the standard \f(CW\*(C`Object\*(C'\fR>Accessor> class would
generate the following code & errors:
.PP
.Vb 2
\&    my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&
\&    Can\*(Aqt modify non\-lvalue subroutine call
.Ve
.PP
Note that \f(CW\*(C`lvalue\*(C'\fR support on \f(CW\*(C`AUTOLOAD\*(C'\fR routines is a
\&\f(CW\*(C`perl 5.8.x\*(C'\fR feature. See perldoc perl58delta for details.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
.IP "\(bu" 4
Allow handlers
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check it against your allow
handler. Allow handlers are therefor unsupported under \f(CW\*(C`lvalue\*(C'\fR
conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.IP "\(bu" 4
Callbacks
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check provide this value
to your callback. Furthermore, we can not distinguish between
a \f(CW\*(C`get\*(C'\fR and a \f(CW\*(C`set\*(C'\fR call. Callbacks are therefor unsupported
under \f(CW\*(C`lvalue\*(C'\fR conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$Object::Accessor::FATAL"
.el .SS "\f(CW$Object::Accessor::FATAL\fP"
.IX Subsection "$Object::Accessor::FATAL"
Set this variable to true to make all attempted access to non-existent
accessors be fatal.
This defaults to \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$Object::Accessor::DEBUG"
.el .SS "\f(CW$Object::Accessor::DEBUG\fP"
.IX Subsection "$Object::Accessor::DEBUG"
Set this variable to enable debugging output.
This defaults to \f(CW\*(C`false\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.SS "Create read-only accessors"
.IX Subsection "Create read-only accessors"
Currently all accessors are read/write for everyone. Perhaps a future
release should make it possible to have read-only accessors as well.
.SH "CAVEATS"
.IX Header "CAVEATS"
If you use codereferences for your allow handlers, you will not be able
to freeze the data structures using \f(CW\*(C`Storable\*(C'\fR.
.PP
Due to a bug in storable (until at least version 2.15), \f(CW\*(C`qr//\*(C'\fR compiled
regexes also don't de-serialize properly. Although this bug has been
reported, you should be aware of this issue when serializing your objects.
.PP
You can track the bug here:
.PP
.Vb 1
\&    http://rt.cpan.org/Ticket/Display.html?id=1827
.Ve
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-object\-accessor@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Object::Accessor5.16.3pm                     0100644 0001750 0001750 00000047256 12566207437 024712  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Accessor 3pm"
.TH Object::Accessor 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Accessor \- interface to create per object accessors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    ### using the object
\&    $obj = Object::Accessor\->new;        # create object
\&    $obj = Object::Accessor\->new(@list); # create object with accessors
\&    $obj = Object::Accessor\->new(\e%h);   # create object with accessors
\&                                         # and their allow handlers
\&
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq); # create accessors
\&    $bool   = $obj\->mk_accessors(        # create accessors with input
\&               {foo => ALLOW_HANDLER} ); # validation
\&
\&    $bool   = $obj\->mk_aliases(          # create an alias to an existing
\&                alias_name => \*(Aqmethod\*(Aq); # method name
\&
\&    $clone  = $obj\->mk_clone;            # create a clone of original
\&                                         # object without data
\&    $bool   = $obj\->mk_flush;            # clean out all data
\&
\&    @list   = $obj\->ls_accessors;        # retrieves a list of all
\&                                         # accessors for this object
\&
\&    $bar    = $obj\->foo(\*(Aqbar\*(Aq);          # set \*(Aqfoo\*(Aq to \*(Aqbar\*(Aq
\&    $bar    = $obj\->foo();               # retrieve \*(Aqbar\*(Aq again
\&
\&    $sub    = $obj\->can(\*(Aqfoo\*(Aq);          # retrieve coderef for
\&                                         # \*(Aqfoo\*(Aq accessor
\&    $bar    = $sub\->(\*(Aqbar\*(Aq);             # set \*(Aqfoo\*(Aq via coderef
\&    $bar    = $sub\->();                  # retrieve \*(Aqbar\*(Aq by coderef
\&
\&    ### using the object as base class
\&    package My::Class;
\&    use base \*(AqObject::Accessor\*(Aq;
\&
\&    $obj    = My::Class\->new;               # create base object
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq);    # create accessors, etc...
\&
\&    ### make all attempted access to non\-existent accessors fatal
\&    ### (defaults to false)
\&    $Object::Accessor::FATAL = 1;
\&
\&    ### enable debugging
\&    $Object::Accessor::DEBUG = 1;
\&
\&    ### advanced usage \-\- callbacks
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&        $obj\->register_callback( sub { ... } );
\&
\&        $obj\->foo( 1 ); # these calls invoke the callback you registered
\&        $obj\->foo()     # which allows you to change the get/set
\&                        # behaviour and what is returned to the caller.
\&    }
\&
\&    ### advanced usage \-\- lvalue attributes
\&    {   my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&        print $obj\->foo = 1;            # will print 1
\&    }
\&
\&    ### advanced usage \-\- scoped attribute values
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&
\&        $obj\->foo( 1 );
\&        print $obj\->foo;                # will print 1
\&
\&        ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&        ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&        ### scope, \*(Aqfoo\*(Aqs previous value will be restored
\&        {   $obj\->foo( 2 => \emy $x );
\&            print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&        }
\&        print $obj\->foo;                # will print 1
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Object::Accessor\*(C'\fR provides an interface to create per object
accessors (as opposed to per \f(CW\*(C`Class\*(C'\fR accessors, as, for example,
\&\f(CW\*(C`Class::Accessor\*(C'\fR provides).
.PP
You can choose to either subclass this module, and thus using its
accessors on your own module, or to store an \f(CW\*(C`Object::Accessor\*(C'\fR
object inside your own object, and access the accessors from there.
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for examples.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$object = Object::Accessor\->new( [\s-1ARGS\s0] );"
.el .SS "\f(CW$object\fP = Object::Accessor\->new( [\s-1ARGS\s0] );"
.IX Subsection "$object = Object::Accessor->new( [ARGS] );"
Creates a new (and empty) \f(CW\*(C`Object::Accessor\*(C'\fR object. This method is
inheritable.
.PP
Any arguments given to \f(CW\*(C`new\*(C'\fR are passed straight to \f(CW\*(C`mk_accessors\*(C'\fR.
.PP
If you want to be able to assign to your accessors as if they
were \f(CW\*(C`lvalue\*(C'\fRs, you should create your object in the
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR namespace instead. See the section
on \f(CW\*(C`LVALUE ACCESSORS\*(C'\fR below.
.ie n .SS "$bool = $object\->mk_accessors( @ACCESSORS | \e%ACCESSOR_MAP );"
.el .SS "\f(CW$bool\fP = \f(CW$object\fP\->mk_accessors( \f(CW@ACCESSORS\fP | \e%ACCESSOR_MAP );"
.IX Subsection "$bool = $object->mk_accessors( @ACCESSORS | %ACCESSOR_MAP );"
Creates a list of accessors for this object (and \f(CW\*(C`NOT\*(C'\fR for other ones
in the same class!).
Will not clobber existing data, so if an accessor already exists,
requesting to create again is effectively a \f(CW\*(C`no\-op\*(C'\fR.
.PP
When providing a \f(CW\*(C`hashref\*(C'\fR as argument, rather than a normal list,
you can specify a list of key/value pairs of accessors and their
respective input validators. The validators can be anything that
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function accepts. Please see its manpage
for details.
.PP
For example:
.PP
.Vb 5
\&    $object\->mk_accessors( {
\&        foo     => qr/^\ed+$/,       # digits only
\&        bar     => [0,1],           # booleans
\&        zot     => \e&my_sub         # a custom verification sub
\&    } );
.Ve
.PP
Returns true on success, false on failure.
.PP
Accessors that are called on an object, that do not exist return
\&\f(CW\*(C`undef\*(C'\fR by default, but you can make this a fatal error by setting the
global variable \f(CW$FATAL\fR to true. See the section on \f(CW\*(C`GLOBAL
VARIABLES\*(C'\fR for details.
.PP
Note that you can bind the values of attributes to a scope. This allows
you to \f(CW\*(C`temporarily\*(C'\fR change a value of an attribute, and have it's
original value restored up on the end of it's bound variable's scope;
.PP
For example, in this snippet of code, the attribute \f(CW\*(C`foo\*(C'\fR will
temporarily be set to \f(CW2\fR, until the end of the scope of \f(CW$x\fR, at
which point the original value of \f(CW1\fR will be restored.
.PP
.Vb 1
\&    my $obj = Object::Accessor\->new;
\&
\&    $obj\->mk_accessors(\*(Aqfoo\*(Aq);
\&    $obj\->foo( 1 );
\&    print $obj\->foo;                # will print 1
\&
\&    ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&    ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&    ### scope, \*(Aqfoo\*(Aq previous value will be restored
\&    {   $obj\->foo( 2 => \emy $x );
\&        print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&    }
\&    print $obj\->foo;                # will print 1
.Ve
.PP
Note that all accessors are read/write for everyone. See the \f(CW\*(C`TODO\*(C'\fR
section for details.
.ie n .SS "@list = $self\->ls_accessors;"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->ls_accessors;"
.IX Subsection "@list = $self->ls_accessors;"
Returns a list of accessors that are supported by the current object.
The corresponding coderefs can be retrieved by passing this list one
by one to the \f(CW\*(C`can\*(C'\fR method.
.ie n .SS "$ref = $self\->ls_allow(\s-1KEY\s0)"
.el .SS "\f(CW$ref\fP = \f(CW$self\fP\->ls_allow(\s-1KEY\s0)"
.IX Subsection "$ref = $self->ls_allow(KEY)"
Returns the allow handler for the given key, which can be used with
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow()\*(C'\fR handler. If there was no allow handler
specified, an allow handler that always returns true will be returned.
.ie n .SS "$bool = $self\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.IX Subsection "$bool = $self->mk_aliases( alias => method, [alias2 => method2, ...] );"
Creates an alias for a given method name. For all intents and purposes,
these two accessors are now identical for this object. This is akin to
doing the following on the symbol table level:
.PP
.Vb 1
\&  *alias = *method
.Ve
.PP
This allows you to do the following:
.PP
.Vb 2
\&  $self\->mk_accessors(\*(Aqfoo\*(Aq);
\&  $self\->mk_aliases( bar => \*(Aqfoo\*(Aq );
\&
\&  $self\->bar( 42 );
\&  print $self\->foo;     # will print 42
.Ve
.ie n .SS "$clone = $self\->mk_clone;"
.el .SS "\f(CW$clone\fP = \f(CW$self\fP\->mk_clone;"
.IX Subsection "$clone = $self->mk_clone;"
Makes a clone of the current object, which will have the exact same
accessors as the current object, but without the data stored in them.
.ie n .SS "$bool = $self\->mk_flush;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_flush;"
.IX Subsection "$bool = $self->mk_flush;"
Flushes all the data from the current object; all accessors will be
set back to their default state of \f(CW\*(C`undef\*(C'\fR.
.PP
Returns true on success and false on failure.
.ie n .SS "$bool = $self\->mk_verify;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_verify;"
.IX Subsection "$bool = $self->mk_verify;"
Checks if all values in the current object are in accordance with their
own allow handler. Specifically useful to check if an empty initialised
object has been filled with values satisfying their own allow criteria.
.ie n .SS "$bool = $self\->register_callback( sub { ... } );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->register_callback( sub { ... } );"
.IX Subsection "$bool = $self->register_callback( sub { ... } );"
This method allows you to register a callback, that is invoked
every time an accessor is called. This allows you to munge input
data, access external data stores, etc.
.PP
You are free to return whatever you wish. On a \f(CW\*(C`set\*(C'\fR call, the
data is even stored in the object.
.PP
Below is an example of the use of a callback.
.PP
.Vb 1
\&    $object\->some_method( "some_value" );
\&
\&    my $callback = sub {
\&        my $self    = shift; # the object
\&        my $meth    = shift; # "some_method"
\&        my $val     = shift; # ["some_value"]
\&                             # could be undef \-\- check \*(Aqexists\*(Aq;
\&                             # if scalar @$val is empty, it was a \*(Aqget\*(Aq
\&
\&        # your code here
\&
\&        return $new_val;     # the value you want to be set/returned
\&    }
.Ve
.PP
To access the values stored in the object, circumventing the
callback structure, you should use the \f(CW\*(C`_\|_\|_get\*(C'\fR and \f(CW\*(C`_\|_\|_set\*(C'\fR methods
documented further down.
.ie n .SS "$bool = $self\->can( \s-1METHOD_NAME\s0 )"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->can( \s-1METHOD_NAME\s0 )"
.IX Subsection "$bool = $self->can( METHOD_NAME )"
This method overrides \f(CW\*(C`UNIVERAL::can\*(C'\fR in order to provide coderefs to
accessors which are loaded on demand. It will behave just like
\&\f(CW\*(C`UNIVERSAL::can\*(C'\fR where it can \*(-- returning a class method if it exists,
or a closure pointing to a valid accessor of this particular object.
.PP
You can use it as follows:
.PP
.Vb 5
\&    $sub = $object\->can(\*(Aqsome_accessor\*(Aq);   # retrieve the coderef
\&    $sub\->(\*(Aqfoo\*(Aq);                          # \*(Aqsome_accessor\*(Aq now set
\&                                            # to \*(Aqfoo\*(Aq for $object
\&    $foo = $sub\->();                        # retrieve the contents
\&                                            # of \*(Aqsome_accessor\*(Aq
.Ve
.PP
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for more examples.
.ie n .SS "$val = $self\->_\|_\|_get( \s-1METHOD_NAME\s0 );"
.el .SS "\f(CW$val\fP = \f(CW$self\fP\->_\|_\|_get( \s-1METHOD_NAME\s0 );"
.IX Subsection "$val = $self->___get( METHOD_NAME );"
Method to directly access the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE\s0 );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE\s0 );"
.IX Subsection "$bool = $self->___set( METHOD_NAME => VALUE );"
Method to directly set the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD\s0 );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD\s0 );"
.IX Subsection "$bool = $self->___alias( ALIAS => METHOD );"
Method to directly alias one accessor to another for
this object. It circumvents all sanity checks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR!
.SH "LVALUE ACCESSORS"
.IX Header "LVALUE ACCESSORS"
\&\f(CW\*(C`Object::Accessor\*(C'\fR supports \f(CW\*(C`lvalue\*(C'\fR attributes as well. To enable
these, you should create your objects in the designated namespace,
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR. For example:
.PP
.Vb 3
\&    my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&    print $obj\->foo;
.Ve
.PP
will actually print \f(CW1\fR and work as expected. Since this is an
optional feature, that's not desirable in all cases, we require
you to explicitly use the \f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR class.
.PP
Doing the same on the standard \f(CW\*(C`Object\*(C'\fR>Accessor> class would
generate the following code & errors:
.PP
.Vb 2
\&    my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&
\&    Can\*(Aqt modify non\-lvalue subroutine call
.Ve
.PP
Note that \f(CW\*(C`lvalue\*(C'\fR support on \f(CW\*(C`AUTOLOAD\*(C'\fR routines is a
\&\f(CW\*(C`perl 5.8.x\*(C'\fR feature. See perldoc perl58delta for details.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
.IP "\(bu" 4
Allow handlers
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check it against your allow
handler. Allow handlers are therefor unsupported under \f(CW\*(C`lvalue\*(C'\fR
conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.IP "\(bu" 4
Callbacks
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check provide this value
to your callback. Furthermore, we can not distinguish between
a \f(CW\*(C`get\*(C'\fR and a \f(CW\*(C`set\*(C'\fR call. Callbacks are therefor unsupported
under \f(CW\*(C`lvalue\*(C'\fR conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$Object::Accessor::FATAL"
.el .SS "\f(CW$Object::Accessor::FATAL\fP"
.IX Subsection "$Object::Accessor::FATAL"
Set this variable to true to make all attempted access to non-existent
accessors be fatal.
This defaults to \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$Object::Accessor::DEBUG"
.el .SS "\f(CW$Object::Accessor::DEBUG\fP"
.IX Subsection "$Object::Accessor::DEBUG"
Set this variable to enable debugging output.
This defaults to \f(CW\*(C`false\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.SS "Create read-only accessors"
.IX Subsection "Create read-only accessors"
Currently all accessors are read/write for everyone. Perhaps a future
release should make it possible to have read-only accessors as well.
.SH "CAVEATS"
.IX Header "CAVEATS"
If you use codereferences for your allow handlers, you will not be able
to freeze the data structures using \f(CW\*(C`Storable\*(C'\fR.
.PP
Due to a bug in storable (until at least version 2.15), \f(CW\*(C`qr//\*(C'\fR compiled
regexes also don't de-serialize properly. Although this bug has been
reported, you should be aware of this issue when serializing your objects.
.PP
You can track the bug here:
.PP
.Vb 1
\&    http://rt.cpan.org/Ticket/Display.html?id=1827
.Ve
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-object\-accessor@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Object::Accessor5.18.3pm                     0100644 0001750 0001750 00000047577 12566207461 024717  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Object::Accessor 3pm"
.TH Object::Accessor 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Object::Accessor \- interface to create per object accessors
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 5
\&    ### using the object
\&    $obj = Object::Accessor\->new;        # create object
\&    $obj = Object::Accessor\->new(@list); # create object with accessors
\&    $obj = Object::Accessor\->new(\e%h);   # create object with accessors
\&                                         # and their allow handlers
\&
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq); # create accessors
\&    $bool   = $obj\->mk_accessors(        # create accessors with input
\&               {foo => ALLOW_HANDLER} ); # validation
\&
\&    $bool   = $obj\->mk_aliases(          # create an alias to an existing
\&                alias_name => \*(Aqmethod\*(Aq); # method name
\&
\&    $clone  = $obj\->mk_clone;            # create a clone of original
\&                                         # object without data
\&    $bool   = $obj\->mk_flush;            # clean out all data
\&
\&    @list   = $obj\->ls_accessors;        # retrieves a list of all
\&                                         # accessors for this object
\&
\&    $bar    = $obj\->foo(\*(Aqbar\*(Aq);          # set \*(Aqfoo\*(Aq to \*(Aqbar\*(Aq
\&    $bar    = $obj\->foo();               # retrieve \*(Aqbar\*(Aq again
\&
\&    $sub    = $obj\->can(\*(Aqfoo\*(Aq);          # retrieve coderef for
\&                                         # \*(Aqfoo\*(Aq accessor
\&    $bar    = $sub\->(\*(Aqbar\*(Aq);             # set \*(Aqfoo\*(Aq via coderef
\&    $bar    = $sub\->();                  # retrieve \*(Aqbar\*(Aq by coderef
\&
\&    ### using the object as base class
\&    package My::Class;
\&    use base \*(AqObject::Accessor\*(Aq;
\&
\&    $obj    = My::Class\->new;               # create base object
\&    $bool   = $obj\->mk_accessors(\*(Aqfoo\*(Aq);    # create accessors, etc...
\&
\&    ### make all attempted access to non\-existent accessors fatal
\&    ### (defaults to false)
\&    $Object::Accessor::FATAL = 1;
\&
\&    ### enable debugging
\&    $Object::Accessor::DEBUG = 1;
\&
\&    ### advanced usage \-\- callbacks
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&        $obj\->register_callback( sub { ... } );
\&
\&        $obj\->foo( 1 ); # these calls invoke the callback you registered
\&        $obj\->foo()     # which allows you to change the get/set
\&                        # behaviour and what is returned to the caller.
\&    }
\&
\&    ### advanced usage \-\- lvalue attributes
\&    {   my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&        print $obj\->foo = 1;            # will print 1
\&    }
\&
\&    ### advanced usage \-\- scoped attribute values
\&    {   my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&
\&        $obj\->foo( 1 );
\&        print $obj\->foo;                # will print 1
\&
\&        ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&        ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&        ### scope, \*(Aqfoo\*(Aqs previous value will be restored
\&        {   $obj\->foo( 2 => \emy $x );
\&            print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&        }
\&        print $obj\->foo;                # will print 1
\&    }
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\f(CW\*(C`Object::Accessor\*(C'\fR provides an interface to create per object
accessors (as opposed to per \f(CW\*(C`Class\*(C'\fR accessors, as, for example,
\&\f(CW\*(C`Class::Accessor\*(C'\fR provides).
.PP
You can choose to either subclass this module, and thus using its
accessors on your own module, or to store an \f(CW\*(C`Object::Accessor\*(C'\fR
object inside your own object, and access the accessors from there.
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for examples.
.SH "METHODS"
.IX Header "METHODS"
.ie n .SS "$object = Object::Accessor\->new( [\s-1ARGS\s0] );"
.el .SS "\f(CW$object\fP = Object::Accessor\->new( [\s-1ARGS\s0] );"
.IX Subsection "$object = Object::Accessor->new( [ARGS] );"
Creates a new (and empty) \f(CW\*(C`Object::Accessor\*(C'\fR object. This method is
inheritable.
.PP
Any arguments given to \f(CW\*(C`new\*(C'\fR are passed straight to \f(CW\*(C`mk_accessors\*(C'\fR.
.PP
If you want to be able to assign to your accessors as if they
were \f(CW\*(C`lvalue\*(C'\fRs, you should create your object in the
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR namespace instead. See the section
on \f(CW\*(C`LVALUE ACCESSORS\*(C'\fR below.
.ie n .SS "$bool = $object\->mk_accessors( @ACCESSORS | \e%ACCESSOR_MAP );"
.el .SS "\f(CW$bool\fP = \f(CW$object\fP\->mk_accessors( \f(CW@ACCESSORS\fP | \e%ACCESSOR_MAP );"
.IX Subsection "$bool = $object->mk_accessors( @ACCESSORS | %ACCESSOR_MAP );"
Creates a list of accessors for this object (and \f(CW\*(C`NOT\*(C'\fR for other ones
in the same class!).
Will not clobber existing data, so if an accessor already exists,
requesting to create again is effectively a \f(CW\*(C`no\-op\*(C'\fR.
.PP
When providing a \f(CW\*(C`hashref\*(C'\fR as argument, rather than a normal list,
you can specify a list of key/value pairs of accessors and their
respective input validators. The validators can be anything that
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow\*(C'\fR function accepts. Please see its manpage
for details.
.PP
For example:
.PP
.Vb 5
\&    $object\->mk_accessors( {
\&        foo     => qr/^\ed+$/,       # digits only
\&        bar     => [0,1],           # booleans
\&        zot     => \e&my_sub         # a custom verification sub
\&    } );
.Ve
.PP
Returns true on success, false on failure.
.PP
Accessors that are called on an object, that do not exist return
\&\f(CW\*(C`undef\*(C'\fR by default, but you can make this a fatal error by setting the
global variable \f(CW$FATAL\fR to true. See the section on \f(CW\*(C`GLOBAL
VARIABLES\*(C'\fR for details.
.PP
Note that you can bind the values of attributes to a scope. This allows
you to \f(CW\*(C`temporarily\*(C'\fR change a value of an attribute, and have it's
original value restored up on the end of it's bound variable's scope;
.PP
For example, in this snippet of code, the attribute \f(CW\*(C`foo\*(C'\fR will
temporarily be set to \f(CW2\fR, until the end of the scope of \f(CW$x\fR, at
which point the original value of \f(CW1\fR will be restored.
.PP
.Vb 1
\&    my $obj = Object::Accessor\->new;
\&
\&    $obj\->mk_accessors(\*(Aqfoo\*(Aq);
\&    $obj\->foo( 1 );
\&    print $obj\->foo;                # will print 1
\&
\&    ### bind the scope of the value of attribute \*(Aqfoo\*(Aq
\&    ### to the scope of \*(Aq$x\*(Aq \-\- when $x goes out of
\&    ### scope, \*(Aqfoo\*(Aq previous value will be restored
\&    {   $obj\->foo( 2 => \emy $x );
\&        print $obj\->foo, \*(Aq \*(Aq, $x;   # will print \*(Aq2 2\*(Aq
\&    }
\&    print $obj\->foo;                # will print 1
.Ve
.PP
Note that all accessors are read/write for everyone. See the \f(CW\*(C`TODO\*(C'\fR
section for details.
.ie n .SS "@list = $self\->ls_accessors;"
.el .SS "\f(CW@list\fP = \f(CW$self\fP\->ls_accessors;"
.IX Subsection "@list = $self->ls_accessors;"
Returns a list of accessors that are supported by the current object.
The corresponding coderefs can be retrieved by passing this list one
by one to the \f(CW\*(C`can\*(C'\fR method.
.ie n .SS "$ref = $self\->ls_allow(\s-1KEY\s0)"
.el .SS "\f(CW$ref\fP = \f(CW$self\fP\->ls_allow(\s-1KEY\s0)"
.IX Subsection "$ref = $self->ls_allow(KEY)"
Returns the allow handler for the given key, which can be used with
\&\f(CW\*(C`Params::Check\*(C'\fR's \f(CW\*(C`allow()\*(C'\fR handler. If there was no allow handler
specified, an allow handler that always returns true will be returned.
.ie n .SS "$bool = $self\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_aliases( alias => method, [alias2 => method2, ...] );"
.IX Subsection "$bool = $self->mk_aliases( alias => method, [alias2 => method2, ...] );"
Creates an alias for a given method name. For all intents and purposes,
these two accessors are now identical for this object. This is akin to
doing the following on the symbol table level:
.PP
.Vb 1
\&  *alias = *method
.Ve
.PP
This allows you to do the following:
.PP
.Vb 2
\&  $self\->mk_accessors(\*(Aqfoo\*(Aq);
\&  $self\->mk_aliases( bar => \*(Aqfoo\*(Aq );
\&
\&  $self\->bar( 42 );
\&  print $self\->foo;     # will print 42
.Ve
.ie n .SS "$clone = $self\->mk_clone;"
.el .SS "\f(CW$clone\fP = \f(CW$self\fP\->mk_clone;"
.IX Subsection "$clone = $self->mk_clone;"
Makes a clone of the current object, which will have the exact same
accessors as the current object, but without the data stored in them.
.ie n .SS "$bool = $self\->mk_flush;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_flush;"
.IX Subsection "$bool = $self->mk_flush;"
Flushes all the data from the current object; all accessors will be
set back to their default state of \f(CW\*(C`undef\*(C'\fR.
.PP
Returns true on success and false on failure.
.ie n .SS "$bool = $self\->mk_verify;"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->mk_verify;"
.IX Subsection "$bool = $self->mk_verify;"
Checks if all values in the current object are in accordance with their
own allow handler. Specifically useful to check if an empty initialised
object has been filled with values satisfying their own allow criteria.
.ie n .SS "$bool = $self\->register_callback( sub { ... } );"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->register_callback( sub { ... } );"
.IX Subsection "$bool = $self->register_callback( sub { ... } );"
This method allows you to register a callback, that is invoked
every time an accessor is called. This allows you to munge input
data, access external data stores, etc.
.PP
You are free to return whatever you wish. On a \f(CW\*(C`set\*(C'\fR call, the
data is even stored in the object.
.PP
Below is an example of the use of a callback.
.PP
.Vb 1
\&    $object\->some_method( "some_value" );
\&
\&    my $callback = sub {
\&        my $self    = shift; # the object
\&        my $meth    = shift; # "some_method"
\&        my $val     = shift; # ["some_value"]
\&                             # could be undef \-\- check \*(Aqexists\*(Aq;
\&                             # if scalar @$val is empty, it was a \*(Aqget\*(Aq
\&
\&        # your code here
\&
\&        return $new_val;     # the value you want to be set/returned
\&    }
.Ve
.PP
To access the values stored in the object, circumventing the
callback structure, you should use the \f(CW\*(C`_\|_\|_get\*(C'\fR and \f(CW\*(C`_\|_\|_set\*(C'\fR methods
documented further down.
.ie n .SS "$bool = $self\->can( \s-1METHOD_NAME \s0)"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->can( \s-1METHOD_NAME \s0)"
.IX Subsection "$bool = $self->can( METHOD_NAME )"
This method overrides \f(CW\*(C`UNIVERAL::can\*(C'\fR in order to provide coderefs to
accessors which are loaded on demand. It will behave just like
\&\f(CW\*(C`UNIVERSAL::can\*(C'\fR where it can \*(-- returning a class method if it exists,
or a closure pointing to a valid accessor of this particular object.
.PP
You can use it as follows:
.PP
.Vb 5
\&    $sub = $object\->can(\*(Aqsome_accessor\*(Aq);   # retrieve the coderef
\&    $sub\->(\*(Aqfoo\*(Aq);                          # \*(Aqsome_accessor\*(Aq now set
\&                                            # to \*(Aqfoo\*(Aq for $object
\&    $foo = $sub\->();                        # retrieve the contents
\&                                            # of \*(Aqsome_accessor\*(Aq
.Ve
.PP
See the \f(CW\*(C`SYNOPSIS\*(C'\fR for more examples.
.ie n .SS "$val = $self\->_\|_\|_get( \s-1METHOD_NAME \s0);"
.el .SS "\f(CW$val\fP = \f(CW$self\fP\->_\|_\|_get( \s-1METHOD_NAME \s0);"
.IX Subsection "$val = $self->___get( METHOD_NAME );"
Method to directly access the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE \s0);"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_set( \s-1METHOD_NAME\s0 => \s-1VALUE \s0);"
.IX Subsection "$bool = $self->___set( METHOD_NAME => VALUE );"
Method to directly set the value of the given accessor in the
object. It circumvents all calls to allow checks, callbacks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR! General usage for
this functionality would be in your own custom callbacks.
.ie n .SS "$bool = $self\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD \s0);"
.el .SS "\f(CW$bool\fP = \f(CW$self\fP\->_\|_\|_alias( \s-1ALIAS\s0 => \s-1METHOD \s0);"
.IX Subsection "$bool = $self->___alias( ALIAS => METHOD );"
Method to directly alias one accessor to another for
this object. It circumvents all sanity checks, etc.
.PP
Use only if you \f(CW\*(C`Know What You Are Doing\*(C'\fR!
.SH "LVALUE ACCESSORS"
.IX Header "LVALUE ACCESSORS"
\&\f(CW\*(C`Object::Accessor\*(C'\fR supports \f(CW\*(C`lvalue\*(C'\fR attributes as well. To enable
these, you should create your objects in the designated namespace,
\&\f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR. For example:
.PP
.Vb 3
\&    my $obj = Object::Accessor::Lvalue\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&    print $obj\->foo;
.Ve
.PP
will actually print \f(CW1\fR and work as expected. Since this is an
optional feature, that's not desirable in all cases, we require
you to explicitly use the \f(CW\*(C`Object::Accessor::Lvalue\*(C'\fR class.
.PP
Doing the same on the standard \f(CW\*(C`Object\*(C'\fR>Accessor> class would
generate the following code & errors:
.PP
.Vb 2
\&    my $obj = Object::Accessor\->new(\*(Aqfoo\*(Aq);
\&    $obj\->foo += 1;
\&
\&    Can\*(Aqt modify non\-lvalue subroutine call
.Ve
.PP
Note that \f(CW\*(C`lvalue\*(C'\fR support on \f(CW\*(C`AUTOLOAD\*(C'\fR routines is a
\&\f(CW\*(C`perl 5.8.x\*(C'\fR feature. See perldoc perl58delta for details.
.SS "\s-1CAVEATS\s0"
.IX Subsection "CAVEATS"
.IP "\(bu" 4
Allow handlers
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check it against your allow
handler. Allow handlers are therefor unsupported under \f(CW\*(C`lvalue\*(C'\fR
conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.IP "\(bu" 4
Callbacks
.Sp
Due to the nature of \f(CW\*(C`lvalue subs\*(C'\fR, we never get access to the
value you are assigning, so we can not check provide this value
to your callback. Furthermore, we can not distinguish between
a \f(CW\*(C`get\*(C'\fR and a \f(CW\*(C`set\*(C'\fR call. Callbacks are therefor unsupported
under \f(CW\*(C`lvalue\*(C'\fR conditions.
.Sp
See \f(CW\*(C`perldoc perlsub\*(C'\fR for details.
.SH "GLOBAL VARIABLES"
.IX Header "GLOBAL VARIABLES"
.ie n .SS "$Object::Accessor::FATAL"
.el .SS "\f(CW$Object::Accessor::FATAL\fP"
.IX Subsection "$Object::Accessor::FATAL"
Set this variable to true to make all attempted access to non-existent
accessors be fatal.
This defaults to \f(CW\*(C`false\*(C'\fR.
.ie n .SS "$Object::Accessor::DEBUG"
.el .SS "\f(CW$Object::Accessor::DEBUG\fP"
.IX Subsection "$Object::Accessor::DEBUG"
Set this variable to enable debugging output.
This defaults to \f(CW\*(C`false\*(C'\fR.
.SH "TODO"
.IX Header "TODO"
.SS "Create read-only accessors"
.IX Subsection "Create read-only accessors"
Currently all accessors are read/write for everyone. Perhaps a future
release should make it possible to have read-only accessors as well.
.SH "CAVEATS"
.IX Header "CAVEATS"
If you use codereferences for your allow handlers, you will not be able
to freeze the data structures using \f(CW\*(C`Storable\*(C'\fR.
.PP
Due to a bug in storable (until at least version 2.15), \f(CW\*(C`qr//\*(C'\fR compiled
regexes also don't de-serialize properly. Although this bug has been
reported, you should be aware of this issue when serializing your objects.
.PP
You can track the bug here:
.PP
.Vb 1
\&    http://rt.cpan.org/Ticket/Display.html?id=1827
.Ve
.SH "BUG REPORTS"
.IX Header "BUG REPORTS"
Please report bugs or other issues to <bug\-object\-accessor@rt.cpan.org>.
.SH "AUTHOR"
.IX Header "AUTHOR"
This module by Jos Boumans <kane@cpan.org>.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
This library is free software; you may redistribute and/or modify it
under the same terms as Perl itself.
                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Opcode.3pm                                   0100644 0001750 0001750 00000047166 12566207461 022531  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Opcode 3pm"
.TH Opcode 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Opcode \- Disable named opcodes when compiling perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Opcode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl code is always compiled into an internal format before execution.
.PP
Evaluating perl code (e.g. via \*(L"eval\*(R" or \*(L"do 'file'\*(R") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
The internal format is based on many distinct \fIopcodes\fR.
.PP
By default no opmask is in effect and any code can be compiled.
.PP
The Opcode module allow you to define an \fIoperator mask\fR to be in
effect when perl \fInext\fR compiles any code.  Attempting to compile code
which contains a masked opcode will cause the compilation to fail
with an error. The code will not be executed.
.SH "NOTE"
.IX Header "NOTE"
The Opcode module is not usually used directly. See the ops pragma and
Safe modules for more typical uses.
.SH "WARNING"
.IX Header "WARNING"
The authors make \fBno warranty\fR, implied or otherwise, about the
suitability of this software for safety or security purposes.
.PP
The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.
.PP
Your mileage will vary. If in any doubt \fBdo not use it\fR.
.SH "Operator Names and Operator Lists"
.IX Header "Operator Names and Operator Lists"
The canonical list of operator names is the contents of the array
PL_op_name defined and initialised in file \fIopcode.h\fR of the Perl
source distribution (and installed into the perl library).
.PP
Each operator has both a terse name (its opname) and a more verbose or
recognisable descriptive name. The opdesc function can be used to
return a list of descriptions for a list of operators.
.PP
Many of the functions and methods listed below take a list of
operators as parameters. Most operator lists can be made up of several
types of element. Each element can be one of
.IP "an operator name (opname)" 8
.IX Item "an operator name (opname)"
Operator names are typically small lowercase words like enterloop,
leaveloop, last, next, redo etc. Sometimes they are rather cryptic
like gv2cv, i_ncmp and ftsvtx.
.IP "an operator tag name (optag)" 8
.IX Item "an operator tag name (optag)"
Operator tags can be used to refer to groups (or sets) of operators.
Tag names always begin with a colon. The Opcode module defines several
optags and the user can define others using the define_optag function.
.IP "a negated opname or optag" 8
.IX Item "a negated opname or optag"
An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir.
Negating an opname or optag means remove the corresponding ops from the
accumulated set of ops at that point.
.IP "an operator set (opset)" 8
.IX Item "an operator set (opset)"
An \fIopset\fR as a binary string of approximately 44 bytes which holds a
set or zero or more operators.
.Sp
The opset and opset_to_ops functions can be used to convert from
a list of operators to an opset and \fIvice versa\fR.
.Sp
Wherever a list of operators can be given you can use one or more opsets.
See also Manipulating Opsets below.
.SH "Opcode Functions"
.IX Header "Opcode Functions"
The Opcode package contains functions for manipulating operator names
tags and sets. All are available for export by the package.
.IP "opcodes" 8
.IX Item "opcodes"
In a scalar context opcodes returns the number of opcodes in this
version of perl (around 350 for perl\-5.7.0).
.Sp
In a list context it returns a list of all the operator names.
(Not yet implemented, use \f(CW@names\fR = opset_to_ops(full_opset).)
.IP "opset (\s-1OP, ...\s0)" 8
.IX Item "opset (OP, ...)"
Returns an opset containing the listed operators.
.IP "opset_to_ops (\s-1OPSET\s0)" 8
.IX Item "opset_to_ops (OPSET)"
Returns a list of operator names corresponding to those operators in
the set.
.IP "opset_to_hex (\s-1OPSET\s0)" 8
.IX Item "opset_to_hex (OPSET)"
Returns a string representation of an opset. Can be handy for debugging.
.IP "full_opset" 8
.IX Item "full_opset"
Returns an opset which includes all operators.
.IP "empty_opset" 8
.IX Item "empty_opset"
Returns an opset which contains no operators.
.IP "invert_opset (\s-1OPSET\s0)" 8
.IX Item "invert_opset (OPSET)"
Returns an opset which is the inverse set of the one supplied.
.IP "verify_opset (\s-1OPSET, ...\s0)" 8
.IX Item "verify_opset (OPSET, ...)"
Returns true if the supplied opset looks like a valid opset (is the
right length etc) otherwise it returns false. If an optional second
parameter is true then verify_opset will croak on an invalid opset
instead of returning false.
.Sp
Most of the other Opcode functions call verify_opset automatically
and will croak if given an invalid opset.
.IP "define_optag (\s-1OPTAG, OPSET\s0)" 8
.IX Item "define_optag (OPTAG, OPSET)"
Define \s-1OPTAG\s0 as a symbolic name for \s-1OPSET.\s0 Optag names always start
with a colon \f(CW\*(C`:\*(C'\fR.
.Sp
The optag name used must not be defined already (define_optag will
croak if it is already defined). Optag names are global to the perl
process and optag definitions cannot be altered or deleted once
defined.
.Sp
It is strongly recommended that applications using Opcode should use a
leading capital letter on their tag names since lowercase names are
reserved for use by the Opcode module. If using Opcode within a module
you should prefix your tags names with the name of your module to
ensure uniqueness and thus avoid clashes with other modules.
.IP "opmask_add (\s-1OPSET\s0)" 8
.IX Item "opmask_add (OPSET)"
Adds the supplied opset to the current opmask. Note that there is
currently \fIno\fR mechanism for unmasking ops once they have been masked.
This is intentional.
.IP "opmask" 8
.IX Item "opmask"
Returns an opset corresponding to the current opmask.
.IP "opdesc (\s-1OP, ...\s0)" 8
.IX Item "opdesc (OP, ...)"
This takes a list of operator names and returns the corresponding list
of operator descriptions.
.IP "opdump (\s-1PAT\s0)" 8
.IX Item "opdump (PAT)"
Dumps to \s-1STDOUT\s0 a two column list of op names and op descriptions.
If an optional pattern is given then only lines which match the
(case insensitive) pattern will be output.
.Sp
It's designed to be used as a handy command line utility:
.Sp
.Vb 2
\&        perl \-MOpcode=opdump \-e opdump
\&        perl \-MOpcode=opdump \-e \*(Aqopdump Eval\*(Aq
.Ve
.SH "Manipulating Opsets"
.IX Header "Manipulating Opsets"
Opsets may be manipulated using the perl bit vector operators & (and), | (or),
^ (xor) and ~ (negate/invert).
.PP
However you should never rely on the numerical position of any opcode
within the opset. In other words both sides of a bit vector operator
should be opsets returned from Opcode functions.
.PP
Also, since the number of opcodes in your current version of perl might
not be an exact multiple of eight, there may be unused bits in the last
byte of an upset. This should not cause any problems (Opcode functions
ignore those extra bits) but it does mean that using the ~ operator
will typically not produce the same 'physical' opset 'string' as the
invert_opset function.
.SH "TO DO (maybe)"
.IX Header "TO DO (maybe)"
.Vb 3
\&    $bool = opset_eq($opset1, $opset2)  true if opsets are logically
\&                                        equivalent
\&    $yes = opset_can($opset, @ops)      true if $opset has all @ops set
\&
\&    @diff = opset_diff($opset1, $opset2) => (\*(Aqfoo\*(Aq, \*(Aq!bar\*(Aq, ...)
.Ve
.SH "Predefined Opcode Tags"
.IX Header "Predefined Opcode Tags"
.IP ":base_core" 5
.IX Item ":base_core"
.Vb 1
\&    null stub scalar pushmark wantarray const defined undef
\&
\&    rv2sv sassign
\&
\&    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
\&
\&    rv2hv helem hslice each values keys exists delete aeach akeys
\&    avalues reach rvalues rkeys
\&
\&    preinc i_preinc predec i_predec postinc i_postinc
\&    postdec i_postdec int hex oct abs pow multiply i_multiply
\&    divide i_divide modulo i_modulo add i_add subtract i_subtract
\&
\&    left_shift right_shift bit_and bit_xor bit_or negate i_negate
\&    not complement
\&
\&    lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
\&    slt sgt sle sge seq sne scmp
\&
\&    substr vec stringify study pos length index rindex ord chr
\&
\&    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop
\&    chomp schomp
\&
\&    match split qr
\&
\&    list lslice splice push pop shift unshift reverse
\&
\&    cond_expr flip flop andassign orassign dorassign and or dor xor
\&
\&    warn die lineseq nextstate scope enter leave
\&
\&    rv2cv anoncode prototype coreargs
\&
\&    entersub leavesub leavesublv return method method_named
\&     \-\- XXX loops via recursion?
\&
\&    leaveeval \-\- needed for Safe to operate, is safe
\&                 without entereval
.Ve
.IP ":base_mem" 5
.IX Item ":base_mem"
These memory related ops are not included in :base_core because they
can easily be used to implement a resource attack (e.g., consume all
available memory).
.Sp
.Vb 1
\&    concat repeat join range
\&
\&    anonlist anonhash
.Ve
.Sp
Note that despite the existence of this optag a memory resource attack
may still be possible using only :base_core ops.
.Sp
Disabling these ops is a \fIvery\fR heavy handed way to attempt to prevent
a memory resource attack. It's probable that a specific memory limit
mechanism will be added to perl in the near future.
.IP ":base_loop" 5
.IX Item ":base_loop"
These loop ops are not included in :base_core because they can easily be
used to implement a resource attack (e.g., consume all available \s-1CPU\s0 time).
.Sp
.Vb 6
\&    grepstart grepwhile
\&    mapstart mapwhile
\&    enteriter iter
\&    enterloop leaveloop unstack
\&    last next redo
\&    goto
.Ve
.IP ":base_io" 5
.IX Item ":base_io"
These ops enable \fIfilehandle\fR (rather than filename) based input and
output. These are safe on the assumption that only pre-existing
filehandles are available for use.  Usually, to create new filehandles
other ops such as open would need to be enabled, if you don't take into
account the magical open of \s-1ARGV.\s0
.Sp
.Vb 1
\&    readline rcatline getc read
\&
\&    formline enterwrite leavewrite
\&
\&    print say sysread syswrite send recv
\&
\&    eof tell seek sysseek
\&
\&    readdir telldir seekdir rewinddir
.Ve
.IP ":base_orig" 5
.IX Item ":base_orig"
These are a hotchpotch of opcodes still waiting to be considered
.Sp
.Vb 1
\&    gvsv gv gelem
\&
\&    padsv padav padhv padcv padany padrange introcv clonecv
\&
\&    once
\&
\&    rv2gv refgen srefgen ref
\&
\&    bless \-\- could be used to change ownership of objects
\&             (reblessing)
\&
\&    pushre regcmaybe regcreset regcomp subst substcont
\&
\&    sprintf prtf \-\- can core dump
\&
\&    crypt
\&
\&    tie untie
\&
\&    dbmopen dbmclose
\&    sselect select
\&    pipe_op sockpair
\&
\&    getppid getpgrp setpgrp getpriority setpriority
\&    localtime gmtime
\&
\&    entertry leavetry \-\- can be used to \*(Aqhide\*(Aq fatal errors
\&
\&    entergiven leavegiven
\&    enterwhen leavewhen
\&    break continue
\&    smartmatch
\&
\&    custom \-\- where should this go
.Ve
.IP ":base_math" 5
.IX Item ":base_math"
These ops are not included in :base_core because of the risk of them being
used to generate floating point exceptions (which would have to be caught
using a \f(CW$SIG\fR{\s-1FPE\s0} handler).
.Sp
.Vb 1
\&    atan2 sin cos exp log sqrt
.Ve
.Sp
These ops are not included in :base_core because they have an effect
beyond the scope of the compartment.
.Sp
.Vb 1
\&    rand srand
.Ve
.IP ":base_thread" 5
.IX Item ":base_thread"
These ops are related to multi-threading.
.Sp
.Vb 1
\&    lock
.Ve
.IP ":default" 5
.IX Item ":default"
A handy tag name for a \fIreasonable\fR default set of ops.  (The current ops
allowed are unstable while development continues. It will change.)
.Sp
.Vb 1
\&    :base_core :base_mem :base_loop :base_orig :base_thread
.Ve
.Sp
This list used to contain :base_io prior to Opcode 1.07.
.Sp
If safety matters to you (and why else would you be using the Opcode module?)
then you should not rely on the definition of this, or indeed any other, optag!
.IP ":filesys_read" 5
.IX Item ":filesys_read"
.Vb 1
\&    stat lstat readlink
\&
\&    ftatime ftblk ftchr ftctime ftdir fteexec fteowned
\&    fteread ftewrite ftfile ftis ftlink ftmtime ftpipe
\&    ftrexec ftrowned ftrread ftsgid ftsize ftsock ftsuid
\&    fttty ftzero ftrwrite ftsvtx
\&
\&    fttext ftbinary
\&
\&    fileno
.Ve
.IP ":sys_db" 5
.IX Item ":sys_db"
.Vb 4
\&    ghbyname ghbyaddr ghostent shostent ehostent      \-\- hosts
\&    gnbyname gnbyaddr gnetent snetent enetent         \-\- networks
\&    gpbyname gpbynumber gprotoent sprotoent eprotoent \-\- protocols
\&    gsbyname gsbyport gservent sservent eservent      \-\- services
\&
\&    gpwnam gpwuid gpwent spwent epwent getlogin       \-\- users
\&    ggrnam ggrgid ggrent sgrent egrent                \-\- groups
.Ve
.IP ":browse" 5
.IX Item ":browse"
A handy tag name for a \fIreasonable\fR default set of ops beyond the
:default optag.  Like :default (and indeed all the other optags) its
current definition is unstable while development continues. It will change.
.Sp
The :browse tag represents the next step beyond :default. It it a
superset of the :default ops and adds :filesys_read the :sys_db.
The intent being that scripts can access more (possibly sensitive)
information about your system but not be able to change it.
.Sp
.Vb 1
\&    :default :filesys_read :sys_db
.Ve
.IP ":filesys_open" 5
.IX Item ":filesys_open"
.Vb 2
\&    sysopen open close
\&    umask binmode
\&
\&    open_dir closedir \-\- other dir ops are in :base_io
.Ve
.IP ":filesys_write" 5
.IX Item ":filesys_write"
.Vb 1
\&    link unlink rename symlink truncate
\&
\&    mkdir rmdir
\&
\&    utime chmod chown
\&
\&    fcntl \-\- not strictly filesys related, but possibly as
\&             dangerous?
.Ve
.IP ":subprocess" 5
.IX Item ":subprocess"
.Vb 1
\&    backtick system
\&
\&    fork
\&
\&    wait waitpid
\&
\&    glob \-\- access to Cshell via <\`rm *\`>
.Ve
.IP ":ownprocess" 5
.IX Item ":ownprocess"
.Vb 1
\&    exec exit kill
\&
\&    time tms \-\- could be used for timing attacks (paranoid?)
.Ve
.IP ":others" 5
.IX Item ":others"
This tag holds groups of assorted specialist opcodes that don't warrant
having optags defined for them.
.Sp
SystemV Interprocess Communications:
.Sp
.Vb 1
\&    msgctl msgget msgrcv msgsnd
\&
\&    semctl semget semop
\&
\&    shmctl shmget shmread shmwrite
.Ve
.IP ":load" 5
.IX Item ":load"
This tag holds opcodes related to loading modules and getting information
about calling environment and args.
.Sp
.Vb 2
\&    require dofile 
\&    caller runcv
.Ve
.IP ":still_to_be_decided" 5
.IX Item ":still_to_be_decided"
.Vb 2
\&    chdir
\&    flock ioctl
\&
\&    socket getpeername ssockopt
\&    bind connect listen accept shutdown gsockopt getsockname
\&
\&    sleep alarm \-\- changes global timer state and signal handling
\&    sort \-\- assorted problems including core dumps
\&    tied \-\- can be used to access object implementing a tie
\&    pack unpack \-\- can be used to create/use memory pointers
\&
\&    hintseval \-\- constant op holding eval hints
\&
\&    entereval \-\- can be used to hide code from initial compile
\&
\&    reset
\&
\&    dbstate \-\- perl \-d version of nextstate(ment) opcode
.Ve
.IP ":dangerous" 5
.IX Item ":dangerous"
This tag is simply a bucket for opcodes that are unlikely to be used via
a tag name but need to be tagged for completeness and documentation.
.Sp
.Vb 1
\&    syscall dump chroot
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ops \*(-- perl pragma interface to Opcode module.
.PP
Safe \*(-- Opcode and namespace limited execution compartments
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally designed and implemented by Malcolm Beattie,
mbeattie@sable.ox.ac.uk as part of Safe version 1.
.PP
Split out from Safe module version 1, named opcode tags and other
changes added by Tim Bunce.
                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Opcode5.16.3pm                               0100644 0001750 0001750 00000046437 12566207437 023046  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Opcode 3pm"
.TH Opcode 3pm "2013-03-04" "perl v5.16.3" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Opcode \- Disable named opcodes when compiling perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Opcode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl code is always compiled into an internal format before execution.
.PP
Evaluating perl code (e.g. via \*(L"eval\*(R" or \*(L"do 'file'\*(R") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
The internal format is based on many distinct \fIopcodes\fR.
.PP
By default no opmask is in effect and any code can be compiled.
.PP
The Opcode module allow you to define an \fIoperator mask\fR to be in
effect when perl \fInext\fR compiles any code.  Attempting to compile code
which contains a masked opcode will cause the compilation to fail
with an error. The code will not be executed.
.SH "NOTE"
.IX Header "NOTE"
The Opcode module is not usually used directly. See the ops pragma and
Safe modules for more typical uses.
.SH "WARNING"
.IX Header "WARNING"
The authors make \fBno warranty\fR, implied or otherwise, about the
suitability of this software for safety or security purposes.
.PP
The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.
.PP
Your mileage will vary. If in any doubt \fBdo not use it\fR.
.SH "Operator Names and Operator Lists"
.IX Header "Operator Names and Operator Lists"
The canonical list of operator names is the contents of the array
PL_op_name defined and initialised in file \fIopcode.h\fR of the Perl
source distribution (and installed into the perl library).
.PP
Each operator has both a terse name (its opname) and a more verbose or
recognisable descriptive name. The opdesc function can be used to
return a list of descriptions for a list of operators.
.PP
Many of the functions and methods listed below take a list of
operators as parameters. Most operator lists can be made up of several
types of element. Each element can be one of
.IP "an operator name (opname)" 8
.IX Item "an operator name (opname)"
Operator names are typically small lowercase words like enterloop,
leaveloop, last, next, redo etc. Sometimes they are rather cryptic
like gv2cv, i_ncmp and ftsvtx.
.IP "an operator tag name (optag)" 8
.IX Item "an operator tag name (optag)"
Operator tags can be used to refer to groups (or sets) of operators.
Tag names always begin with a colon. The Opcode module defines several
optags and the user can define others using the define_optag function.
.IP "a negated opname or optag" 8
.IX Item "a negated opname or optag"
An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir.
Negating an opname or optag means remove the corresponding ops from the
accumulated set of ops at that point.
.IP "an operator set (opset)" 8
.IX Item "an operator set (opset)"
An \fIopset\fR as a binary string of approximately 44 bytes which holds a
set or zero or more operators.
.Sp
The opset and opset_to_ops functions can be used to convert from
a list of operators to an opset and \fIvice versa\fR.
.Sp
Wherever a list of operators can be given you can use one or more opsets.
See also Manipulating Opsets below.
.SH "Opcode Functions"
.IX Header "Opcode Functions"
The Opcode package contains functions for manipulating operator names
tags and sets. All are available for export by the package.
.IP "opcodes" 8
.IX Item "opcodes"
In a scalar context opcodes returns the number of opcodes in this
version of perl (around 350 for perl\-5.7.0).
.Sp
In a list context it returns a list of all the operator names.
(Not yet implemented, use \f(CW@names\fR = opset_to_ops(full_opset).)
.IP "opset (\s-1OP\s0, ...)" 8
.IX Item "opset (OP, ...)"
Returns an opset containing the listed operators.
.IP "opset_to_ops (\s-1OPSET\s0)" 8
.IX Item "opset_to_ops (OPSET)"
Returns a list of operator names corresponding to those operators in
the set.
.IP "opset_to_hex (\s-1OPSET\s0)" 8
.IX Item "opset_to_hex (OPSET)"
Returns a string representation of an opset. Can be handy for debugging.
.IP "full_opset" 8
.IX Item "full_opset"
Returns an opset which includes all operators.
.IP "empty_opset" 8
.IX Item "empty_opset"
Returns an opset which contains no operators.
.IP "invert_opset (\s-1OPSET\s0)" 8
.IX Item "invert_opset (OPSET)"
Returns an opset which is the inverse set of the one supplied.
.IP "verify_opset (\s-1OPSET\s0, ...)" 8
.IX Item "verify_opset (OPSET, ...)"
Returns true if the supplied opset looks like a valid opset (is the
right length etc) otherwise it returns false. If an optional second
parameter is true then verify_opset will croak on an invalid opset
instead of returning false.
.Sp
Most of the other Opcode functions call verify_opset automatically
and will croak if given an invalid opset.
.IP "define_optag (\s-1OPTAG\s0, \s-1OPSET\s0)" 8
.IX Item "define_optag (OPTAG, OPSET)"
Define \s-1OPTAG\s0 as a symbolic name for \s-1OPSET\s0. Optag names always start
with a colon \f(CW\*(C`:\*(C'\fR.
.Sp
The optag name used must not be defined already (define_optag will
croak if it is already defined). Optag names are global to the perl
process and optag definitions cannot be altered or deleted once
defined.
.Sp
It is strongly recommended that applications using Opcode should use a
leading capital letter on their tag names since lowercase names are
reserved for use by the Opcode module. If using Opcode within a module
you should prefix your tags names with the name of your module to
ensure uniqueness and thus avoid clashes with other modules.
.IP "opmask_add (\s-1OPSET\s0)" 8
.IX Item "opmask_add (OPSET)"
Adds the supplied opset to the current opmask. Note that there is
currently \fIno\fR mechanism for unmasking ops once they have been masked.
This is intentional.
.IP "opmask" 8
.IX Item "opmask"
Returns an opset corresponding to the current opmask.
.IP "opdesc (\s-1OP\s0, ...)" 8
.IX Item "opdesc (OP, ...)"
This takes a list of operator names and returns the corresponding list
of operator descriptions.
.IP "opdump (\s-1PAT\s0)" 8
.IX Item "opdump (PAT)"
Dumps to \s-1STDOUT\s0 a two column list of op names and op descriptions.
If an optional pattern is given then only lines which match the
(case insensitive) pattern will be output.
.Sp
It's designed to be used as a handy command line utility:
.Sp
.Vb 2
\&        perl \-MOpcode=opdump \-e opdump
\&        perl \-MOpcode=opdump \-e \*(Aqopdump Eval\*(Aq
.Ve
.SH "Manipulating Opsets"
.IX Header "Manipulating Opsets"
Opsets may be manipulated using the perl bit vector operators & (and), | (or),
^ (xor) and ~ (negate/invert).
.PP
However you should never rely on the numerical position of any opcode
within the opset. In other words both sides of a bit vector operator
should be opsets returned from Opcode functions.
.PP
Also, since the number of opcodes in your current version of perl might
not be an exact multiple of eight, there may be unused bits in the last
byte of an upset. This should not cause any problems (Opcode functions
ignore those extra bits) but it does mean that using the ~ operator
will typically not produce the same 'physical' opset 'string' as the
invert_opset function.
.SH "TO DO (maybe)"
.IX Header "TO DO (maybe)"
.Vb 1
\&    $bool = opset_eq($opset1, $opset2)  true if opsets are logically eqiv
\&
\&    $yes = opset_can($opset, @ops)      true if $opset has all @ops set
\&
\&    @diff = opset_diff($opset1, $opset2) => (\*(Aqfoo\*(Aq, \*(Aq!bar\*(Aq, ...)
.Ve
.SH "Predefined Opcode Tags"
.IX Header "Predefined Opcode Tags"
.IP ":base_core" 5
.IX Item ":base_core"
.Vb 1
\&    null stub scalar pushmark wantarray const defined undef
\&
\&    rv2sv sassign
\&
\&    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
\&
\&    rv2hv helem hslice each values keys exists delete aeach akeys avalues
\&    boolkeys reach rvalues rkeys
\&
\&    preinc i_preinc predec i_predec postinc i_postinc postdec i_postdec
\&    int hex oct abs pow multiply i_multiply divide i_divide
\&    modulo i_modulo add i_add subtract i_subtract
\&
\&    left_shift right_shift bit_and bit_xor bit_or negate i_negate
\&    not complement
\&
\&    lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
\&    slt sgt sle sge seq sne scmp
\&
\&    substr vec stringify study pos length index rindex ord chr
\&
\&    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop chomp schomp
\&
\&    match split qr
\&
\&    list lslice splice push pop shift unshift reverse
\&
\&    cond_expr flip flop andassign orassign dorassign and or dor xor
\&
\&    warn die lineseq nextstate scope enter leave
\&
\&    rv2cv anoncode prototype coreargs
\&
\&    entersub leavesub leavesublv return method method_named \-\- XXX loops via recursion?
\&
\&    leaveeval \-\- needed for Safe to operate, is safe without entereval
.Ve
.IP ":base_mem" 5
.IX Item ":base_mem"
These memory related ops are not included in :base_core because they
can easily be used to implement a resource attack (e.g., consume all
available memory).
.Sp
.Vb 1
\&    concat repeat join range
\&
\&    anonlist anonhash
.Ve
.Sp
Note that despite the existence of this optag a memory resource attack
may still be possible using only :base_core ops.
.Sp
Disabling these ops is a \fIvery\fR heavy handed way to attempt to prevent
a memory resource attack. It's probable that a specific memory limit
mechanism will be added to perl in the near future.
.IP ":base_loop" 5
.IX Item ":base_loop"
These loop ops are not included in :base_core because they can easily be
used to implement a resource attack (e.g., consume all available \s-1CPU\s0 time).
.Sp
.Vb 6
\&    grepstart grepwhile
\&    mapstart mapwhile
\&    enteriter iter
\&    enterloop leaveloop unstack
\&    last next redo
\&    goto
.Ve
.IP ":base_io" 5
.IX Item ":base_io"
These ops enable \fIfilehandle\fR (rather than filename) based input and
output. These are safe on the assumption that only pre-existing
filehandles are available for use.  Usually, to create new filehandles
other ops such as open would need to be enabled, if you don't take into
account the magical open of \s-1ARGV\s0.
.Sp
.Vb 1
\&    readline rcatline getc read
\&
\&    formline enterwrite leavewrite
\&
\&    print say sysread syswrite send recv
\&
\&    eof tell seek sysseek
\&
\&    readdir telldir seekdir rewinddir
.Ve
.IP ":base_orig" 5
.IX Item ":base_orig"
These are a hotchpotch of opcodes still waiting to be considered
.Sp
.Vb 1
\&    gvsv gv gelem
\&
\&    padsv padav padhv padany
\&
\&    once
\&
\&    rv2gv refgen srefgen ref
\&
\&    bless \-\- could be used to change ownership of objects (reblessing)
\&
\&    pushre regcmaybe regcreset regcomp subst substcont
\&
\&    sprintf prtf \-\- can core dump
\&
\&    crypt
\&
\&    tie untie
\&
\&    dbmopen dbmclose
\&    sselect select
\&    pipe_op sockpair
\&
\&    getppid getpgrp setpgrp getpriority setpriority localtime gmtime
\&
\&    entertry leavetry \-\- can be used to \*(Aqhide\*(Aq fatal errors
\&
\&    entergiven leavegiven
\&    enterwhen leavewhen
\&    break continue
\&    smartmatch
\&
\&    custom \-\- where should this go
.Ve
.IP ":base_math" 5
.IX Item ":base_math"
These ops are not included in :base_core because of the risk of them being
used to generate floating point exceptions (which would have to be caught
using a \f(CW$SIG\fR{\s-1FPE\s0} handler).
.Sp
.Vb 1
\&    atan2 sin cos exp log sqrt
.Ve
.Sp
These ops are not included in :base_core because they have an effect
beyond the scope of the compartment.
.Sp
.Vb 1
\&    rand srand
.Ve
.IP ":base_thread" 5
.IX Item ":base_thread"
These ops are related to multi-threading.
.Sp
.Vb 1
\&    lock
.Ve
.IP ":default" 5
.IX Item ":default"
A handy tag name for a \fIreasonable\fR default set of ops.  (The current ops
allowed are unstable while development continues. It will change.)
.Sp
.Vb 1
\&    :base_core :base_mem :base_loop :base_orig :base_thread
.Ve
.Sp
This list used to contain :base_io prior to Opcode 1.07.
.Sp
If safety matters to you (and why else would you be using the Opcode module?)
then you should not rely on the definition of this, or indeed any other, optag!
.IP ":filesys_read" 5
.IX Item ":filesys_read"
.Vb 1
\&    stat lstat readlink
\&
\&    ftatime ftblk ftchr ftctime ftdir fteexec fteowned fteread
\&    ftewrite ftfile ftis ftlink ftmtime ftpipe ftrexec ftrowned
\&    ftrread ftsgid ftsize ftsock ftsuid fttty ftzero ftrwrite ftsvtx
\&
\&    fttext ftbinary
\&
\&    fileno
.Ve
.IP ":sys_db" 5
.IX Item ":sys_db"
.Vb 4
\&    ghbyname ghbyaddr ghostent shostent ehostent      \-\- hosts
\&    gnbyname gnbyaddr gnetent snetent enetent         \-\- networks
\&    gpbyname gpbynumber gprotoent sprotoent eprotoent \-\- protocols
\&    gsbyname gsbyport gservent sservent eservent      \-\- services
\&
\&    gpwnam gpwuid gpwent spwent epwent getlogin       \-\- users
\&    ggrnam ggrgid ggrent sgrent egrent                \-\- groups
.Ve
.IP ":browse" 5
.IX Item ":browse"
A handy tag name for a \fIreasonable\fR default set of ops beyond the
:default optag.  Like :default (and indeed all the other optags) its
current definition is unstable while development continues. It will change.
.Sp
The :browse tag represents the next step beyond :default. It it a
superset of the :default ops and adds :filesys_read the :sys_db.
The intent being that scripts can access more (possibly sensitive)
information about your system but not be able to change it.
.Sp
.Vb 1
\&    :default :filesys_read :sys_db
.Ve
.IP ":filesys_open" 5
.IX Item ":filesys_open"
.Vb 2
\&    sysopen open close
\&    umask binmode
\&
\&    open_dir closedir \-\- other dir ops are in :base_io
.Ve
.IP ":filesys_write" 5
.IX Item ":filesys_write"
.Vb 1
\&    link unlink rename symlink truncate
\&
\&    mkdir rmdir
\&
\&    utime chmod chown
\&
\&    fcntl \-\- not strictly filesys related, but possibly as dangerous?
.Ve
.IP ":subprocess" 5
.IX Item ":subprocess"
.Vb 1
\&    backtick system
\&
\&    fork
\&
\&    wait waitpid
\&
\&    glob \-\- access to Cshell via <\`rm *\`>
.Ve
.IP ":ownprocess" 5
.IX Item ":ownprocess"
.Vb 1
\&    exec exit kill
\&
\&    time tms \-\- could be used for timing attacks (paranoid?)
.Ve
.IP ":others" 5
.IX Item ":others"
This tag holds groups of assorted specialist opcodes that don't warrant
having optags defined for them.
.Sp
SystemV Interprocess Communications:
.Sp
.Vb 1
\&    msgctl msgget msgrcv msgsnd
\&
\&    semctl semget semop
\&
\&    shmctl shmget shmread shmwrite
.Ve
.IP ":load" 5
.IX Item ":load"
This tag holds opcodes related to loading modules and getting information
about calling environment and args.
.Sp
.Vb 2
\&    require dofile 
\&    caller runcv
.Ve
.IP ":still_to_be_decided" 5
.IX Item ":still_to_be_decided"
.Vb 2
\&    chdir
\&    flock ioctl
\&
\&    socket getpeername ssockopt
\&    bind connect listen accept shutdown gsockopt getsockname
\&
\&    sleep alarm \-\- changes global timer state and signal handling
\&    sort \-\- assorted problems including core dumps
\&    tied \-\- can be used to access object implementing a tie
\&    pack unpack \-\- can be used to create/use memory pointers
\&
\&    hintseval \-\- constant op holding eval hints
\&
\&    entereval \-\- can be used to hide code from initial compile
\&
\&    reset
\&
\&    dbstate \-\- perl \-d version of nextstate(ment) opcode
.Ve
.IP ":dangerous" 5
.IX Item ":dangerous"
This tag is simply a bucket for opcodes that are unlikely to be used via
a tag name but need to be tagged for completeness and documentation.
.Sp
.Vb 1
\&    syscall dump chroot
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ops \*(-- perl pragma interface to Opcode module.
.PP
Safe \*(-- Opcode and namespace limited execution compartments
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally designed and implemented by Malcolm Beattie,
mbeattie@sable.ox.ac.uk as part of Safe version 1.
.PP
Split out from Safe module version 1, named opcode tags and other
changes added by Tim Bunce.
                                                                                                                                                                                                                                 osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/Opcode5.18.3pm                               0100644 0001750 0001750 00000047166 12566207461 023045  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "Opcode 3pm"
.TH Opcode 3pm "2014-01-06" "perl v5.18.2" "Perl Programmers Reference Guide"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Opcode \- Disable named opcodes when compiling perl code
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use Opcode;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
Perl code is always compiled into an internal format before execution.
.PP
Evaluating perl code (e.g. via \*(L"eval\*(R" or \*(L"do 'file'\*(R") causes
the code to be compiled into an internal format and then,
provided there was no error in the compilation, executed.
The internal format is based on many distinct \fIopcodes\fR.
.PP
By default no opmask is in effect and any code can be compiled.
.PP
The Opcode module allow you to define an \fIoperator mask\fR to be in
effect when perl \fInext\fR compiles any code.  Attempting to compile code
which contains a masked opcode will cause the compilation to fail
with an error. The code will not be executed.
.SH "NOTE"
.IX Header "NOTE"
The Opcode module is not usually used directly. See the ops pragma and
Safe modules for more typical uses.
.SH "WARNING"
.IX Header "WARNING"
The authors make \fBno warranty\fR, implied or otherwise, about the
suitability of this software for safety or security purposes.
.PP
The authors shall not in any case be liable for special, incidental,
consequential, indirect or other similar damages arising from the use
of this software.
.PP
Your mileage will vary. If in any doubt \fBdo not use it\fR.
.SH "Operator Names and Operator Lists"
.IX Header "Operator Names and Operator Lists"
The canonical list of operator names is the contents of the array
PL_op_name defined and initialised in file \fIopcode.h\fR of the Perl
source distribution (and installed into the perl library).
.PP
Each operator has both a terse name (its opname) and a more verbose or
recognisable descriptive name. The opdesc function can be used to
return a list of descriptions for a list of operators.
.PP
Many of the functions and methods listed below take a list of
operators as parameters. Most operator lists can be made up of several
types of element. Each element can be one of
.IP "an operator name (opname)" 8
.IX Item "an operator name (opname)"
Operator names are typically small lowercase words like enterloop,
leaveloop, last, next, redo etc. Sometimes they are rather cryptic
like gv2cv, i_ncmp and ftsvtx.
.IP "an operator tag name (optag)" 8
.IX Item "an operator tag name (optag)"
Operator tags can be used to refer to groups (or sets) of operators.
Tag names always begin with a colon. The Opcode module defines several
optags and the user can define others using the define_optag function.
.IP "a negated opname or optag" 8
.IX Item "a negated opname or optag"
An opname or optag can be prefixed with an exclamation mark, e.g., !mkdir.
Negating an opname or optag means remove the corresponding ops from the
accumulated set of ops at that point.
.IP "an operator set (opset)" 8
.IX Item "an operator set (opset)"
An \fIopset\fR as a binary string of approximately 44 bytes which holds a
set or zero or more operators.
.Sp
The opset and opset_to_ops functions can be used to convert from
a list of operators to an opset and \fIvice versa\fR.
.Sp
Wherever a list of operators can be given you can use one or more opsets.
See also Manipulating Opsets below.
.SH "Opcode Functions"
.IX Header "Opcode Functions"
The Opcode package contains functions for manipulating operator names
tags and sets. All are available for export by the package.
.IP "opcodes" 8
.IX Item "opcodes"
In a scalar context opcodes returns the number of opcodes in this
version of perl (around 350 for perl\-5.7.0).
.Sp
In a list context it returns a list of all the operator names.
(Not yet implemented, use \f(CW@names\fR = opset_to_ops(full_opset).)
.IP "opset (\s-1OP, ...\s0)" 8
.IX Item "opset (OP, ...)"
Returns an opset containing the listed operators.
.IP "opset_to_ops (\s-1OPSET\s0)" 8
.IX Item "opset_to_ops (OPSET)"
Returns a list of operator names corresponding to those operators in
the set.
.IP "opset_to_hex (\s-1OPSET\s0)" 8
.IX Item "opset_to_hex (OPSET)"
Returns a string representation of an opset. Can be handy for debugging.
.IP "full_opset" 8
.IX Item "full_opset"
Returns an opset which includes all operators.
.IP "empty_opset" 8
.IX Item "empty_opset"
Returns an opset which contains no operators.
.IP "invert_opset (\s-1OPSET\s0)" 8
.IX Item "invert_opset (OPSET)"
Returns an opset which is the inverse set of the one supplied.
.IP "verify_opset (\s-1OPSET, ...\s0)" 8
.IX Item "verify_opset (OPSET, ...)"
Returns true if the supplied opset looks like a valid opset (is the
right length etc) otherwise it returns false. If an optional second
parameter is true then verify_opset will croak on an invalid opset
instead of returning false.
.Sp
Most of the other Opcode functions call verify_opset automatically
and will croak if given an invalid opset.
.IP "define_optag (\s-1OPTAG, OPSET\s0)" 8
.IX Item "define_optag (OPTAG, OPSET)"
Define \s-1OPTAG\s0 as a symbolic name for \s-1OPSET.\s0 Optag names always start
with a colon \f(CW\*(C`:\*(C'\fR.
.Sp
The optag name used must not be defined already (define_optag will
croak if it is already defined). Optag names are global to the perl
process and optag definitions cannot be altered or deleted once
defined.
.Sp
It is strongly recommended that applications using Opcode should use a
leading capital letter on their tag names since lowercase names are
reserved for use by the Opcode module. If using Opcode within a module
you should prefix your tags names with the name of your module to
ensure uniqueness and thus avoid clashes with other modules.
.IP "opmask_add (\s-1OPSET\s0)" 8
.IX Item "opmask_add (OPSET)"
Adds the supplied opset to the current opmask. Note that there is
currently \fIno\fR mechanism for unmasking ops once they have been masked.
This is intentional.
.IP "opmask" 8
.IX Item "opmask"
Returns an opset corresponding to the current opmask.
.IP "opdesc (\s-1OP, ...\s0)" 8
.IX Item "opdesc (OP, ...)"
This takes a list of operator names and returns the corresponding list
of operator descriptions.
.IP "opdump (\s-1PAT\s0)" 8
.IX Item "opdump (PAT)"
Dumps to \s-1STDOUT\s0 a two column list of op names and op descriptions.
If an optional pattern is given then only lines which match the
(case insensitive) pattern will be output.
.Sp
It's designed to be used as a handy command line utility:
.Sp
.Vb 2
\&        perl \-MOpcode=opdump \-e opdump
\&        perl \-MOpcode=opdump \-e \*(Aqopdump Eval\*(Aq
.Ve
.SH "Manipulating Opsets"
.IX Header "Manipulating Opsets"
Opsets may be manipulated using the perl bit vector operators & (and), | (or),
^ (xor) and ~ (negate/invert).
.PP
However you should never rely on the numerical position of any opcode
within the opset. In other words both sides of a bit vector operator
should be opsets returned from Opcode functions.
.PP
Also, since the number of opcodes in your current version of perl might
not be an exact multiple of eight, there may be unused bits in the last
byte of an upset. This should not cause any problems (Opcode functions
ignore those extra bits) but it does mean that using the ~ operator
will typically not produce the same 'physical' opset 'string' as the
invert_opset function.
.SH "TO DO (maybe)"
.IX Header "TO DO (maybe)"
.Vb 3
\&    $bool = opset_eq($opset1, $opset2)  true if opsets are logically
\&                                        equivalent
\&    $yes = opset_can($opset, @ops)      true if $opset has all @ops set
\&
\&    @diff = opset_diff($opset1, $opset2) => (\*(Aqfoo\*(Aq, \*(Aq!bar\*(Aq, ...)
.Ve
.SH "Predefined Opcode Tags"
.IX Header "Predefined Opcode Tags"
.IP ":base_core" 5
.IX Item ":base_core"
.Vb 1
\&    null stub scalar pushmark wantarray const defined undef
\&
\&    rv2sv sassign
\&
\&    rv2av aassign aelem aelemfast aelemfast_lex aslice av2arylen
\&
\&    rv2hv helem hslice each values keys exists delete aeach akeys
\&    avalues reach rvalues rkeys
\&
\&    preinc i_preinc predec i_predec postinc i_postinc
\&    postdec i_postdec int hex oct abs pow multiply i_multiply
\&    divide i_divide modulo i_modulo add i_add subtract i_subtract
\&
\&    left_shift right_shift bit_and bit_xor bit_or negate i_negate
\&    not complement
\&
\&    lt i_lt gt i_gt le i_le ge i_ge eq i_eq ne i_ne ncmp i_ncmp
\&    slt sgt sle sge seq sne scmp
\&
\&    substr vec stringify study pos length index rindex ord chr
\&
\&    ucfirst lcfirst uc lc fc quotemeta trans transr chop schop
\&    chomp schomp
\&
\&    match split qr
\&
\&    list lslice splice push pop shift unshift reverse
\&
\&    cond_expr flip flop andassign orassign dorassign and or dor xor
\&
\&    warn die lineseq nextstate scope enter leave
\&
\&    rv2cv anoncode prototype coreargs
\&
\&    entersub leavesub leavesublv return method method_named
\&     \-\- XXX loops via recursion?
\&
\&    leaveeval \-\- needed for Safe to operate, is safe
\&                 without entereval
.Ve
.IP ":base_mem" 5
.IX Item ":base_mem"
These memory related ops are not included in :base_core because they
can easily be used to implement a resource attack (e.g., consume all
available memory).
.Sp
.Vb 1
\&    concat repeat join range
\&
\&    anonlist anonhash
.Ve
.Sp
Note that despite the existence of this optag a memory resource attack
may still be possible using only :base_core ops.
.Sp
Disabling these ops is a \fIvery\fR heavy handed way to attempt to prevent
a memory resource attack. It's probable that a specific memory limit
mechanism will be added to perl in the near future.
.IP ":base_loop" 5
.IX Item ":base_loop"
These loop ops are not included in :base_core because they can easily be
used to implement a resource attack (e.g., consume all available \s-1CPU\s0 time).
.Sp
.Vb 6
\&    grepstart grepwhile
\&    mapstart mapwhile
\&    enteriter iter
\&    enterloop leaveloop unstack
\&    last next redo
\&    goto
.Ve
.IP ":base_io" 5
.IX Item ":base_io"
These ops enable \fIfilehandle\fR (rather than filename) based input and
output. These are safe on the assumption that only pre-existing
filehandles are available for use.  Usually, to create new filehandles
other ops such as open would need to be enabled, if you don't take into
account the magical open of \s-1ARGV.\s0
.Sp
.Vb 1
\&    readline rcatline getc read
\&
\&    formline enterwrite leavewrite
\&
\&    print say sysread syswrite send recv
\&
\&    eof tell seek sysseek
\&
\&    readdir telldir seekdir rewinddir
.Ve
.IP ":base_orig" 5
.IX Item ":base_orig"
These are a hotchpotch of opcodes still waiting to be considered
.Sp
.Vb 1
\&    gvsv gv gelem
\&
\&    padsv padav padhv padcv padany padrange introcv clonecv
\&
\&    once
\&
\&    rv2gv refgen srefgen ref
\&
\&    bless \-\- could be used to change ownership of objects
\&             (reblessing)
\&
\&    pushre regcmaybe regcreset regcomp subst substcont
\&
\&    sprintf prtf \-\- can core dump
\&
\&    crypt
\&
\&    tie untie
\&
\&    dbmopen dbmclose
\&    sselect select
\&    pipe_op sockpair
\&
\&    getppid getpgrp setpgrp getpriority setpriority
\&    localtime gmtime
\&
\&    entertry leavetry \-\- can be used to \*(Aqhide\*(Aq fatal errors
\&
\&    entergiven leavegiven
\&    enterwhen leavewhen
\&    break continue
\&    smartmatch
\&
\&    custom \-\- where should this go
.Ve
.IP ":base_math" 5
.IX Item ":base_math"
These ops are not included in :base_core because of the risk of them being
used to generate floating point exceptions (which would have to be caught
using a \f(CW$SIG\fR{\s-1FPE\s0} handler).
.Sp
.Vb 1
\&    atan2 sin cos exp log sqrt
.Ve
.Sp
These ops are not included in :base_core because they have an effect
beyond the scope of the compartment.
.Sp
.Vb 1
\&    rand srand
.Ve
.IP ":base_thread" 5
.IX Item ":base_thread"
These ops are related to multi-threading.
.Sp
.Vb 1
\&    lock
.Ve
.IP ":default" 5
.IX Item ":default"
A handy tag name for a \fIreasonable\fR default set of ops.  (The current ops
allowed are unstable while development continues. It will change.)
.Sp
.Vb 1
\&    :base_core :base_mem :base_loop :base_orig :base_thread
.Ve
.Sp
This list used to contain :base_io prior to Opcode 1.07.
.Sp
If safety matters to you (and why else would you be using the Opcode module?)
then you should not rely on the definition of this, or indeed any other, optag!
.IP ":filesys_read" 5
.IX Item ":filesys_read"
.Vb 1
\&    stat lstat readlink
\&
\&    ftatime ftblk ftchr ftctime ftdir fteexec fteowned
\&    fteread ftewrite ftfile ftis ftlink ftmtime ftpipe
\&    ftrexec ftrowned ftrread ftsgid ftsize ftsock ftsuid
\&    fttty ftzero ftrwrite ftsvtx
\&
\&    fttext ftbinary
\&
\&    fileno
.Ve
.IP ":sys_db" 5
.IX Item ":sys_db"
.Vb 4
\&    ghbyname ghbyaddr ghostent shostent ehostent      \-\- hosts
\&    gnbyname gnbyaddr gnetent snetent enetent         \-\- networks
\&    gpbyname gpbynumber gprotoent sprotoent eprotoent \-\- protocols
\&    gsbyname gsbyport gservent sservent eservent      \-\- services
\&
\&    gpwnam gpwuid gpwent spwent epwent getlogin       \-\- users
\&    ggrnam ggrgid ggrent sgrent egrent                \-\- groups
.Ve
.IP ":browse" 5
.IX Item ":browse"
A handy tag name for a \fIreasonable\fR default set of ops beyond the
:default optag.  Like :default (and indeed all the other optags) its
current definition is unstable while development continues. It will change.
.Sp
The :browse tag represents the next step beyond :default. It it a
superset of the :default ops and adds :filesys_read the :sys_db.
The intent being that scripts can access more (possibly sensitive)
information about your system but not be able to change it.
.Sp
.Vb 1
\&    :default :filesys_read :sys_db
.Ve
.IP ":filesys_open" 5
.IX Item ":filesys_open"
.Vb 2
\&    sysopen open close
\&    umask binmode
\&
\&    open_dir closedir \-\- other dir ops are in :base_io
.Ve
.IP ":filesys_write" 5
.IX Item ":filesys_write"
.Vb 1
\&    link unlink rename symlink truncate
\&
\&    mkdir rmdir
\&
\&    utime chmod chown
\&
\&    fcntl \-\- not strictly filesys related, but possibly as
\&             dangerous?
.Ve
.IP ":subprocess" 5
.IX Item ":subprocess"
.Vb 1
\&    backtick system
\&
\&    fork
\&
\&    wait waitpid
\&
\&    glob \-\- access to Cshell via <\`rm *\`>
.Ve
.IP ":ownprocess" 5
.IX Item ":ownprocess"
.Vb 1
\&    exec exit kill
\&
\&    time tms \-\- could be used for timing attacks (paranoid?)
.Ve
.IP ":others" 5
.IX Item ":others"
This tag holds groups of assorted specialist opcodes that don't warrant
having optags defined for them.
.Sp
SystemV Interprocess Communications:
.Sp
.Vb 1
\&    msgctl msgget msgrcv msgsnd
\&
\&    semctl semget semop
\&
\&    shmctl shmget shmread shmwrite
.Ve
.IP ":load" 5
.IX Item ":load"
This tag holds opcodes related to loading modules and getting information
about calling environment and args.
.Sp
.Vb 2
\&    require dofile 
\&    caller runcv
.Ve
.IP ":still_to_be_decided" 5
.IX Item ":still_to_be_decided"
.Vb 2
\&    chdir
\&    flock ioctl
\&
\&    socket getpeername ssockopt
\&    bind connect listen accept shutdown gsockopt getsockname
\&
\&    sleep alarm \-\- changes global timer state and signal handling
\&    sort \-\- assorted problems including core dumps
\&    tied \-\- can be used to access object implementing a tie
\&    pack unpack \-\- can be used to create/use memory pointers
\&
\&    hintseval \-\- constant op holding eval hints
\&
\&    entereval \-\- can be used to hide code from initial compile
\&
\&    reset
\&
\&    dbstate \-\- perl \-d version of nextstate(ment) opcode
.Ve
.IP ":dangerous" 5
.IX Item ":dangerous"
This tag is simply a bucket for opcodes that are unlikely to be used via
a tag name but need to be tagged for completeness and documentation.
.Sp
.Vb 1
\&    syscall dump chroot
.Ve
.SH "SEE ALSO"
.IX Header "SEE ALSO"
ops \*(-- perl pragma interface to Opcode module.
.PP
Safe \*(-- Opcode and namespace limited execution compartments
.SH "AUTHORS"
.IX Header "AUTHORS"
Originally designed and implemented by Malcolm Beattie,
mbeattie@sable.ox.ac.uk as part of Safe version 1.
.PP
Split out from Safe module version 1, named opcode tags and other
changes added by Tim Bunce.
                                                                                                                                                                                                                                                                                                                                                                                                          osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OpenSSL_add_all_algorithms.3ssl              0100644 0001750 0001750 00000014141 12566201132 026631  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "OpenSSL_add_all_algorithms 3"
.TH OpenSSL_add_all_algorithms 3 "2015-07-15" "0.9.8" "OpenSSL"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
OpenSSL_add_all_algorithms, OpenSSL_add_all_ciphers, OpenSSL_add_all_digests \-
add algorithms to internal table
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& #include <openssl/evp.h>
\&
\& void OpenSSL_add_all_algorithms(void);
\& void OpenSSL_add_all_ciphers(void);
\& void OpenSSL_add_all_digests(void);
\&
\& void EVP_cleanup(void);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
OpenSSL keeps an internal table of digest algorithms and ciphers. It uses
this table to lookup ciphers via functions such as \fIEVP_get_cipher_byname()\fR.
.PP
\&\fIOpenSSL_add_all_digests()\fR adds all digest algorithms to the table.
.PP
\&\fIOpenSSL_add_all_algorithms()\fR adds all algorithms to the table (digests and
ciphers).
.PP
\&\fIOpenSSL_add_all_ciphers()\fR adds all encryption algorithms to the table including
password based encryption algorithms.
.PP
\&\fIEVP_cleanup()\fR removes all ciphers and digests from the table.
.SH "RETURN VALUES"
.IX Header "RETURN VALUES"
None of the functions return a value.
.SH "NOTES"
.IX Header "NOTES"
A typical application will call \fIOpenSSL_add_all_algorithms()\fR initially and
\&\fIEVP_cleanup()\fR before exiting.
.PP
An application does not need to add algorithms to use them explicitly, for example
by \fIEVP_sha1()\fR. It just needs to add them if it (or any of the functions it calls)
needs to lookup algorithms.
.PP
The cipher and digest lookup functions are used in many parts of the library. If
the table is not initialized several functions will misbehave and complain they
cannot find algorithms. This includes the \s-1PEM,\s0 PKCS#12, \s-1SSL\s0 and S/MIME libraries.
This is a common query in the OpenSSL mailing lists.
.PP
Calling \fIOpenSSL_add_all_algorithms()\fR links in all algorithms: as a result a
statically linked executable can be quite large. If this is important it is possible
to just add the required ciphers and digests.
.SH "BUGS"
.IX Header "BUGS"
Although the functions do not return error codes it is possible for them to fail.
This will only happen as a result of a memory allocation failure so this is not
too much of a problem in practice.
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fIevp\fR\|(3), \fIEVP_DigestInit\fR\|(3),
\&\fIEVP_EncryptInit\fR\|(3)
                                                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OpenSSL_add_all_ciphers.3ssl                 0120777 0001750 0001750 00000000000 12620245063 034077  2OpenSSL_add_all_algorithms.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OpenSSL_add_all_digests.3ssl                 0120777 0001750 0001750 00000000000 12620245063 034104  2OpenSSL_add_all_algorithms.3ssl                                                                     ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/OpenSSL_add_ssl_algorithms.3ssl              0120777 0001750 0001750 00000000000 12620245063 032700  2SSL_library_init.3ssl                                                                               ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/PAIR_NUMBER.3x                               0100644 0001750 0001750 00000025201 12566174415 022742  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        '\" t
.\"***************************************************************************
.\" Copyright (c) 1998-2006,2007 Free Software Foundation, Inc.              *
.\"                                                                          *
.\" Permission is hereby granted, free of charge, to any person obtaining a  *
.\" copy of this software and associated documentation files (the            *
.\" "Software"), to deal in the Software without restriction, including      *
.\" without limitation the rights to use, copy, modify, merge, publish,      *
.\" distribute, distribute with modifications, sublicense, and/or sell       *
.\" copies of the Software, and to permit persons to whom the Software is    *
.\" furnished to do so, subject to the following conditions:                 *
.\"                                                                          *
.\" The above copyright notice and this permission notice shall be included  *
.\" in all copies or substantial portions of the Software.                   *
.\"                                                                          *
.\" THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS  *
.\" OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF               *
.\" MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.   *
.\" IN NO EVENT SHALL THE ABOVE COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,   *
.\" DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR    *
.\" OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR    *
.\" THE USE OR OTHER DEALINGS IN THE SOFTWARE.                               *
.\"                                                                          *
.\" Except as contained in this notice, the name(s) of the above copyright   *
.\" holders shall not be used in advertising or otherwise to promote the     *
.\" sale, use or other dealings in this Software without prior written       *
.\" authorization.                                                           *
.\"***************************************************************************
.\"
.\" $Id: curs_attr.3x,v 1.31 2007/03/17 20:30:33 tom Exp $
.TH curs_attr 3X ""
.na
.hy 0
.SH NAME
\fBattroff\fR,
\fBwattroff\fR,
\fBattron\fR,
\fBwattron\fR,
\fBattrset\fR,
\fBwattrset\fR,
\fBcolor_set\fR,
\fBwcolor_set\fR,
\fBstandend\fR,
\fBwstandend\fR,
\fBstandout\fR,
\fBwstandout\fR,
\fBattr_get\fR,
\fBwattr_get\fR,
\fBattr_off\fR,
\fBwattr_off\fR,
\fBattr_on\fR,
\fBwattr_on\fR,
\fBattr_set\fR,
\fBwattr_set\fR,
\fBchgat\fR,
\fBwchgat\fR,
\fBmvchgat\fR,
\fBmvwchgat\fR,
\fBPAIR_NUMBER\fR - \fBcurses\fR character and window attribute control routines
.ad
.hy
.SH SYNOPSIS
\fB#include <curses.h>\fR
.br
\fBint attroff(int attrs);\fR
.br
\fBint wattroff(WINDOW *win, int attrs);\fR
.br
\fBint attron(int attrs);\fR
.br
\fBint wattron(WINDOW *win, int attrs);\fR
.br
\fBint attrset(int attrs);\fR
.br
\fBint wattrset(WINDOW *win, int attrs);\fR
.br
\fBint color_set(short color_pair_number, void* opts);\fR
.br
\fBint wcolor_set(WINDOW *win, short color_pair_number,\fR
      \fBvoid* opts);\fR
.br
\fBint standend(void);\fR
.br
\fBint wstandend(WINDOW *win);\fR
.br
\fBint standout(void);\fR
.br
\fBint wstandout(WINDOW *win);\fR
.br
\fBint attr_get(attr_t *attrs, short *pair, void *opts);\fR
.br
\fBint wattr_get(WINDOW *win, attr_t *attrs, short *pair,\fR
       \fBvoid *opts);\fR
.br
\fBint attr_off(attr_t attrs, void *opts);\fR
.br
\fBint wattr_off(WINDOW *win, attr_t attrs, void *opts);\fR
.br
\fBint attr_on(attr_t attrs, void *opts);\fR
.br
\fBint wattr_on(WINDOW *win, attr_t attrs, void *opts);\fR
.br
\fBint attr_set(attr_t attrs, short pair, void *opts);\fR
.br
\fBint wattr_set(WINDOW *win, attr_t attrs, short pair, void *opts);\fR
.br
\fBint chgat(int n, attr_t attr, short color,\fR
      \fBconst void *opts)\fR
.br
\fBint wchgat(WINDOW *win, int n, attr_t attr,\fR
      \fBshort color, const void *opts)\fR
.br
\fBint mvchgat(int y, int x, int n, attr_t attr,\fR
      \fBshort color, const void *opts)\fR
.br
\fBint mvwchgat(WINDOW *win, int y, int x, int n,\fR
      \fBattr_t attr, short color, const void *opts)\fR
.br
.SH DESCRIPTION
These routines manipulate the current attributes of the named window.  The
current attributes of a window apply to all characters that are written into
the window with \fBwaddch\fR, \fBwaddstr\fR and \fBwprintw\fR.  Attributes are
a property of the character, and move with the character through any scrolling
and insert/delete line/character operations.  To the extent possible, they are
displayed as appropriate modifications to the graphic rendition of characters
put on the screen.
.PP
The routine \fBattrset\fR sets the current attributes of the given window to
\fIattrs\fR.  The routine \fBattroff\fR turns off the named attributes without
turning any other attributes on or off.  The routine \fBattron\fR turns on the
named attributes without affecting any others.  The routine \fBstandout\fR is
the same as \fBattron(A_STANDOUT)\fR.  The routine \fBstandend\fR is the same
as \fBattrset(A_NORMAL)\fR or \fBattrset(0)\fR, that is, it turns off all
attributes.
.PP
The \fBattrset\fR and related routines do not affect the attributes used
when erasing portions of the window.
See \fBcurs_bkgd\fR(3X) for functions which modify the attributes used for
erasing and clearing.
.PP
The routine \fBcolor_set\fR sets the current color of the given window to the
foreground/background combination described by the color_pair_number. The
parameter opts is reserved for future use, applications must supply a null
pointer.
.PP
The routine \fBwattr_get\fR returns the current attribute and color pair for
the given window; \fBattr_get\fR returns the current attribute and color pair
for \fBstdscr\fR.
The remaining \fBattr_\fR* functions operate exactly like the corresponding
\fBattr\fR* functions, except that they take arguments of type \fBattr_t\fR
rather than \fBint\fR.
.PP
The routine \fBchgat\fR changes the attributes of a given number of characters
starting at the current cursor location of \fBstdscr\fR.  It does not update
the cursor and does not perform wrapping.  A character count of -1 or greater
than the remaining window width means to change attributes all the way to the
end of the current line.  The \fBwchgat\fR function generalizes this to any
window; the \fBmvwchgat\fR function does a cursor move before acting.  In these
functions, the color argument is a color-pair index (as in the first argument
of \fIinit_pair\fR, see \fBcurs_color\fR(3X)).  The \fBopts\fR argument is not
presently used, but is reserved for the future (leave it \fBNULL\fR).
.SS Attributes
The following video attributes, defined in \fB<curses.h>\fR, can be passed to
the routines \fBattron\fR, \fBattroff\fR, and \fBattrset\fR, or OR'd with the
characters passed to \fBaddch\fR.
.PP
.TS
center ;
l l .
\fBA_NORMAL\fR	Normal display (no highlight)
\fBA_STANDOUT\fR	Best highlighting mode of the terminal.
\fBA_UNDERLINE\fR	Underlining
\fBA_REVERSE\fR	Reverse video
\fBA_BLINK\fR	Blinking
\fBA_DIM\fR	Half bright
\fBA_BOLD\fR	Extra bright or bold
\fBA_PROTECT\fR	Protected mode
\fBA_INVIS\fR	Invisible or blank mode
\fBA_ALTCHARSET\fR	Alternate character set
\fBA_CHARTEXT\fR	Bit-mask to extract a character
\fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR	Color-pair number \fIn\fR
.TE
.PP
The following macro is the reverse of \fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR:
.PP
.br
\fBPAIR_NUMBER(\fR\fIattrs\fR) Returns the pair number associated
                   with the \fBCOLOR_PAIR(\fR\fIn\fR\fB)\fR attribute.
.br
.PP
The return values of many of these routines are not meaningful (they are
implemented as macro-expanded assignments and simply return their argument).
The SVr4 manual page claims (falsely) that these routines always return \fB1\fR.
.SH NOTES
Note that \fBattroff\fR, \fBwattroff\fR, \fBattron\fR, \fBwattron\fR,
\fBattrset\fR, \fBwattrset\fR, \fBstandend\fR and \fBstandout\fR may be macros.
.PP
\fBCOLOR_PAIR\fP values can only be OR'd with attributes if the pair
number is less than 256.
The alternate functions such as \fBcolor_set\fP can pass a color pair
value directly.
However, ncurses ABI 4 and 5 simply OR this value within the alternate functions.
You must use ncurses ABI 6 to support more than 256 color pairs.
.SH PORTABILITY
These functions are supported in the XSI Curses standard, Issue 4.  The
standard defined the dedicated type for highlights, \fBattr_t\fR, which is not
defined in SVr4 curses. The functions taking \fBattr_t\fR arguments are
not supported under SVr4.
.PP
The XSI Curses standard states that whether the traditional functions
\fBattron\fR/\fBattroff\fR/\fBattrset\fR can manipulate attributes other than
\fBA_BLINK\fR, \fBA_BOLD\fR, \fBA_DIM\fR, \fBA_REVERSE\fR, \fBA_STANDOUT\fR, or
\fBA_UNDERLINE\fR is "unspecified".  Under this implementation as well as
SVr4 curses, these functions correctly manipulate all other highlights
(specifically, \fBA_ALTCHARSET\fR, \fBA_PROTECT\fR, and \fBA_INVIS\fR).
.PP
XSI Curses added the new entry points, \fBattr_get\fR, \fBattr_on\fR,
\fBattr_off\fR, \fBattr_set\fR, \fBwattr_on\fR, \fBwattr_off\fR,
\fBwattr_get\fR, \fBwattr_set\fR.  These are intended to work with
a new series of highlight macros prefixed with \fBWA_\fR.
.PP
Older versions of this library did not force an update of the screen
when changing the attributes.
Use \fBtouchwin\fR to force the screen to match the updated attributes.
.PP
.TS
center ;
l l .
\fBWA_NORMAL\fR	Normal display (no highlight)
\fBWA_STANDOUT\fR	Best highlighting mode of the terminal.
\fBWA_UNDERLINE\fR	Underlining
\fBWA_REVERSE\fR	Reverse video
\fBWA_BLINK\fR	Blinking
\fBWA_DIM\fR	Half bright
\fBWA_BOLD\fR	Extra bright or bold
\fBWA_ALTCHARSET\fR	Alternate character set
.TE
.PP
The XSI curses standard specifies that each pair of corresponding \fBA_\fR
and \fBWA_\fR-using functions operates on the same current-highlight
information.
.PP
The XSI standard extended conformance level adds new highlights
\fBA_HORIZONTAL\fR, \fBA_LEFT\fR, \fBA_LOW\fR, \fBA_RIGHT\fR, \fBA_TOP\fR,
\fBA_VERTICAL\fR (and corresponding \fBWA_\fR macros for each) which this
implementation does not yet support.
.SH RETURN VALUE
All routines return the integer \fBOK\fR on success, or \fBERR\fP on failure.
.PP
X/Open does not define any error conditions.
.PP
This implementation returns an error
if the window pointer is null.
The \fBwcolor_set\fP function returns an error if the color pair parameter
is outside the range 0..COLOR_PAIRS-1.
This implementation also provides
\fBgetattrs\fR
for compatibility with older versions of curses.
.SH SEE ALSO
\fBcurses\fR(3X),
\fBcurs_addch\fR(3X),
\fBcurs_addstr\fR(3X),
\fBcurs_bkgd\fR(3X),
\fBcurs_printw\fR(3X)
.\"#
.\"# The following sets edit modes for GNU EMACS
.\"# Local Variables:
.\"# mode:nroff
.\"# fill-column:79
.\"# End:
                                                                                                                                                                                                                                                                                                                                                                                               osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/PAR.3pm                                      0100644 0001750 0001750 00000041336 12566242231 021725  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PAR 3"
.TH PAR 3 "2012-10-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PAR \- Perl Archive Toolkit
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
(If you want to make an executable that contains all module, scripts and
data files, please consult the pp utility instead. pp used to be
part of the \s-1PAR\s0 distribution but is now shipped as part of the PAR::Packer
distribution instead.)
.PP
Following examples assume a \fIfoo.par\fR file in Zip format.
.PP
To use \fIHello.pm\fR from \fI./foo.par\fR:
.PP
.Vb 2
\&    % perl \-MPAR=./foo.par \-MHello
\&    % perl \-MPAR=./foo \-MHello          # the .par part is optional
.Ve
.PP
Same thing, but search \fIfoo.par\fR in the \f(CW@INC\fR;
.PP
.Vb 2
\&    % perl \-MPAR \-Ifoo.par \-MHello
\&    % perl \-MPAR \-Ifoo \-MHello          # ditto
.Ve
.PP
Following paths inside the \s-1PAR\s0 file are searched:
.PP
.Vb 6
\&    /lib/
\&    /arch/
\&    /i386\-freebsd/              # i.e. $Config{archname}
\&    /5.8.0/                     # i.e. $Config{version}
\&    /5.8.0/i386\-freebsd/        # both of the above
\&    /
.Ve
.PP
\&\s-1PAR\s0 files may also (recursively) contain other \s-1PAR\s0 files.
All files under following paths will be considered as \s-1PAR\s0
files and searched as well:
.PP
.Vb 4
\&    /par/i386\-freebsd/          # i.e. $Config{archname}
\&    /par/5.8.0/                 # i.e. $Config{version}
\&    /par/5.8.0/i386\-freebsd/    # both of the above
\&    /par/
.Ve
.PP
Run \fIscript/test.pl\fR or \fItest.pl\fR from \fIfoo.par\fR:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # only when $0 ends in \*(Aq.par\*(Aq
.Ve
.PP
However, if the \fI.par\fR archive contains either \fIscript/main.pl\fR or
\&\fImain.pl\fR, then it is used instead:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # runs main.pl; @ARGV is \*(Aqtest.pl\*(Aq
.Ve
.PP
Use in a program:
.PP
.Vb 2
\&    use PAR \*(Aqfoo.par\*(Aq;
\&    use Hello; # reads within foo.par
\&
\&    # PAR::read_file() returns a file inside any loaded PARs
\&    my $conf = PAR::read_file(\*(Aqdata/MyConfig.yaml\*(Aq);
\&
\&    # PAR::par_handle() returns an Archive::Zip handle
\&    my $zip = PAR::par_handle(\*(Aqfoo.par\*(Aq)
\&    my $src = $zip\->memberNamed(\*(Aqlib/Hello.pm\*(Aq)\->contents;
.Ve
.PP
You can also use wildcard characters:
.PP
.Vb 1
\&    use PAR \*(Aq/home/foo/*.par\*(Aq;  # loads all PAR files in that directory
.Ve
.PP
Since version 0.950, you can also use a different syntax for loading
\&\fI.par\fR archives:
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq }, { file => \*(Aqotherfile.par\*(Aq };
.Ve
.PP
Why? Because you can also do this:
.PP
.Vb 2
\&    use PAR { file => \*(Aqfoo.par, fallback => 1 };
\&    use Foo::Bar;
.Ve
.PP
Foo::Bar will be searched in the system libs first and loaded from \fIfoo.par\fR
if it wasn't found!
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq };
.Ve
.PP
This will load \fIfoo.par\fR as usual and then execute the \fIscript/myscript\fR
file from the archive. Note that your program will not regain control. When
\&\fIscript/myscript\fR exits, so does your main program. To make this more useful,
you can defer this to runtime: (otherwise equivalent)
.PP
.Vb 2
\&    require PAR;
\&    PAR\->import( { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq } );
.Ve
.PP
If you have PAR::Repository::Client installed, you can do this:
.PP
.Vb 2
\&    use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq };
\&    use Module; # not locally installed!
.Ve
.PP
And \s-1PAR\s0 will fetch any modules you don't have from the specified \s-1PAR\s0
repository. For details on how this works, have a look at the \s-1SEE ALSO\s0
section below. Instead of an \s-1URL\s0 or local path, you can construct an
PAR::Repository::Client object manually and pass that to \s-1PAR.\s0
If you specify the \f(CW\*(C`install => 1\*(C'\fR option in the \f(CW\*(C`use PAR\*(C'\fR
line above, the distribution containing \f(CW\*(C`Module\*(C'\fR will be permanently
installed on your system. (\f(CW\*(C`use PAR { repository => \*(Aqhttp://foo/bar\*(Aq, install => 1 };\*(C'\fR)
.PP
Furthermore, there is an \f(CW\*(C`upgrade => 1\*(C'\fR option that checks for upgrades
in the repository in addition to installing. Please note that an upgraded
version of a module is only loaded on the next run of your application.
.PP
Adding the \f(CW\*(C`dependencies => 1\*(C'\fR option will enable PAR::Repository::Client's
static dependency resolution (PAR::Repository::Client 0.23 and up).
.PP
Finally, you can combine the \f(CW\*(C`run\*(C'\fR and \f(CW\*(C`repository\*(C'\fR
options to run an application directly from a repository! (And you can add
the \f(CW\*(C`install\*(C'\fR option, too.)
.PP
.Vb 2
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, run => \*(Aqmy_app\*(Aq };
\&  # Will not reach this point as we executed my_app,
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lets you use special zip files, called \fBP\fRerl \fBAr\fRchives, as
libraries from which Perl modules can be loaded.
.PP
It supports loading \s-1XS\s0 modules by overriding \fBDynaLoader\fR bootstrapping
methods; it writes shared object file to a temporary file at the time it
is needed.
.PP
A \fI.par\fR file is mostly a zip of the \fIblib/\fR directory after the build
process of a \s-1CPAN\s0 distribution. To generate a \fI.par\fR file yourself, all
you have to do is compress the modules under \fIarch/\fR and \fIlib/\fR, e.g.:
.PP
.Vb 4
\&    % perl Makefile.PL
\&    % make
\&    % cd blib
\&    % zip \-r mymodule.par arch/ lib/
.Ve
.PP
Afterward, you can just use \fImymodule.par\fR anywhere in your \f(CW@INC\fR,
use \fB\s-1PAR\s0\fR, and it will Just Work. Support for generating \fI.par\fR files
is going to be in the next (beyond 0.2805) release of Module::Build.
.PP
For convenience, you can set the \f(CW\*(C`PERL5OPT\*(C'\fR environment variable to
\&\f(CW\*(C`\-MPAR\*(C'\fR to enable \f(CW\*(C`PAR\*(C'\fR processing globally (the overhead is small
if not used); setting it to \f(CW\*(C`\-MPAR=/path/to/mylib.par\*(C'\fR will load a
specific \s-1PAR\s0 file.  Alternatively, consider using the \fIpar.pl\fR utility
bundled with the PAR::Packer distribution, or using the
self-contained \fIparl\fR utility which is also distributed with PAR::Packer
on machines without \s-1PAR\s0.pm installed.
.PP
Note that self-containing scripts and executables created with \fIpar.pl\fR
and \fIpp\fR may also be used as \fI.par\fR archives:
.PP
.Vb 3
\&    % pp \-o packed.exe source.pl        # generate packed.exe (see PAR::Packer)
\&    % perl \-MPAR=packed.exe other.pl    # this also works
\&    % perl \-MPAR \-Ipacked.exe other.pl  # ditto
.Ve
.PP
Please see \*(L"\s-1SYNOPSIS\*(R"\s0 for most typical use cases.
.SH "NOTES"
.IX Header "NOTES"
Settings in \fI\s-1META\s0.yml\fR packed inside the \s-1PAR\s0 file may affect \s-1PAR\s0's
operation.  For example, \fIpp\fR provides the \f(CW\*(C`\-C\*(C'\fR (\f(CW\*(C`\-\-clean\*(C'\fR) option
to control the default behavior of temporary file creation.
.PP
Currently, \fIpp\fR\-generated \s-1PAR\s0 files may attach four PAR-specific
attributes in \fI\s-1META\s0.yml\fR:
.PP
.Vb 5
\&    par:
\&      clean: 0          # default value of PAR_CLEAN
\&      signature: \*(Aq\*(Aq     # key ID of the SIGNATURE file
\&      verbatim: 0       # was packed prerequisite\*(Aqs PODs preserved?
\&      version: x.xx     # PAR.pm version that generated this PAR
.Ve
.PP
User-defined environment variables, like \fI\s-1PAR_GLOBAL_CLEAN\s0\fR, always
overrides the ones set in \fI\s-1META\s0.yml\fR.  The algorithm for generating
caching/temporary directory is as follows:
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is specified, use it as the cache directory for
extracted libraries, and do not clean it up after execution.
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is not set, but \fI\s-1PAR_CLEAN\s0\fR is specified, set
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR to \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/temp\-\f(CIPID\f(CW/\*(C'\fR, cleaning it
after execution.
.IP "\(bu" 4
If both are not set,  use \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/cache\-\f(CIHASH\f(CW/\*(C'\fR as the
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR, reusing any existing files inside.
.PP
Here is a description of the variables the previous paths.
.IP "\(bu" 4
\&\fI\s-1TEMP\s0\fR is a temporary directory, which can be set via 
\&\f(CW$ENV{PAR_GLOBAL_TMPDIR}\fR,
\&\f(CW$ENV{TMPDIR}\fR, \f(CW$ENV{TEMPDIR}\fR, \f(CW$ENV{TEMP}\fR
or \f(CW$ENV{TMP}\fR, in that order of priority.
If none of those are set, \fIC:\eTEMP\fR, \fI/tmp\fR are checked.  If neither
of them exists, \fI.\fR is used.
.IP "\(bu" 4
\&\fI\s-1USER\s0\fR is the user name, or \s-1SYSTEM\s0 if none can be found.  On Win32, 
this is \f(CW$Win32::LoginName\fR.  On Unix, this is \f(CW$ENV{USERNAME}\fR or 
\&\f(CW$ENV{USER}\fR.
.IP "\(bu" 4
\&\fI\s-1PID\s0\fR is the process \s-1ID. \s0 Forked children use the parent's \s-1PID.\s0
.IP "\(bu" 4
\&\fI\s-1HASH\s0\fR is a crypto-hash of the entire par file or executable,
calculated at creation time.  This value can be overloaded with \f(CW\*(C`pp\*(C'\fR's
\&\-\-tempdir parameter.
.PP
By default, \s-1PAR\s0 strips \s-1POD\s0 sections from bundled modules. In case
that causes trouble, you can turn this off by setting the
environment variable \f(CW\*(C`PAR_VERBATIM\*(C'\fR to \f(CW1\fR.
.SS "import options"
.IX Subsection "import options"
When you \*(L"use \s-1PAR\s0 {...}\*(R" or call \s-1PAR\-\s0>import({...}), the following
options are available.
.PP
.Vb 3
\&  PAR\->import({ file => \*(Aqfoo.par\*(Aq });
\&  # or
\&  PAR\->import({ repository => \*(Aqhttp://foo/bar/\*(Aq });
.Ve
.IP "file" 4
.IX Item "file"
The par filename.
.Sp
You must pass \fIone\fR option of either 'file' or 'repository'.
.IP "repository" 4
.IX Item "repository"
A par repository (exclusive of file)
.IP "fallback" 4
.IX Item "fallback"
Search the system \f(CW@INC\fR before the par.
.Sp
Off by default for loading \fI.par\fR files via \f(CW\*(C`file =\*(C'\fR ...>.
On by default for \s-1PAR\s0 repositories.
.Sp
To prefer loading modules from a repository over the locally
installed modules, you can load the repository as follows:
.Sp
.Vb 1
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, fallback => 0 };
.Ve
.IP "run" 4
.IX Item "run"
The name of a script to run in the par.  Exits when done.
.IP "no_shlib_unpack" 4
.IX Item "no_shlib_unpack"
Skip unpacking bundled dynamic libraries from shlib/$archname.  The
client may have them installed, or you may wish to cache them yourself.
In either case, they must end up in the standard install location (such
as /usr/local/lib/) or in \f(CW$ENV\fR{\s-1PAR_TEMP\s0} \fIbefore\fR you require the
module which needs them.  If they are not accessible before you require
the dependent module, perl will die with a message such as \*(L"cannot open
shared object file...\*(R"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1PAR\s0 homepage at <http://par.perl.org>.
.PP
PAR::Tutorial, \s-1PAR::FAQ\s0 (For a more
current \s-1FAQ,\s0 refer to the homepage.)
.PP
The PAR::Packer distribution which contains the packaging utilities:
par.pl, parl, pp.
.PP
PAR::Dist for details on \s-1PAR\s0 distributions.
.PP
PAR::Repository::Client for details on accessing \s-1PAR\s0 repositories.
PAR::Repository for details on how to set up such a repository.
.PP
Archive::Zip, \*(L"require\*(R" in perlfunc
.PP
ex::lib::zip, Acme::use::strict::with::pride
.PP
Steffen Mueller has detailed slides on using \s-1PAR\s0 for application
deployment at <http://steffen\-mueller.net/talks/appdeployment/>.
.PP
\&\s-1PAR\s0 supports the prefork module. It declares various run-time
dependencies so you can use the prefork module to get streamlined
processes in a forking environment.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Nicholas Clark for pointing out the mad source filter hook within the
(also mad) coderef \f(CW@INC\fR hook, as well as (even madder) tricks one
can play with PerlIO to avoid source filtering.
.PP
Ton Hospel for convincing me to ditch the \f(CW\*(C`Filter::Simple\*(C'\fR
implementation.
.PP
Uri Guttman for suggesting \f(CW\*(C`read_file\*(C'\fR and \f(CW\*(C`par_handle\*(C'\fR interfaces.
.PP
Antti Lankila for making me implement the self-contained executable
options via \f(CW\*(C`par.pl \-O\*(C'\fR.
.PP
See the \fI\s-1AUTHORS\s0\fR file in the distribution for a list of people who
have sent helpful patches, ideas or comments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.PP
Steffen Mueller <smueller@cpan.org>
.PP
<http://par.perl.org/> is the official \s-1PAR\s0 website.  You can write
to the mailing list at <par@perl.org>, or send an empty mail to
<par\-subscribe@perl.org> to participate in the discussion.
.PP
Please submit bug reports to <bug\-par@rt.cpan.org>. If you need
support, however, joining the <par@perl.org> mailing list is
preferred.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2010 by Audrey Tang
<cpan@audreyt.org>.
Copyright 2005\-2010 by Steffen Mueller <smueller@cpan.org>
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
                                                                                                                                                                                                                                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/PAR5.16.3pm                                  0100644 0001750 0001750 00000041104 12566242235 022234  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.20)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PAR 3"
.TH PAR 3 "2012-10-22" "perl v5.16.3" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PAR \- Perl Archive Toolkit
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
(If you want to make an executable that contains all module, scripts and
data files, please consult the pp utility instead. pp used to be
part of the \s-1PAR\s0 distribution but is now shipped as part of the PAR::Packer
distribution instead.)
.PP
Following examples assume a \fIfoo.par\fR file in Zip format.
.PP
To use \fIHello.pm\fR from \fI./foo.par\fR:
.PP
.Vb 2
\&    % perl \-MPAR=./foo.par \-MHello
\&    % perl \-MPAR=./foo \-MHello          # the .par part is optional
.Ve
.PP
Same thing, but search \fIfoo.par\fR in the \f(CW@INC\fR;
.PP
.Vb 2
\&    % perl \-MPAR \-Ifoo.par \-MHello
\&    % perl \-MPAR \-Ifoo \-MHello          # ditto
.Ve
.PP
Following paths inside the \s-1PAR\s0 file are searched:
.PP
.Vb 6
\&    /lib/
\&    /arch/
\&    /i386\-freebsd/              # i.e. $Config{archname}
\&    /5.8.0/                     # i.e. $Config{version}
\&    /5.8.0/i386\-freebsd/        # both of the above
\&    /
.Ve
.PP
\&\s-1PAR\s0 files may also (recursively) contain other \s-1PAR\s0 files.
All files under following paths will be considered as \s-1PAR\s0
files and searched as well:
.PP
.Vb 4
\&    /par/i386\-freebsd/          # i.e. $Config{archname}
\&    /par/5.8.0/                 # i.e. $Config{version}
\&    /par/5.8.0/i386\-freebsd/    # both of the above
\&    /par/
.Ve
.PP
Run \fIscript/test.pl\fR or \fItest.pl\fR from \fIfoo.par\fR:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # only when $0 ends in \*(Aq.par\*(Aq
.Ve
.PP
However, if the \fI.par\fR archive contains either \fIscript/main.pl\fR or
\&\fImain.pl\fR, then it is used instead:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # runs main.pl; @ARGV is \*(Aqtest.pl\*(Aq
.Ve
.PP
Use in a program:
.PP
.Vb 2
\&    use PAR \*(Aqfoo.par\*(Aq;
\&    use Hello; # reads within foo.par
\&
\&    # PAR::read_file() returns a file inside any loaded PARs
\&    my $conf = PAR::read_file(\*(Aqdata/MyConfig.yaml\*(Aq);
\&
\&    # PAR::par_handle() returns an Archive::Zip handle
\&    my $zip = PAR::par_handle(\*(Aqfoo.par\*(Aq)
\&    my $src = $zip\->memberNamed(\*(Aqlib/Hello.pm\*(Aq)\->contents;
.Ve
.PP
You can also use wildcard characters:
.PP
.Vb 1
\&    use PAR \*(Aq/home/foo/*.par\*(Aq;  # loads all PAR files in that directory
.Ve
.PP
Since version 0.950, you can also use a different syntax for loading
\&\fI.par\fR archives:
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq }, { file => \*(Aqotherfile.par\*(Aq };
.Ve
.PP
Why? Because you can also do this:
.PP
.Vb 2
\&    use PAR { file => \*(Aqfoo.par, fallback => 1 };
\&    use Foo::Bar;
.Ve
.PP
Foo::Bar will be searched in the system libs first and loaded from \fIfoo.par\fR
if it wasn't found!
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq };
.Ve
.PP
This will load \fIfoo.par\fR as usual and then execute the \fIscript/myscript\fR
file from the archive. Note that your program will not regain control. When
\&\fIscript/myscript\fR exits, so does your main program. To make this more useful,
you can defer this to runtime: (otherwise equivalent)
.PP
.Vb 2
\&    require PAR;
\&    PAR\->import( { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq } );
.Ve
.PP
If you have PAR::Repository::Client installed, you can do this:
.PP
.Vb 2
\&    use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq };
\&    use Module; # not locally installed!
.Ve
.PP
And \s-1PAR\s0 will fetch any modules you don't have from the specified \s-1PAR\s0
repository. For details on how this works, have a look at the \s-1SEE\s0 \s-1ALSO\s0
section below. Instead of an \s-1URL\s0 or local path, you can construct an
PAR::Repository::Client object manually and pass that to \s-1PAR\s0.
If you specify the \f(CW\*(C`install => 1\*(C'\fR option in the \f(CW\*(C`use PAR\*(C'\fR
line above, the distribution containing \f(CW\*(C`Module\*(C'\fR will be permanently
installed on your system. (\f(CW\*(C`use PAR { repository => \*(Aqhttp://foo/bar\*(Aq, install => 1 };\*(C'\fR)
.PP
Furthermore, there is an \f(CW\*(C`upgrade => 1\*(C'\fR option that checks for upgrades
in the repository in addition to installing. Please note that an upgraded
version of a module is only loaded on the next run of your application.
.PP
Adding the \f(CW\*(C`dependencies => 1\*(C'\fR option will enable PAR::Repository::Client's
static dependency resolution (PAR::Repository::Client 0.23 and up).
.PP
Finally, you can combine the \f(CW\*(C`run\*(C'\fR and \f(CW\*(C`repository\*(C'\fR
options to run an application directly from a repository! (And you can add
the \f(CW\*(C`install\*(C'\fR option, too.)
.PP
.Vb 2
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, run => \*(Aqmy_app\*(Aq };
\&  # Will not reach this point as we executed my_app,
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lets you use special zip files, called \fBP\fRerl \fBAr\fRchives, as
libraries from which Perl modules can be loaded.
.PP
It supports loading \s-1XS\s0 modules by overriding \fBDynaLoader\fR bootstrapping
methods; it writes shared object file to a temporary file at the time it
is needed.
.PP
A \fI.par\fR file is mostly a zip of the \fIblib/\fR directory after the build
process of a \s-1CPAN\s0 distribution. To generate a \fI.par\fR file yourself, all
you have to do is compress the modules under \fIarch/\fR and \fIlib/\fR, e.g.:
.PP
.Vb 4
\&    % perl Makefile.PL
\&    % make
\&    % cd blib
\&    % zip \-r mymodule.par arch/ lib/
.Ve
.PP
Afterward, you can just use \fImymodule.par\fR anywhere in your \f(CW@INC\fR,
use \fB\s-1PAR\s0\fR, and it will Just Work. Support for generating \fI.par\fR files
is going to be in the next (beyond 0.2805) release of Module::Build.
.PP
For convenience, you can set the \f(CW\*(C`PERL5OPT\*(C'\fR environment variable to
\&\f(CW\*(C`\-MPAR\*(C'\fR to enable \f(CW\*(C`PAR\*(C'\fR processing globally (the overhead is small
if not used); setting it to \f(CW\*(C`\-MPAR=/path/to/mylib.par\*(C'\fR will load a
specific \s-1PAR\s0 file.  Alternatively, consider using the \fIpar.pl\fR utility
bundled with the PAR::Packer distribution, or using the
self-contained \fIparl\fR utility which is also distributed with PAR::Packer
on machines without \s-1PAR\s0.pm installed.
.PP
Note that self-containing scripts and executables created with \fIpar.pl\fR
and \fIpp\fR may also be used as \fI.par\fR archives:
.PP
.Vb 3
\&    % pp \-o packed.exe source.pl        # generate packed.exe (see PAR::Packer)
\&    % perl \-MPAR=packed.exe other.pl    # this also works
\&    % perl \-MPAR \-Ipacked.exe other.pl  # ditto
.Ve
.PP
Please see \*(L"\s-1SYNOPSIS\s0\*(R" for most typical use cases.
.SH "NOTES"
.IX Header "NOTES"
Settings in \fI\s-1META\s0.yml\fR packed inside the \s-1PAR\s0 file may affect \s-1PAR\s0's
operation.  For example, \fIpp\fR provides the \f(CW\*(C`\-C\*(C'\fR (\f(CW\*(C`\-\-clean\*(C'\fR) option
to control the default behavior of temporary file creation.
.PP
Currently, \fIpp\fR\-generated \s-1PAR\s0 files may attach four PAR-specific
attributes in \fI\s-1META\s0.yml\fR:
.PP
.Vb 5
\&    par:
\&      clean: 0          # default value of PAR_CLEAN
\&      signature: \*(Aq\*(Aq     # key ID of the SIGNATURE file
\&      verbatim: 0       # was packed prerequisite\*(Aqs PODs preserved?
\&      version: x.xx     # PAR.pm version that generated this PAR
.Ve
.PP
User-defined environment variables, like \fI\s-1PAR_GLOBAL_CLEAN\s0\fR, always
overrides the ones set in \fI\s-1META\s0.yml\fR.  The algorithm for generating
caching/temporary directory is as follows:
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is specified, use it as the cache directory for
extracted libraries, and do not clean it up after execution.
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is not set, but \fI\s-1PAR_CLEAN\s0\fR is specified, set
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR to \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/temp\-\f(CIPID\f(CW/\*(C'\fR, cleaning it
after execution.
.IP "\(bu" 4
If both are not set,  use \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/cache\-\f(CIHASH\f(CW/\*(C'\fR as the
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR, reusing any existing files inside.
.PP
Here is a description of the variables the previous paths.
.IP "\(bu" 4
\&\fI\s-1TEMP\s0\fR is a temporary directory, which can be set via 
\&\f(CW$ENV{PAR_GLOBAL_TMPDIR}\fR,
\&\f(CW$ENV{TMPDIR}\fR, \f(CW$ENV{TEMPDIR}\fR, \f(CW$ENV{TEMP}\fR
or \f(CW$ENV{TMP}\fR, in that order of priority.
If none of those are set, \fIC:\eTEMP\fR, \fI/tmp\fR are checked.  If neither
of them exists, \fI.\fR is used.
.IP "\(bu" 4
\&\fI\s-1USER\s0\fR is the user name, or \s-1SYSTEM\s0 if none can be found.  On Win32, 
this is \f(CW$Win32::LoginName\fR.  On Unix, this is \f(CW$ENV{USERNAME}\fR or 
\&\f(CW$ENV{USER}\fR.
.IP "\(bu" 4
\&\fI\s-1PID\s0\fR is the process \s-1ID\s0.  Forked children use the parent's \s-1PID\s0.
.IP "\(bu" 4
\&\fI\s-1HASH\s0\fR is a crypto-hash of the entire par file or executable,
calculated at creation time.  This value can be overloaded with \f(CW\*(C`pp\*(C'\fR's
\&\-\-tempdir parameter.
.PP
By default, \s-1PAR\s0 strips \s-1POD\s0 sections from bundled modules. In case
that causes trouble, you can turn this off by setting the
environment variable \f(CW\*(C`PAR_VERBATIM\*(C'\fR to \f(CW1\fR.
.SS "import options"
.IX Subsection "import options"
When you \*(L"use \s-1PAR\s0 {...}\*(R" or call \s-1PAR\-\s0>import({...}), the following
options are available.
.PP
.Vb 3
\&  PAR\->import({ file => \*(Aqfoo.par\*(Aq });
\&  # or
\&  PAR\->import({ repository => \*(Aqhttp://foo/bar/\*(Aq });
.Ve
.IP "file" 4
.IX Item "file"
The par filename.
.Sp
You must pass \fIone\fR option of either 'file' or 'repository'.
.IP "repository" 4
.IX Item "repository"
A par repository (exclusive of file)
.IP "fallback" 4
.IX Item "fallback"
Search the system \f(CW@INC\fR before the par.
.Sp
Off by default for loading \fI.par\fR files via \f(CW\*(C`file =\*(C'\fR ...>.
On by default for \s-1PAR\s0 repositories.
.Sp
To prefer loading modules from a repository over the locally
installed modules, you can load the repository as follows:
.Sp
.Vb 1
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, fallback => 0 };
.Ve
.IP "run" 4
.IX Item "run"
The name of a script to run in the par.  Exits when done.
.IP "no_shlib_unpack" 4
.IX Item "no_shlib_unpack"
Skip unpacking bundled dynamic libraries from shlib/$archname.  The
client may have them installed, or you may wish to cache them yourself.
In either case, they must end up in the standard install location (such
as /usr/local/lib/) or in \f(CW$ENV\fR{\s-1PAR_TEMP\s0} \fIbefore\fR you require the
module which needs them.  If they are not accessible before you require
the dependent module, perl will die with a message such as \*(L"cannot open
shared object file...\*(R"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1PAR\s0 homepage at <http://par.perl.org>.
.PP
PAR::Tutorial, \s-1PAR::FAQ\s0 (For a more
current \s-1FAQ\s0, refer to the homepage.)
.PP
The PAR::Packer distribution which contains the packaging utilities:
par.pl, parl, pp.
.PP
PAR::Dist for details on \s-1PAR\s0 distributions.
.PP
PAR::Repository::Client for details on accessing \s-1PAR\s0 repositories.
PAR::Repository for details on how to set up such a repository.
.PP
Archive::Zip, \*(L"require\*(R" in perlfunc
.PP
ex::lib::zip, Acme::use::strict::with::pride
.PP
Steffen Mueller has detailed slides on using \s-1PAR\s0 for application
deployment at http://steffen\-mueller.net/talks/appdeployment/ <http://steffen-mueller.net/talks/appdeployment/>.
.PP
\&\s-1PAR\s0 supports the prefork module. It declares various run-time
dependencies so you can use the prefork module to get streamlined
processes in a forking environment.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Nicholas Clark for pointing out the mad source filter hook within the
(also mad) coderef \f(CW@INC\fR hook, as well as (even madder) tricks one
can play with PerlIO to avoid source filtering.
.PP
Ton Hospel for convincing me to ditch the \f(CW\*(C`Filter::Simple\*(C'\fR
implementation.
.PP
Uri Guttman for suggesting \f(CW\*(C`read_file\*(C'\fR and \f(CW\*(C`par_handle\*(C'\fR interfaces.
.PP
Antti Lankila for making me implement the self-contained executable
options via \f(CW\*(C`par.pl \-O\*(C'\fR.
.PP
See the \fI\s-1AUTHORS\s0\fR file in the distribution for a list of people who
have sent helpful patches, ideas or comments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.PP
Steffen Mueller <smueller@cpan.org>
.PP
<http://par.perl.org/> is the official \s-1PAR\s0 website.  You can write
to the mailing list at <par@perl.org>, or send an empty mail to
<par\-subscribe@perl.org> to participate in the discussion.
.PP
Please submit bug reports to <bug\-par@rt.cpan.org>. If you need
support, however, joining the <par@perl.org> mailing list is
preferred.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2010 by Audrey Tang
<cpan@audreyt.org>.
Copyright 2005\-2010 by Steffen Mueller <smueller@cpan.org>
.PP
This program is free software; you can redistribute it and/or modify it
under the same terms as Perl itself.
.PP
See <http://www.perl.com/perl/misc/Artistic.html>
                                                                                                                                                                                                                                                                                                                                                                                                                                                            osxcross/target/SDK/MacOSX10.11.sdk/usr/share/man/man3/PAR5.18.3pm                                  0100644 0001750 0001750 00000041336 12566242231 022241  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        .\" Automatically generated by Pod::Man 2.27 (Pod::Simple 3.28)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{
.    if \nF \{
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "PAR 3"
.TH PAR 3 "2012-10-22" "perl v5.18.2" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
PAR \- Perl Archive Toolkit
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
(If you want to make an executable that contains all module, scripts and
data files, please consult the pp utility instead. pp used to be
part of the \s-1PAR\s0 distribution but is now shipped as part of the PAR::Packer
distribution instead.)
.PP
Following examples assume a \fIfoo.par\fR file in Zip format.
.PP
To use \fIHello.pm\fR from \fI./foo.par\fR:
.PP
.Vb 2
\&    % perl \-MPAR=./foo.par \-MHello
\&    % perl \-MPAR=./foo \-MHello          # the .par part is optional
.Ve
.PP
Same thing, but search \fIfoo.par\fR in the \f(CW@INC\fR;
.PP
.Vb 2
\&    % perl \-MPAR \-Ifoo.par \-MHello
\&    % perl \-MPAR \-Ifoo \-MHello          # ditto
.Ve
.PP
Following paths inside the \s-1PAR\s0 file are searched:
.PP
.Vb 6
\&    /lib/
\&    /arch/
\&    /i386\-freebsd/              # i.e. $Config{archname}
\&    /5.8.0/                     # i.e. $Config{version}
\&    /5.8.0/i386\-freebsd/        # both of the above
\&    /
.Ve
.PP
\&\s-1PAR\s0 files may also (recursively) contain other \s-1PAR\s0 files.
All files under following paths will be considered as \s-1PAR\s0
files and searched as well:
.PP
.Vb 4
\&    /par/i386\-freebsd/          # i.e. $Config{archname}
\&    /par/5.8.0/                 # i.e. $Config{version}
\&    /par/5.8.0/i386\-freebsd/    # both of the above
\&    /par/
.Ve
.PP
Run \fIscript/test.pl\fR or \fItest.pl\fR from \fIfoo.par\fR:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # only when $0 ends in \*(Aq.par\*(Aq
.Ve
.PP
However, if the \fI.par\fR archive contains either \fIscript/main.pl\fR or
\&\fImain.pl\fR, then it is used instead:
.PP
.Vb 1
\&    % perl \-MPAR foo.par test.pl        # runs main.pl; @ARGV is \*(Aqtest.pl\*(Aq
.Ve
.PP
Use in a program:
.PP
.Vb 2
\&    use PAR \*(Aqfoo.par\*(Aq;
\&    use Hello; # reads within foo.par
\&
\&    # PAR::read_file() returns a file inside any loaded PARs
\&    my $conf = PAR::read_file(\*(Aqdata/MyConfig.yaml\*(Aq);
\&
\&    # PAR::par_handle() returns an Archive::Zip handle
\&    my $zip = PAR::par_handle(\*(Aqfoo.par\*(Aq)
\&    my $src = $zip\->memberNamed(\*(Aqlib/Hello.pm\*(Aq)\->contents;
.Ve
.PP
You can also use wildcard characters:
.PP
.Vb 1
\&    use PAR \*(Aq/home/foo/*.par\*(Aq;  # loads all PAR files in that directory
.Ve
.PP
Since version 0.950, you can also use a different syntax for loading
\&\fI.par\fR archives:
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq }, { file => \*(Aqotherfile.par\*(Aq };
.Ve
.PP
Why? Because you can also do this:
.PP
.Vb 2
\&    use PAR { file => \*(Aqfoo.par, fallback => 1 };
\&    use Foo::Bar;
.Ve
.PP
Foo::Bar will be searched in the system libs first and loaded from \fIfoo.par\fR
if it wasn't found!
.PP
.Vb 1
\&    use PAR { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq };
.Ve
.PP
This will load \fIfoo.par\fR as usual and then execute the \fIscript/myscript\fR
file from the archive. Note that your program will not regain control. When
\&\fIscript/myscript\fR exits, so does your main program. To make this more useful,
you can defer this to runtime: (otherwise equivalent)
.PP
.Vb 2
\&    require PAR;
\&    PAR\->import( { file => \*(Aqfoo.par\*(Aq, run => \*(Aqmyscript\*(Aq } );
.Ve
.PP
If you have PAR::Repository::Client installed, you can do this:
.PP
.Vb 2
\&    use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq };
\&    use Module; # not locally installed!
.Ve
.PP
And \s-1PAR\s0 will fetch any modules you don't have from the specified \s-1PAR\s0
repository. For details on how this works, have a look at the \s-1SEE ALSO\s0
section below. Instead of an \s-1URL\s0 or local path, you can construct an
PAR::Repository::Client object manually and pass that to \s-1PAR.\s0
If you specify the \f(CW\*(C`install => 1\*(C'\fR option in the \f(CW\*(C`use PAR\*(C'\fR
line above, the distribution containing \f(CW\*(C`Module\*(C'\fR will be permanently
installed on your system. (\f(CW\*(C`use PAR { repository => \*(Aqhttp://foo/bar\*(Aq, install => 1 };\*(C'\fR)
.PP
Furthermore, there is an \f(CW\*(C`upgrade => 1\*(C'\fR option that checks for upgrades
in the repository in addition to installing. Please note that an upgraded
version of a module is only loaded on the next run of your application.
.PP
Adding the \f(CW\*(C`dependencies => 1\*(C'\fR option will enable PAR::Repository::Client's
static dependency resolution (PAR::Repository::Client 0.23 and up).
.PP
Finally, you can combine the \f(CW\*(C`run\*(C'\fR and \f(CW\*(C`repository\*(C'\fR
options to run an application directly from a repository! (And you can add
the \f(CW\*(C`install\*(C'\fR option, too.)
.PP
.Vb 2
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, run => \*(Aqmy_app\*(Aq };
\&  # Will not reach this point as we executed my_app,
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
This module lets you use special zip files, called \fBP\fRerl \fBAr\fRchives, as
libraries from which Perl modules can be loaded.
.PP
It supports loading \s-1XS\s0 modules by overriding \fBDynaLoader\fR bootstrapping
methods; it writes shared object file to a temporary file at the time it
is needed.
.PP
A \fI.par\fR file is mostly a zip of the \fIblib/\fR directory after the build
process of a \s-1CPAN\s0 distribution. To generate a \fI.par\fR file yourself, all
you have to do is compress the modules under \fIarch/\fR and \fIlib/\fR, e.g.:
.PP
.Vb 4
\&    % perl Makefile.PL
\&    % make
\&    % cd blib
\&    % zip \-r mymodule.par arch/ lib/
.Ve
.PP
Afterward, you can just use \fImymodule.par\fR anywhere in your \f(CW@INC\fR,
use \fB\s-1PAR\s0\fR, and it will Just Work. Support for generating \fI.par\fR files
is going to be in the next (beyond 0.2805) release of Module::Build.
.PP
For convenience, you can set the \f(CW\*(C`PERL5OPT\*(C'\fR environment variable to
\&\f(CW\*(C`\-MPAR\*(C'\fR to enable \f(CW\*(C`PAR\*(C'\fR processing globally (the overhead is small
if not used); setting it to \f(CW\*(C`\-MPAR=/path/to/mylib.par\*(C'\fR will load a
specific \s-1PAR\s0 file.  Alternatively, consider using the \fIpar.pl\fR utility
bundled with the PAR::Packer distribution, or using the
self-contained \fIparl\fR utility which is also distributed with PAR::Packer
on machines without \s-1PAR\s0.pm installed.
.PP
Note that self-containing scripts and executables created with \fIpar.pl\fR
and \fIpp\fR may also be used as \fI.par\fR archives:
.PP
.Vb 3
\&    % pp \-o packed.exe source.pl        # generate packed.exe (see PAR::Packer)
\&    % perl \-MPAR=packed.exe other.pl    # this also works
\&    % perl \-MPAR \-Ipacked.exe other.pl  # ditto
.Ve
.PP
Please see \*(L"\s-1SYNOPSIS\*(R"\s0 for most typical use cases.
.SH "NOTES"
.IX Header "NOTES"
Settings in \fI\s-1META\s0.yml\fR packed inside the \s-1PAR\s0 file may affect \s-1PAR\s0's
operation.  For example, \fIpp\fR provides the \f(CW\*(C`\-C\*(C'\fR (\f(CW\*(C`\-\-clean\*(C'\fR) option
to control the default behavior of temporary file creation.
.PP
Currently, \fIpp\fR\-generated \s-1PAR\s0 files may attach four PAR-specific
attributes in \fI\s-1META\s0.yml\fR:
.PP
.Vb 5
\&    par:
\&      clean: 0          # default value of PAR_CLEAN
\&      signature: \*(Aq\*(Aq     # key ID of the SIGNATURE file
\&      verbatim: 0       # was packed prerequisite\*(Aqs PODs preserved?
\&      version: x.xx     # PAR.pm version that generated this PAR
.Ve
.PP
User-defined environment variables, like \fI\s-1PAR_GLOBAL_CLEAN\s0\fR, always
overrides the ones set in \fI\s-1META\s0.yml\fR.  The algorithm for generating
caching/temporary directory is as follows:
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is specified, use it as the cache directory for
extracted libraries, and do not clean it up after execution.
.IP "\(bu" 4
If \fI\s-1PAR_GLOBAL_TEMP\s0\fR is not set, but \fI\s-1PAR_CLEAN\s0\fR is specified, set
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR to \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/temp\-\f(CIPID\f(CW/\*(C'\fR, cleaning it
after execution.
.IP "\(bu" 4
If both are not set,  use \f(CW\*(C`\f(CITEMP\f(CW/par\-\f(CIUSER\f(CW/cache\-\f(CIHASH\f(CW/\*(C'\fR as the
\&\fI\s-1PAR_GLOBAL_TEMP\s0\fR, reusing any existing files inside.
.PP
Here is a description of the variables the previous paths.
.IP "\(bu" 4
\&\fI\s-1TEMP\s0\fR is a temporary directory, which can be set via 
\&\f(CW$ENV{PAR_GLOBAL_TMPDIR}\fR,
\&\f(CW$ENV{TMPDIR}\fR, \f(CW$ENV{TEMPDIR}\fR, \f(CW$ENV{TEMP}\fR
or \f(CW$ENV{TMP}\fR, in that order of priority.
If none of those are set, \fIC:\eTEMP\fR, \fI/tmp\fR are checked.  If neither
of them exists, \fI.\fR is used.
.IP "\(bu" 4
\&\fI\s-1USER\s0\fR is the user name, or \s-1SYSTEM\s0 if none can be found.  On Win32, 
this is \f(CW$Win32::LoginName\fR.  On Unix, this is \f(CW$ENV{USERNAME}\fR or 
\&\f(CW$ENV{USER}\fR.
.IP "\(bu" 4
\&\fI\s-1PID\s0\fR is the process \s-1ID. \s0 Forked children use the parent's \s-1PID.\s0
.IP "\(bu" 4
\&\fI\s-1HASH\s0\fR is a crypto-hash of the entire par file or executable,
calculated at creation time.  This value can be overloaded with \f(CW\*(C`pp\*(C'\fR's
\&\-\-tempdir parameter.
.PP
By default, \s-1PAR\s0 strips \s-1POD\s0 sections from bundled modules. In case
that causes trouble, you can turn this off by setting the
environment variable \f(CW\*(C`PAR_VERBATIM\*(C'\fR to \f(CW1\fR.
.SS "import options"
.IX Subsection "import options"
When you \*(L"use \s-1PAR\s0 {...}\*(R" or call \s-1PAR\-\s0>import({...}), the following
options are available.
.PP
.Vb 3
\&  PAR\->import({ file => \*(Aqfoo.par\*(Aq });
\&  # or
\&  PAR\->import({ repository => \*(Aqhttp://foo/bar/\*(Aq });
.Ve
.IP "file" 4
.IX Item "file"
The par filename.
.Sp
You must pass \fIone\fR option of either 'file' or 'repository'.
.IP "repository" 4
.IX Item "repository"
A par repository (exclusive of file)
.IP "fallback" 4
.IX Item "fallback"
Search the system \f(CW@INC\fR before the par.
.Sp
Off by default for loading \fI.par\fR files via \f(CW\*(C`file =\*(C'\fR ...>.
On by default for \s-1PAR\s0 repositories.
.Sp
To prefer loading modules from a repository over the locally
installed modules, you can load the repository as follows:
.Sp
.Vb 1
\&  use PAR { repository => \*(Aqhttp://foo/bar/\*(Aq, fallback => 0 };
.Ve
.IP "run" 4
.IX Item "run"
The name of a script to run in the par.  Exits when done.
.IP "no_shlib_unpack" 4
.IX Item "no_shlib_unpack"
Skip unpacking bundled dynamic libraries from shlib/$archname.  The
client may have them installed, or you may wish to cache them yourself.
In either case, they must end up in the standard install location (such
as /usr/local/lib/) or in \f(CW$ENV\fR{\s-1PAR_TEMP\s0} \fIbefore\fR you require the
module which needs them.  If they are not accessible before you require
the dependent module, perl will die with a message such as \*(L"cannot open
shared object file...\*(R"
.SH "SEE ALSO"
.IX Header "SEE ALSO"
The \s-1PAR\s0 homepage at <http://par.perl.org>.
.PP
PAR::Tutorial, \s-1PAR::FAQ\s0 (For a more
current \s-1FAQ,\s0 refer to the homepage.)
.PP
The PAR::Packer distribution which contains the packaging utilities:
par.pl, parl, pp.
.PP
PAR::Dist for details on \s-1PAR\s0 distributions.
.PP
PAR::Repository::Client for details on accessing \s-1PAR\s0 repositories.
PAR::Repository for details on how to set up such a repository.
.PP
Archive::Zip, \*(L"require\*(R" in perlfunc
.PP
ex::lib::zip, Acme::use::strict::with::pride
.PP
Steffen Mueller has detailed slides on using \s-1PAR\s0 for application
deployment at <http://steffen\-mueller.net/talks/appdeployment/>.
.PP
\&\s-1PAR\s0 supports the prefork module. It declares various run-time
dependencies so you can use the prefork module to get streamlined
processes in a forking environment.
.SH "ACKNOWLEDGMENTS"
.IX Header "ACKNOWLEDGMENTS"
Nicholas Clark for pointing out the mad source filter hook within the
(also mad) coderef \f(CW@INC\fR hook, as well as (even madder) tricks one
can play with PerlIO to avoid source filtering.
.PP
Ton Hospel for convincing me to ditch the \f(CW\*(C`Filter::Simple\*(C'\fR
implementation.
.PP
Uri Guttman for suggesting \f(CW\*(C`read_file\*(C'\fR and \f(CW\*(C`par_handle\*(C'\fR interfaces.
.PP
Antti Lankila for making me implement the self-contained executable
options via \f(CW\*(C`par.pl \-O\*(C'\fR.
.PP
See the \fI\s-1AUTHORS\s0\fR file in the distribution for a list of people who
have sent helpful patches, ideas or comments.
.SH "AUTHORS"
.IX Header "AUTHORS"
Audrey Tang <cpan@audreyt.org>
.PP
Steffen Mueller <smueller@cpan.org>
.PP
<http://par.perl.org/> is the official \s-1PAR\s0 website.  You can write
to the mailing list at <par@perl.org>, or send an empty mail to
<par\-subscribe@perl.org> to participate in the discussion.
.PP
Please submit bug reports to <bug\-par@rt.cpan.org>. If you need
support, however, joining the <par@perl.org> mailing list is
preferred.
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright 2002\-2010 by Audrey Tang
<cpan@audreyt.org>.
Copyr