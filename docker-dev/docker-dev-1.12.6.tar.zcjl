 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double *dest, const __local double *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double *dest, const __global double *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, size_t stride, event_t evt);
#else
#define __CLFN_EVENT_ALL4(name) event_t __OVERLOAD__ name(__global char *dest, const __local char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar *dest, const __local uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char *dest, const __global char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar *dest, const __global uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, size_t stride, event_t evt);
#endif

#define CHAR_BIT    8
#define	SCHAR_MAX	127		/* min value for a signed char */
#define	SCHAR_MIN	(-128)		/* max value for a signed char */
#define	UCHAR_MAX	255		/* max value for an unsigned char */
#define	CHAR_MAX	SCHAR_MAX		/* max value for a char */
#define	CHAR_MIN	SCHAR_MIN		/* min value for a char */
#define	USHRT_MAX	65535		/* max value for an unsigned short */
#define	SHRT_MAX	32767		/* max value for a short */
#define	SHRT_MIN	(-32768)	/* min value for a short */
#define	UINT_MAX	0xffffffff	/* max value for an unsigned int */
#define	INT_MAX		2147483647	/* max value for an int */
#define	INT_MIN		(-2147483647-1)	/* min value for an int */
#define	ULONG_MAX	0xffffffffffffffffUL	/* max unsigned long */
#define	LONG_MAX	((long)0x7fffffffffffffffL)	/* max signed long */
#define	LONG_MIN	((long)(-0x7fffffffffffffffL-1)) /* min signed long */

#define FLT_DIG         6 
#define FLT_MANT_DIG    24 
#define FLT_MAX_10_EXP  +38 
#define FLT_MAX_EXP     +128 
#define FLT_MIN_10_EXP  -37 
#define FLT_MIN_EXP     -125 
#define FLT_RADIX       2 
#define FLT_MAX         0x1.fffffep127f 
#define FLT_MIN         0x1.0p-126f 
#define FLT_EPSILON     0x1.0p-23f 

#define FP_ILOGB0       INT_MIN
#define FP_ILOGBNAN     INT_MIN

// Section 6.9
#define __kernel_exec( _X, _type)   __kernel __attribute__ ((work_group_size_hint(_X, 1, 1)))  __attribute__((vec_type_hint(_type)))
#define kernel_exec( _X, _type)     __kernel_exec( _X, _type)
#define CL_VERSION_1_0  100
#define CL_VERSION_1_1  110
#define CL_VERSION_1_2  120

#define M_E_F         2.71828182845904523536028747135266250f   /* e */
#define M_LOG2E_F     1.44269504088896340735992468100189214f   /* log 2e */
#define M_LOG10E_F    0.434294481903251827651128918916605082f  /* log 10e */
#define M_LN2_F       0.693147180559945309417232121458176568f  /* log e2 */
#define M_LN10_F      2.3025850929940456840179914546843642f    /* log e10 */
#define M_PI_F        3.14159265358979323846264338327950288f   /* pi */
#define M_PI_2_F      1.57079632679489661923132169163975144f   /* pi/2 */
#define M_PI_4_F      0.785398163397448309615660845819875721f  /* pi/4 */
#define M_1_PI_F      0.318309886183790671537767526745028724f  /* 1/pi */
#define M_2_PI_F      0.636619772367581343075535053490057448f  /* 2/pi */
#define M_2_SQRTPI_F  1.12837916709551257389615890312154517f   /* 2/sqrt(pi) */
#define M_SQRT2_F     1.41421356237309504880168872420969808f   /* sqrt(2) */
#define M_SQRT1_2_F   0.707106781186547524400844362104849039f  /* 1/sqrt(2) */


#if (defined(cl_khr_fp64) || defined(cl_APPLE_fp64_basic_ops))

    #define DBL_DIG         15 
    #define DBL_MANT_DIG    53 
    #define DBL_MAX_10_EXP  +308 
    #define DBL_MAX_EXP     +1024 
    #define DBL_MIN_10_EXP  -307 
    #define DBL_MIN_EXP     -1021 
    #define DBL_RADIX       2 
    #define DBL_MAX         0x1.fffffffffffffp1023 
    #define DBL_MIN         0x1.0p-1022 
    #define DBL_EPSILON     0x1.0p-52

    #define HUGE_VAL        __builtin_huge_val()

    #define M_E         2.71828182845904523536028747135266250   /* e */
    #define M_LOG2E     1.44269504088896340735992468100189214   /* log 2e */
    #define M_LOG10E    0.434294481903251827651128918916605082  /* log 10e */
    #define M_LN2       0.693147180559945309417232121458176568  /* log e2 */
    #define M_LN10      2.30258509299404568401799145468436421   /* log e10 */
    #define M_PI        3.14159265358979323846264338327950288   /* pi */
    #define M_PI_2      1.57079632679489661923132169163975144   /* pi/2 */
    #define M_PI_4      0.785398163397448309615660845819875721  /* pi/4 */
    #define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi */
    #define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi */
    #define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi) */
    #define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2) */
    #define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2) */

#endif

#define __OPENCL_TYPES_DEFINED__ 1

/* vload2 */
char2     __OVERLOAD__ vload2(size_t index, const char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const int *p);
uint2     __OVERLOAD__ vload2(size_t index, const uint *p);
long2     __OVERLOAD__ vload2(size_t index, const long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __global char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __global uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __global short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __global ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __global int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __global uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __global long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __global ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __global double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __local char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __local uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __local short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __local ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __local int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __local uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __local long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __local ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __local double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __constant char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __constant uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __constant short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __constant ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __constant int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __constant uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __constant long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __constant ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __constant double *p);
#endif

/* vload3 */
char3     __OVERLOAD__ vload3(size_t index, const char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const int *p);
uint3     __OVERLOAD__ vload3(size_t index, const uint *p);
long3     __OVERLOAD__ vload3(size_t index, const long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __global char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __global uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __global short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __global ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __global int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __global uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __global long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __global ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __global double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __local char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __local uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __local short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __local ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __local int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __local uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __local long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __local ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __local double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __constant char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __constant uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __constant short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __constant ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __constant int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __constant uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __constant long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __constant ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __constant double *p);
#endif
/* vload4 */
char4     __OVERLOAD__ vload4(size_t index, const char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const int *p);
uint4     __OVERLOAD__ vload4(size_t index, const uint *p);
long4     __OVERLOAD__ vload4(size_t index, const long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __global char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __global uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __global short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __global ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __global int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __global uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __global long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __global ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __global double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __local char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __local uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __local short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __local ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __local int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __local uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __local long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __local ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __local double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __constant char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __constant uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __constant short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __constant ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __constant int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __constant uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __constant long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __constant ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __constant double *p);
#endif
/* vload8 */
char8     __OVERLOAD__ vload8(size_t index, const char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const int *p);
uint8     __OVERLOAD__ vload8(size_t index, const uint *p);
long8     __OVERLOAD__ vload8(size_t index, const long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __global char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __global uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __global short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __global ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __global int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __global uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __global long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __global ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __global double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __local char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __local uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __local short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __local ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __local int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __local uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __local long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __local ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __local double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __constant char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __constant uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __constant short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __constant ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __constant int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __constant uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __constant long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __constant ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __constant double *p);
#endif
/* vload16 */
char16    __OVERLOAD__ vload16(size_t index, const char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const int *p);
uint16    __OVERLOAD__ vload16(size_t index, const uint *p);
long16    __OVERLOAD__ vload16(size_t index, const long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __global char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __global uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __global short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __global ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __global int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __global uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __global long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __global ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __global double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __local char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __local uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __local short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __local ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __local int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __local uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __local long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __local ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __local double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __constant char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __constant uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __constant short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __constant ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __constant int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __constant uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __constant long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __constant ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __constant double *p);
#endif
/* vload_half */
float   __OVERLOAD__ vload_half(size_t index, const half *p);
float   __OVERLOAD__ vload_half(size_t index, const __global half *p);
float   __OVERLOAD__ vload_half(size_t index, const __local half *p);
float   __OVERLOAD__ vload_half(size_t index, const __constant half *p);

/* vload_ahalf */
float __OVERLOAD__ vloada_half(size_t index, const half *p);
float __OVERLOAD__ vloada_half(size_t index, const __global half *p);
float __OVERLOAD__ vloada_half(size_t index, const __local half *p);
float __OVERLOAD__ vloada_half(size_t index, const __constant half *p);

/* vload_half2 */
float2  __OVERLOAD__ vload_half2(size_t index, const half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __global half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __local half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __constant half *p);

/* vloada_half2 */
float2 __OVERLOAD__ vloada_half2(size_t index, const half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __global half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __local half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __constant half *p);

/* vload_half3 */
float3 __OVERLOAD__ vload_half3( size_t index, const half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __global half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __local half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __constant half *p);

/* vloada_half3 */
float3 __OVERLOAD__ vloada_half3(size_t index, const half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __global half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __local half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __constant half *p);

/* vload_half4 */
float4 __OVERLOAD__ vload_half4(size_t index, const half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __global half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __local half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __constant half *p);

/* vloada_half4 */
float4 __OVERLOAD__ vloada_half4(size_t index, const half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __global half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __local half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __constant half *p);

/* vload_half8 */
float8 __OVERLOAD__ vload_half8(size_t index, const half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __global half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __local half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __constant half *p);

/* vloada_half8 */
float8 __OVERLOAD__ vloada_half8(size_t index, const half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __global half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __local half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __constant half *p);

/* vload_half16 */
float16 __OVERLOAD__ vload_half16(size_t index, const half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __global half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __local half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __constant half *p);

/* vloada_half16 */
float16 __OVERLOAD__ vloada_half16(size_t index, const half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __global half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __local half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __constant half *p);

/* vstore2 */
void __OVERLOAD__ vstore2( char2 v, size_t index, char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore2( char2 v, size_t index, __global char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, __global short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, __global int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, __global long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore2( char2 v, size_t index, __local char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, __local short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, __local int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, __local long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, __local double *p );
#endif
/* vstore3 */
void __OVERLOAD__ vstore3( char3 v, size_t index, char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore3( char3 v, size_t index, __global char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, __global short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, __global int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, __global long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore3( char3 v, size_t index, __local char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, __local short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, __local int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, __local long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, __local double *p );
#endif

/* vstore4 */
void __OVERLOAD__ vstore4( char4 v, size_t index, char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore4( char4 v, size_t index, __global char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, __global short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, __global int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, __global long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore4( char4 v, size_t index, __local char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, __local short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, __local int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, __local long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, __local double *p );
#endif

/* vstore8 */
void __OVERLOAD__ vstore8( char8 v, size_t index, char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore8( char8 v, size_t index, __global char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, __global short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, __global int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, __global long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore8( char8 v, size_t index, __local char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, __local short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, __local int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, __local long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, __local double *p );
#endif

/* vstore16 */
void __OVERLOAD__ vstore16( char16 v, size_t index, char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore16( char16 v, size_t index, __global char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, __global short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, __global int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, __global long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore16( char16 v, size_t index, __local char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, __local short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, __local int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, __local long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, __local double *p );
#endif
/* vstore_half */
void __OVERLOAD__ vstore_half (float  f, size_t index, half *p);
void __OVERLOAD__ vstore_half (float  f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half (float  f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half(double f, size_t index, __local half *p);
#endif
/* vstore_half2 */
void __OVERLOAD__ vstore_half2(float2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2(float2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2(float2 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, __local half *p);

/* vstore_half3 */
void __OVERLOAD__ vstore_half3(float3 f, size_t index, half *p);
void __OVERLOAD__ vstore_half3(float3 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3(float3 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, __local half *p);

/* vstore_half4 */
void __OVERLOAD__ vstore_half4(float4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4(float4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4(float4 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, __local half *p);

/* vstore_half8 */
void __OVERLOAD__ vstore_half8(float8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, __local half *p);

/* vstore_half16 */
void __OVERLOAD__ vstore_half16(float16 v, size_t index, half *p);
void __OVERLOAD__ vstore_half16(float16 v, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16(float16 v, size_t index, __local half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, __local half *p);

/* vstorea_half */
void __OVERLOAD__ vstorea_half (float  f, size_t index, half *p);
void __OVERLOAD__ vstorea_half (float  f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half (float  f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half(double f, size_t index, __local half *p);
#endif
/* vstorea_half2 */
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, __local half *p);

/* vstorea_half3 */
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, __local half *p);

/* vstorea_half4 */
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, __local half *p);

/* vstorea_half8 */
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, __local half *p);

/* vstorea_half16 */
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, __local half *p);

/* vstore_half_rte */
void __OVERLOAD__ vstore_half_rte(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rte(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rte(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rte(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rte(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rte(double f, size_t index, __local half *p);
#endif
/* vstore_half2_rte */
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, __local half *p);

/* vstore_half3_rte */
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, half *p);
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, __local half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, __local half *p);

/* vstore_half4_rte */
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, __local half *p);

/* vstore_half8_rte */
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, __local half *p);

/* vstore_half16_rte */
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, half *p);
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, __local half *p);

/* vstorea_half_rte */
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rte( X, Y, Z )     vstore_half_rte( X, Y, Z )

/* vstorea_half2_rte */ 
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, __local half *p );

/* vstorea_half3_rte */
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, __local half *p );

/* vstorea_half4_rte */
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, __global  half *p );
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, __local half *p );

/* vstorea_half8_rte */
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, __local half *p );

/* vstorea_half16_rte */
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, __local half *p);
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, __local half *p );

/* vstore_half_rtz */
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, half *p);
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, __local half *p);
#endif
/* vstore_half2_rtz */
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, half *p);
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, __local half *p);

/* vstore_half3_rtz */
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, half *p);
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, __local half *p );

/* vstore_half4_rtz */
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, half *p);
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, __local half *p );

/* vstore_half8_rtz */
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, half *p);
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, __local half *p );

/* vstore_half16_rtz */
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, half *p);
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, __local half *p );

/* vstorea_half_rtz */
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, half *p);
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rtz( X, Y, Z )     vstore_half_rtz( X, Y, Z )

/* vstorea_half2_rtz */
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, __local half *p );

/* vstorea_half3_rtz */
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, __local half *p );

/* vstorea_half4_rtz */
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtz */
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtz */
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, __local half *p );

/* vstore_half_rtp */
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, __local half *p);
#endif

/* vstore_half2_rtp */
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , half *p);
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, __local half *p);

/* vstore_half3_rtp */
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , half *p);
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, __local half *p );

/* vstore_half4_rtp */
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , half *p);
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, __local half *p );

/* vstore_half8_rtp */
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , half *p);
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, __local half *p );

/* vstore_half16_rtp */
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , half *p);
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, __local half *p );

/* vstorea_half_rtp */
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rtp( X, Y, Z )     vstore_half_rtp( X, Y, Z )

/* vstorea_half2_rtp */
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, __local half *p);

/* vstorea_half3_rtp */
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, __local half *p);

/* vstorea_half4_rtp */
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtp */
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtp */
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, __local half *p );

/* vstore_half_rtn */
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, half *p );
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, __local half *p );
#endif

/* vstore_half2_rtn */
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, half *p);
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, __local half *p);

/* vstore_half3_rtn */
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, half *p);
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, __global half *p);
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, __local half *p);
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, __local half *p );

/* vstore_half4_rtn */
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, half *p);
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, __global half *p);
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, __local half *p);
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, __local half *p );

/* vstore_half8_rtn */
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, half *p);
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, __global half *p);
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, __local half *p);
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, __local half *p );

/* vstore_half16_rtn */
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, half *p);
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, __local half *p );

/* vstorea_half_rtn */
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, half *p );
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, __local half *p );
#endif
#define vstorea_half_rtn( X, Y, Z )     vstore_half_rtn( X, Y, Z )

/* vstorea_half2_rtn */
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, __local half *p );

/* vstorea_half3_rtn */
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, __local half *p );

/* vstorea_half4_rtn */
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtn */
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtn */
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, __local half *p );


// Vector Components / Constructors to be backward compatible with initial release though they are not in the OpenCL1.0 spec.
#define make_uchar2(A,B) (uchar2)((A),(B))
#define make_uchar3(A,B,C) (uchar3)((A),(B),(C))
#define make_uchar4(A,B,C,D) (uchar4)((A),(B),(C),(D))
#define make_uchar8(A,B,C,D,E,F,G,H) (uchar8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_uchar16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (uchar16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_char2(A,B) (char2)((A),(B))
#define make_char3(A,B,C) (char3)((A),(B),(C))
#define make_char4(A,B,C,D) (char4)((A),(B),(C),(D))
#define make_char8(A,B,C,D,E,F,G,H) (char8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_char16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (char16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_short2(A,B) (short2)((A),(B))
#define make_short3(A,B,C) (short3)((A),(B),(C))
#define make_short4(A,B,C,D) (short4)((A),(B),(C),(D))
#define make_short8(A,B,C,D,E,F,G,H) (short8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_short16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (short16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_ushort2(A,B) (ushort2)((A),(B))
#define make_ushort3(A,B,C) (ushort3)((A),(B),(C))
#define make_ushort4(A,B,C,D) (ushort4)((A),(B),(C),(D))
#define make_ushort8(A,B,C,D,E,F,G,H) (ushort8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_ushort16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (ushort16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_int2(A,B) (int2)((A),(B))
#define make_int3(A,B,C) (int3)((A),(B),(C))
#define make_int4(A,B,C,D) (int4)((A),(B),(C),(D))
#define make_int8(A,B,C,D,E,F,G,H) (int8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_int16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (int16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_uint2(A,B) (uint2)((A),(B))
#define make_uint3(A,B,C) (uint3)((A),(B),(C))
#define make_uint4(A,B,C,D) (uint4)((A),(B),(C),(D))
#define make_uint8(A,B,C,D,E,F,G,H) (uint8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_uint16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (uint16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_long2(A,B) (long2)((A),(B))
#define make_long3(A,B,C) (long3)((A),(B),(C))
#define make_long4(A,B,C,D) (long4)((A),(B),(C),(D))
#define make_long8(A,B,C,D,E,F,G,H) (long8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_long16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (long16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_ulong2(A,B) (ulong2)((A),(B))
#define make_ulong3(A,B,C) (ulong3)((A),(B),(C))
#define make_ulong4(A,B,C,D) (ulong4)((A),(B),(C),(D))
#define make_ulong8(A,B,C,D,E,F,G,H) (ulong8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_ulong16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (ulong16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_float2(A,B) (float2)((A),(B))
#define make_float3(A,B,C) (float3)((A),(B),(C))
#define make_float3_SPI(A,B,C) (float3)((A),(B),(C))
#define make_float4(A,B,C,D) (float4)((A),(B),(C),(D))
#define make_float8(A,B,C,D,E,F,G,H) (float8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_float16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (float16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_double2(A,B) (double2)((A),(B))
#define make_double3(A,B,C) (double3)((A),(B),(C))
#define make_double4(A,B,C,D) (double4)((A),(B),(C),(D))
#define make_double8(A,B,C,D,E,F,G,H) (double8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_double16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (double16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))


// 5.2.3 convert_ operators
typedef enum
{
    __kDefaultRoundingMode = 0,
    __kRoundToNearestEven = 1,
    __kRoundTowardNegativeInf = 2,
    __kRoundTowardInf = 3,
    __kRoundTowardZero = 4
}__clRoundingMode;

typedef enum
{
    __kUnsaturated = 0,
    __kSaturated = 1
}__clSaturationMode;

#if defined( __PTX__ )

    //type
    #define convert_char(_X)    __builtin_convert(_X, char, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar(_X)   __builtin_convert(_X, uchar, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short(_X)   __builtin_convert(_X, short, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort(_X)  __builtin_convert(_X, ushort, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int(_X)     __builtin_convert(_X, int, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint(_X)    __builtin_convert(_X, uint, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long(_X)    __builtin_convert(_X, long, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong(_X)   __builtin_convert(_X, ulong, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float(_X)   __builtin_convert(_X, float, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double(_X)  __builtin_convert(_X, double, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char_sat(_X)    __builtin_convert(_X, char, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar_sat(_X)   __builtin_convert(_X, uchar, __kDefaultRoundingMode, __kSaturated )
    #define convert_short_sat(_X)   __builtin_convert(_X, short, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort_sat(_X)  __builtin_convert(_X, ushort, __kDefaultRoundingMode, __kSaturated )
    #define convert_int_sat(_X)     __builtin_convert(_X, int, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint_sat(_X)    __builtin_convert(_X, uint, __kDefaultRoundingMode, __kSaturated )
    #define convert_long_sat(_X)    __builtin_convert(_X, long, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong_sat(_X)   __builtin_convert(_X, ulong, __kDefaultRoundingMode, __kSaturated )
    #define convert_float_sat(_X)   __builtin_convert(_X, float, __kDefaultRoundingMode, __kSaturated )
    #define convert_double_sat(_X)  __builtin_convert(_X, double, __kDefaultRoundingMode, __kSaturated )

    #define convert_char_rte(_X)    __builtin_convert(_X, char, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar_rte(_X)   __builtin_convert(_X, uchar, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short_rte(_X)   __builtin_convert(_X, short, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort_rte(_X)  __builtin_convert(_X, ushort, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int_rte(_X)     __builtin_convert(_X, int, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint_rte(_X)    __builtin_convert(_X, uint, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long_rte(_X)    __builtin_convert(_X, long, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong_rte(_X)   __builtin_convert(_X, ulong, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float_rte(_X)   __builtin_convert(_X, float, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double_rte(_X)  __builtin_convert(_X, double, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char_sat_rte(_X)    __builtin_convert(_X, char, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar_sat_rte(_X)   __builtin_convert(_X, uchar, __kRoundToNearestEven, __kSaturated )
    #define convert_short_sat_rte(_X)   __builtin_convert(_X, short, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort_sat_rte(_X)  __builtin_convert(_X, ushort, __kRoundToNearestEven, __kSaturated )
    #define convert_int_sat_rte(_X)     __builtin_convert(_X, int, __kRoundToNearestEven, __kSaturated )
    #define convert_uint_sat_rte(_X)    __builtin_convert(_X, uint, __kRoundToNearestEven, __kSaturated )
    #define convert_long_sat_rte(_X)    __builtin_convert(_X, long, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong_sat_rte(_X)   __builtin_convert(_X, ulong, __kRoundToNearestEven, __kSaturated )
    #define convert_float_sat_rte(_X)   __builtin_convert(_X, float, __kRoundToNearestEven, __kSaturated )
    #define convert_double_sat_rte(_X)  __builtin_convert(_X, double, __kRoundToNearestEven, __kSaturated )

    #define convert_char_rtn(_X)    __builtin_convert(_X, char, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar_rtn(_X)   __builtin_convert(_X, uchar, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short_rtn(_X)   __builtin_convert(_X, short, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort_rtn(_X)  __builtin_convert(_X, ushort, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int_rtn(_X)     __builtin_convert(_X, int, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint_rtn(_X)    __builtin_convert(_X, uint, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long_rtn(_X)    __builtin_convert(_X, long, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong_rtn(_X)   __builtin_convert(_X, ulong, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float_rtn(_X)   __builtin_convert(_X, float, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double_rtn(_X)  __builtin_convert(_X, double, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char_sat_rtn(_X)    __builtin_convert(_X, char, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar_sat_rtn(_X)   __builtin_convert(_X, uchar, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short_sat_rtn(_X)   __builtin_convert(_X, short, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort_sat_rtn(_X)  __builtin_convert(_X, ushort, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int_sat_rtn(_X)     __builtin_convert(_X, int, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint_sat_rtn(_X)    __builtin_convert(_X, uint, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long_sat_rtn(_X)    __builtin_convert(_X, long, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong_sat_rtn(_X)   __builtin_convert(_X, ulong, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float_sat_rtn(_X)   __builtin_convert(_X, float, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double_sat_rtn(_X)  __builtin_convert(_X, double, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char_rtp(_X)    __builtin_convert(_X, char, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar_rtp(_X)   __builtin_convert(_X, uchar, __kRoundTowardInf, __kUnsaturated )
    #define convert_short_rtp(_X)   __builtin_convert(_X, short, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort_rtp(_X)  __builtin_convert(_X, ushort, __kRoundTowardInf, __kUnsaturated )
    #define convert_int_rtp(_X)     __builtin_convert(_X, int, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint_rtp(_X)    __builtin_convert(_X, uint, __kRoundTowardInf, __kUnsaturated )
    #define convert_long_rtp(_X)    __builtin_convert(_X, long, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong_rtp(_X)   __builtin_convert(_X, ulong, __kRoundTowardInf, __kUnsaturated )
    #define convert_float_rtp(_X)   __builtin_convert(_X, float, __kRoundTowardInf, __kUnsaturated )
    #define convert_double_rtp(_X)  __builtin_convert(_X, double, __kRoundTowardInf, __kUnsaturated )

    #define convert_char_sat_rtp(_X)    __builtin_convert(_X, char, __kRoundTowardInf, __kSaturated )
    #define convert_uchar_sat_rtp(_X)   __builtin_convert(_X, uchar, __kRoundTowardInf, __kSaturated )
    #define convert_short_sat_rtp(_X)   __builtin_convert(_X, short, __kRoundTowardInf, __kSaturated )
    #define convert_ushort_sat_rtp(_X)  __builtin_convert(_X, ushort, __kRoundTowardInf, __kSaturated )
    #define convert_int_sat_rtp(_X)     __builtin_convert(_X, int, __kRoundTowardInf, __kSaturated )
    #define convert_uint_sat_rtp(_X)    __builtin_convert(_X, uint, __kRoundTowardInf, __kSaturated )
    #define convert_long_sat_rtp(_X)    __builtin_convert(_X, long, __kRoundTowardInf, __kSaturated )
    #define convert_ulong_sat_rtp(_X)   __builtin_convert(_X, ulong, __kRoundTowardInf, __kSaturated )
    #define convert_float_sat_rtp(_X)   __builtin_convert(_X, float, __kRoundTowardInf, __kSaturated )
    #define convert_double_sat_rtp(_X)  __builtin_convert(_X, double, __kRoundTowardInf, __kSaturated )

    #define convert_char_rtz(_X)    __builtin_convert(_X, char, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar_rtz(_X)   __builtin_convert(_X, uchar, __kRoundTowardZero, __kUnsaturated )
    #define convert_short_rtz(_X)   __builtin_convert(_X, short, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort_rtz(_X)  __builtin_convert(_X, ushort, __kRoundTowardZero, __kUnsaturated )
    #define convert_int_rtz(_X)     __builtin_convert(_X, int, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint_rtz(_X)    __builtin_convert(_X, uint, __kRoundTowardZero, __kUnsaturated )
    #define convert_long_rtz(_X)    __builtin_convert(_X, long, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong_rtz(_X)   __builtin_convert(_X, ulong, __kRoundTowardZero, __kUnsaturated )
    #define convert_float_rtz(_X)   __builtin_convert(_X, float, __kRoundTowardZero, __kUnsaturated )
    #define convert_double_rtz(_X)  __builtin_convert(_X, double, __kRoundTowardZero, __kUnsaturated )

    #define convert_char_sat_rtz(_X)    __builtin_convert(_X, char, __kRoundTowardZero, __kSaturated )
    #define convert_uchar_sat_rtz(_X)   __builtin_convert(_X, uchar, __kRoundTowardZero, __kSaturated )
    #define convert_short_sat_rtz(_X)   __builtin_convert(_X, short, __kRoundTowardZero, __kSaturated )
    #define convert_ushort_sat_rtz(_X)  __builtin_convert(_X, ushort, __kRoundTowardZero, __kSaturated )
    #define convert_int_sat_rtz(_X)     __builtin_convert(_X, int, __kRoundTowardZero, __kSaturated )
    #define convert_uint_sat_rtz(_X)    __builtin_convert(_X, uint, __kRoundTowardZero, __kSaturated )
    #define convert_long_sat_rtz(_X)    __builtin_convert(_X, long, __kRoundTowardZero, __kSaturated )
    #define convert_ulong_sat_rtz(_X)   __builtin_convert(_X, ulong, __kRoundTowardZero, __kSaturated )
    #define convert_float_sat_rtz(_X)   __builtin_convert(_X, float, __kRoundTowardZero, __kSaturated )
    #define convert_double_sat_rtz(_X)  __builtin_convert(_X, double, __kRoundTowardZero, __kSaturated )

    //type2
    #define convert_char2(_X)    __builtin_convert(_X, char2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar2(_X)   __builtin_convert(_X, uchar2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short2(_X)   __builtin_convert(_X, short2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort2(_X)  __builtin_convert(_X, ushort2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int2(_X)     __builtin_convert(_X, int2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint2(_X)    __builtin_convert(_X, uint2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long2(_X)    __builtin_convert(_X, long2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong2(_X)   __builtin_convert(_X, ulong2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float2(_X)   __builtin_convert(_X, float2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double2(_X)  __builtin_convert(_X, double2, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char2_sat(_X)    __builtin_convert(_X, char2, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar2_sat(_X)   __builtin_convert(_X, uchar2, __kDefaultRoundingMode, __kSaturated )
    #define convert_short2_sat(_X)   __builtin_convert(_X, short2, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort2_sat(_X)  __builtin_convert(_X, ushort2, __kDefaultRoundingMode, __kSaturated )
    #define convert_int2_sat(_X)     __builtin_convert(_X, int2, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint2_sat(_X)    __builtin_convert(_X, uint2, __kDefaultRoundingMode, __kSaturated )
    #define convert_long2_sat(_X)    __builtin_convert(_X, long2, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong2_sat(_X)   __builtin_convert(_X, ulong2, __kDefaultRoundingMode, __kSaturated )
    #define convert_float2_sat(_X)   __builtin_convert(_X, float2, __kDefaultRoundingMode, __kSaturated )
    #define convert_double2_sat(_X)  __builtin_convert(_X, double2, __kDefaultRoundingMode, __kSaturated )

    #define convert_char2_rte(_X)    __builtin_convert(_X, char2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar2_rte(_X)   __builtin_convert(_X, uchar2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short2_rte(_X)   __builtin_convert(_X, short2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort2_rte(_X)  __builtin_convert(_X, ushort2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int2_rte(_X)     __builtin_convert(_X, int2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint2_rte(_X)    __builtin_convert(_X, uint2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long2_rte(_X)    __builtin_convert(_X, long2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong2_rte(_X)   __builtin_convert(_X, ulong2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float2_rte(_X)   __builtin_convert(_X, float2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double2_rte(_X)  __builtin_convert(_X, double2, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char2_sat_rte(_X)    __builtin_convert(_X, char2, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar2_sat_rte(_X)   __builtin_convert(_X, uchar2, __kRoundToNearestEven, __kSaturated )
    #define convert_short2_sat_rte(_X)   __builtin_convert(_X, short2, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort2_sat_rte(_X)  __builtin_convert(_X, ushort2, __kRoundToNearestEven, __kSaturated )
    #define convert_int2_sat_rte(_X)     __builtin_convert(_X, int2, __kRoundToNearestEven, __kSaturated )
    #define convert_uint2_sat_rte(_X)    __builtin_convert(_X, uint2, __kRoundToNearestEven, __kSaturated )
    #define convert_long2_sat_rte(_X)    __builtin_convert(_X, long2, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong2_sat_rte(_X)   __builtin_convert(_X, ulong2, __kRoundToNearestEven, __kSaturated )
    #define convert_float2_sat_rte(_X)   __builtin_convert(_X, float2, __kRoundToNearestEven, __kSaturated )
    #define convert_double2_sat_rte(_X)  __builtin_convert(_X, double2, __kRoundToNearestEven, __kSaturated )

    #define convert_char2_rtn(_X)    __builtin_convert(_X, char2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar2_rtn(_X)   __builtin_convert(_X, uchar2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short2_rtn(_X)   __builtin_convert(_X, short2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort2_rtn(_X)  __builtin_convert(_X, ushort2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int2_rtn(_X)     __builtin_convert(_X, int2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint2_rtn(_X)    __builtin_convert(_X, uint2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long2_rtn(_X)    __builtin_convert(_X, long2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong2_rtn(_X)   __builtin_convert(_X, ulong2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float2_rtn(_X)   __builtin_convert(_X, float2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double2_rtn(_X)  __builtin_convert(_X, double2, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char2_sat_rtn(_X)    __builtin_convert(_X, char2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar2_sat_rtn(_X)   __builtin_convert(_X, uchar2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short2_sat_rtn(_X)   __builtin_convert(_X, short2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort2_sat_rtn(_X)  __builtin_convert(_X, ushort2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int2_sat_rtn(_X)     __builtin_convert(_X, int2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint2_sat_rtn(_X)    __builtin_convert(_X, uint2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long2_sat_rtn(_X)    __builtin_convert(_X, long2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong2_sat_rtn(_X)   __builtin_convert(_X, ulong2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float2_sat_rtn(_X)   __builtin_convert(_X, float2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double2_sat_rtn(_X)  __builtin_convert(_X, double2, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char2_rtp(_X)    __builtin_convert(_X, char2, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar2_rtp(_X)   __builtin_convert(_X, uchar2, __kRoundTowardInf, __kUnsaturated )
    #define convert_short2_rtp(_X)   __builtin_convert(_X, short2, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort2_rtp(_X)  __builtin_convert(_X, ushort2, __kRoundTowardInf, __kUnsaturated )
    #define convert_int2_rtp(_X)     __builtin_convert(_X, int2, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint2_rtp(_X)    __builtin_convert(_X, uint2, __kRoundTowardInf, __kUnsaturated )
    #define convert_long2_rtp(_X)    __builtin_convert(_X, long2, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong2_rtp(_X)   __builtin_convert(_X, ulong2, __kRoundTowardInf, __kUnsaturated )
    #define convert_float2_rtp(_X)   __builtin_convert(_X, float2, __kRoundTowardInf, __kUnsaturated )
    #define convert_double2_rtp(_X)  __builtin_convert(_X, double2, __kRoundTowardInf, __kUnsaturated )

    #define convert_char2_sat_rtp(_X)    __builtin_convert(_X, char2, __kRoundTowardInf, __kSaturated )
    #define convert_uchar2_sat_rtp(_X)   __builtin_convert(_X, uchar2, __kRoundTowardInf, __kSaturated )
    #define convert_short2_sat_rtp(_X)   __builtin_convert(_X, short2, __kRoundTowardInf, __kSaturated )
    #define convert_ushort2_sat_rtp(_X)  __builtin_convert(_X, ushort2, __kRoundTowardInf, __kSaturated )
    #define convert_int2_sat_rtp(_X)     __builtin_convert(_X, int2, __kRoundTowardInf, __kSaturated )
    #define convert_uint2_sat_rtp(_X)    __builtin_convert(_X, uint2, __kRoundTowardInf, __kSaturated )
    #define convert_long2_sat_rtp(_X)    __builtin_convert(_X, long2, __kRoundTowardInf, __kSaturated )
    #define convert_ulong2_sat_rtp(_X)   __builtin_convert(_X, ulong2, __kRoundTowardInf, __kSaturated )
    #define convert_float2_sat_rtp(_X)   __builtin_convert(_X, float2, __kRoundTowardInf, __kSaturated )
    #define convert_double2_sat_rtp(_X)  __builtin_convert(_X, double2, __kRoundTowardInf, __kSaturated )

    #define convert_char2_rtz(_X)    __builtin_convert(_X, char2, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar2_rtz(_X)   __builtin_convert(_X, uchar2, __kRoundTowardZero, __kUnsaturated )
    #define convert_short2_rtz(_X)   __builtin_convert(_X, short2, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort2_rtz(_X)  __builtin_convert(_X, ushort2, __kRoundTowardZero, __kUnsaturated )
    #define convert_int2_rtz(_X)     __builtin_convert(_X, int2, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint2_rtz(_X)    __builtin_convert(_X, uint2, __kRoundTowardZero, __kUnsaturated )
    #define convert_long2_rtz(_X)    __builtin_convert(_X, long2, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong2_rtz(_X)   __builtin_convert(_X, ulong2, __kRoundTowardZero, __kUnsaturated )
    #define convert_float2_rtz(_X)   __builtin_convert(_X, float2, __kRoundTowardZero, __kUnsaturated )
    #define convert_double2_rtz(_X)  __builtin_convert(_X, double2, __kRoundTowardZero, __kUnsaturated )

    #define convert_char2_sat_rtz(_X)    __builtin_convert(_X, char2, __kRoundTowardZero, __kSaturated )
    #define convert_uchar2_sat_rtz(_X)   __builtin_convert(_X, uchar2, __kRoundTowardZero, __kSaturated )
    #define convert_short2_sat_rtz(_X)   __builtin_convert(_X, short2, __kRoundTowardZero, __kSaturated )
    #define convert_ushort2_sat_rtz(_X)  __builtin_convert(_X, ushort2, __kRoundTowardZero, __kSaturated )
    #define convert_int2_sat_rtz(_X)     __builtin_convert(_X, int2, __kRoundTowardZero, __kSaturated )
    #define convert_uint2_sat_rtz(_X)    __builtin_convert(_X, uint2, __kRoundTowardZero, __kSaturated )
    #define convert_long2_sat_rtz(_X)    __builtin_convert(_X, long2, __kRoundTowardZero, __kSaturated )
    #define convert_ulong2_sat_rtz(_X)   __builtin_convert(_X, ulong2, __kRoundTowardZero, __kSaturated )
    #define convert_float2_sat_rtz(_X)   __builtin_convert(_X, float2, __kRoundTowardZero, __kSaturated )
    #define convert_double2_sat_rtz(_X)  __builtin_convert(_X, double2, __kRoundTowardZero, __kSaturated )

    //type3
    #define convert_char3(_X)    __builtin_convert(_X, char3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar3(_X)   __builtin_convert(_X, uchar3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short3(_X)   __builtin_convert(_X, short3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort3(_X)  __builtin_convert(_X, ushort3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int3(_X)     __builtin_convert(_X, int3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint3(_X)    __builtin_convert(_X, uint3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long3(_X)    __builtin_convert(_X, long3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong3(_X)   __builtin_convert(_X, ulong3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float3(_X)   __builtin_convert(_X, float3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double3(_X)  __builtin_convert(_X, double3, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char3_sat(_X)    __builtin_convert(_X, char3, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar3_sat(_X)   __builtin_convert(_X, uchar3, __kDefaultRoundingMode, __kSaturated )
    #define convert_short3_sat(_X)   __builtin_convert(_X, short3, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort3_sat(_X)  __builtin_convert(_X, ushort3, __kDefaultRoundingMode, __kSaturated )
    #define convert_int3_sat(_X)     __builtin_convert(_X, int3, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint3_sat(_X)    __builtin_convert(_X, uint3, __kDefaultRoundingMode, __kSaturated )
    #define convert_long3_sat(_X)    __builtin_convert(_X, long3, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong3_sat(_X)   __builtin_convert(_X, ulong3, __kDefaultRoundingMode, __kSaturated )
    #define convert_float3_sat(_X)   __builtin_convert(_X, float3, __kDefaultRoundingMode, __kSaturated )
    #define convert_double3_sat(_X)  __builtin_convert(_X, double3, __kDefaultRoundingMode, __kSaturated )

    #define convert_char3_rte(_X)    __builtin_convert(_X, char3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar3_rte(_X)   __builtin_convert(_X, uchar3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short3_rte(_X)   __builtin_convert(_X, short3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort3_rte(_X)  __builtin_convert(_X, ushort3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int3_rte(_X)     __builtin_convert(_X, int3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint3_rte(_X)    __builtin_convert(_X, uint3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long3_rte(_X)    __builtin_convert(_X, long3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong3_rte(_X)   __builtin_convert(_X, ulong3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float3_rte(_X)   __builtin_convert(_X, float3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double3_rte(_X)  __builtin_convert(_X, double3, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char3_sat_rte(_X)    __builtin_convert(_X, char3, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar3_sat_rte(_X)   __builtin_convert(_X, uchar3, __kRoundToNearestEven, __kSaturated )
    #define convert_short3_sat_rte(_X)   __builtin_convert(_X, short3, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort3_sat_rte(_X)  __builtin_convert(_X, ushort3, __kRoundToNearestEven, __kSaturated )
    #define convert_int3_sat_rte(_X)     __builtin_convert(_X, int3, __kRoundToNearestEven, __kSaturated )
    #define convert_uint3_sat_rte(_X)    __builtin_convert(_X, uint3, __kRoundToNearestEven, __kSaturated )
    #define convert_long3_sat_rte(_X)    __builtin_convert(_X, long3, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong3_sat_rte(_X)   __builtin_convert(_X, ulong3, __kRoundToNearestEven, __kSaturated )
    #define convert_float3_sat_rte(_X)   __builtin_convert(_X, float3, __kRoundToNearestEven, __kSaturated )
    #define convert_double3_sat_rte(_X)  __builtin_convert(_X, double3, __kRoundToNearestEven, __kSaturated )

    #define convert_char3_rtn(_X)    __builtin_convert(_X, char3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar3_rtn(_X)   __builtin_convert(_X, uchar3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short3_rtn(_X)   __builtin_convert(_X, short3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort3_rtn(_X)  __builtin_convert(_X, ushort3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int3_rtn(_X)     __builtin_convert(_X, int3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint3_rtn(_X)    __builtin_convert(_X, uint3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long3_rtn(_X)    __builtin_convert(_X, long3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong3_rtn(_X)   __builtin_convert(_X, ulong3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float3_rtn(_X)   __builtin_convert(_X, float3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double3_rtn(_X)  __builtin_convert(_X, double3, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char3_sat_rtn(_X)    __builtin_convert(_X, char3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar3_sat_rtn(_X)   __builtin_convert(_X, uchar3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short3_sat_rtn(_X)   __builtin_convert(_X, short3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort3_sat_rtn(_X)  __builtin_convert(_X, ushort3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int3_sat_rtn(_X)     __builtin_convert(_X, int3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint3_sat_rtn(_X)    __builtin_convert(_X, uint3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long3_sat_rtn(_X)    __builtin_convert(_X, long3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong3_sat_rtn(_X)   __builtin_convert(_X, ulong3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float3_sat_rtn(_X)   __builtin_convert(_X, float3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double3_sat_rtn(_X)  __builtin_convert(_X, double3, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char3_rtp(_X)    __builtin_convert(_X, char3, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar3_rtp(_X)   __builtin_convert(_X, uchar3, __kRoundTowardInf, __kUnsaturated )
    #define convert_short3_rtp(_X)   __builtin_convert(_X, short3, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort3_rtp(_X)  __builtin_convert(_X, ushort3, __kRoundTowardInf, __kUnsaturated )
    #define convert_int3_rtp(_X)     __builtin_convert(_X, int3, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint3_rtp(_X)    __builtin_convert(_X, uint3, __kRoundTowardInf, __kUnsaturated )
    #define convert_long3_rtp(_X)    __builtin_convert(_X, long3, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong3_rtp(_X)   __builtin_convert(_X, ulong3, __kRoundTowardInf, __kUnsaturated )
    #define convert_float3_rtp(_X)   __builtin_convert(_X, float3, __kRoundTowardInf, __kUnsaturated )
    #define convert_double3_rtp(_X)  __builtin_convert(_X, double3, __kRoundTowardInf, __kUnsaturated )

    #define convert_char3_sat_rtp(_X)    __builtin_convert(_X, char3, __kRoundTowardInf, __kSaturated )
    #define convert_uchar3_sat_rtp(_X)   __builtin_convert(_X, uchar3, __kRoundTowardInf, __kSaturated )
    #define convert_short3_sat_rtp(_X)   __builtin_convert(_X, short3, __kRoundTowardInf, __kSaturated )
    #define convert_ushort3_sat_rtp(_X)  __builtin_convert(_X, ushort3, __kRoundTowardInf, __kSaturated )
    #define convert_int3_sat_rtp(_X)     __builtin_convert(_X, int3, __kRoundTowardInf, __kSaturated )
    #define convert_uint3_sat_rtp(_X)    __builtin_convert(_X, uint3, __kRoundTowardInf, __kSaturated )
    #define convert_long3_sat_rtp(_X)    __builtin_convert(_X, long3, __kRoundTowardInf, __kSaturated )
    #define convert_ulong3_sat_rtp(_X)   __builtin_convert(_X, ulong3, __kRoundTowardInf, __kSaturated )
    #define convert_float3_sat_rtp(_X)   __builtin_convert(_X, float3, __kRoundTowardInf, __kSaturated )
    #define convert_double3_sat_rtp(_X)  __builtin_convert(_X, double3, __kRoundTowardInf, __kSaturated )

    #define convert_char3_rtz(_X)    __builtin_convert(_X, char3, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar3_rtz(_X)   __builtin_convert(_X, uchar3, __kRoundTowardZero, __kUnsaturated )
    #define convert_short3_rtz(_X)   __builtin_convert(_X, short3, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort3_rtz(_X)  __builtin_convert(_X, ushort3, __kRoundTowardZero, __kUnsaturated )
    #define convert_int3_rtz(_X)     __builtin_convert(_X, int3, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint3_rtz(_X)    __builtin_convert(_X, uint3, __kRoundTowardZero, __kUnsaturated )
    #define convert_long3_rtz(_X)    __builtin_convert(_X, long3, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong3_rtz(_X)   __builtin_convert(_X, ulong3, __kRoundTowardZero, __kUnsaturated )
    #define convert_float3_rtz(_X)   __builtin_convert(_X, float3, __kRoundTowardZero, __kUnsaturated )
    #define convert_double3_rtz(_X)  __builtin_convert(_X, double3, __kRoundTowardZero, __kUnsaturated )

    #define convert_char3_sat_rtz(_X)    __builtin_convert(_X, char3, __kRoundTowardZero, __kSaturated )
    #define convert_uchar3_sat_rtz(_X)   __builtin_convert(_X, uchar3, __kRoundTowardZero, __kSaturated )
    #define convert_short3_sat_rtz(_X)   __builtin_convert(_X, short3, __kRoundTowardZero, __kSaturated )
    #define convert_ushort3_sat_rtz(_X)  __builtin_convert(_X, ushort3, __kRoundTowardZero, __kSaturated )
    #define convert_int3_sat_rtz(_X)     __builtin_convert(_X, int3, __kRoundTowardZero, __kSaturated )
    #define convert_uint3_sat_rtz(_X)    __builtin_convert(_X, uint3, __kRoundTowardZero, __kSaturated )
    #define convert_long3_sat_rtz(_X)    __builtin_convert(_X, long3, __kRoundTowardZero, __kSaturated )
    #define convert_ulong3_sat_rtz(_X)   __builtin_convert(_X, ulong3, __kRoundTowardZero, __kSaturated )
    #define convert_float3_sat_rtz(_X)   __builtin_convert(_X, float3, __kRoundTowardZero, __kSaturated )
    #define convert_double3_sat_rtz(_X)  __builtin_convert(_X, double3, __kRoundTowardZero, __kSaturated )

    //type4
    #define convert_char4(_X)    __builtin_convert(_X, char4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar4(_X)   __builtin_convert(_X, uchar4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short4(_X)   __builtin_convert(_X, short4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort4(_X)  __builtin_convert(_X, ushort4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int4(_X)     __builtin_convert(_X, int4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint4(_X)    __builtin_convert(_X, uint4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long4(_X)    __builtin_convert(_X, long4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong4(_X)   __builtin_convert(_X, ulong4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float4(_X)   __builtin_convert(_X, float4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double4(_X)  __builtin_convert(_X, double4, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char4_sat(_X)    __builtin_convert(_X, char4, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar4_sat(_X)   __builtin_convert(_X, uchar4, __kDefaultRoundingMode, __kSaturated )
    #define convert_short4_sat(_X)   __builtin_convert(_X, short4, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort4_sat(_X)  __builtin_convert(_X, ushort4, __kDefaultRoundingMode, __kSaturated )
    #define convert_int4_sat(_X)     __builtin_convert(_X, int4, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint4_sat(_X)    __builtin_convert(_X, uint4, __kDefaultRoundingMode, __kSaturated )
    #define convert_long4_sat(_X)    __builtin_convert(_X, long4, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong4_sat(_X)   __builtin_convert(_X, ulong4, __kDefaultRoundingMode, __kSaturated )
    #define convert_float4_sat(_X)   __builtin_convert(_X, float4, __kDefaultRoundingMode, __kSaturated )
    #define convert_double4_sat(_X)  __builtin_convert(_X, double4, __kDefaultRoundingMode, __kSaturated )

    #define convert_char4_rte(_X)    __builtin_convert(_X, char4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar4_rte(_X)   __builtin_convert(_X, uchar4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short4_rte(_X)   __builtin_convert(_X, short4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort4_rte(_X)  __builtin_convert(_X, ushort4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int4_rte(_X)     __builtin_convert(_X, int4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint4_rte(_X)    __builtin_convert(_X, uint4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long4_rte(_X)    __builtin_convert(_X, long4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong4_rte(_X)   __builtin_convert(_X, ulong4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float4_rte(_X)   __builtin_convert(_X, float4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double4_rte(_X)  __builtin_convert(_X, double4, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char4_sat_rte(_X)    __builtin_convert(_X, char4, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar4_sat_rte(_X)   __builtin_convert(_X, uchar4, __kRoundToNearestEven, __kSaturated )
    #define convert_short4_sat_rte(_X)   __builtin_convert(_X, short4, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort4_sat_rte(_X)  __builtin_convert(_X, ushort4, __kRoundToNearestEven, __kSaturated )
    #define convert_int4_sat_rte(_X)     __builtin_convert(_X, int4, __kRoundToNearestEven, __kSaturated )
    #define convert_uint4_sat_rte(_X)    __builtin_convert(_X, uint4, __kRoundToNearestEven, __kSaturated )
    #define convert_long4_sat_rte(_X)    __builtin_convert(_X, long4, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong4_sat_rte(_X)   __builtin_convert(_X, ulong4, __kRoundToNearestEven, __kSaturated )
    #define convert_float4_sat_rte(_X)   __builtin_convert(_X, float4, __kRoundToNearestEven, __kSaturated )
    #define convert_double4_sat_rte(_X)  __builtin_convert(_X, double4, __kRoundToNearestEven, __kSaturated )

    #define convert_char4_rtn(_X)    __builtin_convert(_X, char4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar4_rtn(_X)   __builtin_convert(_X, uchar4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short4_rtn(_X)   __builtin_convert(_X, short4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort4_rtn(_X)  __builtin_convert(_X, ushort4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int4_rtn(_X)     __builtin_convert(_X, int4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint4_rtn(_X)    __builtin_convert(_X, uint4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long4_rtn(_X)    __builtin_convert(_X, long4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong4_rtn(_X)   __builtin_convert(_X, ulong4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float4_rtn(_X)   __builtin_convert(_X, float4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double4_rtn(_X)  __builtin_convert(_X, double4, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char4_sat_rtn(_X)    __builtin_convert(_X, char4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar4_sat_rtn(_X)   __builtin_convert(_X, uchar4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short4_sat_rtn(_X)   __builtin_convert(_X, short4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort4_sat_rtn(_X)  __builtin_convert(_X, ushort4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int4_sat_rtn(_X)     __builtin_convert(_X, int4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint4_sat_rtn(_X)    __builtin_convert(_X, uint4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long4_sat_rtn(_X)    __builtin_convert(_X, long4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong4_sat_rtn(_X)   __builtin_convert(_X, ulong4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float4_sat_rtn(_X)   __builtin_convert(_X, float4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double4_sat_rtn(_X)  __builtin_convert(_X, double4, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char4_rtp(_X)    __builtin_convert(_X, char4, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar4_rtp(_X)   __builtin_convert(_X, uchar4, __kRoundTowardInf, __kUnsaturated )
    #define convert_short4_rtp(_X)   __builtin_convert(_X, short4, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort4_rtp(_X)  __builtin_convert(_X, ushort4, __kRoundTowardInf, __kUnsaturated )
    #define convert_int4_rtp(_X)     __builtin_convert(_X, int4, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint4_rtp(_X)    __builtin_convert(_X, uint4, __kRoundTowardInf, __kUnsaturated )
    #define convert_long4_rtp(_X)    __builtin_convert(_X, long4, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong4_rtp(_X)   __builtin_convert(_X, ulong4, __kRoundTowardInf, __kUnsaturated )
    #define convert_float4_rtp(_X)   __builtin_convert(_X, float4, __kRoundTowardInf, __kUnsaturated )
    #define convert_double4_rtp(_X)  __builtin_convert(_X, double4, __kRoundTowardInf, __kUnsaturated )

    #define convert_char4_sat_rtp(_X)    __builtin_convert(_X, char4, __kRoundTowardInf, __kSaturated )
    #define convert_uchar4_sat_rtp(_X)   __builtin_convert(_X, uchar4, __kRoundTowardInf, __kSaturated )
    #define convert_short4_sat_rtp(_X)   __builtin_convert(_X, short4, __kRoundTowardInf, __kSaturated )
    #define convert_ushort4_sat_rtp(_X)  __builtin_convert(_X, ushort4, __kRoundTowardInf, __kSaturated )
    #define convert_int4_sat_rtp(_X)     __builtin_convert(_X, int4, __kRoundTowardInf, __kSaturated )
    #define convert_uint4_sat_rtp(_X)    __builtin_convert(_X, uint4, __kRoundTowardInf, __kSaturated )
    #define convert_long4_sat_rtp(_X)    __builtin_convert(_X, long4, __kRoundTowardInf, __kSaturated )
    #define convert_ulong4_sat_rtp(_X)   __builtin_convert(_X, ulong4, __kRoundTowardInf, __kSaturated )
    #define convert_float4_sat_rtp(_X)   __builtin_convert(_X, float4, __kRoundTowardInf, __kSaturated )
    #define convert_double4_sat_rtp(_X)  __builtin_convert(_X, double4, __kRoundTowardInf, __kSaturated )

    #define convert_char4_rtz(_X)    __builtin_convert(_X, char4, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar4_rtz(_X)   __builtin_convert(_X, uchar4, __kRoundTowardZero, __kUnsaturated )
    #define convert_short4_rtz(_X)   __builtin_convert(_X, short4, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort4_rtz(_X)  __builtin_convert(_X, ushort4, __kRoundTowardZero, __kUnsaturated )
    #define convert_int4_rtz(_X)     __builtin_convert(_X, int4, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint4_rtz(_X)    __builtin_convert(_X, uint4, __kRoundTowardZero, __kUnsaturated )
    #define convert_long4_rtz(_X)    __builtin_convert(_X, long4, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong4_rtz(_X)   __builtin_convert(_X, ulong4, __kRoundTowardZero, __kUnsaturated )
    #define convert_float4_rtz(_X)   __builtin_convert(_X, float4, __kRoundTowardZero, __kUnsaturated )
    #define convert_double4_rtz(_X)  __builtin_convert(_X, double4, __kRoundTowardZero, __kUnsaturated )

    #define convert_char4_sat_rtz(_X)    __builtin_convert(_X, char4, __kRoundTowardZero, __kSaturated )
    #define convert_uchar4_sat_rtz(_X)   __builtin_convert(_X, uchar4, __kRoundTowardZero, __kSaturated )
    #define convert_short4_sat_rtz(_X)   __builtin_convert(_X, short4, __kRoundTowardZero, __kSaturated )
    #define convert_ushort4_sat_rtz(_X)  __builtin_convert(_X, ushort4, __kRoundTowardZero, __kSaturated )
    #define convert_int4_sat_rtz(_X)     __builtin_convert(_X, int4, __kRoundTowardZero, __kSaturated )
    #define convert_uint4_sat_rtz(_X)    __builtin_convert(_X, uint4, __kRoundTowardZero, __kSaturated )
    #define convert_long4_sat_rtz(_X)    __builtin_convert(_X, long4, __kRoundTowardZero, __kSaturated )
    #define convert_ulong4_sat_rtz(_X)   __builtin_convert(_X, ulong4, __kRoundTowardZero, __kSaturated )
    #define convert_float4_sat_rtz(_X)   __builtin_convert(_X, float4, __kRoundTowardZero, __kSaturated )
    #define convert_double4_sat_rtz(_X)  __builtin_convert(_X, double4, __kRoundTowardZero, __kSaturated )

    //type8
    #define convert_char8(_X)    __builtin_convert(_X, char8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar8(_X)   __builtin_convert(_X, uchar8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short8(_X)   __builtin_convert(_X, short8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort8(_X)  __builtin_convert(_X, ushort8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int8(_X)     __builtin_convert(_X, int8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint8(_X)    __builtin_convert(_X, uint8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long8(_X)    __builtin_convert(_X, long8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong8(_X)   __builtin_convert(_X, ulong8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float8(_X)   __builtin_convert(_X, float8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double8(_X)  __builtin_convert(_X, double8, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char8_sat(_X)    __builtin_convert(_X, char8, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar8_sat(_X)   __builtin_convert(_X, uchar8, __kDefaultRoundingMode, __kSaturated )
    #define convert_short8_sat(_X)   __builtin_convert(_X, short8, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort8_sat(_X)  __builtin_convert(_X, ushort8, __kDefaultRoundingMode, __kSaturated )
    #define convert_int8_sat(_X)     __builtin_convert(_X, int8, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint8_sat(_X)    __builtin_convert(_X, uint8, __kDefaultRoundingMode, __kSaturated )
    #define convert_long8_sat(_X)    __builtin_convert(_X, long8, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong8_sat(_X)   __builtin_convert(_X, ulong8, __kDefaultRoundingMode, __kSaturated )
    #define convert_float8_sat(_X)   __builtin_convert(_X, float8, __kDefaultRoundingMode, __kSaturated )
    #define convert_double8_sat(_X)  __builtin_convert(_X, double8, __kDefaultRoundingMode, __kSaturated )

    #define convert_char8_rte(_X)    __builtin_convert(_X, char8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar8_rte(_X)   __builtin_convert(_X, uchar8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short8_rte(_X)   __builtin_convert(_X, short8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort8_rte(_X)  __builtin_convert(_X, ushort8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int8_rte(_X)     __builtin_convert(_X, int8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint8_rte(_X)    __builtin_convert(_X, uint8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long8_rte(_X)    __builtin_convert(_X, long8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong8_rte(_X)   __builtin_convert(_X, ulong8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float8_rte(_X)   __builtin_convert(_X, float8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double8_rte(_X)  __builtin_convert(_X, double8, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char8_sat_rte(_X)    __builtin_convert(_X, char8, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar8_sat_rte(_X)   __builtin_convert(_X, uchar8, __kRoundToNearestEven, __kSaturated )
    #define convert_short8_sat_rte(_X)   __builtin_convert(_X, short8, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort8_sat_rte(_X)  __builtin_convert(_X, ushort8, __kRoundToNearestEven, __kSaturated )
    #define convert_int8_sat_rte(_X)     __builtin_convert(_X, int8, __kRoundToNearestEven, __kSaturated )
    #define convert_uint8_sat_rte(_X)    __builtin_convert(_X, uint8, __kRoundToNearestEven, __kSaturated )
    #define convert_long8_sat_rte(_X)    __builtin_convert(_X, long8, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong8_sat_rte(_X)   __builtin_convert(_X, ulong8, __kRoundToNearestEven, __kSaturated )
    #define convert_float8_sat_rte(_X)   __builtin_convert(_X, float8, __kRoundToNearestEven, __kSaturated )
    #define convert_double8_sat_rte(_X)  __builtin_convert(_X, double8, __kRoundToNearestEven, __kSaturated )

    #define convert_char8_rtn(_X)    __builtin_convert(_X, char8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar8_rtn(_X)   __builtin_convert(_X, uchar8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short8_rtn(_X)   __builtin_convert(_X, short8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort8_rtn(_X)  __builtin_convert(_X, ushort8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int8_rtn(_X)     __builtin_convert(_X, int8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint8_rtn(_X)    __builtin_convert(_X, uint8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long8_rtn(_X)    __builtin_convert(_X, long8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong8_rtn(_X)   __builtin_convert(_X, ulong8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float8_rtn(_X)   __builtin_convert(_X, float8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double8_rtn(_X)  __builtin_convert(_X, double8, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char8_sat_rtn(_X)    __builtin_convert(_X, char8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar8_sat_rtn(_X)   __builtin_convert(_X, uchar8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short8_sat_rtn(_X)   __builtin_convert(_X, short8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort8_sat_rtn(_X)  __builtin_convert(_X, ushort8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int8_sat_rtn(_X)     __builtin_convert(_X, int8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint8_sat_rtn(_X)    __builtin_convert(_X, uint8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long8_sat_rtn(_X)    __builtin_convert(_X, long8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong8_sat_rtn(_X)   __builtin_convert(_X, ulong8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float8_sat_rtn(_X)   __builtin_convert(_X, float8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double8_sat_rtn(_X)  __builtin_convert(_X, double8, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char8_rtp(_X)    __builtin_convert(_X, char8, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar8_rtp(_X)   __builtin_convert(_X, uchar8, __kRoundTowardInf, __kUnsaturated )
    #define convert_short8_rtp(_X)   __builtin_convert(_X, short8, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort8_rtp(_X)  __builtin_convert(_X, ushort8, __kRoundTowardInf, __kUnsaturated )
    #define convert_int8_rtp(_X)     __builtin_convert(_X, int8, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint8_rtp(_X)    __builtin_convert(_X, uint8, __kRoundTowardInf, __kUnsaturated )
    #define convert_long8_rtp(_X)    __builtin_convert(_X, long8, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong8_rtp(_X)   __builtin_convert(_X, ulong8, __kRoundTowardInf, __kUnsaturated )
    #define convert_float8_rtp(_X)   __builtin_convert(_X, float8, __kRoundTowardInf, __kUnsaturated )
    #define convert_double8_rtp(_X)  __builtin_convert(_X, double8, __kRoundTowardInf, __kUnsaturated )

    #define convert_char8_sat_rtp(_X)    __builtin_convert(_X, char8, __kRoundTowardInf, __kSaturated )
    #define convert_uchar8_sat_rtp(_X)   __builtin_convert(_X, uchar8, __kRoundTowardInf, __kSaturated )
    #define convert_short8_sat_rtp(_X)   __builtin_convert(_X, short8, __kRoundTowardInf, __kSaturated )
    #define convert_ushort8_sat_rtp(_X)  __builtin_convert(_X, ushort8, __kRoundTowardInf, __kSaturated )
    #define convert_int8_sat_rtp(_X)     __builtin_convert(_X, int8, __kRoundTowardInf, __kSaturated )
    #define convert_uint8_sat_rtp(_X)    __builtin_convert(_X, uint8, __kRoundTowardInf, __kSaturated )
    #define convert_long8_sat_rtp(_X)    __builtin_convert(_X, long8, __kRoundTowardInf, __kSaturated )
    #define convert_ulong8_sat_rtp(_X)   __builtin_convert(_X, ulong8, __kRoundTowardInf, __kSaturated )
    #define convert_float8_sat_rtp(_X)   __builtin_convert(_X, float8, __kRoundTowardInf, __kSaturated )
    #define convert_double8_sat_rtp(_X)  __builtin_convert(_X, double8, __kRoundTowardInf, __kSaturated )

    #define convert_char8_rtz(_X)    __builtin_convert(_X, char8, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar8_rtz(_X)   __builtin_convert(_X, uchar8, __kRoundTowardZero, __kUnsaturated )
    #define convert_short8_rtz(_X)   __builtin_convert(_X, short8, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort8_rtz(_X)  __builtin_convert(_X, ushort8, __kRoundTowardZero, __kUnsaturated )
    #define convert_int8_rtz(_X)     __builtin_convert(_X, int8, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint8_rtz(_X)    __builtin_convert(_X, uint8, __kRoundTowardZero, __kUnsaturated )
    #define convert_long8_rtz(_X)    __builtin_convert(_X, long8, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong8_rtz(_X)   __builtin_convert(_X, ulong8, __kRoundTowardZero, __kUnsaturated )
    #define convert_float8_rtz(_X)   __builtin_convert(_X, float8, __kRoundTowardZero, __kUnsaturated )
    #define convert_double8_rtz(_X)  __builtin_convert(_X, double8, __kRoundTowardZero, __kUnsaturated )

    #define convert_char8_sat_rtz(_X)    __builtin_convert(_X, char8, __kRoundTowardZero, __kSaturated )
    #define convert_uchar8_sat_rtz(_X)   __builtin_convert(_X, uchar8, __kRoundTowardZero, __kSaturated )
    #define convert_short8_sat_rtz(_X)   __builtin_convert(_X, short8, __kRoundTowardZero, __kSaturated )
    #define convert_ushort8_sat_rtz(_X)  __builtin_convert(_X, ushort8, __kRoundTowardZero, __kSaturated )
    #define convert_int8_sat_rtz(_X)     __builtin_convert(_X, int8, __kRoundTowardZero, __kSaturated )
    #define convert_uint8_sat_rtz(_X)    __builtin_convert(_X, uint8, __kRoundTowardZero, __kSaturated )
    #define convert_long8_sat_rtz(_X)    __builtin_convert(_X, long8, __kRoundTowardZero, __kSaturated )
    #define convert_ulong8_sat_rtz(_X)   __builtin_convert(_X, ulong8, __kRoundTowardZero, __kSaturated )
    #define convert_float8_sat_rtz(_X)   __builtin_convert(_X, float8, __kRoundTowardZero, __kSaturated )
    #define convert_double8_sat_rtz(_X)  __builtin_convert(_X, double8, __kRoundTowardZero, __kSaturated )

    //type16
    #define convert_char16(_X)    __builtin_convert(_X, char16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar16(_X)   __builtin_convert(_X, uchar16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short16(_X)   __builtin_convert(_X, short16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort16(_X)  __builtin_convert(_X, ushort16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int16(_X)     __builtin_convert(_X, int16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint16(_X)    __builtin_convert(_X, uint16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long16(_X)    __builtin_convert(_X, long16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong16(_X)   __builtin_convert(_X, ulong16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float16(_X)   __builtin_convert(_X, float16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double16(_X)  __builtin_convert(_X, double16, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char16_sat(_X)    __builtin_convert(_X, char16, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar16_sat(_X)   __builtin_convert(_X, uchar16, __kDefaultRoundingMode, __kSaturated )
    #define convert_short16_sat(_X)   __builtin_convert(_X, short16, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort16_sat(_X)  __builtin_convert(_X, ushort16, __kDefaultRoundingMode, __kSaturated )
    #define convert_int16_sat(_X)     __builtin_convert(_X, int16, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint16_sat(_X)    __builtin_convert(_X, uint16, __kDefaultRoundingMode, __kSaturated )
    #define convert_long16_sat(_X)    __builtin_convert(_X, long16, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong16_sat(_X)   __builtin_convert(_X, ulong16, __kDefaultRoundingMode, __kSaturated )
    #define convert_float16_sat(_X)   __builtin_convert(_X, float16, __kDefaultRoundingMode, __kSaturated )
    #define convert_double16_sat(_X)  __builtin_convert(_X, double16, __kDefaultRoundingMode, __kSaturated )

    #define convert_char16_rte(_X)    __builtin_convert(_X, char16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar16_rte(_X)   __builtin_convert(_X, uchar16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short16_rte(_X)   __builtin_convert(_X, short16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort16_rte(_X)  __builtin_convert(_X, ushort16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int16_rte(_X)     __builtin_convert(_X, int16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint16_rte(_X)    __builtin_convert(_X, uint16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long16_rte(_X)    __builtin_convert(_X, long16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong16_rte(_X)   __builtin_convert(_X, ulong16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float16_rte(_X)   __builtin_convert(_X, float16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double16_rte(_X)  __builtin_convert(_X, double16, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char16_sat_rte(_X)    __builtin_convert(_X, char16, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar16_sat_rte(_X)   __builtin_convert(_X, uchar16, __kRoundToNearestEven, __kSaturated )
    #define convert_short16_sat_rte(_X)   __builtin_convert(_X, short16, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort16_sat_rte(_X)  __builtin_convert(_X, ushort16, __kRoundToNearestEven, __kSaturated )
    #define convert_int16_sat_rte(_X)     __builtin_convert(_X, int16, __kRoundToNearestEven, __kSaturated )
    #define convert_uint16_sat_rte(_X)    __builtin_convert(_X, uint16, __kRoundToNearestEven, __kSaturated )
    #define convert_long16_sat_rte(_X)    __builtin_convert(_X, long16, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong16_sat_rte(_X)   __builtin_convert(_X, ulong16, __kRoundToNearestEven, __kSaturated )
    #define convert_float16_sat_rte(_X)   __builtin_convert(_X, float16, __kRoundToNearestEven, __kSaturated )
    #define convert_double16_sat_rte(_X)  __builtin_convert(_X, double16, __kRoundToNearestEven, __kSaturated )

    #define convert_char16_rtn(_X)    __builtin_convert(_X, char16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar16_rtn(_X)   __builtin_convert(_X, uchar16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short16_rtn(_X)   __builtin_convert(_X, short16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort16_rtn(_X)  __builtin_convert(_X, ushort16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int16_rtn(_X)     __builtin_convert(_X, int16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint16_rtn(_X)    __builtin_convert(_X, uint16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long16_rtn(_X)    __builtin_convert(_X, long16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong16_rtn(_X)   __builtin_convert(_X, ulong16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float16_rtn(_X)   __builtin_convert(_X, float16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double16_rtn(_X)  __builtin_convert(_X, double16, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char16_sat_rtn(_X)    __builtin_convert(_X, char16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar16_sat_rtn(_X)   __builtin_convert(_X, uchar16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short16_sat_rtn(_X)   __builtin_convert(_X, short16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort16_sat_rtn(_X)  __builtin_convert(_X, ushort16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int16_sat_rtn(_X)     __builtin_convert(_X, int16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint16_sat_rtn(_X)    __builtin_convert(_X, uint16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long16_sat_rtn(_X)    __builtin_convert(_X, long16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong16_sat_rtn(_X)   __builtin_convert(_X, ulong16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float16_sat_rtn(_X)   __builtin_convert(_X, float16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double16_sat_rtn(_X)  __builtin_convert(_X, double16, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char16_rtp(_X)    __builtin_convert(_X, char16, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar16_rtp(_X)   __builtin_convert(_X, uchar16, __kRoundTowardInf, __kUnsaturated )
    #define convert_short16_rtp(_X)   __builtin_convert(_X, short16, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort16_rtp(_X)  __builtin_convert(_X, ushort16, __kRoundTowardInf, __kUnsaturated )
    #define convert_int16_rtp(_X)     __builtin_convert(_X, int16, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint16_rtp(_X)    __builtin_convert(_X, uint16, __kRoundTowardInf, __kUnsaturated )
    #define convert_long16_rtp(_X)    __builtin_convert(_X, long16, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong16_rtp(_X)   __builtin_convert(_X, ulong16, __kRoundTowardInf, __kUnsaturated )
    #define convert_float16_rtp(_X)   __builtin_convert(_X, float16, __kRoundTowardInf, __kUnsaturated )
    #define convert_double16_rtp(_X)  __builtin_convert(_X, double16, __kRoundTowardInf, __kUnsaturated )

    #define convert_char16_sat_rtp(_X)    __builtin_convert(_X, char16, __kRoundTowardInf, __kSaturated )
    #define convert_uchar16_sat_rtp(_X)   __builtin_convert(_X, uchar16, __kRoundTowardInf, __kSaturated )
    #define convert_short16_sat_rtp(_X)   __builtin_convert(_X, short16, __kRoundTowardInf, __kSaturated )
    #define convert_ushort16_sat_rtp(_X)  __builtin_convert(_X, ushort16, __kRoundTowardInf, __kSaturated )
    #define convert_int16_sat_rtp(_X)     __builtin_convert(_X, int16, __kRoundTowardInf, __kSaturated )
    #define convert_uint16_sat_rtp(_X)    __builtin_convert(_X, uint16, __kRoundTowardInf, __kSaturated )
    #define convert_long16_sat_rtp(_X)    __builtin_convert(_X, long16, __kRoundTowardInf, __kSaturated )
    #define convert_ulong16_sat_rtp(_X)   __builtin_convert(_X, ulong16, __kRoundTowardInf, __kSaturated )
    #define convert_float16_sat_rtp(_X)   __builtin_convert(_X, float16, __kRoundTowardInf, __kSaturated )
    #define convert_double16_sat_rtp(_X)  __builtin_convert(_X, double16, __kRoundTowardInf, __kSaturated )

    #define convert_char16_rtz(_X)    __builtin_convert(_X, char16, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar16_rtz(_X)   __builtin_convert(_X, uchar16, __kRoundTowardZero, __kUnsaturated )
    #define convert_short16_rtz(_X)   __builtin_convert(_X, short16, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort16_rtz(_X)  __builtin_convert(_X, ushort16, __kRoundTowardZero, __kUnsaturated )
    #define convert_int16_rtz(_X)     __builtin_convert(_X, int16, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint16_rtz(_X)    __builtin_convert(_X, uint16, __kRoundTowardZero, __kUnsaturated )
    #define convert_long16_rtz(_X)    __builtin_convert(_X, long16, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong16_rtz(_X)   __builtin_convert(_X, ulong16, __kRoundTowardZero, __kUnsaturated )
    #define convert_float16_rtz(_X)   __builtin_convert(_X, float16, __kRoundTowardZero, __kUnsaturated )
    #define convert_double16_rtz(_X)  __builtin_convert(_X, double16, __kRoundTowardZero, __kUnsaturated )

    #define convert_char16_sat_rtz(_X)    __builtin_convert(_X, char16, __kRoundTowardZero, __kSaturated )
    #define convert_uchar16_sat_rtz(_X)   __builtin_convert(_X, uchar16, __kRoundTowardZero, __kSaturated )
    #define convert_short16_sat_rtz(_X)   __builtin_convert(_X, short16, __kRoundTowardZero, __kSaturated )
    #define convert_ushort16_sat_rtz(_X)  __builtin_convert(_X, ushort16, __kRoundTowardZero, __kSaturated )
    #define convert_int16_sat_rtz(_X)     __builtin_convert(_X, int16, __kRoundTowardZero, __kSaturated )
    #define convert_uint16_sat_rtz(_X)    __builtin_convert(_X, uint16, __kRoundTowardZero, __kSaturated )
    #define convert_long16_sat_rtz(_X)    __builtin_convert(_X, long16, __kRoundTowardZero, __kSaturated )
    #define convert_ulong16_sat_rtz(_X)   __builtin_convert(_X, ulong16, __kRoundTowardZero, __kSaturated )
    #define convert_float16_sat_rtz(_X)   __builtin_convert(_X, float16, __kRoundTowardZero, __kSaturated )
    #define convert_double16_sat_rtz(_X)  __builtin_convert(_X, double16, __kRoundTowardZero, __kSaturated )


#else

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_CONVERT(name, rtype) rtype __OVERLOAD__ name( uchar a); \
rtype __OVERLOAD__ name( ushort a); \
rtype __OVERLOAD__ name( uint a); \
rtype __OVERLOAD__ name( ulong a); \
rtype __OVERLOAD__ name( char a); \
rtype __OVERLOAD__ name( short a); \
rtype __OVERLOAD__ name( int a); \
rtype __OVERLOAD__ name( long a); \
rtype __OVERLOAD__ name( float a); \
rtype __OVERLOAD__ name( double a); \
rtype##2 __OVERLOAD__ name##2( uchar2 a); \
rtype##2 __OVERLOAD__ name##2( ushort2 a); \
rtype##2 __OVERLOAD__ name##2( uint2 a); \
rtype##2 __OVERLOAD__ name##2( ulong2 a); \
rtype##2 __OVERLOAD__ name##2( char2 a); \
rtype##2 __OVERLOAD__ name##2( short2 a); \
rtype##2 __OVERLOAD__ name##2( int2 a); \
rtype##2 __OVERLOAD__ name##2( long2 a); \
rtype##2 __OVERLOAD__ name##2( float2 a); \
rtype##2 __OVERLOAD__ name##2( double2 a); \
rtype##3 __OVERLOAD__ name##3( uchar3 a); \
rtype##3 __OVERLOAD__ name##3( ushort3 a); \
rtype##3 __OVERLOAD__ name##3( uint3 a); \
rtype##3 __OVERLOAD__ name##3( ulong3 a); \
rtype##3 __OVERLOAD__ name##3( char3 a); \
rtype##3 __OVERLOAD__ name##3( short3 a); \
rtype##3 __OVERLOAD__ name##3( int3 a); \
rtype##3 __OVERLOAD__ name##3( long3 a); \
rtype##3 __OVERLOAD__ name##3( float3 a); \
rtype##3 __OVERLOAD__ name##3( double3 a); \
rtype##4 __OVERLOAD__ name##4( uchar4 a); \
rtype##4 __OVERLOAD__ name##4( ushort4 a); \
rtype##4 __OVERLOAD__ name##4( uint4 a); \
rtype##4 __OVERLOAD__ name##4( ulong4 a); \
rtype##4 __OVERLOAD__ name##4( char4 a); \
rtype##4 __OVERLOAD__ name##4( short4 a); \
rtype##4 __OVERLOAD__ name##4( int4 a); \
rtype##4 __OVERLOAD__ name##4( long4 a); \
rtype##4 __OVERLOAD__ name##4( float4 a); \
rtype##4 __OVERLOAD__ name##4( double4 a); \
rtype##8 __OVERLOAD__ name##8( uchar8 a); \
rtype##8 __OVERLOAD__ name##8( ushort8 a); \
rtype##8 __OVERLOAD__ name##8( uint8 a); \
rtype##8 __OVERLOAD__ name##8( ulong8 a); \
rtype##8 __OVERLOAD__ name##8( char8 a); \
rtype##8 __OVERLOAD__ name##8( short8 a); \
rtype##8 __OVERLOAD__ name##8( int8 a); \
rtype##8 __OVERLOAD__ name##8( long8 a); \
rtype##8 __OVERLOAD__ name##8( float8 a); \
rtype##8 __OVERLOAD__ name##8( double8 a); \
rtype##16 __OVERLOAD__ name##16( uchar16 a); \
rtype##16 __OVERLOAD__ name##16( ushort16 a); \
rtype##16 __OVERLOAD__ name##16( uint16 a); \
rtype##16 __OVERLOAD__ name##16( ulong16 a); \
rtype##16 __OVERLOAD__ name##16( char16 a); \
rtype##16 __OVERLOAD__ name##16( short16 a); \
rtype##16 __OVERLOAD__ name##16( int16 a); \
rtype##16 __OVERLOAD__ name##16( long16 a); \
rtype##16 __OVERLOAD__ name##16( float16 a); \
rtype##16 __OVERLOAD__ name##16( double16 a);
#else
#define __CLFN_CONVERT(name, rtype) rtype __OVERLOAD__ name( uchar a); \
rtype __OVERLOAD__ name( ushort a); \
rtype __OVERLOAD__ name( uint a); \
rtype __OVERLOAD__ name( ulong a); \
rtype __OVERLOAD__ name( char a); \
rtype __OVERLOAD__ name( short a); \
rtype __OVERLOAD__ name( int a); \
rtype __OVERLOAD__ name( long a); \
rtype __OVERLOAD__ name( float a); \
rtype##2 __OVERLOAD__ name##2( uchar2 a); \
rtype##2 __OVERLOAD__ name##2( ushort2 a); \
rtype##2 __OVERLOAD__ name##2( uint2 a); \
rtype##2 __OVERLOAD__ name##2( ulong2 a); \
rtype##2 __OVERLOAD__ name##2( char2 a); \
rtype##2 __OVERLOAD__ name##2( short2 a); \
rtype##2 __OVERLOAD__ name##2( int2 a); \
rtype##2 __OVERLOAD__ name##2( long2 a); \
rtype##2 __OVERLOAD__ name##2( float2 a); \
rtype##3 __OVERLOAD__ name##3( uchar3 a); \
rtype##3 __OVERLOAD__ name##3( ushort3 a); \
rtype##3 __OVERLOAD__ name##3( uint3 a); \
rtype##3 __OVERLOAD__ name##3( ulong3 a); \
rtype##3 __OVERLOAD__ name##3( char3 a); \
rtype##3 __OVERLOAD__ name##3( short3 a); \
rtype##3 __OVERLOAD__ name##3( int3 a); \
rtype##3 __OVERLOAD__ name##3( long3 a); \
rtype##3 __OVERLOAD__ name##3( float3 a); \
rtype##4 __OVERLOAD__ name##4( uchar4 a); \
rtype##4 __OVERLOAD__ name##4( ushort4 a); \
rtype##4 __OVERLOAD__ name##4( uint4 a); \
rtype##4 __OVERLOAD__ name##4( ulong4 a); \
rtype##4 __OVERLOAD__ name##4( char4 a); \
rtype##4 __OVERLOAD__ name##4( short4 a); \
rtype##4 __OVERLOAD__ name##4( int4 a); \
rtype##4 __OVERLOAD__ name##4( long4 a); \
rtype##4 __OVERLOAD__ name##4( float4 a); \
rtype##8 __OVERLOAD__ name##8( uchar8 a); \
rtype##8 __OVERLOAD__ name##8( ushort8 a); \
rtype##8 __OVERLOAD__ name##8( uint8 a); \
rtype##8 __OVERLOAD__ name##8( ulong8 a); \
rtype##8 __OVERLOAD__ name##8( char8 a); \
rtype##8 __OVERLOAD__ name##8( short8 a); \
rtype##8 __OVERLOAD__ name##8( int8 a); \
rtype##8 __OVERLOAD__ name##8( long8 a); \
rtype##8 __OVERLOAD__ name##8( float8 a); \
rtype##16 __OVERLOAD__ name##16( uchar16 a); \
rtype##16 __OVERLOAD__ name##16( ushort16 a); \
rtype##16 __OVERLOAD__ name##16( uint16 a); \
rtype##16 __OVERLOAD__ name##16( ulong16 a); \
rtype##16 __OVERLOAD__ name##16( char16 a); \
rtype##16 __OVERLOAD__ name##16( short16 a); \
rtype##16 __OVERLOAD__ name##16( int16 a); \
rtype##16 __OVERLOAD__ name##16( long16 a); \
rtype##16 __OVERLOAD__ name##16( float16 a);
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_CONVERT_EXT(name, ext, rtype) rtype __OVERLOAD__ name##ext( uchar a); \
rtype __OVERLOAD__ name##ext( ushort a); \
rtype __OVERLOAD__ name##ext( uint a); \
rtype __OVERLOAD__ name##ext( ulong a); \
rtype __OVERLOAD__ name##ext( char a); \
rtype __OVERLOAD__ name##ext( short a); \
rtype __OVERLOAD__ name##ext( int a); \
rtype __OVERLOAD__ name##ext( long a); \
rtype __OVERLOAD__ name##ext( float a); \
rtype __OVERLOAD__ name##ext( double a); \
rtype##2 __OVERLOAD__ name##2##ext( uchar2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ushort2 a); \
rtype##2 __OVERLOAD__ name##2##ext( uint2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ulong2 a); \
rtype##2 __OVERLOAD__ name##2##ext( char2 a); \
rtype##2 __OVERLOAD__ name##2##ext( short2 a); \
rtype##2 __OVERLOAD__ name##2##ext( int2 a); \
rtype##2 __OVERLOAD__ name##2##ext( long2 a); \
rtype##2 __OVERLOAD__ name##2##ext( float2 a); \
rtype##2 __OVERLOAD__ name##2##ext( double2 a); \
rtype##3 __OVERLOAD__ name##3##ext( uchar3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ushort3 a); \
rtype##3 __OVERLOAD__ name##3##ext( uint3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ulong3 a); \
rtype##3 __OVERLOAD__ name##3##ext( char3 a); \
rtype##3 __OVERLOAD__ name##3##ext( short3 a); \
rtype##3 __OVERLOAD__ name##3##ext( int3 a); \
rtype##3 __OVERLOAD__ name##3##ext( long3 a); \
rtype##3 __OVERLOAD__ name##3##ext( float3 a); \
rtype##3 __OVERLOAD__ name##3##ext( double3 a); \
rtype##4 __OVERLOAD__ name##4##ext( uchar4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ushort4 a); \
rtype##4 __OVERLOAD__ name##4##ext( uint4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ulong4 a); \
rtype##4 __OVERLOAD__ name##4##ext( char4 a); \
rtype##4 __OVERLOAD__ name##4##ext( short4 a); \
rtype##4 __OVERLOAD__ name##4##ext( int4 a); \
rtype##4 __OVERLOAD__ name##4##ext( long4 a); \
rtype##4 __OVERLOAD__ name##4##ext( float4 a); \
rtype##4 __OVERLOAD__ name##4##ext( double4 a); \
rtype##8 __OVERLOAD__ name##8##ext( uchar8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ushort8 a); \
rtype##8 __OVERLOAD__ name##8##ext( uint8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ulong8 a); \
rtype##8 __OVERLOAD__ name##8##ext( char8 a); \
rtype##8 __OVERLOAD__ name##8##ext( short8 a); \
rtype##8 __OVERLOAD__ name##8##ext( int8 a); \
rtype##8 __OVERLOAD__ name##8##ext( long8 a); \
rtype##8 __OVERLOAD__ name##8##ext( float8 a); \
rtype##8 __OVERLOAD__ name##8##ext( double8 a); \
rtype##16 __OVERLOAD__ name##16##ext( uchar16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ushort16 a); \
rtype##16 __OVERLOAD__ name##16##ext( uint16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ulong16 a); \
rtype##16 __OVERLOAD__ name##16##ext( char16 a); \
rtype##16 __OVERLOAD__ name##16##ext( short16 a); \
rtype##16 __OVERLOAD__ name##16##ext( int16 a); \
rtype##16 __OVERLOAD__ name##16##ext( long16 a); \
rtype##16 __OVERLOAD__ name##16##ext( float16 a); \
rtype##16 __OVERLOAD__ name##16##ext( double16 a); 
#else
#define __CLFN_CONVERT_EXT(name, ext, rtype) rtype __OVERLOAD__ name##ext( uchar a); \
rtype __OVERLOAD__ name##ext( ushort a); \
rtype __OVERLOAD__ name##ext( uint a); \
rtype __OVERLOAD__ name##ext( ulong a); \
rtype __OVERLOAD__ name##ext( char a); \
rtype __OVERLOAD__ name##ext( short a); \
rtype __OVERLOAD__ name##ext( int a); \
rtype __OVERLOAD__ name##ext( long a); \
rtype __OVERLOAD__ name##ext( float a); \
rtype##2 __OVERLOAD__ name##2##ext( uchar2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ushort2 a); \
rtype##2 __OVERLOAD__ name##2##ext( uint2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ulong2 a); \
rtype##2 __OVERLOAD__ name##2##ext( char2 a); \
rtype##2 __OVERLOAD__ name##2##ext( short2 a); \
rtype##2 __OVERLOAD__ name##2##ext( int2 a); \
rtype##2 __OVERLOAD__ name##2##ext( long2 a); \
rtype##2 __OVERLOAD__ name##2##ext( float2 a); \
rtype##3 __OVERLOAD__ name##3##ext( uchar3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ushort3 a); \
rtype##3 __OVERLOAD__ name##3##ext( uint3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ulong3 a); \
rtype##3 __OVERLOAD__ name##3##ext( char3 a); \
rtype##3 __OVERLOAD__ name##3##ext( short3 a); \
rtype##3 __OVERLOAD__ name##3##ext( int3 a); \
rtype##3 __OVERLOAD__ name##3##ext( long3 a); \
rtype##3 __OVERLOAD__ name##3##ext( float3 a); \
rtype##4 __OVERLOAD__ name##4##ext( uchar4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ushort4 a); \
rtype##4 __OVERLOAD__ name##4##ext( uint4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ulong4 a); \
rtype##4 __OVERLOAD__ name##4##ext( char4 a); \
rtype##4 __OVERLOAD__ name##4##ext( short4 a); \
rtype##4 __OVERLOAD__ name##4##ext( int4 a); \
rtype##4 __OVERLOAD__ name##4##ext( long4 a); \
rtype##4 __OVERLOAD__ name##4##ext( float4 a); \
rtype##8 __OVERLOAD__ name##8##ext( uchar8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ushort8 a); \
rtype##8 __OVERLOAD__ name##8##ext( uint8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ulong8 a); \
rtype##8 __OVERLOAD__ name##8##ext( char8 a); \
rtype##8 __OVERLOAD__ name##8##ext( short8 a); \
rtype##8 __OVERLOAD__ name##8##ext( int8 a); \
rtype##8 __OVERLOAD__ name##8##ext( long8 a); \
rtype##8 __OVERLOAD__ name##8##ext( float8 a); \
rtype##16 __OVERLOAD__ name##16##ext( uchar16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ushort16 a); \
rtype##16 __OVERLOAD__ name##16##ext( uint16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ulong16 a); \
rtype##16 __OVERLOAD__ name##16##ext( char16 a); \
rtype##16 __OVERLOAD__ name##16##ext( short16 a); \
rtype##16 __OVERLOAD__ name##16##ext( int16 a); \
rtype##16 __OVERLOAD__ name##16##ext( long16 a); \
rtype##16 __OVERLOAD__ name##16##ext( float16 a);
#endif


__CLFN_CONVERT_EXT(convert_uchar, _sat_rtz, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rtp, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rtn, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rte, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtz, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtn, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtp, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rte, uchar);
__CLFN_CONVERT(convert_uchar, uchar);

__CLFN_CONVERT(convert_ushort, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rte, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtp, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtn, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtz, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rte, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtn, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtp, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtz, ushort);

__CLFN_CONVERT(convert_uint, uint);
__CLFN_CONVERT_EXT(convert_uint, _rte, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtp, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtn, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtz, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rte, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtn, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtp, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtz, uint);

__CLFN_CONVERT(convert_ulong, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rte, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtp, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtn, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtz, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rte, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtn, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtp, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtz, ulong);

__CLFN_CONVERT(convert_char, char);
__CLFN_CONVERT_EXT(convert_char, _rte, char);
__CLFN_CONVERT_EXT(convert_char, _rtp, char);
__CLFN_CONVERT_EXT(convert_char, _rtn, char);
__CLFN_CONVERT_EXT(convert_char, _rtz, char);
__CLFN_CONVERT_EXT(convert_char, _sat, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rte, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtn, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtp, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtz, char);

__CLFN_CONVERT(convert_short, short);
__CLFN_CONVERT_EXT(convert_short, _rte, short);
__CLFN_CONVERT_EXT(convert_short, _rtp, short);
__CLFN_CONVERT_EXT(convert_short, _rtn, short);
__CLFN_CONVERT_EXT(convert_short, _rtz, short);
__CLFN_CONVERT_EXT(convert_short, _sat, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rte, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtn, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtp, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtz, short);

__CLFN_CONVERT(convert_int, int);
__CLFN_CONVERT_EXT(convert_int, _rte, int);
__CLFN_CONVERT_EXT(convert_int, _rtp, int);
__CLFN_CONVERT_EXT(convert_int, _rtn, int);
__CLFN_CONVERT_EXT(convert_int, _rtz, int);
__CLFN_CONVERT_EXT(convert_int, _sat, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rte, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtn, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtp, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtz, int);

__CLFN_CONVERT(convert_long, long);
__CLFN_CONVERT_EXT(convert_long, _rte, long);
__CLFN_CONVERT_EXT(convert_long, _rtp, long);
__CLFN_CONVERT_EXT(convert_long, _rtn, long);
__CLFN_CONVERT_EXT(convert_long, _rtz, long);
__CLFN_CONVERT_EXT(convert_long, _sat, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rte, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtn, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtp, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtz, long);

__CLFN_CONVERT(convert_float, float);
__CLFN_CONVERT_EXT(convert_float, _rte, float);
__CLFN_CONVERT_EXT(convert_float, _rtp, float);
__CLFN_CONVERT_EXT(convert_float, _rtn, float);
__CLFN_CONVERT_EXT(convert_float, _rtz, float);

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
__CLFN_CONVERT(convert_double, double);
__CLFN_CONVERT_EXT(convert_double, _rte, double);
__CLFN_CONVERT_EXT(convert_double, _rtp, double);
__CLFN_CONVERT_EXT(convert_double, _rtn, double);
__CLFN_CONVERT_EXT(convert_double, _rtz, double);
#endif

#endif

// 6.2.4.2 as_typen
#define as_char( _x )   __builtin_astype( _x, char )
#define as_uchar( _x )  __builtin_astype( _x, uchar )
#define as_short( _x )  __builtin_astype( _x, short )
#define as_ushort( _x ) __builtin_astype( _x, ushort )
#define as_int( _x )    __builtin_astype( _x, int )
#define as_uint( _x )   __builtin_astype( _x, uint )
#define as_float( _x )  __builtin_astype( _x, float )
#define as_long( _x )   __builtin_astype( _x, long )
#define as_ulong( _x )  __builtin_astype( _x, ulong )
#define as_double( _x ) __builtin_astype( _x, double )

#define as_size_t( _x ) __builtin_astype( _x, size_t )
#define as_intptr_t( _x ) __builtin_astype( _x, intptr_t )
#define as_uintptr_t( _x ) __builtin_astype( _x, uintptr_t )
#define as_ptrdiff_t( _x ) __builtin_astype( _x, ptrdiff_t )

#define as_char2( _x )   __builtin_astype( _x, char2 )
#define as_char3( _x )   __builtin_astype( _x, char3 )
#define as_char4( _x )   __builtin_astype( _x, char4 )
#define as_char8( _x )   __builtin_astype( _x, char8 )
#define as_char16( _x )  __builtin_astype( _x, char16 )

#define as_uchar2( _x )   __builtin_astype( _x, uchar2 )
#define as_uchar3( _x )   __builtin_astype( _x, uchar3 )
#define as_uchar4( _x )   __builtin_astype( _x, uchar4 )
#define as_uchar8( _x )   __builtin_astype( _x, uchar8 )
#define as_uchar16( _x )  __builtin_astype( _x, uchar16 )

#define as_short2( _x )   __builtin_astype( _x, short2 )
#define as_short3( _x )   __builtin_astype( _x, short3 )
#define as_short4( _x )   __builtin_astype( _x, short4 )
#define as_short8( _x )   __builtin_astype( _x, short8 )
#define as_short16( _x )  __builtin_astype( _x, short16 )

#define as_ushort2( _x )   __builtin_astype( _x, ushort2 )
#define as_ushort3( _x )   __builtin_astype( _x, ushort3 )
#define as_ushort4( _x )   __builtin_astype( _x, ushort4 )
#define as_ushort8( _x )   __builtin_astype( _x, ushort8 )
#define as_ushort16( _x )  __builtin_astype( _x, ushort16 )

#define as_int2( _x )   __builtin_astype( _x, int2 )
#define as_int3( _x )   __builtin_astype( _x, int3 )
#define as_int4( _x )   __builtin_astype( _x, int4 )
#define as_int8( _x )   __builtin_astype( _x, int8 )
#define as_int16( _x )  __builtin_astype( _x, int16 )

#define as_uint2( _x )   __builtin_astype( _x, uint2 )
#define as_uint3( _x )   __builtin_astype( _x, uint3 )
#define as_uint4( _x )   __builtin_astype( _x, uint4 )
#define as_uint8( _x )   __builtin_astype( _x, uint8 )
#define as_uint16( _x )  __builtin_astype( _x, uint16 )

#define as_float2( _x )   __builtin_astype( _x, float2 )
#define as_float3( _x )   __builtin_astype( _x, float3 )
#define as_float4( _x )   __builtin_astype( _x, float4 )
#define as_float8( _x )   __builtin_astype( _x, float8 )
#define as_float16( _x )  __builtin_astype( _x, float16 )

#define as_long2( _x )   __builtin_astype( _x, long2 )
#define as_long3( _x )   __builtin_astype( _x, long3 )
#define as_long4( _x )   __builtin_astype( _x, long4 )
#define as_long8( _x )   __builtin_astype( _x, long8 )
#define as_long16( _x )  __builtin_astype( _x, long16 )

#define as_ulong2( _x )   __builtin_astype( _x, ulong2 )
#define as_ulong3( _x )   __builtin_astype( _x, ulong3 )
#define as_ulong4( _x )   __builtin_astype( _x, ulong4 )
#define as_ulong8( _x )   __builtin_astype( _x, ulong8 )
#define as_ulong16( _x )  __builtin_astype( _x, ulong16 )

#define as_double2( _x )   __builtin_astype( _x, double2 )
#define as_double3( _x )   __builtin_astype( _x, double3 )
#define as_double4( _x )   __builtin_astype( _x, double4 )
#define as_double8( _x )   __builtin_astype( _x, double8 )
#define as_double16( _x )  __builtin_astype( _x, double16 )

// 5.5 Function Qualifiers
#define __kernel __attribute__((annotate("kernel")))
#define kernel __attribute__((annotate("kernel")))

// 5.6 Image Access Qualifiers
#define __rd __attribute__((annotate("__rd")))  
#define __wr __attribute__((annotate("__wr")))  
#define __read_only __attribute__((annotate("__rd")))  
#define read_only __attribute__((annotate("__rd")))  
#define __write_only __attribute__((annotate("__wr")))  
#define write_only __attribute__((annotate("__wr")))  
#define __read_write __attribute__((annotate("__rw")))  
#define read_write __attribute__((annotate("__rw")))  

// 5.9.1 - Work-item Functions
// These are defined for GPUs by their respective builtin implementations.
uint   get_work_dim(void);
size_t get_global_size(uint dimindx);
size_t get_global_id(uint dimindx);
size_t get_global_offset(uint dimindx);
size_t get_local_size(uint dimindx);
size_t get_local_id (uint dimindx);
size_t get_num_groups(uint dimindx);
size_t get_group_id(uint dimindx);

// 5.9.2 - Math Defines
#define MAXFLOAT ((float)3.40282346638528860e+38)
#define HUGE_VALF __builtin_huge_valf()
#define INFINITY __builtin_inff()
#define NAN __builtin_nanf("")

/* Section 5.9.2, Table 5.7 */
__CLFN_F_1F(half_cos);
__CLFN_F_2F(half_divide);
__CLFN_F_1F(half_exp);
__CLFN_F_1F(half_exp2);
__CLFN_F_1F(half_exp10);
__CLFN_F_1F(half_log);
__CLFN_F_1F(half_log2);
__CLFN_F_1F(half_log10);
__CLFN_F_2F(half_powr);
__CLFN_F_1F(half_recip);
__CLFN_F_1F(half_rsqrt);
__CLFN_F_1F(half_sin);
__CLFN_F_1F(half_sqrt);
__CLFN_F_1F(half_tan);

__CLFN_F_1F(native_cos);
__CLFN_F_2F(native_divide);
__CLFN_F_1F(native_exp);
__CLFN_F_1F(native_exp2);
__CLFN_F_1F(native_exp10);
__CLFN_F_1F(native_log);
__CLFN_F_1F(native_log2);
__CLFN_F_1F(native_log10);
__CLFN_F_2F(native_powr);
__CLFN_F_1F(native_recip);
__CLFN_F_1F(native_rsqrt);
__CLFN_F_1F(native_sin);
__CLFN_F_1F(native_sqrt);
__CLFN_F_1F(native_tan);


/* Section 5.9.2, Table 5.6 */
__CLFN_FD_1FD(__cl_acos);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef acos
    #define acos(__x) __cl_acos(__x)
#else
    #warning  __CL_INTERNAL_SKIP_MATH_DEFINES__  defined.   Many builtin definitions will be missing.
#endif

__CLFN_FD_1FD(__cl_acosh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef acosh
    #define acosh(__x) __cl_acosh(__x)
#endif

__CLFN_FD_1FD(acospi); 

__CLFN_FD_1FD(__cl_asin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef asin
    #define asin(__x) __cl_asin(__x)
#endif

__CLFN_FD_1FD(__cl_asinh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef asinh
    #define asinh(__x) __cl_asinh(__x)
#endif

__CLFN_FD_1FD(asinpi); 

__CLFN_FD_1FD(__cl_atan); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atan
    #define atan(__x) __cl_atan(__x)
#endif

__CLFN_FD_1FD(__cl_atanh); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atanh
    #define atanh(__x) __cl_atanh(__x)
#endif

__CLFN_FD_1FD(atanpi);

__CLFN_FD_2FD(__cl_atan2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atan2
    #define atan2(__x, __y) __cl_atan2(__x, __y)
#endif

__CLFN_FD_2FD(atan2pi);

__CLFN_FD_1FD(__cl_cbrt);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef cbrt
    #define cbrt(__x) __cl_cbrt(__x)
#endif

__CLFN_FD_1FD(__cl_ceil);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ceil
    #define ceil(__x) __cl_ceil(__x)
#endif

__CLFN_FD_2FD(__cl_copysign);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef copysign
    #define copysign(__x, __y) __cl_copysign(__x, __y)
#endif

__CLFN_FD_1FD(__cl_cosh); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef cosh
    #define cosh(__x) __cl_cosh(__x)
#endif

__CLFN_FD_1FD(cospi); 

__CLFN_FD_1FD(__cl_erf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef erf
    #define erf(__x) __cl_erf(__x)
#endif

__CLFN_FD_1FD(__cl_erfc);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef erfc
    #define erfc(__x) __cl_erfc(__x)
#endif

__CLFN_FD_1FD(__cl_exp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
    #undef exp
    #define exp(__x) __fast_relax_exp(__x)
#endif

__CLFN_FD_1FD(__cl_exp2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp2, native_exp2, __cl_exp2);
    #undef exp2
    #define exp2(__x) __fast_relax_exp2(__x)
#endif

__CLFN_FD_1FD(__cl_exp10); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp10, native_exp10, __cl_exp10);
    #undef exp10
    #define exp10(__x) __fast_relax_exp10(__x)
#endif

__CLFN_FD_1FD(asinpi);

__CLFN_FD_1FD(__cl_expm1);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef expm1
    #define expm1(__x) __cl_expm1(__x)
#endif

__CLFN_FD_1FD(__cl_fabs);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fabs
    #define fabs(__x) __cl_fabs(__x)
#endif

__CLFN_FD_2FD(__cl_fdim);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fdim
    #define fdim(__x, __y) __cl_fdim(__x, __y)
#endif

__CLFN_FD_1FD(__cl_floor);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef floor
    #define floor(__x) __cl_floor(__x)
#endif

__CLFN_FD_3FD(__cl_fma);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fma
    #define fma(__x, __y, __z) __cl_fma(__x, __y, __z)
#endif

__CLFN_FD_2FD(__cl_fmax);
__CLFN_FD_2FD_EXT(__cl_fmax);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmax
    #define fmax(__x, __y) __cl_fmax(__x, __y)
#endif

__CLFN_FD_2FD(__cl_fmin);
__CLFN_FD_2FD_EXT(__cl_fmin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmin
    #define fmin(__x, __y) __cl_fmin(__x, __y)
#endif

__CLFN_FD_2FD(__cl_fmod);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmod
    #define fmod(__x, __y) __cl_fmod(__x, __y)
#endif

                                            
__CLFN_FD_1FD_1PFD(fract);

__CLFN_FD_1FD_1PI(__cl_frexp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef frexp
    #define frexp(__x, __y) __cl_frexp(__x, __y)
#endif

__CLFN_FD_2FD(__cl_hypot);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef hypot
    #define hypot(__x, __y) __cl_hypot(__x, __y)
#endif

__CLFN_I_1FD(__cl_ilogb);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ilogb
    #define ilogb(__x) __cl_ilogb(__x)
#endif

__CLFN_FD_1FD_1I(__cl_ldexp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ldexp
    #define ldexp(__x, __y) __cl_ldexp(__x, __y)
#endif

__CLFN_FD_1FD(__cl_lgamma); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef lgamma
    #define lgamma(__x) __cl_lgamma(__x)
#endif

__CLFN_FD_1FD_1PI(__cl_lgamma_r);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef lgamma_r
    #define lgamma_r(__x, __y) __cl_lgamma_r(__x, __y)
#endif

__CLFN_FD_1FD(__cl_log);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_log, native_log, __cl_log);
    #undef log
    #define log(__x) __fast_relax_log(__x)
#endif

__CLFN_FD_1FD(__cl_log10);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_log10, native_log10, __cl_log10);
    #undef log10
    #define log10(__x) __cl_log10(__x)
#endif

__CLFN_FD_1FD(__cl_log1p);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef log1p
    #define log1p(__x) __cl_log1p(__x)
#endif

__CLFN_FD_1FD(__cl_log2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef log2
    #define log2(__x) __cl_log2(__x)
#endif

__CLFN_FD_1FD(__cl_logb);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef logb
    #define logb(__x) __cl_logb(__x)
#endif

__CLFN_FD_3FD(mad);
__CLFN_FD_2FD(maxmag);
__CLFN_FD_2FD(minmag);

__CLFN_FD_1FD_1PFD(__cl_modf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef modf
    #define modf(__x, __y) __cl_modf(__x, __y)
#endif


__CLFN_FD_1UIL(__cl_nan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef nan
    #define nan(__x) __cl_nan(__x)
#endif

__CLFN_FD_2FD(__cl_nextafter);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef nextafter
    #define nextafter(__x, __y) __cl_nextafter(__x, __y)
#endif

__CLFN_FD_2FD(__cl_pow);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef pow
    #define pow(__x, __y) __cl_pow(__x, __y)
#endif

__CLFN_FD_1FD_1I(__cl_pown);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef pown
    #define pown(__x, __y) __cl_pown(__x, __y)
#endif

__CLFN_FD_2FD(__cl_powr);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
   __CLFN_FD_2FD_FAST_RELAX(__fast_relax_powr, native_powr, __cl_powr);
    #undef powr
    #define powr(__x, __y) __cl_powr(__x, __y)
#endif

__CLFN_FD_2FD(__cl_remainder);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef remainder
    #define remainder(__x, __y) __cl_remainder(__x, __y)
#endif

__CLFN_FD_2FD_1PI(__cl_remquo);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef remquo
    #define remquo(__x, __y, __z) __cl_remquo(__x, __y, __z)
#endif

__CLFN_FD_1FD(__cl_rint);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef rint
    #define rint(__x) __cl_rint(__x)
#endif

__CLFN_FD_1FD_1I(rootn);

__CLFN_FD_1FD(__cl_round);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef round
    #define round(__x) __cl_round(__x)
#endif

__CLFN_FD_1FD(rsqrt);


__CLFN_FD_1FD(__cl_cos);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
    #undef cos
    #define cos(__x) __fast_relax_cos(__x)
#endif

__CLFN_FD_1FD(__cl_sin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
    #undef sin
    #define sin(__x) __fast_relax_sin(__x)
#endif

__CLFN_FD_1FD(__cl_tan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_tan, native_tan, __cl_tan);
    #undef tan
    #define tan(__x) __fast_relax_tan(__x)
#endif

__CLFN_FD_1FD_1PFD(sincos);

__CLFN_FD_1FD(__cl_sinh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef sinh
    #define sinh(__x) __cl_sinh(__x)
#endif

__CLFN_FD_1FD(sinpi);

__CLFN_FD_1FD(__cl_sqrt);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef sqrt
    #define sqrt(__x) __cl_sqrt(__x)
#endif


__CLFN_FD_1FD(__cl_tanh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef tanh
    #define tanh(__x) __cl_tanh(__x)
#endif

__CLFN_FD_1FD(tanpi);          

__CLFN_FD_1FD(__cl_tgamma);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef tgamma
    #define tgamma(__x) __cl_tgamma(__x)
#endif

__CLFN_FD_1FD(__cl_trunc);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef trunc
    #define trunc(__x) __cl_trunc(__x)
#endif

/* Section 5.9.3 */
                                             
__CLFN_UCSIL_1CSIL(__cl_abs);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef abs
    #define abs(__x) __cl_abs(__x)
#endif

__CLFN_UCSIL_2CSIL(abs_diff);
__CLFN_ALL(add_sat);

/* upsample */
short __OVERLOAD_INLINE__ upsample(char ahi, uchar alo);
short2 __OVERLOAD_INLINE__ upsample(char2 ahi, uchar2 alo);
short4 __OVERLOAD_INLINE__ upsample(char4 ahi, uchar4 alo);
short3 __OVERLOAD_INLINE__ upsample(char3 ahi, uchar3 alo);
short8 __OVERLOAD_INLINE__ upsample(char8 ahi, uchar8 alo);
short16 __OVERLOAD_INLINE__ upsample(char16 ahi, uchar16 alo);
ushort __OVERLOAD_INLINE__ upsample(uchar ahi, uchar alo);
ushort2 __OVERLOAD_INLINE__ upsample(uchar2 ahi, uchar2 alo);
ushort3 __OVERLOAD_INLINE__ upsample(uchar3 ahi, uchar3 alo);
ushort4 __OVERLOAD_INLINE__ upsample(uchar4 ahi, uchar4 alo);
ushort8 __OVERLOAD_INLINE__ upsample(uchar8 ahi, uchar8 alo);
ushort16 __OVERLOAD_INLINE__ upsample(uchar16 ahi, uchar16 alo);
int __OVERLOAD_INLINE__ upsample(short ahi, ushort alo);
int2 __OVERLOAD_INLINE__ upsample(short2 ahi, ushort2 alo);
int4 __OVERLOAD_INLINE__ upsample(short4 ahi, ushort4 alo);
int3 __OVERLOAD_INLINE__ upsample(short3 ahi, ushort3 alo);
int8 __OVERLOAD_INLINE__ upsample(short8 ahi, ushort8 alo);
int16 __OVERLOAD_INLINE__ upsample(short16 ahi, ushort16 alo);
uint __OVERLOAD_INLINE__ upsample(ushort ahi, ushort alo);
uint2 __OVERLOAD_INLINE__ upsample(ushort2 ahi, ushort2 alo);
uint3 __OVERLOAD_INLINE__ upsample(ushort3 ahi, ushort3 alo);
uint4 __OVERLOAD_INLINE__ upsample(ushort4 ahi, ushort4 alo);
uint8 __OVERLOAD_INLINE__ upsample(ushort8 ahi, ushort8 alo);
uint16 __OVERLOAD_INLINE__ upsample(ushort16 ahi, ushort16 alo);
long __OVERLOAD_INLINE__ upsample(int ahi, uint alo);
long2 __OVERLOAD_INLINE__ upsample(int2 ahi, uint2 alo); 
long3 __OVERLOAD_INLINE__ upsample(int3 ahi, uint3 alo);
long4 __OVERLOAD_INLINE__ upsample(int4 ahi, uint4 alo);
long8 __OVERLOAD_INLINE__ upsample(int8 ahi, uint8 alo);
long16 __OVERLOAD_INLINE__ upsample(int16 ahi, uint16 alo);
ulong __OVERLOAD_INLINE__ upsample(uint ahi, uint alo);
ulong2 __OVERLOAD_INLINE__ upsample(uint2 ahi, uint2 alo); 
ulong3 __OVERLOAD_INLINE__ upsample(uint3 ahi3, uint3 alo3); 
ulong4 __OVERLOAD_INLINE__ upsample(uint4 ahi, uint4 alo); 
ulong8 __OVERLOAD_INLINE__ upsample(uint8 ahi, uint8 alo);
ulong16 __OVERLOAD_INLINE__ upsample(uint16 ahi, uint16 alo);

__CLFN_ALL(hadd);
__CLFN_ALL(rhadd);
__CLFN_CSIL_1CSIL(clz);
__CLFN_CSIL_1CSIL(popcount);
__CLFN_I3(mad_hi);
__CLFN_I3(mad_hi_sat);
__CLFN_I3(mad_sat);

__CLFN_ALL(max);
__CLFN_ALL_MODD(max);
__CLFN_FD_2FD(max);

__CLFN_ALL(min);
__CLFN_ALL_MODD(min);
__CLFN_FD_2FD(min);

__CLFN_I_3CSIL(msum);
__CLFN_ALL(rotate);
__CLFN_ALL(mul_hi);
__CLFN_ALL(sub_sat);

__CLFN_I_3I(mad24);
__CLFN_I_2I(mul24);

/* Section 5.9.4 */
float __OVERLOAD__ clamp(float x, float minval, float maxval);
float2 __OVERLOAD__ clamp(float2 x, float2 minval, float2 maxval);
float3 __OVERLOAD__ clamp(float3 x, float3 minval, float3 maxval);
float4 __OVERLOAD__ clamp(float4 x, float4 minval, float4 maxval);
float8 __OVERLOAD__ clamp( float8 x, float8 minval, float8 maxval );
float16 __OVERLOAD__ clamp( float16 x, float16 minval, float16 maxval );
#if 0
float2 __OVERLOAD__ clamp(float2 x, float minval, float maxval);
float3 __OVERLOAD__ clamp(float3 x, float minval, float maxval);
float4 __OVERLOAD__ clamp(float4 x, float minval, float maxval);
float8 __OVERLOAD__ clamp(float8 x, float minval, float maxval);
float16 __OVERLOAD__ clamp(float16 x, float minval, float maxval);
double2 __OVERLOAD__ clamp(double2 x, double minval, double maxval);
double3 __OVERLOAD__ clamp(double3 x, double minval, double maxval);
double4 __OVERLOAD__ clamp(double4 x, double minval, double maxval);
double8 __OVERLOAD__ clamp(double8 x, double minval, double maxval);
double16 __OVERLOAD__ clamp(double16 x, double minval, double maxval);
#endif
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ clamp(double x, double minval, double maxval);
#endif
double2 __OVERLOAD__ clamp(double2 x, double2 minval, double2 maxval);
double3 __OVERLOAD__ clamp(double3 x, double3 minval, double3 maxval);
double4 __OVERLOAD__ clamp(double4 x, double4 minval, double4 maxval);
double8 __OVERLOAD__ clamp( double8 x, double8 minval, double8 maxval );
double16 __OVERLOAD__ clamp( double16 x, double16 minval, double16 maxval );
char __OVERLOAD__ clamp( char x, char min, char max );
short __OVERLOAD__ clamp( short x, short min, short max );
int __OVERLOAD__ clamp( int x, int min, int max );
long __OVERLOAD__ clamp( long x, long min, long max );
uchar __OVERLOAD__ clamp( uchar x, uchar min, uchar max );
ushort __OVERLOAD__ clamp( ushort x, ushort min, ushort max );
uint __OVERLOAD__ clamp( uint x, uint min, uint max );
ulong __OVERLOAD__ clamp( ulong x, ulong min, ulong max );
char2 __OVERLOAD__ clamp( char2 x, char2 min, char2 max );
short2 __OVERLOAD__ clamp( short2 x, short2 min, short2 max );
int2 __OVERLOAD__ clamp( int2 x, int2 min, int2 max );
long2 __OVERLOAD__ clamp( long2 x, long2 min, long2 max );
uchar2 __OVERLOAD__ clamp( uchar2 x, uchar2 min, uchar2 max );
ushort2 __OVERLOAD__ clamp( ushort2 x, ushort2 min, ushort2 max );
uint2 __OVERLOAD__ clamp( uint2 x, uint2 min, uint2 max );
ulong2 __OVERLOAD__ clamp( ulong2 x, ulong2 min, ulong2 max );
char3 __OVERLOAD__ clamp( char3 x, char3 min, char3 max );
short3 __OVERLOAD__ clamp( short3 x, short3 min, short3 max );
int3 __OVERLOAD__ clamp( int3 x3, int3 min3, int3 max3 );
long3 __OVERLOAD__ clamp( long3 x3, long3 min3, long3 max3 );
uchar3 __OVERLOAD__ clamp( uchar3 x, uchar3 min, uchar3 max );
ushort3 __OVERLOAD__ clamp( ushort3 x, ushort3 min, ushort3 max );
uint3 __OVERLOAD__ clamp( uint3 x3, uint3 min3, uint3 max3 );
ulong3 __OVERLOAD__ clamp( ulong3 x3, ulong3 min3, ulong3 max3 );
char4 __OVERLOAD__ clamp( char4 x, char4 min, char4 max );
short4 __OVERLOAD__ clamp( short4 x, short4 min, short4 max );
int4 __OVERLOAD__ clamp( int4 x, int4 min, int4 max );
long4 __OVERLOAD__ clamp( long4 x, long4 min, long4 max );
uchar4 __OVERLOAD__ clamp( uchar4 x, uchar4 min, uchar4 max );
ushort4 __OVERLOAD__ clamp( ushort4 x, ushort4 min, ushort4 max );
uint4 __OVERLOAD__ clamp( uint4 x, uint4 min, uint4 max );
ulong4 __OVERLOAD__ clamp( ulong4 x, ulong4 min, ulong4 max );
char8 __OVERLOAD__ clamp( char8 x, char8 min, char8 max );
short8 __OVERLOAD__ clamp( short8 x, short8 min, short8 max );
int8 __OVERLOAD__ clamp( int8 x, int8 min, int8 max );
long8 __OVERLOAD__ clamp( long8 x, long8 min, long8 max );
uchar8 __OVERLOAD__ clamp( uchar8 x, uchar8 min, uchar8 max );
ushort8 __OVERLOAD__ clamp( ushort8 x, ushort8 min, ushort8 max );
uint8 __OVERLOAD__ clamp( uint8 x, uint8 min, uint8 max );
ulong8 __OVERLOAD__ clamp( ulong8 x, ulong8 min, ulong8 max );
char16 __OVERLOAD__ clamp( char16 x, char16 min, char16 max );
short16 __OVERLOAD__ clamp( short16 x, short16 min, short16 max );
int16 __OVERLOAD__ clamp( int16 x, int16 min, int16 max );
long16 __OVERLOAD__ clamp( long16 x, long16 min, long16 max );
ushort16 __OVERLOAD__ clamp( ushort16 x, ushort16 min, ushort16 max );
uchar16 __OVERLOAD__ clamp( uchar16 x, uchar16 min, uchar16 max );
uint16 __OVERLOAD__ clamp( uint16 x, uint16 min, uint16 max );
ulong16 __OVERLOAD__ clamp( ulong16 x, ulong16 min, ulong16 max );
char2 __OVERLOAD__ clamp( char2 x,  char y, char z );
char3 __OVERLOAD__ clamp( char3 x,  char y, char z );
char4 __OVERLOAD__ clamp( char4 x,  char y, char z );
char8 __OVERLOAD__ clamp( char8 x,  char y, char z );
char16 __OVERLOAD__ clamp( char16 x, char y, char z );
uchar2 __OVERLOAD__ clamp( uchar2 x,  uchar y, uchar z );
uchar3 __OVERLOAD__ clamp( uchar3 x,  uchar y, uchar z );
uchar4 __OVERLOAD__ clamp( uchar4 x,  uchar y, uchar z );
uchar8 __OVERLOAD__ clamp( uchar8 x,  uchar y, uchar z );
uchar16 __OVERLOAD__ clamp( uchar16 x, uchar y, uchar z );
short2 __OVERLOAD__ clamp( short2 x,  short y, short z );
short3 __OVERLOAD__ clamp( short3 x,  short y, short z );
short4 __OVERLOAD__ clamp( short4 x,  short y, short z );
short8 __OVERLOAD__ clamp( short8 x,  short y, short z );
short16 __OVERLOAD__ clamp( short16 x, short y, short z );
ushort2 __OVERLOAD__ clamp( ushort2 x,  ushort y, ushort z );
ushort3 __OVERLOAD__ clamp( ushort3 x,  ushort y, ushort z );
ushort4 __OVERLOAD__ clamp( ushort4 x,  ushort y, ushort z );
ushort8 __OVERLOAD__ clamp( ushort8 x,  ushort y, ushort z );
ushort16 __OVERLOAD__ clamp( ushort16 x, ushort y, ushort z );
int2 __OVERLOAD__ clamp( int2 x,  int y, int z );
int3 __OVERLOAD__ clamp( int3 x,  int y, int z );
int4 __OVERLOAD__ clamp( int4 x,  int y, int z );
int8 __OVERLOAD__ clamp( int8 x,  int y, int z );
int16 __OVERLOAD__ clamp( int16 x, int y, int z );
uint2 __OVERLOAD__ clamp( uint2 x,  uint y, uint z );
uint3 __OVERLOAD__ clamp( uint3 x,  uint y, uint z );
uint4 __OVERLOAD__ clamp( uint4 x,  uint y, uint z );
uint8 __OVERLOAD__ clamp( uint8 x,  uint y, uint z );
uint16 __OVERLOAD__ clamp( uint16 x, uint y, uint z );
long2 __OVERLOAD__ clamp( long2 x,  long y, long z );
long3 __OVERLOAD__ clamp( long3 x,  long y, long z );
long4 __OVERLOAD__ clamp( long4 x,  long y, long z );
long8 __OVERLOAD__ clamp( long8 x,  long y, long z );
long16 __OVERLOAD__ clamp( long16 x, long y, long z );
ulong2 __OVERLOAD__ clamp( ulong2 x,  ulong y, ulong z );
ulong3 __OVERLOAD__ clamp( ulong3 x,  ulong y, ulong z );
ulong4 __OVERLOAD__ clamp( ulong4 x,  ulong y, ulong z );
ulong8 __OVERLOAD__ clamp( ulong8 x,  ulong y, ulong z );
ulong16 __OVERLOAD__ clamp( ulong16 x, ulong y, ulong z );
float2 __OVERLOAD__ clamp(float2 x, float minval, float maxval);
float3 __OVERLOAD__ clamp(float3 x, float minval, float maxval);
float4 __OVERLOAD__ clamp(float4 x, float minval, float maxval);
float8 __OVERLOAD__ clamp(float8 x, float minval, float maxval);
float16 __OVERLOAD__ clamp(float16 x, float minval, float maxval);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ clamp(double2 x, double minval, double maxval);
double3 __OVERLOAD__ clamp(double3 x, double minval, double maxval);
double4 __OVERLOAD__ clamp(double4 x, double minval, double maxval);
double8 __OVERLOAD__ clamp(double8 x, double minval, double maxval);
double16 __OVERLOAD__ clamp(double16 x, double minval, double maxval);
#endif


__CLFN_FD_1FD(degrees);

__CLFN_1FD_2FD_MODD(distance);
__CLFN_1FD_2FD_MODD(dot);

float3 __OVERLOAD__ cross(float3 x, float3 y);
float4 __OVERLOAD__ cross(float4 x, float4 y);
double3 __OVERLOAD__ cross(double3 x, double3 y); \
double4 __OVERLOAD__ cross(double4 x, double4 y); \

__CLFN_FD_1FD_MODD(length);
__CLFN_FD_3FD(mix);
__CLFN_FD_3FD_MOD(mix);
__CLFN_FD_1FD_MODD4(normalize);
__CLFN_FD_1FD(radians);

__CLFN_FD_2FD(step);
float2 __OVERLOAD__ step(float edge, float2 x);
float3 __OVERLOAD__ step(float edge, float3 x);
float4 __OVERLOAD__ step(float edge, float4 x);
float8 __OVERLOAD__ step(float edge, float8 x);
float16 __OVERLOAD__ step(float edge, float16 x);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ step(double edge, double2 x);
double3 __OVERLOAD__ step(double edge, double3 x);
double4 __OVERLOAD__ step(double edge, double4 x);
double8 __OVERLOAD__ step(double edge, double8 x);
double16 __OVERLOAD__ step(double edge, double16 x);
#endif

__CLFN_FD_3FD(smoothstep);
float2 __OVERLOAD__ smoothstep( float edge0, float edge1, float2 x );
float3 __OVERLOAD__ smoothstep( float edge0, float edge1, float3 x );
float4 __OVERLOAD__ smoothstep( float edge0, float edge1, float4 x );
float8 __OVERLOAD__ smoothstep( float edge0, float edge1, float8 x );
float16 __OVERLOAD__ smoothstep( float edge0, float edge1, float16 x );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ smoothstep( double e0, double e1, double2 x );
double3 __OVERLOAD__ smoothstep( double e0, double e1, double3 x );
double4 __OVERLOAD__ smoothstep( double e0, double e1, double4 x );
double8 __OVERLOAD__ smoothstep( double e0, double e1, double8 x );
double16 __OVERLOAD__ smoothstep( double e0, double e1, double16 x );
#endif
__CLFN_FD_1FD(sign);
        
__CLFN_1F_2F_MODD(fast_distance);
__CLFN_F_1F_MODD4(fast_length);
__CLFN_F_1F(fast_normalize);

/* Section 5.9.5 */
#define isless(X,Y)             ((X) <  (Y))
#define islessequal(X,Y)        ((X) <= (Y))
#define isgreater(X,Y)          ((X) >  (Y))
#define isgreaterequal(X,Y)     ((X) >= (Y))
#define isequal(X,Y)            ((X) == (Y))
#define isnotequal(X,Y)         ((X) != (Y))

__CLFN_IL_2FD(__cl_islessgreater);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef islessgreater
    #define islessgreater(__x, __y) __cl_islessgreater(__x, __y)
#endif

__CLFN_IL_1FD_MODD(__cl_isfinite);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isfinite
    #define isfinite(__x) __cl_isfinite(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isinf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isinf
    #define isinf(__x) __cl_isinf(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isnan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isnan
    #define isnan(__x) __cl_isnan(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isnormal);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isnormal
    #define isnormal(__x) __cl_isnormal(__x)
#endif

__CLFN_IL_2FD(isordered);

__CLFN_IL_2FD(__cl_isunordered);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isunordered
    #define isunordered(__x, __y) __cl_isunordered(__x, __y)
#endif

int __OVERLOAD__ __cl_signbit( float x );
int2 __OVERLOAD__ __cl_signbit( float2 x );
int3 __OVERLOAD__ __cl_signbit( float3 x );
int4 __OVERLOAD__ __cl_signbit( float4 x );
int8 __OVERLOAD__ __cl_signbit( float8 x );
int16 __OVERLOAD__ __cl_signbit( float16 x );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
int __OVERLOAD__ __cl_signbit( double x );
#endif
long2 __OVERLOAD__ __cl_signbit( double2 x );
long3 __OVERLOAD__ __cl_signbit( double3 x );
long4 __OVERLOAD__ __cl_signbit( double4 x );
long8 __OVERLOAD__ __cl_signbit( double8 x );
long16 __OVERLOAD__ __cl_signbit( double16 x );
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef signbit
    #define signbit(__x) __cl_signbit(__x)
#endif

__CLFN_I_ALL(any);
__CLFN_I_ALL(all);

char __OVERLOAD__ select( char x, char y, char m );
uchar __OVERLOAD__ select( uchar x, uchar y, char m );
short __OVERLOAD__ select( short x, short y, short m );
ushort __OVERLOAD__ select( ushort x, ushort y, short m );
int __OVERLOAD__ select( int x, int y, int m );
uint __OVERLOAD__ select( uint x, uint y, int m );
long __OVERLOAD__ select( long x, long y, long m );
ulong __OVERLOAD__ select( ulong x, ulong y, long m );
char __OVERLOAD__ select( char x, char y, uchar m );
uchar __OVERLOAD__ select( uchar x, uchar y, uchar m );
short __OVERLOAD__ select( short x, short y, ushort m );
ushort __OVERLOAD__ select( ushort x, ushort y, ushort m );
int __OVERLOAD__ select( int x, int y, uint m );
uint __OVERLOAD__ select( uint x, uint y, uint m );
long __OVERLOAD__ select( long x, long y, ulong m );
ulong __OVERLOAD__ select( ulong x, ulong y, ulong m );
float __OVERLOAD__ select( float x, float y, int m );
float __OVERLOAD__ select( float x, float y, uint m );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ select( double x, double y, long m );
double __OVERLOAD__ select( double x, double y, ulong m );
#endif
char2 __OVERLOAD__ select( char2 x, char2 y, char2 m );
char3 __OVERLOAD__ select( char3 x, char3 y, char3 m );
char4 __OVERLOAD__ select( char4 x, char4 y, char4 m );
char8 __OVERLOAD__ select( char8 x, char8 y, char8 m );
char16 __OVERLOAD__ select( char16 vx, char16 vy, char16 vm );
uchar2 __OVERLOAD__ select( uchar2 x, uchar2 y, char2 m );
uchar3 __OVERLOAD__ select( uchar3 x, uchar3 y, char3 m );
uchar4 __OVERLOAD__ select( uchar4 x, uchar4 y, char4 m );
uchar8 __OVERLOAD__ select( uchar8 x, uchar8 y, char8 m );
uchar16 __OVERLOAD__ select( uchar16 vx, uchar16 vy, char16 vm );
char2 __OVERLOAD__ select( char2 x, char2 y, uchar2 m );
char3 __OVERLOAD__ select( char3 x, char3 y, uchar3 m );
char4 __OVERLOAD__ select( char4 x, char4 y, uchar4 m );
char8 __OVERLOAD__ select( char8 x, char8 y, uchar8 m );
char16 __OVERLOAD__ select( char16 x, char16 y, uchar16 m );
uchar2 __OVERLOAD__ select( uchar2 x, uchar2 y, uchar2 m );
uchar3 __OVERLOAD__ select( uchar3 x, uchar3 y, uchar3 m );
uchar4 __OVERLOAD__ select( uchar4 x, uchar4 y, uchar4 m );
uchar8 __OVERLOAD__ select( uchar8 x, uchar8 y, uchar8 m );
uchar16 __OVERLOAD__ select( uchar16 x, uchar16 y, uchar16 m );
short2 __OVERLOAD__ select( short2 x, short2 y, short2 m );
short3 __OVERLOAD__ select( short3 x, short3 y, short3 m );
short4 __OVERLOAD__ select( short4 x, short4 y, short4 m );
short8 __OVERLOAD__ select( short8 vx, short8 vy, short8 vm );
short16 __OVERLOAD__ select( short16 vx, short16 vy, short16 vm );
ushort2 __OVERLOAD__ select( ushort2 x, ushort2 y, short2 m );
ushort3 __OVERLOAD__ select( ushort3 x, ushort3 y, short3 m );
ushort4 __OVERLOAD__ select( ushort4 x, ushort4 y, short4 m );
ushort8 __OVERLOAD__ select( ushort8 vx, ushort8 vy, short8 vm );
ushort16 __OVERLOAD__ select( ushort16 vx, ushort16 vy, short16 vm );
short2 __OVERLOAD__ select( short2 x, short2 y, ushort2 m );
short3 __OVERLOAD__ select( short3 x, short3 y, ushort3 m );
short4 __OVERLOAD__ select( short4 x, short4 y, ushort4 m );
short8 __OVERLOAD__ select( short8 x, short8 y, ushort8 m );
short16 __OVERLOAD__ select( short16 x, short16 y, ushort16 m );
ushort2 __OVERLOAD__ select( ushort2 x, ushort2 y, ushort2 m );
ushort3 __OVERLOAD__ select( ushort3 x, ushort3 y, ushort3 m );
ushort4 __OVERLOAD__ select( ushort4 x, ushort4 y, ushort4 m );
ushort8 __OVERLOAD__ select( ushort8 x, ushort8 y, ushort8 m );
ushort16 __OVERLOAD__ select( ushort16 x, ushort16 y, ushort16 m );
int2 __OVERLOAD__ select( int2 x, int2 y, int2 m );
int3 __OVERLOAD__ select( int3 x, int3 y, int3 m );
int4 __OVERLOAD__ select( int4 vx, int4 vy, int4 vm );
int8 __OVERLOAD__ select( int8 vx, int8 vy, int8 vm );
int16 __OVERLOAD__ select( int16 vx, int16 vy, int16 vm );
uint2 __OVERLOAD__ select( uint2 x, uint2 y, int2 m );
uint3 __OVERLOAD__ select( uint3 x, uint3 y, int3 m );
uint4 __OVERLOAD__ select( uint4 x, uint4 y, int4 m );
uint8 __OVERLOAD__ select( uint8 x, uint8 y, int8 m );
uint16 __OVERLOAD__ select( uint16 x, uint16 y, int16 m );
int2 __OVERLOAD__ select( int2 x, int2 y, uint2 m );
int3 __OVERLOAD__ select( int3 x, int3 y, uint3 m );
int4 __OVERLOAD__ select( int4 x, int4 y, uint4 m );
int8 __OVERLOAD__ select( int8 x, int8 y, uint8 m );
int16 __OVERLOAD__ select( int16 x, int16 y, uint16 m );
uint2 __OVERLOAD__ select( uint2 x, uint2 y, uint2 m );
uint3 __OVERLOAD__ select( uint3 x, uint3 y, uint3 m );
uint4 __OVERLOAD__ select( uint4 x, uint4 y, uint4 m );
uint8 __OVERLOAD__ select( uint8 x, uint8 y, uint8 m );
uint16 __OVERLOAD__ select( uint16 x, uint16 y, uint16 m );
long2 __OVERLOAD__ select( long2 x, long2 y, long2 m );
long3 __OVERLOAD__ select( long3 x, long3 y, long3 m );
long4 __OVERLOAD__ select( long4 x, long4 y, long4 m );
long8 __OVERLOAD__ select( long8 x, long8 y, long8 m );
long16 __OVERLOAD__ select( long16 x, long16 y, long16 m );
ulong2 __OVERLOAD__ select( ulong2 x, ulong2 y, long2 m );
ulong3 __OVERLOAD__ select( ulong3 x, ulong3 y, long3 m );
ulong4 __OVERLOAD__ select( ulong4 x, ulong4 y, long4 m );
ulong8 __OVERLOAD__ select( ulong8 x, ulong8 y, long8 m );
ulong16 __OVERLOAD__ select( ulong16 x, ulong16 y, long16 m );
long2 __OVERLOAD__ select( long2 x, long2 y, ulong2 m );
long3 __OVERLOAD__ select( long3 x, long3 y, ulong3 m );
long4 __OVERLOAD__ select( long4 x, long4 y, ulong4 m );
long8 __OVERLOAD__ select( long8 x, long8 y, ulong8 m );
long16 __OVERLOAD__ select( long16 x, long16 y, ulong16 m );
ulong2 __OVERLOAD__ select( ulong2 x, ulong2 y, ulong2 m );
ulong3 __OVERLOAD__ select( ulong3 x, ulong3 y, ulong3 m );
ulong4 __OVERLOAD__ select( ulong4 x, ulong4 y, ulong4 m );
ulong8 __OVERLOAD__ select( ulong8 x, ulong8 y, ulong8 m );
ulong16 __OVERLOAD__ select( ulong16 x, ulong16 y, ulong16 m );
float2 __OVERLOAD__ select( float2 x, float2 y, int2 m );
float3 __OVERLOAD__ select(float3 x, float3 y, __int3_SPI z);
float4 __OVERLOAD__ select( float4 x, float4 y, int4 m );
float8 __OVERLOAD__ select( float8 x, float8 y, int8 m );
float16 __OVERLOAD__ select( float16 x, float16 y, int16 m );
float2 __OVERLOAD__ select( float2 x, float2 y, uint2 m );
float3 __OVERLOAD__ select( float3 x, float3 y, uint3 m );
float4 __OVERLOAD__ select( float4 x, float4 y, uint4 m );
float8 __OVERLOAD__ select( float8 x, float8 y, uint8 m );
float16 __OVERLOAD__ select( float16 x, float16 y, uint16 m );
double2 __OVERLOAD__ select( double2 x, double2 y, long2 m ) ;
double3 __OVERLOAD__ select( double3 x, double3 y, long3 m ) ;
double4 __OVERLOAD__ select( double4 x, double4 y, long4 m ) ;
double8 __OVERLOAD__ select( double8 x, double8 y, long8 m ) ;
double16 __OVERLOAD__ select( double16 x, double16 y, long16 m ) ;
double2 __OVERLOAD__ select( double2 x, double2 y, ulong2 m ) ;
double3 __OVERLOAD__ select( double3 x, double3 y, ulong3 m ) ;
double4 __OVERLOAD__ select( double4 x, double4 y, ulong4 m ) ;
double8 __OVERLOAD__ select( double8 x, double8 y, ulong8 m ) ;
double16 __OVERLOAD__ select( double16 x, double16 y, ulong16 m ) ;

char __OVERLOAD__ bitselect( char x, char y, char m);
char2 __OVERLOAD__ bitselect( char2 x, char2 y, char2 m);
char3 __OVERLOAD__ bitselect( char3 x, char3 y, char3 m);
char4 __OVERLOAD__ bitselect( char4 x, char4 y, char4 m);
char8 __OVERLOAD__ bitselect( char8 x, char8 y, char8 m);
char16 __OVERLOAD__ bitselect( char16 x, char16 y, char16 m);
uchar __OVERLOAD__ bitselect( uchar x, uchar y, char m);
uchar2 __OVERLOAD__ bitselect( uchar2 x, uchar2 y, char2 m);
uchar3 __OVERLOAD__ bitselect( uchar3 x, uchar3 y, char3 m);
uchar4 __OVERLOAD__ bitselect( uchar4 x, uchar4 y, char4 m);
uchar8 __OVERLOAD__ bitselect( uchar8 x, uchar8 y, char8 m);
uchar16 __OVERLOAD__ bitselect( uchar16 x, uchar16 y, char16 m);
short __OVERLOAD__ bitselect( short x, short y, short m);
short2 __OVERLOAD__ bitselect( short2 x, short2 y, short2 m);
short3 __OVERLOAD__ bitselect( short3 x, short3 y, short3 m);
short4 __OVERLOAD__ bitselect( short4 x, short4 y, short4 m);
short8 __OVERLOAD__ bitselect( short8 x, short8 y, short8 m);
short16 __OVERLOAD__ bitselect( short16 x, short16 y, short16 m);
ushort __OVERLOAD__ bitselect( ushort x, ushort y, short m);
ushort2 __OVERLOAD__ bitselect( ushort2 x, ushort2 y, short2 m);
ushort3 __OVERLOAD__ bitselect( ushort3 x, ushort3 y, short3 m);
ushort4 __OVERLOAD__ bitselect( ushort4 x, ushort4 y, short4 m);
ushort8 __OVERLOAD__ bitselect( ushort8 x, ushort8 y, short8 m);
ushort16 __OVERLOAD__ bitselect( ushort16 x, ushort16 y, short16 m);
int __OVERLOAD__ bitselect( int x, int y, int m);
int2 __OVERLOAD__ bitselect( int2 x, int2 y, int2 m);
int3 __OVERLOAD__ bitselect( int3 x, int3 y, int3 m);
int4 __OVERLOAD__ bitselect( int4 x, int4 y, int4 m);
int8 __OVERLOAD__ bitselect( int8 x, int8 y, int8 m);
int16 __OVERLOAD__ bitselect( int16 x, int16 y, int16 m);
uint __OVERLOAD__ bitselect( uint x, uint y, int m);
uint2 __OVERLOAD__ bitselect( uint2 x, uint2 y, int2 m);
uint3 __OVERLOAD__ bitselect( uint3 x, uint3 y, int3 m);
uint4 __OVERLOAD__ bitselect( uint4 x, uint4 y, int4 m);
uint8 __OVERLOAD__ bitselect( uint8 x, uint8 y, int8 m);
uint16 __OVERLOAD__ bitselect( uint16 x, uint16 y, int16 m);
long __OVERLOAD__ bitselect( long x, long y, long m);
long2 __OVERLOAD__ bitselect( long2 x, long2 y, long2 m);
long3 __OVERLOAD__ bitselect( long3 x, long3 y, long3 m);
long4 __OVERLOAD__ bitselect( long4 x, long4 y, long4 m);
long8 __OVERLOAD__ bitselect( long8 x, long8 y, long8 m);
long16 __OVERLOAD__ bitselect( long16 x, long16 y, long16 m);
ulong __OVERLOAD__ bitselect( ulong x, ulong y, long m);
ulong2 __OVERLOAD__ bitselect( ulong2 x, ulong2 y, long2 m);
ulong3 __OVERLOAD__ bitselect( ulong3 x, ulong3 y, long3 m);
ulong4 __OVERLOAD__ bitselect( ulong4 x, ulong4 y, long4 m);
ulong8 __OVERLOAD__ bitselect( ulong8 x, ulong8 y, long8 m);
ulong16 __OVERLOAD__ bitselect( ulong16 x, ulong16 y, long16 m);
char __OVERLOAD__ bitselect( char x, char y, uchar m);
char2 __OVERLOAD__ bitselect( char2 x, char2 y, uchar2 m);
char3 __OVERLOAD__ bitselect( char3 x, char3 y, uchar3 m);
char4 __OVERLOAD__ bitselect( char4 x, char4 y, uchar4 m);
char8 __OVERLOAD__ bitselect( char8 x, char8 y, uchar8 m);
char16 __OVERLOAD__ bitselect( char16 x, char16 y, uchar16 m);
uchar __OVERLOAD__ bitselect( uchar x, uchar y, uchar m);
uchar2 __OVERLOAD__ bitselect( uchar2 x, uchar2 y, uchar2 m);
uchar3 __OVERLOAD__ bitselect( uchar3 x, uchar3 y, uchar3 m);
uchar4 __OVERLOAD__ bitselect( uchar4 x, uchar4 y, uchar4 m);
uchar8 __OVERLOAD__ bitselect( uchar8 x, uchar8 y, uchar8 m);
uchar16 __OVERLOAD__ bitselect( uchar16 x, uchar16 y, uchar16 m);
short __OVERLOAD__ bitselect( short x, short y, ushort m);
short2 __OVERLOAD__ bitselect( short2 x, short2 y, ushort2 m);
short3 __OVERLOAD__ bitselect( short3 x, short3 y, ushort3 m);
short4 __OVERLOAD__ bitselect( short4 x, short4 y, ushort4 m);
short8 __OVERLOAD__ bitselect( short8 x, short8 y, ushort8 m);
short16 __OVERLOAD__ bitselect( short16 x, short16 y, ushort16 m);
ushort __OVERLOAD__ bitselect( ushort x, ushort y, ushort m);
ushort2 __OVERLOAD__ bitselect( ushort2 x, ushort2 y, ushort2 m);
ushort3 __OVERLOAD__ bitselect( ushort3 x, ushort3 y, ushort3 m);
ushort4 __OVERLOAD__ bitselect( ushort4 x, ushort4 y, ushort4 m);
ushort8 __OVERLOAD__ bitselect( ushort8 x, ushort8 y, ushort8 m);
ushort16 __OVERLOAD__ bitselect( ushort16 x, ushort16 y, ushort16 m);
int __OVERLOAD__ bitselect( int x, int y, uint m);
int2 __OVERLOAD__ bitselect( int2 x, int2 y, uint2 m);
int3 __OVERLOAD__ bitselect( int3 x, int3 y, uint3 m);
int4 __OVERLOAD__ bitselect( int4 x, int4 y, uint4 m);
int8 __OVERLOAD__ bitselect( int8 x, int8 y, uint8 m);
int16 __OVERLOAD__ bitselect( int16 x, int16 y, uint16 m);
uint __OVERLOAD__ bitselect( uint x, uint y, uint m);
uint2 __OVERLOAD__ bitselect( uint2 x, uint2 y, uint2 m);
uint3 __OVERLOAD__ bitselect( uint3 x, uint3 y, uint3 m);
uint4 __OVERLOAD__ bitselect( uint4 x, uint4 y, uint4 m);
uint8 __OVERLOAD__ bitselect( uint8 x, uint8 y, uint8 m);
uint16 __OVERLOAD__ bitselect( uint16 x, uint16 y, uint16 m);
long __OVERLOAD__ bitselect( long x, long y, ulong m);
long2 __OVERLOAD__ bitselect( long2 x, long2 y, ulong2 m);
long3 __OVERLOAD__ bitselect( long3 x, long3 y, ulong3 m);
long4 __OVERLOAD__ bitselect( long4 x, long4 y, ulong4 m);
long8 __OVERLOAD__ bitselect( long8 x, long8 y, ulong8 m);
long16 __OVERLOAD__ bitselect( long16 x, long16 y, ulong16 m);
ulong __OVERLOAD__ bitselect( ulong x, ulong y, ulong m);
ulong2 __OVERLOAD__ bitselect( ulong2 x, ulong2 y, ulong2 m);
ulong3 __OVERLOAD__ bitselect( ulong3 x, ulong3 y, ulong3 m);
ulong4 __OVERLOAD__ bitselect( ulong4 x, ulong4 y, ulong4 m);
ulong8 __OVERLOAD__ bitselect( ulong8 x, ulong8 y, ulong8 m);
ulong16 __OVERLOAD__ bitselect( ulong16 x, ulong16 y, ulong16 m);
float __OVERLOAD__ bitselect( float x, float y, float m);
float2 __OVERLOAD__ bitselect( float2 x, float2 y, float2 m);
float3 __OVERLOAD__ bitselect( float3 x, float3 y, float3 m);
float4 __OVERLOAD__ bitselect( float4 x, float4 y, float4 m);
float8 __OVERLOAD__ bitselect( float8 x, float8 y, float8 m);
float16 __OVERLOAD__ bitselect( float16 x, float16 y, float16 m);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ bitselect( double x, double y, double m);
#endif
double2 __OVERLOAD__ bitselect( double2 x, double2 y, double2 m);
double3 __OVERLOAD__ bitselect( double3 x, double3 y, double3 m);
double4 __OVERLOAD__ bitselect( double4 x, double4 y, double4 m);
double8 __OVERLOAD__ bitselect( double8 x, double8 y, double8 m);
double16 __OVERLOAD__ bitselect( double16 x, double16 y, double16 m);


// Include shared types that have to be visible both here and in the framework
#include "cl_kernel_shared.h"

// image format description
typedef struct _cl_image_format_t {
  unsigned int num_channels;
  unsigned int channel_order;
  unsigned int channel_data_type;
} cl_image_format_t;

typedef __global struct  _image1d_t        *image1d_t;
typedef __global struct  _image2d_t        *image2d_t;
typedef __global struct  _image3d_t        *image3d_t;

typedef __global struct  _image1d_array_t  *image1d_array_t;
typedef __global struct  _image2d_array_t  *image2d_array_t;

typedef __global struct  _image1d_buffer_t *image1d_buffer_t;

typedef __global struct  _image2d_depth_t       *image2d_depth_t;
typedef __global struct  _image2d_array_depth_t *image2d_array_depth_t;
typedef __global struct  _image2d_msaa_t        *image2d_msaa_t;
typedef __global struct  _image2d_array_msaa_t  *image2d_array_msaa_t;
typedef __global struct  _image2d_msaa_depth_t  *image2d_msaa_depth_t;
typedef __global struct  _image2d_array_msaa_depth_t *image2d_array_msaa_depth_t;

// 5.8.4 - Image Stream Read and Write

// 1D
float4 __OVERLOAD__ read_imagef(image1d_t image, sampler_t sampler, int coord);
float4 __OVERLOAD__ read_imagef(image1d_t image, sampler_t sampler, float coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, sampler_t sampler, int coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, sampler_t sampler, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, sampler_t sampler, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, sampler_t sampler, float coord);

// 2D
float4 __OVERLOAD__ read_imagef(image2d_t image, sampler_t sampler, int2 coord);
float4 __OVERLOAD__ read_imagef(image2d_t image, sampler_t sampler, float2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, sampler_t sampler, int2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, sampler_t sampler, float2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, sampler_t sampler, int2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, sampler_t sampler, float2 coord);
float4 __OVERLOAD__ read_gradient_imagef( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);
int4   __OVERLOAD__ read_gradient_imagei( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);
uint4  __OVERLOAD__ read_gradient_imageui( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);

// 3D
float4 __OVERLOAD__ read_imagef(image3d_t image, sampler_t sampler, int4 coord);
float4 __OVERLOAD__ read_imagef(image3d_t image, sampler_t sampler, float4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, sampler_t sampler, int4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, sampler_t sampler, float4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, sampler_t sampler, int4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, sampler_t sampler, float4 coord);
float4 __OVERLOAD__ read_gradient_imagef( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);
int4   __OVERLOAD__ read_gradient_imagei( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);
uint4  __OVERLOAD__ read_gradient_imageui( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);

// 1D array
float4 __OVERLOAD__ read_imagef(image1d_array_t image, sampler_t sampler, int2 coord);
float4 __OVERLOAD__ read_imagef(image1d_array_t image, sampler_t sampler, float2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, sampler_t sampler, int2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, sampler_t sampler, float2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, sampler_t sampler, int2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, sampler_t sampler, float2 coord);

// 2D array
float4 __OVERLOAD__ read_imagef(image2d_array_t image, sampler_t sampler, int4 coord);
float4 __OVERLOAD__ read_imagef(image2d_array_t image, sampler_t sampler, float4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, sampler_t sampler, int4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, sampler_t sampler, float4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, sampler_t sampler, int4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, sampler_t sampler, float4 coord);

// Depth image and depth image array
float __OVERLOAD__ read_imagef(image2d_depth_t image, sampler_t sampler, float2 coord);
float __OVERLOAD__ read_imagef(image2d_depth_t image, sampler_t sampler, int2 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, sampler_t sampler, float4 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, sampler_t sampler, int4 coord);

// MSAA textures
float4 __OVERLOAD__ read_imagef(image2d_msaa_t image, int2 coord, int sample);
int4   __OVERLOAD__ read_imagei(image2d_msaa_t image, int2 coord, int sample);
uint4  __OVERLOAD__ read_imageui(image2d_msaa_t image, int2 coord, int sample);

float  __OVERLOAD__ read_imagef(image2d_msaa_depth_t image, int2 coord, int sample);

float4 __OVERLOAD__ read_imagef(image2d_array_msaa_t image, int4 coord, int sample);
int4   __OVERLOAD__ read_imagei(image2d_array_msaa_t image, int4 coord, int sample);
uint4  __OVERLOAD__ read_imageui(image2d_array_msaa_t image, int4 coord, int sample);

float  __OVERLOAD__ read_imagef(image2d_array_msaa_depth_t image, int4 coord, int sample);

void __OVERLOAD__ write_imagef(image1d_t image, int coord, float4 color);
void __OVERLOAD__ write_imagef(image1d_buffer_t image, int coord, float4 color);
void __OVERLOAD__ write_imagef(image2d_t image, int2 coord, float4 color);
void __OVERLOAD__ write_imagef(image3d_t image, int4 coord, float4 color);
void __OVERLOAD__ write_imagef(image1d_array_t image, int2 coord, float4 color);
void __OVERLOAD__ write_imagef(image2d_array_t image, int4 coord, float4 color);

// Depth image and depth image array
void __OVERLOAD__ write_imagef(image2d_depth_t image, int2 coord, float color);
void __OVERLOAD__ write_imagef(image2d_array_depth_t image, int4 coord, float color);

void __OVERLOAD__ write_imagei(image1d_t image, int  coord, int4 color);
void __OVERLOAD__ write_imagei(image1d_buffer_t image, int coord, int4 color);
void __OVERLOAD__ write_imagei(image2d_t image, int2 coord, int4 color);
void __OVERLOAD__ write_imagei(image3d_t image, int4 coord, int4 color);
void __OVERLOAD__ write_imagei(image1d_array_t image, int2 coord, int4 color);
void __OVERLOAD__ write_imagei(image2d_array_t image, int4 coord, int4 color);

void __OVERLOAD__ write_imageui(image1d_t image, int coord, uint4 val);
void __OVERLOAD__ write_imageui(image1d_buffer_t image, int coord, uint4 color);
void __OVERLOAD__ write_imageui(image2d_t image, int2 coord, uint4 val);
void __OVERLOAD__ write_imageui(image3d_t image, int4 coord, uint4 val);
void __OVERLOAD__ write_imageui(image1d_array_t image, int2 coord, uint4 color);
void __OVERLOAD__ write_imageui(image2d_array_t image, int4 coord, uint4 color);

void __write_imagef_2d_unorm_int8_rgba_apple_SPI(image2d_t image, int2 coord, float4 val);
void __write_imagef_2d_unorm_int8_bgra_apple_SPI(image2d_t image, int2 coord, float4 val); 
#define write_imagef_unorm_int8_rgba_apple_SPI(_image, _coord, _val) __write_imagef_2d_unorm_int8_rgba_apple_SPI(_image, _coord, _val)
#define write_imagef_unorm_int8_bgra_apple_SPI(_image, _coord, _val) __write_imagef_2d_unorm_int8_bgra_apple_SPI(_image, _coord, _val)

// Sampler-less Reads
// 1D
float4 __OVERLOAD__ read_imagef(image1d_t image, int coord);
float4 __OVERLOAD__ read_imagef(image1d_t image, float coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, int coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, float coord);

// 2D
float4 __OVERLOAD__ read_imagef(image2d_t image, int2 coord);
float4 __OVERLOAD__ read_imagef(image2d_t image, float2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, int2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, float2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, int2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, float2 coord);

// 3D
float4 __OVERLOAD__ read_imagef(image3d_t image, int4 coord);
float4 __OVERLOAD__ read_imagef(image3d_t image, float4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, int4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, float4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, int4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, float4 coord);

// 1D buffer
float4 __OVERLOAD__ read_imagef(image1d_buffer_t image, int coord);
float4 __OVERLOAD__ read_imagef(image1d_buffer_t image, float coord);
int4   __OVERLOAD__ read_imagei(image1d_buffer_t image, int coord);
int4   __OVERLOAD__ read_imagei(image1d_buffer_t image, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_buffer_t image, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_buffer_t image, float coord);

// 1D array
float4 __OVERLOAD__ read_imagef(image1d_array_t image, int2 coord);
float4 __OVERLOAD__ read_imagef(image1d_array_t image, float2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, int2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, float2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, int2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, float2 coord);

// 2D array
float4 __OVERLOAD__ read_imagef(image2d_array_t image, int4 coord);
float4 __OVERLOAD__ read_imagef(image2d_array_t image, float4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, int4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, float4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, int4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, float4 coord);

// Depth image and depth image array
float __OVERLOAD__ read_imagef(image2d_depth_t image, int2 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, int4 coord);

int __OVERLOAD__ get_image_width(image1d_t img);
int __OVERLOAD__ get_image_width(image2d_t img);
int __OVERLOAD__ get_image_width(image3d_t img);
int __OVERLOAD__ get_image_width(image1d_array_t img);
int __OVERLOAD__ get_image_width(image2d_array_t img);
int __OVERLOAD__ get_image_width(image2d_depth_t img);
int __OVERLOAD__ get_image_width(image2d_array_depth_t img);
int __OVERLOAD__ get_image_width(image2d_msaa_t img);
int __OVERLOAD__ get_image_width(image2d_array_msaa_t img);
int __OVERLOAD__ get_image_width(image2d_msaa_depth_t img);
int __OVERLOAD__ get_image_width(image2d_array_msaa_depth_t img);

int __OVERLOAD__ get_image_height(image2d_t img);
int __OVERLOAD__ get_image_height(image3d_t img);
int __OVERLOAD__ get_image_height(image2d_array_t img);
int __OVERLOAD__ get_image_height(image2d_depth_t img);
int __OVERLOAD__ get_image_height(image2d_array_depth_t img);
int __OVERLOAD__ get_image_height(image2d_msaa_t img);
int __OVERLOAD__ get_image_height(image2d_array_msaa_t img);
int __OVERLOAD__ get_image_height(image2d_msaa_depth_t img);
int __OVERLOAD__ get_image_height(image2d_array_msaa_depth_t img);

int __OVERLOAD__ get_image_depth(image3d_t img);

int __OVERLOAD__ get_image_channel_data_type(image1d_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_t image);
int __OVERLOAD__ get_image_channel_data_type(image3d_t image);
int __OVERLOAD__ get_image_channel_data_type(image1d_array_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_msaa_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_msaa_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_msaa_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_msaa_depth_t image);

int __OVERLOAD__ get_image_channel_order(image1d_t image);
int __OVERLOAD__ get_image_channel_order(image2d_t image);
int __OVERLOAD__ get_image_channel_order(image3d_t image);
int __OVERLOAD__ get_image_channel_order(image1d_array_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_t image);
int __OVERLOAD__ get_image_channel_order(image2d_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_msaa_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_msaa_t image);
int __OVERLOAD__ get_image_channel_order(image2d_msaa_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_msaa_depth_t image);

int2 __OVERLOAD__ get_image_dim(image2d_t image);
int4 __OVERLOAD__ get_image_dim(image3d_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_t image);
int2 __OVERLOAD__ get_image_dim(image2d_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_msaa_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_msaa_t image);
int2 __OVERLOAD__ get_image_dim(image2d_msaa_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_msaa_depth_t image);

size_t __OVERLOAD__ get_image_array_size(image1d_array_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_depth_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_msaa_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_msaa_depth_t image);

// MSAA textures
int __OVERLOAD__ get_image_num_samples(image2d_msaa_t image);
int __OVERLOAD__ get_image_num_samples(image2d_array_msaa_depth_t image);

int __OVERLOAD__ get_image_num_miplevels(image2d_t image);
int __OVERLOAD__ get_image_num_miplevels(image3d_t image);

#if defined( __i386__ ) || defined( __x86_64__ )
// SPI for CoreImage
void __OVERLOAD__ __read_transposed_imagef_resample( __rd image2d_t src, sampler_t smp, float4 x,float4 y, float4 *r, float4 *g, float4 *b, float4 *a);
void __OVERLOAD__ __read_transposed_imagef_resample( __rd image2d_t src, sampler_t smp, float8 x,float8 y, float8 *r, float8 *g, float8 *b, float8 *a);
#define read_transposed_imagef( _src, _smp, _x, _y, _r, _g, _b, _a )   __read_transposed_imagef_resample(_src, _smp, _x, _y, _r, _g, _b, _a )
void __OVERLOAD__ __read_direct_imagef_resample( __rd image2d_t src, sampler_t smp, float4 x,float4 y, float16 *dest);
void __OVERLOAD__ __read_direct_imagef_resample( __rd image2d_t src, sampler_t smp, float8 x,float8 y, float32 *dest);


void __OVERLOAD__ __read_transposed_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float4 x,float4 y, float4 z, float4 *r,float4 *g,float4 *b,float4 *a);
void __OVERLOAD__ __read_transposed_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float8 x,float8 y, float8 z, float8 *r,float8 *g,float8 *b,float8 *a);
#define read_transposed_3d_imagef( _src, _smp, _x, _y, _z, _r, _g, _b, _a )     __read_transposed_imagef_resample( _src, _smp, _x, _y, _z, _r, _g, _b, _a )
void __OVERLOAD__ __read_direct_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float4 x,float4 y, float4 z, float16 *dest );

void __OVERLOAD__ write_transposed_imagef( __wr image2d_t dst, int x, int y, float4 r, float4 g, float4 b, float4 a);
void __OVERLOAD__ write_transposed_imagef( __wr image2d_t dst, int x, int y, float8 r, float8 g, float8 b, float8 a);
void __OVERLOAD__ write_direct_imagef( __wr image2d_t dst, int x, int y, float16 v );
void __OVERLOAD__ write_direct_imagef( __wr image2d_t dst, int x, int y, float32 v );

event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __global float4 *r, const __global float4 *g, 
                                                    const __global float4 *b, const __global float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __constant float4 *r, const __constant float4 *g, 
                                                    const __constant float4 *b, const __constant float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __private float4 *r, const __private float4 *g, 
                                                    const __private float4 *b, const __private float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __local float4 *r, const __local float4 *g, 
                                                    const __local float4 *b, const __local float4 *a );

event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __global float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __constant float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __private float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __local float4 *src );

                   
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __private float4 *r,  __private float4 *g,  __private float4 *b,  __private float4 *a );
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __global float4 *r,  __global float4 *g,  __global float4 *b,  __global float4 *a );
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __local float4 *r,  __local float4 *g,  __local float4 *b,  __local float4 *a );

event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __private float4 *dest );
event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __global float4 *dest );
event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __local float4 *dest );


float16  __ci_gamma_SPI( float4 r, float4 g, float4 b, float4 y );
float32  __ci_gamma8_SPI( float8 r, float8 g, float8 b, float8 y );
void     __ci_gamma_SPI_8( float8 r, float8 g, float8 b, float8 y, float8 *outR, float8 *outG, float8 *outB ); 
float3  __ci_gamma_scalar_SPI( float3 rgb, float y );
#endif

__CLFN_EVENT_ALL(async_work_group_copy);
__CLFN_EVENT_ALL4(async_work_group_strided_copy);

void wait_group_events( int, event_t* );

void __OVERLOAD__  prefetch(const __global char* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar* p, size_t n);
void __OVERLOAD__  prefetch(const __global short* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort* p, size_t n);
void __OVERLOAD__  prefetch(const __global int* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint* p, size_t n);
void __OVERLOAD__  prefetch(const __global long* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong* p, size_t n);
void __OVERLOAD__  prefetch(const __global float* p, size_t n);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__  prefetch(const __global double* p, size_t n);
#endif
void __OVERLOAD__  prefetch(const __global char2* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar2* p, size_t n);
void __OVERLOAD__  prefetch(const __global short2* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort2* p, size_t n);
void __OVERLOAD__  prefetch(const __global int2* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint2* p, size_t n);
void __OVERLOAD__  prefetch(const __global long2* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong2* p, size_t n);
void __OVERLOAD__  prefetch(const __global float2* p, size_t n);
void __OVERLOAD__  prefetch(const __global double2* p, size_t n);
void __OVERLOAD__  prefetch(const __global char4* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar4* p, size_t n);
void __OVERLOAD__  prefetch(const __global short4* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort4* p, size_t n);
void __OVERLOAD__  prefetch(const __global int4* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint4* p, size_t n);
void __OVERLOAD__  prefetch(const __global long4* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong4* p, size_t n);
void __OVERLOAD__  prefetch(const __global float4* p, size_t n);
void __OVERLOAD__  prefetch(const __global double4* p, size_t n);
void __OVERLOAD__  prefetch(const __global char8* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar8* p, size_t n);
void __OVERLOAD__  prefetch(const __global short8* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort8* p, size_t n);
void __OVERLOAD__  prefetch(const __global int8* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint8* p, size_t n);
void __OVERLOAD__  prefetch(const __global long8* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong8* p, size_t n);
void __OVERLOAD__  prefetch(const __global float8* p, size_t n);
void __OVERLOAD__  prefetch(const __global double8* p, size_t n);
void __OVERLOAD__  prefetch(const __global char16* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar16* p, size_t n);
void __OVERLOAD__  prefetch(const __global short16* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort16* p, size_t n);
void __OVERLOAD__  prefetch(const __global int16* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint16* p, size_t n);
void __OVERLOAD__  prefetch(const __global long16* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong16* p, size_t n);
void __OVERLOAD__  prefetch(const __global float16* p, size_t n);
void __OVERLOAD__  prefetch(const __global double16* p, size_t n);

// 5.9.7 - Synchronization
typedef enum {
  CLK_LOCAL_MEM_FENCE  = 1U << 0,
  CLK_GLOBAL_MEM_FENCE = 1U << 1,
  __unused_except_to_make_sure_the_enum_has_the_right_size = 1U << 31
} cl_mem_fence_flags;

void barrier(cl_mem_fence_flags);
void mem_fence(cl_mem_fence_flags);
void read_mem_fence(cl_mem_fence_flags);
void write_mem_fence(cl_mem_fence_flags);

// 5.9.9 - Atomic Functions
int __OVERLOAD__  atom_add(volatile __global int *p, int val);
int __OVERLOAD__  atom_sub(volatile __global int *p, int val);
int __OVERLOAD__ atom_xchg(volatile __global int *p, int val);
int __OVERLOAD__ atom_min(volatile __global int *p, int val);
int __OVERLOAD__ atom_max(volatile __global int *p, int val);
int __OVERLOAD__ atom_inc(volatile __global int *p);
int __OVERLOAD__ atom_dec(volatile __global int *p);
int __OVERLOAD__ atom_cmpxchg(volatile __global int *p, int cmp, int val);
int __OVERLOAD__ atom_and(volatile __global int *p, int val);
int __OVERLOAD__ atom_or(volatile __global int *p, int val);
int __OVERLOAD__ atom_xor(volatile __global int *p, int val);

unsigned __OVERLOAD__  atom_add(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__  atom_sub(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xchg(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_min(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_max(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_inc(volatile __global unsigned *p);
unsigned __OVERLOAD__ atom_dec(volatile __global unsigned *p);
unsigned __OVERLOAD__ atom_cmpxchg(volatile __global unsigned *p, unsigned cmp, unsigned val);
unsigned __OVERLOAD__ atom_and(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_or(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xor(volatile __global unsigned *p, unsigned val);

float __OVERLOAD__ atom_xchg(volatile __global float *p, float val);


int __OVERLOAD__  atom_add(volatile local int *p, int val);
int __OVERLOAD__  atom_sub(volatile local int *p, int val);
int __OVERLOAD__ atom_xchg(volatile local int *p, int val);
int __OVERLOAD__ atom_min(volatile local int *p, int val);
int __OVERLOAD__ atom_max(volatile local int *p, int val);
int __OVERLOAD__ atom_inc(volatile local int *p);
int __OVERLOAD__ atom_dec(volatile local int *p);
int __OVERLOAD__ atom_cmpxchg(volatile local int *p, int cmp, int val);
int __OVERLOAD__ atom_and(volatile local int *p, int val);
int __OVERLOAD__ atom_or(volatile local int *p, int val);
int __OVERLOAD__ atom_xor(volatile local int *p, int val);

unsigned __OVERLOAD__  atom_add(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__  atom_sub(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xchg(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_min(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_max(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_inc(volatile local unsigned *p);
unsigned __OVERLOAD__ atom_dec(volatile local unsigned *p);
unsigned __OVERLOAD__ atom_cmpxchg(volatile local unsigned *p, unsigned cmp, unsigned val);
unsigned __OVERLOAD__ atom_and(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_or(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xor(volatile local unsigned *p, unsigned val);

float __OVERLOAD__ atom_xchg(volatile local float *p, float val);


long __OVERLOAD__  atom_add(volatile __global long *p, long val);
long __OVERLOAD__  atom_sub(volatile __global long *p, long val);
long __OVERLOAD__ atom_xchg(volatile __global long *p, long val);
long __OVERLOAD__ atom_min(volatile __global long *p, long val);
long __OVERLOAD__ atom_max(volatile __global long *p, long val);
long __OVERLOAD__ atom_inc(volatile __global long *p);
long __OVERLOAD__ atom_dec(volatile __global long *p);
long __OVERLOAD__ atom_cmpxchg(volatile __global long *p, long cmp, long val);
long __OVERLOAD__ atom_and(volatile __global long *p, long val);
long __OVERLOAD__ atom_or(volatile __global long *p, long val);
long __OVERLOAD__ atom_xor(volatile __global long *p, long val);

ulong __OVERLOAD__  atom_add(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__  atom_sub(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_xchg(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_min(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_max(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_inc(volatile __global ulong *p);
ulong __OVERLOAD__ atom_dec(volatile __global ulong *p);
ulong __OVERLOAD__ atom_cmpxchg(volatile __global ulong *p, ulong cmp, ulong val);
ulong __OVERLOAD__ atom_and(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_or(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_xor(volatile __global ulong *p, ulong val);


long __OVERLOAD__  atom_add(volatile local long *p, long val);
long __OVERLOAD__  atom_sub(volatile local long *p, long val);
long __OVERLOAD__ atom_xchg(volatile local long *p, long val);
long __OVERLOAD__ atom_min(volatile local long *p, long val);
long __OVERLOAD__ atom_max(volatile local long *p, long val);
long __OVERLOAD__ atom_inc(volatile local long *p);
long __OVERLOAD__ atom_dec(volatile local long *p);
long __OVERLOAD__ atom_cmpxchg(volatile local long *p, long cmp, long val);
long __OVERLOAD__ atom_and(volatile local long *p, long val);
long __OVERLOAD__ atom_or(volatile local long *p, long val);
long __OVERLOAD__ atom_xor(volatile local long *p, long val);

ulong __OVERLOAD__  atom_add(volatile local ulong *p, ulong val);
ulong __OVERLOAD__  atom_sub(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_xchg(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_min(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_max(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_inc(volatile local ulong *p);
ulong __OVERLOAD__ atom_dec(volatile local ulong *p);
ulong __OVERLOAD__ atom_cmpxchg(volatile local ulong *p, ulong cmp, ulong val);
ulong __OVERLOAD__ atom_and(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_or(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_xor(volatile local ulong *p, ulong val);

#define atomic_add(X,Y)         atom_add((X),(Y))
#define atomic_sub(X,Y)         atom_sub((X),(Y))
#define atomic_xchg(X,Y)        atom_xchg((X),(Y))
#define atomic_min(X,Y)         atom_min((X),(Y))
#define atomic_max(X,Y)         atom_max((X),(Y))
#define atomic_inc(X)           atom_inc(X)
#define atomic_dec(X)           atom_dec(X)
#define atomic_cmpxchg(X,Y,Z)   atom_cmpxchg((X),(Y),(Z)) 
#define atomic_and(X,Y)         atom_and((X),(Y))
#define atomic_or(X,Y)          atom_or((X),(Y))
#define atomic_xor(X,Y)         atom_xor((X),(Y))

char2 __OVERLOAD__ shuffle( char2 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char2 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char2 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char2 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar2 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar2 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar2 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar2 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char4 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char4 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char4 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char4 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar4 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar4 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar4 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar4 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char8 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char8 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char8 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char8 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar8 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar8 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar8 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar8 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char16 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char16 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char16 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char16 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar16 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar16 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar16 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar16 x, uchar16 map );
short2 __OVERLOAD__ shuffle( short2 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short2 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short2 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short2 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort2 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort2 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort2 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort2 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short4 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short4 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short4 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short4 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort4 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort4 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort4 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort4 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short8 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short8 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short8 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short8 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort8 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort8 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort8 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort8 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short16 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short16 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short16 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short16 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort16 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort16 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort16 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort16 x, ushort16 map );
int2 __OVERLOAD__ shuffle( int2 x, uint2 map );
int4 __OVERLOAD__ shuffle( int2 x, uint4 map );
int8 __OVERLOAD__ shuffle( int2 x, uint8 map );
int16 __OVERLOAD__ shuffle( int2 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint2 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint2 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint2 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint2 x, uint16 map );
int2 __OVERLOAD__ shuffle( int4 x, uint2 map );
int4 __OVERLOAD__ shuffle( int4 x, uint4 map );
int8 __OVERLOAD__ shuffle( int4 x, uint8 map );
int16 __OVERLOAD__ shuffle( int4 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint4 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint4 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint4 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint4 x, uint16 map );
int2 __OVERLOAD__ shuffle( int8 x, uint2 map );
int4 __OVERLOAD__ shuffle( int8 x, uint4 map );
int8 __OVERLOAD__ shuffle( int8 x, uint8 map );
int16 __OVERLOAD__ shuffle( int8 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint8 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint8 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint8 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint8 x, uint16 map );
int2 __OVERLOAD__ shuffle( int16 x, uint2 map );
int4 __OVERLOAD__ shuffle( int16 x, uint4 map );
int8 __OVERLOAD__ shuffle( int16 x, uint8 map );
int16 __OVERLOAD__ shuffle( int16 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint16 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint16 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint16 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint16 x, uint16 map );
long2 __OVERLOAD__ shuffle( long2 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long2 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long2 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long2 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong2 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong2 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong2 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong2 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long4 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long4 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long4 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long4 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong4 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong4 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong4 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong4 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long8 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long8 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long8 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long8 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong8 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong8 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong8 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong8 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long16 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long16 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long16 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long16 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong16 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong16 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong16 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong16 x, ulong16 map );
float2  __OVERLOAD__ shuffle( float2 x, uint2 map );
float4  __OVERLOAD__ shuffle( float2 x, uint4 map );
float8  __OVERLOAD__ shuffle( float2 x, uint8 map );
float16  __OVERLOAD__ shuffle( float2 x, uint16 map );
float2  __OVERLOAD__ shuffle( float4 x, uint2 map );
float4  __OVERLOAD__ shuffle( float4 x, uint4 map );
float8  __OVERLOAD__ shuffle( float4 x, uint8 map );
float16  __OVERLOAD__ shuffle( float4 x, uint16 map );
float2  __OVERLOAD__ shuffle( float8 x, uint2 map );
float4  __OVERLOAD__ shuffle( float8 x, uint4 map );
float8  __OVERLOAD__ shuffle( float8 x, uint8 map );
float16  __OVERLOAD__ shuffle( float8 x, uint16 map );
float2  __OVERLOAD__ shuffle( float16 x, uint2 map );
float4  __OVERLOAD__ shuffle( float16 x, uint4 map );
float8  __OVERLOAD__ shuffle( float16 x, uint8 map );
float16  __OVERLOAD__ shuffle( float16 x, uint16 map );
double2  __OVERLOAD__ shuffle( double2 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double2 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double2 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double2 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double4 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double4 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double4 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double4 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double8 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double8 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double8 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double8 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double16 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double16 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double16 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double16 x, ulong16 map );

char2 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar2 map);
char4 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar4 map);
char8 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar8 map);
char16 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar16 map);
short2 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort2 map);
short4 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort4 map);
short8 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort8 map);
short16 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort16 map);
int2 __OVERLOAD__ shuffle2( int2 x, int2 y, uint2 map);
int2 __OVERLOAD__ shuffle2( int4 x, int4 y, uint2 map);
int2 __OVERLOAD__ shuffle2( int8 x, int8 y, uint2 map);
int2  __OVERLOAD__ shuffle2( int16 x, int16 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float2 x, float2 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float4 x, float4 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float8 x, float8 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float16 x, float16 y, uint2 map);
int4 __OVERLOAD__ shuffle2( int2 x, int2 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int4 x, int4 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int8 x, int8 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int16 x, int16 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float2 x, float2 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float4 x, float4 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float8 x, float8 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float16 x, float16 y, uint4 map);
int8 __OVERLOAD__ shuffle2( int2 x, int2 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int4 x, int4 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int8 x, int8 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int16 x, int16 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float2 x, float2 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float4 x, float4 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float8 x, float8 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float16 x, float16 y, uint8 map);
int16 __OVERLOAD__ shuffle2( int2 x, int2 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int4 x, int4 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int8 x, int8 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int16 x, int16 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float2 x, float2 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float4 x, float4 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float8 x, float8 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float16 x, float16 y, uint16 map);
long2 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong2 map);
long4 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong4 map);
long8 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong8 map);
long16 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong16 map);

int __printf_cl(constant char * restrict, ...);
#define printf __printf_cl


#if defined( __arm__ )

// Arm instrinsics for converting fixed to float or vice-versa (e.g. vcvtq_n_s32_f32)
// takes number of bits as an argument which needs to be compile time constant ... hence
// these builtins cannot be defined as builtin functions and need to be defined as macros.
 	
#define float_to_fixed_int_float(x, bits) ({ ((int2)__builtin_neon_vcvt_n_s32_v((float2)((x),(x)), (bits), 2)).x; })
#define float_to_fixed_int_float2(x, bits) ({ (int2)__builtin_neon_vcvt_n_s32_v((float2)(x), (bits), 2); })
#define float_to_fixed_int_float4(x, bits) ({ (int4)__builtin_neon_vcvtq_n_s32_v((float4)(x), (bits), 18); })
#define float_to_fixed_int_float8(x, bits) ({ (int8)(float_to_fixed_int_float4((x).hi, (bits)), float_to_fixed_int_float4((x).lo, (bits))); })
#define float_to_fixed_int_float16(x, bits) ({ (int16)(float_to_fixed_int_float8((x).hi, (bits)), float_to_fixed_int_float8((x).lo, (bits))); })

#define float_to_fixed_uint_float(x, bits) ({ ((uint2)__builtin_neon_vcvt_n_u32_v((float2)((x),(x)), (bits), 10)).x; })
#define float_to_fixed_uint_float2(x, bits) ({ (uint2)__builtin_neon_vcvt_n_u32_v((float2)(x), (bits), 10); })
#define float_to_fixed_uint_float4(x, bits) ({ (uint4)__builtin_neon_vcvtq_n_u32_v((float4)(x), (bits), 26); })
#define float_to_fixed_uint_float8(x, bits) ({ (uint8)(float_to_fixed_uint_float4((x).hi, (bits)), float_to_fixed_uint_float4((x).lo, (bits))); })
#define float_to_fixed_uint_float16(x, bits) ({ (uint16)(float_to_fixed_uint_float8((x).hi, (bits)), float_to_fixed_uint_float8((x).lo, (bits))); })

#define fixed_to_float_int_int(x, bits) ({ ((float2)__builtin_neon_vcvt_n_f32_v((int2)((x),(x)), (bits), 2)).x; })
#define fixed_to_float_int_int2(x, bits) ({ (float2)__builtin_neon_vcvt_n_f32_v((int2)(x), (bits), 2); })
#define fixed_to_float_int_int4(x, bits) ({ (float4)__builtin_neon_vcvtq_n_f32_v((int4)(x), (bits), 18); })
#define fixed_to_float_int_int8(x, bits) ({ (float8)(fixed_to_float_int_int4((x).hi, (bits)), fixed_to_float_int_int4((x).lo, (bits))); })
#define fixed_to_float_int_int16(x, bits) ({ (float16)(fixed_to_float_int_int8((x).hi, (bits)), fixed_to_float_int_int8((x).lo, (bits))); })

#define fixed_to_float_uint_uint(x, bits) ({ ((float2)__builtin_neon_vcvt_n_f32_v((uint2)((x),(x)), (bits), 10)).x; })
#define fixed_to_float_uint_uint2(x, bits) ({ (float2)__builtin_neon_vcvt_n_f32_v((uint2)(x), (bits), 10); })
#define fixed_to_float_uint_uint4(x, bits) ({ (float4)__builtin_neon_vcvtq_n_f32_v((uint4)(x), (bits), 26); })
#define fixed_to_float_uint_uint8(x, bits) ({ (float8)(fixed_to_float_uint_uint4((x).hi, (bits)), fixed_to_float_uint_uint4((x).lo, (bits))); })
#define fixed_to_float_uint_uint16(x, bits) ({ (float16)(fixed_to_float_uint_uint8((x).hi, (bits)), fixed_to_float_uint_uint8((x).lo, (bits))); })

#else

int __OVERLOAD__ float_to_fixed_int_float(float x, const int bits);
int2 __OVERLOAD__ float_to_fixed_int_float2(float2 x, const int bits);
int4 __OVERLOAD__ float_to_fixed_int_float4(float4 x, const int bits);
int8 __OVERLOAD__ float_to_fixed_int_float8(float8 x, const int bits);
int16 __OVERLOAD__ float_to_fixed_int_float16(float16 x, const int bits);

uint __OVERLOAD__ float_to_fixed_uint_float(float x, const int bits);
uint2 __OVERLOAD__ float_to_fixed_uint_float2(float2 x, const int bits);
uint4 __OVERLOAD__ float_to_fixed_uint_float4(float4 x, const int bits);
uint8 __OVERLOAD__ float_to_fixed_uint_float8(float8 x, const int bits);
uint16 __OVERLOAD__ float_to_fixed_uint_float16(float16 x, const int bits);

float __OVERLOAD__ fixed_to_float_int_int(int x, int bits);
float2 __OVERLOAD__ fixed_to_float_int_int2(int2 x, int bits);
float4 __OVERLOAD__ fixed_to_float_int_int4(int4 x, int bits);
float8 __OVERLOAD__ fixed_to_float_int_int8(int8 x, int bits);
float16 __OVERLOAD__ fixed_to_float_int_int16(int16 x, int bits);

float __OVERLOAD__ fixed_to_float_uint_uint(uint x, int bits);
float2 __OVERLOAD__ fixed_to_float_uint_uint2(uint2 x, int bits);
float4 __OVERLOAD__ fixed_to_float_uint_uint4(uint4 x, int bits);
float8 __OVERLOAD__ fixed_to_float_uint_uint8(uint8 x, int bits);
float16 __OVERLOAD__ fixed_to_float_uint_uint16(uint16 x, int bits);

#endif

#endif  // __CL_KERNEL_H
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    cl_kernel_shared.h                                                                                  0100644 0001750 0001750 00000014563 12076116671 036612  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*******************************************************************************
 * Copyright:  (c) 2008-2012 by Apple, Inc., All Rights Reserved.
 ******************************************************************************/


#ifndef __CL_KERNEL_SHARED_H__
#define __CL_KERNEL_SHARED_H__

#ifndef __OPENCL_TYPES_DEFINED__
    #include <stddef.h>
    #include <stdint.h>

    typedef char            char16      __attribute__ ((__vector_size__(16)));
    typedef unsigned char   uchar16     __attribute__ ((__vector_size__(16)));
    typedef short           short8      __attribute__ ((__vector_size__(16)));
    typedef unsigned short  ushort8     __attribute__ ((__vector_size__(16)));
    typedef float           float4      __attribute__ ((__vector_size__(16)));
    typedef int             int4        __attribute__ ((__vector_size__(16)));
    typedef unsigned int    uint4       __attribute__ ((__vector_size__(16)));
    typedef long long       long2       __attribute__ ((__vector_size__(16)));
    typedef unsigned long long  ulong2  __attribute__ ((__vector_size__(16)));
    typedef double          double2     __attribute__ ((__vector_size__(16)));
    typedef size_t          event_t;
    typedef unsigned char   uchar;
    typedef unsigned short  ushort;
    typedef unsigned int    uint;

    typedef struct short16{ short8 lo, hi;  }short16;
    typedef struct ushort16{ ushort8 lo, hi;  }ushort16;

    typedef struct int8{ int4 lo,hi; }int8;
    typedef struct int16{ int8 lo,hi; }int16;

    typedef struct uint8{ uint4 lo,hi; }uint8;
    typedef struct uint16{ uint8 lo,hi; }uint16;

    typedef struct float8{ float4 lo,hi; }float8;
    typedef struct float16{ float8 lo,hi; }float16;
    typedef struct float32{ float16 lo,hi; }float32;

    #define __OPENCL_TYPES_DEFINED__
#endif /* __OPENCL_TYPES_DEFINED__ */

// Channel order; MUST be kept in sync with cld_internal.h in the drivers.
enum {
  CLK_R,
  CLK_A,
  CLK_RG,
  CLK_RA,
  CLK_RGB,
  CLK_RGBA,
  CLK_ARGB,
  CLK_BGRA,
  CLK_INTENSITY,
  CLK_LUMINANCE,
  CLK_Rx,
  CLK_RGx,
  CLK_RGBx,
  CLK_1RGB_APPLE,
  CLK_BGR1_APPLE,
  CLK_422_YCbYCr_APPLE,
  CLK_422_CbYCrY_APPLE,
  CLK_DEPTH_STENCIL,
  CLK_DEPTH,
  CLK_ABGR_APPLE
};

// Extension: cl_APPLE_yuv
// YUV color conversion matrices
enum {
    CLK_ITU_601_APPLE = 0x1000000A,
    CLK_ITU_709_APPLE = 0x1000000B
};

// Extension: cl_APPLE_yuv
// YUV chroma siting
enum {
    CLK_CHROMA_CENTERED_APPLE = 0x1000000C,
    CLK_CHROMA_COSITED_APPLE = 0x1000000D
};

typedef enum clk_channel_type{
  // valid formats for float return types
  CLK_SNORM_INT8,            // four channel RGBA unorm8
  CLK_UNORM_INT8,            // four channel RGBA unorm8
  CLK_SNORM_INT16,           // four channel RGBA unorm16
  CLK_UNORM_INT16,           // four channel RGBA unorm16
  CLK_HALF_FLOAT,            // four channel RGBA half
  CLK_FLOAT,                 // four channel RGBA float

  // valid only for integer return types
  CLK_SIGNED_INT8,
  CLK_SIGNED_INT16,
  CLK_SIGNED_INT32,
  CLK_UNSIGNED_INT8,
  CLK_UNSIGNED_INT16,
  CLK_UNSIGNED_INT32,

  // CI SPI for CPU
  __CLK_UNORM_INT8888,         // four channel ARGB unorm8
  __CLK_UNORM_INT8888R,        // four channel BGRA unorm8
  __CLK_UNORM_INT8A,           // single channel CL_A unorm8
  __CLK_UNORM_INT8I,           // single channel CL_INTENSITY unorm8

  CLK_UNORM_SHORT_565,
  CLK_UNORM_SHORT_555,
  CLK_UNORM_INT_101010,
  
  CLK_UNORM_INT8_ITU_601_APPLE,
  CLK_UNORM_INT8_ITU_709_APPLE,
  CLK_SFIXED14_APPLE,
  CLK_BIASED_HALF_APPLE,
  
  __CLK_VALID_IMAGE_TYPE_COUNT,
  __CLK_INVALID_IMAGE_TYPE = __CLK_VALID_IMAGE_TYPE_COUNT,
  __CLK_VALID_IMAGE_TYPE_MASK_BITS = 5,         // number of bits required to represent any image type
  __CLK_VALID_IMAGE_TYPE_MASK = ( 1 << __CLK_VALID_IMAGE_TYPE_MASK_BITS ) - 1
}clk_channel_type;

typedef enum clk_sampler_type
{
    __CLK_ADDRESS_BASE             = 0,
    CLK_ADDRESS_NONE               = 0 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_CLAMP              = 1 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_CLAMP_TO_EDGE      = 2 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_REPEAT             = 3 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_MIRRORED_REPEAT    = 4 << __CLK_ADDRESS_BASE,
    __CLK_ADDRESS_MASK             = CLK_ADDRESS_NONE | CLK_ADDRESS_CLAMP | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_ADDRESS_REPEAT | CLK_ADDRESS_MIRRORED_REPEAT,
    __CLK_ADDRESS_BITS             = 3,        // number of bits required to represent address info

    __CLK_NORMALIZED_BASE          = __CLK_ADDRESS_BITS,
    CLK_NORMALIZED_COORDS_FALSE    = 0,
    CLK_NORMALIZED_COORDS_TRUE     = 1 << __CLK_NORMALIZED_BASE,
    __CLK_NORMALIZED_MASK          = CLK_NORMALIZED_COORDS_FALSE | CLK_NORMALIZED_COORDS_TRUE,
    __CLK_NORMALIZED_BITS          = 1,        // number of bits required to represent normalization 

    __CLK_FILTER_BASE              = __CLK_NORMALIZED_BASE + __CLK_NORMALIZED_BITS,
    CLK_FILTER_NEAREST             = 0 << __CLK_FILTER_BASE,
    CLK_FILTER_LINEAR              = 1 << __CLK_FILTER_BASE,
    CLK_FILTER_ANISOTROPIC         = 2 << __CLK_FILTER_BASE,
    __CLK_FILTER_MASK              = CLK_FILTER_NEAREST | CLK_FILTER_LINEAR | CLK_FILTER_ANISOTROPIC,
    __CLK_FILTER_BITS              = 2,        // number of bits required to represent address info

    __CLK_MIP_BASE                 = __CLK_FILTER_BASE + __CLK_FILTER_BITS,
    CLK_MIP_NEAREST                = 0 << __CLK_MIP_BASE,
    CLK_MIP_LINEAR                 = 1 << __CLK_MIP_BASE,
    CLK_MIP_ANISOTROPIC            = 2 << __CLK_MIP_BASE,
    __CLK_MIP_MASK                 = CLK_MIP_NEAREST | CLK_MIP_LINEAR | CLK_MIP_ANISOTROPIC,
    __CLK_MIP_BITS                 = 2,
  
    __CLK_SAMPLER_BITS             = __CLK_MIP_BASE + __CLK_MIP_BITS,
    __CLK_SAMPLER_MASK             = __CLK_MIP_MASK | __CLK_FILTER_MASK | __CLK_NORMALIZED_MASK | __CLK_ADDRESS_MASK,
    
    __CLK_ANISOTROPIC_RATIO_BITS   = 5,
    __CLK_ANISOTROPIC_RATIO_MASK   = (int) 0x80000000 >> (__CLK_ANISOTROPIC_RATIO_BITS-1)
}clk_sampler_type;


#if defined( __clang__ )
    //FIXME: commented out per <rdar://problem/6307429> ABI bustage in read_image
    #define __FAST_CALL           /* __attribute__ ((fastcall)) */
    #define __ALWAYS_INLINE       __attribute__ ((__always_inline__))
    #define INLINE                  inline
#else
    // compiling GCC version for debugging
    #define __FAST_CALL
    #define __ALWAYS_INLINE      __attribute__ (( __noinline__))
    #define INLINE
#endif

#endif /* __CL_KERNEL_SHARED_H__ */

                                                                                                                                             emmintrin.h                                                                                         0100644 0001750 0001750 00000114002 11675013170 035307  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- emmintrin.h - SSE2 intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __EMMINTRIN_H
#define __EMMINTRIN_H

#ifndef __SSE2__
#error "SSE2 instruction set not enabled"
#else

#include <xmmintrin.h>

typedef double __m128d __attribute__((__vector_size__(16)));
typedef long long __m128i __attribute__((__vector_size__(16)));

/* Type defines.  */
typedef double __v2df __attribute__ ((__vector_size__ (16)));
typedef long long __v2di __attribute__ ((__vector_size__ (16)));
typedef short __v8hi __attribute__((__vector_size__(16)));
typedef char __v16qi __attribute__((__vector_size__(16)));

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_sd(__m128d a, __m128d b)
{
  a[0] += b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_add_pd(__m128d a, __m128d b)
{
  return a + b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_sd(__m128d a, __m128d b)
{
  a[0] -= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sub_pd(__m128d a, __m128d b)
{
  return a - b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_sd(__m128d a, __m128d b)
{
  a[0] *= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_mul_pd(__m128d a, __m128d b)
{
  return a * b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_sd(__m128d a, __m128d b)
{
  a[0] /= b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_div_pd(__m128d a, __m128d b)
{
  return a / b;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_sd(__m128d a, __m128d b)
{
  __m128d c = __builtin_ia32_sqrtsd(b);
  return (__m128d) { c[0], a[1] };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_pd(__m128d a)
{
  return __builtin_ia32_sqrtpd(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_minsd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_min_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_minpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_maxsd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_max_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_maxpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_and_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a & (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_andnot_pd(__m128d a, __m128d b)
{
  return (__m128d)(~(__v4si)a & (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_or_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a | (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_xor_pd(__m128d a, __m128d b)
{
  return (__m128d)((__v4si)a ^ (__v4si)b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(a, b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_pd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmppd(b, a, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmple_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 7);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 3);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 4);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(a, b, 6);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 5);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_sd(__m128d a, __m128d b)
{
  return (__m128d)__builtin_ia32_cmpsd(b, a, 6);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdeq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdlt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdle(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdgt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdge(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_comisdneq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdeq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdlt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdle(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdgt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdge(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_sd(__m128d a, __m128d b)
{
  return __builtin_ia32_ucomisdneq(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_ps(__m128d a)
{
  return __builtin_ia32_cvtpd2ps(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pd(__m128 a)
{
  return __builtin_ia32_cvtps2pd(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_pd(__m128i a)
{
  return __builtin_ia32_cvtdq2pd((__v4si)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_epi32(__m128d a)
{
  return __builtin_ia32_cvtpd2dq(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si32(__m128d a)
{
  return __builtin_ia32_cvtsd2si(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_ss(__m128 a, __m128d b)
{
  a[0] = b[0];
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_sd(__m128d a, int b)
{
  a[0] = b;
  return a;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_sd(__m128d a, __m128 b)
{
  a[0] = b[0];
  return a;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_epi32(__m128d a)
{
  return (__m128i)__builtin_ia32_cvttpd2dq(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si32(__m128d a)
{
  return a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpd_pi32(__m128d a)
{
  return (__m64)__builtin_ia32_cvtpd2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttpd_pi32(__m128d a)
{
  return (__m64)__builtin_ia32_cvttpd2pi(a);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_pd(__m64 a)
{
  return __builtin_ia32_cvtpi2pd((__v2si)a);
}

static __inline__ double __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_f64(__m128d a)
{
  return a[0];
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_pd(double const *dp)
{
  return *(__m128d*)dp;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load1_pd(double const *dp)
{
  struct __mm_load1_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_load1_pd_struct*)dp)->u;
  return (__m128d){ u, u };
}

#define        _mm_load_pd1(dp)        _mm_load1_pd(dp)

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadr_pd(double const *dp)
{
  __m128d u = *(__m128d*)dp;
  return __builtin_shufflevector(u, u, 1, 0);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadu_pd(double const *dp)
{
  struct __loadu_pd {
    __m128d v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_pd*)dp)->v;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_load_sd(double const *dp)
{
  struct __mm_load_sd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_load_sd_struct*)dp)->u;
  return (__m128d){ u, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pd(__m128d a, double const *dp)
{
  struct __mm_loadh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_loadh_pd_struct*)dp)->u;
  return (__m128d){ a[0], u };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pd(__m128d a, double const *dp)
{
  struct __mm_loadl_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  double u = ((struct __mm_loadl_pd_struct*)dp)->u;
  return (__m128d){ u, a[1] }; 
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_sd(double w)
{
  return (__m128d){ w, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set1_pd(double w)
{
  return (__m128d){ w, w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_set_pd(double w, double x)
{
  return (__m128d){ x, w };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setr_pd(double w, double x)
{
  return (__m128d){ w, x };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_setzero_pd(void)
{
  return (__m128d){ 0, 0 };
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_move_sd(__m128d a, __m128d b)
{
  return (__m128d){ b[0], a[1] };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_sd(double *dp, __m128d a)
{
  struct __mm_store_sd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_sd_struct*)dp)->u = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_pd(double *dp, __m128d a)
{
  struct __mm_store1_pd_struct {
    double u[2];
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store1_pd_struct*)dp)->u[0] = a[0];
  ((struct __mm_store1_pd_struct*)dp)->u[1] = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_pd(double *dp, __m128d a)
{
  *(__m128d *)dp = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_pd(double *dp, __m128d a)
{
  __builtin_ia32_storeupd(dp, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_pd(double *dp, __m128d a)
{
  a = __builtin_shufflevector(a, a, 1, 0);
  *(__m128d *)dp = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeh_pd(double *dp, __m128d a)
{
  struct __mm_storeh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)dp)->u = a[1];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_pd(double *dp, __m128d a)
{
  struct __mm_storeh_pd_struct {
    double u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_storeh_pd_struct*)dp)->u = a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a + (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a + (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a + (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_si64(__m64 a, __m64 b)
{
  return a + b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_add_epi64(__m128i a, __m128i b)
{
  return a + b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddsb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddusb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_adds_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_paddusw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pavgb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_avg_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pavgw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_madd_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaddwd128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaxsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmaxub128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pminsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pminub128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmulhw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_pmulhuw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a * (__v8hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mul_su32(__m64 a, __m64 b)
{
  return __builtin_ia32_pmuludq((__v2si)a, (__v2si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epu32(__m128i a, __m128i b)
{
  return __builtin_ia32_pmuludq128((__v4si)a, (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sad_epu8(__m128i a, __m128i b)
{
  return __builtin_ia32_psadbw128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a - (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a - (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a - (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_si64(__m64 a, __m64 b)
{
  return a - b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sub_epi64(__m128i a, __m128i b)
{
  return a - b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubsb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubusb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_subs_epu16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_psubusw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_and_si128(__m128i a, __m128i b)
{
  return a & b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si128(__m128i a, __m128i b)
{
  return ~a & b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_or_si128(__m128i a, __m128i b)
{
  return a | b;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_xor_si128(__m128i a, __m128i b)
{
  return a ^ b;
}

#define _mm_slli_si128(a, count) __extension__ ({ \
  __m128i __a = (a); \
  (__m128i)__builtin_ia32_pslldqi128(__a, (count)*8); })

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psllwi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psllw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_pslldi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_pslld128((__v4si)a, (__v4si)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_slli_epi64(__m128i a, int count)
{
  return __builtin_ia32_psllqi128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sll_epi64(__m128i a, __m128i count)
{
  return __builtin_ia32_psllq128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrawi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psraw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srai_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psradi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sra_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrad128((__v4si)a, (__v4si)count);
}


#define _mm_srli_si128(a, count) __extension__ ({ \
  __m128i __a = (a); \
  (__m128i)__builtin_ia32_psrldqi128(__a, (count)*8); })

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi16(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrlwi128((__v8hi)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi16(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrlw128((__v8hi)a, (__v8hi)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi32(__m128i a, int count)
{
  return (__m128i)__builtin_ia32_psrldi128((__v4si)a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi32(__m128i a, __m128i count)
{
  return (__m128i)__builtin_ia32_psrld128((__v4si)a, (__v4si)count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srli_epi64(__m128i a, int count)
{
  return __builtin_ia32_psrlqi128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_srl_epi64(__m128i a, __m128i count)
{
  return __builtin_ia32_psrlq128(a, count);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a == (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a == (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a == (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi8(__m128i a, __m128i b)
{
  return (__m128i)((__v16qi)a > (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi16(__m128i a, __m128i b)
{
  return (__m128i)((__v8hi)a > (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi32(__m128i a, __m128i b)
{
  return (__m128i)((__v4si)a > (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi8(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi8(b,a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi16(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi16(b,a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_epi32(__m128i a, __m128i b)
{
  return _mm_cmpgt_epi32(b,a);
}

#ifdef __x86_64__
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_sd(__m128d a, long long b)
{
  a[0] = b;
  return a;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsd_si64(__m128d a)
{
  return __builtin_ia32_cvtsd2si64(a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttsd_si64(__m128d a)
{
  return a[0];
}
#endif

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_ps(__m128i a)
{
  return __builtin_ia32_cvtdq2ps((__v4si)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_epi32(__m128 a)
{
  return (__m128i)__builtin_ia32_cvtps2dq(a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_epi32(__m128 a)
{
  return (__m128i)__builtin_ia32_cvttps2dq(a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si128(int a)
{
  return (__m128i)(__v4si){ a, 0, 0, 0 };
}

#ifdef __x86_64__
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si128(long long a)
{
  return (__m128i){ a, 0 };
}
#endif

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si32(__m128i a)
{
  __v4si b = (__v4si)a;
  return b[0];
}

#ifdef __x86_64__
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi128_si64(__m128i a)
{
  return a[0];
}
#endif

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_load_si128(__m128i const *p)
{
  return *p;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadu_si128(__m128i const *p)
{
  struct __loadu_si128 {
    __m128i v;
  } __attribute__((packed, may_alias));
  return ((struct __loadu_si128*)p)->v;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_loadl_epi64(__m128i const *p)
{
  struct __mm_loadl_epi64_struct {
    long long u;
  } __attribute__((__packed__, __may_alias__));
  return (__m128i) { ((struct __mm_loadl_epi64_struct*)p)->u, 0};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64x(long long q1, long long q0)
{
  return (__m128i){ q0, q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi64(__m64 q1, __m64 q0)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi32(int i3, int i2, int i1, int i0)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi16(short w7, short w6, short w5, short w4, short w3, short w2, short w1, short w0)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set_epi8(char b15, char b14, char b13, char b12, char b11, char b10, char b9, char b8, char b7, char b6, char b5, char b4, char b3, char b2, char b1, char b0)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64x(long long q)
{
  return (__m128i){ q, q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi64(__m64 q)
{
  return (__m128i){ (long long)q, (long long)q };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi32(int i)
{
  return (__m128i)(__v4si){ i, i, i, i };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi16(short w)
{
  return (__m128i)(__v8hi){ w, w, w, w, w, w, w, w };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_set1_epi8(char b)
{
  return (__m128i)(__v16qi){ b, b, b, b, b, b, b, b, b, b, b, b, b, b, b, b };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi64(__m64 q0, __m64 q1)
{
  return (__m128i){ (long long)q0, (long long)q1 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi32(int i0, int i1, int i2, int i3)
{
  return (__m128i)(__v4si){ i0, i1, i2, i3};
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi16(short w0, short w1, short w2, short w3, short w4, short w5, short w6, short w7)
{
  return (__m128i)(__v8hi){ w0, w1, w2, w3, w4, w5, w6, w7 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setr_epi8(char b0, char b1, char b2, char b3, char b4, char b5, char b6, char b7, char b8, char b9, char b10, char b11, char b12, char b13, char b14, char b15)
{
  return (__m128i)(__v16qi){ b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si128(void)
{
  return (__m128i){ 0LL, 0LL };
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_si128(__m128i *p, __m128i b)
{
  *p = b;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_si128(__m128i *p, __m128i b)
{
  __builtin_ia32_storedqu((char *)p, (__v16qi)b);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmoveu_si128(__m128i d, __m128i n, char *p)
{
  __builtin_ia32_maskmovdqu((__v16qi)d, (__v16qi)n, p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storel_epi64(__m128i *p, __m128i a)
{
  __builtin_ia32_storelv4si((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pd(double *p, __m128d a)
{
  __builtin_ia32_movntpd(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si128(__m128i *p, __m128i a)
{
  __builtin_ia32_movntdq(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_si32(int *p, int a)
{
  __builtin_ia32_movnti(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_clflush(void const *p)
{
  __builtin_ia32_clflush(p);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_lfence(void)
{
  __builtin_ia32_lfence();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mfence(void)
{
  __builtin_ia32_mfence();
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packsswb128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packs_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packssdw128((__v4si)a, (__v4si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_ia32_packuswb128((__v8hi)a, (__v8hi)b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_epi16(__m128i a, int imm)
{
  __v8hi b = (__v8hi)a;
  return (unsigned short)b[imm];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_insert_epi16(__m128i a, int b, int imm)
{
  __v8hi c = (__v8hi)a;
  c[imm & 7] = b;
  return (__m128i)c;
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_epi8(__m128i a)
{
  return __builtin_ia32_pmovmskb128((__v16qi)a);
}

#define _mm_shuffle_epi32(a, imm) __extension__ ({ \
  __m128i __a = (a); \
  (__m128i)__builtin_shufflevector((__v4si)__a, (__v4si) _mm_set1_epi32(0), \
                                   (imm) & 0x3, ((imm) & 0xc) >> 2, \
                                   ((imm) & 0x30) >> 4, ((imm) & 0xc0) >> 6); })

#define _mm_shufflelo_epi16(a, imm) __extension__ ({ \
  __m128i __a = (a); \
  (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi) _mm_set1_epi16(0), \
                                   (imm) & 0x3, ((imm) & 0xc) >> 2, \
                                   ((imm) & 0x30) >> 4, ((imm) & 0xc0) >> 6, \
                                   4, 5, 6, 7); })

#define _mm_shufflehi_epi16(a, imm) __extension__ ({ \
  __m128i __a = (a); \
  (__m128i)__builtin_shufflevector((__v8hi)__a, (__v8hi) _mm_set1_epi16(0), \
                                   0, 1, 2, 3, \
                                   4 + (((imm) & 0x03) >> 0), \
                                   4 + (((imm) & 0x0c) >> 2), \
                                   4 + (((imm) & 0x30) >> 4), \
                                   4 + (((imm) & 0xc0) >> 6)); })

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)a, (__v16qi)b, 8, 16+8, 9, 16+9, 10, 16+10, 11, 16+11, 12, 16+12, 13, 16+13, 14, 16+14, 15, 16+15);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)a, (__v8hi)b, 4, 8+4, 5, 8+5, 6, 8+6, 7, 8+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v4si)a, (__v4si)b, 2, 4+2, 3, 4+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_epi64(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector(a, b, 1, 2+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi8(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v16qi)a, (__v16qi)b, 0, 16+0, 1, 16+1, 2, 16+2, 3, 16+3, 4, 16+4, 5, 16+5, 6, 16+6, 7, 16+7);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi16(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v8hi)a, (__v8hi)b, 0, 8+0, 1, 8+1, 2, 8+2, 3, 8+3);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi32(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector((__v4si)a, (__v4si)b, 0, 4+0, 1, 4+1);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_epi64(__m128i a, __m128i b)
{
  return (__m128i)__builtin_shufflevector(a, b, 0, 2+0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_movepi64_pi64(__m128i a)
{
  return (__m64)a[0];
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_movpi64_pi64(__m64 a)
{
  return (__m128i){ (long long)a, 0 };
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_move_epi64(__m128i a)
{
  return __builtin_shufflevector(a, (__m128i){ 0 }, 0, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pd(__m128d a, __m128d b)
{
  return __builtin_shufflevector(a, b, 1, 2+1);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pd(__m128d a, __m128d b)
{
  return __builtin_shufflevector(a, b, 0, 2+0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pd(__m128d a)
{
  return __builtin_ia32_movmskpd(a);
}

#define _mm_shuffle_pd(a, b, i) __extension__ ({ \
  __m128d __a = (a); \
  __m128d __b = (b); \
  __builtin_shufflevector(__a, __b, (i) & 1, (((i) & 2) >> 1) + 2); })

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castpd_ps(__m128d in)
{
  return (__m128)in;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castpd_si128(__m128d in)
{
  return (__m128i)in;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castps_pd(__m128 in)
{
  return (__m128d)in;
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_castps_si128(__m128 in)
{
  return (__m128i)in;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_ps(__m128i in)
{
  return (__m128)in;
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_castsi128_pd(__m128i in)
{
  return (__m128d)in;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_pause(void)
{
  __asm__ volatile ("pause");
}

#define _MM_SHUFFLE2(x, y) (((x) << 1) | (y))

#endif /* __SSE2__ */

#endif /* __EMMINTRIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              float.h                                                                                             0100644 0001750 0001750 00000006710 11675013170 034420  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- float.h - Characteristics of floating point types ----------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __FLOAT_H
#define __FLOAT_H

/* If we're on MinGW, fall back to the system's float.h, which might have
 * additional definitions provided for Windows.
 * For more details see http://msdn.microsoft.com/en-us/library/y0ybw9fy.aspx
 */
#if defined(__MINGW32__) && \
    defined(__has_include_next) && __has_include_next(<float.h>)
#  include_next <float.h>

/* Undefine anything that we'll be redefining below. */
#  undef FLT_EVAL_METHOD
#  undef FLT_ROUNDS
#  undef FLT_RADIX
#  undef FLT_MANT_DIG
#  undef DBL_MANT_DIG
#  undef LDBL_MANT_DIG
#  undef DECIMAL_DIG
#  undef FLT_DIG
#  undef DBL_DIG
#  undef LDBL_DIG
#  undef FLT_MIN_EXP
#  undef DBL_MIN_EXP
#  undef LDBL_MIN_EXP
#  undef FLT_MIN_10_EXP
#  undef DBL_MIN_10_EXP
#  undef LDBL_MIN_10_EXP
#  undef FLT_MAX_EXP
#  undef DBL_MAX_EXP
#  undef LDBL_MAX_EXP
#  undef FLT_MAX_10_EXP
#  undef DBL_MAX_10_EXP
#  undef LDBL_MAX_10_EXP
#  undef FLT_MAX
#  undef DBL_MAX
#  undef LDBL_MAX
#  undef FLT_EPSILON
#  undef DBL_EPSILON
#  undef LDBL_EPSILON
#  undef FLT_MIN
#  undef DBL_MIN
#  undef LDBL_MIN
#endif

/* Characteristics of floating point types, C99 5.2.4.2.2 */

#define FLT_EVAL_METHOD __FLT_EVAL_METHOD__
#define FLT_ROUNDS (__builtin_flt_rounds())
#define FLT_RADIX __FLT_RADIX__

#define FLT_MANT_DIG __FLT_MANT_DIG__
#define DBL_MANT_DIG __DBL_MANT_DIG__
#define LDBL_MANT_DIG __LDBL_MANT_DIG__

#define DECIMAL_DIG __DECIMAL_DIG__

#define FLT_DIG __FLT_DIG__
#define DBL_DIG __DBL_DIG__
#define LDBL_DIG __LDBL_DIG__

#define FLT_MIN_EXP __FLT_MIN_EXP__
#define DBL_MIN_EXP __DBL_MIN_EXP__
#define LDBL_MIN_EXP __LDBL_MIN_EXP__

#define FLT_MIN_10_EXP __FLT_MIN_10_EXP__
#define DBL_MIN_10_EXP __DBL_MIN_10_EXP__
#define LDBL_MIN_10_EXP __LDBL_MIN_10_EXP__

#define FLT_MAX_EXP __FLT_MAX_EXP__
#define DBL_MAX_EXP __DBL_MAX_EXP__
#define LDBL_MAX_EXP __LDBL_MAX_EXP__

#define FLT_MAX_10_EXP __FLT_MAX_10_EXP__
#define DBL_MAX_10_EXP __DBL_MAX_10_EXP__
#define LDBL_MAX_10_EXP __LDBL_MAX_10_EXP__

#define FLT_MAX __FLT_MAX__
#define DBL_MAX __DBL_MAX__
#define LDBL_MAX __LDBL_MAX__

#define FLT_EPSILON __FLT_EPSILON__
#define DBL_EPSILON __DBL_EPSILON__
#define LDBL_EPSILON __LDBL_EPSILON__

#define FLT_MIN __FLT_MIN__
#define DBL_MIN __DBL_MIN__
#define LDBL_MIN __LDBL_MIN__

#endif /* __FLOAT_H */
                                                        immintrin.h                                                                                         0100644 0001750 0001750 00000003327 11567030532 035323  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- immintrin.h - Intel intrinsics -----------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __IMMINTRIN_H
#define __IMMINTRIN_H

#ifdef __MMX__
#include <mmintrin.h>
#endif

#ifdef __SSE__
#include <xmmintrin.h>
#endif

#ifdef __SSE2__
#include <emmintrin.h>
#endif

#ifdef __SSE3__
#include <pmmintrin.h>
#endif

#ifdef __SSSE3__
#include <tmmintrin.h>
#endif

#if defined (__SSE4_2__) || defined (__SSE4_1__)
#include <smmintrin.h>
#endif

#if defined (__AES__) || defined (__PCLMUL__)
#include <wmmintrin.h>
#endif

#ifdef __AVX__
#include <avxintrin.h>
#endif

#endif /* __IMMINTRIN_H */
                                                                                                                                                                                                                                                                                                         iso646.h                                                                                            0100644 0001750 0001750 00000003035 11640174631 034344  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- iso646.h - Standard header for alternate spellings of operators---===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __ISO646_H
#define __ISO646_H

#ifndef __cplusplus
#define and    &&
#define and_eq &=
#define bitand &
#define bitor  |
#define compl  ~
#define not    !
#define not_eq !=
#define or     ||
#define or_eq  |=
#define xor    ^
#define xor_eq ^=
#endif

#endif /* __ISO646_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   limits.h                                                                                            0100644 0001750 0001750 00000007121 11640174631 034613  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- limits.h - Standard header for integer sizes --------------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_LIMITS_H
#define __CLANG_LIMITS_H

/* The system's limits.h may, in turn, try to #include_next GCC's limits.h.
   Avert this #include_next madness. */
#if defined __GNUC__ && !defined _GCC_LIMITS_H_
#define _GCC_LIMITS_H_
#endif

/* System headers include a number of constants from POSIX in <limits.h>.
   Include it if we're hosted. */
#if __STDC_HOSTED__ && \
    defined(__has_include_next) && __has_include_next(<limits.h>)
#include_next <limits.h>
#endif

/* Many system headers try to "help us out" by defining these.  No really, we
   know how big each datatype is. */
#undef  SCHAR_MIN
#undef  SCHAR_MAX
#undef  UCHAR_MAX
#undef  SHRT_MIN
#undef  SHRT_MAX
#undef  USHRT_MAX
#undef  INT_MIN
#undef  INT_MAX
#undef  UINT_MAX
#undef  LONG_MIN
#undef  LONG_MAX
#undef  ULONG_MAX

#undef  CHAR_BIT
#undef  CHAR_MIN
#undef  CHAR_MAX

/* C90/99 5.2.4.2.1 */
#define SCHAR_MAX __SCHAR_MAX__
#define SHRT_MAX  __SHRT_MAX__
#define INT_MAX   __INT_MAX__
#define LONG_MAX  __LONG_MAX__

#define SCHAR_MIN (-__SCHAR_MAX__-1)
#define SHRT_MIN  (-__SHRT_MAX__ -1)
#define INT_MIN   (-__INT_MAX__  -1)
#define LONG_MIN  (-__LONG_MAX__ -1L)

#define UCHAR_MAX (__SCHAR_MAX__*2  +1)
#define USHRT_MAX (__SHRT_MAX__ *2  +1)
#define UINT_MAX  (__INT_MAX__  *2U +1U)
#define ULONG_MAX (__LONG_MAX__ *2UL+1UL)

#ifndef MB_LEN_MAX
#define MB_LEN_MAX 1
#endif

#define CHAR_BIT  __CHAR_BIT__

#ifdef __CHAR_UNSIGNED__  /* -funsigned-char */
#define CHAR_MIN 0
#define CHAR_MAX UCHAR_MAX
#else
#define CHAR_MIN SCHAR_MIN
#define CHAR_MAX __SCHAR_MAX__
#endif

/* C99 5.2.4.2.1: Added long long. */
#if __STDC_VERSION__ >= 199901

#undef  LLONG_MIN
#undef  LLONG_MAX
#undef  ULLONG_MAX

#define LLONG_MAX  __LONG_LONG_MAX__
#define LLONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULLONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif

/* LONG_LONG_MIN/LONG_LONG_MAX/ULONG_LONG_MAX are a GNU extension.  It's too bad
   that we don't have something like #pragma poison that could be used to
   deprecate a macro - the code should just use LLONG_MAX and friends.
 */
#if defined(__GNU_LIBRARY__) ? defined(__USE_GNU) : !defined(__STRICT_ANSI__)

#undef   LONG_LONG_MIN
#undef   LONG_LONG_MAX
#undef   ULONG_LONG_MAX

#define LONG_LONG_MAX  __LONG_LONG_MAX__
#define LONG_LONG_MIN  (-__LONG_LONG_MAX__-1LL)
#define ULONG_LONG_MAX (__LONG_LONG_MAX__*2ULL+1ULL)
#endif

#endif /* __CLANG_LIMITS_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                               mm3dnow.h                                                                                           0100644 0001750 0001750 00000013160 11640174631 034676  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- mm3dnow.h - 3DNow! intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef _MM3DNOW_H_INCLUDED
#define _MM3DNOW_H_INCLUDED

#include <mmintrin.h>

typedef float __v2sf __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_m_femms() {
  __builtin_ia32_femms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pavgusb(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pavgusb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pf2id(__m64 __m) {
  return (__m64)__builtin_ia32_pf2id((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfadd(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfadd((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfcmpeq(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpeq((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfcmpge(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpge((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfcmpgt(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfcmpgt((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfmax(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmax((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfmin(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmin((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfmul(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfmul((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfrcp(__m64 __m) {
  return (__m64)__builtin_ia32_pfrcp((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfrcpit1(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrcpit1((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfrcpit2(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrcpit2((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfrsqrt(__m64 __m) {
  return (__m64)__builtin_ia32_pfrsqrt((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfrsqrtit1(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfrsqrtit1((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfsub(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfsub((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfsubr(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfsubr((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pi2fd(__m64 __m) {
  return (__m64)__builtin_ia32_pi2fd((__v2si)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pmulhrw(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pmulhrw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pf2iw(__m64 __m) {
  return (__m64)__builtin_ia32_pf2iw((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfnacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfnacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pfpnacc(__m64 __m1, __m64 __m2) {
  return (__m64)__builtin_ia32_pfpnacc((__v2sf)__m1, (__v2sf)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pi2fw(__m64 __m) {
  return (__m64)__builtin_ia32_pi2fw((__v2si)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pswapdsf(__m64 __m) {
  return (__m64)__builtin_ia32_pswapdsf((__v2sf)__m);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_m_pswapdsi(__m64 __m) {
  return (__m64)__builtin_ia32_pswapdsi((__v2si)__m);
}

#endif
                                                                                                                                                                                                                                                                                                                                                                                                                mm_malloc.h                                                                                         0100644 0001750 0001750 00000004775 11675013170 035264  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- mm_malloc.h - Allocating and Freeing Aligned Memory Blocks -------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __MM_MALLOC_H
#define __MM_MALLOC_H

#include <stdlib.h>

#ifdef _WIN32
#include <malloc.h>
#else
#ifndef __cplusplus
extern int posix_memalign(void **memptr, size_t alignment, size_t size);
#else
// Some systems (e.g. those with GNU libc) declare posix_memalign with an
// exception specifier. Via an "egregious workaround" in
// Sema::CheckEquivalentExceptionSpec, Clang accepts the following as a valid
// redeclaration of glibc's declaration.
extern "C" int posix_memalign(void **memptr, size_t alignment, size_t size);
#endif
#endif

#if !(defined(_WIN32) && defined(_mm_malloc))
static __inline__ void *__attribute__((__always_inline__, __nodebug__,
                                       __malloc__))
_mm_malloc(size_t size, size_t align)
{
  if (align == 1) {
    return malloc(size);
  }

  if (!(align & (align - 1)) && align < sizeof(void *))
    align = sizeof(void *);

  void *mallocedMemory;
#if defined(__MINGW32__)
  mallocedMemory = __mingw_aligned_malloc(size, align);
#elif defined(_WIN32)
  mallocedMemory = _aligned_malloc(size, align);
#else
  if (posix_memalign(&mallocedMemory, align, size))
    return 0;
#endif

  return mallocedMemory;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_free(void *p)
{
  free(p);
}
#endif

#endif /* __MM_MALLOC_H */
   mmintrin.h                                                                                          0100644 0001750 0001750 00000036166 11640174631 035162  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- mmintrin.h - MMX intrinsics --------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __MMINTRIN_H
#define __MMINTRIN_H

#ifndef __MMX__
#error "MMX instruction set not enabled"
#else

typedef long long __m64 __attribute__((__vector_size__(8)));

typedef int __v2si __attribute__((__vector_size__(8)));
typedef short __v4hi __attribute__((__vector_size__(8)));
typedef char __v8qi __attribute__((__vector_size__(8)));

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_empty(void)
{
    __builtin_ia32_emms();
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_si64(int __i)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i, 0);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_si32(__m64 __m)
{
    return __builtin_ia32_vec_ext_v2si((__v2si)__m, 0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_m64(long long __i)
{
    return (__m64)__i;
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtm64_si64(__m64 __m)
{
    return (long long)__m;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packsswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packssdw((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_packs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_packuswb((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckhdq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklbw((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpcklwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_punpckldq((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_add_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi8(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_paddsw((__v4hi)__m1, (__v4hi)__m2);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu8(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddusb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_adds_pu16(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_paddusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubw((__v4hi)__m1, (__v4hi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sub_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubsw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusb((__v8qi)__m1, (__v8qi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_subs_pu16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_psubusw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_madd_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmaddwd((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pmulhw((__v4hi)__m1, (__v4hi)__m2);
}
 
static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mullo_pi16(__m64 __m1, __m64 __m2) 
{
    return (__m64)__builtin_ia32_pmullw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllw((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllwi((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_pslld((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_pslldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sll_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psllq(__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_slli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psllqi(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psraw((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrawi((__v4hi)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sra_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrad((__v2si)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srai_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psradi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi16(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlw((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi16(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlwi((__v4hi)__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_pi32(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrld((__v2si)__m, __count);       
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_pi32(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrldi((__v2si)__m, __count);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srl_si64(__m64 __m, __m64 __count)
{
    return (__m64)__builtin_ia32_psrlq(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_srli_si64(__m64 __m, int __count)
{
    return (__m64)__builtin_ia32_psrlqi(__m, __count);    
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_and_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pand(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pandn(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_or_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_por(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_xor_si64(__m64 __m1, __m64 __m2)
{
    return __builtin_ia32_pxor(__m1, __m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpeqd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi8(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtb((__v8qi)__m1, (__v8qi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi16(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtw((__v4hi)__m1, (__v4hi)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_pi32(__m64 __m1, __m64 __m2)
{
    return (__m64)__builtin_ia32_pcmpgtd((__v2si)__m1, (__v2si)__m2);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setzero_si64(void)
{
    return (__m64){ 0LL };
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi32(int __i1, int __i0)
{
    return (__m64)__builtin_ia32_vec_init_v2si(__i0, __i1);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi16(short __s3, short __s2, short __s1, short __s0)
{
    return (__m64)__builtin_ia32_vec_init_v4hi(__s0, __s1, __s2, __s3);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set_pi8(char __b7, char __b6, char __b5, char __b4, char __b3, char __b2,
            char __b1, char __b0)
{
    return (__m64)__builtin_ia32_vec_init_v8qi(__b0, __b1, __b2, __b3,
                                               __b4, __b5, __b6, __b7);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi32(int __i)
{
    return _mm_set_pi32(__i, __i);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi16(short __w)
{
    return _mm_set_pi16(__w, __w, __w, __w);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_set1_pi8(char __b)
{
    return _mm_set_pi8(__b, __b, __b, __b, __b, __b, __b, __b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi32(int __i0, int __i1)
{
    return _mm_set_pi32(__i1, __i0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi16(short __w0, short __w1, short __w2, short __w3)
{
    return _mm_set_pi16(__w3, __w2, __w1, __w0);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_setr_pi8(char __b0, char __b1, char __b2, char __b3, char __b4, char __b5,
             char __b6, char __b7)
{
    return _mm_set_pi8(__b7, __b6, __b5, __b4, __b3, __b2, __b1, __b0);
}


/* Aliases for compatibility. */
#define _m_empty _mm_empty
#define _m_from_int _mm_cvtsi32_si64
#define _m_to_int _mm_cvtsi64_si32
#define _m_packsswb _mm_packs_pi16
#define _m_packssdw _mm_packs_pi32
#define _m_packuswb _mm_packs_pu16
#define _m_punpckhbw _mm_unpackhi_pi8
#define _m_punpckhwd _mm_unpackhi_pi16
#define _m_punpckhdq _mm_unpackhi_pi32
#define _m_punpcklbw _mm_unpacklo_pi8
#define _m_punpcklwd _mm_unpacklo_pi16
#define _m_punpckldq _mm_unpacklo_pi32
#define _m_paddb _mm_add_pi8
#define _m_paddw _mm_add_pi16
#define _m_paddd _mm_add_pi32
#define _m_paddsb _mm_adds_pi8
#define _m_paddsw _mm_adds_pi16
#define _m_paddusb _mm_adds_pu8
#define _m_paddusw _mm_adds_pu16
#define _m_psubb _mm_sub_pi8
#define _m_psubw _mm_sub_pi16
#define _m_psubd _mm_sub_pi32
#define _m_psubsb _mm_subs_pi8
#define _m_psubsw _mm_subs_pi16
#define _m_psubusb _mm_subs_pu8
#define _m_psubusw _mm_subs_pu16
#define _m_pmaddwd _mm_madd_pi16
#define _m_pmulhw _mm_mulhi_pi16
#define _m_pmullw _mm_mullo_pi16
#define _m_psllw _mm_sll_pi16
#define _m_psllwi _mm_slli_pi16
#define _m_pslld _mm_sll_pi32
#define _m_pslldi _mm_slli_pi32
#define _m_psllq _mm_sll_si64
#define _m_psllqi _mm_slli_si64
#define _m_psraw _mm_sra_pi16
#define _m_psrawi _mm_srai_pi16
#define _m_psrad _mm_sra_pi32
#define _m_psradi _mm_srai_pi32
#define _m_psrlw _mm_srl_pi16
#define _m_psrlwi _mm_srli_pi16
#define _m_psrld _mm_srl_pi32
#define _m_psrldi _mm_srli_pi32
#define _m_psrlq _mm_srl_si64
#define _m_psrlqi _mm_srli_si64
#define _m_pand _mm_and_si64
#define _m_pandn _mm_andnot_si64
#define _m_por _mm_or_si64
#define _m_pxor _mm_xor_si64
#define _m_pcmpeqb _mm_cmpeq_pi8
#define _m_pcmpeqw _mm_cmpeq_pi16
#define _m_pcmpeqd _mm_cmpeq_pi32
#define _m_pcmpgtb _mm_cmpgt_pi8
#define _m_pcmpgtw _mm_cmpgt_pi16
#define _m_pcmpgtd _mm_cmpgt_pi32

#endif /* __MMX__ */

#endif /* __MMINTRIN_H */

                                                                                                                                                                                                                                                                                                                                                                                                          nmmintrin.h                                                                                         0100644 0001750 0001750 00000003006 11567030532 035322  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- nmmintrin.h - SSE4 intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef _NMMINTRIN_H
#define _NMMINTRIN_H

#ifndef __SSE4_2__
#error "SSE4.2 instruction set not enabled"
#else

/* To match expectations of gcc we put the sse4.2 definitions into smmintrin.h,
   just include it now then.  */
#include <smmintrin.h>
#endif /* __SSE4_2__ */
#endif /* _NMMINTRIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          pmmintrin.h                                                                                         0100644 0001750 0001750 00000007156 11675013170 035335  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- pmmintrin.h - SSE3 intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
 
#ifndef __PMMINTRIN_H
#define __PMMINTRIN_H

#ifndef __SSE3__
#error "SSE3 instruction set not enabled"
#else

#include <emmintrin.h>

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_lddqu_si128(__m128i const *p)
{
  return (__m128i)__builtin_ia32_lddqu((char const *)p);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_addsub_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_addsubps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_haddps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_hsubps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehdup_ps(__m128 a)
{
  return __builtin_shufflevector(a, a, 1, 1, 3, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_moveldup_ps(__m128 a)
{
  return __builtin_shufflevector(a, a, 0, 0, 2, 2);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_addsub_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_addsubpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_haddpd(a, b);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pd(__m128d a, __m128d b)
{
  return __builtin_ia32_hsubpd(a, b);
}

#define        _mm_loaddup_pd(dp)        _mm_load1_pd(dp)

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_movedup_pd(__m128d a)
{
  return __builtin_shufflevector(a, a, 0, 0);
}

#define _MM_DENORMALS_ZERO_ON   (0x0040)
#define _MM_DENORMALS_ZERO_OFF  (0x0000)

#define _MM_DENORMALS_ZERO_MASK (0x0040)

#define _MM_GET_DENORMALS_ZERO_MODE() (_mm_getcsr() & _MM_DENORMALS_ZERO_MASK)
#define _MM_SET_DENORMALS_ZERO_MODE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_DENORMALS_ZERO_MASK) | (x)))

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_monitor(void const *p, unsigned extensions, unsigned hints)
{
  __builtin_ia32_monitor((void *)p, extensions, hints);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_mwait(unsigned extensions, unsigned hints)
{
  __builtin_ia32_mwait(extensions, hints);
}

#endif /* __SSE3__ */

#endif /* __PMMINTRIN_H */
                                                                                                                                                                                                                                                                                                                                                                                                                  smmintrin.h                                                                                         0100644 0001750 0001750 00000041350 11675013170 035332  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- smmintrin.h - SSE4 intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef _SMMINTRIN_H
#define _SMMINTRIN_H

#ifndef __SSE4_1__
#error "SSE4.1 instruction set not enabled"
#else

#include <tmmintrin.h>

/* SSE4 Rounding macros. */
#define _MM_FROUND_TO_NEAREST_INT    0x00
#define _MM_FROUND_TO_NEG_INF        0x01
#define _MM_FROUND_TO_POS_INF        0x02
#define _MM_FROUND_TO_ZERO           0x03
#define _MM_FROUND_CUR_DIRECTION     0x04

#define _MM_FROUND_RAISE_EXC         0x00
#define _MM_FROUND_NO_EXC            0x08

#define _MM_FROUND_NINT      (_MM_FROUND_RAISE_EXC | _MM_FROUND_TO_NEAREST_INT)
#define _MM_FROUND_FLOOR     (_MM_FROUND_RAISE_EXC | _MM_FROUND_TO_NEG_INF)
#define _MM_FROUND_CEIL      (_MM_FROUND_RAISE_EXC | _MM_FROUND_TO_POS_INF)
#define _MM_FROUND_TRUNC     (_MM_FROUND_RAISE_EXC | _MM_FROUND_TO_ZERO)
#define _MM_FROUND_RINT      (_MM_FROUND_RAISE_EXC | _MM_FROUND_CUR_DIRECTION)
#define _MM_FROUND_NEARBYINT (_MM_FROUND_NO_EXC | _MM_FROUND_CUR_DIRECTION)

#define _mm_ceil_ps(X)       _mm_round_ps((X), _MM_FROUND_CEIL)
#define _mm_ceil_pd(X)       _mm_round_pd((X), _MM_FROUND_CEIL)
#define _mm_ceil_ss(X, Y)    _mm_round_ss((X), (Y), _MM_FROUND_CEIL)
#define _mm_ceil_sd(X, Y)    _mm_round_sd((X), (Y), _MM_FROUND_CEIL)

#define _mm_floor_ps(X)      _mm_round_ps((X), _MM_FROUND_FLOOR)
#define _mm_floor_pd(X)      _mm_round_pd((X), _MM_FROUND_FLOOR)
#define _mm_floor_ss(X, Y)   _mm_round_ss((X), (Y), _MM_FROUND_FLOOR)
#define _mm_floor_sd(X, Y)   _mm_round_sd((X), (Y), _MM_FROUND_FLOOR)

#define _mm_round_ps(X, Y)      __builtin_ia32_roundps((X), (Y))
#define _mm_round_ss(X, Y, M)   __builtin_ia32_roundss((X), (Y), (M))
#define _mm_round_pd(X, M)      __builtin_ia32_roundpd((X), (M))
#define _mm_round_sd(X, Y, M)   __builtin_ia32_roundsd((X), (Y), (M))

/* SSE4 Packed Blending Intrinsics.  */
static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_blend_pd (__m128d __V1, __m128d __V2, const int __M)
{
  return (__m128d) __builtin_ia32_blendpd ((__v2df)__V1, (__v2df)__V2, __M);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_blend_ps (__m128 __V1, __m128 __V2, const int __M)
{
  return (__m128) __builtin_ia32_blendps ((__v4sf)__V1, (__v4sf)__V2, __M);
}

static __inline__ __m128d __attribute__((__always_inline__, __nodebug__))
_mm_blendv_pd (__m128d __V1, __m128d __V2, __m128d __M)
{
  return (__m128d) __builtin_ia32_blendvpd ((__v2df)__V1, (__v2df)__V2,
                                            (__v2df)__M);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_blendv_ps (__m128 __V1, __m128 __V2, __m128 __M)
{
  return (__m128) __builtin_ia32_blendvps ((__v4sf)__V1, (__v4sf)__V2,
                                           (__v4sf)__M);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_blendv_epi8 (__m128i __V1, __m128i __V2, __m128i __M)
{
  return (__m128i) __builtin_ia32_pblendvb128 ((__v16qi)__V1, (__v16qi)__V2,
                                               (__v16qi)__M);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_blend_epi16 (__m128i __V1, __m128i __V2, const int __M)
{
  return (__m128i) __builtin_ia32_pblendw128 ((__v8hi)__V1, (__v8hi)__V2, __M);
}

/* SSE4 Dword Multiply Instructions.  */
static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mullo_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) ((__v4si)__V1 * (__v4si)__V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mul_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmuldq128 ((__v4si)__V1, (__v4si)__V2);
}

/* SSE4 Floating Point Dot Product Instructions.  */
#define _mm_dp_ps(X, Y, M) __builtin_ia32_dpps ((X), (Y), (M))
#define _mm_dp_pd(X, Y, M) __builtin_ia32_dppd ((X), (Y), (M))

/* SSE4 Streaming Load Hint Instruction.  */
static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_stream_load_si128 (__m128i *__V)
{
  return (__m128i) __builtin_ia32_movntdqa ((__v2di *) __V);
}

/* SSE4 Packed Integer Min/Max Instructions.  */
static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsb128 ((__v16qi) __V1, (__v16qi) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi8 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsb128 ((__v16qi) __V1, (__v16qi) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminuw128 ((__v8hi) __V1, (__v8hi) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu16 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxuw128 ((__v8hi) __V1, (__v8hi) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminsd128 ((__v4si) __V1, (__v4si) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epi32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxsd128 ((__v4si) __V1, (__v4si) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_min_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pminud128((__v4si) __V1, (__v4si) __V2);
}

static __inline__  __m128i __attribute__((__always_inline__, __nodebug__))
_mm_max_epu32 (__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pmaxud128((__v4si) __V1, (__v4si) __V2);
}

/* SSE4 Insertion and Extraction from XMM Register Instructions.  */
#define _mm_insert_ps(X, Y, N) __builtin_ia32_insertps128((X), (Y), (N))
#define _mm_extract_ps(X, N) (__extension__                      \
                              ({ union { int i; float f; } __t;  \
                                 __v4sf __a = (__v4sf)(X);       \
                                 __t.f = __a[N];                 \
                                 __t.i;}))

/* Miscellaneous insert and extract macros.  */
/* Extract a single-precision float from X at index N into D.  */
#define _MM_EXTRACT_FLOAT(D, X, N) (__extension__ ({ __v4sf __a = (__v4sf)(X); \
                                                    (D) = __a[N]; }))
                                                    
/* Or together 2 sets of indexes (X and Y) with the zeroing bits (Z) to create
   an index suitable for _mm_insert_ps.  */
#define _MM_MK_INSERTPS_NDX(X, Y, Z) (((X) << 6) | ((Y) << 4) | (Z))
                                           
/* Extract a float from X at index N into the first index of the return.  */
#define _MM_PICK_OUT_PS(X, N) _mm_insert_ps (_mm_setzero_ps(), (X),   \
                                             _MM_MK_INSERTPS_NDX((N), 0, 0x0e))
                                             
/* Insert int into packed integer array at index.  */
#define _mm_insert_epi8(X, I, N) (__extension__ ({ __v16qi __a = (__v16qi)(X); \
                                                   __a[N] = I;               \
                                                   __a;}))
#define _mm_insert_epi32(X, I, N) (__extension__ ({ __v4si __a = (__v4si)(X); \
                                                    __a[N] = I;             \
                                                    __a;}))
#ifdef __x86_64__
#define _mm_insert_epi64(X, I, N) (__extension__ ({ __v2di __a = (__v2di)(X); \
                                                    __a[N] = I;             \
                                                    __a;}))
#endif /* __x86_64__ */

/* Extract int from packed integer array at index.  This returns the element
 * as a zero extended value, so it is unsigned.
 */
#define _mm_extract_epi8(X, N) (__extension__ ({ __v16qi __a = (__v16qi)(X); \
                                                 (unsigned char)__a[N];}))
#define _mm_extract_epi32(X, N) (__extension__ ({ __v4si __a = (__v4si)(X); \
                                                  (unsigned)__a[N];}))
#ifdef __x86_64__
#define _mm_extract_epi64(X, N) (__extension__ ({ __v2di __a = (__v2di)(X); \
                                                  __a[N];}))
#endif /* __x86_64 */

/* SSE4 128-bit Packed Integer Comparisons.  */
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_testz_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestz128((__v2di)__M, (__v2di)__V);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_testc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestc128((__v2di)__M, (__v2di)__V);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_testnzc_si128(__m128i __M, __m128i __V)
{
  return __builtin_ia32_ptestnzc128((__v2di)__M, (__v2di)__V);
}

#define _mm_test_all_ones(V) _mm_testc_si128((V), _mm_cmpeq_epi32((V), (V)))
#define _mm_test_mix_ones_zeros(M, V) _mm_testnzc_si128((M), (V))
#define _mm_test_all_zeros(M, V) _mm_testz_si128 ((V), (V))

/* SSE4 64-bit Packed Integer Comparisons.  */
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_epi64(__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_pcmpeqq((__v2di)__V1, (__v2di)__V2);
}

/* SSE4 Packed Integer Sign-Extension.  */
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi8_epi16(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxbw128((__v16qi) __V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi8_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxbd128((__v16qi) __V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi8_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxbq128((__v16qi) __V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi16_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxwd128((__v8hi) __V); 
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi16_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxwq128((__v8hi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepi32_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovsxdq128((__v4si)__V);
}

/* SSE4 Packed Integer Zero-Extension.  */
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu8_epi16(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbw128((__v16qi) __V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu8_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbd128((__v16qi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu8_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxbq128((__v16qi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu16_epi32(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxwd128((__v8hi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu16_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxwq128((__v8hi)__V);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cvtepu32_epi64(__m128i __V)
{
  return (__m128i) __builtin_ia32_pmovzxdq128((__v4si)__V);
}

/* SSE4 Pack with Unsigned Saturation.  */
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_packus_epi32(__m128i __V1, __m128i __V2)
{
  return (__m128i) __builtin_ia32_packusdw128((__v4si)__V1, (__v4si)__V2);
}

/* SSE4 Multiple Packed Sums of Absolute Difference.  */
#define _mm_mpsadbw_epu8(X, Y, M) __builtin_ia32_mpsadbw128((X), (Y), (M))

/* These definitions are normally in nmmintrin.h, but gcc puts them in here
   so we'll do the same.  */
#ifdef __SSE4_2__

/* These specify the type of data that we're comparing.  */
#define _SIDD_UBYTE_OPS                 0x00
#define _SIDD_UWORD_OPS                 0x01
#define _SIDD_SBYTE_OPS                 0x02
#define _SIDD_SWORD_OPS                 0x03

/* These specify the type of comparison operation.  */
#define _SIDD_CMP_EQUAL_ANY             0x00
#define _SIDD_CMP_RANGES                0x04
#define _SIDD_CMP_EQUAL_EACH            0x08
#define _SIDD_CMP_EQUAL_ORDERED         0x0c

/* These macros specify the polarity of the operation.  */
#define _SIDD_POSITIVE_POLARITY         0x00
#define _SIDD_NEGATIVE_POLARITY         0x10
#define _SIDD_MASKED_POSITIVE_POLARITY  0x20
#define _SIDD_MASKED_NEGATIVE_POLARITY  0x30

/* These macros are used in _mm_cmpXstri() to specify the return.  */
#define _SIDD_LEAST_SIGNIFICANT         0x00
#define _SIDD_MOST_SIGNIFICANT          0x40

/* These macros are used in _mm_cmpXstri() to specify the return.  */
#define _SIDD_BIT_MASK                  0x00
#define _SIDD_UNIT_MASK                 0x40

/* SSE4.2 Packed Comparison Intrinsics.  */
#define _mm_cmpistrm(A, B, M) __builtin_ia32_pcmpistrm128((A), (B), (M))
#define _mm_cmpistri(A, B, M) __builtin_ia32_pcmpistri128((A), (B), (M))

#define _mm_cmpestrm(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestrm128((A), (LA), (B), (LB), (M))
#define _mm_cmpestri(X, LX, Y, LY, M) \
     __builtin_ia32_pcmpestri128((A), (LA), (B), (LB), (M))
     
/* SSE4.2 Packed Comparison Intrinsics and EFlag Reading.  */
#define _mm_cmpistra(A, B, M) \
     __builtin_ia32_pcmpistria128((A), (B), (M))
#define _mm_cmpistrc(A, B, M) \
     __builtin_ia32_pcmpistric128((A), (B), (M))
#define _mm_cmpistro(A, B, M) \
     __builtin_ia32_pcmpistrio128((A), (B), (M))
#define _mm_cmpistrs(A, B, M) \
     __builtin_ia32_pcmpistris128((A), (B), (M))
#define _mm_cmpistrz(A, B, M) \
     __builtin_ia32_pcmpistriz128((A), (B), (M))

#define _mm_cmpestra(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestria128((A), (LA), (B), (LB), (M))
#define _mm_cmpestrc(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestric128((A), (LA), (B), (LB), (M))
#define _mm_cmpestro(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestrio128((A), (LA), (B), (LB), (M))
#define _mm_cmpestrs(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestris128((A), (LA), (B), (LB), (M))
#define _mm_cmpestrz(A, LA, B, LB, M) \
     __builtin_ia32_pcmpestriz128((A), (LA), (B), (LB), (M))

/* SSE4.2 Compare Packed Data -- Greater Than.  */
static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_epi64(__m128i __V1, __m128i __V2)
{
  return __builtin_ia32_pcmpgtq((__v2di)__V1, (__v2di)__V2);
}

/* SSE4.2 Accumulate CRC32.  */
static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_crc32_u8(unsigned int __C, unsigned char __D)
{
  return __builtin_ia32_crc32qi(__C, __D);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_crc32_u16(unsigned int __C, unsigned short __D)
{
  return __builtin_ia32_crc32hi(__C, __D);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_crc32_u32(unsigned int __C, unsigned int __D)
{
  return __builtin_ia32_crc32si(__C, __D);
}

#ifdef __x86_64__
static __inline__ unsigned long long __attribute__((__always_inline__, __nodebug__))
_mm_crc32_u64(unsigned long long __C, unsigned long long __D)
{
  return __builtin_ia32_crc32di(__C, __D);
}
#endif /* __x86_64__ */

/* SSE4.2 Population Count.  */
static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_popcnt_u32(unsigned int __A)
{
  return __builtin_popcount(__A);
}

#ifdef __x86_64__
static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_popcnt_u64(unsigned long long __A)
{
  return __builtin_popcountll(__A);
}
#endif /* __x86_64__ */

#endif /* __SSE4_2__ */
#endif /* __SSE4_1__ */

#endif /* _SMMINTRIN_H */
                                                                                                                                                                                                                                                                                        stdalign.h                                                                                          0100644 0001750 0001750 00000002532 11675013170 035116  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- stdalign.h - Standard header for alignment ------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDALIGN_H
#define __STDALIGN_H

#define alignas _Alignas
#define __alignas_is_defined 1

#endif /* __STDALIGN_H */
                                                                                                                                                                      stdarg.h                                                                                            0100644 0001750 0001750 00000004020 11640174631 034571  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- stdarg.h - Variable argument handling ----------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDARG_H
#define __STDARG_H

#ifndef _VA_LIST
typedef __builtin_va_list va_list;
#define _VA_LIST
#endif
#define va_start(ap, param) __builtin_va_start(ap, param)
#define va_end(ap)          __builtin_va_end(ap)
#define va_arg(ap, type)    __builtin_va_arg(ap, type)

/* GCC always defines __va_copy, but does not define va_copy unless in c99 mode
 * or -ansi is not specified, since it was not part of C90.
 */
#define __va_copy(d,s) __builtin_va_copy(d,s)

#if __STDC_VERSION__ >= 199900L || __cplusplus >= 201103L || !defined(__STRICT_ANSI__)
#define va_copy(dest, src)  __builtin_va_copy(dest, src)
#endif

/* Hack required to make standard headers work, at least on Ubuntu */
#define __GNUC_VA_LIST 1
typedef __builtin_va_list __gnuc_va_list;

#endif /* __STDARG_H */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                stdbool.h                                                                                           0100644 0001750 0001750 00000003302 11640174631 034755  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- stdbool.h - Standard header for booleans -------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDBOOL_H
#define __STDBOOL_H

/* Don't define bool, true, and false in C++, except as a GNU extension. */
#ifndef __cplusplus
#define bool _Bool
#define true 1
#define false 0
#elif defined(__GNUC__) && !defined(__STRICT_ANSI__)
/* Define _Bool, bool, false, true as a GNU extension. */
#define _Bool bool
#define bool  bool
#define false false
#define true  true
#endif

#define __bool_true_false_are_defined 1

#endif /* __STDBOOL_H */
                                                                                                                                                                                                                                                                                                                              stddef.h                                                                                            0100644 0001750 0001750 00000004070 11640174631 034563  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- stddef.h - Basic type definitions --------------------------------===
 *
 * Copyright (c) 2008 Eli Friedman
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __STDDEF_H
#define __STDDEF_H

#ifndef _PTRDIFF_T
#define _PTRDIFF_T
typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;
#endif
#ifndef _SIZE_T
#define _SIZE_T
typedef __typeof__(sizeof(int)) size_t;
#endif
#ifndef __cplusplus
#ifndef _WCHAR_T
#define _WCHAR_T
typedef __WCHAR_TYPE__ wchar_t;
#endif
#endif

#undef NULL
#ifdef __cplusplus
#undef __null  // VC++ hack.
#define NULL __null
#else
#define NULL ((void*)0)
#endif

#define offsetof(t, d) __builtin_offsetof(t, d)

#endif /* __STDDEF_H */

/* Some C libraries expect to see a wint_t here. Others (notably MinGW) will use
__WINT_TYPE__ directly; accommodate both by requiring __need_wint_t */
#if defined(__need_wint_t)
#if !defined(_WINT_T)
#define _WINT_T
typedef __WINT_TYPE__ wint_t;
#endif /* _WINT_T */
#undef __need_wint_t
#endif /* __need_wint_t */
                                                                                                                                                                                                                                                                                                                                                                                                                                                                        stdint.h                                                                                            0100644 0001750 0001750 00000053244 11640174631 034626  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- stdint.h - Standard header for sized integer types --------------===*\
 *
 * Copyright (c) 2009 Chris Lattner
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __CLANG_STDINT_H
#define __CLANG_STDINT_H

/* If we're hosted, fall back to the system's stdint.h, which might have
 * additional definitions.
 */
#if __STDC_HOSTED__ && \
    defined(__has_include_next) && __has_include_next(<stdint.h>)
# include_next <stdint.h>
#else

/* C99 7.18.1.1 Exact-width integer types.
 * C99 7.18.1.2 Minimum-width integer types.
 * C99 7.18.1.3 Fastest minimum-width integer types.
 *
 * The standard requires that exact-width type be defined for 8-, 16-, 32-, and 
 * 64-bit types if they are implemented. Other exact width types are optional.
 * This implementation defines an exact-width types for every integer width
 * that is represented in the standard integer types.
 *
 * The standard also requires minimum-width types be defined for 8-, 16-, 32-,
 * and 64-bit widths regardless of whether there are corresponding exact-width
 * types. 
 *
 * To accommodate targets that are missing types that are exactly 8, 16, 32, or
 * 64 bits wide, this implementation takes an approach of cascading
 * redefintions, redefining __int_leastN_t to successively smaller exact-width
 * types. It is therefore important that the types are defined in order of
 * descending widths.
 *
 * We currently assume that the minimum-width types and the fastest
 * minimum-width types are the same. This is allowed by the standard, but is
 * suboptimal.
 *
 * In violation of the standard, some targets do not implement a type that is
 * wide enough to represent all of the required widths (8-, 16-, 32-, 64-bit).  
 * To accommodate these targets, a required minimum-width type is only
 * defined if there exists an exact-width type of equal or greater width.
 */

#ifdef __INT64_TYPE__
# ifndef __int8_t_defined /* glibc sys/types.h also defines int64_t*/
typedef signed __INT64_TYPE__ int64_t;
# endif /* __int8_t_defined */
typedef unsigned __INT64_TYPE__ uint64_t;
# define __int_least64_t int64_t
# define __uint_least64_t uint64_t
# define __int_least32_t int64_t
# define __uint_least32_t uint64_t
# define __int_least16_t int64_t
# define __uint_least16_t uint64_t
# define __int_least8_t int64_t
# define __uint_least8_t uint64_t
#endif /* __INT64_TYPE__ */

#ifdef __int_least64_t
typedef __int_least64_t int_least64_t;
typedef __uint_least64_t uint_least64_t;
typedef __int_least64_t int_fast64_t;
typedef __uint_least64_t uint_fast64_t;
#endif /* __int_least64_t */

#ifdef __INT56_TYPE__
typedef signed __INT56_TYPE__ int56_t;
typedef unsigned __INT56_TYPE__ uint56_t;
typedef int56_t int_least56_t;
typedef uint56_t uint_least56_t;
typedef int56_t int_fast56_t;
typedef uint56_t uint_fast56_t;
# define __int_least32_t int56_t
# define __uint_least32_t uint56_t
# define __int_least16_t int56_t
# define __uint_least16_t uint56_t
# define __int_least8_t int56_t
# define __uint_least8_t uint56_t
#endif /* __INT56_TYPE__ */


#ifdef __INT48_TYPE__
typedef signed __INT48_TYPE__ int48_t;
typedef unsigned __INT48_TYPE__ uint48_t;
typedef int48_t int_least48_t;
typedef uint48_t uint_least48_t;
typedef int48_t int_fast48_t;
typedef uint48_t uint_fast48_t;
# define __int_least32_t int48_t
# define __uint_least32_t uint48_t
# define __int_least16_t int48_t
# define __uint_least16_t uint48_t
# define __int_least8_t int48_t
# define __uint_least8_t uint48_t
#endif /* __INT48_TYPE__ */


#ifdef __INT40_TYPE__
typedef signed __INT40_TYPE__ int40_t;
typedef unsigned __INT40_TYPE__ uint40_t;
typedef int40_t int_least40_t;
typedef uint40_t uint_least40_t;
typedef int40_t int_fast40_t;
typedef uint40_t uint_fast40_t;
# define __int_least32_t int40_t
# define __uint_least32_t uint40_t
# define __int_least16_t int40_t
# define __uint_least16_t uint40_t
# define __int_least8_t int40_t
# define __uint_least8_t uint40_t
#endif /* __INT40_TYPE__ */


#ifdef __INT32_TYPE__

# ifndef __int8_t_defined /* glibc sys/types.h also defines int32_t*/
typedef signed __INT32_TYPE__ int32_t;
# endif /* __int8_t_defined */

# ifndef __uint32_t_defined  /* more glibc compatibility */
# define __uint32_t_defined
typedef unsigned __INT32_TYPE__ uint32_t;
# endif /* __uint32_t_defined */

# define __int_least32_t int32_t
# define __uint_least32_t uint32_t
# define __int_least16_t int32_t
# define __uint_least16_t uint32_t
# define __int_least8_t int32_t
# define __uint_least8_t uint32_t
#endif /* __INT32_TYPE__ */

#ifdef __int_least32_t
typedef __int_least32_t int_least32_t;
typedef __uint_least32_t uint_least32_t;
typedef __int_least32_t int_fast32_t;
typedef __uint_least32_t uint_fast32_t;
#endif /* __int_least32_t */

#ifdef __INT24_TYPE__
typedef signed __INT24_TYPE__ int24_t;
typedef unsigned __INT24_TYPE__ uint24_t;
typedef int24_t int_least24_t;
typedef uint24_t uint_least24_t;
typedef int24_t int_fast24_t;
typedef uint24_t uint_fast24_t;
# define __int_least16_t int24_t
# define __uint_least16_t uint24_t
# define __int_least8_t int24_t
# define __uint_least8_t uint24_t
#endif /* __INT24_TYPE__ */

#ifdef __INT16_TYPE__
#ifndef __int8_t_defined /* glibc sys/types.h also defines int16_t*/
typedef signed __INT16_TYPE__ int16_t;
#endif /* __int8_t_defined */
typedef unsigned __INT16_TYPE__ uint16_t;
# define __int_least16_t int16_t
# define __uint_least16_t uint16_t
# define __int_least8_t int16_t
# define __uint_least8_t uint16_t
#endif /* __INT16_TYPE__ */

#ifdef __int_least16_t
typedef __int_least16_t int_least16_t;
typedef __uint_least16_t uint_least16_t;
typedef __int_least16_t int_fast16_t;
typedef __uint_least16_t uint_fast16_t;
#endif /* __int_least16_t */


#ifdef __INT8_TYPE__
#ifndef __int8_t_defined  /* glibc sys/types.h also defines int8_t*/
typedef signed __INT8_TYPE__ int8_t;
#endif /* __int8_t_defined */
typedef unsigned __INT8_TYPE__ uint8_t;
# define __int_least8_t int8_t
# define __uint_least8_t uint8_t
#endif /* __INT8_TYPE__ */

#ifdef __int_least8_t
typedef __int_least8_t int_least8_t;
typedef __uint_least8_t uint_least8_t;
typedef __int_least8_t int_fast8_t;
typedef __uint_least8_t uint_fast8_t;
#endif /* __int_least8_t */

/* prevent glibc sys/types.h from defining conflicting types */
#ifndef __int8_t_defined  
# define __int8_t_defined
#endif /* __int8_t_defined */

/* C99 7.18.1.4 Integer types capable of holding object pointers.
 */
#define __stdint_join3(a,b,c) a ## b ## c

#define  __intn_t(n) __stdint_join3( int, n, _t)
#define __uintn_t(n) __stdint_join3(uint, n, _t)

#ifndef _INTPTR_T
#ifndef __intptr_t_defined
typedef  __intn_t(__INTPTR_WIDTH__)  intptr_t;
#define __intptr_t_defined
#define _INTPTR_T
#endif
#endif

#ifndef _UINTPTR_T
typedef __uintn_t(__INTPTR_WIDTH__) uintptr_t;
#define _UINTPTR_T
#endif

/* C99 7.18.1.5 Greatest-width integer types.
 */
typedef __INTMAX_TYPE__  intmax_t;
typedef __UINTMAX_TYPE__ uintmax_t;

/* C99 7.18.4 Macros for minimum-width integer constants.
 *
 * The standard requires that integer constant macros be defined for all the
 * minimum-width types defined above. As 8-, 16-, 32-, and 64-bit minimum-width
 * types are required, the corresponding integer constant macros are defined 
 * here. This implementation also defines minimum-width types for every other
 * integer width that the target implements, so corresponding macros are 
 * defined below, too.
 *
 * These macros are defined using the same successive-shrinking approach as
 * the type definitions above. It is likewise important that macros are defined
 * in order of decending width.
 *
 * Note that C++ should not check __STDC_CONSTANT_MACROS here, contrary to the
 * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).
 */

#define __int_c_join(a, b) a ## b
#define __int_c(v, suffix) __int_c_join(v, suffix)
#define __uint_c(v, suffix) __int_c_join(v##U, suffix)


#ifdef __INT64_TYPE__
# ifdef __INT64_C_SUFFIX__
#  define __int64_c_suffix __INT64_C_SUFFIX__
#  define __int32_c_suffix __INT64_C_SUFFIX__
#  define __int16_c_suffix __INT64_C_SUFFIX__
#  define  __int8_c_suffix __INT64_C_SUFFIX__
# else
#  undef __int64_c_suffix
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT64_C_SUFFIX__ */
#endif /* __INT64_TYPE__ */

#ifdef __int_least64_t
# ifdef __int64_c_suffix
#  define INT64_C(v) __int_c(v, __int64_c_suffix)
#  define UINT64_C(v) __uint_c(v, __int64_c_suffix)
# else
#  define INT64_C(v) v
#  define UINT64_C(v) v ## U
# endif /* __int64_c_suffix */
#endif /* __int_least64_t */


#ifdef __INT56_TYPE__
# ifdef __INT56_C_SUFFIX__
#  define INT56_C(v) __int_c(v, __INT56_C_SUFFIX__)
#  define UINT56_C(v) __uint_c(v, __INT56_C_SUFFIX__)
#  define __int32_c_suffix __INT56_C_SUFFIX__
#  define __int16_c_suffix __INT56_C_SUFFIX__
#  define __int8_c_suffix  __INT56_C_SUFFIX__
# else
#  define INT56_C(v) v
#  define UINT56_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT56_C_SUFFIX__ */
#endif /* __INT56_TYPE__ */


#ifdef __INT48_TYPE__
# ifdef __INT48_C_SUFFIX__
#  define INT48_C(v) __int_c(v, __INT48_C_SUFFIX__)
#  define UINT48_C(v) __uint_c(v, __INT48_C_SUFFIX__)
#  define __int32_c_suffix __INT48_C_SUFFIX__
#  define __int16_c_suffix __INT48_C_SUFFIX__
#  define __int8_c_suffix  __INT48_C_SUFFIX__
# else
#  define INT48_C(v) v
#  define UINT48_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT48_C_SUFFIX__ */
#endif /* __INT48_TYPE__ */


#ifdef __INT40_TYPE__
# ifdef __INT40_C_SUFFIX__
#  define INT40_C(v) __int_c(v, __INT40_C_SUFFIX__)
#  define UINT40_C(v) __uint_c(v, __INT40_C_SUFFIX__)
#  define __int32_c_suffix __INT40_C_SUFFIX__
#  define __int16_c_suffix __INT40_C_SUFFIX__
#  define __int8_c_suffix  __INT40_C_SUFFIX__
# else
#  define INT40_C(v) v
#  define UINT40_C(v) v ## U
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT40_C_SUFFIX__ */
#endif /* __INT40_TYPE__ */


#ifdef __INT32_TYPE__
# ifdef __INT32_C_SUFFIX__
#  define __int32_c_suffix __INT32_C_SUFFIX__
#  define __int16_c_suffix __INT32_C_SUFFIX__
#  define __int8_c_suffix  __INT32_C_SUFFIX__
#else
#  undef __int32_c_suffix
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT32_C_SUFFIX__ */
#endif /* __INT32_TYPE__ */

#ifdef __int_least32_t
# ifdef __int32_c_suffix
#  define INT32_C(v) __int_c(v, __int32_c_suffix)
#  define UINT32_C(v) __uint_c(v, __int32_c_suffix)
# else
#  define INT32_C(v) v
#  define UINT32_C(v) v ## U
# endif /* __int32_c_suffix */
#endif /* __int_least32_t */


#ifdef __INT24_TYPE__
# ifdef __INT24_C_SUFFIX__
#  define INT24_C(v) __int_c(v, __INT24_C_SUFFIX__)
#  define UINT24_C(v) __uint_c(v, __INT24_C_SUFFIX__)
#  define __int16_c_suffix __INT24_C_SUFFIX__
#  define __int8_c_suffix  __INT24_C_SUFFIX__
# else
#  define INT24_C(v) v
#  define UINT24_C(v) v ## U
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT24_C_SUFFIX__ */
#endif /* __INT24_TYPE__ */


#ifdef __INT16_TYPE__
# ifdef __INT16_C_SUFFIX__
#  define __int16_c_suffix __INT16_C_SUFFIX__
#  define __int8_c_suffix  __INT16_C_SUFFIX__
#else
#  undef __int16_c_suffix
#  undef  __int8_c_suffix
# endif /* __INT16_C_SUFFIX__ */
#endif /* __INT16_TYPE__ */

#ifdef __int_least16_t
# ifdef __int16_c_suffix
#  define INT16_C(v) __int_c(v, __int16_c_suffix)
#  define UINT16_C(v) __uint_c(v, __int16_c_suffix)
# else
#  define INT16_C(v) v
#  define UINT16_C(v) v ## U
# endif /* __int16_c_suffix */
#endif /* __int_least16_t */


#ifdef __INT8_TYPE__
# ifdef __INT8_C_SUFFIX__
#  define __int8_c_suffix __INT8_C_SUFFIX__
#else
#  undef  __int8_c_suffix
# endif /* __INT8_C_SUFFIX__ */
#endif /* __INT8_TYPE__ */

#ifdef __int_least8_t
# ifdef __int8_c_suffix
#  define INT8_C(v) __int_c(v, __int8_c_suffix)
#  define UINT8_C(v) __uint_c(v, __int8_c_suffix)
# else
#  define INT8_C(v) v
#  define UINT8_C(v) v ## U
# endif /* __int8_c_suffix */
#endif /* __int_least8_t */


/* C99 7.18.2.1 Limits of exact-width integer types. 
 * C99 7.18.2.2 Limits of minimum-width integer types.
 * C99 7.18.2.3 Limits of fastest minimum-width integer types.
 *
 * The presence of limit macros are completely optional in C99.  This
 * implementation defines limits for all of the types (exact- and
 * minimum-width) that it defines above, using the limits of the minimum-width
 * type for any types that do not have exact-width representations.
 *
 * As in the type definitions, this section takes an approach of
 * successive-shrinking to determine which limits to use for the standard (8,
 * 16, 32, 64) bit widths when they don't have exact representations. It is
 * therefore important that the defintions be kept in order of decending
 * widths.
 *
 * Note that C++ should not check __STDC_LIMIT_MACROS here, contrary to the
 * claims of the C standard (see C++ 18.3.1p2, [cstdint.syn]).
 */

#ifdef __INT64_TYPE__
# define INT64_MAX           INT64_C( 9223372036854775807)
# define INT64_MIN         (-INT64_C( 9223372036854775807)-1)
# define UINT64_MAX         UINT64_C(18446744073709551615)
# define __INT_LEAST64_MIN   INT64_MIN
# define __INT_LEAST64_MAX   INT64_MAX
# define __UINT_LEAST64_MAX UINT64_MAX
# define __INT_LEAST32_MIN   INT64_MIN
# define __INT_LEAST32_MAX   INT64_MAX
# define __UINT_LEAST32_MAX UINT64_MAX
# define __INT_LEAST16_MIN   INT64_MIN
# define __INT_LEAST16_MAX   INT64_MAX
# define __UINT_LEAST16_MAX UINT64_MAX
# define __INT_LEAST8_MIN    INT64_MIN
# define __INT_LEAST8_MAX    INT64_MAX
# define __UINT_LEAST8_MAX  UINT64_MAX
#endif /* __INT64_TYPE__ */

#ifdef __INT_LEAST64_MIN
# define INT_LEAST64_MIN   __INT_LEAST64_MIN
# define INT_LEAST64_MAX   __INT_LEAST64_MAX
# define UINT_LEAST64_MAX __UINT_LEAST64_MAX
# define INT_FAST64_MIN    __INT_LEAST64_MIN
# define INT_FAST64_MAX    __INT_LEAST64_MAX
# define UINT_FAST64_MAX  __UINT_LEAST64_MAX
#endif /* __INT_LEAST64_MIN */


#ifdef __INT56_TYPE__
# define INT56_MAX           INT56_C(36028797018963967)
# define INT56_MIN         (-INT56_C(36028797018963967)-1)
# define UINT56_MAX         UINT56_C(72057594037927935)
# define INT_LEAST56_MIN     INT56_MIN
# define INT_LEAST56_MAX     INT56_MAX
# define UINT_LEAST56_MAX   UINT56_MAX
# define INT_FAST56_MIN      INT56_MIN
# define INT_FAST56_MAX      INT56_MAX
# define UINT_FAST56_MAX    UINT56_MAX
# define __INT_LEAST32_MIN   INT56_MIN
# define __INT_LEAST32_MAX   INT56_MAX
# define __UINT_LEAST32_MAX UINT56_MAX
# define __INT_LEAST16_MIN   INT56_MIN
# define __INT_LEAST16_MAX   INT56_MAX
# define __UINT_LEAST16_MAX UINT56_MAX
# define __INT_LEAST8_MIN    INT56_MIN
# define __INT_LEAST8_MAX    INT56_MAX
# define __UINT_LEAST8_MAX  UINT56_MAX
#endif /* __INT56_TYPE__ */


#ifdef __INT48_TYPE__
# define INT48_MAX           INT48_C(140737488355327)
# define INT48_MIN         (-INT48_C(140737488355327)-1)
# define UINT48_MAX         UINT48_C(281474976710655)
# define INT_LEAST48_MIN     INT48_MIN
# define INT_LEAST48_MAX     INT48_MAX
# define UINT_LEAST48_MAX   UINT48_MAX
# define INT_FAST48_MIN      INT48_MIN
# define INT_FAST48_MAX      INT48_MAX
# define UINT_FAST48_MAX    UINT48_MAX
# define __INT_LEAST32_MIN   INT48_MIN
# define __INT_LEAST32_MAX   INT48_MAX
# define __UINT_LEAST32_MAX UINT48_MAX
# define __INT_LEAST16_MIN   INT48_MIN
# define __INT_LEAST16_MAX   INT48_MAX
# define __UINT_LEAST16_MAX UINT48_MAX
# define __INT_LEAST8_MIN    INT48_MIN
# define __INT_LEAST8_MAX    INT48_MAX
# define __UINT_LEAST8_MAX  UINT48_MAX
#endif /* __INT48_TYPE__ */


#ifdef __INT40_TYPE__
# define INT40_MAX           INT40_C(549755813887)
# define INT40_MIN         (-INT40_C(549755813887)-1)
# define UINT40_MAX         UINT40_C(1099511627775)
# define INT_LEAST40_MIN     INT40_MIN
# define INT_LEAST40_MAX     INT40_MAX
# define UINT_LEAST40_MAX   UINT40_MAX
# define INT_FAST40_MIN      INT40_MIN
# define INT_FAST40_MAX      INT40_MAX
# define UINT_FAST40_MAX    UINT40_MAX
# define __INT_LEAST32_MIN   INT40_MIN
# define __INT_LEAST32_MAX   INT40_MAX
# define __UINT_LEAST32_MAX UINT40_MAX
# define __INT_LEAST16_MIN   INT40_MIN
# define __INT_LEAST16_MAX   INT40_MAX
# define __UINT_LEAST16_MAX UINT40_MAX
# define __INT_LEAST8_MIN    INT40_MIN
# define __INT_LEAST8_MAX    INT40_MAX
# define __UINT_LEAST8_MAX  UINT40_MAX
#endif /* __INT40_TYPE__ */


#ifdef __INT32_TYPE__
# define INT32_MAX           INT32_C(2147483647)
# define INT32_MIN         (-INT32_C(2147483647)-1)
# define UINT32_MAX         UINT32_C(4294967295)
# define __INT_LEAST32_MIN   INT32_MIN
# define __INT_LEAST32_MAX   INT32_MAX
# define __UINT_LEAST32_MAX UINT32_MAX
# define __INT_LEAST16_MIN   INT32_MIN
# define __INT_LEAST16_MAX   INT32_MAX
# define __UINT_LEAST16_MAX UINT32_MAX
# define __INT_LEAST8_MIN    INT32_MIN
# define __INT_LEAST8_MAX    INT32_MAX
# define __UINT_LEAST8_MAX  UINT32_MAX
#endif /* __INT32_TYPE__ */

#ifdef __INT_LEAST32_MIN
# define INT_LEAST32_MIN   __INT_LEAST32_MIN
# define INT_LEAST32_MAX   __INT_LEAST32_MAX
# define UINT_LEAST32_MAX __UINT_LEAST32_MAX
# define INT_FAST32_MIN    __INT_LEAST32_MIN
# define INT_FAST32_MAX    __INT_LEAST32_MAX
# define UINT_FAST32_MAX  __UINT_LEAST32_MAX
#endif /* __INT_LEAST32_MIN */


#ifdef __INT24_TYPE__
# define INT24_MAX           INT24_C(8388607)
# define INT24_MIN         (-INT24_C(8388607)-1)
# define UINT24_MAX         UINT24_C(16777215)
# define INT_LEAST24_MIN     INT24_MIN
# define INT_LEAST24_MAX     INT24_MAX
# define UINT_LEAST24_MAX   UINT24_MAX
# define INT_FAST24_MIN      INT24_MIN
# define INT_FAST24_MAX      INT24_MAX
# define UINT_FAST24_MAX    UINT24_MAX
# define __INT_LEAST16_MIN   INT24_MIN
# define __INT_LEAST16_MAX   INT24_MAX
# define __UINT_LEAST16_MAX UINT24_MAX
# define __INT_LEAST8_MIN    INT24_MIN
# define __INT_LEAST8_MAX    INT24_MAX
# define __UINT_LEAST8_MAX  UINT24_MAX
#endif /* __INT24_TYPE__ */


#ifdef __INT16_TYPE__
#define INT16_MAX            INT16_C(32767)
#define INT16_MIN          (-INT16_C(32767)-1)
#define UINT16_MAX          UINT16_C(65535)
# define __INT_LEAST16_MIN   INT16_MIN
# define __INT_LEAST16_MAX   INT16_MAX
# define __UINT_LEAST16_MAX UINT16_MAX
# define __INT_LEAST8_MIN    INT16_MIN
# define __INT_LEAST8_MAX    INT16_MAX
# define __UINT_LEAST8_MAX  UINT16_MAX
#endif /* __INT16_TYPE__ */

#ifdef __INT_LEAST16_MIN
# define INT_LEAST16_MIN   __INT_LEAST16_MIN
# define INT_LEAST16_MAX   __INT_LEAST16_MAX
# define UINT_LEAST16_MAX __UINT_LEAST16_MAX
# define INT_FAST16_MIN    __INT_LEAST16_MIN
# define INT_FAST16_MAX    __INT_LEAST16_MAX
# define UINT_FAST16_MAX  __UINT_LEAST16_MAX
#endif /* __INT_LEAST16_MIN */


#ifdef __INT8_TYPE__
# define INT8_MAX            INT8_C(127)
# define INT8_MIN          (-INT8_C(127)-1)
# define UINT8_MAX          UINT8_C(255)
# define __INT_LEAST8_MIN    INT8_MIN
# define __INT_LEAST8_MAX    INT8_MAX
# define __UINT_LEAST8_MAX  UINT8_MAX
#endif /* __INT8_TYPE__ */

#ifdef __INT_LEAST8_MIN
# define INT_LEAST8_MIN   __INT_LEAST8_MIN
# define INT_LEAST8_MAX   __INT_LEAST8_MAX
# define UINT_LEAST8_MAX __UINT_LEAST8_MAX
# define INT_FAST8_MIN    __INT_LEAST8_MIN
# define INT_FAST8_MAX    __INT_LEAST8_MAX
# define UINT_FAST8_MAX  __UINT_LEAST8_MAX
#endif /* __INT_LEAST8_MIN */

/* Some utility macros */
#define  __INTN_MIN(n)  __stdint_join3( INT, n, _MIN)
#define  __INTN_MAX(n)  __stdint_join3( INT, n, _MAX)
#define __UINTN_MAX(n)  __stdint_join3(UINT, n, _MAX)
#define  __INTN_C(n, v) __stdint_join3( INT, n, _C(v))
#define __UINTN_C(n, v) __stdint_join3(UINT, n, _C(v))

/* C99 7.18.2.4 Limits of integer types capable of holding object pointers. */
/* C99 7.18.3 Limits of other integer types. */

#define  INTPTR_MIN  __INTN_MIN(__INTPTR_WIDTH__)
#define  INTPTR_MAX  __INTN_MAX(__INTPTR_WIDTH__)
#define UINTPTR_MAX __UINTN_MAX(__INTPTR_WIDTH__)
#define PTRDIFF_MIN  __INTN_MIN(__PTRDIFF_WIDTH__)
#define PTRDIFF_MAX  __INTN_MAX(__PTRDIFF_WIDTH__)
#define    SIZE_MAX __UINTN_MAX(__SIZE_WIDTH__)

/* C99 7.18.2.5 Limits of greatest-width integer types. */
#define INTMAX_MIN   __INTN_MIN(__INTMAX_WIDTH__)
#define INTMAX_MAX   __INTN_MAX(__INTMAX_WIDTH__)
#define UINTMAX_MAX __UINTN_MAX(__INTMAX_WIDTH__)

/* C99 7.18.3 Limits of other integer types. */
#define SIG_ATOMIC_MIN __INTN_MIN(__SIG_ATOMIC_WIDTH__)
#define SIG_ATOMIC_MAX __INTN_MAX(__SIG_ATOMIC_WIDTH__)
#ifdef __WINT_UNSIGNED__
# define WINT_MIN       __UINTN_C(__WINT_WIDTH__, 0)
# define WINT_MAX       __UINTN_MAX(__WINT_WIDTH__)
#else
# define WINT_MIN       __INTN_MIN(__WINT_WIDTH__)
# define WINT_MAX       __INTN_MAX(__WINT_WIDTH__)
#endif

#ifndef WCHAR_MAX
# define WCHAR_MAX __WCHAR_MAX__
#endif
#ifndef WCHAR_MIN
# if __WCHAR_MAX__ == __INTN_MAX(__WCHAR_WIDTH__)
#  define WCHAR_MIN __INTN_MIN(__WCHAR_WIDTH__)
# else
#  define WCHAR_MIN __UINTN_C(__WCHAR_WIDTH__, 0)
# endif
#endif

/* 7.18.4.2 Macros for greatest-width integer constants. */
#define INTMAX_C(v)   __INTN_C(__INTMAX_WIDTH__, v)
#define UINTMAX_C(v) __UINTN_C(__INTMAX_WIDTH__, v)

#endif /* __STDC_HOSTED__ */
#endif /* __CLANG_STDINT_H */
                                                                                                                                                                                                                                                                                                                                                            tgmath.h                                                                                            0100644 0001750 0001750 00000073716 11675013170 034611  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- tgmath.h - Standard header for type generic math ----------------===*\
 *
 * Copyright (c) 2009 Howard Hinnant
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
\*===----------------------------------------------------------------------===*/

#ifndef __TGMATH_H
#define __TGMATH_H

/* C99 7.22 Type-generic math <tgmath.h>. */
#include <math.h>

/* C++ handles type genericity with overloading in math.h. */
#ifndef __cplusplus
#include <complex.h>

#define _TG_ATTRSp __attribute__((__overloadable__))
#define _TG_ATTRS __attribute__((__overloadable__, __always_inline__))

// promotion

typedef void _Argument_type_is_not_arithmetic;
static _Argument_type_is_not_arithmetic __tg_promote(...)
  __attribute__((__unavailable__,__overloadable__));
static double               _TG_ATTRSp __tg_promote(int);
static double               _TG_ATTRSp __tg_promote(unsigned int);
static double               _TG_ATTRSp __tg_promote(long);
static double               _TG_ATTRSp __tg_promote(unsigned long);
static double               _TG_ATTRSp __tg_promote(long long);
static double               _TG_ATTRSp __tg_promote(unsigned long long);
static float                _TG_ATTRSp __tg_promote(float);
static double               _TG_ATTRSp __tg_promote(double);
static long double          _TG_ATTRSp __tg_promote(long double);
static float _Complex       _TG_ATTRSp __tg_promote(float _Complex);
static double _Complex      _TG_ATTRSp __tg_promote(double _Complex);
static long double _Complex _TG_ATTRSp __tg_promote(long double _Complex);

#define __tg_promote1(__x)           (__typeof__(__tg_promote(__x)))
#define __tg_promote2(__x, __y)      (__typeof__(__tg_promote(__x) + \
                                                 __tg_promote(__y)))
#define __tg_promote3(__x, __y, __z) (__typeof__(__tg_promote(__x) + \
                                                 __tg_promote(__y) + \
                                                 __tg_promote(__z)))

// acos

static float
    _TG_ATTRS
    __tg_acos(float __x) {return acosf(__x);}

static double
    _TG_ATTRS
    __tg_acos(double __x) {return acos(__x);}

static long double
    _TG_ATTRS
    __tg_acos(long double __x) {return acosl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_acos(float _Complex __x) {return cacosf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_acos(double _Complex __x) {return cacos(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_acos(long double _Complex __x) {return cacosl(__x);}

#undef acos
#define acos(__x) __tg_acos(__tg_promote1((__x))(__x))

// asin

static float
    _TG_ATTRS
    __tg_asin(float __x) {return asinf(__x);}

static double
    _TG_ATTRS
    __tg_asin(double __x) {return asin(__x);}

static long double
    _TG_ATTRS
    __tg_asin(long double __x) {return asinl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_asin(float _Complex __x) {return casinf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_asin(double _Complex __x) {return casin(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_asin(long double _Complex __x) {return casinl(__x);}

#undef asin
#define asin(__x) __tg_asin(__tg_promote1((__x))(__x))

// atan

static float
    _TG_ATTRS
    __tg_atan(float __x) {return atanf(__x);}

static double
    _TG_ATTRS
    __tg_atan(double __x) {return atan(__x);}

static long double
    _TG_ATTRS
    __tg_atan(long double __x) {return atanl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_atan(float _Complex __x) {return catanf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_atan(double _Complex __x) {return catan(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_atan(long double _Complex __x) {return catanl(__x);}

#undef atan
#define atan(__x) __tg_atan(__tg_promote1((__x))(__x))

// acosh

static float
    _TG_ATTRS
    __tg_acosh(float __x) {return acoshf(__x);}

static double
    _TG_ATTRS
    __tg_acosh(double __x) {return acosh(__x);}

static long double
    _TG_ATTRS
    __tg_acosh(long double __x) {return acoshl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_acosh(float _Complex __x) {return cacoshf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_acosh(double _Complex __x) {return cacosh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_acosh(long double _Complex __x) {return cacoshl(__x);}

#undef acosh
#define acosh(__x) __tg_acosh(__tg_promote1((__x))(__x))

// asinh

static float
    _TG_ATTRS
    __tg_asinh(float __x) {return asinhf(__x);}

static double
    _TG_ATTRS
    __tg_asinh(double __x) {return asinh(__x);}

static long double
    _TG_ATTRS
    __tg_asinh(long double __x) {return asinhl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_asinh(float _Complex __x) {return casinhf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_asinh(double _Complex __x) {return casinh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_asinh(long double _Complex __x) {return casinhl(__x);}

#undef asinh
#define asinh(__x) __tg_asinh(__tg_promote1((__x))(__x))

// atanh

static float
    _TG_ATTRS
    __tg_atanh(float __x) {return atanhf(__x);}

static double
    _TG_ATTRS
    __tg_atanh(double __x) {return atanh(__x);}

static long double
    _TG_ATTRS
    __tg_atanh(long double __x) {return atanhl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_atanh(float _Complex __x) {return catanhf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_atanh(double _Complex __x) {return catanh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_atanh(long double _Complex __x) {return catanhl(__x);}

#undef atanh
#define atanh(__x) __tg_atanh(__tg_promote1((__x))(__x))

// cos

static float
    _TG_ATTRS
    __tg_cos(float __x) {return cosf(__x);}

static double
    _TG_ATTRS
    __tg_cos(double __x) {return cos(__x);}

static long double
    _TG_ATTRS
    __tg_cos(long double __x) {return cosl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_cos(float _Complex __x) {return ccosf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_cos(double _Complex __x) {return ccos(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_cos(long double _Complex __x) {return ccosl(__x);}

#undef cos
#define cos(__x) __tg_cos(__tg_promote1((__x))(__x))

// sin

static float
    _TG_ATTRS
    __tg_sin(float __x) {return sinf(__x);}

static double
    _TG_ATTRS
    __tg_sin(double __x) {return sin(__x);}

static long double
    _TG_ATTRS
    __tg_sin(long double __x) {return sinl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_sin(float _Complex __x) {return csinf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_sin(double _Complex __x) {return csin(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_sin(long double _Complex __x) {return csinl(__x);}

#undef sin
#define sin(__x) __tg_sin(__tg_promote1((__x))(__x))

// tan

static float
    _TG_ATTRS
    __tg_tan(float __x) {return tanf(__x);}

static double
    _TG_ATTRS
    __tg_tan(double __x) {return tan(__x);}

static long double
    _TG_ATTRS
    __tg_tan(long double __x) {return tanl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_tan(float _Complex __x) {return ctanf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_tan(double _Complex __x) {return ctan(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_tan(long double _Complex __x) {return ctanl(__x);}

#undef tan
#define tan(__x) __tg_tan(__tg_promote1((__x))(__x))

// cosh

static float
    _TG_ATTRS
    __tg_cosh(float __x) {return coshf(__x);}

static double
    _TG_ATTRS
    __tg_cosh(double __x) {return cosh(__x);}

static long double
    _TG_ATTRS
    __tg_cosh(long double __x) {return coshl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_cosh(float _Complex __x) {return ccoshf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_cosh(double _Complex __x) {return ccosh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_cosh(long double _Complex __x) {return ccoshl(__x);}

#undef cosh
#define cosh(__x) __tg_cosh(__tg_promote1((__x))(__x))

// sinh

static float
    _TG_ATTRS
    __tg_sinh(float __x) {return sinhf(__x);}

static double
    _TG_ATTRS
    __tg_sinh(double __x) {return sinh(__x);}

static long double
    _TG_ATTRS
    __tg_sinh(long double __x) {return sinhl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_sinh(float _Complex __x) {return csinhf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_sinh(double _Complex __x) {return csinh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_sinh(long double _Complex __x) {return csinhl(__x);}

#undef sinh
#define sinh(__x) __tg_sinh(__tg_promote1((__x))(__x))

// tanh

static float
    _TG_ATTRS
    __tg_tanh(float __x) {return tanhf(__x);}

static double
    _TG_ATTRS
    __tg_tanh(double __x) {return tanh(__x);}

static long double
    _TG_ATTRS
    __tg_tanh(long double __x) {return tanhl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_tanh(float _Complex __x) {return ctanhf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_tanh(double _Complex __x) {return ctanh(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_tanh(long double _Complex __x) {return ctanhl(__x);}

#undef tanh
#define tanh(__x) __tg_tanh(__tg_promote1((__x))(__x))

// exp

static float
    _TG_ATTRS
    __tg_exp(float __x) {return expf(__x);}

static double
    _TG_ATTRS
    __tg_exp(double __x) {return exp(__x);}

static long double
    _TG_ATTRS
    __tg_exp(long double __x) {return expl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_exp(float _Complex __x) {return cexpf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_exp(double _Complex __x) {return cexp(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_exp(long double _Complex __x) {return cexpl(__x);}

#undef exp
#define exp(__x) __tg_exp(__tg_promote1((__x))(__x))

// log

static float
    _TG_ATTRS
    __tg_log(float __x) {return logf(__x);}

static double
    _TG_ATTRS
    __tg_log(double __x) {return log(__x);}

static long double
    _TG_ATTRS
    __tg_log(long double __x) {return logl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_log(float _Complex __x) {return clogf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_log(double _Complex __x) {return clog(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_log(long double _Complex __x) {return clogl(__x);}

#undef log
#define log(__x) __tg_log(__tg_promote1((__x))(__x))

// pow

static float
    _TG_ATTRS
    __tg_pow(float __x, float __y) {return powf(__x, __y);}

static double
    _TG_ATTRS
    __tg_pow(double __x, double __y) {return pow(__x, __y);}

static long double
    _TG_ATTRS
    __tg_pow(long double __x, long double __y) {return powl(__x, __y);}

static float _Complex
    _TG_ATTRS
    __tg_pow(float _Complex __x, float _Complex __y) {return cpowf(__x, __y);}

static double _Complex
    _TG_ATTRS
    __tg_pow(double _Complex __x, double _Complex __y) {return cpow(__x, __y);}

static long double _Complex
    _TG_ATTRS
    __tg_pow(long double _Complex __x, long double _Complex __y) 
    {return cpowl(__x, __y);}

#undef pow
#define pow(__x, __y) __tg_pow(__tg_promote2((__x), (__y))(__x), \
                               __tg_promote2((__x), (__y))(__y))

// sqrt

static float
    _TG_ATTRS
    __tg_sqrt(float __x) {return sqrtf(__x);}

static double
    _TG_ATTRS
    __tg_sqrt(double __x) {return sqrt(__x);}

static long double
    _TG_ATTRS
    __tg_sqrt(long double __x) {return sqrtl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_sqrt(float _Complex __x) {return csqrtf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_sqrt(double _Complex __x) {return csqrt(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_sqrt(long double _Complex __x) {return csqrtl(__x);}

#undef sqrt
#define sqrt(__x) __tg_sqrt(__tg_promote1((__x))(__x))

// fabs

static float
    _TG_ATTRS
    __tg_fabs(float __x) {return fabsf(__x);}

static double
    _TG_ATTRS
    __tg_fabs(double __x) {return fabs(__x);}

static long double
    _TG_ATTRS
    __tg_fabs(long double __x) {return fabsl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_fabs(float _Complex __x) {return cabsf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_fabs(double _Complex __x) {return cabs(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_fabs(long double _Complex __x) {return cabsl(__x);}

#undef fabs
#define fabs(__x) __tg_fabs(__tg_promote1((__x))(__x))

// atan2

static float
    _TG_ATTRS
    __tg_atan2(float __x, float __y) {return atan2f(__x, __y);}

static double
    _TG_ATTRS
    __tg_atan2(double __x, double __y) {return atan2(__x, __y);}

static long double
    _TG_ATTRS
    __tg_atan2(long double __x, long double __y) {return atan2l(__x, __y);}

#undef atan2
#define atan2(__x, __y) __tg_atan2(__tg_promote2((__x), (__y))(__x), \
                                   __tg_promote2((__x), (__y))(__y))

// cbrt

static float
    _TG_ATTRS
    __tg_cbrt(float __x) {return cbrtf(__x);}

static double
    _TG_ATTRS
    __tg_cbrt(double __x) {return cbrt(__x);}

static long double
    _TG_ATTRS
    __tg_cbrt(long double __x) {return cbrtl(__x);}

#undef cbrt
#define cbrt(__x) __tg_cbrt(__tg_promote1((__x))(__x))

// ceil

static float
    _TG_ATTRS
    __tg_ceil(float __x) {return ceilf(__x);}

static double
    _TG_ATTRS
    __tg_ceil(double __x) {return ceil(__x);}

static long double
    _TG_ATTRS
    __tg_ceil(long double __x) {return ceill(__x);}

#undef ceil
#define ceil(__x) __tg_ceil(__tg_promote1((__x))(__x))

// copysign

static float
    _TG_ATTRS
    __tg_copysign(float __x, float __y) {return copysignf(__x, __y);}

static double
    _TG_ATTRS
    __tg_copysign(double __x, double __y) {return copysign(__x, __y);}

static long double
    _TG_ATTRS
    __tg_copysign(long double __x, long double __y) {return copysignl(__x, __y);}

#undef copysign
#define copysign(__x, __y) __tg_copysign(__tg_promote2((__x), (__y))(__x), \
                                         __tg_promote2((__x), (__y))(__y))

// erf

static float
    _TG_ATTRS
    __tg_erf(float __x) {return erff(__x);}

static double
    _TG_ATTRS
    __tg_erf(double __x) {return erf(__x);}

static long double
    _TG_ATTRS
    __tg_erf(long double __x) {return erfl(__x);}

#undef erf
#define erf(__x) __tg_erf(__tg_promote1((__x))(__x))

// erfc

static float
    _TG_ATTRS
    __tg_erfc(float __x) {return erfcf(__x);}

static double
    _TG_ATTRS
    __tg_erfc(double __x) {return erfc(__x);}

static long double
    _TG_ATTRS
    __tg_erfc(long double __x) {return erfcl(__x);}

#undef erfc
#define erfc(__x) __tg_erfc(__tg_promote1((__x))(__x))

// exp2

static float
    _TG_ATTRS
    __tg_exp2(float __x) {return exp2f(__x);}

static double
    _TG_ATTRS
    __tg_exp2(double __x) {return exp2(__x);}

static long double
    _TG_ATTRS
    __tg_exp2(long double __x) {return exp2l(__x);}

#undef exp2
#define exp2(__x) __tg_exp2(__tg_promote1((__x))(__x))

// expm1

static float
    _TG_ATTRS
    __tg_expm1(float __x) {return expm1f(__x);}

static double
    _TG_ATTRS
    __tg_expm1(double __x) {return expm1(__x);}

static long double
    _TG_ATTRS
    __tg_expm1(long double __x) {return expm1l(__x);}

#undef expm1
#define expm1(__x) __tg_expm1(__tg_promote1((__x))(__x))

// fdim

static float
    _TG_ATTRS
    __tg_fdim(float __x, float __y) {return fdimf(__x, __y);}

static double
    _TG_ATTRS
    __tg_fdim(double __x, double __y) {return fdim(__x, __y);}

static long double
    _TG_ATTRS
    __tg_fdim(long double __x, long double __y) {return fdiml(__x, __y);}

#undef fdim
#define fdim(__x, __y) __tg_fdim(__tg_promote2((__x), (__y))(__x), \
                                 __tg_promote2((__x), (__y))(__y))

// floor

static float
    _TG_ATTRS
    __tg_floor(float __x) {return floorf(__x);}

static double
    _TG_ATTRS
    __tg_floor(double __x) {return floor(__x);}

static long double
    _TG_ATTRS
    __tg_floor(long double __x) {return floorl(__x);}

#undef floor
#define floor(__x) __tg_floor(__tg_promote1((__x))(__x))

// fma

static float
    _TG_ATTRS
    __tg_fma(float __x, float __y, float __z)
    {return fmaf(__x, __y, __z);}

static double
    _TG_ATTRS
    __tg_fma(double __x, double __y, double __z)
    {return fma(__x, __y, __z);}

static long double
    _TG_ATTRS
    __tg_fma(long double __x,long double __y, long double __z)
    {return fmal(__x, __y, __z);}

#undef fma
#define fma(__x, __y, __z)                                \
        __tg_fma(__tg_promote3((__x), (__y), (__z))(__x), \
                 __tg_promote3((__x), (__y), (__z))(__y), \
                 __tg_promote3((__x), (__y), (__z))(__z))

// fmax

static float
    _TG_ATTRS
    __tg_fmax(float __x, float __y) {return fmaxf(__x, __y);}

static double
    _TG_ATTRS
    __tg_fmax(double __x, double __y) {return fmax(__x, __y);}

static long double
    _TG_ATTRS
    __tg_fmax(long double __x, long double __y) {return fmaxl(__x, __y);}

#undef fmax
#define fmax(__x, __y) __tg_fmax(__tg_promote2((__x), (__y))(__x), \
                                 __tg_promote2((__x), (__y))(__y))

// fmin

static float
    _TG_ATTRS
    __tg_fmin(float __x, float __y) {return fminf(__x, __y);}

static double
    _TG_ATTRS
    __tg_fmin(double __x, double __y) {return fmin(__x, __y);}

static long double
    _TG_ATTRS
    __tg_fmin(long double __x, long double __y) {return fminl(__x, __y);}

#undef fmin
#define fmin(__x, __y) __tg_fmin(__tg_promote2((__x), (__y))(__x), \
                                 __tg_promote2((__x), (__y))(__y))

// fmod

static float
    _TG_ATTRS
    __tg_fmod(float __x, float __y) {return fmodf(__x, __y);}

static double
    _TG_ATTRS
    __tg_fmod(double __x, double __y) {return fmod(__x, __y);}

static long double
    _TG_ATTRS
    __tg_fmod(long double __x, long double __y) {return fmodl(__x, __y);}

#undef fmod
#define fmod(__x, __y) __tg_fmod(__tg_promote2((__x), (__y))(__x), \
                                 __tg_promote2((__x), (__y))(__y))

// frexp

static float
    _TG_ATTRS
    __tg_frexp(float __x, int* __y) {return frexpf(__x, __y);}

static double
    _TG_ATTRS
    __tg_frexp(double __x, int* __y) {return frexp(__x, __y);}

static long double
    _TG_ATTRS
    __tg_frexp(long double __x, int* __y) {return frexpl(__x, __y);}

#undef frexp
#define frexp(__x, __y) __tg_frexp(__tg_promote1((__x))(__x), __y)

// hypot

static float
    _TG_ATTRS
    __tg_hypot(float __x, float __y) {return hypotf(__x, __y);}

static double
    _TG_ATTRS
    __tg_hypot(double __x, double __y) {return hypot(__x, __y);}

static long double
    _TG_ATTRS
    __tg_hypot(long double __x, long double __y) {return hypotl(__x, __y);}

#undef hypot
#define hypot(__x, __y) __tg_hypot(__tg_promote2((__x), (__y))(__x), \
                                   __tg_promote2((__x), (__y))(__y))

// ilogb

static int
    _TG_ATTRS
    __tg_ilogb(float __x) {return ilogbf(__x);}

static int
    _TG_ATTRS
    __tg_ilogb(double __x) {return ilogb(__x);}

static int
    _TG_ATTRS
    __tg_ilogb(long double __x) {return ilogbl(__x);}

#undef ilogb
#define ilogb(__x) __tg_ilogb(__tg_promote1((__x))(__x))

// ldexp

static float
    _TG_ATTRS
    __tg_ldexp(float __x, int __y) {return ldexpf(__x, __y);}

static double
    _TG_ATTRS
    __tg_ldexp(double __x, int __y) {return ldexp(__x, __y);}

static long double
    _TG_ATTRS
    __tg_ldexp(long double __x, int __y) {return ldexpl(__x, __y);}

#undef ldexp
#define ldexp(__x, __y) __tg_ldexp(__tg_promote1((__x))(__x), __y)

// lgamma

static float
    _TG_ATTRS
    __tg_lgamma(float __x) {return lgammaf(__x);}

static double
    _TG_ATTRS
    __tg_lgamma(double __x) {return lgamma(__x);}

static long double
    _TG_ATTRS
    __tg_lgamma(long double __x) {return lgammal(__x);}

#undef lgamma
#define lgamma(__x) __tg_lgamma(__tg_promote1((__x))(__x))

// llrint

static long long
    _TG_ATTRS
    __tg_llrint(float __x) {return llrintf(__x);}

static long long
    _TG_ATTRS
    __tg_llrint(double __x) {return llrint(__x);}

static long long
    _TG_ATTRS
    __tg_llrint(long double __x) {return llrintl(__x);}

#undef llrint
#define llrint(__x) __tg_llrint(__tg_promote1((__x))(__x))

// llround

static long long
    _TG_ATTRS
    __tg_llround(float __x) {return llroundf(__x);}

static long long
    _TG_ATTRS
    __tg_llround(double __x) {return llround(__x);}

static long long
    _TG_ATTRS
    __tg_llround(long double __x) {return llroundl(__x);}

#undef llround
#define llround(__x) __tg_llround(__tg_promote1((__x))(__x))

// log10

static float
    _TG_ATTRS
    __tg_log10(float __x) {return log10f(__x);}

static double
    _TG_ATTRS
    __tg_log10(double __x) {return log10(__x);}

static long double
    _TG_ATTRS
    __tg_log10(long double __x) {return log10l(__x);}

#undef log10
#define log10(__x) __tg_log10(__tg_promote1((__x))(__x))

// log1p

static float
    _TG_ATTRS
    __tg_log1p(float __x) {return log1pf(__x);}

static double
    _TG_ATTRS
    __tg_log1p(double __x) {return log1p(__x);}

static long double
    _TG_ATTRS
    __tg_log1p(long double __x) {return log1pl(__x);}

#undef log1p
#define log1p(__x) __tg_log1p(__tg_promote1((__x))(__x))

// log2

static float
    _TG_ATTRS
    __tg_log2(float __x) {return log2f(__x);}

static double
    _TG_ATTRS
    __tg_log2(double __x) {return log2(__x);}

static long double
    _TG_ATTRS
    __tg_log2(long double __x) {return log2l(__x);}

#undef log2
#define log2(__x) __tg_log2(__tg_promote1((__x))(__x))

// lrint

static long
    _TG_ATTRS
    __tg_lrint(float __x) {return lrintf(__x);}

static long
    _TG_ATTRS
    __tg_lrint(double __x) {return lrint(__x);}

static long
    _TG_ATTRS
    __tg_lrint(long double __x) {return lrintl(__x);}

#undef lrint
#define lrint(__x) __tg_lrint(__tg_promote1((__x))(__x))

// lround

static long
    _TG_ATTRS
    __tg_lround(float __x) {return lroundf(__x);}

static long
    _TG_ATTRS
    __tg_lround(double __x) {return lround(__x);}

static long
    _TG_ATTRS
    __tg_lround(long double __x) {return lroundl(__x);}

#undef lround
#define lround(__x) __tg_lround(__tg_promote1((__x))(__x))

// nearbyint

static float
    _TG_ATTRS
    __tg_nearbyint(float __x) {return nearbyintf(__x);}

static double
    _TG_ATTRS
    __tg_nearbyint(double __x) {return nearbyint(__x);}

static long double
    _TG_ATTRS
    __tg_nearbyint(long double __x) {return nearbyintl(__x);}

#undef nearbyint
#define nearbyint(__x) __tg_nearbyint(__tg_promote1((__x))(__x))

// nextafter

static float
    _TG_ATTRS
    __tg_nextafter(float __x, float __y) {return nextafterf(__x, __y);}

static double
    _TG_ATTRS
    __tg_nextafter(double __x, double __y) {return nextafter(__x, __y);}

static long double
    _TG_ATTRS
    __tg_nextafter(long double __x, long double __y) {return nextafterl(__x, __y);}

#undef nextafter
#define nextafter(__x, __y) __tg_nextafter(__tg_promote2((__x), (__y))(__x), \
                                           __tg_promote2((__x), (__y))(__y))

// nexttoward

static float
    _TG_ATTRS
    __tg_nexttoward(float __x, long double __y) {return nexttowardf(__x, __y);}

static double
    _TG_ATTRS
    __tg_nexttoward(double __x, long double __y) {return nexttoward(__x, __y);}

static long double
    _TG_ATTRS
    __tg_nexttoward(long double __x, long double __y) {return nexttowardl(__x, __y);}

#undef nexttoward
#define nexttoward(__x, __y) __tg_nexttoward(__tg_promote1((__x))(__x), (__y))

// remainder

static float
    _TG_ATTRS
    __tg_remainder(float __x, float __y) {return remainderf(__x, __y);}

static double
    _TG_ATTRS
    __tg_remainder(double __x, double __y) {return remainder(__x, __y);}

static long double
    _TG_ATTRS
    __tg_remainder(long double __x, long double __y) {return remainderl(__x, __y);}

#undef remainder
#define remainder(__x, __y) __tg_remainder(__tg_promote2((__x), (__y))(__x), \
                                           __tg_promote2((__x), (__y))(__y))

// remquo

static float
    _TG_ATTRS
    __tg_remquo(float __x, float __y, int* __z)
    {return remquof(__x, __y, __z);}

static double
    _TG_ATTRS
    __tg_remquo(double __x, double __y, int* __z)
    {return remquo(__x, __y, __z);}

static long double
    _TG_ATTRS
    __tg_remquo(long double __x,long double __y, int* __z)
    {return remquol(__x, __y, __z);}

#undef remquo
#define remquo(__x, __y, __z)                         \
        __tg_remquo(__tg_promote2((__x), (__y))(__x), \
                    __tg_promote2((__x), (__y))(__y), \
                    (__z))

// rint

static float
    _TG_ATTRS
    __tg_rint(float __x) {return rintf(__x);}

static double
    _TG_ATTRS
    __tg_rint(double __x) {return rint(__x);}

static long double
    _TG_ATTRS
    __tg_rint(long double __x) {return rintl(__x);}

#undef rint
#define rint(__x) __tg_rint(__tg_promote1((__x))(__x))

// round

static float
    _TG_ATTRS
    __tg_round(float __x) {return roundf(__x);}

static double
    _TG_ATTRS
    __tg_round(double __x) {return round(__x);}

static long double
    _TG_ATTRS
    __tg_round(long double __x) {return roundl(__x);}

#undef round
#define round(__x) __tg_round(__tg_promote1((__x))(__x))

// scalbn

static float
    _TG_ATTRS
    __tg_scalbn(float __x, int __y) {return scalbnf(__x, __y);}

static double
    _TG_ATTRS
    __tg_scalbn(double __x, int __y) {return scalbn(__x, __y);}

static long double
    _TG_ATTRS
    __tg_scalbn(long double __x, int __y) {return scalbnl(__x, __y);}

#undef scalbn
#define scalbn(__x, __y) __tg_scalbn(__tg_promote1((__x))(__x), __y)

// scalbln

static float
    _TG_ATTRS
    __tg_scalbln(float __x, long __y) {return scalblnf(__x, __y);}

static double
    _TG_ATTRS
    __tg_scalbln(double __x, long __y) {return scalbln(__x, __y);}

static long double
    _TG_ATTRS
    __tg_scalbln(long double __x, long __y) {return scalblnl(__x, __y);}

#undef scalbln
#define scalbln(__x, __y) __tg_scalbln(__tg_promote1((__x))(__x), __y)

// tgamma

static float
    _TG_ATTRS
    __tg_tgamma(float __x) {return tgammaf(__x);}

static double
    _TG_ATTRS
    __tg_tgamma(double __x) {return tgamma(__x);}

static long double
    _TG_ATTRS
    __tg_tgamma(long double __x) {return tgammal(__x);}

#undef tgamma
#define tgamma(__x) __tg_tgamma(__tg_promote1((__x))(__x))

// trunc

static float
    _TG_ATTRS
    __tg_trunc(float __x) {return truncf(__x);}

static double
    _TG_ATTRS
    __tg_trunc(double __x) {return trunc(__x);}

static long double
    _TG_ATTRS
    __tg_trunc(long double __x) {return truncl(__x);}

#undef trunc
#define trunc(__x) __tg_trunc(__tg_promote1((__x))(__x))

// carg

static float
    _TG_ATTRS
    __tg_carg(float __x) {return atan2f(0.F, __x);}

static double
    _TG_ATTRS
    __tg_carg(double __x) {return atan2(0., __x);}

static long double
    _TG_ATTRS
    __tg_carg(long double __x) {return atan2l(0.L, __x);}

static float
    _TG_ATTRS
    __tg_carg(float _Complex __x) {return cargf(__x);}

static double
    _TG_ATTRS
    __tg_carg(double _Complex __x) {return carg(__x);}

static long double
    _TG_ATTRS
    __tg_carg(long double _Complex __x) {return cargl(__x);}

#undef carg
#define carg(__x) __tg_carg(__tg_promote1((__x))(__x))

// cimag

static float
    _TG_ATTRS
    __tg_cimag(float __x) {return 0;}

static double
    _TG_ATTRS
    __tg_cimag(double __x) {return 0;}

static long double
    _TG_ATTRS
    __tg_cimag(long double __x) {return 0;}

static float
    _TG_ATTRS
    __tg_cimag(float _Complex __x) {return cimagf(__x);}

static double
    _TG_ATTRS
    __tg_cimag(double _Complex __x) {return cimag(__x);}

static long double
    _TG_ATTRS
    __tg_cimag(long double _Complex __x) {return cimagl(__x);}

#undef cimag
#define cimag(__x) __tg_cimag(__tg_promote1((__x))(__x))

// conj

static float _Complex
    _TG_ATTRS
    __tg_conj(float __x) {return __x;}

static double _Complex
    _TG_ATTRS
    __tg_conj(double __x) {return __x;}

static long double _Complex
    _TG_ATTRS
    __tg_conj(long double __x) {return __x;}

static float _Complex
    _TG_ATTRS
    __tg_conj(float _Complex __x) {return conjf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_conj(double _Complex __x) {return conj(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_conj(long double _Complex __x) {return conjl(__x);}

#undef conj
#define conj(__x) __tg_conj(__tg_promote1((__x))(__x))

// cproj

static float _Complex
    _TG_ATTRS
    __tg_cproj(float __x) {return cprojf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_cproj(double __x) {return cproj(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_cproj(long double __x) {return cprojl(__x);}

static float _Complex
    _TG_ATTRS
    __tg_cproj(float _Complex __x) {return cprojf(__x);}

static double _Complex
    _TG_ATTRS
    __tg_cproj(double _Complex __x) {return cproj(__x);}

static long double _Complex
    _TG_ATTRS
    __tg_cproj(long double _Complex __x) {return cprojl(__x);}

#undef cproj
#define cproj(__x) __tg_cproj(__tg_promote1((__x))(__x))

// creal

static float _Complex
    _TG_ATTRS
    __tg_creal(float __x) {return __x;}

static double _Complex
    _TG_ATTRS
    __tg_creal(double __x) {return __x;}

static long double _Complex
    _TG_ATTRS
    __tg_creal(long double __x) {return __x;}

static float
    _TG_ATTRS
    __tg_creal(float _Complex __x) {return crealf(__x);}

static double
    _TG_ATTRS
    __tg_creal(double _Complex __x) {return creal(__x);}

static long double
    _TG_ATTRS
    __tg_creal(long double _Complex __x) {return creall(__x);}

#undef creal
#define creal(__x) __tg_creal(__tg_promote1((__x))(__x))

#undef _TG_ATTRSp
#undef _TG_ATTRS

#endif /* __cplusplus */
#endif /* __TGMATH_H */
                                                  tmmintrin.h                                                                                         0100644 0001750 0001750 00000015537 11675013170 035343  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- tmmintrin.h - SSSE3 intrinsics -----------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
 
#ifndef __TMMINTRIN_H
#define __TMMINTRIN_H

#ifndef __SSSE3__
#error "SSSE3 instruction set not enabled"
#else

#include <pmmintrin.h>

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi8(__m64 a)
{
    return (__m64)__builtin_ia32_pabsb((__v8qi)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi8(__m128i a)
{
    return (__m128i)__builtin_ia32_pabsb128((__v16qi)a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi16(__m64 a)
{
    return (__m64)__builtin_ia32_pabsw((__v4hi)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi16(__m128i a)
{
    return (__m128i)__builtin_ia32_pabsw128((__v8hi)a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_abs_pi32(__m64 a)
{
    return (__m64)__builtin_ia32_pabsd((__v2si)a);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_abs_epi32(__m128i a)
{
    return (__m128i)__builtin_ia32_pabsd128((__v4si)a);
}

#define _mm_alignr_epi8(a, b, n) __extension__ ({ \
  __m128i __a = (a); \
  __m128i __b = (b); \
  (__m128i)__builtin_ia32_palignr128((__v16qi)__a, (__v16qi)__b, (n)); })

#define _mm_alignr_pi8(a, b, n) __extension__ ({ \
  __m64 __a = (a); \
  __m64 __b = (b); \
  (__m64)__builtin_ia32_palignr((__v8qi)__a, (__v8qi)__b, (n)); })

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phaddw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadd_epi32(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phaddd128((__v4si)a, (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phaddw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadd_pi32(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phaddd((__v2si)a, (__v2si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hadds_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phaddsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hadds_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phaddsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phsubw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsub_epi32(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phsubd128((__v4si)a, (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phsubw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsub_pi32(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phsubd((__v2si)a, (__v2si)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_phsubsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_hsubs_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_phsubsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_pmaddubsw128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_maddubs_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_pmaddubsw((__v8qi)a, (__v8qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_pmulhrsw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhrs_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_pmulhrsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_epi8(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_pshufb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_shuffle_pi8(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_pshufb((__v8qi)a, (__v8qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi8(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_psignb128((__v16qi)a, (__v16qi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi16(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_psignw128((__v8hi)a, (__v8hi)b);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_sign_epi32(__m128i a, __m128i b)
{
    return (__m128i)__builtin_ia32_psignd128((__v4si)a, (__v4si)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi8(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_psignb((__v8qi)a, (__v8qi)b);  
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi16(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_psignw((__v4hi)a, (__v4hi)b);  
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sign_pi32(__m64 a, __m64 b)
{
    return (__m64)__builtin_ia32_psignd((__v2si)a, (__v2si)b);
}

#endif /* __SSSE3__ */

#endif /* __TMMINTRIN_H */
                                                                                                                                                                 varargs.h                                                                                           0100644 0001750 0001750 00000002466 11567030532 034765  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- varargs.h - Variable argument handling -------------------------------------===
*
* Permission is hereby granted, free of charge, to any person obtaining a copy
* of this software and associated documentation files (the "Software"), to deal
* in the Software without restriction, including without limitation the rights
* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
* copies of the Software, and to permit persons to whom the Software is
* furnished to do so, subject to the following conditions:
*
* The above copyright notice and this permission notice shall be included in
* all copies or substantial portions of the Software.
*
* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
* THE SOFTWARE.
*
*===-----------------------------------------------------------------------===
*/
#ifndef __VARARGS_H
#define __VARARGS_H
  #error "Please use <stdarg.h> instead of <varargs.h>"
#endif
                                                                                                                                                                                                          wmmintrin.h                                                                                         0100644 0001750 0001750 00000004530 11567030532 035336  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- wmmintrin.h - AES intrinsics ------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef _WMMINTRIN_H
#define _WMMINTRIN_H

#if !defined (__AES__)
# error "AES instructions not enabled"
#else

#include <smmintrin.h>

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_aesenc_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenc128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_aesenclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesenclast128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_aesdec_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdec128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_aesdeclast_si128(__m128i __V, __m128i __R)
{
  return (__m128i)__builtin_ia32_aesdeclast128(__V, __R);
}

static __inline__ __m128i __attribute__((__always_inline__, __nodebug__))
_mm_aesimc_si128(__m128i __V)
{
  return (__m128i)__builtin_ia32_aesimc128(__V);
}

#define _mm_aeskeygenassist_si128(C, R) \
  __builtin_ia32_aeskeygenassist128((C), (R))

#endif /* __AES__ */
#endif /* _WMMINTRIN_H */
                                                                                                                                                                        x86intrin.h                                                                                         0100644 0001750 0001750 00000002560 11567030532 035164  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- x86intrin.h - X86 intrinsics -------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */

#ifndef __X86INTRIN_H
#define __X86INTRIN_H

#include <immintrin.h>

// FIXME: SSE4A, 3dNOW, FMA4, XOP, LWP, ABM, POPCNT

#endif /* __X86INTRIN_H */
                                                                                                                                                xmmintrin.h                                                                                         0100644 0001750 0001750 00000062240 11675013170 035340  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/2.0/include                                                        /*===---- xmmintrin.h - SSE intrinsics -------------------------------------===
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 *
 *===-----------------------------------------------------------------------===
 */
 
#ifndef __XMMINTRIN_H
#define __XMMINTRIN_H
 
#ifndef __SSE__
#error "SSE instruction set not enabled"
#else

#include <mmintrin.h>

typedef int __v4si __attribute__((__vector_size__(16)));
typedef float __v4sf __attribute__((__vector_size__(16)));
typedef float __m128 __attribute__((__vector_size__(16)));

// This header should only be included in a hosted environment as it depends on
// a standard library to provide allocation routines.
#if __STDC_HOSTED__
#include <mm_malloc.h>
#endif

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ss(__m128 a, __m128 b)
{
  a[0] += b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_add_ps(__m128 a, __m128 b)
{
  return a + b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ss(__m128 a, __m128 b)
{
  a[0] -= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sub_ps(__m128 a, __m128 b)
{
  return a - b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ss(__m128 a, __m128 b)
{
  a[0] *= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_mul_ps(__m128 a, __m128 b)
{
  return a * b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ss(__m128 a, __m128 b)
{
  a[0] /= b[0];
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_div_ps(__m128 a, __m128 b)
{
  return a / b;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ss(__m128 a)
{
  return __builtin_ia32_sqrtss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_sqrt_ps(__m128 a)
{
  return __builtin_ia32_sqrtps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ss(__m128 a)
{
  return __builtin_ia32_rcpss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rcp_ps(__m128 a)
{
  return __builtin_ia32_rcpps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ss(__m128 a)
{
  return __builtin_ia32_rsqrtss(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_rsqrt_ps(__m128 a)
{
  return __builtin_ia32_rsqrtps(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_minss(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_min_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_minps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_maxss(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_max_ps(__m128 a, __m128 b)
{
  return __builtin_ia32_maxps(a, b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_and_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a & (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_andnot_ps(__m128 a, __m128 b)
{
  return (__m128)(~(__v4si)a & (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_or_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a | (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_xor_ps(__m128 a, __m128 b)
{
  return (__m128)((__v4si)a ^ (__v4si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpeq_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmplt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmple_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpgt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 1);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpge_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 2);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpneq_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 4);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnlt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnle_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpngt_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(b, a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpnge_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(b, a, 6);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpord_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ss(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpss(a, b, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cmpunord_ps(__m128 a, __m128 b)
{
  return (__m128)__builtin_ia32_cmpps(a, b, 3);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comieq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comieq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comilt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comilt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comile_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comile(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comigt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comigt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comige_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comige(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_comineq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_comineq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomieq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomieq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomilt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomilt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomile_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomile(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomigt_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomigt(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomige_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomige(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_ucomineq_ss(__m128 a, __m128 b)
{
  return __builtin_ia32_ucomineq(a, b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si32(__m128 a)
{
  return __builtin_ia32_cvtss2si(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ss2si(__m128 a)
{
  return _mm_cvtss_si32(a);
}

#ifdef __x86_64__

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_si64(__m128 a)
{
  return __builtin_ia32_cvtss2si64(a);
}

#endif

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi32(__m128 a)
{
  return (__m64)__builtin_ia32_cvtps2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_ps2pi(__m128 a)
{
  return _mm_cvtps_pi32(a);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si32(__m128 a)
{
  return a[0];
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ss2si(__m128 a)
{
  return _mm_cvttss_si32(a);
}

static __inline__ long long __attribute__((__always_inline__, __nodebug__))
_mm_cvttss_si64(__m128 a)
{
  return a[0];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvttps_pi32(__m128 a)
{
  return (__m64)__builtin_ia32_cvttps2pi(a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtt_ps2pi(__m128 a)
{
  return _mm_cvttps_pi32(a);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi32_ss(__m128 a, int b)
{
  a[0] = b;
  return a;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_si2ss(__m128 a, int b)
{
  return _mm_cvtsi32_ss(a, b);
}

#ifdef __x86_64__

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtsi64_ss(__m128 a, long long b)
{
  a[0] = b;
  return a;
}

#endif

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32_ps(__m128 a, __m64 b)
{
  return __builtin_ia32_cvtpi2ps(a, (__v2si)b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvt_pi2ps(__m128 a, __m64 b)
{
  return _mm_cvtpi32_ps(a, b);
}

static __inline__ float __attribute__((__always_inline__, __nodebug__))
_mm_cvtss_f32(__m128 a)
{
  return a[0];
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadh_pi(__m128 a, const __m64 *p)
{
  typedef float __mm_loadh_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadh_pi_struct {
    __mm_loadh_pi_v2f32 u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadh_pi_v2f32 b = ((struct __mm_loadh_pi_struct*)p)->u;
  __m128 bb = __builtin_shufflevector(b, b, 0, 1, 0, 1);
  return __builtin_shufflevector(a, bb, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadl_pi(__m128 a, const __m64 *p)
{
  typedef float __mm_loadl_pi_v2f32 __attribute__((__vector_size__(8)));
  struct __mm_loadl_pi_struct {
    __mm_loadl_pi_v2f32 u;
  } __attribute__((__packed__, __may_alias__));
  __mm_loadl_pi_v2f32 b = ((struct __mm_loadl_pi_struct*)p)->u;
  __m128 bb = __builtin_shufflevector(b, b, 0, 1, 0, 1);
  return __builtin_shufflevector(a, bb, 4, 5, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ss(const float *p)
{
  struct __mm_load_ss_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  float u = ((struct __mm_load_ss_struct*)p)->u;
  return (__m128){ u, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load1_ps(const float *p)
{
  struct __mm_load1_ps_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  float u = ((struct __mm_load1_ps_struct*)p)->u;
  return (__m128){ u, u, u, u };
}

#define        _mm_load_ps1(p) _mm_load1_ps(p)

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_load_ps(const float *p)
{
  return *(__m128*)p;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadu_ps(const float *p)
{
  struct __loadu_ps {
    __m128 v;
  } __attribute__((__packed__, __may_alias__));
  return ((struct __loadu_ps*)p)->v;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_loadr_ps(const float *p)
{
  __m128 a = _mm_load_ps(p);
  return __builtin_shufflevector(a, a, 3, 2, 1, 0);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ss(float w)
{
  return (__m128){ w, 0, 0, 0 };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set1_ps(float w)
{
  return (__m128){ w, w, w, w };
}

// Microsoft specific.
static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps1(float w)
{
    return _mm_set1_ps(w);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_set_ps(float z, float y, float x, float w)
{
  return (__m128){ w, x, y, z };
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_setr_ps(float z, float y, float x, float w)
{
  return (__m128){ z, y, x, w };
}

static __inline__ __m128 __attribute__((__always_inline__))
_mm_setzero_ps(void)
{
  return (__m128){ 0, 0, 0, 0 };
}

static __inline__ void __attribute__((__always_inline__))
_mm_storeh_pi(__m64 *p, __m128 a)
{
  __builtin_ia32_storehps((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_storel_pi(__m64 *p, __m128 a)
{
  __builtin_ia32_storelps((__v2si *)p, a);
}

static __inline__ void __attribute__((__always_inline__))
_mm_store_ss(float *p, __m128 a)
{
  struct __mm_store_ss_struct {
    float u;
  } __attribute__((__packed__, __may_alias__));
  ((struct __mm_store_ss_struct*)p)->u = a[0];
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storeu_ps(float *p, __m128 a)
{
  __builtin_ia32_storeups(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store1_ps(float *p, __m128 a)
{
  a = __builtin_shufflevector(a, a, 0, 0, 0, 0);
  _mm_storeu_ps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps1(float *p, __m128 a)
{
    return _mm_store1_ps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_store_ps(float *p, __m128 a)
{
  *(__m128 *)p = a;
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_storer_ps(float *p, __m128 a)
{
  a = __builtin_shufflevector(a, a, 3, 2, 1, 0);
  _mm_store_ps(p, a);
}

#define _MM_HINT_T0 3
#define _MM_HINT_T1 2
#define _MM_HINT_T2 1
#define _MM_HINT_NTA 0

/* FIXME: We have to #define this because "sel" must be a constant integer, and
   Sema doesn't do any form of constant propagation yet. */

#define _mm_prefetch(a, sel) (__builtin_prefetch((void *)(a), 0, sel))

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_pi(__m64 *p, __m64 a)
{
  __builtin_ia32_movntq(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_stream_ps(float *p, __m128 a)
{
  __builtin_ia32_movntps(p, a);
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_sfence(void)
{
  __builtin_ia32_sfence();
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_extract_pi16(__m64 a, int n)
{
  __v4hi b = (__v4hi)a;
  return (unsigned short)b[n & 3];
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_insert_pi16(__m64 a, int d, int n)
{
   __v4hi b = (__v4hi)a;
   b[n & 3] = d;
   return (__m64)b;
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pi16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmaxsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_max_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmaxub((__v8qi)a, (__v8qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pi16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pminsw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_min_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pminub((__v8qi)a, (__v8qi)b);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_pi8(__m64 a)
{
  return __builtin_ia32_pmovmskb((__v8qi)a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_mulhi_pu16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pmulhuw((__v4hi)a, (__v4hi)b);  
}

#define _mm_shuffle_pi16(a, n) __extension__ ({ \
  __m64 __a = (a); \
  (__m64)__builtin_ia32_pshufw((__v4hi)__a, (n)); })

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_maskmove_si64(__m64 d, __m64 n, char *p)
{
  __builtin_ia32_maskmovq((__v8qi)d, (__v8qi)n, p);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pavgb((__v8qi)a, (__v8qi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_avg_pu16(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_pavgw((__v4hi)a, (__v4hi)b);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_sad_pu8(__m64 a, __m64 b)
{
  return (__m64)__builtin_ia32_psadbw((__v8qi)a, (__v8qi)b);
}

static __inline__ unsigned int __attribute__((__always_inline__, __nodebug__))
_mm_getcsr(void)
{
  return __builtin_ia32_stmxcsr();
}

static __inline__ void __attribute__((__always_inline__, __nodebug__))
_mm_setcsr(unsigned int i)
{
  __builtin_ia32_ldmxcsr(i);
}

#define _mm_shuffle_ps(a, b, mask) __extension__ ({ \
  __m128 __a = (a); \
  __m128 __b = (b); \
  (__m128)__builtin_shufflevector((__v4sf)__a, (__v4sf)__b, \
                                  (mask) & 0x3, ((mask) & 0xc) >> 2, \
                                  (((mask) & 0x30) >> 4) + 4, \
                                  (((mask) & 0xc0) >> 6) + 4); })

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpackhi_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 2, 6, 3, 7);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_unpacklo_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 0, 4, 1, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_move_ss(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 4, 1, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movehl_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 6, 7, 2, 3);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_movelh_ps(__m128 a, __m128 b)
{
  return __builtin_shufflevector(a, b, 0, 1, 4, 5);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi16_ps(__m64 a)
{
  __m64 b, c;
  __m128 r;

  b = _mm_setzero_si64();
  b = _mm_cmpgt_pi16(b, a);
  c = _mm_unpackhi_pi16(a, b);  
  r = _mm_setzero_ps();
  r = _mm_cvtpi32_ps(r, c);
  r = _mm_movelh_ps(r, r);
  c = _mm_unpacklo_pi16(a, b);  
  r = _mm_cvtpi32_ps(r, c);

  return r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu16_ps(__m64 a)
{
  __m64 b, c;
  __m128 r;

  b = _mm_setzero_si64();
  c = _mm_unpackhi_pi16(a, b);  
  r = _mm_setzero_ps();
  r = _mm_cvtpi32_ps(r, c);
  r = _mm_movelh_ps(r, r);
  c = _mm_unpacklo_pi16(a, b);  
  r = _mm_cvtpi32_ps(r, c);

  return r;
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi8_ps(__m64 a)
{
  __m64 b;
  
  b = _mm_setzero_si64();
  b = _mm_cmpgt_pi8(b, a);
  b = _mm_unpacklo_pi8(a, b);

  return _mm_cvtpi16_ps(b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpu8_ps(__m64 a)
{
  __m64 b;
  
  b = _mm_setzero_si64();
  b = _mm_unpacklo_pi8(a, b);

  return _mm_cvtpi16_ps(b);
}

static __inline__ __m128 __attribute__((__always_inline__, __nodebug__))
_mm_cvtpi32x2_ps(__m64 a, __m64 b)
{
  __m128 c;
  
  c = _mm_setzero_ps();  
  c = _mm_cvtpi32_ps(c, b);
  c = _mm_movelh_ps(c, c);

  return _mm_cvtpi32_ps(c, a);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi16(__m128 a)
{
  __m64 b, c;
  
  b = _mm_cvtps_pi32(a);
  a = _mm_movehl_ps(a, a);
  c = _mm_cvtps_pi32(a);
  
  return _mm_packs_pi16(b, c);
}

static __inline__ __m64 __attribute__((__always_inline__, __nodebug__))
_mm_cvtps_pi8(__m128 a)
{
  __m64 b, c;
  
  b = _mm_cvtps_pi16(a);
  c = _mm_setzero_si64();
  
  return _mm_packs_pi16(b, c);
}

static __inline__ int __attribute__((__always_inline__, __nodebug__))
_mm_movemask_ps(__m128 a)
{
  return __builtin_ia32_movmskps(a);
}

#define _MM_SHUFFLE(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))

#define _MM_EXCEPT_INVALID    (0x0001)
#define _MM_EXCEPT_DENORM     (0x0002)
#define _MM_EXCEPT_DIV_ZERO   (0x0004)
#define _MM_EXCEPT_OVERFLOW   (0x0008)
#define _MM_EXCEPT_UNDERFLOW  (0x0010)
#define _MM_EXCEPT_INEXACT    (0x0020)
#define _MM_EXCEPT_MASK       (0x003f)

#define _MM_MASK_INVALID      (0x0080)
#define _MM_MASK_DENORM       (0x0100)
#define _MM_MASK_DIV_ZERO     (0x0200)
#define _MM_MASK_OVERFLOW     (0x0400)
#define _MM_MASK_UNDERFLOW    (0x0800)
#define _MM_MASK_INEXACT      (0x1000)
#define _MM_MASK_MASK         (0x1f80)

#define _MM_ROUND_NEAREST     (0x0000)
#define _MM_ROUND_DOWN        (0x2000)
#define _MM_ROUND_UP          (0x4000)
#define _MM_ROUND_TOWARD_ZERO (0x6000)
#define _MM_ROUND_MASK        (0x6000)

#define _MM_FLUSH_ZERO_MASK   (0x8000)
#define _MM_FLUSH_ZERO_ON     (0x8000)
#define _MM_FLUSH_ZERO_OFF    (0x8000)

#define _MM_GET_EXCEPTION_MASK() (_mm_getcsr() & _MM_MASK_MASK)
#define _MM_GET_EXCEPTION_STATE() (_mm_getcsr() & _MM_EXCEPT_MASK)
#define _MM_GET_FLUSH_ZERO_MODE() (_mm_getcsr() & _MM_FLUSH_ZERO_MASK)
#define _MM_GET_ROUNDING_MODE() (_mm_getcsr() & _MM_ROUND_MASK)

#define _MM_SET_EXCEPTION_MASK(x) (_mm_setcsr((_mm_getcsr() & ~_MM_MASK_MASK) | (x)))
#define _MM_SET_EXCEPTION_STATE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_EXCEPT_MASK) | (x)))
#define _MM_SET_FLUSH_ZERO_MODE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_FLUSH_ZERO_MASK) | (x)))
#define _MM_SET_ROUNDING_MODE(x) (_mm_setcsr((_mm_getcsr() & ~_MM_ROUND_MASK) | (x)))

#define _MM_TRANSPOSE4_PS(row0, row1, row2, row3) \
do { \
  __m128 tmp3, tmp2, tmp1, tmp0; \
  tmp0 = _mm_unpacklo_ps((row0), (row1)); \
  tmp2 = _mm_unpacklo_ps((row2), (row3)); \
  tmp1 = _mm_unpackhi_ps((row0), (row1)); \
  tmp3 = _mm_unpackhi_ps((row2), (row3)); \
  (row0) = _mm_movelh_ps(tmp0, tmp2); \
  (row1) = _mm_movehl_ps(tmp2, tmp0); \
  (row2) = _mm_movelh_ps(tmp1, tmp3); \
  (row3) = _mm_movehl_ps(tmp3, tmp1); \
} while (0)

/* Aliases for compatibility. */
#define _m_pextrw _mm_extract_pi16
#define _m_pinsrw _mm_insert_pi16
#define _m_pmaxsw _mm_max_pi16
#define _m_pmaxub _mm_max_pu8
#define _m_pminsw _mm_min_pi16
#define _m_pminub _mm_min_pu8
#define _m_pmovmskb _mm_movemask_pi8
#define _m_pmulhuw _mm_mulhi_pu16
#define _m_pshufw _mm_shuffle_pi16
#define _m_maskmovq _mm_maskmove_si64
#define _m_pavgb _mm_avg_pu8
#define _m_pavgw _mm_avg_pu16
#define _m_psadbw _mm_sad_pu8
#define _m_ _mm_
#define _m_ _mm_

/* Ugly hack for backwards-compatibility (compatible with gcc) */
#ifdef __SSE2__
#include <emmintrin.h>
#endif

#endif /* __SSE__ */

#endif /* __XMMINTRIN_H */
                                                                                                                                                                                                                                                                                                                                                                3.2/                                                                                                0040755 0001750 0001750 00000000000 12612224743 031523  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang                                                                    include/                                                                                            0040755 0001750 0001750 00000000000 12612224743 033146  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2                                                                cl_kernel.h                                                                                         0100644 0001750 0001750 00001334150 12566205433 035264  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include                                                        /*******************************************************************************
 * Copyright:  (c) 2007-2012 by Apple, Inc., All Rights Reserved.
 ******************************************************************************/

#ifndef __CL_KERNEL_H
#define __CL_KERNEL_H

// FIXME: Temporary hack to get double working until cl_khr_fp64 is handled correctly in the compiler

#if ! defined( cl_khr_fp64 )                                       &&  \
  /* Intel  */ (defined( __i386__ ) || defined( __x86_64__ )       ||  \
  /* ARM   */ ((defined(__arm__) && !defined(__SOFT_FP__) )) || \
  /* GPUf64 */ (defined(cl_APPLE_fp64_basic_ops)))
  #define cl_khr_fp64 1
#endif


// 5.1.2 OpenCL Vector Data Types
typedef __attribute__(( ext_vector_type(2) ))  char __char2;
typedef __attribute__(( ext_vector_type(3) ))  char __char3;
typedef __attribute__(( ext_vector_type(4) ))  char __char4;
typedef __attribute__(( ext_vector_type(8) ))  char __char8;
typedef __attribute__(( ext_vector_type(16) )) char __char16;
typedef unsigned char uchar;
typedef __attribute__(( ext_vector_type(2) ))  unsigned char __uchar2;
typedef __attribute__(( ext_vector_type(3) ))  unsigned char __uchar3;
typedef __attribute__(( ext_vector_type(4) ))  unsigned char __uchar4;
typedef __attribute__(( ext_vector_type(8) ))  unsigned char __uchar8;
typedef __attribute__(( ext_vector_type(16) )) unsigned char __uchar16;
typedef __attribute__(( ext_vector_type(2) ))  short __short2;
typedef __attribute__(( ext_vector_type(3) ))  short __short3;
typedef __attribute__(( ext_vector_type(4) ))  short __short4;
typedef __attribute__(( ext_vector_type(8) ))  short __short8;
typedef __attribute__(( ext_vector_type(16) )) short __short16;
typedef unsigned short ushort;
typedef __attribute__(( ext_vector_type(2) ))  unsigned short __ushort2;
typedef __attribute__(( ext_vector_type(3) ))  unsigned short __ushort3;
typedef __attribute__(( ext_vector_type(4) ))  unsigned short __ushort4;
typedef __attribute__(( ext_vector_type(8) ))  unsigned short __ushort8;
typedef __attribute__(( ext_vector_type(16) )) unsigned short __ushort16;
typedef __attribute__(( ext_vector_type(2) ))  int __int2;
typedef __attribute__(( ext_vector_type(3) ))  int __int3;
typedef __attribute__(( ext_vector_type(4) ))  int __int4;
typedef __attribute__(( ext_vector_type(8) ))  int __int8;
typedef __attribute__(( ext_vector_type(16) )) int __int16;
typedef unsigned int uint;
typedef __attribute__(( ext_vector_type(2) ))  unsigned int __uint2;
typedef __attribute__(( ext_vector_type(3) ))  unsigned int __uint3;
typedef __attribute__(( ext_vector_type(4) ))  unsigned int __uint4;
typedef __attribute__(( ext_vector_type(8) ))  unsigned int __uint8;
typedef __attribute__(( ext_vector_type(16) )) unsigned int __uint16;
typedef __attribute__(( ext_vector_type(2) ))  long __long2;
typedef __attribute__(( ext_vector_type(3) ))  long __long3;
typedef __attribute__(( ext_vector_type(4) ))  long __long4;
typedef __attribute__(( ext_vector_type(8) ))  long __long8;
typedef __attribute__(( ext_vector_type(16) )) long __long16;
typedef unsigned long ulong;
typedef __attribute__(( ext_vector_type(2) ))  unsigned long __ulong2;
typedef __attribute__(( ext_vector_type(3) ))  unsigned long __ulong3;
typedef __attribute__(( ext_vector_type(4) ))  unsigned long __ulong4;
typedef __attribute__(( ext_vector_type(8) ))  unsigned long __ulong8;
typedef __attribute__(( ext_vector_type(16) )) unsigned long __ulong16;
typedef __attribute__(( ext_vector_type(2) ))  float __float2;
typedef __attribute__(( ext_vector_type(3) ))  float __float3;
typedef __attribute__(( ext_vector_type(4) ))  float __float4;
typedef __attribute__(( ext_vector_type(8) ))  float __float8;
typedef __attribute__(( ext_vector_type(16) )) float __float16;
typedef __attribute__(( ext_vector_type(32) )) float __float32;

#if (defined(cl_khr_fp16) || defined(cl_APPLE_fp16_basic_ops))
#pragma OPENCL EXTENSION cl_khr_fp16 : enable
typedef __attribute__(( ext_vector_type(2) ))  half __half2;
typedef __attribute__(( ext_vector_type(3) ))  half __half3;
typedef __attribute__(( ext_vector_type(4) ))  half __half4;
typedef __attribute__(( ext_vector_type(8) ))  half __half8;
typedef __attribute__(( ext_vector_type(16) )) half __half16;
typedef __attribute__(( ext_vector_type(32) )) half __half32;
#endif

#if (defined(cl_khr_fp64) || defined(cl_APPLE_fp64_basic_ops))
#pragma OPENCL EXTENSION cl_khr_fp64 : enable
  typedef __attribute__(( ext_vector_type(2) ))  double __double2;
  typedef __attribute__(( ext_vector_type(3) ))  double __double3;
  typedef __attribute__(( ext_vector_type(4) ))  double __double4;
  typedef __attribute__(( ext_vector_type(8) ))  double __double8;
  typedef __attribute__(( ext_vector_type(16) )) double __double16;
#endif


//Vector type common names. These can now be #undef'd to avoid collision with similar names in imported C code. 
#define char2			__char2
#define char3			__char3
#define char4			__char4
#define char8			__char8
#define char16			__char16
#define uchar2			__uchar2
#define uchar3			__uchar3
#define uchar4			__uchar4
#define uchar8			__uchar8
#define uchar16			__uchar16
#define short2			__short2
#define short3			__short3
#define short4			__short4
#define short8			__short8
#define short16			__short16
#define ushort2			__ushort2
#define ushort3			__ushort3
#define ushort4			__ushort4
#define ushort8			__ushort8
#define ushort16		__ushort16
#define int2			__int2
#define int3			__int3
#define int4			__int4
#define int8			__int8
#define int16			__int16
#define uint2			__uint2
#define uint3			__uint3
#define uint4			__uint4
#define uint8			__uint8
#define uint16			__uint16
#define long2			__long2
#define long3			__long3
#define long4			__long4
#define long8			__long8
#define long16			__long16
#define ulong2			__ulong2
#define ulong3			__ulong3
#define ulong4			__ulong4
#define ulong8			__ulong8
#define ulong16			__ulong16
#define float2			__float2
#define float3			__float3
#define float4			__float4
#define float8			__float8
#define float16			__float16
#define float32			__float32

#if (defined(cl_khr_fp16) || defined(cl_APPLE_fp16_basic_ops))
    #define half2               __half2
    #define half3               __half3
    #define half4               __half4
    #define half8               __half8
    #define half16              __half16
#else
typedef struct __Reserved_Name__Do_not_use_half2        half2;
typedef struct __Reserved_Name__Do_not_use_half3        half3;
typedef struct __Reserved_Name__Do_not_use_half4        half4;
typedef struct __Reserved_Name__Do_not_use_half8        half8;
typedef struct __Reserved_Name__Do_not_use_half16       half16;
#endif


#if (defined(cl_khr_fp64) || defined(cl_APPLE_fp64_basic_ops))
    #define double2			__double2
    #define double3			__double3
    #define double4			__double4
    #define double8			__double8
    #define double16		__double16
#else
typedef struct __Unsupported_Type__Do_not_use_double2_on_this_device      double2;
typedef struct __Unsupported_Type__Do_not_use_double3_on_this_device      double3;
typedef struct __Unsupported_Type__Do_not_use_double4_on_this_device      double4;
typedef struct __Unsupported_Type__Do_not_use_double8_on_this_device      double8;
typedef struct __Unsupported_Type__Do_not_use_double16_on_this_device     double16;
#endif

//Legacy SPI interfaces
#define __int3_SPI		__int3
#define __float3_SPI	__float3

typedef struct __Reserved_Name__Do_not_use_bool2        bool2;
typedef struct __Reserved_Name__Do_not_use_bool3        bool3;
typedef struct __Reserved_Name__Do_not_use_bool4        bool4;
typedef struct __Reserved_Name__Do_not_use_bool8        bool8;
typedef struct __Reserved_Name__Do_not_use_bool16       bool16;

// Defend reserved types
typedef struct __Reserved_Name__Do_not_use_quad         quad;
typedef struct __Reserved_Name__Do_not_use_quad2        quad2;
typedef struct __Reserved_Name__Do_not_use_quad3        quad3;
typedef struct __Reserved_Name__Do_not_use_quad4        quad4;
typedef struct __Reserved_Name__Do_not_use_quad8        quad8;
typedef struct __Reserved_Name__Do_not_use_quad16       quad16;
typedef struct __Reserved_Name__Do_not_use_complex      complex;
typedef struct __Reserved_Name__Do_not_use_imaginary    imaginary;
typedef struct __Reserved_Name__Do_not_use_float2x2     float2x2;
typedef struct __Reserved_Name__Do_not_use_float2x3     float2x3;
typedef struct __Reserved_Name__Do_not_use_float3x2     float3x2;
typedef struct __Reserved_Name__Do_not_use_float2x4     float2x4;
typedef struct __Reserved_Name__Do_not_use_float4x2     float4x2;
typedef struct __Reserved_Name__Do_not_use_float3x4     float3x4;
typedef struct __Reserved_Name__Do_not_use_float4x3     float4x3;
typedef struct __Reserved_Name__Do_not_use_float4x4     float4x4;
typedef struct __Reserved_Name__Do_not_use_float8x8     float8x8;
typedef struct __Reserved_Name__Do_not_use_float16x16   float16x16;
typedef struct __Reserved_Name__Do_not_use_double2x2    double2x2;
typedef struct __Reserved_Name__Do_not_use_double2x3    double2x3;
typedef struct __Reserved_Name__Do_not_use_double3x2    double3x2;
typedef struct __Reserved_Name__Do_not_use_double2x4    double2x4;
typedef struct __Reserved_Name__Do_not_use_double4x2    double4x2;
typedef struct __Reserved_Name__Do_not_use_double3x4    double3x4;
typedef struct __Reserved_Name__Do_not_use_double4x3    double4x3;
typedef struct __Reserved_Name__Do_not_use_double4x4    double4x4;
typedef struct __Reserved_Name__Do_not_use_double8x8    double8x8;
typedef struct __Reserved_Name__Do_not_use_double16x16  double16x16;
typedef struct __Reserved_Name__Do_not_use_float5       float5;
typedef struct __Reserved_Name__Do_not_use_float6       float6;
typedef struct __Reserved_Name__Do_not_use_float7       float7;
typedef struct __Reserved_Name__Do_not_use_float9       float9;
typedef struct __Reserved_Name__Do_not_use_float10      float10;
typedef struct __Reserved_Name__Do_not_use_float11      float11;
typedef struct __Reserved_Name__Do_not_use_float12      float12;
typedef struct __Reserved_Name__Do_not_use_float13      float13;
typedef struct __Reserved_Name__Do_not_use_float14      float14;
typedef struct __Reserved_Name__Do_not_use_float15      float15;
typedef struct __Reserved_Name__Do_not_use_double5      double5;
typedef struct __Reserved_Name__Do_not_use_double6      double6;
typedef struct __Reserved_Name__Do_not_use_double7      double7;
typedef struct __Reserved_Name__Do_not_use_double9      double9;
typedef struct __Reserved_Name__Do_not_use_double10     double10;
typedef struct __Reserved_Name__Do_not_use_double11     double11;
typedef struct __Reserved_Name__Do_not_use_double12     double12;
typedef struct __Reserved_Name__Do_not_use_double13     double13;
typedef struct __Reserved_Name__Do_not_use_double14     double14;
typedef struct __Reserved_Name__Do_not_use_double15     double15;
typedef struct __Reserved_Name__Do_not_use_double32     double32;
typedef struct __Reserved_Name__Do_not_use_char5        char5;
typedef struct __Reserved_Name__Do_not_use_char6        char6;
typedef struct __Reserved_Name__Do_not_use_char7        char7;
typedef struct __Reserved_Name__Do_not_use_char9        char9;
typedef struct __Reserved_Name__Do_not_use_char10       char10;
typedef struct __Reserved_Name__Do_not_use_char11       char11;
typedef struct __Reserved_Name__Do_not_use_char12       char12;
typedef struct __Reserved_Name__Do_not_use_char13       char13;
typedef struct __Reserved_Name__Do_not_use_char14       char14;
typedef struct __Reserved_Name__Do_not_use_char15       char15;
typedef struct __Reserved_Name__Do_not_use_char32       char32;
typedef struct __Reserved_Name__Do_not_use_uchar5       uchar5;
typedef struct __Reserved_Name__Do_not_use_uchar6       uchar6;
typedef struct __Reserved_Name__Do_not_use_uchar7       uchar7;
typedef struct __Reserved_Name__Do_not_use_uchar9       uchar9;
typedef struct __Reserved_Name__Do_not_use_uchar10      uchar10;
typedef struct __Reserved_Name__Do_not_use_uchar11      uchar11;
typedef struct __Reserved_Name__Do_not_use_uchar12      uchar12;
typedef struct __Reserved_Name__Do_not_use_uchar13      uchar13;
typedef struct __Reserved_Name__Do_not_use_uchar14      uchar14;
typedef struct __Reserved_Name__Do_not_use_uchar15      uchar15;
typedef struct __Reserved_Name__Do_not_use_uchar32      uchar32;
typedef struct __Reserved_Name__Do_not_use_short5       short5;
typedef struct __Reserved_Name__Do_not_use_short6       short6;
typedef struct __Reserved_Name__Do_not_use_short7       short7;
typedef struct __Reserved_Name__Do_not_use_short9       short9;
typedef struct __Reserved_Name__Do_not_use_short10      short10;
typedef struct __Reserved_Name__Do_not_use_short11      short11;
typedef struct __Reserved_Name__Do_not_use_short12      short12;
typedef struct __Reserved_Name__Do_not_use_short13      short13;
typedef struct __Reserved_Name__Do_not_use_short14      short14;
typedef struct __Reserved_Name__Do_not_use_short15      short15;
typedef struct __Reserved_Name__Do_not_use_short32      short32;
typedef struct __Reserved_Name__Do_not_use_ushort5      ushort5;
typedef struct __Reserved_Name__Do_not_use_ushort6      ushort6;
typedef struct __Reserved_Name__Do_not_use_ushort7      ushort7;
typedef struct __Reserved_Name__Do_not_use_ushort9      ushort9;
typedef struct __Reserved_Name__Do_not_use_ushort10     ushort10;
typedef struct __Reserved_Name__Do_not_use_ushort11     ushort11;
typedef struct __Reserved_Name__Do_not_use_ushort12     ushort12;
typedef struct __Reserved_Name__Do_not_use_ushort13     ushort13;
typedef struct __Reserved_Name__Do_not_use_ushort14     ushort14;
typedef struct __Reserved_Name__Do_not_use_ushort15     ushort15;
typedef struct __Reserved_Name__Do_not_use_ushort32     ushort32;
typedef struct __Reserved_Name__Do_not_use_int5         int5;
typedef struct __Reserved_Name__Do_not_use_int6         int6;
typedef struct __Reserved_Name__Do_not_use_int7         int7;
typedef struct __Reserved_Name__Do_not_use_int9         int9;
typedef struct __Reserved_Name__Do_not_use_int10        int10;
typedef struct __Reserved_Name__Do_not_use_int11        int11;
typedef struct __Reserved_Name__Do_not_use_int12        int12;
typedef struct __Reserved_Name__Do_not_use_int13        int13;
typedef struct __Reserved_Name__Do_not_use_int14        int14;
typedef struct __Reserved_Name__Do_not_use_int15        int15;
typedef struct __Reserved_Name__Do_not_use_int32        int32;
typedef struct __Reserved_Name__Do_not_use_uint5        uint5;
typedef struct __Reserved_Name__Do_not_use_uint6        uint6;
typedef struct __Reserved_Name__Do_not_use_uint7        uint7;
typedef struct __Reserved_Name__Do_not_use_uint9        uint9;
typedef struct __Reserved_Name__Do_not_use_uint10       uint10;
typedef struct __Reserved_Name__Do_not_use_uint11       uint11;
typedef struct __Reserved_Name__Do_not_use_uint12       uint12;
typedef struct __Reserved_Name__Do_not_use_uint13       uint13;
typedef struct __Reserved_Name__Do_not_use_uint14       uint14;
typedef struct __Reserved_Name__Do_not_use_uint15       uint15;
typedef struct __Reserved_Name__Do_not_use_uint32       uint32;
typedef struct __Reserved_Name__Do_not_use_long5        long5;
typedef struct __Reserved_Name__Do_not_use_long6        long6;
typedef struct __Reserved_Name__Do_not_use_long7        long7;
typedef struct __Reserved_Name__Do_not_use_long9        long9;
typedef struct __Reserved_Name__Do_not_use_long10       long10;
typedef struct __Reserved_Name__Do_not_use_long11       long11;
typedef struct __Reserved_Name__Do_not_use_long12       long12;
typedef struct __Reserved_Name__Do_not_use_long13       long13;
typedef struct __Reserved_Name__Do_not_use_long14       long14;
typedef struct __Reserved_Name__Do_not_use_long15       long15;
typedef struct __Reserved_Name__Do_not_use_long32       long32;
typedef struct __Reserved_Name__Do_not_use_ulong5       ulong5;
typedef struct __Reserved_Name__Do_not_use_ulong6       ulong6;
typedef struct __Reserved_Name__Do_not_use_ulong7       ulong7;
typedef struct __Reserved_Name__Do_not_use_ulong9       ulong9;
typedef struct __Reserved_Name__Do_not_use_ulong10      ulong10;
typedef struct __Reserved_Name__Do_not_use_ulong11      ulong11;
typedef struct __Reserved_Name__Do_not_use_ulong12      ulong12;
typedef struct __Reserved_Name__Do_not_use_ulong13      ulong13;
typedef struct __Reserved_Name__Do_not_use_ulong14      ulong14;
typedef struct __Reserved_Name__Do_not_use_ulong15      ulong15;
typedef struct __Reserved_Name__Do_not_use_ulong32      ulong32;
typedef struct __Reserved_Name__Do_not_use_quad5        quad5;
typedef struct __Reserved_Name__Do_not_use_quad6        quad6;
typedef struct __Reserved_Name__Do_not_use_quad7        quad7;
typedef struct __Reserved_Name__Do_not_use_quad9        quad9;
typedef struct __Reserved_Name__Do_not_use_quad10       quad10;
typedef struct __Reserved_Name__Do_not_use_quad11       quad11;
typedef struct __Reserved_Name__Do_not_use_quad12       quad12;
typedef struct __Reserved_Name__Do_not_use_quad13       quad13;
typedef struct __Reserved_Name__Do_not_use_quad14       quad14;
typedef struct __Reserved_Name__Do_not_use_quad15       quad15;
typedef struct __Reserved_Name__Do_not_use_quad32       quad32;
typedef struct __Reserved_Name__Do_not_use_half5        half5;
typedef struct __Reserved_Name__Do_not_use_half6        half6;
typedef struct __Reserved_Name__Do_not_use_half7        half7;
typedef struct __Reserved_Name__Do_not_use_half9        half9;
typedef struct __Reserved_Name__Do_not_use_half10       half10;
typedef struct __Reserved_Name__Do_not_use_half11       half11;
typedef struct __Reserved_Name__Do_not_use_half12       half12;
typedef struct __Reserved_Name__Do_not_use_half13       half13;
typedef struct __Reserved_Name__Do_not_use_half14       half14;
typedef struct __Reserved_Name__Do_not_use_half15       half15;
typedef struct __Reserved_Name__Do_not_use_half32       half32;



typedef __typeof__(((int*)0)-((int*)0)) ptrdiff_t;
typedef __SIZE_TYPE__ size_t;
typedef __SIZE_TYPE__ uintptr_t;
typedef __PTRDIFF_TYPE__ intptr_t;
typedef size_t       event_t;

#define __OVERLOAD_INLINE__ __attribute__((__overloadable__, __always_inline__))
#define __OVERLOAD__ __attribute__((__overloadable__))

// Macro machinery for C-based type overloading of builtin functions

// Returns float or double, one float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
float2 __OVERLOAD__ name(float2 x); \
float3 __OVERLOAD__ name(float3 x); \
float4 __OVERLOAD__ name(float4 x); \
float8 __OVERLOAD__ name(float8 x); \
float16 __OVERLOAD__ name(float16 x); \
double __OVERLOAD__ name(double x); \
double2 __OVERLOAD__ name(double2 x); \
double3 __OVERLOAD__ name(double3 x); \
double4 __OVERLOAD__ name(double4 x); \
double8 __OVERLOAD__ name(double8 x); \
double16 __OVERLOAD__ name(double16 x); 
#else
#define __CLFN_FD_1FD(name) float __OVERLOAD__ name(float x); \
float2 __OVERLOAD__ name(float2 x); \
float3 __OVERLOAD__ name(float3 x); \
float4 __OVERLOAD__ name(float4 x); \
float8 __OVERLOAD__ name(float8 x); \
float16 __OVERLOAD__ name(float16 x);
#endif


#if defined(__FAST_RELAXED_MATH__)
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_FAST_RELAX(_name, _native_name, _default_name) \
inline float __OVERLOAD__ _name(float x) { return _native_name(x); } \
inline float2 __OVERLOAD__ _name(float2 x) { return _native_name(x); } \
inline float3 __OVERLOAD__ _name(float3 x) { return _native_name(x); } \
inline float4 __OVERLOAD__ _name(float4 x) { return _native_name(x); } \
inline float8 __OVERLOAD__ _name(float8 x) { return _native_name(x); } \
inline float16 __OVERLOAD__ _name(float16 x){ return _native_name(x); } \
inline double __OVERLOAD__ _name(double x) { return _default_name(x); } \
inline double2 __OVERLOAD__ _name(double2 x) { return _default_name(x); } \
inline double3 __OVERLOAD__ _name(double3 x) { return _default_name(x); } \
inline double4 __OVERLOAD__ _name(double4 x) { return _default_name(x); } \
inline double8 __OVERLOAD__ _name(double8 x) { return _default_name(x); } \
inline double16 __OVERLOAD__ _name(double16 x) { return _default_name(x); }
#else
#define __CLFN_FD_1FD_FAST_RELAX(_name, _native_name, _default_name) \
inline float __OVERLOAD__ _name(float x) { return _native_name(x); } \
inline float2 __OVERLOAD__ _name(float2 x) { return _native_name(x); } \
inline float3 __OVERLOAD__ _name(float3 x) { return _native_name(x); } \
inline float4 __OVERLOAD__ _name(float4 x) { return _native_name(x); } \
inline float8 __OVERLOAD__ _name(float8 x) { return _native_name(x); } \
inline float16 __OVERLOAD__ _name(float16 x){ return _native_name(x); }
#endif
#else //! __FAST_RELAXED_MATH__
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_FAST_RELAX(_name, _native_name, _default_name) \
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); } \
inline double __OVERLOAD__ _name(double x) { return _default_name(x); } \
inline double2 __OVERLOAD__ _name(double2 x) { return _default_name(x); } \
inline double3 __OVERLOAD__ _name(double3 x) { return _default_name(x); } \
inline double4 __OVERLOAD__ _name(double4 x) { return _default_name(x); } \
inline double8 __OVERLOAD__ _name(double8 x) { return _default_name(x); } \
inline double16 __OVERLOAD__ _name(double16 x) { return _default_name(x); }
#else
#define __CLFN_FD_1FD_FAST_RELAX(_name, _native_name, _default_name) \
inline float __OVERLOAD__ _name(float x) { return _default_name(x); } \
inline float2 __OVERLOAD__ _name(float2 x) { return _default_name(x); } \
inline float3 __OVERLOAD__ _name(float3 x) { return _default_name(x); } \
inline float4 __OVERLOAD__ _name(float4 x) { return _default_name(x); } \
inline float8 __OVERLOAD__ _name(float8 x) { return _default_name(x); } \
inline float16 __OVERLOAD__ _name(float16 x){ return _default_name(x); }
#endif
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_MODD(name) float __OVERLOAD__ name(float x); \
float __OVERLOAD__ name(float2 x); \
float __OVERLOAD__ name(float3 x); \
float __OVERLOAD__ name(float4 x); \
float __OVERLOAD__ name(float8 x); \
float __OVERLOAD__ name(float16 x); \
double __OVERLOAD__ name(double x); \
double __OVERLOAD__ name(double2 x); \
double __OVERLOAD__ name(double3 x); \
double __OVERLOAD__ name(double4 x); \
double __OVERLOAD__ name(double8 x); \
double __OVERLOAD__ name(double16 x);
#else
#define __CLFN_FD_1FD_MODD(name) float __OVERLOAD__ name(float x); \
float __OVERLOAD__ name(float2 x); \
float __OVERLOAD__ name(float3 x); \
float __OVERLOAD__ name(float4 x); \
float __OVERLOAD__ name(float8 x); \
float __OVERLOAD__ name(float16 x);
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_I_1FD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x); \
int __OVERLOAD__ name(double x); \
int2 __OVERLOAD__ name(double2 x); \
int3 __OVERLOAD__ name(double3 x); \
int4 __OVERLOAD__ name(double4 x); \
int8 __OVERLOAD__ name(double8 x); \
int16 __OVERLOAD__ name(double16 x);
#else
#define __CLFN_I_1FD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x);
#endif

// Returns float, float inputs, up to size 4. 
#define __CLFN_1F_2F(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); 

// Returns float, float inputs, up to size 4.
#define __CLFN_1F_2F_MODD(name) float __OVERLOAD__ name(float x, float y); \
float __OVERLOAD__ name(float2 x, float2 y); \
float __OVERLOAD__ name(float3 x, float3 y); \
float __OVERLOAD__ name(float4 x, float4 y);

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_1FD_2FD_MODD(name) float __OVERLOAD__ name(float x, float y); \
float __OVERLOAD__ name(float2 x, float2 y); \
float __OVERLOAD__ name(float3 x, float3 y); \
float __OVERLOAD__ name(float4 x, float4 y); \
double __OVERLOAD__ name(double x, double y); \
double __OVERLOAD__ name(double2 x, double2 y); \
double __OVERLOAD__ name(double3 x, double3 y); \
double __OVERLOAD__ name(double4 x, double4 y);
#else
#define __CLFN_1FD_2FD_MODD(name) float __OVERLOAD__ name(float x, float y); \
float __OVERLOAD__ name(float2 x, float2 y); \
float __OVERLOAD__ name(float3 x, float3 y); \
float __OVERLOAD__ name(float4 x, float4 y);
#endif

// Returns float, float inputs, up to size 4.
#define __CLFN_F_1F_MODD4(name) float __OVERLOAD__ name(float x ); \
float __OVERLOAD__ name(float2 x); \
float __OVERLOAD__ name(float3 x); \
float __OVERLOAD__ name(float4 x);

// Returns float or double, two float or double input. Only up to size 4.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD_MODD4(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
double __OVERLOAD__ name(double x, double y); \
double2 __OVERLOAD__ name(double2 x, double2 y); \
double3 __OVERLOAD__ name(double3 x, double3 y); \
double4 __OVERLOAD__ name(double4 x, double4 y); 
#else
#define __CLFN_FD_2FD_MODD4(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y);
#endif

// Returns float or double, one float or double input. Only up to size 4.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_MODD4(name) float __OVERLOAD__ name(float x); \
float2 __OVERLOAD__ name(float2 x); \
float3 __OVERLOAD__ name(float3 x); \
float4 __OVERLOAD__ name(float4 x); \
double __OVERLOAD__ name(double x); \
double2 __OVERLOAD__ name(double2 x); \
double3 __OVERLOAD__ name(double3 x); \
double4 __OVERLOAD__ name(double4 x);
#else
#define __CLFN_FD_1FD_MODD4(name) float __OVERLOAD__ name(float x); \
float2 __OVERLOAD__ name(float2 x); \
float3 __OVERLOAD__ name(float3 x); \
float4 __OVERLOAD__ name(float4 x);
#endif

// Returns float or double, one uing or ulong input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1UIL(name) float __OVERLOAD__ name(uint x); \
float2 __OVERLOAD__ name(uint2 x); \
float3 __OVERLOAD__ name(uint3 x); \
float4 __OVERLOAD__ name(uint4 x); \
float8 __OVERLOAD__ name(uint8 x); \
float16 __OVERLOAD__ name(uint16 x); \
double __OVERLOAD__ name(ulong x); \
double2 __OVERLOAD__ name(ulong2 x); \
double3 __OVERLOAD__ name(ulong3 x); \
double4 __OVERLOAD__ name(ulong4 x); \
double8 __OVERLOAD__ name(ulong8 x); \
double16 __OVERLOAD__ name(ulong16 x); 
#else
#define __CLFN_FD_1UIL(name) float __OVERLOAD__ name(uint x); \
float2 __OVERLOAD__ name(uint2 x); \
float3 __OVERLOAD__ name(uint3 x); \
float4 __OVERLOAD__ name(uint4 x); \
float8 __OVERLOAD__ name(uint8 x); \
float16 __OVERLOAD__ name(uint16 x); 
#endif

// Returns int or long, one float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_IL_1FD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x); \
long __OVERLOAD__ name(double x); \
long2 __OVERLOAD__ name(double2 x); \
long3 __OVERLOAD__ name(double3 x); \
long4 __OVERLOAD__ name(double4 x); \
long8 __OVERLOAD__ name(double8 x); \
long16 __OVERLOAD__ name(double16 x); 
#else
#define __CLFN_IL_1FD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x);
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_IL_1FD_MODD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x); \
int __OVERLOAD__ name(double x); \
long2 __OVERLOAD__ name(double2 x); \
long3 __OVERLOAD__ name(double3 x); \
long4 __OVERLOAD__ name(double4 x); \
long8 __OVERLOAD__ name(double8 x); \
long16 __OVERLOAD__ name(double16 x);
#else
#define __CLFN_IL_1FD_MODD(name) int __OVERLOAD__ name(float x); \
int2 __OVERLOAD__ name(float2 x); \
int3 __OVERLOAD__ name(float3 x); \
int4 __OVERLOAD__ name(float4 x); \
int8 __OVERLOAD__ name(float8 x); \
int16 __OVERLOAD__ name(float16 x);
#endif


// Returns same as the input. Accepts char,uchar,short,ushort,
// long,ulong,int,unint.
#define __CLFN_CSIL_1CSIL(name) char __OVERLOAD__ name(char x); \
char2 __OVERLOAD__ name(char2 x); \
char3 __OVERLOAD__ name(char3 x); \
char4 __OVERLOAD__ name(char4 x); \
char8 __OVERLOAD__ name(char8 x); \
char16 __OVERLOAD__ name(char16 x); \
uchar __OVERLOAD__ name(uchar x); \
uchar2 __OVERLOAD__ name(uchar2 x); \
uchar3 __OVERLOAD__ name(uchar3 x); \
uchar4 __OVERLOAD__ name(uchar4 x); \
uchar8 __OVERLOAD__ name(uchar8 x); \
uchar16 __OVERLOAD__ name(uchar16 x); \
int __OVERLOAD__ name(int x); \
int2 __OVERLOAD__ name(int2 x); \
int3 __OVERLOAD__ name(int3 x); \
int4 __OVERLOAD__ name(int4 x); \
int8 __OVERLOAD__ name(int8 x); \
int16 __OVERLOAD__ name(int16 x); \
uint __OVERLOAD__ name(uint x); \
uint2 __OVERLOAD__ name(uint2 x); \
uint3 __OVERLOAD__ name(uint3 x); \
uint4 __OVERLOAD__ name(uint4 x); \
uint8 __OVERLOAD__ name(uint8 x); \
uint16 __OVERLOAD__ name(uint16 x); \
short __OVERLOAD__ name(short x); \
short2 __OVERLOAD__ name(short2 x); \
short3 __OVERLOAD__ name(short3 x); \
short4 __OVERLOAD__ name(short4 x); \
short8 __OVERLOAD__ name(short8 x); \
short16 __OVERLOAD__ name(short16 x); \
ushort __OVERLOAD__ name(ushort x); \
ushort2 __OVERLOAD__ name(ushort2 x); \
ushort3 __OVERLOAD__ name(ushort3 x); \
ushort4 __OVERLOAD__ name(ushort4 x); \
ushort8 __OVERLOAD__ name(ushort8 x); \
ushort16 __OVERLOAD__ name(ushort16 x); \
long __OVERLOAD__ name(long x); \
long2 __OVERLOAD__ name(long2 x); \
long3 __OVERLOAD__ name(long3 x); \
long4 __OVERLOAD__ name(long4 x); \
long8 __OVERLOAD__ name(long8 x); \
long16 __OVERLOAD__ name(long16 x); \
ulong __OVERLOAD__ name(ulong x); \
ulong2 __OVERLOAD__ name(ulong2 x); \
ulong3 __OVERLOAD__ name(ulong3 x); \
ulong4 __OVERLOAD__ name(ulong4 x); \
ulong8 __OVERLOAD__ name(ulong8 x); \
ulong16 __OVERLOAD__ name(ulong16 x); 

// Returns same as the input but unsigned. Accepts char,uchar,short,ushort,
// long,ulong,int,unint.
#define __CLFN_UCSIL_1CSIL(name) uchar __OVERLOAD__ name(char x); \
uchar2 __OVERLOAD__ name(char2 x); \
uchar3 __OVERLOAD__ name(char3 x); \
uchar4 __OVERLOAD__ name(char4 x); \
uchar8 __OVERLOAD__ name(char8 x); \
uchar16 __OVERLOAD__ name(char16 x); \
uchar __OVERLOAD__ name(uchar x); \
uchar2 __OVERLOAD__ name(uchar2 x); \
uchar3 __OVERLOAD__ name(uchar3 x); \
uchar4 __OVERLOAD__ name(uchar4 x); \
uchar8 __OVERLOAD__ name(uchar8 x); \
uchar16 __OVERLOAD__ name(uchar16 x); \
uint __OVERLOAD__ name(int x); \
uint2 __OVERLOAD__ name(int2 x); \
uint3 __OVERLOAD__ name(int3 x); \
uint4 __OVERLOAD__ name(int4 x); \
uint8 __OVERLOAD__ name(int8 x); \
uint16 __OVERLOAD__ name(int16 x); \
uint __OVERLOAD__ name(uint x); \
uint2 __OVERLOAD__ name(uint2 x); \
uint3 __OVERLOAD__ name(uint3 x); \
uint4 __OVERLOAD__ name(uint4 x); \
uint8 __OVERLOAD__ name(uint8 x); \
uint16 __OVERLOAD__ name(uint16 x); \
ushort __OVERLOAD__ name(short x); \
ushort2 __OVERLOAD__ name(short2 x); \
ushort3 __OVERLOAD__ name(short3 x); \
ushort4 __OVERLOAD__ name(short4 x); \
ushort8 __OVERLOAD__ name(short8 x); \
ushort16 __OVERLOAD__ name(short16 x); \
ushort __OVERLOAD__ name(ushort x); \
ushort2 __OVERLOAD__ name(ushort2 x); \
ushort3 __OVERLOAD__ name(ushort3 x); \
ushort4 __OVERLOAD__ name(ushort4 x); \
ushort8 __OVERLOAD__ name(ushort8 x); \
ushort16 __OVERLOAD__ name(ushort16 x); \
ulong __OVERLOAD__ name(long x); \
ulong2 __OVERLOAD__ name(long2 x); \
ulong3 __OVERLOAD__ name(long3 x); \
ulong4 __OVERLOAD__ name(long4 x); \
ulong8 __OVERLOAD__ name(long8 x); \
ulong16 __OVERLOAD__ name(long16 x); \
ulong __OVERLOAD__ name(ulong x); \
ulong2 __OVERLOAD__ name(ulong2 x); \
ulong3 __OVERLOAD__ name(ulong3 x); \
ulong4 __OVERLOAD__ name(ulong4 x); \
ulong8 __OVERLOAD__ name(ulong8 x); \
ulong16 __OVERLOAD__ name(ulong16 x); 

// Returns float or double, two float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1F(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
float8 __OVERLOAD__ name(float8 x, float8 y); \
float16 __OVERLOAD__ name(float16 x, float16 y); \
double __OVERLOAD__ name(double x, double y); \
double2 __OVERLOAD__ name(double2 x, double2 y); \
double3 __OVERLOAD__ name(double3 x, double3 y); \
double4 __OVERLOAD__ name(double4 x, double4 y); \
double8 __OVERLOAD__ name(double8 x, double8 y); \
double16 __OVERLOAD__ name(double16 x, double16 y); 
#else
#define __CLFN_FD_1F(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
float8 __OVERLOAD__ name(float8 x, float8 y); \
float16 __OVERLOAD__ name(float16 x, float16 y);
#endif

// Returns float or double, two float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_1I(name) float __OVERLOAD__ name(float x, int y); \
float2 __OVERLOAD__ name(float2 x, int2 y); \
float3 __OVERLOAD__ name(float3 x, int3 y); \
float4 __OVERLOAD__ name(float4 x, int4 y); \
float8 __OVERLOAD__ name(float8 x, int8 y); \
float16 __OVERLOAD__ name(float16 x, int16 y); \
float2 __OVERLOAD__ name(float2 x, int y); \
float3 __OVERLOAD__ name(float3 x, int y); \
float4 __OVERLOAD__ name(float4 x, int y); \
float8 __OVERLOAD__ name(float8 x, int y); \
float16 __OVERLOAD__ name(float16 x, int y); \
double __OVERLOAD__ name(double x, int y); \
double2 __OVERLOAD__ name(double2 x, int2 y); \
double3 __OVERLOAD__ name(double3 x, int3 y); \
double4 __OVERLOAD__ name(double4 x, int4 y); \
double8 __OVERLOAD__ name(double8 x, int8 y); \
double16 __OVERLOAD__ name(double16 x, int16 y); \
double2 __OVERLOAD__ name(double2 x, int y); \
double3 __OVERLOAD__ name(double3 x, int y); \
double4 __OVERLOAD__ name(double4 x, int y); \
double8 __OVERLOAD__ name(double8 x, int y); \
double16 __OVERLOAD__ name(double16 x, int y); 
#else
#define __CLFN_FD_1FD_1I(name) float __OVERLOAD__ name(float x, int y); \
float2 __OVERLOAD__ name(float2 x, int2 y); \
float3 __OVERLOAD__ name(float3 x, int3 y); \
float4 __OVERLOAD__ name(float4 x, int4 y); \
float8 __OVERLOAD__ name(float8 x, int8 y); \
float16 __OVERLOAD__ name(float16 x, int16 y); \
float2 __OVERLOAD__ name(float2 x, int y); \
float3 __OVERLOAD__ name(float3 x, int y); \
float4 __OVERLOAD__ name(float4 x, int y); \
float8 __OVERLOAD__ name(float8 x, int y); \
float16 __OVERLOAD__ name(float16 x, int y);
#endif

// Returns float or double, one float or double input, and one pointer to 
// float or double.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_1PFD(name) float __OVERLOAD__ name(float x, float* y); \
float2 __OVERLOAD__ name(float2 x, float2* y); \
float3 __OVERLOAD__ name(float3 x, float3* y); \
float4 __OVERLOAD__ name(float4 x, float4* y); \
float8 __OVERLOAD__ name(float8 x, float8* y); \
float16 __OVERLOAD__ name(float16 x, float16* y); \
float __OVERLOAD__ name(float x, __global float* y); \
float2 __OVERLOAD__ name(float2 x, __global float2* y); \
float3 __OVERLOAD__ name(float3 x, __global float3* y); \
float4 __OVERLOAD__ name(float4 x, __global float4* y); \
float8 __OVERLOAD__ name(float8 x, __global float8* y); \
float16 __OVERLOAD__ name(float16 x, __global float16* y); \
float __OVERLOAD__ name(float x, __local float* y); \
float2 __OVERLOAD__ name(float2 x, __local float2* y); \
float3 __OVERLOAD__ name(float3 x, __local float3* y); \
float4 __OVERLOAD__ name(float4 x, __local float4* y); \
float8 __OVERLOAD__ name(float8 x, __local float8* y); \
float16 __OVERLOAD__ name(float16 x, __local float16* y); \
double __OVERLOAD__ name(double x, double* y); \
double2 __OVERLOAD__ name(double2 x, double2* y); \
double3 __OVERLOAD__ name(double3 x, double3* y); \
double4 __OVERLOAD__ name(double4 x, double4* y); \
double8 __OVERLOAD__ name(double8 x, double8* y); \
double16 __OVERLOAD__ name(double16 x, double16* y); \
double __OVERLOAD__ name(double x, __global double* y); \
double2 __OVERLOAD__ name(double2 x, __global double2* y); \
double3 __OVERLOAD__ name(double3 x, __global double3* y); \
double4 __OVERLOAD__ name(double4 x, __global double4* y); \
double8 __OVERLOAD__ name(double8 x, __global double8* y); \
double16 __OVERLOAD__ name(double16 x, __global double16* y); \
double __OVERLOAD__ name(double x, __local double* y); \
double2 __OVERLOAD__ name(double2 x, __local double2* y); \
double3 __OVERLOAD__ name(double3 x, __local double3* y); \
double4 __OVERLOAD__ name(double4 x, __local double4* y); \
double8 __OVERLOAD__ name(double8 x, __local double8* y); \
double16 __OVERLOAD__ name(double16 x, __local double16* y); 
#else
#define __CLFN_FD_1FD_1PFD(name) float __OVERLOAD__ name(float x, float* y); \
float2 __OVERLOAD__ name(float2 x, float2* y); \
float3 __OVERLOAD__ name(float3 x, float3* y); \
float4 __OVERLOAD__ name(float4 x, float4* y); \
float8 __OVERLOAD__ name(float8 x, float8* y); \
float16 __OVERLOAD__ name(float16 x, float16* y); \
float __OVERLOAD__ name(float x, __global float* y); \
float2 __OVERLOAD__ name(float2 x, __global float2* y); \
float3 __OVERLOAD__ name(float3 x, __global float3* y); \
float4 __OVERLOAD__ name(float4 x, __global float4* y); \
float8 __OVERLOAD__ name(float8 x, __global float8* y); \
float16 __OVERLOAD__ name(float16 x, __global float16* y); \
float __OVERLOAD__ name(float x, __local float* y); \
float2 __OVERLOAD__ name(float2 x, __local float2* y); \
float3 __OVERLOAD__ name(float3 x, __local float3* y); \
float4 __OVERLOAD__ name(float4 x, __local float4* y); \
float8 __OVERLOAD__ name(float8 x, __local float8* y); \
float16 __OVERLOAD__ name(float16 x, __local float16* y);
#endif

// Returns float or double, one float or double input, and one pointer to 
// int.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_1FD_1PI(name) float __OVERLOAD__ name(float x, int* y); \
float2 __OVERLOAD__ name(float2 x, int2* y); \
float3 __OVERLOAD__ name(float3 x, int3* y); \
float4 __OVERLOAD__ name(float4 x, int4* y); \
float8 __OVERLOAD__ name(float8 x, int8* y); \
float16 __OVERLOAD__ name(float16 x, int16* y); \
float __OVERLOAD__ name(float x, __global int* y); \
float2 __OVERLOAD__ name(float2 x, __global int2* y); \
float3 __OVERLOAD__ name(float3 x, __global int3* y); \
float4 __OVERLOAD__ name(float4 x, __global int4* y); \
float8 __OVERLOAD__ name(float8 x, __global int8* y); \
float16 __OVERLOAD__ name(float16 x, __global int16* y); \
float __OVERLOAD__ name(float x, __local int* y); \
float2 __OVERLOAD__ name(float2 x, __local int2* y); \
float3 __OVERLOAD__ name(float3 x, __local int3* y); \
float4 __OVERLOAD__ name(float4 x, __local int4* y); \
float8 __OVERLOAD__ name(float8 x, __local int8* y); \
float16 __OVERLOAD__ name(float16 x, __local int16* y); \
double __OVERLOAD__ name(double x, int* y); \
double2 __OVERLOAD__ name(double2 x, int2* y); \
double3 __OVERLOAD__ name(double3 x, int3* y); \
double4 __OVERLOAD__ name(double4 x, int4* y); \
double8 __OVERLOAD__ name(double8 x, int8* y); \
double16 __OVERLOAD__ name(double16 x, int16* y); \
double __OVERLOAD__ name(double x, __global int* y); \
double2 __OVERLOAD__ name(double2 x, __global int2* y); \
double3 __OVERLOAD__ name(double3 x, __global int3* y); \
double4 __OVERLOAD__ name(double4 x, __global int4* y); \
double8 __OVERLOAD__ name(double8 x, __global int8* y); \
double16 __OVERLOAD__ name(double16 x, __global int16* y); \
double __OVERLOAD__ name(double x, __local int* y); \
double2 __OVERLOAD__ name(double2 x, __local int2* y); \
double3 __OVERLOAD__ name(double3 x, __local int3* y); \
double4 __OVERLOAD__ name(double4 x, __local int4* y); \
double8 __OVERLOAD__ name(double8 x, __local int8* y); \
double16 __OVERLOAD__ name(double16 x, __local int16* y); 
#else
#define __CLFN_FD_1FD_1PI(name) float __OVERLOAD__ name(float x, int* y); \
float2 __OVERLOAD__ name(float2 x, int2* y); \
float3 __OVERLOAD__ name(float3 x, int3* y); \
float4 __OVERLOAD__ name(float4 x, int4* y); \
float8 __OVERLOAD__ name(float8 x, int8* y); \
float16 __OVERLOAD__ name(float16 x, int16* y); \
float __OVERLOAD__ name(float x, __global int* y); \
float2 __OVERLOAD__ name(float2 x, __global int2* y); \
float3 __OVERLOAD__ name(float3 x, __global int3* y); \
float4 __OVERLOAD__ name(float4 x, __global int4* y); \
float8 __OVERLOAD__ name(float8 x, __global int8* y); \
float16 __OVERLOAD__ name(float16 x, __global int16* y); \
float __OVERLOAD__ name(float x, __local int* y); \
float2 __OVERLOAD__ name(float2 x, __local int2* y); \
float3 __OVERLOAD__ name(float3 x, __local int3* y); \
float4 __OVERLOAD__ name(float4 x, __local int4* y); \
float8 __OVERLOAD__ name(float8 x, __local int8* y); \
float16 __OVERLOAD__ name(float16 x, __local int16* y);
#endif

// Returns float or double, two float or double input, and one pointer to 
// int.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD_1PI(name) float __OVERLOAD__ name(float x, float y, int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, int16* z); \
float __OVERLOAD__ name(float x, float y, __global int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, __global int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, __global int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, __global int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, __global int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, __global int16* z); \
float __OVERLOAD__ name(float x, float y, __local int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, __local int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, __local int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, __local int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, __local int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, __local int16* z); \
double __OVERLOAD__ name(double x, double y, int* z); \
double2 __OVERLOAD__ name(double2 x, double2 y, int2* z); \
double3 __OVERLOAD__ name(double3 x, double3 y, int3* z); \
double4 __OVERLOAD__ name(double4 x, double4 y, int4* z); \
double8 __OVERLOAD__ name(double8 x, double8 y, int8* z); \
double16 __OVERLOAD__ name(double16 x, double16 y, int16* z); \
double __OVERLOAD__ name(double x, double y, __global int* z); \
double2 __OVERLOAD__ name(double2 x, double2 y, __global int2* z); \
double3 __OVERLOAD__ name(double3 x, double3 y, __global int3* z); \
double4 __OVERLOAD__ name(double4 x, double4 y, __global int4* z); \
double8 __OVERLOAD__ name(double8 x, double8 y, __global int8* z); \
double16 __OVERLOAD__ name(double16 x, double16 y, __global int16* z); \
double __OVERLOAD__ name(double x, double y, __local int* z); \
double2 __OVERLOAD__ name(double2 x, double2 y, __local int2* z); \
double3 __OVERLOAD__ name(double3 x, double3 y, __local int3* z); \
double4 __OVERLOAD__ name(double4 x, double4 y, __local int4* z); \
double8 __OVERLOAD__ name(double8 x, double8 y, __local int8* z); \
double16 __OVERLOAD__ name(double16 x, double16 y, __local int16* z); 
#else
#define __CLFN_FD_2FD_1PI(name) float __OVERLOAD__ name(float x, float y, int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, int16* z); \
float __OVERLOAD__ name(float x, float y, __global int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, __global int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, __global int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, __global int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, __global int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, __global int16* z); \
float __OVERLOAD__ name(float x, float y, __local int* z); \
float2 __OVERLOAD__ name(float2 x, float2 y, __local int2* z); \
float3 __OVERLOAD__ name(float3 x, float3 y, __local int3* z); \
float4 __OVERLOAD__ name(float4 x, float4 y, __local int4* z); \
float8 __OVERLOAD__ name(float8 x, float8 y, __local int8* z); \
float16 __OVERLOAD__ name(float16 x, float16 y, __local int16* z);
#endif

// Returns float or double, three float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_3FD_MOD(name) float __OVERLOAD__ name(float x, float y, float z); \
float2 __OVERLOAD__ name(float2 x, float2 y, float z); \
float3 __OVERLOAD__ name(float3 x, float3 y, float z); \
float4 __OVERLOAD__ name(float4 x, float4 y, float z); \
float8 __OVERLOAD__ name(float8 x, float8 y, float z); \
float16 __OVERLOAD__ name(float16 x, float16 y, float z); \
double __OVERLOAD__ name(double x, double y, double z); \
double2 __OVERLOAD__ name(double2 x, double2 y, double z); \
double3 __OVERLOAD__ name(double3 x, double3 y, double z); \
double4 __OVERLOAD__ name(double4 x, double4 y, double z); \
double8 __OVERLOAD__ name(double8 x, double8 y, double z); \
double16 __OVERLOAD__ name(double16 x, double16 y, double z); 
#else
#define __CLFN_FD_3FD_MOD(name) float __OVERLOAD__ name(float x, float y, float z); \
float2 __OVERLOAD__ name(float2 x, float2 y, float z); \
float3 __OVERLOAD__ name(float3 x, float3 y, float z); \
float4 __OVERLOAD__ name(float4 x, float4 y, float z); \
float8 __OVERLOAD__ name(float8 x, float8 y, float z); \
float16 __OVERLOAD__ name(float16 x, float16 y, float z);
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_3FD(name) float __OVERLOAD__ name(float x, float y, float z); \
float2 __OVERLOAD__ name(float2 x, float2 y, float2 z); \
float3 __OVERLOAD__ name(float3 x, float3 y, float3 z); \
float4 __OVERLOAD__ name(float4 x, float4 y, float4 z); \
float8 __OVERLOAD__ name(float8 x, float8 y, float8 z); \
float16 __OVERLOAD__ name(float16 x, float16 y, float16 z); \
double __OVERLOAD__ name(double x, double y, double z); \
double2 __OVERLOAD__ name(double2 x, double2 y, double2 z); \
double3 __OVERLOAD__ name(double3 x, double3 y, double3 z); \
double4 __OVERLOAD__ name(double4 x, double4 y, double4 z); \
double8 __OVERLOAD__ name(double8 x, double8 y, double8 z); \
double16 __OVERLOAD__ name(double16 x, double16 y, double16 z);
#else
#define __CLFN_FD_3FD(name) float __OVERLOAD__ name(float x, float y, float z); \
float2 __OVERLOAD__ name(float2 x, float2 y, float2 z); \
float3 __OVERLOAD__ name(float3 x, float3 y, float3 z); \
float4 __OVERLOAD__ name(float4 x, float4 y, float4 z); \
float8 __OVERLOAD__ name(float8 x, float8 y, float8 z); \
float16 __OVERLOAD__ name(float16 x, float16 y, float16 z);
#endif

// Returns float or double, two float or double input (possible not vector).
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
float8 __OVERLOAD__ name(float8 x, float8 y); \
float16 __OVERLOAD__ name(float16 x, float16 y); \
double __OVERLOAD__ name(double x, double y); \
double2 __OVERLOAD__ name(double2 x, double2 y); \
double3 __OVERLOAD__ name(double3 x, double3 y); \
double4 __OVERLOAD__ name(double4 x, double4 y); \
double8 __OVERLOAD__ name(double8 x, double8 y); \
double16 __OVERLOAD__ name(double16 x, double16 y); 
#else
#define __CLFN_FD_2FD(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
float8 __OVERLOAD__ name(float8 x, float8 y); \
float16 __OVERLOAD__ name(float16 x, float16 y);
#endif

#if defined(__FAST_RELAXED_MATH__)
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD_FAST_RELAX(name, native_name, default_name) \
inline float __OVERLOAD__ name(float x, float y) { return native_name(x,y); } \
inline float2 __OVERLOAD__ name(float2 x, float2 y) { return native_name(x,y); } \
inline float3 __OVERLOAD__ name(float3 x, float3 y) { return native_name(x,y); } \
inline float4 __OVERLOAD__ name(float4 x, float4 y) { return native_name(x,y); } \
inline float8 __OVERLOAD__ name(float8 x, float8 y) { return native_name(x,y); } \
inline float16 __OVERLOAD__ name(float16 x, float16 y){ return native_name(x,y); } \
inline double __OVERLOAD__ name(double x, double y) { return default_name(x,y); } \
inline double2 __OVERLOAD__ name(double2 x, double2 y) { return default_name(x,y); } \
inline double3 __OVERLOAD__ name(double3 x, double3 y) { return default_name(x,y); } \
inline double4 __OVERLOAD__ name(double4 x, double4 y) { return default_name(x,y); } \
inline double8 __OVERLOAD__ name(double8 x, double8 y) { return default_name(x,y); } \
inline double16 __OVERLOAD__ name(double16 x, double16 y) { return default_name(x,y); }
#else
#define __CLFN_FD_2FD_FAST_RELAX(name, native_name, default_name) \
inline float __OVERLOAD__ name(float x, float y) { return native_name(x,y); } \
inline float2 __OVERLOAD__ name(float2 x, float2 y) { return native_name(x,y); } \
inline float3 __OVERLOAD__ name(float3 x, float3 y) { return native_name(x,y); } \
inline float4 __OVERLOAD__ name(float4 x, float4 y) { return native_name(x,y); } \
inline float8 __OVERLOAD__ name(float8 x, float8 y) { return native_name(x,y); } \
inline float16 __OVERLOAD__ name(float16 x, float16 y){ return native_name(x,y); }
#endif
#else //! __FAST_RELAXED_MATH__
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD_FAST_RELAX(name, native_name, default_name) \
inline float __OVERLOAD__ name(float x, float y) { return default_name(x,y); } \
inline float2 __OVERLOAD__ name(float2 x, float2 y) { return default_name(x,y); } \
inline float3 __OVERLOAD__ name(float3 x, float3 y) { return default_name(x,y); } \
inline float4 __OVERLOAD__ name(float4 x, float4 y) { return default_name(x,y); } \
inline float8 __OVERLOAD__ name(float8 x, float8 y) { return default_name(x,y); } \
inline float16 __OVERLOAD__ name(float16 x, float16 y){ return default_name(x,y); } \
inline double __OVERLOAD__ name(double x, double y) { return default_name(x,y); } \
inline double2 __OVERLOAD__ name(double2 x, double2 y) { return default_name(x,y); } \
inline double3 __OVERLOAD__ name(double3 x, double3 y) { return default_name(x,y); } \
inline double4 __OVERLOAD__ name(double4 x, double4 y) { return default_name(x,y); } \
inline double8 __OVERLOAD__ name(double8 x, double8 y) { return default_name(x,y); } \
inline double16 __OVERLOAD__ name(double16 x, double16 y) { return default_name(x,y); }
#else
#define __CLFN_FD_2FD_FAST_RELAX(name, native_name, default_name) \
inline float __OVERLOAD__ name(float x, float y) { return default_name(x,y); } \
inline float2 __OVERLOAD__ name(float2 x, float2 y) { return default_name(x,y); } \
inline float3 __OVERLOAD__ name(float3 x, float3 y) { return default_name(x,y); } \
inline float4 __OVERLOAD__ name(float4 x, float4 y) { return default_name(x,y); } \
inline float8 __OVERLOAD__ name(float8 x, float8 y) { return default_name(x,y); } \
inline float16 __OVERLOAD__ name(float16 x, float16 y){ return default_name(x,y); }
#endif
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_FD_2FD_EXT(name) float2 __OVERLOAD__ name(float2 x, float y); \
float3 __OVERLOAD__ name(float3 x, float y); \
float4 __OVERLOAD__ name(float4 x, float y); \
float8 __OVERLOAD__ name(float8 x, float y); \
float16 __OVERLOAD__ name(float16 x, float y); \
double2 __OVERLOAD__ name(double2 x, double y); \
double3 __OVERLOAD__ name(double3 x, double y); \
double4 __OVERLOAD__ name(double4 x, double y); \
double8 __OVERLOAD__ name(double8 x, double y); \
double16 __OVERLOAD__ name(double16 x, double y);
#else
#define __CLFN_FD_2FD_EXT(name) float2 __OVERLOAD__ name(float2 x, float y); \
float3 __OVERLOAD__ name(float3 x, float y); \
float4 __OVERLOAD__ name(float4 x, float y); \
float8 __OVERLOAD__ name(float8 x, float y); \
float16 __OVERLOAD__ name(float16 x, float y);
#endif

// Returns int or long, two float or double input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_IL_2FD(name) int __OVERLOAD__ name(float x, float y); \
int2 __OVERLOAD__ name(float2 x, float2 y); \
int3 __OVERLOAD__ name(float3 x, float3 y); \
int4 __OVERLOAD__ name(float4 x, float4 y); \
int8 __OVERLOAD__ name(float8 x, float8 y); \
int16 __OVERLOAD__ name(float16 x, float16 y); \
int __OVERLOAD__ name(double x, double y); \
long2 __OVERLOAD__ name(double2 x, double2 y); \
long3 __OVERLOAD__ name(double3 x, double3 y); \
long4 __OVERLOAD__ name(double4 x, double4 y); \
long8 __OVERLOAD__ name(double8 x, double8 y); \
long16 __OVERLOAD__ name(double16 x, double16 y); 
#else
#define __CLFN_IL_2FD(name) int __OVERLOAD__ name(float x, float y); \
int2 __OVERLOAD__ name(float2 x, float2 y); \
int3 __OVERLOAD__ name(float3 x, float3 y); \
int4 __OVERLOAD__ name(float4 x, float4 y); \
int8 __OVERLOAD__ name(float8 x, float8 y); \
int16 __OVERLOAD__ name(float16 x, float16 y);
#endif

// These macros are for the operations that support SPI types

// Returns float and takes one float.
#define __CLFN_F_1F(name) float __OVERLOAD__ name(float x); \
float2 __OVERLOAD__ name(float2 x); \
float3 __OVERLOAD__ name(float3 x); \
float4 __OVERLOAD__ name(float4 x); \
float8 __OVERLOAD__ name(float8 x); \
float16 __OVERLOAD__ name(float16 x); 

// Returns float or double, two float or double input.
#define __CLFN_F_2F(name) float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float2 y); \
float3 __OVERLOAD__ name(float3 x, float3 y); \
float4 __OVERLOAD__ name(float4 x, float4 y); \
float8 __OVERLOAD__ name(float8 x, float8 y); \
float16 __OVERLOAD__ name(float16 x, float16 y);

// Returns uchar,uint, ushort, or ulong, 
// and takes two char, uchar, short, ushort, int, uint, long, ulong inputs.
#define __CLFN_UCSIL_2CSIL(name) uchar __OVERLOAD__ name(char x, char y); \
uchar2 __OVERLOAD__ name(char2 x, char2 y); \
uchar3 __OVERLOAD__ name(char3 x, char3 y); \
uchar4 __OVERLOAD__ name(char4 x, char4 y); \
uchar8 __OVERLOAD__ name(char8 x, char8 y); \
uchar16 __OVERLOAD__ name(char16 x, char16 y); \
uchar __OVERLOAD__ name(uchar x, uchar y); \
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
ushort __OVERLOAD__ name(short x, short y); \
ushort2 __OVERLOAD__ name(short2 x, short2 y); \
ushort3 __OVERLOAD__ name(short3 x, short3 y); \
ushort4 __OVERLOAD__ name(short4 x, short4 y); \
ushort8 __OVERLOAD__ name(short8 x, short8 y); \
ushort16 __OVERLOAD__ name(short16 x, short16 y); \
ushort __OVERLOAD__ name(ushort x, ushort y); \
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
uint __OVERLOAD__ name(int x, int y); \
uint2 __OVERLOAD__ name(int2 x, int2 y); \
uint3 __OVERLOAD__ name(int3 x, int3 y); \
uint4 __OVERLOAD__ name(int4 x, int4 y); \
uint8 __OVERLOAD__ name(int8 x, int8 y); \
uint16 __OVERLOAD__ name(int16 x, int16 y); \
uint __OVERLOAD__ name(uint x, uint y); \
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
ulong __OVERLOAD__ name(long x, long y); \
ulong2 __OVERLOAD__ name(long2 x, long2 y); \
ulong3 __OVERLOAD__ name(long3 x, long3 y); \
ulong4 __OVERLOAD__ name(long4 x, long4 y); \
ulong8 __OVERLOAD__ name(long8 x, long8 y); \
ulong16 __OVERLOAD__ name(long16 x, long16 y); \
ulong __OVERLOAD__ name(ulong x, ulong y); \
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 

// Returns char, int, short, or long, or the unsigned variety 
// and takes two char, uchar, short, ushort, int, uint, long, ulong inputs.
#define __CLFN_ALL(name) char __OVERLOAD__ name(char x, char y); \
char2 __OVERLOAD__ name(char2 x, char2 y); \
char3 __OVERLOAD__ name(char3 x, char3 y); \
char4 __OVERLOAD__ name(char4 x, char4 y); \
char8 __OVERLOAD__ name(char8 x, char8 y); \
char16 __OVERLOAD__ name(char16 x, char16 y); \
uchar __OVERLOAD__ name(uchar x, uchar y); \
uchar2 __OVERLOAD__ name(uchar2 x, uchar2 y); \
uchar3 __OVERLOAD__ name(uchar3 x, uchar3 y); \
uchar4 __OVERLOAD__ name(uchar4 x, uchar4 y); \
uchar8 __OVERLOAD__ name(uchar8 x, uchar8 y); \
uchar16 __OVERLOAD__ name(uchar16 x,uchar16 y); \
short __OVERLOAD__ name(short x, short y); \
short2 __OVERLOAD__ name(short2 x, short2 y); \
short3 __OVERLOAD__ name(short3 x, short3 y); \
short4 __OVERLOAD__ name(short4 x, short4 y); \
short8 __OVERLOAD__ name(short8 x, short8 y); \
short16 __OVERLOAD__ name(short16 x, short16 y); \
ushort __OVERLOAD__ name(ushort x, ushort y); \
ushort2 __OVERLOAD__ name(ushort2 x, ushort2 y); \
ushort3 __OVERLOAD__ name(ushort3 x, ushort3 y); \
ushort4 __OVERLOAD__ name(ushort4 x, ushort4 y); \
ushort8 __OVERLOAD__ name(ushort8 x, ushort8 y); \
ushort16 __OVERLOAD__ name(ushort16 x, ushort16 y); \
int __OVERLOAD__ name(int x, int y); \
int2 __OVERLOAD__ name(int2 x, int2 y); \
int3 __OVERLOAD__ name(int3 x, int3 y); \
int4 __OVERLOAD__ name(int4 x, int4 y); \
int8 __OVERLOAD__ name(int8 x, int8 y); \
int16 __OVERLOAD__ name(int16 x, int16 y); \
uint __OVERLOAD__ name(uint x, uint y); \
uint2 __OVERLOAD__ name(uint2 x, uint2 y); \
uint3 __OVERLOAD__ name(uint3 x, uint3 y); \
uint4 __OVERLOAD__ name(uint4 x, uint4 y); \
uint8 __OVERLOAD__ name(uint8 x, uint8 y); \
uint16 __OVERLOAD__ name(uint16 x, uint16 y); \
long __OVERLOAD__ name(long x, long y); \
long2 __OVERLOAD__ name(long2 x, long2 y); \
long3 __OVERLOAD__ name(long3 x, long3 y); \
long4 __OVERLOAD__ name(long4 x, long4 y); \
long8 __OVERLOAD__ name(long8 x, long8 y); \
long16 __OVERLOAD__ name(long16 x, long16 y); \
ulong __OVERLOAD__ name(ulong x, ulong y); \
ulong2 __OVERLOAD__ name(ulong2 x, ulong2 y); \
ulong3 __OVERLOAD__ name(ulong3 x, ulong3 y); \
ulong4 __OVERLOAD__ name(ulong4 x, ulong4 y); \
ulong8 __OVERLOAD__ name(ulong8 x, ulong8 y); \
ulong16 __OVERLOAD__ name(ulong16 x, ulong16 y); 

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
char2 __OVERLOAD__ name(char2 x, char y); \
char3 __OVERLOAD__ name(char3 x, char y); \
char4 __OVERLOAD__ name(char4 x, char y); \
char8 __OVERLOAD__ name(char8 x, char y); \
char16 __OVERLOAD__ name(char16 x, char y); \
uchar __OVERLOAD__ name(uchar x, uchar y); \
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
short __OVERLOAD__ name(short x, short y); \
short2 __OVERLOAD__ name(short2 x, short y); \
short3 __OVERLOAD__ name(short3 x, short y); \
short4 __OVERLOAD__ name(short4 x, short y); \
short8 __OVERLOAD__ name(short8 x, short y); \
short16 __OVERLOAD__ name(short16 x, short y); \
ushort __OVERLOAD__ name(ushort x, ushort y); \
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
int __OVERLOAD__ name(int x, int y); \
int2 __OVERLOAD__ name(int2 x, int y); \
int3 __OVERLOAD__ name(int3 x, int y); \
int4 __OVERLOAD__ name(int4 x, int y); \
int8 __OVERLOAD__ name(int8 x, int y); \
int16 __OVERLOAD__ name(int16 x, int y); \
uint __OVERLOAD__ name(uint x, uint y); \
uint2 __OVERLOAD__ name(uint2 x, uint y); \
uint3 __OVERLOAD__ name(uint3 x, uint y); \
uint4 __OVERLOAD__ name(uint4 x, uint y); \
uint8 __OVERLOAD__ name(uint8 x, uint y); \
uint16 __OVERLOAD__ name(uint16 x, uint y); \
long __OVERLOAD__ name(long x, long y); \
long2 __OVERLOAD__ name(long2 x, long y); \
long3 __OVERLOAD__ name(long3 x, long y); \
long4 __OVERLOAD__ name(long4 x, long y); \
long8 __OVERLOAD__ name(long8 x, long y); \
long16 __OVERLOAD__ name(long16 x, long y); \
ulong __OVERLOAD__ name(ulong x, ulong y); \
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float y); \
float3 __OVERLOAD__ name(float3 x, float y); \
float4 __OVERLOAD__ name(float4 x, float y); \
float8 __OVERLOAD__ name(float8 x, float y); \
float16 __OVERLOAD__ name(float16 x, float y); \
double __OVERLOAD__ name(double x, double y); \
double2 __OVERLOAD__ name(double2 x, double y); \
double3 __OVERLOAD__ name(double3 x, double y); \
double4 __OVERLOAD__ name(double4 x, double y); \
double8 __OVERLOAD__ name(double8 x, double y); \
double16 __OVERLOAD__ name(double16 x, double y);
#else
#define __CLFN_ALL_MODD(name) char __OVERLOAD__ name(char x, char y); \
char2 __OVERLOAD__ name(char2 x, char y); \
char3 __OVERLOAD__ name(char3 x, char y); \
char4 __OVERLOAD__ name(char4 x, char y); \
char8 __OVERLOAD__ name(char8 x, char y); \
char16 __OVERLOAD__ name(char16 x, char y); \
uchar __OVERLOAD__ name(uchar x, uchar y); \
uchar2 __OVERLOAD__ name(uchar2 x, uchar y); \
uchar3 __OVERLOAD__ name(uchar3 x, uchar y); \
uchar4 __OVERLOAD__ name(uchar4 x, uchar y); \
uchar8 __OVERLOAD__ name(uchar8 x, uchar y); \
uchar16 __OVERLOAD__ name(uchar16 x,uchar y); \
short __OVERLOAD__ name(short x, short y); \
short2 __OVERLOAD__ name(short2 x, short y); \
short3 __OVERLOAD__ name(short3 x, short y); \
short4 __OVERLOAD__ name(short4 x, short y); \
short8 __OVERLOAD__ name(short8 x, short y); \
short16 __OVERLOAD__ name(short16 x, short y); \
ushort __OVERLOAD__ name(ushort x, ushort y); \
ushort2 __OVERLOAD__ name(ushort2 x, ushort y); \
ushort3 __OVERLOAD__ name(ushort3 x, ushort y); \
ushort4 __OVERLOAD__ name(ushort4 x, ushort y); \
ushort8 __OVERLOAD__ name(ushort8 x, ushort y); \
ushort16 __OVERLOAD__ name(ushort16 x, ushort y); \
int __OVERLOAD__ name(int x, int y); \
int2 __OVERLOAD__ name(int2 x, int y); \
int3 __OVERLOAD__ name(int3 x, int y); \
int4 __OVERLOAD__ name(int4 x, int y); \
int8 __OVERLOAD__ name(int8 x, int y); \
int16 __OVERLOAD__ name(int16 x, int y); \
uint __OVERLOAD__ name(uint x, uint y); \
uint2 __OVERLOAD__ name(uint2 x, uint y); \
uint3 __OVERLOAD__ name(uint3 x, uint y); \
uint4 __OVERLOAD__ name(uint4 x, uint y); \
uint8 __OVERLOAD__ name(uint8 x, uint y); \
uint16 __OVERLOAD__ name(uint16 x, uint y); \
long __OVERLOAD__ name(long x, long y); \
long2 __OVERLOAD__ name(long2 x, long y); \
long3 __OVERLOAD__ name(long3 x, long y); \
long4 __OVERLOAD__ name(long4 x, long y); \
long8 __OVERLOAD__ name(long8 x, long y); \
long16 __OVERLOAD__ name(long16 x, long y); \
ulong __OVERLOAD__ name(ulong x, ulong y); \
ulong2 __OVERLOAD__ name(ulong2 x, ulong y); \
ulong3 __OVERLOAD__ name(ulong3 x, ulong y); \
ulong4 __OVERLOAD__ name(ulong4 x, ulong y); \
ulong8 __OVERLOAD__ name(ulong8 x, ulong y); \
ulong16 __OVERLOAD__ name(ulong16 x, ulong y); \
float __OVERLOAD__ name(float x, float y); \
float2 __OVERLOAD__ name(float2 x, float y); \
float3 __OVERLOAD__ name(float3 x, float y); \
float4 __OVERLOAD__ name(float4 x, float y); \
float8 __OVERLOAD__ name(float8 x, float y); \
float16 __OVERLOAD__ name(float16 x, float y);
#endif

#define __CLFN_I3(name) char __OVERLOAD__ name(char x, char y, char z); \
short __OVERLOAD__ name( short x, short y, short z ); \
int __OVERLOAD__ name( int x, int y, int z ); \
long __OVERLOAD__ name( long x, long y, long z ); \
uchar __OVERLOAD__ name( uchar x, uchar y, uchar z ); \
ushort __OVERLOAD__ name( ushort x, ushort y, ushort z ); \
uint __OVERLOAD__ name( uint x, uint y, uint z ); \
ulong __OVERLOAD__ name( ulong x, ulong y, ulong z ); \
char2 __OVERLOAD__ name( char2 x, char2 y, char2 z ); \
short2 __OVERLOAD__ name( short2 x, short2 y, short2 z ); \
int2 __OVERLOAD__ name( int2 x, int2 y, int2 z ); \
long2 __OVERLOAD__ name( long2 x, long2 y, long2 z ); \
uchar2 __OVERLOAD__ name( uchar2 x, uchar2 y, uchar2 z ); \
ushort2 __OVERLOAD__ name( ushort2 x, ushort2 y, ushort2 z ); \
uint2 __OVERLOAD__ name( uint2 x, uint2 y, uint2 z ); \
ulong2 __OVERLOAD__ name( ulong2 x, ulong2 y, ulong2 z ); \
char3 __OVERLOAD__ name( char3 x, char3 y, char3 z ); \
short3 __OVERLOAD__ name( short3 x, short3 y, short3 z ); \
int3 __OVERLOAD__ name( int3 x, int3 y, int3 z ); \
long3 __OVERLOAD__ name( long3 x, long3 y, long3 z ); \
uchar3 __OVERLOAD__ name( uchar3 x, uchar3 y, uchar3 z ); \
ushort3 __OVERLOAD__ name( ushort3 x, ushort3 y, ushort3 z ); \
uint3 __OVERLOAD__ name( uint3 x, uint3 y, uint3 z ); \
ulong3 __OVERLOAD__ name( ulong3 x, ulong3 y, ulong3 z ); \
char4 __OVERLOAD__ name( char4 x, char4 y, char4 z ); \
short4 __OVERLOAD__ name( short4 x, short4 y, short4 z ); \
int4 __OVERLOAD__ name( int4 x, int4 y, int4 z ); \
long4 __OVERLOAD__ name( long4 x, long4 y, long4 z ); \
uchar4 __OVERLOAD__ name( uchar4 x, uchar4 y, uchar4 z ); \
ushort4 __OVERLOAD__ name( ushort4 x, ushort4 y, ushort4 z ); \
uint4 __OVERLOAD__ name( uint4 x, uint4 y, uint4 z ); \
ulong4 __OVERLOAD__ name( ulong4 x, ulong4 y, ulong4 z ); \
char8 __OVERLOAD__ name( char8 x, char8 y, char8 z ); \
short8 __OVERLOAD__ name( short8 x, short8 y, short8 z ); \
int8 __OVERLOAD__ name( int8 x, int8 y, int8 z ); \
long8 __OVERLOAD__ name( long8 x, long8 y, long8 z ); \
uchar8 __OVERLOAD__ name( uchar8 x, uchar8 y, uchar8 z ); \
ushort8 __OVERLOAD__ name( ushort8 x, ushort8 y, ushort8 z ); \
uint8 __OVERLOAD__ name( uint8 x, uint8 y, uint8 z ); \
ulong8 __OVERLOAD__ name( ulong8 x, ulong8 y, ulong8 z ); \
char16 __OVERLOAD__ name( char16 x, char16 y, char16 z ); \
short16 __OVERLOAD__ name( short16 x, short16 y, short16 z ); \
int16 __OVERLOAD__ name( int16 x, int16 y, int16 z ); \
long16 __OVERLOAD__ name( long16 x, long16 y, long16 z ); \
uchar16 __OVERLOAD__ name( uchar16 x, uchar16 y, uchar16 z ); \
ushort16 __OVERLOAD__ name( ushort16 x, ushort16 y, ushort16 z ); \
uint16 __OVERLOAD__ name( uint16 x, uint16 y, uint16 z ); \
ulong16 __OVERLOAD__ name( ulong16 x, ulong16 y, ulong16 z ); 

#define __CLFN_I_3CSIL(name) int __OVERLOAD__ name(short2 a, short2 b, int c); \
int __OVERLOAD__ name(short2 a, ushort2 b, int c); \
uint __OVERLOAD__ name(ushort2 a, ushort2 b, uint c); \
int2 __OVERLOAD__ name(short4 a, short4 b, int2 c); \
int2 __OVERLOAD__ name(short4 a, ushort4 b, int2 c); \
uint2 __OVERLOAD__ name(ushort4 a, ushort4 b, uint2 c); \
int4 __OVERLOAD__ name(short8 a, short8 b, int4 c); \
int4 __OVERLOAD__ name(short8 a, ushort8 b, int4 c); \
uint4 __OVERLOAD__ name(ushort8 a, ushort8 b, uint4 c); \
int8 __OVERLOAD__ name(short16 a, short16 b, int8 c); \
int8 __OVERLOAD__ name(short16 a, ushort16 b, int8 c); \
uint8 __OVERLOAD__ name(ushort16 a, ushort16 b, uint8 c);

// Returns int or unsigned and takes 3 ints or 3 unsigned ints
#define __CLFN_I_3I(name) int __OVERLOAD__ name(int a, int b, int c); \
int2 __OVERLOAD__ name(int2 a, int2 b, int2 c); \
int3 __OVERLOAD__ name(int3 a, int3 b, int3 c); \
int4 __OVERLOAD__ name(int4 a, int4 b, int4 c); \
int8 __OVERLOAD__ name(int8 a, int8 b, int8 c); \
int16 __OVERLOAD__ name(int16 a, int16 b, int16 c); \
uint __OVERLOAD__ name(uint a, uint b, uint c); \
uint2 __OVERLOAD__ name(uint2 a, uint2 b, uint2 c); \
uint3 __OVERLOAD__ name(uint3 a, uint3 b, uint3 c); \
uint4 __OVERLOAD__ name(uint4 a, uint4 b, uint4 c); \
uint8 __OVERLOAD__ name(uint8 a, uint8 b, uint8 c); \
uint16 __OVERLOAD__ name(uint16 a, uint16 b, uint16 c);

#define __CLFN_I_2I(name) int __OVERLOAD__ name(int a, int b); \
int2 __OVERLOAD__ name(int2 a, int2 b); \
int3 __OVERLOAD__ name(int3 a, int3 b); \
int4 __OVERLOAD__ name(int4 a, int4 b); \
int8 __OVERLOAD__ name(int8 a, int8 b); \
int16 __OVERLOAD__ name(int16 a, int16 b); \
uint __OVERLOAD__ name(uint a, uint b); \
uint2 __OVERLOAD__ name(uint2 a, uint2 b); \
uint3 __OVERLOAD__ name(uint3 a, uint3 b); \
uint4 __OVERLOAD__ name(uint4 a, uint4 b); \
uint8 __OVERLOAD__ name(uint8 a, uint8 b); \
uint16 __OVERLOAD__ name(uint16 a, uint16 b);


// Returns an int, takes all types of input
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_I_ALL(name) int __OVERLOAD__ name(uchar x); \
int __OVERLOAD__ name(uchar2 x); \
int __OVERLOAD__ name(uchar3 x); \
int __OVERLOAD__ name(uchar4 x); \
int __OVERLOAD__ name(uchar8 x); \
int __OVERLOAD__ name(uchar16 x); \
int __OVERLOAD__ name(char x); \
int __OVERLOAD__ name(char2 x); \
int __OVERLOAD__ name(char3 x); \
int __OVERLOAD__ name(char4 x); \
int __OVERLOAD__ name(char8 x); \
int __OVERLOAD__ name(char16 x); \
int __OVERLOAD__ name(ushort x); \
int __OVERLOAD__ name(ushort2 x); \
int __OVERLOAD__ name(ushort3 x); \
int __OVERLOAD__ name(ushort4 x); \
int __OVERLOAD__ name(ushort8 x); \
int __OVERLOAD__ name(ushort16 x); \
int __OVERLOAD__ name(short x); \
int __OVERLOAD__ name(short2 x); \
int __OVERLOAD__ name(short3 x); \
int __OVERLOAD__ name(short4 x); \
int __OVERLOAD__ name(short8 x); \
int __OVERLOAD__ name(short16 x); \
int __OVERLOAD__ name(int x); \
int __OVERLOAD__ name(int2 x); \
int __OVERLOAD__ name(int3 x); \
int __OVERLOAD__ name(int4 x); \
int __OVERLOAD__ name(int8 x); \
int __OVERLOAD__ name(int16 x); \
int __OVERLOAD__ name(uint x); \
int __OVERLOAD__ name(uint2 x); \
int __OVERLOAD__ name(uint3 x); \
int __OVERLOAD__ name(uint4 x); \
int __OVERLOAD__ name(uint8 x); \
int __OVERLOAD__ name(uint16 x); \
int __OVERLOAD__ name(long x); \
int __OVERLOAD__ name(long2 x); \
int __OVERLOAD__ name(long3 x); \
int __OVERLOAD__ name(long4 x); \
int __OVERLOAD__ name(long8 x); \
int __OVERLOAD__ name(long16 x); \
int __OVERLOAD__ name(ulong x); \
int __OVERLOAD__ name(ulong2 x); \
int __OVERLOAD__ name(ulong3 x); \
int __OVERLOAD__ name(ulong4 x); \
int __OVERLOAD__ name(ulong8 x); \
int __OVERLOAD__ name(ulong16 x); \
int __OVERLOAD__ name(float x); \
int __OVERLOAD__ name(float2 x); \
int __OVERLOAD__ name(float3 x); \
int __OVERLOAD__ name(float4 x); \
int __OVERLOAD__ name(float8 x); \
int __OVERLOAD__ name(float16 x); \
int __OVERLOAD__ name(double x); \
int __OVERLOAD__ name(double2 x); \
int __OVERLOAD__ name(double3 x); \
int __OVERLOAD__ name(double4 x); \
int __OVERLOAD__ name(double8 x); \
int __OVERLOAD__ name(double16 x);
#else
#define __CLFN_I_ALL(name) int __OVERLOAD__ name(uchar x); \
int __OVERLOAD__ name(uchar2 x); \
int __OVERLOAD__ name(uchar3 x); \
int __OVERLOAD__ name(uchar4 x); \
int __OVERLOAD__ name(uchar8 x); \
int __OVERLOAD__ name(uchar16 x); \
int __OVERLOAD__ name(char x); \
int __OVERLOAD__ name(char2 x); \
int __OVERLOAD__ name(char3 x); \
int __OVERLOAD__ name(char4 x); \
int __OVERLOAD__ name(char8 x); \
int __OVERLOAD__ name(char16 x); \
int __OVERLOAD__ name(ushort x); \
int __OVERLOAD__ name(ushort2 x); \
int __OVERLOAD__ name(ushort3 x); \
int __OVERLOAD__ name(ushort4 x); \
int __OVERLOAD__ name(ushort8 x); \
int __OVERLOAD__ name(ushort16 x); \
int __OVERLOAD__ name(short x); \
int __OVERLOAD__ name(short2 x); \
int __OVERLOAD__ name(short3 x); \
int __OVERLOAD__ name(short4 x); \
int __OVERLOAD__ name(short8 x); \
int __OVERLOAD__ name(short16 x); \
int __OVERLOAD__ name(int x); \
int __OVERLOAD__ name(int2 x); \
int __OVERLOAD__ name(int3 x); \
int __OVERLOAD__ name(int4 x); \
int __OVERLOAD__ name(int8 x); \
int __OVERLOAD__ name(int16 x); \
int __OVERLOAD__ name(uint x); \
int __OVERLOAD__ name(uint2 x); \
int __OVERLOAD__ name(uint3 x); \
int __OVERLOAD__ name(uint4 x); \
int __OVERLOAD__ name(uint8 x); \
int __OVERLOAD__ name(uint16 x); \
int __OVERLOAD__ name(long x); \
int __OVERLOAD__ name(long2 x); \
int __OVERLOAD__ name(long3 x); \
int __OVERLOAD__ name(long4 x); \
int __OVERLOAD__ name(long8 x); \
int __OVERLOAD__ name(long16 x); \
int __OVERLOAD__ name(ulong x); \
int __OVERLOAD__ name(ulong2 x); \
int __OVERLOAD__ name(ulong3 x); \
int __OVERLOAD__ name(ulong4 x); \
int __OVERLOAD__ name(ulong8 x); \
int __OVERLOAD__ name(ulong16 x); \
int __OVERLOAD__ name(float x); \
int __OVERLOAD__ name(float2 x); \
int __OVERLOAD__ name(float3 x); \
int __OVERLOAD__ name(float4 x); \
int __OVERLOAD__ name(float8 x); \
int __OVERLOAD__ name(float16 x);
#endif

// Returns an event, takes 2 inputs of all types with either a 
// local or global qualifier, and then a size_t and event_t input.
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_EVENT_ALL(name) event_t __OVERLOAD__ name(__global char *dest, const __local char *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar *dest, const __local uchar *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char *dest, const __global char *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar *dest, const __global uchar *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double *dest, const __local double *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double *dest, const __global double *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, event_t evt); 
#else
#define __CLFN_EVENT_ALL(name) event_t __OVERLOAD__ name(__global char *dest, const __local char *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar *dest, const __local uchar *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char *dest, const __global char *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar *dest, const __global uchar *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, event_t evt); 
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_EVENT_ALL4(name) event_t __OVERLOAD__ name(__global char *dest, const __local char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar *dest, const __local uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char *dest, const __global char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar *dest, const __global uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double *dest, const __local double *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double *dest, const __global double *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, size_t stride, event_t evt);
#else
#define __CLFN_EVENT_ALL4(name) event_t __OVERLOAD__ name(__global char *dest, const __local char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar *dest, const __local uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char *dest, const __global char *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar *dest, const __global uchar *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short *dest, const __local short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort *dest, const __local ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short *dest, const __global short *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort *dest, const __global ushort *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int *dest, const __local int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint *dest, const __local uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int *dest, const __global int *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint *dest, const __global uint *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long *dest, const __local long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong *dest, const __local ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long *dest, const __global long *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong *dest, const __global ulong *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float *dest, const __local float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float *dest, const __global float *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char2 *dest, const __local char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar2 *dest, const __local uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char2 *dest, const __global char2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar2 *dest, const __global uchar2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short2 *dest, const __local short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort2 *dest, const __local ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short2 *dest, const __global short2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort2 *dest, const __global ushort2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int2 *dest, const __local int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint2 *dest, const __local uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int2 *dest, const __global int2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint2 *dest, const __global uint2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long2 *dest, const __local long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong2 *dest, const __local ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long2 *dest, const __global long2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong2 *dest, const __global ulong2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float2 *dest, const __local float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double2 *dest, const __local double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float2 *dest, const __global float2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double2 *dest, const __global double2 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char4 *dest, const __local char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar4 *dest, const __local uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char4 *dest, const __global char4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar4 *dest, const __global uchar4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short4 *dest, const __local short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort4 *dest, const __local ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short4 *dest, const __global short4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort4 *dest, const __global ushort4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int4 *dest, const __local int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint4 *dest, const __local uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int4 *dest, const __global int4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint4 *dest, const __global uint4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long4 *dest, const __local long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong4 *dest, const __local ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long4 *dest, const __global long4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong4 *dest, const __global ulong4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float4 *dest, const __local float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double4 *dest, const __local double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float4 *dest, const __global float4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double4 *dest, const __global double4 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char8 *dest, const __local char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar8 *dest, const __local uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char8 *dest, const __global char8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar8 *dest, const __global uchar8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short8 *dest, const __local short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort8 *dest, const __local ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short8 *dest, const __global short8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort8 *dest, const __global ushort8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int8 *dest, const __local int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint8 *dest, const __local uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int8 *dest, const __global int8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint8 *dest, const __global uint8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long8 *dest, const __local long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong8 *dest, const __local ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long8 *dest, const __global long8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong8 *dest, const __global ulong8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float8 *dest, const __local float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double8 *dest, const __local double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float8 *dest, const __global float8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double8 *dest, const __global double8 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global char16 *dest, const __local char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uchar16 *dest, const __local uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local char16 *dest, const __global char16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uchar16 *dest, const __global uchar16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global short16 *dest, const __local short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ushort16 *dest, const __local ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local short16 *dest, const __global short16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ushort16 *dest, const __global ushort16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global int16 *dest, const __local int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global uint16 *dest, const __local uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local int16 *dest, const __global int16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local uint16 *dest, const __global uint16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global long16 *dest, const __local long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global ulong16 *dest, const __local ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local long16 *dest, const __global long16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local ulong16 *dest, const __global ulong16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global float16 *dest, const __local float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__global double16 *dest, const __local double16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local float16 *dest, const __global float16 *src, size_t count, size_t stride, event_t evt); \
event_t __OVERLOAD__ name(__local double16 *dest, const __global double16 *src, size_t count, size_t stride, event_t evt);
#endif

#define CHAR_BIT    8
#define	SCHAR_MAX	127		/* min value for a signed char */
#define	SCHAR_MIN	(-128)		/* max value for a signed char */
#define	UCHAR_MAX	255		/* max value for an unsigned char */
#define	CHAR_MAX	SCHAR_MAX		/* max value for a char */
#define	CHAR_MIN	SCHAR_MIN		/* min value for a char */
#define	USHRT_MAX	65535		/* max value for an unsigned short */
#define	SHRT_MAX	32767		/* max value for a short */
#define	SHRT_MIN	(-32768)	/* min value for a short */
#define	UINT_MAX	0xffffffff	/* max value for an unsigned int */
#define	INT_MAX		2147483647	/* max value for an int */
#define	INT_MIN		(-2147483647-1)	/* min value for an int */
#define	ULONG_MAX	0xffffffffffffffffUL	/* max unsigned long */
#define	LONG_MAX	((long)0x7fffffffffffffffL)	/* max signed long */
#define	LONG_MIN	((long)(-0x7fffffffffffffffL-1)) /* min signed long */

#define FLT_DIG         6 
#define FLT_MANT_DIG    24 
#define FLT_MAX_10_EXP  +38 
#define FLT_MAX_EXP     +128 
#define FLT_MIN_10_EXP  -37 
#define FLT_MIN_EXP     -125 
#define FLT_RADIX       2 
#define FLT_MAX         0x1.fffffep127f 
#define FLT_MIN         0x1.0p-126f 
#define FLT_EPSILON     0x1.0p-23f 

#define FP_ILOGB0       INT_MIN
#define FP_ILOGBNAN     INT_MIN

// Section 6.9
#define __kernel_exec( _X, _type)   __kernel __attribute__ ((work_group_size_hint(_X, 1, 1)))  __attribute__((vec_type_hint(_type)))
#define kernel_exec( _X, _type)     __kernel_exec( _X, _type)
#define CL_VERSION_1_0  100
#define CL_VERSION_1_1  110
#define CL_VERSION_1_2  120

#define M_E_F         2.71828182845904523536028747135266250f   /* e */
#define M_LOG2E_F     1.44269504088896340735992468100189214f   /* log 2e */
#define M_LOG10E_F    0.434294481903251827651128918916605082f  /* log 10e */
#define M_LN2_F       0.693147180559945309417232121458176568f  /* log e2 */
#define M_LN10_F      2.3025850929940456840179914546843642f    /* log e10 */
#define M_PI_F        3.14159265358979323846264338327950288f   /* pi */
#define M_PI_2_F      1.57079632679489661923132169163975144f   /* pi/2 */
#define M_PI_4_F      0.785398163397448309615660845819875721f  /* pi/4 */
#define M_1_PI_F      0.318309886183790671537767526745028724f  /* 1/pi */
#define M_2_PI_F      0.636619772367581343075535053490057448f  /* 2/pi */
#define M_2_SQRTPI_F  1.12837916709551257389615890312154517f   /* 2/sqrt(pi) */
#define M_SQRT2_F     1.41421356237309504880168872420969808f   /* sqrt(2) */
#define M_SQRT1_2_F   0.707106781186547524400844362104849039f  /* 1/sqrt(2) */


#if (defined(cl_khr_fp64) || defined(cl_APPLE_fp64_basic_ops))

    #define DBL_DIG         15 
    #define DBL_MANT_DIG    53 
    #define DBL_MAX_10_EXP  +308 
    #define DBL_MAX_EXP     +1024 
    #define DBL_MIN_10_EXP  -307 
    #define DBL_MIN_EXP     -1021 
    #define DBL_RADIX       2 
    #define DBL_MAX         0x1.fffffffffffffp1023 
    #define DBL_MIN         0x1.0p-1022 
    #define DBL_EPSILON     0x1.0p-52

    #define HUGE_VAL        __builtin_huge_val()

    #define M_E         2.71828182845904523536028747135266250   /* e */
    #define M_LOG2E     1.44269504088896340735992468100189214   /* log 2e */
    #define M_LOG10E    0.434294481903251827651128918916605082  /* log 10e */
    #define M_LN2       0.693147180559945309417232121458176568  /* log e2 */
    #define M_LN10      2.30258509299404568401799145468436421   /* log e10 */
    #define M_PI        3.14159265358979323846264338327950288   /* pi */
    #define M_PI_2      1.57079632679489661923132169163975144   /* pi/2 */
    #define M_PI_4      0.785398163397448309615660845819875721  /* pi/4 */
    #define M_1_PI      0.318309886183790671537767526745028724  /* 1/pi */
    #define M_2_PI      0.636619772367581343075535053490057448  /* 2/pi */
    #define M_2_SQRTPI  1.12837916709551257389615890312154517   /* 2/sqrt(pi) */
    #define M_SQRT2     1.41421356237309504880168872420969808   /* sqrt(2) */
    #define M_SQRT1_2   0.707106781186547524400844362104849039  /* 1/sqrt(2) */

#endif

#define __OPENCL_TYPES_DEFINED__ 1

/* vload2 */
char2     __OVERLOAD__ vload2(size_t index, const char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const int *p);
uint2     __OVERLOAD__ vload2(size_t index, const uint *p);
long2     __OVERLOAD__ vload2(size_t index, const long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __global char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __global uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __global short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __global ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __global int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __global uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __global long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __global ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __global double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __local char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __local uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __local short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __local ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __local int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __local uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __local long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __local ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __local double *p);
#endif
char2     __OVERLOAD__ vload2(size_t index, const __constant char *p);
uchar2    __OVERLOAD__ vload2(size_t index, const __constant uchar *p);
short2    __OVERLOAD__ vload2(size_t index, const __constant short *p);
ushort2   __OVERLOAD__ vload2(size_t index, const __constant ushort *p);
int2      __OVERLOAD__ vload2(size_t index, const __constant int *p);
uint2     __OVERLOAD__ vload2(size_t index, const __constant uint *p);
long2     __OVERLOAD__ vload2(size_t index, const __constant long *p);
ulong2    __OVERLOAD__ vload2(size_t index, const __constant ulong *p);
float2    __OVERLOAD__ vload2(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2   __OVERLOAD__ vload2(size_t index, const __constant double *p);
#endif

/* vload3 */
char3     __OVERLOAD__ vload3(size_t index, const char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const int *p);
uint3     __OVERLOAD__ vload3(size_t index, const uint *p);
long3     __OVERLOAD__ vload3(size_t index, const long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __global char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __global uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __global short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __global ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __global int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __global uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __global long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __global ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __global double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __local char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __local uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __local short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __local ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __local int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __local uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __local long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __local ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __local double *p);
#endif
char3     __OVERLOAD__ vload3(size_t index, const __constant char *p);
uchar3    __OVERLOAD__ vload3(size_t index, const __constant uchar *p);
short3    __OVERLOAD__ vload3(size_t index, const __constant short *p);
ushort3   __OVERLOAD__ vload3(size_t index, const __constant ushort *p);
int3      __OVERLOAD__ vload3(size_t index, const __constant int *p);
uint3     __OVERLOAD__ vload3(size_t index, const __constant uint *p);
long3     __OVERLOAD__ vload3(size_t index, const __constant long *p);
ulong3    __OVERLOAD__ vload3(size_t index, const __constant ulong *p);
float3    __OVERLOAD__ vload3(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double3   __OVERLOAD__ vload3(size_t index, const __constant double *p);
#endif
/* vload4 */
char4     __OVERLOAD__ vload4(size_t index, const char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const int *p);
uint4     __OVERLOAD__ vload4(size_t index, const uint *p);
long4     __OVERLOAD__ vload4(size_t index, const long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __global char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __global uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __global short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __global ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __global int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __global uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __global long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __global ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __global double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __local char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __local uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __local short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __local ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __local int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __local uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __local long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __local ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __local double *p);
#endif
char4     __OVERLOAD__ vload4(size_t index, const __constant char *p);
uchar4    __OVERLOAD__ vload4(size_t index, const __constant uchar *p);
short4    __OVERLOAD__ vload4(size_t index, const __constant short *p);
ushort4   __OVERLOAD__ vload4(size_t index, const __constant ushort *p);
int4      __OVERLOAD__ vload4(size_t index, const __constant int *p);
uint4     __OVERLOAD__ vload4(size_t index, const __constant uint *p);
long4     __OVERLOAD__ vload4(size_t index, const __constant long *p);
ulong4    __OVERLOAD__ vload4(size_t index, const __constant ulong *p);
float4    __OVERLOAD__ vload4(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double4   __OVERLOAD__ vload4(size_t index, const __constant double *p);
#endif
/* vload8 */
char8     __OVERLOAD__ vload8(size_t index, const char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const int *p);
uint8     __OVERLOAD__ vload8(size_t index, const uint *p);
long8     __OVERLOAD__ vload8(size_t index, const long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __global char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __global uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __global short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __global ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __global int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __global uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __global long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __global ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __global double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __local char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __local uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __local short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __local ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __local int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __local uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __local long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __local ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __local double *p);
#endif
char8     __OVERLOAD__ vload8(size_t index, const __constant char *p);
uchar8    __OVERLOAD__ vload8(size_t index, const __constant uchar *p);
short8    __OVERLOAD__ vload8(size_t index, const __constant short *p);
ushort8   __OVERLOAD__ vload8(size_t index, const __constant ushort *p);
int8      __OVERLOAD__ vload8(size_t index, const __constant int *p);
uint8     __OVERLOAD__ vload8(size_t index, const __constant uint *p);
long8     __OVERLOAD__ vload8(size_t index, const __constant long *p);
ulong8    __OVERLOAD__ vload8(size_t index, const __constant ulong *p);
float8    __OVERLOAD__ vload8(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double8   __OVERLOAD__ vload8(size_t index, const __constant double *p);
#endif
/* vload16 */
char16    __OVERLOAD__ vload16(size_t index, const char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const int *p);
uint16    __OVERLOAD__ vload16(size_t index, const uint *p);
long16    __OVERLOAD__ vload16(size_t index, const long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __global char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __global uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __global short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __global ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __global int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __global uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __global long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __global ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __global float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __global double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __local char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __local uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __local short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __local ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __local int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __local uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __local long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __local ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __local float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __local double *p);
#endif
char16    __OVERLOAD__ vload16(size_t index, const __constant char *p);
uchar16   __OVERLOAD__ vload16(size_t index, const __constant uchar *p);
short16   __OVERLOAD__ vload16(size_t index, const __constant short *p);
ushort16  __OVERLOAD__ vload16(size_t index, const __constant ushort *p);
int16     __OVERLOAD__ vload16(size_t index, const __constant int *p);
uint16    __OVERLOAD__ vload16(size_t index, const __constant uint *p);
long16    __OVERLOAD__ vload16(size_t index, const __constant long *p);
ulong16   __OVERLOAD__ vload16(size_t index, const __constant ulong *p);
float16   __OVERLOAD__ vload16(size_t index, const __constant float *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double16  __OVERLOAD__ vload16(size_t index, const __constant double *p);
#endif
/* vload_half */
float   __OVERLOAD__ vload_half(size_t index, const half *p);
float   __OVERLOAD__ vload_half(size_t index, const __global half *p);
float   __OVERLOAD__ vload_half(size_t index, const __local half *p);
float   __OVERLOAD__ vload_half(size_t index, const __constant half *p);

/* vload_ahalf */
float __OVERLOAD__ vloada_half(size_t index, const half *p);
float __OVERLOAD__ vloada_half(size_t index, const __global half *p);
float __OVERLOAD__ vloada_half(size_t index, const __local half *p);
float __OVERLOAD__ vloada_half(size_t index, const __constant half *p);

/* vload_half2 */
float2  __OVERLOAD__ vload_half2(size_t index, const half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __global half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __local half *p);
float2  __OVERLOAD__ vload_half2(size_t index, const __constant half *p);

/* vloada_half2 */
float2 __OVERLOAD__ vloada_half2(size_t index, const half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __global half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __local half *p);
float2 __OVERLOAD__ vloada_half2(size_t index, const __constant half *p);

/* vload_half3 */
float3 __OVERLOAD__ vload_half3( size_t index, const half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __global half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __local half *p);
float3 __OVERLOAD__ vload_half3(size_t index, const __constant half *p);

/* vloada_half3 */
float3 __OVERLOAD__ vloada_half3(size_t index, const half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __global half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __local half *p);
float3 __OVERLOAD__ vloada_half3(size_t index, const __constant half *p);

/* vload_half4 */
float4 __OVERLOAD__ vload_half4(size_t index, const half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __global half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __local half *p);
float4 __OVERLOAD__ vload_half4(size_t index, const __constant half *p);

/* vloada_half4 */
float4 __OVERLOAD__ vloada_half4(size_t index, const half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __global half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __local half *p);
float4 __OVERLOAD__ vloada_half4(size_t index, const __constant half *p);

/* vload_half8 */
float8 __OVERLOAD__ vload_half8(size_t index, const half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __global half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __local half *p);
float8 __OVERLOAD__ vload_half8(size_t index, const __constant half *p);

/* vloada_half8 */
float8 __OVERLOAD__ vloada_half8(size_t index, const half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __global half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __local half *p);
float8 __OVERLOAD__ vloada_half8(size_t index, const __constant half *p);

/* vload_half16 */
float16 __OVERLOAD__ vload_half16(size_t index, const half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __global half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __local half *p);
float16 __OVERLOAD__ vload_half16(size_t index, const __constant half *p);

/* vloada_half16 */
float16 __OVERLOAD__ vloada_half16(size_t index, const half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __global half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __local half *p);
float16 __OVERLOAD__ vloada_half16(size_t index, const __constant half *p);

/* vstore2 */
void __OVERLOAD__ vstore2( char2 v, size_t index, char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore2( char2 v, size_t index, __global char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, __global short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, __global int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, __global long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore2( char2 v, size_t index, __local char *p );
void __OVERLOAD__ vstore2( uchar2 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore2( short2 v, size_t index, __local short *p );
void __OVERLOAD__ vstore2( ushort2 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore2( int2 v, size_t index, __local int *p );
void __OVERLOAD__ vstore2( uint2 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore2( long2 v, size_t index, __local long *p );
void __OVERLOAD__ vstore2( ulong2 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore2( float2 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore2( double2 v, size_t index, __local double *p );
#endif
/* vstore3 */
void __OVERLOAD__ vstore3( char3 v, size_t index, char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore3( char3 v, size_t index, __global char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, __global short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, __global int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, __global long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore3( char3 v, size_t index, __local char *p );
void __OVERLOAD__ vstore3( uchar3 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore3( short3 v, size_t index, __local short *p );
void __OVERLOAD__ vstore3( ushort3 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore3( int3 v, size_t index, __local int *p );
void __OVERLOAD__ vstore3( uint3 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore3( long3 v, size_t index, __local long *p );
void __OVERLOAD__ vstore3( ulong3 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore3( float3 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore3( double3 v, size_t index, __local double *p );
#endif

/* vstore4 */
void __OVERLOAD__ vstore4( char4 v, size_t index, char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore4( char4 v, size_t index, __global char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, __global short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, __global int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, __global long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore4( char4 v, size_t index, __local char *p );
void __OVERLOAD__ vstore4( uchar4 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore4( short4 v, size_t index, __local short *p );
void __OVERLOAD__ vstore4( ushort4 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore4( int4 v, size_t index, __local int *p );
void __OVERLOAD__ vstore4( uint4 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore4( long4 v, size_t index, __local long *p );
void __OVERLOAD__ vstore4( ulong4 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore4( float4 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore4( double4 v, size_t index, __local double *p );
#endif

/* vstore8 */
void __OVERLOAD__ vstore8( char8 v, size_t index, char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore8( char8 v, size_t index, __global char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, __global short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, __global int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, __global long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore8( char8 v, size_t index, __local char *p );
void __OVERLOAD__ vstore8( uchar8 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore8( short8 v, size_t index, __local short *p );
void __OVERLOAD__ vstore8( ushort8 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore8( int8 v, size_t index, __local int *p );
void __OVERLOAD__ vstore8( uint8 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore8( long8 v, size_t index, __local long *p );
void __OVERLOAD__ vstore8( ulong8 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore8( float8 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore8( double8 v, size_t index, __local double *p );
#endif

/* vstore16 */
void __OVERLOAD__ vstore16( char16 v, size_t index, char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, double *p );
#endif
void __OVERLOAD__ vstore16( char16 v, size_t index, __global char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, __global uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, __global short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, __global ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, __global int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, __global uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, __global long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, __global ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, __global float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, __global double *p );
#endif
void __OVERLOAD__ vstore16( char16 v, size_t index, __local char *p );
void __OVERLOAD__ vstore16( uchar16 v, size_t index, __local uchar *p );
void __OVERLOAD__ vstore16( short16 v, size_t index, __local short *p );
void __OVERLOAD__ vstore16( ushort16 v, size_t index, __local ushort *p );
void __OVERLOAD__ vstore16( int16 v, size_t index, __local int *p );
void __OVERLOAD__ vstore16( uint16 v, size_t index, __local uint *p );
void __OVERLOAD__ vstore16( long16 v, size_t index, __local long *p );
void __OVERLOAD__ vstore16( ulong16 v, size_t index, __local ulong *p );
void __OVERLOAD__ vstore16( float16 v, size_t index, __local float *p );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore16( double16 v, size_t index, __local double *p );
#endif
/* vstore_half */
void __OVERLOAD__ vstore_half (float  f, size_t index, half *p);
void __OVERLOAD__ vstore_half (float  f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half (float  f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half(double f, size_t index, __local half *p);
#endif
/* vstore_half2 */
void __OVERLOAD__ vstore_half2(float2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2(float2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2(float2 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2(double2 f, size_t index, __local half *p);

/* vstore_half3 */
void __OVERLOAD__ vstore_half3(float3 f, size_t index, half *p);
void __OVERLOAD__ vstore_half3(float3 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3(float3 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3(double3 f, size_t index, __local half *p);

/* vstore_half4 */
void __OVERLOAD__ vstore_half4(float4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4(float4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4(float4 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4(double4 f, size_t index, __local half *p);

/* vstore_half8 */
void __OVERLOAD__ vstore_half8(float8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8(double8 f, size_t index, __local half *p);

/* vstore_half16 */
void __OVERLOAD__ vstore_half16(float16 v, size_t index, half *p);
void __OVERLOAD__ vstore_half16(float16 v, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16(float16 v, size_t index, __local half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16(double16 f, size_t index, __local half *p);

/* vstorea_half */
void __OVERLOAD__ vstorea_half (float  f, size_t index, half *p);
void __OVERLOAD__ vstorea_half (float  f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half (float  f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half(double f, size_t index, __local half *p);
#endif
/* vstorea_half2 */
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2(float2 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half2(double2 f, size_t index, __local half *p);

/* vstorea_half3 */
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3(float3 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half3(double3 f, size_t index, __local half *p);

/* vstorea_half4 */
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4(float4 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half4(double4 f, size_t index, __local half *p);

/* vstorea_half8 */
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8(float8 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half8(double8 f, size_t index, __local half *p);

/* vstorea_half16 */
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half16(double16 f, size_t index, __local half *p);

/* vstore_half_rte */
void __OVERLOAD__ vstore_half_rte(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rte(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rte(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rte(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rte(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rte(double f, size_t index, __local half *p);
#endif
/* vstore_half2_rte */
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rte(float2 f, size_t index, __local half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rte(double2 x, size_t index, __local half *p);

/* vstore_half3_rte */
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, half *p);
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3_rte(float3 x3, size_t index, __local half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half3_rte(double3 x, size_t index, __local half *p);

/* vstore_half4_rte */
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4_rte(float4 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half4_rte(double4 x, size_t index, __local half *p);

/* vstore_half8_rte */
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8_rte(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half8_rte(double8 x, size_t index, __local half *p);

/* vstore_half16_rte */
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, half *p);
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16_rte(float16 x, size_t index, __local half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half16_rte(double16 x, size_t index, __local half *p);

/* vstorea_half_rte */
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rte(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rte(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rte( X, Y, Z )     vstore_half_rte( X, Y, Z )

/* vstorea_half2_rte */ 
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rte(float2 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rte( double2 x, size_t index, __local half *p );

/* vstorea_half3_rte */
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rte(float3 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rte( double3 x, size_t index, __local half *p );

/* vstorea_half4_rte */
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rte(float4 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, __global  half *p );
void __OVERLOAD__ vstorea_half4_rte( double4 x, size_t index, __local half *p );

/* vstorea_half8_rte */
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half8_rte(float8 x, size_t index, __local half *p);
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rte( double8 x, size_t index, __local half *p );

/* vstorea_half16_rte */
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half16_rte(float16 x, size_t index, __local half *p);
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rte( double16 x, size_t index, __local half *p );

/* vstore_half_rtz */
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, half *p);
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half_rtz(float f, size_t i, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtz(double f, size_t index, __local half *p);
#endif
/* vstore_half2_rtz */
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, half *p);
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half2_rtz(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtz(double2 x, size_t index, __local half *p);

/* vstore_half3_rtz */
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, half *p);
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half3_rtz(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtz( double3 x, size_t index, __local half *p );

/* vstore_half4_rtz */
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, half *p);
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half4_rtz(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtz( double4 x, size_t index, __local half *p );

/* vstore_half8_rtz */
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, half *p);
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half8_rtz(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtz( double8 x, size_t index, __local half *p );

/* vstore_half16_rtz */
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, half *p);
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half16_rtz(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtz( double16 x, size_t index, __local half *p );

/* vstorea_half_rtz */
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, half *p);
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half_rtz(float f, size_t i, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtz(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rtz( X, Y, Z )     vstore_half_rtz( X, Y, Z )

/* vstorea_half2_rtz */
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtz(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rtz( double2 x, size_t index, __local half *p );

/* vstorea_half3_rtz */
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtz(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rtz( double3 x, size_t index, __local half *p );

/* vstorea_half4_rtz */
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtz(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtz( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtz */
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtz(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtz( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtz */
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtz(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtz( double16 x, size_t index, __local half *p );

/* vstore_half_rtp */
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtp(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtp(double f, size_t index, __local half *p);
#endif

/* vstore_half2_rtp */
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , half *p);
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half2_rtp(float2 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtp(double2 x, size_t index, __local half *p);

/* vstore_half3_rtp */
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , half *p);
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half3_rtp(float3 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtp( double3 x, size_t index, __local half *p );

/* vstore_half4_rtp */
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , half *p);
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half4_rtp(float4 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtp( double4 x, size_t index, __local half *p );

/* vstore_half8_rtp */
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , half *p);
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half8_rtp(float8 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtp( double8 x, size_t index, __local half *p );

/* vstore_half16_rtp */
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , half *p);
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , __global half *p);
void __OVERLOAD__ vstore_half16_rtp(float16 f, size_t i , __local half *p);
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtp( double16 x, size_t index, __local half *p );

/* vstorea_half_rtp */
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtp(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtp(double f, size_t index, __local half *p);
#endif
#define vstorea_half_rtp( X, Y, Z )     vstore_half_rtp( X, Y, Z )

/* vstorea_half2_rtp */
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtp(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half2_rtp( double2 x, size_t index, __local half *p);

/* vstorea_half3_rtp */
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtp(float3 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half3_rtp( double3 x, size_t index, __local half *p);

/* vstorea_half4_rtp */
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtp(float4 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtp( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtp */
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtp(float8 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtp( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtp */
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtp(float16 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtp( double16 x, size_t index, __local half *p );

/* vstore_half_rtn */
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, half *p);
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, __global half *p);
void __OVERLOAD__ vstore_half_rtn(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, half *p );
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half_rtn( double x, size_t index, __local half *p );
#endif

/* vstore_half2_rtn */
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, half *p);
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstore_half2_rtn(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, __global half *p);
void __OVERLOAD__ vstore_half2_rtn(double2 x, size_t index, __local half *p);

/* vstore_half3_rtn */
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, half *p);
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, __global half *p);
void __OVERLOAD__ vstore_half3_rtn(float3 x3, size_t i, __local half *p);
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, half *p );
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half3_rtn( double3 x, size_t index, __local half *p );

/* vstore_half4_rtn */
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, half *p);
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, __global half *p);
void __OVERLOAD__ vstore_half4_rtn(float4 x, size_t i, __local half *p);
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, half *p );
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half4_rtn( double4 x, size_t index, __local half *p );

/* vstore_half8_rtn */
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, half *p);
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, __global half *p);
void __OVERLOAD__ vstore_half8_rtn(float8 x, size_t i, __local half *p);
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, half *p );
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half8_rtn( double8 x, size_t index, __local half *p );

/* vstore_half16_rtn */
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, half *p);
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstore_half16_rtn(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, half *p );
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstore_half16_rtn( double16 x, size_t index, __local half *p );

/* vstorea_half_rtn */
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, half *p);
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, __global half *p);
void __OVERLOAD__ vstorea_half_rtn(float f, size_t index, __local half *p);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, half *p );
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half_rtn( double x, size_t index, __local half *p );
#endif
#define vstorea_half_rtn( X, Y, Z )     vstore_half_rtn( X, Y, Z )

/* vstorea_half2_rtn */
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, half *p);
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half2_rtn(float2 f, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half2_rtn( double2 x, size_t index, __local half *p );

/* vstorea_half3_rtn */
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, half *p);
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half3_rtn(float3 x3, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half3_rtn( double3 x, size_t index, __local half *p );

/* vstorea_half4_rtn */
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, half *p);
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half4_rtn(float4 x, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half4_rtn( double4 x, size_t index, __local half *p );

/* vstorea_half8_rtn */
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, half *p);
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half8_rtn(float8 x, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half8_rtn( double8 x, size_t index, __local half *p );

/* vstorea_half16_rtn */
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, half *p);
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, __global half *p);
void __OVERLOAD__ vstorea_half16_rtn(float16 v, size_t i, __local half *p);
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, half *p );
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, __global half *p );
void __OVERLOAD__ vstorea_half16_rtn( double16 x, size_t index, __local half *p );


// Vector Components / Constructors to be backward compatible with initial release though they are not in the OpenCL1.0 spec.
#define make_uchar2(A,B) (uchar2)((A),(B))
#define make_uchar3(A,B,C) (uchar3)((A),(B),(C))
#define make_uchar4(A,B,C,D) (uchar4)((A),(B),(C),(D))
#define make_uchar8(A,B,C,D,E,F,G,H) (uchar8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_uchar16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (uchar16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_char2(A,B) (char2)((A),(B))
#define make_char3(A,B,C) (char3)((A),(B),(C))
#define make_char4(A,B,C,D) (char4)((A),(B),(C),(D))
#define make_char8(A,B,C,D,E,F,G,H) (char8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_char16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (char16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_short2(A,B) (short2)((A),(B))
#define make_short3(A,B,C) (short3)((A),(B),(C))
#define make_short4(A,B,C,D) (short4)((A),(B),(C),(D))
#define make_short8(A,B,C,D,E,F,G,H) (short8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_short16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (short16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_ushort2(A,B) (ushort2)((A),(B))
#define make_ushort3(A,B,C) (ushort3)((A),(B),(C))
#define make_ushort4(A,B,C,D) (ushort4)((A),(B),(C),(D))
#define make_ushort8(A,B,C,D,E,F,G,H) (ushort8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_ushort16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (ushort16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_int2(A,B) (int2)((A),(B))
#define make_int3(A,B,C) (int3)((A),(B),(C))
#define make_int4(A,B,C,D) (int4)((A),(B),(C),(D))
#define make_int8(A,B,C,D,E,F,G,H) (int8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_int16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (int16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_uint2(A,B) (uint2)((A),(B))
#define make_uint3(A,B,C) (uint3)((A),(B),(C))
#define make_uint4(A,B,C,D) (uint4)((A),(B),(C),(D))
#define make_uint8(A,B,C,D,E,F,G,H) (uint8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_uint16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (uint16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_long2(A,B) (long2)((A),(B))
#define make_long3(A,B,C) (long3)((A),(B),(C))
#define make_long4(A,B,C,D) (long4)((A),(B),(C),(D))
#define make_long8(A,B,C,D,E,F,G,H) (long8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_long16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (long16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_ulong2(A,B) (ulong2)((A),(B))
#define make_ulong3(A,B,C) (ulong3)((A),(B),(C))
#define make_ulong4(A,B,C,D) (ulong4)((A),(B),(C),(D))
#define make_ulong8(A,B,C,D,E,F,G,H) (ulong8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_ulong16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (ulong16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_float2(A,B) (float2)((A),(B))
#define make_float3(A,B,C) (float3)((A),(B),(C))
#define make_float3_SPI(A,B,C) (float3)((A),(B),(C))
#define make_float4(A,B,C,D) (float4)((A),(B),(C),(D))
#define make_float8(A,B,C,D,E,F,G,H) (float8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_float16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (float16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))

#define make_double2(A,B) (double2)((A),(B))
#define make_double3(A,B,C) (double3)((A),(B),(C))
#define make_double4(A,B,C,D) (double4)((A),(B),(C),(D))
#define make_double8(A,B,C,D,E,F,G,H) (double8)((A),(B),(C),(D),(E),(F),(G),(H))
#define make_double16(A,B,C,D,E,F,G,H,I,J,K,L,M,N,O,P) (double16)((A),(B),(C),(D),(E),(F),(G),(H),(I),(J),(K),(L),(M),(N),(O),(P))


// 5.2.3 convert_ operators
typedef enum
{
    __kDefaultRoundingMode = 0,
    __kRoundToNearestEven = 1,
    __kRoundTowardNegativeInf = 2,
    __kRoundTowardInf = 3,
    __kRoundTowardZero = 4
}__clRoundingMode;

typedef enum
{
    __kUnsaturated = 0,
    __kSaturated = 1
}__clSaturationMode;

#if defined( __PTX__ )

    //type
    #define convert_char(_X)    __builtin_convert(_X, char, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar(_X)   __builtin_convert(_X, uchar, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short(_X)   __builtin_convert(_X, short, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort(_X)  __builtin_convert(_X, ushort, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int(_X)     __builtin_convert(_X, int, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint(_X)    __builtin_convert(_X, uint, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long(_X)    __builtin_convert(_X, long, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong(_X)   __builtin_convert(_X, ulong, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float(_X)   __builtin_convert(_X, float, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double(_X)  __builtin_convert(_X, double, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char_sat(_X)    __builtin_convert(_X, char, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar_sat(_X)   __builtin_convert(_X, uchar, __kDefaultRoundingMode, __kSaturated )
    #define convert_short_sat(_X)   __builtin_convert(_X, short, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort_sat(_X)  __builtin_convert(_X, ushort, __kDefaultRoundingMode, __kSaturated )
    #define convert_int_sat(_X)     __builtin_convert(_X, int, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint_sat(_X)    __builtin_convert(_X, uint, __kDefaultRoundingMode, __kSaturated )
    #define convert_long_sat(_X)    __builtin_convert(_X, long, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong_sat(_X)   __builtin_convert(_X, ulong, __kDefaultRoundingMode, __kSaturated )
    #define convert_float_sat(_X)   __builtin_convert(_X, float, __kDefaultRoundingMode, __kSaturated )
    #define convert_double_sat(_X)  __builtin_convert(_X, double, __kDefaultRoundingMode, __kSaturated )

    #define convert_char_rte(_X)    __builtin_convert(_X, char, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar_rte(_X)   __builtin_convert(_X, uchar, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short_rte(_X)   __builtin_convert(_X, short, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort_rte(_X)  __builtin_convert(_X, ushort, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int_rte(_X)     __builtin_convert(_X, int, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint_rte(_X)    __builtin_convert(_X, uint, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long_rte(_X)    __builtin_convert(_X, long, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong_rte(_X)   __builtin_convert(_X, ulong, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float_rte(_X)   __builtin_convert(_X, float, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double_rte(_X)  __builtin_convert(_X, double, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char_sat_rte(_X)    __builtin_convert(_X, char, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar_sat_rte(_X)   __builtin_convert(_X, uchar, __kRoundToNearestEven, __kSaturated )
    #define convert_short_sat_rte(_X)   __builtin_convert(_X, short, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort_sat_rte(_X)  __builtin_convert(_X, ushort, __kRoundToNearestEven, __kSaturated )
    #define convert_int_sat_rte(_X)     __builtin_convert(_X, int, __kRoundToNearestEven, __kSaturated )
    #define convert_uint_sat_rte(_X)    __builtin_convert(_X, uint, __kRoundToNearestEven, __kSaturated )
    #define convert_long_sat_rte(_X)    __builtin_convert(_X, long, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong_sat_rte(_X)   __builtin_convert(_X, ulong, __kRoundToNearestEven, __kSaturated )
    #define convert_float_sat_rte(_X)   __builtin_convert(_X, float, __kRoundToNearestEven, __kSaturated )
    #define convert_double_sat_rte(_X)  __builtin_convert(_X, double, __kRoundToNearestEven, __kSaturated )

    #define convert_char_rtn(_X)    __builtin_convert(_X, char, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar_rtn(_X)   __builtin_convert(_X, uchar, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short_rtn(_X)   __builtin_convert(_X, short, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort_rtn(_X)  __builtin_convert(_X, ushort, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int_rtn(_X)     __builtin_convert(_X, int, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint_rtn(_X)    __builtin_convert(_X, uint, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long_rtn(_X)    __builtin_convert(_X, long, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong_rtn(_X)   __builtin_convert(_X, ulong, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float_rtn(_X)   __builtin_convert(_X, float, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double_rtn(_X)  __builtin_convert(_X, double, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char_sat_rtn(_X)    __builtin_convert(_X, char, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar_sat_rtn(_X)   __builtin_convert(_X, uchar, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short_sat_rtn(_X)   __builtin_convert(_X, short, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort_sat_rtn(_X)  __builtin_convert(_X, ushort, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int_sat_rtn(_X)     __builtin_convert(_X, int, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint_sat_rtn(_X)    __builtin_convert(_X, uint, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long_sat_rtn(_X)    __builtin_convert(_X, long, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong_sat_rtn(_X)   __builtin_convert(_X, ulong, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float_sat_rtn(_X)   __builtin_convert(_X, float, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double_sat_rtn(_X)  __builtin_convert(_X, double, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char_rtp(_X)    __builtin_convert(_X, char, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar_rtp(_X)   __builtin_convert(_X, uchar, __kRoundTowardInf, __kUnsaturated )
    #define convert_short_rtp(_X)   __builtin_convert(_X, short, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort_rtp(_X)  __builtin_convert(_X, ushort, __kRoundTowardInf, __kUnsaturated )
    #define convert_int_rtp(_X)     __builtin_convert(_X, int, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint_rtp(_X)    __builtin_convert(_X, uint, __kRoundTowardInf, __kUnsaturated )
    #define convert_long_rtp(_X)    __builtin_convert(_X, long, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong_rtp(_X)   __builtin_convert(_X, ulong, __kRoundTowardInf, __kUnsaturated )
    #define convert_float_rtp(_X)   __builtin_convert(_X, float, __kRoundTowardInf, __kUnsaturated )
    #define convert_double_rtp(_X)  __builtin_convert(_X, double, __kRoundTowardInf, __kUnsaturated )

    #define convert_char_sat_rtp(_X)    __builtin_convert(_X, char, __kRoundTowardInf, __kSaturated )
    #define convert_uchar_sat_rtp(_X)   __builtin_convert(_X, uchar, __kRoundTowardInf, __kSaturated )
    #define convert_short_sat_rtp(_X)   __builtin_convert(_X, short, __kRoundTowardInf, __kSaturated )
    #define convert_ushort_sat_rtp(_X)  __builtin_convert(_X, ushort, __kRoundTowardInf, __kSaturated )
    #define convert_int_sat_rtp(_X)     __builtin_convert(_X, int, __kRoundTowardInf, __kSaturated )
    #define convert_uint_sat_rtp(_X)    __builtin_convert(_X, uint, __kRoundTowardInf, __kSaturated )
    #define convert_long_sat_rtp(_X)    __builtin_convert(_X, long, __kRoundTowardInf, __kSaturated )
    #define convert_ulong_sat_rtp(_X)   __builtin_convert(_X, ulong, __kRoundTowardInf, __kSaturated )
    #define convert_float_sat_rtp(_X)   __builtin_convert(_X, float, __kRoundTowardInf, __kSaturated )
    #define convert_double_sat_rtp(_X)  __builtin_convert(_X, double, __kRoundTowardInf, __kSaturated )

    #define convert_char_rtz(_X)    __builtin_convert(_X, char, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar_rtz(_X)   __builtin_convert(_X, uchar, __kRoundTowardZero, __kUnsaturated )
    #define convert_short_rtz(_X)   __builtin_convert(_X, short, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort_rtz(_X)  __builtin_convert(_X, ushort, __kRoundTowardZero, __kUnsaturated )
    #define convert_int_rtz(_X)     __builtin_convert(_X, int, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint_rtz(_X)    __builtin_convert(_X, uint, __kRoundTowardZero, __kUnsaturated )
    #define convert_long_rtz(_X)    __builtin_convert(_X, long, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong_rtz(_X)   __builtin_convert(_X, ulong, __kRoundTowardZero, __kUnsaturated )
    #define convert_float_rtz(_X)   __builtin_convert(_X, float, __kRoundTowardZero, __kUnsaturated )
    #define convert_double_rtz(_X)  __builtin_convert(_X, double, __kRoundTowardZero, __kUnsaturated )

    #define convert_char_sat_rtz(_X)    __builtin_convert(_X, char, __kRoundTowardZero, __kSaturated )
    #define convert_uchar_sat_rtz(_X)   __builtin_convert(_X, uchar, __kRoundTowardZero, __kSaturated )
    #define convert_short_sat_rtz(_X)   __builtin_convert(_X, short, __kRoundTowardZero, __kSaturated )
    #define convert_ushort_sat_rtz(_X)  __builtin_convert(_X, ushort, __kRoundTowardZero, __kSaturated )
    #define convert_int_sat_rtz(_X)     __builtin_convert(_X, int, __kRoundTowardZero, __kSaturated )
    #define convert_uint_sat_rtz(_X)    __builtin_convert(_X, uint, __kRoundTowardZero, __kSaturated )
    #define convert_long_sat_rtz(_X)    __builtin_convert(_X, long, __kRoundTowardZero, __kSaturated )
    #define convert_ulong_sat_rtz(_X)   __builtin_convert(_X, ulong, __kRoundTowardZero, __kSaturated )
    #define convert_float_sat_rtz(_X)   __builtin_convert(_X, float, __kRoundTowardZero, __kSaturated )
    #define convert_double_sat_rtz(_X)  __builtin_convert(_X, double, __kRoundTowardZero, __kSaturated )

    //type2
    #define convert_char2(_X)    __builtin_convert(_X, char2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar2(_X)   __builtin_convert(_X, uchar2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short2(_X)   __builtin_convert(_X, short2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort2(_X)  __builtin_convert(_X, ushort2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int2(_X)     __builtin_convert(_X, int2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint2(_X)    __builtin_convert(_X, uint2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long2(_X)    __builtin_convert(_X, long2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong2(_X)   __builtin_convert(_X, ulong2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float2(_X)   __builtin_convert(_X, float2, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double2(_X)  __builtin_convert(_X, double2, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char2_sat(_X)    __builtin_convert(_X, char2, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar2_sat(_X)   __builtin_convert(_X, uchar2, __kDefaultRoundingMode, __kSaturated )
    #define convert_short2_sat(_X)   __builtin_convert(_X, short2, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort2_sat(_X)  __builtin_convert(_X, ushort2, __kDefaultRoundingMode, __kSaturated )
    #define convert_int2_sat(_X)     __builtin_convert(_X, int2, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint2_sat(_X)    __builtin_convert(_X, uint2, __kDefaultRoundingMode, __kSaturated )
    #define convert_long2_sat(_X)    __builtin_convert(_X, long2, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong2_sat(_X)   __builtin_convert(_X, ulong2, __kDefaultRoundingMode, __kSaturated )
    #define convert_float2_sat(_X)   __builtin_convert(_X, float2, __kDefaultRoundingMode, __kSaturated )
    #define convert_double2_sat(_X)  __builtin_convert(_X, double2, __kDefaultRoundingMode, __kSaturated )

    #define convert_char2_rte(_X)    __builtin_convert(_X, char2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar2_rte(_X)   __builtin_convert(_X, uchar2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short2_rte(_X)   __builtin_convert(_X, short2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort2_rte(_X)  __builtin_convert(_X, ushort2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int2_rte(_X)     __builtin_convert(_X, int2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint2_rte(_X)    __builtin_convert(_X, uint2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long2_rte(_X)    __builtin_convert(_X, long2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong2_rte(_X)   __builtin_convert(_X, ulong2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float2_rte(_X)   __builtin_convert(_X, float2, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double2_rte(_X)  __builtin_convert(_X, double2, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char2_sat_rte(_X)    __builtin_convert(_X, char2, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar2_sat_rte(_X)   __builtin_convert(_X, uchar2, __kRoundToNearestEven, __kSaturated )
    #define convert_short2_sat_rte(_X)   __builtin_convert(_X, short2, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort2_sat_rte(_X)  __builtin_convert(_X, ushort2, __kRoundToNearestEven, __kSaturated )
    #define convert_int2_sat_rte(_X)     __builtin_convert(_X, int2, __kRoundToNearestEven, __kSaturated )
    #define convert_uint2_sat_rte(_X)    __builtin_convert(_X, uint2, __kRoundToNearestEven, __kSaturated )
    #define convert_long2_sat_rte(_X)    __builtin_convert(_X, long2, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong2_sat_rte(_X)   __builtin_convert(_X, ulong2, __kRoundToNearestEven, __kSaturated )
    #define convert_float2_sat_rte(_X)   __builtin_convert(_X, float2, __kRoundToNearestEven, __kSaturated )
    #define convert_double2_sat_rte(_X)  __builtin_convert(_X, double2, __kRoundToNearestEven, __kSaturated )

    #define convert_char2_rtn(_X)    __builtin_convert(_X, char2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar2_rtn(_X)   __builtin_convert(_X, uchar2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short2_rtn(_X)   __builtin_convert(_X, short2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort2_rtn(_X)  __builtin_convert(_X, ushort2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int2_rtn(_X)     __builtin_convert(_X, int2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint2_rtn(_X)    __builtin_convert(_X, uint2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long2_rtn(_X)    __builtin_convert(_X, long2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong2_rtn(_X)   __builtin_convert(_X, ulong2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float2_rtn(_X)   __builtin_convert(_X, float2, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double2_rtn(_X)  __builtin_convert(_X, double2, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char2_sat_rtn(_X)    __builtin_convert(_X, char2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar2_sat_rtn(_X)   __builtin_convert(_X, uchar2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short2_sat_rtn(_X)   __builtin_convert(_X, short2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort2_sat_rtn(_X)  __builtin_convert(_X, ushort2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int2_sat_rtn(_X)     __builtin_convert(_X, int2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint2_sat_rtn(_X)    __builtin_convert(_X, uint2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long2_sat_rtn(_X)    __builtin_convert(_X, long2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong2_sat_rtn(_X)   __builtin_convert(_X, ulong2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float2_sat_rtn(_X)   __builtin_convert(_X, float2, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double2_sat_rtn(_X)  __builtin_convert(_X, double2, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char2_rtp(_X)    __builtin_convert(_X, char2, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar2_rtp(_X)   __builtin_convert(_X, uchar2, __kRoundTowardInf, __kUnsaturated )
    #define convert_short2_rtp(_X)   __builtin_convert(_X, short2, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort2_rtp(_X)  __builtin_convert(_X, ushort2, __kRoundTowardInf, __kUnsaturated )
    #define convert_int2_rtp(_X)     __builtin_convert(_X, int2, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint2_rtp(_X)    __builtin_convert(_X, uint2, __kRoundTowardInf, __kUnsaturated )
    #define convert_long2_rtp(_X)    __builtin_convert(_X, long2, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong2_rtp(_X)   __builtin_convert(_X, ulong2, __kRoundTowardInf, __kUnsaturated )
    #define convert_float2_rtp(_X)   __builtin_convert(_X, float2, __kRoundTowardInf, __kUnsaturated )
    #define convert_double2_rtp(_X)  __builtin_convert(_X, double2, __kRoundTowardInf, __kUnsaturated )

    #define convert_char2_sat_rtp(_X)    __builtin_convert(_X, char2, __kRoundTowardInf, __kSaturated )
    #define convert_uchar2_sat_rtp(_X)   __builtin_convert(_X, uchar2, __kRoundTowardInf, __kSaturated )
    #define convert_short2_sat_rtp(_X)   __builtin_convert(_X, short2, __kRoundTowardInf, __kSaturated )
    #define convert_ushort2_sat_rtp(_X)  __builtin_convert(_X, ushort2, __kRoundTowardInf, __kSaturated )
    #define convert_int2_sat_rtp(_X)     __builtin_convert(_X, int2, __kRoundTowardInf, __kSaturated )
    #define convert_uint2_sat_rtp(_X)    __builtin_convert(_X, uint2, __kRoundTowardInf, __kSaturated )
    #define convert_long2_sat_rtp(_X)    __builtin_convert(_X, long2, __kRoundTowardInf, __kSaturated )
    #define convert_ulong2_sat_rtp(_X)   __builtin_convert(_X, ulong2, __kRoundTowardInf, __kSaturated )
    #define convert_float2_sat_rtp(_X)   __builtin_convert(_X, float2, __kRoundTowardInf, __kSaturated )
    #define convert_double2_sat_rtp(_X)  __builtin_convert(_X, double2, __kRoundTowardInf, __kSaturated )

    #define convert_char2_rtz(_X)    __builtin_convert(_X, char2, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar2_rtz(_X)   __builtin_convert(_X, uchar2, __kRoundTowardZero, __kUnsaturated )
    #define convert_short2_rtz(_X)   __builtin_convert(_X, short2, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort2_rtz(_X)  __builtin_convert(_X, ushort2, __kRoundTowardZero, __kUnsaturated )
    #define convert_int2_rtz(_X)     __builtin_convert(_X, int2, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint2_rtz(_X)    __builtin_convert(_X, uint2, __kRoundTowardZero, __kUnsaturated )
    #define convert_long2_rtz(_X)    __builtin_convert(_X, long2, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong2_rtz(_X)   __builtin_convert(_X, ulong2, __kRoundTowardZero, __kUnsaturated )
    #define convert_float2_rtz(_X)   __builtin_convert(_X, float2, __kRoundTowardZero, __kUnsaturated )
    #define convert_double2_rtz(_X)  __builtin_convert(_X, double2, __kRoundTowardZero, __kUnsaturated )

    #define convert_char2_sat_rtz(_X)    __builtin_convert(_X, char2, __kRoundTowardZero, __kSaturated )
    #define convert_uchar2_sat_rtz(_X)   __builtin_convert(_X, uchar2, __kRoundTowardZero, __kSaturated )
    #define convert_short2_sat_rtz(_X)   __builtin_convert(_X, short2, __kRoundTowardZero, __kSaturated )
    #define convert_ushort2_sat_rtz(_X)  __builtin_convert(_X, ushort2, __kRoundTowardZero, __kSaturated )
    #define convert_int2_sat_rtz(_X)     __builtin_convert(_X, int2, __kRoundTowardZero, __kSaturated )
    #define convert_uint2_sat_rtz(_X)    __builtin_convert(_X, uint2, __kRoundTowardZero, __kSaturated )
    #define convert_long2_sat_rtz(_X)    __builtin_convert(_X, long2, __kRoundTowardZero, __kSaturated )
    #define convert_ulong2_sat_rtz(_X)   __builtin_convert(_X, ulong2, __kRoundTowardZero, __kSaturated )
    #define convert_float2_sat_rtz(_X)   __builtin_convert(_X, float2, __kRoundTowardZero, __kSaturated )
    #define convert_double2_sat_rtz(_X)  __builtin_convert(_X, double2, __kRoundTowardZero, __kSaturated )

    //type3
    #define convert_char3(_X)    __builtin_convert(_X, char3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar3(_X)   __builtin_convert(_X, uchar3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short3(_X)   __builtin_convert(_X, short3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort3(_X)  __builtin_convert(_X, ushort3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int3(_X)     __builtin_convert(_X, int3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint3(_X)    __builtin_convert(_X, uint3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long3(_X)    __builtin_convert(_X, long3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong3(_X)   __builtin_convert(_X, ulong3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float3(_X)   __builtin_convert(_X, float3, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double3(_X)  __builtin_convert(_X, double3, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char3_sat(_X)    __builtin_convert(_X, char3, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar3_sat(_X)   __builtin_convert(_X, uchar3, __kDefaultRoundingMode, __kSaturated )
    #define convert_short3_sat(_X)   __builtin_convert(_X, short3, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort3_sat(_X)  __builtin_convert(_X, ushort3, __kDefaultRoundingMode, __kSaturated )
    #define convert_int3_sat(_X)     __builtin_convert(_X, int3, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint3_sat(_X)    __builtin_convert(_X, uint3, __kDefaultRoundingMode, __kSaturated )
    #define convert_long3_sat(_X)    __builtin_convert(_X, long3, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong3_sat(_X)   __builtin_convert(_X, ulong3, __kDefaultRoundingMode, __kSaturated )
    #define convert_float3_sat(_X)   __builtin_convert(_X, float3, __kDefaultRoundingMode, __kSaturated )
    #define convert_double3_sat(_X)  __builtin_convert(_X, double3, __kDefaultRoundingMode, __kSaturated )

    #define convert_char3_rte(_X)    __builtin_convert(_X, char3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar3_rte(_X)   __builtin_convert(_X, uchar3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short3_rte(_X)   __builtin_convert(_X, short3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort3_rte(_X)  __builtin_convert(_X, ushort3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int3_rte(_X)     __builtin_convert(_X, int3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint3_rte(_X)    __builtin_convert(_X, uint3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long3_rte(_X)    __builtin_convert(_X, long3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong3_rte(_X)   __builtin_convert(_X, ulong3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float3_rte(_X)   __builtin_convert(_X, float3, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double3_rte(_X)  __builtin_convert(_X, double3, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char3_sat_rte(_X)    __builtin_convert(_X, char3, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar3_sat_rte(_X)   __builtin_convert(_X, uchar3, __kRoundToNearestEven, __kSaturated )
    #define convert_short3_sat_rte(_X)   __builtin_convert(_X, short3, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort3_sat_rte(_X)  __builtin_convert(_X, ushort3, __kRoundToNearestEven, __kSaturated )
    #define convert_int3_sat_rte(_X)     __builtin_convert(_X, int3, __kRoundToNearestEven, __kSaturated )
    #define convert_uint3_sat_rte(_X)    __builtin_convert(_X, uint3, __kRoundToNearestEven, __kSaturated )
    #define convert_long3_sat_rte(_X)    __builtin_convert(_X, long3, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong3_sat_rte(_X)   __builtin_convert(_X, ulong3, __kRoundToNearestEven, __kSaturated )
    #define convert_float3_sat_rte(_X)   __builtin_convert(_X, float3, __kRoundToNearestEven, __kSaturated )
    #define convert_double3_sat_rte(_X)  __builtin_convert(_X, double3, __kRoundToNearestEven, __kSaturated )

    #define convert_char3_rtn(_X)    __builtin_convert(_X, char3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar3_rtn(_X)   __builtin_convert(_X, uchar3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short3_rtn(_X)   __builtin_convert(_X, short3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort3_rtn(_X)  __builtin_convert(_X, ushort3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int3_rtn(_X)     __builtin_convert(_X, int3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint3_rtn(_X)    __builtin_convert(_X, uint3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long3_rtn(_X)    __builtin_convert(_X, long3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong3_rtn(_X)   __builtin_convert(_X, ulong3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float3_rtn(_X)   __builtin_convert(_X, float3, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double3_rtn(_X)  __builtin_convert(_X, double3, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char3_sat_rtn(_X)    __builtin_convert(_X, char3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar3_sat_rtn(_X)   __builtin_convert(_X, uchar3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short3_sat_rtn(_X)   __builtin_convert(_X, short3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort3_sat_rtn(_X)  __builtin_convert(_X, ushort3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int3_sat_rtn(_X)     __builtin_convert(_X, int3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint3_sat_rtn(_X)    __builtin_convert(_X, uint3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long3_sat_rtn(_X)    __builtin_convert(_X, long3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong3_sat_rtn(_X)   __builtin_convert(_X, ulong3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float3_sat_rtn(_X)   __builtin_convert(_X, float3, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double3_sat_rtn(_X)  __builtin_convert(_X, double3, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char3_rtp(_X)    __builtin_convert(_X, char3, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar3_rtp(_X)   __builtin_convert(_X, uchar3, __kRoundTowardInf, __kUnsaturated )
    #define convert_short3_rtp(_X)   __builtin_convert(_X, short3, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort3_rtp(_X)  __builtin_convert(_X, ushort3, __kRoundTowardInf, __kUnsaturated )
    #define convert_int3_rtp(_X)     __builtin_convert(_X, int3, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint3_rtp(_X)    __builtin_convert(_X, uint3, __kRoundTowardInf, __kUnsaturated )
    #define convert_long3_rtp(_X)    __builtin_convert(_X, long3, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong3_rtp(_X)   __builtin_convert(_X, ulong3, __kRoundTowardInf, __kUnsaturated )
    #define convert_float3_rtp(_X)   __builtin_convert(_X, float3, __kRoundTowardInf, __kUnsaturated )
    #define convert_double3_rtp(_X)  __builtin_convert(_X, double3, __kRoundTowardInf, __kUnsaturated )

    #define convert_char3_sat_rtp(_X)    __builtin_convert(_X, char3, __kRoundTowardInf, __kSaturated )
    #define convert_uchar3_sat_rtp(_X)   __builtin_convert(_X, uchar3, __kRoundTowardInf, __kSaturated )
    #define convert_short3_sat_rtp(_X)   __builtin_convert(_X, short3, __kRoundTowardInf, __kSaturated )
    #define convert_ushort3_sat_rtp(_X)  __builtin_convert(_X, ushort3, __kRoundTowardInf, __kSaturated )
    #define convert_int3_sat_rtp(_X)     __builtin_convert(_X, int3, __kRoundTowardInf, __kSaturated )
    #define convert_uint3_sat_rtp(_X)    __builtin_convert(_X, uint3, __kRoundTowardInf, __kSaturated )
    #define convert_long3_sat_rtp(_X)    __builtin_convert(_X, long3, __kRoundTowardInf, __kSaturated )
    #define convert_ulong3_sat_rtp(_X)   __builtin_convert(_X, ulong3, __kRoundTowardInf, __kSaturated )
    #define convert_float3_sat_rtp(_X)   __builtin_convert(_X, float3, __kRoundTowardInf, __kSaturated )
    #define convert_double3_sat_rtp(_X)  __builtin_convert(_X, double3, __kRoundTowardInf, __kSaturated )

    #define convert_char3_rtz(_X)    __builtin_convert(_X, char3, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar3_rtz(_X)   __builtin_convert(_X, uchar3, __kRoundTowardZero, __kUnsaturated )
    #define convert_short3_rtz(_X)   __builtin_convert(_X, short3, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort3_rtz(_X)  __builtin_convert(_X, ushort3, __kRoundTowardZero, __kUnsaturated )
    #define convert_int3_rtz(_X)     __builtin_convert(_X, int3, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint3_rtz(_X)    __builtin_convert(_X, uint3, __kRoundTowardZero, __kUnsaturated )
    #define convert_long3_rtz(_X)    __builtin_convert(_X, long3, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong3_rtz(_X)   __builtin_convert(_X, ulong3, __kRoundTowardZero, __kUnsaturated )
    #define convert_float3_rtz(_X)   __builtin_convert(_X, float3, __kRoundTowardZero, __kUnsaturated )
    #define convert_double3_rtz(_X)  __builtin_convert(_X, double3, __kRoundTowardZero, __kUnsaturated )

    #define convert_char3_sat_rtz(_X)    __builtin_convert(_X, char3, __kRoundTowardZero, __kSaturated )
    #define convert_uchar3_sat_rtz(_X)   __builtin_convert(_X, uchar3, __kRoundTowardZero, __kSaturated )
    #define convert_short3_sat_rtz(_X)   __builtin_convert(_X, short3, __kRoundTowardZero, __kSaturated )
    #define convert_ushort3_sat_rtz(_X)  __builtin_convert(_X, ushort3, __kRoundTowardZero, __kSaturated )
    #define convert_int3_sat_rtz(_X)     __builtin_convert(_X, int3, __kRoundTowardZero, __kSaturated )
    #define convert_uint3_sat_rtz(_X)    __builtin_convert(_X, uint3, __kRoundTowardZero, __kSaturated )
    #define convert_long3_sat_rtz(_X)    __builtin_convert(_X, long3, __kRoundTowardZero, __kSaturated )
    #define convert_ulong3_sat_rtz(_X)   __builtin_convert(_X, ulong3, __kRoundTowardZero, __kSaturated )
    #define convert_float3_sat_rtz(_X)   __builtin_convert(_X, float3, __kRoundTowardZero, __kSaturated )
    #define convert_double3_sat_rtz(_X)  __builtin_convert(_X, double3, __kRoundTowardZero, __kSaturated )

    //type4
    #define convert_char4(_X)    __builtin_convert(_X, char4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar4(_X)   __builtin_convert(_X, uchar4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short4(_X)   __builtin_convert(_X, short4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort4(_X)  __builtin_convert(_X, ushort4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int4(_X)     __builtin_convert(_X, int4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint4(_X)    __builtin_convert(_X, uint4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long4(_X)    __builtin_convert(_X, long4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong4(_X)   __builtin_convert(_X, ulong4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float4(_X)   __builtin_convert(_X, float4, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double4(_X)  __builtin_convert(_X, double4, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char4_sat(_X)    __builtin_convert(_X, char4, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar4_sat(_X)   __builtin_convert(_X, uchar4, __kDefaultRoundingMode, __kSaturated )
    #define convert_short4_sat(_X)   __builtin_convert(_X, short4, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort4_sat(_X)  __builtin_convert(_X, ushort4, __kDefaultRoundingMode, __kSaturated )
    #define convert_int4_sat(_X)     __builtin_convert(_X, int4, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint4_sat(_X)    __builtin_convert(_X, uint4, __kDefaultRoundingMode, __kSaturated )
    #define convert_long4_sat(_X)    __builtin_convert(_X, long4, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong4_sat(_X)   __builtin_convert(_X, ulong4, __kDefaultRoundingMode, __kSaturated )
    #define convert_float4_sat(_X)   __builtin_convert(_X, float4, __kDefaultRoundingMode, __kSaturated )
    #define convert_double4_sat(_X)  __builtin_convert(_X, double4, __kDefaultRoundingMode, __kSaturated )

    #define convert_char4_rte(_X)    __builtin_convert(_X, char4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar4_rte(_X)   __builtin_convert(_X, uchar4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short4_rte(_X)   __builtin_convert(_X, short4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort4_rte(_X)  __builtin_convert(_X, ushort4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int4_rte(_X)     __builtin_convert(_X, int4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint4_rte(_X)    __builtin_convert(_X, uint4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long4_rte(_X)    __builtin_convert(_X, long4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong4_rte(_X)   __builtin_convert(_X, ulong4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float4_rte(_X)   __builtin_convert(_X, float4, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double4_rte(_X)  __builtin_convert(_X, double4, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char4_sat_rte(_X)    __builtin_convert(_X, char4, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar4_sat_rte(_X)   __builtin_convert(_X, uchar4, __kRoundToNearestEven, __kSaturated )
    #define convert_short4_sat_rte(_X)   __builtin_convert(_X, short4, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort4_sat_rte(_X)  __builtin_convert(_X, ushort4, __kRoundToNearestEven, __kSaturated )
    #define convert_int4_sat_rte(_X)     __builtin_convert(_X, int4, __kRoundToNearestEven, __kSaturated )
    #define convert_uint4_sat_rte(_X)    __builtin_convert(_X, uint4, __kRoundToNearestEven, __kSaturated )
    #define convert_long4_sat_rte(_X)    __builtin_convert(_X, long4, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong4_sat_rte(_X)   __builtin_convert(_X, ulong4, __kRoundToNearestEven, __kSaturated )
    #define convert_float4_sat_rte(_X)   __builtin_convert(_X, float4, __kRoundToNearestEven, __kSaturated )
    #define convert_double4_sat_rte(_X)  __builtin_convert(_X, double4, __kRoundToNearestEven, __kSaturated )

    #define convert_char4_rtn(_X)    __builtin_convert(_X, char4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar4_rtn(_X)   __builtin_convert(_X, uchar4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short4_rtn(_X)   __builtin_convert(_X, short4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort4_rtn(_X)  __builtin_convert(_X, ushort4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int4_rtn(_X)     __builtin_convert(_X, int4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint4_rtn(_X)    __builtin_convert(_X, uint4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long4_rtn(_X)    __builtin_convert(_X, long4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong4_rtn(_X)   __builtin_convert(_X, ulong4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float4_rtn(_X)   __builtin_convert(_X, float4, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double4_rtn(_X)  __builtin_convert(_X, double4, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char4_sat_rtn(_X)    __builtin_convert(_X, char4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar4_sat_rtn(_X)   __builtin_convert(_X, uchar4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short4_sat_rtn(_X)   __builtin_convert(_X, short4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort4_sat_rtn(_X)  __builtin_convert(_X, ushort4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int4_sat_rtn(_X)     __builtin_convert(_X, int4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint4_sat_rtn(_X)    __builtin_convert(_X, uint4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long4_sat_rtn(_X)    __builtin_convert(_X, long4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong4_sat_rtn(_X)   __builtin_convert(_X, ulong4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float4_sat_rtn(_X)   __builtin_convert(_X, float4, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double4_sat_rtn(_X)  __builtin_convert(_X, double4, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char4_rtp(_X)    __builtin_convert(_X, char4, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar4_rtp(_X)   __builtin_convert(_X, uchar4, __kRoundTowardInf, __kUnsaturated )
    #define convert_short4_rtp(_X)   __builtin_convert(_X, short4, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort4_rtp(_X)  __builtin_convert(_X, ushort4, __kRoundTowardInf, __kUnsaturated )
    #define convert_int4_rtp(_X)     __builtin_convert(_X, int4, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint4_rtp(_X)    __builtin_convert(_X, uint4, __kRoundTowardInf, __kUnsaturated )
    #define convert_long4_rtp(_X)    __builtin_convert(_X, long4, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong4_rtp(_X)   __builtin_convert(_X, ulong4, __kRoundTowardInf, __kUnsaturated )
    #define convert_float4_rtp(_X)   __builtin_convert(_X, float4, __kRoundTowardInf, __kUnsaturated )
    #define convert_double4_rtp(_X)  __builtin_convert(_X, double4, __kRoundTowardInf, __kUnsaturated )

    #define convert_char4_sat_rtp(_X)    __builtin_convert(_X, char4, __kRoundTowardInf, __kSaturated )
    #define convert_uchar4_sat_rtp(_X)   __builtin_convert(_X, uchar4, __kRoundTowardInf, __kSaturated )
    #define convert_short4_sat_rtp(_X)   __builtin_convert(_X, short4, __kRoundTowardInf, __kSaturated )
    #define convert_ushort4_sat_rtp(_X)  __builtin_convert(_X, ushort4, __kRoundTowardInf, __kSaturated )
    #define convert_int4_sat_rtp(_X)     __builtin_convert(_X, int4, __kRoundTowardInf, __kSaturated )
    #define convert_uint4_sat_rtp(_X)    __builtin_convert(_X, uint4, __kRoundTowardInf, __kSaturated )
    #define convert_long4_sat_rtp(_X)    __builtin_convert(_X, long4, __kRoundTowardInf, __kSaturated )
    #define convert_ulong4_sat_rtp(_X)   __builtin_convert(_X, ulong4, __kRoundTowardInf, __kSaturated )
    #define convert_float4_sat_rtp(_X)   __builtin_convert(_X, float4, __kRoundTowardInf, __kSaturated )
    #define convert_double4_sat_rtp(_X)  __builtin_convert(_X, double4, __kRoundTowardInf, __kSaturated )

    #define convert_char4_rtz(_X)    __builtin_convert(_X, char4, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar4_rtz(_X)   __builtin_convert(_X, uchar4, __kRoundTowardZero, __kUnsaturated )
    #define convert_short4_rtz(_X)   __builtin_convert(_X, short4, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort4_rtz(_X)  __builtin_convert(_X, ushort4, __kRoundTowardZero, __kUnsaturated )
    #define convert_int4_rtz(_X)     __builtin_convert(_X, int4, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint4_rtz(_X)    __builtin_convert(_X, uint4, __kRoundTowardZero, __kUnsaturated )
    #define convert_long4_rtz(_X)    __builtin_convert(_X, long4, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong4_rtz(_X)   __builtin_convert(_X, ulong4, __kRoundTowardZero, __kUnsaturated )
    #define convert_float4_rtz(_X)   __builtin_convert(_X, float4, __kRoundTowardZero, __kUnsaturated )
    #define convert_double4_rtz(_X)  __builtin_convert(_X, double4, __kRoundTowardZero, __kUnsaturated )

    #define convert_char4_sat_rtz(_X)    __builtin_convert(_X, char4, __kRoundTowardZero, __kSaturated )
    #define convert_uchar4_sat_rtz(_X)   __builtin_convert(_X, uchar4, __kRoundTowardZero, __kSaturated )
    #define convert_short4_sat_rtz(_X)   __builtin_convert(_X, short4, __kRoundTowardZero, __kSaturated )
    #define convert_ushort4_sat_rtz(_X)  __builtin_convert(_X, ushort4, __kRoundTowardZero, __kSaturated )
    #define convert_int4_sat_rtz(_X)     __builtin_convert(_X, int4, __kRoundTowardZero, __kSaturated )
    #define convert_uint4_sat_rtz(_X)    __builtin_convert(_X, uint4, __kRoundTowardZero, __kSaturated )
    #define convert_long4_sat_rtz(_X)    __builtin_convert(_X, long4, __kRoundTowardZero, __kSaturated )
    #define convert_ulong4_sat_rtz(_X)   __builtin_convert(_X, ulong4, __kRoundTowardZero, __kSaturated )
    #define convert_float4_sat_rtz(_X)   __builtin_convert(_X, float4, __kRoundTowardZero, __kSaturated )
    #define convert_double4_sat_rtz(_X)  __builtin_convert(_X, double4, __kRoundTowardZero, __kSaturated )

    //type8
    #define convert_char8(_X)    __builtin_convert(_X, char8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar8(_X)   __builtin_convert(_X, uchar8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short8(_X)   __builtin_convert(_X, short8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort8(_X)  __builtin_convert(_X, ushort8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int8(_X)     __builtin_convert(_X, int8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint8(_X)    __builtin_convert(_X, uint8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long8(_X)    __builtin_convert(_X, long8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong8(_X)   __builtin_convert(_X, ulong8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float8(_X)   __builtin_convert(_X, float8, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double8(_X)  __builtin_convert(_X, double8, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char8_sat(_X)    __builtin_convert(_X, char8, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar8_sat(_X)   __builtin_convert(_X, uchar8, __kDefaultRoundingMode, __kSaturated )
    #define convert_short8_sat(_X)   __builtin_convert(_X, short8, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort8_sat(_X)  __builtin_convert(_X, ushort8, __kDefaultRoundingMode, __kSaturated )
    #define convert_int8_sat(_X)     __builtin_convert(_X, int8, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint8_sat(_X)    __builtin_convert(_X, uint8, __kDefaultRoundingMode, __kSaturated )
    #define convert_long8_sat(_X)    __builtin_convert(_X, long8, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong8_sat(_X)   __builtin_convert(_X, ulong8, __kDefaultRoundingMode, __kSaturated )
    #define convert_float8_sat(_X)   __builtin_convert(_X, float8, __kDefaultRoundingMode, __kSaturated )
    #define convert_double8_sat(_X)  __builtin_convert(_X, double8, __kDefaultRoundingMode, __kSaturated )

    #define convert_char8_rte(_X)    __builtin_convert(_X, char8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar8_rte(_X)   __builtin_convert(_X, uchar8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short8_rte(_X)   __builtin_convert(_X, short8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort8_rte(_X)  __builtin_convert(_X, ushort8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int8_rte(_X)     __builtin_convert(_X, int8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint8_rte(_X)    __builtin_convert(_X, uint8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long8_rte(_X)    __builtin_convert(_X, long8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong8_rte(_X)   __builtin_convert(_X, ulong8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float8_rte(_X)   __builtin_convert(_X, float8, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double8_rte(_X)  __builtin_convert(_X, double8, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char8_sat_rte(_X)    __builtin_convert(_X, char8, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar8_sat_rte(_X)   __builtin_convert(_X, uchar8, __kRoundToNearestEven, __kSaturated )
    #define convert_short8_sat_rte(_X)   __builtin_convert(_X, short8, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort8_sat_rte(_X)  __builtin_convert(_X, ushort8, __kRoundToNearestEven, __kSaturated )
    #define convert_int8_sat_rte(_X)     __builtin_convert(_X, int8, __kRoundToNearestEven, __kSaturated )
    #define convert_uint8_sat_rte(_X)    __builtin_convert(_X, uint8, __kRoundToNearestEven, __kSaturated )
    #define convert_long8_sat_rte(_X)    __builtin_convert(_X, long8, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong8_sat_rte(_X)   __builtin_convert(_X, ulong8, __kRoundToNearestEven, __kSaturated )
    #define convert_float8_sat_rte(_X)   __builtin_convert(_X, float8, __kRoundToNearestEven, __kSaturated )
    #define convert_double8_sat_rte(_X)  __builtin_convert(_X, double8, __kRoundToNearestEven, __kSaturated )

    #define convert_char8_rtn(_X)    __builtin_convert(_X, char8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar8_rtn(_X)   __builtin_convert(_X, uchar8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short8_rtn(_X)   __builtin_convert(_X, short8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort8_rtn(_X)  __builtin_convert(_X, ushort8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int8_rtn(_X)     __builtin_convert(_X, int8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint8_rtn(_X)    __builtin_convert(_X, uint8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long8_rtn(_X)    __builtin_convert(_X, long8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong8_rtn(_X)   __builtin_convert(_X, ulong8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float8_rtn(_X)   __builtin_convert(_X, float8, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double8_rtn(_X)  __builtin_convert(_X, double8, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char8_sat_rtn(_X)    __builtin_convert(_X, char8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar8_sat_rtn(_X)   __builtin_convert(_X, uchar8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short8_sat_rtn(_X)   __builtin_convert(_X, short8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort8_sat_rtn(_X)  __builtin_convert(_X, ushort8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int8_sat_rtn(_X)     __builtin_convert(_X, int8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint8_sat_rtn(_X)    __builtin_convert(_X, uint8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long8_sat_rtn(_X)    __builtin_convert(_X, long8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong8_sat_rtn(_X)   __builtin_convert(_X, ulong8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float8_sat_rtn(_X)   __builtin_convert(_X, float8, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double8_sat_rtn(_X)  __builtin_convert(_X, double8, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char8_rtp(_X)    __builtin_convert(_X, char8, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar8_rtp(_X)   __builtin_convert(_X, uchar8, __kRoundTowardInf, __kUnsaturated )
    #define convert_short8_rtp(_X)   __builtin_convert(_X, short8, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort8_rtp(_X)  __builtin_convert(_X, ushort8, __kRoundTowardInf, __kUnsaturated )
    #define convert_int8_rtp(_X)     __builtin_convert(_X, int8, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint8_rtp(_X)    __builtin_convert(_X, uint8, __kRoundTowardInf, __kUnsaturated )
    #define convert_long8_rtp(_X)    __builtin_convert(_X, long8, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong8_rtp(_X)   __builtin_convert(_X, ulong8, __kRoundTowardInf, __kUnsaturated )
    #define convert_float8_rtp(_X)   __builtin_convert(_X, float8, __kRoundTowardInf, __kUnsaturated )
    #define convert_double8_rtp(_X)  __builtin_convert(_X, double8, __kRoundTowardInf, __kUnsaturated )

    #define convert_char8_sat_rtp(_X)    __builtin_convert(_X, char8, __kRoundTowardInf, __kSaturated )
    #define convert_uchar8_sat_rtp(_X)   __builtin_convert(_X, uchar8, __kRoundTowardInf, __kSaturated )
    #define convert_short8_sat_rtp(_X)   __builtin_convert(_X, short8, __kRoundTowardInf, __kSaturated )
    #define convert_ushort8_sat_rtp(_X)  __builtin_convert(_X, ushort8, __kRoundTowardInf, __kSaturated )
    #define convert_int8_sat_rtp(_X)     __builtin_convert(_X, int8, __kRoundTowardInf, __kSaturated )
    #define convert_uint8_sat_rtp(_X)    __builtin_convert(_X, uint8, __kRoundTowardInf, __kSaturated )
    #define convert_long8_sat_rtp(_X)    __builtin_convert(_X, long8, __kRoundTowardInf, __kSaturated )
    #define convert_ulong8_sat_rtp(_X)   __builtin_convert(_X, ulong8, __kRoundTowardInf, __kSaturated )
    #define convert_float8_sat_rtp(_X)   __builtin_convert(_X, float8, __kRoundTowardInf, __kSaturated )
    #define convert_double8_sat_rtp(_X)  __builtin_convert(_X, double8, __kRoundTowardInf, __kSaturated )

    #define convert_char8_rtz(_X)    __builtin_convert(_X, char8, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar8_rtz(_X)   __builtin_convert(_X, uchar8, __kRoundTowardZero, __kUnsaturated )
    #define convert_short8_rtz(_X)   __builtin_convert(_X, short8, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort8_rtz(_X)  __builtin_convert(_X, ushort8, __kRoundTowardZero, __kUnsaturated )
    #define convert_int8_rtz(_X)     __builtin_convert(_X, int8, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint8_rtz(_X)    __builtin_convert(_X, uint8, __kRoundTowardZero, __kUnsaturated )
    #define convert_long8_rtz(_X)    __builtin_convert(_X, long8, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong8_rtz(_X)   __builtin_convert(_X, ulong8, __kRoundTowardZero, __kUnsaturated )
    #define convert_float8_rtz(_X)   __builtin_convert(_X, float8, __kRoundTowardZero, __kUnsaturated )
    #define convert_double8_rtz(_X)  __builtin_convert(_X, double8, __kRoundTowardZero, __kUnsaturated )

    #define convert_char8_sat_rtz(_X)    __builtin_convert(_X, char8, __kRoundTowardZero, __kSaturated )
    #define convert_uchar8_sat_rtz(_X)   __builtin_convert(_X, uchar8, __kRoundTowardZero, __kSaturated )
    #define convert_short8_sat_rtz(_X)   __builtin_convert(_X, short8, __kRoundTowardZero, __kSaturated )
    #define convert_ushort8_sat_rtz(_X)  __builtin_convert(_X, ushort8, __kRoundTowardZero, __kSaturated )
    #define convert_int8_sat_rtz(_X)     __builtin_convert(_X, int8, __kRoundTowardZero, __kSaturated )
    #define convert_uint8_sat_rtz(_X)    __builtin_convert(_X, uint8, __kRoundTowardZero, __kSaturated )
    #define convert_long8_sat_rtz(_X)    __builtin_convert(_X, long8, __kRoundTowardZero, __kSaturated )
    #define convert_ulong8_sat_rtz(_X)   __builtin_convert(_X, ulong8, __kRoundTowardZero, __kSaturated )
    #define convert_float8_sat_rtz(_X)   __builtin_convert(_X, float8, __kRoundTowardZero, __kSaturated )
    #define convert_double8_sat_rtz(_X)  __builtin_convert(_X, double8, __kRoundTowardZero, __kSaturated )

    //type16
    #define convert_char16(_X)    __builtin_convert(_X, char16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uchar16(_X)   __builtin_convert(_X, uchar16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_short16(_X)   __builtin_convert(_X, short16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ushort16(_X)  __builtin_convert(_X, ushort16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_int16(_X)     __builtin_convert(_X, int16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_uint16(_X)    __builtin_convert(_X, uint16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_long16(_X)    __builtin_convert(_X, long16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_ulong16(_X)   __builtin_convert(_X, ulong16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_float16(_X)   __builtin_convert(_X, float16, __kDefaultRoundingMode, __kUnsaturated )
    #define convert_double16(_X)  __builtin_convert(_X, double16, __kDefaultRoundingMode, __kUnsaturated )

    #define convert_char16_sat(_X)    __builtin_convert(_X, char16, __kDefaultRoundingMode, __kSaturated )
    #define convert_uchar16_sat(_X)   __builtin_convert(_X, uchar16, __kDefaultRoundingMode, __kSaturated )
    #define convert_short16_sat(_X)   __builtin_convert(_X, short16, __kDefaultRoundingMode, __kSaturated )
    #define convert_ushort16_sat(_X)  __builtin_convert(_X, ushort16, __kDefaultRoundingMode, __kSaturated )
    #define convert_int16_sat(_X)     __builtin_convert(_X, int16, __kDefaultRoundingMode, __kSaturated )
    #define convert_uint16_sat(_X)    __builtin_convert(_X, uint16, __kDefaultRoundingMode, __kSaturated )
    #define convert_long16_sat(_X)    __builtin_convert(_X, long16, __kDefaultRoundingMode, __kSaturated )
    #define convert_ulong16_sat(_X)   __builtin_convert(_X, ulong16, __kDefaultRoundingMode, __kSaturated )
    #define convert_float16_sat(_X)   __builtin_convert(_X, float16, __kDefaultRoundingMode, __kSaturated )
    #define convert_double16_sat(_X)  __builtin_convert(_X, double16, __kDefaultRoundingMode, __kSaturated )

    #define convert_char16_rte(_X)    __builtin_convert(_X, char16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uchar16_rte(_X)   __builtin_convert(_X, uchar16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_short16_rte(_X)   __builtin_convert(_X, short16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ushort16_rte(_X)  __builtin_convert(_X, ushort16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_int16_rte(_X)     __builtin_convert(_X, int16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_uint16_rte(_X)    __builtin_convert(_X, uint16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_long16_rte(_X)    __builtin_convert(_X, long16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_ulong16_rte(_X)   __builtin_convert(_X, ulong16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_float16_rte(_X)   __builtin_convert(_X, float16, __kRoundToNearestEven, __kUnsaturated )
    #define convert_double16_rte(_X)  __builtin_convert(_X, double16, __kRoundToNearestEven, __kUnsaturated )

    #define convert_char16_sat_rte(_X)    __builtin_convert(_X, char16, __kRoundToNearestEven, __kSaturated )
    #define convert_uchar16_sat_rte(_X)   __builtin_convert(_X, uchar16, __kRoundToNearestEven, __kSaturated )
    #define convert_short16_sat_rte(_X)   __builtin_convert(_X, short16, __kRoundToNearestEven, __kSaturated )
    #define convert_ushort16_sat_rte(_X)  __builtin_convert(_X, ushort16, __kRoundToNearestEven, __kSaturated )
    #define convert_int16_sat_rte(_X)     __builtin_convert(_X, int16, __kRoundToNearestEven, __kSaturated )
    #define convert_uint16_sat_rte(_X)    __builtin_convert(_X, uint16, __kRoundToNearestEven, __kSaturated )
    #define convert_long16_sat_rte(_X)    __builtin_convert(_X, long16, __kRoundToNearestEven, __kSaturated )
    #define convert_ulong16_sat_rte(_X)   __builtin_convert(_X, ulong16, __kRoundToNearestEven, __kSaturated )
    #define convert_float16_sat_rte(_X)   __builtin_convert(_X, float16, __kRoundToNearestEven, __kSaturated )
    #define convert_double16_sat_rte(_X)  __builtin_convert(_X, double16, __kRoundToNearestEven, __kSaturated )

    #define convert_char16_rtn(_X)    __builtin_convert(_X, char16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uchar16_rtn(_X)   __builtin_convert(_X, uchar16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_short16_rtn(_X)   __builtin_convert(_X, short16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ushort16_rtn(_X)  __builtin_convert(_X, ushort16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_int16_rtn(_X)     __builtin_convert(_X, int16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_uint16_rtn(_X)    __builtin_convert(_X, uint16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_long16_rtn(_X)    __builtin_convert(_X, long16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_ulong16_rtn(_X)   __builtin_convert(_X, ulong16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_float16_rtn(_X)   __builtin_convert(_X, float16, __kRoundTowardNegativeInf, __kUnsaturated )
    #define convert_double16_rtn(_X)  __builtin_convert(_X, double16, __kRoundTowardNegativeInf, __kUnsaturated )

    #define convert_char16_sat_rtn(_X)    __builtin_convert(_X, char16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uchar16_sat_rtn(_X)   __builtin_convert(_X, uchar16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_short16_sat_rtn(_X)   __builtin_convert(_X, short16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ushort16_sat_rtn(_X)  __builtin_convert(_X, ushort16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_int16_sat_rtn(_X)     __builtin_convert(_X, int16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_uint16_sat_rtn(_X)    __builtin_convert(_X, uint16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_long16_sat_rtn(_X)    __builtin_convert(_X, long16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_ulong16_sat_rtn(_X)   __builtin_convert(_X, ulong16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_float16_sat_rtn(_X)   __builtin_convert(_X, float16, __kRoundTowardNegativeInf, __kSaturated )
    #define convert_double16_sat_rtn(_X)  __builtin_convert(_X, double16, __kRoundTowardNegativeInf, __kSaturated )

    #define convert_char16_rtp(_X)    __builtin_convert(_X, char16, __kRoundTowardInf, __kUnsaturated )
    #define convert_uchar16_rtp(_X)   __builtin_convert(_X, uchar16, __kRoundTowardInf, __kUnsaturated )
    #define convert_short16_rtp(_X)   __builtin_convert(_X, short16, __kRoundTowardInf, __kUnsaturated )
    #define convert_ushort16_rtp(_X)  __builtin_convert(_X, ushort16, __kRoundTowardInf, __kUnsaturated )
    #define convert_int16_rtp(_X)     __builtin_convert(_X, int16, __kRoundTowardInf, __kUnsaturated )
    #define convert_uint16_rtp(_X)    __builtin_convert(_X, uint16, __kRoundTowardInf, __kUnsaturated )
    #define convert_long16_rtp(_X)    __builtin_convert(_X, long16, __kRoundTowardInf, __kUnsaturated )
    #define convert_ulong16_rtp(_X)   __builtin_convert(_X, ulong16, __kRoundTowardInf, __kUnsaturated )
    #define convert_float16_rtp(_X)   __builtin_convert(_X, float16, __kRoundTowardInf, __kUnsaturated )
    #define convert_double16_rtp(_X)  __builtin_convert(_X, double16, __kRoundTowardInf, __kUnsaturated )

    #define convert_char16_sat_rtp(_X)    __builtin_convert(_X, char16, __kRoundTowardInf, __kSaturated )
    #define convert_uchar16_sat_rtp(_X)   __builtin_convert(_X, uchar16, __kRoundTowardInf, __kSaturated )
    #define convert_short16_sat_rtp(_X)   __builtin_convert(_X, short16, __kRoundTowardInf, __kSaturated )
    #define convert_ushort16_sat_rtp(_X)  __builtin_convert(_X, ushort16, __kRoundTowardInf, __kSaturated )
    #define convert_int16_sat_rtp(_X)     __builtin_convert(_X, int16, __kRoundTowardInf, __kSaturated )
    #define convert_uint16_sat_rtp(_X)    __builtin_convert(_X, uint16, __kRoundTowardInf, __kSaturated )
    #define convert_long16_sat_rtp(_X)    __builtin_convert(_X, long16, __kRoundTowardInf, __kSaturated )
    #define convert_ulong16_sat_rtp(_X)   __builtin_convert(_X, ulong16, __kRoundTowardInf, __kSaturated )
    #define convert_float16_sat_rtp(_X)   __builtin_convert(_X, float16, __kRoundTowardInf, __kSaturated )
    #define convert_double16_sat_rtp(_X)  __builtin_convert(_X, double16, __kRoundTowardInf, __kSaturated )

    #define convert_char16_rtz(_X)    __builtin_convert(_X, char16, __kRoundTowardZero, __kUnsaturated )
    #define convert_uchar16_rtz(_X)   __builtin_convert(_X, uchar16, __kRoundTowardZero, __kUnsaturated )
    #define convert_short16_rtz(_X)   __builtin_convert(_X, short16, __kRoundTowardZero, __kUnsaturated )
    #define convert_ushort16_rtz(_X)  __builtin_convert(_X, ushort16, __kRoundTowardZero, __kUnsaturated )
    #define convert_int16_rtz(_X)     __builtin_convert(_X, int16, __kRoundTowardZero, __kUnsaturated )
    #define convert_uint16_rtz(_X)    __builtin_convert(_X, uint16, __kRoundTowardZero, __kUnsaturated )
    #define convert_long16_rtz(_X)    __builtin_convert(_X, long16, __kRoundTowardZero, __kUnsaturated )
    #define convert_ulong16_rtz(_X)   __builtin_convert(_X, ulong16, __kRoundTowardZero, __kUnsaturated )
    #define convert_float16_rtz(_X)   __builtin_convert(_X, float16, __kRoundTowardZero, __kUnsaturated )
    #define convert_double16_rtz(_X)  __builtin_convert(_X, double16, __kRoundTowardZero, __kUnsaturated )

    #define convert_char16_sat_rtz(_X)    __builtin_convert(_X, char16, __kRoundTowardZero, __kSaturated )
    #define convert_uchar16_sat_rtz(_X)   __builtin_convert(_X, uchar16, __kRoundTowardZero, __kSaturated )
    #define convert_short16_sat_rtz(_X)   __builtin_convert(_X, short16, __kRoundTowardZero, __kSaturated )
    #define convert_ushort16_sat_rtz(_X)  __builtin_convert(_X, ushort16, __kRoundTowardZero, __kSaturated )
    #define convert_int16_sat_rtz(_X)     __builtin_convert(_X, int16, __kRoundTowardZero, __kSaturated )
    #define convert_uint16_sat_rtz(_X)    __builtin_convert(_X, uint16, __kRoundTowardZero, __kSaturated )
    #define convert_long16_sat_rtz(_X)    __builtin_convert(_X, long16, __kRoundTowardZero, __kSaturated )
    #define convert_ulong16_sat_rtz(_X)   __builtin_convert(_X, ulong16, __kRoundTowardZero, __kSaturated )
    #define convert_float16_sat_rtz(_X)   __builtin_convert(_X, float16, __kRoundTowardZero, __kSaturated )
    #define convert_double16_sat_rtz(_X)  __builtin_convert(_X, double16, __kRoundTowardZero, __kSaturated )


#else

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_CONVERT(name, rtype) rtype __OVERLOAD__ name( uchar a); \
rtype __OVERLOAD__ name( ushort a); \
rtype __OVERLOAD__ name( uint a); \
rtype __OVERLOAD__ name( ulong a); \
rtype __OVERLOAD__ name( char a); \
rtype __OVERLOAD__ name( short a); \
rtype __OVERLOAD__ name( int a); \
rtype __OVERLOAD__ name( long a); \
rtype __OVERLOAD__ name( float a); \
rtype __OVERLOAD__ name( double a); \
rtype##2 __OVERLOAD__ name##2( uchar2 a); \
rtype##2 __OVERLOAD__ name##2( ushort2 a); \
rtype##2 __OVERLOAD__ name##2( uint2 a); \
rtype##2 __OVERLOAD__ name##2( ulong2 a); \
rtype##2 __OVERLOAD__ name##2( char2 a); \
rtype##2 __OVERLOAD__ name##2( short2 a); \
rtype##2 __OVERLOAD__ name##2( int2 a); \
rtype##2 __OVERLOAD__ name##2( long2 a); \
rtype##2 __OVERLOAD__ name##2( float2 a); \
rtype##2 __OVERLOAD__ name##2( double2 a); \
rtype##3 __OVERLOAD__ name##3( uchar3 a); \
rtype##3 __OVERLOAD__ name##3( ushort3 a); \
rtype##3 __OVERLOAD__ name##3( uint3 a); \
rtype##3 __OVERLOAD__ name##3( ulong3 a); \
rtype##3 __OVERLOAD__ name##3( char3 a); \
rtype##3 __OVERLOAD__ name##3( short3 a); \
rtype##3 __OVERLOAD__ name##3( int3 a); \
rtype##3 __OVERLOAD__ name##3( long3 a); \
rtype##3 __OVERLOAD__ name##3( float3 a); \
rtype##3 __OVERLOAD__ name##3( double3 a); \
rtype##4 __OVERLOAD__ name##4( uchar4 a); \
rtype##4 __OVERLOAD__ name##4( ushort4 a); \
rtype##4 __OVERLOAD__ name##4( uint4 a); \
rtype##4 __OVERLOAD__ name##4( ulong4 a); \
rtype##4 __OVERLOAD__ name##4( char4 a); \
rtype##4 __OVERLOAD__ name##4( short4 a); \
rtype##4 __OVERLOAD__ name##4( int4 a); \
rtype##4 __OVERLOAD__ name##4( long4 a); \
rtype##4 __OVERLOAD__ name##4( float4 a); \
rtype##4 __OVERLOAD__ name##4( double4 a); \
rtype##8 __OVERLOAD__ name##8( uchar8 a); \
rtype##8 __OVERLOAD__ name##8( ushort8 a); \
rtype##8 __OVERLOAD__ name##8( uint8 a); \
rtype##8 __OVERLOAD__ name##8( ulong8 a); \
rtype##8 __OVERLOAD__ name##8( char8 a); \
rtype##8 __OVERLOAD__ name##8( short8 a); \
rtype##8 __OVERLOAD__ name##8( int8 a); \
rtype##8 __OVERLOAD__ name##8( long8 a); \
rtype##8 __OVERLOAD__ name##8( float8 a); \
rtype##8 __OVERLOAD__ name##8( double8 a); \
rtype##16 __OVERLOAD__ name##16( uchar16 a); \
rtype##16 __OVERLOAD__ name##16( ushort16 a); \
rtype##16 __OVERLOAD__ name##16( uint16 a); \
rtype##16 __OVERLOAD__ name##16( ulong16 a); \
rtype##16 __OVERLOAD__ name##16( char16 a); \
rtype##16 __OVERLOAD__ name##16( short16 a); \
rtype##16 __OVERLOAD__ name##16( int16 a); \
rtype##16 __OVERLOAD__ name##16( long16 a); \
rtype##16 __OVERLOAD__ name##16( float16 a); \
rtype##16 __OVERLOAD__ name##16( double16 a);
#else
#define __CLFN_CONVERT(name, rtype) rtype __OVERLOAD__ name( uchar a); \
rtype __OVERLOAD__ name( ushort a); \
rtype __OVERLOAD__ name( uint a); \
rtype __OVERLOAD__ name( ulong a); \
rtype __OVERLOAD__ name( char a); \
rtype __OVERLOAD__ name( short a); \
rtype __OVERLOAD__ name( int a); \
rtype __OVERLOAD__ name( long a); \
rtype __OVERLOAD__ name( float a); \
rtype##2 __OVERLOAD__ name##2( uchar2 a); \
rtype##2 __OVERLOAD__ name##2( ushort2 a); \
rtype##2 __OVERLOAD__ name##2( uint2 a); \
rtype##2 __OVERLOAD__ name##2( ulong2 a); \
rtype##2 __OVERLOAD__ name##2( char2 a); \
rtype##2 __OVERLOAD__ name##2( short2 a); \
rtype##2 __OVERLOAD__ name##2( int2 a); \
rtype##2 __OVERLOAD__ name##2( long2 a); \
rtype##2 __OVERLOAD__ name##2( float2 a); \
rtype##3 __OVERLOAD__ name##3( uchar3 a); \
rtype##3 __OVERLOAD__ name##3( ushort3 a); \
rtype##3 __OVERLOAD__ name##3( uint3 a); \
rtype##3 __OVERLOAD__ name##3( ulong3 a); \
rtype##3 __OVERLOAD__ name##3( char3 a); \
rtype##3 __OVERLOAD__ name##3( short3 a); \
rtype##3 __OVERLOAD__ name##3( int3 a); \
rtype##3 __OVERLOAD__ name##3( long3 a); \
rtype##3 __OVERLOAD__ name##3( float3 a); \
rtype##4 __OVERLOAD__ name##4( uchar4 a); \
rtype##4 __OVERLOAD__ name##4( ushort4 a); \
rtype##4 __OVERLOAD__ name##4( uint4 a); \
rtype##4 __OVERLOAD__ name##4( ulong4 a); \
rtype##4 __OVERLOAD__ name##4( char4 a); \
rtype##4 __OVERLOAD__ name##4( short4 a); \
rtype##4 __OVERLOAD__ name##4( int4 a); \
rtype##4 __OVERLOAD__ name##4( long4 a); \
rtype##4 __OVERLOAD__ name##4( float4 a); \
rtype##8 __OVERLOAD__ name##8( uchar8 a); \
rtype##8 __OVERLOAD__ name##8( ushort8 a); \
rtype##8 __OVERLOAD__ name##8( uint8 a); \
rtype##8 __OVERLOAD__ name##8( ulong8 a); \
rtype##8 __OVERLOAD__ name##8( char8 a); \
rtype##8 __OVERLOAD__ name##8( short8 a); \
rtype##8 __OVERLOAD__ name##8( int8 a); \
rtype##8 __OVERLOAD__ name##8( long8 a); \
rtype##8 __OVERLOAD__ name##8( float8 a); \
rtype##16 __OVERLOAD__ name##16( uchar16 a); \
rtype##16 __OVERLOAD__ name##16( ushort16 a); \
rtype##16 __OVERLOAD__ name##16( uint16 a); \
rtype##16 __OVERLOAD__ name##16( ulong16 a); \
rtype##16 __OVERLOAD__ name##16( char16 a); \
rtype##16 __OVERLOAD__ name##16( short16 a); \
rtype##16 __OVERLOAD__ name##16( int16 a); \
rtype##16 __OVERLOAD__ name##16( long16 a); \
rtype##16 __OVERLOAD__ name##16( float16 a);
#endif

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
#define __CLFN_CONVERT_EXT(name, ext, rtype) rtype __OVERLOAD__ name##ext( uchar a); \
rtype __OVERLOAD__ name##ext( ushort a); \
rtype __OVERLOAD__ name##ext( uint a); \
rtype __OVERLOAD__ name##ext( ulong a); \
rtype __OVERLOAD__ name##ext( char a); \
rtype __OVERLOAD__ name##ext( short a); \
rtype __OVERLOAD__ name##ext( int a); \
rtype __OVERLOAD__ name##ext( long a); \
rtype __OVERLOAD__ name##ext( float a); \
rtype __OVERLOAD__ name##ext( double a); \
rtype##2 __OVERLOAD__ name##2##ext( uchar2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ushort2 a); \
rtype##2 __OVERLOAD__ name##2##ext( uint2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ulong2 a); \
rtype##2 __OVERLOAD__ name##2##ext( char2 a); \
rtype##2 __OVERLOAD__ name##2##ext( short2 a); \
rtype##2 __OVERLOAD__ name##2##ext( int2 a); \
rtype##2 __OVERLOAD__ name##2##ext( long2 a); \
rtype##2 __OVERLOAD__ name##2##ext( float2 a); \
rtype##2 __OVERLOAD__ name##2##ext( double2 a); \
rtype##3 __OVERLOAD__ name##3##ext( uchar3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ushort3 a); \
rtype##3 __OVERLOAD__ name##3##ext( uint3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ulong3 a); \
rtype##3 __OVERLOAD__ name##3##ext( char3 a); \
rtype##3 __OVERLOAD__ name##3##ext( short3 a); \
rtype##3 __OVERLOAD__ name##3##ext( int3 a); \
rtype##3 __OVERLOAD__ name##3##ext( long3 a); \
rtype##3 __OVERLOAD__ name##3##ext( float3 a); \
rtype##3 __OVERLOAD__ name##3##ext( double3 a); \
rtype##4 __OVERLOAD__ name##4##ext( uchar4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ushort4 a); \
rtype##4 __OVERLOAD__ name##4##ext( uint4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ulong4 a); \
rtype##4 __OVERLOAD__ name##4##ext( char4 a); \
rtype##4 __OVERLOAD__ name##4##ext( short4 a); \
rtype##4 __OVERLOAD__ name##4##ext( int4 a); \
rtype##4 __OVERLOAD__ name##4##ext( long4 a); \
rtype##4 __OVERLOAD__ name##4##ext( float4 a); \
rtype##4 __OVERLOAD__ name##4##ext( double4 a); \
rtype##8 __OVERLOAD__ name##8##ext( uchar8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ushort8 a); \
rtype##8 __OVERLOAD__ name##8##ext( uint8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ulong8 a); \
rtype##8 __OVERLOAD__ name##8##ext( char8 a); \
rtype##8 __OVERLOAD__ name##8##ext( short8 a); \
rtype##8 __OVERLOAD__ name##8##ext( int8 a); \
rtype##8 __OVERLOAD__ name##8##ext( long8 a); \
rtype##8 __OVERLOAD__ name##8##ext( float8 a); \
rtype##8 __OVERLOAD__ name##8##ext( double8 a); \
rtype##16 __OVERLOAD__ name##16##ext( uchar16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ushort16 a); \
rtype##16 __OVERLOAD__ name##16##ext( uint16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ulong16 a); \
rtype##16 __OVERLOAD__ name##16##ext( char16 a); \
rtype##16 __OVERLOAD__ name##16##ext( short16 a); \
rtype##16 __OVERLOAD__ name##16##ext( int16 a); \
rtype##16 __OVERLOAD__ name##16##ext( long16 a); \
rtype##16 __OVERLOAD__ name##16##ext( float16 a); \
rtype##16 __OVERLOAD__ name##16##ext( double16 a); 
#else
#define __CLFN_CONVERT_EXT(name, ext, rtype) rtype __OVERLOAD__ name##ext( uchar a); \
rtype __OVERLOAD__ name##ext( ushort a); \
rtype __OVERLOAD__ name##ext( uint a); \
rtype __OVERLOAD__ name##ext( ulong a); \
rtype __OVERLOAD__ name##ext( char a); \
rtype __OVERLOAD__ name##ext( short a); \
rtype __OVERLOAD__ name##ext( int a); \
rtype __OVERLOAD__ name##ext( long a); \
rtype __OVERLOAD__ name##ext( float a); \
rtype##2 __OVERLOAD__ name##2##ext( uchar2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ushort2 a); \
rtype##2 __OVERLOAD__ name##2##ext( uint2 a); \
rtype##2 __OVERLOAD__ name##2##ext( ulong2 a); \
rtype##2 __OVERLOAD__ name##2##ext( char2 a); \
rtype##2 __OVERLOAD__ name##2##ext( short2 a); \
rtype##2 __OVERLOAD__ name##2##ext( int2 a); \
rtype##2 __OVERLOAD__ name##2##ext( long2 a); \
rtype##2 __OVERLOAD__ name##2##ext( float2 a); \
rtype##3 __OVERLOAD__ name##3##ext( uchar3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ushort3 a); \
rtype##3 __OVERLOAD__ name##3##ext( uint3 a); \
rtype##3 __OVERLOAD__ name##3##ext( ulong3 a); \
rtype##3 __OVERLOAD__ name##3##ext( char3 a); \
rtype##3 __OVERLOAD__ name##3##ext( short3 a); \
rtype##3 __OVERLOAD__ name##3##ext( int3 a); \
rtype##3 __OVERLOAD__ name##3##ext( long3 a); \
rtype##3 __OVERLOAD__ name##3##ext( float3 a); \
rtype##4 __OVERLOAD__ name##4##ext( uchar4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ushort4 a); \
rtype##4 __OVERLOAD__ name##4##ext( uint4 a); \
rtype##4 __OVERLOAD__ name##4##ext( ulong4 a); \
rtype##4 __OVERLOAD__ name##4##ext( char4 a); \
rtype##4 __OVERLOAD__ name##4##ext( short4 a); \
rtype##4 __OVERLOAD__ name##4##ext( int4 a); \
rtype##4 __OVERLOAD__ name##4##ext( long4 a); \
rtype##4 __OVERLOAD__ name##4##ext( float4 a); \
rtype##8 __OVERLOAD__ name##8##ext( uchar8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ushort8 a); \
rtype##8 __OVERLOAD__ name##8##ext( uint8 a); \
rtype##8 __OVERLOAD__ name##8##ext( ulong8 a); \
rtype##8 __OVERLOAD__ name##8##ext( char8 a); \
rtype##8 __OVERLOAD__ name##8##ext( short8 a); \
rtype##8 __OVERLOAD__ name##8##ext( int8 a); \
rtype##8 __OVERLOAD__ name##8##ext( long8 a); \
rtype##8 __OVERLOAD__ name##8##ext( float8 a); \
rtype##16 __OVERLOAD__ name##16##ext( uchar16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ushort16 a); \
rtype##16 __OVERLOAD__ name##16##ext( uint16 a); \
rtype##16 __OVERLOAD__ name##16##ext( ulong16 a); \
rtype##16 __OVERLOAD__ name##16##ext( char16 a); \
rtype##16 __OVERLOAD__ name##16##ext( short16 a); \
rtype##16 __OVERLOAD__ name##16##ext( int16 a); \
rtype##16 __OVERLOAD__ name##16##ext( long16 a); \
rtype##16 __OVERLOAD__ name##16##ext( float16 a);
#endif


__CLFN_CONVERT_EXT(convert_uchar, _sat_rtz, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rtp, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rtn, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat_rte, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _sat, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtz, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtn, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rtp, uchar);
__CLFN_CONVERT_EXT(convert_uchar, _rte, uchar);
__CLFN_CONVERT(convert_uchar, uchar);

__CLFN_CONVERT(convert_ushort, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rte, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtp, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtn, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _rtz, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rte, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtn, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtp, ushort);
__CLFN_CONVERT_EXT(convert_ushort, _sat_rtz, ushort);

__CLFN_CONVERT(convert_uint, uint);
__CLFN_CONVERT_EXT(convert_uint, _rte, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtp, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtn, uint);
__CLFN_CONVERT_EXT(convert_uint, _rtz, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rte, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtn, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtp, uint);
__CLFN_CONVERT_EXT(convert_uint, _sat_rtz, uint);

__CLFN_CONVERT(convert_ulong, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rte, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtp, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtn, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _rtz, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rte, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtn, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtp, ulong);
__CLFN_CONVERT_EXT(convert_ulong, _sat_rtz, ulong);

__CLFN_CONVERT(convert_char, char);
__CLFN_CONVERT_EXT(convert_char, _rte, char);
__CLFN_CONVERT_EXT(convert_char, _rtp, char);
__CLFN_CONVERT_EXT(convert_char, _rtn, char);
__CLFN_CONVERT_EXT(convert_char, _rtz, char);
__CLFN_CONVERT_EXT(convert_char, _sat, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rte, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtn, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtp, char);
__CLFN_CONVERT_EXT(convert_char, _sat_rtz, char);

__CLFN_CONVERT(convert_short, short);
__CLFN_CONVERT_EXT(convert_short, _rte, short);
__CLFN_CONVERT_EXT(convert_short, _rtp, short);
__CLFN_CONVERT_EXT(convert_short, _rtn, short);
__CLFN_CONVERT_EXT(convert_short, _rtz, short);
__CLFN_CONVERT_EXT(convert_short, _sat, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rte, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtn, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtp, short);
__CLFN_CONVERT_EXT(convert_short, _sat_rtz, short);

__CLFN_CONVERT(convert_int, int);
__CLFN_CONVERT_EXT(convert_int, _rte, int);
__CLFN_CONVERT_EXT(convert_int, _rtp, int);
__CLFN_CONVERT_EXT(convert_int, _rtn, int);
__CLFN_CONVERT_EXT(convert_int, _rtz, int);
__CLFN_CONVERT_EXT(convert_int, _sat, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rte, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtn, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtp, int);
__CLFN_CONVERT_EXT(convert_int, _sat_rtz, int);

__CLFN_CONVERT(convert_long, long);
__CLFN_CONVERT_EXT(convert_long, _rte, long);
__CLFN_CONVERT_EXT(convert_long, _rtp, long);
__CLFN_CONVERT_EXT(convert_long, _rtn, long);
__CLFN_CONVERT_EXT(convert_long, _rtz, long);
__CLFN_CONVERT_EXT(convert_long, _sat, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rte, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtn, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtp, long);
__CLFN_CONVERT_EXT(convert_long, _sat_rtz, long);

__CLFN_CONVERT(convert_float, float);
__CLFN_CONVERT_EXT(convert_float, _rte, float);
__CLFN_CONVERT_EXT(convert_float, _rtp, float);
__CLFN_CONVERT_EXT(convert_float, _rtn, float);
__CLFN_CONVERT_EXT(convert_float, _rtz, float);

#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
__CLFN_CONVERT(convert_double, double);
__CLFN_CONVERT_EXT(convert_double, _rte, double);
__CLFN_CONVERT_EXT(convert_double, _rtp, double);
__CLFN_CONVERT_EXT(convert_double, _rtn, double);
__CLFN_CONVERT_EXT(convert_double, _rtz, double);
#endif

#endif

// 6.2.4.2 as_typen
#define as_char( _x )   __builtin_astype( _x, char )
#define as_uchar( _x )  __builtin_astype( _x, uchar )
#define as_short( _x )  __builtin_astype( _x, short )
#define as_ushort( _x ) __builtin_astype( _x, ushort )
#define as_int( _x )    __builtin_astype( _x, int )
#define as_uint( _x )   __builtin_astype( _x, uint )
#define as_float( _x )  __builtin_astype( _x, float )
#define as_long( _x )   __builtin_astype( _x, long )
#define as_ulong( _x )  __builtin_astype( _x, ulong )
#define as_double( _x ) __builtin_astype( _x, double )

#define as_size_t( _x ) __builtin_astype( _x, size_t )
#define as_intptr_t( _x ) __builtin_astype( _x, intptr_t )
#define as_uintptr_t( _x ) __builtin_astype( _x, uintptr_t )
#define as_ptrdiff_t( _x ) __builtin_astype( _x, ptrdiff_t )

#define as_char2( _x )   __builtin_astype( _x, char2 )
#define as_char3( _x )   __builtin_astype( _x, char3 )
#define as_char4( _x )   __builtin_astype( _x, char4 )
#define as_char8( _x )   __builtin_astype( _x, char8 )
#define as_char16( _x )  __builtin_astype( _x, char16 )

#define as_uchar2( _x )   __builtin_astype( _x, uchar2 )
#define as_uchar3( _x )   __builtin_astype( _x, uchar3 )
#define as_uchar4( _x )   __builtin_astype( _x, uchar4 )
#define as_uchar8( _x )   __builtin_astype( _x, uchar8 )
#define as_uchar16( _x )  __builtin_astype( _x, uchar16 )

#define as_short2( _x )   __builtin_astype( _x, short2 )
#define as_short3( _x )   __builtin_astype( _x, short3 )
#define as_short4( _x )   __builtin_astype( _x, short4 )
#define as_short8( _x )   __builtin_astype( _x, short8 )
#define as_short16( _x )  __builtin_astype( _x, short16 )

#define as_ushort2( _x )   __builtin_astype( _x, ushort2 )
#define as_ushort3( _x )   __builtin_astype( _x, ushort3 )
#define as_ushort4( _x )   __builtin_astype( _x, ushort4 )
#define as_ushort8( _x )   __builtin_astype( _x, ushort8 )
#define as_ushort16( _x )  __builtin_astype( _x, ushort16 )

#define as_int2( _x )   __builtin_astype( _x, int2 )
#define as_int3( _x )   __builtin_astype( _x, int3 )
#define as_int4( _x )   __builtin_astype( _x, int4 )
#define as_int8( _x )   __builtin_astype( _x, int8 )
#define as_int16( _x )  __builtin_astype( _x, int16 )

#define as_uint2( _x )   __builtin_astype( _x, uint2 )
#define as_uint3( _x )   __builtin_astype( _x, uint3 )
#define as_uint4( _x )   __builtin_astype( _x, uint4 )
#define as_uint8( _x )   __builtin_astype( _x, uint8 )
#define as_uint16( _x )  __builtin_astype( _x, uint16 )

#define as_float2( _x )   __builtin_astype( _x, float2 )
#define as_float3( _x )   __builtin_astype( _x, float3 )
#define as_float4( _x )   __builtin_astype( _x, float4 )
#define as_float8( _x )   __builtin_astype( _x, float8 )
#define as_float16( _x )  __builtin_astype( _x, float16 )

#define as_long2( _x )   __builtin_astype( _x, long2 )
#define as_long3( _x )   __builtin_astype( _x, long3 )
#define as_long4( _x )   __builtin_astype( _x, long4 )
#define as_long8( _x )   __builtin_astype( _x, long8 )
#define as_long16( _x )  __builtin_astype( _x, long16 )

#define as_ulong2( _x )   __builtin_astype( _x, ulong2 )
#define as_ulong3( _x )   __builtin_astype( _x, ulong3 )
#define as_ulong4( _x )   __builtin_astype( _x, ulong4 )
#define as_ulong8( _x )   __builtin_astype( _x, ulong8 )
#define as_ulong16( _x )  __builtin_astype( _x, ulong16 )

#define as_double2( _x )   __builtin_astype( _x, double2 )
#define as_double3( _x )   __builtin_astype( _x, double3 )
#define as_double4( _x )   __builtin_astype( _x, double4 )
#define as_double8( _x )   __builtin_astype( _x, double8 )
#define as_double16( _x )  __builtin_astype( _x, double16 )

// 5.6 Image Access Qualifiers
#define __rd __attribute__((annotate("__rd")))  
#define __wr __attribute__((annotate("__wr")))  
#define __read_only __attribute__((annotate("__rd")))  
#define read_only __attribute__((annotate("__rd")))  
#define __write_only __attribute__((annotate("__wr")))  
#define write_only __attribute__((annotate("__wr")))  
#define __read_write __attribute__((annotate("__rw")))  
#define read_write __attribute__((annotate("__rw")))  

// 5.9.1 - Work-item Functions
// These are defined for GPUs by their respective builtin implementations.
uint   get_work_dim(void);
size_t get_global_size(uint dimindx);
size_t get_global_id(uint dimindx);
size_t get_global_offset(uint dimindx);
size_t get_local_size(uint dimindx);
size_t get_local_id (uint dimindx);
size_t get_num_groups(uint dimindx);
size_t get_group_id(uint dimindx);

// 5.9.2 - Math Defines
#define MAXFLOAT ((float)3.40282346638528860e+38)
#define HUGE_VALF __builtin_huge_valf()
#define INFINITY __builtin_inff()
#define NAN __builtin_nanf((const __attribute__((address_space(2))) char *)(""))

/* Section 5.9.2, Table 5.7 */
__CLFN_F_1F(half_cos);
__CLFN_F_2F(half_divide);
__CLFN_F_1F(half_exp);
__CLFN_F_1F(half_exp2);
__CLFN_F_1F(half_exp10);
__CLFN_F_1F(half_log);
__CLFN_F_1F(half_log2);
__CLFN_F_1F(half_log10);
__CLFN_F_2F(half_powr);
__CLFN_F_1F(half_recip);
__CLFN_F_1F(half_rsqrt);
__CLFN_F_1F(half_sin);
__CLFN_F_1F(half_sqrt);
__CLFN_F_1F(half_tan);

__CLFN_FD_1FD(native_cos);
__CLFN_FD_2FD(native_divide);
__CLFN_FD_1FD(native_exp);
__CLFN_FD_1FD(native_exp2);
__CLFN_FD_1FD(native_exp10);
__CLFN_FD_1FD(native_log);
__CLFN_FD_1FD(native_log2);
__CLFN_FD_1FD(native_log10);
__CLFN_FD_2FD(native_powr);
__CLFN_FD_1FD(native_recip);
__CLFN_FD_1FD(native_rsqrt);
__CLFN_FD_1FD(native_sin);
__CLFN_FD_1FD(native_sqrt);
__CLFN_FD_1FD(native_tan);


/* Section 5.9.2, Table 5.6 */
__CLFN_FD_1FD(__cl_acos);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef acos
    #define acos(__x) __cl_acos(__x)
#else
    #warning  __CL_INTERNAL_SKIP_MATH_DEFINES__  defined.   Many builtin definitions will be missing.
#endif

__CLFN_FD_1FD(__cl_acosh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef acosh
    #define acosh(__x) __cl_acosh(__x)
#endif

__CLFN_FD_1FD(acospi); 

__CLFN_FD_1FD(__cl_asin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef asin
    #define asin(__x) __cl_asin(__x)
#endif

__CLFN_FD_1FD(__cl_asinh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef asinh
    #define asinh(__x) __cl_asinh(__x)
#endif

__CLFN_FD_1FD(asinpi); 

__CLFN_FD_1FD(__cl_atan); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atan
    #define atan(__x) __cl_atan(__x)
#endif

__CLFN_FD_1FD(__cl_atanh); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atanh
    #define atanh(__x) __cl_atanh(__x)
#endif

__CLFN_FD_1FD(atanpi);

__CLFN_FD_2FD(__cl_atan2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef atan2
    #define atan2(__x, __y) __cl_atan2(__x, __y)
#endif

__CLFN_FD_2FD(atan2pi);

__CLFN_FD_1FD(__cl_cbrt);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef cbrt
    #define cbrt(__x) __cl_cbrt(__x)
#endif

__CLFN_FD_1FD(__cl_ceil);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ceil
    #define ceil(__x) __cl_ceil(__x)
#endif

__CLFN_FD_2FD(__cl_copysign);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef copysign
    #define copysign(__x, __y) __cl_copysign(__x, __y)
#endif

__CLFN_FD_1FD(__cl_cosh); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef cosh
    #define cosh(__x) __cl_cosh(__x)
#endif

__CLFN_FD_1FD(cospi); 

__CLFN_FD_1FD(__cl_erf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef erf
    #define erf(__x) __cl_erf(__x)
#endif

__CLFN_FD_1FD(__cl_erfc);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef erfc
    #define erfc(__x) __cl_erfc(__x)
#endif

__CLFN_FD_1FD(__cl_exp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp, native_exp, __cl_exp);
    #undef exp
    #define exp(__x) __fast_relax_exp(__x)
#endif

__CLFN_FD_1FD(__cl_exp2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp2, native_exp2, __cl_exp2);
    #undef exp2
    #define exp2(__x) __fast_relax_exp2(__x)
#endif

__CLFN_FD_1FD(__cl_exp10); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_exp10, native_exp10, __cl_exp10);
    #undef exp10
    #define exp10(__x) __fast_relax_exp10(__x)
#endif

__CLFN_FD_1FD(asinpi);

__CLFN_FD_1FD(__cl_expm1);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef expm1
    #define expm1(__x) __cl_expm1(__x)
#endif

__CLFN_FD_1FD(__cl_fabs);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fabs
    #define fabs(__x) __cl_fabs(__x)
#endif

__CLFN_FD_2FD(__cl_fdim);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fdim
    #define fdim(__x, __y) __cl_fdim(__x, __y)
#endif

__CLFN_FD_1FD(__cl_floor);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef floor
    #define floor(__x) __cl_floor(__x)
#endif

__CLFN_FD_3FD(__cl_fma);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fma
    #define fma(__x, __y, __z) __cl_fma(__x, __y, __z)
#endif

__CLFN_FD_2FD(__cl_fmax);
__CLFN_FD_2FD_EXT(__cl_fmax);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmax
    #define fmax(__x, __y) __cl_fmax(__x, __y)
#endif

__CLFN_FD_2FD(__cl_fmin);
__CLFN_FD_2FD_EXT(__cl_fmin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmin
    #define fmin(__x, __y) __cl_fmin(__x, __y)
#endif

__CLFN_FD_2FD(__cl_fmod);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef fmod
    #define fmod(__x, __y) __cl_fmod(__x, __y)
#endif

                                            
__CLFN_FD_1FD_1PFD(fract);

__CLFN_FD_1FD_1PI(__cl_frexp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef frexp
    #define frexp(__x, __y) __cl_frexp(__x, __y)
#endif

__CLFN_FD_2FD(__cl_hypot);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef hypot
    #define hypot(__x, __y) __cl_hypot(__x, __y)
#endif

__CLFN_I_1FD(__cl_ilogb);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ilogb
    #define ilogb(__x) __cl_ilogb(__x)
#endif

__CLFN_FD_1FD_1I(__cl_ldexp);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef ldexp
    #define ldexp(__x, __y) __cl_ldexp(__x, __y)
#endif

__CLFN_FD_1FD(__cl_lgamma); 
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef lgamma
    #define lgamma(__x) __cl_lgamma(__x)
#endif

__CLFN_FD_1FD_1PI(__cl_lgamma_r);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef lgamma_r
    #define lgamma_r(__x, __y) __cl_lgamma_r(__x, __y)
#endif

__CLFN_FD_1FD(__cl_log);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_log, native_log, __cl_log);
    #undef log
    #define log(__x) __fast_relax_log(__x)
#endif

__CLFN_FD_1FD(__cl_log10);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_log10, native_log10, __cl_log10);
    #undef log10
    #define log10(__x) __cl_log10(__x)
#endif

__CLFN_FD_1FD(__cl_log1p);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef log1p
    #define log1p(__x) __cl_log1p(__x)
#endif

__CLFN_FD_1FD(__cl_log2);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef log2
    #define log2(__x) __cl_log2(__x)
#endif

__CLFN_FD_1FD(__cl_logb);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef logb
    #define logb(__x) __cl_logb(__x)
#endif

__CLFN_FD_3FD(mad);
__CLFN_FD_2FD(maxmag);
__CLFN_FD_2FD(minmag);

__CLFN_FD_1FD_1PFD(__cl_modf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef modf
    #define modf(__x, __y) __cl_modf(__x, __y)
#endif


__CLFN_FD_1UIL(__cl_nan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef nan
    #define nan(__x) __cl_nan(__x)
#endif

__CLFN_FD_2FD(__cl_nextafter);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef nextafter
    #define nextafter(__x, __y) __cl_nextafter(__x, __y)
#endif

__CLFN_FD_2FD(__cl_pow);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef pow
    #define pow(__x, __y) __cl_pow(__x, __y)
#endif

__CLFN_FD_1FD_1I(__cl_pown);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef pown
    #define pown(__x, __y) __cl_pown(__x, __y)
#endif

__CLFN_FD_2FD(__cl_powr);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
   __CLFN_FD_2FD_FAST_RELAX(__fast_relax_powr, native_powr, __cl_powr);
    #undef powr
    #define powr(__x, __y) __cl_powr(__x, __y)
#endif

__CLFN_FD_2FD(__cl_remainder);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef remainder
    #define remainder(__x, __y) __cl_remainder(__x, __y)
#endif

__CLFN_FD_2FD_1PI(__cl_remquo);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef remquo
    #define remquo(__x, __y, __z) __cl_remquo(__x, __y, __z)
#endif

__CLFN_FD_1FD(__cl_rint);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef rint
    #define rint(__x) __cl_rint(__x)
#endif

__CLFN_FD_1FD_1I(rootn);

__CLFN_FD_1FD(__cl_round);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef round
    #define round(__x) __cl_round(__x)
#endif

__CLFN_FD_1FD(rsqrt);


__CLFN_FD_1FD(__cl_cos);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_cos, native_cos, __cl_cos);
    #undef cos
    #define cos(__x) __fast_relax_cos(__x)
#endif

__CLFN_FD_1FD(__cl_sin);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_sin, native_sin, __cl_sin);
    #undef sin
    #define sin(__x) __fast_relax_sin(__x)
#endif

__CLFN_FD_1FD(__cl_tan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    __CLFN_FD_1FD_FAST_RELAX(__fast_relax_tan, native_tan, __cl_tan);
    #undef tan
    #define tan(__x) __fast_relax_tan(__x)
#endif

__CLFN_FD_1FD_1PFD(sincos);

__CLFN_FD_1FD(__cl_sinh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef sinh
    #define sinh(__x) __cl_sinh(__x)
#endif

__CLFN_FD_1FD(sinpi);

__CLFN_FD_1FD(__cl_sqrt);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef sqrt
    #define sqrt(__x) __cl_sqrt(__x)
#endif


__CLFN_FD_1FD(__cl_tanh);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef tanh
    #define tanh(__x) __cl_tanh(__x)
#endif

__CLFN_FD_1FD(tanpi);          

__CLFN_FD_1FD(__cl_tgamma);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef tgamma
    #define tgamma(__x) __cl_tgamma(__x)
#endif

__CLFN_FD_1FD(__cl_trunc);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef trunc
    #define trunc(__x) __cl_trunc(__x)
#endif

/* Section 5.9.3 */
                                             
__CLFN_UCSIL_1CSIL(__cl_abs);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef abs
    #define abs(__x) __cl_abs(__x)
#endif

__CLFN_UCSIL_2CSIL(abs_diff);
__CLFN_ALL(add_sat);

/* upsample */
short __OVERLOAD_INLINE__ upsample(char ahi, uchar alo);
short2 __OVERLOAD_INLINE__ upsample(char2 ahi, uchar2 alo);
short4 __OVERLOAD_INLINE__ upsample(char4 ahi, uchar4 alo);
short3 __OVERLOAD_INLINE__ upsample(char3 ahi, uchar3 alo);
short8 __OVERLOAD_INLINE__ upsample(char8 ahi, uchar8 alo);
short16 __OVERLOAD_INLINE__ upsample(char16 ahi, uchar16 alo);
ushort __OVERLOAD_INLINE__ upsample(uchar ahi, uchar alo);
ushort2 __OVERLOAD_INLINE__ upsample(uchar2 ahi, uchar2 alo);
ushort3 __OVERLOAD_INLINE__ upsample(uchar3 ahi, uchar3 alo);
ushort4 __OVERLOAD_INLINE__ upsample(uchar4 ahi, uchar4 alo);
ushort8 __OVERLOAD_INLINE__ upsample(uchar8 ahi, uchar8 alo);
ushort16 __OVERLOAD_INLINE__ upsample(uchar16 ahi, uchar16 alo);
int __OVERLOAD_INLINE__ upsample(short ahi, ushort alo);
int2 __OVERLOAD_INLINE__ upsample(short2 ahi, ushort2 alo);
int4 __OVERLOAD_INLINE__ upsample(short4 ahi, ushort4 alo);
int3 __OVERLOAD_INLINE__ upsample(short3 ahi, ushort3 alo);
int8 __OVERLOAD_INLINE__ upsample(short8 ahi, ushort8 alo);
int16 __OVERLOAD_INLINE__ upsample(short16 ahi, ushort16 alo);
uint __OVERLOAD_INLINE__ upsample(ushort ahi, ushort alo);
uint2 __OVERLOAD_INLINE__ upsample(ushort2 ahi, ushort2 alo);
uint3 __OVERLOAD_INLINE__ upsample(ushort3 ahi, ushort3 alo);
uint4 __OVERLOAD_INLINE__ upsample(ushort4 ahi, ushort4 alo);
uint8 __OVERLOAD_INLINE__ upsample(ushort8 ahi, ushort8 alo);
uint16 __OVERLOAD_INLINE__ upsample(ushort16 ahi, ushort16 alo);
long __OVERLOAD_INLINE__ upsample(int ahi, uint alo);
long2 __OVERLOAD_INLINE__ upsample(int2 ahi, uint2 alo); 
long3 __OVERLOAD_INLINE__ upsample(int3 ahi, uint3 alo);
long4 __OVERLOAD_INLINE__ upsample(int4 ahi, uint4 alo);
long8 __OVERLOAD_INLINE__ upsample(int8 ahi, uint8 alo);
long16 __OVERLOAD_INLINE__ upsample(int16 ahi, uint16 alo);
ulong __OVERLOAD_INLINE__ upsample(uint ahi, uint alo);
ulong2 __OVERLOAD_INLINE__ upsample(uint2 ahi, uint2 alo); 
ulong3 __OVERLOAD_INLINE__ upsample(uint3 ahi3, uint3 alo3); 
ulong4 __OVERLOAD_INLINE__ upsample(uint4 ahi, uint4 alo); 
ulong8 __OVERLOAD_INLINE__ upsample(uint8 ahi, uint8 alo);
ulong16 __OVERLOAD_INLINE__ upsample(uint16 ahi, uint16 alo);

__CLFN_ALL(hadd);
__CLFN_ALL(rhadd);
__CLFN_CSIL_1CSIL(clz);
__CLFN_CSIL_1CSIL(popcount);
__CLFN_I3(mad_hi);
__CLFN_I3(mad_hi_sat);
__CLFN_I3(mad_sat);

__CLFN_ALL(max);
__CLFN_ALL_MODD(max);
__CLFN_FD_2FD(max);

__CLFN_ALL(min);
__CLFN_ALL_MODD(min);
__CLFN_FD_2FD(min);

__CLFN_I_3CSIL(msum);
__CLFN_ALL(rotate);
__CLFN_ALL(mul_hi);
__CLFN_ALL(sub_sat);

__CLFN_I_3I(mad24);
__CLFN_I_2I(mul24);

/* Section 5.9.4 */
float __OVERLOAD__ clamp(float x, float minval, float maxval);
float2 __OVERLOAD__ clamp(float2 x, float2 minval, float2 maxval);
float3 __OVERLOAD__ clamp(float3 x, float3 minval, float3 maxval);
float4 __OVERLOAD__ clamp(float4 x, float4 minval, float4 maxval);
float8 __OVERLOAD__ clamp( float8 x, float8 minval, float8 maxval );
float16 __OVERLOAD__ clamp( float16 x, float16 minval, float16 maxval );
#if 0
float2 __OVERLOAD__ clamp(float2 x, float minval, float maxval);
float3 __OVERLOAD__ clamp(float3 x, float minval, float maxval);
float4 __OVERLOAD__ clamp(float4 x, float minval, float maxval);
float8 __OVERLOAD__ clamp(float8 x, float minval, float maxval);
float16 __OVERLOAD__ clamp(float16 x, float minval, float maxval);
double2 __OVERLOAD__ clamp(double2 x, double minval, double maxval);
double3 __OVERLOAD__ clamp(double3 x, double minval, double maxval);
double4 __OVERLOAD__ clamp(double4 x, double minval, double maxval);
double8 __OVERLOAD__ clamp(double8 x, double minval, double maxval);
double16 __OVERLOAD__ clamp(double16 x, double minval, double maxval);
#endif
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ clamp(double x, double minval, double maxval);
#endif
double2 __OVERLOAD__ clamp(double2 x, double2 minval, double2 maxval);
double3 __OVERLOAD__ clamp(double3 x, double3 minval, double3 maxval);
double4 __OVERLOAD__ clamp(double4 x, double4 minval, double4 maxval);
double8 __OVERLOAD__ clamp( double8 x, double8 minval, double8 maxval );
double16 __OVERLOAD__ clamp( double16 x, double16 minval, double16 maxval );
char __OVERLOAD__ clamp( char x, char min, char max );
short __OVERLOAD__ clamp( short x, short min, short max );
int __OVERLOAD__ clamp( int x, int min, int max );
long __OVERLOAD__ clamp( long x, long min, long max );
uchar __OVERLOAD__ clamp( uchar x, uchar min, uchar max );
ushort __OVERLOAD__ clamp( ushort x, ushort min, ushort max );
uint __OVERLOAD__ clamp( uint x, uint min, uint max );
ulong __OVERLOAD__ clamp( ulong x, ulong min, ulong max );
char2 __OVERLOAD__ clamp( char2 x, char2 min, char2 max );
short2 __OVERLOAD__ clamp( short2 x, short2 min, short2 max );
int2 __OVERLOAD__ clamp( int2 x, int2 min, int2 max );
long2 __OVERLOAD__ clamp( long2 x, long2 min, long2 max );
uchar2 __OVERLOAD__ clamp( uchar2 x, uchar2 min, uchar2 max );
ushort2 __OVERLOAD__ clamp( ushort2 x, ushort2 min, ushort2 max );
uint2 __OVERLOAD__ clamp( uint2 x, uint2 min, uint2 max );
ulong2 __OVERLOAD__ clamp( ulong2 x, ulong2 min, ulong2 max );
char3 __OVERLOAD__ clamp( char3 x, char3 min, char3 max );
short3 __OVERLOAD__ clamp( short3 x, short3 min, short3 max );
int3 __OVERLOAD__ clamp( int3 x3, int3 min3, int3 max3 );
long3 __OVERLOAD__ clamp( long3 x3, long3 min3, long3 max3 );
uchar3 __OVERLOAD__ clamp( uchar3 x, uchar3 min, uchar3 max );
ushort3 __OVERLOAD__ clamp( ushort3 x, ushort3 min, ushort3 max );
uint3 __OVERLOAD__ clamp( uint3 x3, uint3 min3, uint3 max3 );
ulong3 __OVERLOAD__ clamp( ulong3 x3, ulong3 min3, ulong3 max3 );
char4 __OVERLOAD__ clamp( char4 x, char4 min, char4 max );
short4 __OVERLOAD__ clamp( short4 x, short4 min, short4 max );
int4 __OVERLOAD__ clamp( int4 x, int4 min, int4 max );
long4 __OVERLOAD__ clamp( long4 x, long4 min, long4 max );
uchar4 __OVERLOAD__ clamp( uchar4 x, uchar4 min, uchar4 max );
ushort4 __OVERLOAD__ clamp( ushort4 x, ushort4 min, ushort4 max );
uint4 __OVERLOAD__ clamp( uint4 x, uint4 min, uint4 max );
ulong4 __OVERLOAD__ clamp( ulong4 x, ulong4 min, ulong4 max );
char8 __OVERLOAD__ clamp( char8 x, char8 min, char8 max );
short8 __OVERLOAD__ clamp( short8 x, short8 min, short8 max );
int8 __OVERLOAD__ clamp( int8 x, int8 min, int8 max );
long8 __OVERLOAD__ clamp( long8 x, long8 min, long8 max );
uchar8 __OVERLOAD__ clamp( uchar8 x, uchar8 min, uchar8 max );
ushort8 __OVERLOAD__ clamp( ushort8 x, ushort8 min, ushort8 max );
uint8 __OVERLOAD__ clamp( uint8 x, uint8 min, uint8 max );
ulong8 __OVERLOAD__ clamp( ulong8 x, ulong8 min, ulong8 max );
char16 __OVERLOAD__ clamp( char16 x, char16 min, char16 max );
short16 __OVERLOAD__ clamp( short16 x, short16 min, short16 max );
int16 __OVERLOAD__ clamp( int16 x, int16 min, int16 max );
long16 __OVERLOAD__ clamp( long16 x, long16 min, long16 max );
ushort16 __OVERLOAD__ clamp( ushort16 x, ushort16 min, ushort16 max );
uchar16 __OVERLOAD__ clamp( uchar16 x, uchar16 min, uchar16 max );
uint16 __OVERLOAD__ clamp( uint16 x, uint16 min, uint16 max );
ulong16 __OVERLOAD__ clamp( ulong16 x, ulong16 min, ulong16 max );
char2 __OVERLOAD__ clamp( char2 x,  char y, char z );
char3 __OVERLOAD__ clamp( char3 x,  char y, char z );
char4 __OVERLOAD__ clamp( char4 x,  char y, char z );
char8 __OVERLOAD__ clamp( char8 x,  char y, char z );
char16 __OVERLOAD__ clamp( char16 x, char y, char z );
uchar2 __OVERLOAD__ clamp( uchar2 x,  uchar y, uchar z );
uchar3 __OVERLOAD__ clamp( uchar3 x,  uchar y, uchar z );
uchar4 __OVERLOAD__ clamp( uchar4 x,  uchar y, uchar z );
uchar8 __OVERLOAD__ clamp( uchar8 x,  uchar y, uchar z );
uchar16 __OVERLOAD__ clamp( uchar16 x, uchar y, uchar z );
short2 __OVERLOAD__ clamp( short2 x,  short y, short z );
short3 __OVERLOAD__ clamp( short3 x,  short y, short z );
short4 __OVERLOAD__ clamp( short4 x,  short y, short z );
short8 __OVERLOAD__ clamp( short8 x,  short y, short z );
short16 __OVERLOAD__ clamp( short16 x, short y, short z );
ushort2 __OVERLOAD__ clamp( ushort2 x,  ushort y, ushort z );
ushort3 __OVERLOAD__ clamp( ushort3 x,  ushort y, ushort z );
ushort4 __OVERLOAD__ clamp( ushort4 x,  ushort y, ushort z );
ushort8 __OVERLOAD__ clamp( ushort8 x,  ushort y, ushort z );
ushort16 __OVERLOAD__ clamp( ushort16 x, ushort y, ushort z );
int2 __OVERLOAD__ clamp( int2 x,  int y, int z );
int3 __OVERLOAD__ clamp( int3 x,  int y, int z );
int4 __OVERLOAD__ clamp( int4 x,  int y, int z );
int8 __OVERLOAD__ clamp( int8 x,  int y, int z );
int16 __OVERLOAD__ clamp( int16 x, int y, int z );
uint2 __OVERLOAD__ clamp( uint2 x,  uint y, uint z );
uint3 __OVERLOAD__ clamp( uint3 x,  uint y, uint z );
uint4 __OVERLOAD__ clamp( uint4 x,  uint y, uint z );
uint8 __OVERLOAD__ clamp( uint8 x,  uint y, uint z );
uint16 __OVERLOAD__ clamp( uint16 x, uint y, uint z );
long2 __OVERLOAD__ clamp( long2 x,  long y, long z );
long3 __OVERLOAD__ clamp( long3 x,  long y, long z );
long4 __OVERLOAD__ clamp( long4 x,  long y, long z );
long8 __OVERLOAD__ clamp( long8 x,  long y, long z );
long16 __OVERLOAD__ clamp( long16 x, long y, long z );
ulong2 __OVERLOAD__ clamp( ulong2 x,  ulong y, ulong z );
ulong3 __OVERLOAD__ clamp( ulong3 x,  ulong y, ulong z );
ulong4 __OVERLOAD__ clamp( ulong4 x,  ulong y, ulong z );
ulong8 __OVERLOAD__ clamp( ulong8 x,  ulong y, ulong z );
ulong16 __OVERLOAD__ clamp( ulong16 x, ulong y, ulong z );
float2 __OVERLOAD__ clamp(float2 x, float minval, float maxval);
float3 __OVERLOAD__ clamp(float3 x, float minval, float maxval);
float4 __OVERLOAD__ clamp(float4 x, float minval, float maxval);
float8 __OVERLOAD__ clamp(float8 x, float minval, float maxval);
float16 __OVERLOAD__ clamp(float16 x, float minval, float maxval);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ clamp(double2 x, double minval, double maxval);
double3 __OVERLOAD__ clamp(double3 x, double minval, double maxval);
double4 __OVERLOAD__ clamp(double4 x, double minval, double maxval);
double8 __OVERLOAD__ clamp(double8 x, double minval, double maxval);
double16 __OVERLOAD__ clamp(double16 x, double minval, double maxval);
#endif


__CLFN_FD_1FD(degrees);

__CLFN_1FD_2FD_MODD(distance);
__CLFN_1FD_2FD_MODD(dot);

float3 __OVERLOAD__ cross(float3 x, float3 y);
float4 __OVERLOAD__ cross(float4 x, float4 y);
double3 __OVERLOAD__ cross(double3 x, double3 y); \
double4 __OVERLOAD__ cross(double4 x, double4 y); \

__CLFN_FD_1FD_MODD(length);
__CLFN_FD_3FD(mix);
__CLFN_FD_3FD_MOD(mix);
__CLFN_FD_1FD_MODD4(normalize);
__CLFN_FD_1FD(radians);

__CLFN_FD_2FD(step);
float2 __OVERLOAD__ step(float edge, float2 x);
float3 __OVERLOAD__ step(float edge, float3 x);
float4 __OVERLOAD__ step(float edge, float4 x);
float8 __OVERLOAD__ step(float edge, float8 x);
float16 __OVERLOAD__ step(float edge, float16 x);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ step(double edge, double2 x);
double3 __OVERLOAD__ step(double edge, double3 x);
double4 __OVERLOAD__ step(double edge, double4 x);
double8 __OVERLOAD__ step(double edge, double8 x);
double16 __OVERLOAD__ step(double edge, double16 x);
#endif

__CLFN_FD_3FD(smoothstep);
float2 __OVERLOAD__ smoothstep( float edge0, float edge1, float2 x );
float3 __OVERLOAD__ smoothstep( float edge0, float edge1, float3 x );
float4 __OVERLOAD__ smoothstep( float edge0, float edge1, float4 x );
float8 __OVERLOAD__ smoothstep( float edge0, float edge1, float8 x );
float16 __OVERLOAD__ smoothstep( float edge0, float edge1, float16 x );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double2 __OVERLOAD__ smoothstep( double e0, double e1, double2 x );
double3 __OVERLOAD__ smoothstep( double e0, double e1, double3 x );
double4 __OVERLOAD__ smoothstep( double e0, double e1, double4 x );
double8 __OVERLOAD__ smoothstep( double e0, double e1, double8 x );
double16 __OVERLOAD__ smoothstep( double e0, double e1, double16 x );
#endif
__CLFN_FD_1FD(sign);
        
__CLFN_1F_2F_MODD(fast_distance);
__CLFN_F_1F_MODD4(fast_length);
__CLFN_F_1F(fast_normalize);

/* Section 5.9.5 */
#define isless(X,Y)             ((X) <  (Y))
#define islessequal(X,Y)        ((X) <= (Y))
#define isgreater(X,Y)          ((X) >  (Y))
#define isgreaterequal(X,Y)     ((X) >= (Y))
#define isequal(X,Y)            ((X) == (Y))
#define isnotequal(X,Y)         ((X) != (Y))

__CLFN_IL_2FD(__cl_islessgreater);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef islessgreater
    #define islessgreater(__x, __y) __cl_islessgreater(__x, __y)
#endif

__CLFN_IL_1FD_MODD(__cl_isfinite);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isfinite
    #define isfinite(__x) __cl_isfinite(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isinf);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isinf
    #define isinf(__x) __cl_isinf(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isnan);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isnan
    #define isnan(__x) __cl_isnan(__x)
#endif

__CLFN_IL_1FD_MODD(__cl_isnormal);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isnormal
    #define isnormal(__x) __cl_isnormal(__x)
#endif

__CLFN_IL_2FD(isordered);

__CLFN_IL_2FD(__cl_isunordered);
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef isunordered
    #define isunordered(__x, __y) __cl_isunordered(__x, __y)
#endif

int __OVERLOAD__ __cl_signbit( float x );
int2 __OVERLOAD__ __cl_signbit( float2 x );
int3 __OVERLOAD__ __cl_signbit( float3 x );
int4 __OVERLOAD__ __cl_signbit( float4 x );
int8 __OVERLOAD__ __cl_signbit( float8 x );
int16 __OVERLOAD__ __cl_signbit( float16 x );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
int __OVERLOAD__ __cl_signbit( double x );
#endif
long2 __OVERLOAD__ __cl_signbit( double2 x );
long3 __OVERLOAD__ __cl_signbit( double3 x );
long4 __OVERLOAD__ __cl_signbit( double4 x );
long8 __OVERLOAD__ __cl_signbit( double8 x );
long16 __OVERLOAD__ __cl_signbit( double16 x );
#ifndef __CL_INTERNAL_SKIP_MATH_DEFINES__
    #undef signbit
    #define signbit(__x) __cl_signbit(__x)
#endif

__CLFN_I_ALL(any);
__CLFN_I_ALL(all);

char __OVERLOAD__ select( char x, char y, char m );
uchar __OVERLOAD__ select( uchar x, uchar y, char m );
short __OVERLOAD__ select( short x, short y, short m );
ushort __OVERLOAD__ select( ushort x, ushort y, short m );
int __OVERLOAD__ select( int x, int y, int m );
uint __OVERLOAD__ select( uint x, uint y, int m );
long __OVERLOAD__ select( long x, long y, long m );
ulong __OVERLOAD__ select( ulong x, ulong y, long m );
char __OVERLOAD__ select( char x, char y, uchar m );
uchar __OVERLOAD__ select( uchar x, uchar y, uchar m );
short __OVERLOAD__ select( short x, short y, ushort m );
ushort __OVERLOAD__ select( ushort x, ushort y, ushort m );
int __OVERLOAD__ select( int x, int y, uint m );
uint __OVERLOAD__ select( uint x, uint y, uint m );
long __OVERLOAD__ select( long x, long y, ulong m );
ulong __OVERLOAD__ select( ulong x, ulong y, ulong m );
float __OVERLOAD__ select( float x, float y, int m );
float __OVERLOAD__ select( float x, float y, uint m );
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ select( double x, double y, long m );
double __OVERLOAD__ select( double x, double y, ulong m );
#endif
char2 __OVERLOAD__ select( char2 x, char2 y, char2 m );
char3 __OVERLOAD__ select( char3 x, char3 y, char3 m );
char4 __OVERLOAD__ select( char4 x, char4 y, char4 m );
char8 __OVERLOAD__ select( char8 x, char8 y, char8 m );
char16 __OVERLOAD__ select( char16 vx, char16 vy, char16 vm );
uchar2 __OVERLOAD__ select( uchar2 x, uchar2 y, char2 m );
uchar3 __OVERLOAD__ select( uchar3 x, uchar3 y, char3 m );
uchar4 __OVERLOAD__ select( uchar4 x, uchar4 y, char4 m );
uchar8 __OVERLOAD__ select( uchar8 x, uchar8 y, char8 m );
uchar16 __OVERLOAD__ select( uchar16 vx, uchar16 vy, char16 vm );
char2 __OVERLOAD__ select( char2 x, char2 y, uchar2 m );
char3 __OVERLOAD__ select( char3 x, char3 y, uchar3 m );
char4 __OVERLOAD__ select( char4 x, char4 y, uchar4 m );
char8 __OVERLOAD__ select( char8 x, char8 y, uchar8 m );
char16 __OVERLOAD__ select( char16 x, char16 y, uchar16 m );
uchar2 __OVERLOAD__ select( uchar2 x, uchar2 y, uchar2 m );
uchar3 __OVERLOAD__ select( uchar3 x, uchar3 y, uchar3 m );
uchar4 __OVERLOAD__ select( uchar4 x, uchar4 y, uchar4 m );
uchar8 __OVERLOAD__ select( uchar8 x, uchar8 y, uchar8 m );
uchar16 __OVERLOAD__ select( uchar16 x, uchar16 y, uchar16 m );
short2 __OVERLOAD__ select( short2 x, short2 y, short2 m );
short3 __OVERLOAD__ select( short3 x, short3 y, short3 m );
short4 __OVERLOAD__ select( short4 x, short4 y, short4 m );
short8 __OVERLOAD__ select( short8 vx, short8 vy, short8 vm );
short16 __OVERLOAD__ select( short16 vx, short16 vy, short16 vm );
ushort2 __OVERLOAD__ select( ushort2 x, ushort2 y, short2 m );
ushort3 __OVERLOAD__ select( ushort3 x, ushort3 y, short3 m );
ushort4 __OVERLOAD__ select( ushort4 x, ushort4 y, short4 m );
ushort8 __OVERLOAD__ select( ushort8 vx, ushort8 vy, short8 vm );
ushort16 __OVERLOAD__ select( ushort16 vx, ushort16 vy, short16 vm );
short2 __OVERLOAD__ select( short2 x, short2 y, ushort2 m );
short3 __OVERLOAD__ select( short3 x, short3 y, ushort3 m );
short4 __OVERLOAD__ select( short4 x, short4 y, ushort4 m );
short8 __OVERLOAD__ select( short8 x, short8 y, ushort8 m );
short16 __OVERLOAD__ select( short16 x, short16 y, ushort16 m );
ushort2 __OVERLOAD__ select( ushort2 x, ushort2 y, ushort2 m );
ushort3 __OVERLOAD__ select( ushort3 x, ushort3 y, ushort3 m );
ushort4 __OVERLOAD__ select( ushort4 x, ushort4 y, ushort4 m );
ushort8 __OVERLOAD__ select( ushort8 x, ushort8 y, ushort8 m );
ushort16 __OVERLOAD__ select( ushort16 x, ushort16 y, ushort16 m );
int2 __OVERLOAD__ select( int2 x, int2 y, int2 m );
int3 __OVERLOAD__ select( int3 x, int3 y, int3 m );
int4 __OVERLOAD__ select( int4 vx, int4 vy, int4 vm );
int8 __OVERLOAD__ select( int8 vx, int8 vy, int8 vm );
int16 __OVERLOAD__ select( int16 vx, int16 vy, int16 vm );
uint2 __OVERLOAD__ select( uint2 x, uint2 y, int2 m );
uint3 __OVERLOAD__ select( uint3 x, uint3 y, int3 m );
uint4 __OVERLOAD__ select( uint4 x, uint4 y, int4 m );
uint8 __OVERLOAD__ select( uint8 x, uint8 y, int8 m );
uint16 __OVERLOAD__ select( uint16 x, uint16 y, int16 m );
int2 __OVERLOAD__ select( int2 x, int2 y, uint2 m );
int3 __OVERLOAD__ select( int3 x, int3 y, uint3 m );
int4 __OVERLOAD__ select( int4 x, int4 y, uint4 m );
int8 __OVERLOAD__ select( int8 x, int8 y, uint8 m );
int16 __OVERLOAD__ select( int16 x, int16 y, uint16 m );
uint2 __OVERLOAD__ select( uint2 x, uint2 y, uint2 m );
uint3 __OVERLOAD__ select( uint3 x, uint3 y, uint3 m );
uint4 __OVERLOAD__ select( uint4 x, uint4 y, uint4 m );
uint8 __OVERLOAD__ select( uint8 x, uint8 y, uint8 m );
uint16 __OVERLOAD__ select( uint16 x, uint16 y, uint16 m );
long2 __OVERLOAD__ select( long2 x, long2 y, long2 m );
long3 __OVERLOAD__ select( long3 x, long3 y, long3 m );
long4 __OVERLOAD__ select( long4 x, long4 y, long4 m );
long8 __OVERLOAD__ select( long8 x, long8 y, long8 m );
long16 __OVERLOAD__ select( long16 x, long16 y, long16 m );
ulong2 __OVERLOAD__ select( ulong2 x, ulong2 y, long2 m );
ulong3 __OVERLOAD__ select( ulong3 x, ulong3 y, long3 m );
ulong4 __OVERLOAD__ select( ulong4 x, ulong4 y, long4 m );
ulong8 __OVERLOAD__ select( ulong8 x, ulong8 y, long8 m );
ulong16 __OVERLOAD__ select( ulong16 x, ulong16 y, long16 m );
long2 __OVERLOAD__ select( long2 x, long2 y, ulong2 m );
long3 __OVERLOAD__ select( long3 x, long3 y, ulong3 m );
long4 __OVERLOAD__ select( long4 x, long4 y, ulong4 m );
long8 __OVERLOAD__ select( long8 x, long8 y, ulong8 m );
long16 __OVERLOAD__ select( long16 x, long16 y, ulong16 m );
ulong2 __OVERLOAD__ select( ulong2 x, ulong2 y, ulong2 m );
ulong3 __OVERLOAD__ select( ulong3 x, ulong3 y, ulong3 m );
ulong4 __OVERLOAD__ select( ulong4 x, ulong4 y, ulong4 m );
ulong8 __OVERLOAD__ select( ulong8 x, ulong8 y, ulong8 m );
ulong16 __OVERLOAD__ select( ulong16 x, ulong16 y, ulong16 m );
float2 __OVERLOAD__ select( float2 x, float2 y, int2 m );
float3 __OVERLOAD__ select(float3 x, float3 y, __int3_SPI z);
float4 __OVERLOAD__ select( float4 x, float4 y, int4 m );
float8 __OVERLOAD__ select( float8 x, float8 y, int8 m );
float16 __OVERLOAD__ select( float16 x, float16 y, int16 m );
float2 __OVERLOAD__ select( float2 x, float2 y, uint2 m );
float3 __OVERLOAD__ select( float3 x, float3 y, uint3 m );
float4 __OVERLOAD__ select( float4 x, float4 y, uint4 m );
float8 __OVERLOAD__ select( float8 x, float8 y, uint8 m );
float16 __OVERLOAD__ select( float16 x, float16 y, uint16 m );
double2 __OVERLOAD__ select( double2 x, double2 y, long2 m ) ;
double3 __OVERLOAD__ select( double3 x, double3 y, long3 m ) ;
double4 __OVERLOAD__ select( double4 x, double4 y, long4 m ) ;
double8 __OVERLOAD__ select( double8 x, double8 y, long8 m ) ;
double16 __OVERLOAD__ select( double16 x, double16 y, long16 m ) ;
double2 __OVERLOAD__ select( double2 x, double2 y, ulong2 m ) ;
double3 __OVERLOAD__ select( double3 x, double3 y, ulong3 m ) ;
double4 __OVERLOAD__ select( double4 x, double4 y, ulong4 m ) ;
double8 __OVERLOAD__ select( double8 x, double8 y, ulong8 m ) ;
double16 __OVERLOAD__ select( double16 x, double16 y, ulong16 m ) ;

char __OVERLOAD__ bitselect( char x, char y, char m);
char2 __OVERLOAD__ bitselect( char2 x, char2 y, char2 m);
char3 __OVERLOAD__ bitselect( char3 x, char3 y, char3 m);
char4 __OVERLOAD__ bitselect( char4 x, char4 y, char4 m);
char8 __OVERLOAD__ bitselect( char8 x, char8 y, char8 m);
char16 __OVERLOAD__ bitselect( char16 x, char16 y, char16 m);
uchar __OVERLOAD__ bitselect( uchar x, uchar y, char m);
uchar2 __OVERLOAD__ bitselect( uchar2 x, uchar2 y, char2 m);
uchar3 __OVERLOAD__ bitselect( uchar3 x, uchar3 y, char3 m);
uchar4 __OVERLOAD__ bitselect( uchar4 x, uchar4 y, char4 m);
uchar8 __OVERLOAD__ bitselect( uchar8 x, uchar8 y, char8 m);
uchar16 __OVERLOAD__ bitselect( uchar16 x, uchar16 y, char16 m);
short __OVERLOAD__ bitselect( short x, short y, short m);
short2 __OVERLOAD__ bitselect( short2 x, short2 y, short2 m);
short3 __OVERLOAD__ bitselect( short3 x, short3 y, short3 m);
short4 __OVERLOAD__ bitselect( short4 x, short4 y, short4 m);
short8 __OVERLOAD__ bitselect( short8 x, short8 y, short8 m);
short16 __OVERLOAD__ bitselect( short16 x, short16 y, short16 m);
ushort __OVERLOAD__ bitselect( ushort x, ushort y, short m);
ushort2 __OVERLOAD__ bitselect( ushort2 x, ushort2 y, short2 m);
ushort3 __OVERLOAD__ bitselect( ushort3 x, ushort3 y, short3 m);
ushort4 __OVERLOAD__ bitselect( ushort4 x, ushort4 y, short4 m);
ushort8 __OVERLOAD__ bitselect( ushort8 x, ushort8 y, short8 m);
ushort16 __OVERLOAD__ bitselect( ushort16 x, ushort16 y, short16 m);
int __OVERLOAD__ bitselect( int x, int y, int m);
int2 __OVERLOAD__ bitselect( int2 x, int2 y, int2 m);
int3 __OVERLOAD__ bitselect( int3 x, int3 y, int3 m);
int4 __OVERLOAD__ bitselect( int4 x, int4 y, int4 m);
int8 __OVERLOAD__ bitselect( int8 x, int8 y, int8 m);
int16 __OVERLOAD__ bitselect( int16 x, int16 y, int16 m);
uint __OVERLOAD__ bitselect( uint x, uint y, int m);
uint2 __OVERLOAD__ bitselect( uint2 x, uint2 y, int2 m);
uint3 __OVERLOAD__ bitselect( uint3 x, uint3 y, int3 m);
uint4 __OVERLOAD__ bitselect( uint4 x, uint4 y, int4 m);
uint8 __OVERLOAD__ bitselect( uint8 x, uint8 y, int8 m);
uint16 __OVERLOAD__ bitselect( uint16 x, uint16 y, int16 m);
long __OVERLOAD__ bitselect( long x, long y, long m);
long2 __OVERLOAD__ bitselect( long2 x, long2 y, long2 m);
long3 __OVERLOAD__ bitselect( long3 x, long3 y, long3 m);
long4 __OVERLOAD__ bitselect( long4 x, long4 y, long4 m);
long8 __OVERLOAD__ bitselect( long8 x, long8 y, long8 m);
long16 __OVERLOAD__ bitselect( long16 x, long16 y, long16 m);
ulong __OVERLOAD__ bitselect( ulong x, ulong y, long m);
ulong2 __OVERLOAD__ bitselect( ulong2 x, ulong2 y, long2 m);
ulong3 __OVERLOAD__ bitselect( ulong3 x, ulong3 y, long3 m);
ulong4 __OVERLOAD__ bitselect( ulong4 x, ulong4 y, long4 m);
ulong8 __OVERLOAD__ bitselect( ulong8 x, ulong8 y, long8 m);
ulong16 __OVERLOAD__ bitselect( ulong16 x, ulong16 y, long16 m);
char __OVERLOAD__ bitselect( char x, char y, uchar m);
char2 __OVERLOAD__ bitselect( char2 x, char2 y, uchar2 m);
char3 __OVERLOAD__ bitselect( char3 x, char3 y, uchar3 m);
char4 __OVERLOAD__ bitselect( char4 x, char4 y, uchar4 m);
char8 __OVERLOAD__ bitselect( char8 x, char8 y, uchar8 m);
char16 __OVERLOAD__ bitselect( char16 x, char16 y, uchar16 m);
uchar __OVERLOAD__ bitselect( uchar x, uchar y, uchar m);
uchar2 __OVERLOAD__ bitselect( uchar2 x, uchar2 y, uchar2 m);
uchar3 __OVERLOAD__ bitselect( uchar3 x, uchar3 y, uchar3 m);
uchar4 __OVERLOAD__ bitselect( uchar4 x, uchar4 y, uchar4 m);
uchar8 __OVERLOAD__ bitselect( uchar8 x, uchar8 y, uchar8 m);
uchar16 __OVERLOAD__ bitselect( uchar16 x, uchar16 y, uchar16 m);
short __OVERLOAD__ bitselect( short x, short y, ushort m);
short2 __OVERLOAD__ bitselect( short2 x, short2 y, ushort2 m);
short3 __OVERLOAD__ bitselect( short3 x, short3 y, ushort3 m);
short4 __OVERLOAD__ bitselect( short4 x, short4 y, ushort4 m);
short8 __OVERLOAD__ bitselect( short8 x, short8 y, ushort8 m);
short16 __OVERLOAD__ bitselect( short16 x, short16 y, ushort16 m);
ushort __OVERLOAD__ bitselect( ushort x, ushort y, ushort m);
ushort2 __OVERLOAD__ bitselect( ushort2 x, ushort2 y, ushort2 m);
ushort3 __OVERLOAD__ bitselect( ushort3 x, ushort3 y, ushort3 m);
ushort4 __OVERLOAD__ bitselect( ushort4 x, ushort4 y, ushort4 m);
ushort8 __OVERLOAD__ bitselect( ushort8 x, ushort8 y, ushort8 m);
ushort16 __OVERLOAD__ bitselect( ushort16 x, ushort16 y, ushort16 m);
int __OVERLOAD__ bitselect( int x, int y, uint m);
int2 __OVERLOAD__ bitselect( int2 x, int2 y, uint2 m);
int3 __OVERLOAD__ bitselect( int3 x, int3 y, uint3 m);
int4 __OVERLOAD__ bitselect( int4 x, int4 y, uint4 m);
int8 __OVERLOAD__ bitselect( int8 x, int8 y, uint8 m);
int16 __OVERLOAD__ bitselect( int16 x, int16 y, uint16 m);
uint __OVERLOAD__ bitselect( uint x, uint y, uint m);
uint2 __OVERLOAD__ bitselect( uint2 x, uint2 y, uint2 m);
uint3 __OVERLOAD__ bitselect( uint3 x, uint3 y, uint3 m);
uint4 __OVERLOAD__ bitselect( uint4 x, uint4 y, uint4 m);
uint8 __OVERLOAD__ bitselect( uint8 x, uint8 y, uint8 m);
uint16 __OVERLOAD__ bitselect( uint16 x, uint16 y, uint16 m);
long __OVERLOAD__ bitselect( long x, long y, ulong m);
long2 __OVERLOAD__ bitselect( long2 x, long2 y, ulong2 m);
long3 __OVERLOAD__ bitselect( long3 x, long3 y, ulong3 m);
long4 __OVERLOAD__ bitselect( long4 x, long4 y, ulong4 m);
long8 __OVERLOAD__ bitselect( long8 x, long8 y, ulong8 m);
long16 __OVERLOAD__ bitselect( long16 x, long16 y, ulong16 m);
ulong __OVERLOAD__ bitselect( ulong x, ulong y, ulong m);
ulong2 __OVERLOAD__ bitselect( ulong2 x, ulong2 y, ulong2 m);
ulong3 __OVERLOAD__ bitselect( ulong3 x, ulong3 y, ulong3 m);
ulong4 __OVERLOAD__ bitselect( ulong4 x, ulong4 y, ulong4 m);
ulong8 __OVERLOAD__ bitselect( ulong8 x, ulong8 y, ulong8 m);
ulong16 __OVERLOAD__ bitselect( ulong16 x, ulong16 y, ulong16 m);
float __OVERLOAD__ bitselect( float x, float y, float m);
float2 __OVERLOAD__ bitselect( float2 x, float2 y, float2 m);
float3 __OVERLOAD__ bitselect( float3 x, float3 y, float3 m);
float4 __OVERLOAD__ bitselect( float4 x, float4 y, float4 m);
float8 __OVERLOAD__ bitselect( float8 x, float8 y, float8 m);
float16 __OVERLOAD__ bitselect( float16 x, float16 y, float16 m);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
double __OVERLOAD__ bitselect( double x, double y, double m);
#endif
double2 __OVERLOAD__ bitselect( double2 x, double2 y, double2 m);
double3 __OVERLOAD__ bitselect( double3 x, double3 y, double3 m);
double4 __OVERLOAD__ bitselect( double4 x, double4 y, double4 m);
double8 __OVERLOAD__ bitselect( double8 x, double8 y, double8 m);
double16 __OVERLOAD__ bitselect( double16 x, double16 y, double16 m);


// Include shared types that have to be visible both here and in the framework
#include "cl_kernel_shared.h"

// image format description
typedef struct _cl_image_format_t {
  unsigned int num_channels;
  unsigned int channel_order;
  unsigned int channel_data_type;
} cl_image_format_t;

typedef __global struct  _image1d_t        *image1d_t;
typedef __global struct  _image2d_t        *image2d_t;
typedef __global struct  _image3d_t        *image3d_t;

typedef __global struct  _image1d_array_t  *image1d_array_t;
typedef __global struct  _image2d_array_t  *image2d_array_t;

typedef __global struct  _image1d_buffer_t *image1d_buffer_t;

typedef __global struct  _image2d_depth_t       *image2d_depth_t;
typedef __global struct  _image2d_array_depth_t *image2d_array_depth_t;
typedef __global struct  _image2d_msaa_t        *image2d_msaa_t;
typedef __global struct  _image2d_array_msaa_t  *image2d_array_msaa_t;
typedef __global struct  _image2d_msaa_depth_t  *image2d_msaa_depth_t;
typedef __global struct  _image2d_array_msaa_depth_t *image2d_array_msaa_depth_t;

// 5.8.4 - Image Stream Read and Write

// 1D
float4 __OVERLOAD__ read_imagef(image1d_t image, sampler_t sampler, int coord);
float4 __OVERLOAD__ read_imagef(image1d_t image, sampler_t sampler, float coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, sampler_t sampler, int coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, sampler_t sampler, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, sampler_t sampler, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, sampler_t sampler, float coord);

// 2D
float4 __OVERLOAD__ read_imagef(image2d_t image, sampler_t sampler, int2 coord);
float4 __OVERLOAD__ read_imagef(image2d_t image, sampler_t sampler, float2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, sampler_t sampler, int2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, sampler_t sampler, float2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, sampler_t sampler, int2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, sampler_t sampler, float2 coord);
float4 __OVERLOAD__ read_gradient_imagef( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);
int4   __OVERLOAD__ read_gradient_imagei( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);
uint4  __OVERLOAD__ read_gradient_imageui( image2d_t image, sampler_t sampler, float2 ddx, float2 ddy, float2 coord);

// 3D
float4 __OVERLOAD__ read_imagef(image3d_t image, sampler_t sampler, int4 coord);
float4 __OVERLOAD__ read_imagef(image3d_t image, sampler_t sampler, float4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, sampler_t sampler, int4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, sampler_t sampler, float4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, sampler_t sampler, int4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, sampler_t sampler, float4 coord);
float4 __OVERLOAD__ read_gradient_imagef( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);
int4   __OVERLOAD__ read_gradient_imagei( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);
uint4  __OVERLOAD__ read_gradient_imageui( image3d_t image, sampler_t sampler, float4 ddx, float4 ddy, float4 coord);

// 1D array
float4 __OVERLOAD__ read_imagef(image1d_array_t image, sampler_t sampler, int2 coord);
float4 __OVERLOAD__ read_imagef(image1d_array_t image, sampler_t sampler, float2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, sampler_t sampler, int2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, sampler_t sampler, float2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, sampler_t sampler, int2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, sampler_t sampler, float2 coord);

// 2D array
float4 __OVERLOAD__ read_imagef(image2d_array_t image, sampler_t sampler, int4 coord);
float4 __OVERLOAD__ read_imagef(image2d_array_t image, sampler_t sampler, float4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, sampler_t sampler, int4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, sampler_t sampler, float4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, sampler_t sampler, int4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, sampler_t sampler, float4 coord);

// Depth image and depth image array
float __OVERLOAD__ read_imagef(image2d_depth_t image, sampler_t sampler, float2 coord);
float __OVERLOAD__ read_imagef(image2d_depth_t image, sampler_t sampler, int2 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, sampler_t sampler, float4 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, sampler_t sampler, int4 coord);

// MSAA textures
float4 __OVERLOAD__ read_imagef(image2d_msaa_t image, int2 coord, int sample);
int4   __OVERLOAD__ read_imagei(image2d_msaa_t image, int2 coord, int sample);
uint4  __OVERLOAD__ read_imageui(image2d_msaa_t image, int2 coord, int sample);

float  __OVERLOAD__ read_imagef(image2d_msaa_depth_t image, int2 coord, int sample);

float4 __OVERLOAD__ read_imagef(image2d_array_msaa_t image, int4 coord, int sample);
int4   __OVERLOAD__ read_imagei(image2d_array_msaa_t image, int4 coord, int sample);
uint4  __OVERLOAD__ read_imageui(image2d_array_msaa_t image, int4 coord, int sample);

float  __OVERLOAD__ read_imagef(image2d_array_msaa_depth_t image, int4 coord, int sample);

void __OVERLOAD__ write_imagef(image1d_t image, int coord, float4 color);
void __OVERLOAD__ write_imagef(image1d_buffer_t image, int coord, float4 color);
void __OVERLOAD__ write_imagef(image2d_t image, int2 coord, float4 color);
void __OVERLOAD__ write_imagef(image3d_t image, int4 coord, float4 color);
void __OVERLOAD__ write_imagef(image1d_array_t image, int2 coord, float4 color);
void __OVERLOAD__ write_imagef(image2d_array_t image, int4 coord, float4 color);

// Depth image and depth image array
void __OVERLOAD__ write_imagef(image2d_depth_t image, int2 coord, float color);
void __OVERLOAD__ write_imagef(image2d_array_depth_t image, int4 coord, float color);

void __OVERLOAD__ write_imagei(image1d_t image, int  coord, int4 color);
void __OVERLOAD__ write_imagei(image1d_buffer_t image, int coord, int4 color);
void __OVERLOAD__ write_imagei(image2d_t image, int2 coord, int4 color);
void __OVERLOAD__ write_imagei(image3d_t image, int4 coord, int4 color);
void __OVERLOAD__ write_imagei(image1d_array_t image, int2 coord, int4 color);
void __OVERLOAD__ write_imagei(image2d_array_t image, int4 coord, int4 color);

void __OVERLOAD__ write_imageui(image1d_t image, int coord, uint4 val);
void __OVERLOAD__ write_imageui(image1d_buffer_t image, int coord, uint4 color);
void __OVERLOAD__ write_imageui(image2d_t image, int2 coord, uint4 val);
void __OVERLOAD__ write_imageui(image3d_t image, int4 coord, uint4 val);
void __OVERLOAD__ write_imageui(image1d_array_t image, int2 coord, uint4 color);
void __OVERLOAD__ write_imageui(image2d_array_t image, int4 coord, uint4 color);

void __write_imagef_2d_unorm_int8_rgba_apple_SPI(image2d_t image, int2 coord, float4 val);
void __write_imagef_2d_unorm_int8_bgra_apple_SPI(image2d_t image, int2 coord, float4 val); 
#define write_imagef_unorm_int8_rgba_apple_SPI(_image, _coord, _val) __write_imagef_2d_unorm_int8_rgba_apple_SPI(_image, _coord, _val)
#define write_imagef_unorm_int8_bgra_apple_SPI(_image, _coord, _val) __write_imagef_2d_unorm_int8_bgra_apple_SPI(_image, _coord, _val)

// Sampler-less Reads
// 1D
float4 __OVERLOAD__ read_imagef(image1d_t image, int coord);
float4 __OVERLOAD__ read_imagef(image1d_t image, float coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, int coord);
int4   __OVERLOAD__ read_imagei(image1d_t image, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_t image, float coord);

// 2D
float4 __OVERLOAD__ read_imagef(image2d_t image, int2 coord);
float4 __OVERLOAD__ read_imagef(image2d_t image, float2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, int2 coord);
int4   __OVERLOAD__ read_imagei(image2d_t image, float2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, int2 coord);
uint4  __OVERLOAD__ read_imageui(image2d_t image, float2 coord);

// 3D
float4 __OVERLOAD__ read_imagef(image3d_t image, int4 coord);
float4 __OVERLOAD__ read_imagef(image3d_t image, float4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, int4 coord);
int4   __OVERLOAD__ read_imagei(image3d_t image, float4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, int4 coord);
uint4  __OVERLOAD__ read_imageui(image3d_t image, float4 coord);

// 1D buffer
float4 __OVERLOAD__ read_imagef(image1d_buffer_t image, int coord);
float4 __OVERLOAD__ read_imagef(image1d_buffer_t image, float coord);
int4   __OVERLOAD__ read_imagei(image1d_buffer_t image, int coord);
int4   __OVERLOAD__ read_imagei(image1d_buffer_t image, float coord);
uint4  __OVERLOAD__ read_imageui(image1d_buffer_t image, int coord);
uint4  __OVERLOAD__ read_imageui(image1d_buffer_t image, float coord);

// 1D array
float4 __OVERLOAD__ read_imagef(image1d_array_t image, int2 coord);
float4 __OVERLOAD__ read_imagef(image1d_array_t image, float2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, int2 coord);
int4   __OVERLOAD__ read_imagei(image1d_array_t image, float2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, int2 coord);
uint4  __OVERLOAD__ read_imageui(image1d_array_t image, float2 coord);

// 2D array
float4 __OVERLOAD__ read_imagef(image2d_array_t image, int4 coord);
float4 __OVERLOAD__ read_imagef(image2d_array_t image, float4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, int4 coord);
int4   __OVERLOAD__ read_imagei(image2d_array_t image, float4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, int4 coord);
uint4  __OVERLOAD__ read_imageui(image2d_array_t image, float4 coord);

// Depth image and depth image array
float __OVERLOAD__ read_imagef(image2d_depth_t image, int2 coord);
float __OVERLOAD__ read_imagef(image2d_array_depth_t image, int4 coord);

int __OVERLOAD__ get_image_width(image1d_t img);
int __OVERLOAD__ get_image_width(image2d_t img);
int __OVERLOAD__ get_image_width(image3d_t img);
int __OVERLOAD__ get_image_width(image1d_array_t img);
int __OVERLOAD__ get_image_width(image2d_array_t img);
int __OVERLOAD__ get_image_width(image2d_depth_t img);
int __OVERLOAD__ get_image_width(image2d_array_depth_t img);
int __OVERLOAD__ get_image_width(image2d_msaa_t img);
int __OVERLOAD__ get_image_width(image2d_array_msaa_t img);
int __OVERLOAD__ get_image_width(image2d_msaa_depth_t img);
int __OVERLOAD__ get_image_width(image2d_array_msaa_depth_t img);

int __OVERLOAD__ get_image_height(image2d_t img);
int __OVERLOAD__ get_image_height(image3d_t img);
int __OVERLOAD__ get_image_height(image2d_array_t img);
int __OVERLOAD__ get_image_height(image2d_depth_t img);
int __OVERLOAD__ get_image_height(image2d_array_depth_t img);
int __OVERLOAD__ get_image_height(image2d_msaa_t img);
int __OVERLOAD__ get_image_height(image2d_array_msaa_t img);
int __OVERLOAD__ get_image_height(image2d_msaa_depth_t img);
int __OVERLOAD__ get_image_height(image2d_array_msaa_depth_t img);

int __OVERLOAD__ get_image_depth(image3d_t img);

int __OVERLOAD__ get_image_channel_data_type(image1d_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_t image);
int __OVERLOAD__ get_image_channel_data_type(image3d_t image);
int __OVERLOAD__ get_image_channel_data_type(image1d_array_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_msaa_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_msaa_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_msaa_depth_t image);
int __OVERLOAD__ get_image_channel_data_type(image2d_array_msaa_depth_t image);

int __OVERLOAD__ get_image_channel_order(image1d_t image);
int __OVERLOAD__ get_image_channel_order(image2d_t image);
int __OVERLOAD__ get_image_channel_order(image3d_t image);
int __OVERLOAD__ get_image_channel_order(image1d_array_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_t image);
int __OVERLOAD__ get_image_channel_order(image2d_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_msaa_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_msaa_t image);
int __OVERLOAD__ get_image_channel_order(image2d_msaa_depth_t image);
int __OVERLOAD__ get_image_channel_order(image2d_array_msaa_depth_t image);

int2 __OVERLOAD__ get_image_dim(image2d_t image);
int4 __OVERLOAD__ get_image_dim(image3d_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_t image);
int2 __OVERLOAD__ get_image_dim(image2d_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_msaa_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_msaa_t image);
int2 __OVERLOAD__ get_image_dim(image2d_msaa_depth_t image);
int2 __OVERLOAD__ get_image_dim(image2d_array_msaa_depth_t image);

size_t __OVERLOAD__ get_image_array_size(image1d_array_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_depth_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_msaa_t image);
size_t __OVERLOAD__ get_image_array_size(image2d_array_msaa_depth_t image);

// MSAA textures
int __OVERLOAD__ get_image_num_samples(image2d_msaa_t image);
int __OVERLOAD__ get_image_num_samples(image2d_array_msaa_t image);
int __OVERLOAD__ get_image_num_samples(image2d_msaa_depth_t image);
int __OVERLOAD__ get_image_num_samples(image2d_array_msaa_depth_t image);

int __OVERLOAD__ get_image_num_miplevels(image2d_t image);
int __OVERLOAD__ get_image_num_miplevels(image3d_t image);

#if defined( __i386__ ) || defined( __x86_64__ )
// SPI for CoreImage
void __OVERLOAD__ __read_transposed_imagef_resample( __rd image2d_t src, sampler_t smp, float4 x,float4 y, float4 *r, float4 *g, float4 *b, float4 *a);
void __OVERLOAD__ __read_transposed_imagef_resample( __rd image2d_t src, sampler_t smp, float8 x,float8 y, float8 *r, float8 *g, float8 *b, float8 *a);
#define read_transposed_imagef( _src, _smp, _x, _y, _r, _g, _b, _a )   __read_transposed_imagef_resample(_src, _smp, _x, _y, _r, _g, _b, _a )
void __OVERLOAD__ __read_direct_imagef_resample( __rd image2d_t src, sampler_t smp, float4 x,float4 y, float16 *dest);
void __OVERLOAD__ __read_direct_imagef_resample( __rd image2d_t src, sampler_t smp, float8 x,float8 y, float32 *dest);


void __OVERLOAD__ __read_transposed_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float4 x,float4 y, float4 z, float4 *r,float4 *g,float4 *b,float4 *a);
void __OVERLOAD__ __read_transposed_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float8 x,float8 y, float8 z, float8 *r,float8 *g,float8 *b,float8 *a);
#define read_transposed_3d_imagef( _src, _smp, _x, _y, _z, _r, _g, _b, _a )     __read_transposed_imagef_resample( _src, _smp, _x, _y, _z, _r, _g, _b, _a )
void __OVERLOAD__ __read_direct_3d_imagef_resample( __rd image3d_t src, sampler_t smp, float4 x,float4 y, float4 z, float16 *dest );

void __OVERLOAD__ write_transposed_imagef( __wr image2d_t dst, int x, int y, float4 r, float4 g, float4 b, float4 a);
void __OVERLOAD__ write_transposed_imagef( __wr image2d_t dst, int x, int y, float8 r, float8 g, float8 b, float8 a);
void __OVERLOAD__ write_direct_imagef( __wr image2d_t dst, int x, int y, float16 v );
void __OVERLOAD__ write_direct_imagef( __wr image2d_t dst, int x, int y, float32 v );

event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __global float4 *r, const __global float4 *g, 
                                                    const __global float4 *b, const __global float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __constant float4 *r, const __constant float4 *g, 
                                                    const __constant float4 *b, const __constant float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __private float4 *r, const __private float4 *g, 
                                                    const __private float4 *b, const __private float4 *a );
event_t __OVERLOAD__ __async_work_group_stream_to_image( __wr image2d_t image, size_t x, size_t y, size_t count, 
                                                    const __local float4 *r, const __local float4 *g, 
                                                    const __local float4 *b, const __local float4 *a );

event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __global float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __constant float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __private float4 *src );
event_t __OVERLOAD__ __async_work_group_stream_to_image_direct( __wr image2d_t image, size_t x, size_t y, size_t count, const __local float4 *src );

                   
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __private float4 *r,  __private float4 *g,  __private float4 *b,  __private float4 *a );
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __global float4 *r,  __global float4 *g,  __global float4 *b,  __global float4 *a );
event_t	__OVERLOAD__  __async_work_group_stream_from_image( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, 
                                                        __local float4 *r,  __local float4 *g,  __local float4 *b,  __local float4 *a );

event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __private float4 *dest );
event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __global float4 *dest );
event_t	__OVERLOAD__  __async_work_group_stream_from_image_direct( __rd image2d_t image, sampler_t sampler, float2 start, float2 stride, size_t count, __local float4 *dest );


float16  __ci_gamma_SPI( float4 r, float4 g, float4 b, float4 y );
float32  __ci_gamma8_SPI( float8 r, float8 g, float8 b, float8 y );
void     __ci_gamma_SPI_8( float8 r, float8 g, float8 b, float8 y, float8 *outR, float8 *outG, float8 *outB ); 
float3  __ci_gamma_scalar_SPI( float3 rgb, float y );
#endif

__CLFN_EVENT_ALL(async_work_group_copy);
__CLFN_EVENT_ALL4(async_work_group_strided_copy);

void wait_group_events( int, event_t* );

void __OVERLOAD__  prefetch(const __global char* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar* p, size_t n);
void __OVERLOAD__  prefetch(const __global short* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort* p, size_t n);
void __OVERLOAD__  prefetch(const __global int* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint* p, size_t n);
void __OVERLOAD__  prefetch(const __global long* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong* p, size_t n);
void __OVERLOAD__  prefetch(const __global float* p, size_t n);
#if defined( cl_khr_fp64 ) || defined( cl_APPLE_fp64_basic_ops )
void __OVERLOAD__  prefetch(const __global double* p, size_t n);
#endif
void __OVERLOAD__  prefetch(const __global char2* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar2* p, size_t n);
void __OVERLOAD__  prefetch(const __global short2* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort2* p, size_t n);
void __OVERLOAD__  prefetch(const __global int2* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint2* p, size_t n);
void __OVERLOAD__  prefetch(const __global long2* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong2* p, size_t n);
void __OVERLOAD__  prefetch(const __global float2* p, size_t n);
void __OVERLOAD__  prefetch(const __global double2* p, size_t n);
void __OVERLOAD__  prefetch(const __global char4* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar4* p, size_t n);
void __OVERLOAD__  prefetch(const __global short4* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort4* p, size_t n);
void __OVERLOAD__  prefetch(const __global int4* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint4* p, size_t n);
void __OVERLOAD__  prefetch(const __global long4* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong4* p, size_t n);
void __OVERLOAD__  prefetch(const __global float4* p, size_t n);
void __OVERLOAD__  prefetch(const __global double4* p, size_t n);
void __OVERLOAD__  prefetch(const __global char8* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar8* p, size_t n);
void __OVERLOAD__  prefetch(const __global short8* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort8* p, size_t n);
void __OVERLOAD__  prefetch(const __global int8* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint8* p, size_t n);
void __OVERLOAD__  prefetch(const __global long8* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong8* p, size_t n);
void __OVERLOAD__  prefetch(const __global float8* p, size_t n);
void __OVERLOAD__  prefetch(const __global double8* p, size_t n);
void __OVERLOAD__  prefetch(const __global char16* p, size_t n);
void __OVERLOAD__  prefetch(const __global uchar16* p, size_t n);
void __OVERLOAD__  prefetch(const __global short16* p, size_t n);
void __OVERLOAD__  prefetch(const __global ushort16* p, size_t n);
void __OVERLOAD__  prefetch(const __global int16* p, size_t n);
void __OVERLOAD__  prefetch(const __global uint16* p, size_t n);
void __OVERLOAD__  prefetch(const __global long16* p, size_t n);
void __OVERLOAD__  prefetch(const __global ulong16* p, size_t n);
void __OVERLOAD__  prefetch(const __global float16* p, size_t n);
void __OVERLOAD__  prefetch(const __global double16* p, size_t n);

// 5.9.7 - Synchronization
typedef enum {
  CLK_LOCAL_MEM_FENCE  = 1U << 0,
  CLK_GLOBAL_MEM_FENCE = 1U << 1,
  __unused_except_to_make_sure_the_enum_has_the_right_size = 1U << 31
} cl_mem_fence_flags;

void barrier(cl_mem_fence_flags);
void mem_fence(cl_mem_fence_flags);
void read_mem_fence(cl_mem_fence_flags);
void write_mem_fence(cl_mem_fence_flags);

// 5.9.9 - Atomic Functions
int __OVERLOAD__  atom_add(volatile __global int *p, int val);
int __OVERLOAD__  atom_sub(volatile __global int *p, int val);
int __OVERLOAD__ atom_xchg(volatile __global int *p, int val);
int __OVERLOAD__ atom_min(volatile __global int *p, int val);
int __OVERLOAD__ atom_max(volatile __global int *p, int val);
int __OVERLOAD__ atom_inc(volatile __global int *p);
int __OVERLOAD__ atom_dec(volatile __global int *p);
int __OVERLOAD__ atom_cmpxchg(volatile __global int *p, int cmp, int val);
int __OVERLOAD__ atom_and(volatile __global int *p, int val);
int __OVERLOAD__ atom_or(volatile __global int *p, int val);
int __OVERLOAD__ atom_xor(volatile __global int *p, int val);

unsigned __OVERLOAD__  atom_add(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__  atom_sub(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xchg(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_min(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_max(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_inc(volatile __global unsigned *p);
unsigned __OVERLOAD__ atom_dec(volatile __global unsigned *p);
unsigned __OVERLOAD__ atom_cmpxchg(volatile __global unsigned *p, unsigned cmp, unsigned val);
unsigned __OVERLOAD__ atom_and(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_or(volatile __global unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xor(volatile __global unsigned *p, unsigned val);

float __OVERLOAD__ atom_xchg(volatile __global float *p, float val);


int __OVERLOAD__  atom_add(volatile local int *p, int val);
int __OVERLOAD__  atom_sub(volatile local int *p, int val);
int __OVERLOAD__ atom_xchg(volatile local int *p, int val);
int __OVERLOAD__ atom_min(volatile local int *p, int val);
int __OVERLOAD__ atom_max(volatile local int *p, int val);
int __OVERLOAD__ atom_inc(volatile local int *p);
int __OVERLOAD__ atom_dec(volatile local int *p);
int __OVERLOAD__ atom_cmpxchg(volatile local int *p, int cmp, int val);
int __OVERLOAD__ atom_and(volatile local int *p, int val);
int __OVERLOAD__ atom_or(volatile local int *p, int val);
int __OVERLOAD__ atom_xor(volatile local int *p, int val);

unsigned __OVERLOAD__  atom_add(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__  atom_sub(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xchg(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_min(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_max(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_inc(volatile local unsigned *p);
unsigned __OVERLOAD__ atom_dec(volatile local unsigned *p);
unsigned __OVERLOAD__ atom_cmpxchg(volatile local unsigned *p, unsigned cmp, unsigned val);
unsigned __OVERLOAD__ atom_and(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_or(volatile local unsigned *p, unsigned val);
unsigned __OVERLOAD__ atom_xor(volatile local unsigned *p, unsigned val);

float __OVERLOAD__ atom_xchg(volatile local float *p, float val);


long __OVERLOAD__  atom_add(volatile __global long *p, long val);
long __OVERLOAD__  atom_sub(volatile __global long *p, long val);
long __OVERLOAD__ atom_xchg(volatile __global long *p, long val);
long __OVERLOAD__ atom_min(volatile __global long *p, long val);
long __OVERLOAD__ atom_max(volatile __global long *p, long val);
long __OVERLOAD__ atom_inc(volatile __global long *p);
long __OVERLOAD__ atom_dec(volatile __global long *p);
long __OVERLOAD__ atom_cmpxchg(volatile __global long *p, long cmp, long val);
long __OVERLOAD__ atom_and(volatile __global long *p, long val);
long __OVERLOAD__ atom_or(volatile __global long *p, long val);
long __OVERLOAD__ atom_xor(volatile __global long *p, long val);

ulong __OVERLOAD__  atom_add(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__  atom_sub(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_xchg(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_min(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_max(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_inc(volatile __global ulong *p);
ulong __OVERLOAD__ atom_dec(volatile __global ulong *p);
ulong __OVERLOAD__ atom_cmpxchg(volatile __global ulong *p, ulong cmp, ulong val);
ulong __OVERLOAD__ atom_and(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_or(volatile __global ulong *p, ulong val);
ulong __OVERLOAD__ atom_xor(volatile __global ulong *p, ulong val);


long __OVERLOAD__  atom_add(volatile local long *p, long val);
long __OVERLOAD__  atom_sub(volatile local long *p, long val);
long __OVERLOAD__ atom_xchg(volatile local long *p, long val);
long __OVERLOAD__ atom_min(volatile local long *p, long val);
long __OVERLOAD__ atom_max(volatile local long *p, long val);
long __OVERLOAD__ atom_inc(volatile local long *p);
long __OVERLOAD__ atom_dec(volatile local long *p);
long __OVERLOAD__ atom_cmpxchg(volatile local long *p, long cmp, long val);
long __OVERLOAD__ atom_and(volatile local long *p, long val);
long __OVERLOAD__ atom_or(volatile local long *p, long val);
long __OVERLOAD__ atom_xor(volatile local long *p, long val);

ulong __OVERLOAD__  atom_add(volatile local ulong *p, ulong val);
ulong __OVERLOAD__  atom_sub(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_xchg(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_min(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_max(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_inc(volatile local ulong *p);
ulong __OVERLOAD__ atom_dec(volatile local ulong *p);
ulong __OVERLOAD__ atom_cmpxchg(volatile local ulong *p, ulong cmp, ulong val);
ulong __OVERLOAD__ atom_and(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_or(volatile local ulong *p, ulong val);
ulong __OVERLOAD__ atom_xor(volatile local ulong *p, ulong val);

#define atomic_add(X,Y)         atom_add((X),(Y))
#define atomic_sub(X,Y)         atom_sub((X),(Y))
#define atomic_xchg(X,Y)        atom_xchg((X),(Y))
#define atomic_min(X,Y)         atom_min((X),(Y))
#define atomic_max(X,Y)         atom_max((X),(Y))
#define atomic_inc(X)           atom_inc(X)
#define atomic_dec(X)           atom_dec(X)
#define atomic_cmpxchg(X,Y,Z)   atom_cmpxchg((X),(Y),(Z)) 
#define atomic_and(X,Y)         atom_and((X),(Y))
#define atomic_or(X,Y)          atom_or((X),(Y))
#define atomic_xor(X,Y)         atom_xor((X),(Y))

char2 __OVERLOAD__ shuffle( char2 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char2 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char2 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char2 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar2 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar2 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar2 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar2 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char4 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char4 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char4 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char4 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar4 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar4 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar4 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar4 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char8 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char8 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char8 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char8 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar8 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar8 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar8 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar8 x, uchar16 map );
char2 __OVERLOAD__ shuffle( char16 x, uchar2 map );
char4 __OVERLOAD__ shuffle( char16 x, uchar4 map );
char8 __OVERLOAD__ shuffle( char16 x, uchar8 map );
char16 __OVERLOAD__ shuffle( char16 x, uchar16 map );
uchar2 __OVERLOAD__ shuffle( uchar16 x, uchar2 map );
uchar4 __OVERLOAD__ shuffle( uchar16 x, uchar4 map );
uchar8 __OVERLOAD__ shuffle( uchar16 x, uchar8 map );
uchar16 __OVERLOAD__ shuffle( uchar16 x, uchar16 map );
short2 __OVERLOAD__ shuffle( short2 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short2 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short2 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short2 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort2 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort2 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort2 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort2 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short4 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short4 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short4 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short4 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort4 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort4 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort4 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort4 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short8 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short8 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short8 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short8 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort8 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort8 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort8 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort8 x, ushort16 map );
short2 __OVERLOAD__ shuffle( short16 x, ushort2 map );
short4 __OVERLOAD__ shuffle( short16 x, ushort4 map );
short8 __OVERLOAD__ shuffle( short16 x, ushort8 map );
short16 __OVERLOAD__ shuffle( short16 x, ushort16 map );
ushort2 __OVERLOAD__ shuffle( ushort16 x, ushort2 map );
ushort4 __OVERLOAD__ shuffle( ushort16 x, ushort4 map );
ushort8 __OVERLOAD__ shuffle( ushort16 x, ushort8 map );
ushort16 __OVERLOAD__ shuffle( ushort16 x, ushort16 map );
int2 __OVERLOAD__ shuffle( int2 x, uint2 map );
int4 __OVERLOAD__ shuffle( int2 x, uint4 map );
int8 __OVERLOAD__ shuffle( int2 x, uint8 map );
int16 __OVERLOAD__ shuffle( int2 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint2 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint2 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint2 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint2 x, uint16 map );
int2 __OVERLOAD__ shuffle( int4 x, uint2 map );
int4 __OVERLOAD__ shuffle( int4 x, uint4 map );
int8 __OVERLOAD__ shuffle( int4 x, uint8 map );
int16 __OVERLOAD__ shuffle( int4 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint4 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint4 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint4 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint4 x, uint16 map );
int2 __OVERLOAD__ shuffle( int8 x, uint2 map );
int4 __OVERLOAD__ shuffle( int8 x, uint4 map );
int8 __OVERLOAD__ shuffle( int8 x, uint8 map );
int16 __OVERLOAD__ shuffle( int8 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint8 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint8 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint8 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint8 x, uint16 map );
int2 __OVERLOAD__ shuffle( int16 x, uint2 map );
int4 __OVERLOAD__ shuffle( int16 x, uint4 map );
int8 __OVERLOAD__ shuffle( int16 x, uint8 map );
int16 __OVERLOAD__ shuffle( int16 x, uint16 map );
uint2 __OVERLOAD__ shuffle( uint16 x, uint2 map );
uint4 __OVERLOAD__ shuffle( uint16 x, uint4 map );
uint8 __OVERLOAD__ shuffle( uint16 x, uint8 map );
uint16 __OVERLOAD__ shuffle( uint16 x, uint16 map );
long2 __OVERLOAD__ shuffle( long2 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long2 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long2 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long2 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong2 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong2 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong2 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong2 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long4 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long4 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long4 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long4 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong4 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong4 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong4 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong4 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long8 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long8 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long8 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long8 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong8 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong8 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong8 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong8 x, ulong16 map );
long2 __OVERLOAD__ shuffle( long16 x, ulong2 map );
long4 __OVERLOAD__ shuffle( long16 x, ulong4 map );
long8 __OVERLOAD__ shuffle( long16 x, ulong8 map );
long16 __OVERLOAD__ shuffle( long16 x, ulong16 map );
ulong2 __OVERLOAD__ shuffle( ulong16 x, ulong2 map );
ulong4 __OVERLOAD__ shuffle( ulong16 x, ulong4 map );
ulong8 __OVERLOAD__ shuffle( ulong16 x, ulong8 map );
ulong16 __OVERLOAD__ shuffle( ulong16 x, ulong16 map );
float2  __OVERLOAD__ shuffle( float2 x, uint2 map );
float4  __OVERLOAD__ shuffle( float2 x, uint4 map );
float8  __OVERLOAD__ shuffle( float2 x, uint8 map );
float16  __OVERLOAD__ shuffle( float2 x, uint16 map );
float2  __OVERLOAD__ shuffle( float4 x, uint2 map );
float4  __OVERLOAD__ shuffle( float4 x, uint4 map );
float8  __OVERLOAD__ shuffle( float4 x, uint8 map );
float16  __OVERLOAD__ shuffle( float4 x, uint16 map );
float2  __OVERLOAD__ shuffle( float8 x, uint2 map );
float4  __OVERLOAD__ shuffle( float8 x, uint4 map );
float8  __OVERLOAD__ shuffle( float8 x, uint8 map );
float16  __OVERLOAD__ shuffle( float8 x, uint16 map );
float2  __OVERLOAD__ shuffle( float16 x, uint2 map );
float4  __OVERLOAD__ shuffle( float16 x, uint4 map );
float8  __OVERLOAD__ shuffle( float16 x, uint8 map );
float16  __OVERLOAD__ shuffle( float16 x, uint16 map );
double2  __OVERLOAD__ shuffle( double2 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double2 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double2 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double2 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double4 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double4 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double4 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double4 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double8 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double8 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double8 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double8 x, ulong16 map );
double2  __OVERLOAD__ shuffle( double16 x, ulong2 map );
double4  __OVERLOAD__ shuffle( double16 x, ulong4 map );
double8  __OVERLOAD__ shuffle( double16 x, ulong8 map );
double16  __OVERLOAD__ shuffle( double16 x, ulong16 map );

char2 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar2 map);
char2 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar2 map);
uchar2 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar2 map);
char4 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar4 map);
char4 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar4 map);
uchar4 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar4 map);
char8 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar8 map);
char8 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar8 map);
uchar8 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar8 map);
char16 __OVERLOAD__ shuffle2( char2 x, char2 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char4 x, char4 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char8 x, char8 y, uchar16 map);
char16 __OVERLOAD__ shuffle2( char16 x, char16 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar2 x, uchar2 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar4 x, uchar4 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar8 x, uchar8 y, uchar16 map);
uchar16 __OVERLOAD__ shuffle2( uchar16 x, uchar16 y, uchar16 map);
short2 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort2 map);
short2 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort2 map);
ushort2 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort2 map);
short4 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort4 map);
short4 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort4 map);
ushort4 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort4 map);
short8 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort8 map);
short8 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort8 map);
ushort8 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort8 map);
short16 __OVERLOAD__ shuffle2( short2 x, short2 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short4 x, short4 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short8 x, short8 y, ushort16 map);
short16 __OVERLOAD__ shuffle2( short16 x, short16 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort2 x, ushort2 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort4 x, ushort4 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort8 x, ushort8 y, ushort16 map);
ushort16 __OVERLOAD__ shuffle2( ushort16 x, ushort16 y, ushort16 map);
int2 __OVERLOAD__ shuffle2( int2 x, int2 y, uint2 map);
int2 __OVERLOAD__ shuffle2( int4 x, int4 y, uint2 map);
int2 __OVERLOAD__ shuffle2( int8 x, int8 y, uint2 map);
int2  __OVERLOAD__ shuffle2( int16 x, int16 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint2 map);
uint2 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float2 x, float2 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float4 x, float4 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float8 x, float8 y, uint2 map);
float2 __OVERLOAD__ shuffle2( float16 x, float16 y, uint2 map);
int4 __OVERLOAD__ shuffle2( int2 x, int2 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int4 x, int4 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int8 x, int8 y, uint4 map);
int4 __OVERLOAD__ shuffle2( int16 x, int16 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint4 map);
uint4 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float2 x, float2 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float4 x, float4 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float8 x, float8 y, uint4 map);
float4 __OVERLOAD__ shuffle2( float16 x, float16 y, uint4 map);
int8 __OVERLOAD__ shuffle2( int2 x, int2 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int4 x, int4 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int8 x, int8 y, uint8 map);
int8 __OVERLOAD__ shuffle2( int16 x, int16 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint8 map);
uint8 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float2 x, float2 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float4 x, float4 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float8 x, float8 y, uint8 map);
float8 __OVERLOAD__ shuffle2( float16 x, float16 y, uint8 map);
int16 __OVERLOAD__ shuffle2( int2 x, int2 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int4 x, int4 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int8 x, int8 y, uint16 map);
int16 __OVERLOAD__ shuffle2( int16 x, int16 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint2 x, uint2 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint4 x, uint4 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint8 x, uint8 y, uint16 map);
uint16 __OVERLOAD__ shuffle2( uint16 x, uint16 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float2 x, float2 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float4 x, float4 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float8 x, float8 y, uint16 map);
float16 __OVERLOAD__ shuffle2( float16 x, float16 y, uint16 map);
long2 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong2 map);
long2 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong2 map);
ulong2 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong2 map);
double2 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong2 map);
long4 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong4 map);
long4 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong4 map);
ulong4 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong4 map);
double4 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong4 map);
long8 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong8 map);
long8 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong8 map);
ulong8 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong8 map);
double8 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong8 map);
long16 __OVERLOAD__ shuffle2( long2 x, long2 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long4 x, long4 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long8 x, long8 y, ulong16 map);
long16 __OVERLOAD__ shuffle2( long16 x, long16 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong2 x, ulong2 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong4 x, ulong4 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong8 x, ulong8 y, ulong16 map);
ulong16 __OVERLOAD__ shuffle2( ulong16 x, ulong16 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double2 x, double2 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double4 x, double4 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double8 x, double8 y, ulong16 map);
double16 __OVERLOAD__ shuffle2( double16 x, double16 y, ulong16 map);

int __printf_cl(constant char * restrict, ...);
#define printf __printf_cl


#if defined( __arm__ )

// Arm instrinsics for converting fixed to float or vice-versa (e.g. vcvtq_n_s32_f32)
// takes number of bits as an argument which needs to be compile time constant ... hence
// these builtins cannot be defined as builtin functions and need to be defined as macros.
 	
#define float_to_fixed_int_float(x, bits) ({ ((int2)__builtin_neon_vcvt_n_s32_v((float2)((x),(x)), (bits), 2)).x; })
#define float_to_fixed_int_float2(x, bits) ({ (int2)__builtin_neon_vcvt_n_s32_v((float2)(x), (bits), 2); })
#define float_to_fixed_int_float4(x, bits) ({ (int4)__builtin_neon_vcvtq_n_s32_v((float4)(x), (bits), 18); })
#define float_to_fixed_int_float8(x, bits) ({ (int8)(float_to_fixed_int_float4((x).hi, (bits)), float_to_fixed_int_float4((x).lo, (bits))); })
#define float_to_fixed_int_float16(x, bits) ({ (int16)(float_to_fixed_int_float8((x).hi, (bits)), float_to_fixed_int_float8((x).lo, (bits))); })

#define float_to_fixed_uint_float(x, bits) ({ ((uint2)__builtin_neon_vcvt_n_u32_v((float2)((x),(x)), (bits), 10)).x; })
#define float_to_fixed_uint_float2(x, bits) ({ (uint2)__builtin_neon_vcvt_n_u32_v((float2)(x), (bits), 10); })
#define float_to_fixed_uint_float4(x, bits) ({ (uint4)__builtin_neon_vcvtq_n_u32_v((float4)(x), (bits), 26); })
#define float_to_fixed_uint_float8(x, bits) ({ (uint8)(float_to_fixed_uint_float4((x).hi, (bits)), float_to_fixed_uint_float4((x).lo, (bits))); })
#define float_to_fixed_uint_float16(x, bits) ({ (uint16)(float_to_fixed_uint_float8((x).hi, (bits)), float_to_fixed_uint_float8((x).lo, (bits))); })

#define fixed_to_float_int_int(x, bits) ({ ((float2)__builtin_neon_vcvt_n_f32_v((int2)((x),(x)), (bits), 2)).x; })
#define fixed_to_float_int_int2(x, bits) ({ (float2)__builtin_neon_vcvt_n_f32_v((int2)(x), (bits), 2); })
#define fixed_to_float_int_int4(x, bits) ({ (float4)__builtin_neon_vcvtq_n_f32_v((int4)(x), (bits), 18); })
#define fixed_to_float_int_int8(x, bits) ({ (float8)(fixed_to_float_int_int4((x).hi, (bits)), fixed_to_float_int_int4((x).lo, (bits))); })
#define fixed_to_float_int_int16(x, bits) ({ (float16)(fixed_to_float_int_int8((x).hi, (bits)), fixed_to_float_int_int8((x).lo, (bits))); })

#define fixed_to_float_uint_uint(x, bits) ({ ((float2)__builtin_neon_vcvt_n_f32_v((uint2)((x),(x)), (bits), 10)).x; })
#define fixed_to_float_uint_uint2(x, bits) ({ (float2)__builtin_neon_vcvt_n_f32_v((uint2)(x), (bits), 10); })
#define fixed_to_float_uint_uint4(x, bits) ({ (float4)__builtin_neon_vcvtq_n_f32_v((uint4)(x), (bits), 26); })
#define fixed_to_float_uint_uint8(x, bits) ({ (float8)(fixed_to_float_uint_uint4((x).hi, (bits)), fixed_to_float_uint_uint4((x).lo, (bits))); })
#define fixed_to_float_uint_uint16(x, bits) ({ (float16)(fixed_to_float_uint_uint8((x).hi, (bits)), fixed_to_float_uint_uint8((x).lo, (bits))); })

#else

int __OVERLOAD__ float_to_fixed_int_float(float x, const int bits);
int2 __OVERLOAD__ float_to_fixed_int_float2(float2 x, const int bits);
int4 __OVERLOAD__ float_to_fixed_int_float4(float4 x, const int bits);
int8 __OVERLOAD__ float_to_fixed_int_float8(float8 x, const int bits);
int16 __OVERLOAD__ float_to_fixed_int_float16(float16 x, const int bits);

uint __OVERLOAD__ float_to_fixed_uint_float(float x, const int bits);
uint2 __OVERLOAD__ float_to_fixed_uint_float2(float2 x, const int bits);
uint4 __OVERLOAD__ float_to_fixed_uint_float4(float4 x, const int bits);
uint8 __OVERLOAD__ float_to_fixed_uint_float8(float8 x, const int bits);
uint16 __OVERLOAD__ float_to_fixed_uint_float16(float16 x, const int bits);

float __OVERLOAD__ fixed_to_float_int_int(int x, int bits);
float2 __OVERLOAD__ fixed_to_float_int_int2(int2 x, int bits);
float4 __OVERLOAD__ fixed_to_float_int_int4(int4 x, int bits);
float8 __OVERLOAD__ fixed_to_float_int_int8(int8 x, int bits);
float16 __OVERLOAD__ fixed_to_float_int_int16(int16 x, int bits);

float __OVERLOAD__ fixed_to_float_uint_uint(uint x, int bits);
float2 __OVERLOAD__ fixed_to_float_uint_uint2(uint2 x, int bits);
float4 __OVERLOAD__ fixed_to_float_uint_uint4(uint4 x, int bits);
float8 __OVERLOAD__ fixed_to_float_uint_uint8(uint8 x, int bits);
float16 __OVERLOAD__ fixed_to_float_uint_uint16(uint16 x, int bits);

#endif

#endif  // __CL_KERNEL_H
                                                                                                                                                                                                                                                                                                                                                                                                                        cl_kernel_shared.h                                                                                  0100644 0001750 0001750 00000014611 12174012604 036575  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/A/lib/clang/3.2/include                                                        /*******************************************************************************
 * Copyright:  (c) 2008-2012 by Apple, Inc., All Rights Reserved.
 ******************************************************************************/


#ifndef __CL_KERNEL_SHARED_H__
#define __CL_KERNEL_SHARED_H__

#ifndef __OPENCL_TYPES_DEFINED__
    #include <stddef.h>
    #include <stdint.h>

    typedef char            char16      __attribute__ ((__vector_size__(16)));
    typedef unsigned char   uchar16     __attribute__ ((__vector_size__(16)));
    typedef short           short8      __attribute__ ((__vector_size__(16)));
    typedef unsigned short  ushort8     __attribute__ ((__vector_size__(16)));
    typedef float           float4      __attribute__ ((__vector_size__(16)));
    typedef int             int4        __attribute__ ((__vector_size__(16)));
    typedef unsigned int    uint4       __attribute__ ((__vector_size__(16)));
    typedef long long       long2       __attribute__ ((__vector_size__(16)));
    typedef unsigned long long  ulong2  __attribute__ ((__vector_size__(16)));
    typedef double          double2     __attribute__ ((__vector_size__(16)));
    typedef size_t          event_t;
    typedef unsigned char   uchar;
    typedef unsigned short  ushort;
    typedef unsigned int    uint;

    typedef struct short16{ short8 lo, hi;  }short16;
    typedef struct ushort16{ ushort8 lo, hi;  }ushort16;

    typedef struct int8{ int4 lo,hi; }int8;
    typedef struct int16{ int8 lo,hi; }int16;

    typedef struct uint8{ uint4 lo,hi; }uint8;
    typedef struct uint16{ uint8 lo,hi; }uint16;

    typedef struct float8{ float4 lo,hi; }float8;
    typedef struct float16{ float8 lo,hi; }float16;
    typedef struct float32{ float16 lo,hi; }float32;

    #define __OPENCL_TYPES_DEFINED__
#endif /* __OPENCL_TYPES_DEFINED__ */

// Channel order; MUST be kept in sync with cld_internal.h in the drivers.
enum {
  CLK_R,
  CLK_A,
  CLK_RG,
  CLK_RA,
  CLK_RGB,
  CLK_RGBA,
  CLK_ARGB,
  CLK_BGRA,
  CLK_INTENSITY,
  CLK_LUMINANCE,
  CLK_Rx,
  CLK_RGx,
  CLK_RGBx,
  CLK_1RGB_APPLE,
  CLK_BGR1_APPLE,
  CLK_422_YCbYCr_APPLE,
  CLK_422_CbYCrY_APPLE,
  CLK_DEPTH_STENCIL,
  CLK_DEPTH,
  CLK_ABGR_APPLE
};

// Extension: cl_APPLE_yuv
// YUV color conversion matrices
enum {
    CLK_ITU_601_APPLE = 0x1000000A,
    CLK_ITU_709_APPLE = 0x1000000B
};

// Extension: cl_APPLE_yuv
// YUV chroma siting
enum {
    CLK_CHROMA_CENTERED_APPLE = 0x1000000C,
    CLK_CHROMA_COSITED_APPLE = 0x1000000D
};

typedef enum clk_channel_type{
  // valid formats for float return types
  CLK_SNORM_INT8,            // four channel RGBA unorm8
  CLK_UNORM_INT8,            // four channel RGBA unorm8
  CLK_SNORM_INT16,           // four channel RGBA unorm16
  CLK_UNORM_INT16,           // four channel RGBA unorm16
  CLK_HALF_FLOAT,            // four channel RGBA half
  CLK_FLOAT,                 // four channel RGBA float

  // valid only for integer return types
  CLK_SIGNED_INT8,
  CLK_SIGNED_INT16,
  CLK_SIGNED_INT32,
  CLK_UNSIGNED_INT8,
  CLK_UNSIGNED_INT16,
  CLK_UNSIGNED_INT32,

  CLK_UNORM_INT24,
  
  // CI SPI for CPU
  __CLK_UNORM_INT8888,         // four channel ARGB unorm8
  __CLK_UNORM_INT8888R,        // four channel BGRA unorm8
  __CLK_UNORM_INT8A,           // single channel CL_A unorm8
  __CLK_UNORM_INT8I,           // single channel CL_INTENSITY unorm8

  CLK_UNORM_SHORT_565,
  CLK_UNORM_SHORT_555,
  CLK_UNORM_INT_101010,
  
  CLK_UNORM_INT8_ITU_601_APPLE,
  CLK_UNORM_INT8_ITU_709_APPLE,
  CLK_SFIXED14_APPLE,
  CLK_BIASED_HALF_APPLE,
  
  __CLK_VALID_IMAGE_TYPE_COUNT,
  __CLK_INVALID_IMAGE_TYPE = __CLK_VALID_IMAGE_TYPE_COUNT,
  __CLK_VALID_IMAGE_TYPE_MASK_BITS = 5,         // number of bits required to represent any image type
  __CLK_VALID_IMAGE_TYPE_MASK = ( 1 << __CLK_VALID_IMAGE_TYPE_MASK_BITS ) - 1
}clk_channel_type;

typedef enum clk_sampler_type
{
    __CLK_ADDRESS_BASE             = 0,
    CLK_ADDRESS_NONE               = 0 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_CLAMP              = 1 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_CLAMP_TO_EDGE      = 2 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_REPEAT             = 3 << __CLK_ADDRESS_BASE,
    CLK_ADDRESS_MIRRORED_REPEAT    = 4 << __CLK_ADDRESS_BASE,
    __CLK_ADDRESS_MASK             = CLK_ADDRESS_NONE | CLK_ADDRESS_CLAMP | CLK_ADDRESS_CLAMP_TO_EDGE | CLK_ADDRESS_REPEAT | CLK_ADDRESS_MIRRORED_REPEAT,
    __CLK_ADDRESS_BITS             = 3,        // number of bits required to represent address info

    __CLK_NORMALIZED_BASE          = __CLK_ADDRESS_BITS,
    CLK_NORMALIZED_COORDS_FALSE    = 0,
    CLK_NORMALIZED_COORDS_TRUE     = 1 << __CLK_NORMALIZED_BASE,
    __CLK_NORMALIZED_MASK          = CLK_NORMALIZED_COORDS_FALSE | CLK_NORMALIZED_COORDS_TRUE,
    __CLK_NORMALIZED_BITS          = 1,        // number of bits required to represent normalization 

    __CLK_FILTER_BASE              = __CLK_NORMALIZED_BASE + __CLK_NORMALIZED_BITS,
    CLK_FILTER_NEAREST             = 0 << __CLK_FILTER_BASE,
    CLK_FILTER_LINEAR              = 1 << __CLK_FILTER_BASE,
    CLK_FILTER_ANISOTROPIC         = 2 << __CLK_FILTER_BASE,
    __CLK_FILTER_MASK              = CLK_FILTER_NEAREST | CLK_FILTER_LINEAR | CLK_FILTER_ANISOTROPIC,
    __CLK_FILTER_BITS              = 2,        // number of bits required to represent address info

    __CLK_MIP_BASE                 = __CLK_FILTER_BASE + __CLK_FILTER_BITS,
    CLK_MIP_NEAREST                = 0 << __CLK_MIP_BASE,
    CLK_MIP_LINEAR                 = 1 << __CLK_MIP_BASE,
    CLK_MIP_ANISOTROPIC            = 2 << __CLK_MIP_BASE,
    __CLK_MIP_MASK                 = CLK_MIP_NEAREST | CLK_MIP_LINEAR | CLK_MIP_ANISOTROPIC,
    __CLK_MIP_BITS                 = 2,
  
    __CLK_SAMPLER_BITS             = __CLK_MIP_BASE + __CLK_MIP_BITS,
    __CLK_SAMPLER_MASK             = __CLK_MIP_MASK | __CLK_FILTER_MASK | __CLK_NORMALIZED_MASK | __CLK_ADDRESS_MASK,
    
    __CLK_ANISOTROPIC_RATIO_BITS   = 5,
    __CLK_ANISOTROPIC_RATIO_MASK   = (int) 0x80000000 >> (__CLK_ANISOTROPIC_RATIO_BITS-1)
}clk_sampler_type;


#if defined( __clang__ )
    //FIXME: commented out per <rdar://problem/6307429> ABI bustage in read_image
    #define __FAST_CALL           /* __attribute__ ((fastcall)) */
    #define __ALWAYS_INLINE       __attribute__ ((__always_inline__))
    #define INLINE                  inline
#else
    // compiling GCC version for debugging
    #define __FAST_CALL
    #define __ALWAYS_INLINE      __attribute__ (( __noinline__))
    #define INLINE
#endif

#endif /* __CL_KERNEL_SHARED_H__ */

                                                                                                                       osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/Versions/Current     0120777 0001750 0001750 00000000000 12620245063 030727  2A                                                                                                   ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenCL.framework/module.map           0100644 0001750 0001750 00000000247 12566173265 027454  0                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        framework module OpenCL [extern_c] {
  umbrella header "opencl.h"

  export *
  module * { export * }

  exclude header "cl_kernel.h"
  exclude header "gcl_priv.h"
}

                                                                                                                                                                                                                                                                                                                                                         osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/              0040755 0001750 0001750 00000000000 12612224743 027124  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Frameworks    0120777 0001750 0001750 00000000000 12620245063 036455  2Versions/Current/Frameworks                                                                         ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Headers       0120777 0001750 0001750 00000000000 12620245063 035143  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000                                                                                                                                                                        OpenDirectory.tbd                                                                                   0120777 0001750 0001750 00000000000 12620245063 041032  2Versions/Current/OpenDirectory.tbd                                                                  ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework                                                                                  osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/     0040755 0001750 0001750 00000000000 12612224743 030734  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/   0040755 0001750 0001750 00000000000 12612224743 031114  5                                                                                                    ustar 00                                                                0000000 0000000                                                                                                                                                                        Frameworks/                                                                                         0040755 0001750 0001750 00000000000 12612224743 033155  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A                                                                       CFOpenDirectory.framework/                                                                          0040755 0001750 0001750 00000000000 12612224743 040150  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks                                                            CFOpenDirectory.tbd                                                                                 0120777 0001750 0001750 00000000000 12620245063 052557  2Versions/Current/CFOpenDirectory.tbd                                                                ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework                                  Headers                                                                                             0120777 0001750 0001750 00000000000 12620245063 046167  2Versions/Current/Headers                                                                            ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework                                  Versions/                                                                                           0040755 0001750 0001750 00000000000 12612224743 041760  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework                                  A/                                                                                                  0040755 0001750 0001750 00000000000 12612224743 042140  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions                         CFOpenDirectory.tbd                                                                                 0100644 0001750 0001750 00000053024 12571375067 045645  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A                       ---
archs:           [ i386, x86_64 ]
platform:        macosx
install-name:    /System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/CFOpenDirectory
exports:         
  - archs:           [ i386, x86_64 ]
    symbols:         [ _ODContextGetTypeID, _ODConvertToLegacyErrorCode, 
                       _ODNodeAddAccountPolicy, _ODNodeCopyAccountPolicies, 
                       _ODNodeCopyCredentials, _ODNodeCopyDetails, _ODNodeCopyPolicies, 
                       _ODNodeCopyRecord, _ODNodeCopyRecordAuthenticationData, 
                       _ODNodeCopySession, _ODNodeCopySubnodeNames, _ODNodeCopySupportedAttributes, 
                       _ODNodeCopySupportedPolicies, _ODNodeCopySupportedRecordTypes, 
                       _ODNodeCopyUnreachableSubnodeNames, _ODNodeCreateCopy, 
                       _ODNodeCreateRecord, _ODNodeCreateWithDSRef, _ODNodeCreateWithName, 
                       _ODNodeCreateWithNameAndOptions, _ODNodeCreateWithNodeType, 
                       _ODNodeCustomCall, _ODNodeCustomFunction, _ODNodeGetDSRef, 
                       _ODNodeGetName, _ODNodeGetTypeID, _ODNodePasswordContentCheck, 
                       _ODNodeRemoveAccountPolicy, _ODNodeRemovePolicy, 
                       _ODNodeSetAccountPolicies, _ODNodeSetCredentials, 
                       _ODNodeSetCredentialsExtended, _ODNodeSetCredentialsUsingKerberosCache, 
                       _ODNodeSetPolicies, _ODNodeSetPolicy, _ODNodeVerifyCredentialsExtended, 
                       _ODQueryCopyResults, _ODQueryCreateWithNode, _ODQueryCreateWithNodeType, 
                       _ODQueryGetTypeID, _ODQueryScheduleWithRunLoop, 
                       _ODQuerySetCallback, _ODQuerySetDispatchQueue, _ODQuerySynchronize, 
                       _ODQueryUnscheduleFromRunLoop, _ODRecordAddAccountPolicy, 
                       _ODRecordAddMember, _ODRecordAddValue, _ODRecordAuthenticationAllowed, 
                       _ODRecordChangePassword, _ODRecordContainsMember, 
                       _ODRecordContainsMemberRefresh, _ODRecordCopyAccountPolicies, 
                       _ODRecordCopyDetails, _ODRecordCopyEffectivePolicies, 
                       _ODRecordCopyPasswordContentSummary, _ODRecordCopyPasswordPolicy, 
                       _ODRecordCopyPolicies, _ODRecordCopySupportedPolicies, 
                       _ODRecordCopyValues, _ODRecordDelete, _ODRecordEnumerateMembers, 
                       _ODRecordEnumerateMembership, _ODRecordGetRecordName, 
                       _ODRecordGetRecordType, _ODRecordGetTypeID, _ODRecordPasswordChangeAllowed, 
                       _ODRecordRemoveAccountPolicy, _ODRecordRemoveMember, 
                       _ODRecordRemovePolicy, _ODRecordRemoveValue, _ODRecordSecondsUntilAuthenticationsExpire, 
                       _ODRecordSecondsUntilPasswordExpires, _ODRecordSetAccountPolicies, 
                       _ODRecordSetNodeCredentials, _ODRecordSetNodeCredentialsExtended, 
                       _ODRecordSetNodeCredentialsUsingKerberosCache, _ODRecordSetPolicies, 
                       _ODRecordSetPolicy, _ODRecordSetValue, _ODRecordSynchronize, 
                       _ODRecordVerifyPassword, _ODRecordVerifyPasswordExtended, 
                       _ODRecordWillAuthenticationsExpire, _ODRecordWillPasswordExpire, 
                       _ODSessionCopyNodeNames, _ODSessionCopySessionKeySupport, 
                       _ODSessionCreate, _ODSessionCreateWithDSRef, _ODSessionGetDSRef, 
                       _ODSessionGetTypeID, _ODSessionIsProxy, _ODSessionNodeNameIsLocal, 
                       _ODSessionProxyAuthorizationForm, _ODTriggerCancel, 
                       _ODTriggerCreateForNodes, _ODTriggerCreateForRecordAttributes, 
                       _ODTriggerCreateForRecords, _ODTriggerCreateForSearch, 
                       _ODTriggerGetTypeID, __NodeGetNodeTypeName, __ODInitialize, 
                       __ODNodeCreate, __ODNodeInit, __ODQueryCreate, __ODQueryGetDelegate, 
                       __ODQueryGetOperationQueue, __ODQueryInit, __ODQuerySetDelegate, 
                       __ODQuerySetOperationQueue, __ODSessionCreate, __ODSessionGetShared, 
                       __ODSessionInit, _kODAttributeTypeAccessControlEntry, 
                       _kODAttributeTypeAddressLine1, _kODAttributeTypeAddressLine2, 
                       _kODAttributeTypeAddressLine3, _kODAttributeTypeAdminLimits, 
                       _kODAttributeTypeAdvertisedServices, _kODAttributeTypeAlias, 
                       _kODAttributeTypeAllAttributes, _kODAttributeTypeAllTypes, 
                       _kODAttributeTypeAltSecurityIdentities, _kODAttributeTypeAreaCode, 
                       _kODAttributeTypeAttrListRefCount, _kODAttributeTypeAttrListRefs, 
                       _kODAttributeTypeAttrListValueRefCount, _kODAttributeTypeAttrListValueRefs, 
                       _kODAttributeTypeAuthCredential, _kODAttributeTypeAuthMethod, 
                       _kODAttributeTypeAuthenticationAuthority, _kODAttributeTypeAuthenticationHint, 
                       _kODAttributeTypeAuthorityRevocationList, _kODAttributeTypeAutomaticSearchPath, 
                       _kODAttributeTypeAutomountInformation, _kODAttributeTypeBirthday, 
                       _kODAttributeTypeBootParams, _kODAttributeTypeBuildVersion, 
                       _kODAttributeTypeBuilding, _kODAttributeTypeCACertificate, 
                       _kODAttributeTypeCapacity, _kODAttributeTypeCategory, 
                       _kODAttributeTypeCertificateRevocationList, _kODAttributeTypeCity, 
                       _kODAttributeTypeComment, _kODAttributeTypeCompany, 
                       _kODAttributeTypeComputers, _kODAttributeTypeConfigAvailable, 
                       _kODAttributeTypeConfigFile, _kODAttributeTypeContactGUID, 
                       _kODAttributeTypeContactPerson, _kODAttributeTypeCopyTimestamp, 
                       _kODAttributeTypeCoreFWVersion, _kODAttributeTypeCountry, 
                       _kODAttributeTypeCreationTimestamp, _kODAttributeTypeCrossCertificatePair, 
                       _kODAttributeTypeCustomSearchPath, _kODAttributeTypeDNSDomain, 
                       _kODAttributeTypeDNSName, _kODAttributeTypeDNSNameServer, 
                       _kODAttributeTypeDataStamp, _kODAttributeTypeDateRecordCreated, 
                       _kODAttributeTypeDepartment, _kODAttributeTypeDirRefCount, 
                       _kODAttributeTypeDirRefs, _kODAttributeTypeEMailAddress, 
                       _kODAttributeTypeEMailContacts, _kODAttributeTypeENetAddress, 
                       _kODAttributeTypeExpire, _kODAttributeTypeFWVersion, 
                       _kODAttributeTypeFaxNumber, _kODAttributeTypeFirstName, 
                       _kODAttributeTypeFullName, _kODAttributeTypeFunctionalState, 
                       _kODAttributeTypeGUID, _kODAttributeTypeGroup, _kODAttributeTypeGroupMembers, 
                       _kODAttributeTypeGroupMembership, _kODAttributeTypeGroupServices, 
                       _kODAttributeTypeHTML, _kODAttributeTypeHardwareUUID, 
                       _kODAttributeTypeHomeDirectory, _kODAttributeTypeHomeDirectoryQuota, 
                       _kODAttributeTypeHomeDirectorySoftQuota, _kODAttributeTypeHomeLocOwner, 
                       _kODAttributeTypeHomePhoneNumber, _kODAttributeTypeIMHandle, 
                       _kODAttributeTypeIPAddress, _kODAttributeTypeIPAddressAndENetAddress, 
                       _kODAttributeTypeIPv6Address, _kODAttributeTypeInternetAlias, 
                       _kODAttributeTypeJPEGPhoto, _kODAttributeTypeJobTitle, 
                       _kODAttributeTypeKDCAuthKey, _kODAttributeTypeKDCConfigData, 
                       _kODAttributeTypeKerberosACL, _kODAttributeTypeKerberosKeySet, 
                       _kODAttributeTypeKerberosPrincipalACL, _kODAttributeTypeKerberosPrincipalAliases, 
                       _kODAttributeTypeKerberosPrincipalName, _kODAttributeTypeKerberosRealm, 
                       _kODAttributeTypeKerberosServices, _kODAttributeTypeKerberosTicketPolicy, 
                       _kODAttributeTypeKeywords, _kODAttributeTypeLDAPReadReplicas, 
                       _kODAttributeTypeLDAPSearchBaseSuffix, _kODAttributeTypeLDAPWriteReplicas, 
                       _kODAttributeTypeLastName, _kODAttributeTypeLocalOnlySearchPath, 
                       _kODAttributeTypeLocaleRelay, _kODAttributeTypeLocaleSubnets, 
                       _kODAttributeTypeLocation, _kODAttributeTypeMCXFlags, 
                       _kODAttributeTypeMCXSettings, _kODAttributeTypeMIME, 
                       _kODAttributeTypeMailAttribute, _kODAttributeTypeMapCoordinates, 
                       _kODAttributeTypeMapGUID, _kODAttributeTypeMapURI, 
                       _kODAttributeTypeMetaAmbiguousName, _kODAttributeTypeMetaAugmentedAttributes, 
                       _kODAttributeTypeMetaAutomountMap, _kODAttributeTypeMetaNodeLocation, 
                       _kODAttributeTypeMetaRecordName, _kODAttributeTypeMiddleName, 
                       _kODAttributeTypeMobileNumber, _kODAttributeTypeModificationTimestamp, 
                       _kODAttributeTypeNFSHomeDirectory, _kODAttributeTypeNTDomainComputerAccount, 
                       _kODAttributeTypeNamePrefix, _kODAttributeTypeNameSuffix, 
                       _kODAttributeTypeNativeOnly, _kODAttributeTypeNestedGroups, 
                       _kODAttributeTypeNetGroupTriplet, _kODAttributeTypeNetGroups, 
                       _kODAttributeTypeNetworkInterfaces, _kODAttributeTypeNetworkNumber, 
                       _kODAttributeTypeNickName, _kODAttributeTypeNodeOptions, 
                       _kODAttributeTypeNodePath, _kODAttributeTypeNodeRefCount, 
                       _kODAttributeTypeNodeRefs, _kODAttributeTypeNodeSASLRealm, 
                       _kODAttributeTypeNote, _kODAttributeTypeNumTableList, 
                       _kODAttributeTypeOperatingSystem, _kODAttributeTypeOperatingSystemVersion, 
                       _kODAttributeTypeOrganizationInfo, _kODAttributeTypeOrganizationName, 
                       _kODAttributeTypeOriginalHomeDirectory, _kODAttributeTypeOriginalNFSHomeDirectory, 
                       _kODAttributeTypeOriginalNodeName, _kODAttributeTypeOwner, 
                       _kODAttributeTypeOwnerGUID, _kODAttributeTypePGPPublicKey, 
                       _kODAttributeTypePIDValue, _kODAttributeTypePagerNumber, 
                       _kODAttributeTypeParentLocales, _kODAttributeTypePassword, 
                       _kODAttributeTypePasswordPlus, _kODAttributeTypePasswordPolicyOptions, 
                       _kODAttributeTypePasswordServerList, _kODAttributeTypePasswordServerLocation, 
                       _kODAttributeTypePhoneContacts, _kODAttributeTypePhoneNumber, 
                       _kODAttributeTypePicture, _kODAttributeTypePlugInInfo, 
                       _kODAttributeTypePluginIndex, _kODAttributeTypePort, 
                       _kODAttributeTypePostalAddress, _kODAttributeTypePostalAddressContacts, 
                       _kODAttributeTypePostalCode, _kODAttributeTypePresetUserIsAdmin, 
                       _kODAttributeTypePrimaryComputerGUID, _kODAttributeTypePrimaryComputerList, 
                       _kODAttributeTypePrimaryGroupID, _kODAttributeTypePrimaryLocale, 
                       _kODAttributeTypePrimaryNTDomain, _kODAttributeTypePrintServiceInfoText, 
                       _kODAttributeTypePrintServiceInfoXML, _kODAttributeTypePrintServiceUserData, 
                       _kODAttributeTypePrinter1284DeviceID, _kODAttributeTypePrinterLPRHost, 
                       _kODAttributeTypePrinterLPRQueue, _kODAttributeTypePrinterMakeAndModel, 
                       _kODAttributeTypePrinterType, _kODAttributeTypePrinterURI, 
                       _kODAttributeTypePrinterXRISupported, _kODAttributeTypeProcessName, 
                       _kODAttributeTypeProfiles, _kODAttributeTypeProfilesTimestamp, 
                       _kODAttributeTypeProtocolNumber, _kODAttributeTypeProtocols, 
                       _kODAttributeTypePwdAgingPolicy, _kODAttributeTypeRPCNumber, 
                       _kODAttributeTypeReadOnlyNode, _kODAttributeTypeRealUserID, 
                       _kODAttributeTypeRecRefCount, _kODAttributeTypeRecRefs, 
                       _kODAttributeTypeRecordName, _kODAttributeTypeRecordType, 
                       _kODAttributeTypeRelationships, _kODAttributeTypeRelativeDNPrefix, 
                       _kODAttributeTypeResourceInfo, _kODAttributeTypeResourceType, 
                       _kODAttributeTypeSMBAcctFlags, _kODAttributeTypeSMBGroupRID, 
                       _kODAttributeTypeSMBHome, _kODAttributeTypeSMBHomeDrive, 
                       _kODAttributeTypeSMBKickoffTime, _kODAttributeTypeSMBLogoffTime, 
                       _kODAttributeTypeSMBLogonTime, _kODAttributeTypeSMBPWDLastSet, 
                       _kODAttributeTypeSMBPrimaryGroupSID, _kODAttributeTypeSMBProfilePath, 
                       _kODAttributeTypeSMBRID, _kODAttributeTypeSMBSID, 
                       _kODAttributeTypeSMBScriptPath, _kODAttributeTypeSMBUserWorkstations, 
                       _kODAttributeTypeSchema, _kODAttributeTypeSearchPath, 
                       _kODAttributeTypeSearchPolicy, _kODAttributeTypeServiceType, 
                       _kODAttributeTypeServicesLocator, _kODAttributeTypeSetupAdvertising, 
                       _kODAttributeTypeSetupAutoRegister, _kODAttributeTypeSetupLocation, 
                       _kODAttributeTypeSetupOccupation, _kODAttributeTypeStandardOnly, 
                       _kODAttributeTypeState, _kODAttributeTypeStreet, 
                       _kODAttributeTypeSubNodes, _kODAttributeTypeTimePackage, 
                       _kODAttributeTypeTimeToLive, _kODAttributeTypeTotalRefCount, 
                       _kODAttributeTypeTotalSize, _kODAttributeTypeTrustInformation, 
                       _kODAttributeTypeURL, _kODAttributeTypeUniqueID, 
                       _kODAttributeTypeUserCertificate, _kODAttributeTypeUserPKCS12Data, 
                       _kODAttributeTypeUserSMIMECertificate, _kODAttributeTypeUserShell, 
                       _kODAttributeTypeVFSDumpFreq, _kODAttributeTypeVFSLinkDir, 
                       _kODAttributeTypeVFSOpts, _kODAttributeTypeVFSPassNo, 
                       _kODAttributeTypeVFSType, _kODAttributeTypeVersion, 
                       _kODAttributeTypeWeblogURI, _kODAttributeTypeXMLPlist, 
                       _kODAuthenticationType2WayRandom, _kODAuthenticationType2WayRandomChangePasswd, 
                       _kODAuthenticationTypeAPOP, _kODAuthenticationTypeCRAM_MD5, 
                       _kODAuthenticationTypeChangePasswd, _kODAuthenticationTypeClearText, 
                       _kODAuthenticationTypeCrypt, _kODAuthenticationTypeDIGEST_MD5, 
                       _kODAuthenticationTypeDeleteUser, _kODAuthenticationTypeGetEffectivePolicy, 
                       _kODAuthenticationTypeGetGlobalPolicy, _kODAuthenticationTypeGetKerberosPrincipal, 
                       _kODAuthenticationTypeGetPolicy, _kODAuthenticationTypeGetUserData, 
                       _kODAuthenticationTypeGetUserName, _kODAuthenticationTypeKerberosTickets, 
                       _kODAuthenticationTypeMPPEMasterKeys, _kODAuthenticationTypeMSCHAP2, 
                       _kODAuthenticationTypeNTLMv2, _kODAuthenticationTypeNTLMv2WithSessionKey, 
                       _kODAuthenticationTypeNewUser, _kODAuthenticationTypeNewUserWithPolicy, 
                       _kODAuthenticationTypeNodeNativeClearTextOK, _kODAuthenticationTypeNodeNativeNoClearText, 
                       _kODAuthenticationTypeNodeNativeRetainCredential, 
                       _kODAuthenticationTypeNodePPS, _kODAuthenticationTypeReadSecureHash, 
                       _kODAuthenticationTypeSMBNTv2UserSessionKey, _kODAuthenticationTypeSMBWorkstationCredentialSessionKey, 
                       _kODAuthenticationTypeSMB_LM_Key, _kODAuthenticationTypeSMB_NT_Key, 
                       _kODAuthenticationTypeSMB_NT_UserSessionKey, _kODAuthenticationTypeSMB_NT_WithUserSessionKey, 
                       _kODAuthenticationTypeSecureHash, _kODAuthenticationTypeSetGlobalPolicy, 
                       _kODAuthenticationTypeSetLMHash, _kODAuthenticationTypeSetNTHash, 
                       _kODAuthenticationTypeSetPassword, _kODAuthenticationTypeSetPasswordAsCurrent, 
                       _kODAuthenticationTypeSetPolicy, _kODAuthenticationTypeSetPolicyAsCurrent, 
                       _kODAuthenticationTypeSetUserData, _kODAuthenticationTypeSetUserName, 
                       _kODAuthenticationTypeSetWorkstationPassword, _kODAuthenticationTypeWithAuthorizationRef, 
                       _kODAuthenticationTypeWriteSecureHash, _kODErrorDomainFramework, 
                       _kODModuleConfigOptionConnectionIdleDisconnect, 
                       _kODModuleConfigOptionConnectionSetupTimeout, _kODModuleConfigOptionManInTheMiddle, 
                       _kODModuleConfigOptionPacketEncryption, _kODModuleConfigOptionPacketSigning, 
                       _kODModuleConfigOptionQueryTimeout, _kODNodeOptionsQuerySkippedSubnode, 
                       _kODPolicyAttributeCreationTime, _kODPolicyAttributeCurrentDate, 
                       _kODPolicyAttributeCurrentDayOfWeek, _kODPolicyAttributeCurrentTime, 
                       _kODPolicyAttributeCurrentTimeOfDay, _kODPolicyAttributeDaysUntilExpiration, 
                       _kODPolicyAttributeEnableAtTimeOfDay, _kODPolicyAttributeEnableOnDate, 
                       _kODPolicyAttributeEnableOnDayOfWeek, _kODPolicyAttributeExpiresAtTimeOfDay, 
                       _kODPolicyAttributeExpiresEveryNDays, _kODPolicyAttributeExpiresOnDate, 
                       _kODPolicyAttributeExpiresOnDayOfWeek, _kODPolicyAttributeFailedAuthentications, 
                       _kODPolicyAttributeLastAuthenticationTime, _kODPolicyAttributeLastFailedAuthenticationTime, 
                       _kODPolicyAttributeLastPasswordChangeTime, _kODPolicyAttributeMaximumFailedAuthentications, 
                       _kODPolicyAttributeNewPasswordRequiredTime, _kODPolicyAttributePassword, 
                       _kODPolicyAttributePasswordHashes, _kODPolicyAttributePasswordHistory, 
                       _kODPolicyAttributePasswordHistoryDepth, _kODPolicyAttributeRecordName, 
                       _kODPolicyAttributeRecordType, _kODPolicyCategoryAuthentication, 
                       _kODPolicyCategoryPasswordChange, _kODPolicyCategoryPasswordContent, 
                       _kODPolicyKeyContent, _kODPolicyKeyContentDescription, 
                       _kODPolicyKeyEvaluationDetails, _kODPolicyKeyIdentifier, 
                       _kODPolicyKeyParameters, _kODPolicyKeyPasswordContentSummaries, 
                       _kODPolicyKeyPolicySatisfied, _kODPolicyTypeAccountExpiresOnDate, 
                       _kODPolicyTypeAccountMaximumFailedLogins, _kODPolicyTypeAccountMaximumMinutesOfNonUse, 
                       _kODPolicyTypeAccountMaximumMinutesUntilDisabled, 
                       _kODPolicyTypeAccountMinutesUntilFailedLoginReset, 
                       _kODPolicyTypePasswordCannotBeAccountName, _kODPolicyTypePasswordChangeRequired, 
                       _kODPolicyTypePasswordHistory, _kODPolicyTypePasswordMaximumAgeInMinutes, 
                       _kODPolicyTypePasswordMaximumNumberOfCharacters, 
                       _kODPolicyTypePasswordMinimumNumberOfCharacters, 
                       _kODPolicyTypePasswordRequiresAlpha, _kODPolicyTypePasswordRequiresMixedCase, 
                       _kODPolicyTypePasswordRequiresNumeric, _kODPolicyTypePasswordRequiresSymbol, 
                       _kODPolicyTypePasswordSelfModification, _kODRecordTypeAFPServer, 
                       _kODRecordTypeAliases, _kODRecordTypeAttributeTypes, 
                       _kODRecordTypeAugments, _kODRecordTypeAutoServerSetup, 
                       _kODRecordTypeAutomount, _kODRecordTypeAutomountMap, 
                       _kODRecordTypeBootp, _kODRecordTypeCertificateAuthorities, 
                       _kODRecordTypeComputerGroups, _kODRecordTypeComputerLists, 
                       _kODRecordTypeComputers, _kODRecordTypeConfiguration, 
                       _kODRecordTypeEthernets, _kODRecordTypeFTPServer, 
                       _kODRecordTypeFileMakerServers, _kODRecordTypeGroups, 
                       _kODRecordTypeHostServices, _kODRecordTypeHosts, 
                       _kODRecordTypeLDAPServer, _kODRecordTypeLocations, 
                       _kODRecordTypeMounts, _kODRecordTypeNFS, _kODRecordTypeNetDomains, 
                       _kODRecordTypeNetGroups, _kODRecordTypeNetworks, 
                       _kODRecordTypePasswordServer, _kODRecordTypePeople, 
                       _kODRecordTypePlugins, _kODRecordTypePresetComputerGroups, 
                       _kODRecordTypePresetComputerLists, _kODRecordTypePresetComputers, 
                       _kODRecordTypePresetGroups, _kODRecordTypePresetUsers, 
                       _kODRecordTypePrintService, _kODRecordTypePrintServiceUser, 
                       _kODRecordTypePrinters, _kODRecordTypeProtocols, 
                       _kODRecordTypeQTSServer, _kODRecordTypeQueryInformation, 
                       _kODRecordTypeRPC, _kODRecordTypeRecordTypes, _kODRecordTypeResources, 
                       _kODRecordTypeSMBServer, _kODRecordTypeServer, _kODRecordTypeServices, 
                       _kODRecordTypeSharePoints, _kODRecordTypeUserAuthenticationData, 
                       _kODRecordTypeUsers, _kODRecordTypeWebServer, _kODSessionDefault, 
                       _kODSessionLocalPath, _kODSessionProxyAddress, _kODSessionProxyPassword, 
                       _kODSessionProxyPort, _kODSessionProxyUsername ]
...
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            Headers/                                                                                            0040755 0001750 0001750 00000000000 12612224743 043513  5                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A                       CFODContext.h                                                                                       0100644 0001750 0001750 00000002655 12566201065 045751  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFODCONTEXT__)
#define __OPENDIRECTORY_CFODCONTEXT__ 1

#include <CFOpenDirectory/CFOpenDirectory.h>

__BEGIN_DECLS

/*!
    @function   ODContextGetTypeID
    @abstract   Standard GetTypeID function support for CF-based objects
    @discussion Returns the typeID for the ODContext object
    @result     a valid CFTypeID for the ODContext object
*/
CF_EXPORT
CFTypeID ODContextGetTypeID(void);

__END_DECLS

#endif /* ! __OPENDIRECTORY_CFODCONTEXT__ */
                                                                                   CFODNode.h                                                                                          0100644 0001750 0001750 00000061110 12566201065 045201  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009-2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFODNODE__)
#define __OPENDIRECTORY_CFODNODE__ 1

#include <CFOpenDirectory/CFOpenDirectory.h>

__BEGIN_DECLS

/*!
    @function   ODNodeGetTypeID
    @abstract   Standard GetTypeID function support for CF-based objects
    @discussion Returns the typeID for the ODNode objects
    @result     a valid CFTypeID for the ODNode object
*/
CF_EXPORT
CFTypeID ODNodeGetTypeID(void) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCreateWithNodeType
    @abstract   Creates an ODNodeRef based on a specific node type
    @discussion Creates an ODNodeRef based on a specific node type
    @param      allocator a memory allocator to use for this object
    @param      session an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
    @param      nodeType an ODNodeType of the node to open
    @param      error an optional CFErrorRef reference for error details
    @result     a valid ODNodeRef if successful, otherwise returns NULL.  outError can be checked for details upon
                failure.
*/
CF_EXPORT
ODNodeRef ODNodeCreateWithNodeType(CFAllocatorRef allocator, ODSessionRef session, ODNodeType nodeType, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCreateWithName
    @abstract   Creates an ODNodeRef based on a partciular node name
    @discussion Creates an ODNodeRef based on a particular node name
    @param      allocator a memory allocator to use for this object
    @param      session an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
    @param      nodeName a CFStringRef of the name of the node to open
    @param      error an optional CFErrorRef reference for error details
    @result     a valid ODNodeRef if successful, otherwise returns NULL. outError can be checked for specific
                error
*/
CF_EXPORT
ODNodeRef ODNodeCreateWithName(CFAllocatorRef allocator, ODSessionRef session, CFStringRef nodeName, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCreateCopy
    @abstract   Creates a copy, including any remote credentials used for Proxy and/or Node authentication
    @discussion Creates a copy of the object including all credentials used for the original.  Can be used for future
                references to the same node setup.
    @param      allocator a memory allocator to use for this object
    @param      node an ODNodeRef to make a copy of
    @param      error an optional CFErrorRef reference for error details
    @result     a valid ODNodeRef if successful, otherwise returns NULL, with outError set to a CFErrorRef
*/
CF_EXPORT
ODNodeRef ODNodeCreateCopy(CFAllocatorRef allocator, ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopySubnodeNames
    @abstract   Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes
    @discussion Returns a CFArray of subnode names for this node, which may contain sub-nodes or search policy nodes.
                Commonly used with Search policy nodes.
    @param      node an ODNodeRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFArrayRef with the list of nodes, otherwise NULL, with outError set to a CFErrorRef
*/
CF_EXPORT
CFArrayRef ODNodeCopySubnodeNames(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopyUnreachableSubnodeNames
    @abstract   Will return names of subnodes that are not currently reachable.
    @discussion Will return names of subnodes that are not currently reachable.  Commonly used with Search policy nodes
                to determine if any nodes are currently unreachable, but may also return other subnodes if the
                Open Directory plugin supports.
    @param      node an ODNodeRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFArrayRef with the list of unreachable nodes or NULL if no bad nodes
*/
CF_EXPORT
CFArrayRef ODNodeCopyUnreachableSubnodeNames(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeGetName
    @abstract   Returns the node name of the node that was opened
    @discussion Returns the node name of the node that was opened
    @param      node an ODNodeRef to use
    @result     a CFStringRef of the node name that is current or NULL if no open node
*/
CF_EXPORT
CFStringRef ODNodeGetName(ODNodeRef node) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopyDetails
    @abstract   Returns a dictionary with details about the node in dictionary form
    @discussion Returns a dictionary with details about the node in dictionary form.
    @param      node an ODNodeRef to use
    @param      keys a CFArrayRef listing the keys the user wants returned, such as 
                kODAttributeTypeStreet
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing the requested key and values in form of a CFArray
*/
CF_EXPORT
CFDictionaryRef ODNodeCopyDetails(ODNodeRef node, CFArrayRef keys, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopySupportedRecordTypes
    @abstract   Returns a CFArrayRef of the record types supported by this node.
    @discussion Returns a CFArrayRef of the record types supported by this node.  If node does not support the check
                then all possible types will be returned.
    @param      node an ODNodeRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a valid CFArrayRef of CFStrings listing the supported Record types on this node.
*/
CF_EXPORT
CFArrayRef ODNodeCopySupportedRecordTypes(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopySupportedAttributes
    @abstract   Will return a list of attribute types supported for that attribute if possible
    @discussion Will return a list of attribute types supported for that attribute if possible.  If no specific
                types are available, then all possible values will be returned instead.
    @param      node an ODNodeRef to use
    @param      recordType a ODRecordTypeRef with the type of record to check attribute types.  If NULL is passed it will
                return all possible attributes that are available.
    @param      error an optional CFErrorRef reference for error details
    @result     a valid CFArrayRef of CFStrings listing the attributes supported for the requested record type
*/
CF_EXPORT
CFArrayRef ODNodeCopySupportedAttributes(ODNodeRef node, ODRecordType recordType, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeSetCredentials
    @abstract   Sets the credentials for interaction with the ODNode
    @discussion Sets the credentials for interaction with the ODNode.  Record references, etc. will use these credentials
                to query or change data.  Setting the credentials on a node referenced by other OD object types will
                change the credentials for all for all references.
    @param      node an ODNodeRef to use
    @param      recordType a ODRecordTypeRef of the Record Type to use, if NULL is passed, defaults to a 
                kODRecordTypeUsers
    @param      recordName a CFString of the username to be used for this node authentication
    @param      password a CFString of the password to be used for this node authentication
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details.  If the authentication failed, 
                the previous credentials are used.
*/
CF_EXPORT
bool ODNodeSetCredentials(ODNodeRef node, ODRecordType recordType, CFStringRef recordName, CFStringRef password, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeSetCredentialsExtended
    @abstract   Allows use of other Open Directory types of authentications to set the credentials for an ODNode
    @discussion Allows the caller to use other types of authentications that are available in Open Directory, that may
                require response-request loops, etc.  Not all OD plugins will support this call, look for 
                kODErrorCredentialsMethodNotSupported in outError.
    @param      node an ODNodeRef to use
    @param      recordType a ODRecordType of the type of record to do the authentication with
    @param      authType a ODAuthenticationType of the type of authentication to be used (e.g., kDSStdAuthNTLMv2)
    @param      authItems a CFArray of CFData or CFString items that will be sent in order to the auth process
    @param      outAuthItems will be assigned to a pointer of a CFArray of CFData items if there are returned values
    @param      outContext will return a pointer to a context if caller supplies a container, and the call requires a
                context.  If a non-NULL value is returned, then more calls must be made with the Context to continue
                the authorization.
    @param      error an optional CFErrorRef reference for error details
    @result     a bool will be returned with the result of the operation and outAuthItems set with response items
                and outContext set for any needed continuation.
*/
CF_EXPORT
bool ODNodeSetCredentialsExtended(ODNodeRef node, ODRecordType recordType, ODAuthenticationType authType, CFArrayRef authItems, CFArrayRef *outAuthItems, ODContextRef *outContext, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeSetCredentialsUsingKerberosCache
    @abstract   Unsupported function.
    @discussion Unsupported function.
*/
CF_EXPORT
bool ODNodeSetCredentialsUsingKerberosCache(ODNodeRef node, CFStringRef cacheName, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_7, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   ODNodeCreateRecord
    @abstract   Takes a record and all of the provided attributes and creates the record in the node
    @discussion Takes all the provided attributes and type to create an entire record.  The function will assign a
                UUID to the record automatically.  This UUID can be overwritten by the client by passing with the
                other attributes.
    @param      node an ODNodeRef to use
    @param      recordType a ODRecordTypeRef of the type of record (e.g., kODRecordTypeUsers, etc.)
    @param      recordName a CFStringRef of the name of record
    @param      attributeDict a CFDictionaryRef of key-value pairs for attribute values.  The key is a CFStringRef of the
                attribute name or ODRecordType constant such as kODAttributeTypeRecordName.  The value must be a CFArrayRef of
                CFDataRef or CFStringRef.  If additional kODAttributeTypeRecordName are to be set, they can be passed in the 
                inAttributes list.  This parameter is optional and can be NULL.  If any of the attributes passed
                fail to be set, the record will be deleted and outError will be set with the appropriate error.
                If a password is not supplied with a user account, then a random password will be set automatically.  If
                an empty password is expected, then the kODAttributeTypePassword should be set to an empty CFArray.
    @param      error an optional CFErrorRef reference for error details
    @result     returns a valid ODRecordRef.  If the add fails, outError can be checked for details.
*/
CF_EXPORT
ODRecordRef ODNodeCreateRecord(ODNodeRef node, ODRecordType recordType, CFStringRef recordName, CFDictionaryRef attributeDict, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCopyRecord
    @abstract   Simple API to open / create a references to a particular record on a Node
    @discussion Simple API to open / create a references to a particular record on a Node
    @param      node an ODNodeRef to use
    @param      recordType a ODRecordTypeRef of the record type to copy
    @param      recordName a CFStringRef of the record name to copy
    @param      attributes (optional) a CFArrayRef (or single ODAttributeType) of the attributes to copy from the directory.  Can be NULL when no 
                attributes are needed.  Any standard types can be passed, for example
                kODAttributeTypeAllAttributes will fetch all attributes up front.  If just standard attributes are needed, then
                kODAttributeTypeStandardOnly can be passed.
    @param      error an optional CFErrorRef reference for error details
    @result     returns a valid ODRecordRef.  If the record copy fails, the error can be checked for details.
                If the record is not found, will return NULL with a NULL error.
*/
CF_EXPORT
ODRecordRef ODNodeCopyRecord(ODNodeRef node, ODRecordType recordType, CFStringRef recordName, CFTypeRef attributes, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODNodeCustomCall
    @abstract   Sends a custom call to a node.
    @discussion This will send a custom call to a node along with the specified data, returning the result.
    @param      node an ODNodeRef to use
    @param      customCode the custom code to be sent to the node
    @param      data a data blob expected by the custom code, can be NULL of no send data
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDataRef with the result of the operation, otherwise outError can be checked for specific details
*/
CF_EXPORT CF_RETURNS_RETAINED
CFDataRef ODNodeCustomCall(ODNodeRef node, CFIndex customCode, CFDataRef data, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
 * @function ODNodeCustomCall
 *
 * @abstract
 * Sends a named custom function call to a node.
 *
 * @discussion
 * Sends a named custom function call to a node.  Custom functions are defined by the modules that implement them
 * and the parameter is defined by the module.
 *
 * @param node
 * An ODNodeRef to use
 *
 * @param function
 * A CFStringRef that specifies the name of the function
 *
 * @param payload
 * A CFType appropriate for the custom function.  The type is dictated by the module implementing the function.
 *
 * @param error
 * An optional CFErrorRef reference to receive any errors from the custom function call.
 *
 * @result
 * Returns a CFType appropriate for the function.
 */
CF_EXPORT CF_RETURNS_RETAINED
CFTypeRef
ODNodeCustomFunction(ODNodeRef node, CFStringRef function, CFTypeRef payload, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);

/*!
    @function   ODNodeCopyPolicies
    @abstract   This will copy any policies configured for the node.
    @discussion This will copy any policies configured for the node.
    @param      node an ODNodeRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing all currently set policies
*/
CF_EXPORT
CFDictionaryRef ODNodeCopyPolicies(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODNodeCopyAccountPolicies");

/*!
    @function   ODNodeCopySupportedPolicies
    @abstract   This will return a dictionary of supported policies.
    @discussion This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
                for the policy in question.  For example, if password history is available, it will state how much history is
                supported.
    @param      node an ODNodeRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing all currently supported policies.  The values will be the maximum value allowed.
*/
CF_EXPORT
CFDictionaryRef ODNodeCopySupportedPolicies(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   ODNodeSetPolicies
    @abstract   This will set the policy for the node.
    @discussion This will set the policy for the node.  Policies are evaluated in combination with record-level policies.
    @param      node an ODNodeRef to use
    @param      policies a CFDictionary of policies to be set
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy set succeeded, otherwise error is set. 
*/
CF_EXPORT
bool ODNodeSetPolicies(ODNodeRef node, CFDictionaryRef policies, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODNodeSetAccountPolicies");

/*!
    @function   ODNodeSetPolicy
    @abstract   This will set a specific policy setting for the node.
    @discussion This will set a specific policy setting for the node.
    @param      node an ODNodeRef to use
    @param      policy a valid ODPolicyType
    @param      value a CFTypeRef to be set (should be of appropriate type for the policy)
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy set succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODNodeSetPolicy(ODNodeRef node, ODPolicyType policyType, CFTypeRef value, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODNodeAddAccountPolicy");

/*!
    @function   ODNodeRemovePolicy
    @abstract   This will remove a specific policy setting from the node.
    @discussion This will remove a specific policy setting from the node.
    @param      node an ODNodeRef to use
    @param      policy a valid ODPolicyType
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy removal succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODNodeRemovePolicy(ODNodeRef node, ODPolicyType policyType, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODNodeRemoveAccountPolicy");

/*!
    @function   ODNodeAddAccountPolicy
    @abstract   This will add an account policy to the node for the specified category.
    @discussion This will add an account policy to the node for the specified category.
                The specified policy will be applied to all users in the
                specified node when policies are evaluated.
    @param      node an ODNodeRef to use.
    @param      policy a dictionary containing the specific policy to be added.
                The dictionary may contain the following keys:
                    kODPolicyKeyIdentifier a required key identifying the policy.
                    kODPolicyKeyParameters an optional key containing a dictionary of
                        parameters that can be used for informational purposes or in
                        the policy format string.
                    kODPolicyKeyContent a required key specifying the policy,
                        from which a predicate will be created for evaluating
                        the policy.
    @param      category a valid ODPolicyCategoryType to which the specified policy will be added.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy addition succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODNodeAddAccountPolicy(ODNodeRef node, CFDictionaryRef policy, ODPolicyCategoryType category, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODNodeRemoveAccountPolicy
    @abstract   This will remove an account policy from the node for the specified category.
    @discussion This will remove an account policy from the node for the specified category.
    @param      node an ODNodeRef to use.
    @param      policy a dictionary containing the specific policy to be
                removed, with the same format as described in ODNodeAddAccountPolicy.
    @param      category a valid ODPolicyCategoryType from which the specified policy will be removed.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy removal succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODNodeRemoveAccountPolicy(ODNodeRef node, CFDictionaryRef policy, ODPolicyCategoryType category, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODNodeSetAccountPolicies
    @abstract   This will set the policies for the node.
    @discussion This will set the policies for the node, replacing any existing
                policies.
    @param      node an ODNodeRef to use.
    @param      policies a dictionary containing all of the policies to be set
                for the node.  The dictionary may contain the following keys:
                    kODPolicyCategoryAuthentication an optional key with a value
                        of an array of policy dictionaries that specify when
                        authentications should be allowed.
                    kODPolicyCategoryPasswordContent an optional key with a
                        value of an array of policy dictionaries the specify the
                        required content of passwords. 
                    kODPolicyCategoryPasswordChange an optional key with a value
                    of an array of policy dictionaries that specify when
                    passwords are required to be changed.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy set succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODNodeSetAccountPolicies(ODNodeRef node, CFDictionaryRef policies, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODNodeCopyAccountPolicies
    @abstract   This will copy any policies configured for the node.
    @discussion This will copy any policies configured for the node.
    @param      node an ODNodeRef to use.
    @param      error an optional CFErrorRef reference for error details.
    @result     a CFDictionaryRef containing all currently set policies.  The
                format of the dictionary is the same as described in
                ODNodeSetAccountPolicies(). 
*/
CF_EXPORT CF_RETURNS_RETAINED
CFDictionaryRef ODNodeCopyAccountPolicies(ODNodeRef node, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODNodePasswordContentCheck
    @abstract   Validates a password against the node's password content policies.
    @discussion Validates a password against the node's password content policies.
                The node's password content policies will be evaluated to
                determine if the password is acceptable.  May be used prior to
                creating the record.

                This check is only definitive at the time it was requested. The
                policy or the environment could change before the password change
                is actually requested.  Errors from the password change request
                should be consulted.

    @param      node an ODNodeRef to use.
    @param      password the password to be evaluated against the content policies.
    @param      recordName the name of the record.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the password passes all content policies, otherwise error is set.
 */
CF_EXPORT
bool ODNodePasswordContentCheck(ODNodeRef node, CFStringRef password, CFStringRef recordName, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

__END_DECLS

#endif /* ! __OPENDIRECTORY_CFODNODE__ */
                                                                                                                                                                                                                                                                                                                                                                                                                                                        CFODQuery.h                                                                                         0100644 0001750 0001750 00000024263 12566201065 045431  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFODQUERY__)
#define __OPENDIRECTORY_CFODQUERY__ 1

#include <CFOpenDirectory/CFOpenDirectory.h>

/*!
    @header CFODQuery
    @abstract   ODQuery functions
    @discussion This header describes functions for working with ODQueryRefs.
*/

/*!
    @typedef    ODQueryCallback
    @abstract   Is called as results are returned from a query.  The incoming result must be retained or copied.
    @discussion Is called as results are returned from an CFRunLoop-based query.  These results are only partial
                and the callback is called repeatedly as results are available.  The incoming result must be retained or copied.  The 
                array will be released by the CFRunLoop upon return.  Incoming results do not include previous results,
                only the most recent results are returned.  inResults can be NULL if an error occurs or the query is complete.  If 
                inError and inResults are NULL then the query has completed.
*/
typedef void (*ODQueryCallback)(ODQueryRef query, CFArrayRef results, CFErrorRef error, void *context);

__BEGIN_DECLS

/*!
    @function   ODQueryGetTypeID
    @abstract   Standard GetTypeID function support for CF-based objects
    @discussion Returns the typeID for the ODQuery object
    @result     a valid CFTypeID for the ODQuery object
*/
CF_EXPORT
CFTypeID ODQueryGetTypeID(void) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQueryCreateWithNode
    @abstract   Creates a query with the node using the parameters provided
    @discussion Creates a query with the node using the supplied query parameters.  Some parameters can either be CFString or
                CFData or a CFArray of either CFString or CFData.
    @param      allocator a memory allocator to use for this object
    @param      node an ODNodeRef to use
    @param      recordTypeOrList a CFString of a type or CFArray with a list of record types
    @param      attribute a CFStringRef of the attribute name to query
    @param      matchType an ODMatchType value that signifies the type of query
    @param      queryValueOrList a CFStringRef, CFDataRef or CFArrayRef of either type for values to query in attribute
    @param      returnAttributeOrList a CFStringRef or CFArrayRef of CFStrings with the list of attributes to be returned
                from the query.  Passing NULL is equivalent to passing kODAttributeTypeStandardOnly.
    @param      maxResults a CFIndex of the total number of values the caller wants to be returned
    @param      error an optional CFErrorRef reference for error details
    @result     an ODQueryRef which should be passed into ODQueryCopyResults for immediate results or
                ODQueryScheduleWithRunLoop for background behavior
*/
CF_EXPORT
ODQueryRef ODQueryCreateWithNode(CFAllocatorRef allocator, ODNodeRef node, CFTypeRef recordTypeOrList, ODAttributeType attribute, ODMatchType matchType, CFTypeRef queryValueOrList, CFTypeRef returnAttributeOrList, CFIndex maxResults, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQueryCreateWithNodeType
    @abstract   Creates a query object that is initialized to a particular node type.
    @discussion Creates a query object that is initialized to a particular node type using the supplied
                query options.
    @param      allocator a memory allocator to use for this object
    @param      nodeType an ODNodeType to use when doing a query
    @param      recordTypeOrList a ODRecordType of a type or CFArray with a list of record types
    @param      attribute a ODAttributeType or CFStringRef of the attribute name to query
    @param      matchType an ODMatchType value that signifies the type of query
    @param      queryValueOrList a CFStringRef, CFDataRef or CFArrayRef of either type for values to query in attribute
    @param      returnAttributeOrList a CFStringRef or CFArrayRef of CFStrings with the list of attributes to be returned
                from the query.  Passing NULL is equivalent to passing kODAttributeTypeStandardOnly.
    @param      maxResults a CFIndex of the total number of values the caller wants to be returned
    @param      error an optional CFErrorRef reference for error details
    @result     an ODQueryRef which should be passed into ODQueryCopyResults for immediate results or
                ODQueryScheduleWithRunLoop for background behavior, see ODQueryCallback for details on RunLoop
                behavior.
*/
CF_EXPORT
ODQueryRef ODQueryCreateWithNodeType(CFAllocatorRef allocator, ODNodeType nodeType, CFTypeRef recordTypeOrList, ODAttributeType attribute, ODMatchType matchType, CFTypeRef queryValueOrList, CFTypeRef returnAttributeOrList, CFIndex maxResults, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQueryCopyResults
    @abstract   Returns results from a provided ODQueryRef synchronously
    @discussion Returns results from a provided ODQueryRef synchronously.  Passing false to inAllowPartialResults
                will block the call until all results are returned or an error occurs.  true can be passed at any time
                even if previous calls were made with false.
    @param      query an ODQueryRef to use
    @param      allowPartialResults a bool, passing true to retrieve any currently available results, or false to
                wait for all results
    @param      error an optional CFErrorRef reference for error details
    @result     a CFArrayRef comprised of ODRecord objects.  If partial results were requested but are complete, then
                NULL will be returned with outError set to NULL. If an error occurs, NULL will be returned and 
                outError should be checked accordingly.
*/
CF_EXPORT
CFArrayRef ODQueryCopyResults(ODQueryRef query, bool allowPartialResults, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQuerySynchronize
    @abstract   Will dispose of any results and restart the query.
    @discussion Will dispose of any results and restart the query for subsequent ODQueryCopyResults.  If the query
                is currently scheduled on a RunLoop, then the callback function will be called with inResults == NULL and
                inError.error == kODErrorQuerySynchronize and inError.domain == kODErrorDomainFramework, signifying that
                all existing results should be thrown away in preparation for new results.
    @param      query an ODQueryRef to use
*/
CF_EXPORT
void ODQuerySynchronize(ODQueryRef query) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQuerySetCallback
    @abstract   This call is used to set the callback function for an asynchronous query
    @discussion This call is used to set the callback function for an asynchronous query, using a
                CFRunLoop or a dispatch queue.
    @param      query an ODQueryRef to use
    @param      callback a function to call when a query has results to return
    @param      userInfo a user-defined pointer to be passed back to the Query callback function
*/
CF_EXPORT
void ODQuerySetCallback(ODQueryRef query, ODQueryCallback callback, void *userInfo) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQueryScheduleWithRunLoop
    @abstract   Allows a query to run off of a runloop, though it will spawn a thread to handle the work
    @discussion Allows a query to run off of a runloop, though it will spawn a thread to handle the work.
                When query is complete or stopped the callback function will be called with NULL results 
                and inError set to NULL.  ODQueryUnscheduleFromRunLoop() must be called to remove this query
                from Runloops if necessary.
    @param      query an ODQueryRef to put on the runloop
    @param      runLoop a CFRunLoopRef to put the ODQueryRef source onto
    @param      runLoopMode a CFStringRef with the runloop mode to add the ODQueryRef to
*/
CF_EXPORT
void ODQueryScheduleWithRunLoop(ODQueryRef query, CFRunLoopRef runLoop, CFStringRef runLoopMode) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQueryUnscheduleFromRunLoop
    @abstract   Removes the ODQueryRef from the provided runloop
    @discussion Removes the ODQueryRef from the provided runloop
    @param      query an ODQueryRef to remove from the runloop
    @param      runLoop a CFRunLoopRef to remove the ODQuery source from
    @param      runLoopMode a CFStringRef of the mode to remove the ODQuery from
*/
CF_EXPORT
void ODQueryUnscheduleFromRunLoop(ODQueryRef query, CFRunLoopRef runLoop, CFStringRef runLoopMode) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODQuerySetDispatchQueue
    @abstract   Performs the query and sends the results using the specified dispatch queue
    @discussion Schedule the query to run and deliver its results using the specified dispatch queue.
                The previously set callback will be called using the same semantics as
                ODQueryScheduleWithRunLoop
    @param      query an ODQueryRef to perform
    @param      queue a dispatch queue to receive the query results
*/
CF_EXPORT
void ODQuerySetDispatchQueue(ODQueryRef query, dispatch_queue_t queue) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

__END_DECLS

#endif /* ! __OPENDIRECTORY_CFODQUERY__ */
                                                                                                                                                                                                                                                                                                                                             CFODRecord.h                                                                                        0100644 0001750 0001750 00000103256 12566201065 045542  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFODRECORD__)
#define __OPENDIRECTORY_CFODRECORD__

#include <CFOpenDirectory/CFOpenDirectory.h>

__BEGIN_DECLS

/*!
    @function   ODRecordGetTypeID
    @abstract   Standard GetTypeID function support for CF-based objects
    @discussion Returns the typeID for the ODRecord object
    @result     a valid CFTypeID for the ODRecord object
*/
CF_EXPORT
CFTypeID ODRecordGetTypeID(void) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordSetNodeCredentials
    @abstract   Similar to calling ODNodeSetCredentials except credentials are only set for this particular record's node
    @discussion Sets the credentials if necessary on the ODNodeRef referenced by this ODRecordRef.  Very similar to
                calling ODNodeSetCredentials except other records referencing the underlying ODNodeRef will not get
                authenticated, therefore inadvertant changes cannot occur.  If all records referencing a particular 
                ODNodeRef need to be updated, then use ODNodeSetCredentials on the original ODNodeRef instead.  If the
                ODNodeRef is already authenticated with the same name and password, this will be a NOOP call.  The original
                ODNodeRef held by an ODRecordRef will be released and a new ODNodeRef will be created when the credentials
                are set for this ODRecordRef.  Calling this on multiple records could result in multiple References into the 
                OpenDirectory daemon, which could cause errors logged into /var/log/system.log if a threshold is reached.
    @param      record an ODRecordRef to use
    @param      username a CFStringRef of the username used to authenticate
    @param      password a CFStringRef of the password used to authenticate
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details.  Upon failure the original node
                will still be intact.
*/
CF_EXPORT
bool ODRecordSetNodeCredentials(ODRecordRef record, CFStringRef username, CFStringRef password, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordSetNodeCredentialsExtended
    @abstract   Similar to calling ODNodeSetCredentialsExtended except credentials are only set for this particular record's
                node
    @discussion Allows the caller to use other types of authentications that are available in Open Directory, that may
                require response-request loops, etc.  Not all OD plugins will support this call, look for 
                kODErrorCredentialsMethodNotSupported in outError.  Same behavior as ODRecordSetNodeCredentials.
    @param      record an ODRecordRef to use
    @param      recordType a ODRecordTypeRef of the type of record to do the authentication with
    @param      authType a ODAuthenticationTypeRef of the type of authentication to be used (e.g., kDSStdAuthNTLMv2)
    @param      authItems a CFArrayRef of CFData or CFString items that will be sent in order to the auth process
    @param      outAuthItems a pointer to CFArrayRef that will be assigned to a CFArrayRef of CFData items if the
                call returned any values followup values
    @param      outContext a pointer to ODContextRef if the call requires further calls for response-request auths.
    @param      error an optional CFErrorRef reference for error details
    @result     a bool will be returned with the result of the operation and outAuthItems set with response items
                and outContext set for any needed continuation.  Upon failure the original node will still be intact.
*/
CF_EXPORT
bool ODRecordSetNodeCredentialsExtended(ODRecordRef record, ODRecordType recordType, ODAuthenticationType authType, CFArrayRef authItems, CFArrayRef *outAuthItems, ODContextRef *outContext, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordSetNodeCredentialsUsingKerberosCache
    @abstract   Unsupported function.
    @discussion Unsupported function.
*/
CF_EXPORT
bool ODRecordSetNodeCredentialsUsingKerberosCache(ODRecordRef record, CFStringRef cacheName, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_6, __MAC_10_7, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   ODRecordCopyPasswordPolicy
    @abstract   Returns a CFDictionaryRef of the effective policy for the user if available
    @discussion Returns a CFDictionaryRef of the effective policy for the user if available
    @param      allocator a CFAllocatorRef to use
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef of the password policies for the supplied record, or NULL if no policy set
*/
CF_EXPORT
CFDictionaryRef ODRecordCopyPasswordPolicy(CFAllocatorRef allocator, ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_9, __IPHONE_NA, __IPHONE_NA, "use ODRecordCopyEffectivePolicies");

/*!
    @function   ODRecordVerifyPassword
    @abstract   Verifies the password provided is valid for the record
    @discussion Verifies the password provided is valid for the record.
    @param      record an ODRecordRef to use
    @param      password a CFStringRef of the password that is being verified
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordVerifyPassword(ODRecordRef record, CFStringRef password, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordVerifyPasswordExtended
    @abstract   Allows use of other Open Directory types of authentications to verify a record password
    @discussion Allows the caller to use other types of authentications that are available in Open Directory, that may 
                require response-request loops, etc.
    @param      record an ODRecordRef to use
    @param      authType a ODAuthenticationTypeRef of the type of authentication to be used (e.g., kODAuthenticationTypeCRAM_MD5)
    @param      authItems a CFArrayRef of CFData or CFString items that will be sent in order to the auth process
    @param      outAuthItems a pointer to CFArrayRef that will be assigned to a CFArrayRef of CFData items if the
                call returned any values followup values
    @param      outContext a pointer to ODContextRef if the call requires further calls for response-request auths.
    @param      error an optional CFErrorRef reference for error details
    @result     a bool will be returned with the result of the operation and outAuthItems set with response items
                and outContext set for any needed continuation.  Some ODNodes may not support the call so an error of
                eNotHandledByThisNode or eNotYetImplemented may be returned.
*/
CF_EXPORT
bool ODRecordVerifyPasswordExtended(ODRecordRef record, ODAuthenticationType authType, CFArrayRef authItems, CFArrayRef *outAuthItems, ODContextRef *outContext, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordChangePassword
    @abstract   Changes the password of an ODRecord
    @discussion Changes the password of an ODRecord.  If NULL is passed into inOldPassword, then an attempt to set
                the password will be tried.  If changing a password, then both old and new passwords should be supplied.
    @param      record an ODRecordRef to use
    @param      oldPassword a CFString of the record's old password (NULL is optional).
    @param      newPassword a CFString of the record's new password
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordChangePassword(ODRecordRef record, CFStringRef oldPassword, CFStringRef newPassword, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordGetRecordType
    @abstract   Returns the record type of an ODRecordRef
    @discussion Returns the record type of an ODRecordRef
    @param      record an ODRecordRef to use
    @result     a CFStringRef of the record type for this ODRecordRef
*/
CF_EXPORT
CFStringRef ODRecordGetRecordType(ODRecordRef record) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordGetRecordName
    @abstract   Returns the official record name of an ODRecordRef
    @discussion Returns the official record name of an ODRecordRef which typically corresponds to the first value
                of the kODAttributeTypeRecordName attribute, but not always.  This name should be a valid name in either case.
    @param      record an ODRecordRef to use
    @result     a CFStringRef of the record name for this ODRecordRef
*/
CF_EXPORT
CFStringRef ODRecordGetRecordName(ODRecordRef record) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordCopyValues
    @abstract   Returns the value of an attribute as an array of CFStringRef or CFDataRef types
    @discussion Returns the value of an attribute as an array of CFStringRef or CFDataRef, depending on
                whether the data is Binary or not.  If the value has been fetched from the directory previously
                a copy of the internal storage will be returned without going to the directory.  If it has not been fetched
                previously, then it will be fetched at that time.
    @param      record an ODRecordRef to use
    @param      attribute a CFStringRef or ODAttributeType of the attribute (e.g., kODAttributeTypeRecordName, etc.)
    @param      error an optional CFErrorRef reference for error details
    @result     a CFArrayRef of the attribute requested if possible, or NULL if the attribute doesn't exist
*/
CF_EXPORT
CFArrayRef ODRecordCopyValues(ODRecordRef record, ODAttributeType attribute, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordSetValue
    @abstract   Will take a CFDataRef or CFStringRef or a CFArrayRef of either type and set it for the attribute
    @discussion Will take a CFDataRef or CFStringRef or a CFArrayRef of either type and set it for the attribute.
                Any mixture of the types CFData and CFString are accepted.
    @param      record an ODRecordRef to use
    @param      attribute a CFStringRef of the attribute for values to be added too
    @param      valueOrValues a CFArrayRef of CFStringRef or CFDataRef types or either of the individual types, passing
                an empty CFArray deletes the attribute.  The underlying implementation will do this in the most efficient manner,
                either by adding only new values or completely replacing the values depending on the capabilities of the
                particular plugin.
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordSetValue(ODRecordRef record, ODAttributeType attribute, CFTypeRef valueOrValues, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordAddValue
    @abstract   Adds a value to an attribute
    @discussion Adds a value to an attribute.
    @param      record an ODRecordRef to use
    @param      attribute a CFStringRef of the attribute for values to be added too
    @param      value a CFTypeRef of the value to be added to the attribute, either CFStringRef or CFDataRef
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordAddValue(ODRecordRef record, ODAttributeType attribute, CFTypeRef value, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordRemoveValue
    @abstract   Removes a particular value from an attribute.
    @discussion Removes a particular value from an attribute.
    @param      record an ODRecordRef to use
    @param      attribute a CFStringRef of the attribute to remove the value from
    @param      value a CFTypeRef of the value to be removed from the attribute.  Either CFStringRef or CFDataRef.
                If the value does not exist, true will be returned and no error will be set.
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordRemoveValue(ODRecordRef record, ODAttributeType attribute, CFTypeRef value, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordCopyDetails
    @abstract   Returns the attributes and values in the form of a key-value pair set for this record.
    @discussion Returns the attributes and values in the form of a key-value pair set for this record.  The key is a 
                CFStringRef or ODAttributeType of the attribute name (e.g., kODAttributeTypeRecordName, etc.) and the 
                value is an CFArrayRef of either CFDataRef or CFStringRef depending on the type of data.  Binary data will
                be returned as CFDataRef.
    @param      record an ODRecordRef to use
    @param      attributes a CFArrayRef of attributes.  If an attribute has not been fetched previously, it will be
                fetched in order to return the value.  If this parameter is NULL then all currently fetched attributes 
                will be returned.
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef of the attributes for the record
*/
CF_EXPORT
CFDictionaryRef ODRecordCopyDetails(ODRecordRef record, CFArrayRef attributes, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordSynchronize
    @abstract   Synchronizes the record from the Directory in order to get current data and commit pending changes
    @discussion Synchronizes the record from the Directory in order to get current data.  Any previously fetched attributes
                will be refetched from the Directory.  This will not refetch the entire record, unless the entire record
                has been accessed.  Additionally, any changes made to the record will be committed to the directory
                if the node does not do immediate commits.
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
*/
CF_EXPORT
bool ODRecordSynchronize(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordDelete
    @abstract   Deletes the record from the node and invalidates the record.
    @discussion Deletes the record from the node and invalidates the record.  The ODRecordRef should be
                released after deletion.
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordDelete(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordAddMember
    @abstract   Will add the record as a member of the group record that is provided
    @discussion Will add the record as a member of the group record that is provided in an appopriate manner 
                based on what the directory will store.  An error will be returned if the record is not a group record.  
                Additionally, if the member record is not an appropriate type allowed as part of a group an
                error will be returned.
    @param      group an ODRecordRef of the group record to modify
    @param      member an ODRecordRef of the record to add to the group record
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordAddMember(ODRecordRef group, ODRecordRef member, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordRemoveMember
    @abstract   Will remove the record as a member from the group record that is provided
    @discussion Will remove the record as a member from the group record that is provided.  If the record type
                of group is not a Group, false will be returned with an appropriate error.
    @param      group an ODRecordRef of the group record to modify
    @param      member an ODRecordRef of the record to remove from the group record
    @param      error an optional CFErrorRef reference for error details
    @result     returns true on success, otherwise outError can be checked for details
*/
CF_EXPORT
bool ODRecordRemoveMember(ODRecordRef group, ODRecordRef member, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordContainsMember
    @abstract   Will use membership APIs to resolve group membership based on Group and Member record combination
    @discussion Will use membership APIs to resolve group membership based on Group and Member record combination.
                This API does not check attributes values directly, instead uses system APIs to deal with nested
                memberships.
    @param      group an ODRecordRef of the group to be checked for membership
    @param      member an ODRecordRef of the member to be checked against the group
    @param      error an optional CFErrorRef reference for error details
    @result     returns true or false depending on result
*/
CF_EXPORT
bool ODRecordContainsMember(ODRecordRef group, ODRecordRef member, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODRecordCopyPolicies
    @abstract   This will copy any policies configured for the record.
    @discussion This will copy any policies configured for the record.
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing all currently configured policies
*/
CF_EXPORT
CFDictionaryRef ODRecordCopyPolicies(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODRecordCopyAccountPolicies");

/*!
    @function   ODRecordCopyEffectivePolicies
    @abstract   This will copy the effective policies for the record (merging any node-level policies).
    @discussion This will copy the effective policies for the record (merging any node-level policies).
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing all currently configured policies (merging any node-level policies)
*/
CF_EXPORT
CFDictionaryRef ODRecordCopyEffectivePolicies(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODRecordAuthenticationAllowed and similar functions");

/*!
    @function   ODRecordCopySupportedPolicies
    @abstract   This will return a dictionary of supported policies.
    @discussion This will return a dictionary of supported policies, if appropriate, the value will be the maximum value allowed
                for the policy in question.  For example, if password history is available, it will state how much history is
                supported.
    @param      record an ODRecordRef to use
    @param      error an optional CFErrorRef reference for error details
    @result     a CFDictionaryRef containing all currently supported policies
*/
CF_EXPORT
CFDictionaryRef ODRecordCopySupportedPolicies(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA);

/*!
    @function   ODRecordSetPolicies
    @abstract   This will set the policy for the record.
    @discussion This will set the policy for the record.  Policies are evaluated in combination with node-level policies.
    @param      record an ODRecordRef to use
    @param      policies a CFDictionary of policies to be set
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy set succeeded, otherwise error is set. 
*/
CF_EXPORT
bool ODRecordSetPolicies(ODRecordRef record, CFDictionaryRef policies, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODRecordSetAccountPolicies");

/*!
    @function   ODRecordSetPolicy
    @abstract   This will set a specific policy setting for the record.
    @discussion This will set a specific policy setting for the record.
    @param      record an ODRecordRef to use
    @param      policy a valid ODPolicyType
    @param      value a CFTypeRef to be set (should be of appropriate type for the policy)
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy set succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODRecordSetPolicy(ODRecordRef record, ODPolicyType policy, CFTypeRef value, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODRecordAddAccountPolicy");

/*!
    @function   ODRecordRemovePolicy
    @abstract   This will remove a specific policy setting from the record.
    @discussion This will remove a specific policy setting from the record.
    @param      record an ODRecordRef to use
    @param      policy a valid ODPolicyType
    @param      error an optional CFErrorRef reference for error details
    @result     a bool which signifies if the policy removal succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODRecordRemovePolicy(ODRecordRef record, ODPolicyType policy, CFErrorRef *error) __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_9, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "use ODRecordRemoveAccountPolicy");

/*!
    @function   ODRecordAddAccountPolicy
    @abstract   This will add an account policy to the record for the specified category.
    @discussion This will add an account policy to the record for the specified category.
                The node-level and record-level policies will be combined and
				evaluated as appropriate, ensuring the strongest policy is enforced.
    @param      record an ODRecordRef to use.
    @param      policy a dictionary containing the specific policy to be added.
                The dictionary may contain the following keys:
                    kODPolicyKeyIdentifier a required key identifying the policy.
                    kODPolicyKeyParameters an optional key containing a dictionary of
                        parameters that can be used for informational purposes or in
                        the policy format string.
                    kODPolicyKeyContent a required key specifying the policy,
                        from which a predicate will be created for evaluating
                        the policy.
    @param      category a valid ODPolicyCategoryType to which the policy will be added.
    @param      error is an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy addition succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODRecordAddAccountPolicy(ODRecordRef record, CFDictionaryRef policy, ODPolicyCategoryType category, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordRemoveAccountPolicy
    @abstract   This will remove an account policy from the record for the specified category.
    @discussion This will remove an account policy from the record for the specified category.
    @param      record an ODRecordRef to use.
    @param      policy a dictionary containing the specific policy to be
                removed, with the same format as described in ODRecordAddAccountPolicy.
    @param      category a valid ODPolicyCategoryType from which the policy will be removed.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy removal succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODRecordRemoveAccountPolicy(ODRecordRef record, CFDictionaryRef policy, ODPolicyCategoryType category, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordSetAccountPolicies
    @abstract   This will set the policies for the record.
    @discussion This will set the policies for the record, replacing any
                existing policies.  All of the policies in the set will be
                applied to the record when policies are evaluated.
    @param      record an ODRecordRef to use.
    @param      policies a dictionary containing all of the policies to be set
                for the node.  The dictionary may contain the following keys:
                    kODPolicyCategoryAuthentication an optional key with a value
                        of an array of policy dictionaries that specify when
                        authentications should be allowed.
                    kODPolicyCategoryPasswordContent an optional key with a
                        value of an array of policy dictionaries the specify the
                        required content of passwords. 
                    kODPolicyCategoryPasswordChange an optional key with a value
                    of an array of policy dictionaries that specify when
                    passwords are required to be changed.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the policy set succeeded, otherwise error is set.
*/
CF_EXPORT
bool ODRecordSetAccountPolicies(ODRecordRef record, CFDictionaryRef policies, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordCopyAccountPolicies
    @abstract   This will copy any policies configured for the record.
    @discussion This will copy any policies configured for the record.  Does not
                copy any policies set for the node.
    @param      record an ODRecordRef to use.
    @param      error an optional CFErrorRef reference for error details.
    @result     a CFDictionaryRef containing all currently set policies.  The
                format of the dictionary is the same as described in
                ODRecordSetAccountPolicies(). 
*/
CF_EXPORT CF_RETURNS_RETAINED
CFDictionaryRef ODRecordCopyAccountPolicies(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordAuthenticationAllowed
    @abstract   Determines if policies allow the account to authenticate.
    @discussion Determines if policies allow the account to authenticate.
                Authentication and password change policies are evaluated.
                Record-level and node-level policies are evaluated in
                combination, with record-level taking precedence over node-level
                policies.  The failure of any single policy will deny the
                authentication.
 
                This check is only definitive at the time it was requested. The
                policy or the environment could change before the authentication
                is actually requested.  Errors from the authentication request
                should be consulted.

                It is not necessary to call this function when callingg
                ODRecordVerifyPassword or ODRecordVerifyPasswordExtended
                since those functions perform same policy evaluation.

    @param      record an ODRecordRef to use.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the authentication is allowed, otherwise error is set.
 */
CF_EXPORT
bool ODRecordAuthenticationAllowed(ODRecordRef record, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordPasswordChangeAllowed
    @abstract   Determines if policies allow the password change.
    @discussion Determines if policies allow the password change.  Password
                content policies are evaluated. Record-level and node-level
                policies are evaluated in combination, with record-level taking
                precedence over node-level policies.  The failure of any single
                policy will deny the password change.
 
                This check is only definitive at the time it was requested. The
                policy or the environment could change before the password change
                is actually requested.  Errors from the password change request
                should be consulted.

    @param      record an ODRecordRef to use.
    @param      newPassword contains the password to be evaluated.
    @param      error an optional CFErrorRef reference for error details.
    @result     a bool which signifies if the password change is allowed, otherwise error is set.
 */
CF_EXPORT
bool ODRecordPasswordChangeAllowed(ODRecordRef record, CFStringRef newPassword, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordWillPasswordExpire
    @abstract   Determines if the password will expire within the specified time.
    @discussion Determines if the password will expire (i.e. need to be changed)
                between now and the specified number of seconds in the future. 
                Record-level and node-level policies are evaluated
                together, with record-level taking precedence over node-level
                policies.
    @param      record an ODRecordRef to use.
    @param      willExpireIn the number of seconds from the current time to be
                used as the upper-bound for the password expiration period.
    @result     a bool which signifies if the password will expire within the
                specified time.
 */
CF_EXPORT
bool ODRecordWillPasswordExpire(ODRecordRef record, uint64_t willExpireIn) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordWillAuthenticationsExpire
    @abstract   Determines if authentications will expire within the specified time.
    @discussion Determines if authentications will expire (i.e. session and/or
                account expires) between now and the specified number of seconds
                in the future.  Record-level and node-level policies are evaluated
                together, with record-level taking precedence over node-level
                policies. 
    @param      record an ODRecordRef to use.
    @param      willExpireIn the number of seconds from the current time to be
                used as the upper-bound for the authentication expiration period.
    @result     a bool which signifies if authentications will expire within the
                specified time.
 */
CF_EXPORT
bool ODRecordWillAuthenticationsExpire(ODRecordRef record, uint64_t willExpireIn) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordSecondsUntilPasswordExpires
    @abstract   Determines how many seconds until the password expires.
    @discussion Determines how many seconds until the password expires (i.e.
                needs changing).  Password change policies are evaluated.
                Record-level and node-level policies are evaluated in
                combination, with record-level taking precedence over node-level
                policies. 
    @param      record an ODRecordRef to use.
    @result     the number of seconds until the password expires.  If multiple
                policies will cause the password to expire, the soonest
                expiration time is returned.  If already expired,
                kODExpirationTimeExpired is returned.  If there are no password
                change policies, kODExpirationTimeNeverExpires is returned. 
 */
CF_EXPORT
int64_t ODRecordSecondsUntilPasswordExpires(ODRecordRef record) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

/*!
    @function   ODRecordSecondsUntilAuthenticationsExpire
    @abstract   Determines how many seconds until authentications expire.
    @discussion Determines how many seconds until authentications expire (i.e.
                session and/or account expires). Record-level and node-level 
                policies are evaluated together, with record-level taking 
                precedence over node-level policies
    @param      record an ODRecordRef to use.
    @result     the number of seconds until authentications expire.  If multiple
                policies will cause authentications to expire, the soonest
                expiration time is returned. If already expired,
                kODExpirationTimeExpired is returned.  If there are no
                authentication policies controlling expiration,
                kODExpirationTimeNeverExpires is returned.  
 */
CF_EXPORT
int64_t ODRecordSecondsUntilAuthenticationsExpire(ODRecordRef record) __OSX_AVAILABLE_STARTING(__MAC_10_10, __IPHONE_NA);

__END_DECLS

#endif /* ! __OPENDIRECTORY_CFODRECORD__ */
                                                                                                                                                                                                                                                                                                                                                  CFODSession.h                                                                                       0100644 0001750 0001750 00000007352 12566201065 045747  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFODSESSION__)
#define __OPENDIRECTORY_CFODSESSION__

#include <CFOpenDirectory/CFOpenDirectory.h>

/*!
    @const      kODSessionDefault
    @abstract   is the default type of ODSessionRef used if there is no need to create a specific reference
    @discussion is the default type of ODSessionRef used if there is no need to create a specific reference
*/
CF_EXPORT
ODSessionRef kODSessionDefault __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

__BEGIN_DECLS

/*!
    @function	ODSessionGetTypeID
    @abstract   Standard GetTypeID function support for CF-based objects
    @discussion Returns the typeID for ODSession objects
    @result     a valid CFTypeID for the ODSession object
*/
CF_EXPORT
CFTypeID ODSessionGetTypeID(void) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODSessionCreate
    @abstract   Creates an ODSession object to be passed to ODNode functions
    @discussion Creates an ODSession object to be passed to ODNode functions.
    @param      allocator a memory allocator to use for this object
    @param      options a CFDictionary of options associated with this ODSession.  This is typically NULL
                unless caller needs to proxy to another host.  
 
                If proxy is required then a dictionary with keys should be:
                            Key                             Value
                    kODSessionProxyAddress        CFString(hostname or IP)
                    kODSessionProxyPort           CFNumber(IP port, should not be set as it will default)
                    kODSessionProxyUsername       CFString(username)
                    kODSessionProxyPassword       CFString(password)
    @param      error an optional CFErrorRef reference for error details
    @result     a valid ODSessionRef object or NULL if it cannot be created. Pass reference to CFErrorRef to
                get error details
*/
CF_EXPORT
ODSessionRef ODSessionCreate(CFAllocatorRef allocator, CFDictionaryRef options, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @function   ODSessionCopyNodeNames
    @abstract   Returns the node names that are registered on this ODSession
    @discussion Returns the node names that are registered on this ODSession
    @param      allocator a memory allocator to use for this object
    @param      session an ODSessionRef, either kODSessionDefault or a valid ODSessionRef can be passed
    @param      error an optional CFErrorRef reference for error details
    @result     a valid CFArrayRef of node names that can be opened on the session reference
*/
CF_EXPORT
CFArrayRef ODSessionCopyNodeNames(CFAllocatorRef allocator, ODSessionRef session, CFErrorRef *error) __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

__END_DECLS

#endif /* !__OPENDIRECTORY_CFODSESSION__ */
                                                                                                                                                                                                                                                                                      CFOpenDirectory.h                                                                                   0100644 0001750 0001750 00000004470 12566201065 046665  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__OPENDIRECTORY_CFOPENDIRECTORY__)
#define __OPENDIRECTORY_CFOPENDIRECTORY__ 1

#include <CoreFoundation/CoreFoundation.h>

/*!
    @typedef    ODContextRef
    @abstract   Opaque reference for the ODContext object
*/
typedef const struct __ODContext *ODContextRef;

/*!
    @typedef    ODNodeRef
    @abstract   Opaque reference for the ODNode object
*/
typedef struct __ODNode *ODNodeRef;

/*!
    @typedef    ODQueryRef
    @abstract   Opaque reference for the ODQuery object
*/
typedef struct __ODQuery *ODQueryRef;

/*!
    @typedef    ODRecordRef
    @abstract   Opaque reference for the ODRecord object
*/
typedef struct __ODRecord *ODRecordRef;

/*!
    @typedef	ODSessionRef
    @abstract   Opaque reference for ODSession object
*/
typedef struct __ODSession *ODSessionRef;

/*!
    @const      kODErrorDomainFramework
    @abstract   the error domain for OpenDirectory.framework details
    @discussion the error domain for OpenDirectory.framework details
*/
CF_EXPORT
const CFStringRef kODErrorDomainFramework __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

#include <CFOpenDirectory/CFOpenDirectoryConstants.h>

#include <CFOpenDirectory/CFODContext.h>
#include <CFOpenDirectory/CFODNode.h>
#include <CFOpenDirectory/CFODQuery.h>
#include <CFOpenDirectory/CFODRecord.h>
#include <CFOpenDirectory/CFODSession.h>

#endif /* ! __OPENDIRECTORY_CFOPENDIRECTORY__ */
                                                                                                                                                                                                        CFOpenDirectoryConstants.h                                                                          0100644 0001750 0001750 00000466575 12566201065 050604  0                                                                                                    ustar 00                                                                0000000 0000000 osxcross/target/SDK/MacOSX10.11.sdk/System/Library/Frameworks/OpenDirectory.framework/Versions/A/Frameworks/CFOpenDirectory.framework/Versions/A/Headers               /*
 * Copyright (c) 2009-2011 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * http://www.opensource.apple.com/apsl/ and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */

#if !defined(__ODCONSTANTS_H)
#define __ODCONSTANTS_H

/*!
    @const      kODSessionProxyAddress
    @abstract   the address to connect to via proxy, used when making the options dictionary
    @discussion the address to connect to via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyAddress __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyPort
    @abstract   the port to connect to via proxy, used when making the options dictionary
    @discussion the port to connect to via proxy, used when making the options dictionary.  This parameter
                is optional and should not be passed normally.
*/
CF_EXPORT
const CFStringRef kODSessionProxyPort __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyUsername
    @abstract   the username to connect with via proxy, used when making the options dictionary
    @discussion the username to connect with via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyUsername __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const      kODSessionProxyPassword
    @abstract   the password to connect with via proxy, used when making the options dictionary
    @discussion the password to connect with via proxy, used when making the options dictionary
*/
CF_EXPORT
const CFStringRef kODSessionProxyPassword __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
 @const      kODModuleConfigOptionQueryTimeout
 @abstract   number of seconds before a query times out
 @discussion number of seconds before a query times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionQueryTimeout __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionConnectionSetupTimeout
 @abstract   number of seconds before a connection attempt times out
 @discussion number of seconds before a connection attempt times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionConnectionSetupTimeout __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionConnectionIdleDisconnect
 @abstract   number of seconds before a connection is idle disconnected
 @discussion number of seconds before a connection is idle disconnected
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionConnectionIdleDisconnect __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionPacketSigning
 @abstract   enable or disable packet signing
 @discussion number of seconds before a query times out
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionPacketSigning __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionPacketEncryption
 @abstract   enable or disable packet encryption
 @discussion enable or disable packet encryption
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionPacketEncryption __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
 @const      kODModuleConfigOptionManInTheMiddle
 @abstract   enable or disable man-in-middle countermeasures
 @discussion enable or disable man-in-middle countermeasures
 */
CF_EXPORT
const CFStringRef kODModuleConfigOptionManInTheMiddle __OSX_AVAILABLE_STARTING(__MAC_10_9, __IPHONE_NA);
/*!
	@enum		ODNodeType
	@abstract   Types of nodes that can be opened
	@discussion Various types of nodes that can be opened.
	@constant   kODNodeTypeAuthentication is a node type commonly used for all authentications or record lookups
	@constant   kODNodeTypeContacts is a node type commonly used for applications that deal with contact data
	@constant   kODNodeTypeNetwork is a node type used for looking for network resource type data
	@constant   kODNodeTypeLocalNodes is a node type that specifically looks at the local directory
	@constant   kODNodeTypeConfigure is a node type that refers to the configuration node within DS
*/
enum
{
	kODNodeTypeAuthentication			= 0x2201,
	kODNodeTypeContacts					= 0x2204,
	kODNodeTypeNetwork					= 0x2205, /* deprecated, behaves identically to kODNodeTypeAuthentication */
	
	kODNodeTypeLocalNodes				= 0x2200,
	kODNodeTypeConfigure   				= 0x2202
};
typedef uint32_t ODNodeType;

/*!
    @const      kODNodeOptionsQuerySkippedSubnode
    @abstract   Used with nodes that support options.
    @discussion Passed in an options dictionary where the value is a boolean (kCFBooleanTrue/kCFBooleanFalse).
                If a node supports the option it will notify the client when a subnode is skipped during queries.
                Supported options are listed in node details under kODAttributeTypeNodeOptions.  Node may fail to
                open if unsupported options are used.
 */
CF_EXPORT
const CFStringRef kODNodeOptionsQuerySkippedSubnode __OSX_AVAILABLE_STARTING(__MAC_10_8, __IPHONE_NA);

/*!
	@enum   	ODMatchType
	@abstract   Are types of matching types used for doing searches.  Each type is self explanatory based on the name.
	@constant	kODMatchAny is used to search for any records (typically passed with nil search value)
	@constant	kODMatchEqualTo is searching values that are equal to the provided value
	@constant	kODMatchBeginsWith is searching values that begin with the provided value
	@constant	kODMatchContains is searching values that contain the provided value
	@constant	kODMatchEndsWith is searching values that end with the provided value
	@constant	kODMatchGreaterThan is searching values greater than the provided value
	@constant	kODMatchLessThan is searching values less than the provided value
 */
enum
{
	kODMatchAny						= 0x0001,
	
	kODMatchEqualTo					= 0x2001,
	kODMatchBeginsWith				= 0x2002,
	kODMatchContains				= 0x2004,
	kODMatchEndsWith				= 0x2003,
	
	kODMatchInsensitiveEqualTo    __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2101,
	kODMatchInsensitiveBeginsWith __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2102,
	kODMatchInsensitiveContains   __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2104,
	kODMatchInsensitiveEndsWith   __OSX_AVAILABLE_BUT_DEPRECATED_MSG(__MAC_10_6, __MAC_10_10, __IPHONE_NA, __IPHONE_NA, "case matching is defined by attribute schema")		= 0x2103,
	
	kODMatchGreaterThan				= 0x2006,
	kODMatchLessThan				= 0x2007,
};
typedef uint32_t ODMatchType;

/*!
	@typedef	ODRecordType
	@abstract   is used to define a specific record type
	@discussion is used to define a specific record type common to DirectoryService.
				Records types are strings that have a prefix:
 
					Standard records	- "dsRecTypeStandard:"
					Native to the node	- "dsRecTypeNative:"
 
				The most commonly used Standard records are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODRecordType for ease
				of use.
*/
#ifdef __OBJC__
#include <Foundation/Foundation.h>
typedef NSString *ODRecordType;
#else
typedef CFStringRef ODRecordType;
#endif

/*!
	@typedef	ODAttributeType
	@abstract   is used to define a specific attribute type
	@discussion is used to define a specific attribute type common to DirectoryService.
				Attribute types are strings that have a prefix:
 
					Standard attributes	- "dsAttrTypeStandard:"
					Native to the node	- "dsAttrTypeNative:"
 
				The most commonly used Standard attributes are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODAttributeType for ease
				of use.
*/
#ifdef __OBJC__
typedef NSString *ODAttributeType;
#else
typedef CFStringRef ODAttributeType;
#endif

/*!
	@typedef	ODAuthenticationType
	@abstract   is used to define a specific credential method type
	@discussion is used to define a specific credential method type common to DirectoryService.
				Authentication types are strings that have a prefix:
 
					Standard attributes	- "dsAuthMethodStandard:"
					Native to the node	- "dsAuthMethodNative:"
 
				The most commonly used Standard authentications are contained in this header.
 
				Note:  CFStringRef can be use interchangeably with ODAuthenticationType for ease
				of use.
*/
#ifdef __OBJC__
typedef NSString *ODAuthenticationType;
#else
typedef CFStringRef ODAuthenticationType;
#endif

/*!
	@typedef	ODPolicyType
	@abstract   is used to modify policies on nodes or records
	@discussion is used to modify policies on nodes or records
*/
#ifdef __OBJC_
typedef NSString *ODPolicyType;
#else
typedef CFStringRef ODPolicyType;
#endif

// Compatibility
typedef ODRecordType _ODRecordType;
typedef ODAttributeType _ODAttributeType;
typedef ODAuthenticationType _ODAuthenticationType;

#pragma mark Record Types

/*!
    @const		kODRecordTypeAttributeTypes
    @abstract   Identifies records that represent each possible attribute type.
    @discussion Identifies records that represent each possible attribute type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAttributeTypes;

/*!
    @const		kODRecordTypeAFPServer
    @abstract   Record type of AFP server records.
    @discussion Record type of AFP server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAFPServer;

/*!
    @const		kODRecordTypeAliases
    @abstract   Used to represent alias records.
    @discussion Used to represent alias records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAliases;

/*!
    @const		kODRecordTypeAugments
    @abstract   Used to store augmented record data.
    @discussion Used to store augmented record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAugments;

/*!
    @const		kODRecordTypeAutomount
    @abstract   Used to store automount record data.
    @discussion Used to store automount record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutomount;

/*!
    @const		kODRecordTypeAutomountMap
    @abstract   Used to store automountMap record data.
    @discussion Used to store automountMap record data.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutomountMap;

/*!
    @const		kODRecordTypeAutoServerSetup
    @abstract   Used to discover automated server setup information.
    @discussion Used to discover automated server setup information.
*/
CF_EXPORT
const ODRecordType kODRecordTypeAutoServerSetup;

/*!
    @const		kODRecordTypeBootp
    @abstract   Record in the local node for storing bootp info.
    @discussion Record in the local node for storing bootp info.
*/
CF_EXPORT
const ODRecordType kODRecordTypeBootp;

/*!
    @const		kODRecordTypeCertificateAuthorities
    @abstract   Record type that contains certificate authority information.
    @discussion Record type that contains certificate authority information.
*/
CF_EXPORT
const ODRecordType kODRecordTypeCertificateAuthorities;

/*!
    @const		kODRecordTypeComputerLists
    @abstract   Identifies computer list records.
    @discussion Identifies computer list records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputerLists;

/*!
    @const		kODRecordTypeComputerGroups
    @abstract   Identifies computer group records.
    @discussion Identifies computer group records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputerGroups;

/*!
    @const		kODRecordTypeComputers
    @abstract   Identifies computer records.
    @discussion Identifies computer records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeComputers;

/*!
    @const		kODRecordTypeConfiguration
    @abstract   Identifies configuration records.
    @discussion Identifies configuration records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeConfiguration;

/*!
    @const		kODRecordTypeEthernets
    @abstract   Record in the node for storing ethernets.
    @discussion Record in the node for storing ethernets.
*/
CF_EXPORT
const ODRecordType kODRecordTypeEthernets;

/*!
    @const		kODRecordTypeFileMakerServers
	@abstract   FileMaker servers record type. 
	@discussion FileMaker servers record type that describes available FileMaker servers, 
				used for service discovery.
*/
CF_EXPORT
const ODRecordType kODRecordTypeFileMakerServers;

/*!
    @const		kODRecordTypeFTPServer
    @abstract   Identifies ftp server records.
    @discussion Identifies ftp server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeFTPServer;

/*!
    @const		kODRecordTypeGroups
    @abstract   Identifies group records.
    @discussion Identifies group records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeGroups;

/*!
    @const		kODRecordTypeHostServices
    @abstract   Record in the local node for storing host services.
    @discussion Record in the local node for storing host services.
*/
CF_EXPORT
const ODRecordType kODRecordTypeHostServices;

/*!
    @const		kODRecordTypeHosts
    @abstract   Identifies host records.
    @discussion Identifies host records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeHosts;

/*!
    @const		kODRecordTypeLDAPServer
    @abstract   Identifies LDAP server records.
    @discussion Identifies LDAP server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeLDAPServer;

/*!
    @const		kODRecordTypeLocations
    @abstract   Location record type.
    @discussion Location record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeLocations;

/*!
    @const		kODRecordTypeMounts
    @abstract   Identifies mount records.
    @discussion Identifies mount records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeMounts;

/*!
    @const		kODRecordTypeNFS
    @abstract   Identifies NFS records.
    @discussion Identifies NFS records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNFS;

/*!
    @const		kODRecordTypeNetDomains
    @abstract   Record in the local node for storing net domains.
    @discussion Record in the local node for storing net domains.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetDomains;

/*!
    @const		kODRecordTypeNetGroups
    @abstract   Record in the local node for storing net groups.
    @discussion Record in the local node for storing net groups.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetGroups;

/*!
    @const		kODRecordTypeNetworks
    @abstract   Identifies network records.
    @discussion Identifies network records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeNetworks;

/*!
    @const		kODRecordTypePeople
    @abstract   Record type that contains "People" records used for contact information.
    @discussion Record type that contains "People" records used for contact information.
*/
CF_EXPORT
const ODRecordType kODRecordTypePeople;

/*!
    @const		kODRecordTypePresetComputers
    @abstract   The computer record type used for presets in record creation.
    @discussion The computer record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputers;

/*!
    @const		kODRecordTypePresetComputerGroups
    @abstract   The computer group record type used for presets in record creation.
    @discussion The computer group record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputerGroups;

/*!
    @const		kODRecordTypePresetComputerLists
    @abstract   The computer list record type used for presets in record creation.
    @discussion The computer list record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetComputerLists;

/*!
    @const		kODRecordTypePresetGroups
    @abstract   The group record type used for presets in record creation.
    @discussion The group record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetGroups;

/*!
    @const		kODRecordTypePresetUsers
    @abstract   The user record type used for presets in record creation.
    @discussion The user record type used for presets in record creation.
*/
CF_EXPORT
const ODRecordType kODRecordTypePresetUsers;

/*!
    @const		kODRecordTypePrintService
    @abstract   Identifies print service records.
    @discussion Identifies print service records.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrintService;

/*!
    @const		kODRecordTypePrintServiceUser
    @abstract   Record in the local node for storing quota usage for a user.
    @discussion Record in the local node for storing quota usage for a user.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrintServiceUser;

/*!
    @const		kODRecordTypePrinters
    @abstract   Identifies printer records.
    @discussion Identifies printer records.
*/
CF_EXPORT
const ODRecordType kODRecordTypePrinters;

/*!
    @const		kODRecordTypeProtocols
    @abstract   Identifies protocol records.
    @discussion Identifies protocol records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeProtocols;

/*!
    @const		kODRecordTypeQTSServer
    @abstract   Identifies quicktime streaming server records.
    @discussion Identifies quicktime streaming server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeQTSServer;

/*!
    @const		kODRecordTypeQueryInformation
    @abstract   Special query information record
    @discussion Specifically to return query information inline such as skipped nodes
 */
CF_EXPORT
const ODRecordType kODRecordTypeQueryInformation;

/*!
    @const		kODRecordTypeRecordTypes
    @abstract   Identifies records that represent each possible record type.
    @discussion Identifies records that represent each possible record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeRecordTypes;

/*!
    @const		kODRecordTypeResources
    @abstract   Identifies resources used in group services.
    @discussion Identifies resources used in group services.
*/
CF_EXPORT
const ODRecordType kODRecordTypeResources;

/*!
    @const		kODRecordTypeRPC
    @abstract   Identifies remote procedure call records.
    @discussion Identifies remote procedure call records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeRPC;

/*!
    @const		kODRecordTypeSMBServer
    @abstract   Identifies SMB server records.
    @discussion Identifies SMB server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeSMBServer;

/*!
    @const		kODRecordTypeServer
    @abstract   Identifies generic server records.
    @discussion Identifies generic server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeServer;

/*!
    @const		kODRecordTypeServices
    @abstract   Identifies directory based service records.
    @discussion Identifies directory based service records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeServices;

/*!
    @const		kODRecordTypeSharePoints
    @abstract   Share point record type.
    @discussion Share point record type.
*/
CF_EXPORT
const ODRecordType kODRecordTypeSharePoints;

/*!
    @const		kODRecordTypeUsers
    @abstract   Identifies user records.
    @discussion Identifies user records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeUsers;

/*!
    @const		kODRecordTypeWebServer
    @abstract   Identifies web server records.
    @discussion Identifies web server records.
*/
CF_EXPORT
const ODRecordType kODRecordTypeWebServer;

#pragma mark Attribute Types

/*!
    @const		kODAttributeTypeAllAttributes
    @abstract   Used in requesting all attribute types in a search.
    @discussion Used in requesting all attribute types in a search.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAllAttributes;

/*!
    @const		kODAttributeTypeStandardOnly
    @abstract   Used in requesting all standard attribute types in a query.
    @discussion Used in requesting all standard attribute types in a query.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeStandardOnly;

/*!
    @const		kODAttributeTypeNativeOnly
    @abstract   Used in requesting all native attribute types in a search.
    @discussion Used in requesting all native attribute types in a search.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNativeOnly;

/*!
    @const		kODAttributeTypeMetaAmbiguousName
    @abstract   Used to disambiguate a provided name.
    @discussion Searches a configured list of attributes; by default: RecordName, FullName, EMailAddress.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAmbiguousName;

/*!
    @const		kODAttributeTypeMetaAugmentedAttributes
    @abstract   Attributes that have been augmented.
    @discussion Attributes that have been augmented.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAugmentedAttributes;

/*!
    @const		kODAttributeTypeMetaRecordName
    @abstract   Native record name.
    @discussion Native record name, e.g. LDAP DN
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaRecordName;

/*!
    @const		kODAttributeTypeAdminLimits
    @abstract   XML plist indicating what an admin user can edit.
    @discussion XML plist indicating what an admin user can edit. Found in kODRecordTypeUsers records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAdminLimits;

/*!
	@const		kODAttributeTypeAltSecurityIdentities
	@abstract	Used to store alternate identities for the record
	@discussion Used to store alternate identities for the record. Values will have standardized form as
				specified by Microsoft LDAP schema (1.2.840.113556.1.4.867).

 				Kerberos:user\@REALM
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeAltSecurityIdentities __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeAuthenticationHint
    @abstract   Used to identify the authentication hint phrase.
    @discussion Used to identify the authentication hint phrase.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthenticationHint;

/*!
    @const		kODAttributeTypeAllTypes
    @abstract   Used to indicated recommended attribute types for a record type in the Config node.
    @discussion Used to indicated recommended attribute types for a record type in the Config node.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAllTypes;

/*!
    @const		kODAttributeTypeAuthorityRevocationList
    @abstract   Attribute containing the binary of the authority revocation list
	@discussion Attribute containing the binary of the authority revocation list.
				A certificate revocation list that defines certificate authority certificates
				which are no longer trusted.  No user certificates are included in this list.
				Usually found in kODRecordTypeCertificateAuthorities records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthorityRevocationList;

/*!
    @const		kODAttributeTypeBirthday
    @abstract   Single-valued attribute that defines the user's birthday.
	@discussion Single-valued attribute that defines the user's birthday.
				Format is x.208 standard YYYYMMDDHHMMSSZ which we will require as GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBirthday;

/*!
    @const		kODAttributeTypeCACertificate
	@abstract   Attribute containing the binary of the certificate of a certificate authority.
	@discussion Attribute containing the binary of the certificate of a certificate authority.
				Its corresponding private key is used to sign certificates.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCACertificate;

/*!
    @const		kODAttributeTypeCapacity
    @abstract   Attribute type for the capacity of a resource. 
	@discussion Attribute type for the capacity of a resource. 
				found in resource records (kODRecordTypeResources). 
					Example: 50
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCapacity;

/*!
    @const		kODAttributeTypeCertificateRevocationList
    @abstract   Attribute containing the binary of the certificate revocation list.
	@discussion Attribute containing the binary of the certificate revocation list.
				This is a list of certificates which are no longer trusted.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCertificateRevocationList;

/*!
    @const		kODAttributeTypeComment
    @abstract   Attribute used for unformatted comment.
    @discussion Attribute used for unformatted comment.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeComment;

/*!
    @const		kODAttributeTypeContactGUID
	@abstract   Attribute type for the contact GUID of a group. 
	@discussion Attribute type for the contact GUID of a group. 
				Usually found in group records (kODRecordTypeGroups)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeContactGUID;

/*!
    @const		kODAttributeTypeContactPerson
	@abstract   Attribute type for the contact person of the machine. 
	@discussion Attribute type for the contact person of the machine. 
				Found in host or machine records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeContactPerson;

/*!
    @const		kODAttributeTypeCreationTimestamp
	@abstract   Attribute showing date/time of record creation.
	@discussion Attribute showing date/time of record creation.
				Format is x.208 standard YYYYMMDDHHMMSSZ which should be GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCreationTimestamp;

/*!
    @const		kODAttributeTypeCrossCertificatePair
	@abstract   Attribute containing the binary of a pair of certificates which 
				verify each other.
	@discussion Attribute containing the binary of a pair of certificates which 
				verify each other.  Both certificates have the same level of authority.
				Usually found in kODRecordTypeCertificateAuthority records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCrossCertificatePair;

/*!
    @const		kODAttributeTypeDataStamp
    @abstract   Attribute for checksum/meta data
    @discussion Attribute for checksum/meta data
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDataStamp;

/*!
    @const		kODAttributeTypeFullName
    @abstract   Full name of a record
    @discussion Full name of a record (e.g., "John Doe", "John Doe's Computer")
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFullName;

/*!
    @const		kODAttributeTypeDNSDomain
    @abstract   DNS Resolver domain attribute.
    @discussion DNS Resolver domain attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSDomain;

/*!
    @const		kODAttributeTypeDNSNameServer
    @abstract   DNS Resolver nameserver attribute.
    @discussion DNS Resolver nameserver attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSNameServer;

/*!
    @const		kODAttributeTypeENetAddress
	@abstract   Attribute for hardware Ethernet address (MAC address).
	@discussion Attribute for hardware Ethernet address (MAC address).
				Found in computer records (kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeENetAddress;

/*!
    @const		kODAttributeTypeExpire
    @abstract   Used for expiration date or time depending on association.
    @discussion Used for expiration date or time depending on association.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeExpire;

/*!
    @const		kODAttributeTypeFirstName
    @abstract   Used for first name of user or person record.
    @discussion Used for first name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFirstName;

/*!
    @const		kODAttributeTypeGUID
	@abstract   Used for 36 character (128 bit) unique ID.
	@discussion Used for 36 character (128 bit) unique ID. An example value is
				"A579E95E-CDFE-4EBC-B7E7-F2158562170F". The standard format contains
				32 uppercase hex characters and four hyphen characters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGUID;

/*!
    @const      kODAttributeTypeHardwareUUID
    @abstract   Used to store hardware UUID in string form
    @discussion Used to store hardware UUID in string form for a record.  Typically found in
                kODRecordTypeComputers.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHardwareUUID __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeHomeDirectoryQuota
	@abstract   Represents the allowed usage for a user's home directory in bytes.
	@discussion Represents the allowed usage for a user's home directory in bytes.
				Found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectoryQuota;

/*!
    @const		kODAttributeTypeHomeDirectorySoftQuota
	@abstract   Used to define home directory size limit in bytes when user is notified
				that the hard limit is approaching.
	@discussion Used to define home directory size limit in bytes when user is notified
				that the hard limit is approaching.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectorySoftQuota;

/*!
    @const		kODAttributeTypeHomeLocOwner
	@abstract   Represents the owner of a workgroup's shared home directory.
	@discussion Represents the owner of a workgroup's shared home directory.
				Typically found in kODRecordTypeGroups records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeLocOwner;

/*!
    @const		kODAttributeTypeInternetAlias
    @abstract   Used to track internet alias.
    @discussion Used to track internet alias.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeInternetAlias;

/*!
    @const		kODAttributeTypeKDCConfigData
    @abstract   Contents of the kdc.conf file.
    @discussion Contents of the kdc.conf file.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKDCConfigData;

/*!
	@const		kODAttributeTypeKerberosServices
	@abstract	This is used to store the principals in host records (i.e., "host", "vnc", etc.)
	@discussion	This is used to store the principals in host records (i.e., "host", "vnc", etc.)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeKerberosServices __OSX_AVAILABLE_STARTING(__MAC_10_7, __IPHONE_NA);

/*!
    @const		kODAttributeTypeLastName
    @abstract   Used for the last name of user or person record.
    @discussion Used for the last name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLastName;

/*!
    @const		kODAttributeTypeLDAPSearchBaseSuffix
    @abstract   Search base suffix for a LDAP server.
    @discussion Search base suffix for a LDAP server.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLDAPSearchBaseSuffix;

/*!
    @const		kODAttributeTypeLocation
	@abstract   Represents the location a service is available from (usually domain name)
	@discussion Represents the location a service is available from (usually domain name).
				Typically found in service record types including kODRecordTypeAFPServer,
				kODRecordTypeLDAPServer, and kODRecordTypeWebServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeLocation;

/*!
    @const		kODAttributeTypeMapGUID
    @abstract   Represents the GUID for a record's map
    @discussion Represents the GUID for a record's map.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMapGUID;

/*!
    @const		kODAttributeTypeMCXFlags
    @abstract   Used by ManagedClient
    @discussion Used by ManagedClient.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMCXFlags;

/*!
    @const		kODAttributeTypeMCXSettings
    @abstract   Used by ManagedClient
    @discussion Used by ManagedClient.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMCXSettings;

/*!
    @const		kODAttributeTypeMailAttribute
    @abstract   Holds the mail account config data
    @discussion Holds the mail account config data.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMailAttribute;

/*!
    @const		kODAttributeTypeMetaAutomountMap
	@abstract   Used to query for kODRecordTypeAutomount entries
	@discussion Used to query for kODRecordTypeAutomount entries associated with a specific 
				kODRecordTypeAutomountMap.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMetaAutomountMap;

/*!
    @const		kODAttributeTypeMiddleName
    @abstract   Used for the middle name of user or person record.
    @discussion Used for the middle name of user or person record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeMiddleName;

/*!
    @const		kODAttributeTypeModificationTimestamp
	@abstract   Attribute showing date/time of record modification.
	@discussion Attribute showing date/time of record modification.
				Format is x.208 standard YYYYMMDDHHMMSSZ which is required as GMT time.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeModificationTimestamp;

/*!
    @const		kODAttributeTypeNFSHomeDirectory
    @abstract   Defines a user's home directory mount point on the local machine.
    @discussion Defines a user's home directory mount point on the local machine.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNFSHomeDirectory;

/*!
    @const		kODAttributeTypeNote
    @abstract   Note attribute.
    @discussion Note attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNote;

/*!
    @const		kODAttributeTypeOperatingSystem
    @abstract   Returns the operating system type where the daemon is running
    @discussion Returns the operating system type where the daemon is running,
				e.g., Mac OS X or Mac OS X Server
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOperatingSystem __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
	@const		kODAttributeTypeOperatingSystemVersion
	@abstract   Returns the operating system version where the daemon is running
	@discussion Returns the operating system version where the daemon is running,
				e.g., 10.6
 */
CF_EXPORT
const ODAttributeType kODAttributeTypeOperatingSystemVersion __OSX_AVAILABLE_STARTING(__MAC_10_6, __IPHONE_NA);

/*!
    @const		kODAttributeTypeOwner
	@abstract   Attribute type for the owner of a record. 
	@discussion Attribute type for the owner of a record. 
				Typically the value is a LDAP distinguished name.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOwner;

/*!
    @const		kODAttributeTypeOwnerGUID
	@abstract   Attribute type for the owner GUID of a group. 
	@discussion Attribute type for the owner GUID of a group. 
				Found in group records (kODRecordTypeGroups). 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeOwnerGUID;

/*!
    @const		kODAttributeTypePassword
    @abstract   Holds the password or credential value.
    @discussion Holds the password or credential value.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePassword;

/*!
    @const		kODAttributeTypePasswordPlus
    @abstract   Holds marker data to indicate possible authentication redirection.
    @discussion Holds marker data to indicate possible authentication redirection.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordPlus;

/*!
    @const		kODAttributeTypePasswordPolicyOptions
	@abstract   Collection of password policy options in single attribute.
	@discussion Collection of password policy options in single attribute.
				Used in user presets record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordPolicyOptions;

/*!
    @const		kODAttributeTypePasswordServerList
    @abstract   Represents the attribute for storing the password server's replication information.
    @discussion Represents the attribute for storing the password server's replication information.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordServerList;

/*!
    @const		kODAttributeTypePasswordServerLocation
	@abstract   Specifies the IP address or domain name of the Password Server associated
				with a given directory node.
	@discussion Specifies the IP address or domain name of the Password Server associated
				with a given directory node. Found in a config record named PasswordServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePasswordServerLocation;

/*!
    @const		kODAttributeTypePicture
	@abstract   Represents the path of the picture for each user displayed in the login window.
	@discussion Represents the path of the picture for each user displayed in the login window.
				Found in user records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePicture;

/*!
    @const		kODAttributeTypePort
	@abstract   Represents the port number a service is available on.
	@discussion Represents the port number a service is available on.
				Typically found in service record types including kODRecordTypeAFPServer,
				kODRecordTypeLDAPServer, and kODRecordTypeWebServer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePort;

/*!
    @const		kODAttributeTypePresetUserIsAdmin
	@abstract   Flag to indicate whether users created from this preset are administrators
				by default.
	@discussion Flag to indicate whether users created from this preset are administrators
				by default. Found in kODRecordTypePresetUsers records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePresetUserIsAdmin;

/*!
    @const		kODAttributeTypePrimaryComputerGUID
	@abstract   An attribute that defines a primary computer of the computer group.  
	@discussion An attribute that defines a primary computer of the computer group.  
				Added to computer group record type (kODRecordTypeComputerGroups)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryComputerGUID;

/*!
    @const		kODAttributeTypePrimaryComputerList
    @abstract   The GUID of the computer list with which this computer record is associated.
    @discussion The GUID of the computer list with which this computer record is associated.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryComputerList;

/*!
    @const		kODAttributeTypePrimaryGroupID
	@abstract   This is the 32 bit unique ID that represents the primary group 
				a user is part of, or the ID of a group.
	@discussion This is the 32 bit unique ID that represents the primary group 
				a user is part of, or the ID of a group. Format is a signed 32 bit integer
				represented as a string.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrimaryGroupID;

/*!
    @const		kODAttributeTypePrinter1284DeviceID
	@abstract   Attribute that defines the IEEE 1284 DeviceID of a printer.
	@discussion Attribute that defines the IEEE 1284 DeviceID of a printer.
				This is used when configuring a printer.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinter1284DeviceID;

/*!
    @const		kODAttributeTypePrinterLPRHost
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterLPRHost;

/*!
    @const		kODAttributeTypePrinterLPRQueue
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterLPRQueue;

/*!
    @const		kODAttributeTypePrinterMakeAndModel
	@abstract   Attribute for definition of the Printer Make and Model.
	@discussion Attribute for definition of the Printer Make and Model.  An example
				value would be "HP LaserJet 2200".  This would be used to determine the proper PPD
				file to be used when configuring a printer from the Directory.  This attribute
				is based on the IPP Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterMakeAndModel;

/*!
    @const		kODAttributeTypePrinterType
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterType;

/*!
    @const		kODAttributeTypePrinterURI
	@abstract   Attribute that defines the URI of a printer "ipp://address" or
				"smb://server/queue".
	@discussion Attribute that defines the URI of a printer "ipp://address" or
				"smb://server/queue".  This is used when configuring a printer. This attribute
				is based on the IPP Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterURI;

/*!
    @const		kODAttributeTypePrinterXRISupported
	@abstract   Attribute that defines additional URIs supported by a printer.
	@discussion attribute that defines additional URIs supported by a printer.
				This is used when configuring a printer. This attribute is based on the IPP 
				Printing Specification RFC and IETF IPP-LDAP Printer Record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrinterXRISupported;

/*!
    @const		kODAttributeTypePrintServiceInfoText
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceInfoText;

/*!
    @const		kODAttributeTypePrintServiceInfoXML
    @abstract   Standard attribute type for kODRecordTypePrinters.
    @discussion Standard attribute type for kODRecordTypePrinters.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceInfoXML;

/*!
    @const		kODAttributeTypePrintServiceUserData
	@abstract   Attribute for print quota configuration or statistics (XML data).
	@discussion Attribute for print quota configuration or statistics (XML data).
				Found in user records (kODRecordTypeUsers) or print service
				statistics records (kODRecordTypePrintServiceUser).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypePrintServiceUserData;

/*!
    @const		kODAttributeTypeRealUserID
    @abstract   Used by Managed Client.
    @discussion Used by Managed Client
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRealUserID;

/*!
    @const		kODAttributeTypeRelativeDNPrefix
	@abstract   Used to map the first native LDAP attribute type required in the building of the
				Relative Distinguished Name for LDAP record creation.
	@discussion Used to map the first native LDAP attribute type required in the building of the
				Relative Distinguished Name for LDAP record creation.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRelativeDNPrefix;

/*!
    @const		kODAttributeTypeSMBAcctFlags
    @abstract   Account control flag.
    @discussion Account control flag.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBAcctFlags;

/*!
    @const		kODAttributeTypeSMBGroupRID
    @abstract   Constant for supporting PDC SMB interaction with DirectoryService.
    @discussion Constant for supporting PDC SMB interaction with DirectoryService.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBGroupRID;

/*!
    @const		kODAttributeTypeSMBHome
    @abstract   UNC address of Windows homedirectory mount point (\\server\\sharepoint).
    @discussion UNC address of Windows homedirectory mount point (\\server\\sharepoint).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBHome;

/*!
    @const		kODAttributeTypeSMBHomeDrive
    @abstract   Drive letter for homedirectory mount point.
    @discussion Drive letter for homedirectory mount point.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBHomeDrive;

/*!
    @const		kODAttributeTypeSMBKickoffTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBKickoffTime;

/*!
    @const		kODAttributeTypeSMBLogoffTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBLogoffTime;

/*!
    @const		kODAttributeTypeSMBLogonTime
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBLogonTime;

/*!
    @const		kODAttributeTypeSMBPrimaryGroupSID
	@abstract   SMB Primary Group Security ID, stored as a string attribute of
				up to 64 bytes.
	@discussion SMB Primary Group Security ID, stored as a string attribute of
				up to 64 bytes. Found in user, group, and computer records
				(kODRecordTypeUsers, kODRecordTypeGroups, kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBPrimaryGroupSID;

/*!
    @const		kODAttributeTypeSMBPWDLastSet
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBPWDLastSet;

/*!
    @const		kODAttributeTypeSMBProfilePath
    @abstract   Desktop management info (dock, desktop links, etc).
    @discussion Desktop management info (dock, desktop links, etc).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBProfilePath;

/*!
    @const		kODAttributeTypeSMBRID
    @abstract   Attribute in support of SMB interaction.
    @discussion Attribute in support of SMB interaction.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBRID;

/*!
    @const		kODAttributeTypeSMBScriptPath
    @abstract   Login script path.
    @discussion Login script path.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBScriptPath;

/*!
    @const		kODAttributeTypeSMBSID
	@abstract   SMB Security ID, stored as a string attribute of up to 64 bytes.
	@discussion SMB Security ID, stored as a string attribute of up to 64 bytes.
				Found in user, group, and computer records (kODRecordTypeUsers, 
				kODRecordTypeGroups, kODRecordTypeComputers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBSID;

/*!
    @const		kODAttributeTypeSMBUserWorkstations
    @abstract   List of workstations user can login from (machine account names).
    @discussion List of workstations user can login from (machine account names).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSMBUserWorkstations;

/*!
    @const		kODAttributeTypeServiceType
	@abstract   Represents the service type for the service.  This is the raw service type of the
				service.
	@discussion Represents the service type for the service.  This is the raw service type of the
				service.  For example a service record type of kODRecordTypeWebServer 
				might have a service type of "http" or "https".
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeServiceType;

/*!
    @const		kODAttributeTypeSetupAdvertising
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupAdvertising;

/*!
    @const		kODAttributeTypeSetupAutoRegister
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupAutoRegister;

/*!
    @const		kODAttributeTypeSetupLocation
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupLocation;

/*!
    @const		kODAttributeTypeSetupOccupation
    @abstract   Used for Setup Assistant automatic population.
    @discussion Used for Setup Assistant automatic population.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeSetupOccupation;

/*!
    @const		kODAttributeTypeTimeToLive
	@abstract   Attribute recommending how long to cache the record's attribute values.
	@discussion Attribute recommending how long to cache the record's attribute values.
				Format is an unsigned 32 bit representing seconds. ie. 300 is 5 minutes.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTimeToLive;

/*!
	@const		kODAttributeTypeTrustInformation
	@abstract	Used to describe a node's trust information.
	@discussion	Used to describe a node's trust information.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeTrustInformation;

/*!
    @const		kODAttributeTypeUniqueID
	@abstract   This is the 32 bit unique ID that represents the user in the legacy manner.
	@discussion This is the 32 bit unique ID that represents the user in the legacy manner.
				Format is a signed integer represented as a string.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUniqueID;

/*!
    @const		kODAttributeTypeUserCertificate
	@abstract   Attribute containing the binary of the user's certificate.
	@discussion Attribute containing the binary of the user's certificate.
				Usually found in user records. The certificate is data which identifies a user.
				This data is attested to by a known party, and can be independently verified 
				by a third party.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserCertificate;

/*!
    @const		kODAttributeTypeUserPKCS12Data
	@abstract   Attribute containing binary data in PKCS #12 format. 
	@discussion Attribute containing binary data in PKCS #12 format. 
				Usually found in user records. The value can contain keys, certificates,
				and other related information and is encrypted with a passphrase.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserPKCS12Data;

/*!
    @const		kODAttributeTypeUserShell
    @abstract   Used to represent the user's shell setting.
    @discussion Used to represent the user's shell setting.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserShell;

/*!
    @const		kODAttributeTypeUserSMIMECertificate
	@abstract   Attribute containing the binary of the user's SMIME certificate.
	@discussion Attribute containing the binary of the user's SMIME certificate.
				Usually found in user records. The certificate is data which identifies a user.
				This data is attested to by a known party, and can be independently verified 
				by a third party. SMIME certificates are often used for signed or encrypted
				emails.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeUserSMIMECertificate;

/*!
    @const		kODAttributeTypeVFSDumpFreq
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSDumpFreq;

/*!
    @const		kODAttributeTypeVFSLinkDir
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSLinkDir;

/*!
    @const		kODAttributeTypeVFSPassNo
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSPassNo;

/*!
    @const		kODAttributeTypeVFSType
    @abstract   Attribute used to support mount records.
    @discussion Attribute used to support mount records.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeVFSType;

/*!
    @const		kODAttributeTypeWeblogURI
	@abstract   attribute that defines the URI of a user's weblog.
	@discussion attribute that defines the URI of a user's weblog.
				Usually found in user records (kODRecordTypeUsers). 
				Example: http://example.com/blog/jsmith
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeWeblogURI;

/*!
    @const		kODAttributeTypeXMLPlist
    @abstract   XML plist used.
    @discussion XML plist used.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeXMLPlist;

/*!
    @const		kODAttributeTypeProtocolNumber
	@abstract   Attribute that defines a protocol number.
	@discussion Attribute that defines a protocol number.  Usually found
				in protocol records (kODRecordTypeProtocols)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeProtocolNumber;

/*!
    @const		kODAttributeTypeRPCNumber
	@abstract   Attribute that defines an RPC number.
	@discussion Attribute that defines an RPC number.  Usually found
				in RPC records (kODRecordTypeRPC)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeRPCNumber;

/*!
    @const		kODAttributeTypeNetworkNumber
	@abstract   Attribute that defines a network number.
	@discussion Attribute that defines a network number.  Usually found
				in network records (kODRecordTypeNetworks)
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeNetworkNumber;

/*!
    @const		kODAttributeTypeAccessControlEntry
    @abstract   Attribute type which stores directory access control directives.
    @discussion Attribute type which stores directory access control directives.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAccessControlEntry;

/*!
    @const		kODAttributeTypeAddressLine1
    @abstract   Line one of multiple lines of address data for a user.
    @discussion Line one of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine1;

/*!
    @const		kODAttributeTypeAddressLine2
    @abstract   Line two of multiple lines of address data for a user.
    @discussion Line two of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine2;

/*!
    @const		kODAttributeTypeAddressLine3
    @abstract   Line three of multiple lines of address data for a user.
    @discussion Line three of multiple lines of address data for a user.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAddressLine3;

/*!
    @const		kODAttributeTypeAreaCode
    @abstract   Area code of a user's phone number.
    @discussion Area code of a user's phone number.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAreaCode;

/*!
    @const		kODAttributeTypeAuthenticationAuthority
	@abstract   Determines what mechanism is used to verify or set a user's password.
	@discussion Determines what mechanism is used to verify or set a user's password.
				If multiple values are present, the first attributes returned take precedence.
				Typically found in User records (kODRecordTypeUsers).
 
				Authentication authorities are a multi-part string separated by semi-colons.
				One component is the "type" of authority, such as those listed below:
 
					"basic"					- is a crypt password
					"ShadowHash"			- is a hashed password stored in a secure location
					"ApplePasswordServer"	- is a password server-based account
					"Kerberosv5"			- is a Kerberosv5 based
					"LocalCachedUser"		- is a cached account based on an account from another node, using a ShadowHash password
					"DisabledUser"			- is an account that has been disabled
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAuthenticationAuthority;

/*!
    @const		kODAttributeTypeAutomountInformation
	@abstract   Determines what mechanism is used to verify or set a user's password.
	@discussion Determines what mechanism is used to verify or set a user's password.
				If multiple values are present, the first attributes returned take precedence.
				Typically found in User records (kODRecordTypeUsers).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeAutomountInformation;

/*!
    @const		kODAttributeTypeBootParams
    @abstract   Attribute type in host or machine records for storing boot params.
    @discussion Attribute type in host or machine records for storing boot params.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBootParams;

/*!
    @const		kODAttributeTypeBuilding
	@abstract   Represents the building name for a user or person record.
	@discussion Represents the building name for a user or person record.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeBuilding;

/*!
    @const		kODAttributeTypeServicesLocator
    @abstract   the URI for a record's calendar
    @discussion the URI for a record's calendar
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeServicesLocator;

/*!
    @const		kODAttributeTypeCity
	@abstract   Usually, city for a user or person record.
	@discussion Usually, city for a user or person record.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCity;

/*!
    @const		kODAttributeTypeCompany
	@abstract   attribute that defines the user's company.
	@discussion attribute that defines the user's company.
				Example: Apple Inc.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCompany;

/*!
    @const		kODAttributeTypeComputers
    @abstract   List of computers.
    @discussion List of computers.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeComputers;

/*!
    @const		kODAttributeTypeCountry
	@abstract   Represents country of a record entry.
	@discussion Represents country of a record entry.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeCountry;

/*!
    @const		kODAttributeTypeDepartment
	@abstract   Represents the department name of a user or person.
	@discussion Represents the department name of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDepartment;

/*!
    @const		kODAttributeTypeDNSName
    @abstract   DNS Resolver nameserver attribute.
    @discussion DNS Resolver nameserver attribute.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeDNSName;

/*!
    @const		kODAttributeTypeEMailAddress
    @abstract   Email address of usually a user record.
    @discussion Email address of usually a user record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeEMailAddress;

/*!
    @const		kODAttributeTypeEMailContacts
	@abstract   Attribute that defines a record's custom email addresses.
	@discussion Attribute that defines a record's custom email addresses.
				found in user records (kODRecordTypeUsers). 
				Example: home:johndoe\@mymail.com
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeEMailContacts;

/*!
    @const		kODAttributeTypeFaxNumber
	@abstract   Represents the FAX numbers of a user or person.
	@discussion Represents the FAX numbers of a user or person.
				Usually found in user or people records (kODRecordTypeUsers or 
				kODRecordTypePeople).
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeFaxNumber;

/*!
    @const		kODAttributeTypeGroup
    @abstract   List of groups.
    @discussion List of groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroup;

/*!
    @const		kODAttributeTypeGroupMembers
    @abstract   Attribute type in group records containing lists of GUID values for members other than groups.
    @discussion Attribute type in group records containing lists of GUID values for members other than groups.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupMembers;

/*!
    @const		kODAttributeTypeGroupMembership
    @abstract   Usually a list of users that below to a given group record.
    @discussion Usually a list of users that below to a given group record.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupMembership;

/*!
    @const		kODAttributeTypeGroupServices
	@abstract   xml-plist attribute that defines a group's services.
	@discussion xml-plist attribute that defines a group's services.
				Found in group records (kODRecordTypeGroups). 
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeGroupServices;

/*!
    @const		kODAttributeTypeHomePhoneNumber
    @abstract   Home telephone number of a user or person.
    @discussion Home telephone number of a user or person.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomePhoneNumber;

/*!
    @const		kODAttributeTypeHTML
    @abstract   HTML location.
    @discussion HTML location.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHTML;

/*!
    @const		kODAttributeTypeHomeDirectory
    @abstract   Network home directory URL.
    @discussion Network home directory URL.
*/
CF_EXPORT
const ODAttributeType kODAttributeTypeHomeDirectory;

/*!
    @const		kODAttributeTypeIMHandle
	@abstract   Represents the Instant Messaging handles of a user.
	@discussion Represents the Instant Messaging handles of a user.
				Values should be prefixed with the appropriate IM type
				(i.e., AIM: